record_number,buggy_code,fixed_code
90001,"/** 
 * Put the file provided by Genie.
 * @param srcLocalPath  The local path of the file which has to be transfered to remote location
 * @param dstRemotePath The remote destination path where the file has to be put
 * @throws GenieException If there is any problem
 */
public void putFile(@NotBlank(message=""String_Node_Str"") final String srcLocalPath,@NotBlank(message=""String_Node_Str"") final String dstRemotePath) throws GenieException {
  log.debug(""String_Node_Str"",srcLocalPath,dstRemotePath);
  getFileTransfer(dstRemotePath).putFile(srcLocalPath,dstRemotePath);
}","/** 
 * Put the file provided by Genie.
 * @param srcLocalPath  The local path of the file which has to be transfered to remote location
 * @param dstRemotePath The remote destination path where the file has to be put
 * @throws GenieException If there is any problem
 */
public void putFile(@NotBlank(message=""String_Node_Str"") final String srcLocalPath,@NotBlank(message=""String_Node_Str"") final String dstRemotePath) throws GenieException {
  log.debug(""String_Node_Str"",srcLocalPath,dstRemotePath);
  this.getFileTransfer(dstRemotePath).putFile(srcLocalPath,dstRemotePath);
}"
90002,"/** 
 * {@inheritDoc}
 */
@Override public long getLastModifiedTime(final String path) throws GenieException {
  try {
    return new File(path).lastModified();
  }
 catch (  Exception e) {
    final String message=String.format(""String_Node_Str"",path);
    log.error(message);
    throw new GenieServerException(message,e);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public long getLastModifiedTime(final String path) throws GenieException {
  try {
    return new File(path).lastModified();
  }
 catch (  Exception e) {
    final String message=String.format(""String_Node_Str"",path);
    log.error(message,e);
    throw new GenieServerException(message,e);
  }
}"
90003,"/** 
 * {@inheritDoc}
 */
@Override public void getFile(@NotBlank(message=""String_Node_Str"") final String srcRemotePath,@NotBlank(message=""String_Node_Str"") final String dstLocalPath) throws GenieException {
  log.debug(""String_Node_Str"",srcRemotePath,dstLocalPath);
  try {
    final File src=new File(srcRemotePath);
    final File dest=new File(dstLocalPath);
    Files.copy(src.toPath(),dest.toPath(),StandardCopyOption.REPLACE_EXISTING);
  }
 catch (  IOException ioe) {
    log.error(""String_Node_Str"",srcRemotePath,dstLocalPath);
    throw new GenieServerException(""String_Node_Str"" + srcRemotePath + ""String_Node_Str""+ dstLocalPath,ioe);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void getFile(@NotBlank(message=""String_Node_Str"") final String srcRemotePath,@NotBlank(message=""String_Node_Str"") final String dstLocalPath) throws GenieException {
  log.debug(""String_Node_Str"",srcRemotePath,dstLocalPath);
  this.copy(srcRemotePath,dstLocalPath);
}"
90004,"/** 
 * {@inheritDoc}
 */
@Override public void putFile(@NotBlank(message=""String_Node_Str"") final String srcLocalPath,@NotBlank(message=""String_Node_Str"") final String dstRemotePath) throws GenieException {
  log.debug(""String_Node_Str"",srcLocalPath,dstRemotePath);
  try {
    final File src=new File(srcLocalPath);
    final File dest=new File(dstRemotePath);
    Files.copy(src.toPath(),dest.toPath(),StandardCopyOption.REPLACE_EXISTING);
  }
 catch (  IOException ioe) {
    log.error(""String_Node_Str"",srcLocalPath,dstRemotePath);
    throw new GenieServerException(""String_Node_Str"" + srcLocalPath + ""String_Node_Str""+ dstRemotePath,ioe);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void putFile(@NotBlank(message=""String_Node_Str"") final String srcLocalPath,@NotBlank(message=""String_Node_Str"") final String dstRemotePath) throws GenieException {
  log.debug(""String_Node_Str"",srcLocalPath,dstRemotePath);
  this.copy(srcLocalPath,dstRemotePath);
}"
90005,"/** 
 * {@inheritDoc}
 */
@Override public String coordinateJob(@Valid @NotNull(message=""String_Node_Str"") final JobRequest jobRequest,@Valid @NotNull(message=""String_Node_Str"") final JobMetadata jobMetadata) throws GenieException {
  final long coordinationStart=System.nanoTime();
  final String jobId=jobRequest.getId().orElseThrow(() -> new GenieServerException(""String_Node_Str""));
  JobStatus jobStatus=JobStatus.FAILED;
  try {
    log.info(""String_Node_Str"",jobId);
    final Job.Builder jobBuilder=new Job.Builder(jobRequest.getName(),jobRequest.getUser(),jobRequest.getVersion(),jobRequest.getCommandArgs()).withId(jobId).withTags(jobRequest.getTags()).withStatus(JobStatus.INIT).withStatusMsg(""String_Node_Str"");
    jobRequest.getDescription().ifPresent(jobBuilder::withDescription);
    if (!jobRequest.isDisableLogArchival()) {
      jobBuilder.withArchiveLocation(this.jobsProperties.getLocations().getArchives() + JobConstants.FILE_PATH_DELIMITER + jobId+ ""String_Node_Str"");
    }
    final JobExecution jobExecution=new JobExecution.Builder(this.hostName).withId(jobId).build();
    this.jobPersistenceService.createJob(jobRequest,jobMetadata,jobBuilder.build(),jobExecution);
    jobStateService.init(jobId);
    final Cluster cluster=this.getCluster(jobRequest);
    final Command command=this.getCommand(jobRequest,cluster);
    final List<Application> applications=this.getApplications(jobRequest,command);
    final int memory=jobRequest.getMemory().orElse(command.getMemory().orElse(this.jobsProperties.getMemory().getDefaultJobMemory()));
    this.setRuntimeEnvironment(jobId,cluster,command,applications,memory);
    final int maxJobMemory=this.jobsProperties.getMemory().getMaxJobMemory();
    if (memory > maxJobMemory) {
      jobStatus=JobStatus.INVALID;
      throw new GeniePreconditionException(""String_Node_Str"" + memory + ""String_Node_Str""+ maxJobMemory+ ""String_Node_Str"");
    }
    log.info(""String_Node_Str"",jobRequest.getId(),jobRequest.getUser());
    final JobsUsersActiveLimitProperties activeLimit=this.jobsProperties.getUsers().getActiveLimit();
    if (activeLimit.isEnabled()) {
      final long activeJobsLimit=activeLimit.getCount();
      final long activeJobsCount=this.jobSearchService.getActiveJobCountForUser(jobRequest.getUser());
      if (activeJobsCount >= activeJobsLimit) {
        throw GenieUserLimitExceededException.createForActiveJobsLimit(jobRequest.getUser(),activeJobsCount,activeJobsLimit);
      }
    }
synchronized (this) {
      log.info(""String_Node_Str"",jobRequest.getId());
      final int maxSystemMemory=this.jobsProperties.getMemory().getMaxSystemMemory();
      final int usedMemory=this.jobStateService.getUsedMemory();
      if (usedMemory + memory <= maxSystemMemory) {
        log.info(""String_Node_Str"",jobId,usedMemory,maxSystemMemory,memory);
        log.info(""String_Node_Str"",jobId);
        jobStateService.schedule(jobId,jobRequest,cluster,command,applications,memory);
        return jobId;
      }
 else {
        throw new GenieServerUnavailableException(""String_Node_Str"" + jobId + ""String_Node_Str""+ usedMemory+ ""String_Node_Str""+ maxSystemMemory+ ""String_Node_Str""+ memory+ ""String_Node_Str"");
      }
    }
  }
 catch (  GenieConflictException e) {
    throw e;
  }
catch (  GenieException e) {
    if (jobStateService.jobExists(jobId)) {
      jobStateService.done(jobId);
      jobPersistenceService.updateJobStatus(jobId,jobStatus,e.getMessage());
    }
    throw e;
  }
catch (  Exception e) {
    if (jobStateService.jobExists(jobId)) {
      jobStateService.done(jobId);
      jobPersistenceService.updateJobStatus(jobId,jobStatus,e.getMessage());
    }
    throw new GenieServerException(e);
  }
 finally {
    this.coordinationTimer.record(System.nanoTime() - coordinationStart,TimeUnit.MILLISECONDS);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public String coordinateJob(@Valid @NotNull(message=""String_Node_Str"") final JobRequest jobRequest,@Valid @NotNull(message=""String_Node_Str"") final JobMetadata jobMetadata) throws GenieException {
  final long coordinationStart=System.nanoTime();
  final String jobId=jobRequest.getId().orElseThrow(() -> new GenieServerException(""String_Node_Str""));
  JobStatus jobStatus=JobStatus.FAILED;
  try {
    log.info(""String_Node_Str"",jobId);
    final Job.Builder jobBuilder=new Job.Builder(jobRequest.getName(),jobRequest.getUser(),jobRequest.getVersion(),jobRequest.getCommandArgs()).withId(jobId).withTags(jobRequest.getTags()).withStatus(JobStatus.INIT).withStatusMsg(""String_Node_Str"");
    jobRequest.getDescription().ifPresent(jobBuilder::withDescription);
    if (!jobRequest.isDisableLogArchival()) {
      jobBuilder.withArchiveLocation(this.jobsProperties.getLocations().getArchives() + JobConstants.FILE_PATH_DELIMITER + jobId+ ""String_Node_Str"");
    }
    final JobExecution jobExecution=new JobExecution.Builder(this.hostName).withId(jobId).build();
    this.jobPersistenceService.createJob(jobRequest,jobMetadata,jobBuilder.build(),jobExecution);
    jobStateService.init(jobId);
    final Cluster cluster=this.getCluster(jobRequest);
    final Command command=this.getCommand(jobRequest,cluster);
    final List<Application> applications=this.getApplications(jobRequest,command);
    final int memory=jobRequest.getMemory().orElse(command.getMemory().orElse(this.jobsProperties.getMemory().getDefaultJobMemory()));
    this.setRuntimeEnvironment(jobId,cluster,command,applications,memory);
    final int maxJobMemory=this.jobsProperties.getMemory().getMaxJobMemory();
    if (memory > maxJobMemory) {
      jobStatus=JobStatus.INVALID;
      throw new GeniePreconditionException(""String_Node_Str"" + memory + ""String_Node_Str""+ maxJobMemory+ ""String_Node_Str"");
    }
    log.info(""String_Node_Str"",jobRequest.getId(),jobRequest.getUser());
    final JobsUsersActiveLimitProperties activeLimit=this.jobsProperties.getUsers().getActiveLimit();
    if (activeLimit.isEnabled()) {
      final long activeJobsLimit=activeLimit.getCount();
      final long activeJobsCount=this.jobSearchService.getActiveJobCountForUser(jobRequest.getUser());
      if (activeJobsCount >= activeJobsLimit) {
        throw GenieUserLimitExceededException.createForActiveJobsLimit(jobRequest.getUser(),activeJobsCount,activeJobsLimit);
      }
    }
synchronized (this) {
      log.info(""String_Node_Str"",jobRequest.getId());
      final int maxSystemMemory=this.jobsProperties.getMemory().getMaxSystemMemory();
      final int usedMemory=this.jobStateService.getUsedMemory();
      if (usedMemory + memory <= maxSystemMemory) {
        log.info(""String_Node_Str"",jobId,usedMemory,maxSystemMemory,memory);
        log.info(""String_Node_Str"",jobId);
        jobStateService.schedule(jobId,jobRequest,cluster,command,applications,memory);
        return jobId;
      }
 else {
        throw new GenieServerUnavailableException(""String_Node_Str"" + jobId + ""String_Node_Str""+ usedMemory+ ""String_Node_Str""+ maxSystemMemory+ ""String_Node_Str""+ memory+ ""String_Node_Str"");
      }
    }
  }
 catch (  GenieConflictException e) {
    throw e;
  }
catch (  GenieException e) {
    if (jobStateService.jobExists(jobId)) {
      jobStateService.done(jobId);
      jobPersistenceService.updateJobStatus(jobId,jobStatus,e.getMessage());
    }
    throw e;
  }
catch (  Exception e) {
    if (jobStateService.jobExists(jobId)) {
      jobStateService.done(jobId);
      jobPersistenceService.updateJobStatus(jobId,jobStatus,e.getMessage());
    }
    throw new GenieServerException(e);
  }
 finally {
    this.coordinationTimer.record(System.nanoTime() - coordinationStart,TimeUnit.NANOSECONDS);
  }
}"
90006,"/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException, IOException {
  final long start=System.nanoTime();
  try {
    final JobExecutionEnvironment jobExecEnv=(JobExecutionEnvironment)context.get(JobConstants.JOB_EXECUTION_ENV_KEY);
    final String jobWorkingDirectory=jobExecEnv.getJobWorkingDir().getCanonicalPath();
    final Writer writer=(Writer)context.get(JobConstants.WRITER_KEY);
    final String jobId=jobExecEnv.getJobRequest().getId().orElseThrow(() -> new GeniePreconditionException(""String_Node_Str""));
    log.info(""String_Node_Str"",jobId);
    try {
      writer.flush();
      writer.close();
    }
 catch (    IOException e) {
      throw new GenieServerException(""String_Node_Str"" + e);
    }
    final String runScript=jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_JOB_LAUNCHER_SCRIPT;
    if (this.isUserCreationEnabled) {
      final String user=jobExecEnv.getJobRequest().getUser();
      this.createUser(user,jobExecEnv.getJobRequest().getGroup().orElse(null));
    }
    final List<String> command=new ArrayList<>();
    if (this.isRunAsUserEnabled) {
      changeOwnershipOfDirectory(jobWorkingDirectory,jobExecEnv.getJobRequest().getUser());
      makeDirGroupWritable(jobWorkingDirectory + ""String_Node_Str"");
      command.add(""String_Node_Str"");
      command.add(""String_Node_Str"");
      command.add(jobExecEnv.getJobRequest().getUser());
    }
    if (SystemUtils.IS_OS_LINUX) {
      command.add(""String_Node_Str"");
    }
    command.add(runScript);
    final ProcessBuilder pb=new ProcessBuilder(command);
    pb.directory(jobExecEnv.getJobWorkingDir());
    pb.redirectOutput(new File(jobExecEnv.getJobWorkingDir() + JobConstants.GENIE_LOG_PATH));
    pb.redirectError(new File(jobExecEnv.getJobWorkingDir() + JobConstants.GENIE_LOG_PATH));
    try {
      final Process process=pb.start();
      final int processId=this.getProcessId(process);
      final JobRequest request=jobExecEnv.getJobRequest();
      final Calendar calendar=Calendar.getInstance(UTC);
      calendar.add(Calendar.SECOND,request.getTimeout().orElse(JobRequest.DEFAULT_TIMEOUT_DURATION));
      final JobExecution jobExecution=new JobExecution.Builder(this.hostname).withId(jobId).withProcessId(processId).withCheckDelay(jobExecEnv.getCommand().getCheckDelay()).withTimeout(calendar.getTime()).withMemory(jobExecEnv.getMemory()).build();
      context.put(JobConstants.JOB_EXECUTION_DTO_KEY,jobExecution);
    }
 catch (    final IOException ie) {
      throw new GenieServerException(""String_Node_Str"" + String.valueOf(command),ie);
    }
    log.info(""String_Node_Str"",jobExecEnv.getJobRequest().getId());
  }
  finally {
    final long finish=System.nanoTime();
    this.timer.record(finish - start,TimeUnit.NANOSECONDS);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException, IOException {
  final long start=System.nanoTime();
  try {
    final JobExecutionEnvironment jobExecEnv=(JobExecutionEnvironment)context.get(JobConstants.JOB_EXECUTION_ENV_KEY);
    final String jobWorkingDirectory=jobExecEnv.getJobWorkingDir().getCanonicalPath();
    final JobRequest jobRequest=jobExecEnv.getJobRequest();
    final String user=jobRequest.getUser();
    final Writer writer=(Writer)context.get(JobConstants.WRITER_KEY);
    final String jobId=jobRequest.getId().orElseThrow(() -> new GeniePreconditionException(""String_Node_Str""));
    log.info(""String_Node_Str"",jobId);
    try {
      writer.flush();
      writer.close();
    }
 catch (    IOException e) {
      throw new GenieServerException(""String_Node_Str"" + e);
    }
    if (isUserCreationEnabled) {
      createUser(user,jobRequest.getGroup().orElse(null));
    }
    final List<String> command=new ArrayList<>();
    if (isRunAsUserEnabled) {
      changeOwnershipOfDirectory(jobWorkingDirectory,user);
      makeDirGroupWritable(jobWorkingDirectory + ""String_Node_Str"");
      command.add(""String_Node_Str"");
      command.add(""String_Node_Str"");
      command.add(user);
    }
    if (SystemUtils.IS_OS_LINUX) {
      command.add(""String_Node_Str"");
    }
    final String runScript=jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_JOB_LAUNCHER_SCRIPT;
    command.add(runScript);
    final ProcessBuilder pb=new ProcessBuilder(command).directory(jobExecEnv.getJobWorkingDir()).redirectOutput(new File(jobExecEnv.getJobWorkingDir() + JobConstants.GENIE_LOG_PATH)).redirectError(new File(jobExecEnv.getJobWorkingDir() + JobConstants.GENIE_LOG_PATH));
    canExecute(runScript);
    try {
      final Process process=pb.start();
      final int processId=this.getProcessId(process);
      final Calendar calendar=Calendar.getInstance(UTC);
      calendar.add(Calendar.SECOND,jobRequest.getTimeout().orElse(JobRequest.DEFAULT_TIMEOUT_DURATION));
      final JobExecution jobExecution=new JobExecution.Builder(this.hostname).withId(jobId).withProcessId(processId).withCheckDelay(jobExecEnv.getCommand().getCheckDelay()).withTimeout(calendar.getTime()).withMemory(jobExecEnv.getMemory()).build();
      context.put(JobConstants.JOB_EXECUTION_DTO_KEY,jobExecution);
    }
 catch (    final IOException ie) {
      throw new GenieServerException(""String_Node_Str"" + String.valueOf(command),ie);
    }
    log.info(""String_Node_Str"",jobId);
  }
  finally {
    final long finish=System.nanoTime();
    this.timer.record(finish - start,TimeUnit.NANOSECONDS);
  }
}"
90007,"/** 
 * Constructor.
 * @param runAsUserEnabled    Flag that tells if job should be run as user specified in the request
 * @param userCreationEnabled Flag that tells if the user specified should be created
 * @param executor            An executor object used to run jobs
 * @param hostname            Hostname for the node the job is running on
 * @param registry            The metrics registry to use
 */
public JobKickoffTask(final boolean runAsUserEnabled,final boolean userCreationEnabled,@NotNull final Executor executor,@NotNull final String hostname,@NotNull final Registry registry){
  this.isRunAsUserEnabled=runAsUserEnabled;
  this.isUserCreationEnabled=userCreationEnabled;
  this.executor=executor;
  this.hostname=hostname;
  this.timer=registry.timer(""String_Node_Str"");
}","/** 
 * Constructor.
 * @param runAsUserEnabled    Flag that tells if job should be run as user specified in the request
 * @param userCreationEnabled Flag that tells if the user specified should be created
 * @param executor            An executor object used to run jobs
 * @param hostname            Hostname for the node the job is running on
 * @param registry            The metrics registry to use
 */
public JobKickoffTask(final boolean runAsUserEnabled,final boolean userCreationEnabled,@NotNull final Executor executor,@NotNull final String hostname,@NotNull final Registry registry){
  this.isRunAsUserEnabled=runAsUserEnabled;
  this.isUserCreationEnabled=userCreationEnabled;
  this.executor=executor;
  this.hostname=hostname;
  this.registry=registry;
  this.timer=registry.timer(""String_Node_Str"");
  retryTemplate=new RetryTemplate();
  retryTemplate.setBackOffPolicy(new ExponentialBackOffPolicy());
}"
90008,"/** 
 * Method to change the ownership of a directory.
 * @param dir  The directory to change the ownership of.
 * @param user Userid of the user.
 * @throws GenieException If there is a problem.
 */
protected void changeOwnershipOfDirectory(final String dir,final String user) throws GenieException {
  final CommandLine commandLine=new CommandLine(""String_Node_Str"");
  commandLine.addArgument(""String_Node_Str"");
  commandLine.addArgument(""String_Node_Str"");
  commandLine.addArgument(user);
  commandLine.addArgument(dir);
  try {
    this.executor.execute(commandLine);
  }
 catch (  IOException ioexception) {
    throw new GenieServerException(""String_Node_Str"" + ioexception);
  }
}","/** 
 * Method to change the ownership of a directory.
 * @param dir  The directory to change the ownership of.
 * @param user Userid of the user.
 * @throws GenieException If there is a problem.
 */
protected void changeOwnershipOfDirectory(final String dir,final String user) throws GenieException {
  final CommandLine commandLine=new CommandLine(""String_Node_Str"").addArgument(""String_Node_Str"").addArgument(""String_Node_Str"").addArgument(user).addArgument(dir);
  try {
    this.executor.execute(commandLine);
  }
 catch (  IOException ioexception) {
    throw new GenieServerException(""String_Node_Str"" + ioexception);
  }
}"
90009,"/** 
 * Create user on the system. Synchronized to prevent multiple threads from trying to create user at the same time.
 * @param user  user id
 * @param group group id
 * @throws GenieException If there is any problem.
 */
protected synchronized void createUser(final String user,final String group) throws GenieException {
  final CommandLine idCheckCommandLine=new CommandLine(""String_Node_Str"");
  idCheckCommandLine.addArgument(""String_Node_Str"");
  idCheckCommandLine.addArgument(user);
  try {
    this.executor.execute(idCheckCommandLine);
    log.debug(""String_Node_Str"");
  }
 catch (  final IOException ioe) {
    log.debug(""String_Node_Str"");
    final boolean isGroupValid=StringUtils.isNotBlank(group) && !group.equals(user);
    if (isGroupValid) {
      log.debug(""String_Node_Str"");
      final CommandLine groupCreateCommandLine=new CommandLine(""String_Node_Str"");
      groupCreateCommandLine.addArgument(""String_Node_Str"");
      groupCreateCommandLine.addArgument(group);
      try {
        log.debug(""String_Node_Str"" + groupCreateCommandLine.toString() + ""String_Node_Str"");
        this.executor.execute(groupCreateCommandLine);
      }
 catch (      IOException ioexception) {
        log.debug(""String_Node_Str"");
      }
    }
    final CommandLine userCreateCommandLine=new CommandLine(""String_Node_Str"");
    userCreateCommandLine.addArgument(""String_Node_Str"");
    userCreateCommandLine.addArgument(user);
    if (isGroupValid) {
      userCreateCommandLine.addArgument(""String_Node_Str"");
      userCreateCommandLine.addArgument(group);
    }
    userCreateCommandLine.addArgument(""String_Node_Str"");
    try {
      log.debug(""String_Node_Str"" + userCreateCommandLine.toString() + ""String_Node_Str"");
      this.executor.execute(userCreateCommandLine);
    }
 catch (    IOException ioexception) {
      throw new GenieServerException(""String_Node_Str"" + user + ""String_Node_Str""+ ioexception);
    }
  }
}","/** 
 * Create user on the system. Synchronized to prevent multiple threads from trying to create user at the same time.
 * @param user  user id
 * @param group group id
 * @throws GenieException If there is any problem.
 */
protected synchronized void createUser(final String user,final String group) throws GenieException {
  final CommandLine idCheckCommandLine=new CommandLine(""String_Node_Str"").addArgument(""String_Node_Str"").addArgument(user);
  try {
    this.executor.execute(idCheckCommandLine);
    log.debug(""String_Node_Str"");
  }
 catch (  final IOException ioe) {
    log.debug(""String_Node_Str"");
    final boolean isGroupValid=StringUtils.isNotBlank(group) && !group.equals(user);
    if (isGroupValid) {
      log.debug(""String_Node_Str"");
      final CommandLine groupCreateCommandLine=new CommandLine(""String_Node_Str"").addArgument(""String_Node_Str"").addArgument(group);
      try {
        log.debug(""String_Node_Str"" + groupCreateCommandLine.toString() + ""String_Node_Str"");
        this.executor.execute(groupCreateCommandLine);
      }
 catch (      IOException ioexception) {
        log.debug(""String_Node_Str"");
      }
    }
    final CommandLine userCreateCommandLine=new CommandLine(""String_Node_Str"").addArgument(""String_Node_Str"").addArgument(user);
    if (isGroupValid) {
      userCreateCommandLine.addArgument(""String_Node_Str"").addArgument(group);
    }
    userCreateCommandLine.addArgument(""String_Node_Str"");
    try {
      log.debug(""String_Node_Str"" + userCreateCommandLine.toString() + ""String_Node_Str"");
      this.executor.execute(userCreateCommandLine);
    }
 catch (    IOException ioexception) {
      throw new GenieServerException(""String_Node_Str"" + user + ""String_Node_Str""+ ioexception);
    }
  }
}"
90010,"private void makeDirGroupWritable(final String dir) throws GenieServerException {
  log.debug(""String_Node_Str"" + dir + ""String_Node_Str"");
  final CommandLine commandLIne=new CommandLine(""String_Node_Str"");
  commandLIne.addArgument(""String_Node_Str"");
  commandLIne.addArgument(""String_Node_Str"");
  commandLIne.addArgument(dir);
  try {
    this.executor.execute(commandLIne);
  }
 catch (  IOException ioe) {
    throw new GenieServerException(""String_Node_Str"");
  }
}","private void makeDirGroupWritable(final String dir) throws GenieServerException {
  log.debug(""String_Node_Str"" + dir + ""String_Node_Str"");
  final CommandLine commandLIne=new CommandLine(""String_Node_Str"").addArgument(""String_Node_Str"").addArgument(""String_Node_Str"").addArgument(dir);
  try {
    this.executor.execute(commandLIne);
  }
 catch (  IOException ioe) {
    throw new GenieServerException(""String_Node_Str"");
  }
}"
90011,"/** 
 * {@inheritDoc}
 */
@Override public Page<JobSearchResult> findJobs(final String id,final String jobName,final String user,final Set<JobStatus> statuses,final Set<String> tags,final String clusterName,final String clusterId,final String commandName,final String commandId,final Date minStarted,final Date maxStarted,final Date minFinished,final Date maxFinished,@NotNull final Pageable page){
  log.debug(""String_Node_Str"");
  final CriteriaBuilder cb=this.entityManager.getCriteriaBuilder();
  final CriteriaQuery<Long> countQuery=cb.createQuery(Long.class);
  final Root<JobEntity> root=countQuery.from(JobEntity.class);
  final Predicate whereClause=JpaJobSpecs.getFindPredicate(root,cb,id,jobName,user,statuses,tags,clusterName,clusterId,commandName,commandId,minStarted,maxStarted,minFinished,maxFinished);
  countQuery.select(cb.count(root)).where(whereClause);
  final Long count=this.entityManager.createQuery(countQuery).getSingleResult();
  if (count > 0) {
    final CriteriaQuery<JobSearchResult> contentQuery=cb.createQuery(JobSearchResult.class);
    contentQuery.from(JobEntity.class);
    contentQuery.multiselect(root.get(JobEntity_.id),root.get(JobEntity_.name),root.get(JobEntity_.user),root.get(JobEntity_.status),root.get(JobEntity_.started),root.get(JobEntity_.finished),root.get(JobEntity_.clusterName),root.get(JobEntity_.commandName));
    contentQuery.where(whereClause);
    final Sort sort=page.getSort();
    final List<Order> orders=new ArrayList<>();
    sort.iterator().forEachRemaining(order -> {
      if (order.isAscending()) {
        orders.add(cb.asc(root.get(order.getProperty())));
      }
 else {
        orders.add(cb.desc(root.get(order.getProperty())));
      }
    }
);
    contentQuery.orderBy(orders);
    final List<JobSearchResult> results=this.entityManager.createQuery(contentQuery).setFirstResult(page.getOffset()).setMaxResults(page.getPageSize()).getResultList();
    return new PageImpl<>(results,page,count);
  }
 else {
    return new PageImpl<>(Lists.newArrayList());
  }
}","/** 
 * {@inheritDoc}
 */
@Override public Page<JobSearchResult> findJobs(final String id,final String jobName,final String user,final Set<JobStatus> statuses,final Set<String> tags,final String clusterName,final String clusterId,final String commandName,final String commandId,final Date minStarted,final Date maxStarted,final Date minFinished,final Date maxFinished,@NotNull final Pageable page){
  log.debug(""String_Node_Str"");
  final CriteriaBuilder cb=this.entityManager.getCriteriaBuilder();
  final CriteriaQuery<Long> countQuery=cb.createQuery(Long.class);
  final Root<JobEntity> root=countQuery.from(JobEntity.class);
  final Predicate whereClause=JpaJobSpecs.getFindPredicate(root,cb,id,jobName,user,statuses,tags,clusterName,clusterId == null ? null : this.clusterRepository.findOne(clusterId),commandName,commandId == null ? null : this.commandRepository.findOne(commandId),minStarted,maxStarted,minFinished,maxFinished);
  countQuery.select(cb.count(root)).where(whereClause);
  final Long count=this.entityManager.createQuery(countQuery).getSingleResult();
  if (count > 0) {
    final CriteriaQuery<JobSearchResult> contentQuery=cb.createQuery(JobSearchResult.class);
    contentQuery.from(JobEntity.class);
    contentQuery.multiselect(root.get(JobEntity_.id),root.get(JobEntity_.name),root.get(JobEntity_.user),root.get(JobEntity_.status),root.get(JobEntity_.started),root.get(JobEntity_.finished),root.get(JobEntity_.clusterName),root.get(JobEntity_.commandName));
    contentQuery.where(whereClause);
    final Sort sort=page.getSort();
    final List<Order> orders=new ArrayList<>();
    sort.iterator().forEachRemaining(order -> {
      if (order.isAscending()) {
        orders.add(cb.asc(root.get(order.getProperty())));
      }
 else {
        orders.add(cb.desc(root.get(order.getProperty())));
      }
    }
);
    contentQuery.orderBy(orders);
    final List<JobSearchResult> results=this.entityManager.createQuery(contentQuery).setFirstResult(page.getOffset()).setMaxResults(page.getPageSize()).getResultList();
    return new PageImpl<>(results,page,count);
  }
 else {
    return new PageImpl<>(Lists.newArrayList());
  }
}"
90012,"/** 
 * Constructor.
 * @param jobRepository          The repository to use for job entities
 * @param jobRequestRepository   The repository to use for job request entities
 * @param jobExecutionRepository The repository to use for job execution entities
 */
public JpaJobSearchServiceImpl(final JpaJobRepository jobRepository,final JpaJobRequestRepository jobRequestRepository,final JpaJobExecutionRepository jobExecutionRepository){
  this.jobRepository=jobRepository;
  this.jobRequestRepository=jobRequestRepository;
  this.jobExecutionRepository=jobExecutionRepository;
}","/** 
 * Constructor.
 * @param jobRepository          The repository to use for job entities
 * @param jobRequestRepository   The repository to use for job request entities
 * @param jobExecutionRepository The repository to use for job execution entities
 * @param clusterRepository      The repository to use for cluster entities
 * @param commandRepository      The repository to use for command entities
 */
public JpaJobSearchServiceImpl(final JpaJobRepository jobRepository,final JpaJobRequestRepository jobRequestRepository,final JpaJobExecutionRepository jobExecutionRepository,final JpaClusterRepository clusterRepository,final JpaCommandRepository commandRepository){
  this.jobRepository=jobRepository;
  this.jobRequestRepository=jobRequestRepository;
  this.jobExecutionRepository=jobExecutionRepository;
  this.clusterRepository=clusterRepository;
  this.commandRepository=commandRepository;
}"
90013,"/** 
 * Generate a criteria query predicate for a where clause based on the given parameters.
 * @param root        The root to use
 * @param cb          The criteria builder to use
 * @param id          The job id
 * @param name        The job name
 * @param user        The user who created the job
 * @param statuses    The job statuses
 * @param tags        The tags for the jobs to find
 * @param clusterName The cluster name
 * @param clusterId   The cluster id
 * @param commandName The command name
 * @param commandId   The command id
 * @param minStarted  The time which the job had to start after in order to be return (inclusive)
 * @param maxStarted  The time which the job had to start before in order to be returned (exclusive)
 * @param minFinished The time which the job had to finish after in order to be return (inclusive)
 * @param maxFinished The time which the job had to finish before in order to be returned (exclusive)
 * @return The specification
 */
public static Predicate getFindPredicate(final Root<JobEntity> root,final CriteriaBuilder cb,final String id,final String name,final String user,final Set<JobStatus> statuses,final Set<String> tags,final String clusterName,final String clusterId,final String commandName,final String commandId,final Date minStarted,final Date maxStarted,final Date minFinished,final Date maxFinished){
  final List<Predicate> predicates=new ArrayList<>();
  if (StringUtils.isNotBlank(id)) {
    predicates.add(cb.like(root.get(JobEntity_.id),id));
  }
  if (StringUtils.isNotBlank(name)) {
    predicates.add(cb.like(root.get(JobEntity_.name),name));
  }
  if (StringUtils.isNotBlank(user)) {
    predicates.add(cb.equal(root.get(JobEntity_.user),user));
  }
  if (statuses != null && !statuses.isEmpty()) {
    final List<Predicate> orPredicates=statuses.stream().map(status -> cb.equal(root.get(JobEntity_.status),status)).collect(Collectors.toList());
    predicates.add(cb.or(orPredicates.toArray(new Predicate[orPredicates.size()])));
  }
  if (tags != null && !tags.isEmpty()) {
    predicates.add(cb.like(root.get(JobEntity_.tags),JpaSpecificationUtils.getTagLikeString(tags)));
  }
  if (StringUtils.isNotBlank(clusterId)) {
    predicates.add(cb.equal(root.get(JobEntity_.cluster),clusterId));
  }
  if (StringUtils.isNotBlank(clusterName)) {
    predicates.add(cb.equal(root.get(JobEntity_.clusterName),clusterName));
  }
  if (StringUtils.isNotBlank(commandId)) {
    predicates.add(cb.equal(root.get(JobEntity_.command),commandId));
  }
  if (StringUtils.isNotBlank(commandName)) {
    predicates.add(cb.equal(root.get(JobEntity_.commandName),commandName));
  }
  if (minStarted != null) {
    predicates.add(cb.greaterThanOrEqualTo(root.get(JobEntity_.started),minStarted));
  }
  if (maxStarted != null) {
    predicates.add(cb.lessThan(root.get(JobEntity_.started),maxStarted));
  }
  if (minFinished != null) {
    predicates.add(cb.greaterThanOrEqualTo(root.get(JobEntity_.finished),minFinished));
  }
  if (maxFinished != null) {
    predicates.add(cb.lessThan(root.get(JobEntity_.finished),maxFinished));
  }
  return cb.and(predicates.toArray(new Predicate[predicates.size()]));
}","/** 
 * Generate a criteria query predicate for a where clause based on the given parameters.
 * @param root        The root to use
 * @param cb          The criteria builder to use
 * @param id          The job id
 * @param name        The job name
 * @param user        The user who created the job
 * @param statuses    The job statuses
 * @param tags        The tags for the jobs to find
 * @param clusterName The cluster name
 * @param cluster     The cluster the job should have been run on
 * @param commandName The command name
 * @param command     The command the job should have been run with
 * @param minStarted  The time which the job had to start after in order to be return (inclusive)
 * @param maxStarted  The time which the job had to start before in order to be returned (exclusive)
 * @param minFinished The time which the job had to finish after in order to be return (inclusive)
 * @param maxFinished The time which the job had to finish before in order to be returned (exclusive)
 * @return The specification
 */
public static Predicate getFindPredicate(final Root<JobEntity> root,final CriteriaBuilder cb,final String id,final String name,final String user,final Set<JobStatus> statuses,final Set<String> tags,final String clusterName,final ClusterEntity cluster,final String commandName,final CommandEntity command,final Date minStarted,final Date maxStarted,final Date minFinished,final Date maxFinished){
  final List<Predicate> predicates=new ArrayList<>();
  if (StringUtils.isNotBlank(id)) {
    predicates.add(cb.like(root.get(JobEntity_.id),id));
  }
  if (StringUtils.isNotBlank(name)) {
    predicates.add(cb.like(root.get(JobEntity_.name),name));
  }
  if (StringUtils.isNotBlank(user)) {
    predicates.add(cb.equal(root.get(JobEntity_.user),user));
  }
  if (statuses != null && !statuses.isEmpty()) {
    final List<Predicate> orPredicates=statuses.stream().map(status -> cb.equal(root.get(JobEntity_.status),status)).collect(Collectors.toList());
    predicates.add(cb.or(orPredicates.toArray(new Predicate[orPredicates.size()])));
  }
  if (tags != null && !tags.isEmpty()) {
    predicates.add(cb.like(root.get(JobEntity_.tags),JpaSpecificationUtils.getTagLikeString(tags)));
  }
  if (cluster != null) {
    predicates.add(cb.equal(root.get(JobEntity_.cluster),cluster));
  }
  if (StringUtils.isNotBlank(clusterName)) {
    predicates.add(cb.equal(root.get(JobEntity_.clusterName),clusterName));
  }
  if (command != null) {
    predicates.add(cb.equal(root.get(JobEntity_.command),command));
  }
  if (StringUtils.isNotBlank(commandName)) {
    predicates.add(cb.equal(root.get(JobEntity_.commandName),commandName));
  }
  if (minStarted != null) {
    predicates.add(cb.greaterThanOrEqualTo(root.get(JobEntity_.started),minStarted));
  }
  if (maxStarted != null) {
    predicates.add(cb.lessThan(root.get(JobEntity_.started),maxStarted));
  }
  if (minFinished != null) {
    predicates.add(cb.greaterThanOrEqualTo(root.get(JobEntity_.finished),minFinished));
  }
  if (maxFinished != null) {
    predicates.add(cb.lessThan(root.get(JobEntity_.finished),maxFinished));
  }
  return cb.and(predicates.toArray(new Predicate[predicates.size()]));
}"
90014,"/** 
 * Get JPA based implementation of the JobSearchService.
 * @param jobRepository          The repository to use for job entities
 * @param jobRequestRepository   The repository to use for job request entities
 * @param jobExecutionRepository The repository to use for job execution entities
 * @return A job search service instance.
 */
@Bean public JobSearchService jobSearchService(final JpaJobRepository jobRepository,final JpaJobRequestRepository jobRequestRepository,final JpaJobExecutionRepository jobExecutionRepository){
  return new JpaJobSearchServiceImpl(jobRepository,jobRequestRepository,jobExecutionRepository);
}","/** 
 * Get JPA based implementation of the JobSearchService.
 * @param jobRepository          The repository to use for job entities
 * @param jobRequestRepository   The repository to use for job request entities
 * @param jobExecutionRepository The repository to use for job execution entities
 * @param clusterRepository      The repository to use for cluster entities
 * @param commandRepository      The repository to use for command entities
 * @return A job search service instance.
 */
@Bean public JobSearchService jobSearchService(final JpaJobRepository jobRepository,final JpaJobRequestRepository jobRequestRepository,final JpaJobExecutionRepository jobExecutionRepository,final JpaClusterRepository clusterRepository,final JpaCommandRepository commandRepository){
  return new JpaJobSearchServiceImpl(jobRepository,jobRequestRepository,jobExecutionRepository,clusterRepository,commandRepository);
}"
90015,"/** 
 * Setup for the tests.
 */
@Before public void setup(){
  this.jobRepository=Mockito.mock(JpaJobRepository.class);
  this.jobRequestRepository=Mockito.mock(JpaJobRequestRepository.class);
  this.jobExecutionRepository=Mockito.mock(JpaJobExecutionRepository.class);
  this.service=new JpaJobSearchServiceImpl(this.jobRepository,this.jobRequestRepository,this.jobExecutionRepository);
}","/** 
 * Setup for the tests.
 */
@Before public void setup(){
  this.jobRepository=Mockito.mock(JpaJobRepository.class);
  this.jobRequestRepository=Mockito.mock(JpaJobRequestRepository.class);
  this.jobExecutionRepository=Mockito.mock(JpaJobExecutionRepository.class);
  this.service=new JpaJobSearchServiceImpl(this.jobRepository,this.jobRequestRepository,this.jobExecutionRepository,Mockito.mock(JpaClusterRepository.class),Mockito.mock(JpaCommandRepository.class));
}"
90016,"/** 
 * Get the file needed by Genie for job execution.
 * @param srcRemotePath Path of the file in the remote location to be fetched
 * @param dstLocalPath  Local path where the file needs to be placed
 * @throws GenieException If there is any problem
 */
public void getFile(@NotBlank(message=""String_Node_Str"") final String srcRemotePath,@NotBlank(message=""String_Node_Str"") final String dstLocalPath) throws GenieException {
  log.debug(""String_Node_Str"",srcRemotePath,dstLocalPath);
  File cachedFile=fileCache.getIfPresent(srcRemotePath);
  try {
    if (cachedFile == null) {
      cachedFile=fileCache.get(srcRemotePath);
    }
 else {
      cachedFile=fileCache.get(srcRemotePath);
      final long lastModifiedTime=getFileTransfer(srcRemotePath).getLastModifiedTime(srcRemotePath);
      if (lastModifiedTime > cachedFile.lastModified()) {
synchronized (this) {
          if (lastModifiedTime > cachedFile.lastModified()) {
            fileCache.invalidate(srcRemotePath);
            deleteFile(cachedFile);
            cachedFile=fileCache.get(srcRemotePath);
          }
        }
      }
    }
  }
 catch (  Exception e) {
    final String message=String.format(""String_Node_Str"",srcRemotePath);
    log.error(message);
    throw new GenieServerException(message,e);
  }
  localFileTransfer.getFile(cachedFile.getPath(),dstLocalPath);
}","/** 
 * Get the file needed by Genie for job execution.
 * @param srcRemotePath Path of the file in the remote location to be fetched
 * @param dstLocalPath  Local path where the file needs to be placed
 * @throws GenieException If there is any problem
 */
public void getFile(@NotBlank(message=""String_Node_Str"") final String srcRemotePath,@NotBlank(message=""String_Node_Str"") final String dstLocalPath) throws GenieException {
  log.debug(""String_Node_Str"",srcRemotePath,dstLocalPath);
  File cachedFile=null;
  try {
    cachedFile=fileCache.get(srcRemotePath);
    final long lastModifiedTime=getFileTransfer(srcRemotePath).getLastModifiedTime(srcRemotePath);
    if (lastModifiedTime > cachedFile.lastModified()) {
synchronized (this) {
        if (lastModifiedTime > cachedFile.lastModified()) {
          fileCache.invalidate(srcRemotePath);
          deleteFile(cachedFile);
          cachedFile=fileCache.get(srcRemotePath);
        }
      }
    }
  }
 catch (  Exception e) {
    final String message=String.format(""String_Node_Str"",srcRemotePath);
    log.error(message);
    throw new GenieServerException(message,e);
  }
  localFileTransfer.getFile(cachedFile.getPath(),dstLocalPath);
}"
90017,"/** 
 * Sends an email when the job is completed. Returns true if an email has been sent.
 * @param jobId The job id.
 * @throws GenieException If there is any problem.
 */
private boolean sendEmail(final String jobId) throws GenieException {
  log.debug(""String_Node_Str"");
  final JobRequest jobRequest=this.jobSearchService.getJobRequest(jobId);
  boolean result=false;
  final Optional<String> email=jobRequest.getEmail();
  if (email.isPresent() && Strings.isNullOrEmpty(email.get())) {
    final JobStatus status=this.jobSearchService.getJobStatus(jobId);
    this.mailServiceImpl.sendEmail(email.get(),""String_Node_Str"" + jobId,""String_Node_Str"" + jobId + ""String_Node_Str""+ status);
    result=true;
    this.emailSuccessRate.increment();
  }
  return result;
}","/** 
 * Sends an email when the job is completed. Returns true if an email has been sent.
 * @param jobId The job id.
 * @throws GenieException If there is any problem.
 */
private boolean sendEmail(final String jobId) throws GenieException {
  final JobRequest jobRequest=this.jobSearchService.getJobRequest(jobId);
  boolean result=false;
  final Optional<String> email=jobRequest.getEmail();
  if (email.isPresent() && !Strings.isNullOrEmpty(email.get())) {
    log.debug(""String_Node_Str"",email.get());
    final JobStatus status=this.jobSearchService.getJobStatus(jobId);
    this.mailServiceImpl.sendEmail(email.get(),""String_Node_Str"" + jobId,""String_Node_Str"" + jobId + ""String_Node_Str""+ status);
    result=true;
    this.emailSuccessRate.increment();
  }
  return result;
}"
90018,"private void copyRequestHeaders(final HttpServletRequest request,final ClientHttpRequest forwardRequest){
  final HttpHeaders headers=forwardRequest.getHeaders();
  final Enumeration<String> headerNames=request.getHeaderNames();
  if (headerNames != null) {
    while (headerNames.hasMoreElements()) {
      final String headerName=headerNames.nextElement();
      final String headerValue=request.getHeader(headerName);
      log.debug(""String_Node_Str"",headerName,headerValue);
      headers.add(headerName,headerValue);
    }
  }
  headers.add(JobConstants.GENIE_FORWARDED_FROM_HEADER,request.getRequestURL().toString());
}","private void copyRequestHeaders(final HttpServletRequest request,final ClientHttpRequest forwardRequest){
  final HttpHeaders headers=forwardRequest.getHeaders();
  final Enumeration<String> headerNames=request.getHeaderNames();
  if (headerNames != null) {
    while (headerNames.hasMoreElements()) {
      final String headerName=headerNames.nextElement();
      if (!NAME_HEADER_COOKIE.equals(headerName)) {
        final String headerValue=request.getHeader(headerName);
        log.debug(""String_Node_Str"",headerName,headerValue);
        headers.add(headerName,headerValue);
      }
    }
  }
  final Cookie[] cookies=request.getCookies();
  if (cookies != null && cookies.length > 0) {
    StringBuilder builder=null;
    for (    final Cookie cookie : request.getCookies()) {
      if (builder == null) {
        builder=new StringBuilder();
      }
 else {
        builder.append(""String_Node_Str"");
      }
      builder.append(cookie.getName()).append(""String_Node_Str"").append(cookie.getValue());
    }
    if (builder != null) {
      final String cookieValue=builder.toString();
      headers.add(NAME_HEADER_COOKIE,cookieValue);
      log.debug(""String_Node_Str"",NAME_HEADER_COOKIE,cookieValue);
    }
  }
  headers.add(JobConstants.GENIE_FORWARDED_FROM_HEADER,request.getRequestURL().toString());
}"
90019,"/** 
 * Get the tags with the current genie.id and genie.name tags added into the set.
 * @return The final set of tags for storing in the database
 * @throws GenieException On any exception
 */
protected Set<String> getFinalTags() throws GenieException {
  final Set<String> finalTags;
  if (this.tags == null) {
    finalTags=Sets.newHashSet();
  }
 else {
    finalTags=Sets.newHashSet(this.tags.split(PIPE_REGEX)).stream().filter(tag -> !tag.contains(GENIE_TAG_NAMESPACE)).collect(Collectors.toSet());
  }
  if (this.getId() == null) {
    this.setId(UUID.randomUUID().toString());
  }
  finalTags.add(GENIE_ID_TAG_NAMESPACE + this.getId());
  finalTags.add(GENIE_NAME_TAG_NAMESPACE + this.getName());
  return finalTags;
}","/** 
 * Get the tags with the current genie.id and genie.name tags added into the set.
 * @return The final set of tags for storing in the database
 * @throws GenieException On any exception
 */
protected Set<String> getFinalTags() throws GenieException {
  final Set<String> finalTags;
  if (this.tags == null) {
    finalTags=Sets.newHashSet();
  }
 else {
    finalTags=Sets.newHashSet(this.splitTags(this.tags)).stream().filter(tag -> !tag.contains(GENIE_TAG_NAMESPACE)).collect(Collectors.toSet());
  }
  if (this.getId() == null) {
    this.setId(UUID.randomUUID().toString());
  }
  finalTags.add(GENIE_ID_TAG_NAMESPACE + this.getId());
  finalTags.add(GENIE_NAME_TAG_NAMESPACE + this.getName());
  return finalTags;
}"
90020,"/** 
 * Get the tags attached to this entity.
 * @return The tags attached to this entity
 */
public Set<String> getTags(){
  final Set<String> returnTags=new HashSet<>();
  if (this.tags != null) {
    returnTags.addAll(Arrays.asList(this.tags.split(PIPE_REGEX)));
  }
  return returnTags;
}","/** 
 * Get the tags attached to this entity.
 * @return The tags attached to this entity
 */
public Set<String> getTags(){
  if (this.tags != null) {
    return Sets.newHashSet(this.splitTags(this.tags));
  }
 else {
    return Sets.newHashSet();
  }
}"
90021,"/** 
 * Set the tags.
 * @param tags The tags to set
 */
public void setTags(final Set<String> tags){
  this.tags=null;
  if (tags != null && !tags.isEmpty()) {
    this.tags=tags.stream().sorted(String.CASE_INSENSITIVE_ORDER).reduce((one,two) -> one + PIPE + two).get();
  }
}","/** 
 * Set the tags.
 * @param tags The tags to set
 */
public void setTags(final Set<String> tags){
  this.tags=null;
  if (tags != null && !tags.isEmpty()) {
    this.tags=TAG_DELIMITER + tags.stream().sorted(String.CASE_INSENSITIVE_ORDER).reduce((one,two) -> one + TAG_DELIMITER + TAG_DELIMITER+ two).get() + TAG_DELIMITER;
  }
}"
90022,"/** 
 * Get the sorted like statement for tags used in specification queries.
 * @param tags The tags to use. Not null.
 * @return The tags sorted while ignoring case delimited with percent symbol.
 */
public static String getTagLikeString(@NotNull final Set<String> tags){
  final StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  tags.stream().filter(StringUtils::isNotBlank).sorted(String.CASE_INSENSITIVE_ORDER).forEach(tag -> builder.append(tag).append(""String_Node_Str""));
  return builder.toString();
}","/** 
 * Get the sorted like statement for tags used in specification queries.
 * @param tags The tags to use. Not null.
 * @return The tags sorted while ignoring case delimited with percent symbol.
 */
public static String getTagLikeString(@NotNull final Set<String> tags){
  final StringBuilder builder=new StringBuilder();
  tags.stream().filter(StringUtils::isNotBlank).sorted(String.CASE_INSENSITIVE_ORDER).forEach(tag -> builder.append(PERCENT).append(CommonFieldsEntity.TAG_DELIMITER).append(tag).append(CommonFieldsEntity.TAG_DELIMITER));
  return builder.append(PERCENT).toString();
}"
90023,"/** 
 * Test to patch a cluster.
 * @throws GenieException For any problem
 * @throws IOException For Json serialization problem
 */
@Test public void testPatchCluster() throws GenieException, IOException {
  final Cluster getCluster=this.service.getCluster(CLUSTER_1_ID);
  Assert.assertThat(getCluster.getName(),Matchers.is(CLUSTER_1_NAME));
  final Date updateTime=getCluster.getUpdated();
  final String patchString=""String_Node_Str"" + CLUSTER_2_NAME + ""String_Node_Str"";
  final ObjectMapper mapper=new ObjectMapper();
  final JsonPatch patch=JsonPatch.fromJson(mapper.readTree(patchString));
  this.service.patchCluster(CLUSTER_1_ID,patch);
  final Cluster updated=this.service.getCluster(CLUSTER_1_ID);
  Assert.assertNotEquals(updated.getUpdated(),Matchers.is(updateTime));
  Assert.assertThat(updated.getName(),Matchers.is(CLUSTER_2_NAME));
}","/** 
 * Test to patch a cluster.
 * @throws GenieException For any problem
 * @throws IOException    For Json serialization problem
 */
@Test public void testPatchCluster() throws GenieException, IOException {
  final Cluster getCluster=this.service.getCluster(CLUSTER_1_ID);
  Assert.assertThat(getCluster.getName(),Matchers.is(CLUSTER_1_NAME));
  final Date updateTime=getCluster.getUpdated();
  final String patchString=""String_Node_Str"" + CLUSTER_2_NAME + ""String_Node_Str"";
  final ObjectMapper mapper=new ObjectMapper();
  final JsonPatch patch=JsonPatch.fromJson(mapper.readTree(patchString));
  this.service.patchCluster(CLUSTER_1_ID,patch);
  final Cluster updated=this.service.getCluster(CLUSTER_1_ID);
  Assert.assertNotEquals(updated.getUpdated(),Matchers.is(updateTime));
  Assert.assertThat(updated.getName(),Matchers.is(CLUSTER_2_NAME));
}"
90024,"/** 
 * Test the choseClusterForJob function.
 * @throws GenieException For any problem
 */
@Ignore @Test public void testChooseClusterForJob() throws GenieException {
}","/** 
 * Test the choseClusterForJobRequest function.
 * @throws GenieException For any problem
 */
@Test public void testChooseClusterForJob() throws GenieException {
  final JobRequest one=new JobRequest.Builder(UUID.randomUUID().toString(),UUID.randomUUID().toString(),UUID.randomUUID().toString(),UUID.randomUUID().toString(),Lists.newArrayList(new ClusterCriteria(Sets.newHashSet(""String_Node_Str""))),Sets.newHashSet(""String_Node_Str"")).build();
  final JobRequest two=new JobRequest.Builder(UUID.randomUUID().toString(),UUID.randomUUID().toString(),UUID.randomUUID().toString(),UUID.randomUUID().toString(),Lists.newArrayList(new ClusterCriteria(Sets.newHashSet(""String_Node_Str""))),Sets.newHashSet(""String_Node_Str"")).build();
  final JobRequest three=new JobRequest.Builder(UUID.randomUUID().toString(),UUID.randomUUID().toString(),UUID.randomUUID().toString(),UUID.randomUUID().toString(),Lists.newArrayList(new ClusterCriteria(Sets.newHashSet(""String_Node_Str""))),Sets.newHashSet(""String_Node_Str"")).build();
  final JobRequest four=new JobRequest.Builder(UUID.randomUUID().toString(),UUID.randomUUID().toString(),UUID.randomUUID().toString(),UUID.randomUUID().toString(),Lists.newArrayList(new ClusterCriteria(Sets.newHashSet(""String_Node_Str""))),Sets.newHashSet(""String_Node_Str"")).build();
  final JobRequest five=new JobRequest.Builder(UUID.randomUUID().toString(),UUID.randomUUID().toString(),UUID.randomUUID().toString(),UUID.randomUUID().toString(),Lists.newArrayList(new ClusterCriteria(Sets.newHashSet(""String_Node_Str"",""String_Node_Str""))),Sets.newHashSet(""String_Node_Str"")).build();
  Assert.assertThat(this.service.chooseClusterForJobRequest(one).size(),Matchers.is(1));
  Assert.assertThat(this.service.chooseClusterForJobRequest(two).size(),Matchers.is(0));
  Assert.assertThat(this.service.chooseClusterForJobRequest(three).size(),Matchers.is(0));
  Assert.assertThat(this.service.chooseClusterForJobRequest(four).size(),Matchers.is(2));
  Assert.assertThat(this.service.chooseClusterForJobRequest(five).size(),Matchers.is(2));
}"
90025,"/** 
 * Make sure we can get a valid like string for the tag list.
 */
@Test public void canGetTagLikeString(){
  Assert.assertThat(JpaSpecificationUtils.getTagLikeString(Sets.newHashSet()),Matchers.is(""String_Node_Str""));
  Assert.assertThat(JpaSpecificationUtils.getTagLikeString(Sets.newHashSet(""String_Node_Str"")),Matchers.is(""String_Node_Str""));
  Assert.assertThat(JpaSpecificationUtils.getTagLikeString(Sets.newHashSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Matchers.is(""String_Node_Str""));
}","/** 
 * Make sure we can get a valid like string for the tag list.
 */
@Test public void canGetTagLikeString(){
  Assert.assertThat(JpaSpecificationUtils.getTagLikeString(Sets.newHashSet()),Matchers.is(""String_Node_Str""));
  Assert.assertThat(JpaSpecificationUtils.getTagLikeString(Sets.newHashSet(""String_Node_Str"")),Matchers.is(""String_Node_Str"" + CommonFieldsEntity.TAG_DELIMITER + ""String_Node_Str""+ CommonFieldsEntity.TAG_DELIMITER+ ""String_Node_Str""));
  Assert.assertThat(JpaSpecificationUtils.getTagLikeString(Sets.newHashSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),Matchers.is(""String_Node_Str"" + CommonFieldsEntity.TAG_DELIMITER + ""String_Node_Str""+ CommonFieldsEntity.TAG_DELIMITER+ ""String_Node_Str""+ CommonFieldsEntity.TAG_DELIMITER+ ""String_Node_Str""+ CommonFieldsEntity.TAG_DELIMITER+ ""String_Node_Str""+ CommonFieldsEntity.TAG_DELIMITER+ ""String_Node_Str""+ CommonFieldsEntity.TAG_DELIMITER+ ""String_Node_Str""));
}"
90026,"@Override public Health health(){
  final double freePhysicalMemorySize=(double)operatingSystemMXBean.getFreePhysicalMemorySize();
  final double totalPhysicalMemorySize=(double)operatingSystemMXBean.getTotalPhysicalMemorySize();
  final double usedPhysicalMemoryPercentage=((totalPhysicalMemorySize - freePhysicalMemorySize) / totalPhysicalMemorySize) * 100;
  if (usedPhysicalMemoryPercentage > maxUsedPhysicalMemoryPercentage) {
    log.warn(""String_Node_Str"",usedPhysicalMemoryPercentage,maxUsedPhysicalMemoryPercentage);
    return Health.outOfService().withDetail(FREE_PHYSICAL_MEMORY_SIZE,freePhysicalMemorySize).withDetail(TOTAL_PHYSICAL_MEMORY_SIZE,totalPhysicalMemorySize).build();
  }
 else {
    return Health.up().withDetail(FREE_PHYSICAL_MEMORY_SIZE,freePhysicalMemorySize).withDetail(TOTAL_PHYSICAL_MEMORY_SIZE,totalPhysicalMemorySize).build();
  }
}","@Override public Health health(){
  Health.Builder result=Health.up();
  try {
    final double freePhysicalMemorySize=(double)operatingSystemMXBean.getFreePhysicalMemorySize();
    final double totalPhysicalMemorySize=(double)operatingSystemMXBean.getTotalPhysicalMemorySize();
    final double usedPhysicalMemoryPercentage=((totalPhysicalMemorySize - freePhysicalMemorySize) / totalPhysicalMemorySize) * 100;
    if (usedPhysicalMemoryPercentage > maxUsedPhysicalMemoryPercentage) {
      log.warn(""String_Node_Str"",usedPhysicalMemoryPercentage,maxUsedPhysicalMemoryPercentage);
      result=Health.outOfService();
    }
    result.withDetail(FREE_PHYSICAL_MEMORY_SIZE,freePhysicalMemorySize).withDetail(TOTAL_PHYSICAL_MEMORY_SIZE,totalPhysicalMemorySize);
  }
 catch (  Throwable e) {
    log.warn(""String_Node_Str"",e.getMessage());
  }
  return result.build();
}"
90027,"/** 
 * Constructor.
 * @param maxUsedPhysicalMemoryPercentage The maximum physical memory threshold
 * @param operatingSystemMXBean MX bean for operating system
 */
@Autowired public MemoryHealthIndicator(@Value(""String_Node_Str"") final double maxUsedPhysicalMemoryPercentage,final OperatingSystemMXBean operatingSystemMXBean){
  this.maxUsedPhysicalMemoryPercentage=maxUsedPhysicalMemoryPercentage;
  this.operatingSystemMXBean=operatingSystemMXBean;
}","MemoryHealthIndicator(final double maxUsedPhysicalMemoryPercentage,final OperatingSystemMXBean operatingSystemMXBean){
  this.maxUsedPhysicalMemoryPercentage=maxUsedPhysicalMemoryPercentage;
  this.operatingSystemMXBean=operatingSystemMXBean;
}"
90028,"@Override public Health health(){
  final double freePhysicalMemorySize=(double)operatingSystemMXBean.getFreePhysicalMemorySize();
  final double totalPhysicalMemorySize=(double)operatingSystemMXBean.getTotalPhysicalMemorySize();
  final double usedPhysicalMemoryPercentage=((totalPhysicalMemorySize - freePhysicalMemorySize) / totalPhysicalMemorySize) * 100;
  if (usedPhysicalMemoryPercentage > maxUsedPhysicalMemoryPercentage) {
    log.warn(""String_Node_Str"",usedPhysicalMemoryPercentage,maxUsedPhysicalMemoryPercentage);
    return Health.outOfService().withDetail(FREE_PHYSICAL_MEMORY_SIZE,freePhysicalMemorySize).withDetail(TOTAL_PHYSICAL_MEMORY_SIZE,totalPhysicalMemorySize).build();
  }
 else {
    return Health.up().withDetail(FREE_PHYSICAL_MEMORY_SIZE,freePhysicalMemorySize).withDetail(TOTAL_PHYSICAL_MEMORY_SIZE,totalPhysicalMemorySize).build();
  }
}","@Override public Health health(){
  Health.Builder result=Health.up();
  try {
    final double freePhysicalMemorySize=(double)operatingSystemMXBean.getFreePhysicalMemorySize();
    final double totalPhysicalMemorySize=(double)operatingSystemMXBean.getTotalPhysicalMemorySize();
    final double usedPhysicalMemoryPercentage=((totalPhysicalMemorySize - freePhysicalMemorySize) / totalPhysicalMemorySize) * 100;
    if (usedPhysicalMemoryPercentage > maxUsedPhysicalMemoryPercentage) {
      log.warn(""String_Node_Str"",usedPhysicalMemoryPercentage,maxUsedPhysicalMemoryPercentage);
      result=Health.outOfService();
    }
    result.withDetail(FREE_PHYSICAL_MEMORY_SIZE,freePhysicalMemorySize).withDetail(TOTAL_PHYSICAL_MEMORY_SIZE,totalPhysicalMemorySize);
  }
 catch (  Throwable e) {
    log.warn(""String_Node_Str"",e.getMessage());
  }
  return result.build();
}"
90029,"/** 
 * Constructor.
 * @param maxUsedPhysicalMemoryPercentage The maximum physical memory threshold
 * @param operatingSystemMXBean MX bean for operating system
 */
@Autowired public MemoryHealthIndicator(@Value(""String_Node_Str"") final double maxUsedPhysicalMemoryPercentage,final OperatingSystemMXBean operatingSystemMXBean){
  this.maxUsedPhysicalMemoryPercentage=maxUsedPhysicalMemoryPercentage;
  this.operatingSystemMXBean=operatingSystemMXBean;
}","MemoryHealthIndicator(final double maxUsedPhysicalMemoryPercentage,final OperatingSystemMXBean operatingSystemMXBean){
  this.maxUsedPhysicalMemoryPercentage=maxUsedPhysicalMemoryPercentage;
  this.operatingSystemMXBean=operatingSystemMXBean;
}"
90030,"private void addConfigParamsFromConfig(final OkHttpClient.Builder builder,final GenieNetworkConfiguration genieNetworkConfiguration){
  if (genieNetworkConfiguration.getConnectTimeout() != 0) {
    builder.connectTimeout(genieNetworkConfiguration.getConnectTimeout(),TimeUnit.MILLISECONDS);
  }
  if (genieNetworkConfiguration.getReadTimeout() != 0) {
    builder.readTimeout(genieNetworkConfiguration.getReadTimeout(),TimeUnit.MILLISECONDS);
  }
  if (genieNetworkConfiguration.getWriteTimeout() != 0) {
    builder.writeTimeout(genieNetworkConfiguration.getWriteTimeout(),TimeUnit.MILLISECONDS);
  }
  builder.retryOnConnectionFailure(genieNetworkConfiguration.isRetryOnConnectionFailure());
}","private void addConfigParamsFromConfig(final OkHttpClient.Builder builder,final GenieNetworkConfiguration genieNetworkConfiguration){
  if (genieNetworkConfiguration.getConnectTimeout() != GenieNetworkConfiguration.DEFAULT_TIMEOUT) {
    builder.connectTimeout(genieNetworkConfiguration.getConnectTimeout(),TimeUnit.MILLISECONDS);
  }
  if (genieNetworkConfiguration.getReadTimeout() != GenieNetworkConfiguration.DEFAULT_TIMEOUT) {
    builder.readTimeout(genieNetworkConfiguration.getReadTimeout(),TimeUnit.MILLISECONDS);
  }
  if (genieNetworkConfiguration.getWriteTimeout() != GenieNetworkConfiguration.DEFAULT_TIMEOUT) {
    builder.writeTimeout(genieNetworkConfiguration.getWriteTimeout(),TimeUnit.MILLISECONDS);
  }
  builder.retryOnConnectionFailure(genieNetworkConfiguration.isRetryOnConnectionFailure());
}"
90031,"/** 
 * Constructor that takes the service url and a security interceptor implementation.
 * @param url The url of the Genie Service.
 * @param securityInterceptor An implementation of the Security Interceptor.
 * @param genieNetworkConfiguration  A configuration object that provides network settings for HTTP calls.
 * @throws GenieClientException If there is any problem creating the constructor.
 */
public BaseGenieClient(final String url,final SecurityInterceptor securityInterceptor,final GenieNetworkConfiguration genieNetworkConfiguration) throws GenieClientException {
  if (StringUtils.isBlank(url)) {
    throw new GenieClientException(""String_Node_Str"");
  }
  final OkHttpClient.Builder builder=new OkHttpClient.Builder();
  if (genieNetworkConfiguration != null) {
    addConfigParamsFromConfig(builder,genieNetworkConfiguration);
  }
  mapper=new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
  builder.addInterceptor(new ResponseMappingInterceptor());
  if (securityInterceptor != null) {
    builder.addInterceptor(securityInterceptor);
  }
  final OkHttpClient client=builder.build();
  retrofit=new Retrofit.Builder().baseUrl(url).addConverterFactory(JacksonConverterFactory.create(mapper)).client(client).build();
}","/** 
 * Constructor that takes the service url and a security interceptor implementation.
 * @param url The url of the Genie Service.
 * @param securityInterceptor An implementation of the Security Interceptor.
 * @param genieNetworkConfiguration  A configuration object that provides network settings for HTTP calls.
 * @throws GenieClientException If there is any problem creating the constructor.
 */
public BaseGenieClient(final String url,final SecurityInterceptor securityInterceptor,final GenieNetworkConfiguration genieNetworkConfiguration) throws GenieClientException {
  if (StringUtils.isBlank(url)) {
    throw new GenieClientException(""String_Node_Str"");
  }
  final OkHttpClient.Builder builder=new OkHttpClient.Builder();
  if (genieNetworkConfiguration != null) {
    this.addConfigParamsFromConfig(builder,genieNetworkConfiguration);
  }
  mapper=new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
  builder.addInterceptor(new ResponseMappingInterceptor());
  if (securityInterceptor != null) {
    builder.addInterceptor(securityInterceptor);
  }
  final OkHttpClient client=builder.build();
  retrofit=new Retrofit.Builder().baseUrl(url).addConverterFactory(JacksonConverterFactory.create(mapper)).client(client).build();
}"
90032,"/** 
 * {@inheritDoc}
 */
@Override public Response intercept(final Chain chain) throws IOException {
  final Response response=chain.proceed(chain.request());
  if (response.isSuccessful()) {
    return response;
  }
 else {
    final JsonNode responseBody=mapper.readTree(response.body().string());
    throw new GenieClientException(response.code(),response.message() + ""String_Node_Str"" + responseBody.get(""String_Node_Str""));
  }
}","/** 
 * {@inheritDoc}
 */
@Override public Response intercept(final Chain chain) throws IOException {
  final Response response=chain.proceed(chain.request());
  if (response.isSuccessful()) {
    return response;
  }
 else {
    try {
      final JsonNode responseBody=mapper.readTree(response.body().string());
      throw new GenieClientException(response.code(),response.message() + ""String_Node_Str"" + responseBody.get(""String_Node_Str""));
    }
 catch (    JsonMappingException jme) {
      throw new GenieClientException(response.code(),response.message() + response.body().toString());
    }
  }
}"
90033,"/** 
 * Uploads the job directory to the archive location.
 * @param jobId The job id.
 * @throws GenieException if there is any problem
 */
public void processJobDir(final String jobId) throws GenieException {
  try {
    log.debug(""String_Node_Str"");
    final Job job=this.jobSearchService.getJob(jobId);
    final String jobWorkingDir=this.baseWorkingDir + JobConstants.FILE_PATH_DELIMITER + jobId;
    if (StringUtils.isNotBlank(job.getArchiveLocation())) {
      final String localArchiveFile=jobWorkingDir + JobConstants.FILE_PATH_DELIMITER + ""String_Node_Str""+ jobId+ ""String_Node_Str"";
      final CommandLine commandLine=new CommandLine(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(localArchiveFile);
      commandLine.addArgument(""String_Node_Str"");
      executor.setWorkingDirectory(new File(jobWorkingDir));
      executor.execute(commandLine);
      this.genieFileTransferService.putFile(localArchiveFile,job.getArchiveLocation());
      if (deleteArchiveFile) {
        try {
          new File(localArchiveFile).delete();
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"",jobId,e);
          this.archiveFileDeletionFailure.increment();
        }
      }
    }
    if (deleteDependencies) {
      try {
        final String applicationsDependenciesRegex=jobWorkingDir + JobConstants.FILE_PATH_DELIMITER + ""String_Node_Str"";
        final CommandLine deleteCommand=new CommandLine(""String_Node_Str"");
        deleteCommand.addArgument(""String_Node_Str"");
        deleteCommand.addArgument(""String_Node_Str"");
        deleteCommand.addArgument(applicationsDependenciesRegex);
        executor.execute(deleteCommand);
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"",jobId,e);
        this.deleteDependenciesFailure.increment();
      }
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",jobId,e);
    this.archivalFailureRate.increment();
  }
}","/** 
 * Uploads the job directory to the archive location.
 * @param jobId The job id.
 * @throws GenieException if there is any problem
 */
public void processJobDir(final String jobId) throws GenieException {
  try {
    log.debug(""String_Node_Str"");
    final Job job=this.jobSearchService.getJob(jobId);
    final String jobWorkingDir=this.baseWorkingDir + JobConstants.FILE_PATH_DELIMITER + jobId;
    if (deleteDependencies) {
      try {
        log.debug(""String_Node_Str"");
        final String applicationsDependenciesRegex=jobWorkingDir + JobConstants.FILE_PATH_DELIMITER + ""String_Node_Str"";
        final CommandLine deleteCommand=new CommandLine(""String_Node_Str"");
        deleteCommand.addArgument(""String_Node_Str"");
        deleteCommand.addArgument(""String_Node_Str"");
        deleteCommand.addArgument(applicationsDependenciesRegex);
        log.debug(""String_Node_Str"",deleteCommand.toString());
        executor.execute(deleteCommand);
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"",jobId,e);
        this.deleteDependenciesFailure.increment();
      }
    }
    if (StringUtils.isNotBlank(job.getArchiveLocation())) {
      log.debug(""String_Node_Str"");
      final String localArchiveFile=jobWorkingDir + JobConstants.FILE_PATH_DELIMITER + ""String_Node_Str""+ jobId+ ""String_Node_Str"";
      final CommandLine commandLine=new CommandLine(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(localArchiveFile);
      commandLine.addArgument(""String_Node_Str"");
      executor.setWorkingDirectory(new File(jobWorkingDir));
      log.debug(""String_Node_Str"",commandLine.toString());
      executor.execute(commandLine);
      this.genieFileTransferService.putFile(localArchiveFile,job.getArchiveLocation());
      if (deleteArchiveFile) {
        log.debug(""String_Node_Str"");
        try {
          new File(localArchiveFile).delete();
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"",jobId,e);
          this.archiveFileDeletionFailure.increment();
        }
      }
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",jobId,e);
    this.archivalFailureRate.increment();
  }
}"
90034,"/** 
 * Constructor.
 * @param oauthUrl The url of the IDP from where to get the credentials.
 * @param clientId The clientId to use to get the credentials.
 * @param clientSecret The clientSecret to use to get the credentials.
 * @param grantType The type of the grant.
 * @param scope The scope of the credentials returned.
 * @throws GenieException If there is any problem.
 */
public TokenFetcher(final String oauthUrl,final String clientId,final String clientSecret,final String grantType,final String scope) throws GenieException {
  log.debug(""String_Node_Str"");
  try {
    final URL url=new URL(oauthUrl);
    final String oAuthServer=url.getProtocol() + ""String_Node_Str"" + url.getHost()+ ""String_Node_Str"";
    final Retrofit retrofit=new Retrofit.Builder().baseUrl(oAuthServer).addConverterFactory(JacksonConverterFactory.create()).build();
    this.oauthUrl=oauthUrl;
    tokenService=retrofit.create(TokenService.class);
    credentialParams.put(CLIENT_ID,clientId);
    credentialParams.put(CLIENT_SECRET,clientSecret);
    credentialParams.put(GRANT_TYPE,grantType);
    credentialParams.put(SCOPE,scope);
  }
 catch (  Exception e) {
    throw new GenieServerException(""String_Node_Str"",e);
  }
}","/** 
 * Constructor.
 * @param oauthUrl The url of the IDP from where to get the credentials.
 * @param clientId The clientId to use to get the credentials.
 * @param clientSecret The clientSecret to use to get the credentials.
 * @param grantType The type of the grant.
 * @param scope The scope of the credentials returned.
 * @throws GenieException If there is any problem.
 */
public TokenFetcher(final String oauthUrl,final String clientId,final String clientSecret,final String grantType,final String scope) throws GenieException {
  log.debug(""String_Node_Str"");
  if (StringUtils.isBlank(oauthUrl)) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(clientId)) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(clientSecret)) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(grantType)) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(scope)) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  try {
    final URL url=new URL(oauthUrl);
    final String oAuthServerUrl=url.getProtocol() + ""String_Node_Str"" + url.getHost()+ ""String_Node_Str"";
    final Retrofit retrofit=new Retrofit.Builder().baseUrl(oAuthServerUrl).addConverterFactory(JacksonConverterFactory.create()).build();
    this.oauthUrl=oauthUrl;
    tokenService=retrofit.create(TokenService.class);
    credentialParams.put(CLIENT_ID,clientId);
    credentialParams.put(CLIENT_SECRET,clientSecret);
    credentialParams.put(GRANT_TYPE,grantType);
    credentialParams.put(SCOPE,scope);
  }
 catch (  Exception e) {
    throw new GenieException(400,""String_Node_Str"",e);
  }
}"
90035,"/** 
 * Method to test submitting a job.
 * @throws Exception If there is any problem.
 */
@Ignore @Test public void canSubmitJob() throws Exception {
  final String jobId=UUID.randomUUID().toString();
  final Set<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  final Cluster cluster=new Cluster.Builder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ClusterStatus.UP).withTags(tags).withId(""String_Node_Str"").build();
  clusterClient.createCluster(cluster);
  tags.clear();
  tags.add(""String_Node_Str"");
  final Command command=new Command.Builder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",CommandStatus.ACTIVE,""String_Node_Str"",1000).withId(""String_Node_Str"").withTags(tags).build();
  commandClient.createCommand(command);
  clusterClient.addCommandsToCluster(cluster.getId(),Arrays.asList(command.getId()));
  final String clusterTag=""String_Node_Str"";
  final List<ClusterCriteria> clusterCriteriaList=Lists.newArrayList(new ClusterCriteria(Sets.newHashSet(clusterTag)));
  final String commandTag=""String_Node_Str"";
  final Set<String> commandCriteria=Sets.newHashSet(commandTag);
  final JobRequest jobRequest=new JobRequest.Builder(JOB_NAME,JOB_USER,JOB_VERSION,""String_Node_Str"",clusterCriteriaList,commandCriteria).withId(jobId).withDisableLogArchival(true).withDescription(JOB_DESCRIPTION).build();
  final String id=jobClient.submitJob(jobRequest);
  final Job job=jobClient.getJob(id);
  Assert.assertEquals(jobId,job.getId());
  final JobRequest jobRequest1=jobClient.getJobRequest(jobId);
  Assert.assertEquals(jobId,jobRequest1.getId());
  final JobExecution jobExecution=jobClient.getJobExecution(jobId);
  Assert.assertEquals(jobId,jobExecution.getId());
}","/** 
 * Method to test submitting a job.
 * @throws Exception If there is any problem.
 */
@Ignore @Test public void canSubmitJob() throws Exception {
  final String jobId=UUID.randomUUID().toString();
  final Set<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  final Cluster cluster=new Cluster.Builder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ClusterStatus.UP).withTags(tags).withId(""String_Node_Str"").build();
  clusterClient.createCluster(cluster);
  tags.clear();
  tags.add(""String_Node_Str"");
  final Command command=new Command.Builder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",CommandStatus.ACTIVE,""String_Node_Str"",1000).withId(""String_Node_Str"").withTags(tags).build();
  commandClient.createCommand(command);
  clusterClient.addCommandsToCluster(cluster.getId(),Arrays.asList(command.getId()));
  final String clusterTag=""String_Node_Str"";
  final List<ClusterCriteria> clusterCriteriaList=Lists.newArrayList(new ClusterCriteria(Sets.newHashSet(clusterTag)));
  final String commandTag=""String_Node_Str"";
  final Set<String> commandCriteria=Sets.newHashSet(commandTag);
  final JobRequest jobRequest=new JobRequest.Builder(JOB_NAME,JOB_USER,JOB_VERSION,""String_Node_Str"",clusterCriteriaList,commandCriteria).withId(jobId).withDisableLogArchival(true).withDescription(JOB_DESCRIPTION).build();
  final String id=jobClient.submitJob(jobRequest);
  final JobStatus jobStatus=jobClient.waitForCompletion(jobId,600000,5000);
  Assert.assertEquals(JobStatus.SUCCEEDED,jobStatus);
  final Job job=jobClient.getJob(id);
  Assert.assertEquals(jobId,job.getId());
  final JobRequest jobRequest1=jobClient.getJobRequest(jobId);
  Assert.assertEquals(jobId,jobRequest1.getId());
  final JobExecution jobExecution=jobClient.getJobExecution(jobId);
  Assert.assertEquals(jobId,jobExecution.getId());
  final InputStream inputStream1=jobClient.getJobStdout(jobId);
  final BufferedReader reader1=new BufferedReader(new InputStreamReader(inputStream1,""String_Node_Str""));
  final StringBuilder sb=new StringBuilder();
  String line;
  while ((line=reader1.readLine()) != null) {
    sb.append(line);
  }
  reader1.close();
  inputStream1.close();
  Assert.assertEquals(""String_Node_Str"",sb.toString());
}"
90036,"/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException, IOException {
  log.debug(""String_Node_Str"");
  super.executeTask(context);
  super.createDirectory(this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_PATH_VAR);
  super.createDirectory(this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.LOGS_PATH_VAR);
  super.createDirectory(this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.APPLICATION_PATH_VAR);
  super.createDirectory(this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.COMMAND_PATH_VAR);
  super.createDirectory(this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.CLUSTER_PATH_VAR);
  writer.write(JobConstants.EXPORT + JobConstants.GENIE_JOB_DIR_ENV_VAR + JobConstants.EQUALS_SYMBOL+ this.jobWorkingDirectory+ System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(JobConstants.EXPORT + JobConstants.GENIE_APPLICATION_DIR_ENV_VAR + JobConstants.EQUALS_SYMBOL+ ""String_Node_Str""+ JobConstants.GENIE_JOB_DIR_ENV_VAR+ ""String_Node_Str""+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.APPLICATION_PATH_VAR+ System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(JobConstants.EXPORT + JobConstants.GENIE_COMMAND_DIR_ENV_VAR + JobConstants.EQUALS_SYMBOL+ ""String_Node_Str""+ JobConstants.GENIE_JOB_DIR_ENV_VAR+ ""String_Node_Str""+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.COMMAND_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ this.jobExecEnv.getCommand().getId()+ System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(JobConstants.EXPORT + JobConstants.GENIE_CLUSTER_DIR_ENV_VAR + JobConstants.EQUALS_SYMBOL+ ""String_Node_Str""+ JobConstants.GENIE_JOB_DIR_ENV_VAR+ ""String_Node_Str""+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.CLUSTER_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ this.jobExecEnv.getCluster().getId()+ System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(JobConstants.EXPORT + JobConstants.GENIE_JOB_ID_ENV_VAR + JobConstants.EQUALS_SYMBOL+ this.jobExecEnv.getJobRequest().getId()+ System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(JobConstants.EXPORT + JobConstants.GENIE_JOB_NAME_ENV_VAR + JobConstants.EQUALS_SYMBOL+ this.jobExecEnv.getJobRequest().getName()+ System.lineSeparator());
  writer.write(System.lineSeparator());
}","/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException, IOException {
  log.debug(""String_Node_Str"");
  super.executeTask(context);
  super.createDirectory(this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_PATH_VAR);
  super.createDirectory(this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.LOGS_PATH_VAR);
  super.createDirectory(this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.APPLICATION_PATH_VAR);
  super.createDirectory(this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.COMMAND_PATH_VAR);
  super.createDirectory(this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.CLUSTER_PATH_VAR);
  writer.write(JobConstants.EXPORT + JobConstants.GENIE_JOB_DIR_ENV_VAR + JobConstants.EQUALS_SYMBOL+ JobConstants.DOUBLE_QUOTE_SYMBOL+ this.jobWorkingDirectory+ JobConstants.DOUBLE_QUOTE_SYMBOL+ System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(JobConstants.EXPORT + JobConstants.GENIE_APPLICATION_DIR_ENV_VAR + JobConstants.EQUALS_SYMBOL+ JobConstants.DOUBLE_QUOTE_SYMBOL+ ""String_Node_Str""+ JobConstants.GENIE_JOB_DIR_ENV_VAR+ ""String_Node_Str""+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.APPLICATION_PATH_VAR+ JobConstants.DOUBLE_QUOTE_SYMBOL+ System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(JobConstants.EXPORT + JobConstants.GENIE_COMMAND_DIR_ENV_VAR + JobConstants.EQUALS_SYMBOL+ JobConstants.DOUBLE_QUOTE_SYMBOL+ ""String_Node_Str""+ JobConstants.GENIE_JOB_DIR_ENV_VAR+ ""String_Node_Str""+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.COMMAND_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ this.jobExecEnv.getCommand().getId()+ JobConstants.DOUBLE_QUOTE_SYMBOL+ System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(JobConstants.EXPORT + JobConstants.GENIE_CLUSTER_DIR_ENV_VAR + JobConstants.EQUALS_SYMBOL+ JobConstants.DOUBLE_QUOTE_SYMBOL+ ""String_Node_Str""+ JobConstants.GENIE_JOB_DIR_ENV_VAR+ ""String_Node_Str""+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.GENIE_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ JobConstants.CLUSTER_PATH_VAR+ JobConstants.FILE_PATH_DELIMITER+ this.jobExecEnv.getCluster().getId()+ JobConstants.DOUBLE_QUOTE_SYMBOL+ System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(JobConstants.EXPORT + JobConstants.GENIE_JOB_ID_ENV_VAR + JobConstants.EQUALS_SYMBOL+ JobConstants.DOUBLE_QUOTE_SYMBOL+ this.jobExecEnv.getJobRequest().getId()+ JobConstants.DOUBLE_QUOTE_SYMBOL+ System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(JobConstants.EXPORT + JobConstants.GENIE_JOB_NAME_ENV_VAR + JobConstants.EQUALS_SYMBOL+ JobConstants.DOUBLE_QUOTE_SYMBOL+ this.jobExecEnv.getJobRequest().getName()+ JobConstants.DOUBLE_QUOTE_SYMBOL+ System.lineSeparator());
  writer.write(System.lineSeparator());
}"
90037,"/** 
 * {@inheritDoc}
 */
@Override public void createJobExecution(@NotNull(message=""String_Node_Str"") final JobExecution jobExecution) throws GenieException {
  log.debug(""String_Node_Str"",jobExecution);
  if (StringUtils.isBlank(jobExecution.getId())) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  final JobEntity jobEntity=jobRepo.findOne(jobExecution.getId());
  if (jobEntity == null) {
    throw new GenieNotFoundException(""String_Node_Str"");
  }
  final JobExecutionEntity jobExecutionEntity=new JobExecutionEntity();
  jobExecutionEntity.setId(jobExecution.getId());
  jobExecutionEntity.setHostName(jobExecution.getHostName());
  jobExecutionEntity.setProcessId(jobExecution.getProcessId());
  jobExecutionEntity.setCheckDelay(jobExecution.getCheckDelay());
  jobExecutionEntity.setTimeout(jobExecution.getTimeout());
  jobEntity.setExecution(jobExecutionEntity);
  jobEntity.setStatus(JobStatus.RUNNING);
  jobEntity.setStatusMsg(""String_Node_Str"");
  jobEntity.setStarted(new Date());
}","/** 
 * {@inheritDoc}
 */
@Override public void createJobExecution(@NotNull(message=""String_Node_Str"") final JobExecution jobExecution) throws GenieException {
  log.debug(""String_Node_Str"",jobExecution);
  if (StringUtils.isBlank(jobExecution.getId())) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  this.updateJobStatus(jobExecution.getId(),JobStatus.RUNNING,""String_Node_Str"");
  final JobEntity jobEntity=jobRepo.findOne(jobExecution.getId());
  if (jobEntity == null) {
    throw new GenieNotFoundException(""String_Node_Str"");
  }
  final JobExecutionEntity jobExecutionEntity=new JobExecutionEntity();
  jobExecutionEntity.setId(jobExecution.getId());
  jobExecutionEntity.setHostName(jobExecution.getHostName());
  jobExecutionEntity.setProcessId(jobExecution.getProcessId());
  jobExecutionEntity.setCheckDelay(jobExecution.getCheckDelay());
  jobExecutionEntity.setTimeout(jobExecution.getTimeout());
  jobEntity.setExecution(jobExecutionEntity);
}"
90038,"/** 
 * {@inheritDoc}
 */
@Override public void updateJobStatus(@NotBlank(message=""String_Node_Str"") final String id,@NotNull(message=""String_Node_Str"") final JobStatus jobStatus,@NotBlank(message=""String_Node_Str"") final String statusMsg) throws GenieException {
  log.debug(""String_Node_Str"",id,jobStatus,statusMsg);
  final JobEntity jobEntity=this.jobRepo.findOne(id);
  if (jobEntity == null) {
    throw new GenieNotFoundException(""String_Node_Str"");
  }
  jobEntity.setStatus(jobStatus);
  jobEntity.setStatusMsg(statusMsg);
  if (jobStatus.equals(JobStatus.KILLED) || jobStatus.equals(JobStatus.FAILED) || jobStatus.equals(JobStatus.SUCCEEDED)) {
    jobEntity.setFinished(new Date());
  }
  this.jobRepo.save(jobEntity);
}","/** 
 * {@inheritDoc}
 */
@Override public void updateJobStatus(@NotBlank(message=""String_Node_Str"") final String id,@NotNull(message=""String_Node_Str"") final JobStatus jobStatus,@NotBlank(message=""String_Node_Str"") final String statusMsg) throws GenieException {
  log.debug(""String_Node_Str"",id,jobStatus,statusMsg);
  final JobEntity jobEntity=this.jobRepo.findOne(id);
  if (jobEntity == null) {
    throw new GenieNotFoundException(""String_Node_Str"");
  }
  jobEntity.setStatus(jobStatus);
  jobEntity.setStatusMsg(statusMsg);
  if (jobStatus.equals(JobStatus.RUNNING)) {
    jobEntity.setStarted(new Date());
  }
 else   if (jobEntity.getStarted() != null && (jobStatus.equals(JobStatus.KILLED) || jobStatus.equals(JobStatus.FAILED) || jobStatus.equals(JobStatus.SUCCEEDED))) {
    jobEntity.setFinished(new Date());
  }
  this.jobRepo.save(jobEntity);
}"
90039,"/** 
 * {@inheritDoc}
 */
@Override public void addCommandsForCluster(@NotBlank(message=""String_Node_Str"") final String id,@NotEmpty(message=""String_Node_Str"") final List<String> commandIds) throws GenieException {
  final ClusterEntity clusterEntity=this.findCluster(id);
  for (  final String commandId : commandIds) {
    final CommandEntity cmd=this.commandRepo.findOne(commandId);
    if (cmd != null) {
      clusterEntity.addCommand(cmd);
    }
 else {
      throw new GenieNotFoundException(""String_Node_Str"" + commandId + ""String_Node_Str"");
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void addCommandsForCluster(@NotBlank(message=""String_Node_Str"") final String id,@NotEmpty(message=""String_Node_Str"") final List<String> commandIds) throws GenieException {
  final ClusterEntity clusterEntity=this.findCluster(id);
  final Set<String> resultCommandIds=clusterEntity.getCommands().stream().map(CommandEntity::getId).collect(Collectors.toSet());
  for (  final String commandId : commandIds) {
    if (resultCommandIds.contains(commandId)) {
      throw new GeniePreconditionException(""String_Node_Str"" + commandId + ""String_Node_Str"");
    }
    final CommandEntity cmd=this.commandRepo.findOne(commandId);
    if (cmd != null) {
      clusterEntity.addCommand(cmd);
      resultCommandIds.add(commandId);
    }
 else {
      throw new GenieNotFoundException(""String_Node_Str"" + commandId + ""String_Node_Str"");
    }
  }
}"
90040,"/** 
 * {@inheritDoc}
 */
@Override @Transactional(readOnly=true) public List<com.netflix.genie.common.dto.Command> getCommandsForCluster(@NotBlank(message=""String_Node_Str"") final String id,final Set<CommandStatus> statuses) throws GenieException {
  final ClusterEntity clusterEntity=this.findCluster(id);
  final List<CommandEntity> commandEntities=clusterEntity.getCommands();
  if (statuses != null) {
    return commandEntities.stream().filter(command -> statuses.contains(command.getStatus())).map(CommandEntity::getDTO).collect(Collectors.toList());
  }
 else {
    return commandEntities.stream().map(CommandEntity::getDTO).collect(Collectors.toList());
  }
}","/** 
 * {@inheritDoc}
 */
@Override @Transactional(readOnly=true) public List<Command> getCommandsForCluster(@NotBlank(message=""String_Node_Str"") final String id,final Set<CommandStatus> statuses) throws GenieException {
  final ClusterEntity clusterEntity=this.findCluster(id);
  final List<CommandEntity> commandEntities=clusterEntity.getCommands();
  if (statuses != null) {
    return commandEntities.stream().filter(command -> statuses.contains(command.getStatus())).map(CommandEntity::getDTO).collect(Collectors.toList());
  }
 else {
    return commandEntities.stream().map(CommandEntity::getDTO).collect(Collectors.toList());
  }
}"
90041,"/** 
 * {@inheritDoc}
 */
@Override public void updateCommandsForCluster(@NotBlank(message=""String_Node_Str"") final String id,@NotNull(message=""String_Node_Str"") final List<String> commandIds) throws GenieException {
  final ClusterEntity clusterEntity=this.findCluster(id);
  final List<CommandEntity> commandEntities=new ArrayList<>();
  for (  final String commandId : commandIds) {
    final CommandEntity cmd=this.commandRepo.findOne(commandId);
    if (cmd != null) {
      commandEntities.add(cmd);
    }
 else {
      throw new GenieNotFoundException(""String_Node_Str"" + commandId + ""String_Node_Str"");
    }
  }
  clusterEntity.setCommands(commandEntities);
}","/** 
 * {@inheritDoc}
 */
@Override public void updateCommandsForCluster(@NotBlank(message=""String_Node_Str"") final String id,@NotNull(message=""String_Node_Str"") final List<String> commandIds) throws GenieException {
  final ClusterEntity clusterEntity=this.findCluster(id);
  final List<CommandEntity> commandEntities=new ArrayList<>();
  final Set<String> currentIds=new HashSet<>();
  for (  final String commandId : commandIds) {
    if (currentIds.contains(commandId)) {
      throw new GeniePreconditionException(""String_Node_Str"" + commandId + ""String_Node_Str"");
    }
    final CommandEntity cmd=this.commandRepo.findOne(commandId);
    if (cmd != null) {
      currentIds.add(commandId);
      commandEntities.add(cmd);
    }
 else {
      throw new GenieNotFoundException(""String_Node_Str"" + commandId + ""String_Node_Str"");
    }
  }
  clusterEntity.setCommands(commandEntities);
}"
90042,"/** 
 * {@inheritDoc}
 */
@Override public void addApplicationsForCommand(@NotBlank(message=""String_Node_Str"") final String id,@NotEmpty(message=""String_Node_Str"") final List<String> applicationIds) throws GenieException {
  if (applicationIds.size() != applicationIds.stream().filter(this.appRepo::exists).count()) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  final CommandEntity commandEntity=this.findCommand(id);
  applicationIds.stream().forEach(applicationId -> commandEntity.getApplications().add(this.appRepo.findOne(applicationId)));
}","/** 
 * {@inheritDoc}
 */
@Override public void addApplicationsForCommand(@NotBlank(message=""String_Node_Str"") final String id,@NotEmpty(message=""String_Node_Str"") final List<String> applicationIds) throws GenieException {
  if (applicationIds.size() != applicationIds.stream().filter(this.appRepo::exists).count()) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  final CommandEntity commandEntity=this.findCommand(id);
  final Set<String> resultApplicationIds=commandEntity.getApplications().stream().map(ApplicationEntity::getId).collect(Collectors.toSet());
  for (  final String applicationId : applicationIds) {
    if (resultApplicationIds.contains(applicationId)) {
      throw new GeniePreconditionException(""String_Node_Str"" + id + ""String_Node_Str"");
    }
    commandEntity.getApplications().add(this.appRepo.findOne(applicationId));
    resultApplicationIds.add(id);
  }
}"
90043,"/** 
 * Constructor.
 * @param hostName         The name of the host this Genie node is running on
 * @param jobSearchService The job search service to use to locate job information
 * @param executor         The executor to use to run system processes
 */
public LocalJobKillServiceImpl(@NotBlank final String hostName,@NotNull final JobSearchService jobSearchService,@NotNull final Executor executor){
  this.hostName=hostName;
  this.jobSearchService=jobSearchService;
  this.executor=executor;
}","/** 
 * Constructor.
 * @param hostName         The name of the host this Genie node is running on
 * @param jobSearchService The job search service to use to locate job information
 * @param executor         The executor to use to run system processes
 * @param runAsUser        True if jobs are run as the user who submitted the job
 */
public LocalJobKillServiceImpl(@NotBlank final String hostName,@NotNull final JobSearchService jobSearchService,@NotNull final Executor executor,final boolean runAsUser){
  this.hostName=hostName;
  this.jobSearchService=jobSearchService;
  this.executor=executor;
  this.runAsUser=runAsUser;
}"
90044,"private void killJobOnUnix(final int pid) throws GenieException {
  try {
    final Calendar tomorrow=Calendar.getInstance(JobConstants.UTC);
    tomorrow.add(Calendar.DAY_OF_YEAR,1);
    final ProcessChecker processChecker=new UnixProcessChecker(pid,this.executor,tomorrow.getTime());
    processChecker.checkProcess();
  }
 catch (  final ExecuteException ee) {
    log.debug(""String_Node_Str"",pid);
    return;
  }
catch (  final IOException ioe) {
    throw new GenieServerException(""String_Node_Str"" + pid,ioe);
  }
  try {
    final CommandLine killCommand=new CommandLine(""String_Node_Str"");
    killCommand.addArguments(Integer.toString(pid));
    this.executor.execute(killCommand);
  }
 catch (  final IOException ioe) {
    throw new GenieServerException(""String_Node_Str"" + pid,ioe);
  }
}","private void killJobOnUnix(final int pid) throws GenieException {
  try {
    final Calendar tomorrow=Calendar.getInstance(JobConstants.UTC);
    tomorrow.add(Calendar.DAY_OF_YEAR,1);
    final ProcessChecker processChecker=new UnixProcessChecker(pid,this.executor,tomorrow.getTime());
    processChecker.checkProcess();
  }
 catch (  final ExecuteException ee) {
    log.debug(""String_Node_Str"",pid);
    return;
  }
catch (  final IOException ioe) {
    throw new GenieServerException(""String_Node_Str"" + pid,ioe);
  }
  try {
    final CommandLine killCommand;
    if (this.runAsUser) {
      killCommand=new CommandLine(""String_Node_Str"");
      killCommand.addArgument(""String_Node_Str"");
    }
 else {
      killCommand=new CommandLine(""String_Node_Str"");
    }
    killCommand.addArguments(Integer.toString(pid));
    this.executor.execute(killCommand);
  }
 catch (  final IOException ioe) {
    throw new GenieServerException(""String_Node_Str"" + pid,ioe);
  }
}"
90045,"/** 
 * Get an local implementation of the JobKillService.
 * @param hostname         The name of the host this Genie node is running on.
 * @param jobSearchService The job search service to use to locate job information.
 * @param executor         The executor to use to run system processes.
 * @return A job kill service instance.
 */
@Bean public JobKillService jobKillService(final String hostname,final JobSearchService jobSearchService,final Executor executor){
  return new LocalJobKillServiceImpl(hostname,jobSearchService,executor);
}","/** 
 * Get an local implementation of the JobKillService.
 * @param hostname         The name of the host this Genie node is running on.
 * @param jobSearchService The job search service to use to locate job information.
 * @param executor         The executor to use to run system processes.
 * @return A job kill service instance.
 */
@Bean public JobKillService jobKillService(final String hostname,final JobSearchService jobSearchService,final Executor executor){
  return new LocalJobKillServiceImpl(hostname,jobSearchService,executor,false);
}"
90046,"/** 
 * Setup for the tests.
 */
@Before public void setup(){
  Assume.assumeTrue(SystemUtils.IS_OS_UNIX);
  this.jobSearchService=Mockito.mock(JobSearchService.class);
  this.executor=Mockito.mock(Executor.class);
  this.service=new LocalJobKillServiceImpl(HOSTNAME,this.jobSearchService,this.executor);
  this.killCommand=new CommandLine(""String_Node_Str"");
  this.killCommand.addArguments(Integer.toString(PID));
  this.psCommand=new CommandLine(""String_Node_Str"");
  this.psCommand.addArgument(""String_Node_Str"");
  this.psCommand.addArgument(Integer.toString(PID));
}","/** 
 * Setup for the tests.
 */
@Before public void setup(){
  Assume.assumeTrue(SystemUtils.IS_OS_UNIX);
  this.jobSearchService=Mockito.mock(JobSearchService.class);
  this.executor=Mockito.mock(Executor.class);
  this.service=new LocalJobKillServiceImpl(HOSTNAME,this.jobSearchService,this.executor,false);
  this.killCommand=new CommandLine(""String_Node_Str"");
  this.killCommand.addArguments(Integer.toString(PID));
}"
90047,"/** 
 * Returns a bean for mail service impl using the Spring Mail.
 * @param javaMailSender An implementation of the JavaMailSender interface.
 * @param fromAddress    The from email address for the email.
 * @param mailUser       The userid of the account used to send email.
 * @param mailPassword   The password of the account used to send email.
 * @return An instance of MailService implementation.
 * @throws GenieException If there is any problem.
 */
@Bean @ConditionalOnBean(JavaMailSender.class) public MailService getJavaMailSenderMailService(final JavaMailSender javaMailSender,@Value(""String_Node_Str"") final String fromAddress,@Value(""String_Node_Str"") final String mailUser,@Value(""String_Node_Str"") final String mailPassword) throws GenieException {
  return new MailServiceImpl(javaMailSender,fromAddress,mailUser,mailPassword);
}","/** 
 * Returns a bean for mail service impl using the Spring Mail.
 * @param javaMailSender An implementation of the JavaMailSender interface.
 * @param fromAddress    The from email address for the email.
 * @param mailUser       The userid of the account used to send email.
 * @param mailPassword   The password of the account used to send email.
 * @return An instance of MailService implementation.
 * @throws GenieException If there is any problem.
 */
@Bean @ConditionalOnProperty(""String_Node_Str"") public MailService getJavaMailSenderMailService(final JavaMailSender javaMailSender,@Value(""String_Node_Str"") final String fromAddress,@Value(""String_Node_Str"") final String mailUser,@Value(""String_Node_Str"") final String mailPassword) throws GenieException {
  return new MailServiceImpl(javaMailSender,fromAddress,mailUser,mailPassword);
}"
90048,"/** 
 * Get an instance of the JobCoordinatorService.
 * @param jobPersistenceService implementation of job persistence service interface
 * @param jobSearchService      implementation of job search service interface
 * @param jobSubmitterService   implementation of the job submitter service
 * @param jobKillService        The job kill service to use
 * @param baseArchiveLocation   The base directory location of where the job dir should be archived
 * @return An instance of the JobCoordinatorService.
 */
@Bean public JobCoordinatorService jobCoordinatorService(final JobPersistenceService jobPersistenceService,final JobSearchService jobSearchService,final JobSubmitterService jobSubmitterService,final JobKillService jobKillService,@Value(""String_Node_Str"") final String baseArchiveLocation){
  return new JobCoordinatorService(jobPersistenceService,jobSubmitterService,jobKillService,baseArchiveLocation);
}","/** 
 * Get an instance of the JobCoordinatorService.
 * @param jobPersistenceService implementation of job persistence service interface
 * @param jobSubmitterService   implementation of the job submitter service
 * @param jobKillService        The job kill service to use
 * @param baseArchiveLocation   The base directory location of where the job dir should be archived
 * @return An instance of the JobCoordinatorService.
 */
@Bean public JobCoordinatorService jobCoordinatorService(final JobPersistenceService jobPersistenceService,final JobSubmitterService jobSubmitterService,final JobKillService jobKillService,@Value(""String_Node_Str"") final String baseArchiveLocation){
  return new JobCoordinatorService(jobPersistenceService,jobSubmitterService,jobKillService,baseArchiveLocation);
}"
90049,"/** 
 * Get an local implementation of the JobKillService.
 * @param hostName         The name of the host this Genie node is running on.
 * @param jobSearchService The job search service to use to locate job information.
 * @param executor         The executor to use to run system processes.
 * @return A job kill service instance.
 */
@Bean public JobKillService jobKillService(final String hostName,final JobSearchService jobSearchService,final Executor executor){
  return new LocalJobKillServiceImpl(hostName,jobSearchService,executor);
}","/** 
 * Get an local implementation of the JobKillService.
 * @param hostName         The name of the host this Genie node is running on.
 * @param jobSearchService The job search service to use to locate job information.
 * @param executor         The executor to use to run system processes.
 * @param runAsUser        Whether jobs on this instance are run as the user or not
 * @return A job kill service instance.
 */
@Bean public JobKillService jobKillService(final String hostName,final JobSearchService jobSearchService,final Executor executor,@Value(""String_Node_Str"") final boolean runAsUser){
  return new LocalJobKillServiceImpl(hostName,jobSearchService,executor,runAsUser);
}"
90050,"/** 
 * Can get a bean for Job Coordinator Service.
 */
@Test public void canGetJobCoordinatorServiceBean(){
  final JobPersistenceService jobPersistenceService=Mockito.mock(JobPersistenceService.class);
  final JobSubmitterService jobSubmitterService=Mockito.mock(JobSubmitterService.class);
  final JobKillService jobKillService=Mockito.mock(JobKillService.class);
  Assert.assertNotNull(this.servicesConfig.jobCoordinatorService(jobPersistenceService,this.jobSearchService,jobSubmitterService,jobKillService,""String_Node_Str""));
}","/** 
 * Can get a bean for Job Coordinator Service.
 */
@Test public void canGetJobCoordinatorServiceBean(){
  final JobPersistenceService jobPersistenceService=Mockito.mock(JobPersistenceService.class);
  final JobSubmitterService jobSubmitterService=Mockito.mock(JobSubmitterService.class);
  final JobKillService jobKillService=Mockito.mock(JobKillService.class);
  Assert.assertNotNull(this.servicesConfig.jobCoordinatorService(jobPersistenceService,jobSubmitterService,jobKillService,""String_Node_Str""));
}"
90051,"/** 
 * Can get a bean for Job Kill Service.
 */
@Test public void canGetJobKillServiceBean(){
  Assert.assertNotNull(this.servicesConfig.jobKillService(""String_Node_Str"",this.jobSearchService,Mockito.mock(Executor.class)));
}","/** 
 * Can get a bean for Job Kill Service.
 */
@Test public void canGetJobKillServiceBean(){
  Assert.assertNotNull(this.servicesConfig.jobKillService(""String_Node_Str"",this.jobSearchService,Mockito.mock(Executor.class),true));
}"
90052,"/** 
 * Method to test submitting a job.
 * @throws Exception If there is any problem.
 */
@Test public void canSubmitJob() throws Exception {
  final String jobId=UUID.randomUUID().toString();
  final Set<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  final Cluster cluster=new Cluster.Builder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ClusterStatus.UP).withTags(tags).withId(""String_Node_Str"").build();
  clusterClient.createCluster(cluster);
  tags.clear();
  tags.add(""String_Node_Str"");
  final Command command=new Command.Builder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",CommandStatus.ACTIVE,""String_Node_Str"",1000).withId(""String_Node_Str"").withTags(tags).build();
  commandClient.createCommand(command);
  clusterClient.addCommandsToCluster(cluster.getId(),Arrays.asList(command.getId()));
  final String clusterTag=""String_Node_Str"";
  final List<ClusterCriteria> clusterCriteriaList=Lists.newArrayList(new ClusterCriteria(Sets.newHashSet(clusterTag)));
  final String commandTag=""String_Node_Str"";
  final Set<String> commandCriteria=Sets.newHashSet(commandTag);
  final JobRequest jobRequest=new JobRequest.Builder(JOB_NAME,JOB_USER,JOB_VERSION,""String_Node_Str"",clusterCriteriaList,commandCriteria).withId(jobId).withDisableLogArchival(true).withDescription(JOB_DESCRIPTION).build();
  final String id=jobClient.submitJob(jobRequest);
  final JobStatus jobStatus=jobClient.waitForCompletion(jobId,600000,5000);
  Assert.assertEquals(JobStatus.SUCCEEDED,jobStatus);
  final Job job=jobClient.getJob(id);
  Assert.assertEquals(jobId,job.getId());
  final JobRequest jobRequest1=jobClient.getJobRequest(jobId);
  Assert.assertEquals(jobId,jobRequest1.getId());
  final JobExecution jobExecution=jobClient.getJobExecution(jobId);
  Assert.assertEquals(jobId,jobExecution.getId());
  final InputStream inputStream1=jobClient.getJobStdout(jobId);
  final BufferedReader reader1=new BufferedReader(new InputStreamReader(inputStream1,""String_Node_Str""));
  final StringBuilder sb=new StringBuilder();
  String line;
  while ((line=reader1.readLine()) != null) {
    sb.append(line);
  }
  reader1.close();
  inputStream1.close();
  Assert.assertEquals(""String_Node_Str"",sb.toString());
}","/** 
 * Method to test submitting a job.
 * @throws Exception If there is any problem.
 */
@Test public void canSubmitJob() throws Exception {
  final String jobId=UUID.randomUUID().toString();
  final Set<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  final Cluster cluster=new Cluster.Builder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ClusterStatus.UP).withTags(tags).withId(""String_Node_Str"").build();
  clusterClient.createCluster(cluster);
  tags.clear();
  tags.add(""String_Node_Str"");
  final Command command=new Command.Builder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",CommandStatus.ACTIVE,""String_Node_Str"",1000).withId(""String_Node_Str"").withTags(tags).build();
  commandClient.createCommand(command);
  clusterClient.addCommandsToCluster(cluster.getId(),Arrays.asList(command.getId()));
  final String clusterTag=""String_Node_Str"";
  final List<ClusterCriteria> clusterCriteriaList=Lists.newArrayList(new ClusterCriteria(Sets.newHashSet(clusterTag)));
  final String commandTag=""String_Node_Str"";
  final Set<String> commandCriteria=Sets.newHashSet(commandTag);
  final JobRequest jobRequest=new JobRequest.Builder(JOB_NAME,JOB_USER,JOB_VERSION,""String_Node_Str"",clusterCriteriaList,commandCriteria).withId(jobId).withDisableLogArchival(true).withDescription(JOB_DESCRIPTION).build();
  final String id=jobClient.submitJob(jobRequest);
  final Job job=jobClient.getJob(id);
  Assert.assertEquals(jobId,job.getId());
  final JobRequest jobRequest1=jobClient.getJobRequest(jobId);
  Assert.assertEquals(jobId,jobRequest1.getId());
  final JobExecution jobExecution=jobClient.getJobExecution(jobId);
  Assert.assertEquals(jobId,jobExecution.getId());
}"
90053,"/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException, IOException {
  log.info(""String_Node_Str"");
  super.executeTask(context);
  try {
    writer.flush();
    writer.close();
  }
 catch (  IOException e) {
    throw new GenieServerException(""String_Node_Str"" + e);
  }
  final String runScript=this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_JOB_LAUNCHER_SCRIPT;
  if (this.isUserCreationEnabled) {
    createUser(this.jobExecEnv.getJobRequest().getUser(),this.jobExecEnv.getJobRequest().getGroup());
  }
  final List<String> command=new ArrayList<>();
  if (this.isRunAsUserEnabled) {
    changeOwnershipOfDirectory(this.jobWorkingDirectory,this.jobExecEnv.getJobRequest().getUser());
    command.add(""String_Node_Str"");
    command.add(""String_Node_Str"");
    command.add(this.jobExecEnv.getJobRequest().getUser());
  }
  if (SystemUtils.IS_OS_LINUX) {
    command.add(""String_Node_Str"");
  }
  command.add(""String_Node_Str"");
  command.add(runScript);
  final ProcessBuilder pb=new ProcessBuilder(command);
  pb.directory(this.jobExecEnv.getJobWorkingDir());
  pb.redirectOutput(new File(this.jobExecEnv.getJobWorkingDir() + JobConstants.GENIE_LOG_PATH));
  pb.redirectError(new File(this.jobExecEnv.getJobWorkingDir() + JobConstants.GENIE_LOG_PATH));
  try {
    final Process process=pb.start();
    final int processId=this.getProcessId(process);
    final JobRequest request=this.jobExecEnv.getJobRequest();
    final Calendar calendar=Calendar.getInstance(UTC);
    calendar.add(Calendar.SECOND,request.getTimeout());
    final JobExecution jobExecution=new JobExecution.Builder(this.hostname,processId,this.jobExecEnv.getCommand().getCheckDelay(),calendar.getTime()).withId(request.getId()).build();
    context.put(JobConstants.JOB_EXECUTION_DTO_KEY,jobExecution);
  }
 catch (  IOException ie) {
    throw new GenieServerException(""String_Node_Str"" + String.valueOf(command),ie);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException, IOException {
  log.info(""String_Node_Str"");
  super.executeTask(context);
  try {
    writer.flush();
    writer.close();
  }
 catch (  IOException e) {
    throw new GenieServerException(""String_Node_Str"" + e);
  }
  final String runScript=this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + JobConstants.GENIE_JOB_LAUNCHER_SCRIPT;
  if (this.isUserCreationEnabled) {
    createUser(this.jobExecEnv.getJobRequest().getUser(),this.jobExecEnv.getJobRequest().getGroup());
  }
  final List<String> command=new ArrayList<>();
  if (this.isRunAsUserEnabled) {
    changeOwnershipOfDirectory(this.jobWorkingDirectory,this.jobExecEnv.getJobRequest().getUser());
    makeDirGroupWritable(this.jobWorkingDirectory + ""String_Node_Str"");
    command.add(""String_Node_Str"");
    command.add(""String_Node_Str"");
    command.add(this.jobExecEnv.getJobRequest().getUser());
  }
  if (SystemUtils.IS_OS_LINUX) {
    command.add(""String_Node_Str"");
  }
  command.add(""String_Node_Str"");
  command.add(runScript);
  final ProcessBuilder pb=new ProcessBuilder(command);
  pb.directory(this.jobExecEnv.getJobWorkingDir());
  pb.redirectOutput(new File(this.jobExecEnv.getJobWorkingDir() + JobConstants.GENIE_LOG_PATH));
  pb.redirectError(new File(this.jobExecEnv.getJobWorkingDir() + JobConstants.GENIE_LOG_PATH));
  try {
    final Process process=pb.start();
    final int processId=this.getProcessId(process);
    final JobRequest request=this.jobExecEnv.getJobRequest();
    final Calendar calendar=Calendar.getInstance(UTC);
    calendar.add(Calendar.SECOND,request.getTimeout());
    final JobExecution jobExecution=new JobExecution.Builder(this.hostname,processId,this.jobExecEnv.getCommand().getCheckDelay(),calendar.getTime()).withId(request.getId()).build();
    context.put(JobConstants.JOB_EXECUTION_DTO_KEY,jobExecution);
  }
 catch (  IOException ie) {
    throw new GenieServerException(""String_Node_Str"" + String.valueOf(command),ie);
  }
}"
90054,"/** 
 * Method to change the ownership of a directory.
 * @param dir The directory to change the ownership of.
 * @param user Userid of the user.
 * @throws GenieException If there is a problem.
 */
public void changeOwnershipOfDirectory(final String dir,final String user) throws GenieException {
  final CommandLine commandLine=new CommandLine(""String_Node_Str"");
  commandLine.addArgument(""String_Node_Str"");
  commandLine.addArgument(user);
  commandLine.addArgument(dir);
  try {
    this.executor.execute(commandLine);
  }
 catch (  IOException ioexception) {
    throw new GenieServerException(""String_Node_Str"" + ioexception);
  }
}","/** 
 * Method to change the ownership of a directory.
 * @param dir The directory to change the ownership of.
 * @param user Userid of the user.
 * @throws GenieException If there is a problem.
 */
public void changeOwnershipOfDirectory(final String dir,final String user) throws GenieException {
  final CommandLine commandLine=new CommandLine(""String_Node_Str"");
  commandLine.addArgument(""String_Node_Str"");
  commandLine.addArgument(""String_Node_Str"");
  commandLine.addArgument(user);
  commandLine.addArgument(dir);
  try {
    this.executor.execute(commandLine);
  }
 catch (  IOException ioexception) {
    throw new GenieServerException(""String_Node_Str"" + ioexception);
  }
}"
90055,"/** 
 * Create user on the system.
 * @param user user id
 * @param group group id
 * @throws GenieException If there is any problem.
 */
public void createUser(final String user,final String group) throws GenieException {
  final CommandLine idCheckCommandLine=new CommandLine(""String_Node_Str"");
  idCheckCommandLine.addArgument(""String_Node_Str"");
  idCheckCommandLine.addArgument(user);
  try {
    this.executor.execute(idCheckCommandLine);
    log.info(""String_Node_Str"");
  }
 catch (  IOException ioe) {
    log.info(""String_Node_Str"");
    final CommandLine userCreateCommandLine=new CommandLine(""String_Node_Str"");
    userCreateCommandLine.addArgument(""String_Node_Str"");
    userCreateCommandLine.addArgument(user);
    if (StringUtils.isNotBlank(group)) {
      userCreateCommandLine.addArgument(""String_Node_Str"");
      userCreateCommandLine.addArgument(group);
    }
    userCreateCommandLine.addArgument(""String_Node_Str"");
    try {
      this.executor.execute(userCreateCommandLine);
    }
 catch (    IOException ioexception) {
      throw new GenieServerException(""String_Node_Str"" + user + ""String_Node_Str""+ ioexception);
    }
  }
}","/** 
 * Create user on the system.
 * @param user user id
 * @param group group id
 * @throws GenieException If there is any problem.
 */
public void createUser(final String user,final String group) throws GenieException {
  final CommandLine idCheckCommandLine=new CommandLine(""String_Node_Str"");
  idCheckCommandLine.addArgument(""String_Node_Str"");
  idCheckCommandLine.addArgument(user);
  try {
    this.executor.execute(idCheckCommandLine);
    log.debug(""String_Node_Str"");
  }
 catch (  IOException ioe) {
    log.debug(""String_Node_Str"");
    final CommandLine groupCreateCommandLine=new CommandLine(""String_Node_Str"");
    groupCreateCommandLine.addArgument(""String_Node_Str"");
    groupCreateCommandLine.addArgument(group);
    try {
      this.executor.execute(groupCreateCommandLine);
    }
 catch (    IOException ioexception) {
      log.debug(""String_Node_Str"");
    }
    final CommandLine userCreateCommandLine=new CommandLine(""String_Node_Str"");
    userCreateCommandLine.addArgument(""String_Node_Str"");
    userCreateCommandLine.addArgument(user);
    if (StringUtils.isNotBlank(group)) {
      userCreateCommandLine.addArgument(""String_Node_Str"");
      userCreateCommandLine.addArgument(group);
    }
    userCreateCommandLine.addArgument(""String_Node_Str"");
    try {
      this.executor.execute(userCreateCommandLine);
    }
 catch (    IOException ioexception) {
      throw new GenieServerException(""String_Node_Str"" + user + ""String_Node_Str""+ ioexception);
    }
  }
}"
90056,"/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException, IOException {
  log.debug(""String_Node_Str"");
  super.executeTask(context);
  final String jobSetupFile=jobExecEnv.getJobRequest().getSetupFile();
  if (jobSetupFile != null && StringUtils.isNotBlank(jobSetupFile)) {
    final String localPath=this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + jobSetupFile.substring(jobSetupFile.lastIndexOf(JobConstants.FILE_PATH_DELIMITER) + 1);
    this.fts.getFile(jobSetupFile,localPath);
    writer.write(""String_Node_Str"" + System.lineSeparator());
    writer.write(JobConstants.SOURCE + localPath.replace(this.jobWorkingDirectory,""String_Node_Str"" + JobConstants.GENIE_JOB_DIR_ENV_VAR + ""String_Node_Str"") + System.lineSeparator());
    writer.write(System.lineSeparator());
  }
  for (  final String dependencyFile : jobExecEnv.getJobRequest().getDependencies()) {
    final String localPath=this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + dependencyFile.substring(dependencyFile.lastIndexOf(JobConstants.FILE_PATH_DELIMITER) + 1);
    this.fts.getFile(dependencyFile,localPath);
  }
  this.attachmentService.copy(jobExecEnv.getJobRequest().getId(),jobExecEnv.getJobWorkingDir());
  writer.write(System.lineSeparator());
  writer.write(""String_Node_Str"" + System.lineSeparator());
  writer.write(jobExecEnv.getCommand().getExecutable() + JobConstants.WHITE_SPACE + jobExecEnv.getJobRequest().getCommandArgs()+ JobConstants.STDOUT_REDIRECT+ JobConstants.STDOUT_LOG_FILE_NAME+ JobConstants.STDERR_REDIRECT+ JobConstants.STDERR_LOG_FILE_NAME+ ""String_Node_Str""+ System.lineSeparator());
  writer.write(""String_Node_Str"" + System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(""String_Node_Str"" + System.lineSeparator());
  writer.write(JobConstants.GENIE_DONE_FILE_CONTENT_PREFIX + JobConstants.GENIE_DONE_FILE_NAME + System.lineSeparator());
}","/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException, IOException {
  log.debug(""String_Node_Str"");
  super.executeTask(context);
  final String jobSetupFile=jobExecEnv.getJobRequest().getSetupFile();
  if (jobSetupFile != null && StringUtils.isNotBlank(jobSetupFile)) {
    final String localPath=this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + jobSetupFile.substring(jobSetupFile.lastIndexOf(JobConstants.FILE_PATH_DELIMITER) + 1);
    this.fts.getFile(jobSetupFile,localPath);
    writer.write(""String_Node_Str"" + System.lineSeparator());
    writer.write(JobConstants.SOURCE + localPath.replace(this.jobWorkingDirectory,""String_Node_Str"" + JobConstants.GENIE_JOB_DIR_ENV_VAR + ""String_Node_Str"") + System.lineSeparator());
    writer.write(System.lineSeparator());
  }
  for (  final String dependencyFile : jobExecEnv.getJobRequest().getDependencies()) {
    final String localPath=this.jobWorkingDirectory + JobConstants.FILE_PATH_DELIMITER + dependencyFile.substring(dependencyFile.lastIndexOf(JobConstants.FILE_PATH_DELIMITER) + 1);
    this.fts.getFile(dependencyFile,localPath);
  }
  this.attachmentService.copy(jobExecEnv.getJobRequest().getId(),jobExecEnv.getJobWorkingDir());
  writer.write(""String_Node_Str"" + System.lineSeparator());
  writer.write(""String_Node_Str"" + ""String_Node_Str"" + JobConstants.GENIE_JOB_DIR_ENV_VAR + ""String_Node_Str""+ JobConstants.GENIE_ENV_PATH+ System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(""String_Node_Str"" + System.lineSeparator());
  writer.write(jobExecEnv.getCommand().getExecutable() + JobConstants.WHITE_SPACE + jobExecEnv.getJobRequest().getCommandArgs()+ JobConstants.STDOUT_REDIRECT+ JobConstants.STDOUT_LOG_FILE_NAME+ JobConstants.STDERR_REDIRECT+ JobConstants.STDERR_LOG_FILE_NAME+ ""String_Node_Str""+ System.lineSeparator());
  writer.write(""String_Node_Str"" + System.lineSeparator());
  writer.write(System.lineSeparator());
  writer.write(""String_Node_Str"" + System.lineSeparator());
  writer.write(JobConstants.GENIE_DONE_FILE_CONTENT_PREFIX + JobConstants.GENIE_DONE_FILE_NAME + System.lineSeparator());
}"
90057,"/** 
 * Test the create user method for user already exists.
 * @throws IOException If there is any problem.
 * @throws GenieException If there is any problem.
 */
@Test public void testCreateUserMethodSuccessDoesNotExist1() throws IOException, GenieException {
  final String user=""String_Node_Str"";
  final String group=""String_Node_Str"";
  final CommandLine idCheckCommandLine=new CommandLine(""String_Node_Str"");
  idCheckCommandLine.addArgument(""String_Node_Str"");
  idCheckCommandLine.addArgument(user);
  Mockito.when(this.executor.execute(Mockito.any())).thenThrow(IOException.class);
  final ArgumentCaptor<CommandLine> argumentCaptor=ArgumentCaptor.forClass(CommandLine.class);
  final List<String> command=Arrays.asList(""String_Node_Str"",""String_Node_Str"",user,""String_Node_Str"",group,""String_Node_Str"");
  try {
    this.jobKickoffTask.createUser(user,group);
  }
 catch (  GenieException ge) {
    log.debug(""String_Node_Str"");
  }
  Mockito.verify(this.executor,Mockito.times(2)).execute(argumentCaptor.capture());
  Assert.assertArrayEquals(command.toArray(),argumentCaptor.getAllValues().get(1).toStrings());
}","/** 
 * Test the create user method for user already exists.
 * @throws IOException If there is any problem.
 * @throws GenieException If there is any problem.
 */
@Test public void testCreateUserMethodSuccessDoesNotExist1() throws IOException, GenieException {
  final String user=""String_Node_Str"";
  final String group=""String_Node_Str"";
  final CommandLine idCheckCommandLine=new CommandLine(""String_Node_Str"");
  idCheckCommandLine.addArgument(""String_Node_Str"");
  idCheckCommandLine.addArgument(user);
  Mockito.when(this.executor.execute(Mockito.any())).thenThrow(IOException.class);
  final ArgumentCaptor<CommandLine> argumentCaptor=ArgumentCaptor.forClass(CommandLine.class);
  final List<String> command=Arrays.asList(""String_Node_Str"",""String_Node_Str"",user,""String_Node_Str"",group,""String_Node_Str"");
  try {
    this.jobKickoffTask.createUser(user,group);
  }
 catch (  GenieException ge) {
    log.debug(""String_Node_Str"");
  }
  Mockito.verify(this.executor,Mockito.times(3)).execute(argumentCaptor.capture());
  Assert.assertArrayEquals(command.toArray(),argumentCaptor.getAllValues().get(2).toStrings());
}"
90058,"/** 
 * Test the change ownership method for success.
 * @throws IOException If there is any problem.
 * @throws GenieException If there is any problem.
 */
@Test public void testChangeOwnershipOfDirectoryMethodSuccess() throws IOException, GenieException {
  final String user=""String_Node_Str"";
  final String dir=""String_Node_Str"";
  final ArgumentCaptor<CommandLine> argumentCaptor=ArgumentCaptor.forClass(CommandLine.class);
  final List<String> command=Arrays.asList(""String_Node_Str"",""String_Node_Str"",user,dir);
  this.jobKickoffTask.changeOwnershipOfDirectory(dir,user);
  Mockito.verify(this.executor).execute(argumentCaptor.capture());
  Assert.assertArrayEquals(command.toArray(),argumentCaptor.getValue().toStrings());
}","/** 
 * Test the change ownership method for success.
 * @throws IOException If there is any problem.
 * @throws GenieException If there is any problem.
 */
@Test public void testChangeOwnershipOfDirectoryMethodSuccess() throws IOException, GenieException {
  final String user=""String_Node_Str"";
  final String dir=""String_Node_Str"";
  final ArgumentCaptor<CommandLine> argumentCaptor=ArgumentCaptor.forClass(CommandLine.class);
  final List<String> command=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",user,dir);
  this.jobKickoffTask.changeOwnershipOfDirectory(dir,user);
  Mockito.verify(this.executor).execute(argumentCaptor.capture());
  Assert.assertArrayEquals(command.toArray(),argumentCaptor.getValue().toStrings());
}"
90059,"/** 
 * Uploads the job directory to the archive location.
 * @param jobId The job id.
 * @throws GenieException if there is any problem
 */
public void archivedJobDir(final String jobId) throws GenieException {
  try {
    log.debug(""String_Node_Str"");
    final Job job=this.jobSearchService.getJob(jobId);
    if (StringUtils.isNotBlank(job.getArchiveLocation())) {
      final String jobWorkingDir=this.baseWorkingDir + JobConstants.FILE_PATH_DELIMITER + jobId;
      final String localArchiveFile=jobWorkingDir + JobConstants.FILE_PATH_DELIMITER + jobId+ ""String_Node_Str"";
      final CommandLine commandLine=new CommandLine(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(localArchiveFile);
      commandLine.addArgument(""String_Node_Str"");
      executor.setWorkingDirectory(new File(jobWorkingDir));
      executor.execute(commandLine);
      this.genieFileTransferService.putFile(localArchiveFile,job.getArchiveLocation());
    }
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",jobId,e);
  }
}","/** 
 * Uploads the job directory to the archive location.
 * @param jobId The job id.
 * @throws GenieException if there is any problem
 */
public void archivedJobDir(final String jobId) throws GenieException {
  try {
    log.debug(""String_Node_Str"");
    final Job job=this.jobSearchService.getJob(jobId);
    if (StringUtils.isNotBlank(job.getArchiveLocation())) {
      final String jobWorkingDir=this.baseWorkingDir + JobConstants.FILE_PATH_DELIMITER + jobId;
      final String localArchiveFile=jobWorkingDir + JobConstants.FILE_PATH_DELIMITER + ""String_Node_Str""+ jobId+ ""String_Node_Str"";
      final CommandLine commandLine=new CommandLine(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(localArchiveFile);
      commandLine.addArgument(""String_Node_Str"");
      executor.setWorkingDirectory(new File(jobWorkingDir));
      executor.execute(commandLine);
      this.genieFileTransferService.putFile(localArchiveFile,job.getArchiveLocation());
    }
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",jobId,e);
  }
}"
90060,"/** 
 * Main method that uses the JobClient.
 * @param args The args to the main application.
 * @throws Exception For all other issues.
 */
public static void main(final String[] args) throws Exception {
  log.debug(""String_Node_Str"");
  final Configurations configs=new Configurations();
  final Configuration configuration=configs.properties(""String_Node_Str"");
  final JobClient jobClient=new JobClient(new GenieClientConfigurationCommonsConfigImpl(configuration));
  final String commandArgs=""String_Node_Str"";
  final List<ClusterCriteria> clusterCriteriaList=new ArrayList<>();
  final String clusterTag=""String_Node_Str"";
  final ClusterCriteria clusterCriteria=new ClusterCriteria(Sets.newHashSet(clusterTag));
  clusterCriteriaList.add(clusterCriteria);
  final HashSet<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  tags.add(""String_Node_Str"");
  final String commandTag=""String_Node_Str"";
  final Set<String> commandCriteria=Sets.newHashSet(commandTag);
  final JobRequest jobRequest=new JobRequest.Builder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",commandArgs,clusterCriteriaList,commandCriteria).withDisableLogArchival(true).withTags(tags).build();
  jobClient.getJobs().forEach(job -> log.info(job.toString()));
}","/** 
 * Main method that uses the JobClient.
 * @param args The args to the main application.
 * @throws Exception For all other issues.
 */
public static void main(final String[] args) throws Exception {
  log.debug(""String_Node_Str"");
  final Configurations configs=new Configurations();
  final Configuration configuration=configs.properties(""String_Node_Str"");
  final JobClient jobClient=new JobClient(new GenieClientConfigurationCommonsConfigImpl(configuration));
  final String commandArgs=""String_Node_Str"";
  final List<ClusterCriteria> clusterCriteriaList=new ArrayList<>();
  final String clusterTag=""String_Node_Str"";
  final ClusterCriteria clusterCriteria=new ClusterCriteria(Sets.newHashSet(clusterTag));
  clusterCriteriaList.add(clusterCriteria);
  final HashSet<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  tags.add(""String_Node_Str"");
  final String commandTag=""String_Node_Str"";
  final Set<String> commandCriteria=Sets.newHashSet(commandTag);
  final JobRequest jobRequest=new JobRequest.Builder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",commandArgs,clusterCriteriaList,commandCriteria).withDisableLogArchival(true).withTags(tags).build();
  final String jobId=jobClient.submitJob(jobRequest);
  log.info(jobClient.getJob(jobId).toString());
  log.info(jobClient.getJobRequest(jobId).toString());
  log.info(jobClient.getJobCluster(jobId).toString());
  log.info(jobClient.getJobCommand(jobId).toString());
  log.info(jobClient.getJobExecution(jobId).toString());
  jobClient.getJobs().forEach(job -> log.info(job.toString()));
}"
90061,"/** 
 * Method to set exit code for the job execution.
 * @param id       the id of the job to update the exit code
 * @param exitCode The exit code of the process
 * @throws GenieException if there is an error
 */
@Override public synchronized void setExitCode(@NotBlank(message=""String_Node_Str"") final String id,@NotBlank(message=""String_Node_Str"") final int exitCode) throws GenieException {
  log.debug(""String_Node_Str"",id,exitCode);
  final JobExecutionEntity jobExecutionEntity=this.jobExecutionRepo.findOne(id);
  if (jobExecutionEntity != null) {
    if (jobExecutionEntity.getExitCode() == JobExecution.DEFAULT_EXIT_CODE) {
switch (exitCode) {
case JobExecution.DEFAULT_EXIT_CODE:
        break;
case JobExecution.KILLED_EXIT_CODE:
      this.updateJobStatus(id,JobStatus.KILLED,""String_Node_Str"");
    break;
case JobExecution.ZOMBIE_EXIT_CODE:
  this.updateJobStatus(id,JobStatus.FAILED,""String_Node_Str"");
break;
case JobExecution.SUCCESS_EXIT_CODE:
this.updateJobStatus(id,JobStatus.SUCCEEDED,""String_Node_Str"");
break;
default :
this.updateJobStatus(id,JobStatus.FAILED,""String_Node_Str"");
}
jobExecutionEntity.setExitCode(exitCode);
}
 else {
throw new GeniePreconditionException(""String_Node_Str"");
}
}
 else {
throw new GenieNotFoundException(""String_Node_Str"" + id);
}
}","/** 
 * Method to set exit code for the job execution.
 * @param id       the id of the job to update the exit code
 * @param exitCode The exit code of the process
 * @throws GenieException if there is an error
 */
@Override public synchronized void setExitCode(@NotBlank(message=""String_Node_Str"") final String id,@NotBlank(message=""String_Node_Str"") final int exitCode) throws GenieException {
  log.debug(""String_Node_Str"",id,exitCode);
  final JobExecutionEntity jobExecutionEntity=this.jobExecutionRepo.findOne(id);
  if (jobExecutionEntity != null) {
    if (jobExecutionEntity.getExitCode() == JobExecution.DEFAULT_EXIT_CODE) {
switch (exitCode) {
case JobExecution.DEFAULT_EXIT_CODE:
        break;
case JobExecution.KILLED_EXIT_CODE:
      this.updateJobStatus(id,JobStatus.KILLED,""String_Node_Str"");
    break;
case JobExecution.ZOMBIE_EXIT_CODE:
  this.updateJobStatus(id,JobStatus.FAILED,""String_Node_Str"");
break;
case JobExecution.SUCCESS_EXIT_CODE:
this.updateJobStatus(id,JobStatus.SUCCEEDED,""String_Node_Str"");
break;
default :
this.updateJobStatus(id,JobStatus.FAILED,""String_Node_Str"");
}
jobExecutionEntity.setExitCode(exitCode);
}
 else {
if (jobExecutionEntity.getExitCode() != exitCode) {
throw new GeniePreconditionException(""String_Node_Str"");
}
}
}
 else {
throw new GenieNotFoundException(""String_Node_Str"" + id);
}
}"
90062,"/** 
 * {@inheritDoc}
 */
@Override public void putFile(@NotBlank(message=""String_Node_Str"") final String srcLocalPath,@NotBlank(message=""String_Node_Str"") final String dstRemotePath) throws GenieException {
  log.debug(""String_Node_Str"",srcLocalPath,dstRemotePath);
  try {
    final File src=new File(srcLocalPath);
    final File dest=new File(dstRemotePath);
    Files.copy(src.toPath(),dest.toPath());
  }
 catch (  IOException ioe) {
    log.error(""String_Node_Str"",srcLocalPath,dstRemotePath);
    throw new GenieServerException(""String_Node_Str"" + dstRemotePath + ""String_Node_Str""+ srcLocalPath,ioe);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void putFile(@NotBlank(message=""String_Node_Str"") final String srcLocalPath,@NotBlank(message=""String_Node_Str"") final String dstRemotePath) throws GenieException {
  log.debug(""String_Node_Str"",srcLocalPath,dstRemotePath);
  try {
    final File src=new File(srcLocalPath);
    final File dest=new File(dstRemotePath);
    Files.copy(src.toPath(),dest.toPath());
  }
 catch (  IOException ioe) {
    log.error(""String_Node_Str"",srcLocalPath,dstRemotePath);
    throw new GenieServerException(""String_Node_Str"" + srcLocalPath + ""String_Node_Str""+ dstRemotePath,ioe);
  }
}"
90063,"/** 
 * Sends an email when the job is completed.
 * @param jobId The job id.
 * @throws GenieException If there is any problem.
 */
public void sendEmail(final String jobId) throws GenieException {
  log.debug(""String_Node_Str"");
  final JobRequest jobRequest=this.jobSearchService.getJobRequest(jobId);
  final Job job=this.jobSearchService.getJob(jobId);
  if (org.apache.commons.lang3.StringUtils.isNotBlank(jobRequest.getEmail())) {
    final String message=new StringBuilder().append(""String_Node_Str"").append(jobId).append(""String_Node_Str"").append(job.getStatus()).toString();
    this.mailServiceImpl.sendEmail(jobRequest.getEmail(),message,message);
  }
}","/** 
 * Sends an email when the job is completed.
 * @param jobId The job id.
 * @throws GenieException If there is any problem.
 */
public void sendEmail(final String jobId) throws GenieException {
  try {
    log.debug(""String_Node_Str"");
    final JobRequest jobRequest=this.jobSearchService.getJobRequest(jobId);
    final Job job=this.jobSearchService.getJob(jobId);
    if (org.apache.commons.lang3.StringUtils.isNotBlank(jobRequest.getEmail())) {
      final String message=new StringBuilder().append(""String_Node_Str"").append(jobId).append(""String_Node_Str"").append(job.getStatus()).toString();
      this.mailServiceImpl.sendEmail(jobRequest.getEmail(),message,message);
    }
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",jobId,e);
  }
}"
90064,"/** 
 * An external fail-safe mechanism to clean up processes left behind by the run.sh after the job is killed or failed.
 * @param pid The process id.
 * @throws GenieException
 */
private void cleanupProcesses(final int pid) throws GenieException {
  final CommandLine commandLine=new CommandLine(JobConstants.UNIX_PKILL_COMMAND);
  commandLine.addArgument(JobConstants.getKillFlag());
  commandLine.addArgument(Integer.toString(pid));
  try {
    executor.execute(commandLine);
  }
 catch (  IOException ioe) {
    log.debug(""String_Node_Str"");
  }
}","/** 
 * An external fail-safe mechanism to clean up processes left behind by the run.sh after the job is killed or failed.
 * @param pid The process id.
 * @throws GenieException
 */
private void cleanupProcesses(final int pid) throws GenieException {
  try {
    final CommandLine commandLine=new CommandLine(JobConstants.UNIX_PKILL_COMMAND);
    commandLine.addArgument(JobConstants.getKillFlag());
    commandLine.addArgument(Integer.toString(pid));
    executor.execute(commandLine);
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",e);
  }
}"
90065,"/** 
 * Updates the status of the job.
 * @param jobId The job id.
 * @throws GenieException If there is any problem
 */
public void updateExitCode(final String jobId) throws GenieException {
  log.debug(""String_Node_Str"");
  final ObjectMapper objectMapper=new ObjectMapper();
  try {
    final JobDoneFile jobDoneFile=objectMapper.readValue(new File(baseWorkingDir + ""String_Node_Str"" + jobId+ ""String_Node_Str""),JobDoneFile.class);
    final int exitCode=jobDoneFile.getExitCode();
    this.jobPersistenceService.setExitCode(jobId,exitCode);
  }
 catch (  final IOException ioe) {
    log.error(""String_Node_Str"",jobId);
    this.jobPersistenceService.updateJobStatus(jobId,JobStatus.FAILED,""String_Node_Str"");
  }
}","/** 
 * Updates the status of the job.
 * @param jobId The job id.
 * @throws GenieException If there is any problem
 */
public void updateExitCode(final String jobId) throws GenieException {
  try {
    log.debug(""String_Node_Str"");
    final ObjectMapper objectMapper=new ObjectMapper();
    try {
      final JobDoneFile jobDoneFile=objectMapper.readValue(new File(baseWorkingDir + ""String_Node_Str"" + jobId+ ""String_Node_Str""),JobDoneFile.class);
      final int exitCode=jobDoneFile.getExitCode();
      this.jobPersistenceService.setExitCode(jobId,exitCode);
    }
 catch (    final IOException ioe) {
      log.error(""String_Node_Str"",jobId);
      this.jobPersistenceService.updateJobStatus(jobId,JobStatus.FAILED,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",jobId,e);
  }
}"
90066,"/** 
 * Uploads the job directory to the archive location.
 * @param jobId The job id.
 * @throws GenieException if there is any problem
 */
public void archivedJobDir(final String jobId) throws GenieException {
  log.debug(""String_Node_Str"");
  final Job job=this.jobSearchService.getJob(jobId);
  if (StringUtils.isNotBlank(job.getArchiveLocation())) {
    final String jobWorkingDir=this.baseWorkingDir + JobConstants.FILE_PATH_DELIMITER + jobId;
    final String localArchiveFile=jobWorkingDir + JobConstants.FILE_PATH_DELIMITER + jobId+ ""String_Node_Str"";
    final CommandLine commandLine=new CommandLine(""String_Node_Str"");
    commandLine.addArgument(""String_Node_Str"");
    commandLine.addArgument(""String_Node_Str"");
    commandLine.addArgument(""String_Node_Str"");
    commandLine.addArgument(localArchiveFile);
    commandLine.addArgument(""String_Node_Str"");
    executor.setWorkingDirectory(new File(jobWorkingDir));
    try {
      executor.execute(commandLine);
    }
 catch (    IOException ioe) {
      throw new GenieServerException(""String_Node_Str"" + jobId + ioe);
    }
    this.genieFileTransferService.putFile(localArchiveFile,job.getArchiveLocation());
  }
}","/** 
 * Uploads the job directory to the archive location.
 * @param jobId The job id.
 * @throws GenieException if there is any problem
 */
public void archivedJobDir(final String jobId) throws GenieException {
  try {
    log.debug(""String_Node_Str"");
    final Job job=this.jobSearchService.getJob(jobId);
    if (StringUtils.isNotBlank(job.getArchiveLocation())) {
      final String jobWorkingDir=this.baseWorkingDir + JobConstants.FILE_PATH_DELIMITER + jobId;
      final String localArchiveFile=jobWorkingDir + JobConstants.FILE_PATH_DELIMITER + jobId+ ""String_Node_Str"";
      final CommandLine commandLine=new CommandLine(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(""String_Node_Str"");
      commandLine.addArgument(localArchiveFile);
      commandLine.addArgument(""String_Node_Str"");
      executor.setWorkingDirectory(new File(jobWorkingDir));
      executor.execute(commandLine);
      this.genieFileTransferService.putFile(localArchiveFile,job.getArchiveLocation());
    }
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",jobId,e);
  }
}"
90067,"/** 
 * Constructor used by the builder build() method.
 * @param builder The builder to use
 */
public JobExecutionEnvironment(final Builder builder){
  this.jobRequest=builder.jobRequest;
  this.cluster=builder.cluster;
  this.command=builder.command;
  this.applications.addAll(builder.applications);
  this.jobWorkingDir=builder.jobWorkingDir;
}","/** 
 * Constructor used by the builder build() method.
 * @param builder The builder to use
 */
public JobExecutionEnvironment(final Builder builder){
  this.jobRequest=builder.bJobRequest;
  this.cluster=builder.bCluster;
  this.command=builder.bCommand;
  this.applications.addAll(builder.bApplications);
  this.jobWorkingDir=builder.bJobWorkingDir;
}"
90068,"/** 
 * Constructor.
 * @param request The job request object.
 * @param clusterObj The cluster object.
 * @param commandObj The command object.
 * @param dir The directory location for the jobs
 * @throws GenieException If there is an error
 */
public Builder(@NotNull(message=""String_Node_Str"") final JobRequest request,@NotNull(message=""String_Node_Str"") final Cluster clusterObj,@NotNull(message=""String_Node_Str"") final Command commandObj,@NotBlank(message=""String_Node_Str"") final File dir) throws GenieException {
  this.jobRequest=request;
  this.cluster=clusterObj;
  this.command=commandObj;
  this.jobWorkingDir=dir;
}","/** 
 * Constructor.
 * @param request The job request object.
 * @param clusterObj The cluster object.
 * @param commandObj The command object.
 * @param dir The directory location for the jobs
 * @throws GenieException If there is an error
 */
public Builder(@NotNull(message=""String_Node_Str"") final JobRequest request,@NotNull(message=""String_Node_Str"") final Cluster clusterObj,@NotNull(message=""String_Node_Str"") final Command commandObj,@NotBlank(message=""String_Node_Str"") final File dir) throws GenieException {
  this.bJobRequest=request;
  this.bCluster=clusterObj;
  this.bCommand=commandObj;
  this.bJobWorkingDir=dir;
}"
90069,"/** 
 * Set the applications needed for the jobs' execution.
 * @param applications The list of application objects.
 * @return The builder
 */
public Builder withApplications(final List<Application> applications){
  if (applications != null) {
    this.applications.addAll(applications);
  }
  return this;
}","/** 
 * Set the applications needed for the jobs' execution.
 * @param applications The list of application objects.
 * @return The builder
 */
public Builder withApplications(final List<Application> applications){
  if (applications != null) {
    this.bApplications.addAll(applications);
  }
  return this;
}"
90070,"/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException {
  log.debug(""String_Node_Str"");
  super.executeTask(context);
  final Writer writer=Utils.getWriter(this.runScript);
  if (this.jobExecEnv.getApplications() != null) {
    for (    Application application : this.jobExecEnv.getApplications()) {
      createEntityInstanceDirectory(application.getId(),Constants.AdminResources.APPLICATION);
      final String applicationSetupFile=application.getSetupFile();
      if (applicationSetupFile != null && StringUtils.isNotBlank(applicationSetupFile)) {
        final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,application.getId(),applicationSetupFile,Constants.FileType.SETUP,Constants.AdminResources.APPLICATION);
        this.fts.getFile(applicationSetupFile,localPath);
        Utils.appendToWriter(writer,""String_Node_Str"" + localPath + ""String_Node_Str"");
      }
      for (      final String dependencyFile : application.getDependencies()) {
        final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,application.getId(),dependencyFile,Constants.FileType.DEPENDENCIES,Constants.AdminResources.APPLICATION);
        this.fts.getFile(dependencyFile,localPath);
      }
      for (      final String configFile : application.getConfigs()) {
        final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,application.getId(),configFile,Constants.FileType.CONFIG,Constants.AdminResources.APPLICATION);
        this.fts.getFile(configFile,localPath);
      }
    }
  }
  Utils.closeWriter(writer);
}","/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException {
  log.debug(""String_Node_Str"");
  super.executeTask(context);
  final Writer writer=Utils.getWriter(this.runScript);
  if (this.jobExecEnv.getApplications() != null) {
    for (    Application application : this.jobExecEnv.getApplications()) {
      createEntityInstanceDirectory(application.getId(),Constants.AdminResources.APPLICATION);
      createEntityInstanceConfigDirectory(application.getId(),Constants.AdminResources.APPLICATION);
      createEntityInstanceDependenciesDirectory(application.getId(),Constants.AdminResources.APPLICATION);
      final String applicationSetupFile=application.getSetupFile();
      if (applicationSetupFile != null && StringUtils.isNotBlank(applicationSetupFile)) {
        final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,application.getId(),applicationSetupFile,Constants.FileType.SETUP,Constants.AdminResources.APPLICATION);
        this.fts.getFile(applicationSetupFile,localPath);
        Utils.appendToWriter(writer,""String_Node_Str"" + localPath + ""String_Node_Str"");
      }
      for (      final String dependencyFile : application.getDependencies()) {
        final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,application.getId(),dependencyFile,Constants.FileType.DEPENDENCIES,Constants.AdminResources.APPLICATION);
        this.fts.getFile(dependencyFile,localPath);
      }
      for (      final String configFile : application.getConfigs()) {
        final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,application.getId(),configFile,Constants.FileType.CONFIG,Constants.AdminResources.APPLICATION);
        this.fts.getFile(configFile,localPath);
      }
    }
  }
  Utils.closeWriter(writer);
}"
90071,"/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException {
  log.debug(""String_Node_Str"");
  super.executeTask(context);
  final Writer writer=Utils.getWriter(runScript);
  createEntityInstanceDirectory(this.jobExecEnv.getCluster().getId(),Constants.AdminResources.CLUSTER);
  final String clusterSetupFile=jobExecEnv.getCluster().getSetupFile();
  if (clusterSetupFile != null && StringUtils.isNotBlank(clusterSetupFile)) {
    final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,jobExecEnv.getCommand().getId(),clusterSetupFile,Constants.FileType.SETUP,Constants.AdminResources.CLUSTER);
    fts.getFile(clusterSetupFile,localPath);
    Utils.appendToWriter(writer,""String_Node_Str"" + localPath + ""String_Node_Str"");
  }
  for (  final String configFile : jobExecEnv.getCluster().getConfigs()) {
    final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,jobExecEnv.getCluster().getId(),configFile,Constants.FileType.CONFIG,Constants.AdminResources.CLUSTER);
    this.fts.getFile(configFile,localPath);
  }
  Utils.closeWriter(writer);
}","/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException {
  log.debug(""String_Node_Str"");
  super.executeTask(context);
  final Writer writer=Utils.getWriter(runScript);
  createEntityInstanceDirectory(this.jobExecEnv.getCluster().getId(),Constants.AdminResources.CLUSTER);
  createEntityInstanceConfigDirectory(this.jobExecEnv.getCluster().getId(),Constants.AdminResources.CLUSTER);
  createEntityInstanceDependenciesDirectory(this.jobExecEnv.getCluster().getId(),Constants.AdminResources.CLUSTER);
  final String clusterSetupFile=jobExecEnv.getCluster().getSetupFile();
  if (clusterSetupFile != null && StringUtils.isNotBlank(clusterSetupFile)) {
    final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,jobExecEnv.getCluster().getId(),clusterSetupFile,Constants.FileType.SETUP,Constants.AdminResources.CLUSTER);
    fts.getFile(clusterSetupFile,localPath);
    Utils.appendToWriter(writer,""String_Node_Str"" + localPath + ""String_Node_Str"");
  }
  for (  final String configFile : jobExecEnv.getCluster().getConfigs()) {
    final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,jobExecEnv.getCluster().getId(),configFile,Constants.FileType.CONFIG,Constants.AdminResources.CLUSTER);
    this.fts.getFile(configFile,localPath);
  }
  Utils.closeWriter(writer);
}"
90072,"/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException {
  log.debug(""String_Node_Str"");
  super.executeTask(context);
  final Writer writer=Utils.getWriter(runScript);
  createEntityInstanceDirectory(this.jobExecEnv.getCluster().getId(),Constants.AdminResources.COMMAND);
  final String commandSetupFile=jobExecEnv.getCommand().getSetupFile();
  if (commandSetupFile != null && StringUtils.isNotBlank(commandSetupFile)) {
    final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,jobExecEnv.getCommand().getId(),commandSetupFile,Constants.FileType.SETUP,Constants.AdminResources.COMMAND);
    this.fts.getFile(commandSetupFile,localPath);
    Utils.appendToWriter(writer,""String_Node_Str"" + localPath + ""String_Node_Str"");
  }
  for (  final String configFile : jobExecEnv.getCommand().getConfigs()) {
    final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,jobExecEnv.getCommand().getId(),configFile,Constants.FileType.CONFIG,Constants.AdminResources.COMMAND);
    this.fts.getFile(configFile,localPath);
  }
  Utils.closeWriter(writer);
}","/** 
 * {@inheritDoc}
 */
@Override public void executeTask(@NotNull final Map<String,Object> context) throws GenieException {
  log.debug(""String_Node_Str"");
  super.executeTask(context);
  final Writer writer=Utils.getWriter(runScript);
  createEntityInstanceDirectory(this.jobExecEnv.getCommand().getId(),Constants.AdminResources.COMMAND);
  createEntityInstanceConfigDirectory(this.jobExecEnv.getCommand().getId(),Constants.AdminResources.COMMAND);
  createEntityInstanceDependenciesDirectory(this.jobExecEnv.getCommand().getId(),Constants.AdminResources.COMMAND);
  final String commandSetupFile=jobExecEnv.getCommand().getSetupFile();
  if (commandSetupFile != null && StringUtils.isNotBlank(commandSetupFile)) {
    final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,jobExecEnv.getCommand().getId(),commandSetupFile,Constants.FileType.SETUP,Constants.AdminResources.COMMAND);
    this.fts.getFile(commandSetupFile,localPath);
    Utils.appendToWriter(writer,""String_Node_Str"" + localPath + ""String_Node_Str"");
  }
  for (  final String configFile : jobExecEnv.getCommand().getConfigs()) {
    final String localPath=super.buildLocalFilePath(this.jobWorkigDirectory,jobExecEnv.getCommand().getId(),configFile,Constants.FileType.CONFIG,Constants.AdminResources.COMMAND);
    this.fts.getFile(configFile,localPath);
  }
  Utils.closeWriter(writer);
}"
90073,"/** 
 * Constructor.
 * @param executor The executor to use to launch processes
 */
@Autowired public LocalFileTransferImpl(final Executor executor){
  this.executor=executor;
}","/** 
 * Constructor.
 * @param executor The executor to use to launch processes
 */
@Autowired public LocalFileTransferImpl(final Executor executor){
  this.executor=executor;
  this.resourceLoader=new DefaultResourceLoader();
}"
90074,"/** 
 * {@inheritDoc}
 */
@Override public void getFile(@NotBlank(message=""String_Node_Str"") final String srcRemotePath,@NotBlank(message=""String_Node_Str"") final String dstLocalPath) throws GenieException {
  log.debug(""String_Node_Str"",srcRemotePath,dstLocalPath);
  final CommandLine commandLine=new CommandLine(""String_Node_Str"");
  commandLine.addArgument(srcRemotePath);
  commandLine.addArgument(dstLocalPath);
  try {
    this.executor.execute(commandLine);
  }
 catch (  IOException ioe) {
    log.error(""String_Node_Str"",srcRemotePath,dstLocalPath);
    throw new GenieServerException(""String_Node_Str"" + srcRemotePath + ""String_Node_Str""+ dstLocalPath,ioe);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void getFile(@NotBlank(message=""String_Node_Str"") final String srcRemotePath,@NotBlank(message=""String_Node_Str"") final String dstLocalPath) throws GenieException {
  log.debug(""String_Node_Str"",srcRemotePath,dstLocalPath);
  try {
    final File src=this.resourceLoader.getResource(srcRemotePath).getFile();
    final File dest=new File(dstLocalPath);
    Files.copy(src.toPath(),dest.toPath());
  }
 catch (  IOException ioe) {
    log.error(""String_Node_Str"",srcRemotePath,dstLocalPath);
    throw new GenieServerException(""String_Node_Str"" + srcRemotePath + ""String_Node_Str""+ dstLocalPath,ioe);
  }
}"
90075,"/** 
 * {@inheritDoc}
 */
@Override public void putFile(@NotBlank(message=""String_Node_Str"") final String srcLocalPath,@NotBlank(message=""String_Node_Str"") final String dstRemotePath) throws GenieException {
  log.debug(""String_Node_Str"",srcLocalPath,dstRemotePath);
  final CommandLine commandLine=new CommandLine(""String_Node_Str"");
  commandLine.addArgument(srcLocalPath);
  commandLine.addArgument(dstRemotePath);
  try {
    this.executor.execute(commandLine);
  }
 catch (  IOException ioe) {
    log.error(""String_Node_Str"",srcLocalPath,dstRemotePath);
    throw new GenieServerException(""String_Node_Str"" + dstRemotePath + ""String_Node_Str""+ srcLocalPath,ioe);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void putFile(@NotBlank(message=""String_Node_Str"") final String srcLocalPath,@NotBlank(message=""String_Node_Str"") final String dstRemotePath) throws GenieException {
  log.debug(""String_Node_Str"",srcLocalPath,dstRemotePath);
  try {
    final File src=new File(srcLocalPath);
    final File dest=this.resourceLoader.getResource(dstRemotePath).getFile();
    Files.copy(src.toPath(),dest.toPath());
  }
 catch (  IOException ioe) {
    log.error(""String_Node_Str"",srcLocalPath,dstRemotePath);
    throw new GenieServerException(""String_Node_Str"" + dstRemotePath + ""String_Node_Str""+ srcLocalPath,ioe);
  }
}"
90076,"/** 
 * Test the putFile method.
 * @throws GenieException If there is any problem
 * @throws IOException If there is any problem
 */
@Test(expected=GenieServerException.class) public void testPutFileMethod() throws GenieException, IOException {
  final ArgumentCaptor<CommandLine> argument=ArgumentCaptor.forClass(CommandLine.class);
  Mockito.when(this.executor.execute(Mockito.any())).thenThrow(IOException.class);
  this.localFileTransfer.putFile(SOURCE_FILE,DESTINATION_FILE);
  Mockito.verify(this.executor).execute(argument.capture());
  final List<String> expectedCommandLine=new ArrayList<>();
  expectedCommandLine.add(COPY_COMMAND);
  expectedCommandLine.add(SOURCE_FILE);
  expectedCommandLine.add(DESTINATION_FILE);
  Assert.assertArrayEquals(expectedCommandLine.toArray(),argument.getValue().getArguments());
}","/** 
 * Test the putFile method.
 * @throws GenieException If there is any problem
 * @throws IOException If there is any problem
 */
@Test(expected=GenieServerException.class) @Ignore public void testPutFileMethod() throws GenieException, IOException {
}"
90077,"/** 
 * Test the getFile method.
 * @throws GenieException If there is any problem
 * @throws IOException If there is any problem
 */
@Test(expected=GenieServerException.class) public void testGetFileMethod() throws GenieException, IOException {
  final ArgumentCaptor<CommandLine> argument=ArgumentCaptor.forClass(CommandLine.class);
  Mockito.when(this.executor.execute(Mockito.any())).thenThrow(IOException.class);
  this.localFileTransfer.getFile(SOURCE_FILE,DESTINATION_FILE);
  Mockito.verify(this.executor).execute(argument.capture());
  final List<String> expectedCommandLine=new ArrayList<>();
  expectedCommandLine.add(COPY_COMMAND);
  expectedCommandLine.add(SOURCE_FILE);
  expectedCommandLine.add(DESTINATION_FILE);
  Assert.assertArrayEquals(expectedCommandLine.toArray(),argument.getValue().getArguments());
}","/** 
 * Test the getFile method.
 * @throws GenieException If there is any problem
 * @throws IOException If there is any problem
 */
@Test @Ignore public void testGetFileMethod() throws GenieException, IOException {
}"
90078,"/** 
 * Takes in a Job Request persists it in db and then hands of the job to submitter interface to submit.
 * @param jobRequest of job to run
 * @param clientHost Hostname of the client sending request
 * @throws GenieException if there is an error
 */
@Override public String coordinateJob(@NotNull(message=""String_Node_Str"") @Valid final JobRequest jobRequest,final String clientHost) throws GenieException {
  log.debug(""String_Node_Str"",jobRequest);
  final JobRequest jobRequestWithId=this.jobPersistenceService.createJobRequest(jobRequest);
  if (StringUtils.isNotBlank(clientHost)) {
    this.jobPersistenceService.addClientHostToJobRequest(jobRequestWithId.getId(),clientHost);
  }
  String jobArchivalLocation=null;
  if (!jobRequestWithId.isDisableLogArchival()) {
    if (baseArchiveLocation == null) {
      throw new GeniePreconditionException(""String_Node_Str"");
    }
    jobArchivalLocation=baseArchiveLocation + ""String_Node_Str"" + jobRequestWithId.getId();
  }
  final Job job=new Job.Builder(jobRequest.getName(),jobRequest.getUser(),jobRequest.getVersion()).withArchiveLocation(jobArchivalLocation).withDescription(jobRequest.getDescription()).withId(jobRequestWithId.getId()).withStatus(JobStatus.INIT).withStatusMsg(""String_Node_Str"").build();
  this.jobPersistenceService.createJob(job);
  this.jobSubmitterService.submitJob(jobRequestWithId);
  return jobRequestWithId.getId();
}","/** 
 * Takes in a Job Request persists it in db and then hands of the job to submitter interface to submit.
 * @param jobRequest of job to run
 * @param clientHost Hostname of the client sending request
 * @return The id of the job just submitted.
 * @throws GenieException if there is an error
 */
@Override public String coordinateJob(@NotNull(message=""String_Node_Str"") @Valid final JobRequest jobRequest,final String clientHost) throws GenieException {
  log.debug(""String_Node_Str"",jobRequest);
  final JobRequest jobRequestWithId=this.jobPersistenceService.createJobRequest(jobRequest);
  if (StringUtils.isNotBlank(clientHost)) {
    this.jobPersistenceService.addClientHostToJobRequest(jobRequestWithId.getId(),clientHost);
  }
  String jobArchivalLocation=null;
  if (!jobRequestWithId.isDisableLogArchival()) {
    if (baseArchiveLocation == null) {
      throw new GeniePreconditionException(""String_Node_Str"");
    }
    jobArchivalLocation=baseArchiveLocation + ""String_Node_Str"" + jobRequestWithId.getId();
  }
  final Job job=new Job.Builder(jobRequest.getName(),jobRequest.getUser(),jobRequest.getVersion()).withArchiveLocation(jobArchivalLocation).withDescription(jobRequest.getDescription()).withId(jobRequestWithId.getId()).withStatus(JobStatus.INIT).withStatusMsg(""String_Node_Str"").build();
  this.jobPersistenceService.createJob(job);
  this.jobSubmitterService.submitJob(jobRequestWithId);
  return jobRequestWithId.getId();
}"
90079,"@Test @Ignore public void testGetJobs(){
}","/** 
 * Test the get jobs method.
 * @throws GenieException If there is any problem
 */
@Test @Ignore public void testGetJobs() throws GenieException {
}"
90080,"@Test public void testGetJob() throws GenieException {
  final ArgumentCaptor<String> argument=ArgumentCaptor.forClass(String.class);
  this.jobCoordinatorService.getJob(JOB_1_ID);
  Mockito.verify(this.jobPersistenceService).getJob(argument.capture());
  Assert.assertEquals(JOB_1_ID,argument.getValue());
}","/** 
 * Test the get job method to verify that the id sent is used to fetch from persistence service.
 * @throws GenieException If there is any problem
 */
@Test public void testGetJob() throws GenieException {
  final ArgumentCaptor<String> argument=ArgumentCaptor.forClass(String.class);
  this.jobCoordinatorService.getJob(JOB_1_ID);
  Mockito.verify(this.jobPersistenceService).getJob(argument.capture());
  Assert.assertEquals(JOB_1_ID,argument.getValue());
}"
90081,"@Test public void testCoordinateJobArchiveLocationEnabled() throws GenieException {
  final String clientHost=""String_Node_Str"";
  final JobRequest jobRequest=new JobRequest.Builder(JOB_1_NAME,JOB_1_USER,JOB_1_VERSION,null,null,null).withDisableLogArchival(false).withId(JOB_1_ID).build();
  Mockito.when(this.jobPersistenceService.createJobRequest(Mockito.eq(jobRequest))).thenReturn(jobRequest);
  final ArgumentCaptor<Job> argument=ArgumentCaptor.forClass(Job.class);
  this.jobCoordinatorService.coordinateJob(jobRequest,clientHost);
  Mockito.verify(this.jobPersistenceService).createJob(argument.capture());
  Assert.assertEquals(BASE_ARCHIVE_LOCATION + ""String_Node_Str"" + JOB_1_ID,argument.getValue().getArchiveLocation());
}","/** 
 * Test the coordinate job method with archive location enabled.
 * @throws GenieException If there is any problem
 */
@Test public void testCoordinateJobArchiveLocationEnabled() throws GenieException {
  final String clientHost=""String_Node_Str"";
  final JobRequest jobRequest=new JobRequest.Builder(JOB_1_NAME,JOB_1_USER,JOB_1_VERSION,null,null,null).withDisableLogArchival(false).withId(JOB_1_ID).build();
  Mockito.when(this.jobPersistenceService.createJobRequest(Mockito.eq(jobRequest))).thenReturn(jobRequest);
  final ArgumentCaptor<Job> argument=ArgumentCaptor.forClass(Job.class);
  this.jobCoordinatorService.coordinateJob(jobRequest,clientHost);
  Mockito.verify(this.jobPersistenceService).createJob(argument.capture());
  Assert.assertEquals(BASE_ARCHIVE_LOCATION + ""String_Node_Str"" + JOB_1_ID,argument.getValue().getArchiveLocation());
}"
90082,"@Test public void testCoordinateJobArchiveLocationDisabled() throws GenieException {
  final String clientHost=""String_Node_Str"";
  final JobRequest jobRequest=new JobRequest.Builder(JOB_1_NAME,JOB_1_USER,JOB_1_VERSION,null,null,null).withDisableLogArchival(true).withId(JOB_1_ID).build();
  Mockito.when(this.jobPersistenceService.createJobRequest(Mockito.eq(jobRequest))).thenReturn(jobRequest);
  final ArgumentCaptor<Job> argument=ArgumentCaptor.forClass(Job.class);
  this.jobCoordinatorService.coordinateJob(jobRequest,clientHost);
  Mockito.verify(this.jobPersistenceService).createJob(argument.capture());
  Assert.assertNull(argument.getValue().getArchiveLocation());
}","/** 
 * Test the coordinate job method with archive location disabled.
 * @throws GenieException If there is any problem
 */
@Test public void testCoordinateJobArchiveLocationDisabled() throws GenieException {
  final String clientHost=""String_Node_Str"";
  final JobRequest jobRequest=new JobRequest.Builder(JOB_1_NAME,JOB_1_USER,JOB_1_VERSION,null,null,null).withDisableLogArchival(true).withId(JOB_1_ID).build();
  Mockito.when(this.jobPersistenceService.createJobRequest(Mockito.eq(jobRequest))).thenReturn(jobRequest);
  final ArgumentCaptor<Job> argument=ArgumentCaptor.forClass(Job.class);
  this.jobCoordinatorService.coordinateJob(jobRequest,clientHost);
  Mockito.verify(this.jobPersistenceService).createJob(argument.capture());
  Assert.assertNull(argument.getValue().getArchiveLocation());
}"
90083,"@Test(expected=GeniePreconditionException.class) public void testCoordinateJobArchiveLocationEnabledBaseLocationMissing() throws GenieException {
  final String clientHost=""String_Node_Str"";
  final JobRequest jobRequest=new JobRequest.Builder(JOB_1_NAME,JOB_1_USER,JOB_1_VERSION,null,null,null).withDisableLogArchival(false).withId(JOB_1_ID).build();
  Mockito.when(this.jobPersistenceService.createJobRequest(Mockito.eq(jobRequest))).thenReturn(jobRequest);
  final ArgumentCaptor<Job> argument=ArgumentCaptor.forClass(Job.class);
  final JobCoordinatorService jobCoordinatorService=new JobCoordinatorServiceImpl(this.jobPersistenceService,this.jobSearchService,this.jobSubmitterService,null);
  jobCoordinatorService.coordinateJob(jobRequest,clientHost);
  Mockito.verify(this.jobPersistenceService).createJob(argument.capture());
  Assert.assertEquals(BASE_ARCHIVE_LOCATION + ""String_Node_Str"" + JOB_1_ID,argument.getValue().getArchiveLocation());
}","/** 
 * Test the coordinate job method with archive location enabled but base archive directory not set.
 * @throws GenieException If there is any problem
 */
@Test(expected=GeniePreconditionException.class) public void testCoordinateJobArchiveLocationEnabledBaseLocationMissing() throws GenieException {
  final String clientHost=""String_Node_Str"";
  final JobRequest jobRequest=new JobRequest.Builder(JOB_1_NAME,JOB_1_USER,JOB_1_VERSION,null,null,null).withDisableLogArchival(false).withId(JOB_1_ID).build();
  Mockito.when(this.jobPersistenceService.createJobRequest(Mockito.eq(jobRequest))).thenReturn(jobRequest);
  final ArgumentCaptor<Job> argument=ArgumentCaptor.forClass(Job.class);
  final JobCoordinatorService jcs=new JobCoordinatorServiceImpl(this.jobPersistenceService,this.jobSearchService,this.jobSubmitterService,null);
  jcs.coordinateJob(jobRequest,clientHost);
  Mockito.verify(this.jobPersistenceService).createJob(argument.capture());
  Assert.assertEquals(BASE_ARCHIVE_LOCATION + ""String_Node_Str"" + JOB_1_ID,argument.getValue().getArchiveLocation());
}"
90084,"/** 
 * Constructor Initialize the object using Job execution environment object.
 * @param fileCopyServiceImpls List of implementations of the file copy interface
 * @param jobExecEnv           The job execution environment details like the job, cluster,command and applications
 * @param mode Whether to run it in full genie mode or just local.
 * @throws GenieException Exception in case of an error
 */
public JobExecutor(final List<FileCopyService> fileCopyServiceImpls,@NotNull(message=""String_Node_Str"") final JobExecutionEnvironment jobExecEnv,final String mode) throws GenieException {
  this.fileCopyServiceImpls=fileCopyServiceImpls;
  this.jobExecEnv=jobExecEnv;
  this.mode=mode;
  if ((this.jobExecEnv.getJobWorkingDir() == null) || (StringUtils.isBlank(this.jobExecEnv.getJobWorkingDir()))) {
    throw new GenieServerException(""String_Node_Str"");
  }
 else {
    this.jobWorkingDir=jobExecEnv.getJobWorkingDir();
  }
  genieLauncherScript=this.jobWorkingDir + ""String_Node_Str"" + GENIE_JOB_LAUNCHER_SCRIPT;
  makeDir(jobExecEnv.getJobWorkingDir());
  makeDir(jobExecEnv.getJobWorkingDir() + ""String_Node_Str"");
  makeDir(jobExecEnv.getJobWorkingDir() + ""String_Node_Str"");
  initializeWriter();
}","/** 
 * Constructor Initialize the object using Job execution environment object.
 * @param fileCopyServiceImpls List of implementations of the file copy interface
 * @param jobExecEnv           The job execution environment details like the job, cluster,command and applications
 * @param mode Whether to run it in full genie mode or just local.
 * @throws GenieException Exception in case of an error
 */
public JobExecutor(final List<FileCopyService> fileCopyServiceImpls,@NotNull(message=""String_Node_Str"") final JobExecutionEnvironment jobExecEnv,final String mode) throws GenieException {
  this.fileCopyServiceImpls=fileCopyServiceImpls;
  this.jobExecEnv=jobExecEnv;
  this.mode=mode;
  if (this.jobExecEnv.getJobWorkingDir() == null || StringUtils.isBlank(this.jobExecEnv.getJobWorkingDir())) {
    throw new GenieServerException(""String_Node_Str"");
  }
 else {
    this.jobWorkingDir=jobExecEnv.getJobWorkingDir();
  }
  genieLauncherScript=this.jobWorkingDir + ""String_Node_Str"" + GENIE_JOB_LAUNCHER_SCRIPT;
  makeDir(jobExecEnv.getJobWorkingDir());
  makeDir(jobExecEnv.getJobWorkingDir() + ""String_Node_Str"");
  makeDir(jobExecEnv.getJobWorkingDir() + ""String_Node_Str"");
  initializeWriter();
}"
90085,"/** 
 * Set the number of cpu's being requested to run the job. Defaults to 1 if not set.
 * @param cpu The number of cpu's. Must be > 0.
 * @return The builder
 */
public Builder withCpu(@Min(1) final int cpu){
  this.bCpu=cpu;
  return this;
}","/** 
 * Set the number of cpu's being requested to run the job. Defaults to 1 if not set.
 * @param cpu The number of cpu's. Must be greater than 0.
 * @return The builder
 */
public Builder withCpu(@Min(1) final int cpu){
  this.bCpu=cpu;
  return this;
}"
90086,"/** 
 * Set the amount of memory being requested to run the job. Defaults to 1560 MB if not set.
 * @param memory The amount of memory in terms of MB's. Must be > 0.
 * @return The builder
 */
public Builder withMemory(@Min(1) final int memory){
  this.bMemory=memory;
  return this;
}","/** 
 * Set the amount of memory being requested to run the job. Defaults to 1560 MB if not set.
 * @param memory The amount of memory in terms of MB's. Must be greater than 0.
 * @return The builder
 */
public Builder withMemory(@Min(1) final int memory){
  this.bMemory=memory;
  return this;
}"
90087,"/** 
 * Get Applications based on user parameters.
 * @param name      name for configuration (optional)
 * @param userName  The user who created the application (optional)
 * @param statuses  The statuses of the applications (optional)
 * @param tags      The set of tags you want the command for.
 * @param page      The page to get
 * @param assembler The paged resources assembler to use
 * @return All applications matching the criteria
 * @throws GenieException For any error
 */
@RequestMapping(method=RequestMethod.GET,produces=MediaTypes.HAL_JSON_VALUE) @ResponseStatus(HttpStatus.OK) @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"",response=PagedResources.class,responseContainer=""String_Node_Str"") @ApiResponses(value={@ApiResponse(code=HttpURLConnection.HTTP_PRECON_FAILED,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_INTERNAL_ERROR,message=""String_Node_Str"")}) public PagedResources<ApplicationResource> getApplications(@ApiParam(value=""String_Node_Str"") @RequestParam(value=""String_Node_Str"",required=false) final String name,@ApiParam(value=""String_Node_Str"") @RequestParam(value=""String_Node_Str"",required=false) final String userName,@ApiParam(value=""String_Node_Str"",allowableValues=""String_Node_Str"") @RequestParam(value=""String_Node_Str"",required=false) final Set<String> statuses,@ApiParam(value=""String_Node_Str"") @RequestParam(value=""String_Node_Str"",required=false) final Set<String> tags,@PageableDefault(page=0,size=64,sort={""String_Node_Str""},direction=Sort.Direction.DESC) final Pageable page,final PagedResourcesAssembler<Application> assembler) throws GenieException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"");
    LOG.debug(name + ""String_Node_Str"" + userName+ ""String_Node_Str""+ statuses+ ""String_Node_Str""+ tags+ ""String_Node_Str""+ page);
  }
  Set<ApplicationStatus> enumStatuses=null;
  if (statuses != null && !statuses.isEmpty()) {
    enumStatuses=EnumSet.noneOf(ApplicationStatus.class);
    for (    final String status : statuses) {
      if (StringUtils.isNotBlank(status)) {
        enumStatuses.add(ApplicationStatus.parse(status));
      }
    }
  }
  final Link self=ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(ApplicationRestController.class).getApplications(name,userName,statuses,tags,page,null)).withSelfRel();
  return assembler.toResource(this.applicationService.getApplications(name,userName,enumStatuses,tags,page),this.applicationResourceAssembler,self);
}","/** 
 * Get Applications based on user parameters.
 * @param name      name for configuration (optional)
 * @param userName  The user who created the application (optional)
 * @param statuses  The statuses of the applications (optional)
 * @param tags      The set of tags you want the command for.
 * @param page      The page to get
 * @param assembler The paged resources assembler to use
 * @return All applications matching the criteria
 * @throws GenieException For any error
 */
@RequestMapping(method=RequestMethod.GET,produces=MediaTypes.HAL_JSON_VALUE) @ResponseStatus(HttpStatus.OK) @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"",response=PagedResources.class,responseContainer=""String_Node_Str"") @ApiResponses(value={@ApiResponse(code=HttpURLConnection.HTTP_PRECON_FAILED,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_INTERNAL_ERROR,message=""String_Node_Str"")}) public PagedResources<ApplicationResource> getApplications(@ApiParam(value=""String_Node_Str"") @RequestParam(value=""String_Node_Str"",required=false) final String name,@ApiParam(value=""String_Node_Str"") @RequestParam(value=""String_Node_Str"",required=false) final String userName,@ApiParam(value=""String_Node_Str"",allowableValues=""String_Node_Str"") @RequestParam(value=""String_Node_Str"",required=false) final Set<String> statuses,@ApiParam(value=""String_Node_Str"") @RequestParam(value=""String_Node_Str"",required=false) final Set<String> tags,@PageableDefault(page=0,size=64,sort={""String_Node_Str""},direction=Sort.Direction.DESC) final Pageable page,final PagedResourcesAssembler<Application> assembler) throws GenieException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"");
    LOG.debug(name + ""String_Node_Str"" + userName+ ""String_Node_Str""+ statuses+ ""String_Node_Str""+ tags+ ""String_Node_Str""+ page);
  }
  Set<ApplicationStatus> enumStatuses=null;
  if (statuses != null && !statuses.isEmpty()) {
    enumStatuses=EnumSet.noneOf(ApplicationStatus.class);
    for (    final String status : statuses) {
      if (StringUtils.isNotBlank(status)) {
        enumStatuses.add(ApplicationStatus.parse(status));
      }
    }
  }
  final Link self=ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(ApplicationRestController.class).getApplications(name,userName,statuses,tags,page,assembler)).withSelfRel();
  return assembler.toResource(this.applicationService.getApplications(name,userName,enumStatuses,tags,page),this.applicationResourceAssembler,self);
}"
90088,"/** 
 * Wait for job to complete, until the given timeout.
 * @param id           the Genie job ID to wait for completion
 * @param blockTimeout the time to block for (in ms), after which aGenieException will be thrown
 * @param pollTime     the time to sleep between polling for job status
 * @return the jobInfo for the job after completion
 * @throws GenieException       For any other error.
 * @throws InterruptedException on timeout/thread errors
 */
public Job waitForCompletion(final String id,final long blockTimeout,final long pollTime) throws GenieException, InterruptedException {
  if (StringUtils.isEmpty(id)) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  final long startTime=System.currentTimeMillis();
  while (true) {
    final Job job=getJob(id);
    if (!job.getFinished().equals(new Date(0))) {
      return job;
    }
    long currTime=System.currentTimeMillis();
    if (currTime - startTime < blockTimeout) {
      Thread.sleep(pollTime);
    }
 else {
      throw new InterruptedException(""String_Node_Str"");
    }
  }
}","/** 
 * Wait for job to complete, until the given timeout.
 * @param id           the Genie job ID to wait for completion
 * @param blockTimeout the time to block for (in ms), after which aGenieException will be thrown
 * @param pollTime     the time to sleep between polling for job status
 * @return the jobInfo for the job after completion
 * @throws GenieException       For any other error.
 * @throws InterruptedException on timeout/thread errors
 */
public Job waitForCompletion(final String id,final long blockTimeout,final long pollTime) throws GenieException, InterruptedException {
  if (StringUtils.isEmpty(id)) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  final long startTime=System.currentTimeMillis();
  while (true) {
    final Job job=getJob(id);
    final JobStatus status=job.getStatus();
    if (status == JobStatus.FAILED || status == JobStatus.KILLED || status == JobStatus.SUCCEEDED) {
      return job;
    }
    if (System.currentTimeMillis() - startTime < blockTimeout) {
      Thread.sleep(pollTime);
    }
 else {
      throw new InterruptedException(""String_Node_Str"");
    }
  }
}"
90089,"/** 
 * Get the time this entity was updated.
 * @return The updated timestamp
 */
@JsonProperty(""String_Node_Str"") @JsonSerialize(using=JsonDateSerializer.class) public Date getUpdated(){
  if (this.updated == null) {
    return null;
  }
 else {
    return new Date(this.updated.getTime());
  }
}","/** 
 * Get the time this entity was updated.
 * @return The updated timestamp
 */
public Date getUpdated(){
  if (this.updated == null) {
    return null;
  }
 else {
    return new Date(this.updated.getTime());
  }
}"
90090,"/** 
 * Get when this entity was created.
 * @return The created timestamps
 */
@JsonProperty(""String_Node_Str"") @JsonSerialize(using=JsonDateSerializer.class) public Date getCreated(){
  if (this.created == null) {
    return null;
  }
 else {
    return new Date(this.created.getTime());
  }
}","/** 
 * Get when this entity was created.
 * @return The created timestamps
 */
public Date getCreated(){
  if (this.created == null) {
    return null;
  }
 else {
    return new Date(this.created.getTime());
  }
}"
90091,"/** 
 * Set the created timestamp. This is a No-Op. Set once by system.
 * @param created The created timestamp
 */
@JsonIgnore public void setCreated(final Date created){
  LOG.info(""String_Node_Str"" + created + ""String_Node_Str""+ this.id+ ""String_Node_Str"");
}","/** 
 * Set the created timestamp. This is a No-Op. Set once by system.
 * @param created The created timestamp
 */
public void setCreated(final Date created){
  LOG.info(""String_Node_Str"" + created + ""String_Node_Str""+ this.id+ ""String_Node_Str"");
  this.created=new Date(created.getTime());
}"
90092,"/** 
 * Set the time this entity was updated. This is a No-Op. Updated automatically by system.
 * @param updated The updated timestamp
 */
@JsonIgnore public void setUpdated(final Date updated){
  LOG.info(""String_Node_Str"" + updated + ""String_Node_Str""+ this.id+ ""String_Node_Str"");
}","/** 
 * Set the time this entity was updated. This is a No-Op. Updated automatically by system.
 * @param updated The updated timestamp
 */
public void setUpdated(final Date updated){
  this.updated=new Date(updated.getTime());
}"
90093,"/** 
 * Gets the tags allocated to this application.
 * @return the tags as an unmodifiable list
 */
public Set<String> getTags(){
  if (this.tags == null) {
    this.tags=new HashSet<>();
  }
  return this.tags;
}","/** 
 * Gets the tags allocated to this application.
 * @return the tags
 */
public Set<String> getTags(){
  return this.tags;
}"
90094,"/** 
 * Gets the tags allocated to this cluster.
 * @return the tags as an unmodifiable list
 */
public Set<String> getTags(){
  if (this.tags == null) {
    this.tags=new HashSet<>();
  }
  return this.tags;
}","/** 
 * Gets the tags allocated to this cluster.
 * @return the tags
 */
public Set<String> getTags(){
  return this.tags;
}"
90095,"/** 
 * Check to make sure everything is OK before persisting.
 * @throws GeniePreconditionException If any precondition isn't met.
 */
@PrePersist @PreUpdate protected void onCreateOrUpdateCluster() throws GeniePreconditionException {
  validate(this.status,this.clusterType,this.configs,null);
  if (this.tags == null) {
    this.tags=new HashSet<>();
  }
  this.addAndValidateSystemTags(this.tags);
}","/** 
 * Check to make sure everything is OK before persisting.
 * @throws GeniePreconditionException If any precondition isn't met.
 */
@PrePersist @PreUpdate protected void onCreateOrUpdateCluster() throws GeniePreconditionException {
  validate(this.status,this.clusterType,null);
  if (this.tags == null) {
    this.tags=new HashSet<>();
  }
  this.addAndValidateSystemTags(this.tags);
}"
90096,"/** 
 * Helper method to ensure that values are valid for a cluster.
 * @param status      The status of the cluster
 * @param clusterType The type of cluster
 * @param configs     The configuration files for the cluster
 * @throws GeniePreconditionException If any precondition isn't met.
 */
private void validate(final ClusterStatus status,final String clusterType,final Set<String> configs,final String error) throws GeniePreconditionException {
  final StringBuilder builder=new StringBuilder();
  if (StringUtils.isNotBlank(error)) {
    builder.append(error);
  }
  if (status == null) {
    builder.append(""String_Node_Str"");
  }
  if (StringUtils.isBlank(clusterType)) {
    builder.append(""String_Node_Str"");
  }
  if (builder.length() > 0) {
    builder.insert(0,""String_Node_Str"");
    final String msg=builder.toString();
    LOG.error(msg);
    throw new GeniePreconditionException(msg);
  }
}","/** 
 * Helper method to ensure that values are valid for a cluster.
 * @param status      The status of the cluster
 * @param clusterType The type of cluster
 * @throws GeniePreconditionException If any precondition isn't met.
 */
private void validate(final ClusterStatus status,final String clusterType,final String error) throws GeniePreconditionException {
  final StringBuilder builder=new StringBuilder();
  if (StringUtils.isNotBlank(error)) {
    builder.append(error);
  }
  if (status == null) {
    builder.append(""String_Node_Str"");
  }
  if (StringUtils.isBlank(clusterType)) {
    builder.append(""String_Node_Str"");
  }
  if (builder.length() > 0) {
    builder.insert(0,""String_Node_Str"");
    final String msg=builder.toString();
    LOG.error(msg);
    throw new GeniePreconditionException(msg);
  }
}"
90097,"/** 
 * Gets the tags allocated to this command.
 * @return the tags as an unmodifiable list
 */
public Set<String> getTags(){
  if (this.tags == null) {
    this.tags=new HashSet<>();
  }
  return this.tags;
}","/** 
 * Gets the tags allocated to this command.
 * @return the tags
 */
public Set<String> getTags(){
  return this.tags;
}"
90098,"/** 
 * Gets the tags allocated to this job.
 * @return the tags as a list
 */
public Set<String> getTags(){
  if (this.tags == null) {
    this.tags=new HashSet<>();
  }
  return this.tags;
}","/** 
 * Gets the tags allocated to this job.
 * @return the tags
 */
public Set<String> getTags(){
  return this.tags;
}"
90099,"/** 
 * Test setting the tags.
 */
@Test public void testSetTags(){
  Assert.assertNotNull(this.a.getTags());
  final Set<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  tags.add(""String_Node_Str"");
  this.a.setTags(tags);
  Assert.assertEquals(tags,this.a.getTags());
}","/** 
 * Test setting the tags.
 */
@Test public void testSetTags(){
  Assert.assertNull(this.a.getTags());
  final Set<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  tags.add(""String_Node_Str"");
  this.a.setTags(tags);
  Assert.assertEquals(tags,this.a.getTags());
}"
90100,"/** 
 * Test setting the tags.
 * @throws GeniePreconditionException If any precondition isn't met.
 */
@Test public void testSetTags() throws GeniePreconditionException {
  Assert.assertNotNull(this.c.getTags());
  final Set<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  tags.add(""String_Node_Str"");
  this.c.setTags(tags);
  Assert.assertEquals(tags,this.c.getTags());
}","/** 
 * Test setting the tags.
 * @throws GeniePreconditionException If any precondition isn't met.
 */
@Test public void testSetTags() throws GeniePreconditionException {
  Assert.assertNull(this.c.getTags());
  final Set<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  tags.add(""String_Node_Str"");
  this.c.setTags(tags);
  Assert.assertEquals(tags,this.c.getTags());
}"
90101,"/** 
 * Test the argument Constructor.
 * @throws GeniePreconditionException If any precondition isn't met.
 */
@Test public void testConstructor() throws GeniePreconditionException {
  this.c=new Cluster(NAME,USER,ClusterStatus.UP,CLUSTER_TYPE,this.configs,VERSION);
  Assert.assertEquals(CLUSTER_TYPE,this.c.getClusterType());
  Assert.assertNull(this.c.getCommands());
  Assert.assertEquals(this.configs,this.c.getConfigs());
  Assert.assertEquals(NAME,this.c.getName());
  Assert.assertEquals(ClusterStatus.UP,this.c.getStatus());
  Assert.assertNotNull(this.c.getTags());
  Assert.assertEquals(USER,this.c.getUser());
  Assert.assertEquals(VERSION,this.c.getVersion());
}","/** 
 * Test the argument Constructor.
 * @throws GeniePreconditionException If any precondition isn't met.
 */
@Test public void testConstructor() throws GeniePreconditionException {
  this.c=new Cluster(NAME,USER,ClusterStatus.UP,CLUSTER_TYPE,this.configs,VERSION);
  Assert.assertEquals(CLUSTER_TYPE,this.c.getClusterType());
  Assert.assertNull(this.c.getCommands());
  Assert.assertEquals(this.configs,this.c.getConfigs());
  Assert.assertEquals(NAME,this.c.getName());
  Assert.assertEquals(ClusterStatus.UP,this.c.getStatus());
  Assert.assertNull(this.c.getTags());
  Assert.assertEquals(USER,this.c.getUser());
  Assert.assertEquals(VERSION,this.c.getVersion());
}"
90102,"/** 
 * Test the default Constructor.
 */
@Test public void testDefaultConstructor(){
  Assert.assertNull(this.c.getClusterType());
  Assert.assertNull(this.c.getCommands());
  Assert.assertNull(this.c.getConfigs());
  Assert.assertNull(this.c.getName());
  Assert.assertNull(this.c.getStatus());
  Assert.assertNotNull(this.c.getTags());
  Assert.assertNull(this.c.getUser());
  Assert.assertNull(this.c.getVersion());
}","/** 
 * Test the default Constructor.
 */
@Test public void testDefaultConstructor(){
  Assert.assertNull(this.c.getClusterType());
  Assert.assertNull(this.c.getCommands());
  Assert.assertNull(this.c.getConfigs());
  Assert.assertNull(this.c.getName());
  Assert.assertNull(this.c.getStatus());
  Assert.assertNull(this.c.getTags());
  Assert.assertNull(this.c.getUser());
  Assert.assertNull(this.c.getVersion());
}"
90103,"/** 
 * Test setting the tags.
 */
@Test public void testSetTags(){
  Assert.assertNotNull(this.c.getTags());
  final Set<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  tags.add(""String_Node_Str"");
  this.c.setTags(tags);
  Assert.assertEquals(tags,this.c.getTags());
}","/** 
 * Test setting the tags.
 */
@Test public void testSetTags(){
  Assert.assertNull(this.c.getTags());
  final Set<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  tags.add(""String_Node_Str"");
  this.c.setTags(tags);
  Assert.assertEquals(tags,this.c.getTags());
}"
90104,"/** 
 * Just test to make sure it doesn't try to do something weird with tags.
 * @throws GeniePreconditionException If any precondition isn't met.
 */
@Test public void testOnCreateOrUpdateJobWithNotNullTags() throws GeniePreconditionException {
  Assert.assertTrue(this.job.getTags().isEmpty());
  this.job.onCreateAuditable();
  this.job.onCreateOrUpdateCommonEntityFields();
  this.job.onCreateOrUpdateJob();
  Assert.assertNotNull(this.job.getTags());
  Assert.assertNotNull(this.job.getId());
  Assert.assertNotNull(this.job.getClusterCriteriasString());
  Assert.assertNotNull(this.job.getCommandCriteriaString());
  Assert.assertFalse(this.job.getTags().contains(CommonEntityFields.GENIE_ID_TAG_NAMESPACE + this.job.getId()));
  Assert.assertFalse(this.job.getTags().contains(CommonEntityFields.GENIE_NAME_TAG_NAMESPACE + this.job.getName()));
}","/** 
 * Just test to make sure it doesn't try to do something weird with tags.
 * @throws GeniePreconditionException If any precondition isn't met.
 */
@Test public void testOnCreateOrUpdateJobWithNotNullTags() throws GeniePreconditionException {
  Assert.assertNull(this.job.getTags());
  this.job.onCreateAuditable();
  this.job.onCreateOrUpdateCommonEntityFields();
  this.job.onCreateOrUpdateJob();
  Assert.assertNotNull(this.job.getTags());
  Assert.assertNotNull(this.job.getId());
  Assert.assertNotNull(this.job.getClusterCriteriasString());
  Assert.assertNotNull(this.job.getCommandCriteriaString());
  Assert.assertFalse(this.job.getTags().contains(CommonEntityFields.GENIE_ID_TAG_NAMESPACE + this.job.getId()));
  Assert.assertFalse(this.job.getTags().contains(CommonEntityFields.GENIE_NAME_TAG_NAMESPACE + this.job.getName()));
}"
90105,"/** 
 * Test the setter and the getter for tags.
 */
@Test public void testSetGetTags(){
  Assert.assertTrue(this.job.getTags().isEmpty());
  final Set<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  tags.add(""String_Node_Str"");
  this.job.setTags(tags);
  Assert.assertEquals(tags,this.job.getTags());
}","/** 
 * Test the setter and the getter for tags.
 */
@Test public void testSetGetTags(){
  Assert.assertNull(this.job.getTags());
  final Set<String> tags=new HashSet<>();
  tags.add(""String_Node_Str"");
  tags.add(""String_Node_Str"");
  this.job.setTags(tags);
  Assert.assertEquals(tags,this.job.getTags());
}"
90106,"/** 
 * {@inheritDoc}
 */
@Override public void launch() throws GenieException {
  LOG.info(""String_Node_Str"");
  if (!this.isInitCalled()) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  final List<String> processArgs=this.createBaseProcessArguments();
  processArgs.add(""String_Node_Str"" + this.getCluster().getName() + ""String_Node_Str"");
  processArgs.add(""String_Node_Str"");
  processArgs.add(""String_Node_Str"");
  processArgs.addAll(Arrays.asList(StringUtil.splitCmdLine(this.getJob().getCommandArgs())));
  final ProcessBuilder processBuilder=new ProcessBuilder(processArgs);
  this.setupCommonProcess(processBuilder);
  this.setupPrestoProcess(processBuilder);
  this.launchProcess(processBuilder);
}","/** 
 * {@inheritDoc}
 */
@Override public void launch() throws GenieException {
  LOG.info(""String_Node_Str"");
  if (!this.isInitCalled()) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  final List<String> processArgs=this.createBaseProcessArguments();
  processArgs.add(""String_Node_Str"");
  processArgs.add(""String_Node_Str"" + this.getCluster().getName() + ""String_Node_Str"");
  processArgs.add(""String_Node_Str"");
  processArgs.add(""String_Node_Str"");
  processArgs.add(""String_Node_Str"");
  processArgs.addAll(Arrays.asList(StringUtil.splitCmdLine(this.getJob().getCommandArgs())));
  final ProcessBuilder processBuilder=new ProcessBuilder(processArgs);
  this.setupCommonProcess(processBuilder);
  this.setupPrestoProcess(processBuilder);
  this.launchProcess(processBuilder);
}"
90107,"/** 
 * {@inheritDoc}
 */
@Override public void launch() throws GenieException {
  LOG.info(""String_Node_Str"");
  if (!this.isInitCalled()) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  final String prestoProtocol=ConfigurationManager.getConfigInstance().getString(PRESTO_PROTOCOL_KEY,null);
  if (prestoProtocol == null) {
    throw new GeniePreconditionException(""String_Node_Str"" + PRESTO_PROTOCOL_KEY);
  }
  final String prestoMasterDomain=ConfigurationManager.getConfigInstance().getString(PRESTO_MASTER_DOMAIN,null);
  if (prestoMasterDomain == null) {
    throw new GeniePreconditionException(""String_Node_Str"" + PRESTO_MASTER_DOMAIN);
  }
  final List<String> processArgs=this.createBaseProcessArguments();
  processArgs.add(""String_Node_Str"");
  processArgs.add(PRESTO_PROTOCOL_KEY + this.getCluster().getName() + PRESTO_MASTER_DOMAIN);
  processArgs.add(""String_Node_Str"");
  processArgs.add(""String_Node_Str"");
  processArgs.add(""String_Node_Str"");
  processArgs.addAll(Arrays.asList(StringUtil.splitCmdLine(this.getJob().getCommandArgs())));
  final ProcessBuilder processBuilder=new ProcessBuilder(processArgs);
  this.setupCommonProcess(processBuilder);
  this.setupPrestoProcess(processBuilder);
  this.launchProcess(processBuilder);
}","/** 
 * {@inheritDoc}
 */
@Override public void launch() throws GenieException {
  LOG.info(""String_Node_Str"");
  if (!this.isInitCalled()) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  final String prestoProtocol=ConfigurationManager.getConfigInstance().getString(PRESTO_PROTOCOL_KEY,null);
  if (prestoProtocol == null) {
    throw new GeniePreconditionException(""String_Node_Str"" + PRESTO_PROTOCOL_KEY);
  }
  final String prestoMasterDomain=ConfigurationManager.getConfigInstance().getString(PRESTO_MASTER_DOMAIN,null);
  if (prestoMasterDomain == null) {
    throw new GeniePreconditionException(""String_Node_Str"" + PRESTO_MASTER_DOMAIN);
  }
  final List<String> processArgs=this.createBaseProcessArguments();
  processArgs.add(""String_Node_Str"");
  processArgs.add(prestoProtocol + this.getCluster().getName() + prestoMasterDomain);
  processArgs.add(""String_Node_Str"");
  processArgs.add(""String_Node_Str"");
  processArgs.add(""String_Node_Str"");
  processArgs.addAll(Arrays.asList(StringUtil.splitCmdLine(this.getJob().getCommandArgs())));
  final ProcessBuilder processBuilder=new ProcessBuilder(processArgs);
  this.setupCommonProcess(processBuilder);
  this.setupPrestoProcess(processBuilder);
  this.launchProcess(processBuilder);
}"
90108,"/** 
 * Test setting the status.
 */
@Test public void testSetStatus(){
  Assert.assertEquals(ApplicationStatus.INACTIVE,this.a.getStatus());
  this.a.setStatus(ApplicationStatus.ACTIVE);
  Assert.assertEquals(ApplicationStatus.ACTIVE,this.a.getStatus());
}","/** 
 * Test setting the status.
 */
@Test public void testSetStatus(){
  Assert.assertNull(this.a.getStatus());
  this.a.setStatus(ApplicationStatus.ACTIVE);
  Assert.assertEquals(ApplicationStatus.ACTIVE,this.a.getStatus());
}"
90109,"/** 
 * Test the default Constructor.
 */
@Test public void testDefaultConstructor(){
  Assert.assertNull(this.a.getCommands());
  Assert.assertNull(this.a.getConfigs());
  Assert.assertNull(this.a.getEnvPropFile());
  Assert.assertEquals(ApplicationStatus.INACTIVE,this.a.getStatus());
  Assert.assertNull(this.a.getJars());
  Assert.assertNull(this.a.getName());
  Assert.assertNull(this.a.getUser());
  Assert.assertNull(this.a.getVersion());
}","/** 
 * Test the default Constructor.
 */
@Test public void testDefaultConstructor(){
  Assert.assertNull(this.a.getCommands());
  Assert.assertNull(this.a.getConfigs());
  Assert.assertNull(this.a.getEnvPropFile());
  Assert.assertNull(this.a.getStatus());
  Assert.assertNull(this.a.getJars());
  Assert.assertNull(this.a.getName());
  Assert.assertNull(this.a.getUser());
  Assert.assertNull(this.a.getVersion());
}"
90110,"/** 
 * Test setting the status.
 */
@Test public void testSetStatus(){
  Assert.assertEquals(ClusterStatus.OUT_OF_SERVICE,this.c.getStatus());
  this.c.setStatus(ClusterStatus.TERMINATED);
  Assert.assertEquals(ClusterStatus.TERMINATED,this.c.getStatus());
}","/** 
 * Test setting the status.
 */
@Test public void testSetStatus(){
  Assert.assertNull(this.c.getStatus());
  this.c.setStatus(ClusterStatus.TERMINATED);
  Assert.assertEquals(ClusterStatus.TERMINATED,this.c.getStatus());
}"
90111,"/** 
 * Test the default Constructor.
 */
@Test public void testDefaultConstructor(){
  Assert.assertNull(this.c.getClusterType());
  Assert.assertNull(this.c.getCommands());
  Assert.assertNull(this.c.getConfigs());
  Assert.assertNull(this.c.getName());
  Assert.assertEquals(ClusterStatus.OUT_OF_SERVICE,this.c.getStatus());
  Assert.assertNotNull(this.c.getTags());
  Assert.assertNull(this.c.getUser());
  Assert.assertNull(this.c.getVersion());
}","/** 
 * Test the default Constructor.
 */
@Test public void testDefaultConstructor(){
  Assert.assertNull(this.c.getClusterType());
  Assert.assertNull(this.c.getCommands());
  Assert.assertNull(this.c.getConfigs());
  Assert.assertNull(this.c.getName());
  Assert.assertNull(this.c.getStatus());
  Assert.assertNotNull(this.c.getTags());
  Assert.assertNull(this.c.getUser());
  Assert.assertNull(this.c.getVersion());
}"
90112,"/** 
 * Test setting the status.
 */
@Test public void testSetStatus(){
  Assert.assertEquals(CommandStatus.INACTIVE,this.c.getStatus());
  this.c.setStatus(CommandStatus.ACTIVE);
  Assert.assertEquals(CommandStatus.ACTIVE,this.c.getStatus());
}","/** 
 * Test setting the status.
 */
@Test public void testSetStatus(){
  Assert.assertNull(this.c.getStatus());
  this.c.setStatus(CommandStatus.ACTIVE);
  Assert.assertEquals(CommandStatus.ACTIVE,this.c.getStatus());
}"
90113,"/** 
 * Test the default Constructor.
 */
@Test public void testDefaultConstructor(){
  Assert.assertNull(this.c.getApplication());
  Assert.assertNull(this.c.getClusters());
  Assert.assertNull(this.c.getConfigs());
  Assert.assertNull(this.c.getEnvPropFile());
  Assert.assertNull(this.c.getExecutable());
  Assert.assertNull(this.c.getJobType());
  Assert.assertNull(this.c.getName());
  Assert.assertEquals(CommandStatus.INACTIVE,this.c.getStatus());
  Assert.assertNull(this.c.getUser());
  Assert.assertNull(this.c.getVersion());
}","/** 
 * Test the default Constructor.
 */
@Test public void testDefaultConstructor(){
  Assert.assertNull(this.c.getApplication());
  Assert.assertNull(this.c.getClusters());
  Assert.assertNull(this.c.getConfigs());
  Assert.assertNull(this.c.getEnvPropFile());
  Assert.assertNull(this.c.getExecutable());
  Assert.assertNull(this.c.getJobType());
  Assert.assertNull(this.c.getName());
  Assert.assertNull(this.c.getStatus());
  Assert.assertNull(this.c.getUser());
  Assert.assertNull(this.c.getVersion());
}"
90114,"/** 
 * Find jobs based on the parameters.
 * @param id The job id
 * @param jobName The job name
 * @param userName The user who created the job
 * @param status The job status
 * @param clusterName The cluster name
 * @param clusterId The cluster id
 * @return The specification
 */
public static Specification<Job> find(final String id,final String jobName,final String userName,final JobStatus status,final String clusterName,final String clusterId){
  return new Specification<Job>(){
    @Override public Predicate toPredicate(    final Root<Job> root,    final CriteriaQuery<?> cq,    final CriteriaBuilder cb){
      final List<Predicate> predicates=new ArrayList<>();
      if (StringUtils.isNotBlank(id)) {
        predicates.add(cb.like(root.get(Job_.id),id));
      }
      if (StringUtils.isNotBlank(jobName)) {
        predicates.add(cb.like(root.get(Job_.name),jobName));
      }
      if (StringUtils.isNotBlank(userName)) {
        predicates.add(cb.equal(root.get(Job_.user),userName));
      }
      if (status != null) {
        predicates.add(cb.equal(root.get(Job_.status),status));
      }
      if (StringUtils.isNotBlank(clusterName)) {
        predicates.add(cb.equal(root.get(Job_.executionClusterName),clusterName));
      }
      if (StringUtils.isNotBlank(clusterId)) {
        predicates.add(cb.equal(root.get(Job_.executionClusterId),clusterId));
      }
      return cb.and(predicates.toArray(new Predicate[predicates.size()]));
    }
  }
;
}","/** 
 * Find jobs based on the parameters.
 * @param id The job id
 * @param jobName The job name
 * @param userName The user who created the job
 * @param status The job status
 * @param clusterName The cluster name
 * @param clusterId The cluster id
 * @return The specification
 */
public static Specification<Job> find(final String id,final String jobName,final String userName,final JobStatus status,final Set<String> tags,final String clusterName,final String clusterId){
  return new Specification<Job>(){
    @Override public Predicate toPredicate(    final Root<Job> root,    final CriteriaQuery<?> cq,    final CriteriaBuilder cb){
      final List<Predicate> predicates=new ArrayList<>();
      if (StringUtils.isNotBlank(id)) {
        predicates.add(cb.like(root.get(Job_.id),id));
      }
      if (StringUtils.isNotBlank(jobName)) {
        predicates.add(cb.like(root.get(Job_.name),jobName));
      }
      if (StringUtils.isNotBlank(userName)) {
        predicates.add(cb.equal(root.get(Job_.user),userName));
      }
      if (status != null) {
        predicates.add(cb.equal(root.get(Job_.status),status));
      }
      if (tags != null) {
        for (        final String tag : tags) {
          predicates.add(cb.isMember(tag,root.get(Job_.tags)));
        }
      }
      if (StringUtils.isNotBlank(clusterName)) {
        predicates.add(cb.equal(root.get(Job_.executionClusterName),clusterName));
      }
      if (StringUtils.isNotBlank(clusterId)) {
        predicates.add(cb.equal(root.get(Job_.executionClusterId),clusterId));
      }
      return cb.and(predicates.toArray(new Predicate[predicates.size()]));
    }
  }
;
}"
90115,"/** 
 * Get jobs for given filter criteria.
 * @param id          id for job
 * @param name        name of job (can be a SQL-style pattern such as HIVE%)
 * @param userName    user who submitted job
 * @param status      status of job - possible types Type.JobStatus
 * @param clusterName the name of the cluster
 * @param clusterId   the id of the cluster
 * @param page        page number for job
 * @param limit       max number of jobs to return
 * @return successful response, or one with HTTP error code
 * @throws GenieException For any error
 */
@GET @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"",response=Job.class,responseContainer=""String_Node_Str"") @ApiResponses(value={@ApiResponse(code=HttpURLConnection.HTTP_OK,message=""String_Node_Str"",response=Job.class),@ApiResponse(code=HttpURLConnection.HTTP_BAD_REQUEST,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_NOT_FOUND,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_PRECON_FAILED,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_INTERNAL_ERROR,message=""String_Node_Str"")}) public List<Job> getJobs(@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final String id,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final String name,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final String userName,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final String status,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final String clusterName,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final String clusterId,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") int page,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") int limit) throws GenieException {
  LOG.info(""String_Node_Str"");
  LOG.info(id + ""String_Node_Str"" + name+ ""String_Node_Str""+ userName+ ""String_Node_Str""+ status+ ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ clusterId+ ""String_Node_Str""+ page+ ""String_Node_Str""+ limit);
  @SuppressWarnings(""String_Node_Str"") final List<Job> jobs=this.jobService.getJobs(id,name,userName,((status == null) || (status.isEmpty()) ? null : JobStatus.parse(status)),clusterName,clusterId,page,limit);
  return jobs;
}","/** 
 * Get jobs for given filter criteria.
 * @param id          id for job
 * @param name        name of job (can be a SQL-style pattern such as HIVE%)
 * @param userName    user who submitted job
 * @param status      status of job - possible types Type.JobStatus
 * @param tags          tags for the job
 * @param clusterName the name of the cluster
 * @param clusterId   the id of the cluster
 * @param page        page number for job
 * @param limit       max number of jobs to return
 * @return successful response, or one with HTTP error code
 * @throws GenieException For any error
 */
@GET @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"",response=Job.class,responseContainer=""String_Node_Str"") @ApiResponses(value={@ApiResponse(code=HttpURLConnection.HTTP_OK,message=""String_Node_Str"",response=Job.class),@ApiResponse(code=HttpURLConnection.HTTP_BAD_REQUEST,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_NOT_FOUND,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_PRECON_FAILED,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_INTERNAL_ERROR,message=""String_Node_Str"")}) public List<Job> getJobs(@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final String id,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final String name,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final String userName,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final String status,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final Set<String> tags,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final String clusterName,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") final String clusterId,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") int page,@ApiParam(value=""String_Node_Str"",required=false) @QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") int limit) throws GenieException {
  LOG.info(""String_Node_Str"");
  LOG.info(id + ""String_Node_Str"" + name+ ""String_Node_Str""+ userName+ ""String_Node_Str""+ status+ ""String_Node_Str""+ tags+ ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ clusterId+ ""String_Node_Str""+ page+ ""String_Node_Str""+ limit);
  @SuppressWarnings(""String_Node_Str"") final List<Job> jobs=this.jobService.getJobs(id,name,userName,((status == null) || (status.isEmpty()) ? null : JobStatus.parse(status)),tags,clusterName,clusterId,page,limit);
  return jobs;
}"
90116,"/** 
 * Get job info for given filter criteria.
 * @param id          id for job
 * @param jobName     name of job (can be a SQL-style pattern such as HIVE%)
 * @param userName    user who submitted job
 * @param status      status of job - possible types Type.JobStatus
 * @param clusterName name of cluster for job
 * @param clusterId   id of cluster for job
 * @param page        page number for job
 * @param limit       max number of jobs to return
 * @return All jobs which match the criteria
 */
List getJobs(final String id,final String jobName,final String userName,final JobStatus status,final String clusterName,final String clusterId,final int page,final int limit);","/** 
 * Get job info for given filter criteria.
 * @param id          id for job
 * @param jobName     name of job (can be a SQL-style pattern such as HIVE%)
 * @param userName    user who submitted job
 * @param status      status of job - possible types Type.JobStatus
 * @param tags          tags for the job
 * @param clusterName name of cluster for job
 * @param clusterId   id of cluster for job
 * @param page        page number for job
 * @param limit       max number of jobs to return
 * @return All jobs which match the criteria
 */
List getJobs(final String id,final String jobName,final String userName,final JobStatus status,final Set<String> tags,final String clusterName,final String clusterId,final int page,final int limit);"
90117,"/** 
 * {@inheritDoc}
 */
@Override @Transactional(rollbackFor=GenieException.class) public JobStatus finalizeJob(final String id,final int exitCode) throws GenieException {
  final Job job=this.jobRepo.findOne(id);
  if (job == null) {
    throw new GenieNotFoundException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  job.setExitCode(exitCode);
  if (job.getStatus() != null && job.getStatus() != JobStatus.KILLED) {
    if (exitCode != ProcessStatus.SUCCESS.getExitCode()) {
      LOG.error(""String_Node_Str"" + exitCode);
      String errMsg;
      try {
        errMsg=ProcessStatus.parse(exitCode).getMessage();
      }
 catch (      final GenieException ge) {
        errMsg=""String_Node_Str"";
      }
      job.setJobStatus(JobStatus.FAILED,""String_Node_Str"" + errMsg);
      this.stats.incrGenieFailedJobs();
    }
 else {
      job.setJobStatus(JobStatus.SUCCEEDED,""String_Node_Str"");
      this.stats.incrGenieSuccessfulJobs();
    }
    if (!job.isDisableLogArchival()) {
      job.setArchiveLocation(NetUtil.getArchiveURI(job.getId()));
    }
    job.setUpdated(new Date());
    return job.getStatus();
  }
 else {
    LOG.debug(""String_Node_Str"" + job.getId());
    return JobStatus.KILLED;
  }
}","/** 
 * {@inheritDoc}
 */
@Override @Transactional(rollbackFor=GenieException.class) public JobStatus finalizeJob(final String id,final int exitCode) throws GenieException {
  final Job job=this.jobRepo.findOne(id);
  if (job == null) {
    throw new GenieNotFoundException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  job.setExitCode(exitCode);
  if (exitCode == ProcessStatus.JOB_KILLED.getExitCode()) {
    LOG.debug(""String_Node_Str"");
    job.setJobStatus(JobStatus.KILLED,""String_Node_Str"");
    return JobStatus.KILLED;
  }
 else {
    if (exitCode != ProcessStatus.SUCCESS.getExitCode()) {
      LOG.error(""String_Node_Str"" + exitCode);
      String errMsg;
      try {
        errMsg=ProcessStatus.parse(exitCode).getMessage();
      }
 catch (      final GenieException ge) {
        errMsg=""String_Node_Str"";
      }
      job.setJobStatus(JobStatus.FAILED,""String_Node_Str"" + errMsg);
      this.stats.incrGenieFailedJobs();
    }
 else {
      job.setJobStatus(JobStatus.SUCCEEDED,""String_Node_Str"");
      this.stats.incrGenieSuccessfulJobs();
    }
    if (!job.isDisableLogArchival()) {
      job.setArchiveLocation(NetUtil.getArchiveURI(job.getId()));
    }
    job.setUpdated(new Date());
    return job.getStatus();
  }
}"
90118,"/** 
 * {@inheritDoc}
 */
@Override @Transactional(readOnly=true) public List<Job> getJobs(final String id,final String jobName,final String userName,final JobStatus status,final String clusterName,final String clusterId,final int page,final int limit){
  LOG.debug(""String_Node_Str"");
  final PageRequest pageRequest=new PageRequest(page < 0 ? 0 : page,limit < 1 ? 1024 : limit,Direction.DESC,Job_.updated.getName());
  @SuppressWarnings(""String_Node_Str"") final List<Job> jobs=this.jobRepo.findAll(JobSpecs.find(id,jobName,userName,status,clusterName,clusterId),pageRequest).getContent();
  return jobs;
}","/** 
 * {@inheritDoc}
 */
@Override @Transactional(readOnly=true) public List<Job> getJobs(final String id,final String jobName,final String userName,final JobStatus status,final Set<String> tags,final String clusterName,final String clusterId,final int page,final int limit){
  LOG.debug(""String_Node_Str"");
  final PageRequest pageRequest=new PageRequest(page < 0 ? 0 : page,limit < 1 ? 1024 : limit,Direction.DESC,Job_.updated.getName());
  @SuppressWarnings(""String_Node_Str"") final List<Job> jobs=this.jobRepo.findAll(JobSpecs.find(id,jobName,userName,status,tags,clusterName,clusterId),pageRequest).getContent();
  return jobs;
}"
90119,"/** 
 * Test the find specification.
 */
@Test public void testFindWithOutJobName(){
  final Specification<Job> spec=JobSpecs.find(ID,""String_Node_Str"",USER_NAME,JobStatus.INIT,CLUSTER_NAME,CLUSTER_ID);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.never()).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}","/** 
 * Test the find specification.
 */
@Test public void testFindWithOutJobName(){
  final Specification<Job> spec=JobSpecs.find(ID,""String_Node_Str"",USER_NAME,JobStatus.INIT,TAGS,CLUSTER_NAME,CLUSTER_ID);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.never()).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}"
90120,"/** 
 * Test the find specification.
 */
@Test public void testFindWithOutClusterId(){
  final Specification<Job> spec=JobSpecs.find(ID,JOB_NAME,USER_NAME,JobStatus.INIT,CLUSTER_NAME,null);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.never()).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}","/** 
 * Test the find specification.
 */
@Test public void testFindWithOutClusterId(){
  final Specification<Job> spec=JobSpecs.find(ID,JOB_NAME,USER_NAME,JobStatus.INIT,TAGS,CLUSTER_NAME,null);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.never()).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}"
90121,"/** 
 * Setup the mocks.
 */
@Before @SuppressWarnings(""String_Node_Str"") public void setup(){
  this.root=(Root<Job>)Mockito.mock(Root.class);
  this.cq=Mockito.mock(CriteriaQuery.class);
  this.cb=Mockito.mock(CriteriaBuilder.class);
  final Path<String> idPath=(Path<String>)Mockito.mock(Path.class);
  final Predicate likeIdPredicate=Mockito.mock(Predicate.class);
  Mockito.when(this.root.get(Job_.id)).thenReturn(idPath);
  Mockito.when(this.cb.like(idPath,ID)).thenReturn(likeIdPredicate);
  final Path<String> jobNamePath=(Path<String>)Mockito.mock(Path.class);
  final Predicate likeJobNamePredicate=Mockito.mock(Predicate.class);
  Mockito.when(this.root.get(Job_.name)).thenReturn(jobNamePath);
  Mockito.when(this.cb.like(jobNamePath,JOB_NAME)).thenReturn(likeJobNamePredicate);
  final Path<String> userNamePath=(Path<String>)Mockito.mock(Path.class);
  final Predicate equalUserNamePredicate=Mockito.mock(Predicate.class);
  Mockito.when(this.root.get(Job_.user)).thenReturn(userNamePath);
  Mockito.when(this.cb.equal(userNamePath,USER_NAME)).thenReturn(equalUserNamePredicate);
  final Path<JobStatus> statusPath=(Path<JobStatus>)Mockito.mock(Path.class);
  final Predicate equalStatusPredicate=Mockito.mock(Predicate.class);
  Mockito.when(this.root.get(Job_.status)).thenReturn(statusPath);
  Mockito.when(this.cb.equal(statusPath,JobStatus.INIT)).thenReturn(equalStatusPredicate);
  final Path<String> clusterNamePath=(Path<String>)Mockito.mock(Path.class);
  final Predicate equalClusterNamePredicate=Mockito.mock(Predicate.class);
  Mockito.when(this.root.get(Job_.executionClusterName)).thenReturn(clusterNamePath);
  Mockito.when(this.cb.equal(clusterNamePath,CLUSTER_NAME)).thenReturn(equalClusterNamePredicate);
  final Path<String> clusterIdPath=(Path<String>)Mockito.mock(Path.class);
  final Predicate equalClusterIdPredicate=Mockito.mock(Predicate.class);
  Mockito.when(this.root.get(Job_.executionClusterId)).thenReturn(clusterIdPath);
  Mockito.when(this.cb.equal(clusterIdPath,CLUSTER_ID)).thenReturn(equalClusterIdPredicate);
}","/** 
 * Setup the mocks.
 */
@Before @SuppressWarnings(""String_Node_Str"") public void setup(){
  TAGS.add(""String_Node_Str"");
  this.root=(Root<Job>)Mockito.mock(Root.class);
  this.cq=Mockito.mock(CriteriaQuery.class);
  this.cb=Mockito.mock(CriteriaBuilder.class);
  final Path<String> idPath=(Path<String>)Mockito.mock(Path.class);
  final Predicate likeIdPredicate=Mockito.mock(Predicate.class);
  Mockito.when(this.root.get(Job_.id)).thenReturn(idPath);
  Mockito.when(this.cb.like(idPath,ID)).thenReturn(likeIdPredicate);
  final Path<String> jobNamePath=(Path<String>)Mockito.mock(Path.class);
  final Predicate likeJobNamePredicate=Mockito.mock(Predicate.class);
  Mockito.when(this.root.get(Job_.name)).thenReturn(jobNamePath);
  Mockito.when(this.cb.like(jobNamePath,JOB_NAME)).thenReturn(likeJobNamePredicate);
  final Path<String> userNamePath=(Path<String>)Mockito.mock(Path.class);
  final Predicate equalUserNamePredicate=Mockito.mock(Predicate.class);
  Mockito.when(this.root.get(Job_.user)).thenReturn(userNamePath);
  Mockito.when(this.cb.equal(userNamePath,USER_NAME)).thenReturn(equalUserNamePredicate);
  final Path<JobStatus> statusPath=(Path<JobStatus>)Mockito.mock(Path.class);
  final Predicate equalStatusPredicate=Mockito.mock(Predicate.class);
  Mockito.when(this.root.get(Job_.status)).thenReturn(statusPath);
  Mockito.when(this.cb.equal(statusPath,JobStatus.INIT)).thenReturn(equalStatusPredicate);
  Mockito.when(this.cb.equal(statusPath,JobStatus.INIT)).thenReturn(equalStatusPredicate);
  final Path<String> clusterNamePath=(Path<String>)Mockito.mock(Path.class);
  final Predicate equalClusterNamePredicate=Mockito.mock(Predicate.class);
  Mockito.when(this.root.get(Job_.executionClusterName)).thenReturn(clusterNamePath);
  Mockito.when(this.cb.equal(clusterNamePath,CLUSTER_NAME)).thenReturn(equalClusterNamePredicate);
  final Path<String> clusterIdPath=(Path<String>)Mockito.mock(Path.class);
  final Predicate equalClusterIdPredicate=Mockito.mock(Predicate.class);
  Mockito.when(this.root.get(Job_.executionClusterId)).thenReturn(clusterIdPath);
  Mockito.when(this.cb.equal(clusterIdPath,CLUSTER_ID)).thenReturn(equalClusterIdPredicate);
}"
90122,"/** 
 * Test the find specification.
 */
@Test public void testFindWithOutUserName(){
  final Specification<Job> spec=JobSpecs.find(ID,JOB_NAME,""String_Node_Str"",JobStatus.INIT,CLUSTER_NAME,CLUSTER_ID);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.never()).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}","/** 
 * Test the find specification.
 */
@Test public void testFindWithOutUserName(){
  final Specification<Job> spec=JobSpecs.find(ID,JOB_NAME,""String_Node_Str"",JobStatus.INIT,TAGS,CLUSTER_NAME,CLUSTER_ID);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.never()).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}"
90123,"/** 
 * Test the find specification.
 */
@Test public void testFindWithOutStatus(){
  final Specification<Job> spec=JobSpecs.find(ID,JOB_NAME,USER_NAME,null,CLUSTER_NAME,CLUSTER_ID);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.never()).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}","/** 
 * Test the find specification.
 */
@Test public void testFindWithOutStatus(){
  final Specification<Job> spec=JobSpecs.find(ID,JOB_NAME,USER_NAME,null,TAGS,CLUSTER_NAME,CLUSTER_ID);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.never()).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}"
90124,"/** 
 * Test the find specification.
 */
@Test public void testFindWithAll(){
  final Specification<Job> spec=JobSpecs.find(ID,JOB_NAME,USER_NAME,JobStatus.INIT,CLUSTER_NAME,CLUSTER_ID);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}","/** 
 * Test the find specification.
 */
@Test public void testFindWithAll(){
  final Specification<Job> spec=JobSpecs.find(ID,JOB_NAME,USER_NAME,JobStatus.INIT,TAGS,CLUSTER_NAME,CLUSTER_ID);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}"
90125,"/** 
 * Test the find specification.
 */
@Test public void testFindWithOutId(){
  final Specification<Job> spec=JobSpecs.find(null,JOB_NAME,USER_NAME,JobStatus.INIT,CLUSTER_NAME,CLUSTER_ID);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.never()).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}","/** 
 * Test the find specification.
 */
@Test public void testFindWithOutId(){
  final Specification<Job> spec=JobSpecs.find(null,JOB_NAME,USER_NAME,JobStatus.INIT,TAGS,CLUSTER_NAME,CLUSTER_ID);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.never()).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}"
90126,"/** 
 * Test the find specification.
 */
@Test public void testFindWithOutClusterName(){
  final Specification<Job> spec=JobSpecs.find(ID,JOB_NAME,USER_NAME,JobStatus.INIT,null,CLUSTER_ID);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.never()).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}","/** 
 * Test the find specification.
 */
@Test public void testFindWithOutClusterName(){
  final Specification<Job> spec=JobSpecs.find(ID,JOB_NAME,USER_NAME,JobStatus.INIT,TAGS,null,CLUSTER_ID);
  spec.toPredicate(this.root,this.cq,this.cb);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.id),ID);
  Mockito.verify(this.cb,Mockito.times(1)).like(this.root.get(Job_.name),JOB_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.user),USER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.status),JobStatus.INIT);
  Mockito.verify(this.cb,Mockito.never()).equal(this.root.get(Job_.executionClusterName),CLUSTER_NAME);
  Mockito.verify(this.cb,Mockito.times(1)).equal(this.root.get(Job_.executionClusterId),CLUSTER_ID);
}"
90127,"/** 
 * {@inheritDoc}
 */
@Override public void init(final Job job,final Cluster cluster) throws GenieException {
  if (job == null) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  if (cluster == null) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  this.jobMonitor.setJobManager(this);
  this.job=job;
  this.cluster=cluster;
  this.jobService.setClusterInfoForJob(this.job.getId(),this.cluster.getId(),this.cluster.getName());
  Command command=null;
  for (  final Command cmd : this.cluster.getCommands()) {
    if (cmd.getTags().containsAll(this.job.getCommandCriteria())) {
      command=cmd;
      break;
    }
  }
  if (command == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GeniePreconditionException(msg);
  }
  this.jobService.setCommandInfoForJob(this.job.getId(),command.getId(),command.getName());
  final Application application=command.getApplication();
  if (application != null) {
    this.jobService.setApplicationInfoForJob(this.job.getId(),application.getId(),application.getName());
  }
  this.initCalled=true;
}","/** 
 * {@inheritDoc}
 */
@Override public void init(final Job job,final Cluster cluster) throws GenieException {
  if (job == null) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  if (cluster == null) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  this.jobMonitor.setJobManager(this);
  this.job=job;
  this.cluster=cluster;
  this.jobService.setClusterInfoForJob(this.job.getId(),this.cluster.getId(),this.cluster.getName());
  Command command=null;
  for (  final Command cmd : this.cluster.getCommands()) {
    if (cmd.getTags().containsAll(this.job.getCommandCriteria())) {
      command=cmd;
      break;
    }
  }
  if (command == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GeniePreconditionException(msg);
  }
  this.jobService.setCommandInfoForJob(this.job.getId(),command.getId(),command.getName());
  final Application application=command.getApplication();
  if (application != null) {
    this.jobService.setApplicationInfoForJob(this.job.getId(),application.getId(),application.getName());
  }
  this.job=this.jobService.getJob(this.job.getId());
  this.initCalled=true;
}"
90128,"/** 
 * {@inheritDoc}
 */
@Override public void init(final Job job,final Cluster cluster) throws GenieException {
  if (job == null) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  if (cluster == null) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  this.jobMonitor.setJobManager(this);
  this.job=job;
  this.cluster=cluster;
  this.jobService.setClusterInfoForJob(this.job.getId(),this.cluster.getId(),this.cluster.getName());
  this.initCalled=true;
}","/** 
 * {@inheritDoc}
 */
@Override public void init(final Job job,final Cluster cluster) throws GenieException {
  if (job == null) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  if (cluster == null) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  this.jobMonitor.setJobManager(this);
  this.job=job;
  this.cluster=cluster;
  this.jobService.setClusterInfoForJob(this.job.getId(),this.cluster.getId(),this.cluster.getName());
  Command command=null;
  for (  final Command cmd : this.cluster.getCommands()) {
    if (cmd.getTags().containsAll(this.job.getCommandCriteria())) {
      command=cmd;
      break;
    }
  }
  if (command == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GeniePreconditionException(msg);
  }
  this.jobService.setCommandInfoForJob(this.job.getId(),command.getId(),command.getName());
  final Application application=command.getApplication();
  if (application != null) {
    this.jobService.setApplicationInfoForJob(this.job.getId(),application.getId(),application.getName());
  }
  this.initCalled=true;
}"
90129,"/** 
 * Set the command and application for a given process and job.
 * @param processBuilder The process builder to use.
 * @throws GenieException On an error interacting with database.
 */
private void setCommandAndApplicationForJob(final ProcessBuilder processBuilder) throws GenieException {
  Command command=null;
  for (  final Command cmd : this.cluster.getCommands()) {
    if (cmd.getTags().containsAll(this.job.getCommandCriteria())) {
      command=cmd;
      break;
    }
  }
  if (command == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GeniePreconditionException(msg);
  }
  this.jobService.setCommandInfoForJob(this.job.getId(),command.getId(),command.getName());
  if (command.getConfigs() != null && !command.getConfigs().isEmpty()) {
    processBuilder.environment().put(""String_Node_Str"",convertCollectionToCSV(command.getConfigs()));
  }
  if (StringUtils.isNotBlank(command.getEnvPropFile())) {
    processBuilder.environment().put(""String_Node_Str"",command.getEnvPropFile());
  }
  final Application application=command.getApplication();
  if (application != null) {
    this.jobService.setApplicationInfoForJob(this.job.getId(),application.getId(),application.getName());
    if (application.getConfigs() != null && !application.getConfigs().isEmpty()) {
      processBuilder.environment().put(""String_Node_Str"",convertCollectionToCSV(application.getConfigs()));
    }
    if (application.getJars() != null && !application.getJars().isEmpty()) {
      processBuilder.environment().put(""String_Node_Str"",convertCollectionToCSV(application.getJars()));
    }
    if (StringUtils.isNotBlank(application.getEnvPropFile())) {
      processBuilder.environment().put(""String_Node_Str"",application.getEnvPropFile());
    }
  }
}","/** 
 * Set the command and application for a given process and job.
 * @param processBuilder The process builder to use.
 * @throws GenieException On an error interacting with database.
 */
private void setCommandAndApplicationForJob(final ProcessBuilder processBuilder) throws GenieException {
  final Command command=this.commandService.getCommand(this.job.getCommandId());
  if (command.getConfigs() != null && !command.getConfigs().isEmpty()) {
    processBuilder.environment().put(""String_Node_Str"",convertCollectionToCSV(command.getConfigs()));
  }
  if (StringUtils.isNotBlank(command.getEnvPropFile())) {
    processBuilder.environment().put(""String_Node_Str"",command.getEnvPropFile());
  }
  final Application application=command.getApplication();
  if (application != null) {
    if (application.getConfigs() != null && !application.getConfigs().isEmpty()) {
      processBuilder.environment().put(""String_Node_Str"",convertCollectionToCSV(application.getConfigs()));
    }
    if (application.getJars() != null && !application.getJars().isEmpty()) {
      processBuilder.environment().put(""String_Node_Str"",convertCollectionToCSV(application.getJars()));
    }
    if (StringUtils.isNotBlank(application.getEnvPropFile())) {
      processBuilder.environment().put(""String_Node_Str"",application.getEnvPropFile());
    }
  }
}"
90130,"/** 
 * {@inheritDoc}
 */
@Override public void init(final Job job,final Cluster cluster) throws GenieException {
  if (job == null) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  if (cluster == null) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  this.jobMonitor.setJobManager(this);
  this.job=job;
  this.cluster=cluster;
  this.jobService.setClusterInfoForJob(this.job.getId(),this.cluster.getId(),this.cluster.getName());
  Command command=null;
  for (  final Command cmd : this.cluster.getCommands()) {
    if (cmd.getTags().containsAll(this.job.getCommandCriteria())) {
      command=cmd;
      break;
    }
  }
  if (command == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GeniePreconditionException(msg);
  }
  this.jobService.setCommandInfoForJob(this.job.getId(),command.getId(),command.getName());
  final Application application=command.getApplication();
  if (application != null) {
    this.jobService.setApplicationInfoForJob(this.job.getId(),application.getId(),application.getName());
  }
  this.job=this.jobService.getJob(this.job.getId());
  this.initCalled=true;
}","/** 
 * {@inheritDoc}
 */
@Override public void init(final Job job,final Cluster cluster) throws GenieException {
  if (job == null) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  if (cluster == null) {
    throw new GeniePreconditionException(""String_Node_Str"");
  }
  this.jobMonitor.setJobManager(this);
  this.job=job;
  this.cluster=cluster;
  this.attachments=this.job.getAttachments();
  this.jobService.setClusterInfoForJob(this.job.getId(),this.cluster.getId(),this.cluster.getName());
  Command command=null;
  for (  final Command cmd : this.cluster.getCommands()) {
    if (cmd.getTags().containsAll(this.job.getCommandCriteria())) {
      command=cmd;
      break;
    }
  }
  if (command == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GeniePreconditionException(msg);
  }
  this.jobService.setCommandInfoForJob(this.job.getId(),command.getId(),command.getName());
  final Application application=command.getApplication();
  if (application != null) {
    this.jobService.setApplicationInfoForJob(this.job.getId(),application.getId(),application.getName());
  }
  this.job=this.jobService.getJob(this.job.getId());
  this.initCalled=true;
}"
90131,"/** 
 * Copy over any attachments for the job which exist.
 * @throws GenieException
 */
private void copyAttachments() throws GenieException {
  if (this.job.getAttachments() != null) {
    for (    final FileAttachment attachment : this.job.getAttachments()) {
      if (attachment.getName() == null || attachment.getName().isEmpty()) {
        final String msg=""String_Node_Str"";
        LOG.error(msg);
        throw new GeniePreconditionException(msg);
      }
      if (attachment.getData() == null) {
        final String msg=""String_Node_Str"";
        LOG.error(msg);
        throw new GeniePreconditionException(msg);
      }
      try (final FileOutputStream output=new FileOutputStream(this.jobDir + File.separator + attachment.getName())){
        output.write(attachment.getData());
      }
 catch (      final IOException e) {
        final String msg=""String_Node_Str"" + attachment.getName();
        LOG.error(msg);
        throw new GenieServerException(msg,e);
      }
    }
  }
}","/** 
 * Copy over any attachments for the job which exist.
 * @throws GenieException
 */
private void copyAttachments() throws GenieException {
  if (this.attachments != null) {
    for (    final FileAttachment attachment : this.job.getAttachments()) {
      if (attachment.getName() == null || attachment.getName().isEmpty()) {
        final String msg=""String_Node_Str"";
        LOG.error(msg);
        throw new GeniePreconditionException(msg);
      }
      if (attachment.getData() == null) {
        final String msg=""String_Node_Str"";
        LOG.error(msg);
        throw new GeniePreconditionException(msg);
      }
      try (final FileOutputStream output=new FileOutputStream(this.jobDir + File.separator + attachment.getName())){
        output.write(attachment.getData());
      }
 catch (      final IOException e) {
        final String msg=""String_Node_Str"" + attachment.getName();
        LOG.error(msg);
        throw new GenieServerException(msg,e);
      }
    }
  }
}"
90132,"/** 
 * Test getting number of running jobs on one instance.
 * @throws GenieException if there is any error during this test
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testNumInstanceJobs() throws GenieException {
  final String hostName=NetUtil.getHostName();
  final List<Job> jobs=this.jobRepo.findAll();
  for (  final Job job : jobs) {
    job.setHostName(hostName);
  }
  this.jobRepo.flush();
  Assert.assertEquals(2,this.manager.getNumInstanceJobs());
  Assert.assertEquals(2,this.manager.getNumInstanceJobs(0L,System.currentTimeMillis()));
  Assert.assertEquals(1,this.manager.getNumInstanceJobs(1404257259000L,1404257260000L));
  Assert.assertEquals(1,this.manager.getNumInstanceJobs(hostName,1404257258000L,1404257259000L));
  Assert.assertEquals(0,this.manager.getNumInstanceJobs(0L,0L));
}","/** 
 * Test getting number of running jobs on one instance.
 * @throws GenieException if there is any error during this test
 */
@Test @DatabaseSetup(""String_Node_Str"") public void testNumInstanceJobs() throws GenieException {
  final String hostName=NetUtil.getHostName();
  final List<Job> jobs=this.jobRepo.findAll();
  for (  final Job job : jobs) {
    job.setHostName(hostName);
  }
  this.jobRepo.flush();
  final Calendar one=Calendar.getInstance();
  one.clear();
  one.set(2014,Calendar.JULY,1,16,27,38);
  final Calendar two=Calendar.getInstance();
  two.clear();
  two.set(2014,Calendar.JULY,1,16,27,39);
  final Calendar three=Calendar.getInstance();
  three.clear();
  three.set(2014,Calendar.JULY,1,16,27,40);
  Assert.assertEquals(2,this.manager.getNumInstanceJobs());
  Assert.assertEquals(2,this.manager.getNumInstanceJobs(0L,System.currentTimeMillis()));
  Assert.assertEquals(1,this.manager.getNumInstanceJobs(one.getTimeInMillis(),two.getTimeInMillis()));
  Assert.assertEquals(1,this.manager.getNumInstanceJobs(hostName,two.getTimeInMillis(),three.getTimeInMillis()));
  Assert.assertEquals(0,this.manager.getNumInstanceJobs(0L,0L));
}"
90133,"/** 
 * Test the setter and getter for attachments.
 * @throws GenieException
 */
@Test public void testSetGetAttachments() throws GenieException {
  Assert.assertNull(this.job.getAttachments());
  final FileAttachment attachment=new FileAttachment();
  attachment.setName(""String_Node_Str"");
  attachment.setData(""String_Node_Str"".getBytes());
  final Set<FileAttachment> attachments=new HashSet<FileAttachment>();
  attachments.add(attachment);
  this.job.setAttachments(attachments);
  Assert.assertEquals(attachments,this.job.getAttachments());
}","/** 
 * Test the setter and getter for attachments.
 * @throws GenieException
 */
@Test public void testSetGetAttachments() throws GenieException {
  Assert.assertNull(this.job.getAttachments());
  final FileAttachment attachment=new FileAttachment();
  attachment.setName(""String_Node_Str"");
  attachment.setData(""String_Node_Str"".getBytes(UTF8_CHARSET));
  final Set<FileAttachment> attachments=new HashSet<FileAttachment>();
  attachments.add(attachment);
  this.job.setAttachments(attachments);
  Assert.assertEquals(attachments,this.job.getAttachments());
}"
90134,"/** 
 * Submit a new job.
 * @param job request object containing job info element for new job
 * @param hsr servlet context
 * @return The submitted job
 * @throws GenieException
 */
@POST @Consumes(MediaType.APPLICATION_JSON) @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"",response=Job.class) @ApiResponses(value={@ApiResponse(code=HttpURLConnection.HTTP_CREATED,message=""String_Node_Str"",response=Job.class),@ApiResponse(code=HttpURLConnection.HTTP_BAD_REQUEST,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_CONFLICT,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_PRECON_FAILED,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_INTERNAL_ERROR,message=""String_Node_Str"")}) public Response submitJob(@ApiParam(value=""String_Node_Str"",required=true) final Job job,@ApiParam(value=""String_Node_Str"",required=true) @Context final HttpServletRequest hsr) throws GenieException {
  LOG.info(""String_Node_Str"" + job);
  if (job == null) {
    throw new GenieException(HttpURLConnection.HTTP_PRECON_FAILED,""String_Node_Str"");
  }
  String clientHost=hsr.getHeader(""String_Node_Str"");
  if (clientHost != null) {
    clientHost=clientHost.split(""String_Node_Str"")[0];
  }
 else {
    clientHost=hsr.getRemoteAddr();
  }
  if (StringUtils.isBlank(clientHost)) {
    LOG.debug(""String_Node_Str"" + clientHost);
    job.setClientHost(clientHost);
  }
  final Job createdJob=this.xs.submitJob(job);
  return Response.created(this.uriInfo.getAbsolutePathBuilder().path(createdJob.getId()).build()).entity(createdJob).build();
}","/** 
 * Submit a new job.
 * @param job request object containing job info element for new job
 * @param hsr servlet context
 * @return The submitted job
 * @throws GenieException
 */
@POST @Consumes(MediaType.APPLICATION_JSON) @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"",response=Job.class) @ApiResponses(value={@ApiResponse(code=HttpURLConnection.HTTP_CREATED,message=""String_Node_Str"",response=Job.class),@ApiResponse(code=HttpURLConnection.HTTP_BAD_REQUEST,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_CONFLICT,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_PRECON_FAILED,message=""String_Node_Str""),@ApiResponse(code=HttpURLConnection.HTTP_INTERNAL_ERROR,message=""String_Node_Str"")}) public Response submitJob(@ApiParam(value=""String_Node_Str"",required=true) final Job job,@ApiParam(value=""String_Node_Str"",required=true) @Context final HttpServletRequest hsr) throws GenieException {
  LOG.info(""String_Node_Str"" + job);
  if (job == null) {
    throw new GenieException(HttpURLConnection.HTTP_PRECON_FAILED,""String_Node_Str"");
  }
  final boolean forwarded=job.isForwarded();
  String clientHost=hsr.getHeader(""String_Node_Str"");
  if (clientHost != null) {
    clientHost=clientHost.split(""String_Node_Str"")[0];
  }
 else {
    clientHost=hsr.getRemoteAddr();
  }
  if (StringUtils.isBlank(clientHost)) {
    LOG.debug(""String_Node_Str"" + clientHost);
    job.setClientHost(clientHost);
  }
  final Job createdJob=this.xs.submitJob(job);
  if (forwarded) {
    return Response.ok().entity(createdJob).build();
  }
 else {
    return Response.created(this.uriInfo.getAbsolutePathBuilder().path(createdJob.getId()).build()).entity(createdJob).build();
  }
}"
90135,"private Job executeRequest(final Verb method,final String restURI,final Job job) throws GenieException {
  HttpResponse clientResponse=null;
  try {
    LOG.info(""String_Node_Str"" + restURI);
    final RestClient genieClient=(RestClient)ClientFactory.getNamedClient(""String_Node_Str"");
    final Set<Class<?>> providers=new HashSet<Class<?>>();
    providers.add(JacksonJaxbJsonProvider.class);
    providers.add(JacksonJsonProvider.class);
    final ClientConfig clientConfig=new DefaultClientConfig(providers);
    final Client jerseyClient=Client.create(clientConfig);
    genieClient.setJerseyClient(jerseyClient);
    final HttpRequest req=HttpRequest.newBuilder().verb(method).header(""String_Node_Str"",MediaType.APPLICATION_JSON).header(""String_Node_Str"",MediaType.APPLICATION_JSON).uri(new URI(restURI)).entity(job).build();
    clientResponse=genieClient.execute(req);
    if (clientResponse != null && clientResponse.isSuccess()) {
      return clientResponse.getEntity(Job.class);
    }
 else {
      if (clientResponse != null) {
        throw new GenieException(clientResponse.getStatus(),clientResponse.getEntity(String.class));
      }
 else {
        throw new GenieException(HttpURLConnection.HTTP_INTERNAL_ERROR,""String_Node_Str"");
      }
    }
  }
 catch (  final Exception e) {
    if (e instanceof GenieException) {
      throw (GenieException)e;
    }
    final String msg=""String_Node_Str"" + e.getMessage();
    throw new GenieException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
 finally {
    if (clientResponse != null) {
      clientResponse.close();
    }
  }
}","private Job executeRequest(final Verb method,final String restURI,final Job job) throws GenieException {
  HttpResponse clientResponse=null;
  try {
    LOG.info(""String_Node_Str"" + restURI);
    final RestClient genieClient=(RestClient)ClientFactory.getNamedClient(""String_Node_Str"");
    final Set<Class<?>> providers=new HashSet<Class<?>>();
    providers.add(JacksonJaxbJsonProvider.class);
    providers.add(JacksonJsonProvider.class);
    final ClientConfig clientConfig=new DefaultClientConfig(providers);
    final Client jerseyClient=Client.create(clientConfig);
    genieClient.setJerseyClient(jerseyClient);
    final HttpRequest req=HttpRequest.newBuilder().verb(method).header(HttpHeaders.ACCEPT,MediaType.APPLICATION_JSON).header(HttpHeaders.CONTENT_TYPE,MediaType.APPLICATION_JSON).uri(new URI(restURI)).entity(job).build();
    clientResponse=genieClient.execute(req);
    if (clientResponse != null && clientResponse.isSuccess()) {
      return clientResponse.getEntity(Job.class);
    }
 else {
      if (clientResponse != null) {
        throw new GenieException(clientResponse.getStatus(),clientResponse.getEntity(String.class));
      }
 else {
        throw new GenieException(HttpURLConnection.HTTP_INTERNAL_ERROR,""String_Node_Str"");
      }
    }
  }
 catch (  final Exception e) {
    if (e instanceof GenieException) {
      throw (GenieException)e;
    }
    final String msg=""String_Node_Str"" + e.getMessage();
    throw new GenieException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
 finally {
    if (clientResponse != null) {
      clientResponse.close();
    }
  }
}"
90136,"/** 
 * Wait for job to complete, until the given timeout.
 * @param id           the Genie job ID to wait for completion
 * @param blockTimeout the time to block for (in ms), after which aGenieException will be thrown
 * @param pollTime     the time to sleep between polling for job status
 * @return the jobInfo for the job after completion
 * @throws GenieException       on service errors
 * @throws InterruptedException on timeout/thread errors
 */
public Job waitForCompletion(final String id,final long blockTimeout,final long pollTime) throws GenieException, InterruptedException {
  if (StringUtils.isEmpty(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final long startTime=System.currentTimeMillis();
  while (true) {
    final Job job=getJob(id);
    if (job.getFinished() != new Date(0)) {
      return job;
    }
    long currTime=System.currentTimeMillis();
    if (currTime - startTime < blockTimeout) {
      Thread.sleep(pollTime);
    }
 else {
      final String msg=""String_Node_Str"";
      LOG.error(msg);
      throw new InterruptedException(msg);
    }
  }
}","/** 
 * Wait for job to complete, until the given timeout.
 * @param id           the Genie job ID to wait for completion
 * @param blockTimeout the time to block for (in ms), after which aGenieException will be thrown
 * @param pollTime     the time to sleep between polling for job status
 * @return the jobInfo for the job after completion
 * @throws GenieException       on service errors
 * @throws InterruptedException on timeout/thread errors
 */
public Job waitForCompletion(final String id,final long blockTimeout,final long pollTime) throws GenieException, InterruptedException {
  if (StringUtils.isEmpty(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final long startTime=System.currentTimeMillis();
  while (true) {
    final Job job=getJob(id);
    if (!job.getFinished().equals(new Date(0))) {
      return job;
    }
    long currTime=System.currentTimeMillis();
    if (currTime - startTime < blockTimeout) {
      Thread.sleep(pollTime);
    }
 else {
      final String msg=""String_Node_Str"";
      LOG.error(msg);
      throw new InterruptedException(msg);
    }
  }
}"
90137,"/** 
 * Initialize, and launch the job once it has been initialized.
 * @param job the JobInfo object for the job to be launched
 * @throws GenieException
 */
void launch(final Job job) throws GenieException ;","/** 
 * Launch the job.
 * @throws GenieException
 */
void launch() throws GenieException ;"
90138,"/** 
 * Kill a job using the job information - no need to initialize this job.
 * @param job the JobInfo object for the job to be killed
 * @throws GenieException
 */
void kill(final Job job) throws GenieException ;","/** 
 * Kill a job using the job information - no need to initialize this job.
 * @throws GenieException
 */
void kill() throws GenieException ;"
90139,"/** 
 * Returns the right job manager for the job type.
 * @param job The job this manager will be managing
 * @return instance of the appropriate job manager
 * @throws GenieException
 */
public JobManager getJobManager(final Job job) throws GenieException {
  LOG.info(""String_Node_Str"");
  final Cluster cluster=this.clb.selectCluster(this.ccs.getClusters(job));
  final String className=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"" + cluster.getClusterType() + ""String_Node_Str"");
  try {
    final Class jobManagerClass=Class.forName(className);
    final Object instance=this.context.getBean(jobManagerClass);
    if (instance instanceof JobManager) {
      final JobManager jobManager=(JobManager)instance;
      jobManager.setCluster(cluster);
      return jobManager;
    }
 else {
      final String msg=className + ""String_Node_Str"";
      LOG.error(msg);
      throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
    }
  }
 catch (  final ClassNotFoundException e) {
    final String msg=""String_Node_Str"" + className;
    LOG.error(msg,e);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
catch (  final BeansException e) {
    final String msg=""String_Node_Str"" + className;
    LOG.error(msg,e);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
}","/** 
 * Returns the right job manager for the job type.
 * @param job The job this manager will be managing
 * @return instance of the appropriate job manager
 * @throws GenieException
 */
public JobManager getJobManager(final Job job) throws GenieException {
  LOG.info(""String_Node_Str"");
  final Cluster cluster=this.clb.selectCluster(this.ccs.getClusters(job));
  final String className=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"" + cluster.getClusterType() + ""String_Node_Str"");
  try {
    final Class jobManagerClass=Class.forName(className);
    final Object instance=this.context.getBean(jobManagerClass);
    if (instance instanceof JobManager) {
      final JobManager jobManager=(JobManager)instance;
      jobManager.init(job,cluster);
      return jobManager;
    }
 else {
      final String msg=className + ""String_Node_Str"";
      LOG.error(msg);
      throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
    }
  }
 catch (  final ClassNotFoundException e) {
    final String msg=""String_Node_Str"" + className;
    LOG.error(msg,e);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
catch (  final BeansException e) {
    final String msg=""String_Node_Str"" + className;
    LOG.error(msg,e);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
}"
90140,"/** 
 * Wait until the job finishes, and then return exit code. Also ensure that stdout is within the limit (if specified), and update DB status periodically (as RUNNING).
 * @return exit code for the job after it finishes
 */
@Transactional private int waitForExit(){
  this.lastUpdatedTimeMS=System.currentTimeMillis();
  while (isRunning()) {
    try {
      Thread.sleep(JOB_WAIT_TIME_MS);
    }
 catch (    InterruptedException e) {
      LOG.error(""String_Node_Str"" + job.getId() + ""String_Node_Str"",e);
    }
    if (shouldUpdateJob()) {
      LOG.debug(""String_Node_Str"" + job.getId());
      this.lastUpdatedTimeMS=System.currentTimeMillis();
      this.job.setJobStatus(JobStatus.RUNNING,""String_Node_Str"");
      this.job.setUpdated(new Date(this.lastUpdatedTimeMS));
      try {
        final Job dbJI=this.em.find(Job.class,this.job.getId());
        if ((dbJI.getStatus() != null) && dbJI.getStatus() != JobStatus.KILLED) {
          this.job.setUpdated(new Date());
          this.em.merge(this.job);
        }
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"" + this.job.getId(),e);
      }
      if (this.stdOutFile != null && this.stdOutFile.exists() && this.maxStdoutSize != null && this.stdOutFile.length() > this.maxStdoutSize && !this.terminated) {
        LOG.warn(""String_Node_Str"" + this.job.getId() + ""String_Node_Str"");
        try {
          this.jobManager.kill(this.job);
          this.terminated=true;
        }
 catch (        GenieException e) {
          LOG.error(""String_Node_Str"" + this.job.getId() + ""String_Node_Str"",e);
        }
      }
    }
  }
  return this.proc.exitValue();
}","/** 
 * Wait until the job finishes, and then return exit code. Also ensure that stdout is within the limit (if specified), and update DB status periodically (as RUNNING).
 * @return exit code for the job after it finishes
 */
private int waitForExit(){
  this.lastUpdatedTimeMS=System.currentTimeMillis();
  while (isRunning()) {
    try {
      Thread.sleep(JOB_WAIT_TIME_MS);
    }
 catch (    InterruptedException e) {
      LOG.error(""String_Node_Str"" + this.jobId + ""String_Node_Str"",e);
    }
    if (shouldUpdateJob()) {
      updateJob();
      if (this.stdOutFile != null && this.stdOutFile.exists() && this.maxStdoutSize != null && this.stdOutFile.length() > this.maxStdoutSize && !this.terminated) {
        LOG.warn(""String_Node_Str"" + this.jobId + ""String_Node_Str"");
        try {
          this.jobManager.kill();
          this.terminated=true;
        }
 catch (        GenieException e) {
          LOG.error(""String_Node_Str"" + this.jobId + ""String_Node_Str"",e);
        }
      }
    }
  }
  return this.proc.exitValue();
}"
90141,"/** 
 * Check the properties file to figure out if an email needs to be sent at the end of the job. If yes, get mail properties and try and send email about Job Status.
 * @return 0 for success, -1 for failure
 */
private boolean sendEmail(String emailTo,boolean killed){
  LOG.debug(""String_Node_Str"");
  if (!this.config.getBoolean(""String_Node_Str"",false)) {
    LOG.warn(""String_Node_Str"");
    return false;
  }
  String fromEmail=this.config.getString(""String_Node_Str"",""String_Node_Str"");
  LOG.info(""String_Node_Str"" + fromEmail);
  String smtpHost=this.config.getString(""String_Node_Str"",""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + smtpHost);
  Properties properties=new Properties();
  properties.setProperty(""String_Node_Str"",smtpHost);
  Authenticator auth=null;
  if (this.config.getBoolean(""String_Node_Str"",false)) {
    LOG.debug(""String_Node_Str"");
    properties.put(""String_Node_Str"",""String_Node_Str"");
    properties.put(""String_Node_Str"",""String_Node_Str"");
    String userName=config.getString(""String_Node_Str"");
    String password=config.getString(""String_Node_Str"");
    if ((userName == null) || (password == null)) {
      LOG.error(""String_Node_Str"");
      return false;
    }
    LOG.debug(""String_Node_Str"" + userName + ""String_Node_Str""+ password);
    auth=new SMTPAuthenticator(userName,password);
  }
 else {
    LOG.debug(""String_Node_Str"");
  }
  Session session=Session.getInstance(properties,auth);
  try {
    MimeMessage message=new MimeMessage(session);
    message.setFrom(new InternetAddress(fromEmail));
    message.addRecipient(Message.RecipientType.TO,new InternetAddress(emailTo));
    JobStatus jobStatus;
    if (killed) {
      jobStatus=JobStatus.KILLED;
    }
 else {
      jobStatus=job.getStatus();
    }
    message.setSubject(""String_Node_Str"" + job.getName() + ""String_Node_Str""+ jobStatus);
    String body=""String_Node_Str"" + ""String_Node_Str"" + job.getId() + ""String_Node_Str""+ ""String_Node_Str""+ job.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ job.getStatus()+ ""String_Node_Str""+ ""String_Node_Str""+ job.getStatusMsg()+ ""String_Node_Str""+ ""String_Node_Str""+ job.getOutputURI()+ ""String_Node_Str"";
    message.setText(body);
    Transport.send(message);
    LOG.info(""String_Node_Str"");
    return true;
  }
 catch (  MessagingException mex) {
    LOG.error(""String_Node_Str"",mex);
    return false;
  }
}","/** 
 * Check the properties file to figure out if an email needs to be sent at the end of the job. If yes, get mail properties and try and send email about Job Status.
 * @return 0 for success, -1 for failure
 */
private boolean sendEmail(String emailTo,boolean killed){
  final Job job=this.jobRepo.findOne(this.jobId);
  LOG.debug(""String_Node_Str"");
  if (!this.config.getBoolean(""String_Node_Str"",false)) {
    LOG.warn(""String_Node_Str"");
    return false;
  }
  String fromEmail=this.config.getString(""String_Node_Str"",""String_Node_Str"");
  LOG.info(""String_Node_Str"" + fromEmail);
  String smtpHost=this.config.getString(""String_Node_Str"",""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + smtpHost);
  Properties properties=new Properties();
  properties.setProperty(""String_Node_Str"",smtpHost);
  Authenticator auth=null;
  if (this.config.getBoolean(""String_Node_Str"",false)) {
    LOG.debug(""String_Node_Str"");
    properties.put(""String_Node_Str"",""String_Node_Str"");
    properties.put(""String_Node_Str"",""String_Node_Str"");
    String userName=config.getString(""String_Node_Str"");
    String password=config.getString(""String_Node_Str"");
    if ((userName == null) || (password == null)) {
      LOG.error(""String_Node_Str"");
      return false;
    }
    LOG.debug(""String_Node_Str"" + userName + ""String_Node_Str""+ password);
    auth=new SMTPAuthenticator(userName,password);
  }
 else {
    LOG.debug(""String_Node_Str"");
  }
  Session session=Session.getInstance(properties,auth);
  try {
    MimeMessage message=new MimeMessage(session);
    message.setFrom(new InternetAddress(fromEmail));
    message.addRecipient(Message.RecipientType.TO,new InternetAddress(emailTo));
    JobStatus jobStatus;
    if (killed) {
      jobStatus=JobStatus.KILLED;
    }
 else {
      jobStatus=job.getStatus();
    }
    message.setSubject(""String_Node_Str"" + job.getName() + ""String_Node_Str""+ jobStatus);
    String body=""String_Node_Str"" + ""String_Node_Str"" + job.getId() + ""String_Node_Str""+ ""String_Node_Str""+ job.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ job.getStatus()+ ""String_Node_Str""+ ""String_Node_Str""+ job.getStatusMsg()+ ""String_Node_Str""+ ""String_Node_Str""+ job.getOutputURI()+ ""String_Node_Str"";
    message.setText(body);
    Transport.send(message);
    LOG.info(""String_Node_Str"");
    return true;
  }
 catch (  MessagingException mex) {
    LOG.error(""String_Node_Str"",mex);
    return false;
  }
}"
90142,"/** 
 * Constructor.
 * @param genieNodeStatistics The statistics object to use
 */
@Inject public JobMonitorImpl(final GenieNodeStatistics genieNodeStatistics){
  this.genieNodeStatistics=genieNodeStatistics;
  this.config=ConfigurationManager.getConfigInstance();
  this.maxStdoutSize=this.config.getLong(""String_Node_Str"",null);
  this.job=null;
  this.workingDir=null;
  this.proc=null;
  this.stdOutFile=null;
}","/** 
 * Constructor.
 * @param jobRepo The job repository
 * @param genieNodeStatistics The statistics object to use
 */
@Inject public JobMonitorImpl(final JobRepository jobRepo,final GenieNodeStatistics genieNodeStatistics){
  this.jobRepo=jobRepo;
  this.genieNodeStatistics=genieNodeStatistics;
  this.config=ConfigurationManager.getConfigInstance();
  this.maxStdoutSize=this.config.getLong(""String_Node_Str"",null);
  this.workingDir=null;
  this.proc=null;
  this.stdOutFile=null;
}"
90143,"/** 
 * Set the job for this to monitor.
 * @param job The job to monitor. Not null.
 * @throws GenieException
 */
@Override public void setJob(final Job job) throws GenieException {
  if (job == null) {
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"");
  }
  this.job=job;
}","/** 
 * Set the job for this to monitor.
 * @param job The job to monitor. Not null.
 * @throws GenieException
 */
@Override public void setJob(final Job job) throws GenieException {
  if (job == null || StringUtils.isBlank(job.getId())) {
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"");
  }
  this.jobId=job.getId();
}"
90144,"/** 
 * The main run method for this thread - wait till it finishes, and manage job state in DB.
 */
@Override public void run(){
  boolean killed=false;
  int exitCode=waitForExit();
  this.job.setExitCode(exitCode);
  final Job dbJI=this.em.find(Job.class,this.job.getId());
  if (dbJI.getStatus() != null && dbJI.getStatus() != JobStatus.KILLED) {
    if (exitCode != SubProcessStatus.SUCCESS.code()) {
      LOG.error(""String_Node_Str"" + exitCode);
      String errMsg=SubProcessStatus.message(exitCode);
      if ((errMsg == null) || (errMsg.isEmpty())) {
        errMsg=""String_Node_Str"";
      }
      this.job.setJobStatus(JobStatus.FAILED,""String_Node_Str"" + errMsg);
      this.genieNodeStatistics.incrGenieFailedJobs();
    }
 else {
      this.job.setJobStatus(JobStatus.SUCCEEDED,""String_Node_Str"");
      this.genieNodeStatistics.incrGenieSuccessfulJobs();
    }
    if (!this.job.isDisableLogArchival()) {
      this.job.setArchiveLocation(NetUtil.getArchiveURI(this.job.getId()));
    }
    this.job.setUpdated(new Date());
    this.em.merge(this.job);
  }
 else {
    LOG.debug(""String_Node_Str"" + job.getId());
    killed=true;
  }
  final String emailTo=this.job.getEmail();
  if (emailTo != null) {
    LOG.info(""String_Node_Str"" + emailTo);
    if (sendEmail(emailTo,killed)) {
      this.genieNodeStatistics.incrSuccessfulEmailCount();
    }
 else {
      LOG.warn(""String_Node_Str"");
      this.genieNodeStatistics.incrFailedEmailCount();
    }
  }
}","/** 
 * The main run method for this thread - wait till it finishes, and manage job state in DB.
 */
@Override public void run(){
  final boolean killed=this.finalizeJob(waitForExit()) == JobStatus.KILLED;
  final String emailTo=this.jobRepo.findOne(this.jobId).getEmail();
  if (emailTo != null) {
    LOG.info(""String_Node_Str"" + emailTo);
    if (sendEmail(emailTo,killed)) {
      this.genieNodeStatistics.incrSuccessfulEmailCount();
    }
 else {
      LOG.warn(""String_Node_Str"");
      this.genieNodeStatistics.incrFailedEmailCount();
    }
  }
}"
90145,"/** 
 * Set command Name with which this job is run.
 * @param commandName Name of the command if specified on which the job isrun
 * @throws GenieException
 */
public void setCommandName(final String commandName) throws GenieException {
  if (StringUtils.isBlank(commandName)) {
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"");
  }
  this.commandName=commandName;
}","/** 
 * Set command Name with which this job is run.
 * @param commandName Name of the command if specified on which the job isrun
 */
public void setCommandName(final String commandName){
  this.commandName=commandName;
}"
90146,"/** 
 * Helper method for building the cluster criteria string.
 * @param clusterCriteria2 The criteria to build up from
 * @return The cluster criteria string
 */
private String clusterCriteriaToString(final List<ClusterCriteria> clusterCriteria2) throws GenieException {
  if (clusterCriteria2 == null || clusterCriteria2.isEmpty()) {
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"");
  }
  final StringBuilder builder=new StringBuilder();
  for (  final ClusterCriteria cc : clusterCriteria2) {
    if (builder.length() != 0) {
      builder.append(CRITERIA_SET_DELIMITER);
    }
    builder.append(StringUtils.join(cc.getTags(),CRITERIA_DELIMITER));
  }
  return builder.toString();
}","/** 
 * Helper method for building the cluster criteria string.
 * @param clusterCriteria2 The criteria to build up from
 * @return The cluster criteria string
 */
private String clusterCriteriaToString(final List<ClusterCriteria> clusterCriteria2){
  if (clusterCriteria2 == null || clusterCriteria2.isEmpty()) {
    return null;
  }
  final StringBuilder builder=new StringBuilder();
  for (  final ClusterCriteria cc : clusterCriteria2) {
    if (builder.length() != 0) {
      builder.append(CRITERIA_SET_DELIMITER);
    }
    builder.append(StringUtils.join(cc.getTags(),CRITERIA_DELIMITER));
  }
  return builder.toString();
}"
90147,"/** 
 * Set the cluster criteria string.
 * @param clusterCriteriaString A list of cluster criteria objects
 * @throws GenieException
 */
protected void setClusterCriteriaString(final String clusterCriteriaString) throws GenieException {
  if (StringUtils.isBlank(clusterCriteriaString)) {
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"");
  }
  this.clusterCriteriaString=clusterCriteriaString;
  this.clusterCriteria=stringToClusterCriteria(clusterCriteriaString);
}","/** 
 * Set the cluster criteria string.
 * @param clusterCriteriaString A list of cluster criteria objects
 * @throws GenieException 
 */
protected void setClusterCriteriaString(final String clusterCriteriaString) throws GenieException {
  this.clusterCriteriaString=clusterCriteriaString;
  this.clusterCriteria=stringToClusterCriteria(clusterCriteriaString);
}"
90148,"/** 
 * Set command Id with which this job is run.
 * @param commandId Id of the command if specified on which the job is run
 * @throws com.netflix.genie.common.exceptions.GenieException
 */
public void setCommandId(final String commandId) throws GenieException {
  if (StringUtils.isBlank(commandId)) {
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"");
  }
  this.commandId=commandId;
}","/** 
 * Set command Id with which this job is run.
 * @param commandId Id of the command if specified on which the job is run
 */
public void setCommandId(final String commandId){
  this.commandId=commandId;
}"
90149,"/** 
 * Kill job based on given job ID.
 * @param id id for job to kill
 * @return The job that was killed
 * @throws GenieException
 */
@DELETE @Path(""String_Node_Str"") @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"",response=Job.class) @ApiResponses(value={@ApiResponse(code=200,message=""String_Node_Str"",response=Job.class)}) public Job killJob(@PathParam(""String_Node_Str"") @ApiParam(value=""String_Node_Str"",required=true) final String id) throws GenieException {
  LOG.debug(""String_Node_Str"" + id);
  return this.xs.killJob(id);
}","/** 
 * Kill job based on given job ID.
 * @param id id for job to kill
 * @return The job that was killed
 * @throws GenieException
 */
@DELETE @Path(""String_Node_Str"") @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"",response=Job.class) @ApiResponses(value={@ApiResponse(code=200,message=""String_Node_Str"",response=Job.class)}) public Job killJob(@ApiParam(value=""String_Node_Str"",required=true) @PathParam(""String_Node_Str"") final String id) throws GenieException {
  LOG.debug(""String_Node_Str"" + id);
  return this.xs.killJob(id);
}"
90150,"/** 
 * {@inheritDoc}
 * @throws GenieException
 */
@Override public Job submitJob(final Job job) throws GenieException {
  LOG.debug(""String_Node_Str"");
  if (job == null) {
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"");
  }
  job.validate();
  job.setJobStatus(JobStatus.INIT,""String_Node_Str"");
  final Job savedJob;
  final int maxRunningJobs=CONF.getInt(""String_Node_Str"",0);
  final int jobForwardThreshold=CONF.getInt(""String_Node_Str"",0);
  final int maxIdleHostThreshold=CONF.getInt(""String_Node_Str"",0);
  final int idleHostThresholdDelta=CONF.getInt(""String_Node_Str"",0);
synchronized (this) {
    final int numRunningJobs=this.jobCountManager.getNumInstanceJobs();
    LOG.info(""String_Node_Str"" + numRunningJobs);
    int idleHostThreshold=numRunningJobs - idleHostThresholdDelta;
    if ((idleHostThreshold > maxIdleHostThreshold) || (numRunningJobs >= maxRunningJobs)) {
      idleHostThreshold=maxIdleHostThreshold;
    }
    if (numRunningJobs >= jobForwardThreshold && !job.isForwarded()) {
      LOG.info(""String_Node_Str"");
      final String idleHost=this.jobCountManager.getIdleInstance(idleHostThreshold);
      if (!idleHost.equals(NetUtil.getHostName())) {
        job.setForwarded(true);
        this.stats.incrGenieForwardedJobs();
        return forwardJobRequest(""String_Node_Str"" + idleHost + ""String_Node_Str""+ SERVER_PORT+ ""String_Node_Str""+ JOB_RESOURCE_PREFIX,job);
      }
    }
    if (numRunningJobs >= maxRunningJobs) {
      throw new GenieException(HttpURLConnection.HTTP_UNAVAILABLE,""String_Node_Str"" + maxRunningJobs + ""String_Node_Str"");
    }
    buildJobURIs(job);
    try {
      savedJob=this.jobRepo.save(job);
    }
 catch (    final RollbackException e) {
      LOG.error(""String_Node_Str"",e);
      if (e.getCause() instanceof EntityExistsException) {
        throw new GenieException(HttpURLConnection.HTTP_CONFLICT,""String_Node_Str"" + job.getId());
      }
 else {
        throw new GenieException(HttpURLConnection.HTTP_INTERNAL_ERROR,e);
      }
    }
  }
  if (savedJob == null) {
    throw new GenieException(HttpURLConnection.HTTP_INTERNAL_ERROR,""String_Node_Str"");
  }
  this.stats.incrGenieJobSubmissions();
  try {
    this.jobManagerFactory.getJobManager(savedJob).launch();
    savedJob.setUpdated(new Date());
    return savedJob;
  }
 catch (  final GenieException e) {
    LOG.error(""String_Node_Str"",e);
    savedJob.setJobStatus(JobStatus.FAILED,e.getMessage());
    this.stats.incrGenieFailedJobs();
    return savedJob;
  }
}","/** 
 * {@inheritDoc}
 * @throws GenieException
 */
@Override public Job submitJob(final Job job) throws GenieException {
  LOG.debug(""String_Node_Str"");
  if (job == null) {
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"");
  }
  job.validate();
  job.setJobStatus(JobStatus.INIT,""String_Node_Str"");
  final Job savedJob;
  final int maxRunningJobs=CONF.getInt(""String_Node_Str"",0);
  final int jobForwardThreshold=CONF.getInt(""String_Node_Str"",0);
  final int maxIdleHostThreshold=CONF.getInt(""String_Node_Str"",0);
  final int idleHostThresholdDelta=CONF.getInt(""String_Node_Str"",0);
synchronized (this) {
    final int numRunningJobs=this.jobCountManager.getNumInstanceJobs();
    LOG.info(""String_Node_Str"" + numRunningJobs);
    int idleHostThreshold=numRunningJobs - idleHostThresholdDelta;
    if ((idleHostThreshold > maxIdleHostThreshold) || (numRunningJobs >= maxRunningJobs)) {
      idleHostThreshold=maxIdleHostThreshold;
    }
    if (numRunningJobs >= jobForwardThreshold && !job.isForwarded()) {
      LOG.info(""String_Node_Str"");
      final String idleHost=this.jobCountManager.getIdleInstance(idleHostThreshold);
      if (!idleHost.equals(NetUtil.getHostName())) {
        job.setForwarded(true);
        this.stats.incrGenieForwardedJobs();
        return forwardJobRequest(""String_Node_Str"" + idleHost + ""String_Node_Str""+ SERVER_PORT+ ""String_Node_Str""+ JOB_RESOURCE_PREFIX,job);
      }
    }
    if (numRunningJobs >= maxRunningJobs) {
      throw new GenieException(HttpURLConnection.HTTP_UNAVAILABLE,""String_Node_Str"" + maxRunningJobs + ""String_Node_Str"");
    }
    try {
      savedJob=this.jobRepo.save(job);
      buildJobURIs(savedJob);
    }
 catch (    final RollbackException e) {
      LOG.error(""String_Node_Str"",e);
      if (e.getCause() instanceof EntityExistsException) {
        throw new GenieException(HttpURLConnection.HTTP_CONFLICT,""String_Node_Str"" + job.getId());
      }
 else {
        throw new GenieException(HttpURLConnection.HTTP_INTERNAL_ERROR,e);
      }
    }
  }
  if (savedJob == null) {
    throw new GenieException(HttpURLConnection.HTTP_INTERNAL_ERROR,""String_Node_Str"");
  }
  this.stats.incrGenieJobSubmissions();
  try {
    this.jobManagerFactory.getJobManager(savedJob).launch();
    savedJob.setUpdated(new Date());
    return savedJob;
  }
 catch (  final GenieException e) {
    LOG.error(""String_Node_Str"",e);
    savedJob.setJobStatus(JobStatus.FAILED,e.getMessage());
    this.stats.incrGenieFailedJobs();
    return savedJob;
  }
}"
90151,"/** 
 * Add some more tags to a given application.
 * @param id The id of the application to add tags to. NotNull/empty/blank.
 * @param tags The tags to add. Not null or empty.
 * @return The new set of tags for the given application.
 * @throws GenieException
 */
public Set<String> addTagsToApplication(final String id,final Set<String> tags) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  if (tags == null || tags.isEmpty()) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.POST,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id,""String_Node_Str""},SLASH),null,tags);
  return (Set<String>)this.executeRequest(request,Set.class,String.class);
}","/** 
 * Add some more tags to a given application.
 * @param id   The id of the application to add tags to. NotNull/empty/blank.
 * @param tags The tags to add. Not null or empty.
 * @return The new set of tags for the given application.
 * @throws GenieException
 */
public Set<String> addTagsToApplication(final String id,final Set<String> tags) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  if (tags == null || tags.isEmpty()) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.POST,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id,""String_Node_Str""},SLASH),null,tags);
  return (Set<String>)this.executeRequest(request,Set.class,String.class);
}"
90152,"/** 
 * Update the configuration files for a given application.
 * @param id The id of the application to update the configuration filesfor. Not null/empty/blank.
 * @param configs The configuration files to replace existing configurationfiles with. Not null.
 * @return The new set of application configurations.
 * @throws GenieException
 */
public Set<String> updateConfigsForApplication(final String id,final Set<String> configs) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  if (configs == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.PUT,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id,""String_Node_Str""},SLASH),null,configs);
  return (Set<String>)this.executeRequest(request,Set.class,String.class);
}","/** 
 * Update the configuration files for a given application.
 * @param id      The id of the application to update the configuration filesfor. Not null/empty/blank.
 * @param configs The configuration files to replace existing configurationfiles with. Not null.
 * @return The new set of application configurations.
 * @throws GenieException
 */
public Set<String> updateConfigsForApplication(final String id,final Set<String> configs) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  if (configs == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.PUT,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id,""String_Node_Str""},SLASH),null,configs);
  return (Set<String>)this.executeRequest(request,Set.class,String.class);
}"
90153,"/** 
 * Update the tags for a given application.
 * @param id The id of the application to update the tags for.Not null/empty/blank.
 * @param tags The tags to replace existing tagfiles with. Not null.
 * @return The new set of application tags.
 * @throws GenieException
 */
public Set<String> updateTagsForApplication(final String id,final Set<String> tags) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  if (tags == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.PUT,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id,""String_Node_Str""},SLASH),null,tags);
  return (Set<String>)this.executeRequest(request,Set.class,String.class);
}","/** 
 * Update the tags for a given application.
 * @param id   The id of the application to update the tags for.Not null/empty/blank.
 * @param tags The tags to replace existing tagfiles with. Not null.
 * @return The new set of application tags.
 * @throws GenieException
 */
public Set<String> updateTagsForApplication(final String id,final Set<String> tags) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  if (tags == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.PUT,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id,""String_Node_Str""},SLASH),null,tags);
  return (Set<String>)this.executeRequest(request,Set.class,String.class);
}"
90154,"/** 
 * Create or update an application configuration.
 * @param id the id for the application to create or update
 * @param application the object encapsulating the new application to create
 * @return extracted application configuration response
 * @throws GenieException
 */
public Application updateApplication(final String id,final Application application) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.PUT,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id},SLASH),null,application);
  return (Application)this.executeRequest(request,null,Application.class);
}","/** 
 * Create or update an application configuration.
 * @param id          the id for the application to create or update
 * @param application the object encapsulating the new application to create
 * @return extracted application configuration response
 * @throws GenieException
 */
public Application updateApplication(final String id,final Application application) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.PUT,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id},SLASH),null,application);
  return (Application)this.executeRequest(request,null,Application.class);
}"
90155,"/** 
 * Add some more configuration files to a given application.
 * @param id The id of the application to add configurations to. NotNull/empty/blank.
 * @param configs The configuration files to add. Not null or empty.
 * @return The new set of configuration files for the given application.
 * @throws GenieException
 */
public Set<String> addConfigsToApplication(final String id,final Set<String> configs) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  if (configs == null || configs.isEmpty()) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.POST,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id,""String_Node_Str""},SLASH),null,configs);
  return (Set<String>)this.executeRequest(request,Set.class,String.class);
}","/** 
 * Add some more configuration files to a given application.
 * @param id      The id of the application to add configurations to. NotNull/empty/blank.
 * @param configs The configuration files to add. Not null or empty.
 * @return The new set of configuration files for the given application.
 * @throws GenieException
 */
public Set<String> addConfigsToApplication(final String id,final Set<String> configs) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  if (configs == null || configs.isEmpty()) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.POST,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id,""String_Node_Str""},SLASH),null,configs);
  return (Set<String>)this.executeRequest(request,Set.class,String.class);
}"
90156,"/** 
 * Gets a set of application configurations for the given parameters.
 * @param params key/value pairs in a map object.<br>More details on the parameters can be found on the Genie User Guide on GitHub.
 * @return List of application configuration elements that match the filter
 * @throws GenieException
 */
public List<Application> getApplications(final Multimap<String,String> params) throws GenieException {
  final HttpRequest request=this.buildRequest(Verb.GET,BASE_CONFIG_APPLICATION_REST_URL,params,null);
  return (List<Application>)this.executeRequest(request,List.class,Application.class);
}","/** 
 * Gets a set of application configurations for the given parameters.
 * @param params key/value pairs in a map object.<br><p/> More details on the parameters can be found on the Genie User Guide on GitHub.
 * @return List of application configuration elements that match the filter
 * @throws GenieException
 */
public List<Application> getApplications(final Multimap<String,String> params) throws GenieException {
  final HttpRequest request=this.buildRequest(Verb.GET,BASE_CONFIG_APPLICATION_REST_URL,params,null);
  return (List<Application>)this.executeRequest(request,List.class,Application.class);
}"
90157,"/** 
 * Add some more jar files to a given application.
 * @param id The id of the application to add jars to. NotNull/empty/blank.
 * @param jars The jar files to add. Not null or empty.
 * @return The new set of jar files for the given application.
 * @throws GenieException
 */
public Set<String> addJarsToApplication(final String id,final Set<String> jars) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  if (jars == null || jars.isEmpty()) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.POST,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id,""String_Node_Str""},SLASH),null,jars);
  return (Set<String>)this.executeRequest(request,Set.class,String.class);
}","/** 
 * Add some more jar files to a given application.
 * @param id   The id of the application to add jars to. NotNull/empty/blank.
 * @param jars The jar files to add. Not null or empty.
 * @return The new set of jar files for the given application.
 * @throws GenieException
 */
public Set<String> addJarsToApplication(final String id,final Set<String> jars) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  if (jars == null || jars.isEmpty()) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.POST,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id,""String_Node_Str""},SLASH),null,jars);
  return (Set<String>)this.executeRequest(request,Set.class,String.class);
}"
90158,"/** 
 * Update the jar files for a given application.
 * @param id The id of the application to update the jar filesfor. Not null/empty/blank.
 * @param jars The jar files to replace existing jarfiles with. Not null.
 * @return The new set of application jars.
 * @throws GenieException
 */
public Set<String> updateJarsForApplication(final String id,final Set<String> jars) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  if (jars == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.PUT,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id,""String_Node_Str""},SLASH),null,jars);
  return (Set<String>)this.executeRequest(request,Set.class,String.class);
}","/** 
 * Update the jar files for a given application.
 * @param id   The id of the application to update the jar filesfor. Not null/empty/blank.
 * @param jars The jar files to replace existing jarfiles with. Not null.
 * @return The new set of application jars.
 * @throws GenieException
 */
public Set<String> updateJarsForApplication(final String id,final Set<String> jars) throws GenieException {
  if (StringUtils.isBlank(id)) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  if (jars == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
  }
  final HttpRequest request=this.buildRequest(Verb.PUT,StringUtils.join(new String[]{BASE_CONFIG_APPLICATION_REST_URL,id,""String_Node_Str""},SLASH),null,jars);
  return (Set<String>)this.executeRequest(request,Set.class,String.class);
}"
90159,"/** 
 * Build a HTTP request from the given parameters.
 * @param verb The type of HTTP request to use.
 * @param requestUri The URI to send the request to.
 * @param params Any query parameters to send along with the request.
 * @param entity An entity if required to add to the request.
 * @return The HTTP request.
 * @throws GenieException
 */
protected HttpRequest buildRequest(final Verb verb,final String requestUri,final Multimap<String,String> params,final Object entity) throws GenieException {
  try {
    final HttpRequest.Builder builder=HttpRequest.newBuilder().verb(verb).header(HttpHeaders.CONTENT_TYPE,MediaType.APPLICATION_JSON).header(HttpHeaders.ACCEPT,MediaType.APPLICATION_JSON).uri(new URI(requestUri)).entity(entity);
    if (params != null) {
      for (      final Entry<String,String> param : params.entries()) {
        builder.queryParams(param.getKey(),param.getValue());
      }
    }
    return builder.build();
  }
 catch (  final URISyntaxException use) {
    LOG.error(use.getMessage(),use);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,use);
  }
}","/** 
 * Build a HTTP request from the given parameters.
 * @param verb       The type of HTTP request to use.
 * @param requestUri The URI to send the request to.
 * @param params     Any query parameters to send along with the request.
 * @param entity     An entity if required to add to the request.
 * @return The HTTP request.
 * @throws GenieException
 */
protected HttpRequest buildRequest(final Verb verb,final String requestUri,final Multimap<String,String> params,final Object entity) throws GenieException {
  try {
    final HttpRequest.Builder builder=HttpRequest.newBuilder().verb(verb).header(HttpHeaders.CONTENT_TYPE,MediaType.APPLICATION_JSON).header(HttpHeaders.ACCEPT,MediaType.APPLICATION_JSON).uri(new URI(requestUri)).entity(entity);
    if (params != null) {
      for (      final Entry<String,String> param : params.entries()) {
        builder.queryParams(param.getKey(),param.getValue());
      }
    }
    return builder.build();
  }
 catch (  final URISyntaxException use) {
    LOG.error(use.getMessage(),use);
    throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,use);
  }
}"
90160,"/** 
 * Execute a HTTP request.
 * @param < C > The collection class if a collection is the expected responseentity.
 * @param request The request to send
 * @param collectionClass The collection class. Null if none expected.
 * @param entityClass The entity class. Not null.
 * @return The response entity.
 * @throws GenieException
 */
protected <C extends Collection>Object executeRequest(final HttpRequest request,final Class<C> collectionClass,final Class entityClass) throws GenieException {
  HttpResponse response=null;
  try {
    response=this.client.executeWithLoadBalancer(request);
    if (response.isSuccess()) {
      if (collectionClass != null) {
        final ObjectMapper mapper=new ObjectMapper();
        final CollectionType type=mapper.getTypeFactory().constructCollectionType(collectionClass,entityClass);
        return mapper.readValue(response.getInputStream(),type);
      }
 else       if (entityClass != null) {
        return response.getEntity(entityClass);
      }
 else {
        throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"");
      }
    }
 else {
      throw new GenieException(response.getStatus(),response.getEntity(String.class));
    }
  }
 catch (  final Exception e) {
    if (e instanceof GenieException) {
      throw (GenieException)e;
    }
 else {
      LOG.error(e.getMessage(),e);
      throw new GenieException(HttpURLConnection.HTTP_INTERNAL_ERROR,e);
    }
  }
 finally {
    if (response != null) {
      response.close();
    }
  }
}","/** 
 * Execute a HTTP request.
 * @param < C >             The collection class if a collection is the expected responseentity.
 * @param request         The request to send
 * @param collectionClass The collection class. Null if none expected.
 * @param entityClass     The entity class. Not null.
 * @return The response entity.
 * @throws GenieException
 */
protected <C extends Collection>Object executeRequest(final HttpRequest request,final Class<C> collectionClass,final Class entityClass) throws GenieException {
  HttpResponse response=null;
  try {
    response=this.client.executeWithLoadBalancer(request);
    if (response.isSuccess()) {
      if (collectionClass != null) {
        final ObjectMapper mapper=new ObjectMapper();
        final CollectionType type=mapper.getTypeFactory().constructCollectionType(collectionClass,entityClass);
        return mapper.readValue(response.getInputStream(),type);
      }
 else       if (entityClass != null) {
        return response.getEntity(entityClass);
      }
 else {
        throw new GenieException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"");
      }
    }
 else {
      throw new GenieException(response.getStatus(),response.getEntity(String.class));
    }
  }
 catch (  final Exception e) {
    if (e instanceof GenieException) {
      throw (GenieException)e;
    }
 else {
      LOG.error(e.getMessage(),e);
      throw new GenieException(HttpURLConnection.HTTP_INTERNAL_ERROR,e);
    }
  }
 finally {
    if (response != null) {
      response.close();
    }
  }
}"
90161,"/** 
 * {@inheritDoc}
 */
@Override public void setJobStatus(final String id,final JobStatus status,final String msg) throws GenieException {
  LOG.debug(""String_Node_Str"" + id + ""String_Node_Str""+ msg);
  final Job job=this.jobRepo.findOne(id);
  if (job != null) {
    job.setJobStatus(status,msg);
  }
 else {
    throw new GenieException(HttpURLConnection.HTTP_NOT_FOUND,""String_Node_Str"" + id + ""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void setJobStatus(final String id,final JobStatus status,final String msg) throws GenieException {
  LOG.debug(""String_Node_Str"" + id + ""String_Node_Str""+ status+ ""String_Node_Str""+ msg);
  final Job job=this.jobRepo.findOne(id);
  if (job != null) {
    job.setJobStatus(status,msg);
  }
 else {
    throw new GenieException(HttpURLConnection.HTTP_NOT_FOUND,""String_Node_Str"" + id + ""String_Node_Str"");
  }
}"
90162,"/** 
 * Initializes the object with the job information and environment prior to job launch This method must be called before job is launched.
 * @param ji2 the JobInfo object passed by the user
 * @throws CloudServiceException if there is an error during initialization
 */
protected void init(Job ji2) throws CloudServiceException {
  LOG.info(""String_Node_Str"");
  genieJobIDProp=GENIE_JOB_ID + ""String_Node_Str"" + ji2.getId();
  netflixEnvProp=NFLX_ENV + ""String_Node_Str"" + ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  String lipstickUuidPropName=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"",""String_Node_Str"");
  if (ConfigurationManager.getConfigInstance().getBoolean(""String_Node_Str"",false)) {
    lipstickUuidProp=lipstickUuidPropName + ""String_Node_Str"" + GENIE_JOB_ID;
  }
  this.env=initEnv(ji2);
  this.args=initArgs(ji2);
  this.ji=ji2;
}","/** 
 * Initializes the object with the job information and environment prior to job launch This method must be called before job is launched.
 * @param job the JobInfo object passed by the user
 * @throws CloudServiceException if there is an error during initialization
 */
protected void init(final Job job) throws CloudServiceException {
  LOG.info(""String_Node_Str"");
  genieJobIDProp=GENIE_JOB_ID + ""String_Node_Str"" + job.getId();
  netflixEnvProp=NFLX_ENV + ""String_Node_Str"" + ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  String lipstickUuidPropName=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"",""String_Node_Str"");
  if (ConfigurationManager.getConfigInstance().getBoolean(""String_Node_Str"",false)) {
    lipstickUuidProp=lipstickUuidPropName + ""String_Node_Str"" + GENIE_JOB_ID;
  }
  this.env=initEnv(job);
  this.args=initArgs(job);
  this.ji=job;
}"
90163,"/** 
 * Default constructor - initializes cluster configuration and load balancer.
 * @param jobMonitor The job monitor object to use.
 * @throws CloudServiceException if there is any error in initialization
 */
public YarnJobManager(final JobMonitor jobMonitor) throws CloudServiceException {
  this.jobMonitor=jobMonitor;
}","/** 
 * Default constructor - initializes cluster configuration and load balancer.
 * @param jobMonitor The job monitor object to use.
 * @throws CloudServiceException if there is any error in initialization
 */
@Inject public YarnJobManager(final JobMonitor jobMonitor) throws CloudServiceException {
  this.jobMonitor=jobMonitor;
  this.jobMonitorThread=new Thread(this.jobMonitor);
}"
90164,"/** 
 * Initialize, and launch the job once it has been initialized.
 * @param jInfo the JobInfo object for the job to be launched
 * @throws CloudServiceException if there is any error in the job launch
 */
@Override public void launch(final Job jInfo) throws CloudServiceException {
  LOG.info(""String_Node_Str"");
  init(jInfo);
  ProcessBuilder pb=new ProcessBuilder(this.args);
  String cWorkingDir=env.get(""String_Node_Str"") + File.separator + ji.getId();
  File userJobDir=new File(cWorkingDir);
  if (userJobDir.exists()) {
    String msg=""String_Node_Str"";
    ji.setJobStatus(JobStatus.FAILED,msg);
    LOG.error(ji.getStatusMsg() + ""String_Node_Str"" + userJobDir.getAbsolutePath());
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  boolean resMkDir=userJobDir.mkdirs();
  if (!resMkDir) {
    String msg=""String_Node_Str"";
    ji.setJobStatus(JobStatus.FAILED,msg);
    LOG.error(ji.getStatusMsg() + ""String_Node_Str"" + userJobDir.getAbsolutePath());
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  pb.directory(userJobDir);
  if (ji.getAttachments() != null) {
    for (    final FileAttachment attachment : ji.getAttachments()) {
      if ((attachment.getName() == null) || (attachment.getName().isEmpty())) {
        String msg=""String_Node_Str"";
        LOG.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
      }
      if (attachment.getData() == null) {
        String msg=""String_Node_Str"";
        LOG.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
      }
      FileOutputStream output=null;
      try {
        output=new FileOutputStream(cWorkingDir + File.separator + attachment.getName());
        DataHandler inputHandler=attachment.getData();
        inputHandler.writeTo(output);
      }
 catch (      IOException e) {
        String msg=""String_Node_Str"" + attachment.getName();
        LOG.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg,e);
      }
 finally {
        if (output != null) {
          try {
            output.close();
          }
 catch (          final IOException ioe) {
            final String msg=""String_Node_Str"";
            LOG.error(msg,ioe);
          }
        }
      }
    }
  }
  Map<String,String> penv=pb.environment();
  penv.putAll(env);
  LOG.info(""String_Node_Str"");
  penv.put(""String_Node_Str"",cWorkingDir);
  penv.put(""String_Node_Str"",cWorkingDir + ""String_Node_Str"");
  penv.put(""String_Node_Str"",cWorkingDir + ""String_Node_Str"");
  penv.put(""String_Node_Str"",cWorkingDir + ""String_Node_Str"");
  int pid;
  try {
    final Process proc=pb.start();
    pid=getProcessId(proc);
    this.ji.setProcessHandle(pid);
    this.jobMonitor.setJob(this.ji);
    this.jobMonitor.setProcess(proc);
    this.jobMonitor.setWorkingDir(cWorkingDir);
    this.jobMonitor.start();
    this.ji.setJobStatus(JobStatus.RUNNING,""String_Node_Str"");
  }
 catch (  IOException e) {
    String msg=""String_Node_Str"";
    LOG.error(msg,e);
    ji.setJobStatus(JobStatus.FAILED,msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg,e);
  }
  LOG.info(""String_Node_Str"" + pid);
}","/** 
 * Initialize, and launch the job once it has been initialized.
 * @param jInfo the JobInfo object for the job to be launched
 * @throws CloudServiceException if there is any error in the job launch
 */
@Override public void launch(final Job jInfo) throws CloudServiceException {
  LOG.info(""String_Node_Str"");
  init(jInfo);
  ProcessBuilder pb=new ProcessBuilder(this.args);
  String cWorkingDir=env.get(""String_Node_Str"") + File.separator + ji.getId();
  File userJobDir=new File(cWorkingDir);
  if (userJobDir.exists()) {
    String msg=""String_Node_Str"";
    ji.setJobStatus(JobStatus.FAILED,msg);
    LOG.error(ji.getStatusMsg() + ""String_Node_Str"" + userJobDir.getAbsolutePath());
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  boolean resMkDir=userJobDir.mkdirs();
  if (!resMkDir) {
    String msg=""String_Node_Str"";
    ji.setJobStatus(JobStatus.FAILED,msg);
    LOG.error(ji.getStatusMsg() + ""String_Node_Str"" + userJobDir.getAbsolutePath());
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  pb.directory(userJobDir);
  if (ji.getAttachments() != null) {
    for (    final FileAttachment attachment : ji.getAttachments()) {
      if ((attachment.getName() == null) || (attachment.getName().isEmpty())) {
        String msg=""String_Node_Str"";
        LOG.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
      }
      if (attachment.getData() == null) {
        String msg=""String_Node_Str"";
        LOG.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
      }
      FileOutputStream output=null;
      try {
        output=new FileOutputStream(cWorkingDir + File.separator + attachment.getName());
        DataHandler inputHandler=attachment.getData();
        inputHandler.writeTo(output);
      }
 catch (      IOException e) {
        String msg=""String_Node_Str"" + attachment.getName();
        LOG.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg,e);
      }
 finally {
        if (output != null) {
          try {
            output.close();
          }
 catch (          final IOException ioe) {
            final String msg=""String_Node_Str"";
            LOG.error(msg,ioe);
          }
        }
      }
    }
  }
  Map<String,String> penv=pb.environment();
  penv.putAll(env);
  LOG.info(""String_Node_Str"");
  penv.put(""String_Node_Str"",cWorkingDir);
  penv.put(""String_Node_Str"",cWorkingDir + ""String_Node_Str"");
  penv.put(""String_Node_Str"",cWorkingDir + ""String_Node_Str"");
  penv.put(""String_Node_Str"",cWorkingDir + ""String_Node_Str"");
  int pid;
  try {
    final Process proc=pb.start();
    pid=getProcessId(proc);
    this.ji.setProcessHandle(pid);
    this.jobMonitor.setJob(this.ji);
    this.jobMonitor.setProcess(proc);
    this.jobMonitor.setWorkingDir(cWorkingDir);
    this.jobMonitorThread.start();
    this.ji.setJobStatus(JobStatus.RUNNING,""String_Node_Str"");
  }
 catch (  IOException e) {
    String msg=""String_Node_Str"";
    LOG.error(msg,e);
    ji.setJobStatus(JobStatus.FAILED,msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg,e);
  }
  LOG.info(""String_Node_Str"" + pid);
}"
90165,"/** 
 * Kill the job pointed to by the job info - this only kills the Yarn job shell.
 * @param ji the jobInfo object for the job to be killed
 * @throws CloudServiceException if there is any error in job killing
 */
@Override public void kill(Job ji) throws CloudServiceException {
  LOG.info(""String_Node_Str"");
  if (ji == null) {
    String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  this.ji=ji;
  int processId=ji.getProcessHandle();
  if (processId > 0) {
    LOG.info(""String_Node_Str"" + processId);
    try {
      String genieHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
      if ((genieHome == null) || genieHome.isEmpty()) {
        String msg=""String_Node_Str"";
        LOG.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
      }
      Runtime.getRuntime().exec(genieHome + File.separator + ""String_Node_Str""+ processId);
    }
 catch (    CloudServiceException e) {
      String msg=""String_Node_Str"";
      LOG.error(msg,e);
      throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg,e);
    }
catch (    IOException e) {
      String msg=""String_Node_Str"";
      LOG.error(msg,e);
      throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg,e);
    }
  }
 else {
    String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
}","/** 
 * Kill the job pointed to by the job info - this only kills the Yarn job shell.
 * @param job the jobInfo object for the job to be killed
 * @throws CloudServiceException if there is any error in job killing
 */
@Override public void kill(final Job job) throws CloudServiceException {
  LOG.info(""String_Node_Str"");
  if (job == null) {
    String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  this.ji=job;
  int processId=job.getProcessHandle();
  if (processId > 0) {
    LOG.info(""String_Node_Str"" + processId);
    try {
      String genieHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
      if ((genieHome == null) || genieHome.isEmpty()) {
        String msg=""String_Node_Str"";
        LOG.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
      }
      Runtime.getRuntime().exec(genieHome + File.separator + ""String_Node_Str""+ processId);
    }
 catch (    final CloudServiceException e) {
      String msg=""String_Node_Str"";
      LOG.error(msg,e);
      throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg,e);
    }
catch (    final IOException e) {
      String msg=""String_Node_Str"";
      LOG.error(msg,e);
      throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg,e);
    }
  }
 else {
    String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
}"
90166,"/** 
 * Set/initialize environment variables for this job.
 * @param ji2 job info object for this job
 * @return a map containing environment variables for this job
 * @throws CloudServiceException if there is any error in initialization
 */
@Transactional(readOnly=true) protected Map<String,String> initEnv(Job ji2) throws CloudServiceException {
  LOG.info(""String_Node_Str"");
  Map<String,String> hEnv=new HashMap<String,String>();
  if ((ji2.getFileDependencies() != null) && (!ji2.getFileDependencies().isEmpty())) {
    hEnv.put(""String_Node_Str"",ji2.getFileDependencies());
  }
  Set<String> clusterConfigs=this.cluster.getConfigs();
  hEnv.put(""String_Node_Str"",convertCollectionToCSV(clusterConfigs));
  Command command=null;
  Application application=null;
  boolean done=false;
  if ((ji2.getCommandId() != null) && (!(ji2.getCommandId().isEmpty()))) {
    String cmdId=ji2.getCommandId();
    command=this.em.find(Command.class,cmdId);
    for (    final Application ace : command.getApplications()) {
      if ((ji2.getApplicationId() != null) && ((!ji2.getApplicationId().isEmpty()))) {
        if (ace.getId().equals(ji2.getApplicationId())) {
          application=ace;
          break;
        }
      }
 else       if ((ji2.getApplicationName() != null) && ((!ji2.getApplicationName().isEmpty()))) {
        if (ace.getName().equals(ji2.getApplicationName())) {
          application=ace;
          break;
        }
      }
 else {
        application=ace;
        break;
      }
    }
  }
 else   if ((ji2.getCommandName() != null) && (!(ji2.getCommandName().isEmpty()))) {
    for (    final Command cce : cluster.getCommands()) {
      if (cce.getName().equals(ji2.getCommandName())) {
        for (        final Application ace : cce.getApplications()) {
          if ((ji2.getApplicationId() != null) && ((!ji2.getApplicationId().isEmpty()))) {
            if (ace.getId().equals(ji2.getApplicationId())) {
              command=cce;
              application=ace;
              done=true;
              break;
            }
          }
 else           if ((ji2.getApplicationName() != null) && ((!ji2.getApplicationName().isEmpty()))) {
            if (ace.getName().equals(ji2.getApplicationName())) {
              command=cce;
              application=ace;
              done=true;
              break;
            }
          }
 else {
            command=cce;
            application=ace;
            done=true;
            break;
          }
        }
        if (done) {
          break;
        }
      }
    }
  }
  if (command == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  ji2.setCommandId(command.getId());
  ji2.setCommandName(command.getName());
  if (application != null) {
    ji2.setApplicationId(application.getId());
    ji2.setApplicationName(application.getName());
    if ((application.getConfigs() != null) && (!application.getConfigs().isEmpty())) {
      hEnv.put(""String_Node_Str"",convertCollectionToCSV(application.getConfigs()));
    }
    if ((application.getJars() != null) && (!application.getJars().isEmpty())) {
      hEnv.put(""String_Node_Str"",convertCollectionToCSV(application.getJars()));
    }
    if ((application.getEnvPropFile() != null) && (!application.getEnvPropFile().isEmpty())) {
      hEnv.put(""String_Node_Str"",application.getEnvPropFile());
    }
  }
  if ((command.getConfigs() != null) && (!command.getConfigs().isEmpty())) {
    hEnv.put(""String_Node_Str"",convertCollectionToCSV(command.getConfigs()));
  }
  this.executable=command.getExecutable();
  ji2.setExecutionClusterName(cluster.getName());
  ji2.setExecutionClusterId(cluster.getId());
  if ((command.getEnvPropFile() != null) && (!command.getEnvPropFile().isEmpty())) {
    hEnv.put(""String_Node_Str"",command.getEnvPropFile());
  }
  if ((ji2.getEnvPropFile() != null) && (!ji2.getEnvPropFile().isEmpty())) {
    hEnv.put(""String_Node_Str"",ji2.getEnvPropFile());
  }
  hEnv.put(""String_Node_Str"",ji2.getUser());
  hEnv.put(""String_Node_Str"",ji2.getUser());
  String groupName=HADOOP_GROUP_NAME;
  if (ji2.getGroup() != null) {
    groupName=ji2.getGroup();
    hEnv.put(""String_Node_Str"",groupName);
  }
  hEnv.put(""String_Node_Str"",groupName);
  String javaHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  if ((javaHome != null) && (!javaHome.isEmpty())) {
    hEnv.put(""String_Node_Str"",javaHome);
  }
  String genieHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  if ((genieHome == null) || genieHome.isEmpty()) {
    String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  hEnv.put(""String_Node_Str"",genieHome);
  String hadoopHome;
  if (cluster.getVersion() != null) {
    String hadoopVersion=cluster.getVersion();
    LOG.debug(""String_Node_Str"" + hadoopVersion);
    hadoopHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"" + hadoopVersion + ""String_Node_Str"");
    if (hadoopHome == null) {
      hadoopVersion=StringUtil.trimVersion(hadoopVersion);
      hadoopHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"" + hadoopVersion + ""String_Node_Str"");
    }
    if ((hadoopHome == null) || (!new File(hadoopHome).exists())) {
      String msg=""String_Node_Str"" + hadoopVersion;
      LOG.error(msg);
      throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
    }
    LOG.info(""String_Node_Str"" + hadoopHome);
    hEnv.put(""String_Node_Str"",hadoopHome);
  }
 else {
    hadoopHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
    if ((hadoopHome == null) || (!new File(hadoopHome).exists())) {
      String msg=""String_Node_Str"";
      LOG.error(msg);
      throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
    }
    hEnv.put(""String_Node_Str"",hadoopHome);
  }
  hEnv.put(""String_Node_Str"",ConfigurationManager.getConfigInstance().getString(""String_Node_Str"",""String_Node_Str""));
  String cpOpts;
  cpOpts=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"",""String_Node_Str"");
  String copyCommand=hadoopHome + ""String_Node_Str"" + cpOpts+ ""String_Node_Str"";
  hEnv.put(""String_Node_Str"",copyCommand);
  String mkdirCommand=hadoopHome + ""String_Node_Str"" + cpOpts+ ""String_Node_Str"";
  hEnv.put(""String_Node_Str"",mkdirCommand);
  String baseUserWorkingDir=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  if ((baseUserWorkingDir == null) || (baseUserWorkingDir.isEmpty())) {
    String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
 else {
    hEnv.put(""String_Node_Str"",baseUserWorkingDir);
  }
  if (!ji2.isDisableLogArchival()) {
    String s3ArchiveLocation=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
    if ((s3ArchiveLocation != null) && (!s3ArchiveLocation.isEmpty())) {
      hEnv.put(""String_Node_Str"",s3ArchiveLocation);
    }
  }
  hEnv.put(""String_Node_Str"",genieJobIDProp + ""String_Node_Str"" + netflixEnvProp+ ""String_Node_Str""+ lipstickUuidProp);
  return hEnv;
}","/** 
 * Set/initialize environment variables for this job.
 * @param ji2 job info object for this job
 * @return a map containing environment variables for this job
 * @throws CloudServiceException if there is any error in initialization
 */
@Transactional(readOnly=true) protected Map<String,String> initEnv(Job ji2) throws CloudServiceException {
  LOG.info(""String_Node_Str"");
  Map<String,String> hEnv=new HashMap<String,String>();
  if ((ji2.getFileDependencies() != null) && (!ji2.getFileDependencies().isEmpty())) {
    hEnv.put(""String_Node_Str"",ji2.getFileDependencies());
  }
  Set<String> clusterConfigs=this.cluster.getConfigs();
  hEnv.put(""String_Node_Str"",convertCollectionToCSV(clusterConfigs));
  Command command=null;
  Application application=null;
  boolean done=false;
  if ((ji2.getCommandId() != null) && (!(ji2.getCommandId().isEmpty()))) {
    String cmdId=ji2.getCommandId();
    command=this.em.find(Command.class,cmdId);
    for (    final Application ace : command.getApplications()) {
      if ((ji2.getApplicationId() != null) && ((!ji2.getApplicationId().isEmpty()))) {
        if (ace.getId().equals(ji2.getApplicationId())) {
          application=ace;
          break;
        }
      }
 else       if ((ji2.getApplicationName() != null) && ((!ji2.getApplicationName().isEmpty()))) {
        if (ace.getName().equals(ji2.getApplicationName())) {
          application=ace;
          break;
        }
      }
 else {
        application=ace;
        break;
      }
    }
  }
 else   if ((ji2.getCommandName() != null) && (!(ji2.getCommandName().isEmpty()))) {
    for (    final Command cce : cluster.getCommands()) {
      if (cce.getName().equals(ji2.getCommandName())) {
        for (        final Application ace : cce.getApplications()) {
          if ((ji2.getApplicationId() != null) && ((!ji2.getApplicationId().isEmpty()))) {
            if (ace.getId().equals(ji2.getApplicationId())) {
              command=cce;
              application=ace;
              done=true;
              break;
            }
          }
 else           if ((ji2.getApplicationName() != null) && ((!ji2.getApplicationName().isEmpty()))) {
            if (ace.getName().equals(ji2.getApplicationName())) {
              command=cce;
              application=ace;
              done=true;
              break;
            }
          }
 else {
            command=cce;
            application=ace;
            done=true;
            break;
          }
        }
        if (done) {
          break;
        }
      }
    }
  }
  if (command == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  ji2.setCommandId(command.getId());
  ji2.setCommandName(command.getName());
  if (application != null) {
    ji2.setApplicationId(application.getId());
    ji2.setApplicationName(application.getName());
    if ((application.getConfigs() != null) && (!application.getConfigs().isEmpty())) {
      hEnv.put(""String_Node_Str"",convertCollectionToCSV(application.getConfigs()));
    }
    if ((application.getJars() != null) && (!application.getJars().isEmpty())) {
      hEnv.put(""String_Node_Str"",convertCollectionToCSV(application.getJars()));
    }
    if ((application.getEnvPropFile() != null) && (!application.getEnvPropFile().isEmpty())) {
      hEnv.put(""String_Node_Str"",application.getEnvPropFile());
    }
  }
  if ((command.getConfigs() != null) && (!command.getConfigs().isEmpty())) {
    hEnv.put(""String_Node_Str"",convertCollectionToCSV(command.getConfigs()));
  }
  this.executable=command.getExecutable();
  ji2.setExecutionClusterName(cluster.getName());
  ji2.setExecutionClusterId(cluster.getId());
  if ((command.getEnvPropFile() != null) && (!command.getEnvPropFile().isEmpty())) {
    hEnv.put(""String_Node_Str"",command.getEnvPropFile());
  }
  if ((ji2.getEnvPropFile() != null) && (!ji2.getEnvPropFile().isEmpty())) {
    hEnv.put(""String_Node_Str"",ji2.getEnvPropFile());
  }
  hEnv.put(""String_Node_Str"",ji2.getUser());
  hEnv.put(""String_Node_Str"",ji2.getUser());
  String groupName=HADOOP_GROUP_NAME;
  if (ji2.getGroup() != null) {
    groupName=ji2.getGroup();
    hEnv.put(""String_Node_Str"",groupName);
  }
  hEnv.put(""String_Node_Str"",groupName);
  String javaHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  if ((javaHome != null) && (!javaHome.isEmpty())) {
    hEnv.put(""String_Node_Str"",javaHome);
  }
  String genieHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  if ((genieHome == null) || genieHome.isEmpty()) {
    String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  hEnv.put(""String_Node_Str"",genieHome);
  String hadoopHome;
  if (this.cluster.getVersion() != null) {
    String hadoopVersion=cluster.getVersion();
    LOG.debug(""String_Node_Str"" + hadoopVersion);
    hadoopHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"" + hadoopVersion + ""String_Node_Str"");
    if (hadoopHome == null) {
      hadoopVersion=StringUtil.trimVersion(hadoopVersion);
      hadoopHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"" + hadoopVersion + ""String_Node_Str"");
    }
    if ((hadoopHome == null) || (!new File(hadoopHome).exists())) {
      String msg=""String_Node_Str"" + hadoopVersion;
      LOG.error(msg);
      throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
    }
    LOG.info(""String_Node_Str"" + hadoopHome);
    hEnv.put(""String_Node_Str"",hadoopHome);
  }
 else {
    hadoopHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
    if ((hadoopHome == null) || (!new File(hadoopHome).exists())) {
      String msg=""String_Node_Str"";
      LOG.error(msg);
      throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
    }
    hEnv.put(""String_Node_Str"",hadoopHome);
  }
  hEnv.put(""String_Node_Str"",ConfigurationManager.getConfigInstance().getString(""String_Node_Str"",""String_Node_Str""));
  String cpOpts;
  cpOpts=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"",""String_Node_Str"");
  String copyCommand=hadoopHome + ""String_Node_Str"" + cpOpts+ ""String_Node_Str"";
  hEnv.put(""String_Node_Str"",copyCommand);
  String mkdirCommand=hadoopHome + ""String_Node_Str"" + cpOpts+ ""String_Node_Str"";
  hEnv.put(""String_Node_Str"",mkdirCommand);
  String baseUserWorkingDir=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  if ((baseUserWorkingDir == null) || (baseUserWorkingDir.isEmpty())) {
    String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
 else {
    hEnv.put(""String_Node_Str"",baseUserWorkingDir);
  }
  if (!ji2.isDisableLogArchival()) {
    String s3ArchiveLocation=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
    if ((s3ArchiveLocation != null) && (!s3ArchiveLocation.isEmpty())) {
      hEnv.put(""String_Node_Str"",s3ArchiveLocation);
    }
  }
  hEnv.put(""String_Node_Str"",genieJobIDProp + ""String_Node_Str"" + netflixEnvProp+ ""String_Node_Str""+ lipstickUuidProp);
  return hEnv;
}"
90167,"/** 
 * Get the tags for this cluster criteria.
 * @return The tags for this criteria as unmodifiable list
 */
@XmlElement public Set<String> getTags(){
  return this.tags;
}","/** 
 * Get the tags for this cluster criteria.
 * @return The tags for this criteria as unmodifiable list
 */
public Set<String> getTags(){
  return this.tags;
}"
90168,"/** 
 * Set/initialize environment variables for this job.
 * @param ji2 job info object for this job
 * @return a map containing environment variables for this job
 * @throws CloudServiceException if there is any error in initialization
 */
protected Map<String,String> initEnv(Job ji2) throws CloudServiceException {
  LOG.info(""String_Node_Str"");
  Map<String,String> hEnv=new HashMap<String,String>();
  if ((ji2.getFileDependencies() != null) && (!ji2.getFileDependencies().isEmpty())) {
    hEnv.put(""String_Node_Str"",ji2.getFileDependencies());
  }
  cluster=getClusterConfig(ji2);
  ArrayList<String> clusterConfigList=cluster.getConfigs();
  hEnv.put(""String_Node_Str"",convertListToCSV(clusterConfigList));
  CommandConfig command=null;
  ApplicationConfig application=null;
  boolean done=false;
  if ((ji2.getCommandId() != null) && (!(ji2.getCommandId().isEmpty()))) {
    String cmdId=ji2.getCommandId();
    command=pmCommand.getEntity(cmdId,CommandConfig.class);
    for (    final ApplicationConfig ace : command.getApplications()) {
      if ((ji2.getApplicationId() != null) && ((!ji2.getApplicationId().isEmpty()))) {
        if (ace.getId().equals(ji2.getApplicationId())) {
          application=ace;
          break;
        }
      }
 else       if ((ji2.getApplicationName() != null) && ((!ji2.getApplicationName().isEmpty()))) {
        if (ace.getName().equals(ji2.getApplicationName())) {
          application=ace;
          break;
        }
      }
 else {
        application=ace;
        break;
      }
    }
  }
 else   if ((ji2.getCommandName() != null) && (!(ji2.getCommandName().isEmpty()))) {
    for (    final CommandConfig cce : cluster.getCommands()) {
      if (cce.getName().equals(ji2.getCommandName())) {
        for (        final ApplicationConfig ace : cce.getApplications()) {
          if ((ji2.getApplicationId() != null) && ((!ji2.getApplicationId().isEmpty()))) {
            if (ace.getId().equals(ji2.getApplicationId())) {
              command=cce;
              application=ace;
              done=true;
              break;
            }
          }
 else           if ((ji2.getApplicationName() != null) && ((!ji2.getApplicationName().isEmpty()))) {
            if (ace.getName().equals(ji2.getApplicationName())) {
              command=cce;
              application=ace;
              done=true;
              break;
            }
          }
 else {
            command=cce;
            application=ace;
            done=true;
            break;
          }
        }
        if (done) {
          break;
        }
      }
    }
  }
  if (command == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  ji2.setCommandId(command.getId());
  ji2.setCommandName(command.getName());
  if (application != null) {
    ji2.setApplicationId(application.getId());
    ji2.setApplicationName(application.getName());
  }
  hEnv.put(""String_Node_Str"",convertListToCSV(command.getConfigs()));
  hEnv.put(""String_Node_Str"",convertListToCSV(application.getConfigs()));
  hEnv.put(""String_Node_Str"",convertListToCSV(application.getJars()));
  this.executable=command.getExecutable();
  ji2.setExecutionClusterName(cluster.getName());
  ji2.setExecutionClusterId(cluster.getId());
  hEnv.put(""String_Node_Str"",application.getEnvPropFile());
  hEnv.put(""String_Node_Str"",command.getEnvPropFile());
  hEnv.put(""String_Node_Str"",ji2.getEnvPropFile());
  hEnv.put(""String_Node_Str"",ji2.getUserName());
  hEnv.put(""String_Node_Str"",ji2.getUserName());
  String groupName=HADOOP_GROUP_NAME;
  if (ji2.getGroupName() != null) {
    groupName=ji2.getGroupName();
    hEnv.put(""String_Node_Str"",groupName);
  }
  hEnv.put(""String_Node_Str"",groupName);
  String javaHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  if ((javaHome != null) && (!javaHome.isEmpty())) {
    hEnv.put(""String_Node_Str"",javaHome);
  }
  String genieHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  if ((genieHome == null) || genieHome.isEmpty()) {
    String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  hEnv.put(""String_Node_Str"",genieHome);
  String hadoopHome;
  if (cluster.getVersion() != null) {
    String hadoopVersion=cluster.getVersion();
    LOG.debug(""String_Node_Str"" + hadoopVersion);
    hadoopHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"" + hadoopVersion + ""String_Node_Str"");
    if (hadoopHome == null) {
      hadoopVersion=StringUtil.trimVersion(hadoopVersion);
      hadoopHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"" + hadoopVersion + ""String_Node_Str"");
    }
    if ((hadoopHome == null) || (!new File(hadoopHome).exists())) {
      String msg=""String_Node_Str"" + hadoopVersion;
      LOG.error(msg);
      throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
    }
    LOG.info(""String_Node_Str"" + hadoopHome);
    hEnv.put(""String_Node_Str"",hadoopHome);
  }
 else {
    hadoopHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
    if ((hadoopHome == null) || (!new File(hadoopHome).exists())) {
      String msg=""String_Node_Str"";
      LOG.error(msg);
      throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
    }
    hEnv.put(""String_Node_Str"",hadoopHome);
  }
  hEnv.put(""String_Node_Str"",ConfigurationManager.getConfigInstance().getString(""String_Node_Str"",""String_Node_Str""));
  String cpOpts=""String_Node_Str"";
  cpOpts=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"",""String_Node_Str"");
  String copyCommand=hadoopHome + ""String_Node_Str"" + cpOpts+ ""String_Node_Str"";
  hEnv.put(""String_Node_Str"",copyCommand);
  String mkdirCommand=hadoopHome + ""String_Node_Str"" + cpOpts+ ""String_Node_Str"";
  hEnv.put(""String_Node_Str"",mkdirCommand);
  String baseUserWorkingDir=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  if ((baseUserWorkingDir == null) || (baseUserWorkingDir.isEmpty())) {
    String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
 else {
    hEnv.put(""String_Node_Str"",baseUserWorkingDir);
  }
  if (!ji2.isDisableLogArchival()) {
    String s3ArchiveLocation=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
    if ((s3ArchiveLocation != null) && (!s3ArchiveLocation.isEmpty())) {
      hEnv.put(""String_Node_Str"",s3ArchiveLocation);
    }
  }
  hEnv.put(""String_Node_Str"",genieJobIDProp + ""String_Node_Str"" + netflixEnvProp+ ""String_Node_Str""+ lipstickUuidProp);
  return hEnv;
}","/** 
 * Set/initialize environment variables for this job.
 * @param ji2 job info object for this job
 * @return a map containing environment variables for this job
 * @throws CloudServiceException if there is any error in initialization
 */
protected Map<String,String> initEnv(Job ji2) throws CloudServiceException {
  LOG.info(""String_Node_Str"");
  Map<String,String> hEnv=new HashMap<String,String>();
  if ((ji2.getFileDependencies() != null) && (!ji2.getFileDependencies().isEmpty())) {
    hEnv.put(""String_Node_Str"",ji2.getFileDependencies());
  }
  cluster=getClusterConfig(ji2);
  ArrayList<String> clusterConfigList=cluster.getConfigs();
  hEnv.put(""String_Node_Str"",convertListToCSV(clusterConfigList));
  CommandConfig command=null;
  ApplicationConfig application=null;
  boolean done=false;
  if ((ji2.getCommandId() != null) && (!(ji2.getCommandId().isEmpty()))) {
    String cmdId=ji2.getCommandId();
    command=pmCommand.getEntity(cmdId,CommandConfig.class);
    for (    final ApplicationConfig ace : command.getApplications()) {
      if ((ji2.getApplicationId() != null) && ((!ji2.getApplicationId().isEmpty()))) {
        if (ace.getId().equals(ji2.getApplicationId())) {
          application=ace;
          break;
        }
      }
 else       if ((ji2.getApplicationName() != null) && ((!ji2.getApplicationName().isEmpty()))) {
        if (ace.getName().equals(ji2.getApplicationName())) {
          application=ace;
          break;
        }
      }
 else {
        application=ace;
        break;
      }
    }
  }
 else   if ((ji2.getCommandName() != null) && (!(ji2.getCommandName().isEmpty()))) {
    for (    final CommandConfig cce : cluster.getCommands()) {
      if (cce.getName().equals(ji2.getCommandName())) {
        for (        final ApplicationConfig ace : cce.getApplications()) {
          if ((ji2.getApplicationId() != null) && ((!ji2.getApplicationId().isEmpty()))) {
            if (ace.getId().equals(ji2.getApplicationId())) {
              command=cce;
              application=ace;
              done=true;
              break;
            }
          }
 else           if ((ji2.getApplicationName() != null) && ((!ji2.getApplicationName().isEmpty()))) {
            if (ace.getName().equals(ji2.getApplicationName())) {
              command=cce;
              application=ace;
              done=true;
              break;
            }
          }
 else {
            command=cce;
            application=ace;
            done=true;
            break;
          }
        }
        if (done) {
          break;
        }
      }
    }
  }
  if (command == null) {
    final String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  ji2.setCommandId(command.getId());
  ji2.setCommandName(command.getName());
  if (application != null) {
    ji2.setApplicationId(application.getId());
    ji2.setApplicationName(application.getName());
    hEnv.put(""String_Node_Str"",convertListToCSV(application.getConfigs()));
    hEnv.put(""String_Node_Str"",convertListToCSV(application.getJars()));
    hEnv.put(""String_Node_Str"",application.getEnvPropFile());
  }
  hEnv.put(""String_Node_Str"",convertListToCSV(command.getConfigs()));
  this.executable=command.getExecutable();
  ji2.setExecutionClusterName(cluster.getName());
  ji2.setExecutionClusterId(cluster.getId());
  hEnv.put(""String_Node_Str"",command.getEnvPropFile());
  hEnv.put(""String_Node_Str"",ji2.getEnvPropFile());
  hEnv.put(""String_Node_Str"",ji2.getUserName());
  hEnv.put(""String_Node_Str"",ji2.getUserName());
  String groupName=HADOOP_GROUP_NAME;
  if (ji2.getGroupName() != null) {
    groupName=ji2.getGroupName();
    hEnv.put(""String_Node_Str"",groupName);
  }
  hEnv.put(""String_Node_Str"",groupName);
  String javaHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  if ((javaHome != null) && (!javaHome.isEmpty())) {
    hEnv.put(""String_Node_Str"",javaHome);
  }
  String genieHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  if ((genieHome == null) || genieHome.isEmpty()) {
    String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  hEnv.put(""String_Node_Str"",genieHome);
  String hadoopHome;
  if (cluster.getVersion() != null) {
    String hadoopVersion=cluster.getVersion();
    LOG.debug(""String_Node_Str"" + hadoopVersion);
    hadoopHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"" + hadoopVersion + ""String_Node_Str"");
    if (hadoopHome == null) {
      hadoopVersion=StringUtil.trimVersion(hadoopVersion);
      hadoopHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"" + hadoopVersion + ""String_Node_Str"");
    }
    if ((hadoopHome == null) || (!new File(hadoopHome).exists())) {
      String msg=""String_Node_Str"" + hadoopVersion;
      LOG.error(msg);
      throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
    }
    LOG.info(""String_Node_Str"" + hadoopHome);
    hEnv.put(""String_Node_Str"",hadoopHome);
  }
 else {
    hadoopHome=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
    if ((hadoopHome == null) || (!new File(hadoopHome).exists())) {
      String msg=""String_Node_Str"";
      LOG.error(msg);
      throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
    }
    hEnv.put(""String_Node_Str"",hadoopHome);
  }
  hEnv.put(""String_Node_Str"",ConfigurationManager.getConfigInstance().getString(""String_Node_Str"",""String_Node_Str""));
  String cpOpts=""String_Node_Str"";
  cpOpts=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"",""String_Node_Str"");
  String copyCommand=hadoopHome + ""String_Node_Str"" + cpOpts+ ""String_Node_Str"";
  hEnv.put(""String_Node_Str"",copyCommand);
  String mkdirCommand=hadoopHome + ""String_Node_Str"" + cpOpts+ ""String_Node_Str"";
  hEnv.put(""String_Node_Str"",mkdirCommand);
  String baseUserWorkingDir=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
  if ((baseUserWorkingDir == null) || (baseUserWorkingDir.isEmpty())) {
    String msg=""String_Node_Str"";
    LOG.error(msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
 else {
    hEnv.put(""String_Node_Str"",baseUserWorkingDir);
  }
  if (!ji2.isDisableLogArchival()) {
    String s3ArchiveLocation=ConfigurationManager.getConfigInstance().getString(""String_Node_Str"");
    if ((s3ArchiveLocation != null) && (!s3ArchiveLocation.isEmpty())) {
      hEnv.put(""String_Node_Str"",s3ArchiveLocation);
    }
  }
  hEnv.put(""String_Node_Str"",genieJobIDProp + ""String_Node_Str"" + netflixEnvProp+ ""String_Node_Str""+ lipstickUuidProp);
  return hEnv;
}"
90169,"/** 
 * Insert/update command config.
 * @param id unique id for config to upsert
 * @param request contains the comamnd config element for update
 * @return successful response, or one with an HTTP error code
 */
@PUT @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) public Response updateCommandConfig(@PathParam(""String_Node_Str"") String id,CommandConfigRequest request){
  LOG.info(""String_Node_Str"");
  CommandConfig commandConfig=request.getCommandConfig();
  if (commandConfig != null) {
    commandConfig.setId(id);
    ArrayList<String> appids=commandConfig.getAppids();
    if (appids != null) {
      PersistenceManager<ApplicationConfig> pma=new PersistenceManager<ApplicationConfig>();
      ArrayList<ApplicationConfig> appList=new ArrayList<ApplicationConfig>();
      Iterator<String> it=appids.iterator();
      while (it.hasNext()) {
        String appId=(String)it.next();
        ApplicationConfig ae=(ApplicationConfig)pma.getEntity(appId,ApplicationConfig.class);
        if (ae != null) {
          appList.add(ae);
        }
 else {
          CommandConfigResponse acr=new CommandConfigResponse(new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"" + appId + ""String_Node_Str""));
          return ResponseUtil.createResponse(acr);
        }
      }
      commandConfig.setApplications(appList);
    }
  }
  CommandConfigResponse ccr=ccs.updateCommandConfig(request);
  return ResponseUtil.createResponse(ccr);
}","/** 
 * Insert/update command config.
 * @param id unique id for config to upsert
 * @param request contains the comamnd config element for update
 * @return successful response, or one with an HTTP error code
 */
@PUT @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) public Response updateCommandConfig(@PathParam(""String_Node_Str"") String id,CommandConfigRequest request){
  LOG.info(""String_Node_Str"");
  CommandConfig commandConfig=request.getCommandConfig();
  if (commandConfig != null) {
    commandConfig.setId(id);
    ArrayList<String> appids=commandConfig.getAppIds();
    if (appids != null) {
      PersistenceManager<ApplicationConfig> pma=new PersistenceManager<ApplicationConfig>();
      ArrayList<ApplicationConfig> appList=new ArrayList<ApplicationConfig>();
      Iterator<String> it=appids.iterator();
      while (it.hasNext()) {
        String appId=(String)it.next();
        ApplicationConfig ae=(ApplicationConfig)pma.getEntity(appId,ApplicationConfig.class);
        if (ae != null) {
          appList.add(ae);
        }
 else {
          CommandConfigResponse acr=new CommandConfigResponse(new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"" + appId + ""String_Node_Str""));
          return ResponseUtil.createResponse(acr);
        }
      }
      commandConfig.setApplications(appList);
    }
  }
  CommandConfigResponse ccr=ccs.updateCommandConfig(request);
  return ResponseUtil.createResponse(ccr);
}"
90170,"/** 
 * Create Command configuration.
 * @param request contains a command config element
 * @return successful response, or one with an HTTP error code
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) public Response createCommandConfig(CommandConfigRequest request){
  LOG.info(""String_Node_Str"");
  CommandConfig ce=request.getCommandConfig();
  if (ce == null) {
    return ResponseUtil.createResponse(new CommandConfigResponse(new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"")));
  }
  ArrayList<String> appids=ce.getAppids();
  if (appids != null) {
    PersistenceManager<ApplicationConfig> pma=new PersistenceManager<ApplicationConfig>();
    ArrayList<ApplicationConfig> appList=new ArrayList<ApplicationConfig>();
    Iterator<String> it=appids.iterator();
    while (it.hasNext()) {
      String appId=(String)it.next();
      ApplicationConfig ae=(ApplicationConfig)pma.getEntity(appId,ApplicationConfig.class);
      if (ae != null) {
        appList.add(ae);
      }
 else {
        CommandConfigResponse acr=new CommandConfigResponse(new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"" + appId + ""String_Node_Str""));
        return ResponseUtil.createResponse(acr);
      }
    }
    ce.setApplications(appList);
  }
  CommandConfigResponse acr=ccs.createCommandConfig(request);
  return ResponseUtil.createResponse(acr);
}","/** 
 * Create Command configuration.
 * @param request contains a command config element
 * @return successful response, or one with an HTTP error code
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) public Response createCommandConfig(CommandConfigRequest request){
  LOG.info(""String_Node_Str"");
  CommandConfig ce=request.getCommandConfig();
  if (ce == null) {
    return ResponseUtil.createResponse(new CommandConfigResponse(new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"")));
  }
  ArrayList<String> appids=ce.getAppIds();
  if (appids != null) {
    PersistenceManager<ApplicationConfig> pma=new PersistenceManager<ApplicationConfig>();
    ArrayList<ApplicationConfig> appList=new ArrayList<ApplicationConfig>();
    Iterator<String> it=appids.iterator();
    while (it.hasNext()) {
      String appId=(String)it.next();
      ApplicationConfig ae=(ApplicationConfig)pma.getEntity(appId,ApplicationConfig.class);
      if (ae != null) {
        appList.add(ae);
      }
 else {
        CommandConfigResponse acr=new CommandConfigResponse(new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,""String_Node_Str"" + appId + ""String_Node_Str""));
        return ResponseUtil.createResponse(acr);
      }
    }
    ce.setApplications(appList);
  }
  CommandConfigResponse acr=ccs.createCommandConfig(request);
  return ResponseUtil.createResponse(acr);
}"
90171,"/** 
 * Check the properties file to figure out if an email needs to be sent at the end of the job. If yes, get  mail properties and try and send email about Job Status.
 * @return 0 for success, -1 for failure
 */
private int sendEmail(){
  logger.info(""String_Node_Str"");
  String emailTo=ji.getUserEmail();
  if (emailTo == null) {
    logger.info(""String_Node_Str"");
    return -1;
  }
 else {
    logger.info(""String_Node_Str"" + emailTo);
  }
  String fromEmail=config.getString(""String_Node_Str"",""String_Node_Str"");
  logger.info(""String_Node_Str"" + fromEmail);
  String smtpHost=config.getString(""String_Node_Str"",""String_Node_Str"");
  logger.debug(""String_Node_Str"" + smtpHost);
  Properties properties=System.getProperties();
  properties.setProperty(""String_Node_Str"",smtpHost);
  Authenticator auth=null;
  Boolean enableAuth=config.getBoolean(""String_Node_Str"",false);
  if (enableAuth) {
    logger.debug(""String_Node_Str"");
    properties.put(""String_Node_Str"",enableAuth);
    properties.put(""String_Node_Str"",""String_Node_Str"");
    properties.put(""String_Node_Str"",""String_Node_Str"");
    String userName=config.getString(""String_Node_Str"");
    String password=config.getString(""String_Node_Str"");
    if ((userName == null) || (password == null)) {
      logger.error(""String_Node_Str"");
      return -1;
    }
    logger.debug(""String_Node_Str"" + userName + ""String_Node_Str""+ password);
    auth=new SMTPAuthenticator(userName,password);
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  Session session=Session.getDefaultInstance(properties,auth);
  try {
    MimeMessage message=new MimeMessage(session);
    message.setFrom(new InternetAddress(fromEmail));
    message.addRecipient(Message.RecipientType.TO,new InternetAddress(emailTo));
    message.setSubject(""String_Node_Str"" + ji.getJobName() + ""String_Node_Str""+ ji.getStatus());
    String body=""String_Node_Str"" + ""String_Node_Str"" + ji.getJobID() + ""String_Node_Str""+ ""String_Node_Str""+ ji.getJobName()+ ""String_Node_Str""+ ""String_Node_Str""+ ji.getStatus()+ ""String_Node_Str""+ ""String_Node_Str""+ ji.getStatusMsg()+ ""String_Node_Str""+ ""String_Node_Str""+ ji.getOutputURI()+ ""String_Node_Str"";
    message.setText(body);
    Transport.send(message);
    logger.debug(""String_Node_Str"");
  }
 catch (  MessagingException mex) {
    mex.printStackTrace();
    return -1;
  }
  return 0;
}","/** 
 * Check the properties file to figure out if an email needs to be sent at the end of the job. If yes, get mail properties and try and send email about Job Status.
 * @return 0 for success, -1 for failure
 */
private int sendEmail(){
  logger.debug(""String_Node_Str"");
  String emailTo=ji.getUserEmail();
  if (emailTo == null) {
    logger.info(""String_Node_Str"");
    return -1;
  }
 else {
    logger.info(""String_Node_Str"" + emailTo);
  }
  String fromEmail=config.getString(""String_Node_Str"",""String_Node_Str"");
  logger.info(""String_Node_Str"" + fromEmail);
  String smtpHost=config.getString(""String_Node_Str"",""String_Node_Str"");
  logger.debug(""String_Node_Str"" + smtpHost);
  Properties properties=System.getProperties();
  properties.setProperty(""String_Node_Str"",smtpHost);
  Authenticator auth=null;
  if (config.getBoolean(""String_Node_Str"",false)) {
    logger.debug(""String_Node_Str"");
    properties.put(""String_Node_Str"",""String_Node_Str"");
    properties.put(""String_Node_Str"",""String_Node_Str"");
    String userName=config.getString(""String_Node_Str"");
    String password=config.getString(""String_Node_Str"");
    if ((userName == null) || (password == null)) {
      logger.error(""String_Node_Str"");
      return -1;
    }
    logger.debug(""String_Node_Str"" + userName + ""String_Node_Str""+ password);
    auth=new SMTPAuthenticator(userName,password);
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  Session session=Session.getDefaultInstance(properties,auth);
  try {
    MimeMessage message=new MimeMessage(session);
    message.setFrom(new InternetAddress(fromEmail));
    message.addRecipient(Message.RecipientType.TO,new InternetAddress(emailTo));
    message.setSubject(""String_Node_Str"" + ji.getJobName() + ""String_Node_Str""+ ji.getStatus());
    String body=""String_Node_Str"" + ""String_Node_Str"" + ji.getJobID() + ""String_Node_Str""+ ""String_Node_Str""+ ji.getJobName()+ ""String_Node_Str""+ ""String_Node_Str""+ ji.getStatus()+ ""String_Node_Str""+ ""String_Node_Str""+ ji.getStatusMsg()+ ""String_Node_Str""+ ""String_Node_Str""+ ji.getOutputURI()+ ""String_Node_Str"";
    message.setText(body);
    Transport.send(message);
    logger.debug(""String_Node_Str"");
  }
 catch (  MessagingException mex) {
    mex.printStackTrace();
    return -1;
  }
  return 0;
}"
90172,"/** 
 * Default constructor
 */
SMTPAuthenticator(String username,String password){
  this.username=username;
  this.password=password;
}","/** 
 * Default constructor.
 */
SMTPAuthenticator(String username,String password){
  this.username=username;
  this.password=password;
}"
90173,"/** 
 * The main run method for this thread - wait till it finishes, and manage job state in DB.
 */
@Override public void run(){
  int exitCode=waitForExit();
  ji.setExitCode(exitCode);
  ReentrantReadWriteLock rwl=PersistenceManager.getDbLock();
  try {
    rwl.writeLock().lock();
    JobInfoElement dbJI=pm.getEntity(ji.getJobID(),JobInfoElement.class);
    if ((dbJI.getStatus() != null) && !dbJI.getStatus().equalsIgnoreCase(""String_Node_Str"")) {
      GenieNodeStatistics stats=GenieNodeStatistics.getInstance();
      if (exitCode != SubprocessStatus.SUCCESS.code()) {
        logger.error(""String_Node_Str"" + exitCode);
        String errMsg=Types.SubprocessStatus.message(exitCode);
        if ((errMsg == null) || (errMsg.isEmpty())) {
          errMsg=""String_Node_Str"";
        }
        ji.setJobStatus(JobStatus.FAILED,""String_Node_Str"" + errMsg);
        stats.incrGenieFailedJobs();
      }
 else {
        ji.setJobStatus(JobStatus.SUCCEEDED,""String_Node_Str"");
        stats.incrGenieSuccessfulJobs();
      }
      if (!ji.getDisableLogArchival()) {
        ji.setArchiveLocation(NetUtil.getArchiveURI(ji.getJobID()));
      }
      pm.updateEntity(ji);
      rwl.writeLock().unlock();
    }
 else {
      logger.debug(""String_Node_Str"" + ji.getJobID());
      rwl.writeLock().unlock();
    }
    if (config.getBoolean(""String_Node_Str"",false) == false) {
      logger.info(""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"");
      if (sendEmail() != 0) {
        logger.warn(""String_Node_Str"");
      }
    }
  }
  finally {
    if (rwl.writeLock().isHeldByCurrentThread()) {
      rwl.writeLock().unlock();
    }
  }
}","/** 
 * The main run method for this thread - wait till it finishes, and manage job state in DB.
 */
@Override public void run(){
  int exitCode=waitForExit();
  ji.setExitCode(exitCode);
  ReentrantReadWriteLock rwl=PersistenceManager.getDbLock();
  try {
    rwl.writeLock().lock();
    JobInfoElement dbJI=pm.getEntity(ji.getJobID(),JobInfoElement.class);
    if ((dbJI.getStatus() != null) && !dbJI.getStatus().equalsIgnoreCase(""String_Node_Str"")) {
      GenieNodeStatistics stats=GenieNodeStatistics.getInstance();
      if (exitCode != SubprocessStatus.SUCCESS.code()) {
        logger.error(""String_Node_Str"" + exitCode);
        String errMsg=Types.SubprocessStatus.message(exitCode);
        if ((errMsg == null) || (errMsg.isEmpty())) {
          errMsg=""String_Node_Str"";
        }
        ji.setJobStatus(JobStatus.FAILED,""String_Node_Str"" + errMsg);
        stats.incrGenieFailedJobs();
      }
 else {
        ji.setJobStatus(JobStatus.SUCCEEDED,""String_Node_Str"");
        stats.incrGenieSuccessfulJobs();
      }
      if (!ji.getDisableLogArchival()) {
        ji.setArchiveLocation(NetUtil.getArchiveURI(ji.getJobID()));
      }
      pm.updateEntity(ji);
      rwl.writeLock().unlock();
    }
 else {
      logger.debug(""String_Node_Str"" + ji.getJobID());
      rwl.writeLock().unlock();
    }
    if (config.getBoolean(""String_Node_Str"",false)) {
      logger.info(""String_Node_Str"");
      if (sendEmail() != 0) {
        logger.warn(""String_Node_Str"");
      }
    }
 else {
      logger.info(""String_Node_Str"");
    }
  }
  finally {
    if (rwl.writeLock().isHeldByCurrentThread()) {
      rwl.writeLock().unlock();
    }
  }
}"
90174,"/** 
 * Return a PasswordAuthentication object based on username/password
 */
public PasswordAuthentication getPasswordAuthentication(){
  return new PasswordAuthentication(username,password);
}","/** 
 * Return a PasswordAuthentication object based on username/password.
 */
public PasswordAuthentication getPasswordAuthentication(){
  return new PasswordAuthentication(username,password);
}"
90175,"/** 
 * Get the set of attachments for this job.
 * @return the set of attachments for this job
 */
public FileAttachment[] getAttachments(){
  return attachments;
}","/** 
 * Get the set of attachments for this job.
 * @return the set of attachments for this job
 */
public FileAttachment[] getAttachments(){
  if (attachments == null) {
    return null;
  }
 else {
    return Arrays.copyOf(attachments,attachments.length);
  }
}"
90176,"/** 
 * Set the attachments for this job.
 * @param attachments the attachments for this job
 */
public void setAttachments(FileAttachment[] attachments){
  this.attachments=attachments;
}","/** 
 * Set the attachments for this job.
 * @param attachments the attachments for this job
 */
public void setAttachments(FileAttachment[] attachments){
  if (attachments == null) {
    this.attachments=null;
  }
 else {
    this.attachments=Arrays.copyOf(attachments,attachments.length);
  }
}"
90177,"/** 
 * Initialize, and launch the job once it has been initialized.
 * @param ji the JobInfo object for the job to be launched
 * @throws CloudServiceException if there is any error in the job launch
 */
@Override public void launch(JobInfoElement ji) throws CloudServiceException {
  logger.info(""String_Node_Str"");
  init(ji);
  ProcessBuilder pb=new ProcessBuilder(args);
  String cWorkingDir=env.get(""String_Node_Str"") + File.separator + ji.getJobID();
  File userJobDir=new File(cWorkingDir);
  if (userJobDir.exists()) {
    String msg=""String_Node_Str"";
    ji.setJobStatus(JobStatus.FAILED,msg);
    logger.error(ji.getStatusMsg() + ""String_Node_Str"" + userJobDir.getAbsolutePath());
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  boolean resMkDir=userJobDir.mkdirs();
  if (!resMkDir) {
    String msg=""String_Node_Str"";
    ji.setJobStatus(JobStatus.FAILED,msg);
    logger.error(ji.getStatusMsg() + ""String_Node_Str"" + userJobDir.getAbsolutePath());
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  pb.directory(userJobDir);
  if ((ji.getAttachments() != null) && (ji.getAttachments().length > 0)) {
    for (int i=0; i < ji.getAttachments().length; i++) {
      FileAttachment attachment=ji.getAttachments()[i];
      if ((attachment.getName() == null) || (attachment.getName().isEmpty())) {
        String msg=""String_Node_Str"";
        logger.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
      }
      if (attachment.getData() == null) {
        String msg=""String_Node_Str"";
        logger.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
      }
      try {
        FileOutputStream output=new FileOutputStream(cWorkingDir + File.separator + attachment.getName());
        DataHandler inputHandler=attachment.getData();
        inputHandler.writeTo(output);
        output.close();
      }
 catch (      Exception e) {
        String msg=""String_Node_Str"" + attachment.getName();
        logger.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
      }
    }
  }
  Map<String,String> penv=pb.environment();
  penv.putAll(env);
  penv.put(""String_Node_Str"",cWorkingDir);
  penv.put(""String_Node_Str"",cWorkingDir + ""String_Node_Str"");
  int pid;
  try {
    Process proc=pb.start();
    pid=getProcessId(proc);
    ji.setProcessHandle(pid);
    JobMonitor jobMonitorThread=new JobMonitor(ji,cWorkingDir,proc);
    jobMonitorThread.start();
    ji.setJobStatus(JobStatus.RUNNING,""String_Node_Str"");
  }
 catch (  IOException e) {
    String msg=""String_Node_Str"";
    logger.error(msg,e);
    ji.setJobStatus(JobStatus.FAILED,msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg,e);
  }
  logger.info(""String_Node_Str"" + pid);
}","/** 
 * Initialize, and launch the job once it has been initialized.
 * @param ji the JobInfo object for the job to be launched
 * @throws CloudServiceException if there is any error in the job launch
 */
@Override public void launch(JobInfoElement ji) throws CloudServiceException {
  logger.info(""String_Node_Str"");
  init(ji);
  ProcessBuilder pb=new ProcessBuilder(args);
  String cWorkingDir=env.get(""String_Node_Str"") + File.separator + ji.getJobID();
  File userJobDir=new File(cWorkingDir);
  if (userJobDir.exists()) {
    String msg=""String_Node_Str"";
    ji.setJobStatus(JobStatus.FAILED,msg);
    logger.error(ji.getStatusMsg() + ""String_Node_Str"" + userJobDir.getAbsolutePath());
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  boolean resMkDir=userJobDir.mkdirs();
  if (!resMkDir) {
    String msg=""String_Node_Str"";
    ji.setJobStatus(JobStatus.FAILED,msg);
    logger.error(ji.getStatusMsg() + ""String_Node_Str"" + userJobDir.getAbsolutePath());
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
  }
  pb.directory(userJobDir);
  if ((ji.getAttachments() != null) && (ji.getAttachments().length > 0)) {
    for (int i=0; i < ji.getAttachments().length; i++) {
      FileAttachment attachment=ji.getAttachments()[i];
      if ((attachment.getName() == null) || (attachment.getName().isEmpty())) {
        String msg=""String_Node_Str"";
        logger.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
      }
      if (attachment.getData() == null) {
        String msg=""String_Node_Str"";
        logger.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_BAD_REQUEST,msg);
      }
      try {
        FileOutputStream output=new FileOutputStream(cWorkingDir + File.separator + attachment.getName());
        DataHandler inputHandler=attachment.getData();
        inputHandler.writeTo(output);
        output.close();
      }
 catch (      IOException e) {
        String msg=""String_Node_Str"" + attachment.getName();
        logger.error(msg);
        throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg);
      }
    }
  }
  Map<String,String> penv=pb.environment();
  penv.putAll(env);
  penv.put(""String_Node_Str"",cWorkingDir);
  penv.put(""String_Node_Str"",cWorkingDir + ""String_Node_Str"");
  int pid;
  try {
    Process proc=pb.start();
    pid=getProcessId(proc);
    ji.setProcessHandle(pid);
    JobMonitor jobMonitorThread=new JobMonitor(ji,cWorkingDir,proc);
    jobMonitorThread.start();
    ji.setJobStatus(JobStatus.RUNNING,""String_Node_Str"");
  }
 catch (  IOException e) {
    String msg=""String_Node_Str"";
    logger.error(msg,e);
    ji.setJobStatus(JobStatus.FAILED,msg);
    throw new CloudServiceException(HttpURLConnection.HTTP_INTERNAL_ERROR,msg,e);
  }
  logger.info(""String_Node_Str"" + pid);
}"
90178,"/** 
 * Main for running client code.
 */
public static void main(String[] args) throws Exception {
  System.out.println(""String_Node_Str"");
  ConfigurationManager.getConfigInstance().setProperty(""String_Node_Str"",""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  ExecutionServiceClient client=ExecutionServiceClient.getInstance();
  String userName=""String_Node_Str"";
  System.out.println(""String_Node_Str"");
  MultivaluedMapImpl params=new MultivaluedMapImpl();
  params.add(""String_Node_Str"",userName);
  params.add(""String_Node_Str"",JobType.HIVE.name());
  params.add(""String_Node_Str"",JobStatus.FAILED.name());
  params.add(""String_Node_Str"",3);
  JobInfoElement[] responses=client.getJobs(params);
  for (  JobInfoElement ji : responses) {
    System.out.println(""String_Node_Str"" + ji.getJobID() + ""String_Node_Str""+ ji.getStatus()+ ""String_Node_Str""+ ji.getFinishTime()+ ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  JobInfoElement jobInfo=new JobInfoElement();
  jobInfo.setUserName(userName);
  jobInfo.setJobType(JobType.HIVE.name());
  jobInfo.setDescription(""String_Node_Str"");
  jobInfo.setConfiguration(Configuration.TEST.name());
  jobInfo.setSchedule(Schedule.ADHOC.name());
  File query=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  PrintWriter pw=new PrintWriter(query);
  pw.println(""String_Node_Str"");
  pw.close();
  FileAttachment[] attachments=new FileAttachment[1];
  attachments[0]=new FileAttachment();
  attachments[0].setName(""String_Node_Str"");
  attachments[0].setData(new DataHandler(new FileDataSource(query.getAbsolutePath())));
  jobInfo.setAttachments(attachments);
  jobInfo.setCmdArgs(""String_Node_Str"");
  jobInfo=client.submitJob(jobInfo);
  String jobID=jobInfo.getJobID();
  String outputURI=jobInfo.getOutputURI();
  System.out.println(""String_Node_Str"" + jobID);
  System.out.println(""String_Node_Str"" + outputURI);
  System.out.println(""String_Node_Str"");
  jobInfo=client.getJob(jobID);
  System.out.println(""String_Node_Str"" + jobInfo.getStatus());
  System.out.println(""String_Node_Str"");
  jobInfo=client.waitForCompletion(jobID,600000,5000);
  System.out.println(""String_Node_Str"" + jobInfo.getStatus());
  System.out.println(""String_Node_Str"");
  JobStatusResponse jobStatus=client.killJob(jobID);
  System.out.println(""String_Node_Str"" + jobStatus.getMessage());
  System.out.println(""String_Node_Str"" + jobStatus.getStatus());
  System.out.println(""String_Node_Str"");
}","/** 
 * Main for running client code.
 */
public static void main(String[] args) throws Exception {
  System.out.println(""String_Node_Str"");
  ConfigurationManager.getConfigInstance().setProperty(""String_Node_Str"",""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  ExecutionServiceClient client=ExecutionServiceClient.getInstance();
  String userName=""String_Node_Str"";
  System.out.println(""String_Node_Str"");
  MultivaluedMapImpl params=new MultivaluedMapImpl();
  params.add(""String_Node_Str"",userName);
  params.add(""String_Node_Str"",JobType.HIVE.name());
  params.add(""String_Node_Str"",JobStatus.FAILED.name());
  params.add(""String_Node_Str"",3);
  JobInfoElement[] responses=client.getJobs(params);
  for (  JobInfoElement ji : responses) {
    System.out.println(""String_Node_Str"" + ji.getJobID() + ""String_Node_Str""+ ji.getStatus()+ ""String_Node_Str""+ ji.getFinishTime()+ ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  JobInfoElement jobInfo=new JobInfoElement();
  jobInfo.setUserName(userName);
  jobInfo.setJobType(JobType.HIVE.name());
  jobInfo.setDescription(""String_Node_Str"");
  jobInfo.setConfiguration(Configuration.TEST.name());
  jobInfo.setSchedule(Schedule.ADHOC.name());
  File query=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  PrintWriter pw=new PrintWriter(query,""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.close();
  FileAttachment[] attachments=new FileAttachment[1];
  attachments[0]=new FileAttachment();
  attachments[0].setName(""String_Node_Str"");
  attachments[0].setData(new DataHandler(new FileDataSource(query.getAbsolutePath())));
  jobInfo.setAttachments(attachments);
  jobInfo.setCmdArgs(""String_Node_Str"");
  jobInfo=client.submitJob(jobInfo);
  String jobID=jobInfo.getJobID();
  String outputURI=jobInfo.getOutputURI();
  System.out.println(""String_Node_Str"" + jobID);
  System.out.println(""String_Node_Str"" + outputURI);
  System.out.println(""String_Node_Str"");
  jobInfo=client.getJob(jobID);
  System.out.println(""String_Node_Str"" + jobInfo.getStatus());
  System.out.println(""String_Node_Str"");
  jobInfo=client.waitForCompletion(jobID,600000,5000);
  System.out.println(""String_Node_Str"" + jobInfo.getStatus());
  System.out.println(""String_Node_Str"");
  JobStatusResponse jobStatus=client.killJob(jobID);
  System.out.println(""String_Node_Str"" + jobStatus.getMessage());
  System.out.println(""String_Node_Str"" + jobStatus.getStatus());
  System.out.println(""String_Node_Str"");
}"
90179,"/** 
 * Test the counter and daemon thread that sets running job.
 * @throws InterruptedException
 * @throws CloudServiceException
 */
@Test public void testRunningJobs() throws InterruptedException, CloudServiceException {
  int numRunningJobs=JobCountManager.getNumInstanceJobs();
  stats.setGenieRunningJobs(0);
  Assert.assertEquals(stats.getGenieRunningJobs().intValue(),0);
  ConfigurationManager.getConfigInstance().setProperty(""String_Node_Str"",new Long(2000));
  stats.setGenieRunningJobs(5);
  Assert.assertEquals(stats.getGenieRunningJobs().intValue(),5);
  Thread.sleep(6000);
  Assert.assertEquals(numRunningJobs,stats.getGenieRunningJobs().intValue());
}","/** 
 * Test the counter and daemon thread that sets running job.
 * @throws InterruptedException
 * @throws CloudServiceException
 */
@Test public void testRunningJobs() throws InterruptedException, CloudServiceException {
  int numRunningJobs=JobCountManager.getNumInstanceJobs();
  stats.setGenieRunningJobs(0);
  Assert.assertEquals(stats.getGenieRunningJobs().intValue(),0);
  ConfigurationManager.getConfigInstance().setProperty(""String_Node_Str"",new Long(2000));
  stats.setGenieRunningJobs(5);
  Assert.assertEquals(stats.getGenieRunningJobs().intValue(),5);
  Thread.sleep(15000);
  Assert.assertEquals(numRunningJobs,stats.getGenieRunningJobs().intValue());
}"
90180,"/** 
 * Private constructor for singleton.
 */
private GenieNodeStatistics(){
}","/** 
 * Private constructor for singleton.
 */
private GenieNodeStatistics(){
  jobCountMonitor=new JobCountMonitor(this);
  jobCountMonitor.setDaemon(true);
  jobCountMonitor.start();
}"
90181,"/** 
 * Shut down cleanly.
 */
public void shutdown(){
  logger.info(""String_Node_Str"");
  Monitors.unregisterObject(this);
}","/** 
 * Shut down cleanly.
 */
public void shutdown(){
  logger.info(""String_Node_Str"");
  Monitors.unregisterObject(this);
  jobCountMonitor.setStop(true);
}"
90182,"@Test public void testContainsArrayContainer_ExcludeDisJointSet(){
  Container rc=new RunContainer().add(0,10);
  Container disjoint=new ArrayContainer().add(20,40);
  assertFalse(rc.contains(disjoint));
  assertFalse(disjoint.contains(rc));
}","@Test public void testContainsArrayContainer_ExcludeDisJointSet(){
  Container rc=new RunContainer().add(0,10);
  Container disjoint=new ArrayContainer().add(20,40);
  assertFalse(rc.contains(disjoint));
  assertFalse(disjoint.contains(rc));
  disjoint=new ArrayContainer().add((short)512);
  assertFalse(rc.contains(disjoint));
  assertFalse(disjoint.contains(rc));
  rc=rc.add(12,14).add(16,18).add(20,22);
  assertFalse(rc.contains(disjoint));
  assertFalse(disjoint.contains(rc));
  rc.trim();
  assertFalse(rc.contains(disjoint));
  assertFalse(disjoint.contains(rc));
}"
90183,"@Override protected boolean contains(BitmapContainer bitmapContainer){
  final int cardinality=getCardinality();
  if (bitmapContainer.getCardinality() != -1 && bitmapContainer.getCardinality() > cardinality) {
    return false;
  }
  final int runCount=numberOfRuns();
  short ib=0, ir=0;
  while (ib < bitmapContainer.bitmap.length && ir < runCount) {
    long w=bitmapContainer.bitmap[ib];
    while (w != 0 && ir < runCount) {
      short start=getValue(ir);
      int stop=start + toIntUnsigned(getLength(ir));
      long t=w & -w;
      long r=ib * 64 + Long.numberOfTrailingZeros(w);
      if (r < start) {
        return false;
      }
 else       if (r > stop) {
        ++ir;
      }
 else {
        w^=t;
      }
    }
    if (w == 0) {
      ++ib;
    }
 else {
      return false;
    }
  }
  if (ib < bitmapContainer.bitmap.length) {
    for (; ib < bitmapContainer.bitmap.length; ib++) {
      if (bitmapContainer.bitmap[ib] != 0) {
        return false;
      }
    }
  }
  return true;
}","@Override protected boolean contains(BitmapContainer bitmapContainer){
  final int cardinality=getCardinality();
  if (bitmapContainer.getCardinality() != -1 && bitmapContainer.getCardinality() > cardinality) {
    return false;
  }
  final int runCount=numberOfRuns();
  short ib=0, ir=0;
  while (ib < bitmapContainer.bitmap.length && ir < runCount) {
    long w=bitmapContainer.bitmap[ib];
    while (w != 0 && ir < runCount) {
      int start=Util.toIntUnsigned(getValue(ir));
      int stop=start + toIntUnsigned(getLength(ir));
      long t=w & -w;
      long r=ib * 64 + Long.numberOfTrailingZeros(w);
      if (r < start) {
        return false;
      }
 else       if (r > stop) {
        ++ir;
      }
 else {
        w^=t;
      }
    }
    if (w == 0) {
      ++ib;
    }
 else {
      return false;
    }
  }
  if (ib < bitmapContainer.bitmap.length) {
    for (; ib < bitmapContainer.bitmap.length; ib++) {
      if (bitmapContainer.bitmap[ib] != 0) {
        return false;
      }
    }
  }
  return true;
}"
90184,"/** 
 * @param high for which high bucket should we compute the cardinality
 * @return the highest validatedIndex
 */
protected int ensureCumulatives(int high){
  if (allValid) {
    return sortedHighs.length;
  }
 else   if (compare(high,firstHighNotValid) < 0) {
    int position=binarySearch(sortedHighs,high);
    if (position >= 0) {
      return position + 1;
    }
 else {
      int insertionPosition=-position - 1;
      return insertionPosition;
    }
  }
 else {
    SortedMap<Integer,BitmapDataProvider> tailMap=highToBitmap.tailMap(firstHighNotValid,true);
    boolean earlyBreak=true;
    int indexOk=highToBitmap.size() - tailMap.size();
    Iterator<Entry<Integer,BitmapDataProvider>> it=tailMap.entrySet().iterator();
    while (it.hasNext()) {
      Entry<Integer,BitmapDataProvider> e=it.next();
      int currentHigh=e.getKey();
      if (compare(currentHigh,high) > 0) {
        earlyBreak=true;
        break;
      }
 else       if (e.getValue().isEmpty()) {
        if (latestAddedHigh != null && latestAddedHigh.getKey().intValue() == currentHigh) {
          latestAddedHigh=null;
        }
        it.remove();
      }
 else {
        ensureOne(e,currentHigh,indexOk);
        indexOk++;
      }
    }
    if (highToBitmap.isEmpty() || !earlyBreak) {
      allValid=true;
    }
    return indexOk;
  }
}","/** 
 * @param high for which high bucket should we compute the cardinality
 * @return the highest validatedIndex
 */
protected int ensureCumulatives(int high){
  if (allValid) {
    return highToBitmap.size();
  }
 else   if (compare(high,firstHighNotValid) < 0) {
    int position=binarySearch(sortedHighs,high);
    if (position >= 0) {
      return position + 1;
    }
 else {
      int insertionPosition=-position - 1;
      return insertionPosition;
    }
  }
 else {
    SortedMap<Integer,BitmapDataProvider> tailMap=highToBitmap.tailMap(firstHighNotValid,true);
    int indexOk=highToBitmap.size() - tailMap.size();
    Iterator<Entry<Integer,BitmapDataProvider>> it=tailMap.entrySet().iterator();
    while (it.hasNext()) {
      Entry<Integer,BitmapDataProvider> e=it.next();
      int currentHigh=e.getKey();
      if (compare(currentHigh,high) > 0) {
        break;
      }
 else       if (e.getValue().isEmpty()) {
        if (latestAddedHigh != null && latestAddedHigh.getKey().intValue() == currentHigh) {
          latestAddedHigh=null;
        }
        it.remove();
      }
 else {
        ensureOne(e,currentHigh,indexOk);
        indexOk++;
      }
    }
    if (highToBitmap.isEmpty() || indexOk == highToBitmap.values().size()) {
      allValid=true;
    }
    return indexOk;
  }
}"
90185,"/** 
 * Return the jth value stored in this bitmap.
 * @param j index of the value
 * @return the value
 */
@Override public long select(final long j){
  if (!doCacheCardinalities) {
    return selectNoCache(j);
  }
  int indexOk=ensureCumulatives(highestHigh());
  if (highToBitmap.isEmpty()) {
    return throwSelectInvalidIndex(j);
  }
  int position=Arrays.binarySearch(sortedCumulatedCardinality,0,indexOk,j);
  if (position >= 0) {
    if (position == indexOk - 1) {
      return throwSelectInvalidIndex(j);
    }
    int high=sortedHighs[position + 1];
    BitmapDataProvider nextBitmap=highToBitmap.get(high);
    return RoaringIntPacking.pack(high,nextBitmap.select(0));
  }
 else {
    int insertionPoint=-position - 1;
    final long previousBucketCardinality;
    if (insertionPoint == 0) {
      previousBucketCardinality=0L;
    }
 else     if (insertionPoint >= indexOk) {
      return throwSelectInvalidIndex(j);
    }
 else {
      previousBucketCardinality=sortedCumulatedCardinality[insertionPoint - 1];
    }
    final int givenBitmapSelect=(int)(j - previousBucketCardinality);
    int high=sortedHighs[insertionPoint];
    BitmapDataProvider lowBitmap=highToBitmap.get(high);
    int low=lowBitmap.select(givenBitmapSelect);
    return RoaringIntPacking.pack(high,low);
  }
}","/** 
 * Return the jth value stored in this bitmap.
 * @param j index of the value
 * @return the value
 * @throws IllegalArgumentException if j is out of the bounds of the bitmap cardinality
 */
@Override public long select(final long j) throws IllegalArgumentException {
  if (!doCacheCardinalities) {
    return selectNoCache(j);
  }
  int indexOk=ensureCumulatives(highestHigh());
  if (highToBitmap.isEmpty()) {
    return throwSelectInvalidIndex(j);
  }
  int position=Arrays.binarySearch(sortedCumulatedCardinality,0,indexOk,j);
  if (position >= 0) {
    if (position == indexOk - 1) {
      return throwSelectInvalidIndex(j);
    }
    int high=sortedHighs[position + 1];
    BitmapDataProvider nextBitmap=highToBitmap.get(high);
    return RoaringIntPacking.pack(high,nextBitmap.select(0));
  }
 else {
    int insertionPoint=-position - 1;
    final long previousBucketCardinality;
    if (insertionPoint == 0) {
      previousBucketCardinality=0L;
    }
 else     if (insertionPoint >= indexOk) {
      return throwSelectInvalidIndex(j);
    }
 else {
      previousBucketCardinality=sortedCumulatedCardinality[insertionPoint - 1];
    }
    final int givenBitmapSelect=(int)(j - previousBucketCardinality);
    int high=sortedHighs[insertionPoint];
    BitmapDataProvider lowBitmap=highToBitmap.get(high);
    int low=lowBitmap.select(givenBitmapSelect);
    return RoaringIntPacking.pack(high,low);
  }
}"
90186,"protected void ensureCumulatives(int x){
}","protected void ensureCumulatives(int high){
}"
90187,"@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeObject(hiToBitmap);
}","@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeObject(highToBitmap);
}"
90188,"private long pack(int x,int y){
  return (((long)x) << 32) | (y & 0xffffffffL);
}","private long pack(int high,int low){
  return (((long)high) << 32) | (low & 0xffffffffL);
}"
90189,"public long getCardinality(){
  if (hiToBitmap.isEmpty()) {
    return 0L;
  }
  ensureCumulatives(Integer.MAX_VALUE);
  return sortedCumulatedCardinality[sortedCumulatedCardinality.length - 1];
}","public long getCardinality(){
  if (highToBitmap.isEmpty()) {
    return 0L;
  }
  ensureCumulatives(Integer.MAX_VALUE);
  return sortedCumulatedCardinality[sortedCumulatedCardinality.length - 1];
}"
90190,"public LongIterator iterator(){
  final Iterator<Map.Entry<Integer,MutableRoaringBitmap>> it=hiToBitmap.entrySet().iterator();
  return new LongIterator(){
    protected int currentKey;
    protected IntIterator currentIt;
    @Override public boolean hasNext(){
      if (currentIt == null) {
        if (!moveToNextEntry(it)) {
          return false;
        }
      }
      while (true) {
        if (currentIt.hasNext()) {
          return true;
        }
 else {
          if (!moveToNextEntry(it)) {
            return false;
          }
        }
      }
    }
    /** 
 * @param it
 * @return true if we MAY have more entries. false if there is definitely nothing more
 */
    private boolean moveToNextEntry(    Iterator<Map.Entry<Integer,MutableRoaringBitmap>> it){
      if (it.hasNext()) {
        Map.Entry<Integer,MutableRoaringBitmap> next=it.next();
        currentKey=next.getKey();
        currentIt=next.getValue().getIntIterator();
        return true;
      }
 else {
        return false;
      }
    }
    @Override public long next(){
      if (hasNext()) {
        return pack(currentKey,currentIt.next());
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
    }
    @Override public LongIterator clone(){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
  }
;
}","public LongIterator iterator(){
  final Iterator<Map.Entry<Integer,MutableRoaringBitmap>> it=highToBitmap.entrySet().iterator();
  return new LongIterator(){
    protected int currentKey;
    protected IntIterator currentIt;
    @Override public boolean hasNext(){
      if (currentIt == null) {
        if (!moveToNextEntry(it)) {
          return false;
        }
      }
      while (true) {
        if (currentIt.hasNext()) {
          return true;
        }
 else {
          if (!moveToNextEntry(it)) {
            return false;
          }
        }
      }
    }
    /** 
 * @param it
 * @return true if we MAY have more entries. false if there is definitely nothing more
 */
    private boolean moveToNextEntry(    Iterator<Map.Entry<Integer,MutableRoaringBitmap>> it){
      if (it.hasNext()) {
        Map.Entry<Integer,MutableRoaringBitmap> next=it.next();
        currentKey=next.getKey();
        currentIt=next.getValue().getIntIterator();
        return true;
      }
 else {
        return false;
      }
    }
    @Override public long next(){
      if (hasNext()) {
        return pack(currentKey,currentIt.next());
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
    }
    @Override public LongIterator clone(){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
  }
;
}"
90191,"public long rankLong(long id){
  int x=(int)(id >> 32);
  int y=(int)id;
  ensureCumulatives(x);
  int bitmapPosition=Arrays.binarySearch(sortedHighs,0,sortedHighs.length,x);
  if (bitmapPosition >= 0) {
    final long previousBucketCardinality;
    if (bitmapPosition == 0) {
      previousBucketCardinality=0;
    }
 else {
      previousBucketCardinality=sortedCumulatedCardinality[bitmapPosition - 1];
    }
    MutableRoaringBitmap bitmap=linkedBitmaps.get(bitmapPosition);
    return previousBucketCardinality + bitmap.rankLong(y);
  }
 else {
    int insertionPoint=-bitmapPosition - 1;
    if (insertionPoint == 0) {
      return 0;
    }
 else {
      return sortedCumulatedCardinality[insertionPoint - 1];
    }
  }
}","public long rankLong(long id){
  int high=(int)(id >> 32);
  int low=(int)id;
  ensureCumulatives(high);
  int bitmapPosition=Arrays.binarySearch(sortedHighs,0,sortedHighs.length,high);
  if (bitmapPosition >= 0) {
    final long previousBucketCardinality;
    if (bitmapPosition == 0) {
      previousBucketCardinality=0;
    }
 else {
      previousBucketCardinality=sortedCumulatedCardinality[bitmapPosition - 1];
    }
    MutableRoaringBitmap bitmap=linkedBitmaps.get(bitmapPosition);
    return previousBucketCardinality + bitmap.rankLong(low);
  }
 else {
    int insertionPoint=-bitmapPosition - 1;
    if (insertionPoint == 0) {
      return 0;
    }
 else {
      return sortedCumulatedCardinality[insertionPoint - 1];
    }
  }
}"
90192,"@Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  hiToBitmap=(NavigableMap<Integer,MutableRoaringBitmap>)in.readObject();
}","@Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  highToBitmap=(NavigableMap<Integer,MutableRoaringBitmap>)in.readObject();
}"
90193,"public void addLong(long id){
  int x=(int)(id >> 32);
  int y=(int)id;
  Map.Entry<Integer,MutableRoaringBitmap> local=latest;
  if (local != null && local.getKey().intValue() == x) {
    local.getValue().add(y);
  }
 else {
    MutableRoaringBitmap bitmap=hiToBitmap.get(x);
    if (bitmap == null) {
      bitmap=new MutableRoaringBitmap();
      hiToBitmap.put(x,bitmap);
    }
    bitmap.add(y);
    latest=new AbstractMap.SimpleImmutableEntry<>(x,bitmap);
  }
  firstHighNotValid=Math.min(firstHighNotValid,x);
}","public void addLong(long id){
  int high=(int)(id >> 32);
  int low=(int)id;
  Map.Entry<Integer,MutableRoaringBitmap> local=latest;
  if (local != null && local.getKey().intValue() == high) {
    local.getValue().add(low);
  }
 else {
    MutableRoaringBitmap bitmap=highToBitmap.get(high);
    if (bitmap == null) {
      bitmap=new MutableRoaringBitmap();
      highToBitmap.put(high,bitmap);
    }
    bitmap.add(low);
    latest=new AbstractMap.SimpleImmutableEntry<>(high,bitmap);
  }
  firstHighNotValid=Math.min(firstHighNotValid,high);
  allValid=false;
}"
90194,"@Test public void testAddingLowValueAfterHighValue(){
  RoaringTreeMap map=new RoaringTreeMap();
  map.addLong(Long.MAX_VALUE);
  Assert.assertEquals(Long.MAX_VALUE,map.select(0));
  map.addLong(666);
  Assert.assertEquals(666,map.select(0));
  Assert.assertEquals(Long.MAX_VALUE,map.select(0));
}","@Test public void testAddingLowValueAfterHighValue(){
  RoaringTreeMap map=new RoaringTreeMap();
  map.addLong(Long.MAX_VALUE);
  Assert.assertEquals(Long.MAX_VALUE,map.select(0));
  map.addLong(666);
  Assert.assertEquals(666,map.select(0));
  Assert.assertEquals(Long.MAX_VALUE,map.select(1));
}"
90195,"/** 
 * @param high for which high bucket should we compute the cardinality
 * @return the highest validatedIndex
 */
protected int ensureCumulatives(int high){
  if (allValid) {
    return sortedHighs.length;
  }
 else   if (compare(high,firstHighNotValid) < 0) {
    int position=binarySearch(sortedHighs,high);
    if (position >= 0) {
      return position + 1;
    }
 else {
      int insertionPosition=-position - 1;
      return insertionPosition;
    }
  }
 else {
    SortedMap<Integer,BitmapDataProvider> tailMap=highToBitmap.tailMap(firstHighNotValid,true);
    int indexOk=highToBitmap.size() - tailMap.size();
    for (    Map.Entry<Integer,BitmapDataProvider> e : tailMap.entrySet()) {
      int currentHigh=e.getKey();
      if (compare(currentHigh,high) > 0) {
        break;
      }
      ensureOne(e,currentHigh,indexOk);
      indexOk++;
    }
    if (highToBitmap.isEmpty() || high == highToBitmap.lastKey().intValue()) {
      allValid=true;
    }
    return indexOk;
  }
}","/** 
 * @param high for which high bucket should we compute the cardinality
 * @return the highest validatedIndex
 */
protected int ensureCumulatives(int high){
  if (allValid) {
    return sortedHighs.length;
  }
 else   if (compare(high,firstHighNotValid) < 0) {
    int position=binarySearch(sortedHighs,high);
    if (position >= 0) {
      return position + 1;
    }
 else {
      int insertionPosition=-position - 1;
      return insertionPosition;
    }
  }
 else {
    SortedMap<Integer,BitmapDataProvider> tailMap=highToBitmap.tailMap(firstHighNotValid,true);
    boolean earlyBreak=true;
    int indexOk=highToBitmap.size() - tailMap.size();
    Iterator<Entry<Integer,BitmapDataProvider>> it=tailMap.entrySet().iterator();
    while (it.hasNext()) {
      Entry<Integer,BitmapDataProvider> e=it.next();
      int currentHigh=e.getKey();
      if (compare(currentHigh,high) > 0) {
        earlyBreak=true;
        break;
      }
 else       if (e.getValue().isEmpty()) {
        int sizeBefore=highToBitmap.size();
        it.remove();
        System.arraycopy(sortedCumulatedCardinality,indexOk + 1,sortedCumulatedCardinality,indexOk,sizeBefore - indexOk);
        System.arraycopy(sortedHighs,indexOk + 1,sortedHighs,indexOk,sizeBefore=indexOk);
        lowBitmaps.remove(indexOk);
      }
 else {
        ensureOne(e,currentHigh,indexOk);
        indexOk++;
      }
    }
    if (highToBitmap.isEmpty() || !earlyBreak) {
      allValid=true;
    }
    return indexOk;
  }
}"
90196,"@Ignore(""String_Node_Str"") @Test public void testRemove(){
  Roaring64NavigableMap map=new Roaring64NavigableMap();
  map.addLong(123);
  Assert.assertEquals(1L,map.getLongCardinality());
  map.remove(123L);
  Assert.assertEquals(0L,map.getLongCardinality());
  map.addLong(123);
  Assert.assertEquals(1L,map.getLongCardinality());
}","@Test public void testRemove(){
  Roaring64NavigableMap map=new Roaring64NavigableMap();
  map.addLong(123);
  Assert.assertEquals(1L,map.getLongCardinality());
  map.remove(123L);
  Assert.assertEquals(0L,map.getLongCardinality());
  map.addLong(123);
  Assert.assertEquals(1L,map.getLongCardinality());
}"
90197,"@Ignore(""String_Node_Str"") @Test public void testCardinalityAboveIntegerMaxValue(){
  Roaring64NavigableMap map=new Roaring64NavigableMap();
  map.add(0,outOfRoaringBitmapRange);
  Assert.assertEquals(0,map.select(0));
  Assert.assertEquals(outOfRoaringBitmapRange,map.select(outOfRoaringBitmapRange - 1));
  Assert.assertEquals(outOfRoaringBitmapRange,map.getLongCardinality());
}","@Test public void testCardinalityAboveIntegerMaxValue(){
  Roaring64NavigableMap map=new Roaring64NavigableMap();
  map.add(0,outOfRoaringBitmapRange);
  Assert.assertEquals(0,map.select(0));
  Assert.assertEquals(outOfRoaringBitmapRange,map.select(outOfRoaringBitmapRange - 1));
  Assert.assertEquals(outOfRoaringBitmapRange,map.getLongCardinality());
}"
90198,"@Override public int rank(short lowbits){
  int x=Util.toIntUnsigned(lowbits);
  int answer=0;
  for (int k=0; k < this.nbrruns; ++k) {
    int value=Util.toIntUnsigned(getValue(k));
    int length=Util.toIntUnsigned(getLength(k));
    if (x < value) {
      return answer;
    }
 else     if (value + length + 1 >= x) {
      return answer + x - value + 1;
    }
    answer+=length + 1;
  }
  return answer;
}","@Override public int rank(short lowbits){
  int x=Util.toIntUnsigned(lowbits);
  int answer=0;
  for (int k=0; k < this.nbrruns; ++k) {
    int value=Util.toIntUnsigned(getValue(k));
    int length=Util.toIntUnsigned(getLength(k));
    if (x < value) {
      return answer;
    }
 else     if (value + length + 1 > x) {
      return answer + x - value + 1;
    }
    answer+=length + 1;
  }
  return answer;
}"
90199,"public void shortRangeRank(){
  Container container=new RunContainer();
  container=container.add(16,32);
  assertTrue(container instanceof RunContainer);
  assertEquals(16,container.rank((short)32));
}","@Test public void shortRangeRank(){
  Container container=new RunContainer();
  container=container.add(16,32);
  assertTrue(container instanceof RunContainer);
  assertEquals(16,container.rank((short)32));
}"
90200,"/** 
 * Modifies the current bitmap by complementing the bits in the given range, from rangeStart (inclusive) rangeEnd (exclusive).
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 * @deprecated use the version where longs specify the range
 */
@Deprecated public void flip(final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    flip((long)rangeStart,(long)rangeEnd);
  }
  flip(rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}","/** 
 * Modifies the current bitmap by complementing the bits in the given range, from rangeStart (inclusive) rangeEnd (exclusive).
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 * @deprecated use the version where longs specify the range
 */
@Deprecated public void flip(final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    flip((long)rangeStart,(long)rangeEnd);
  }
 else {
    flip(rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
  }
}"
90201,"@Test @SuppressWarnings(""String_Node_Str"") public void testDeprecatedStaticFlip(){
  RoaringBitmap rb1=new RoaringBitmap();
  RoaringBitmap.flip(rb1,300000,500000);
  RoaringBitmap rb2=new RoaringBitmap();
  RoaringBitmap.flip(rb2,300000L,500000L);
  assertTrue(rb1.equals(rb2));
  RoaringBitmap.flip(rb1,Integer.MAX_VALUE + 300000,Integer.MAX_VALUE + 500000);
  RoaringBitmap.flip(rb2,Integer.MAX_VALUE + 300000L,Integer.MAX_VALUE + 500000L);
  assertTrue(rb1.equals(rb2));
}","@Test @SuppressWarnings(""String_Node_Str"") public void testDeprecatedStaticFlip(){
  RoaringBitmap rb1=RoaringBitmap.flip(new RoaringBitmap(),300000,500000);
  RoaringBitmap rb2=RoaringBitmap.flip(new RoaringBitmap(),300000L,500000L);
  assertTrue(rb1.equals(rb2));
  rb1=RoaringBitmap.flip(rb1,Integer.MAX_VALUE + 300000,Integer.MAX_VALUE + 500000);
  rb2=RoaringBitmap.flip(rb2,Integer.MAX_VALUE + 300000L,Integer.MAX_VALUE + 500000L);
  assertTrue(rb1.equals(rb2));
}"
90202,"protected static RoaringBitmap lazyorfromlazyinputs(final RoaringBitmap x1,final RoaringBitmap x2){
  final RoaringBitmap answer=new RoaringBitmap();
  int pos1=0, pos2=0;
  final int length1=x1.highLowContainer.size(), length2=x2.highLowContainer.size();
  main:   if (pos1 < length1 && pos2 < length2) {
    short s1=x1.highLowContainer.getKeyAtIndex(pos1);
    short s2=x2.highLowContainer.getKeyAtIndex(pos2);
    while (true) {
      if (s1 == s2) {
        Container c1=x1.highLowContainer.getContainerAtIndex(pos1);
        Container c2=x2.highLowContainer.getContainerAtIndex(pos2);
        if ((c2 instanceof BitmapContainer) && (!(c1 instanceof BitmapContainer))) {
          Container tmp=c1;
          c1=c2;
          c2=tmp;
        }
        answer.highLowContainer.append(s1,c1.lazyIOR(c2));
        pos1++;
        pos2++;
        if ((pos1 == length1) || (pos2 == length2)) {
          break main;
        }
        s1=x1.highLowContainer.getKeyAtIndex(pos1);
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
 else       if (Util.compareUnsigned(s1,s2) < 0) {
        Container c1=x1.highLowContainer.getContainerAtIndex(pos1);
        answer.highLowContainer.append(s1,c1);
        pos1++;
        if (pos1 == length1) {
          break main;
        }
        s1=x1.highLowContainer.getKeyAtIndex(pos1);
      }
 else {
        Container c2=x1.highLowContainer.getContainerAtIndex(pos2);
        answer.highLowContainer.append(s2,c2);
        pos2++;
        if (pos2 == length2) {
          break main;
        }
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
    }
  }
  if (pos1 == length1) {
    answer.highLowContainer.append(x2.highLowContainer,pos2,length2);
  }
 else   if (pos2 == length2) {
    answer.highLowContainer.append(x1.highLowContainer,pos1,length1);
  }
  return answer;
}","protected static RoaringBitmap lazyorfromlazyinputs(final RoaringBitmap x1,final RoaringBitmap x2){
  final RoaringBitmap answer=new RoaringBitmap();
  int pos1=0, pos2=0;
  final int length1=x1.highLowContainer.size(), length2=x2.highLowContainer.size();
  main:   if (pos1 < length1 && pos2 < length2) {
    short s1=x1.highLowContainer.getKeyAtIndex(pos1);
    short s2=x2.highLowContainer.getKeyAtIndex(pos2);
    while (true) {
      if (s1 == s2) {
        Container c1=x1.highLowContainer.getContainerAtIndex(pos1);
        Container c2=x2.highLowContainer.getContainerAtIndex(pos2);
        if ((c2 instanceof BitmapContainer) && (!(c1 instanceof BitmapContainer))) {
          Container tmp=c1;
          c1=c2;
          c2=tmp;
        }
        answer.highLowContainer.append(s1,c1.lazyIOR(c2));
        pos1++;
        pos2++;
        if ((pos1 == length1) || (pos2 == length2)) {
          break main;
        }
        s1=x1.highLowContainer.getKeyAtIndex(pos1);
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
 else       if (Util.compareUnsigned(s1,s2) < 0) {
        Container c1=x1.highLowContainer.getContainerAtIndex(pos1);
        answer.highLowContainer.append(s1,c1);
        pos1++;
        if (pos1 == length1) {
          break main;
        }
        s1=x1.highLowContainer.getKeyAtIndex(pos1);
      }
 else {
        Container c2=x2.highLowContainer.getContainerAtIndex(pos2);
        answer.highLowContainer.append(s2,c2);
        pos2++;
        if (pos2 == length2) {
          break main;
        }
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
    }
  }
  if (pos1 == length1) {
    answer.highLowContainer.append(x2.highLowContainer,pos2,length2);
  }
 else   if (pos2 == length2) {
    answer.highLowContainer.append(x1.highLowContainer,pos1,length1);
  }
  return answer;
}"
90203,"/** 
 * flip bits at start, start+1,..., end-1
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 */
public static void flipBitmapRange(long[] bitmap,int start,int end){
  if (start == end) {
    return;
  }
  int firstword=start / 64;
  int endword=(end - 1) / 64;
  bitmap[firstword]^=~(~0L << start);
  ;
  for (int i=firstword; i < endword; i++) {
    bitmap[i]=~bitmap[i];
  }
  bitmap[endword]^=~0L >>> -end;
}","/** 
 * flip bits at start, start+1,..., end-1
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 */
public static void flipBitmapRange(long[] bitmap,int start,int end){
  if (start == end) {
    return;
  }
  int firstword=start / 64;
  int endword=(end - 1) / 64;
  bitmap[firstword]^=~(~0L << start);
  for (int i=firstword; i < endword; i++) {
    bitmap[i]=~bitmap[i];
  }
  bitmap[endword]^=~0L >>> -end;
}"
90204,"protected static int unsignedLocalIntersect2by2Cardinality(final ShortBuffer set1,final int length1,final ShortBuffer set2,final int length2){
  if ((0 == length1) || (0 == length2)) {
    return 0;
  }
  int k1=0;
  int k2=0;
  int pos=0;
  short s1=set1.get(k1);
  short s2=set2.get(k2);
  mainwhile:   while (true) {
    if (toIntUnsigned(s2) < toIntUnsigned(s1)) {
      do {
        ++k2;
        if (k2 == length2) {
          break mainwhile;
        }
        s2=set2.get(k2);
      }
 while (toIntUnsigned(s2) < toIntUnsigned(s1));
    }
    if (toIntUnsigned(s1) < toIntUnsigned(s2)) {
      do {
        ++k1;
        if (k1 == length1) {
          break mainwhile;
        }
        s1=set1.get(k1);
      }
 while (toIntUnsigned(s1) < toIntUnsigned(s2));
    }
 else {
      ++k1;
      if (k1 == length1) {
        break;
      }
      s1=set1.get(k1);
      ++k2;
      if (k2 == length2) {
        break;
      }
      s2=set2.get(k2);
    }
  }
  return pos;
}","protected static int unsignedLocalIntersect2by2Cardinality(final ShortBuffer set1,final int length1,final ShortBuffer set2,final int length2){
  if ((0 == length1) || (0 == length2)) {
    return 0;
  }
  int k1=0;
  int k2=0;
  int pos=0;
  short s1=set1.get(k1);
  short s2=set2.get(k2);
  mainwhile:   while (true) {
    if (toIntUnsigned(s2) < toIntUnsigned(s1)) {
      do {
        ++k2;
        if (k2 == length2) {
          break mainwhile;
        }
        s2=set2.get(k2);
      }
 while (toIntUnsigned(s2) < toIntUnsigned(s1));
    }
    if (toIntUnsigned(s1) < toIntUnsigned(s2)) {
      do {
        ++k1;
        if (k1 == length1) {
          break mainwhile;
        }
        s1=set1.get(k1);
      }
 while (toIntUnsigned(s1) < toIntUnsigned(s2));
    }
 else {
      ++pos;
      ++k1;
      if (k1 == length1) {
        break;
      }
      s1=set1.get(k1);
      ++k2;
      if (k2 == length2) {
        break;
      }
      s2=set2.get(k2);
    }
  }
  return pos;
}"
90205,"/** 
 * Test massive or.
 */
@Test public void testMassiveXOr(){
  System.out.println(""String_Node_Str"");
  final int N=128;
  for (int howmany=512; howmany <= 1000000; howmany*=2) {
    RoaringBitmap[] ewah=new RoaringBitmap[N];
    for (int k=0; k < ewah.length; ++k) {
      ewah[k]=new RoaringBitmap();
    }
    for (int k=0; k < howmany; ++k) {
      ewah[Math.abs(k + 2 * k * k) % ewah.length].add(k);
    }
    for (int k=3; k < ewah.length; k+=3) {
      ewah[k].flip(13,howmany / 2);
    }
    RoaringBitmap answer=ewah[0];
    for (int k=1; k < ewah.length; ++k) {
      answer=RoaringBitmap.xor(answer,ewah[k]);
    }
    RoaringBitmap answer2=FastAggregation.xor(ewah);
    RoaringBitmap answer3=FastAggregation.horizontal_xor(ewah);
    Assert.assertTrue(answer.equals(answer2));
    Assert.assertTrue(answer.equals(answer3));
  }
}","/** 
 * Test massive xor.
 */
@Test public void testMassiveXOr(){
  System.out.println(""String_Node_Str"");
  final int N=128;
  for (int howmany=512; howmany <= 1000000; howmany*=2) {
    RoaringBitmap[] ewah=new RoaringBitmap[N];
    for (int k=0; k < ewah.length; ++k) {
      ewah[k]=new RoaringBitmap();
    }
    for (int k=0; k < howmany; ++k) {
      ewah[Math.abs(k + 2 * k * k) % ewah.length].add(k);
    }
    for (int k=3; k < ewah.length; k+=3) {
      ewah[k].flip(13,howmany / 2);
    }
    RoaringBitmap answer=ewah[0];
    for (int k=1; k < ewah.length; ++k) {
      answer=RoaringBitmap.xor(answer,ewah[k]);
    }
    RoaringBitmap rb1=RoaringBitmap.bitmapOf(randomlists[0]);
    RoaringBitmap rb2=RoaringBitmap.bitmapOf(randomlists[1]);
    RoaringBitmap rxor=FastAggregation.xor(rb1,rb2);
    RoaringBitmap answer2=FastAggregation.xor(ewah);
    RoaringBitmap answer3=FastAggregation.horizontal_xor(ewah);
    Assert.assertTrue(answer.equals(answer2));
    Assert.assertTrue(answer.equals(answer3));
    Assert.assertTrue(rxor.equals(FastAggregation.priorityqueue_xor(rb1,rb2)));
  }
}"
90206,"/** 
 * Test massive or.
 */
@Test public void testMassiveOr(){
  System.out.println(""String_Node_Str"");
  final int N=128;
  for (int howmany=512; howmany <= 1000000; howmany*=2) {
    RoaringBitmap[] ewah=new RoaringBitmap[N];
    for (int k=0; k < ewah.length; ++k) {
      ewah[k]=new RoaringBitmap();
    }
    for (int k=0; k < howmany; ++k) {
      ewah[Math.abs(k + 2 * k * k) % ewah.length].add(k);
    }
    for (int k=3; k < ewah.length; k+=3) {
      ewah[k].flip(13,howmany / 2);
    }
    RoaringBitmap answer=ewah[0];
    for (int k=1; k < ewah.length; ++k) {
      answer=RoaringBitmap.or(answer,ewah[k]);
    }
    RoaringBitmap answer2=FastAggregation.or(ewah);
    RoaringBitmap answer3=FastAggregation.horizontal_or(ewah);
    RoaringBitmap answer3b=FastAggregation.or(toIterator(ewah));
    Assert.assertTrue(answer.equals(answer2));
    Assert.assertTrue(answer.equals(answer3));
    Assert.assertTrue(answer.equals(answer3b));
  }
}","/** 
 * Test massive or.
 */
@Test public void testMassiveOr(){
  System.out.println(""String_Node_Str"");
  final int N=128;
  for (int howmany=512; howmany <= 1000000; howmany*=2) {
    RoaringBitmap[] ewah=new RoaringBitmap[N];
    for (int k=0; k < ewah.length; ++k) {
      ewah[k]=new RoaringBitmap();
    }
    for (int k=0; k < howmany; ++k) {
      ewah[Math.abs(k + 2 * k * k) % ewah.length].add(k);
    }
    for (int k=3; k < ewah.length; k+=3) {
      ewah[k].flip(13,howmany / 2);
    }
    RoaringBitmap answer=ewah[0];
    for (int k=1; k < ewah.length; ++k) {
      answer=RoaringBitmap.or(answer,ewah[k]);
    }
    RoaringBitmap rb1=RoaringBitmap.bitmapOf(randomlists[0]);
    RoaringBitmap rb2=RoaringBitmap.bitmapOf(randomlists[1]);
    List<RoaringBitmap> rbl=new ArrayList<>();
    rbl.add(rb1);
    rbl.add(rb2);
    ArrayList<RoaringBitmap> arrayList=new ArrayList<>();
    arrayList.add(rb1);
    arrayList.add(rb2);
    Iterator<RoaringBitmap> rbi=arrayList.iterator();
    RoaringBitmap rbor=RoaringBitmap.or(rb1,rb2);
    RoaringBitmap answer2=FastAggregation.or(ewah);
    RoaringBitmap answer3=FastAggregation.horizontal_or(ewah);
    RoaringBitmap answer3b=FastAggregation.or(toIterator(ewah));
    Assert.assertTrue(answer.equals(answer2));
    Assert.assertTrue(answer.equals(answer3));
    Assert.assertTrue(answer.equals(answer3b));
    Assert.assertTrue(rbor.equals(FastAggregation.horizontal_or(rbl)));
    Assert.assertTrue(rbor.equals(FastAggregation.priorityqueue_or(rb1,rb2)));
    Assert.assertTrue(rbor.equals(FastAggregation.priorityqueue_or(rbi)));
  }
}"
90207,"/** 
 * @deprecated use the version where longs specify the range
 */
@Deprecated public void add(final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    add((long)rangeStart,(long)rangeEnd);
  }
  add(rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}","/** 
 * Add to the current bitmap all integers in [rangeStart,rangeEnd).
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 * @deprecated use the version where longs specify the range
 */
@Deprecated public void add(final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    add((long)rangeStart,(long)rangeEnd);
  }
  add(rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}"
90208,"/** 
 * @deprecated use the version where longs specify the range. Negative values for rangeendpoints are not allowed.
 */
@Deprecated public static RoaringBitmap andNot(final RoaringBitmap x1,final RoaringBitmap x2,final int rangeStart,final int rangeEnd){
  return andNot(x1,x2,(long)rangeStart,(long)rangeEnd);
}","/** 
 * Bitwise ANDNOT (difference) operation for the given range, rangeStart (inclusive) and rangeEnd (exclusive). The provided bitmaps are *not* modified. This operation is thread-safe as long as the provided bitmaps remain unchanged.
 * @param x1 first bitmap
 * @param x2 other bitmap
 * @param rangeStart starting point of the range (inclusive)
 * @param rangeEnd end point of the range (exclusive)
 * @return result of the operation
 * @deprecated use the version where longs specify the range. Negative values for rangeendpoints are not allowed.
 */
@Deprecated public static RoaringBitmap andNot(final RoaringBitmap x1,final RoaringBitmap x2,final int rangeStart,final int rangeEnd){
  return andNot(x1,x2,(long)rangeStart,(long)rangeEnd);
}"
90209,"/** 
 * @deprecated use the version where longs specify the range. Negative range end are illegal.
 */
@Deprecated public static RoaringBitmap and(@SuppressWarnings(""String_Node_Str"") final Iterator bitmaps,final int rangeStart,final int rangeEnd){
  return and(bitmaps,(long)rangeStart,(long)rangeEnd);
}","/** 
 * Computes AND between input bitmaps in the given range, from rangeStart (inclusive) to rangeEnd (exclusive)
 * @param bitmaps input bitmaps, these are not modified
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 * @return new result bitmap
 * @deprecated use the version where longs specify the range. Negative range end are illegal.
 */
@Deprecated public static RoaringBitmap and(@SuppressWarnings(""String_Node_Str"") final Iterator bitmaps,final int rangeStart,final int rangeEnd){
  return and(bitmaps,(long)rangeStart,(long)rangeEnd);
}"
90210,"/** 
 * @deprecated use the version where longs specify the range. Negative values not allowed for rangeStart and rangeEnd
 */
@Deprecated public static RoaringBitmap xor(@SuppressWarnings(""String_Node_Str"") final Iterator bitmaps,final int rangeStart,final int rangeEnd){
  return xor(bitmaps,(long)rangeStart,(long)rangeEnd);
}","/** 
 * Computes XOR between input bitmaps in the given range, from rangeStart (inclusive) to rangeEnd (exclusive)
 * @param bitmaps input bitmaps, these are not modified
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 * @return new result bi
 * @deprecated use the version where longs specify the range. Negative values not allowed for rangeStart and rangeEnd
 */
@Deprecated public static RoaringBitmap xor(@SuppressWarnings(""String_Node_Str"") final Iterator bitmaps,final int rangeStart,final int rangeEnd){
  return xor(bitmaps,(long)rangeStart,(long)rangeEnd);
}"
90211,"/** 
 * @deprecated use the version where longs specify the range
 */
@Deprecated public void flip(final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    flip((long)rangeStart,(long)rangeEnd);
  }
  flip(rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}","/** 
 * Modifies the current bitmap by complementing the bits in the given range, from rangeStart (inclusive) rangeEnd (exclusive).
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 * @deprecated use the version where longs specify the range
 */
@Deprecated public void flip(final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    flip((long)rangeStart,(long)rangeEnd);
  }
  flip(rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}"
90212,"/** 
 * @deprecated use the version where longs specify the range. Negative range points are forbidden.
 */
@Deprecated public static RoaringBitmap or(@SuppressWarnings(""String_Node_Str"") final Iterator bitmaps,final int rangeStart,final int rangeEnd){
  return or(bitmaps,(long)rangeStart,(long)rangeEnd);
}","/** 
 * Computes OR between input bitmaps in the given range, from rangeStart (inclusive) to rangeEnd (exclusive)
 * @param bitmaps input bitmaps, these are not modified
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 * @return new result bitmap 
 * @deprecated use the version where longs specify the range. Negative range points are forbidden.
 */
@Deprecated public static RoaringBitmap or(@SuppressWarnings(""String_Node_Str"") final Iterator bitmaps,final int rangeStart,final int rangeEnd){
  return or(bitmaps,(long)rangeStart,(long)rangeEnd);
}"
90213,"/** 
 * Hamming weight of the 64-bit words involved in the range start, start+1,..., end-1
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 */
public static int cardinalityInBitmapWordRange(long[] bitmap,int start,int end){
  if (start == end) {
    return 0;
  }
  int firstword=start / 64;
  int endword=(end - 1) / 64;
  int answer=0;
  for (int i=firstword; i <= endword; i++) {
    answer+=Long.bitCount(bitmap[i]);
  }
  return answer;
}","/** 
 * Hamming weight of the 64-bit words involved in the range start, start+1,..., end-1
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 * @return the hamming weight
 */
public static int cardinalityInBitmapWordRange(long[] bitmap,int start,int end){
  if (start == end) {
    return 0;
  }
  int firstword=start / 64;
  int endword=(end - 1) / 64;
  int answer=0;
  for (int i=firstword; i <= endword; i++) {
    answer+=Long.bitCount(bitmap[i]);
  }
  return answer;
}"
90214,"/** 
 * set bits at start, start+1,..., end-1 and report the cardinality change
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 */
public static int setBitmapRangeAndCardinalityChange(long[] bitmap,int start,int end){
  int cardbefore=cardinalityInBitmapWordRange(bitmap,start,end);
  setBitmapRange(bitmap,start,end);
  int cardafter=cardinalityInBitmapWordRange(bitmap,start,end);
  return cardafter - cardbefore;
}","/** 
 * set bits at start, start+1,..., end-1 and report the cardinality change
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 * @return cardinality change
 */
public static int setBitmapRangeAndCardinalityChange(long[] bitmap,int start,int end){
  int cardbefore=cardinalityInBitmapWordRange(bitmap,start,end);
  setBitmapRange(bitmap,start,end);
  int cardafter=cardinalityInBitmapWordRange(bitmap,start,end);
  return cardafter - cardbefore;
}"
90215,"/** 
 * reset  bits at start, start+1,..., end-1 and report the cardinality change
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 */
public static int resetBitmapRangeAndCardinalityChange(long[] bitmap,int start,int end){
  int cardbefore=cardinalityInBitmapWordRange(bitmap,start,end);
  resetBitmapRange(bitmap,start,end);
  int cardafter=cardinalityInBitmapWordRange(bitmap,start,end);
  return cardafter - cardbefore;
}","/** 
 * reset  bits at start, start+1,..., end-1 and report the cardinality change
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 * @return cardinality change
 */
public static int resetBitmapRangeAndCardinalityChange(long[] bitmap,int start,int end){
  int cardbefore=cardinalityInBitmapWordRange(bitmap,start,end);
  resetBitmapRange(bitmap,start,end);
  int cardafter=cardinalityInBitmapWordRange(bitmap,start,end);
  return cardafter - cardbefore;
}"
90216,"/** 
 * flip  bits at start, start+1,..., end-1 and report the cardinality change
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 */
public static int flipBitmapRangeAndCardinalityChange(long[] bitmap,int start,int end){
  int cardbefore=cardinalityInBitmapWordRange(bitmap,start,end);
  flipBitmapRange(bitmap,start,end);
  int cardafter=cardinalityInBitmapWordRange(bitmap,start,end);
  return cardafter - cardbefore;
}","/** 
 * flip  bits at start, start+1,..., end-1 and report the cardinality change
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 * @return cardinality change
 */
public static int flipBitmapRangeAndCardinalityChange(long[] bitmap,int start,int end){
  int cardbefore=cardinalityInBitmapWordRange(bitmap,start,end);
  flipBitmapRange(bitmap,start,end);
  int cardafter=cardinalityInBitmapWordRange(bitmap,start,end);
  return cardafter - cardbefore;
}"
90217,"/** 
 * set bits at start, start+1,..., end-1 and report the cardinality change
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 */
public static int setBitmapRangeAndCardinalityChange(LongBuffer bitmap,int start,int end){
  if (BufferUtil.isBackedBySimpleArray(bitmap)) {
    return Util.setBitmapRangeAndCardinalityChange(bitmap.array(),start,end);
  }
  int cardbefore=cardinalityInBitmapWordRange(bitmap,start,end);
  setBitmapRange(bitmap,start,end);
  int cardafter=cardinalityInBitmapWordRange(bitmap,start,end);
  return cardafter - cardbefore;
}","/** 
 * set bits at start, start+1,..., end-1 and report the cardinality change
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 * @return cardinality change
 */
public static int setBitmapRangeAndCardinalityChange(LongBuffer bitmap,int start,int end){
  if (BufferUtil.isBackedBySimpleArray(bitmap)) {
    return Util.setBitmapRangeAndCardinalityChange(bitmap.array(),start,end);
  }
  int cardbefore=cardinalityInBitmapWordRange(bitmap,start,end);
  setBitmapRange(bitmap,start,end);
  int cardafter=cardinalityInBitmapWordRange(bitmap,start,end);
  return cardafter - cardbefore;
}"
90218,"/** 
 * reset bits at start, start+1,..., end-1 and report the cardinality change
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 */
public static int resetBitmapRangeAndCardinalityChange(LongBuffer bitmap,int start,int end){
  if (BufferUtil.isBackedBySimpleArray(bitmap)) {
    return Util.resetBitmapRangeAndCardinalityChange(bitmap.array(),start,end);
  }
  int cardbefore=cardinalityInBitmapWordRange(bitmap,start,end);
  resetBitmapRange(bitmap,start,end);
  int cardafter=cardinalityInBitmapWordRange(bitmap,start,end);
  return cardafter - cardbefore;
}","/** 
 * reset bits at start, start+1,..., end-1 and report the cardinality change
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 * @return cardinality change
 */
public static int resetBitmapRangeAndCardinalityChange(LongBuffer bitmap,int start,int end){
  if (BufferUtil.isBackedBySimpleArray(bitmap)) {
    return Util.resetBitmapRangeAndCardinalityChange(bitmap.array(),start,end);
  }
  int cardbefore=cardinalityInBitmapWordRange(bitmap,start,end);
  resetBitmapRange(bitmap,start,end);
  int cardafter=cardinalityInBitmapWordRange(bitmap,start,end);
  return cardafter - cardbefore;
}"
90219,"/** 
 * flip bits at start, start+1,..., end-1 and report the cardinality change
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 */
public static int flipBitmapRangeAndCardinalityChange(LongBuffer bitmap,int start,int end){
  if (BufferUtil.isBackedBySimpleArray(bitmap)) {
    return Util.flipBitmapRangeAndCardinalityChange(bitmap.array(),start,end);
  }
  int cardbefore=cardinalityInBitmapWordRange(bitmap,start,end);
  flipBitmapRange(bitmap,start,end);
  int cardafter=cardinalityInBitmapWordRange(bitmap,start,end);
  return cardafter - cardbefore;
}","/** 
 * flip bits at start, start+1,..., end-1 and report the cardinality change
 * @param bitmap array of words to be modified
 * @param start first index to be modified (inclusive)
 * @param end last index to be modified (exclusive)
 * @return cardinality change
 */
public static int flipBitmapRangeAndCardinalityChange(LongBuffer bitmap,int start,int end){
  if (BufferUtil.isBackedBySimpleArray(bitmap)) {
    return Util.flipBitmapRangeAndCardinalityChange(bitmap.array(),start,end);
  }
  int cardbefore=cardinalityInBitmapWordRange(bitmap,start,end);
  flipBitmapRange(bitmap,start,end);
  int cardafter=cardinalityInBitmapWordRange(bitmap,start,end);
  return cardafter - cardbefore;
}"
90220,"/** 
 * @deprecated use the version where longs specify the range
 */
@Deprecated public static MutableRoaringBitmap flip(ImmutableRoaringBitmap bm,final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    return flip(bm,(long)rangeStart,(long)rangeEnd);
  }
  return flip(bm,rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}","/** 
 * Complements the bits in the given range, from rangeStart (inclusive) rangeEnd (exclusive). The given bitmap is unchanged.
 * @param bm bitmap being negated
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 * @return a new Bitmap
 * @deprecated use the version where longs specify the range
 */
@Deprecated public static MutableRoaringBitmap flip(ImmutableRoaringBitmap bm,final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    return flip(bm,(long)rangeStart,(long)rangeEnd);
  }
  return flip(bm,rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}"
90221,"/** 
 * @deprecated use the version where longs specify the range. Negative range points are forbidden.
 */
@Deprecated public static MutableRoaringBitmap or(@SuppressWarnings(""String_Node_Str"") final Iterator bitmaps,final int rangeStart,final int rangeEnd){
  return or(bitmaps,(long)rangeStart,(long)rangeEnd);
}","/** 
 * Computes OR between input bitmaps in the given range, from rangeStart (inclusive) to rangeEnd (exclusive)
 * @param bitmaps input bitmaps, these are not modified
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 * @return new result bitmap
 * @deprecated use the version where longs specify the range. Negative range points are forbidden.
 */
@Deprecated public static MutableRoaringBitmap or(@SuppressWarnings(""String_Node_Str"") final Iterator bitmaps,final int rangeStart,final int rangeEnd){
  return or(bitmaps,(long)rangeStart,(long)rangeEnd);
}"
90222,"/** 
 * @deprecated use the version where longs specify the range
 */
@Deprecated public void remove(final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    remove((long)rangeStart,(long)rangeEnd);
  }
  remove(rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}","/** 
 * Remove from the current bitmap all integers in [rangeStart,rangeEnd).
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 * @deprecated use the version where longs specify the range
 */
@Deprecated public void remove(final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    remove((long)rangeStart,(long)rangeEnd);
  }
  remove(rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}"
90223,"/** 
 * @deprecated use the version where longs specify the range
 */
@Deprecated public void flip(final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    flip((long)rangeStart,(long)rangeEnd);
  }
  flip(rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}","/** 
 * Modifies the current bitmap by complementing the bits in the given range, from rangeStart (inclusive) rangeEnd (exclusive).
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 * @deprecated use the version where longs specify the range
 */
@Deprecated public void flip(final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    flip((long)rangeStart,(long)rangeEnd);
  }
  flip(rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}"
90224,"/** 
 * @deprecated use the version where longs specify the range
 */
@Deprecated public void add(final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    add((long)rangeStart,(long)rangeEnd);
  }
  add(rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}","/** 
 * Add to the current bitmap all integers in [rangeStart,rangeEnd).
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 * @deprecated use the version where longs specify the range
 */
@Deprecated public void add(final int rangeStart,final int rangeEnd){
  if (rangeStart >= 0) {
    add((long)rangeStart,(long)rangeEnd);
  }
  add(rangeStart & 0xFFFFFFFFL,rangeEnd & 0xFFFFFFFFL);
}"
90225,"/** 
 * Creates an instance that is ready for iteration.
 * @param r bitmap to be iterated over
 */
public ReverseIntIteratorFlyweight(RoaringBitmap r){
}","/** 
 * Creates an instance that is ready for iteration.
 * @param r bitmap to be iterated over
 */
public ReverseIntIteratorFlyweight(RoaringBitmap r){
  wrap(r);
}"
90226,"/** 
 * Creates an instance that is ready for iteration.
 * @param r bitmap to be iterated over
 */
public BufferReverseIntIteratorFlyweight(ImmutableRoaringBitmap r){
}","/** 
 * Creates an instance that is ready for iteration.
 * @param r bitmap to be iterated over
 */
public BufferReverseIntIteratorFlyweight(ImmutableRoaringBitmap r){
  wrap(r);
}"
90227,"private static int[] takeSortedAndDistinct(Random source,int count){
  LinkedHashSet<Integer> ints=new LinkedHashSet<Integer>(count);
  for (int size=0; size < count; size++) {
    int next;
    do {
      next=Math.abs(source.nextInt());
    }
 while (!ints.add(next));
  }
  int[] unboxed=Ints.toArray(ints);
  Arrays.sort(unboxed);
  return unboxed;
}","private static int[] takeSortedAndDistinct(Random source,int count){
  LinkedHashSet<Integer> ints=new LinkedHashSet<Integer>(count);
  for (int size=0; size < count; size++) {
    int next;
    do {
      next=Math.abs(source.nextInt());
    }
 while (!ints.add(next));
  }
  for (int k=1000; k < 10000; ++k) {
    if (!ints.contains(k))     ints.add(k);
  }
  int[] unboxed=Ints.toArray(ints);
  Arrays.sort(unboxed);
  return unboxed;
}"
90228,"@Test(expected=IllegalArgumentException.class) public void testPriorityQueueXor(){
  int[] array1={1232,3324,123,43243,1322,7897,8767};
  int[] array2={39173,39174,39175,39176,39177,39178,39179};
  int[] array3={1232,3324,123,43243,1322,7897,8767,39173,39174,39175,39176,39177,39178,39179};
  MutableRoaringBitmap data1=MutableRoaringBitmap.bitmapOf(array1);
  MutableRoaringBitmap data2=MutableRoaringBitmap.bitmapOf(array2);
  MutableRoaringBitmap data3=MutableRoaringBitmap.bitmapOf(array3);
  Assert.assertEquals(data3,BufferFastAggregation.priorityqueue_xor(data1,data2));
  BufferFastAggregation.priorityqueue_xor(data1);
}","@Test(expected=IllegalArgumentException.class) public void testPriorityQueueXor(){
  int[] array1={1232,3324,123,43243,1322,7897,8767};
  int[] array2={39173,39174,39175,39176,39177,39178,39179};
  int[] array3={1232,3324,123,43243,1322,7897,8767,39173,39174,39175,39176,39177,39178,39179};
  ImmutableRoaringBitmap data1=MutableRoaringBitmap.bitmapOf(array1);
  ImmutableRoaringBitmap data2=MutableRoaringBitmap.bitmapOf(array2);
  ImmutableRoaringBitmap data3=MutableRoaringBitmap.bitmapOf(array3);
  Assert.assertEquals(data3,BufferFastAggregation.priorityqueue_xor(data1,data2));
  BufferFastAggregation.priorityqueue_xor(data1);
}"
90229,"private static int[] takeSortedAndDistinct(Random source,int count){
  LinkedHashSet<Integer> ints=new LinkedHashSet<Integer>(count);
  for (int size=0; size < count; size++) {
    int next;
    do {
      next=Math.abs(source.nextInt());
    }
 while (!ints.add(next));
  }
  int[] unboxed=Ints.toArray(ints);
  Arrays.sort(unboxed);
  return unboxed;
}","private static int[] takeSortedAndDistinct(Random source,int count){
  LinkedHashSet<Integer> ints=new LinkedHashSet<Integer>(count);
  for (int size=0; size < count; size++) {
    int next;
    do {
      next=Math.abs(source.nextInt());
    }
 while (!ints.add(next));
  }
  for (int k=1000; k < 10000; ++k) {
    if (!ints.contains(k))     ints.add(k);
  }
  int[] unboxed=Ints.toArray(ints);
  Arrays.sort(unboxed);
  return unboxed;
}"
90230,"public static ImmutableRoaringBitmap toMapped(MutableRoaringBitmap r){
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(bos);
  try {
    r.serialize(dos);
    dos.close();
  }
 catch (  IOException e) {
    throw new RuntimeException(e.toString());
  }
  ByteBuffer bb=ByteBuffer.wrap(bos.toByteArray());
  return new ImmutableRoaringBitmap(bb);
}","private static ImmutableRoaringBitmap toMapped(MutableRoaringBitmap r){
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(bos);
  try {
    r.serialize(dos);
    dos.close();
  }
 catch (  IOException e) {
    throw new RuntimeException(e.toString());
  }
  ByteBuffer bb=ByteBuffer.wrap(bos.toByteArray());
  return new ImmutableRoaringBitmap(bb);
}"
90231,"/** 
 * Return the set values as an array, if the cardinality is smaller than 1<<31.  The integer values are in sorted order.
 * @return array representing the set values.
 */
@Override public int[] toArray(){
  final int[] array=new int[(int)this.getCardinality()];
  int pos=0, pos2=0;
  while (pos < this.highLowContainer.size()) {
    final int hs=this.highLowContainer.getKeyAtIndex(pos) << 16;
    Container c=this.highLowContainer.getContainerAtIndex(pos++);
    c.fillLeastSignificant16bits(array,pos2,hs);
    pos2+=c.getCardinality();
  }
  return array;
}","/** 
 * Return the set values as an array, if the cardinality is smaller than 2147483648.  The integer values are in sorted order.
 * @return array representing the set values.
 */
@Override public int[] toArray(){
  final int[] array=new int[(int)this.getCardinality()];
  int pos=0, pos2=0;
  while (pos < this.highLowContainer.size()) {
    final int hs=this.highLowContainer.getKeyAtIndex(pos) << 16;
    Container c=this.highLowContainer.getContainerAtIndex(pos++);
    c.fillLeastSignificant16bits(array,pos2,hs);
    pos2+=c.getCardinality();
  }
  return array;
}"
90232,"/** 
 * Return the set values as an array if the cardinality is less  than 1<<31. The integer values are in sorted order.
 * @return array representing the set values.
 */
@Override public int[] toArray(){
  final int[] array=new int[(int)this.getCardinality()];
  int pos=0, pos2=0;
  while (pos < this.highLowContainer.size()) {
    final int hs=BufferUtil.toIntUnsigned(this.highLowContainer.getKeyAtIndex(pos)) << 16;
    final MappeableContainer c=this.highLowContainer.getContainerAtIndex(pos++);
    c.fillLeastSignificant16bits(array,pos2,hs);
    pos2+=c.getCardinality();
  }
  return array;
}","/** 
 * Return the set values as an array if the cardinality is less  than 2147483648. The integer values are in sorted order.
 * @return array representing the set values.
 */
@Override public int[] toArray(){
  final int[] array=new int[(int)this.getCardinality()];
  int pos=0, pos2=0;
  while (pos < this.highLowContainer.size()) {
    final int hs=BufferUtil.toIntUnsigned(this.highLowContainer.getKeyAtIndex(pos)) << 16;
    final MappeableContainer c=this.highLowContainer.getContainerAtIndex(pos++);
    c.fillLeastSignificant16bits(array,pos2,hs);
    pos2+=c.getCardinality();
  }
  return array;
}"
90233,"@Override public Container not(final int firstOfRange,final int lastOfRange){
  return not(new BitmapContainer(),firstOfRange,lastOfRange);
}","@Override public Container not(final int firstOfRange,final int lastOfRange){
  BitmapContainer answer=clone();
  answer.cardinality+=Util.flipBitmapRangeAndCardinalityChange(answer.bitmap,firstOfRange,lastOfRange);
  if (answer.cardinality <= ArrayContainer.DEFAULT_MAX_SIZE)   return answer.toArrayContainer();
  return answer;
}"
90234,"@Override public Container inot(final int firstOfRange,final int lastOfRange){
  return not(this,firstOfRange,lastOfRange);
}","@Override public Container inot(final int firstOfRange,final int lastOfRange){
  cardinality+=Util.flipBitmapRangeAndCardinalityChange(bitmap,firstOfRange,lastOfRange);
  if (cardinality <= ArrayContainer.DEFAULT_MAX_SIZE)   return toArrayContainer();
  return this;
}"
90235,"/** 
 * Extracts the values in the specified range, rangeStart (inclusive) and rangeEnd (exclusive) while avoiding copies as much as possible.
 * @param rb input bitmap
 * @param rangeStart inclusive
 * @param rangeEnd exclusive
 * @return new bitmap
 */
static MutableRoaringBitmap selectRangeWithoutCopy(ImmutableRoaringBitmap rb,final int rangeStart,final int rangeEnd){
}","/** 
 * Extracts the values in the specified range, rangeStart (inclusive) and rangeEnd (exclusive) while avoiding copies as much as possible.
 * @param rb input bitmap
 * @param rangeStart inclusive
 * @param rangeEnd exclusive
 * @return new bitmap
 */
private static MutableRoaringBitmap selectRangeWithoutCopy(ImmutableRoaringBitmap rb,final int rangeStart,final int rangeEnd){
}"
90236,"/** 
 * Extracts the values in the specified range, rangeStart (inclusive) and rangeEnd (exclusive) while avoiding copies as much as possible.
 * @param rb input bitmap
 * @param rangeStart inclusive
 * @param rangeEnd exclusive
 * @return new bitmap
 */
private static MutableRoaringBitmap selectRangeWithoutCopy(ImmutableRoaringBitmap rb,final int rangeStart,final int rangeEnd){
}","/** 
 * Extracts the values in the specified range, rangeStart (inclusive) and rangeEnd (exclusive) while avoiding copies as much as possible.
 * @param rb input bitmap
 * @param rangeStart inclusive
 * @param rangeEnd exclusive
 * @return new bitmap
 */
static MutableRoaringBitmap selectRangeWithoutCopy(ImmutableRoaringBitmap rb,final int rangeStart,final int rangeEnd){
}"
90237,"@Override public int hashCode(){
  MappeableContainerPointer cp=this.getContainerPointer();
  int hashvalue=0;
  while (cp.hasContainer()) {
    int th=cp.key() * 0xF0F0F0 + cp.getContainer().hashCode();
    hashvalue=31 * hashvalue + th;
  }
  return hashvalue;
}","@Override public int hashCode(){
  MappeableContainerPointer cp=this.getContainerPointer();
  int hashvalue=0;
  while (cp.hasContainer()) {
    int th=cp.key() * 0xF0F0F0 + cp.getContainer().hashCode();
    hashvalue=31 * hashvalue + th;
    cp.advance();
  }
  return hashvalue;
}"
90238,"@Override public Container inot(int rangeStart,int rangeEnd){
  if (rangeEnd <= rangeStart)   return this;
  if (valueslength.length <= 2 * nbrruns) {
    boolean lastValueBeforeRange=false;
    boolean firstValueInRange=false;
    boolean lastValueInRange=false;
    boolean firstValuePastRange=false;
    if (rangeStart > 0)     lastValueBeforeRange=contains((short)(rangeStart - 1));
    firstValueInRange=contains((short)rangeStart);
    if (lastValueBeforeRange == firstValueInRange) {
      lastValueInRange=contains((short)(rangeEnd - 1));
      if (rangeEnd != 65536)       firstValuePastRange=contains((short)rangeEnd);
      if (lastValueInRange == firstValuePastRange) {
        return not(rangeStart,rangeEnd);
      }
    }
  }
  int myNbrRuns=nbrruns;
  RunContainer ans=this;
  int k=0;
  ans.nbrruns=0;
  for (; (k < myNbrRuns) && ((Util.toIntUnsigned(this.getValue(k)) < rangeStart)); ++k) {
    ans.nbrruns++;
  }
  short bufferedValue=0, bufferedLength=0;
  short nextValue=0, nextLength=0;
  if (k < myNbrRuns) {
    bufferedValue=getValue(k);
    bufferedLength=getLength(k);
  }
  ans.smartAppendExclusive((short)rangeStart,(short)(rangeEnd - rangeStart - 1));
  for (; k < myNbrRuns; ++k) {
    if (ans.nbrruns > k + 1)     throw new RuntimeException(""String_Node_Str"" + k + ""String_Node_Str""+ ans.nbrruns);
    if (k + 1 < myNbrRuns) {
      nextValue=getValue(k + 1);
      nextLength=getLength(k + 1);
    }
    ans.smartAppendExclusive(bufferedValue,bufferedLength);
    bufferedValue=nextValue;
    bufferedLength=nextLength;
  }
  return ans.toEfficientContainer();
}","@Override public Container inot(int rangeStart,int rangeEnd){
  if (rangeEnd <= rangeStart)   return this;
  if (valueslength.length <= 2 * nbrruns + 1) {
    boolean lastValueBeforeRange=false;
    boolean firstValueInRange=false;
    boolean lastValueInRange=false;
    boolean firstValuePastRange=false;
    if (rangeStart > 0)     lastValueBeforeRange=contains((short)(rangeStart - 1));
    firstValueInRange=contains((short)rangeStart);
    if (lastValueBeforeRange == firstValueInRange) {
      lastValueInRange=contains((short)(rangeEnd - 1));
      if (rangeEnd != 65536)       firstValuePastRange=contains((short)rangeEnd);
      if (lastValueInRange == firstValuePastRange) {
        return not(rangeStart,rangeEnd);
      }
    }
  }
  int myNbrRuns=nbrruns;
  RunContainer ans=this;
  int k=0;
  ans.nbrruns=0;
  for (; (k < myNbrRuns) && ((Util.toIntUnsigned(this.getValue(k)) < rangeStart)); ++k) {
    ans.nbrruns++;
  }
  short bufferedValue=0, bufferedLength=0;
  short nextValue=0, nextLength=0;
  if (k < myNbrRuns) {
    bufferedValue=getValue(k);
    bufferedLength=getLength(k);
  }
  ans.smartAppendExclusive((short)rangeStart,(short)(rangeEnd - rangeStart - 1));
  for (; k < myNbrRuns; ++k) {
    if (ans.nbrruns > k + 1)     throw new RuntimeException(""String_Node_Str"" + k + ""String_Node_Str""+ ans.nbrruns);
    if (k + 1 < myNbrRuns) {
      nextValue=getValue(k + 1);
      nextLength=getLength(k + 1);
    }
    ans.smartAppendExclusive(bufferedValue,bufferedLength);
    bufferedValue=nextValue;
    bufferedLength=nextLength;
  }
  return ans.toEfficientContainer();
}"
90239,"/** 
 * Computes the bitwise OR of this container with another (union). This container as well as the provided container are left unaffected. The resulting container may not track its cardinality correctly. This can be fixed as follows:   if(c.getCardinality()&lt;0) ((MappeableBitmapContainer)c).computeCardinality();
 * @param x other container
 * @return aggregated container
 */
public MappeableContainer lazyOR(MappeableContainer x){
  if (this instanceof MappeableArrayContainer) {
    if (x instanceof MappeableArrayContainer)     return or((MappeableArrayContainer)x);
 else     if (x instanceof MappeableBitmapContainer)     return ((MappeableBitmapContainer)x).lazyor((MappeableArrayContainer)this);
    return ((MappeableRunContainer)x).lazyor((MappeableArrayContainer)this);
  }
 else   if (this instanceof MappeableRunContainer) {
    if (x instanceof MappeableArrayContainer)     return ((MappeableRunContainer)this).ilazyor((MappeableArrayContainer)x);
 else     if (x instanceof MappeableBitmapContainer)     return ((MappeableBitmapContainer)x).lazyor((MappeableRunContainer)this);
    return or((MappeableRunContainer)x);
  }
 else {
    if (x instanceof MappeableArrayContainer)     return ((MappeableBitmapContainer)this).lazyor((MappeableArrayContainer)x);
 else     if (x instanceof MappeableBitmapContainer)     return ((MappeableBitmapContainer)this).lazyor((MappeableBitmapContainer)x);
    return ((MappeableBitmapContainer)this).lazyor((MappeableRunContainer)x);
  }
}","/** 
 * Computes the bitwise OR of this container with another (union). This container as well as the provided container are left unaffected. The resulting container may not track its cardinality correctly. This can be fixed as follows:   if(c.getCardinality()&lt;0) ((MappeableBitmapContainer)c).computeCardinality();
 * @param x other container
 * @return aggregated container
 */
public MappeableContainer lazyOR(MappeableContainer x){
  if (this instanceof MappeableArrayContainer) {
    if (x instanceof MappeableArrayContainer)     return or((MappeableArrayContainer)x);
 else     if (x instanceof MappeableBitmapContainer)     return ((MappeableBitmapContainer)x).lazyor((MappeableArrayContainer)this);
    return ((MappeableRunContainer)x).lazyor((MappeableArrayContainer)this);
  }
 else   if (this instanceof MappeableRunContainer) {
    if (x instanceof MappeableArrayContainer)     return ((MappeableRunContainer)this).lazyor((MappeableArrayContainer)x);
 else     if (x instanceof MappeableBitmapContainer)     return ((MappeableBitmapContainer)x).lazyor((MappeableRunContainer)this);
    return or((MappeableRunContainer)x);
  }
 else {
    if (x instanceof MappeableArrayContainer)     return ((MappeableBitmapContainer)this).lazyor((MappeableArrayContainer)x);
 else     if (x instanceof MappeableBitmapContainer)     return ((MappeableBitmapContainer)this).lazyor((MappeableBitmapContainer)x);
    return ((MappeableBitmapContainer)this).lazyor((MappeableRunContainer)x);
  }
}"
90240,"/** 
 * Computes the in-place bitwise OR of this container with another (union). The current container is generally modified, whereas the provided container (x) is unaffected. May generate a new container. The resulting container may not track its cardinality correctly. The resulting container may not track its cardinality correctly. This can be fixed as follows:   if(c.getCardinality()&lt;0) ((MappeableBitmapContainer)c).computeCardinality();
 * @param x other container
 * @return aggregated container
 */
public MappeableContainer lazyIOR(MappeableContainer x){
  if (this instanceof MappeableArrayContainer) {
    if (x instanceof MappeableArrayContainer)     return ior((MappeableArrayContainer)x);
 else     if (x instanceof MappeableBitmapContainer)     return ((MappeableBitmapContainer)x).lazyor((MappeableArrayContainer)this);
    return ((MappeableRunContainer)x).lazyor((MappeableArrayContainer)this);
  }
 else   if (this instanceof MappeableRunContainer) {
    if (x instanceof MappeableArrayContainer)     return ((MappeableRunContainer)this).lazyor((MappeableArrayContainer)x);
 else     if (x instanceof MappeableBitmapContainer)     return ((MappeableBitmapContainer)x).lazyor((MappeableRunContainer)this);
    return ior((MappeableRunContainer)x);
  }
 else {
    if (x instanceof MappeableArrayContainer)     return ((MappeableBitmapContainer)this).ilazyor((MappeableArrayContainer)x);
 else     if (x instanceof MappeableBitmapContainer)     return ((MappeableBitmapContainer)this).ilazyor((MappeableBitmapContainer)x);
    return ((MappeableBitmapContainer)this).ilazyor((MappeableRunContainer)x);
  }
}","/** 
 * Computes the in-place bitwise OR of this container with another (union). The current container is generally modified, whereas the provided container (x) is unaffected. May generate a new container. The resulting container may not track its cardinality correctly. The resulting container may not track its cardinality correctly. This can be fixed as follows:   if(c.getCardinality()&lt;0) ((MappeableBitmapContainer)c).computeCardinality();
 * @param x other container
 * @return aggregated container
 */
public MappeableContainer lazyIOR(MappeableContainer x){
  if (this instanceof MappeableArrayContainer) {
    if (x instanceof MappeableArrayContainer)     return ior((MappeableArrayContainer)x);
 else     if (x instanceof MappeableBitmapContainer)     return ((MappeableBitmapContainer)x).lazyor((MappeableArrayContainer)this);
    return ((MappeableRunContainer)x).lazyor((MappeableArrayContainer)this);
  }
 else   if (this instanceof MappeableRunContainer) {
    if (x instanceof MappeableArrayContainer)     return ((MappeableRunContainer)this).ilazyor((MappeableArrayContainer)x);
 else     if (x instanceof MappeableBitmapContainer)     return ((MappeableBitmapContainer)x).lazyor((MappeableRunContainer)this);
    return ior((MappeableRunContainer)x);
  }
 else {
    if (x instanceof MappeableArrayContainer)     return ((MappeableBitmapContainer)this).ilazyor((MappeableArrayContainer)x);
 else     if (x instanceof MappeableBitmapContainer)     return ((MappeableBitmapContainer)this).ilazyor((MappeableBitmapContainer)x);
    return ((MappeableBitmapContainer)this).ilazyor((MappeableRunContainer)x);
  }
}"
90241,"private Container ilazyorToRun(ArrayContainer x){
  if (isFull())   return this.clone();
  final int nbrruns=this.nbrruns;
  final int offset=Math.max(nbrruns,x.getCardinality());
  ensureCapacity(offset + nbrruns);
  copyValuesLength(this.valueslength,0,this.valueslength,offset,nbrruns);
  int rlepos=0;
  this.nbrruns=0;
  PeekableShortIterator i=(PeekableShortIterator)x.getShortIterator();
  while (i.hasNext() && (rlepos < nbrruns)) {
    if (Util.compareUnsigned(getValue(rlepos + offset),i.peekNext()) <= 0) {
      smartAppend(getValue(rlepos + offset),getLength(rlepos + offset));
      rlepos++;
    }
 else {
      smartAppend(i.next());
    }
  }
  if (i.hasNext()) {
    if (this.nbrruns > 0) {
      int lastval=Util.toIntUnsigned(getValue(nbrruns + offset)) + Util.toIntUnsigned(getLength(nbrruns + offset)) + 1;
      i.advanceIfNeeded((short)lastval);
    }
    while (i.hasNext()) {
      smartAppend(i.next());
    }
  }
 else {
    while (rlepos < nbrruns) {
      smartAppend(getValue(rlepos + offset),getLength(rlepos + offset));
      rlepos++;
    }
  }
  return convertToLazyBitmapIfNeeded();
}","private Container ilazyorToRun(ArrayContainer x){
  if (isFull())   return this.clone();
  final int nbrruns=this.nbrruns;
  final int offset=Math.max(nbrruns,x.getCardinality());
  ensureCapacity(offset + nbrruns);
  copyValuesLength(this.valueslength,0,this.valueslength,offset,nbrruns);
  int rlepos=0;
  this.nbrruns=0;
  PeekableShortIterator i=(PeekableShortIterator)x.getShortIterator();
  while (i.hasNext() && (rlepos < nbrruns)) {
    if (Util.compareUnsigned(getValue(rlepos + offset),i.peekNext()) <= 0) {
      smartAppend(getValue(rlepos + offset),getLength(rlepos + offset));
      rlepos++;
    }
 else {
      smartAppend(i.next());
    }
  }
  if (i.hasNext()) {
    if (this.nbrruns > 0) {
      int lastval=Util.toIntUnsigned(getValue(nbrruns + offset - 1)) + Util.toIntUnsigned(getLength(nbrruns + offset - 1)) + 1;
      i.advanceIfNeeded((short)lastval);
    }
    while (i.hasNext()) {
      smartAppend(i.next());
    }
  }
 else {
    while (rlepos < nbrruns) {
      smartAppend(getValue(rlepos + offset),getLength(rlepos + offset));
      rlepos++;
    }
  }
  return convertToLazyBitmapIfNeeded();
}"
90242,"private Container lazyorToRun(ArrayContainer x){
  if (isFull())   return this.clone();
  RunContainer answer=new RunContainer(0,new short[2 * (this.nbrruns + x.getCardinality())]);
  int rlepos=0;
  PeekableShortIterator i=(PeekableShortIterator)x.getShortIterator();
  while (i.hasNext() && (rlepos < this.nbrruns)) {
    if (Util.compareUnsigned(getValue(rlepos),i.peekNext()) <= 0) {
      answer.smartAppend(getValue(rlepos),getLength(rlepos));
      rlepos++;
    }
 else {
      answer.smartAppend(i.next());
    }
  }
  if (i.hasNext()) {
    if (answer.nbrruns > 0) {
      int lastval=Util.toIntUnsigned(answer.getValue(answer.nbrruns)) + Util.toIntUnsigned(answer.getLength(answer.nbrruns)) + 1;
      i.advanceIfNeeded((short)lastval);
    }
    while (i.hasNext()) {
      answer.smartAppend(i.next());
    }
  }
 else {
    while (rlepos < this.nbrruns) {
      answer.smartAppend(getValue(rlepos),getLength(rlepos));
      rlepos++;
    }
  }
  return answer.convertToLazyBitmapIfNeeded();
}","private Container lazyorToRun(ArrayContainer x){
  if (isFull())   return this.clone();
  RunContainer answer=new RunContainer(0,new short[2 * (this.nbrruns + x.getCardinality())]);
  int rlepos=0;
  PeekableShortIterator i=(PeekableShortIterator)x.getShortIterator();
  while (i.hasNext() && (rlepos < this.nbrruns)) {
    if (Util.compareUnsigned(getValue(rlepos),i.peekNext()) <= 0) {
      answer.smartAppend(getValue(rlepos),getLength(rlepos));
      rlepos++;
    }
 else {
      answer.smartAppend(i.next());
    }
  }
  if (i.hasNext()) {
    if (answer.nbrruns > 0) {
      int lastval=Util.toIntUnsigned(answer.getValue(answer.nbrruns - 1)) + Util.toIntUnsigned(answer.getLength(answer.nbrruns - 1)) + 1;
      i.advanceIfNeeded((short)lastval);
    }
    while (i.hasNext()) {
      answer.smartAppend(i.next());
    }
  }
 else {
    while (rlepos < this.nbrruns) {
      answer.smartAppend(getValue(rlepos),getLength(rlepos));
      rlepos++;
    }
  }
  return answer.convertToLazyBitmapIfNeeded();
}"
90243,"private MappeableContainer lazyorToRun(MappeableArrayContainer x){
  if (isFull())   return this.clone();
  MappeableRunContainer answer=new MappeableRunContainer(0,ShortBuffer.allocate(2 * (this.nbrruns + x.getCardinality())));
  short[] vl=answer.valueslength.array();
  int rlepos=0;
  PeekableShortIterator i=(PeekableShortIterator)x.getShortIterator();
  while ((rlepos < this.nbrruns) && i.hasNext()) {
    if (BufferUtil.compareUnsigned(getValue(rlepos),i.peekNext()) <= 0) {
      answer.smartAppend(vl,getValue(rlepos),getLength(rlepos));
      rlepos++;
    }
 else {
      answer.smartAppend(vl,i.next());
    }
  }
  if (i.hasNext()) {
    if (answer.nbrruns > 0) {
      int lastval=BufferUtil.toIntUnsigned(answer.getValue(answer.nbrruns)) + BufferUtil.toIntUnsigned(answer.getLength(answer.nbrruns)) + 1;
      i.advanceIfNeeded((short)lastval);
    }
    while (i.hasNext()) {
      answer.smartAppend(vl,i.next());
    }
  }
 else {
    while (rlepos < this.nbrruns) {
      answer.smartAppend(vl,getValue(rlepos),getLength(rlepos));
      rlepos++;
    }
  }
  return answer.convertToLazyBitmapIfNeeded();
}","private MappeableContainer lazyorToRun(MappeableArrayContainer x){
  if (isFull())   return this.clone();
  MappeableRunContainer answer=new MappeableRunContainer(0,ShortBuffer.allocate(2 * (this.nbrruns + x.getCardinality())));
  short[] vl=answer.valueslength.array();
  int rlepos=0;
  PeekableShortIterator i=(PeekableShortIterator)x.getShortIterator();
  while ((rlepos < this.nbrruns) && i.hasNext()) {
    if (BufferUtil.compareUnsigned(getValue(rlepos),i.peekNext()) <= 0) {
      answer.smartAppend(vl,getValue(rlepos),getLength(rlepos));
      rlepos++;
    }
 else {
      answer.smartAppend(vl,i.next());
    }
  }
  if (i.hasNext()) {
    if (answer.nbrruns > 0) {
      int lastval=BufferUtil.toIntUnsigned(answer.getValue(answer.nbrruns - 1)) + BufferUtil.toIntUnsigned(answer.getLength(answer.nbrruns - 1)) + 1;
      i.advanceIfNeeded((short)lastval);
    }
    while (i.hasNext()) {
      answer.smartAppend(vl,i.next());
    }
  }
 else {
    while (rlepos < this.nbrruns) {
      answer.smartAppend(vl,getValue(rlepos),getLength(rlepos));
      rlepos++;
    }
  }
  return answer.convertToLazyBitmapIfNeeded();
}"
90244,"@Setup public void setup() throws Exception {
  ZipRealDataRetriever dataRetriever=new ZipRealDataRetriever(dataset);
  System.out.println();
  System.out.println(""String_Node_Str"" + dataRetriever.getName());
  ArrayList<MutableRoaringBitmap> tmpac=new ArrayList<MutableRoaringBitmap>();
  ArrayList<MutableRoaringBitmap> tmprc=new ArrayList<MutableRoaringBitmap>();
  ArrayList<ConciseSet> tmpcc=new ArrayList<ConciseSet>();
  ArrayList<EWAHCompressedBitmap> tmpewah=new ArrayList<EWAHCompressedBitmap>();
  ArrayList<EWAHCompressedBitmap32> tmpewah32=new ArrayList<EWAHCompressedBitmap32>();
  for (  int[] data : dataRetriever.fetchBitPositions()) {
    MutableRoaringBitmap mbasic=MutableRoaringBitmap.bitmapOf(data);
    MutableRoaringBitmap mopti=mbasic.clone();
    mopti.runOptimize();
    if (!mopti.equals(mbasic))     throw new RuntimeException(""String_Node_Str"");
    ConciseSet concise=toConcise(data);
    tmpac.add(mbasic);
    tmprc.add(mopti);
    tmpcc.add(concise);
    tmpewah.add(EWAHCompressedBitmap.bitmapOf(data));
    tmpewah32.add(EWAHCompressedBitmap32.bitmapOf(data));
  }
  mrc=convertToImmutableRoaring(tmprc);
  mac=convertToImmutableRoaring(tmpac);
  cc=convertToImmutableConcise(tmpcc);
  ewah=convertToImmutableEWAH(tmpewah);
  ewah32=convertToImmutableEWAH32(tmpewah32);
  if ((mrc.size() != mac.size()) || (mac.size() != cc.size()))   throw new RuntimeException(""String_Node_Str"");
  expectedvalue=BufferFastAggregation.naive_or(limit(count,mrc.iterator())).getCardinality();
}","@Setup public void setup() throws Exception {
  ZipRealDataRetriever dataRetriever=new ZipRealDataRetriever(dataset);
  System.out.println();
  System.out.println(""String_Node_Str"" + dataRetriever.getName());
  ArrayList<MutableRoaringBitmap> tmpac=new ArrayList<MutableRoaringBitmap>();
  ArrayList<MutableRoaringBitmap> tmprc=new ArrayList<MutableRoaringBitmap>();
  ArrayList<ConciseSet> tmpcc=new ArrayList<ConciseSet>();
  ArrayList<EWAHCompressedBitmap> tmpewah=new ArrayList<EWAHCompressedBitmap>();
  ArrayList<EWAHCompressedBitmap32> tmpewah32=new ArrayList<EWAHCompressedBitmap32>();
  for (  int[] data : dataRetriever.fetchBitPositions()) {
    MutableRoaringBitmap mbasic=MutableRoaringBitmap.bitmapOf(data);
    MutableRoaringBitmap mopti=mbasic.clone();
    mopti.runOptimize();
    if (!mopti.equals(mbasic))     throw new RuntimeException(""String_Node_Str"");
    ConciseSet concise=toConcise(data);
    tmpac.add(mbasic);
    tmprc.add(mopti);
    tmpcc.add(concise);
    tmpewah.add(EWAHCompressedBitmap.bitmapOf(data));
    tmpewah32.add(EWAHCompressedBitmap32.bitmapOf(data));
  }
  System.out.println(""String_Node_Str"" + count + ""String_Node_Str""+ tmpac.size());
  mrc=convertToImmutableRoaring(tmprc);
  mac=convertToImmutableRoaring(tmpac);
  cc=convertToImmutableConcise(tmpcc);
  ewah=convertToImmutableEWAH(tmpewah);
  ewah32=convertToImmutableEWAH32(tmpewah32);
  if ((mrc.size() != mac.size()) || (mac.size() != cc.size()))   throw new RuntimeException(""String_Node_Str"");
  expectedvalue=BufferFastAggregation.naive_or(limit(count,mrc.iterator())).getCardinality();
}"
90245,"protected void lazyor(final RoaringBitmap x2){
  int pos1=0, pos2=0;
  int length1=highLowContainer.size();
  final int length2=x2.highLowContainer.size();
  main:   if (pos1 < length1 && pos2 < length2) {
    short s1=highLowContainer.getKeyAtIndex(pos1);
    short s2=x2.highLowContainer.getKeyAtIndex(pos2);
    while (true) {
      if (s1 == s2) {
        this.highLowContainer.setContainerAtIndex(pos1,highLowContainer.getContainerAtIndex(pos1).lazyIOR(x2.highLowContainer.getContainerAtIndex(pos2)));
        pos1++;
        pos2++;
        if ((pos1 == length1) || (pos2 == length2)) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
 else       if (Util.compareUnsigned(s1,s2) < 0) {
        pos1++;
        if (pos1 == length1) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
      }
 else {
        highLowContainer.insertNewKeyValueAt(pos1,s2,x2.highLowContainer.getContainerAtIndex(pos2));
        pos1++;
        length1++;
        pos2++;
        if (pos2 == length2) {
          break main;
        }
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
    }
  }
  if (pos1 == length1) {
    highLowContainer.appendCopy(x2.highLowContainer,pos2,length2);
  }
}","protected void lazyor(final RoaringBitmap x2){
  int pos1=0, pos2=0;
  int length1=highLowContainer.size();
  final int length2=x2.highLowContainer.size();
  main:   if (pos1 < length1 && pos2 < length2) {
    short s1=highLowContainer.getKeyAtIndex(pos1);
    short s2=x2.highLowContainer.getKeyAtIndex(pos2);
    while (true) {
      if (s1 == s2) {
        this.highLowContainer.setContainerAtIndex(pos1,highLowContainer.getContainerAtIndex(pos1).lazyIOR(x2.highLowContainer.getContainerAtIndex(pos2)));
        pos1++;
        pos2++;
        if ((pos1 == length1) || (pos2 == length2)) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
 else       if (Util.compareUnsigned(s1,s2) < 0) {
        pos1++;
        if (pos1 == length1) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
      }
 else {
        highLowContainer.insertNewKeyValueAt(pos1,s2,x2.highLowContainer.getContainerAtIndex(pos2).clone());
        pos1++;
        length1++;
        pos2++;
        if (pos2 == length2) {
          break main;
        }
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
    }
  }
  if (pos1 == length1) {
    highLowContainer.appendCopy(x2.highLowContainer,pos2,length2);
  }
}"
90246,"@Override public Container or(RunContainer x){
  if (isFull() || x.isFull())   return clone();
  RunContainer answer=new RunContainer(0,new short[2 * (this.nbrruns + x.nbrruns)]);
  int rlepos=0;
  int xrlepos=0;
  while ((xrlepos < x.nbrruns) && (rlepos < this.nbrruns)) {
    if (Util.compareUnsigned(getValue(rlepos),x.getValue(xrlepos)) < 0) {
      answer.smartAppend(getValue(rlepos),getLength(rlepos));
      rlepos++;
    }
 else {
      answer.smartAppend(x.getValue(xrlepos),x.getLength(xrlepos));
      xrlepos++;
    }
  }
  while (xrlepos < x.nbrruns) {
    answer.smartAppend(x.getValue(xrlepos),x.getLength(xrlepos));
    xrlepos++;
  }
  while (rlepos < this.nbrruns) {
    answer.smartAppend(getValue(rlepos),getLength(rlepos));
    rlepos++;
  }
  return answer;
}","@Override public Container or(RunContainer x){
  if (isFull())   return clone();
  if (x.isFull())   return x.clone();
  RunContainer answer=new RunContainer(0,new short[2 * (this.nbrruns + x.nbrruns)]);
  int rlepos=0;
  int xrlepos=0;
  while ((xrlepos < x.nbrruns) && (rlepos < this.nbrruns)) {
    if (Util.compareUnsigned(getValue(rlepos),x.getValue(xrlepos)) <= 0) {
      answer.smartAppend(getValue(rlepos),getLength(rlepos));
      rlepos++;
    }
 else {
      answer.smartAppend(x.getValue(xrlepos),x.getLength(xrlepos));
      xrlepos++;
    }
  }
  while (xrlepos < x.nbrruns) {
    answer.smartAppend(x.getValue(xrlepos),x.getLength(xrlepos));
    xrlepos++;
  }
  while (rlepos < this.nbrruns) {
    answer.smartAppend(getValue(rlepos),getLength(rlepos));
    rlepos++;
  }
  return answer;
}"
90247,"@Override public MappeableContainer or(MappeableRunContainer x){
  if (isFull() || x.isFull())   return clone();
  MappeableRunContainer answer=new MappeableRunContainer(0,ShortBuffer.allocate(2 * (this.nbrruns + x.nbrruns)));
  short[] vl=answer.valueslength.array();
  int rlepos=0;
  int xrlepos=0;
  while ((rlepos < this.nbrruns) && (xrlepos < x.nbrruns)) {
    if (BufferUtil.compareUnsigned(getValue(rlepos),x.getValue(xrlepos)) < 0) {
      answer.smartAppend(vl,getValue(rlepos),getLength(rlepos));
      rlepos++;
    }
 else {
      answer.smartAppend(vl,x.getValue(xrlepos),x.getLength(xrlepos));
      xrlepos++;
    }
  }
  while (xrlepos < x.nbrruns) {
    answer.smartAppend(vl,x.getValue(xrlepos),x.getLength(xrlepos));
    xrlepos++;
  }
  while (rlepos < this.nbrruns) {
    answer.smartAppend(vl,getValue(rlepos),getLength(rlepos));
    rlepos++;
  }
  return answer;
}","@Override public MappeableContainer or(MappeableRunContainer x){
  if (isFull())   return clone();
  if (x.isFull())   return x.clone();
  MappeableRunContainer answer=new MappeableRunContainer(0,ShortBuffer.allocate(2 * (this.nbrruns + x.nbrruns)));
  short[] vl=answer.valueslength.array();
  int rlepos=0;
  int xrlepos=0;
  while ((rlepos < this.nbrruns) && (xrlepos < x.nbrruns)) {
    if (BufferUtil.compareUnsigned(getValue(rlepos),x.getValue(xrlepos)) <= 0) {
      answer.smartAppend(vl,getValue(rlepos),getLength(rlepos));
      rlepos++;
    }
 else {
      answer.smartAppend(vl,x.getValue(xrlepos),x.getLength(xrlepos));
      xrlepos++;
    }
  }
  while (xrlepos < x.nbrruns) {
    answer.smartAppend(vl,x.getValue(xrlepos),x.getLength(xrlepos));
    xrlepos++;
  }
  while (rlepos < this.nbrruns) {
    answer.smartAppend(vl,getValue(rlepos),getLength(rlepos));
    rlepos++;
  }
  return answer;
}"
90248,"@Benchmark public int pairwiseAnd_EWAH(BenchmarkState benchmarkState){
  int total=0;
  for (int k=0; k + 1 < benchmarkState.ewah.size(); ++k)   total+=benchmarkState.ewah.get(k).and(benchmarkState.ewah.get(k + 1)).cardinality();
  return total;
}","@Benchmark public int pairwiseAnd_EWAH(BenchmarkState benchmarkState){
  int total=0;
  for (int k=0; k + 1 < benchmarkState.ewah.size(); ++k)   total+=benchmarkState.ewah.get(k).and(benchmarkState.ewah.get(k + 1)).cardinality();
  if (total != benchmarkState.expectedvalue)   throw new RuntimeException(""String_Node_Str"");
  return total;
}"
90249,"@Benchmark public int pairwiseAnd_EWAH32(BenchmarkState benchmarkState){
  int total=0;
  for (int k=0; k + 1 < benchmarkState.ewah32.size(); ++k)   total+=benchmarkState.ewah32.get(k).and(benchmarkState.ewah32.get(k + 1)).cardinality();
  return total;
}","@Benchmark public int pairwiseAnd_EWAH32(BenchmarkState benchmarkState){
  int total=0;
  for (int k=0; k + 1 < benchmarkState.ewah32.size(); ++k)   total+=benchmarkState.ewah32.get(k).and(benchmarkState.ewah32.get(k + 1)).cardinality();
  if (total != benchmarkState.expectedvalue)   throw new RuntimeException(""String_Node_Str"");
  return total;
}"
90250,"@Benchmark public int horizontalOr_EWAH32(BenchmarkState benchmarkState){
  EWAHCompressedBitmap32 bitmapor=benchmarkState.ewah32.get(0);
  for (int j=1; j < benchmarkState.ewah32.size(); ++j) {
    bitmapor=bitmapor.or(benchmarkState.ewah32.get(j));
  }
  int answer=bitmapor.cardinality();
  return answer;
}","@Benchmark public int horizontalOr_EWAH32(BenchmarkState benchmarkState){
  EWAHCompressedBitmap32[] a=new EWAHCompressedBitmap32[benchmarkState.ewah32.size()];
  EWAHCompressedBitmap32 bitmapor=EWAHCompressedBitmap32.or(benchmarkState.ewah32.toArray(a));
  int answer=bitmapor.cardinality();
  if (answer != benchmarkState.expectedvalue)   throw new RuntimeException(""String_Node_Str"");
  return answer;
}"
90251,"@Benchmark public int horizontalOr_EWAH(BenchmarkState benchmarkState){
  EWAHCompressedBitmap bitmapor=benchmarkState.ewah.get(0);
  for (int j=1; j < benchmarkState.ewah.size(); ++j) {
    bitmapor=bitmapor.or(benchmarkState.ewah.get(j));
  }
  int answer=bitmapor.cardinality();
  return answer;
}","@Benchmark public int horizontalOr_EWAH(BenchmarkState benchmarkState){
  EWAHCompressedBitmap[] a=new EWAHCompressedBitmap[benchmarkState.ewah.size()];
  EWAHCompressedBitmap bitmapor=EWAHCompressedBitmap.or(benchmarkState.ewah.toArray(a));
  int answer=bitmapor.cardinality();
  if (answer != benchmarkState.expectedvalue)   throw new RuntimeException(""String_Node_Str"");
  return answer;
}"
90252,"@Setup public void setup() throws Exception {
  ZipRealDataRetriever dataRetriever=new ZipRealDataRetriever(dataset);
  System.out.println();
  System.out.println(""String_Node_Str"" + dataRetriever.getName());
  ArrayList<MutableRoaringBitmap> tmpac=new ArrayList<MutableRoaringBitmap>();
  ArrayList<MutableRoaringBitmap> tmprc=new ArrayList<MutableRoaringBitmap>();
  ArrayList<ConciseSet> tmpcc=new ArrayList<ConciseSet>();
  ArrayList<EWAHCompressedBitmap> tmpewah=new ArrayList<EWAHCompressedBitmap>();
  ArrayList<EWAHCompressedBitmap32> tmpewah32=new ArrayList<EWAHCompressedBitmap32>();
  for (  int[] data : dataRetriever.fetchBitPositions()) {
    MutableRoaringBitmap mbasic=MutableRoaringBitmap.bitmapOf(data);
    MutableRoaringBitmap mopti=mbasic.clone();
    mopti.runOptimize();
    ConciseSet concise=toConcise(data);
    tmpac.add(mbasic);
    tmprc.add(mopti);
    tmpcc.add(concise);
    tmpewah.add(EWAHCompressedBitmap.bitmapOf(data));
    tmpewah32.add(EWAHCompressedBitmap32.bitmapOf(data));
  }
  mrc=convertToImmutableRoaring(tmprc);
  mac=convertToImmutableRoaring(tmpac);
  cc=convertToImmutableConcise(tmpcc);
  if ((mrc.size() != mac.size()) || (mac.size() != cc.size()))   throw new RuntimeException(""String_Node_Str"");
  expectedvalue=0;
  for (int k=0; k < mrc.size(); ++k) {
    ImmutableRoaringBitmap rb=mrc.get(k);
    org.roaringbitmap.IntIterator i=rb.getIntIterator();
    while (i.hasNext())     expectedvalue+=i.next();
  }
}","@Setup public void setup() throws Exception {
  ZipRealDataRetriever dataRetriever=new ZipRealDataRetriever(dataset);
  System.out.println();
  System.out.println(""String_Node_Str"" + dataRetriever.getName());
  ArrayList<MutableRoaringBitmap> tmpac=new ArrayList<MutableRoaringBitmap>();
  ArrayList<MutableRoaringBitmap> tmprc=new ArrayList<MutableRoaringBitmap>();
  ArrayList<ConciseSet> tmpcc=new ArrayList<ConciseSet>();
  ArrayList<EWAHCompressedBitmap> tmpewah=new ArrayList<EWAHCompressedBitmap>();
  ArrayList<EWAHCompressedBitmap32> tmpewah32=new ArrayList<EWAHCompressedBitmap32>();
  for (  int[] data : dataRetriever.fetchBitPositions()) {
    MutableRoaringBitmap mbasic=MutableRoaringBitmap.bitmapOf(data);
    MutableRoaringBitmap mopti=mbasic.clone();
    mopti.runOptimize();
    ConciseSet concise=toConcise(data);
    tmpac.add(mbasic);
    tmprc.add(mopti);
    tmpcc.add(concise);
    tmpewah.add(EWAHCompressedBitmap.bitmapOf(data));
    tmpewah32.add(EWAHCompressedBitmap32.bitmapOf(data));
  }
  mrc=convertToImmutableRoaring(tmprc);
  mac=convertToImmutableRoaring(tmpac);
  cc=convertToImmutableConcise(tmpcc);
  ewah=convertToImmutableEWAH(tmpewah);
  ewah32=convertToImmutableEWAH32(tmpewah32);
  if ((mrc.size() != mac.size()) || (mac.size() != cc.size()))   throw new RuntimeException(""String_Node_Str"");
  expectedvalue=0;
  for (int k=0; k < mrc.size(); ++k) {
    ImmutableRoaringBitmap rb=mrc.get(k);
    org.roaringbitmap.IntIterator i=rb.getIntIterator();
    while (i.hasNext())     expectedvalue+=i.next();
  }
}"
90253,"@Benchmark public int pairwiseOr_EWAH(BenchmarkState benchmarkState){
  int total=0;
  for (int k=0; k + 1 < benchmarkState.ewah.size(); ++k)   total+=benchmarkState.ewah.get(k).or(benchmarkState.ewah.get(k + 1)).cardinality();
  return total;
}","@Benchmark public int pairwiseOr_EWAH(BenchmarkState benchmarkState){
  int total=0;
  for (int k=0; k + 1 < benchmarkState.ewah.size(); ++k)   total+=benchmarkState.ewah.get(k).or(benchmarkState.ewah.get(k + 1)).cardinality();
  if (total != benchmarkState.expectedvalue)   throw new RuntimeException(""String_Node_Str"");
  return total;
}"
90254,"@Benchmark public int pairwiseOr_EWAH32(BenchmarkState benchmarkState){
  int total=0;
  for (int k=0; k + 1 < benchmarkState.ewah32.size(); ++k)   total+=benchmarkState.ewah32.get(k).or(benchmarkState.ewah32.get(k + 1)).cardinality();
  return total;
}","@Benchmark public int pairwiseOr_EWAH32(BenchmarkState benchmarkState){
  int total=0;
  for (int k=0; k + 1 < benchmarkState.ewah32.size(); ++k)   total+=benchmarkState.ewah32.get(k).or(benchmarkState.ewah32.get(k + 1)).cardinality();
  if (total != benchmarkState.expectedvalue)   throw new RuntimeException(""String_Node_Str"");
  return total;
}"
90255,"@Benchmark public int pairwiseAnd_EWAH(BenchmarkState benchmarkState){
  int total=0;
  for (int k=0; k + 1 < benchmarkState.ewah.size(); ++k)   total+=EWAHCompressedBitmap.and(benchmarkState.ewah.get(k),benchmarkState.ewah.get(k + 1)).cardinality();
  if (total != benchmarkState.totaland)   throw new RuntimeException(""String_Node_Str"");
  return total;
}","@Benchmark public int pairwiseAnd_EWAH(BenchmarkState benchmarkState){
  int total=0;
  for (int k=0; k + 1 < benchmarkState.ewah.size(); ++k)   total+=benchmarkState.ewah.get(k).and(benchmarkState.ewah.get(k + 1)).cardinality();
  if (total != benchmarkState.totaland)   throw new RuntimeException(""String_Node_Str"");
  return total;
}"
90256,"@Benchmark public int pairwiseAnd_EWAH32(BenchmarkState benchmarkState){
  int total=0;
  for (int k=0; k + 1 < benchmarkState.ewah32.size(); ++k)   total+=EWAHCompressedBitmap32.and(benchmarkState.ewah32.get(k),benchmarkState.ewah32.get(k + 1)).cardinality();
  if (total != benchmarkState.totaland)   throw new RuntimeException(""String_Node_Str"");
  return total;
}","@Benchmark public int pairwiseAnd_EWAH32(BenchmarkState benchmarkState){
  int total=0;
  for (int k=0; k + 1 < benchmarkState.ewah32.size(); ++k)   total+=benchmarkState.ewah32.get(k).and(benchmarkState.ewah32.get(k + 1)).cardinality();
  if (total != benchmarkState.totaland)   throw new RuntimeException(""String_Node_Str"");
  return total;
}"
90257,"@Setup public void setup() throws Exception {
  ZipRealDataRetriever dataRetriever=new ZipRealDataRetriever(dataset);
  System.out.println();
  System.out.println(""String_Node_Str"" + dataRetriever.getName());
  int normalsize=0;
  int runsize=0;
  int concisesize=0;
  int wahsize=0;
  int ewahsize=0;
  int ewahsize32=0;
  long stupidarraysize=0;
  long stupidbitmapsize=0;
  int totalcount=0;
  int numberofbitmaps=0;
  int universesize=0;
  for (  int[] data : dataRetriever.fetchBitPositions()) {
    numberofbitmaps++;
    if (universesize < data[data.length - 1])     universesize=data[data.length - 1];
    stupidarraysize+=8 + data.length * 4L;
    stupidbitmapsize+=8 + (data[data.length - 1] + 63L) / 64 * 8;
    totalcount+=data.length;
    EWAHCompressedBitmap ewahBitmap=EWAHCompressedBitmap.bitmapOf(data);
    ewahsize+=ewahBitmap.serializedSizeInBytes();
    ewah.add(ewahBitmap);
    EWAHCompressedBitmap32 ewahBitmap32=EWAHCompressedBitmap32.bitmapOf(data);
    ewahsize32+=ewahBitmap32.serializedSizeInBytes();
    ewah32.add(ewahBitmap32);
    RoaringBitmap basic=RoaringBitmap.bitmapOf(data);
    RoaringBitmap opti=basic.clone();
    opti.runOptimize();
    ConciseSet concise=toConcise(data);
    ConciseSet w=toWAH(data);
    wah.add(w);
    wahsize+=(int)(concise.size() * concise.collectionCompressionRatio()) * 4;
    rc.add(opti);
    ac.add(basic);
    cc.add(concise);
    normalsize+=basic.serializedSizeInBytes();
    runsize+=opti.serializedSizeInBytes();
    concisesize+=(int)(concise.size() * concise.collectionCompressionRatio()) * 4;
  }
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + dataset);
  System.out.println(""String_Node_Str"" + numberofbitmaps + ""String_Node_Str""+ totalcount+ ""String_Node_Str""+ universesize);
  System.out.println(""String_Node_Str"" + df.format(totalcount * 1.0 / numberofbitmaps));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + runsize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(runsize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(runsize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + normalsize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(normalsize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(normalsize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + concisesize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(concisesize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(concisesize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + wahsize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(wahsize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(wahsize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + ewahsize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(ewahsize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(ewahsize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + ewahsize32) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(ewahsize32 * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(ewahsize32 * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + stupidarraysize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(stupidarraysize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(stupidarraysize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + stupidbitmapsize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(stupidbitmapsize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(stupidbitmapsize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"");
  System.out.println();
  for (int k=0; k + 1 < rc.size(); ++k) {
    totalandnot+=RoaringBitmap.andNot(rc.get(k),rc.get(k + 1)).getCardinality();
  }
}","@Setup public void setup() throws Exception {
  ZipRealDataRetriever dataRetriever=new ZipRealDataRetriever(dataset);
  System.out.println();
  System.out.println(""String_Node_Str"" + dataRetriever.getName());
  int normalsize=0;
  int runsize=0;
  int concisesize=0;
  int wahsize=0;
  int ewahsize=0;
  int ewahsize32=0;
  long stupidarraysize=0;
  long stupidbitmapsize=0;
  int totalcount=0;
  int numberofbitmaps=0;
  int universesize=0;
  for (  int[] data : dataRetriever.fetchBitPositions()) {
    numberofbitmaps++;
    if (universesize < data[data.length - 1])     universesize=data[data.length - 1];
    stupidarraysize+=8 + data.length * 4L;
    stupidbitmapsize+=8 + (data[data.length - 1] + 63L) / 64 * 8;
    totalcount+=data.length;
    EWAHCompressedBitmap ewahBitmap=EWAHCompressedBitmap.bitmapOf(data);
    ewahsize+=ewahBitmap.serializedSizeInBytes();
    ewah.add(ewahBitmap);
    EWAHCompressedBitmap32 ewahBitmap32=EWAHCompressedBitmap32.bitmapOf(data);
    ewahsize32+=ewahBitmap32.serializedSizeInBytes();
    ewah32.add(ewahBitmap32);
    RoaringBitmap basic=RoaringBitmap.bitmapOf(data);
    RoaringBitmap opti=basic.clone();
    opti.runOptimize();
    ConciseSet concise=toConcise(data);
    ConciseSet w=toWAH(data);
    wah.add(w);
    wahsize+=(int)(concise.size() * concise.collectionCompressionRatio()) * 4;
    rc.add(opti);
    ac.add(basic);
    cc.add(concise);
    normalsize+=basic.serializedSizeInBytes();
    runsize+=opti.serializedSizeInBytes();
    concisesize+=(int)(concise.size() * concise.collectionCompressionRatio()) * 4;
  }
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + dataset);
  System.out.println(""String_Node_Str"" + numberofbitmaps + ""String_Node_Str""+ totalcount+ ""String_Node_Str""+ universesize);
  System.out.println(""String_Node_Str"" + df.format(totalcount * 1.0 / numberofbitmaps));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + runsize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(runsize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(runsize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + normalsize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(normalsize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(normalsize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + concisesize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(concisesize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(concisesize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + wahsize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(wahsize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(wahsize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + ewahsize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(ewahsize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(ewahsize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + ewahsize32) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(ewahsize32 * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(ewahsize32 * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + stupidarraysize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(stupidarraysize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(stupidarraysize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",""String_Node_Str"" + stupidbitmapsize) + ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(stupidbitmapsize * 1.0 / numberofbitmaps))+ ""String_Node_Str""+ String.format(""String_Node_Str"",df.format(stupidbitmapsize * 8.0 / totalcount)));
  System.out.println(""String_Node_Str"");
  System.out.println();
  totalandnot=0;
  for (int k=0; k + 1 < rc.size(); ++k) {
    int answer1=RoaringBitmap.andNot(rc.get(k),rc.get(k + 1)).getCardinality();
    int answer2=RoaringBitmap.andNot(ac.get(k),ac.get(k + 1)).getCardinality();
    int answer3=cc.get(k).difference(cc.get(k + 1)).size();
    int answer4=wah.get(k).difference(wah.get(k + 1)).size();
    int answer5=ewah.get(k).andNot(ewah.get(k + 1)).cardinality();
    int answer6=ewah32.get(k).andNot(ewah32.get(k + 1)).cardinality();
    if ((answer1 != answer2) || (answer2 != answer3) || (answer3 != answer4)|| (answer4 != answer5)|| (answer5 != answer6)) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + answer1);
      System.out.println(""String_Node_Str"" + answer2);
      System.out.println(""String_Node_Str"" + answer3);
      System.out.println(""String_Node_Str"" + answer4);
      System.out.println(""String_Node_Str"" + answer5);
      System.out.println(""String_Node_Str"" + answer6);
      throw new RuntimeException(""String_Node_Str"");
    }
    totalandnot+=RoaringBitmap.andNot(rc.get(k),rc.get(k + 1)).getCardinality();
  }
}"
90258,"@Benchmark public int horizontalOr_EWAH32(BenchmarkState benchmarkState){
  EWAHCompressedBitmap32 bitmapor=benchmarkState.ewah32.get(0);
  for (int j=1; j < benchmarkState.ewah32.size(); ++j) {
    bitmapor=bitmapor.or(benchmarkState.ewah32.get(j));
  }
  int answer=bitmapor.cardinality();
  if (answer != benchmarkState.horizontalor)   throw new RuntimeException(""String_Node_Str"");
  return answer;
}","@Benchmark public int horizontalOr_EWAH32(BenchmarkState benchmarkState){
  EWAHCompressedBitmap32[] a=new EWAHCompressedBitmap32[benchmarkState.ewah32.size()];
  EWAHCompressedBitmap32 bitmapor=EWAHCompressedBitmap32.or(benchmarkState.ewah32.toArray(a));
  int answer=bitmapor.cardinality();
  if (answer != benchmarkState.horizontalor)   throw new RuntimeException(""String_Node_Str"");
  return answer;
}"
90259,"private void smartAppendExclusive(short start,short length){
  int oldend;
  if ((nbrruns == 0) || (Util.toIntUnsigned(start) > (oldend=Util.toIntUnsigned(getValue(nbrruns - 1)) + Util.toIntUnsigned(getLength(nbrruns - 1)) + 1))) {
    valueslength[2 * nbrruns]=start;
    valueslength[2 * nbrruns + 1]=length;
    nbrruns++;
    return;
  }
  int newend=Util.toIntUnsigned(start) + Util.toIntUnsigned(length) + 1;
  if (Util.toIntUnsigned(start) == Util.toIntUnsigned(getValue(nbrruns - 1))) {
    if (newend != oldend) {
      int m=Math.min(newend,oldend);
      int M=Math.max(newend,oldend);
      setValue(nbrruns - 1,(short)m);
      setLength(nbrruns - 1,(short)(M - m - 1));
      return;
    }
 else {
      nbrruns--;
      return;
    }
  }
  setLength(nbrruns - 1,(short)(start - Util.toIntUnsigned(getValue(nbrruns - 1)) - 1));
  if (newend != oldend) {
    int m=Math.min(newend,oldend);
    int M=Math.max(newend,oldend);
    setValue(nbrruns,(short)m);
    setLength(nbrruns,(short)(M - m - 1));
    nbrruns++;
  }
}","private void smartAppendExclusive(short start,short length){
  int oldend;
  if ((nbrruns == 0) || (Util.toIntUnsigned(start) > (oldend=Util.toIntUnsigned(getValue(nbrruns - 1)) + Util.toIntUnsigned(getLength(nbrruns - 1)) + 1))) {
    valueslength[2 * nbrruns]=start;
    valueslength[2 * nbrruns + 1]=length;
    nbrruns++;
    return;
  }
  if (oldend == Util.toIntUnsigned(start)) {
    valueslength[2 * (nbrruns - 1) + 1]+=length + 1;
    return;
  }
  int newend=Util.toIntUnsigned(start) + Util.toIntUnsigned(length) + 1;
  if (Util.toIntUnsigned(start) == Util.toIntUnsigned(getValue(nbrruns - 1))) {
    if (newend != oldend) {
      int m=Math.min(newend,oldend);
      int M=Math.max(newend,oldend);
      setValue(nbrruns - 1,(short)m);
      setLength(nbrruns - 1,(short)(M - m - 1));
      return;
    }
 else {
      nbrruns--;
      return;
    }
  }
  setLength(nbrruns - 1,(short)(start - Util.toIntUnsigned(getValue(nbrruns - 1)) - 1));
  if (newend != oldend) {
    int m=Math.min(newend,oldend);
    int M=Math.max(newend,oldend);
    setValue(nbrruns,(short)m);
    setLength(nbrruns,(short)(M - m - 1));
    nbrruns++;
  }
}"
90260,"private void smartAppendExclusive(short[] vl,short val){
  int oldend;
  if ((nbrruns == 0) || (BufferUtil.toIntUnsigned(val) > (oldend=BufferUtil.toIntUnsigned(getValue(nbrruns - 1)) + BufferUtil.toIntUnsigned(getLength(nbrruns - 1)) + 1))) {
    vl[2 * nbrruns]=val;
    vl[2 * nbrruns + 1]=0;
    nbrruns++;
    return;
  }
  int newend=BufferUtil.toIntUnsigned(val) + 1;
  if (BufferUtil.toIntUnsigned(val) == BufferUtil.toIntUnsigned(getValue(nbrruns - 1))) {
    if (newend != oldend) {
      setValue(nbrruns - 1,(short)newend);
      setLength(nbrruns - 1,(short)(oldend - newend - 1));
      return;
    }
 else {
      nbrruns--;
      return;
    }
  }
  setLength(nbrruns - 1,(short)(val - BufferUtil.toIntUnsigned(getValue(nbrruns - 1)) - 1));
  if (newend != oldend) {
    setValue(nbrruns,(short)newend);
    setLength(nbrruns,(short)(oldend - newend - 1));
    nbrruns++;
  }
}","private void smartAppendExclusive(short[] vl,short val){
  int oldend;
  if ((nbrruns == 0) || (BufferUtil.toIntUnsigned(val) > (oldend=BufferUtil.toIntUnsigned(getValue(nbrruns - 1)) + BufferUtil.toIntUnsigned(getLength(nbrruns - 1)) + 1))) {
    vl[2 * nbrruns]=val;
    vl[2 * nbrruns + 1]=0;
    nbrruns++;
    return;
  }
  if (oldend == BufferUtil.toIntUnsigned(val)) {
    vl[2 * (nbrruns - 1) + 1]++;
    return;
  }
  int newend=BufferUtil.toIntUnsigned(val) + 1;
  if (BufferUtil.toIntUnsigned(val) == BufferUtil.toIntUnsigned(getValue(nbrruns - 1))) {
    if (newend != oldend) {
      setValue(nbrruns - 1,(short)newend);
      setLength(nbrruns - 1,(short)(oldend - newend - 1));
      return;
    }
 else {
      nbrruns--;
      return;
    }
  }
  setLength(nbrruns - 1,(short)(val - BufferUtil.toIntUnsigned(getValue(nbrruns - 1)) - 1));
  if (newend < oldend) {
    setValue(nbrruns,(short)newend);
    setLength(nbrruns,(short)(oldend - newend - 1));
    nbrruns++;
  }
 else   if (oldend < newend) {
    setValue(nbrruns,(short)oldend);
    setLength(nbrruns,(short)(newend - oldend - 1));
    nbrruns++;
  }
}"
90261,"/** 
 * Sort the bitmap prior to using the and aggregate.
 * @param bitmaps input bitmaps
 * @return aggregated bitmap
 */
public static RoaringBitmap and(Iterator<RoaringBitmap> bitmaps){
  if (!bitmaps.hasNext())   return new RoaringBitmap();
  ArrayList<RoaringBitmap> array=new ArrayList<RoaringBitmap>();
  while (bitmaps.hasNext())   array.add(bitmaps.next());
  Collections.sort(array,new Comparator<RoaringBitmap>(){
    @Override public int compare(    RoaringBitmap a,    RoaringBitmap b){
      return a.getSizeInBytes() - b.getSizeInBytes();
    }
  }
);
  RoaringBitmap answer=RoaringBitmap.and(array.get(0),array.get(1));
  for (int k=2; k < array.size(); ++k)   answer.and(array.get(k));
  return answer;
}","/** 
 * Sort the bitmap prior to using the and aggregate.
 * @param bitmaps input bitmaps
 * @return aggregated bitmap
 */
public static RoaringBitmap and(Iterator<RoaringBitmap> bitmaps){
  if (!bitmaps.hasNext())   return new RoaringBitmap();
  ArrayList<RoaringBitmap> array=new ArrayList<RoaringBitmap>();
  while (bitmaps.hasNext())   array.add(bitmaps.next());
  if (array.size() == 1)   return array.get(0);
  Collections.sort(array,new Comparator<RoaringBitmap>(){
    @Override public int compare(    RoaringBitmap a,    RoaringBitmap b){
      return a.getSizeInBytes() - b.getSizeInBytes();
    }
  }
);
  RoaringBitmap answer=RoaringBitmap.and(array.get(0),array.get(1));
  for (int k=2; k < array.size(); ++k)   answer.and(array.get(k));
  return answer;
}"
90262,"/** 
 * Generate a new bitmap with  all integers in [rangeStart,rangeEnd) added.
 * @param rb initial bitmap (will not be modified)
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd   exclusive ending of range
 */
public static RoaringBitmap add(RoaringBitmap rb,final int rangeStart,final int rangeEnd){
  if (rangeStart >= rangeEnd)   return rb.clone();
  final int hbStart=Util.toIntUnsigned(Util.highbits(rangeStart));
  final int lbStart=Util.toIntUnsigned(Util.lowbits(rangeStart));
  final int hbLast=Util.toIntUnsigned(Util.highbits(rangeEnd - 1));
  final int lbLast=Util.toIntUnsigned(Util.lowbits(rangeEnd - 1));
  RoaringBitmap answer=new RoaringBitmap();
  answer.highLowContainer.appendCopiesUntil(rb.highLowContainer,(short)hbStart);
  if (hbStart == hbLast) {
    final int i=rb.highLowContainer.getIndex((short)hbStart);
    final Container c=i >= 0 ? rb.highLowContainer.getContainerAtIndex(i).add(lbStart,lbLast + 1) : Container.rangeOfOnes(lbStart,lbLast + 1);
    answer.highLowContainer.append((short)hbStart,c);
    answer.highLowContainer.appendCopiesAfter(rb.highLowContainer,(short)hbLast);
    return answer;
  }
  int ifirst=rb.highLowContainer.getIndex((short)hbStart);
  int ilast=rb.highLowContainer.getIndex((short)hbLast);
{
    final Container c=ifirst >= 0 ? rb.highLowContainer.getContainerAtIndex(ifirst).add(lbStart,Util.maxLowBitAsInteger() + 1) : Container.rangeOfOnes(lbStart,Util.maxLowBitAsInteger() + 1);
    answer.highLowContainer.append((short)hbStart,c);
  }
  for (int hb=hbStart + 1; hb < hbLast; ++hb) {
    Container c=Container.rangeOfOnes(0,Util.maxLowBitAsInteger() + 1);
    answer.highLowContainer.append((short)hb,c);
  }
{
    final Container c=ilast >= 0 ? rb.highLowContainer.getContainerAtIndex(ilast).add(0,lbLast + 1) : Container.rangeOfOnes(0,lbLast + 1);
    answer.highLowContainer.append((short)hbLast,c);
  }
  answer.highLowContainer.appendCopiesAfter(rb.highLowContainer,(short)hbLast);
  return answer;
}","/** 
 * Generate a new bitmap with  all integers in [rangeStart,rangeEnd) added.
 * @param rb initial bitmap (will not be modified)
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd   exclusive ending of range
 * @return the bitmap
 */
public static RoaringBitmap add(RoaringBitmap rb,final int rangeStart,final int rangeEnd){
  if (rangeStart >= rangeEnd)   return rb.clone();
  final int hbStart=Util.toIntUnsigned(Util.highbits(rangeStart));
  final int lbStart=Util.toIntUnsigned(Util.lowbits(rangeStart));
  final int hbLast=Util.toIntUnsigned(Util.highbits(rangeEnd - 1));
  final int lbLast=Util.toIntUnsigned(Util.lowbits(rangeEnd - 1));
  RoaringBitmap answer=new RoaringBitmap();
  answer.highLowContainer.appendCopiesUntil(rb.highLowContainer,(short)hbStart);
  if (hbStart == hbLast) {
    final int i=rb.highLowContainer.getIndex((short)hbStart);
    final Container c=i >= 0 ? rb.highLowContainer.getContainerAtIndex(i).add(lbStart,lbLast + 1) : Container.rangeOfOnes(lbStart,lbLast + 1);
    answer.highLowContainer.append((short)hbStart,c);
    answer.highLowContainer.appendCopiesAfter(rb.highLowContainer,(short)hbLast);
    return answer;
  }
  int ifirst=rb.highLowContainer.getIndex((short)hbStart);
  int ilast=rb.highLowContainer.getIndex((short)hbLast);
{
    final Container c=ifirst >= 0 ? rb.highLowContainer.getContainerAtIndex(ifirst).add(lbStart,Util.maxLowBitAsInteger() + 1) : Container.rangeOfOnes(lbStart,Util.maxLowBitAsInteger() + 1);
    answer.highLowContainer.append((short)hbStart,c);
  }
  for (int hb=hbStart + 1; hb < hbLast; ++hb) {
    Container c=Container.rangeOfOnes(0,Util.maxLowBitAsInteger() + 1);
    answer.highLowContainer.append((short)hb,c);
  }
{
    final Container c=ilast >= 0 ? rb.highLowContainer.getContainerAtIndex(ilast).add(0,lbLast + 1) : Container.rangeOfOnes(0,lbLast + 1);
    answer.highLowContainer.append((short)hbLast,c);
  }
  answer.highLowContainer.appendCopiesAfter(rb.highLowContainer,(short)hbLast);
  return answer;
}"
90263,"/** 
 * Look value value k in array in the range [begin,end). If the value is found, return its index. If not, return -(i+1) where i is the index where the value would be inserted.  The array is assumed to contain sorted values where shorts are interpreted as unsigned integers.
 * @param array array where we search
 * @param begin first index (inclusive)
 * @param end last index (exclusive)
 * @param k value we search for
 * @return
 */
public static int unsignedBinarySearch(final short[] array,final int begin,final int end,final short k){
  int ikey=toIntUnsigned(k);
  if ((end > 0) && (toIntUnsigned(array[end - 1]) < ikey))   return -end - 1;
  int low=begin;
  int high=end - 1;
  while (low <= high) {
    final int middleIndex=(low + high) >>> 1;
    final int middleValue=toIntUnsigned(array[middleIndex]);
    if (middleValue < ikey)     low=middleIndex + 1;
 else     if (middleValue > ikey)     high=middleIndex - 1;
 else     return middleIndex;
  }
  return -(low + 1);
}","/** 
 * Look value value k in array in the range [begin,end). If the value is found, return its index. If not, return -(i+1) where i is the index where the value would be inserted.  The array is assumed to contain sorted values where shorts are interpreted as unsigned integers.
 * @param array array where we search
 * @param begin first index (inclusive)
 * @param end last index (exclusive)
 * @param k value we search for
 * @return count
 */
public static int unsignedBinarySearch(final short[] array,final int begin,final int end,final short k){
  int ikey=toIntUnsigned(k);
  if ((end > 0) && (toIntUnsigned(array[end - 1]) < ikey))   return -end - 1;
  int low=begin;
  int high=end - 1;
  while (low <= high) {
    final int middleIndex=(low + high) >>> 1;
    final int middleValue=toIntUnsigned(array[middleIndex]);
    if (middleValue < ikey)     low=middleIndex + 1;
 else     if (middleValue > ikey)     high=middleIndex - 1;
 else     return middleIndex;
  }
  return -(low + 1);
}"
90264,"/** 
 * Generate a new bitmap with  all integers in [rangeStart,rangeEnd) added.
 * @param rb initial bitmap (will not be modified)
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd   exclusive ending of range
 */
public static MutableRoaringBitmap add(MutableRoaringBitmap rb,final int rangeStart,final int rangeEnd){
  if (rangeStart >= rangeEnd)   return rb.clone();
  final int hbStart=BufferUtil.toIntUnsigned(BufferUtil.highbits(rangeStart));
  final int lbStart=BufferUtil.toIntUnsigned(BufferUtil.lowbits(rangeStart));
  final int hbLast=BufferUtil.toIntUnsigned(BufferUtil.highbits(rangeEnd - 1));
  final int lbLast=BufferUtil.toIntUnsigned(BufferUtil.lowbits(rangeEnd - 1));
  MutableRoaringBitmap answer=new MutableRoaringBitmap();
  ((MutableRoaringArray)answer.highLowContainer).appendCopiesUntil(rb.highLowContainer,(short)hbStart);
  if (hbStart == hbLast) {
    final int i=rb.highLowContainer.getIndex((short)hbStart);
    final MappeableContainer c=i >= 0 ? rb.highLowContainer.getContainerAtIndex(i).add(lbStart,lbLast + 1) : MappeableContainer.rangeOfOnes(lbStart,lbLast + 1);
    ((MutableRoaringArray)answer.highLowContainer).append((short)hbStart,c);
    ((MutableRoaringArray)answer.highLowContainer).appendCopiesAfter(rb.highLowContainer,(short)hbLast);
    return answer;
  }
  int ifirst=rb.highLowContainer.getIndex((short)hbStart);
  int ilast=rb.highLowContainer.getIndex((short)hbLast);
{
    final MappeableContainer c=ifirst >= 0 ? rb.highLowContainer.getContainerAtIndex(ifirst).add(lbStart,BufferUtil.maxLowBitAsInteger() + 1) : MappeableContainer.rangeOfOnes(lbStart,BufferUtil.maxLowBitAsInteger() + 1);
    ((MutableRoaringArray)answer.highLowContainer).append((short)hbStart,c);
  }
  for (int hb=hbStart + 1; hb < hbLast; ++hb) {
    MappeableContainer c=MappeableContainer.rangeOfOnes(0,BufferUtil.maxLowBitAsInteger() + 1);
    ((MutableRoaringArray)answer.highLowContainer).append((short)hb,c);
  }
{
    final MappeableContainer c=ilast >= 0 ? rb.highLowContainer.getContainerAtIndex(ilast).add(0,lbLast + 1) : MappeableContainer.rangeOfOnes(0,lbLast + 1);
    ((MutableRoaringArray)answer.highLowContainer).append((short)hbLast,c);
  }
  ((MutableRoaringArray)answer.highLowContainer).appendCopiesAfter(rb.highLowContainer,(short)hbLast);
  return answer;
}","/** 
 * Generate a new bitmap with  all integers in [rangeStart,rangeEnd) added.
 * @param rb initial bitmap (will not be modified)
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd   exclusive ending of range
 * @return the bitmap
 */
public static MutableRoaringBitmap add(MutableRoaringBitmap rb,final int rangeStart,final int rangeEnd){
  if (rangeStart >= rangeEnd)   return rb.clone();
  final int hbStart=BufferUtil.toIntUnsigned(BufferUtil.highbits(rangeStart));
  final int lbStart=BufferUtil.toIntUnsigned(BufferUtil.lowbits(rangeStart));
  final int hbLast=BufferUtil.toIntUnsigned(BufferUtil.highbits(rangeEnd - 1));
  final int lbLast=BufferUtil.toIntUnsigned(BufferUtil.lowbits(rangeEnd - 1));
  MutableRoaringBitmap answer=new MutableRoaringBitmap();
  ((MutableRoaringArray)answer.highLowContainer).appendCopiesUntil(rb.highLowContainer,(short)hbStart);
  if (hbStart == hbLast) {
    final int i=rb.highLowContainer.getIndex((short)hbStart);
    final MappeableContainer c=i >= 0 ? rb.highLowContainer.getContainerAtIndex(i).add(lbStart,lbLast + 1) : MappeableContainer.rangeOfOnes(lbStart,lbLast + 1);
    ((MutableRoaringArray)answer.highLowContainer).append((short)hbStart,c);
    ((MutableRoaringArray)answer.highLowContainer).appendCopiesAfter(rb.highLowContainer,(short)hbLast);
    return answer;
  }
  int ifirst=rb.highLowContainer.getIndex((short)hbStart);
  int ilast=rb.highLowContainer.getIndex((short)hbLast);
{
    final MappeableContainer c=ifirst >= 0 ? rb.highLowContainer.getContainerAtIndex(ifirst).add(lbStart,BufferUtil.maxLowBitAsInteger() + 1) : MappeableContainer.rangeOfOnes(lbStart,BufferUtil.maxLowBitAsInteger() + 1);
    ((MutableRoaringArray)answer.highLowContainer).append((short)hbStart,c);
  }
  for (int hb=hbStart + 1; hb < hbLast; ++hb) {
    MappeableContainer c=MappeableContainer.rangeOfOnes(0,BufferUtil.maxLowBitAsInteger() + 1);
    ((MutableRoaringArray)answer.highLowContainer).append((short)hb,c);
  }
{
    final MappeableContainer c=ilast >= 0 ? rb.highLowContainer.getContainerAtIndex(ilast).add(0,lbLast + 1) : MappeableContainer.rangeOfOnes(0,lbLast + 1);
    ((MutableRoaringArray)answer.highLowContainer).append((short)hbLast,c);
  }
  ((MutableRoaringArray)answer.highLowContainer).appendCopiesAfter(rb.highLowContainer,(short)hbLast);
  return answer;
}"
90265,"/** 
 * In-place bitwise OR (union) operation. The current bitmap is modified.
 * @param x2 other bitmap
 */
public void or(final ImmutableRoaringBitmap x2){
  int pos1=0, pos2=0;
  int length1=highLowContainer.size();
  final int length2=x2.highLowContainer.size();
  main:   if (pos1 < length1 && pos2 < length2) {
    short s1=highLowContainer.getKeyAtIndex(pos1);
    short s2=x2.highLowContainer.getKeyAtIndex(pos2);
    while (true) {
      if (s1 == s2) {
        getMappeableRoaringArray().setContainerAtIndex(pos1,highLowContainer.getContainerAtIndex(pos1).ior(x2.highLowContainer.getContainerAtIndex(pos2)));
        pos1++;
        pos2++;
        if ((pos1 == length1) || (pos2 == length2)) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
 else       if (Util.compareUnsigned(s1,s2) < 0) {
        pos1++;
        if (pos1 == length1) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
      }
 else {
        getMappeableRoaringArray().insertNewKeyValueAt(pos1,(short)s2,x2.highLowContainer.getContainerAtIndex(pos2));
        pos1++;
        length1++;
        pos2++;
        if (pos2 == length2) {
          break main;
        }
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
    }
  }
  if (pos1 == length1) {
    getMappeableRoaringArray().appendCopy(x2.highLowContainer,pos2,length2);
  }
}","/** 
 * In-place bitwise OR (union) operation. The current bitmap is modified.
 * @param x2 other bitmap
 */
public void or(final ImmutableRoaringBitmap x2){
  int pos1=0, pos2=0;
  int length1=highLowContainer.size();
  final int length2=x2.highLowContainer.size();
  main:   if (pos1 < length1 && pos2 < length2) {
    short s1=highLowContainer.getKeyAtIndex(pos1);
    short s2=x2.highLowContainer.getKeyAtIndex(pos2);
    while (true) {
      if (s1 == s2) {
        getMappeableRoaringArray().setContainerAtIndex(pos1,highLowContainer.getContainerAtIndex(pos1).ior(x2.highLowContainer.getContainerAtIndex(pos2)));
        pos1++;
        pos2++;
        if ((pos1 == length1) || (pos2 == length2)) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
 else       if (Util.compareUnsigned(s1,s2) < 0) {
        pos1++;
        if (pos1 == length1) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
      }
 else {
        getMappeableRoaringArray().insertNewKeyValueAt(pos1,(short)s2,x2.highLowContainer.getContainerAtIndex(pos2).clone());
        pos1++;
        length1++;
        pos2++;
        if (pos2 == length2) {
          break main;
        }
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
    }
  }
  if (pos1 == length1) {
    getMappeableRoaringArray().appendCopy(x2.highLowContainer,pos2,length2);
  }
}"
90266,"/** 
 * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.
 * @param x2 other bitmap
 */
public void xor(final ImmutableRoaringBitmap x2){
  int pos1=0, pos2=0;
  int length1=highLowContainer.size();
  final int length2=x2.highLowContainer.size();
  main:   if (pos1 < length1 && pos2 < length2) {
    short s1=highLowContainer.getKeyAtIndex(pos1);
    short s2=x2.highLowContainer.getKeyAtIndex(pos2);
    while (true) {
      if (s1 == s2) {
        final MappeableContainer c=highLowContainer.getContainerAtIndex(pos1).ixor(x2.highLowContainer.getContainerAtIndex(pos2));
        if (c.getCardinality() > 0) {
          this.getMappeableRoaringArray().setContainerAtIndex(pos1,c);
          pos1++;
        }
 else {
          getMappeableRoaringArray().removeAtIndex(pos1);
          --length1;
        }
        pos2++;
        if ((pos1 == length1) || (pos2 == length2)) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
 else       if (Util.compareUnsigned(s1,s2) < 0) {
        pos1++;
        if (pos1 == length1) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
      }
 else {
        getMappeableRoaringArray().insertNewKeyValueAt(pos1,(short)s2,x2.highLowContainer.getContainerAtIndex(pos2));
        pos1++;
        length1++;
        pos2++;
        if (pos2 == length2) {
          break main;
        }
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
    }
  }
  if (pos1 == length1) {
    getMappeableRoaringArray().appendCopy(x2.highLowContainer,pos2,length2);
  }
}","/** 
 * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.
 * @param x2 other bitmap
 */
public void xor(final ImmutableRoaringBitmap x2){
  int pos1=0, pos2=0;
  int length1=highLowContainer.size();
  final int length2=x2.highLowContainer.size();
  main:   if (pos1 < length1 && pos2 < length2) {
    short s1=highLowContainer.getKeyAtIndex(pos1);
    short s2=x2.highLowContainer.getKeyAtIndex(pos2);
    while (true) {
      if (s1 == s2) {
        final MappeableContainer c=highLowContainer.getContainerAtIndex(pos1).ixor(x2.highLowContainer.getContainerAtIndex(pos2));
        if (c.getCardinality() > 0) {
          this.getMappeableRoaringArray().setContainerAtIndex(pos1,c);
          pos1++;
        }
 else {
          getMappeableRoaringArray().removeAtIndex(pos1);
          --length1;
        }
        pos2++;
        if ((pos1 == length1) || (pos2 == length2)) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
 else       if (Util.compareUnsigned(s1,s2) < 0) {
        pos1++;
        if (pos1 == length1) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
      }
 else {
        getMappeableRoaringArray().insertNewKeyValueAt(pos1,(short)s2,x2.highLowContainer.getContainerAtIndex(pos2).clone());
        pos1++;
        length1++;
        pos2++;
        if (pos2 == length2) {
          break main;
        }
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
    }
  }
  if (pos1 == length1) {
    getMappeableRoaringArray().appendCopy(x2.highLowContainer,pos2,length2);
  }
}"
90267,"int numberOfRunsAdjustment(){
  int ans=0;
  long nextWord=bitmap[0];
  for (int i=0; i < bitmap.length - 1; i++) {
    final long word=nextWord;
    nextWord=bitmap[i + 1];
    ans+=((word >>> 63) & ~nextWord);
  }
  final long word=nextWord;
  if ((word & 0x8000000000000000L) != 0)   ans++;
  return ans;
}","/** 
 * Computes the number of runs
 * @return the number of runs
 */
public int numberOfRunsAdjustment(){
  int ans=0;
  long nextWord=bitmap[0];
  for (int i=0; i < bitmap.length - 1; i++) {
    final long word=nextWord;
    nextWord=bitmap[i + 1];
    ans+=((word >>> 63) & ~nextWord);
  }
  final long word=nextWord;
  if ((word & 0x8000000000000000L) != 0)   ans++;
  return ans;
}"
90268,"int numberOfRunsLowerBound(int mustNotExceed){
  int numRuns=0;
  for (int blockOffset=0; blockOffset < bitmap.length; blockOffset+=BLOCKSIZE) {
    for (int i=blockOffset; i < blockOffset + BLOCKSIZE; i++) {
      long word=bitmap[i];
      numRuns+=Long.bitCount((~word) & (word << 1));
    }
    if (numRuns > mustNotExceed)     return numRuns;
  }
  return numRuns;
}","/** 
 * Counts how many runs there is in the bitmap, up to a maximum
 * @param mustNotExceed maximum of runs beyond which counting is pointless
 * @return estimated number of courses
 */
public int numberOfRunsLowerBound(int mustNotExceed){
  int numRuns=0;
  for (int blockOffset=0; blockOffset < bitmap.length; blockOffset+=BLOCKSIZE) {
    for (int i=blockOffset; i < blockOffset + BLOCKSIZE; i++) {
      long word=bitmap[i];
      numRuns+=Long.bitCount((~word) & (word << 1));
    }
    if (numRuns > mustNotExceed)     return numRuns;
  }
  return numRuns;
}"
90269,"@Override public Container iremove(int begin,int end){
  if ((begin >= end) || (end > (1 << 16))) {
    throw new IllegalArgumentException(""String_Node_Str"" + begin + ""String_Node_Str""+ end+ ""String_Node_Str"");
  }
  if (begin == end - 1) {
    remove((short)begin);
    return this;
  }
  int bIndex=unsignedInterleavedBinarySearch(this.valueslength,0,this.nbrruns,(short)begin);
  int eIndex=unsignedInterleavedBinarySearch(this.valueslength,0,this.nbrruns,(short)(end - 1));
  if (bIndex >= 0) {
    if (eIndex < 0) {
      eIndex=-eIndex - 2;
    }
    if (valueLengthContains(end,eIndex)) {
      initValueLength(end,eIndex);
      recoverRoomsInRange(bIndex - 1,eIndex - 1);
    }
 else {
      recoverRoomsInRange(bIndex - 1,eIndex);
    }
  }
 else   if (bIndex < 0 && eIndex >= 0) {
    bIndex=-bIndex - 2;
    if (bIndex >= 0) {
      if (valueLengthContains(begin,bIndex)) {
        closeValueLength(begin - 1,bIndex);
      }
    }
    incrementValue(eIndex);
    decrementLength(eIndex);
    recoverRoomsInRange(bIndex,eIndex - 1);
  }
 else {
    bIndex=-bIndex - 2;
    eIndex=-eIndex - 2;
    if (eIndex >= 0) {
      if (bIndex >= 0) {
        if (bIndex == eIndex) {
          if (valueLengthContains(begin,bIndex)) {
            if (valueLengthContains(end,eIndex)) {
              makeRoomAtIndex(bIndex);
              closeValueLength(begin - 1,bIndex);
              initValueLength(end,bIndex + 1);
              return this;
            }
            closeValueLength(begin - 1,bIndex);
          }
        }
 else {
          if (valueLengthContains(begin,bIndex)) {
            closeValueLength(begin - 1,bIndex);
          }
          if (valueLengthContains(end,eIndex)) {
            initValueLength(end,eIndex);
            eIndex--;
          }
          recoverRoomsInRange(bIndex,eIndex);
        }
      }
 else {
        if (valueLengthContains(end - 1,eIndex)) {
          initValueLength(end,eIndex);
          recoverRoomsInRange(bIndex,eIndex - 1);
        }
 else {
          recoverRoomsInRange(bIndex,eIndex);
        }
      }
    }
  }
  return this;
}","@Override public Container iremove(int begin,int end){
  if ((begin >= end) || (end > (1 << 16))) {
    throw new IllegalArgumentException(""String_Node_Str"" + begin + ""String_Node_Str""+ end+ ""String_Node_Str"");
  }
  if (begin == end - 1) {
    remove((short)begin);
    return this;
  }
  int bIndex=unsignedInterleavedBinarySearch(this.valueslength,0,this.nbrruns,(short)begin);
  int eIndex=unsignedInterleavedBinarySearch(this.valueslength,0,this.nbrruns,(short)(end - 1));
  if (bIndex >= 0) {
    if (eIndex < 0) {
      eIndex=-eIndex - 2;
    }
    if (valueLengthContains(end,eIndex)) {
      initValueLength(end,eIndex);
      recoverRoomsInRange(bIndex - 1,eIndex - 1);
    }
 else {
      recoverRoomsInRange(bIndex - 1,eIndex);
    }
  }
 else   if (bIndex < 0 && eIndex >= 0) {
    bIndex=-bIndex - 2;
    if (bIndex >= 0) {
      if (valueLengthContains(begin,bIndex)) {
        closeValueLength(begin - 1,bIndex);
      }
    }
    incrementValue(eIndex);
    decrementLength(eIndex);
    recoverRoomsInRange(bIndex,eIndex - 1);
  }
 else {
    bIndex=-bIndex - 2;
    eIndex=-eIndex - 2;
    if (eIndex >= 0) {
      if (bIndex >= 0) {
        if (bIndex == eIndex) {
          if (valueLengthContains(begin,bIndex)) {
            if (valueLengthContains(end,eIndex)) {
              makeRoomAtIndex(bIndex);
              closeValueLength(begin - 1,bIndex);
              initValueLength(end,bIndex + 1);
              return this;
            }
            closeValueLength(begin - 1,bIndex);
          }
        }
 else {
          if (valueLengthContains(begin,bIndex)) {
            closeValueLength(begin - 1,bIndex);
          }
          if (valueLengthContains(end,eIndex)) {
            initValueLength(end,eIndex);
            eIndex--;
          }
 else {
          }
          recoverRoomsInRange(bIndex,eIndex);
        }
      }
 else {
        if (valueLengthContains(end,eIndex)) {
          initValueLength(end,eIndex);
          recoverRoomsInRange(bIndex,eIndex - 1);
        }
 else {
          recoverRoomsInRange(bIndex,eIndex);
        }
      }
    }
 else {
    }
  }
  return this;
}"
90270,"@Override public MappeableContainer iremove(int begin,int end){
  if ((begin >= end) || (end > (1 << 16))) {
    throw new IllegalArgumentException(""String_Node_Str"" + begin + ""String_Node_Str""+ end+ ""String_Node_Str"");
  }
  if (begin == end - 1) {
    remove((short)begin);
    return this;
  }
  int bIndex=bufferedUnsignedInterleavedBinarySearch(this.valueslength,0,this.nbrruns,(short)begin);
  int eIndex=bufferedUnsignedInterleavedBinarySearch(this.valueslength,0,this.nbrruns,(short)(end - 1));
  if (bIndex >= 0) {
    if (eIndex < 0) {
      eIndex=-eIndex - 2;
    }
    if (valueLengthContains(end,eIndex)) {
      initValueLength(end,eIndex);
      recoverRoomsInRange(bIndex - 1,eIndex - 1);
    }
 else {
      recoverRoomsInRange(bIndex - 1,eIndex);
    }
  }
 else   if (bIndex < 0 && eIndex >= 0) {
    bIndex=-bIndex - 2;
    if (bIndex >= 0) {
      if (valueLengthContains(begin,bIndex)) {
        closeValueLength(begin - 1,bIndex);
      }
    }
    incrementValue(eIndex);
    decrementLength(eIndex);
    recoverRoomsInRange(bIndex,eIndex - 1);
  }
 else {
    bIndex=-bIndex - 2;
    eIndex=-eIndex - 2;
    if (eIndex >= 0) {
      if (bIndex >= 0) {
        if (bIndex == eIndex) {
          if (valueLengthContains(begin,bIndex)) {
            if (valueLengthContains(end,eIndex)) {
              makeRoomAtIndex(bIndex);
              closeValueLength(begin - 1,bIndex);
              initValueLength(end,bIndex + 1);
              return this;
            }
            closeValueLength(begin - 1,bIndex);
          }
        }
 else {
          if (valueLengthContains(begin,bIndex)) {
            closeValueLength(begin - 1,bIndex);
          }
          if (valueLengthContains(end,eIndex)) {
            initValueLength(end,eIndex);
            eIndex--;
          }
          recoverRoomsInRange(bIndex,eIndex);
        }
      }
 else {
        if (valueLengthContains(end - 1,eIndex)) {
          initValueLength(end,eIndex);
          recoverRoomsInRange(bIndex,eIndex - 1);
        }
 else {
          recoverRoomsInRange(bIndex,eIndex);
        }
      }
    }
  }
  return this;
}","@Override public MappeableContainer iremove(int begin,int end){
  if ((begin >= end) || (end > (1 << 16))) {
    throw new IllegalArgumentException(""String_Node_Str"" + begin + ""String_Node_Str""+ end+ ""String_Node_Str"");
  }
  if (begin == end - 1) {
    remove((short)begin);
    return this;
  }
  int bIndex=bufferedUnsignedInterleavedBinarySearch(this.valueslength,0,this.nbrruns,(short)begin);
  int eIndex=bufferedUnsignedInterleavedBinarySearch(this.valueslength,0,this.nbrruns,(short)(end - 1));
  if (bIndex >= 0) {
    if (eIndex < 0) {
      eIndex=-eIndex - 2;
    }
    if (valueLengthContains(end,eIndex)) {
      initValueLength(end,eIndex);
      recoverRoomsInRange(bIndex - 1,eIndex - 1);
    }
 else {
      recoverRoomsInRange(bIndex - 1,eIndex);
    }
  }
 else   if (bIndex < 0 && eIndex >= 0) {
    bIndex=-bIndex - 2;
    if (bIndex >= 0) {
      if (valueLengthContains(begin,bIndex)) {
        closeValueLength(begin - 1,bIndex);
      }
    }
    incrementValue(eIndex);
    decrementLength(eIndex);
    recoverRoomsInRange(bIndex,eIndex - 1);
  }
 else {
    bIndex=-bIndex - 2;
    eIndex=-eIndex - 2;
    if (eIndex >= 0) {
      if (bIndex >= 0) {
        if (bIndex == eIndex) {
          if (valueLengthContains(begin,bIndex)) {
            if (valueLengthContains(end,eIndex)) {
              makeRoomAtIndex(bIndex);
              closeValueLength(begin - 1,bIndex);
              initValueLength(end,bIndex + 1);
              return this;
            }
            closeValueLength(begin - 1,bIndex);
          }
        }
 else {
          if (valueLengthContains(begin,bIndex)) {
            closeValueLength(begin - 1,bIndex);
          }
          if (valueLengthContains(end,eIndex)) {
            initValueLength(end,eIndex);
            eIndex--;
          }
          recoverRoomsInRange(bIndex,eIndex);
        }
      }
 else {
        if (valueLengthContains(end,eIndex)) {
          initValueLength(end,eIndex);
          recoverRoomsInRange(bIndex,eIndex - 1);
        }
 else {
          recoverRoomsInRange(bIndex,eIndex);
        }
      }
    }
  }
  return this;
}"
90271,"@Override public MappeableContainer add(int begin,int end){
  int indexstart=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)begin);
  if (indexstart < 0)   indexstart=-indexstart - 1;
  int indexend=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(end - 1));
  if (indexend < 0)   indexend=-indexend - 1;
 else   indexend++;
  int rangelength=end - begin;
  int newcardinality=indexstart + (cardinality - indexend) + rangelength;
  if (newcardinality > DEFAULT_MAX_SIZE) {
    MappeableBitmapContainer a=this.toBitmapContainer();
    return a.iadd(begin,end);
  }
  MappeableArrayContainer answer=new MappeableArrayContainer(newcardinality,content);
  BufferUtil.arraycopy(content,indexend,answer.content,indexstart + rangelength,cardinality - indexend);
  short[] answerarray=answer.content.array();
  for (int k=0; k < rangelength; ++k) {
    answerarray[k + indexstart]=(short)(begin + k);
  }
  answer.cardinality=newcardinality;
  return answer;
}","@Override public MappeableContainer add(int begin,int end){
  int indexstart=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)begin);
  if (indexstart < 0)   indexstart=-indexstart - 1;
  int indexend=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(end - 1));
  if (indexend < 0)   indexend=-indexend - 1;
 else   indexend++;
  int rangelength=end - begin;
  int newcardinality=indexstart + (cardinality - indexend) + rangelength;
  if (newcardinality > DEFAULT_MAX_SIZE) {
    MappeableBitmapContainer a=this.toBitmapContainer();
    return a.iadd(begin,end);
  }
  MappeableArrayContainer answer=new MappeableArrayContainer(newcardinality,content);
  if (!BufferUtil.isBackedBySimpleArray(answer.content))   throw new RuntimeException(""String_Node_Str"");
  BufferUtil.arraycopy(content,indexend,answer.content,indexstart + rangelength,cardinality - indexend);
  short[] answerarray=answer.content.array();
  for (int k=0; k < rangelength; ++k) {
    answerarray[k + indexstart]=(short)(begin + k);
  }
  answer.cardinality=newcardinality;
  return answer;
}"
90272,"protected void loadData(final MappeableBitmapContainer bitmapContainer){
  this.cardinality=bitmapContainer.cardinality;
  bitmapContainer.fillArray(content.array());
}","protected void loadData(final MappeableBitmapContainer bitmapContainer){
  this.cardinality=bitmapContainer.cardinality;
  if (!BufferUtil.isBackedBySimpleArray(this.content))   throw new RuntimeException(""String_Node_Str"");
  bitmapContainer.fillArray(content.array());
}"
90273,"@Override public MappeableContainer not(final int firstOfRange,final int lastOfRange){
  if (firstOfRange >= lastOfRange) {
    return clone();
  }
  int startIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 2;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (newCardinality > DEFAULT_MAX_SIZE)   return toBitmapContainer().not(firstOfRange,lastOfRange);
  final MappeableArrayContainer answer=new MappeableArrayContainer(newCardinality);
  short[] sarray=answer.content.array();
  for (int i=0; i < startIndex; ++i)   sarray[i]=content.get(i);
  int outPos=startIndex;
  int inPos=startIndex;
  int valInRange=firstOfRange;
  for (; valInRange < lastOfRange && inPos <= lastIndex; ++valInRange) {
    if ((short)valInRange != content.get(inPos))     sarray[outPos++]=(short)valInRange;
 else {
      ++inPos;
    }
  }
  for (; valInRange < lastOfRange; ++valInRange) {
    answer.content.put(outPos++,(short)valInRange);
  }
  for (int i=lastIndex + 1; i < cardinality; ++i)   answer.content.put(outPos++,content.get(i));
  answer.cardinality=newCardinality;
  return answer;
}","@Override public MappeableContainer not(final int firstOfRange,final int lastOfRange){
  if (firstOfRange >= lastOfRange) {
    return clone();
  }
  int startIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 2;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (newCardinality > DEFAULT_MAX_SIZE)   return toBitmapContainer().not(firstOfRange,lastOfRange);
  final MappeableArrayContainer answer=new MappeableArrayContainer(newCardinality);
  if (!BufferUtil.isBackedBySimpleArray(answer.content))   throw new RuntimeException(""String_Node_Str"");
  short[] sarray=answer.content.array();
  for (int i=0; i < startIndex; ++i)   sarray[i]=content.get(i);
  int outPos=startIndex;
  int inPos=startIndex;
  int valInRange=firstOfRange;
  for (; valInRange < lastOfRange && inPos <= lastIndex; ++valInRange) {
    if ((short)valInRange != content.get(inPos))     sarray[outPos++]=(short)valInRange;
 else {
      ++inPos;
    }
  }
  for (; valInRange < lastOfRange; ++valInRange) {
    answer.content.put(outPos++,(short)valInRange);
  }
  for (int i=lastIndex + 1; i < cardinality; ++i)   answer.content.put(outPos++,content.get(i));
  answer.cardinality=newCardinality;
  return answer;
}"
90274,"/** 
 * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.
 * @param x2 other bitmap
 */
public void xor(final ImmutableRoaringBitmap x2){
  int pos1=0, pos2=0;
  int length1=highLowContainer.size();
  final int length2=x2.highLowContainer.size();
  main:   if (pos1 < length1 && pos2 < length2) {
    short s1=highLowContainer.getKeyAtIndex(pos1);
    short s2=x2.highLowContainer.getKeyAtIndex(pos2);
    while (true) {
      if (s1 == s2) {
        final MappeableContainer c=highLowContainer.getContainerAtIndex(pos1).ixor(x2.highLowContainer.getContainerAtIndex(pos2));
        if (c.getCardinality() > 0) {
          this.getMappeableRoaringArray().setContainerAtIndex(pos1,c);
          pos1++;
        }
 else {
          getMappeableRoaringArray().removeAtIndex(pos1);
          --length1;
        }
        pos2++;
        if ((pos1 == length1) || (pos2 == length2)) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
 else       if (Util.compareUnsigned(s1,s2) < 0) {
        pos1++;
        if (pos1 == length1) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
      }
 else {
        getMappeableRoaringArray().insertNewKeyValueAt(pos1,(short)s2,x2.highLowContainer.getContainerAtIndex(pos2));
        pos1++;
        length1++;
        pos2++;
        if (pos2 == length2) {
          break main;
        }
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
    }
  }
  if (pos1 == length1) {
    getMappeableRoaringArray().appendCopy(x2.highLowContainer,pos2,length2);
  }
}","/** 
 * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.
 * @param x2 other bitmap
 */
public void xor(final ImmutableRoaringBitmap x2){
  int pos1=0, pos2=0;
  int length1=highLowContainer.size();
  final int length2=x2.highLowContainer.size();
  main:   if (pos1 < length1 && pos2 < length2) {
    short s1=highLowContainer.getKeyAtIndex(pos1);
    short s2=x2.highLowContainer.getKeyAtIndex(pos2);
    while (true) {
      if (s1 == s2) {
        final MappeableContainer c=highLowContainer.getContainerAtIndex(pos1).ixor(x2.highLowContainer.getContainerAtIndex(pos2));
        if (c.getCardinality() > 0) {
          this.getMappeableRoaringArray().setContainerAtIndex(pos1,c);
          pos1++;
        }
 else {
          getMappeableRoaringArray().removeAtIndex(pos1);
          --length1;
        }
        pos2++;
        if ((pos1 == length1) || (pos2 == length2)) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
 else       if (Util.compareUnsigned(s1,s2) < 0) {
        pos1++;
        if (pos1 == length1) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
      }
 else {
        getMappeableRoaringArray().insertNewKeyValueAt(pos1,(short)s2,x2.highLowContainer.getContainerAtIndex(pos2).clone());
        pos1++;
        length1++;
        pos2++;
        if (pos2 == length2) {
          break main;
        }
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
    }
  }
  if (pos1 == length1) {
    getMappeableRoaringArray().appendCopy(x2.highLowContainer,pos2,length2);
  }
}"
90275,"/** 
 * In-place bitwise OR (union) operation. The current bitmap is modified.
 * @param x2 other bitmap
 */
public void or(final ImmutableRoaringBitmap x2){
  int pos1=0, pos2=0;
  int length1=highLowContainer.size();
  final int length2=x2.highLowContainer.size();
  main:   if (pos1 < length1 && pos2 < length2) {
    short s1=highLowContainer.getKeyAtIndex(pos1);
    short s2=x2.highLowContainer.getKeyAtIndex(pos2);
    while (true) {
      if (s1 == s2) {
        getMappeableRoaringArray().setContainerAtIndex(pos1,highLowContainer.getContainerAtIndex(pos1).ior(x2.highLowContainer.getContainerAtIndex(pos2)));
        pos1++;
        pos2++;
        if ((pos1 == length1) || (pos2 == length2)) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
 else       if (Util.compareUnsigned(s1,s2) < 0) {
        pos1++;
        if (pos1 == length1) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
      }
 else {
        getMappeableRoaringArray().insertNewKeyValueAt(pos1,(short)s2,x2.highLowContainer.getContainerAtIndex(pos2));
        pos1++;
        length1++;
        pos2++;
        if (pos2 == length2) {
          break main;
        }
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
    }
  }
  if (pos1 == length1) {
    getMappeableRoaringArray().appendCopy(x2.highLowContainer,pos2,length2);
  }
}","/** 
 * In-place bitwise OR (union) operation. The current bitmap is modified.
 * @param x2 other bitmap
 */
public void or(final ImmutableRoaringBitmap x2){
  int pos1=0, pos2=0;
  int length1=highLowContainer.size();
  final int length2=x2.highLowContainer.size();
  main:   if (pos1 < length1 && pos2 < length2) {
    short s1=highLowContainer.getKeyAtIndex(pos1);
    short s2=x2.highLowContainer.getKeyAtIndex(pos2);
    while (true) {
      if (s1 == s2) {
        getMappeableRoaringArray().setContainerAtIndex(pos1,highLowContainer.getContainerAtIndex(pos1).ior(x2.highLowContainer.getContainerAtIndex(pos2)));
        pos1++;
        pos2++;
        if ((pos1 == length1) || (pos2 == length2)) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
 else       if (Util.compareUnsigned(s1,s2) < 0) {
        pos1++;
        if (pos1 == length1) {
          break main;
        }
        s1=highLowContainer.getKeyAtIndex(pos1);
      }
 else {
        getMappeableRoaringArray().insertNewKeyValueAt(pos1,(short)s2,x2.highLowContainer.getContainerAtIndex(pos2).clone());
        pos1++;
        length1++;
        pos2++;
        if (pos2 == length2) {
          break main;
        }
        s2=x2.highLowContainer.getKeyAtIndex(pos2);
      }
    }
  }
  if (pos1 == length1) {
    getMappeableRoaringArray().appendCopy(x2.highLowContainer,pos2,length2);
  }
}"
90276,"@Override public boolean equals(Object o){
  if (o instanceof ImmutableRoaringArray) {
    final ImmutableRoaringArray srb=(ImmutableRoaringArray)o;
    return srb.buffer.equals(this.buffer);
  }
  if (o instanceof MutableRoaringArray) {
    final MutableRoaringArray srb=(MutableRoaringArray)o;
    MappeableContainerPointer cp1=srb.getContainerPointer();
    MappeableContainerPointer cp2=srb.getContainerPointer();
    while (cp1.hasContainer()) {
      if (!cp2.hasContainer())       return false;
      if (cp1.key() != cp2.key())       return false;
      if (cp1.getCardinality() != cp2.getCardinality())       return false;
      if (!cp1.getContainer().equals(cp2.getContainer()))       return false;
      cp1.advance();
      cp2.advance();
    }
    if (cp2.hasContainer())     return false;
    return true;
  }
  return false;
}","@Override public boolean equals(Object o){
  if (o instanceof ImmutableRoaringArray) {
    final ImmutableRoaringArray srb=(ImmutableRoaringArray)o;
    return srb.buffer.equals(this.buffer);
  }
  if (o instanceof MutableRoaringArray) {
    final MutableRoaringArray srb=(MutableRoaringArray)o;
    MappeableContainerPointer cp1=this.getContainerPointer();
    MappeableContainerPointer cp2=srb.getContainerPointer();
    while (cp1.hasContainer()) {
      if (!cp2.hasContainer())       return false;
      if (cp1.key() != cp2.key())       return false;
      if (cp1.getCardinality() != cp2.getCardinality())       return false;
      if (!cp1.getContainer().equals(cp2.getContainer()))       return false;
      cp1.advance();
      cp2.advance();
    }
    if (cp2.hasContainer())     return false;
    return true;
  }
  return false;
}"
90277,"private MappeableContainer operationArrayGuess(MappeableRunContainer x,int opcode){
  ShortBuffer ansArray=ShortBuffer.allocate(10);
  int card=0;
  int thisHead, xHead;
  ShortIterator it=getShortIterator();
  ShortIterator xIt=x.getShortIterator();
  thisHead=(it.hasNext() ? BufferUtil.toIntUnsigned(it.next()) : -1);
  xHead=(xIt.hasNext() ? BufferUtil.toIntUnsigned(xIt.next()) : -1);
  while (thisHead != -1 && xHead != -1) {
    if (thisHead > xHead) {
      if (opcode == OP_OR || opcode == OP_XOR) {
        if (card == ansArray.capacity())         ansArray=increaseCapacity(ansArray);
        ansArray.put(card++,(short)xHead);
      }
      xHead=(xIt.hasNext() ? BufferUtil.toIntUnsigned(xIt.next()) : -1);
    }
 else     if (thisHead < xHead) {
      if (opcode != OP_AND) {
        if (card == ansArray.capacity())         ansArray=increaseCapacity(ansArray);
        ansArray.put(card++,(short)thisHead);
      }
      thisHead=(it.hasNext() ? BufferUtil.toIntUnsigned(it.next()) : -1);
    }
 else {
      if (opcode == OP_AND || opcode == OP_OR) {
        if (card == ansArray.capacity())         ansArray=increaseCapacity(ansArray);
        ansArray.put(card++,(short)thisHead);
      }
      thisHead=(it.hasNext() ? BufferUtil.toIntUnsigned(it.next()) : -1);
      xHead=(xIt.hasNext() ? BufferUtil.toIntUnsigned(xIt.next()) : -1);
    }
  }
  if (opcode != OP_AND) {
    while (thisHead != -1) {
      if (card == ansArray.capacity())       ansArray=increaseCapacity(ansArray);
      ansArray.put(card++,(short)thisHead);
      thisHead=(it.hasNext() ? BufferUtil.toIntUnsigned(it.next()) : -1);
    }
    if (opcode == OP_OR || opcode == OP_XOR)     while (xHead != -1) {
      if (card == ansArray.capacity())       ansArray=increaseCapacity(ansArray);
      ansArray.put(card++,(short)xHead);
      xHead=(xIt.hasNext() ? BufferUtil.toIntUnsigned(xIt.next()) : -1);
    }
  }
  ShortBuffer content=ShortBuffer.allocate(card);
  ansArray.flip();
  content.put(ansArray);
  MappeableArrayContainer ac=new MappeableArrayContainer(content,card);
  if (card > MappeableArrayContainer.DEFAULT_MAX_SIZE)   return ac.toBitmapContainer();
 else   return ac;
}","private MappeableContainer operationArrayGuess(MappeableRunContainer x,int opcode){
  ShortBuffer ansArray=ShortBuffer.allocate(10);
  int card=0;
  int thisHead, xHead;
  ShortIterator it=getShortIterator();
  ShortIterator xIt=x.getShortIterator();
  thisHead=(it.hasNext() ? BufferUtil.toIntUnsigned(it.next()) : -1);
  xHead=(xIt.hasNext() ? BufferUtil.toIntUnsigned(xIt.next()) : -1);
  while (thisHead != -1 && xHead != -1) {
    if (thisHead > xHead) {
      if (opcode == OP_OR || opcode == OP_XOR) {
        if (card == ansArray.capacity())         ansArray=increaseCapacity(ansArray);
        ansArray.put((short)xHead);
        card++;
      }
      xHead=(xIt.hasNext() ? BufferUtil.toIntUnsigned(xIt.next()) : -1);
    }
 else     if (thisHead < xHead) {
      if (opcode != OP_AND) {
        if (card == ansArray.capacity())         ansArray=increaseCapacity(ansArray);
        ansArray.put((short)thisHead);
        card++;
      }
      thisHead=(it.hasNext() ? BufferUtil.toIntUnsigned(it.next()) : -1);
    }
 else {
      if (opcode == OP_AND || opcode == OP_OR) {
        if (card == ansArray.capacity())         ansArray=increaseCapacity(ansArray);
        ansArray.put((short)thisHead);
        card++;
      }
      thisHead=(it.hasNext() ? BufferUtil.toIntUnsigned(it.next()) : -1);
      xHead=(xIt.hasNext() ? BufferUtil.toIntUnsigned(xIt.next()) : -1);
    }
  }
  if (opcode != OP_AND) {
    while (thisHead != -1) {
      if (card == ansArray.capacity())       ansArray=increaseCapacity(ansArray);
      ansArray.put((short)thisHead);
      card++;
      thisHead=(it.hasNext() ? BufferUtil.toIntUnsigned(it.next()) : -1);
    }
    if (opcode == OP_OR || opcode == OP_XOR)     while (xHead != -1) {
      if (card == ansArray.capacity())       ansArray=increaseCapacity(ansArray);
      ansArray.put((short)xHead);
      card++;
      xHead=(xIt.hasNext() ? BufferUtil.toIntUnsigned(xIt.next()) : -1);
    }
  }
  ShortBuffer content=ShortBuffer.allocate(card);
  ansArray.flip();
  content.put(ansArray);
  MappeableArrayContainer ac=new MappeableArrayContainer(content,card);
  if (card > MappeableArrayContainer.DEFAULT_MAX_SIZE)   return ac.toBitmapContainer();
 else   return ac;
}"
90278,"/** 
 * Deserialize.
 * @param in the DataInput stream
 * @throws IOException Signals that an I/O exception has occurred.
 */
public void deserialize(DataInput in) throws IOException {
  this.clear();
  final int cookie=Integer.reverseBytes(in.readInt());
  if (cookie != SERIAL_COOKIE && cookie != SERIAL_COOKIE_NO_RUNCONTAINER)   throw new IOException(""String_Node_Str"");
  this.size=Integer.reverseBytes(in.readInt());
  if ((this.array == null) || (this.array.length < this.size))   this.array=new Element[this.size];
  int[] bitmapOfRunContainers=null;
  if (cookie == SERIAL_COOKIE) {
    System.out.println(""String_Node_Str"");
    bitmapOfRunContainers=new int[(size + 31) / 32];
    for (int i=0; i < bitmapOfRunContainers.length; ++i)     bitmapOfRunContainers[i]=Integer.reverseBytes(in.readInt());
  }
  final short keys[]=new short[this.size];
  final int cardinalities[]=new int[this.size];
  final boolean isBitmap[]=new boolean[this.size];
  for (int k=0; k < this.size; ++k) {
    keys[k]=Short.reverseBytes(in.readShort());
    cardinalities[k]=1 + (0xFFFF & Short.reverseBytes(in.readShort()));
    isBitmap[k]=cardinalities[k] > ArrayContainer.DEFAULT_MAX_SIZE;
    if (bitmapOfRunContainers != null && (bitmapOfRunContainers[k / 32] & (1 << (k % 32))) != 0) {
      System.out.println(""String_Node_Str"" + k + ""String_Node_Str"");
      isBitmap[k]=false;
    }
  }
  in.skipBytes(this.size * 4);
  for (int k=0; k < this.size; ++k) {
    Container val;
    if (isBitmap[k]) {
      final long[] bitmapArray=new long[BitmapContainer.MAX_CAPACITY / 64];
      for (int l=0; l < bitmapArray.length; ++l) {
        bitmapArray[l]=Long.reverseBytes(in.readLong());
      }
      val=new BitmapContainer(bitmapArray,cardinalities[k]);
    }
 else     if (bitmapOfRunContainers != null && ((bitmapOfRunContainers[k / 32] & (1 << (k % 32))) != 0)) {
      int nbrruns=Util.toIntUnsigned(Short.reverseBytes(in.readShort()));
      final short lengthsAndValues[]=new short[2 * nbrruns];
      for (int j=0; j < 2 * nbrruns; ++j)       lengthsAndValues[j]=Short.reverseBytes(in.readShort());
      val=new RunContainer(lengthsAndValues);
      System.out.println(""String_Node_Str"" + nbrruns + ""String_Node_Str""+ k);
    }
 else {
      final short[] shortArray=new short[cardinalities[k]];
      for (int l=0; l < shortArray.length; ++l) {
        shortArray[l]=Short.reverseBytes(in.readShort());
      }
      val=new ArrayContainer(shortArray);
    }
    this.array[k]=new Element(keys[k],val);
  }
}","/** 
 * Deserialize.
 * @param in the DataInput stream
 * @throws IOException Signals that an I/O exception has occurred.
 */
public void deserialize(DataInput in) throws IOException {
  this.clear();
  final int cookie=Integer.reverseBytes(in.readInt());
  if (cookie != SERIAL_COOKIE && cookie != SERIAL_COOKIE_NO_RUNCONTAINER)   throw new IOException(""String_Node_Str"");
  this.size=Integer.reverseBytes(in.readInt());
  if ((this.array == null) || (this.array.length < this.size))   this.array=new Element[this.size];
  int[] bitmapOfRunContainers=null;
  if (cookie == SERIAL_COOKIE) {
    bitmapOfRunContainers=new int[(size + 31) / 32];
    for (int i=0; i < bitmapOfRunContainers.length; ++i)     bitmapOfRunContainers[i]=Integer.reverseBytes(in.readInt());
  }
  final short keys[]=new short[this.size];
  final int cardinalities[]=new int[this.size];
  final boolean isBitmap[]=new boolean[this.size];
  for (int k=0; k < this.size; ++k) {
    keys[k]=Short.reverseBytes(in.readShort());
    cardinalities[k]=1 + (0xFFFF & Short.reverseBytes(in.readShort()));
    isBitmap[k]=cardinalities[k] > ArrayContainer.DEFAULT_MAX_SIZE;
    if (bitmapOfRunContainers != null && (bitmapOfRunContainers[k / 32] & (1 << (k % 32))) != 0) {
      isBitmap[k]=false;
    }
  }
  in.skipBytes(this.size * 4);
  for (int k=0; k < this.size; ++k) {
    Container val;
    if (isBitmap[k]) {
      final long[] bitmapArray=new long[BitmapContainer.MAX_CAPACITY / 64];
      for (int l=0; l < bitmapArray.length; ++l) {
        bitmapArray[l]=Long.reverseBytes(in.readLong());
      }
      val=new BitmapContainer(bitmapArray,cardinalities[k]);
    }
 else     if (bitmapOfRunContainers != null && ((bitmapOfRunContainers[k / 32] & (1 << (k % 32))) != 0)) {
      int nbrruns=Util.toIntUnsigned(Short.reverseBytes(in.readShort()));
      final short lengthsAndValues[]=new short[2 * nbrruns];
      for (int j=0; j < 2 * nbrruns; ++j)       lengthsAndValues[j]=Short.reverseBytes(in.readShort());
      val=new RunContainer(lengthsAndValues);
    }
 else {
      final short[] shortArray=new short[cardinalities[k]];
      for (int l=0; l < shortArray.length; ++l) {
        shortArray[l]=Short.reverseBytes(in.readShort());
      }
      val=new ArrayContainer(shortArray);
    }
    this.array[k]=new Element(keys[k],val);
  }
}"
90279,"/** 
 * Serialize. The current bitmap is not modified.
 * @param out the DataOutput stream
 * @throws IOException Signals that an I/O exception has occurred.
 */
public void serialize(DataOutput out) throws IOException {
  int startOffset=0;
  if (hasRunContainer()) {
    System.out.println(""String_Node_Str"");
    out.writeInt(Integer.reverseBytes(SERIAL_COOKIE));
    out.writeInt(Integer.reverseBytes(size));
    System.out.println(""String_Node_Str"" + size);
    int[] bitmapOfRunContainers=new int[(size + 31) / 32];
    for (int i=0; i < size; ++i)     if (this.array[i].value instanceof RunContainer)     bitmapOfRunContainers[i / 32]|=(1 << (i % 32));
    for (int i=0; i < bitmapOfRunContainers.length; ++i)     out.writeInt(Integer.reverseBytes(bitmapOfRunContainers[i]));
    System.out.println(""String_Node_Str"" + bitmapOfRunContainers.length + ""String_Node_Str"");
    startOffset=4 + 4 + 4 * this.size + 4 * this.size + 4 * bitmapOfRunContainers.length;
  }
 else {
    System.out.println(""String_Node_Str"");
    out.writeInt(Integer.reverseBytes(SERIAL_COOKIE_NO_RUNCONTAINER));
    out.writeInt(Integer.reverseBytes(size));
    startOffset=4 + 4 + 4 * this.size + 4 * this.size;
  }
  for (int k=0; k < size; ++k) {
    out.writeShort(Short.reverseBytes(this.array[k].key));
    out.writeShort(Short.reverseBytes((short)((this.array[k].value.getCardinality() - 1))));
  }
  for (int k=0; k < this.size; k++) {
    out.writeInt(Integer.reverseBytes(startOffset));
    startOffset=startOffset + this.array[k].value.getArraySizeInBytes();
  }
  for (int k=0; k < size; ++k) {
    array[k].value.writeArray(out);
  }
}","/** 
 * Serialize. The current bitmap is not modified.
 * @param out the DataOutput stream
 * @throws IOException Signals that an I/O exception has occurred.
 */
public void serialize(DataOutput out) throws IOException {
  int startOffset=0;
  if (hasRunContainer()) {
    out.writeInt(Integer.reverseBytes(SERIAL_COOKIE));
    out.writeInt(Integer.reverseBytes(size));
    int[] bitmapOfRunContainers=new int[(size + 31) / 32];
    for (int i=0; i < size; ++i)     if (this.array[i].value instanceof RunContainer)     bitmapOfRunContainers[i / 32]|=(1 << (i % 32));
    for (int i=0; i < bitmapOfRunContainers.length; ++i)     out.writeInt(Integer.reverseBytes(bitmapOfRunContainers[i]));
    startOffset=4 + 4 + 4 * this.size + 4 * this.size + 4 * bitmapOfRunContainers.length;
  }
 else {
    out.writeInt(Integer.reverseBytes(SERIAL_COOKIE_NO_RUNCONTAINER));
    out.writeInt(Integer.reverseBytes(size));
    startOffset=4 + 4 + 4 * this.size + 4 * this.size;
  }
  for (int k=0; k < size; ++k) {
    out.writeShort(Short.reverseBytes(this.array[k].key));
    out.writeShort(Short.reverseBytes((short)((this.array[k].value.getCardinality() - 1))));
  }
  for (int k=0; k < this.size; k++) {
    out.writeInt(Integer.reverseBytes(startOffset));
    startOffset=startOffset + this.array[k].value.getArraySizeInBytes();
  }
  for (int k=0; k < size; ++k) {
    array[k].value.writeArray(out);
  }
}"
90280,"public void iaddInvalidRange2(){
}","@Test(expected=IllegalArgumentException.class) public void iaddInvalidRange2(){
  Container rc=new RunContainer();
  rc.iadd(0,1 << 20);
}"
90281,"/** 
 * Find the smallest integer index larger than pos such that array[index].key&gt;=x. If none can be found, return size. Based on code by O. Kaser.
 * @param x minimal value
 * @param pos index to exceed
 * @return the smallest index greater than pos such that array[index].key is at least as largeas min, or size if it is not possible.
 */
protected int advanceUntil(short x,int pos){
  int lower=pos + 1;
  if (lower >= size || Util.toIntUnsigned(array[lower].key) >= Util.toIntUnsigned(x)) {
    return lower;
  }
  int spansize=1;
  while (lower + spansize < size && Util.toIntUnsigned(array[lower + spansize].key) < Util.toIntUnsigned(x))   spansize*=2;
  int upper=(lower + spansize < size) ? lower + spansize : size - 1;
  if (array[upper].key == x) {
    return upper;
  }
  if (Util.toIntUnsigned(array[upper].key) < Util.toIntUnsigned(x)) {
    return size;
  }
  lower+=(spansize / 2);
  while (lower + 1 != upper) {
    int mid=(lower + upper) / 2;
    if (array[mid].key == x)     return mid;
 else     if (Util.toIntUnsigned(array[mid].key) < Util.toIntUnsigned(x))     lower=mid;
 else     upper=mid;
  }
  return upper;
}","/** 
 * Find the smallest integer index larger than pos such that array[index].key&gt;=x. If none can be found, return size. Based on code by O. Kaser.
 * @param x minimal value
 * @param pos index to exceed
 * @return the smallest index greater than pos such that array[index].key is at least as largeas min, or size if it is not possible.
 */
protected int advanceUntil(int x,int pos){
  int lower=pos + 1;
  if (lower >= size || Util.toIntUnsigned(array[lower].key) >= x) {
    return lower;
  }
  int spansize=1;
  while (lower + spansize < size && Util.toIntUnsigned(array[lower + spansize].key) < x)   spansize*=2;
  int upper=(lower + spansize < size) ? lower + spansize : size - 1;
  if (array[upper].key == x) {
    return upper;
  }
  if (Util.toIntUnsigned(array[upper].key) < x) {
    return size;
  }
  lower+=(spansize / 2);
  while (lower + 1 != upper) {
    int mid=(lower + upper) / 2;
    if (array[mid].key == x)     return mid;
 else     if (Util.toIntUnsigned(array[mid].key) < x)     lower=mid;
 else     upper=mid;
  }
  return upper;
}"
90282,"/** 
 * Append copies of the values from another array
 * @param sa            other array
 * @param startingIndex starting index in the other array
 * @param end endingIndex (exclusive) in the other array
 */
protected void appendCopy(RoaringArray sa,int startingIndex,int end){
  extendArray(end - startingIndex);
  for (int i=startingIndex; i < end; ++i) {
    this.array[this.size++]=new Element(sa.array[i].key,sa.array[i].value.clone());
  }
}","/** 
 * Append copies of the values from another array
 * @param sa            other array
 * @param startingIndex starting index in the other array
 * @param end endingIndex (exclusive) in the other array
 */
protected void appendCopy(RoaringArray sa,int startingIndex,int end){
  extendArray(end - startingIndex);
  for (int i=startingIndex; i < end; ++i)   this.array[this.size++]=new Element(sa.array[i].key,sa.array[i].value.clone());
}"
90283,"public int advanceUntil(short x,int pos){
  int lower=pos + 1;
  if (lower >= size || getKey(lower) >= BufferUtil.toIntUnsigned(x)) {
    return lower;
  }
  int spansize=1;
  while (lower + spansize < size && getKey(lower + spansize) < BufferUtil.toIntUnsigned(x))   spansize*=2;
  int upper=(lower + spansize < size) ? lower + spansize : size - 1;
  if (getKey(upper) == x) {
    return upper;
  }
  if (getKey(upper) < BufferUtil.toIntUnsigned(x)) {
    return size;
  }
  lower+=(spansize / 2);
  while (lower + 1 != upper) {
    int mid=(lower + upper) / 2;
    if (getKey(mid) == BufferUtil.toIntUnsigned(x))     return mid;
 else     if (getKey(mid) < BufferUtil.toIntUnsigned(x))     lower=mid;
 else     upper=mid;
  }
  return upper;
}","public int advanceUntil(int x,int pos){
  int lower=pos + 1;
  if (lower >= size || getKey(lower) >= x) {
    return lower;
  }
  int spansize=1;
  while (lower + spansize < size && getKey(lower + spansize) < x)   spansize*=2;
  int upper=(lower + spansize < size) ? lower + spansize : size - 1;
  if (getKey(upper) == x) {
    return upper;
  }
  if (getKey(upper) < x) {
    return size;
  }
  lower+=(spansize / 2);
  while (lower + 1 != upper) {
    int mid=(lower + upper) / 2;
    if (getKey(mid) == x)     return mid;
 else     if (getKey(mid) < x)     lower=mid;
 else     upper=mid;
  }
  return upper;
}"
90284,"public int advanceUntil(short x,int pos){
  int lower=pos + 1;
  if (lower >= size || BufferUtil.toIntUnsigned(array[lower].key) >= BufferUtil.toIntUnsigned(x)) {
    return lower;
  }
  int spansize=1;
  while (lower + spansize < size && BufferUtil.toIntUnsigned(array[lower + spansize].key) < BufferUtil.toIntUnsigned(x))   spansize*=2;
  int upper=(lower + spansize < size) ? lower + spansize : size - 1;
  if (array[upper].key == x) {
    return upper;
  }
  if (BufferUtil.toIntUnsigned(array[upper].key) < BufferUtil.toIntUnsigned(x)) {
    return size;
  }
  lower+=(spansize / 2);
  while (lower + 1 != upper) {
    int mid=(lower + upper) / 2;
    if (array[mid].key == x)     return mid;
 else     if (BufferUtil.toIntUnsigned(array[mid].key) < BufferUtil.toIntUnsigned(x))     lower=mid;
 else     upper=mid;
  }
  return upper;
}","public int advanceUntil(int x,int pos){
  int lower=pos + 1;
  if (lower >= size || BufferUtil.toIntUnsigned(array[lower].key) >= x) {
    return lower;
  }
  int spansize=1;
  while (lower + spansize < size && BufferUtil.toIntUnsigned(array[lower + spansize].key) < x)   spansize*=2;
  int upper=(lower + spansize < size) ? lower + spansize : size - 1;
  if (array[upper].key == x) {
    return upper;
  }
  if (BufferUtil.toIntUnsigned(array[upper].key) < x) {
    return size;
  }
  lower+=(spansize / 2);
  while (lower + 1 != upper) {
    int mid=(lower + upper) / 2;
    if (array[mid].key == x)     return mid;
 else     if (BufferUtil.toIntUnsigned(array[mid].key) < x)     lower=mid;
 else     upper=mid;
  }
  return upper;
}"
90285,"/** 
 * Find the smallest integer index larger than pos such that getKeyAtIndex(index)&gt;=x. If none can be found, return size.
 * @param x minimal value
 * @param pos index to exceed
 * @return the smallest index greater than pos such that getKeyAtIndex(index) is at least as largeas min, or size if it is not possible.
 */
int advanceUntil(short x,int pos);","/** 
 * Find the smallest integer index larger than pos such that getKeyAtIndex(index)&gt;=x. If none can be found, return size.
 * @param x minimal value
 * @param pos index to exceed
 * @return the smallest index greater than pos such that getKeyAtIndex(index) is at least as largeas min, or size if it is not possible.
 */
int advanceUntil(int x,int pos);"
90286,"@Test(expected=IllegalArgumentException.class) public void iremoveInvalidRange2(){
  Container rc=new RunContainer();
  rc.remove(0,1 << 20);
}","@Test(expected=IllegalArgumentException.class) public void iremoveInvalidRange2(){
  Container rc=new RunContainer();
  rc.iremove(0,1 << 20);
}"
90287,"@Test(expected=IllegalArgumentException.class) public void iaddRangeInvalid2(){
}","@Test(expected=IllegalArgumentException.class) public void iaddRangeInvalid2(){
  Container rc=new RunContainer();
  rc.iadd(0,1 << 20);
}"
90288,"@Override public Container not(final int firstOfRange,final int lastOfRange){
  if (firstOfRange >= lastOfRange) {
    return clone();
  }
  int startIndex=Util.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=Util.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 2;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (newCardinality >= DEFAULT_MAX_SIZE)   return toBitmapContainer().not(firstOfRange,lastOfRange);
  ArrayContainer answer=new ArrayContainer(newCardinality);
  System.arraycopy(content,0,answer.content,0,startIndex);
  int outPos=startIndex;
  int inPos=startIndex;
  int valInRange=firstOfRange;
  for (; valInRange < lastOfRange && inPos <= lastIndex; ++valInRange) {
    if ((short)valInRange != content[inPos]) {
      answer.content[outPos++]=(short)valInRange;
    }
 else {
      ++inPos;
    }
  }
  for (; valInRange < lastOfRange; ++valInRange) {
    answer.content[outPos++]=(short)valInRange;
  }
  for (int i=lastIndex + 1; i < cardinality; ++i)   answer.content[outPos++]=content[i];
  answer.cardinality=newCardinality;
  return answer;
}","@Override public Container not(final int firstOfRange,final int lastOfRange){
  if (firstOfRange >= lastOfRange) {
    return clone();
  }
  int startIndex=Util.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=Util.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 2;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (newCardinality > DEFAULT_MAX_SIZE)   return toBitmapContainer().not(firstOfRange,lastOfRange);
  ArrayContainer answer=new ArrayContainer(newCardinality);
  System.arraycopy(content,0,answer.content,0,startIndex);
  int outPos=startIndex;
  int inPos=startIndex;
  int valInRange=firstOfRange;
  for (; valInRange < lastOfRange && inPos <= lastIndex; ++valInRange) {
    if ((short)valInRange != content[inPos]) {
      answer.content[outPos++]=(short)valInRange;
    }
 else {
      ++inPos;
    }
  }
  for (; valInRange < lastOfRange; ++valInRange) {
    answer.content[outPos++]=(short)valInRange;
  }
  for (int i=lastIndex + 1; i < cardinality; ++i)   answer.content[outPos++]=content[i];
  answer.cardinality=newCardinality;
  return answer;
}"
90289,"@Override public Container add(int begin,int end){
  int indexstart=Util.unsignedBinarySearch(content,0,cardinality,(short)begin);
  if (indexstart < 0)   indexstart=-indexstart - 1;
  int indexend=Util.unsignedBinarySearch(content,0,cardinality,(short)(end - 1));
  if (indexend < 0)   indexend=-indexend - 1;
 else   indexend++;
  int rangelength=end - begin;
  int newcardinality=indexstart + (cardinality - indexend) + rangelength;
  if (newcardinality >= DEFAULT_MAX_SIZE) {
    BitmapContainer a=this.toBitmapContainer();
    return a.iadd(begin,end);
  }
  ArrayContainer answer=new ArrayContainer(newcardinality,content);
  System.arraycopy(content,indexend,answer.content,indexstart + rangelength,cardinality - indexend);
  for (int k=0; k < rangelength; ++k) {
    answer.content[k + indexstart]=(short)(begin + k);
  }
  answer.cardinality=newcardinality;
  return answer;
}","@Override public Container add(int begin,int end){
  int indexstart=Util.unsignedBinarySearch(content,0,cardinality,(short)begin);
  if (indexstart < 0)   indexstart=-indexstart - 1;
  int indexend=Util.unsignedBinarySearch(content,0,cardinality,(short)(end - 1));
  if (indexend < 0)   indexend=-indexend - 1;
 else   indexend++;
  int rangelength=end - begin;
  int newcardinality=indexstart + (cardinality - indexend) + rangelength;
  if (newcardinality > DEFAULT_MAX_SIZE) {
    BitmapContainer a=this.toBitmapContainer();
    return a.iadd(begin,end);
  }
  ArrayContainer answer=new ArrayContainer(newcardinality,content);
  System.arraycopy(content,indexend,answer.content,indexstart + rangelength,cardinality - indexend);
  for (int k=0; k < rangelength; ++k) {
    answer.content[k + indexstart]=(short)(begin + k);
  }
  answer.cardinality=newcardinality;
  return answer;
}"
90290,"@Override public Container iadd(int begin,int end){
  int indexstart=Util.unsignedBinarySearch(content,0,cardinality,(short)begin);
  if (indexstart < 0)   indexstart=-indexstart - 1;
  int indexend=Util.unsignedBinarySearch(content,0,cardinality,(short)(end - 1));
  if (indexend < 0)   indexend=-indexend - 1;
 else   indexend++;
  int rangelength=end - begin;
  int newcardinality=indexstart + (cardinality - indexend) + rangelength;
  if (newcardinality >= DEFAULT_MAX_SIZE) {
    BitmapContainer a=this.toBitmapContainer();
    return a.iadd(begin,end);
  }
  if (newcardinality >= this.content.length)   increaseCapacity(newcardinality);
  System.arraycopy(content,indexend,content,indexstart + rangelength,cardinality - indexend);
  for (int k=0; k < rangelength; ++k) {
    content[k + indexstart]=(short)(begin + k);
  }
  cardinality=newcardinality;
  return this;
}","@Override public Container iadd(int begin,int end){
  int indexstart=Util.unsignedBinarySearch(content,0,cardinality,(short)begin);
  if (indexstart < 0)   indexstart=-indexstart - 1;
  int indexend=Util.unsignedBinarySearch(content,0,cardinality,(short)(end - 1));
  if (indexend < 0)   indexend=-indexend - 1;
 else   indexend++;
  int rangelength=end - begin;
  int newcardinality=indexstart + (cardinality - indexend) + rangelength;
  if (newcardinality > DEFAULT_MAX_SIZE) {
    BitmapContainer a=this.toBitmapContainer();
    return a.iadd(begin,end);
  }
  if (newcardinality >= this.content.length)   increaseCapacity(newcardinality);
  System.arraycopy(content,indexend,content,indexstart + rangelength,cardinality - indexend);
  for (int k=0; k < rangelength; ++k) {
    content[k + indexstart]=(short)(begin + k);
  }
  cardinality=newcardinality;
  return this;
}"
90291,"@Override public Container inot(final int firstOfRange,final int lastOfRange){
  int startIndex=Util.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=Util.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 1 - 1;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final short[] buffer=new short[newValuesInRange];
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (cardinalityChange > 0) {
    if (newCardinality > content.length) {
      if (newCardinality >= DEFAULT_MAX_SIZE)       return toBitmapContainer().inot(firstOfRange,lastOfRange);
      content=Arrays.copyOf(content,newCardinality);
    }
    System.arraycopy(content,lastIndex + 1,content,lastIndex + 1 + cardinalityChange,cardinality - 1 - lastIndex);
    negateRange(buffer,startIndex,lastIndex,firstOfRange,lastOfRange);
  }
 else {
    negateRange(buffer,startIndex,lastIndex,firstOfRange,lastOfRange);
    if (cardinalityChange < 0) {
      System.arraycopy(content,startIndex + newValuesInRange - cardinalityChange,content,startIndex + newValuesInRange,newCardinality - (startIndex + newValuesInRange));
    }
  }
  cardinality=newCardinality;
  return this;
}","@Override public Container inot(final int firstOfRange,final int lastOfRange){
  int startIndex=Util.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=Util.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 1 - 1;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final short[] buffer=new short[newValuesInRange];
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (cardinalityChange > 0) {
    if (newCardinality > content.length) {
      if (newCardinality > DEFAULT_MAX_SIZE)       return toBitmapContainer().inot(firstOfRange,lastOfRange);
      content=Arrays.copyOf(content,newCardinality);
    }
    System.arraycopy(content,lastIndex + 1,content,lastIndex + 1 + cardinalityChange,cardinality - 1 - lastIndex);
    negateRange(buffer,startIndex,lastIndex,firstOfRange,lastOfRange);
  }
 else {
    negateRange(buffer,startIndex,lastIndex,firstOfRange,lastOfRange);
    if (cardinalityChange < 0) {
      System.arraycopy(content,startIndex + newValuesInRange - cardinalityChange,content,startIndex + newValuesInRange,newCardinality - (startIndex + newValuesInRange));
    }
  }
  cardinality=newCardinality;
  return this;
}"
90292,"@Override public Container iremove(int begin,int end){
  Util.resetBitmapRange(bitmap,begin,end);
  computeCardinality();
  if (getCardinality() < ArrayContainer.DEFAULT_MAX_SIZE)   return toArrayContainer();
  return this;
}","@Override public Container iremove(int begin,int end){
  Util.resetBitmapRange(bitmap,begin,end);
  computeCardinality();
  if (getCardinality() <= ArrayContainer.DEFAULT_MAX_SIZE)   return toArrayContainer();
  return this;
}"
90293,"@Override public MappeableContainer not(final int firstOfRange,final int lastOfRange){
  if (firstOfRange >= lastOfRange) {
    return clone();
  }
  int startIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 2;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (newCardinality >= DEFAULT_MAX_SIZE)   return toBitmapContainer().not(firstOfRange,lastOfRange);
  final MappeableArrayContainer answer=new MappeableArrayContainer(newCardinality);
  short[] sarray=answer.content.array();
  for (int i=0; i < startIndex; ++i)   sarray[i]=content.get(i);
  int outPos=startIndex;
  int inPos=startIndex;
  int valInRange=firstOfRange;
  for (; valInRange < lastOfRange && inPos <= lastIndex; ++valInRange) {
    if ((short)valInRange != content.get(inPos))     sarray[outPos++]=(short)valInRange;
 else {
      ++inPos;
    }
  }
  for (; valInRange < lastOfRange; ++valInRange) {
    answer.content.put(outPos++,(short)valInRange);
  }
  for (int i=lastIndex + 1; i < cardinality; ++i)   answer.content.put(outPos++,content.get(i));
  answer.cardinality=newCardinality;
  return answer;
}","@Override public MappeableContainer not(final int firstOfRange,final int lastOfRange){
  if (firstOfRange >= lastOfRange) {
    return clone();
  }
  int startIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 2;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (newCardinality > DEFAULT_MAX_SIZE)   return toBitmapContainer().not(firstOfRange,lastOfRange);
  final MappeableArrayContainer answer=new MappeableArrayContainer(newCardinality);
  short[] sarray=answer.content.array();
  for (int i=0; i < startIndex; ++i)   sarray[i]=content.get(i);
  int outPos=startIndex;
  int inPos=startIndex;
  int valInRange=firstOfRange;
  for (; valInRange < lastOfRange && inPos <= lastIndex; ++valInRange) {
    if ((short)valInRange != content.get(inPos))     sarray[outPos++]=(short)valInRange;
 else {
      ++inPos;
    }
  }
  for (; valInRange < lastOfRange; ++valInRange) {
    answer.content.put(outPos++,(short)valInRange);
  }
  for (int i=lastIndex + 1; i < cardinality; ++i)   answer.content.put(outPos++,content.get(i));
  answer.cardinality=newCardinality;
  return answer;
}"
90294,"@Override public MappeableContainer add(int begin,int end){
  int indexstart=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)begin);
  if (indexstart < 0)   indexstart=-indexstart - 1;
  int indexend=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(end - 1));
  if (indexend < 0)   indexend=-indexend - 1;
 else   indexend++;
  int rangelength=end - begin;
  int newcardinality=indexstart + (cardinality - indexend) + rangelength;
  if (newcardinality >= DEFAULT_MAX_SIZE) {
    MappeableBitmapContainer a=this.toBitmapContainer();
    return a.iadd(begin,end);
  }
  MappeableArrayContainer answer=new MappeableArrayContainer(newcardinality,content);
  BufferUtil.arraycopy(content,indexend,answer.content,indexstart + rangelength,cardinality - indexend);
  short[] answerarray=answer.content.array();
  for (int k=0; k < rangelength; ++k) {
    answerarray[k + indexstart]=(short)(begin + k);
  }
  answer.cardinality=newcardinality;
  return answer;
}","@Override public MappeableContainer add(int begin,int end){
  int indexstart=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)begin);
  if (indexstart < 0)   indexstart=-indexstart - 1;
  int indexend=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(end - 1));
  if (indexend < 0)   indexend=-indexend - 1;
 else   indexend++;
  int rangelength=end - begin;
  int newcardinality=indexstart + (cardinality - indexend) + rangelength;
  if (newcardinality > DEFAULT_MAX_SIZE) {
    MappeableBitmapContainer a=this.toBitmapContainer();
    return a.iadd(begin,end);
  }
  MappeableArrayContainer answer=new MappeableArrayContainer(newcardinality,content);
  BufferUtil.arraycopy(content,indexend,answer.content,indexstart + rangelength,cardinality - indexend);
  short[] answerarray=answer.content.array();
  for (int k=0; k < rangelength; ++k) {
    answerarray[k + indexstart]=(short)(begin + k);
  }
  answer.cardinality=newcardinality;
  return answer;
}"
90295,"@Override public MappeableContainer iadd(int begin,int end){
  int indexstart=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)begin);
  if (indexstart < 0)   indexstart=-indexstart - 1;
  int indexend=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(end - 1));
  if (indexend < 0)   indexend=-indexend - 1;
 else   indexend++;
  int rangelength=end - begin;
  int newcardinality=indexstart + (cardinality - indexend) + rangelength;
  if (newcardinality >= DEFAULT_MAX_SIZE) {
    MappeableBitmapContainer a=this.toBitmapContainer();
    return a.iadd(begin,end);
  }
  if (newcardinality >= this.content.limit())   increaseCapacity(newcardinality);
  BufferUtil.arraycopy(content,indexend,content,indexstart + rangelength,cardinality - indexend);
  if (BufferUtil.isBackedBySimpleArray(content)) {
    short[] contentarray=content.array();
    for (int k=0; k < rangelength; ++k) {
      contentarray[k + indexstart]=(short)(begin + k);
    }
  }
 else {
    for (int k=0; k < rangelength; ++k) {
      content.put(k + indexstart,(short)(begin + k));
    }
  }
  cardinality=newcardinality;
  return this;
}","@Override public MappeableContainer iadd(int begin,int end){
  int indexstart=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)begin);
  if (indexstart < 0)   indexstart=-indexstart - 1;
  int indexend=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(end - 1));
  if (indexend < 0)   indexend=-indexend - 1;
 else   indexend++;
  int rangelength=end - begin;
  int newcardinality=indexstart + (cardinality - indexend) + rangelength;
  if (newcardinality > DEFAULT_MAX_SIZE) {
    MappeableBitmapContainer a=this.toBitmapContainer();
    return a.iadd(begin,end);
  }
  if (newcardinality >= this.content.limit())   increaseCapacity(newcardinality);
  BufferUtil.arraycopy(content,indexend,content,indexstart + rangelength,cardinality - indexend);
  if (BufferUtil.isBackedBySimpleArray(content)) {
    short[] contentarray=content.array();
    for (int k=0; k < rangelength; ++k) {
      contentarray[k + indexstart]=(short)(begin + k);
    }
  }
 else {
    for (int k=0; k < rangelength; ++k) {
      content.put(k + indexstart,(short)(begin + k));
    }
  }
  cardinality=newcardinality;
  return this;
}"
90296,"@Override public MappeableContainer inot(final int firstOfRange,final int lastOfRange){
  int startIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 1 - 1;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final ShortBuffer buffer=ShortBuffer.allocate(newValuesInRange);
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (cardinalityChange > 0) {
    if (newCardinality > content.limit()) {
      if (newCardinality >= DEFAULT_MAX_SIZE)       return toBitmapContainer().inot(firstOfRange,lastOfRange);
      final ShortBuffer co=ShortBuffer.allocate(newCardinality);
      content.rewind();
      co.put(content);
      content=co;
    }
    for (int pos=cardinality - 1; pos > lastIndex; --pos)     content.put(pos + cardinalityChange,content.get(pos));
    negateRange(buffer,startIndex,lastIndex,firstOfRange,lastOfRange);
  }
 else {
    negateRange(buffer,startIndex,lastIndex,firstOfRange,lastOfRange);
    if (cardinalityChange < 0)     for (int i=startIndex + newValuesInRange; i < newCardinality; ++i)     content.put(i,content.get(i - cardinalityChange));
  }
  cardinality=newCardinality;
  return this;
}","@Override public MappeableContainer inot(final int firstOfRange,final int lastOfRange){
  int startIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 1 - 1;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final ShortBuffer buffer=ShortBuffer.allocate(newValuesInRange);
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (cardinalityChange > 0) {
    if (newCardinality > content.limit()) {
      if (newCardinality > DEFAULT_MAX_SIZE)       return toBitmapContainer().inot(firstOfRange,lastOfRange);
      final ShortBuffer co=ShortBuffer.allocate(newCardinality);
      content.rewind();
      co.put(content);
      content=co;
    }
    for (int pos=cardinality - 1; pos > lastIndex; --pos)     content.put(pos + cardinalityChange,content.get(pos));
    negateRange(buffer,startIndex,lastIndex,firstOfRange,lastOfRange);
  }
 else {
    negateRange(buffer,startIndex,lastIndex,firstOfRange,lastOfRange);
    if (cardinalityChange < 0)     for (int i=startIndex + newValuesInRange; i < newCardinality; ++i)     content.put(i,content.get(i - cardinalityChange));
  }
  cardinality=newCardinality;
  return this;
}"
90297,"/** 
 * Computes the bitwise OR of this container with another (union). This container as well as the provided container are left unaffected.
 * @param x other parameter
 * @return aggregated container
 */
public Container xor(Container x){
  if (x instanceof ArrayContainer)   return xor((ArrayContainer)x);
  return xor((BitmapContainer)x);
}","/** 
 * Computes the bitwise XOR of this container with another (symmetric difference). This container as well as the provided container are left unaffected.
 * @param x other parameter
 * @return aggregated container
 */
public Container xor(Container x){
  if (x instanceof ArrayContainer)   return xor((ArrayContainer)x);
  return xor((BitmapContainer)x);
}"
90298,"/** 
 * Computes the in-place bitwise OR of this container with another (union). The current container is generally modified, whereas the provided container (x) is unaffected. May generate a new container.
 * @param x other container
 * @return aggregated container
 */
public Container ixor(Container x){
  if (x instanceof ArrayContainer)   return ixor((ArrayContainer)x);
  return ixor((BitmapContainer)x);
}","/** 
 * Computes the in-place bitwise XOR of this container with another (symmetric difference). The current container is generally modified, whereas the provided container (x) is unaffected. May generate a new container.
 * @param x other container
 * @return aggregated container
 */
public Container ixor(Container x){
  if (x instanceof ArrayContainer)   return ixor((ArrayContainer)x);
  return ixor((BitmapContainer)x);
}"
90299,"/** 
 * Computes the bitwise OR of this container with another (union). This container as well as the provided container are left unaffected.
 * @param x other parameter
 * @return aggregated container
 */
public MappeableContainer xor(MappeableContainer x){
  if (x instanceof MappeableArrayContainer)   return xor((MappeableArrayContainer)x);
  return xor((MappeableBitmapContainer)x);
}","/** 
 * Computes the bitwise XOR of this container with another (symmetric difference). This container as well as the provided container are left unaffected.
 * @param x other parameter
 * @return aggregated container
 */
public MappeableContainer xor(MappeableContainer x){
  if (x instanceof MappeableArrayContainer)   return xor((MappeableArrayContainer)x);
  return xor((MappeableBitmapContainer)x);
}"
90300,"/** 
 * Computes the in-place bitwise OR of this container with another (union). The current container is generally modified, whereas the provided container (x) is unaffected. May generate a new container.
 * @param x other container
 * @return aggregated container
 */
public MappeableContainer ixor(MappeableContainer x){
  if (x instanceof MappeableArrayContainer)   return ixor((MappeableArrayContainer)x);
 else   return ixor((MappeableBitmapContainer)x);
}","/** 
 * Computes the in-place bitwise XOR of this container with another (symmetric difference). The current container is generally modified, whereas the provided container (x) is unaffected. May generate a new container.
 * @param x other container
 * @return aggregated container
 */
public MappeableContainer ixor(MappeableContainer x){
  if (x instanceof MappeableArrayContainer)   return ixor((MappeableArrayContainer)x);
 else   return ixor((MappeableBitmapContainer)x);
}"
90301,"@Override public MappeableContainer inot(final int firstOfRange,final int lastOfRange){
  int startIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)lastOfRange);
  if (lastIndex < 0)   lastIndex=-lastIndex - 1 - 1;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange + 1;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final ShortBuffer buffer=ShortBuffer.allocate(newValuesInRange);
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (cardinalityChange > 0) {
    if (newCardinality > content.limit()) {
      if (newCardinality >= DEFAULT_MAX_SIZE)       return toBitmapContainer().inot(firstOfRange,lastOfRange);
      final ShortBuffer co=ShortBuffer.allocate(newCardinality);
      content.rewind();
      co.put(content);
      content=co;
    }
    for (int pos=cardinality - 1; pos > lastIndex; --pos)     content.put(pos + cardinalityChange,content.get(pos));
    negateRange(buffer,startIndex,lastIndex,firstOfRange,lastOfRange);
  }
 else {
    negateRange(buffer,startIndex,lastIndex,firstOfRange,lastOfRange);
    if (cardinalityChange < 0)     for (int i=startIndex + newValuesInRange; i < newCardinality; ++i)     content.put(i,content.get(i - cardinalityChange));
  }
  cardinality=newCardinality;
  return this;
}","@Override public MappeableContainer inot(final int firstOfRange,final int lastOfRange){
  int startIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 1 - 1;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final ShortBuffer buffer=ShortBuffer.allocate(newValuesInRange);
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (cardinalityChange > 0) {
    if (newCardinality > content.limit()) {
      if (newCardinality >= DEFAULT_MAX_SIZE)       return toBitmapContainer().inot(firstOfRange,lastOfRange);
      final ShortBuffer co=ShortBuffer.allocate(newCardinality);
      content.rewind();
      co.put(content);
      content=co;
    }
    for (int pos=cardinality - 1; pos > lastIndex; --pos)     content.put(pos + cardinalityChange,content.get(pos));
    negateRange(buffer,startIndex,lastIndex,firstOfRange,lastOfRange);
  }
 else {
    negateRange(buffer,startIndex,lastIndex,firstOfRange,lastOfRange);
    if (cardinalityChange < 0)     for (int i=startIndex + newValuesInRange; i < newCardinality; ++i)     content.put(i,content.get(i - cardinalityChange));
  }
  cardinality=newCardinality;
  return this;
}"
90302,"@Override public MappeableContainer flip(short i){
  final int x=BufferUtil.toIntUnsigned(i);
  if (cardinality == MappeableArrayContainer.DEFAULT_MAX_SIZE + 1) {
    if ((bitmap.get(x / 64) & (1l << x)) != 0) {
      --cardinality;
      bitmap.put(x / 64,bitmap.get(x / 64) & ~(1l << x));
      return this.toArrayContainer();
    }
  }
  cardinality+=2 * ((bitmap.get(x / 64) ^ (1l << x)) >>> x) - 1;
  bitmap.put(x / 64,bitmap.get(x / 64) ^ (1l << x));
  return this;
}","@Override public MappeableContainer flip(short i){
  final int x=BufferUtil.toIntUnsigned(i);
  if (cardinality == MappeableArrayContainer.DEFAULT_MAX_SIZE + 1) {
    if ((bitmap.get(x / 64) & (1l << x)) != 0) {
      --cardinality;
      bitmap.put(x / 64,bitmap.get(x / 64) & ~(1l << x));
      return this.toArrayContainer();
    }
  }
  cardinality+=1 - 2 * ((bitmap.get(x / 64) & (1l << x)) >>> x);
  bitmap.put(x / 64,bitmap.get(x / 64) ^ (1l << x));
  return this;
}"
90303,"/** 
 * Create a container initialized with a range of consecutive values
 * @param start first index
 * @param last last index (range in exclusive)
 * @return a new container initialized with the specified values
 */
public static MappeableContainer rangeOfOnes(final int start,final int last){
  if (last - start > MappeableArrayContainer.DEFAULT_MAX_SIZE)   return new MappeableBitmapContainer(start,last);
  return new MappeableArrayContainer(start,last);
}","/** 
 * Create a container initialized with a range of consecutive values
 * @param start first index
 * @param last last index (range is exclusive)
 * @return a new container initialized with the specified values
 */
public static MappeableContainer rangeOfOnes(final int start,final int last){
  if (last - start > MappeableArrayContainer.DEFAULT_MAX_SIZE)   return new MappeableBitmapContainer(start,last);
  return new MappeableArrayContainer(start,last);
}"
90304,"/** 
 * Modifies the current bitmap by complementing the bits in the given range, from rangeStart (inclusive) rangeEnd (exclusive).
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 */
public void flip(final int rangeStart,final int rangeEnd){
  if (rangeStart >= rangeEnd)   return;
  final int hbStart=BufferUtil.toIntUnsigned(BufferUtil.highbits(rangeStart));
  final int lbStart=BufferUtil.toIntUnsigned(BufferUtil.lowbits(rangeStart));
  final int hbLast=BufferUtil.toIntUnsigned(BufferUtil.highbits(rangeEnd - 1));
  final int lbLast=BufferUtil.toIntUnsigned(BufferUtil.lowbits(rangeEnd - 1));
  final int max=BufferUtil.toIntUnsigned(BufferUtil.maxLowBit());
  for (int hb=hbStart; hb <= hbLast; ++hb) {
    final int containerStart=(hb == hbStart) ? lbStart : 0;
    final int containerLast=(hb == hbLast) ? lbLast : max;
    final int i=highLowContainer.getIndex((short)hb);
    if (i >= 0) {
      final MappeableContainer c=highLowContainer.getContainerAtIndex(i).inot(containerStart,containerLast);
      if (c.getCardinality() > 0)       getMappeableRoaringArray().setContainerAtIndex(i,c);
 else       getMappeableRoaringArray().removeAtIndex(i);
    }
 else {
      getMappeableRoaringArray().insertNewKeyValueAt(-i - 1,(short)hb,MappeableContainer.rangeOfOnes(containerStart,containerLast + 1));
    }
  }
}","/** 
 * Modifies the current bitmap by complementing the bits in the given range, from rangeStart (inclusive) rangeEnd (exclusive).
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd exclusive ending of range
 */
public void flip(final int rangeStart,final int rangeEnd){
  if (rangeStart >= rangeEnd)   return;
  final int hbStart=BufferUtil.toIntUnsigned(BufferUtil.highbits(rangeStart));
  final int lbStart=BufferUtil.toIntUnsigned(BufferUtil.lowbits(rangeStart));
  final int hbLast=BufferUtil.toIntUnsigned(BufferUtil.highbits(rangeEnd - 1));
  final int lbLast=BufferUtil.toIntUnsigned(BufferUtil.lowbits(rangeEnd - 1));
  final int max=BufferUtil.toIntUnsigned(BufferUtil.maxLowBit());
  for (int hb=hbStart; hb <= hbLast; ++hb) {
    final int containerStart=(hb == hbStart) ? lbStart : 0;
    final int containerLast=(hb == hbLast) ? lbLast : max;
    final int i=highLowContainer.getIndex((short)hb);
    if (i >= 0) {
      final MappeableContainer c=highLowContainer.getContainerAtIndex(i).inot(containerStart,containerLast + 1);
      if (c.getCardinality() > 0)       getMappeableRoaringArray().setContainerAtIndex(i,c);
 else       getMappeableRoaringArray().removeAtIndex(i);
    }
 else {
      getMappeableRoaringArray().insertNewKeyValueAt(-i - 1,(short)hb,MappeableContainer.rangeOfOnes(containerStart,containerLast + 1));
    }
  }
}"
90305,"@Test public void notTest9(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(0,65200);
  assertTrue(c1 instanceof MappeableBitmapContainer);
  assertEquals(32438,c1.getCardinality());
  final MappeableContainer c2=c1.not(0,65200);
  assertTrue(c2 instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c2,content));
}","@Test public void notTest9(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(0,65201);
  assertTrue(c1 instanceof MappeableBitmapContainer);
  assertEquals(32438,c1.getCardinality());
  final MappeableContainer c2=c1.not(0,65201);
  assertTrue(c2 instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c2,content));
}"
90306,"@Test public void inotTest10(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[3];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.inot(65190,65200);
  assertTrue(c1 instanceof MappeableArrayContainer);
  assertEquals(14,c1.getCardinality());
  assertTrue(checkContent(c1,new short[]{0,2,4,(short)65190,(short)65191,(short)65192,(short)65193,(short)65194,(short)65195,(short)65196,(short)65197,(short)65198,(short)65199,(short)65200}));
}","@Test public void inotTest10(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[3];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.inot(65190,65201);
  assertTrue(c1 instanceof MappeableArrayContainer);
  assertEquals(14,c1.getCardinality());
  assertTrue(checkContent(c1,new short[]{0,2,4,(short)65190,(short)65191,(short)65192,(short)65193,(short)65194,(short)65195,(short)65196,(short)65197,(short)65198,(short)65199,(short)65200}));
}"
90307,"@Test public void notTest7(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(5,31000);
  if (c1.getCardinality() <= MappeableArrayContainer.DEFAULT_MAX_SIZE)   assertTrue(c1 instanceof MappeableArrayContainer);
 else   assertTrue(c1 instanceof MappeableBitmapContainer);
  assertEquals(1773,c1.getCardinality());
  final MappeableContainer c2=c1.not(5,31000);
  if (c2.getCardinality() <= MappeableArrayContainer.DEFAULT_MAX_SIZE)   assertTrue(c2 instanceof MappeableArrayContainer);
 else   assertTrue(c2 instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c2,content));
}","@Test public void notTest7(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(5,31001);
  if (c1.getCardinality() <= MappeableArrayContainer.DEFAULT_MAX_SIZE)   assertTrue(c1 instanceof MappeableArrayContainer);
 else   assertTrue(c1 instanceof MappeableBitmapContainer);
  assertEquals(1773,c1.getCardinality());
  final MappeableContainer c2=c1.not(5,31001);
  if (c2.getCardinality() <= MappeableArrayContainer.DEFAULT_MAX_SIZE)   assertTrue(c2 instanceof MappeableArrayContainer);
 else   assertTrue(c2 instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c2,content));
}"
90308,"@Test public void notTest8(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(4,65535);
  assertTrue(c1 instanceof MappeableBitmapContainer);
  assertEquals(32773,c1.getCardinality());
  final MappeableContainer c2=c1.not(4,65535);
  assertTrue(c2 instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c2,content));
}","@Test public void notTest8(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(4,65536);
  assertTrue(c1 instanceof MappeableBitmapContainer);
  assertEquals(32773,c1.getCardinality());
  final MappeableContainer c2=c1.not(4,65536);
  assertTrue(c2 instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c2,content));
}"
90309,"@Test public void notTest5(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(4,999);
  assertTrue(c1 instanceof MappeableBitmapContainer);
  assertEquals(31773,c1.getCardinality());
  final MappeableContainer c2=c1.not(4,999);
  assertTrue(c2 instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c2,content));
}","@Test public void notTest5(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(4,1000);
  assertTrue(c1 instanceof MappeableBitmapContainer);
  assertEquals(31773,c1.getCardinality());
  final MappeableContainer c2=c1.not(4,1000);
  assertTrue(c2 instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c2,content));
}"
90310,"@Test public void notTest6(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(4,8);
  assertTrue(c1 instanceof MappeableBitmapContainer);
  assertEquals(32762,c1.getCardinality());
  final MappeableContainer c2=c1.not(4,8);
  assertTrue(c2 instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c2,content));
}","@Test public void notTest6(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(4,9);
  assertTrue(c1 instanceof MappeableBitmapContainer);
  assertEquals(32762,c1.getCardinality());
  final MappeableContainer c2=c1.not(4,9);
  assertTrue(c2 instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c2,content));
}"
90311,"@Test public void inotTest4(){
  final short[] content={1,3,5,7,9};
  MappeableContainer c=makeContainer(content);
  c=c.inot(4,999);
  assertTrue(c instanceof MappeableArrayContainer);
  assertEquals(999 - 4 + 1 - 3 + 2,c.getCardinality());
  c=c.inot(4,999);
  assertTrue(checkContent(c,content));
}","@Test public void inotTest4(){
  final short[] content={1,3,5,7,9};
  MappeableContainer c=makeContainer(content);
  c=c.inot(4,1000);
  assertTrue(c instanceof MappeableArrayContainer);
  assertEquals(999 - 4 + 1 - 3 + 2,c.getCardinality());
  c=c.inot(4,1000);
  assertTrue(checkContent(c,content));
}"
90312,"@Test public void inotTest5(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  MappeableContainer c=makeContainer(content);
  c=c.inot(4,999);
  assertTrue(c instanceof MappeableBitmapContainer);
  assertEquals(31773,c.getCardinality());
  c=c.inot(4,999);
  assertTrue(c instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c,content));
}","@Test public void inotTest5(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  MappeableContainer c=makeContainer(content);
  c=c.inot(4,1000);
  assertTrue(c instanceof MappeableBitmapContainer);
  assertEquals(31773,c.getCardinality());
  c=c.inot(4,1000);
  assertTrue(c instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c,content));
}"
90313,"@Test public void inotTest6(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  MappeableContainer c=makeContainer(content);
  c=c.inot(4,8);
  assertTrue(c instanceof MappeableBitmapContainer);
  assertEquals(32762,c.getCardinality());
  c=c.inot(4,8);
  assertTrue(c instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c,content));
}","@Test public void inotTest6(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  MappeableContainer c=makeContainer(content);
  c=c.inot(4,9);
  assertTrue(c instanceof MappeableBitmapContainer);
  assertEquals(32762,c.getCardinality());
  c=c.inot(4,9);
  assertTrue(c instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c,content));
}"
90314,"@Test public void inotTest7(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  MappeableContainer c=makeContainer(content);
  c=c.inot(5,31000);
  if (c.getCardinality() <= MappeableArrayContainer.DEFAULT_MAX_SIZE)   assertTrue(c instanceof MappeableArrayContainer);
 else   assertTrue(c instanceof MappeableBitmapContainer);
  assertEquals(1773,c.getCardinality());
  c=c.inot(5,31000);
  if (c.getCardinality() <= MappeableArrayContainer.DEFAULT_MAX_SIZE)   assertTrue(c instanceof MappeableArrayContainer);
 else   assertTrue(c instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c,content));
}","@Test public void inotTest7(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[32768 - 5];
  content[0]=0;
  content[1]=2;
  content[2]=4;
  content[3]=6;
  content[4]=8;
  for (int i=10; i <= 32767; ++i)   content[i - 10 + 5]=(short)i;
  MappeableContainer c=makeContainer(content);
  c=c.inot(5,31001);
  if (c.getCardinality() <= MappeableArrayContainer.DEFAULT_MAX_SIZE)   assertTrue(c instanceof MappeableArrayContainer);
 else   assertTrue(c instanceof MappeableBitmapContainer);
  assertEquals(1773,c.getCardinality());
  c=c.inot(5,31001);
  if (c.getCardinality() <= MappeableArrayContainer.DEFAULT_MAX_SIZE)   assertTrue(c instanceof MappeableArrayContainer);
 else   assertTrue(c instanceof MappeableBitmapContainer);
  assertTrue(checkContent(c,content));
}"
90315,"@Test public void inotTest8(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[21];
  for (int i=0; i < 18; ++i)   content[i]=(short)i;
  content[18]=21;
  content[19]=22;
  content[20]=23;
  MappeableContainer c=makeContainer(content);
  c=c.inot(5,21);
  assertTrue(c instanceof MappeableArrayContainer);
  assertEquals(10,c.getCardinality());
  c=c.inot(5,21);
  assertTrue(c instanceof MappeableArrayContainer);
  assertTrue(checkContent(c,content));
}","@Test public void inotTest8(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[21];
  for (int i=0; i < 18; ++i)   content[i]=(short)i;
  content[18]=21;
  content[19]=22;
  content[20]=23;
  MappeableContainer c=makeContainer(content);
  c=c.inot(5,22);
  assertTrue(c instanceof MappeableArrayContainer);
  assertEquals(10,c.getCardinality());
  c=c.inot(5,22);
  assertTrue(c instanceof MappeableArrayContainer);
  assertTrue(checkContent(c,content));
}"
90316,"@Test public void notTest3(){
  MappeableContainer c=new MappeableArrayContainer();
  for (int i=0; i < 65536; i+=2)   c=c.add((short)i);
  final MappeableContainer c1=c.not(0,65535);
  assertTrue(c1.contains((short)3) && !c1.contains((short)4));
  assertEquals(32768,c1.getCardinality());
  final MappeableContainer c2=c1.not(0,65535);
  for (int i=0; i < 65536; i+=2)   assertTrue(c2.contains((short)i) && !c2.contains((short)(i + 1)));
}","@Test public void notTest3(){
  MappeableContainer c=new MappeableArrayContainer();
  for (int i=0; i < 65536; i+=2)   c=c.add((short)i);
  final MappeableContainer c1=c.not(0,65536);
  assertTrue(c1.contains((short)3) && !c1.contains((short)4));
  assertEquals(32768,c1.getCardinality());
  final MappeableContainer c2=c1.not(0,65536);
  for (int i=0; i < 65536; i+=2)   assertTrue(c2.contains((short)i) && !c2.contains((short)(i + 1)));
}"
90317,"@Test public void notTest4(){
  System.out.println(""String_Node_Str"");
  final short[] content={1,3,5,7,9};
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(4,999);
  assertTrue(c1 instanceof MappeableArrayContainer);
  assertEquals(999 - 4 + 1 - 3 + 2,c1.getCardinality());
  final MappeableContainer c2=c1.not(4,999);
  assertTrue(checkContent(c2,content));
}","@Test public void notTest4(){
  System.out.println(""String_Node_Str"");
  final short[] content={1,3,5,7,9};
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(4,1000);
  assertTrue(c1 instanceof MappeableArrayContainer);
  assertEquals(999 - 4 + 1 - 3 + 2,c1.getCardinality());
  final MappeableContainer c2=c1.not(4,1000);
  assertTrue(checkContent(c2,content));
}"
90318,"@Test public void notTest1(){
  final short[] content={1,3,5,7,9};
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(0,65535);
  final short[] s=new short[65536 - content.length];
  int pos=0;
  for (int i=0; i < 65536; ++i)   if (Arrays.binarySearch(content,(short)i) < 0)   s[pos++]=(short)i;
  assertTrue(checkContent(c1,s));
  assertTrue(checkContent(c,content));
}","@Test public void notTest1(){
  final short[] content={1,3,5,7,9};
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(0,65536);
  final short[] s=new short[65536 - content.length];
  int pos=0;
  for (int i=0; i < 65536; ++i)   if (Arrays.binarySearch(content,(short)i) < 0)   s[pos++]=(short)i;
  assertTrue(checkContent(c1,s));
  assertTrue(checkContent(c,content));
}"
90319,"@Test public void notTest11(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[40];
  for (int i=244; i <= 283; ++i)   content[i - 244]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(1,58);
  assertTrue(c1 instanceof MappeableArrayContainer);
  assertEquals(40 + 58,c1.getCardinality());
  final short[] rightAns=new short[98];
  for (int i=1; i <= 58; ++i)   rightAns[i - 1]=(short)i;
  for (int i=244; i <= 283; ++i)   rightAns[i - 244 + 58]=(short)i;
  assertTrue(checkContent(c1,rightAns));
}","@Test public void notTest11(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[40];
  for (int i=244; i <= 283; ++i)   content[i - 244]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(1,59);
  assertTrue(c1 instanceof MappeableArrayContainer);
  assertEquals(40 + 58,c1.getCardinality());
  final short[] rightAns=new short[98];
  for (int i=1; i <= 58; ++i)   rightAns[i - 1]=(short)i;
  for (int i=244; i <= 283; ++i)   rightAns[i - 244 + 58]=(short)i;
  assertTrue(checkContent(c1,rightAns));
}"
90320,"@Test public void inotTest1(){
  final short[] content={1,3,5,7,9};
  MappeableContainer c=makeContainer(content);
  c=c.inot(0,65535);
  final short[] s=new short[65536 - content.length];
  int pos=0;
  for (int i=0; i < 65536; ++i)   if (Arrays.binarySearch(content,(short)i) < 0)   s[pos++]=(short)i;
  assertTrue(checkContent(c,s));
}","@Test public void inotTest1(){
  final short[] content={1,3,5,7,9};
  MappeableContainer c=makeContainer(content);
  c=c.inot(0,65536);
  final short[] s=new short[65536 - content.length];
  int pos=0;
  for (int i=0; i < 65536; ++i)   if (Arrays.binarySearch(content,(short)i) < 0)   s[pos++]=(short)i;
  assertTrue(checkContent(c,s));
}"
90321,"@Test public void notTest10(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[40];
  for (int i=244; i <= 283; ++i)   content[i - 244]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(51413,51470);
  assertTrue(c1 instanceof MappeableArrayContainer);
  assertEquals(40 + 58,c1.getCardinality());
  final short[] rightAns=new short[98];
  for (int i=244; i <= 283; ++i)   rightAns[i - 244]=(short)i;
  for (int i=51413; i <= 51470; ++i)   rightAns[i - 51413 + 40]=(short)i;
  assertTrue(checkContent(c1,rightAns));
}","@Test public void notTest10(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[40];
  for (int i=244; i <= 283; ++i)   content[i - 244]=(short)i;
  final MappeableContainer c=makeContainer(content);
  final MappeableContainer c1=c.not(51413,51471);
  assertTrue(c1 instanceof MappeableArrayContainer);
  assertEquals(40 + 58,c1.getCardinality());
  final short[] rightAns=new short[98];
  for (int i=244; i <= 283; ++i)   rightAns[i - 244]=(short)i;
  for (int i=51413; i <= 51470; ++i)   rightAns[i - 51413 + 40]=(short)i;
  assertTrue(checkContent(c1,rightAns));
}"
90322,"@Test public void inotTest3(){
  MappeableContainer c=new MappeableArrayContainer();
  for (int i=0; i < 65536; i+=2)   c=c.add((short)i);
  c=c.inot(0,65535);
  assertTrue(c.contains((short)3) && !c.contains((short)4));
  assertEquals(32768,c.getCardinality());
  c=c.inot(0,65535);
  for (int i=0; i < 65536; i+=2)   assertTrue(c.contains((short)i) && !c.contains((short)(i + 1)));
}","@Test public void inotTest3(){
  MappeableContainer c=new MappeableArrayContainer();
  for (int i=0; i < 65536; i+=2)   c=c.add((short)i);
  c=c.inot(0,65536);
  assertTrue(c.contains((short)3) && !c.contains((short)4));
  assertEquals(32768,c.getCardinality());
  c=c.inot(0,65536);
  for (int i=0; i < 65536; i+=2)   assertTrue(c.contains((short)i) && !c.contains((short)(i + 1)));
}"
90323,"@Test public void serializationExample() throws IOException {
  File tmpfile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  tmpfile.deleteOnExit();
  final FileOutputStream fos=new FileOutputStream(tmpfile);
  MutableRoaringBitmap Bitmap=MutableRoaringBitmap.bitmapOf(0,2,55,64,1 << 30);
  System.out.println(""String_Node_Str"" + Bitmap);
  Bitmap.serialize(new DataOutputStream(fos));
  long totalcount=fos.getChannel().position();
  System.out.println(""String_Node_Str"" + totalcount + ""String_Node_Str"");
  fos.close();
  RandomAccessFile memoryMappedFile=new RandomAccessFile(tmpfile,""String_Node_Str"");
  ByteBuffer bb=memoryMappedFile.getChannel().map(FileChannel.MapMode.READ_ONLY,0,totalcount);
  ImmutableRoaringBitmap mapped=new ImmutableRoaringBitmap(bb);
  System.out.println(""String_Node_Str"" + mapped);
  if (!mapped.equals(Bitmap))   throw new RuntimeException(""String_Node_Str"");
  memoryMappedFile.close();
}","@Test public void serializationExample() throws IOException {
  File tmpfile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  tmpfile.deleteOnExit();
  final FileOutputStream fos=new FileOutputStream(tmpfile);
  MutableRoaringBitmap Bitmap=MutableRoaringBitmap.bitmapOf(0,2,55,64,1 << 30);
  System.out.println(""String_Node_Str"" + Bitmap);
  Bitmap.serialize(new DataOutputStream(fos));
  long totalcount=fos.getChannel().position();
  System.out.println(""String_Node_Str"" + totalcount + ""String_Node_Str"");
  fos.close();
  RandomAccessFile memoryMappedFile=new RandomAccessFile(tmpfile,""String_Node_Str"");
  ByteBuffer bb=memoryMappedFile.getChannel().map(FileChannel.MapMode.READ_ONLY,0,totalcount);
  ImmutableRoaringBitmap mapped=new ImmutableRoaringBitmap(bb);
  System.out.println(""String_Node_Str"" + mapped);
  memoryMappedFile.close();
  if (!mapped.equals(Bitmap))   throw new RuntimeException(""String_Node_Str"");
}"
90324,"@Test public void flipTestBigA(){
  final int numCases=1000;
  final BitSet bs=new BitSet();
  final Random r=new Random(3333);
  int checkTime=2;
  MutableRoaringBitmap rb1=new MutableRoaringBitmap(), rb2=null;
  for (int i=0; i < numCases; ++i) {
    final int start=r.nextInt(65536 * 20);
    int end=r.nextInt(65536 * 20);
    if (r.nextDouble() < 0.1)     end=start + r.nextInt(100);
    if ((i & 1) == 0) {
      rb2=MutableRoaringBitmap.flip(rb1,start,end);
      rb1.flip(r.nextInt(65536 * 20),r.nextInt(65536 * 20));
    }
 else {
      rb1=MutableRoaringBitmap.flip(rb2,start,end);
      rb2.flip(r.nextInt(65536 * 20),r.nextInt(65536 * 20));
    }
    if (start < end)     bs.flip(start,end);
    if (r.nextDouble() < 0.2 && (i & 1) == 0) {
      final MutableRoaringBitmap mask=new MutableRoaringBitmap();
      final BitSet mask1=new BitSet();
      final int startM=r.nextInt(65536 * 20);
      final int endM=startM + 100000;
      mask.flip(startM,endM);
      mask1.flip(startM,endM);
      mask.flip(0,65536 * 20 + 100000);
      mask1.flip(0,65536 * 20 + 100000);
      rb2.and(mask);
      bs.and(mask1);
    }
    if (i > checkTime) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ rb2.getCardinality());
      final MutableRoaringBitmap rb=(i & 1) == 0 ? rb2 : rb1;
      final boolean status=equals(bs,rb);
      Assert.assertTrue(status);
      checkTime*=1.5;
    }
  }
}","@Test public void flipTestBigA(){
  final int numCases=1000;
  final BitSet bs=new BitSet();
  final Random r=new Random(3333);
  int checkTime=2;
  MutableRoaringBitmap rb1=new MutableRoaringBitmap(), rb2=null;
  for (int i=0; i < numCases; ++i) {
    final int start=r.nextInt(65536 * 20);
    int end=r.nextInt(65536 * 20);
    if (r.nextDouble() < 0.1)     end=start + r.nextInt(100);
    if ((i & 1) == 0) {
      rb2=MutableRoaringBitmap.flip(rb1,start,end);
      int r1=r.nextInt(65536 * 20);
      int r2=r.nextInt(65536 * 20);
      rb1.flip(r1,r2);
    }
 else {
      rb1=MutableRoaringBitmap.flip(rb2,start,end);
      int r1=r.nextInt(65536 * 20);
      int r2=r.nextInt(65536 * 20);
      rb2.flip(r1,r2);
    }
    if (start < end)     bs.flip(start,end);
    if (r.nextDouble() < 0.2 && (i & 1) == 0) {
      final MutableRoaringBitmap mask=new MutableRoaringBitmap();
      final BitSet mask1=new BitSet();
      final int startM=r.nextInt(65536 * 20);
      final int endM=startM + 100000;
      mask.flip(startM,endM);
      mask1.flip(startM,endM);
      mask.flip(0,65536 * 20 + 100000);
      mask1.flip(0,65536 * 20 + 100000);
      rb2.and(mask);
      bs.and(mask1);
    }
    if (i > checkTime) {
      final MutableRoaringBitmap rb=(i & 1) == 0 ? rb2 : rb1;
      final boolean status=equals(bs,rb);
      Assert.assertTrue(status);
      checkTime*=1.5;
    }
  }
}"
90325,"@Override public Container not(final int firstOfRange,final int lastOfRange){
  if (firstOfRange > lastOfRange) {
    return clone();
  }
  int startIndex=Util.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=Util.unsignedBinarySearch(content,0,cardinality,(short)lastOfRange);
  if (lastIndex < 0)   lastIndex=-lastIndex - 2;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange + 1;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (newCardinality >= DEFAULT_MAX_SIZE)   return toBitmapContainer().not(firstOfRange,lastOfRange);
  ArrayContainer answer=new ArrayContainer(newCardinality);
  System.arraycopy(content,0,answer.content,0,startIndex);
  int outPos=startIndex;
  int inPos=startIndex;
  int valInRange=firstOfRange;
  for (; valInRange <= lastOfRange && inPos <= lastIndex; ++valInRange) {
    if ((short)valInRange != content[inPos]) {
      answer.content[outPos++]=(short)valInRange;
    }
 else {
      ++inPos;
    }
  }
  for (; valInRange <= lastOfRange; ++valInRange) {
    answer.content[outPos++]=(short)valInRange;
  }
  for (int i=lastIndex + 1; i < cardinality; ++i)   answer.content[outPos++]=content[i];
  answer.cardinality=newCardinality;
  return answer;
}","@Override public Container not(final int firstOfRange,final int lastOfRange){
  if (firstOfRange >= lastOfRange) {
    return clone();
  }
  int startIndex=Util.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=Util.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 2;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (newCardinality >= DEFAULT_MAX_SIZE)   return toBitmapContainer().not(firstOfRange,lastOfRange);
  ArrayContainer answer=new ArrayContainer(newCardinality);
  System.arraycopy(content,0,answer.content,0,startIndex);
  int outPos=startIndex;
  int inPos=startIndex;
  int valInRange=firstOfRange;
  for (; valInRange < lastOfRange && inPos <= lastIndex; ++valInRange) {
    if ((short)valInRange != content[inPos]) {
      answer.content[outPos++]=(short)valInRange;
    }
 else {
      ++inPos;
    }
  }
  for (; valInRange < lastOfRange; ++valInRange) {
    answer.content[outPos++]=(short)valInRange;
  }
  for (int i=lastIndex + 1; i < cardinality; ++i)   answer.content[outPos++]=content[i];
  answer.cardinality=newCardinality;
  return answer;
}"
90326,"@Override public Container flip(short i){
  final int x=Util.toIntUnsigned(i);
  if (cardinality == ArrayContainer.DEFAULT_MAX_SIZE + 1) {
    if ((bitmap[x / 64] & (1l << x)) != 0) {
      --cardinality;
      bitmap[x / 64]&=~(1l << x);
      return this.toArrayContainer();
    }
  }
  cardinality+=2 * ((bitmap[x / 64] ^ (1l << x)) >>> x) - 1;
  bitmap[x / 64]^=(1l << x);
  return this;
}","@Override public Container flip(short i){
  final int x=Util.toIntUnsigned(i);
  if (cardinality == ArrayContainer.DEFAULT_MAX_SIZE + 1) {
    if ((bitmap[x / 64] & (1l << x)) != 0) {
      --cardinality;
      bitmap[x / 64]&=~(1l << x);
      return this.toArrayContainer();
    }
  }
  cardinality+=1 - 2 * ((bitmap[x / 64] & (1l << x)) >>> x);
  bitmap[x / 64]^=(1l << x);
  return this;
}"
90327,"/** 
 * Modifies the current bitmap by complementing the bits in the given range, from rangeStart (inclusive) rangeEnd (exclusive).
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd   exclusive ending of range
 */
public void flip(final int rangeStart,final int rangeEnd){
  if (rangeStart >= rangeEnd)   return;
  final int hbStart=Util.toIntUnsigned(Util.highbits(rangeStart));
  final int lbStart=Util.toIntUnsigned(Util.lowbits(rangeStart));
  final int hbLast=Util.toIntUnsigned(Util.highbits(rangeEnd - 1));
  final int lbLast=Util.toIntUnsigned(Util.lowbits(rangeEnd - 1));
  final int max=Util.toIntUnsigned(Util.maxLowBit());
  for (int hb=hbStart; hb <= hbLast; ++hb) {
    final int containerStart=(hb == hbStart) ? lbStart : 0;
    final int containerLast=(hb == hbLast) ? lbLast : max;
    final int i=highLowContainer.getIndex((short)hb);
    if (i >= 0) {
      System.out.println(""String_Node_Str"" + containerStart + ""String_Node_Str""+ (containerLast + 1));
      final Container longway=highLowContainer.getContainerAtIndex(i).xor(Container.rangeOfOnes(containerStart,containerLast + 1));
      final Container c=highLowContainer.getContainerAtIndex(i).inot(containerStart,containerLast + 1);
      if (!c.equals(longway))       throw new RuntimeException(""String_Node_Str"");
      if (c.getCardinality() > 0)       highLowContainer.setContainerAtIndex(i,c);
 else       highLowContainer.removeAtIndex(i);
    }
 else {
      highLowContainer.insertNewKeyValueAt(-i - 1,(short)hb,Container.rangeOfOnes(containerStart,containerLast + 1));
    }
  }
}","/** 
 * Modifies the current bitmap by complementing the bits in the given range, from rangeStart (inclusive) rangeEnd (exclusive).
 * @param rangeStart inclusive beginning of range
 * @param rangeEnd   exclusive ending of range
 */
public void flip(final int rangeStart,final int rangeEnd){
  if (rangeStart >= rangeEnd)   return;
  final int hbStart=Util.toIntUnsigned(Util.highbits(rangeStart));
  final int lbStart=Util.toIntUnsigned(Util.lowbits(rangeStart));
  final int hbLast=Util.toIntUnsigned(Util.highbits(rangeEnd - 1));
  final int lbLast=Util.toIntUnsigned(Util.lowbits(rangeEnd - 1));
  final int max=Util.toIntUnsigned(Util.maxLowBit());
  for (int hb=hbStart; hb <= hbLast; ++hb) {
    final int containerStart=(hb == hbStart) ? lbStart : 0;
    final int containerLast=(hb == hbLast) ? lbLast : max;
    final int i=highLowContainer.getIndex((short)hb);
    if (i >= 0) {
      final Container c=highLowContainer.getContainerAtIndex(i).inot(containerStart,containerLast + 1);
      if (c.getCardinality() > 0)       highLowContainer.setContainerAtIndex(i,c);
 else       highLowContainer.removeAtIndex(i);
    }
 else {
      highLowContainer.insertNewKeyValueAt(-i - 1,(short)hb,Container.rangeOfOnes(containerStart,containerLast + 1));
    }
  }
}"
90328,"@Override public MappeableContainer not(final int firstOfRange,final int lastOfRange){
  if (firstOfRange > lastOfRange) {
    return clone();
  }
  int startIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)lastOfRange);
  if (lastIndex < 0)   lastIndex=-lastIndex - 2;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange + 1;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (newCardinality >= DEFAULT_MAX_SIZE)   return toBitmapContainer().not(firstOfRange,lastOfRange);
  final MappeableArrayContainer answer=new MappeableArrayContainer(newCardinality);
  short[] sarray=answer.content.array();
  for (int i=0; i < startIndex; ++i)   sarray[i]=content.get(i);
  int outPos=startIndex;
  int inPos=startIndex;
  int valInRange=firstOfRange;
  for (; valInRange <= lastOfRange && inPos <= lastIndex; ++valInRange) {
    if ((short)valInRange != content.get(inPos))     sarray[outPos++]=(short)valInRange;
 else {
      ++inPos;
    }
  }
  for (; valInRange <= lastOfRange; ++valInRange) {
    answer.content.put(outPos++,(short)valInRange);
  }
  for (int i=lastIndex + 1; i < cardinality; ++i)   answer.content.put(outPos++,content.get(i));
  answer.cardinality=newCardinality;
  return answer;
}","@Override public MappeableContainer not(final int firstOfRange,final int lastOfRange){
  if (firstOfRange >= lastOfRange) {
    return clone();
  }
  int startIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)firstOfRange);
  if (startIndex < 0)   startIndex=-startIndex - 1;
  int lastIndex=BufferUtil.unsignedBinarySearch(content,0,cardinality,(short)(lastOfRange - 1));
  if (lastIndex < 0)   lastIndex=-lastIndex - 2;
  final int currentValuesInRange=lastIndex - startIndex + 1;
  final int spanToBeFlipped=lastOfRange - firstOfRange;
  final int newValuesInRange=spanToBeFlipped - currentValuesInRange;
  final int cardinalityChange=newValuesInRange - currentValuesInRange;
  final int newCardinality=cardinality + cardinalityChange;
  if (newCardinality >= DEFAULT_MAX_SIZE)   return toBitmapContainer().not(firstOfRange,lastOfRange);
  final MappeableArrayContainer answer=new MappeableArrayContainer(newCardinality);
  short[] sarray=answer.content.array();
  for (int i=0; i < startIndex; ++i)   sarray[i]=content.get(i);
  int outPos=startIndex;
  int inPos=startIndex;
  int valInRange=firstOfRange;
  for (; valInRange < lastOfRange && inPos <= lastIndex; ++valInRange) {
    if ((short)valInRange != content.get(inPos))     sarray[outPos++]=(short)valInRange;
 else {
      ++inPos;
    }
  }
  for (; valInRange < lastOfRange; ++valInRange) {
    answer.content.put(outPos++,(short)valInRange);
  }
  for (int i=lastIndex + 1; i < cardinality; ++i)   answer.content.put(outPos++,content.get(i));
  answer.cardinality=newCardinality;
  return answer;
}"
90329,"@Test public void notTest4(){
  System.out.println(""String_Node_Str"");
  final short[] content={1,3,5,7,9};
  final Container c=makeContainer(content);
  final Container c1=c.not(4,999);
  assertTrue(c1 instanceof ArrayContainer);
  assertEquals(999 - 4 + 1 - 3 + 2,c1.getCardinality());
  final Container c2=c1.not(4,999);
  assertTrue(checkContent(c2,content));
}","@Test public void notTest4(){
  System.out.println(""String_Node_Str"");
  final short[] content={1,3,5,7,9};
  final Container c=makeContainer(content);
  final Container c1=c.not(4,1000);
  assertTrue(c1 instanceof ArrayContainer);
  assertEquals(999 - 4 + 1 - 3 + 2,c1.getCardinality());
  final Container c2=c1.not(4,1000);
  assertTrue(checkContent(c2,content));
}"
90330,"@Test public void notTest11(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[40];
  for (int i=244; i <= 283; ++i)   content[i - 244]=(short)i;
  final Container c=makeContainer(content);
  final Container c1=c.not(1,58);
  assertTrue(c1 instanceof ArrayContainer);
  assertEquals(40 + 58,c1.getCardinality());
  final short[] rightAns=new short[98];
  for (int i=1; i <= 58; ++i)   rightAns[i - 1]=(short)i;
  for (int i=244; i <= 283; ++i)   rightAns[i - 244 + 58]=(short)i;
  assertTrue(checkContent(c1,rightAns));
}","@Test public void notTest11(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[40];
  for (int i=244; i <= 283; ++i)   content[i - 244]=(short)i;
  final Container c=makeContainer(content);
  final Container c1=c.not(1,59);
  assertTrue(c1 instanceof ArrayContainer);
  assertEquals(40 + 58,c1.getCardinality());
  final short[] rightAns=new short[98];
  for (int i=1; i <= 58; ++i)   rightAns[i - 1]=(short)i;
  for (int i=244; i <= 283; ++i)   rightAns[i - 244 + 58]=(short)i;
  assertTrue(checkContent(c1,rightAns));
}"
90331,"@Test public void notTest10(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[40];
  for (int i=244; i <= 283; ++i)   content[i - 244]=(short)i;
  final Container c=makeContainer(content);
  final Container c1=c.not(51413,51470);
  assertTrue(c1 instanceof ArrayContainer);
  assertEquals(40 + 58,c1.getCardinality());
  final short[] rightAns=new short[98];
  for (int i=244; i <= 283; ++i)   rightAns[i - 244]=(short)i;
  for (int i=51413; i <= 51470; ++i)   rightAns[i - 51413 + 40]=(short)i;
  assertTrue(checkContent(c1,rightAns));
}","@Test public void notTest10(){
  System.out.println(""String_Node_Str"");
  final short[] content=new short[40];
  for (int i=244; i <= 283; ++i)   content[i - 244]=(short)i;
  final Container c=makeContainer(content);
  final Container c1=c.not(51413,51471);
  assertTrue(c1 instanceof ArrayContainer);
  assertEquals(40 + 58,c1.getCardinality());
  final short[] rightAns=new short[98];
  for (int i=244; i <= 283; ++i)   rightAns[i - 244]=(short)i;
  for (int i=51413; i <= 51470; ++i)   rightAns[i - 51413 + 40]=(short)i;
  assertTrue(checkContent(c1,rightAns));
}"
90332,"@Test public void flipTestBigA(){
  final int numCases=1000;
  final BitSet bs=new BitSet();
  final Random r=new Random(3333);
  int checkTime=2;
  RoaringBitmap rb1=new RoaringBitmap(), rb2=null;
  for (int i=0; i < numCases; ++i) {
    final int start=r.nextInt(65536 * 20);
    int end=r.nextInt(65536 * 20);
    if (r.nextDouble() < 0.1)     end=start + r.nextInt(100);
    if ((i & 1) == 0) {
      rb2=RoaringBitmap.flip(rb1,start,end);
      RoaringBitmap tmpsh=slowflip(rb1,start,end);
      assert(tmpsh.equals(rb2));
      rb1.flip(r.nextInt(65536 * 20),r.nextInt(65536 * 20));
    }
 else {
      rb1=RoaringBitmap.flip(rb2,start,end);
      RoaringBitmap tmpsh=slowflip(rb2,start,end);
      assert(tmpsh.equals(rb1));
      rb2.flip(r.nextInt(65536 * 20),r.nextInt(65536 * 20));
    }
    if (start < end)     bs.flip(start,end);
    if (r.nextDouble() < 0.2 && (i & 1) == 0) {
      final RoaringBitmap mask=new RoaringBitmap();
      final BitSet mask1=new BitSet();
      final int startM=r.nextInt(65536 * 20);
      final int endM=startM + 100000;
      mask.flip(startM,endM);
      mask1.flip(startM,endM);
      mask.flip(0,65536 * 20 + 100000);
      mask1.flip(0,65536 * 20 + 100000);
      rb2.and(mask);
      bs.and(mask1);
    }
    if (i > checkTime) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ rb2.getCardinality());
      final RoaringBitmap rb=(i & 1) == 0 ? rb2 : rb1;
      final boolean status=equals(bs,rb);
      Assert.assertTrue(status);
      checkTime*=1.5;
    }
  }
}","@Test public void flipTestBigA(){
  final int numCases=1000;
  final BitSet bs=new BitSet();
  final Random r=new Random(3333);
  int checkTime=2;
  RoaringBitmap rb1=new RoaringBitmap(), rb2=null;
  for (int i=0; i < numCases; ++i) {
    final int start=r.nextInt(65536 * 20);
    int end=r.nextInt(65536 * 20);
    if (r.nextDouble() < 0.1)     end=start + r.nextInt(100);
    if ((i & 1) == 0) {
      rb2=RoaringBitmap.flip(rb1,start,end);
      int r1=r.nextInt(65536 * 20);
      int r2=r.nextInt(65536 * 20);
      rb1.flip(r1,r2);
    }
 else {
      rb1=RoaringBitmap.flip(rb2,start,end);
      int r1=r.nextInt(65536 * 20);
      int r2=r.nextInt(65536 * 20);
      rb2.flip(r1,r2);
    }
    if (start < end) {
      bs.flip(start,end);
    }
    if (r.nextDouble() < 0.2 && (i & 1) == 0) {
      final RoaringBitmap mask=new RoaringBitmap();
      final BitSet mask1=new BitSet();
      final int startM=r.nextInt(65536 * 20);
      final int endM=startM + 100000;
      mask.flip(startM,endM);
      mask1.flip(startM,endM);
      mask.flip(0,65536 * 20 + 100000);
      mask1.flip(0,65536 * 20 + 100000);
      rb2.and(mask);
      bs.and(mask1);
    }
    if (i > checkTime) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ rb2.getCardinality());
      final RoaringBitmap rb=(i & 1) == 0 ? rb2 : rb1;
      final boolean status=equals(bs,rb);
      Assert.assertTrue(status);
      checkTime*=1.5;
    }
  }
}"
90333,"@Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public RoaringBitmap inplace_newand(){
  bitmap1.newand(bitmap2);
}","@Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public RoaringBitmap inplace_newand(){
  RoaringBitmap b1=bitmap1.clone();
  b1.newand(bitmap2);
  return b1;
}"
90334,"@Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public RoaringBitmap inplace_and(){
  bitmap1.and(bitmap2);
}","@Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public RoaringBitmap inplace_and(){
  RoaringBitmap b1=bitmap1.clone();
  b1.and(bitmap2);
  return b1;
}"
90335,"@Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public RoaringBitmap inplace_newand(){
  return bitmap1.clone().newand(bitmap2);
}","@Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public RoaringBitmap inplace_newand(){
  RoaringBitmap b1=bitmap1.clone();
  b1.newand(bitmap2);
  return b1;
}"
90336,"@Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public RoaringBitmap inplace_and(){
  return bitmap1.clone().and(bitmap2);
}","@Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public RoaringBitmap inplace_and(){
  RoaringBitmap b1=bitmap1.clone();
  b1.and(bitmap2);
  return b1;
}"
90337,"@Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public RoaringBitmap inplace_newand(){
  return bitmap1.clone().newand(bitmap2);
}","@Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public RoaringBitmap inplace_newand(){
  RoaringBitmap b1=bitmap1.clone();
  b1.newand(bitmap2);
  return b1;
}"
90338,"@Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public RoaringBitmap inplace_and(){
  return bitmap1.clone().and(bitmap2);
}","@Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) public RoaringBitmap inplace_and(){
  RoaringBitmap b1=bitmap1.clone();
  b1.and(bitmap2);
  return b1;
}"
90339,"@Override public Container limit(int maxcardinality){
  if (maxcardinality >= this.cardinality) {
    return clone();
  }
  if (maxcardinality <= MAX_CAPACITY) {
    ArrayContainer ac=new ArrayContainer(maxcardinality);
    int pos=0;
    for (int k=0; (ac.cardinality < maxcardinality) && (k < bitmap.length); ++k) {
      long bitset=bitmap[k];
      while ((ac.cardinality < maxcardinality) && (bitset != 0)) {
        long t=bitset & -bitset;
        ac.content[pos++]=(short)(k * 64 + Long.bitCount(t - 1));
        ac.cardinality++;
        bitset^=t;
      }
    }
    return ac;
  }
  BitmapContainer bc=new BitmapContainer(maxcardinality,this.bitmap);
  int s=Util.toIntUnsigned(select(maxcardinality));
  int usedwords=(s + 63) / 64;
  int todelete=this.bitmap.length - usedwords;
  for (int k=0; k < todelete; ++k)   bc.bitmap[bc.bitmap.length - 1 - k]=0;
  int lastword=s % 64;
  if (lastword != 0) {
    bc.bitmap[s / 64]=(bc.bitmap[s / 64] << (64 - lastword)) >> (64 - lastword);
  }
  return bc;
}","@Override public Container limit(int maxcardinality){
  if (maxcardinality >= this.cardinality) {
    return clone();
  }
  if (maxcardinality < ArrayContainer.DEFAULT_MAX_SIZE) {
    ArrayContainer ac=new ArrayContainer(maxcardinality);
    int pos=0;
    for (int k=0; (ac.cardinality < maxcardinality) && (k < bitmap.length); ++k) {
      long bitset=bitmap[k];
      while ((ac.cardinality < maxcardinality) && (bitset != 0)) {
        long t=bitset & -bitset;
        ac.content[pos++]=(short)(k * 64 + Long.bitCount(t - 1));
        ac.cardinality++;
        bitset^=t;
      }
    }
    return ac;
  }
  BitmapContainer bc=new BitmapContainer(maxcardinality,this.bitmap);
  int s=Util.toIntUnsigned(select(maxcardinality));
  int usedwords=(s + 63) / 64;
  int todelete=this.bitmap.length - usedwords;
  for (int k=0; k < todelete; ++k)   bc.bitmap[bc.bitmap.length - 1 - k]=0;
  int lastword=s % 64;
  if (lastword != 0) {
    bc.bitmap[s / 64]=(bc.bitmap[s / 64] << (64 - lastword)) >> (64 - lastword);
  }
  return bc;
}"
90340,"protected void resetBitmapRange(long[] bitmap,int start,int end){
  if (start == end)   return;
  int firstword=start / 64;
  int endword=(end - 1) / 64;
  bitmap[firstword]&=~(~0L << start);
  for (int i=firstword + 1; i < endword; i++)   bitmap[i]=0;
  bitmap[endword]&=~(~0L >>> -end);
}","protected static void resetBitmapRange(long[] bitmap,int start,int end){
  if (start == end)   return;
  int firstword=start / 64;
  int endword=(end - 1) / 64;
  if (firstword == endword) {
    bitmap[firstword]&=~((~0L << start) & (~0L >>> -end));
    return;
  }
  bitmap[firstword]&=~(~0L << start);
  for (int i=firstword + 1; i < endword; i++)   bitmap[i]=0;
  bitmap[endword]&=~(~0L >>> -end);
}"
90341,"protected void flipBitmapRange(long[] bitmap,int start,int end){
  if (start == end)   return;
  int firstword=start / 64;
  int endword=(end - 1) / 64;
  bitmap[firstword]^=~0L << start;
  for (int i=firstword + 1; i < endword; i++)   bitmap[i]=~bitmap[i];
  bitmap[endword]^=~0L >>> -end;
}","protected static void flipBitmapRange(long[] bitmap,int start,int end){
  if (start == end)   return;
  int firstword=start / 64;
  int endword=(end - 1) / 64;
  bitmap[firstword]^=~(~0L << start);
  ;
  for (int i=firstword; i < endword; i++)   bitmap[i]=~bitmap[i];
  bitmap[endword]^=~0L >>> -end;
}"
90342,"protected void setBitmapRange(long[] bitmap,int start,int end){
  if (start == end)   return;
  int firstword=start / 64;
  int endword=(end - 1) / 64;
  bitmap[firstword]|=~0L << start;
  for (int i=firstword + 1; i < endword; i++)   bitmap[i]=~0;
  bitmap[endword]|=~0L >>> -end;
}","protected static void setBitmapRange(long[] bitmap,int start,int end){
  if (start == end)   return;
  int firstword=start / 64;
  int endword=(end - 1) / 64;
  if (firstword == endword) {
    bitmap[firstword]|=(~0L << start) & (~0L >>> -end);
    return;
  }
  bitmap[firstword]|=~0L << start;
  for (int i=firstword + 1; i < endword; i++)   bitmap[i]=~0;
  bitmap[endword]|=~0L >>> -end;
}"
90343,"@Override public MappeableContainer limit(int maxcardinality){
  if (maxcardinality >= this.cardinality) {
    return clone();
  }
  if (maxcardinality <= MAX_CAPACITY) {
    MappeableArrayContainer ac=new MappeableArrayContainer(maxcardinality);
    int pos=0;
    short[] cont=ac.content.array();
    for (int k=0; (ac.cardinality < maxcardinality) && (k < bitmap.limit()); ++k) {
      long bitset=bitmap.get(k);
      while ((ac.cardinality < maxcardinality) && (bitset != 0)) {
        long t=bitset & -bitset;
        cont[pos++]=(short)(k * 64 + Long.bitCount(t - 1));
        ac.cardinality++;
        bitset^=t;
      }
    }
    return ac;
  }
  MappeableBitmapContainer bc=new MappeableBitmapContainer(maxcardinality,this.bitmap);
  int s=BufferUtil.toIntUnsigned(select(maxcardinality));
  int usedwords=(s + 63) / 64;
  int todelete=this.bitmap.limit() - usedwords;
  for (int k=0; k < todelete; ++k)   bc.bitmap.put(bc.bitmap.limit() - 1 - k,0);
  int lastword=s % 64;
  if (lastword != 0) {
    bc.bitmap.put(s / 64,(bc.bitmap.get(s / 64) << (64 - lastword)) >> (64 - lastword));
  }
  return bc;
}","@Override public MappeableContainer limit(int maxcardinality){
  if (maxcardinality >= this.cardinality) {
    return clone();
  }
  if (maxcardinality < MappeableArrayContainer.DEFAULT_MAX_SIZE) {
    MappeableArrayContainer ac=new MappeableArrayContainer(maxcardinality);
    int pos=0;
    short[] cont=ac.content.array();
    for (int k=0; (ac.cardinality < maxcardinality) && (k < bitmap.limit()); ++k) {
      long bitset=bitmap.get(k);
      while ((ac.cardinality < maxcardinality) && (bitset != 0)) {
        long t=bitset & -bitset;
        cont[pos++]=(short)(k * 64 + Long.bitCount(t - 1));
        ac.cardinality++;
        bitset^=t;
      }
    }
    return ac;
  }
  MappeableBitmapContainer bc=new MappeableBitmapContainer(maxcardinality,this.bitmap);
  int s=BufferUtil.toIntUnsigned(select(maxcardinality));
  int usedwords=(s + 63) / 64;
  int todelete=this.bitmap.limit() - usedwords;
  for (int k=0; k < todelete; ++k)   bc.bitmap.put(bc.bitmap.limit() - 1 - k,0);
  int lastword=s % 64;
  if (lastword != 0) {
    bc.bitmap.put(s / 64,(bc.bitmap.get(s / 64) << (64 - lastword)) >> (64 - lastword));
  }
  return bc;
}"
90344,"@Override public Container limit(int maxcardinality){
  if (maxcardinality >= this.cardinality) {
    return clone();
  }
  if (maxcardinality < ArrayContainer.DEFAULT_MAX_SIZE) {
    ArrayContainer ac=new ArrayContainer(maxcardinality);
    int pos=0;
    for (int k=0; (ac.cardinality < maxcardinality) && (k < bitmap.length); ++k) {
      long bitset=bitmap[k];
      while ((ac.cardinality < maxcardinality) && (bitset != 0)) {
        long t=bitset & -bitset;
        ac.content[pos++]=(short)(k * 64 + Long.bitCount(t - 1));
        ac.cardinality++;
        bitset^=t;
      }
    }
    return ac;
  }
  BitmapContainer bc=new BitmapContainer(maxcardinality,this.bitmap);
  int s=Util.toIntUnsigned(select(maxcardinality));
  int usedwords=(s + 63) / 64;
  int todelete=this.bitmap.length - usedwords;
  for (int k=0; k < todelete; ++k)   bc.bitmap[bc.bitmap.length - 1 - k]=0;
  int lastword=s % 64;
  if (lastword != 0) {
    bc.bitmap[s / 64]=(bc.bitmap[s / 64] << (64 - lastword)) >> (64 - lastword);
  }
  return bc;
}","@Override public Container limit(int maxcardinality){
  if (maxcardinality >= this.cardinality) {
    return clone();
  }
  if (maxcardinality <= ArrayContainer.DEFAULT_MAX_SIZE) {
    ArrayContainer ac=new ArrayContainer(maxcardinality);
    int pos=0;
    for (int k=0; (ac.cardinality < maxcardinality) && (k < bitmap.length); ++k) {
      long bitset=bitmap[k];
      while ((ac.cardinality < maxcardinality) && (bitset != 0)) {
        long t=bitset & -bitset;
        ac.content[pos++]=(short)(k * 64 + Long.bitCount(t - 1));
        ac.cardinality++;
        bitset^=t;
      }
    }
    return ac;
  }
  BitmapContainer bc=new BitmapContainer(maxcardinality,this.bitmap);
  int s=Util.toIntUnsigned(select(maxcardinality));
  int usedwords=(s + 63) / 64;
  int todelete=this.bitmap.length - usedwords;
  for (int k=0; k < todelete; ++k)   bc.bitmap[bc.bitmap.length - 1 - k]=0;
  int lastword=s % 64;
  if (lastword != 0) {
    bc.bitmap[s / 64]=(bc.bitmap[s / 64] << (64 - lastword)) >> (64 - lastword);
  }
  return bc;
}"
90345,"@Override public MappeableContainer limit(int maxcardinality){
  if (maxcardinality >= this.cardinality) {
    return clone();
  }
  if (maxcardinality < MappeableArrayContainer.DEFAULT_MAX_SIZE) {
    MappeableArrayContainer ac=new MappeableArrayContainer(maxcardinality);
    int pos=0;
    short[] cont=ac.content.array();
    for (int k=0; (ac.cardinality < maxcardinality) && (k < bitmap.limit()); ++k) {
      long bitset=bitmap.get(k);
      while ((ac.cardinality < maxcardinality) && (bitset != 0)) {
        long t=bitset & -bitset;
        cont[pos++]=(short)(k * 64 + Long.bitCount(t - 1));
        ac.cardinality++;
        bitset^=t;
      }
    }
    return ac;
  }
  MappeableBitmapContainer bc=new MappeableBitmapContainer(maxcardinality,this.bitmap);
  int s=BufferUtil.toIntUnsigned(select(maxcardinality));
  int usedwords=(s + 63) / 64;
  int todelete=this.bitmap.limit() - usedwords;
  for (int k=0; k < todelete; ++k)   bc.bitmap.put(bc.bitmap.limit() - 1 - k,0);
  int lastword=s % 64;
  if (lastword != 0) {
    bc.bitmap.put(s / 64,(bc.bitmap.get(s / 64) << (64 - lastword)) >> (64 - lastword));
  }
  return bc;
}","@Override public MappeableContainer limit(int maxcardinality){
  if (maxcardinality >= this.cardinality) {
    return clone();
  }
  if (maxcardinality <= MappeableArrayContainer.DEFAULT_MAX_SIZE) {
    MappeableArrayContainer ac=new MappeableArrayContainer(maxcardinality);
    int pos=0;
    short[] cont=ac.content.array();
    for (int k=0; (ac.cardinality < maxcardinality) && (k < bitmap.limit()); ++k) {
      long bitset=bitmap.get(k);
      while ((ac.cardinality < maxcardinality) && (bitset != 0)) {
        long t=bitset & -bitset;
        cont[pos++]=(short)(k * 64 + Long.bitCount(t - 1));
        ac.cardinality++;
        bitset^=t;
      }
    }
    return ac;
  }
  MappeableBitmapContainer bc=new MappeableBitmapContainer(maxcardinality,this.bitmap);
  int s=BufferUtil.toIntUnsigned(select(maxcardinality));
  int usedwords=(s + 63) / 64;
  int todelete=this.bitmap.limit() - usedwords;
  for (int k=0; k < todelete; ++k)   bc.bitmap.put(bc.bitmap.limit() - 1 - k,0);
  int lastword=s % 64;
  if (lastword != 0) {
    bc.bitmap.put(s / 64,(bc.bitmap.get(s / 64) << (64 - lastword)) >> (64 - lastword));
  }
  return bc;
}"
90346,"/** 
 * Prepares a bitmap for iteration
 * @param r
 */
public void wrap(RoaringBitmap r){
  this.roaringBitmap=r;
  this.hs=0;
  this.pos=(short)(this.roaringBitmap.highLowContainer.size() - 1);
  this.nextContainer();
}","/** 
 * Prepares a bitmap for iteration
 * @param r  bitmap to be iterated over
 */
public void wrap(RoaringBitmap r){
  this.roaringBitmap=r;
  this.hs=0;
  this.pos=(short)(this.roaringBitmap.highLowContainer.size() - 1);
  this.nextContainer();
}"
90347,"/** 
 * Prepares a bitmap for iteration
 * @param r
 */
public void wrap(ImmutableRoaringBitmap r){
  this.roaringBitmap=r;
  this.hs=0;
  this.pos=(short)(this.roaringBitmap.highLowContainer.size() - 1);
  this.nextContainer();
}","/** 
 * Prepares a bitmap for iteration
 * @param r bitmap to be iterated over
 */
public void wrap(ImmutableRoaringBitmap r){
  this.roaringBitmap=r;
  this.hs=0;
  this.pos=(short)(this.roaringBitmap.highLowContainer.size() - 1);
  this.nextContainer();
}"
90348,"/** 
 * @return a ContainerPointer to iterator over the array initially positioned at startIndex
 */
MappeableContainerPointer getContainerPointer(int startIndex);","/** 
 * @param startIndex starting index
 * @return a ContainerPointer to iterator over the array initially positioned at startIndex
 */
MappeableContainerPointer getContainerPointer(int startIndex);"
90349,"private void increaseCapacity(){
  int newCapacity=this.content.length < 64 ? this.content.length * 2 : this.content.length < 1024 ? this.content.length * 3 / 2 : this.content.length * 5 / 4;
  if (newCapacity > ArrayContainer.DEFAULT_MAX_SIZE)   newCapacity=ArrayContainer.DEFAULT_MAX_SIZE;
  this.content=Arrays.copyOf(this.content,newCapacity);
}","private void increaseCapacity(){
  int newCapacity=(this.content.length == 0) ? DEFAULT_INIT_SIZE : this.content.length < 64 ? this.content.length * 2 : this.content.length < 1024 ? this.content.length * 3 / 2 : this.content.length * 5 / 4;
  if (newCapacity > ArrayContainer.DEFAULT_MAX_SIZE)   newCapacity=ArrayContainer.DEFAULT_MAX_SIZE;
  this.content=Arrays.copyOf(this.content,newCapacity);
}"
90350,"private void increaseCapacity(){
  int newCapacity=this.content.limit() < 64 ? this.content.limit() * 2 : this.content.limit() < 1024 ? this.content.limit() * 3 / 2 : this.content.limit() * 5 / 4;
  if (newCapacity > MappeableArrayContainer.DEFAULT_MAX_SIZE)   newCapacity=MappeableArrayContainer.DEFAULT_MAX_SIZE;
  final ShortBuffer newContent=ShortBuffer.allocate(newCapacity);
  this.content.rewind();
  newContent.put(this.content);
  this.content=newContent;
}","private void increaseCapacity(){
  int newCapacity=(this.content.limit() == 0) ? DEFAULT_INIT_SIZE : this.content.limit() < 64 ? this.content.limit() * 2 : this.content.limit() < 1024 ? this.content.limit() * 3 / 2 : this.content.limit() * 5 / 4;
  if (newCapacity > MappeableArrayContainer.DEFAULT_MAX_SIZE)   newCapacity=MappeableArrayContainer.DEFAULT_MAX_SIZE;
  final ShortBuffer newContent=ShortBuffer.allocate(newCapacity);
  this.content.rewind();
  newContent.put(this.content);
  this.content=newContent;
}"
90351,"protected static int unsignedBinarySearch(final short[] array,final int begin,final int end,final short k){
  int ikey=toIntUnsigned(k);
  if ((end > 0) && (toIntUnsigned(array[end - 1]) < ikey))   return -end;
  int low=begin;
  int high=end - 1;
  while (low <= high) {
    final int middleIndex=(low + high) >>> 1;
    final int middleValue=toIntUnsigned(array[middleIndex]);
    if (middleValue < ikey)     low=middleIndex + 1;
 else     if (middleValue > ikey)     high=middleIndex - 1;
 else     return middleIndex;
  }
  return -(low + 1);
}","protected static int unsignedBinarySearch(final short[] array,final int begin,final int end,final short k){
  int ikey=toIntUnsigned(k);
  if ((end > 0) && (toIntUnsigned(array[end - 1]) < ikey))   return -end - 1;
  int low=begin;
  int high=end - 1;
  while (low <= high) {
    final int middleIndex=(low + high) >>> 1;
    final int middleValue=toIntUnsigned(array[middleIndex]);
    if (middleValue < ikey)     low=middleIndex + 1;
 else     if (middleValue > ikey)     high=middleIndex - 1;
 else     return middleIndex;
  }
  return -(low + 1);
}"
90352,"protected static int unsignedBinarySearch(final ShortBuffer array,final int begin,final int end,final short k){
  final int ikey=toIntUnsigned(k);
  if ((end > 0) && (toIntUnsigned(array.get(end - 1)) < ikey))   return -end;
  int low=begin;
  int high=end - 1;
  while (low <= high) {
    final int middleIndex=(low + high) >>> 1;
    final int middleValue=toIntUnsigned(array.get(middleIndex));
    if (middleValue < ikey)     low=middleIndex + 1;
 else     if (middleValue > ikey)     high=middleIndex - 1;
 else     return middleIndex;
  }
  return -(low + 1);
}","protected static int unsignedBinarySearch(final ShortBuffer array,final int begin,final int end,final short k){
  final int ikey=toIntUnsigned(k);
  if ((end > 0) && (toIntUnsigned(array.get(end - 1)) < ikey))   return -end - 1;
  int low=begin;
  int high=end - 1;
  while (low <= high) {
    final int middleIndex=(low + high) >>> 1;
    final int middleValue=toIntUnsigned(array.get(middleIndex));
    if (middleValue < ikey)     low=middleIndex + 1;
 else     if (middleValue > ikey)     high=middleIndex - 1;
 else     return middleIndex;
  }
  return -(low + 1);
}"
90353,"@Test public void testHorizontalOrCardinality(){
  int[] vals={65535,131071,196607,262143,327679,393215,458751,524287};
  final RoaringBitmap[] b=new RoaringBitmap[2];
  b[0]=RoaringBitmap.bitmapOf(vals);
  b[1]=RoaringBitmap.bitmapOf(vals);
  RoaringBitmap a=FastAggregation.horizontal_or(new Iterator<RoaringBitmap>(){
    int k=0;
    @Override public boolean hasNext(){
      return k < b.length;
    }
    @Override public RoaringBitmap next(){
      return b[k++];
    }
  }
);
  Assert.assertEquals(8,a.getCardinality());
}","@Test public void testHorizontalOrCardinality(){
  int[] vals={65535,131071,196607,262143,327679,393215,458751,524287};
  final RoaringBitmap[] b=new RoaringBitmap[2];
  b[0]=RoaringBitmap.bitmapOf(vals);
  b[1]=RoaringBitmap.bitmapOf(vals);
  RoaringBitmap a=FastAggregation.horizontal_or(new Iterator<RoaringBitmap>(){
    int k=0;
    @Override public boolean hasNext(){
      return k < b.length;
    }
    @Override public void remove(){
    }
    @Override public RoaringBitmap next(){
      return b[k++];
    }
  }
);
  Assert.assertEquals(8,a.getCardinality());
}"
90354,"@Test public void testHorizontalOrCardinality(){
  int[] vals={65535,131071,196607,262143,327679,393215,458751,524287};
  final MutableRoaringBitmap[] b=new MutableRoaringBitmap[2];
  b[0]=MutableRoaringBitmap.bitmapOf(vals);
  b[1]=MutableRoaringBitmap.bitmapOf(vals);
  MutableRoaringBitmap a=BufferFastAggregation.horizontal_or(new Iterator<ImmutableRoaringBitmap>(){
    int k=0;
    @Override public boolean hasNext(){
      return k < b.length;
    }
    @Override public ImmutableRoaringBitmap next(){
      return b[k++];
    }
  }
);
  Assert.assertEquals(8,a.getCardinality());
}","@Test public void testHorizontalOrCardinality(){
  int[] vals={65535,131071,196607,262143,327679,393215,458751,524287};
  final MutableRoaringBitmap[] b=new MutableRoaringBitmap[2];
  b[0]=MutableRoaringBitmap.bitmapOf(vals);
  b[1]=MutableRoaringBitmap.bitmapOf(vals);
  MutableRoaringBitmap a=BufferFastAggregation.horizontal_or(new Iterator<ImmutableRoaringBitmap>(){
    int k=0;
    @Override public boolean hasNext(){
      return k < b.length;
    }
    @Override public void remove(){
    }
    @Override public ImmutableRoaringBitmap next(){
      return b[k++];
    }
  }
);
  Assert.assertEquals(8,a.getCardinality());
}"
90355,"/** 
 * Minimizes memory usage while computing the xor aggregate.
 * @param bitmaps input bitmaps
 * @return aggregated bitmap
 */
public static RoaringBitmap horizontal_xor(RoaringBitmap... bitmaps){
  RoaringBitmap answer=new RoaringBitmap();
  if (bitmaps.length == 0)   return answer;
  PriorityQueue<ContainerPointer> pq=new PriorityQueue<ContainerPointer>(bitmaps.length);
  for (int k=0; k < bitmaps.length; ++k) {
    ContainerPointer x=bitmaps[k].highLowContainer.getContainerPointer();
    if (x.getContainer() != null)     pq.add(x);
  }
  while (!pq.isEmpty()) {
    ContainerPointer x1=pq.poll();
    if (pq.isEmpty() || (pq.peek().key() != x1.key())) {
      answer.highLowContainer.append(x1.key(),x1.getContainer().clone());
      x1.advance();
      if (x1.getContainer() != null)       pq.add(x1);
      continue;
    }
    ContainerPointer x2=pq.poll();
    Container newc=x1.getContainer().xor(x2.getContainer());
    while (pq.peek().key() == x1.key()) {
      ContainerPointer x=pq.poll();
      newc=newc.ixor(x.getContainer());
      x.advance();
      if (x.getContainer() != null)       pq.add(x);
 else       if (pq.isEmpty())       break;
    }
    answer.highLowContainer.append(x1.key(),newc);
    x1.advance();
    if (x1.getContainer() != null)     pq.add(x1);
    x2.advance();
    if (x2.getContainer() != null)     pq.add(x2);
  }
  return answer;
}","/** 
 * Minimizes memory usage while computing the xor aggregate.
 * @param bitmaps input bitmaps
 * @return aggregated bitmap
 */
public static RoaringBitmap horizontal_xor(RoaringBitmap... bitmaps){
  RoaringBitmap answer=new RoaringBitmap();
  if (bitmaps.length == 0)   return answer;
  PriorityQueue<ContainerPointer> pq=new PriorityQueue<ContainerPointer>(bitmaps.length);
  for (int k=0; k < bitmaps.length; ++k) {
    ContainerPointer x=bitmaps[k].highLowContainer.getContainerPointer();
    if (x.getContainer() != null)     pq.add(x);
  }
  while (!pq.isEmpty()) {
    ContainerPointer x1=pq.poll();
    if (pq.isEmpty() || (pq.peek().key() != x1.key())) {
      answer.highLowContainer.append(x1.key(),x1.getContainer().clone());
      x1.advance();
      if (x1.getContainer() != null)       pq.add(x1);
      continue;
    }
    ContainerPointer x2=pq.poll();
    Container newc=x1.getContainer().xor(x2.getContainer());
    while (!pq.isEmpty() && (pq.peek().key() == x1.key())) {
      ContainerPointer x=pq.poll();
      newc=newc.ixor(x.getContainer());
      x.advance();
      if (x.getContainer() != null)       pq.add(x);
 else       if (pq.isEmpty())       break;
    }
    answer.highLowContainer.append(x1.key(),newc);
    x1.advance();
    if (x1.getContainer() != null)     pq.add(x1);
    x2.advance();
    if (x2.getContainer() != null)     pq.add(x2);
  }
  return answer;
}"
90356,"/** 
 * Minimizes memory usage while computing the or aggregate.
 * @param bitmaps input bitmaps
 * @return aggregated bitmap
 */
public static RoaringBitmap horizontal_or(RoaringBitmap... bitmaps){
  RoaringBitmap answer=new RoaringBitmap();
  if (bitmaps.length == 0)   return answer;
  PriorityQueue<ContainerPointer> pq=new PriorityQueue<ContainerPointer>(bitmaps.length);
  for (int k=0; k < bitmaps.length; ++k) {
    ContainerPointer x=bitmaps[k].highLowContainer.getContainerPointer();
    if (x.getContainer() != null)     pq.add(x);
  }
  while (!pq.isEmpty()) {
    ContainerPointer x1=pq.poll();
    if (pq.isEmpty() || (pq.peek().key() != x1.key())) {
      answer.highLowContainer.append(x1.key(),x1.getContainer().clone());
      x1.advance();
      if (x1.getContainer() != null)       pq.add(x1);
      continue;
    }
    ContainerPointer x2=pq.poll();
    Container newc=x1.getContainer().or(x2.getContainer());
    while (pq.peek().key() == x1.key()) {
      ContainerPointer x=pq.poll();
      newc=newc.ior(x.getContainer());
      x.advance();
      if (x.getContainer() != null)       pq.add(x);
 else       if (pq.isEmpty())       break;
    }
    answer.highLowContainer.append(x1.key(),newc);
    x1.advance();
    if (x1.getContainer() != null)     pq.add(x1);
    x2.advance();
    if (x2.getContainer() != null)     pq.add(x2);
  }
  return answer;
}","/** 
 * Minimizes memory usage while computing the or aggregate.
 * @param bitmaps input bitmaps
 * @return aggregated bitmap
 */
public static RoaringBitmap horizontal_or(RoaringBitmap... bitmaps){
  RoaringBitmap answer=new RoaringBitmap();
  if (bitmaps.length == 0)   return answer;
  PriorityQueue<ContainerPointer> pq=new PriorityQueue<ContainerPointer>(bitmaps.length);
  for (int k=0; k < bitmaps.length; ++k) {
    ContainerPointer x=bitmaps[k].highLowContainer.getContainerPointer();
    if (x.getContainer() != null)     pq.add(x);
  }
  while (!pq.isEmpty()) {
    ContainerPointer x1=pq.poll();
    if (pq.isEmpty() || (pq.peek().key() != x1.key())) {
      answer.highLowContainer.append(x1.key(),x1.getContainer().clone());
      x1.advance();
      if (x1.getContainer() != null)       pq.add(x1);
      continue;
    }
    ContainerPointer x2=pq.poll();
    Container newc=x1.getContainer().or(x2.getContainer());
    while (!pq.isEmpty() && (pq.peek().key() == x1.key())) {
      ContainerPointer x=pq.poll();
      newc=newc.ior(x.getContainer());
      x.advance();
      if (x.getContainer() != null)       pq.add(x);
 else       if (pq.isEmpty())       break;
    }
    answer.highLowContainer.append(x1.key(),newc);
    x1.advance();
    if (x1.getContainer() != null)     pq.add(x1);
    x2.advance();
    if (x2.getContainer() != null)     pq.add(x2);
  }
  return answer;
}"
90357,"/** 
 * Minimizes memory usage while computing the xor aggregate.
 * @param bitmaps input bitmaps
 * @return aggregated bitmap
 */
public static MappeableRoaringBitmap horizontal_xor(ImmutableRoaringBitmap... bitmaps){
  MappeableRoaringBitmap answer=new MappeableRoaringBitmap();
  if (bitmaps.length == 0)   return answer;
  PriorityQueue<MappeableContainerPointer> pq=new PriorityQueue<MappeableContainerPointer>(bitmaps.length);
  for (int k=0; k < bitmaps.length; ++k) {
    MappeableContainerPointer x=bitmaps[k].highLowContainer.getContainerPointer();
    if (x.getContainer() != null)     pq.add(x);
  }
  while (!pq.isEmpty()) {
    MappeableContainerPointer x1=pq.poll();
    if (pq.isEmpty() || (pq.peek().key() != x1.key())) {
      answer.highLowContainer.append(x1.key(),x1.getContainer().clone());
      x1.advance();
      if (x1.getContainer() != null)       pq.add(x1);
      continue;
    }
    MappeableContainerPointer x2=pq.poll();
    MappeableContainer newc=x1.getContainer().xor(x2.getContainer());
    while (pq.peek().key() == x1.key()) {
      MappeableContainerPointer x=pq.poll();
      newc=newc.ixor(x.getContainer());
      x.advance();
      if (x.getContainer() != null)       pq.add(x);
 else       if (pq.isEmpty())       break;
    }
    answer.highLowContainer.append(x1.key(),newc);
    x1.advance();
    if (x1.getContainer() != null)     pq.add(x1);
    x2.advance();
    if (x2.getContainer() != null)     pq.add(x2);
  }
  return answer;
}","/** 
 * Minimizes memory usage while computing the xor aggregate.
 * @param bitmaps input bitmaps
 * @return aggregated bitmap
 */
public static MappeableRoaringBitmap horizontal_xor(ImmutableRoaringBitmap... bitmaps){
  MappeableRoaringBitmap answer=new MappeableRoaringBitmap();
  if (bitmaps.length == 0)   return answer;
  PriorityQueue<MappeableContainerPointer> pq=new PriorityQueue<MappeableContainerPointer>(bitmaps.length);
  for (int k=0; k < bitmaps.length; ++k) {
    MappeableContainerPointer x=bitmaps[k].highLowContainer.getContainerPointer();
    if (x.getContainer() != null)     pq.add(x);
  }
  while (!pq.isEmpty()) {
    MappeableContainerPointer x1=pq.poll();
    if (pq.isEmpty() || (pq.peek().key() != x1.key())) {
      answer.highLowContainer.append(x1.key(),x1.getContainer().clone());
      x1.advance();
      if (x1.getContainer() != null)       pq.add(x1);
      continue;
    }
    MappeableContainerPointer x2=pq.poll();
    MappeableContainer newc=x1.getContainer().xor(x2.getContainer());
    while (!pq.isEmpty() && (pq.peek().key() == x1.key())) {
      MappeableContainerPointer x=pq.poll();
      newc=newc.ixor(x.getContainer());
      x.advance();
      if (x.getContainer() != null)       pq.add(x);
 else       if (pq.isEmpty())       break;
    }
    answer.highLowContainer.append(x1.key(),newc);
    x1.advance();
    if (x1.getContainer() != null)     pq.add(x1);
    x2.advance();
    if (x2.getContainer() != null)     pq.add(x2);
  }
  return answer;
}"
90358,"/** 
 * Minimizes memory usage while computing the or aggregate.
 * @param bitmaps input bitmaps
 * @return aggregated bitmap
 */
public static MappeableRoaringBitmap horizontal_or(ImmutableRoaringBitmap... bitmaps){
  MappeableRoaringBitmap answer=new MappeableRoaringBitmap();
  if (bitmaps.length == 0)   return answer;
  PriorityQueue<MappeableContainerPointer> pq=new PriorityQueue<MappeableContainerPointer>(bitmaps.length);
  for (int k=0; k < bitmaps.length; ++k) {
    MappeableContainerPointer x=bitmaps[k].highLowContainer.getContainerPointer();
    if (x.getContainer() != null)     pq.add(x);
  }
  while (!pq.isEmpty()) {
    MappeableContainerPointer x1=pq.poll();
    if (pq.isEmpty() || (pq.peek().key() != x1.key())) {
      answer.highLowContainer.append(x1.key(),x1.getContainer().clone());
      x1.advance();
      if (x1.getContainer() != null)       pq.add(x1);
      continue;
    }
    MappeableContainerPointer x2=pq.poll();
    MappeableContainer newc=x1.getContainer().or(x2.getContainer());
    while (pq.peek().key() == x1.key()) {
      MappeableContainerPointer x=pq.poll();
      newc=newc.ior(x.getContainer());
      x.advance();
      if (x.getContainer() != null)       pq.add(x);
 else       if (pq.isEmpty())       break;
    }
    answer.highLowContainer.append(x1.key(),newc);
    x1.advance();
    if (x1.getContainer() != null)     pq.add(x1);
    x2.advance();
    if (x2.getContainer() != null)     pq.add(x2);
  }
  return answer;
}","/** 
 * Minimizes memory usage while computing the or aggregate.
 * @param bitmaps input bitmaps
 * @return aggregated bitmap
 */
public static MappeableRoaringBitmap horizontal_or(ImmutableRoaringBitmap... bitmaps){
  MappeableRoaringBitmap answer=new MappeableRoaringBitmap();
  if (bitmaps.length == 0)   return answer;
  PriorityQueue<MappeableContainerPointer> pq=new PriorityQueue<MappeableContainerPointer>(bitmaps.length);
  for (int k=0; k < bitmaps.length; ++k) {
    MappeableContainerPointer x=bitmaps[k].highLowContainer.getContainerPointer();
    if (x.getContainer() != null)     pq.add(x);
  }
  while (!pq.isEmpty()) {
    MappeableContainerPointer x1=pq.poll();
    if (pq.isEmpty() || (pq.peek().key() != x1.key())) {
      answer.highLowContainer.append(x1.key(),x1.getContainer().clone());
      x1.advance();
      if (x1.getContainer() != null)       pq.add(x1);
      continue;
    }
    MappeableContainerPointer x2=pq.poll();
    MappeableContainer newc=x1.getContainer().or(x2.getContainer());
    while (!pq.isEmpty() && (pq.peek().key() == x1.key())) {
      MappeableContainerPointer x=pq.poll();
      newc=newc.ior(x.getContainer());
      x.advance();
      if (x.getContainer() != null)       pq.add(x);
 else       if (pq.isEmpty())       break;
    }
    answer.highLowContainer.append(x1.key(),newc);
    x1.advance();
    if (x1.getContainer() != null)     pq.add(x1);
    x2.advance();
    if (x2.getContainer() != null)     pq.add(x2);
  }
  return answer;
}"
90359,"@Override public short next(){
  return ArrayContainer.this.content[pos++];
}","@Override public Short next(){
  return new Short(ArrayContainer.this.content[pos++]);
}"
90360,"@Override public ShortIterator getShortIterator(){
  return new ShortIterator(){
    int pos=0;
    @Override public boolean hasNext(){
      return pos < ArrayContainer.this.cardinality;
    }
    @Override public short next(){
      return ArrayContainer.this.content[pos++];
    }
  }
;
}","@Override public ShortIterator getShortIterator(){
  return new ShortIterator(){
    @Override public boolean hasNext(){
      return pos < ArrayContainer.this.cardinality;
    }
    @Override public short next(){
      return ArrayContainer.this.content[pos++];
    }
    int pos=0;
  }
;
}"
90361,"@Override public void remove(){
  ArrayContainer.this.remove((short)(pos - 1));
  pos--;
}","@Override public Container remove(final short x){
  final int loc=Util.unsigned_binarySearch(content,0,cardinality,x);
  if (loc >= 0) {
    System.arraycopy(content,loc + 1,content,loc,cardinality - loc - 1);
    --cardinality;
  }
  return this;
}"
90362,"@Override public Iterator<Short> iterator(){
  return new Iterator<Short>(){
    short pos=0;
    @Override public boolean hasNext(){
      return pos < ArrayContainer.this.cardinality;
    }
    @Override public Short next(){
      return new Short(ArrayContainer.this.content[pos++]);
    }
    @Override public void remove(){
      ArrayContainer.this.remove((short)(pos - 1));
      pos--;
    }
  }
;
}","@Override public Iterator<Short> iterator(){
  return new Iterator<Short>(){
    @Override public boolean hasNext(){
      return pos < ArrayContainer.this.cardinality;
    }
    @Override public Short next(){
      return new Short(ArrayContainer.this.content[pos++]);
    }
    @Override public void remove(){
      ArrayContainer.this.remove((short)(pos - 1));
      pos--;
    }
    short pos=0;
  }
;
}"
90363,"public ArrayContainer(){
  this(DEFAULTINITSIZE);
}","public ArrayContainer(final int capacity){
  content=new short[capacity];
}"
90364,"/** 
 * running time is in O(n) time if insert is not in order.
 */
@Override public Container add(final short x){
  if ((cardinality == 0) || (Util.toIntUnsigned(x) > Util.toIntUnsigned(content[cardinality - 1]))) {
    if (cardinality >= DEFAULTMAXSIZE) {
      BitmapContainer a=ContainerFactory.transformToBitmapContainer(this);
      a.add(x);
      return a;
    }
    if (cardinality >= this.content.length)     increaseCapacity();
    content[cardinality++]=x;
    return this;
  }
  int loc=Util.unsigned_binarySearch(content,0,cardinality,x);
  if (loc < 0) {
    if (cardinality >= DEFAULTMAXSIZE) {
      BitmapContainer a=ContainerFactory.transformToBitmapContainer(this);
      a.add(x);
      return a;
    }
    if (cardinality >= this.content.length)     increaseCapacity();
    System.arraycopy(content,-loc - 1,content,-loc,cardinality + loc + 1);
    content[-loc - 1]=x;
    ++cardinality;
  }
  return this;
}","/** 
 * running time is in O(n) time if insert is not in order.
 */
@Override public Container add(final short x){
  if (cardinality >= DEFAULTMAXSIZE) {
    BitmapContainer a=ContainerFactory.transformToBitmapContainer(this);
    a.add(x);
    return a;
  }
  if ((cardinality == 0) || (Util.toIntUnsigned(x) > Util.toIntUnsigned(content[cardinality - 1]))) {
    if (cardinality >= this.content.length)     increaseCapacity();
    content[cardinality++]=x;
    return this;
  }
  int loc=Util.unsigned_binarySearch(content,0,cardinality,x);
  if (loc < 0) {
    if (cardinality >= this.content.length)     increaseCapacity();
    System.arraycopy(content,-loc - 1,content,-loc,cardinality + loc + 1);
    content[-loc - 1]=x;
    ++cardinality;
  }
  return this;
}"
90365,"@Override public short next(){
  short j=(short)i;
  i=BitmapContainer.this.nextSetBit(i + 1);
  return j;
}","@Override public Short next(){
  j=i;
  i=BitmapContainer.this.nextSetBit(i + 1);
  return new Short((short)j);
}"
90366,"@Override public ShortIterator getShortIterator(){
  return new ShortIterator(){
    int i=BitmapContainer.this.nextSetBit(0);
    @Override public boolean hasNext(){
      return i >= 0;
    }
    @Override public short next(){
      short j=(short)i;
      i=BitmapContainer.this.nextSetBit(i + 1);
      return j;
    }
  }
;
}","@Override public ShortIterator getShortIterator(){
  return new ShortIterator(){
    @Override public boolean hasNext(){
      return i >= 0;
    }
    @Override public short next(){
      short j=(short)i;
      i=BitmapContainer.this.nextSetBit(i + 1);
      return j;
    }
    int i=BitmapContainer.this.nextSetBit(0);
  }
;
}"
90367,"@Override public void remove(){
  BitmapContainer.this.remove((short)j);
}","@Override public Container remove(final short i){
  final int x=Util.toIntUnsigned(i);
  if (cardinality == ArrayContainer.DEFAULTMAXSIZE) {
    if ((bitmap[x / 64] & (1l << x)) != 0) {
      --cardinality;
      bitmap[x / 64]&=~(1l << x);
      return ContainerFactory.transformToArrayContainer(this);
    }
  }
  cardinality-=(bitmap[x / 64] & (1l << x)) >>> x;
  bitmap[x / 64]&=~(1l << x);
  return this;
}"
90368,"@Override public Iterator<Short> iterator(){
  return new Iterator<Short>(){
    int i=BitmapContainer.this.nextSetBit(0);
    int j;
    @Override public boolean hasNext(){
      return i >= 0;
    }
    @Override public Short next(){
      j=i;
      i=BitmapContainer.this.nextSetBit(i + 1);
      return new Short((short)j);
    }
    @Override public void remove(){
      BitmapContainer.this.remove((short)j);
    }
  }
;
}","@Override public Iterator<Short> iterator(){
  return new Iterator<Short>(){
    @Override public boolean hasNext(){
      return i >= 0;
    }
    @Override public Short next(){
      j=i;
      i=BitmapContainer.this.nextSetBit(i + 1);
      return new Short((short)j);
    }
    @Override public void remove(){
      BitmapContainer.this.remove((short)j);
    }
    int i=BitmapContainer.this.nextSetBit(0);
    int j;
  }
;
}"
90369,"public BitmapContainer inPlaceOR(final ArrayContainer value2){
  for (int k=0; k < value2.cardinality; ++k) {
    final int i=Util.toIntUnsigned(value2.content[k]) >>> 6;
    this.cardinality+=((~this.bitmap[i]) & (1l << value2.content[k])) >>> value2.content[k];
    this.bitmap[i]|=(1l << value2.content[k]);
  }
  return this;
}","public Container inPlaceOR(final BitmapContainer B2){
  this.cardinality=0;
  for (int k=0; k < this.bitmap.length; k++) {
    this.bitmap[k]|=B2.bitmap[k];
    this.cardinality+=Long.bitCount(this.bitmap[k]);
  }
  return this;
}"
90370,"public ArrayContainer and(final ArrayContainer value2){
  final ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < value2.content.length)   answer.content=new short[value2.content.length];
  for (int k=0; k < value2.getCardinality(); ++k)   if (this.contains(value2.content[k]))   answer.content[answer.cardinality++]=value2.content[k];
  return answer;
}","public Container and(final BitmapContainer value2){
  final BitmapContainer answer=ContainerFactory.getUnintializedBitmapContainer();
  answer.cardinality=0;
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=this.bitmap[k] & value2.bitmap[k];
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  if (answer.cardinality <= ArrayContainer.DEFAULTMAXSIZE)   return ContainerFactory.transformToArrayContainer(answer);
  return answer;
}"
90371,"@Override public Container add(final short i){
  final int x=Util.toIntUnsigned(i);
  final long previous=bitmap[x / 64];
  if (previous != (bitmap[x / 64]|=(1l << x)))   ++cardinality;
  return this;
}","@Override public Container add(final short i){
  final int x=Util.toIntUnsigned(i);
  final long previous=bitmap[x / 64];
  bitmap[x / 64]|=(1l << x);
  cardinality+=(previous ^ bitmap[x / 64]) >>> x;
  return this;
}"
90372,"public Container inPlaceXOR(final ArrayContainer value2){
  for (int k=0; k < value2.getCardinality(); ++k) {
    final int index=Util.toIntUnsigned(value2.content[k]) >>> 6;
    this.cardinality+=1 - 2 * ((this.bitmap[index] & (1l << value2.content[k])) >>> value2.content[k]);
    this.bitmap[index]^=(1l << value2.content[k]);
  }
  if (this.cardinality <= ArrayContainer.DEFAULTMAXSIZE)   return ContainerFactory.transformToArrayContainer(this);
  return this;
}","public Container inPlaceXOR(BitmapContainer B2){
  this.cardinality=0;
  for (int k=0; k < this.bitmap.length; ++k) {
    this.bitmap[k]^=B2.bitmap[k];
    this.cardinality+=Long.bitCount(this.bitmap[k]);
  }
  if (this.cardinality <= ArrayContainer.DEFAULTMAXSIZE)   return ContainerFactory.transformToArrayContainer(this);
  return this;
}"
90373,"public Container andNot(final ArrayContainer value2){
  final BitmapContainer answer=ContainerFactory.getCopyOfBitmapContainer(this);
  for (int k=0; k < value2.cardinality; ++k) {
    final int i=Util.toIntUnsigned(value2.content[k]) >>> 6;
    answer.bitmap[i]=answer.bitmap[i] & (~(1l << value2.content[k]));
    answer.cardinality-=(answer.bitmap[i] ^ this.bitmap[i]) >>> value2.content[k];
  }
  if (answer.cardinality <= ArrayContainer.DEFAULTMAXSIZE)   return ContainerFactory.transformToArrayContainer(answer);
  return answer;
}","public Container andNot(final BitmapContainer value2){
  final BitmapContainer answer=ContainerFactory.getUnintializedBitmapContainer();
  answer.cardinality=0;
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=this.bitmap[k] & (~value2.bitmap[k]);
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  if (answer.cardinality <= ArrayContainer.DEFAULTMAXSIZE)   return ContainerFactory.transformToArrayContainer(answer);
  return answer;
}"
90374,"public void extendArray(){
  if (this.nbKeys == this.array.length) {
    int newcapacity;
    if (this.array.length < 4) {
      newcapacity=4;
    }
 else     if (this.array.length < 1024) {
      newcapacity=2 * this.array.length;
    }
 else {
      newcapacity=5 * this.array.length / 4;
    }
    this.array=Arrays.copyOf(this.array,newcapacity);
  }
}","public void extendArray(int k){
  if (this.size + k >= this.array.length) {
    int newcapacity;
    if (this.array.length < 4) {
      newcapacity=this.size + k;
    }
 else     if (this.array.length < 1024) {
      newcapacity=2 * (this.size + k);
    }
 else {
      newcapacity=5 * (this.size + k) / 4;
    }
    this.array=Arrays.copyOf(this.array,newcapacity);
  }
}"
90375,"public int getIndex(short x){
  return this.binarySearch(0,nbKeys,x);
}","public int getIndex(short x){
  return this.binarySearch(0,size,x);
}"
90376,"public Container getContainer(short x){
  int i=this.binarySearch(0,nbKeys,x);
  if (i < 0)   return null;
  return this.array[i].value;
}","public Container getContainer(short x){
  int i=this.binarySearch(0,size,x);
  if (i < 0)   return null;
  return this.array[i].value;
}"
90377,"public void clear(){
  this.nbKeys=0;
}","public void clear(){
  this.array=null;
  this.size=0;
}"
90378,"public int binarySearch(int begin,int end,short key){
  int low=begin;
  int high=end - 1;
  int ikey=Util.toIntUnsigned(key);
  while (low <= high) {
    int middleIndex=(low + high) >>> 1;
    int middleValue=Util.toIntUnsigned(array[middleIndex].key);
    if (middleValue < ikey)     low=middleIndex + 1;
 else     if (middleValue > ikey)     high=middleIndex - 1;
 else     return middleIndex;
  }
  return -(low + 1);
}","private int binarySearch(int begin,int end,short key){
  int low=begin;
  int high=end - 1;
  int ikey=Util.toIntUnsigned(key);
  while (low <= high) {
    int middleIndex=(low + high) >>> 1;
    int middleValue=Util.toIntUnsigned(array[middleIndex].key);
    if (middleValue < ikey)     low=middleIndex + 1;
 else     if (middleValue > ikey)     high=middleIndex - 1;
 else     return middleIndex;
  }
  return -(low + 1);
}"
90379,"public boolean remove(short key){
  int i=binarySearch(0,nbKeys,key);
  if (i >= 0) {
    removeAtIndex(i);
    return true;
  }
  return false;
}","public boolean remove(short key){
  int i=binarySearch(0,size,key);
  if (i >= 0) {
    removeAtIndex(i);
    return true;
  }
  return false;
}"
90380,"public boolean ContainsKey(short x){
  return (binarySearch(0,nbKeys,x) >= 0);
}","public boolean ContainsKey(short x){
  return (binarySearch(0,size,x) >= 0);
}"
90381,"public void removeAtIndex(int i){
  System.arraycopy(array,i + 1,array,i,nbKeys - i - 1);
  nbKeys--;
}","public void removeAtIndex(int i){
  System.arraycopy(array,i + 1,array,i,size - i - 1);
  array[size - 1]=null;
  size--;
}"
90382,"public int size(){
  return this.nbKeys;
}","public int size(){
  return this.size;
}"
90383,"@Override public SpeedyArray clone() throws CloneNotSupportedException {
  SpeedyArray sa;
  sa=(SpeedyArray)super.clone();
  sa.array=Arrays.copyOf(this.array,this.nbKeys);
  sa.nbKeys=this.nbKeys;
  return sa;
}","@Override public SpeedyArray clone() throws CloneNotSupportedException {
  SpeedyArray sa;
  sa=(SpeedyArray)super.clone();
  sa.array=Arrays.copyOf(this.array,this.size);
  sa.size=this.size;
  return sa;
}"
90384,"/** 
 * Generating N sets of nbInts integers using Zipfian distribution.
 * @param N number of generated sets of integers
 * @param repeat number of repetitions
 */
public static void Tests(int N,int repeat,String path,int distribution){
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  zpf=new ZipfianDistribution();
  uniform=new UniformDataGenerator();
  cdg=new ClusteredDataGenerator();
  String distdir=null;
switch (distribution) {
case 0:
    distdir=path + File.separator + ""String_Node_Str""+ CPU+ File.separator+ ""String_Node_Str"";
  break;
case 1:
distdir=path + File.separator + ""String_Node_Str""+ CPU+ File.separator+ ""String_Node_Str"";
break;
case 2:
distdir=path + File.separator + ""String_Node_Str""+ CPU+ File.separator+ ""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"");
System.exit(0);
}
launchBenchmark(distribution,N,repeat,distdir,classic);
}","/** 
 * Generating N sets of nbInts integers using Zipfian distribution.
 * @param N number of generated sets of integers
 * @param repeat number of repetitions
 */
public static void Tests(int N,int repeat,String path,int distribution){
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  zpf=new ZipfianDistribution();
  uniform=new UniformDataGenerator();
  cdg=new ClusteredDataGenerator();
  String distdir=null;
  if (path != null) switch (distribution) {
case 0:
    distdir=path + File.separator + ""String_Node_Str""+ CPU+ File.separator+ ""String_Node_Str"";
  break;
case 1:
distdir=path + File.separator + ""String_Node_Str""+ CPU+ File.separator+ ""String_Node_Str"";
break;
case 2:
distdir=path + File.separator + ""String_Node_Str""+ CPU+ File.separator+ ""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"");
System.exit(0);
}
launchBenchmark(distribution,N,repeat,distdir,classic);
}"
90385,"public static void launchBenchmark(int distribution,int N,int repeat,String distdir,int optimisation){
  String Chartsdir=null, Benchmarkdir=null, optdir=null;
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
switch (optimisation) {
case 0:
    optdir=distdir + File.separator + ""String_Node_Str"";
  break;
case 1:
optdir=distdir + File.separator + ""String_Node_Str"";
break;
case 2:
optdir=distdir + File.separator + ""String_Node_Str"";
break;
case 3:
optdir=distdir + File.separator + ""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"");
System.exit(0);
}
Chartsdir=optdir + File.separator + ""String_Node_Str"";
Benchmarkdir=optdir + File.separator + ""String_Node_Str"";
try {
boolean success=(new File(Chartsdir).mkdirs());
boolean success2=(new File(Benchmarkdir).mkdirs());
if (success & success2) System.out.println(""String_Node_Str"");
}
 catch (Exception e) {
e.getMessage();
}
try {
File file=new File(Benchmarkdir + ""String_Node_Str"");
if (!file.exists()) file.createNewFile();
Date date=new Date();
SimpleDateFormat dateFormatComp;
dateFormatComp=new SimpleDateFormat(""String_Node_Str"");
String[] op={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
System.out.println(""String_Node_Str"");
System.out.println(""String_Node_Str"");
System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + N + ""String_Node_Str""+ max+ ""String_Node_Str""+ op[optimisation]+ ""String_Node_Str""+ dateFormatComp.format(date)+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str""));
FileWriter fw=new FileWriter(file.getAbsoluteFile());
bw=null;
bw=new BufferedWriter(fw);
bw.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + N + ""String_Node_Str""+ max+ ""String_Node_Str""+ op[optimisation]+ ""String_Node_Str""+ dateFormatComp.format(date)+ ""String_Node_Str""+ System.getenv(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str""));
}
 catch (IOException e) {
e.printStackTrace();
}
for (double k=0.001; k < 1.0; k*=10) {
SizeGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
OrGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
AndGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
XorGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
for (int i=0; i < nbTechnique; i++) {
SizeGraphCoordinates.add(new Vector<LineChartPoint>());
OrGraphCoordinates.add(new Vector<LineChartPoint>());
AndGraphCoordinates.add(new Vector<LineChartPoint>());
XorGraphCoordinates.add(new Vector<LineChartPoint>());
}
for (double density=k; density < k * 10.0; density+=density) {
if (density >= 0.7) density=0.6;
int SetSize=(int)(max * density);
int data[][]=new int[N][];
int data2[][]=new int[N][];
System.out.println(""String_Node_Str"" + density);
System.out.println(""String_Node_Str"");
try {
bw.write(""String_Node_Str"" + density + ""String_Node_Str"");
}
 catch (IOException e1) {
e1.printStackTrace();
}
for (int i=0; i < nbTechnique; i++) {
SizeGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
OrGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
AndGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
XorGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
}
for (int i=0; i < N; i++) {
switch (distribution) {
case 0:
data[i]=zpf.GenartingInts(SetSize,max);
data2[i]=zpf.GenartingInts(SetSize,max);
break;
case 1:
data[i]=uniform.generateUniform(SetSize,max);
data2[i]=uniform.generateUniform(SetSize,max);
break;
case 2:
int[] inter=cdg.generateClustered(1 << (18 / 2),max);
data[i]=IntUtil.unite(inter,cdg.generateClustered(1 << 18,max));
data2[i]=IntUtil.unite(inter,cdg.generateClustered(1 << 18,max));
break;
default :
System.out.println(""String_Node_Str"");
System.exit(0);
}
Arrays.sort(data[i]);
Arrays.sort(data2[i]);
}
System.out.println(""String_Node_Str"");
System.out.println(""String_Node_Str"" + density + ""String_Node_Str""+ SetSize);
try {
bw.write(""String_Node_Str"" + ""String_Node_Str"" + density + ""String_Node_Str""+ SetSize);
}
 catch (IOException e) {
e.printStackTrace();
}
testRoaringBitmap(data.clone(),data2.clone(),repeat,df,optimisation);
testWAH32(data.clone(),data2.clone(),repeat,df,optimisation);
testConciseSet(data.clone(),data2.clone(),repeat,df,optimisation);
testSparseBitmap(data.clone(),data2.clone(),repeat,df,optimisation);
testEWAH64(data.clone(),data2.clone(),repeat,df,optimisation);
System.out.println();
}
if (Chartsdir != null) {
String p=Chartsdir + File.separator;
try {
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",SizeGraphCoordinates,p);
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",OrGraphCoordinates,p);
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",AndGraphCoordinates,p);
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",XorGraphCoordinates,p);
}
 catch (java.awt.HeadlessException e) {
System.out.println(""String_Node_Str"");
}
}
}
try {
bw.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}","public static void launchBenchmark(int distribution,int N,int repeat,String distdir,int optimisation){
  String Chartsdir=null, Benchmarkdir=null, optdir=null;
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  if (distdir != null) switch (optimisation) {
case 0:
    optdir=distdir + File.separator + ""String_Node_Str"";
  break;
case 1:
optdir=distdir + File.separator + ""String_Node_Str"";
break;
case 2:
optdir=distdir + File.separator + ""String_Node_Str"";
break;
case 3:
optdir=distdir + File.separator + ""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"");
System.exit(0);
}
if (optdir != null) Chartsdir=optdir + File.separator + ""String_Node_Str"";
if (optdir != null) Benchmarkdir=optdir + File.separator + ""String_Node_Str"";
try {
boolean success=(new File(Chartsdir).mkdirs());
boolean success2=(new File(Benchmarkdir).mkdirs());
if (success & success2) System.out.println(""String_Node_Str"");
}
 catch (Exception e) {
e.getMessage();
}
try {
File file=new File(Benchmarkdir + ""String_Node_Str"");
if (!file.exists()) file.createNewFile();
Date date=new Date();
SimpleDateFormat dateFormatComp;
dateFormatComp=new SimpleDateFormat(""String_Node_Str"");
String[] op={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
System.out.println(""String_Node_Str"");
System.out.println(""String_Node_Str"");
System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + N + ""String_Node_Str""+ max+ ""String_Node_Str""+ op[optimisation]+ ""String_Node_Str""+ dateFormatComp.format(date)+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str""));
FileWriter fw=new FileWriter(file.getAbsoluteFile());
bw=null;
bw=new BufferedWriter(fw);
bw.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + N + ""String_Node_Str""+ max+ ""String_Node_Str""+ op[optimisation]+ ""String_Node_Str""+ dateFormatComp.format(date)+ ""String_Node_Str""+ System.getenv(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str""));
}
 catch (IOException e) {
e.printStackTrace();
}
for (double k=0.001; k < 1.0; k*=10) {
SizeGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
OrGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
AndGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
XorGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
for (int i=0; i < nbTechnique; i++) {
SizeGraphCoordinates.add(new Vector<LineChartPoint>());
OrGraphCoordinates.add(new Vector<LineChartPoint>());
AndGraphCoordinates.add(new Vector<LineChartPoint>());
XorGraphCoordinates.add(new Vector<LineChartPoint>());
}
for (double density=k; density < k * 10.0; density+=density) {
if (density >= 0.7) density=0.6;
int SetSize=(int)(max * density);
int data[][]=new int[N][];
int data2[][]=new int[N][];
System.out.println(""String_Node_Str"" + density);
System.out.println(""String_Node_Str"");
try {
bw.write(""String_Node_Str"" + density + ""String_Node_Str"");
}
 catch (IOException e1) {
e1.printStackTrace();
}
for (int i=0; i < nbTechnique; i++) {
SizeGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
OrGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
AndGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
XorGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
}
for (int i=0; i < N; i++) {
switch (distribution) {
case 0:
data[i]=zpf.GenartingInts(SetSize,max);
data2[i]=zpf.GenartingInts(SetSize,max);
break;
case 1:
data[i]=uniform.generateUniform(SetSize,max);
data2[i]=uniform.generateUniform(SetSize,max);
break;
case 2:
int[] inter=cdg.generateClustered(1 << (18 / 2),max);
data[i]=IntUtil.unite(inter,cdg.generateClustered(1 << 18,max));
data2[i]=IntUtil.unite(inter,cdg.generateClustered(1 << 18,max));
break;
default :
System.out.println(""String_Node_Str"");
System.exit(0);
}
Arrays.sort(data[i]);
Arrays.sort(data2[i]);
}
System.out.println(""String_Node_Str"");
System.out.println(""String_Node_Str"" + density + ""String_Node_Str""+ SetSize);
try {
bw.write(""String_Node_Str"" + ""String_Node_Str"" + density + ""String_Node_Str""+ SetSize);
}
 catch (IOException e) {
e.printStackTrace();
}
testRoaringBitmap(data.clone(),data2.clone(),repeat,df,optimisation);
testWAH32(data.clone(),data2.clone(),repeat,df,optimisation);
testConciseSet(data.clone(),data2.clone(),repeat,df,optimisation);
testSparseBitmap(data.clone(),data2.clone(),repeat,df,optimisation);
testEWAH64(data.clone(),data2.clone(),repeat,df,optimisation);
testEWAH32(data.clone(),data2.clone(),repeat,df,optimisation);
System.out.println();
}
if (Chartsdir != null) {
String p=Chartsdir + File.separator;
try {
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",SizeGraphCoordinates,p);
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",OrGraphCoordinates,p);
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",AndGraphCoordinates,p);
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",XorGraphCoordinates,p);
}
 catch (Exception e) {
System.out.println(""String_Node_Str"");
}
}
}
try {
bw.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}"
90386,"public static void launchBenchmark(int distribution,int N,int repeat,String distdir,int optimisation){
  String Chartsdir=null, Benchmarkdir=null, optdir=null;
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
switch (optimisation) {
case 0:
    optdir=distdir + File.separator + ""String_Node_Str"";
  break;
case 1:
optdir=distdir + File.separator + ""String_Node_Str"";
break;
case 2:
optdir=distdir + File.separator + ""String_Node_Str"";
break;
case 3:
optdir=distdir + File.separator + ""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"");
System.exit(0);
}
Chartsdir=optdir + File.separator + ""String_Node_Str"";
Benchmarkdir=optdir + File.separator + ""String_Node_Str"";
try {
boolean success=(new File(Chartsdir).mkdirs());
boolean success2=(new File(Benchmarkdir).mkdirs());
if (success & success2) System.out.println(""String_Node_Str"");
}
 catch (Exception e) {
e.getMessage();
}
try {
File file=new File(Benchmarkdir + ""String_Node_Str"");
if (!file.exists()) file.createNewFile();
Date date=new Date();
SimpleDateFormat dateFormatComp;
dateFormatComp=new SimpleDateFormat(""String_Node_Str"");
String[] op={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
System.out.println(""String_Node_Str"");
System.out.println(""String_Node_Str"");
System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + N + ""String_Node_Str""+ max+ ""String_Node_Str""+ op[optimisation]+ ""String_Node_Str""+ dateFormatComp.format(date)+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str""));
FileWriter fw=new FileWriter(file.getAbsoluteFile());
bw=null;
bw=new BufferedWriter(fw);
bw.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + N + ""String_Node_Str""+ max+ ""String_Node_Str""+ op[optimisation]+ ""String_Node_Str""+ dateFormatComp.format(date)+ ""String_Node_Str""+ System.getenv(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str""));
}
 catch (IOException e) {
e.printStackTrace();
}
for (double k=0.001; k < 1.0; k*=10) {
SizeGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
OrGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
AndGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
XorGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
for (int i=0; i < nbTechnique; i++) {
SizeGraphCoordinates.add(new Vector<LineChartPoint>());
OrGraphCoordinates.add(new Vector<LineChartPoint>());
AndGraphCoordinates.add(new Vector<LineChartPoint>());
XorGraphCoordinates.add(new Vector<LineChartPoint>());
}
for (double density=k; density < k * 10.0; density+=density) {
if (density >= 0.7) density=0.6;
int SetSize=(int)(max * density);
int data[][]=new int[N][];
int data2[][]=new int[N][];
System.out.println(""String_Node_Str"" + density);
System.out.println(""String_Node_Str"");
try {
bw.write(""String_Node_Str"" + density + ""String_Node_Str"");
}
 catch (IOException e1) {
e1.printStackTrace();
}
for (int i=0; i < nbTechnique; i++) {
SizeGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
OrGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
AndGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
XorGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
}
for (int i=0; i < N; i++) {
switch (distribution) {
case 0:
data[i]=zpf.GenartingInts(SetSize,max);
data2[i]=zpf.GenartingInts(SetSize,max);
break;
case 1:
data[i]=uniform.generateUniform(SetSize,max);
data2[i]=uniform.generateUniform(SetSize,max);
break;
case 2:
int[] inter=cdg.generateClustered(1 << (18 / 2),max);
data[i]=IntUtil.unite(inter,cdg.generateClustered(1 << 18,max));
data2[i]=IntUtil.unite(inter,cdg.generateClustered(1 << 18,max));
break;
default :
System.out.println(""String_Node_Str"");
System.exit(0);
}
Arrays.sort(data[i]);
Arrays.sort(data2[i]);
}
System.out.println(""String_Node_Str"");
System.out.println(""String_Node_Str"" + density + ""String_Node_Str""+ SetSize+ ""String_Node_Str""+ (32 * density));
try {
bw.write(""String_Node_Str"" + ""String_Node_Str"" + density + ""String_Node_Str""+ SetSize);
}
 catch (IOException e) {
e.printStackTrace();
}
testSpeedyRoaringBitmap(data.clone(),data2.clone(),repeat,df,optimisation);
testRoaringBitmap(data.clone(),data2.clone(),repeat,df,optimisation);
testWAH32(data.clone(),data2.clone(),repeat,df,optimisation);
testConciseSet(data.clone(),data2.clone(),repeat,df,optimisation);
testSparseBitmap(data.clone(),data2.clone(),repeat,df,optimisation);
testSparseBitSet(data.clone(),data2.clone(),repeat,df,optimisation);
testEWAH64(data.clone(),data2.clone(),repeat,df,optimisation);
System.out.println();
}
if (Chartsdir != null) {
String p=Chartsdir + File.separator;
try {
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",SizeGraphCoordinates,p);
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",OrGraphCoordinates,p);
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",AndGraphCoordinates,p);
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",XorGraphCoordinates,p);
}
 catch (java.awt.HeadlessException e) {
System.out.println(""String_Node_Str"");
}
}
}
try {
bw.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}","public static void launchBenchmark(int distribution,int N,int repeat,String distdir,int optimisation){
  String Chartsdir=null, Benchmarkdir=null, optdir=null;
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  if (distdir != null) switch (optimisation) {
case 0:
    optdir=distdir + File.separator + ""String_Node_Str"";
  break;
case 1:
optdir=distdir + File.separator + ""String_Node_Str"";
break;
case 2:
optdir=distdir + File.separator + ""String_Node_Str"";
break;
case 3:
optdir=distdir + File.separator + ""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"");
System.exit(0);
}
if (optdir != null) Chartsdir=optdir + File.separator + ""String_Node_Str"";
if (optdir != null) Benchmarkdir=optdir + File.separator + ""String_Node_Str"";
try {
boolean success=(new File(Chartsdir).mkdirs());
boolean success2=(new File(Benchmarkdir).mkdirs());
if (success & success2) System.out.println(""String_Node_Str"");
}
 catch (Exception e) {
e.getMessage();
}
try {
File file=new File(Benchmarkdir + ""String_Node_Str"");
if (!file.exists()) file.createNewFile();
Date date=new Date();
SimpleDateFormat dateFormatComp;
dateFormatComp=new SimpleDateFormat(""String_Node_Str"");
String[] op={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
System.out.println(""String_Node_Str"");
System.out.println(""String_Node_Str"");
System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + N + ""String_Node_Str""+ max+ ""String_Node_Str""+ op[optimisation]+ ""String_Node_Str""+ dateFormatComp.format(date)+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str""));
FileWriter fw=new FileWriter(file.getAbsoluteFile());
bw=null;
bw=new BufferedWriter(fw);
bw.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + N + ""String_Node_Str""+ max+ ""String_Node_Str""+ op[optimisation]+ ""String_Node_Str""+ dateFormatComp.format(date)+ ""String_Node_Str""+ System.getenv(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str""));
}
 catch (IOException e) {
e.printStackTrace();
}
for (double k=0.001; k < 1.0; k*=10) {
SizeGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
OrGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
AndGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
XorGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
for (int i=0; i < nbTechnique; i++) {
SizeGraphCoordinates.add(new Vector<LineChartPoint>());
OrGraphCoordinates.add(new Vector<LineChartPoint>());
AndGraphCoordinates.add(new Vector<LineChartPoint>());
XorGraphCoordinates.add(new Vector<LineChartPoint>());
}
for (double density=k; density < k * 10.0; density+=density) {
if (density >= 0.7) density=0.6;
int SetSize=(int)(max * density);
int data[][]=new int[N][];
int data2[][]=new int[N][];
System.out.println(""String_Node_Str"" + density);
System.out.println(""String_Node_Str"");
try {
bw.write(""String_Node_Str"" + density + ""String_Node_Str"");
}
 catch (IOException e1) {
e1.printStackTrace();
}
for (int i=0; i < nbTechnique; i++) {
SizeGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
OrGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
AndGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
XorGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
}
for (int i=0; i < N; i++) {
switch (distribution) {
case 0:
data[i]=zpf.GenartingInts(SetSize,max);
data2[i]=zpf.GenartingInts(SetSize,max);
break;
case 1:
data[i]=uniform.generateUniform(SetSize,max);
data2[i]=uniform.generateUniform(SetSize,max);
break;
case 2:
int[] inter=cdg.generateClustered(1 << (18 / 2),max);
data[i]=IntUtil.unite(inter,cdg.generateClustered(1 << 18,max));
data2[i]=IntUtil.unite(inter,cdg.generateClustered(1 << 18,max));
break;
default :
System.out.println(""String_Node_Str"");
System.exit(0);
}
Arrays.sort(data[i]);
Arrays.sort(data2[i]);
}
System.out.println(""String_Node_Str"");
System.out.println(""String_Node_Str"" + density + ""String_Node_Str""+ SetSize+ ""String_Node_Str""+ (32 * density));
try {
bw.write(""String_Node_Str"" + ""String_Node_Str"" + density + ""String_Node_Str""+ SetSize);
}
 catch (IOException e) {
e.printStackTrace();
}
testSpeedyRoaringBitmap(data.clone(),data2.clone(),repeat,df,optimisation);
testRoaringBitmap(data.clone(),data2.clone(),repeat,df,optimisation);
testWAH32(data.clone(),data2.clone(),repeat,df,optimisation);
testConciseSet(data.clone(),data2.clone(),repeat,df,optimisation);
testSparseBitmap(data.clone(),data2.clone(),repeat,df,optimisation);
testSparseBitSet(data.clone(),data2.clone(),repeat,df,optimisation);
testEWAH64(data.clone(),data2.clone(),repeat,df,optimisation);
testEWAH32(data.clone(),data2.clone(),repeat,df,optimisation);
System.out.println();
}
if (Chartsdir != null) {
String p=Chartsdir + File.separator;
try {
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",SizeGraphCoordinates,p);
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",OrGraphCoordinates,p);
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",AndGraphCoordinates,p);
new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),""String_Node_Str"",XorGraphCoordinates,p);
}
 catch (Exception e) {
System.out.println(""String_Node_Str"");
}
}
}
try {
bw.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}"
90387,"/** 
 * Generating N sets of nbInts integers using Zipfian distribution.
 * @param N number of generated sets of integers
 * @param repeat number of repetitions
 */
public static void Tests(int N,int repeat,String path,int distribution){
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  zpf=new ZipfianDistribution();
  uniform=new UniformDataGenerator();
  cdg=new ClusteredDataGenerator();
  String distdir=null;
switch (distribution) {
case 0:
    distdir=path + File.separator + ""String_Node_Str""+ CPU+ File.separator+ ""String_Node_Str"";
  break;
case 1:
distdir=path + File.separator + ""String_Node_Str""+ CPU+ File.separator+ ""String_Node_Str"";
break;
case 2:
distdir=path + File.separator + ""String_Node_Str""+ CPU+ File.separator+ ""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"");
System.exit(0);
}
launchBenchmark(distribution,N,repeat,distdir,classic);
}","/** 
 * Generating N sets of nbInts integers using Zipfian distribution.
 * @param N number of generated sets of integers
 * @param repeat number of repetitions
 */
public static void Tests(int N,int repeat,String path,int distribution){
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  zpf=new ZipfianDistribution();
  uniform=new UniformDataGenerator();
  cdg=new ClusteredDataGenerator();
  String distdir=null;
  if (path != null) switch (distribution) {
case 0:
    distdir=path + File.separator + ""String_Node_Str""+ CPU+ File.separator+ ""String_Node_Str"";
  break;
case 1:
distdir=path + File.separator + ""String_Node_Str""+ CPU+ File.separator+ ""String_Node_Str"";
break;
case 2:
distdir=path + File.separator + ""String_Node_Str""+ CPU+ File.separator+ ""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"");
System.exit(0);
}
launchBenchmark(distribution,N,repeat,distdir,classic);
}"
90388,"public static BitmapContainer getBitmapContainer(){
  if (Bbuffer.isEmpty())   return new BitmapContainer();
  return Bbuffer.remove(Bbuffer.size() - 1);
}","/** 
 * Warning: the BitmapContainer won't be initialized as empty.
 * @return a BitmapContainer
 */
public static BitmapContainer getBitmapContainer(){
  if (Bbuffer.isEmpty())   return new BitmapContainer();
  return Bbuffer.remove(Bbuffer.size() - 1);
}"
90389,"public static BitmapContainer transformToBitmapContainer(ArrayContainer ac){
  BitmapContainer bc=Bbuffer.isEmpty() ? new BitmapContainer() : Bbuffer.remove(Bbuffer.size() - 1);
  bc.loadData(ac);
  putBackInStore(ac);
  return bc;
}","public static BitmapContainer transformToBitmapContainer(ArrayContainer ac){
  BitmapContainer bc;
  if (Bbuffer.isEmpty())   bc=new BitmapContainer();
 else {
    bc=Bbuffer.remove(Bbuffer.size() - 1);
    bc.clear();
  }
  bc.loadData(ac);
  putBackInStore(ac);
  return bc;
}"
90390,"/** 
 * Generating N sets of nbInts integers uzing Zipfian distribution
 * @param N number of generated sets of integers
 * @param repeat number of repetitions
 */
public static void ZipfianTests(int N,int repeat,String path,int distribution){
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  ZipfianDistribution zpf=new ZipfianDistribution();
  uniform=new UniformDataGenerator();
  String Chartdirs=distribution == distUniform ? path + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"" : path + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  String Benchmarkdirs=distribution == distUniform ? path + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"" : path + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  try {
    boolean success=(new File(Chartdirs).mkdirs());
    boolean success2=(new File(Benchmarkdirs).mkdirs());
    if (success)     System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.getMessage();
  }
  try {
    File file=new File(Benchmarkdirs + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    FileWriter fw=new FileWriter(file.getAbsoluteFile());
    bw=new BufferedWriter(fw);
    bw.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  for (double k=0.0001; k < 0.001; k*=10) {
    SizeGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
    OrGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
    AndGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
    XorGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
    for (int i=0; i < nbTechnique; i++) {
      SizeGraphCoordinates.add(new Vector<LineChartPoint>());
      OrGraphCoordinates.add(new Vector<LineChartPoint>());
      AndGraphCoordinates.add(new Vector<LineChartPoint>());
      XorGraphCoordinates.add(new Vector<LineChartPoint>());
    }
    for (double density=k; density < k * 10.0; density+=density) {
      if (density >= 0.7)       density=0.6;
      int max=10000000;
      int SetSize=(int)(max * density);
      int data[][]=new int[N][];
      int data2[][]=new int[N][];
      System.out.println(""String_Node_Str"" + density);
      System.out.println(""String_Node_Str"");
      try {
        bw.write(""String_Node_Str"" + density + ""String_Node_Str"");
      }
 catch (      IOException e1) {
        e1.printStackTrace();
      }
      for (int i=0; i < nbTechnique; i++) {
        SizeGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
        OrGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
        AndGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
        XorGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
      }
      for (int i=0; i < N; i++) {
        data[i]=distribution == distUniform ? uniform.generateUniform(SetSize,max) : zpf.GenartingInts(SetSize,max);
        data2[i]=distribution == distUniform ? uniform.generateUniform(SetSize,max) : zpf.GenartingInts(SetSize,max);
        Arrays.sort(data[i]);
        Arrays.sort(data2[i]);
      }
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + density + ""String_Node_Str""+ SetSize);
      try {
        bw.write(""String_Node_Str"" + ""String_Node_Str"" + density + ""String_Node_Str""+ SetSize);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
      testRoaringBitmap(data,data2,repeat,df);
      testWAH32(data,data2,repeat,df);
      testConciseSet(data,data2,repeat,df);
      testSparseBitmap(data,data2,repeat,df);
      testEWAH64(data,data2,repeat,df);
      testEWAH32(data,data2,repeat,df);
      System.out.println();
    }
    if (path != null) {
      path+=distribution == distUniform ? ""String_Node_Str"" : ""String_Node_Str"";
      path+=""String_Node_Str"";
      new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),SizeGraphCoordinates,path);
      new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),OrGraphCoordinates,path);
      new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),AndGraphCoordinates,path);
      new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),XorGraphCoordinates,path);
    }
  }
  try {
    bw.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Generating N sets of nbInts integers uzing Zipfian distribution
 * @param N number of generated sets of integers
 * @param repeat number of repetitions
 */
public static void ZipfianTests(int N,int repeat,String path,int distribution){
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  ZipfianDistribution zpf=new ZipfianDistribution();
  uniform=new UniformDataGenerator();
  String Chartdirs=distribution == distUniform ? path + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"" : path + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  String Benchmarkdirs=distribution == distUniform ? path + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"" : path + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  try {
    boolean success=(new File(Chartdirs).mkdirs());
    boolean success2=(new File(Benchmarkdirs).mkdirs());
    if (success)     System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.getMessage();
  }
  try {
    File file=new File(Benchmarkdirs + ""String_Node_Str"");
    if (!file.exists()) {
      file.createNewFile();
    }
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    FileWriter fw=new FileWriter(file.getAbsoluteFile());
    bw=new BufferedWriter(fw);
    bw.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  for (double k=0.0001; k < 1.0; k*=10) {
    SizeGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
    OrGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
    AndGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
    XorGraphCoordinates=new ArrayList<Vector<LineChartPoint>>();
    for (int i=0; i < nbTechnique; i++) {
      SizeGraphCoordinates.add(new Vector<LineChartPoint>());
      OrGraphCoordinates.add(new Vector<LineChartPoint>());
      AndGraphCoordinates.add(new Vector<LineChartPoint>());
      XorGraphCoordinates.add(new Vector<LineChartPoint>());
    }
    for (double density=k; density < k * 10.0; density+=density) {
      if (density >= 0.7)       density=0.6;
      int max=10000000;
      int SetSize=(int)(max * density);
      int data[][]=new int[N][];
      int data2[][]=new int[N][];
      System.out.println(""String_Node_Str"" + density);
      System.out.println(""String_Node_Str"");
      try {
        bw.write(""String_Node_Str"" + density + ""String_Node_Str"");
      }
 catch (      IOException e1) {
        e1.printStackTrace();
      }
      for (int i=0; i < nbTechnique; i++) {
        SizeGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
        OrGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
        AndGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
        XorGraphCoordinates.get(i).add(new LineChartPoint(0.0,String.valueOf(density),null));
      }
      for (int i=0; i < N; i++) {
        data[i]=distribution == distUniform ? uniform.generateUniform(SetSize,max) : zpf.GenartingInts(SetSize,max);
        data2[i]=distribution == distUniform ? uniform.generateUniform(SetSize,max) : zpf.GenartingInts(SetSize,max);
        Arrays.sort(data[i]);
        Arrays.sort(data2[i]);
      }
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + density + ""String_Node_Str""+ SetSize);
      try {
        bw.write(""String_Node_Str"" + ""String_Node_Str"" + density + ""String_Node_Str""+ SetSize);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
      testRoaringBitmap(data,data2,repeat,df);
      testWAH32(data,data2,repeat,df);
      testConciseSet(data,data2,repeat,df);
      testSparseBitmap(data,data2,repeat,df);
      testEWAH64(data,data2,repeat,df);
      testEWAH32(data,data2,repeat,df);
      System.out.println();
    }
    if (path != null) {
      String p=distribution == distUniform ? path + ""String_Node_Str"" : path + ""String_Node_Str"";
      p+=""String_Node_Str"";
      new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),SizeGraphCoordinates,p);
      new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),OrGraphCoordinates,p);
      new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),AndGraphCoordinates,p);
      new LineChartDemo1(""String_Node_Str"" + k + ""String_Node_Str""+ (k * 10),XorGraphCoordinates,p);
    }
  }
  try {
    bw.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
90391,"/** 
 * running time is in O(n) time if insert is not in order.
 */
@Override public Container add(short x){
  if ((cardinality == 0) || (Util.toIntUnsigned(x) > Util.toIntUnsigned(content[cardinality - 1]))) {
    if (cardinality == content.length) {
      BitmapContainer a=ContainerFactory.transformToBitmapContainer(this);
      a.add(x);
      return a;
    }
    content[cardinality++]=x;
    return this;
  }
  int loc=Util.unsigned_binarySearch(content,0,cardinality,x);
  if (loc < 0) {
    if (cardinality == content.length) {
      BitmapContainer a=ContainerFactory.transformToBitmapContainer(this);
      a.add(x);
      return a;
    }
    System.arraycopy(content,-loc - 1,content,-loc,cardinality + loc + 1);
    content[-loc - 1]=x;
    ++cardinality;
  }
  return this;
}","/** 
 * running time is in O(n) time if insert is not in order.
 */
@Override public Container add(final short x){
  if ((cardinality == 0) || (Util.toIntUnsigned(x) > Util.toIntUnsigned(content[cardinality - 1]))) {
    if (cardinality == content.length) {
      BitmapContainer a=ContainerFactory.transformToBitmapContainer(this);
      a.add(x);
      return a;
    }
    content[cardinality++]=x;
    return this;
  }
  int loc=Util.unsigned_binarySearch(content,0,cardinality,x);
  if (loc < 0) {
    if (cardinality == content.length) {
      BitmapContainer a=ContainerFactory.transformToBitmapContainer(this);
      a.add(x);
      return a;
    }
    System.arraycopy(content,-loc - 1,content,-loc,cardinality + loc + 1);
    content[-loc - 1]=x;
    ++cardinality;
  }
  return this;
}"
90392,"public Container or(ArrayContainer value2){
  ArrayContainer value1=this;
  int tailleAC=value1.getCardinality() + value2.getCardinality();
  final int desiredcapacity=tailleAC > 65535 ? 65535 : tailleAC;
  ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < desiredcapacity)   answer.content=new short[desiredcapacity];
  answer.cardinality=Util.unsigned_union2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  if (answer.cardinality > DEFAULTMAXSIZE)   return ContainerFactory.transformToBitmapContainer(answer);
  return answer;
}","public Container or(final ArrayContainer value2){
  final ArrayContainer value1=this;
  int tailleAC=value1.getCardinality() + value2.getCardinality();
  final int desiredcapacity=tailleAC > 65535 ? 65535 : tailleAC;
  ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < desiredcapacity)   answer.content=new short[desiredcapacity];
  answer.cardinality=Util.unsigned_union2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  if (answer.cardinality > DEFAULTMAXSIZE)   return ContainerFactory.transformToBitmapContainer(answer);
  return answer;
}"
90393,"public void loadData(BitmapContainer bitmapContainer){
  if (content.length < bitmapContainer.cardinality)   content=new short[bitmapContainer.cardinality];
  this.cardinality=bitmapContainer.cardinality;
  int pos=0;
  for (int i=bitmapContainer.nextSetBit(0); i >= 0; i=bitmapContainer.nextSetBit(i + 1)) {
    content[pos++]=(short)i;
  }
  if (pos != this.cardinality)   throw new RuntimeException(""String_Node_Str"" + pos + ""String_Node_Str""+ this.cardinality);
}","public void loadData(final BitmapContainer bitmapContainer){
  if (content.length < bitmapContainer.cardinality)   content=new short[bitmapContainer.cardinality];
  this.cardinality=bitmapContainer.cardinality;
  int pos=0;
  for (int i=bitmapContainer.nextSetBit(0); i >= 0; i=bitmapContainer.nextSetBit(i + 1)) {
    content[pos++]=(short)i;
  }
  if (pos != this.cardinality)   throw new RuntimeException(""String_Node_Str"" + pos + ""String_Node_Str""+ this.cardinality);
}"
90394,"@Override public boolean contains(short x){
  return Util.unsigned_binarySearch(content,0,cardinality,x) >= 0;
}","@Override public boolean contains(final short x){
  return Util.unsigned_binarySearch(content,0,cardinality,x) >= 0;
}"
90395,"public ArrayContainer and(ArrayContainer value2){
  ArrayContainer value1=this;
  final int desiredcapacity=Math.min(value1.getCardinality(),value2.getCardinality());
  ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < desiredcapacity)   answer.content=new short[desiredcapacity];
  answer.cardinality=Util.unsigned_intersect2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  return answer;
}","public ArrayContainer and(final ArrayContainer value2){
  ArrayContainer value1=this;
  final int desiredcapacity=Math.min(value1.getCardinality(),value2.getCardinality());
  ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < desiredcapacity)   answer.content=new short[desiredcapacity];
  answer.cardinality=Util.unsigned_intersect2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  return answer;
}"
90396,"@Override public ArrayContainer clone(){
  try {
    ArrayContainer x=(ArrayContainer)super.clone();
    x.cardinality=this.cardinality;
    x.content=Arrays.copyOf(content,content.length);
    return x;
  }
 catch (  CloneNotSupportedException e) {
    throw new java.lang.RuntimeException();
  }
}","@Override public ArrayContainer clone(){
  try {
    final ArrayContainer x=(ArrayContainer)super.clone();
    x.cardinality=this.cardinality;
    x.content=Arrays.copyOf(content,content.length);
    return x;
  }
 catch (  CloneNotSupportedException e) {
    throw new java.lang.RuntimeException();
  }
}"
90397,"public Container xor(ArrayContainer value2){
  ArrayContainer value1=this;
  final int desiredcapacity=Math.min(value1.getCardinality() + value2.getCardinality(),65536);
  ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < desiredcapacity)   answer.content=new short[desiredcapacity];
  answer.cardinality=Util.unsigned_exclusiveunion2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  if (answer.cardinality > DEFAULTMAXSIZE)   return ContainerFactory.transformToBitmapContainer(answer);
  return answer;
}","public Container xor(final ArrayContainer value2){
  final ArrayContainer value1=this;
  final int desiredcapacity=Math.min(value1.getCardinality() + value2.getCardinality(),65536);
  ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < desiredcapacity)   answer.content=new short[desiredcapacity];
  answer.cardinality=Util.unsigned_exclusiveunion2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  if (answer.cardinality > DEFAULTMAXSIZE)   return ContainerFactory.transformToBitmapContainer(answer);
  return answer;
}"
90398,"@Override public Container add(short i){
  final int x=Util.toIntUnsigned(i);
  final long previous=bitmap[x / 64];
  if (previous != (bitmap[x / 64]|=(1l << x)))   ++cardinality;
  return this;
}","@Override public Container add(final short i){
  final int x=Util.toIntUnsigned(i);
  final long previous=bitmap[x / 64];
  if (previous != (bitmap[x / 64]|=(1l << x)))   ++cardinality;
  return this;
}"
90399,"public Container or(BitmapContainer value2){
  BitmapContainer answer=ContainerFactory.getBitmapContainer();
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=this.bitmap[k] | value2.bitmap[k];
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  return answer;
}","public Container or(final BitmapContainer value2){
  final BitmapContainer answer=ContainerFactory.getBitmapContainer();
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=this.bitmap[k] | value2.bitmap[k];
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  return answer;
}"
90400,"public short nextUnsetBit(int i){
  int x=i / 64;
  long w=~bitmap[x];
  w>>>=i;
  if (w != 0) {
    return (short)(i + Long.numberOfTrailingZeros(w));
  }
  ++x;
  for (; x < bitmap.length; ++x) {
    if (bitmap[x] != ~0) {
      return (short)(x * 64 + Long.numberOfTrailingZeros(~bitmap[x]));
    }
  }
  return -1;
}","public short nextUnsetBit(final int i){
  int x=i / 64;
  long w=~bitmap[x];
  w>>>=i;
  if (w != 0) {
    return (short)(i + Long.numberOfTrailingZeros(w));
  }
  ++x;
  for (; x < bitmap.length; ++x) {
    if (bitmap[x] != ~0) {
      return (short)(x * 64 + Long.numberOfTrailingZeros(~bitmap[x]));
    }
  }
  return -1;
}"
90401,"public void loadData(ArrayContainer arrayContainer){
  this.cardinality=arrayContainer.cardinality;
  for (int k=0; k < arrayContainer.cardinality; ++k) {
    final short x=arrayContainer.content[k];
    bitmap[Util.toIntUnsigned(x) / 64]|=(1l << x);
  }
}","public void loadData(final ArrayContainer arrayContainer){
  this.cardinality=arrayContainer.cardinality;
  for (int k=0; k < arrayContainer.cardinality; ++k) {
    final short x=arrayContainer.content[k];
    bitmap[Util.toIntUnsigned(x) / 64]|=(1l << x);
  }
}"
90402,"public int nextSetBit(int i){
  int x=i / 64;
  if (x >= bitmap.length)   return -1;
  long w=bitmap[x];
  w>>>=i;
  if (w != 0) {
    return i + Long.numberOfTrailingZeros(w);
  }
  ++x;
  for (; x < bitmap.length; ++x) {
    if (bitmap[x] != 0) {
      return x * 64 + Long.numberOfTrailingZeros(bitmap[x]);
    }
  }
  return -1;
}","public int nextSetBit(final int i){
  int x=i / 64;
  if (x >= bitmap.length)   return -1;
  long w=bitmap[x];
  w>>>=i;
  if (w != 0) {
    return i + Long.numberOfTrailingZeros(w);
  }
  ++x;
  for (; x < bitmap.length; ++x) {
    if (bitmap[x] != 0) {
      return x * 64 + Long.numberOfTrailingZeros(bitmap[x]);
    }
  }
  return -1;
}"
90403,"@Override public boolean contains(short i){
  final int x=Util.toIntUnsigned(i);
  return (bitmap[x / 64] & (1l << x)) != 0;
}","@Override public boolean contains(final short i){
  final int x=Util.toIntUnsigned(i);
  return (bitmap[x / 64] & (1l << x)) != 0;
}"
90404,"public ArrayContainer and(ArrayContainer value2){
  ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < value2.content.length)   answer.content=new short[value2.content.length];
  for (int k=0; k < value2.getCardinality(); ++k)   if (this.contains(value2.content[k]))   answer.content[answer.cardinality++]=value2.content[k];
  return answer;
}","public ArrayContainer and(final ArrayContainer value2){
  final ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < value2.content.length)   answer.content=new short[value2.content.length];
  for (int k=0; k < value2.getCardinality(); ++k)   if (this.contains(value2.content[k]))   answer.content[answer.cardinality++]=value2.content[k];
  return answer;
}"
90405,"@Override public BitmapContainer clone(){
  try {
    BitmapContainer x=(BitmapContainer)super.clone();
    x.cardinality=this.cardinality;
    System.arraycopy(this.bitmap,0,x.bitmap,0,x.bitmap.length);
    return x;
  }
 catch (  CloneNotSupportedException e) {
    throw new java.lang.RuntimeException();
  }
}","@Override public BitmapContainer clone(){
  try {
    final BitmapContainer x=(BitmapContainer)super.clone();
    x.cardinality=this.cardinality;
    x.bitmap=Arrays.copyOf(this.bitmap,this.bitmap.length);
    return x;
  }
 catch (  CloneNotSupportedException e) {
    throw new java.lang.RuntimeException();
  }
}"
90406,"public Container xor(BitmapContainer value2){
  BitmapContainer answer=ContainerFactory.getBitmapContainer();
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=this.bitmap[k] ^ value2.bitmap[k];
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  if (answer.cardinality <= ArrayContainer.DEFAULTMAXSIZE)   return ContainerFactory.transformToArrayContainer(answer);
  return answer;
}","public Container xor(BitmapContainer value2){
  final BitmapContainer answer=ContainerFactory.getBitmapContainer();
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=this.bitmap[k] ^ value2.bitmap[k];
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  if (answer.cardinality <= ArrayContainer.DEFAULTMAXSIZE)   return ContainerFactory.transformToArrayContainer(answer);
  return answer;
}"
90407,"public static BitmapContainer transformToBitmapContainer(ArrayContainer ac){
  BitmapContainer bc;
  if (Bbuffer.isEmpty())   bc=new BitmapContainer();
 else {
    bc=Bbuffer.remove(Bbuffer.size() - 1);
    bc.clear();
  }
  bc.loadData(ac);
  putBackInStore(ac);
  return bc;
}","public static BitmapContainer transformToBitmapContainer(ArrayContainer ac){
  BitmapContainer bc=Bbuffer.isEmpty() ? new BitmapContainer() : Bbuffer.remove(Bbuffer.size() - 1);
  bc.loadData(ac);
  putBackInStore(ac);
  return bc;
}"
90408,"/** 
 * running time is in O(n) time if insert is not in order.
 */
@Override public Container add(short x){
  if ((cardinality == 0) || (Util.toIntUnsigned(x) > content[cardinality - 1])) {
    if (cardinality == content.length) {
      BitmapContainer a=ContainerFactory.transformToBitmapContainer(this);
      a.add(x);
      return a;
    }
    content[cardinality++]=x;
    return this;
  }
  int loc=Util.unsigned_binarySearch(content,0,cardinality,x);
  if (loc < 0) {
    if (cardinality == content.length) {
      BitmapContainer a=ContainerFactory.transformToBitmapContainer(this);
      a.add(x);
      return a;
    }
    System.arraycopy(content,-loc - 1,content,-loc,cardinality + loc + 1);
    content[-loc - 1]=x;
    ++cardinality;
  }
  return this;
}","/** 
 * running time is in O(n) time if insert is not in order.
 */
@Override public Container add(short x){
  if ((cardinality == 0) || (Util.toIntUnsigned(x) > Util.toIntUnsigned(content[cardinality - 1]))) {
    if (cardinality == content.length) {
      BitmapContainer a=ContainerFactory.transformToBitmapContainer(this);
      a.add(x);
      return a;
    }
    content[cardinality++]=x;
    return this;
  }
  int loc=Util.unsigned_binarySearch(content,0,cardinality,x);
  if (loc < 0) {
    if (cardinality == content.length) {
      BitmapContainer a=ContainerFactory.transformToBitmapContainer(this);
      a.add(x);
      return a;
    }
    System.arraycopy(content,-loc - 1,content,-loc,cardinality + loc + 1);
    content[-loc - 1]=x;
    ++cardinality;
  }
  return this;
}"
90409,"/** 
 * set the value to ""true"", whether it already appears on not.
 */
public void set(int x){
  short hb=Util.highbits(x);
  Container z=highlowcontainer.get(hb);
  if (z != null) {
    Container z2=z.add(Util.lowbits(x));
    if (z2 != z) {
      highlowcontainer.put(hb,z2);
    }
  }
 else {
    ArrayContainer newac=ContainerFactory.getArrayContainer();
    highlowcontainer.put(hb,newac.add(Util.lowbits(x)));
  }
}","/** 
 * set the value to ""true"", whether it already appears on not.
 */
public void set(int x){
  final short hb=Util.highbits(x);
  Container z=highlowcontainer.get(hb);
  if (z != null) {
    Container z2=z.add(Util.lowbits(x));
    if (z2 != z) {
      highlowcontainer.put(hb,z2);
    }
  }
 else {
    ArrayContainer newac=ContainerFactory.getArrayContainer();
    highlowcontainer.put(hb,newac.add(Util.lowbits(x)));
  }
}"
90410,"public boolean contains(int x){
  short hb=Util.highbits(x);
  if (highlowcontainer.containsKey(hb)) {
    Container C=highlowcontainer.get(hb);
    return C.contains(Util.lowbits(x));
  }
  return false;
}","public boolean contains(int x){
  final short hb=Util.highbits(x);
  if (highlowcontainer.containsKey(hb)) {
    Container C=highlowcontainer.get(hb);
    return C.contains(Util.lowbits(x));
  }
  return false;
}"
90411,"public Container xor(BitmapContainer value2){
  BitmapContainer answer=new BitmapContainer();
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=this.bitmap[k] ^ value2.bitmap[k];
    if (answer.bitmap[k] != 0)     answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  if (answer.cardinality <= ArrayContainer.DEFAULTMAXSIZE)   return ContainerFactory.transformToArrayContainer(answer);
  return answer;
}","public Container xor(BitmapContainer value2){
  BitmapContainer answer=new BitmapContainer();
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=this.bitmap[k] ^ value2.bitmap[k];
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  if (answer.cardinality <= ArrayContainer.DEFAULTMAXSIZE)   return ContainerFactory.transformToArrayContainer(answer);
  return answer;
}"
90412,"@Test public void ArrayContainerCardinalityTest(){
  ArrayContainer ac=new ArrayContainer();
  for (short k=0; k < 100; ++k) {
    ac.add(k);
    Assert.assertEquals(ac.getCardinality(),k + 1);
  }
  for (short k=0; k < 100; ++k) {
    ac.add(k);
    Assert.assertEquals(ac.getCardinality(),100);
  }
}","@Test public void ArrayContainerCardinalityTest(){
  ArrayContainer ac=new ArrayContainer();
  for (short k=0; k < 100; ++k) {
    ac.add(k);
    Assert.assertEquals(ac.getCardinality(),k + 1);
  }
  for (short k=0; k < 100; ++k) {
    ac.add(k);
    Assert.assertEquals(ac.getCardinality(),100);
  }
  for (short k=0; k < 100; ++k) {
    ac.remove(k);
    Assert.assertEquals(ac.getCardinality(),100 - k - 1);
  }
}"
90413,"@Test public void BitmapContainerCardinalityTest(){
  BitmapContainer ac=new BitmapContainer();
  for (short k=0; k < 100; ++k) {
    ac.add(k);
    Assert.assertEquals(ac.getCardinality(),k + 1);
  }
  for (short k=0; k < 100; ++k) {
    ac.add(k);
    Assert.assertEquals(ac.getCardinality(),100);
  }
}","@Test public void BitmapContainerCardinalityTest(){
  BitmapContainer ac=new BitmapContainer();
  for (short k=0; k < 100; ++k) {
    ac.add(k);
    Assert.assertEquals(ac.getCardinality(),k + 1);
  }
  for (short k=0; k < 100; ++k) {
    ac.add(k);
    Assert.assertEquals(ac.getCardinality(),100);
  }
  Assert.assertEquals(ac.getCardinality(),100);
  for (short k=0; k < 100; ++k) {
    Container z=ac.remove(k);
    if (z instanceof ArrayContainer) {
      ac=new BitmapContainer();
      ac.loadData((ArrayContainer)z);
    }
    Assert.assertEquals(ac.getCardinality(),100 - k - 1);
  }
}"
90414,"@Test public void cardinalityTest(){
  System.out.println(""String_Node_Str"");
  final int N=1024;
  for (int gap=7; gap < 100000; gap*=10) {
    for (int offset=2; offset <= 1024; offset*=2) {
      System.out.println(""String_Node_Str"" + gap + ""String_Node_Str""+ offset);
      RoaringBitmap rb=new RoaringBitmap();
      for (int k=0; k < N; k++) {
        rb.add(k * gap);
        Assert.assertEquals(rb.getCardinality(),k + 1);
      }
      Assert.assertEquals(rb.getCardinality(),N);
      for (int k=0; k < N; k++) {
        rb.add(k * gap);
        Assert.assertEquals(rb.getCardinality(),N);
      }
      RoaringBitmap rb2=new RoaringBitmap();
      for (int k=0; k < N; k++) {
        rb2.add(k * gap * offset);
        Assert.assertEquals(rb2.getCardinality(),k + 1);
      }
      Assert.assertEquals(rb2.getCardinality(),N);
      for (int k=0; k < N; k++) {
        rb2.add(k * gap * offset);
        Assert.assertEquals(rb2.getCardinality(),N);
      }
      Assert.assertEquals(RoaringBitmap.and(rb,rb2).getCardinality(),N / offset);
      Assert.assertEquals(RoaringBitmap.or(rb,rb2).getCardinality(),2 * N - N / offset);
      Assert.assertEquals(RoaringBitmap.xor(rb,rb2).getCardinality(),2 * N - 2 * N / offset);
    }
  }
}","@Test public void cardinalityTest(){
  System.out.println(""String_Node_Str"");
  final int N=1024;
  for (int gap=7; gap < 100000; gap*=10) {
    for (int offset=2; offset <= 1024; offset*=2) {
      System.out.println(""String_Node_Str"" + gap + ""String_Node_Str""+ offset);
      RoaringBitmap rb=new RoaringBitmap();
      for (int k=0; k < N; k++) {
        rb.add(k * gap);
        Assert.assertEquals(rb.getCardinality(),k + 1);
      }
      Assert.assertEquals(rb.getCardinality(),N);
      for (int k=0; k < N; k++) {
        rb.add(k * gap);
        Assert.assertEquals(rb.getCardinality(),N);
      }
      RoaringBitmap rb2=new RoaringBitmap();
      for (int k=0; k < N; k++) {
        rb2.add(k * gap * offset);
        Assert.assertEquals(rb2.getCardinality(),k + 1);
      }
      Assert.assertEquals(rb2.getCardinality(),N);
      for (int k=0; k < N; k++) {
        rb2.add(k * gap * offset);
        Assert.assertEquals(rb2.getCardinality(),N);
      }
      Assert.assertEquals(RoaringBitmap.and(rb,rb2).getCardinality(),N / offset);
      Assert.assertEquals(RoaringBitmap.or(rb,rb2).getCardinality(),2 * N - N / offset);
      Assert.assertEquals(RoaringBitmap.xor(rb,rb2).getCardinality(),2 * N - 2 * N / offset);
      for (int k=0; k < N; k++) {
        Assert.assertTrue(rb.contains(k * gap));
        rb.remove(k * gap);
        Assert.assertFalse(rb.contains(k * gap));
        Assert.assertEquals(rb.getCardinality(),N - k - 1);
      }
      for (int k=0; k < N; k++) {
        Assert.assertTrue(rb2.contains(k * gap * offset));
        rb2.remove(k * gap * offset);
        Assert.assertFalse(rb2.contains(k * gap * offset));
        Assert.assertEquals(rb2.getCardinality(),N - k - 1);
      }
    }
  }
}"
90415,"public Container or(ArrayContainer value2){
  ArrayContainer value1=this;
  int tailleAC=value1.getCardinality() + value2.getCardinality();
  final int desiredcapacity=tailleAC > 65535 ? 65535 : tailleAC;
  ArrayContainer answer=new ArrayContainer(desiredcapacity);
  answer.cardinality=Util.unsigned_union2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  if (answer.cardinality > DEFAULTMAXSIZE)   return ContainerFactory.transformToBitmapContainer(answer);
  return answer;
}","public Container or(ArrayContainer value2){
  ArrayContainer value1=this;
  int tailleAC=value1.getCardinality() + value2.getCardinality();
  final int desiredcapacity=tailleAC > 65535 ? 65535 : tailleAC;
  ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < desiredcapacity)   answer.content=new short[desiredcapacity];
  answer.cardinality=Util.unsigned_union2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  if (answer.cardinality > DEFAULTMAXSIZE)   return ContainerFactory.transformToBitmapContainer(answer);
  return answer;
}"
90416,"public ArrayContainer and(ArrayContainer value2){
  ArrayContainer value1=this;
  final int desiredcapacity=Math.min(value1.getCardinality(),value2.getCardinality());
  ArrayContainer answer=new ArrayContainer(desiredcapacity);
  answer.cardinality=Util.unsigned_intersect2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  return answer;
}","public ArrayContainer and(ArrayContainer value2){
  ArrayContainer value1=this;
  final int desiredcapacity=Math.min(value1.getCardinality(),value2.getCardinality());
  ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < desiredcapacity)   answer.content=new short[desiredcapacity];
  answer.cardinality=Util.unsigned_intersect2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  return answer;
}"
90417,"public Container xor(ArrayContainer value2){
  ArrayContainer value1=this;
  final int desiredcapacity=Math.min(value1.getCardinality() + value2.getCardinality(),65536);
  ArrayContainer answer=new ArrayContainer(desiredcapacity);
  answer.cardinality=Util.unsigned_exclusiveunion2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  if (answer.cardinality > DEFAULTMAXSIZE)   return ContainerFactory.transformToBitmapContainer(answer);
  return answer;
}","public Container xor(ArrayContainer value2){
  ArrayContainer value1=this;
  final int desiredcapacity=Math.min(value1.getCardinality() + value2.getCardinality(),65536);
  ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < desiredcapacity)   answer.content=new short[desiredcapacity];
  answer.cardinality=Util.unsigned_exclusiveunion2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  if (answer.cardinality > DEFAULTMAXSIZE)   return ContainerFactory.transformToBitmapContainer(answer);
  return answer;
}"
90418,"public Container or(BitmapContainer value2){
  BitmapContainer answer=new BitmapContainer();
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=this.bitmap[k] | value2.bitmap[k];
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  return answer;
}","public Container or(BitmapContainer value2){
  BitmapContainer answer=ContainerFactory.getBitmapContainer();
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=this.bitmap[k] | value2.bitmap[k];
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  return answer;
}"
90419,"public ArrayContainer and(ArrayContainer value2){
  ArrayContainer answer=new ArrayContainer();
  for (int k=0; k < value2.getCardinality(); ++k)   if (this.contains(value2.content[k]))   answer.content[answer.cardinality++]=value2.content[k];
  return answer;
}","public ArrayContainer and(ArrayContainer value2){
  ArrayContainer answer=ContainerFactory.getArrayContainer();
  if (answer.content.length < value2.content.length)   answer.content=new short[value2.content.length];
  for (int k=0; k < value2.getCardinality(); ++k)   if (this.contains(value2.content[k]))   answer.content[answer.cardinality++]=value2.content[k];
  return answer;
}"
90420,"@Override public BitmapContainer clone(){
  try {
    BitmapContainer x=(BitmapContainer)super.clone();
    x.cardinality=this.cardinality;
    x.bitmap=Arrays.copyOf(bitmap,bitmap.length);
    return x;
  }
 catch (  CloneNotSupportedException e) {
    throw new java.lang.RuntimeException();
  }
}","@Override public BitmapContainer clone(){
  try {
    BitmapContainer x=(BitmapContainer)super.clone();
    x.cardinality=this.cardinality;
    System.arraycopy(this.bitmap,0,x.bitmap,0,x.bitmap.length);
    return x;
  }
 catch (  CloneNotSupportedException e) {
    throw new java.lang.RuntimeException();
  }
}"
90421,"public Container xor(BitmapContainer value2){
  BitmapContainer answer=new BitmapContainer();
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=this.bitmap[k] ^ value2.bitmap[k];
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  if (answer.cardinality <= ArrayContainer.DEFAULTMAXSIZE)   return ContainerFactory.transformToArrayContainer(answer);
  return answer;
}","public Container xor(BitmapContainer value2){
  BitmapContainer answer=ContainerFactory.getBitmapContainer();
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=this.bitmap[k] ^ value2.bitmap[k];
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  if (answer.cardinality <= ArrayContainer.DEFAULTMAXSIZE)   return ContainerFactory.transformToArrayContainer(answer);
  return answer;
}"
90422,"public Container or(ArrayContainer value2){
  ArrayContainer value1=this;
  ArrayContainer answer=new ArrayContainer();
  answer.cardinality=Util.union2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  if (answer.cardinality >= 1024)   return new BitmapContainer(answer);
  return answer;
}","public Container or(ArrayContainer value2){
  ArrayContainer value1=this;
  final int desiredcapacity=Math.min(value1.getCardinality() + value2.getCardinality(),65536);
  ArrayContainer answer=new ArrayContainer(desiredcapacity);
  answer.cardinality=Util.union2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  if (answer.cardinality >= 1024)   return new BitmapContainer(answer);
  return answer;
}"
90423,"public ArrayContainer and(ArrayContainer value2){
  ArrayContainer value1=this;
  ArrayContainer answer=new ArrayContainer();
  answer.cardinality=Util.localintersect2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  return answer;
}","public ArrayContainer and(ArrayContainer value2){
  ArrayContainer value1=this;
  final int desiredcapacity=Math.min(value1.getCardinality(),value2.getCardinality());
  ArrayContainer answer=new ArrayContainer(desiredcapacity);
  answer.cardinality=Util.localintersect2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  return answer;
}"
90424,"public Container xor(ArrayContainer value2){
  ArrayContainer value1=this;
  ArrayContainer answer=new ArrayContainer();
  answer.cardinality=Util.ExclusiveUnion2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  if (answer.cardinality >= 1024)   return new BitmapContainer(answer);
  return answer;
}","public Container xor(ArrayContainer value2){
  ArrayContainer value1=this;
  final int desiredcapacity=Math.min(value1.getCardinality() + value2.getCardinality(),65536);
  ArrayContainer answer=new ArrayContainer(desiredcapacity);
  answer.cardinality=Util.ExclusiveUnion2by2(value1.content,value1.getCardinality(),value2.content,value2.getCardinality(),answer.content);
  if (answer.cardinality >= 1024)   return new BitmapContainer(answer);
  return answer;
}"
90425,"public ArrayContainer(){
}","public ArrayContainer(){
  content=new short[2048];
}"
90426,"@Override public Container add(short i){
  if (!contains(i)) {
    bitmap[Math.abs(i / 64)]|=(1l << (i % 64));
    ++cardinality;
  }
  return this;
}","@Override public Container add(short i){
  if (!contains(i)) {
    bitmap[toIntUnsigned(i) / 64]|=(1l << (i % 64));
    ++cardinality;
  }
  return this;
}"
90427,"public Container or(BitmapContainer value2){
  BitmapContainer value1=this;
  BitmapContainer answer=new BitmapContainer();
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=value1.bitmap[k] | value2.bitmap[k];
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  if (cardinality < 1024)   return new ArrayContainer(answer);
  return answer;
}","public Container or(BitmapContainer value2){
  BitmapContainer value1=this;
  BitmapContainer answer=new BitmapContainer();
  for (int k=0; k < answer.bitmap.length; ++k) {
    answer.bitmap[k]=value1.bitmap[k] | value2.bitmap[k];
    answer.cardinality+=Long.bitCount(answer.bitmap[k]);
  }
  if (answer.cardinality < 1024)   return new ArrayContainer(answer);
  return answer;
}"
90428,"public short nextSetBit(int i){
  int x=i / 64;
  long w=bitmap[x];
  w>>>=(i % 64);
  if (w != 0) {
    return (short)(i + Long.numberOfTrailingZeros(w));
  }
  ++x;
  for (; x < bitmap.length; ++x) {
    if (bitmap[x] != 0) {
      return (short)(x * 64 + Long.numberOfTrailingZeros(bitmap[x]));
    }
  }
  return -1;
}","public int nextSetBit(int i){
  int x=i / 64;
  if (x >= bitmap.length)   return -1;
  long w=bitmap[x];
  w>>>=(i % 64);
  if (w != 0) {
    return i + Long.numberOfTrailingZeros(w);
  }
  ++x;
  for (; x < bitmap.length; ++x) {
    if (bitmap[x] != 0) {
      return x * 64 + Long.numberOfTrailingZeros(bitmap[x]);
    }
  }
  return -1;
}"
90429,"@Override public boolean contains(short i){
  return (bitmap[Math.abs(i / 64)] & (1l << (i % 64))) != 0;
}","@Override public boolean contains(short i){
  return (bitmap[toIntUnsigned(i) / 64] & (1l << (i % 64))) != 0;
}"
90430,"public BitmapContainer(ArrayContainer arrayContainer){
  this.cardinality=arrayContainer.cardinality;
  for (  short x : arrayContainer.content)   bitmap[Math.abs(x) / 64]|=(1l << (x % 64));
}","public BitmapContainer(ArrayContainer arrayContainer){
  this.cardinality=arrayContainer.cardinality;
  for (int k=0; k < arrayContainer.cardinality; ++k) {
    final short x=arrayContainer.content[k];
    bitmap[toIntUnsigned(x) / 64]|=(1l << x % 64);
  }
}"
90431,"@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  int i=this.nextSetBit(0);
  do {
    sb.append(i);
    i=this.nextSetBit(i + 1);
    if (i >= 0)     sb.append(""String_Node_Str"");
  }
 while (i >= 0);
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  int counter=0;
  sb.append(""String_Node_Str"");
  int i=this.nextSetBit(0);
  while (i >= 0) {
    sb.append(i);
    ++counter;
    i=this.nextSetBit(i + 1);
    if (i >= 0)     sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + cardinality + ""String_Node_Str""+ counter);
  return sb.toString();
}"
90432,"public int getCardinality(){
  int size=0;
  final Iterator<Entry<Short,Container>> p1=this.highlowcontainer.entrySet().iterator();
  Entry<Short,Container> s;
  do {
    s=p1.next();
    size+=this.highlowcontainer.get(s.getKey()).getCardinality();
  }
 while (p1.hasNext());
  return size;
}","public int getCardinality(){
  int size=0;
  final Iterator<Entry<Short,Container>> p1=this.highlowcontainer.entrySet().iterator();
  Entry<Short,Container> s;
  while (p1.hasNext()) {
    s=p1.next();
    size+=this.highlowcontainer.get(s.getKey()).getCardinality();
  }
  return size;
}"
90433,"public void getIntegers(int array[]){
  array=new int[this.getCardinality()];
  int pos=0;
  final Iterator<Entry<Short,Container>> p1=this.highlowcontainer.entrySet().iterator();
  Entry<Short,Container> s;
  do {
    s=p1.next();
    if (s.getValue() instanceof ArrayContainer)     for (int i=0; i < s.getValue().getCardinality(); i++)     array[pos++]=(16 << s.getKey().shortValue()) | ((ArrayContainer)s.getValue()).content[i];
 else     if (s.getValue() instanceof BitmapContainer)     for (int i=((BitmapContainer)s.getValue()).nextSetBit(0); i >= 0; i=((BitmapContainer)s.getValue()).nextSetBit(i + 1))     array[pos++]=(16 << s.getKey().shortValue()) | i;
  }
 while (p1.hasNext());
}","public int[] getIntegers(){
  int[] array=new int[this.getCardinality()];
  int pos=0;
  final Iterator<Entry<Short,Container>> p1=this.highlowcontainer.entrySet().iterator();
  Entry<Short,Container> s;
  while (p1.hasNext()) {
    s=p1.next();
    if (s.getValue() instanceof ArrayContainer)     for (int i=0; i < s.getValue().getCardinality(); i++)     array[pos++]=(16 << s.getKey().shortValue()) | ((ArrayContainer)s.getValue()).content[i];
 else     if (s.getValue() instanceof BitmapContainer)     for (int i=((BitmapContainer)s.getValue()).nextSetBit(0); i >= 0; i=((BitmapContainer)s.getValue()).nextSetBit(i + 1))     array[pos++]=(16 << s.getKey().shortValue()) | i;
  }
  return array;
}"
90434,"private StatusLogger(final String name,final MessageFactory messageFactory){
  super(name,messageFactory);
  this.logger=new SimpleLogger(""String_Node_Str"",Level.ERROR,false,true,false,false,System.getProperty(STATUS_DATE_FORMAT,Strings.EMPTY),messageFactory,PROPS,System.err);
  this.listenersLevel=Level.toLevel(DEFAULT_STATUS_LEVEL,Level.WARN).intLevel();
  if (isDebugPropertyEnabled()) {
    logger.setLevel(Level.TRACE);
  }
}","private StatusLogger(final String name,final MessageFactory messageFactory){
  super(name,messageFactory);
  final String dateFormat=PROPS.getStringProperty(STATUS_DATE_FORMAT,Strings.EMPTY);
  final boolean showDateTime=!Strings.isEmpty(dateFormat);
  this.logger=new SimpleLogger(""String_Node_Str"",Level.ERROR,false,true,showDateTime,false,dateFormat,messageFactory,PROPS,System.err);
  this.listenersLevel=Level.toLevel(DEFAULT_STATUS_LEVEL,Level.WARN).intLevel();
  if (isDebugPropertyEnabled()) {
    logger.setLevel(Level.TRACE);
  }
}"
90435,"/** 
 * Constructor.
 * @param loggerName The name of the Logger.
 * @param marker The Marker or null.
 * @param loggerFQCN The fully qualified class name of the caller.
 * @param level The logging Level.
 * @param message The Message.
 * @param thrown A Throwable or null.
 * @param thrownProxy A ThrowableProxy or null.
 * @param contextData The key-value pairs from the context.
 * @param contextStack the nested diagnostic context.
 * @param threadId the thread ID
 * @param threadName The name of the thread.
 * @param threadPriority the thread priority
 * @param source The locations of the caller.
 * @param timestampMillis The timestamp of the event.
 * @param nanoOfMillisecond the nanoseconds within the millisecond, always positive, never exceeds {@code 999,999}
 * @param nanoTime The value of the running Java Virtual Machine's high-resolution time source when the event wascreated.
 */
private Log4jLogEvent(final String loggerName,final Marker marker,final String loggerFQCN,final Level level,final Message message,final Throwable thrown,final ThrowableProxy thrownProxy,final StringMap contextData,final ThreadContext.ContextStack contextStack,final long threadId,final String threadName,final int threadPriority,final StackTraceElement source,final long timestampMillis,final int nanoOfMillisecond,final long nanoTime){
  this.loggerName=loggerName;
  this.marker=marker;
  this.loggerFqcn=loggerFQCN;
  this.level=level == null ? Level.OFF : level;
  this.message=message;
  this.thrown=thrown;
  this.thrownProxy=thrownProxy;
  this.contextData=contextData == null ? ContextDataFactory.createContextData() : contextData;
  this.contextStack=contextStack == null ? ThreadContext.EMPTY_STACK : contextStack;
  long millis=message instanceof TimestampMessage ? ((TimestampMessage)message).getTimestamp() : timestampMillis;
  this.instant.initFromEpochMilli(millis,nanoOfMillisecond);
  this.threadId=threadId;
  this.threadName=threadName;
  this.threadPriority=threadPriority;
  this.source=source;
  if (message != null && message instanceof LoggerNameAwareMessage) {
    ((LoggerNameAwareMessage)message).setLoggerName(loggerName);
  }
  this.nanoTime=nanoTime;
}","private Log4jLogEvent(final String loggerName,final Marker marker,final String loggerFQCN,final Level level,final Message message,final Throwable thrown,final ThrowableProxy thrownProxy,final StringMap contextData,final ThreadContext.ContextStack contextStack,final long threadId,final String threadName,final int threadPriority,final StackTraceElement source,final long nanoTime){
  this.loggerName=loggerName;
  this.marker=marker;
  this.loggerFqcn=loggerFQCN;
  this.level=level == null ? Level.OFF : level;
  this.message=message;
  this.thrown=thrown;
  this.thrownProxy=thrownProxy;
  this.contextData=contextData == null ? ContextDataFactory.createContextData() : contextData;
  this.contextStack=contextStack == null ? ThreadContext.EMPTY_STACK : contextStack;
  this.threadId=threadId;
  this.threadName=threadName;
  this.threadPriority=threadPriority;
  this.source=source;
  if (message instanceof LoggerNameAwareMessage) {
    ((LoggerNameAwareMessage)message).setLoggerName(loggerName);
  }
  this.nanoTime=nanoTime;
}"
90436,"private static Clock createClock(){
  final String userRequest=PropertiesUtil.getProperties().getStringProperty(PROPERTY_NAME);
  if (userRequest == null) {
    LOGGER.trace(""String_Node_Str"");
    return new SystemClock();
  }
  Supplier<Clock> specified=aliases().get(userRequest);
  if (specified != null) {
    LOGGER.trace(""String_Node_Str"",userRequest);
    return specified.get();
  }
  try {
    final Clock result=Loader.newCheckedInstanceOf(userRequest,Clock.class);
    LOGGER.trace(""String_Node_Str"",result.getClass().getName());
    return result;
  }
 catch (  final Exception e) {
    final String fmt=""String_Node_Str"";
    LOGGER.error(fmt,userRequest,e);
    return new SystemClock();
  }
}","private static Clock createClock(){
  final String userRequest=PropertiesUtil.getProperties().getStringProperty(PROPERTY_NAME);
  if (userRequest == null) {
    LOGGER.trace(""String_Node_Str"");
    return logSupportedPrecision(new SystemClock());
  }
  Supplier<Clock> specified=aliases().get(userRequest);
  if (specified != null) {
    LOGGER.trace(""String_Node_Str"",userRequest);
    return logSupportedPrecision(specified.get());
  }
  try {
    final Clock result=Loader.newCheckedInstanceOf(userRequest,Clock.class);
    LOGGER.trace(""String_Node_Str"",result.getClass().getName());
    return logSupportedPrecision(result);
  }
 catch (  final Exception e) {
    final String fmt=""String_Node_Str"";
    LOGGER.error(fmt,userRequest,e);
    return logSupportedPrecision(new SystemClock());
  }
}"
90437,"@Override public String toString(){
  return ""String_Node_Str"" + epochSecond + ""String_Node_Str""+ nanoOfSecond+ ""String_Node_Str"";
}","@Override public String toString(){
  final StringBuilder sb=new StringBuilder(64);
  formatTo(sb);
  return sb.toString();
}"
90438,"void FixedFormat(final String pattern,final String datePattern,final int escapeCount,final char timeSeparator,final int timeSepLength,final char millisSeparator,final int millisSepLength){
  this.timeSeparatorChar=timeSeparator;
  this.timeSeparatorLength=timeSepLength;
  this.millisSeparatorChar=millisSeparator;
  this.millisSeparatorLength=millisSepLength;
  this.pattern=Objects.requireNonNull(pattern);
  this.datePattern=datePattern;
  this.escapeCount=escapeCount;
}","void FixedFormat(final String pattern,final String datePattern,final int escapeCount,final char timeSeparator,final int timeSepLength,final char millisSeparator,final int millisSepLength,final int secondFractionDigits){
  this.timeSeparatorChar=timeSeparator;
  this.timeSeparatorLength=timeSepLength;
  this.millisSeparatorChar=millisSeparator;
  this.millisSeparatorLength=millisSepLength;
  this.pattern=Objects.requireNonNull(pattern);
  this.datePattern=datePattern;
  this.escapeCount=escapeCount;
  this.secondFractionDigits=secondFractionDigits;
}"
90439,"@PluginFactory public static Script createScript(@PluginAttribute(""String_Node_Str"") final String name,@PluginAttribute(""String_Node_Str"") String language,@PluginValue(""String_Node_Str"") final String scriptText){
  if (language == null) {
    LOGGER.info(""String_Node_Str"",DEFAULT_LANGUAGE);
    language=DEFAULT_LANGUAGE;
  }
  if (scriptText == null) {
    LOGGER.error(""String_Node_Str"",name);
    return null;
  }
  return new Script(name,language,scriptText);
}","@PluginFactory public static Script createScript(@PluginAttribute(""String_Node_Str"") final String name,@PluginAttribute(ATTR_LANGUAGE) String language,@PluginValue(ATTR_SCRIPT_TEXT) final String scriptText){
  if (language == null) {
    LOGGER.error(""String_Node_Str"",ATTR_LANGUAGE,PLUGIN_NAME,name);
    language=DEFAULT_LANGUAGE;
  }
  if (scriptText == null) {
    LOGGER.error(""String_Node_Str"",ATTR_SCRIPT_TEXT,PLUGIN_NAME,name);
    return null;
  }
  return new Script(name,language,scriptText);
}"
90440,"@Test public void testReconfiguration() throws Exception {
  final Configuration oldConfig=context.getConfiguration();
  final int MONITOR_INTERVAL_SECONDS=5;
  final File file=new File(CONFIG);
  final long orig=file.lastModified();
  final long newTime=orig + 10000;
  assertTrue(""String_Node_Str"",file.setLastModified(newTime));
  TimeUnit.SECONDS.sleep(MONITOR_INTERVAL_SECONDS + 1);
  for (int i=0; i < 17; ++i) {
    logger.debug(""String_Node_Str"");
  }
  final int loopCount=0;
  Configuration newConfig;
  do {
    Thread.sleep(100);
    newConfig=context.getConfiguration();
  }
 while (newConfig == oldConfig && loopCount < 5);
  assertNotSame(""String_Node_Str"",newConfig,oldConfig);
}","@Test public void testReconfiguration() throws Exception {
  final Configuration oldConfig=context.getConfiguration();
  final int MONITOR_INTERVAL_SECONDS=5;
  final File file=new File(CONFIG);
  final long orig=file.lastModified();
  final long newTime=orig + 10000;
  assertTrue(""String_Node_Str"",file.setLastModified(newTime));
  TimeUnit.SECONDS.sleep(MONITOR_INTERVAL_SECONDS + 1);
  for (int i=0; i < 17; ++i) {
    logger.info(""String_Node_Str"");
  }
  int loopCount=0;
  Configuration newConfig;
  do {
    Thread.sleep(100);
    newConfig=context.getConfiguration();
  }
 while (newConfig == oldConfig && loopCount++ < 5);
  assertNotSame(""String_Node_Str"",newConfig,oldConfig);
}"
90441,"private int writeTime(int ms,final char[] buffer,int pos){
  final int hours=ms / 3600000;
  ms-=3600000 * hours;
  final int minutes=ms / 60000;
  ms-=60000 * minutes;
  final int seconds=ms / 1000;
  ms-=1000 * seconds;
  int temp=hours / 10;
  buffer[pos++]=((char)(temp + '0'));
  buffer[pos++]=((char)(hours - 10 * temp + '0'));
  buffer[pos]=timeSeparatorChar;
  pos+=timeSeparatorLength;
  temp=minutes / 10;
  buffer[pos++]=((char)(temp + '0'));
  buffer[pos++]=((char)(minutes - 10 * temp + '0'));
  buffer[pos]=timeSeparatorChar;
  pos+=timeSeparatorLength;
  temp=seconds / 10;
  buffer[pos++]=((char)(temp + '0'));
  buffer[pos++]=((char)(seconds - 10 * temp + '0'));
  buffer[pos]=millisSeparatorChar;
  pos+=millisSeparatorLength;
  temp=ms / 100;
  buffer[pos++]=((char)(temp + '0'));
  ms-=100 * temp;
  temp=ms / 10;
  buffer[pos++]=((char)(temp + '0'));
  ms-=10 * temp;
  buffer[pos++]=((char)(ms + '0'));
  return pos;
}","private int writeTime(int ms,final char[] buffer,int pos){
  final int hourOfDay=ms / 3600000;
  final int hours=hourOfDay + daylightSavingTime(hourOfDay) / 3600000;
  ms-=3600000 * hourOfDay;
  final int minutes=ms / 60000;
  ms-=60000 * minutes;
  final int seconds=ms / 1000;
  ms-=1000 * seconds;
  int temp=hours / 10;
  buffer[pos++]=((char)(temp + '0'));
  buffer[pos++]=((char)(hours - 10 * temp + '0'));
  buffer[pos]=timeSeparatorChar;
  pos+=timeSeparatorLength;
  temp=minutes / 10;
  buffer[pos++]=((char)(temp + '0'));
  buffer[pos++]=((char)(minutes - 10 * temp + '0'));
  buffer[pos]=timeSeparatorChar;
  pos+=timeSeparatorLength;
  temp=seconds / 10;
  buffer[pos++]=((char)(temp + '0'));
  buffer[pos++]=((char)(seconds - 10 * temp + '0'));
  buffer[pos]=millisSeparatorChar;
  pos+=millisSeparatorLength;
  temp=ms / 100;
  buffer[pos++]=((char)(temp + '0'));
  ms-=100 * temp;
  temp=ms / 10;
  buffer[pos++]=((char)(temp + '0'));
  ms-=10 * temp;
  buffer[pos++]=((char)(ms + '0'));
  return pos;
}"
90442,"private void updateMidnightMillis(final long now){
  if (now >= midnightTomorrow || now < midnightToday) {
synchronized (this) {
      updateCachedDate(now);
      midnightToday=calcMidnightMillis(now,0);
      midnightTomorrow=calcMidnightMillis(now,1);
    }
  }
}","private void updateMidnightMillis(final long now){
  if (now >= midnightTomorrow || now < midnightToday) {
synchronized (this) {
      updateCachedDate(now);
      midnightToday=calcMidnightMillis(now,0);
      midnightTomorrow=calcMidnightMillis(now,1);
      updateDaylightSavingTime();
    }
  }
}"
90443,"@Test public void testCreateIfSupported_defaultIfOptionsArrayNull(){
  final FixedDateFormat fmt=FixedDateFormat.createIfSupported((String[])null);
  assertEquals(FixedFormat.DEFAULT.getPattern(),fmt.getFormat());
}","@Test public void testCreateIfSupported_defaultIfOptionsArrayNull(){
  final FixedDateFormat fmt=FixedDateFormat.createIfSupported((String[])null);
  assertEquals(DEFAULT.getPattern(),fmt.getFormat());
}"
90444,"@Test public void testCreateIfSupported_customTimeZoneIfOptionsArrayWithTimeZoneElement(){
  final FixedDateFormat fmt=FixedDateFormat.createIfSupported(new String[]{FixedFormat.DEFAULT.getPattern(),""String_Node_Str"",""String_Node_Str""});
  assertEquals(FixedFormat.DEFAULT.getPattern(),fmt.getFormat());
  assertEquals(TimeZone.getTimeZone(""String_Node_Str""),fmt.getTimeZone());
}","@Test public void testCreateIfSupported_customTimeZoneIfOptionsArrayWithTimeZoneElement(){
  final FixedDateFormat fmt=FixedDateFormat.createIfSupported(new String[]{DEFAULT.getPattern(),""String_Node_Str"",""String_Node_Str""});
  assertEquals(DEFAULT.getPattern(),fmt.getFormat());
  assertEquals(TimeZone.getTimeZone(""String_Node_Str""),fmt.getTimeZone());
}"
90445,"@Test public void testFixedFormat_getDatePatternReturnsDatePatternIfExists(){
  assertEquals(""String_Node_Str"",FixedFormat.COMPACT.getDatePattern());
  assertEquals(""String_Node_Str"",FixedFormat.DEFAULT.getDatePattern());
}","@Test public void testFixedFormat_getDatePatternReturnsDatePatternIfExists(){
  assertEquals(""String_Node_Str"",FixedFormat.COMPACT.getDatePattern());
  assertEquals(""String_Node_Str"",DEFAULT.getDatePattern());
}"
90446,"@Test public void testFixedFormat_getDatePatternLengthReturnsDatePatternLength(){
  assertEquals(""String_Node_Str"".length(),FixedFormat.COMPACT.getDatePatternLength());
  assertEquals(""String_Node_Str"".length(),FixedFormat.DEFAULT.getDatePatternLength());
}","@Test public void testFixedFormat_getDatePatternLengthReturnsDatePatternLength(){
  assertEquals(""String_Node_Str"".length(),FixedFormat.COMPACT.getDatePatternLength());
  assertEquals(""String_Node_Str"".length(),DEFAULT.getDatePatternLength());
}"
90447,"@Test public void testCreateIfSupported_defaultIfOptionsArrayWithSingleNullElement(){
  final FixedDateFormat fmt=FixedDateFormat.createIfSupported(new String[1]);
  assertEquals(FixedFormat.DEFAULT.getPattern(),fmt.getFormat());
  assertEquals(TimeZone.getDefault(),fmt.getTimeZone());
}","@Test public void testCreateIfSupported_defaultIfOptionsArrayWithSingleNullElement(){
  final FixedDateFormat fmt=FixedDateFormat.createIfSupported(new String[1]);
  assertEquals(DEFAULT.getPattern(),fmt.getFormat());
  assertEquals(TimeZone.getDefault(),fmt.getTimeZone());
}"
90448,"@Test public void testCreateIfSupported_defaultIfOptionsArrayEmpty(){
  final FixedDateFormat fmt=FixedDateFormat.createIfSupported(new String[0]);
  assertEquals(FixedFormat.DEFAULT.getPattern(),fmt.getFormat());
}","@Test public void testCreateIfSupported_defaultIfOptionsArrayEmpty(){
  final FixedDateFormat fmt=FixedDateFormat.createIfSupported(new String[0]);
  assertEquals(DEFAULT.getPattern(),fmt.getFormat());
}"
90449,"@Test public void testCreateIfSupported_defaultTimeZoneIfOptionsArrayWithSecondNullElement(){
  final FixedDateFormat fmt=FixedDateFormat.createIfSupported(new String[]{FixedFormat.DEFAULT.getPattern(),null,""String_Node_Str""});
  assertEquals(FixedFormat.DEFAULT.getPattern(),fmt.getFormat());
  assertEquals(TimeZone.getDefault(),fmt.getTimeZone());
}","@Test public void testCreateIfSupported_defaultTimeZoneIfOptionsArrayWithSecondNullElement(){
  final FixedDateFormat fmt=FixedDateFormat.createIfSupported(new String[]{DEFAULT.getPattern(),null,""String_Node_Str""});
  assertEquals(DEFAULT.getPattern(),fmt.getFormat());
  assertEquals(TimeZone.getDefault(),fmt.getTimeZone());
}"
90450,"@Test public void testFixedFormat_getFastDateFormatNonNullIfDateInPattern(){
  assertNotNull(FixedFormat.COMPACT.getFastDateFormat());
  assertNotNull(FixedFormat.DEFAULT.getFastDateFormat());
  assertEquals(""String_Node_Str"",FixedFormat.COMPACT.getFastDateFormat().getPattern());
  assertEquals(""String_Node_Str"",FixedFormat.DEFAULT.getFastDateFormat().getPattern());
}","@Test public void testFixedFormat_getFastDateFormatNonNullIfDateInPattern(){
  assertNotNull(FixedFormat.COMPACT.getFastDateFormat());
  assertNotNull(DEFAULT.getFastDateFormat());
  assertEquals(""String_Node_Str"",FixedFormat.COMPACT.getFastDateFormat().getPattern());
  assertEquals(""String_Node_Str"",DEFAULT.getFastDateFormat().getPattern());
}"
90451,"@Test public void tesStringOneArgLocaleFrance_MessageFormatMessage(){
  final String testMsg=""String_Node_Str"";
  final FormattedMessage msg=new FormattedMessage(Locale.FRANCE,testMsg,12);
  final String result=msg.getFormattedMessage();
  final String expected=""String_Node_Str"";
  assertEquals(expected,result);
}","@Test public void tesStringOneArgLocaleFrance_MessageFormatMessage(){
  final String testMsg=""String_Node_Str"";
  final FormattedMessage msg=new FormattedMessage(Locale.FRANCE,testMsg,12);
  final String result=msg.getFormattedMessage();
  final String expected=""String_Node_Str"" + SPACE + ""String_Node_Str"";
  assertEquals(expected,result);
}"
90452,"/** 
 * This method is called by the EventHandler that processes the RingBufferLogEvent in a separate thread. Merges the contents of the configuration map into the contextData, after replacing any variables in the property values with the StrSubstitutor-supplied actual values.
 * @param event the event to log
 */
public void actualAsyncLog(final RingBufferLogEvent event){
  final List<Property> properties=privateConfig.loggerConfig.getPropertyList();
  if (properties != null) {
    StringMap contextData=(StringMap)event.getContextData();
    if (contextData.isFrozen()) {
      final StringMap temp=ContextDataFactory.createContextData();
      temp.putAll(contextData);
      contextData=temp;
    }
    for (int i=0; i < properties.size(); i++) {
      final Property prop=properties.get(i);
      if (contextData.getValue(prop.getName()) != null) {
        continue;
      }
      final String value=prop.isValueNeedsLookup() ? privateConfig.config.getStrSubstitutor().replace(event,prop.getValue()) : prop.getValue();
      contextData.putValue(prop.getName(),prop.getValue());
    }
    event.setContextData(contextData);
  }
  final ReliabilityStrategy strategy=privateConfig.loggerConfig.getReliabilityStrategy();
  strategy.log(this,event);
}","/** 
 * This method is called by the EventHandler that processes the RingBufferLogEvent in a separate thread. Merges the contents of the configuration map into the contextData, after replacing any variables in the property values with the StrSubstitutor-supplied actual values.
 * @param event the event to log
 */
public void actualAsyncLog(final RingBufferLogEvent event){
  final List<Property> properties=privateConfig.loggerConfig.getPropertyList();
  if (properties != null) {
    StringMap contextData=(StringMap)event.getContextData();
    if (contextData.isFrozen()) {
      final StringMap temp=ContextDataFactory.createContextData();
      temp.putAll(contextData);
      contextData=temp;
    }
    for (int i=0; i < properties.size(); i++) {
      final Property prop=properties.get(i);
      if (contextData.getValue(prop.getName()) != null) {
        continue;
      }
      final String value=prop.isValueNeedsLookup() ? privateConfig.config.getStrSubstitutor().replace(event,prop.getValue()) : prop.getValue();
      contextData.putValue(prop.getName(),value);
    }
    event.setContextData(contextData);
  }
  final ReliabilityStrategy strategy=privateConfig.loggerConfig.getReliabilityStrategy();
  strategy.log(this,event);
}"
90453,"/** 
 * Writes the specified data to the specified destination.
 * @param data the data to write
 * @param offset where to start in the specified data array
 * @param length the number of bytes to write
 * @param destination the {@code ByteBufferDestination} to write to
 */
public static void writeTo(final byte[] data,int offset,int length,final ByteBufferDestination destination){
  int chunk=0;
  ByteBuffer buffer=destination.getByteBuffer();
  do {
    if (length > buffer.remaining()) {
      buffer=destination.drain(buffer);
    }
    chunk=Math.min(length,buffer.remaining());
    buffer.put(data,offset,chunk);
    offset+=chunk;
    length-=chunk;
  }
 while (length > 0);
}","/** 
 * Writes the specified data to the specified destination.
 * @param data the data to write
 * @param offset where to start in the specified data array
 * @param length the number of bytes to write
 * @param destination the {@code ByteBufferDestination} to write to
 */
public static void writeTo(final byte[] data,int offset,int length,final ByteBufferDestination destination){
  int chunk=0;
synchronized (destination) {
    ByteBuffer buffer=destination.getByteBuffer();
    do {
      if (length > buffer.remaining()) {
        buffer=destination.drain(buffer);
      }
      chunk=Math.min(length,buffer.remaining());
      buffer.put(data,offset,chunk);
      offset+=chunk;
      length-=chunk;
    }
 while (length > 0);
  }
}"
90454,"@Override public void start(){
  super.start();
  if (scheduledItems > 0) {
    LOGGER.debug(""String_Node_Str"",scheduledItems,SIMPLE_NAME);
    scheduledItems=Math.min(scheduledItems,MAX_SCHEDULED_ITEMS);
    executorService=new ScheduledThreadPoolExecutor(scheduledItems,Log4jThreadFactory.createDaemonThreadFactory(""String_Node_Str""));
  }
 else {
    LOGGER.debug(""String_Node_Str"",SIMPLE_NAME);
  }
}","@Override public void start(){
  super.start();
  if (scheduledItems > 0) {
    LOGGER.debug(""String_Node_Str"",SIMPLE_NAME,scheduledItems);
    scheduledItems=Math.min(scheduledItems,MAX_SCHEDULED_ITEMS);
    executorService=new ScheduledThreadPoolExecutor(scheduledItems,Log4jThreadFactory.createDaemonThreadFactory(""String_Node_Str""));
  }
 else {
    LOGGER.debug(""String_Node_Str"",SIMPLE_NAME);
  }
}"
90455,"/** 
 * {@inheritDoc}
 */
@Override public void format(final LogEvent event,final StringBuilder toAppendTo){
  MapMessage msg;
  if (event.getMessage() instanceof MapMessage) {
    msg=(MapMessage)event.getMessage();
  }
 else {
    return;
  }
  final IndexedReadOnlyStringMap sortedMap=msg.getIndexedReadOnlyStringMap();
  if (key == null) {
    if (sortedMap.isEmpty()) {
      toAppendTo.append(""String_Node_Str"");
      return;
    }
    final StringBuilder sb=toAppendTo.append(""String_Node_Str"");
    for (int i=0; i < sortedMap.size(); i++) {
      if (sb.length() > 1) {
        sb.append(""String_Node_Str"");
      }
      sb.append(sortedMap.getKeyAt(i)).append('=').append(sortedMap.getValueAt(i));
    }
    sb.append('}');
    toAppendTo.append(sb);
  }
 else {
    final String val=sortedMap.getValue(key);
    if (val != null) {
      toAppendTo.append(val);
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void format(final LogEvent event,final StringBuilder toAppendTo){
  MapMessage msg;
  if (event.getMessage() instanceof MapMessage) {
    msg=(MapMessage)event.getMessage();
  }
 else {
    return;
  }
  final IndexedReadOnlyStringMap sortedMap=msg.getIndexedReadOnlyStringMap();
  if (key == null) {
    if (sortedMap.isEmpty()) {
      toAppendTo.append(""String_Node_Str"");
      return;
    }
    toAppendTo.append(""String_Node_Str"");
    for (int i=0; i < sortedMap.size(); i++) {
      if (i > 0) {
        toAppendTo.append(""String_Node_Str"");
      }
      toAppendTo.append(sortedMap.getKeyAt(i)).append('=').append(sortedMap.getValueAt(i));
    }
    toAppendTo.append('}');
  }
 else {
    final String val=sortedMap.getValue(key);
    if (val != null) {
      toAppendTo.append(val);
    }
  }
}"
90456,"@Test public void testConverter(){
  final MapMessage msg=new MapMessage();
  msg.put(""String_Node_Str"",""String_Node_Str"");
  msg.put(""String_Node_Str"",""String_Node_Str"");
  msg.put(""String_Node_Str"",""String_Node_Str"");
  final MapPatternConverter converter=MapPatternConverter.newInstance(null);
  final LogEvent event=Log4jLogEvent.newBuilder().setLoggerName(""String_Node_Str"").setLevel(Level.DEBUG).setMessage(msg).build();
  final StringBuilder sb=new StringBuilder();
  converter.format(event,sb);
  final String str=sb.toString();
  String expected=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + expected + ""String_Node_Str""+ str,str.contains(expected));
  expected=""String_Node_Str"";
  assertTrue(""String_Node_Str"",str.contains(expected));
  expected=""String_Node_Str"";
  assertTrue(""String_Node_Str"",str.contains(expected));
}","@Test public void testConverter(){
  final MapMessage msg=new MapMessage();
  msg.put(""String_Node_Str"",""String_Node_Str"");
  msg.put(""String_Node_Str"",""String_Node_Str"");
  msg.put(""String_Node_Str"",""String_Node_Str"");
  final MapPatternConverter converter=MapPatternConverter.newInstance(null);
  final LogEvent event=Log4jLogEvent.newBuilder().setLoggerName(""String_Node_Str"").setLevel(Level.DEBUG).setMessage(msg).build();
  final StringBuilder sb=new StringBuilder();
  converter.format(event,sb);
  final String str=sb.toString();
  String expected=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + expected + ""String_Node_Str""+ str,str.contains(expected));
  expected=""String_Node_Str"";
  assertTrue(""String_Node_Str"",str.contains(expected));
  expected=""String_Node_Str"";
  assertTrue(""String_Node_Str"",str.contains(expected));
  assertEquals(""String_Node_Str"",str);
}"
90457,"/** 
 * Get the time zone used by this parser. <p> The default   {@link TimeZone} used to create a {@link Date} when the {@link TimeZone} is not specified by theformat pattern. </p>
 * @return the time zone
 */
TimeZone getTimeZone();","/** 
 * Gets the time zone used by this parser. <p> The default   {@link TimeZone} used to create a {@link Date} when the {@link TimeZone} is not specified by theformat pattern. </p>
 * @return the time zone
 */
TimeZone getTimeZone();"
90458,"/** 
 * Equivalent to DateFormat.parse(String, ParsePosition). See   {@link java.text.DateFormat#parse(String,ParsePosition)} for more information.
 * @param source A <code>String</code>, part of which should be parsed.
 * @param pos A <code>ParsePosition</code> object with index and error index information as described above.
 * @return A <code>Date</code> parsed from the string. In case of error, returns null.
 * @throws NullPointerException if text or pos is null.
 */
Date parse(String source,ParsePosition pos);","/** 
 * Parses a formatted date string according to the format.  Updates the Calendar with parsed fields. Upon success, the ParsePosition index is updated to indicate how much of the source text was consumed. Not all source text needs to be consumed.  Upon parse failure, ParsePosition error index is updated to the offset of the source text which does not match the supplied format.
 * @param source The text to parse.
 * @param pos On input, the position in the source to start parsing, on output, updated position.
 * @param calendar The calendar into which to set parsed fields.
 * @return true, if source has been parsed (pos parsePosition is updated); otherwise false (and pos errorIndex is updated)
 * @throws IllegalArgumentException when Calendar has been set to be not lenient, and a parsed field isout of range.
 */
boolean parse(String source,ParsePosition pos,Calendar calendar);"
90459,"/** 
 * Get the pattern used by this parser.
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
String getPattern();","/** 
 * Gets the pattern used by this parser.
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
String getPattern();"
90460,"/** 
 * Get the locale used by this parser.
 * @return the locale
 */
Locale getLocale();","/** 
 * Gets the locale used by this parser.
 * @return the locale
 */
Locale getLocale();"
90461,"/** 
 * Parse a date/time string according to the given parse position.
 * @param source A <code>String</code> whose beginning should be parsed.
 * @param pos the parse position
 * @return a <code>java.util.Date</code> object
 * @see java.text.DateFormat#parseObject(String,ParsePosition)
 */
Object parseObject(String source,ParsePosition pos);","/** 
 * Parses a date/time string according to the given parse position.
 * @param source A <code>String</code> whose beginning should be parsed.
 * @param pos the parse position
 * @return a <code>java.util.Date</code> object
 * @see java.text.DateFormat#parseObject(String,ParsePosition)
 */
Object parseObject(String source,ParsePosition pos);"
90462,"@Override public Date parse(final String source,final ParsePosition pos){
  return parser.parse(source,pos);
}","@Override public boolean parse(String source,ParsePosition pos,Calendar calendar){
  return parser.parse(source,pos,calendar);
}"
90463,"private String createClassPath(Class<?> cls){
  final String resource=""String_Node_Str"" + cls.getName().replace('.','/') + ""String_Node_Str"";
  final URL url=cls.getResource(resource);
  String location=url.toString();
  if (location.startsWith(""String_Node_Str"")) {
    location=location.substring(""String_Node_Str"".length(),location.indexOf('!'));
  }
  if (location.startsWith(""String_Node_Str"")) {
    location=location.substring(""String_Node_Str"".length());
  }
  if (location.endsWith(resource)) {
    location=location.substring(0,location.length() - resource.length());
  }
  return location.isEmpty() ? ""String_Node_Str"" : location;
}","private String createClassPath(Class<?> cls){
  final String resource=""String_Node_Str"" + cls.getName().replace('.','/') + ""String_Node_Str"";
  final URL url=cls.getResource(resource);
  String location=url.toString();
  if (location.startsWith(""String_Node_Str"")) {
    location=location.substring(""String_Node_Str"".length(),location.indexOf('!'));
  }
  if (location.startsWith(""String_Node_Str"")) {
    location=location.substring(""String_Node_Str"".length());
  }
  if (location.endsWith(resource)) {
    location=location.substring(0,location.length() - resource.length());
  }
  if (!new File(location).exists()) {
    location=File.separator + location;
  }
  return location.isEmpty() ? ""String_Node_Str"" : location;
}"
90464,"/** 
 * If there are no configuration properties, this injector will return the thread context's internal data structure. Otherwise the configuration properties are combined with the thread context key-value pairs into the specified reusable StringMap.
 * @param props list of configuration properties, may be {@code null}
 * @param reusable a {@code StringMap} instance that may be reused to avoid creating temporary objects
 * @return a {@code StringMap} combining configuration properties with thread context data
 */
@Override public StringMap injectContextData(final List<Property> props,final StringMap reusable){
  final StringMap immutableCopy=ThreadContextAccess.getThreadContextMap2().getReadOnlyContextData();
  if (props == null || props.isEmpty()) {
    return immutableCopy;
  }
  copyProperties(props,reusable);
  reusable.putAll(immutableCopy);
  return reusable;
}","/** 
 * If there are no configuration properties, this injector will return the thread context's internal data structure. Otherwise the configuration properties are combined with the thread context key-value pairs into the specified reusable StringMap.
 * @param props list of configuration properties, may be {@code null}
 * @param ignore a {@code StringMap} instance from the log event
 * @return a {@code StringMap} combining configuration properties with thread context data
 */
@Override public StringMap injectContextData(final List<Property> props,final StringMap ignore){
  final StringMap immutableCopy=ThreadContextAccess.getThreadContextMap2().getReadOnlyContextData();
  if (props == null || props.isEmpty()) {
    return immutableCopy;
  }
  final StringMap result=ContextDataFactory.createContextData();
  copyProperties(props,result);
  result.putAll(immutableCopy);
  return result;
}"
90465,"/** 
 * {@inheritDoc}
 */
@Override public MutableContextData getMutableContextData(){
  final MutableContextData map=localMap.get();
  return map == null ? createMutableContextData() : map;
}","/** 
 * {@inheritDoc}
 */
@Override public MutableContextData getMutableContextData(){
  final MutableContextData map=localMap.get();
  return map == null ? EMPTY_CONTEXT_DATA : map;
}"
90466,"@Override public AppenderSet build(){
  if (configuration == null) {
    LOGGER.error(""String_Node_Str"");
  }
  final List<Node> children=node.getChildren();
  final Map<String,Node> map=new HashMap<>(node == null ? 0 : children.size());
  if (children == null) {
    LOGGER.error(""String_Node_Str"",this);
    return null;
  }
  for (  final Node childNode : children) {
    final String key=childNode.getAttributes().get(""String_Node_Str"");
    if (key == null) {
      LOGGER.error(""String_Node_Str"",childNode,children);
    }
 else {
      map.put(key,childNode);
    }
  }
  return new AppenderSet(configuration,map);
}","@Override public AppenderSet build(){
  if (configuration == null) {
    LOGGER.error(""String_Node_Str"",this);
    return null;
  }
  if (node == null) {
    LOGGER.error(""String_Node_Str"",this);
    return null;
  }
  final List<Node> children=node.getChildren();
  if (children == null) {
    LOGGER.error(""String_Node_Str"",this);
    return null;
  }
  final Map<String,Node> map=new HashMap<>(children.size());
  for (  final Node childNode : children) {
    final String key=childNode.getAttributes().get(""String_Node_Str"");
    if (key == null) {
      LOGGER.error(""String_Node_Str"",childNode,children);
    }
 else {
      map.put(key,childNode);
    }
  }
  return new AppenderSet(configuration,map);
}"
90467,"/** 
 * Appender Filter method. The default returns NEUTRAL.
 * @param logger the Logger.
 * @param level The logging Level.
 * @param marker The Marker, if any.
 * @param msg The message, if present.
 * @param p0 the message parameters
 * @param p1 the message parameters
 * @param p2 the message parameters
 * @param p3 the message parameters
 * @param p4 the message parameters
 * @param p5 the message parameters
 * @param p6 the message parameters
 * @param p7 the message parameters
 * @param p8 the message parameters
 * @param p9 the message parameters
 * @return The Result of filtering.
 */
@Override public Result filter(final Logger logger,final Level level,final Marker marker,final String msg,final Object p0,final Object p1,final Object p2,final Object p3,final Object p4,final Object p5,final Object p6,final Object p7,final Object p8,final Object p9){
  return Result.NEUTRAL;
}","/** 
 * Appender Filter method. The default returns NEUTRAL.
 * @param logger the Logger.
 * @param level The logging Level.
 * @param marker The Marker, if any.
 * @param msg The message, if present.
 * @param p0 the message parameters
 * @param p1 the message parameters
 * @param p2 the message parameters
 * @param p3 the message parameters
 * @param p4 the message parameters
 * @param p5 the message parameters
 * @param p6 the message parameters
 * @param p7 the message parameters
 * @param p8 the message parameters
 * @param p9 the message parameters
 * @return The Result of filtering.
 */
@Override public Result filter(final Logger logger,final Level level,final Marker marker,final String msg,final Object p0,final Object p1,final Object p2,final Object p3,final Object p4,final Object p5,final Object p6,final Object p7,final Object p8,final Object p9){
  return filter(logger,level,marker,msg,new Object[]{p0,p1,p2,p3,p4,p5,p6,p7,p8,p9});
}"
90468,"@Override public void remove(final String key){
  if (keys == EMPTY) {
    return;
  }
  final int index=indexOfKey(key);
  if (index >= 0) {
    assertNotFrozen();
    assertNoConcurrentModification();
    System.arraycopy(keys,index + 1,keys,index,size - index);
    System.arraycopy(values,index + 1,values,index,size - index);
    size--;
  }
}","@Override public void remove(final String key){
  if (keys == EMPTY) {
    return;
  }
  final int index=indexOfKey(key);
  if (index >= 0) {
    assertNotFrozen();
    assertNoConcurrentModification();
    System.arraycopy(keys,index + 1,keys,index,size - 1 - index);
    System.arraycopy(values,index + 1,values,index,size - 1 - index);
    keys[size - 1]=null;
    values[size - 1]=null;
    size--;
  }
}"
90469,"/** 
 * This method is called by the EventHandler that processes the RingBufferLogEvent in a separate thread. Merges the contents of the configuration map into the contextData, after replacing any variables in the property values with the StrSubstitutor-supplied actual values.
 * @param event the event to log
 */
public void actualAsyncLog(final RingBufferLogEvent event){
  final Map<Property,Boolean> properties=privateConfig.loggerConfig.getProperties();
  if (properties != null) {
    MutableContextData contextData=(MutableContextData)event.getContextData();
    for (    final Map.Entry<Property,Boolean> entry : properties.entrySet()) {
      final Property prop=entry.getKey();
      if (contextData.getValue(prop.getName()) != null) {
        continue;
      }
      final String value=entry.getValue() ? privateConfig.config.getStrSubstitutor().replace(event,prop.getValue()) : prop.getValue();
      contextData.putValue(prop.getName(),prop.getValue());
    }
  }
  final ReliabilityStrategy strategy=privateConfig.loggerConfig.getReliabilityStrategy();
  strategy.log(this,event);
}","/** 
 * This method is called by the EventHandler that processes the RingBufferLogEvent in a separate thread. Merges the contents of the configuration map into the contextData, after replacing any variables in the property values with the StrSubstitutor-supplied actual values.
 * @param event the event to log
 */
public void actualAsyncLog(final RingBufferLogEvent event){
  final List<Property> properties=privateConfig.loggerConfig.getPropertyList();
  if (properties != null) {
    MutableContextData contextData=(MutableContextData)event.getContextData();
    if (contextData.isFrozen()) {
      final MutableContextData temp=ContextDataFactory.createContextData();
      temp.putAll(contextData);
      contextData=temp;
    }
    for (int i=0; i < properties.size(); i++) {
      final Property prop=properties.get(i);
      if (contextData.getValue(prop.getName()) != null) {
        continue;
      }
      final String value=prop.isValueNeedsLookup() ? privateConfig.config.getStrSubstitutor().replace(event,prop.getValue()) : prop.getValue();
      contextData.putValue(prop.getName(),prop.getValue());
    }
    event.setContextData(contextData);
  }
  final ReliabilityStrategy strategy=privateConfig.loggerConfig.getReliabilityStrategy();
  strategy.log(this,event);
}"
90470,"@Override public void putAll(final ContextData source){
  assertNotFrozen();
  assertNoConcurrentModification();
  if (source instanceof ArrayContextData) {
    initFrom0((ArrayContextData)source);
  }
 else   if (source != null) {
    if (source == this) {
      return;
    }
    source.forEach(PUT_ALL,this);
  }
}","@Override public void putAll(final ContextData source){
  assertNotFrozen();
  assertNoConcurrentModification();
  if (source instanceof ArrayContextData && this.size == 0) {
    initFrom0((ArrayContextData)source);
  }
 else   if (source != null) {
    if (source == this) {
      return;
    }
    source.forEach(PUT_ALL,this);
  }
}"
90471,"/** 
 * Initialize the fields of this   {@code MutableLogEvent} from another event.Similar in purpose and usage as  {@link org.apache.logging.log4j.core.impl.Log4jLogEvent.LogEventProxy}, but a mutable version. <p> This method is used on async logger ringbuffer slots holding MutableLogEvent objects in each slot. </p>
 * @param event the event to copy data from
 */
public void initFrom(final LogEvent event){
  this.loggerFqcn=event.getLoggerFqcn();
  this.marker=event.getMarker();
  this.level=event.getLevel();
  this.loggerName=event.getLoggerName();
  this.timeMillis=event.getTimeMillis();
  this.thrown=event.getThrown();
  this.thrownProxy=event.getThrownProxy();
  if (event.getContextData() instanceof MutableContextData) {
    this.contextData=(MutableContextData)event.getContextData();
  }
 else {
    this.contextData.putAll(event.getContextData());
  }
  this.contextStack=event.getContextStack();
  this.source=event.isIncludeLocation() ? event.getSource() : null;
  this.threadId=event.getThreadId();
  this.threadName=event.getThreadName();
  this.threadPriority=event.getThreadPriority();
  this.endOfBatch=event.isEndOfBatch();
  this.includeLocation=event.isIncludeLocation();
  this.nanoTime=event.getNanoTime();
  setMessage(event.getMessage());
}","/** 
 * Initialize the fields of this   {@code MutableLogEvent} from another event.Similar in purpose and usage as  {@link org.apache.logging.log4j.core.impl.Log4jLogEvent.LogEventProxy}, but a mutable version. <p> This method is used on async logger ringbuffer slots holding MutableLogEvent objects in each slot. </p>
 * @param event the event to copy data from
 */
public void initFrom(final LogEvent event){
  this.loggerFqcn=event.getLoggerFqcn();
  this.marker=event.getMarker();
  this.level=event.getLevel();
  this.loggerName=event.getLoggerName();
  this.timeMillis=event.getTimeMillis();
  this.thrown=event.getThrown();
  this.thrownProxy=event.getThrownProxy();
  this.contextData.putAll(event.getContextData());
  this.contextStack=event.getContextStack();
  this.source=event.isIncludeLocation() ? event.getSource() : null;
  this.threadId=event.getThreadId();
  this.threadName=event.getThreadName();
  this.threadPriority=event.getThreadPriority();
  this.endOfBatch=event.isEndOfBatch();
  this.includeLocation=event.isIncludeLocation();
  this.nanoTime=event.getNanoTime();
  setMessage(event.getMessage());
}"
90472,"@Override public Configuration getConfiguration(final LoggerContext loggerContext,final ConfigurationSource source){
  final ConfigurationBuilder<BuiltConfiguration> builder;
  try (final InputStream configStream=source.getInputStream()){
    builder=new Log4j1ConfigurationParser().buildConfigurationBuilder(configStream);
  }
 catch (  IOException e) {
    throw new ConfigurationException(""String_Node_Str"" + source.toString(),e);
  }
  if (builder == null)   return null;
  return builder.build();
}","@Override public Configuration getConfiguration(final LoggerContext loggerContext,final ConfigurationSource source){
  final ConfigurationBuilder<BuiltConfiguration> builder;
  try (final InputStream configStream=source.getInputStream()){
    builder=new Log4j1ConfigurationParser().buildConfigurationBuilder(configStream);
  }
 catch (  IOException e) {
    throw new ConfigurationException(""String_Node_Str"" + source.toString(),e);
  }
  return builder.build();
}"
90473,"/** 
 * Parse a Log4j 1.2 properties configuration file into a ConfigurationBuilder.
 * @param input  InputStream to read from, will not be closed.
 * @return  the populated ConfigurationBuilder
 * @throws IOException  if unable to read the input
 */
public ConfigurationBuilder<BuiltConfiguration> buildConfigurationBuilder(final InputStream input) throws IOException {
  properties.load(input);
  final String rootCategoryValue=getLog4jValue(""String_Node_Str"");
  final String rootLoggerValue=getLog4jValue(""String_Node_Str"");
  if (rootCategoryValue == null && rootLoggerValue == null) {
    return null;
  }
  builder.setConfigurationName(""String_Node_Str"");
  final String debugValue=getLog4jValue(""String_Node_Str"");
  if (Boolean.valueOf(debugValue)) {
    builder.setStatusLevel(Level.DEBUG);
  }
  final String[] sortedAppenderNamesC=buildRootLogger(getLog4jValue(""String_Node_Str""));
  final String[] sortedAppenderNamesL=buildRootLogger(getLog4jValue(""String_Node_Str""));
  final String[] sortedAppenderNames=sortedAppenderNamesL.length > 0 ? sortedAppenderNamesL : sortedAppenderNamesC;
  final Map<String,String> classNameToProperty=buildClassToPropertyPrefixMap(sortedAppenderNames);
  for (  final Map.Entry<String,String> entry : classNameToProperty.entrySet()) {
    final String appenderName=entry.getKey();
    String appenderClass=entry.getValue();
    buildAppender(appenderName,appenderClass);
  }
  buildLoggers(""String_Node_Str"");
  buildLoggers(""String_Node_Str"");
  return builder;
}","/** 
 * Parse a Log4j 1.2 properties configuration file into a ConfigurationBuilder.
 * @param input  InputStream to read from, will not be closed.
 * @return  the populated ConfigurationBuilder, never {@literal null}
 * @throws IOException  if unable to read the input
 * @throws ConfigurationException  if the input does not contain a valid configuration
 */
public ConfigurationBuilder<BuiltConfiguration> buildConfigurationBuilder(final InputStream input) throws IOException {
  properties.load(input);
  final String rootCategoryValue=getLog4jValue(""String_Node_Str"");
  final String rootLoggerValue=getLog4jValue(""String_Node_Str"");
  if (rootCategoryValue == null && rootLoggerValue == null) {
    throw new ConfigurationException(""String_Node_Str"");
  }
  builder.setConfigurationName(""String_Node_Str"");
  final String debugValue=getLog4jValue(""String_Node_Str"");
  if (Boolean.valueOf(debugValue)) {
    builder.setStatusLevel(Level.DEBUG);
  }
  final String[] sortedAppenderNamesC=buildRootLogger(getLog4jValue(""String_Node_Str""));
  final String[] sortedAppenderNamesL=buildRootLogger(getLog4jValue(""String_Node_Str""));
  final String[] sortedAppenderNames=sortedAppenderNamesL.length > 0 ? sortedAppenderNamesL : sortedAppenderNamesC;
  final Map<String,String> classNameToProperty=buildClassToPropertyPrefixMap(sortedAppenderNames);
  for (  final Map.Entry<String,String> entry : classNameToProperty.entrySet()) {
    final String appenderName=entry.getKey();
    String appenderClass=entry.getValue();
    buildAppender(appenderName,appenderClass);
  }
  buildLoggers(""String_Node_Str"");
  buildLoggers(""String_Node_Str"");
  return builder;
}"
90474,"public IdlePurgePolicy(long timeToLive,long checkInterval,final ConfigurationScheduler scheduler){
  this.timeToLive=timeToLive;
  this.checkInterval=checkInterval;
  this.scheduler=scheduler;
}","public IdlePurgePolicy(final long timeToLive,final long checkInterval,final ConfigurationScheduler scheduler){
  this.timeToLive=timeToLive;
  this.checkInterval=checkInterval;
  this.scheduler=scheduler;
}"
90475,"/** 
 * Delete specified appender
 * @param key The appender's key
 */
public void deleteAppender(final String key){
  LOGGER.debug(""String_Node_Str"" + key);
  AppenderControl control=appenders.remove(key);
  control.getAppender().stop();
  LOGGER.debug(""String_Node_Str"" + key + ""String_Node_Str"");
  final AppenderControl control=appenders.remove(key);
  if (null != control) {
    LOGGER.debug(""String_Node_Str"" + key + ""String_Node_Str"");
    control.getAppender().stop();
  }
 else {
    LOGGER.debug(""String_Node_Str"" + key + ""String_Node_Str"");
  }
}","/** 
 * Delete specified appender
 * @param key The appender's key
 */
public void deleteAppender(final String key){
  LOGGER.debug(""String_Node_Str"" + key + ""String_Node_Str"");
  final AppenderControl control=appenders.remove(key);
  if (null != control) {
    LOGGER.debug(""String_Node_Str"" + key + ""String_Node_Str"");
    control.getAppender().stop();
  }
 else {
    LOGGER.debug(""String_Node_Str"" + key + ""String_Node_Str"");
  }
}"
90476,"/** 
 * Determines if there are any packages to filter.
 * @return true if there are packages, false otherwise.
 */
public boolean hasPackages(){
  return this.packages != null && !this.packages.isEmpty();
}","/** 
 * Determines if there are any packages to filter.
 * @return true if there are packages, false otherwise.
 */
public boolean hasPackages(){
  return this.ignorePackages != null && !this.ignorePackages.isEmpty();
}"
90477,"/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  final StringBuilder s=new StringBuilder();
  s.append('{').append(allLines() ? FULL : this.lines == 2 ? SHORT : anyLines() ? String.valueOf(this.lines) : NONE).append('}');
  s.append(""String_Node_Str"").append(this.separator).append(""String_Node_Str"");
  if (hasPackages()) {
    s.append(""String_Node_Str"");
    for (    final String p : this.packages) {
      s.append(p).append(',');
    }
    s.deleteCharAt(s.length() - 1);
    s.append(""String_Node_Str"");
  }
  return s.toString();
}","/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  final StringBuilder s=new StringBuilder();
  s.append('{').append(allLines() ? FULL : this.lines == 2 ? SHORT : anyLines() ? String.valueOf(this.lines) : NONE).append('}');
  s.append(""String_Node_Str"").append(this.separator).append(""String_Node_Str"");
  if (hasPackages()) {
    s.append(""String_Node_Str"");
    for (    final String p : this.ignorePackages) {
      s.append(p).append(',');
    }
    s.deleteCharAt(s.length() - 1);
    s.append(""String_Node_Str"");
  }
  return s.toString();
}"
90478,"/** 
 * Creates a new instance based on the array of options.
 * @param options The array of options.
 * @return A new initialized instance.
 */
public static ThrowableFormatOptions newInstance(String[] options){
  if (options == null || options.length == 0) {
    return DEFAULT;
  }
  if (options.length == 1 && Strings.isNotEmpty(options[0])) {
    final String[] opts=options[0].split(Patterns.COMMA_SEPARATOR,2);
    final String first=opts[0].trim();
    try (final Scanner scanner=new Scanner(first)){
      if (opts.length > 1 && (first.equalsIgnoreCase(FULL) || first.equalsIgnoreCase(SHORT) || first.equalsIgnoreCase(NONE)|| scanner.hasNextInt())) {
        options=new String[]{first,opts[1].trim()};
      }
    }
   }
  int lines=DEFAULT.lines;
  String separator=DEFAULT.separator;
  List<String> packages=DEFAULT.packages;
  TextRenderer ansiRenderer=DEFAULT.textRenderer;
  for (  final String rawOption : options) {
    if (rawOption != null) {
      final String option=rawOption.trim();
      if (option.isEmpty()) {
      }
 else       if (option.startsWith(""String_Node_Str"") && option.endsWith(""String_Node_Str"")) {
        separator=option.substring(""String_Node_Str"".length(),option.length() - 1);
      }
 else       if (option.startsWith(""String_Node_Str"") && option.endsWith(""String_Node_Str"")) {
        final String filterStr=option.substring(""String_Node_Str"".length(),option.length() - 1);
        if (filterStr.length() > 0) {
          final String[] array=filterStr.split(Patterns.COMMA_SEPARATOR);
          if (array.length > 0) {
            packages=new ArrayList<>(array.length);
            for (            String token : array) {
              token=token.trim();
              if (token.length() > 0) {
                packages.add(token);
              }
            }
          }
        }
      }
 else       if (option.equalsIgnoreCase(NONE)) {
        lines=0;
      }
 else       if (option.equalsIgnoreCase(SHORT) || option.equalsIgnoreCase(CLASS_NAME) || option.equalsIgnoreCase(METHOD_NAME)|| option.equalsIgnoreCase(LINE_NUMBER)|| option.equalsIgnoreCase(FILE_NAME)|| option.equalsIgnoreCase(MESSAGE)|| option.equalsIgnoreCase(LOCALIZED_MESSAGE)) {
        lines=2;
      }
 else       if (option.startsWith(""String_Node_Str"") && option.endsWith(""String_Node_Str"")) {
        if (Loader.isJansiAvailable()) {
          ansiRenderer=new JAnsiTextRenderer(new String[]{null,option.substring(""String_Node_Str"".length(),option.length() - 1)},JAnsiTextRenderer.DefaultExceptionStyleMap);
        }
 else {
          StatusLogger.getLogger().warn(""String_Node_Str"");
        }
      }
 else       if (!option.equalsIgnoreCase(FULL)) {
        lines=Integer.parseInt(option);
      }
    }
  }
  return new ThrowableFormatOptions(lines,separator,packages,ansiRenderer);
}","/** 
 * Creates a new instance based on the array of options.
 * @param options The array of options.
 * @return A new initialized instance.
 */
public static ThrowableFormatOptions newInstance(String[] options){
  if (options == null || options.length == 0) {
    return DEFAULT;
  }
  if (options.length == 1 && Strings.isNotEmpty(options[0])) {
    final String[] opts=options[0].split(Patterns.COMMA_SEPARATOR,2);
    final String first=opts[0].trim();
    try (final Scanner scanner=new Scanner(first)){
      if (opts.length > 1 && (first.equalsIgnoreCase(FULL) || first.equalsIgnoreCase(SHORT) || first.equalsIgnoreCase(NONE)|| scanner.hasNextInt())) {
        options=new String[]{first,opts[1].trim()};
      }
    }
   }
  int lines=DEFAULT.lines;
  String separator=DEFAULT.separator;
  List<String> packages=DEFAULT.ignorePackages;
  TextRenderer ansiRenderer=DEFAULT.textRenderer;
  for (  final String rawOption : options) {
    if (rawOption != null) {
      final String option=rawOption.trim();
      if (option.isEmpty()) {
      }
 else       if (option.startsWith(""String_Node_Str"") && option.endsWith(""String_Node_Str"")) {
        separator=option.substring(""String_Node_Str"".length(),option.length() - 1);
      }
 else       if (option.startsWith(""String_Node_Str"") && option.endsWith(""String_Node_Str"")) {
        final String filterStr=option.substring(""String_Node_Str"".length(),option.length() - 1);
        if (filterStr.length() > 0) {
          final String[] array=filterStr.split(Patterns.COMMA_SEPARATOR);
          if (array.length > 0) {
            packages=new ArrayList<>(array.length);
            for (            String token : array) {
              token=token.trim();
              if (token.length() > 0) {
                packages.add(token);
              }
            }
          }
        }
      }
 else       if (option.equalsIgnoreCase(NONE)) {
        lines=0;
      }
 else       if (option.equalsIgnoreCase(SHORT) || option.equalsIgnoreCase(CLASS_NAME) || option.equalsIgnoreCase(METHOD_NAME)|| option.equalsIgnoreCase(LINE_NUMBER)|| option.equalsIgnoreCase(FILE_NAME)|| option.equalsIgnoreCase(MESSAGE)|| option.equalsIgnoreCase(LOCALIZED_MESSAGE)) {
        lines=2;
      }
 else       if (option.startsWith(""String_Node_Str"") && option.endsWith(""String_Node_Str"")) {
        if (Loader.isJansiAvailable()) {
          ansiRenderer=new JAnsiTextRenderer(new String[]{null,option.substring(""String_Node_Str"".length(),option.length() - 1)},JAnsiTextRenderer.DefaultExceptionStyleMap);
        }
 else {
          StatusLogger.getLogger().warn(""String_Node_Str"");
        }
      }
 else       if (!option.equalsIgnoreCase(FULL)) {
        lines=Integer.parseInt(option);
      }
    }
  }
  return new ThrowableFormatOptions(lines,separator,packages,ansiRenderer);
}"
90479,"/** 
 * {@inheritDoc}
 */
@Override public void format(final LogEvent event,final StringBuilder toAppendTo){
  final ThrowableProxy proxy=event.getThrownProxy();
  final Throwable throwable=event.getThrown();
  if ((throwable != null || proxy != null) && options.anyLines()) {
    if (proxy == null) {
      super.format(event,toAppendTo);
      return;
    }
    final String extStackTrace=proxy.getExtendedStackTraceAsString(options.getPackages(),options.getTextRenderer());
    final int len=toAppendTo.length();
    if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {
      toAppendTo.append(' ');
    }
    if (!options.allLines() || !Constants.LINE_SEPARATOR.equals(options.getSeparator())) {
      final StringBuilder sb=new StringBuilder();
      final String[] array=extStackTrace.split(Constants.LINE_SEPARATOR);
      final int limit=options.minLines(array.length) - 1;
      for (int i=0; i <= limit; ++i) {
        sb.append(array[i]);
        if (i < limit) {
          sb.append(options.getSeparator());
        }
      }
      toAppendTo.append(sb.toString());
    }
 else {
      toAppendTo.append(extStackTrace);
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void format(final LogEvent event,final StringBuilder toAppendTo){
  final ThrowableProxy proxy=event.getThrownProxy();
  final Throwable throwable=event.getThrown();
  if ((throwable != null || proxy != null) && options.anyLines()) {
    if (proxy == null) {
      super.format(event,toAppendTo);
      return;
    }
    final String extStackTrace=proxy.getExtendedStackTraceAsString(options.getIgnorePackages(),options.getTextRenderer());
    final int len=toAppendTo.length();
    if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {
      toAppendTo.append(' ');
    }
    if (!options.allLines() || !Constants.LINE_SEPARATOR.equals(options.getSeparator())) {
      final StringBuilder sb=new StringBuilder();
      final String[] array=extStackTrace.split(Constants.LINE_SEPARATOR);
      final int limit=options.minLines(array.length) - 1;
      for (int i=0; i <= limit; ++i) {
        sb.append(array[i]);
        if (i < limit) {
          sb.append(options.getSeparator());
        }
      }
      toAppendTo.append(sb.toString());
    }
 else {
      toAppendTo.append(extStackTrace);
    }
  }
}"
90480,"/** 
 * {@inheritDoc}
 */
@Override public void format(final LogEvent event,final StringBuilder toAppendTo){
  final ThrowableProxy proxy=event.getThrownProxy();
  final Throwable throwable=event.getThrown();
  if (throwable != null && options.anyLines()) {
    if (proxy == null) {
      super.format(event,toAppendTo);
      return;
    }
    final String trace=proxy.getCauseStackTraceAsString(options.getPackages());
    final int len=toAppendTo.length();
    if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {
      toAppendTo.append(' ');
    }
    if (!options.allLines() || !Constants.LINE_SEPARATOR.equals(options.getSeparator())) {
      final StringBuilder sb=new StringBuilder();
      final String[] array=trace.split(Constants.LINE_SEPARATOR);
      final int limit=options.minLines(array.length) - 1;
      for (int i=0; i <= limit; ++i) {
        sb.append(array[i]);
        if (i < limit) {
          sb.append(options.getSeparator());
        }
      }
      toAppendTo.append(sb.toString());
    }
 else {
      toAppendTo.append(trace);
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void format(final LogEvent event,final StringBuilder toAppendTo){
  final ThrowableProxy proxy=event.getThrownProxy();
  final Throwable throwable=event.getThrown();
  if (throwable != null && options.anyLines()) {
    if (proxy == null) {
      super.format(event,toAppendTo);
      return;
    }
    final String trace=proxy.getCauseStackTraceAsString(options.getIgnorePackages());
    final int len=toAppendTo.length();
    if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {
      toAppendTo.append(' ');
    }
    if (!options.allLines() || !Constants.LINE_SEPARATOR.equals(options.getSeparator())) {
      final StringBuilder sb=new StringBuilder();
      final String[] array=trace.split(Constants.LINE_SEPARATOR);
      final int limit=options.minLines(array.length) - 1;
      for (int i=0; i <= limit; ++i) {
        sb.append(array[i]);
        if (i < limit) {
          sb.append(options.getSeparator());
        }
      }
      toAppendTo.append(sb.toString());
    }
 else {
      toAppendTo.append(trace);
    }
  }
}"
90481,"public void test(final String[] args){
  final String config=args == null || args.length == 0 ? ""String_Node_Str"" : args[0];
  final LoggerContext ctx=Configurator.initialize(ConsoleAppenderAnsiMessagesMain.class.getName(),config);
  final Logger logger=LogManager.getLogger(ConsoleAppenderJAnsiXExceptionMain.class);
  try {
    IllegalArgumentException e=new IllegalArgumentException(""String_Node_Str"");
    e.fillInStackTrace();
    throw new IllegalStateException(""String_Node_Str"",e);
  }
 catch (  Exception e) {
    logger.info(""String_Node_Str"",e);
  }
 finally {
    Configurator.shutdown(ctx);
  }
}","public void test(final String[] args){
  final String config=args == null || args.length == 0 ? ""String_Node_Str"" : args[0];
  final LoggerContext ctx=Configurator.initialize(ConsoleAppenderAnsiMessagesMain.class.getName(),config);
  final Logger logger=LogManager.getLogger(ConsoleAppenderJAnsiXExceptionMain.class);
  try {
    Files.getFileStore(Paths.get(""String_Node_Str""));
  }
 catch (  Exception e) {
    IllegalArgumentException logE=new IllegalArgumentException(""String_Node_Str"",e);
    logger.info(""String_Node_Str"",logE);
  }
 finally {
    Configurator.shutdown(ctx);
  }
}"
90482,"/** 
 * Runs a given test comparing against the expected values.
 * @param options The list of options to parse.
 * @param expectedLines The expected lines.
 * @param expectedPackages The expected package filters.
 * @param expectedSeparator The expected seperator.
 */
private static void test(final String[] options,final int expectedLines,final String expectedSeparator,final List<String> expectedPackages){
  final ThrowableFormatOptions o=ThrowableFormatOptions.newInstance(options);
  assertEquals(""String_Node_Str"",expectedLines,o.getLines());
  assertEquals(""String_Node_Str"",expectedSeparator,o.getSeparator());
  assertEquals(""String_Node_Str"",expectedPackages,o.getPackages());
  assertEquals(""String_Node_Str"",expectedLines == Integer.MAX_VALUE,o.allLines());
  assertEquals(""String_Node_Str"",expectedLines != 0,o.anyLines());
  assertEquals(""String_Node_Str"",0,o.minLines(0));
  assertEquals(""String_Node_Str"",expectedLines,o.minLines(Integer.MAX_VALUE));
  assertEquals(""String_Node_Str"",expectedPackages != null && !expectedPackages.isEmpty(),o.hasPackages());
  assertNotNull(""String_Node_Str"",o.toString());
}","/** 
 * Runs a given test comparing against the expected values.
 * @param options The list of options to parse.
 * @param expectedLines The expected lines.
 * @param expectedPackages The expected package filters.
 * @param expectedSeparator The expected seperator.
 */
private static void test(final String[] options,final int expectedLines,final String expectedSeparator,final List<String> expectedPackages){
  final ThrowableFormatOptions o=ThrowableFormatOptions.newInstance(options);
  assertEquals(""String_Node_Str"",expectedLines,o.getLines());
  assertEquals(""String_Node_Str"",expectedSeparator,o.getSeparator());
  assertEquals(""String_Node_Str"",expectedPackages,o.getIgnorePackages());
  assertEquals(""String_Node_Str"",expectedLines == Integer.MAX_VALUE,o.allLines());
  assertEquals(""String_Node_Str"",expectedLines != 0,o.anyLines());
  assertEquals(""String_Node_Str"",0,o.minLines(0));
  assertEquals(""String_Node_Str"",expectedLines,o.minLines(Integer.MAX_VALUE));
  assertEquals(""String_Node_Str"",expectedPackages != null && !expectedPackages.isEmpty(),o.hasPackages());
  assertNotNull(""String_Node_Str"",o.toString());
}"
90483,"/** 
 * Logs entry to a method using a Message to describe the parameters. <pre> public void doSomething(Request foo) { LOGGER.traceEntry(new JsonMessage(foo)); // do something } </pre>
 * @param message The message.
 * @return the built message
 * @since 2.6
 */
EntryMessage traceEntry(Message message);","/** 
 * Logs entry to a method using a Message to describe the parameters. <pre> public void doSomething(Request foo) { LOGGER.traceEntry(new JsonMessage(foo)); // do something } </pre> <p> Avoid passing a   {@code ReusableMessage} to this method (therefore, also avoid passing messages created bycalling  {@code logger.getMessageFactory().newMessage(""some message"")}): Log4j will replace such messages with an immutable message to prevent situations where the reused message instance is modified by subsequent calls to the logger before the returned   {@code EntryMessage} is fully processed.</p>
 * @param message The message. Avoid specifying a ReusableMessage, use immutable messages instead.
 * @return the built message
 * @since 2.6
 * @see org.apache.logging.log4j.message.ReusableMessage
 */
EntryMessage traceEntry(Message message);"
90484,"@Override public EntryMessage newEntryMessage(final Message message){
  return new SimpleEntryMessage(entryText,message);
}","@Override public EntryMessage newEntryMessage(final Message message){
  return new SimpleEntryMessage(entryText,makeImmutable(message));
}"
90485,"private MessageRenderer loadMessageRenderer(String[] options){
  if (formats != null && formats.length == 0) {
    return null;
  }
  final String format=formats[0].toUpperCase(Locale.ROOT);
switch (format) {
case ""String_Node_Str"":
    return new JAnsiMessageRenderer(formats);
case ""String_Node_Str"":
  return new HtmlMessageRenderer(formats);
}
return null;
}","private MessageRenderer loadMessageRenderer(String[] options){
  if (formats != null && formats.length > 0) {
    final String format=formats[0].toUpperCase(Locale.ROOT);
switch (format) {
case ""String_Node_Str"":
      return new JAnsiMessageRenderer(formats);
case ""String_Node_Str"":
    return new HtmlMessageRenderer(formats);
}
}
return null;
}"
90486,"/** 
 * Provide the RollingFileManager to the policy.
 * @param manager The RollingFileManager.
 */
@Override public void initialize(final RollingFileManager manager){
  this.manager=manager;
  if (manager.getFileSize() > 0) {
    manager.skipFooter(true);
    manager.rollover();
    manager.skipFooter(false);
  }
}","/** 
 * Provide the RollingFileManager to the policy.
 * @param manager The RollingFileManager.
 */
@Override public void initialize(final RollingFileManager manager){
  if (manager.getFileTime() < JVM_START_TIME && manager.getFileSize() >= minSize) {
    manager.skipFooter(true);
    manager.rollover();
    manager.skipFooter(false);
  }
}"
90487,"@PluginFactory public static OnStartupTriggeringPolicy createPolicy(){
  return new OnStartupTriggeringPolicy();
}","@PluginFactory public static OnStartupTriggeringPolicy createPolicy(@PluginAttribute(value=""String_Node_Str"",defaultLong=1) final long minSize){
  return new OnStartupTriggeringPolicy(minSize);
}"
90488,"@Test public void testPolicy() throws Exception {
  final Configuration configuration=new DefaultConfiguration();
  final Path target=Paths.get(TARGET_FILE);
  final Path rolled=Paths.get(ROLLED_FILE);
  Files.deleteIfExists(target);
  Files.deleteIfExists(rolled);
  final InputStream is=new ByteArrayInputStream(TEST_DATA.getBytes(""String_Node_Str""));
  Files.copy(is,target);
  is.close();
  final long size=Files.size(target);
  assertTrue(size > 0);
  final PatternLayout layout=PatternLayout.newBuilder().withPattern(""String_Node_Str"").withConfiguration(configuration).build();
  final RolloverStrategy strategy=DefaultRolloverStrategy.createStrategy(null,null,null,""String_Node_Str"",null,true,configuration);
  final OnStartupTriggeringPolicy policy=OnStartupTriggeringPolicy.createPolicy();
  final RollingFileManager manager=RollingFileManager.getFileManager(TARGET_FILE,TARGET_PATTERN,true,false,policy,strategy,null,layout,8192,true);
  manager.initialize();
  assertTrue(Files.exists(target));
  assertTrue(Files.size(target) == 0);
  assertTrue(Files.exists(rolled));
  assertTrue(Files.size(rolled) == size);
}","@Test public void testPolicy() throws Exception {
  final Configuration configuration=new DefaultConfiguration();
  final Path target=Paths.get(TARGET_FILE);
  final Path rolled=Paths.get(ROLLED_FILE);
  Files.deleteIfExists(target);
  Files.deleteIfExists(rolled);
  final InputStream is=new ByteArrayInputStream(TEST_DATA.getBytes(""String_Node_Str""));
  Files.copy(is,target);
  is.close();
  final long size=Files.size(target);
  assertTrue(size > 0);
  final PatternLayout layout=PatternLayout.newBuilder().withPattern(""String_Node_Str"").withConfiguration(configuration).build();
  final RolloverStrategy strategy=DefaultRolloverStrategy.createStrategy(null,null,null,""String_Node_Str"",null,true,configuration);
  final OnStartupTriggeringPolicy policy=OnStartupTriggeringPolicy.createPolicy(1);
  final RollingFileManager manager=RollingFileManager.getFileManager(TARGET_FILE,TARGET_PATTERN,true,false,policy,strategy,null,layout,8192,true);
  manager.initialize();
  assertTrue(Files.exists(target));
  assertTrue(Files.size(target) == 0);
  assertTrue(Files.exists(rolled));
  assertTrue(Files.size(rolled) == size);
}"
90489,"/** 
 * Not a real test, just make sure we can compile access to the typed manager.
 * @throws IOException
 */
@Test public void testAccessManager() throws IOException {
  final LoggerContext ctx=LoggerContext.getContext(false);
  final Configuration config=ctx.getConfiguration();
  final File file=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  file.deleteOnExit();
  final RollingFileAppender appender=RollingFileAppender.createAppender(file.getCanonicalPath(),""String_Node_Str"",null,""String_Node_Str"",null,null,null,OnStartupTriggeringPolicy.createPolicy(),null,null,null,null,null,null,config);
  final RollingFileManager manager=appender.getManager();
  manager.getRolloverStrategy();
  manager.getTriggeringPolicy();
}","/** 
 * Not a real test, just make sure we can compile access to the typed manager.
 * @throws IOException
 */
@Test public void testAccessManager() throws IOException {
  final LoggerContext ctx=LoggerContext.getContext(false);
  final Configuration config=ctx.getConfiguration();
  final File file=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  file.deleteOnExit();
  final RollingFileAppender appender=RollingFileAppender.createAppender(file.getCanonicalPath(),""String_Node_Str"",null,""String_Node_Str"",null,null,null,OnStartupTriggeringPolicy.createPolicy(1),null,null,null,null,null,null,config);
  final RollingFileManager manager=appender.getManager();
  manager.getRolloverStrategy();
  manager.getTriggeringPolicy();
}"
90490,"private void initThrowable(final Object[] params,final int argCount,final int usedParams){
  if (usedParams < argCount && this.throwable == null && params[argCount - 1] instanceof Throwable) {
    this.throwable=(Throwable)params[argCount - 1];
  }
}","private void initThrowable(final Object[] params,final int argCount,final int usedParams){
  if (usedParams < argCount && params[argCount - 1] instanceof Throwable) {
    this.throwable=(Throwable)params[argCount - 1];
  }
 else {
    this.throwable=null;
  }
}"
90491,"/** 
 * Merge the source Configuration into the target Configuration.
 * @param target        The target node to merge into.
 * @param source        The source node.
 * @param pluginManager The PluginManager.
 */
@Override public void mergConfigurations(Node target,Node source,PluginManager pluginManager){
  for (  Node sourceChildNode : source.getChildren()) {
    boolean isFilter=isFilterNode(sourceChildNode);
    boolean isMerged=false;
    for (    Node targetChildNode : target.getChildren()) {
      if (isFilter) {
        if (isFilterNode(targetChildNode)) {
          updateFilterNode(target,targetChildNode,sourceChildNode,pluginManager);
          isMerged=true;
          break;
        }
 else {
          continue;
        }
      }
      if (!targetChildNode.getName().equalsIgnoreCase(sourceChildNode.getName())) {
        continue;
      }
switch (targetChildNode.getName().toLowerCase()) {
case PROPERTIES:
case SCRIPTS:
case APPENDERS:
{
          for (          Node node : sourceChildNode.getChildren()) {
            for (            Node targetNode : targetChildNode.getChildren()) {
              if (targetNode.getAttributes().get(NAME).equals(node.getAttributes().get(NAME))) {
                targetChildNode.getChildren().remove(targetNode);
                break;
              }
            }
            targetChildNode.getChildren().add(node);
          }
          isMerged=true;
          break;
        }
case LOGGERS:
{
        Map<String,Node> targetLoggers=new HashMap<>();
        for (        Node node : targetChildNode.getChildren()) {
          targetLoggers.put(node.getName(),node);
        }
        for (        Node node : sourceChildNode.getChildren()) {
          Node targetNode=getLoggerNode(targetChildNode,node.getAttributes().get(NAME));
          Node loggerNode=new Node(targetChildNode,node.getName(),node.getType());
          if (targetNode != null) {
            for (            Node sourceLoggerChild : node.getChildren()) {
              if (isFilterNode(sourceLoggerChild)) {
                boolean foundFilter=false;
                for (                Node targetChild : targetNode.getChildren()) {
                  if (isFilterNode(targetChild)) {
                    updateFilterNode(loggerNode,targetChild,sourceLoggerChild,pluginManager);
                    foundFilter=true;
                    break;
                  }
                }
                if (!foundFilter) {
                  Node childNode=new Node(loggerNode,sourceLoggerChild.getName(),sourceLoggerChild.getType());
                  targetNode.getChildren().add(childNode);
                }
              }
 else {
                Node childNode=new Node(loggerNode,sourceLoggerChild.getName(),sourceLoggerChild.getType());
                childNode.getAttributes().putAll(sourceLoggerChild.getAttributes());
                if (childNode.getName().equalsIgnoreCase(""String_Node_Str"")) {
                  for (                  Node targetChild : targetNode.getChildren()) {
                    if (isSameReference(targetChild,childNode)) {
                      targetNode.getChildren().remove(targetChild);
                      break;
                    }
                  }
                }
 else {
                  for (                  Node targetChild : targetNode.getChildren()) {
                    if (isSameName(targetChild,childNode)) {
                      targetNode.getChildren().remove(targetChild);
                      break;
                    }
                  }
                }
                targetNode.getChildren().add(childNode);
              }
            }
          }
 else {
            loggerNode.getAttributes().putAll(node.getAttributes());
            loggerNode.getChildren().addAll(node.getChildren());
            targetChildNode.getChildren().add(loggerNode);
          }
        }
        isMerged=true;
        break;
      }
default :
{
      targetChildNode.getChildren().addAll(sourceChildNode.getChildren());
      isMerged=true;
      break;
    }
}
}
if (!isMerged) {
target.getChildren().add(sourceChildNode);
}
}
}","/** 
 * Merge the source Configuration into the target Configuration.
 * @param target        The target node to merge into.
 * @param source        The source node.
 * @param pluginManager The PluginManager.
 */
@Override public void mergConfigurations(Node target,Node source,PluginManager pluginManager){
  for (  Node sourceChildNode : source.getChildren()) {
    boolean isFilter=isFilterNode(sourceChildNode);
    boolean isMerged=false;
    for (    Node targetChildNode : target.getChildren()) {
      if (isFilter) {
        if (isFilterNode(targetChildNode)) {
          updateFilterNode(target,targetChildNode,sourceChildNode,pluginManager);
          isMerged=true;
          break;
        }
 else {
          continue;
        }
      }
      if (!targetChildNode.getName().equalsIgnoreCase(sourceChildNode.getName())) {
        continue;
      }
switch (targetChildNode.getName().toLowerCase()) {
case PROPERTIES:
case SCRIPTS:
case APPENDERS:
{
          for (          Node node : sourceChildNode.getChildren()) {
            for (            Node targetNode : targetChildNode.getChildren()) {
              if (targetNode.getAttributes().get(NAME).equals(node.getAttributes().get(NAME))) {
                targetChildNode.getChildren().remove(targetNode);
                break;
              }
            }
            targetChildNode.getChildren().add(node);
          }
          isMerged=true;
          break;
        }
case LOGGERS:
{
        Map<String,Node> targetLoggers=new HashMap<>();
        for (        Node node : targetChildNode.getChildren()) {
          targetLoggers.put(node.getName(),node);
        }
        for (        Node node : sourceChildNode.getChildren()) {
          Node targetNode=getLoggerNode(targetChildNode,node.getAttributes().get(NAME));
          Node loggerNode=new Node(targetChildNode,node.getName(),node.getType());
          if (targetNode != null) {
            for (            Node sourceLoggerChild : node.getChildren()) {
              if (isFilterNode(sourceLoggerChild)) {
                boolean foundFilter=false;
                for (                Node targetChild : targetNode.getChildren()) {
                  if (isFilterNode(targetChild)) {
                    updateFilterNode(loggerNode,targetChild,sourceLoggerChild,pluginManager);
                    foundFilter=true;
                    break;
                  }
                }
                if (!foundFilter) {
                  Node childNode=new Node(loggerNode,sourceLoggerChild.getName(),sourceLoggerChild.getType());
                  targetNode.getChildren().add(childNode);
                }
              }
 else {
                Node childNode=new Node(loggerNode,sourceLoggerChild.getName(),sourceLoggerChild.getType());
                childNode.getAttributes().putAll(sourceLoggerChild.getAttributes());
                if (childNode.getName().equalsIgnoreCase(""String_Node_Str"")) {
                  for (                  Node targetChild : targetNode.getChildren()) {
                    if (isSameReference(targetChild,childNode)) {
                      targetNode.getChildren().remove(targetChild);
                      break;
                    }
                  }
                }
 else {
                  for (                  Node targetChild : targetNode.getChildren()) {
                    if (isSameName(targetChild,childNode)) {
                      targetNode.getChildren().remove(targetChild);
                      break;
                    }
                  }
                }
                targetNode.getChildren().add(childNode);
              }
            }
          }
 else {
            loggerNode.getAttributes().putAll(node.getAttributes());
            loggerNode.getChildren().addAll(node.getChildren());
            targetChildNode.getChildren().add(loggerNode);
          }
        }
        isMerged=true;
        break;
      }
default :
{
      targetChildNode.getChildren().addAll(sourceChildNode.getChildren());
      isMerged=true;
      break;
    }
}
}
if (!isMerged) {
if (sourceChildNode.getName().equalsIgnoreCase(""String_Node_Str"")) {
  target.getChildren().add(0,sourceChildNode);
}
 else {
  target.getChildren().add(sourceChildNode);
}
}
}
}"
90492,"@Override public void evaluate() throws Throwable {
  final Configuration oldConfig=rule.getConfiguration();
  final org.apache.logging.log4j.Logger logger=rule.getLogger(""String_Node_Str"");
  final int MONITOR_INTERVAL_SECONDS=5;
  final File file=new File(""String_Node_Str"");
  final long orig=file.lastModified();
  final long newTime=orig + 10000;
  assertTrue(""String_Node_Str"",file.setLastModified(newTime));
  TimeUnit.SECONDS.sleep(MONITOR_INTERVAL_SECONDS + 1);
  for (int i=0; i < 17; ++i) {
    logger.debug(""String_Node_Str"");
  }
  int loopCount=0;
  Configuration newConfig;
  do {
    Thread.sleep(100);
    newConfig=rule.getConfiguration();
    ++loopCount;
  }
 while (newConfig == oldConfig && loopCount <= 5);
  assertNotSame(""String_Node_Str"",newConfig,oldConfig);
}","@Override public void evaluate() throws Throwable {
  CompositeConfiguration config=(CompositeConfiguration)lcr.getConfiguration();
  Map<String,Appender> appendersMap=config.getLogger(""String_Node_Str"").getAppenders();
  assertEquals(""String_Node_Str"" + appendersMap.size(),2,appendersMap.size());
  assertTrue(appendersMap.get(""String_Node_Str"") instanceof ConsoleAppender);
  appendersMap=config.getLogger(""String_Node_Str"").getAppenders();
  assertEquals(""String_Node_Str"" + appendersMap.size(),1,appendersMap.size());
  assertTrue(appendersMap.get(""String_Node_Str"") instanceof FileAppender);
  appendersMap=config.getLogger(""String_Node_Str"").getAppenders();
  assertEquals(""String_Node_Str"" + appendersMap.size(),1,appendersMap.size());
  assertTrue(appendersMap.get(""String_Node_Str"") instanceof FileAppender);
  appendersMap=config.getRootLogger().getAppenders();
  assertEquals(""String_Node_Str"" + appendersMap.size(),2,appendersMap.size());
  assertTrue(appendersMap.get(""String_Node_Str"") instanceof FileAppender);
  assertTrue(appendersMap.get(""String_Node_Str"") instanceof ConsoleAppender);
}"
90493,"private boolean handleInterruptedException(final Log4jLogEvent frozenLogEvent){
  final boolean appendSuccessful=queue.offer(frozenLogEvent);
  if (!appendSuccessful) {
    LOGGER.warn(""String_Node_Str"",getName());
  }
  Thread.currentThread().interrupt();
  return appendSuccessful;
}","private boolean handleInterruptedException(final LogEvent memento){
  final boolean appendSuccessful=queue.offer(memento);
  if (!appendSuccessful) {
    LOGGER.warn(""String_Node_Str"",getName());
  }
  Thread.currentThread().interrupt();
  return appendSuccessful;
}"
90494,"/** 
 * FOR INTERNAL USE ONLY.
 * @param logEvent the event to log
 */
public void logMessageInBackgroundThread(final LogEvent logEvent){
  final boolean success=blocking ? enqueueOrBlockIfQueueFull(logEvent) : enqueueOrDropIfQueueFull(logEvent);
  logToErrorAppenderIfNecessary(success,logEvent);
}","/** 
 * FOR INTERNAL USE ONLY.
 * @param logEvent the event to log
 */
public void logMessageInBackgroundThread(final LogEvent logEvent){
  try {
    queue.put(logEvent);
  }
 catch (  final InterruptedException e) {
    final boolean appendSuccessful=handleInterruptedException(logEvent);
    logToErrorAppenderIfNecessary(appendSuccessful,logEvent);
  }
}"
90495,"/** 
 * Actual writing occurs here.
 * @param logEvent The LogEvent.
 */
@Override public void append(LogEvent logEvent){
  if (!isStarted()) {
    throw new IllegalStateException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (!Constants.FORMAT_MESSAGES_IN_BACKGROUND) {
    logEvent.getMessage().getFormattedMessage();
  }
  final EventRoute route=asyncEventRouter.getRoute(thread.getId(),logEvent.getLevel());
  route.logMessage(this,logEvent);
}","/** 
 * Actual writing occurs here.
 * @param logEvent The LogEvent.
 */
@Override public void append(LogEvent logEvent){
  if (!isStarted()) {
    throw new IllegalStateException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (!Constants.FORMAT_MESSAGES_IN_BACKGROUND) {
    logEvent.getMessage().getFormattedMessage();
  }
  final Log4jLogEvent memento=Log4jLogEvent.createMemento(logEvent,includeLocation);
  if (!queue.offer(memento)) {
    if (blocking) {
      final EventRoute route=asyncEventRouter.getRoute(thread.getId(),memento.getLevel());
      route.logMessage(this,memento);
    }
 else {
      error(""String_Node_Str"" + getName() + ""String_Node_Str"");
      logToErrorAppenderIfNecessary(false,memento);
    }
  }
}"
90496,"private static void runLatencyTest(final int samples,final Logger logger,final Histogram serviceTmHist,final Histogram responseTmHist,final Pacer pacer){
  for (int i=0; i < samples; i++) {
    final long expectedStartTimeNanos=pacer.expectedNextOperationNanoTime();
    pacer.acquire(1);
    final long actualStartTime=System.nanoTime();
    logger.info(LATENCY_MSG);
    final long doneTime=System.nanoTime();
    serviceTmHist.recordValue(doneTime - actualStartTime);
    responseTmHist.recordValue(doneTime - expectedStartTimeNanos);
  }
}","private static void runLatencyTest(final int samples,final Logger logger,final Histogram serviceTmHist,final Histogram responseTmHist,final Pacer pacer){
  pacer.setInitialStartTime(System.nanoTime());
  for (int i=0; i < samples; i++) {
    final long expectedStartTimeNanos=pacer.expectedNextOperationNanoTime();
    pacer.acquire(1);
    final long actualStartTime=System.nanoTime();
    logger.info(LATENCY_MSG);
    final long doneTime=System.nanoTime();
    serviceTmHist.recordValue(doneTime - actualStartTime);
    responseTmHist.recordValue(doneTime - expectedStartTimeNanos);
  }
}"
90497,"private void setMessage(final Message msg){
  if (msg instanceof ReusableMessage) {
    ReusableMessage reusable=(ReusableMessage)msg;
    reusable.formatTo(getMessageTextForWriting());
    parameters=reusable.swapParameters(parameters);
    parameterCount=reusable.getParameterCount();
  }
 else {
    if (!Constants.FORMAT_MESSAGES_IN_BACKGROUND && msg != null) {
      msg.getFormattedMessage();
    }
    this.message=msg;
  }
}","private void setMessage(final Message msg){
  if (msg instanceof ReusableMessage) {
    ReusableMessage reusable=(ReusableMessage)msg;
    reusable.formatTo(getMessageTextForWriting());
    if (parameters != null) {
      parameters=reusable.swapParameters(parameters);
      parameterCount=reusable.getParameterCount();
    }
  }
 else {
    if (!Constants.FORMAT_MESSAGES_IN_BACKGROUND && msg != null) {
      msg.getFormattedMessage();
    }
    this.message=msg;
  }
}"
90498,"public void setMessage(final Message msg){
  if (msg instanceof ReusableMessage) {
    ReusableMessage reusable=(ReusableMessage)msg;
    reusable.formatTo(getMessageTextForWriting());
    parameters=reusable.swapParameters(parameters);
    parameterCount=reusable.getParameterCount();
  }
 else {
    if (!Constants.FORMAT_MESSAGES_IN_BACKGROUND && msg != null) {
      msg.getFormattedMessage();
    }
    this.message=msg;
  }
}","public void setMessage(final Message msg){
  if (msg instanceof ReusableMessage) {
    ReusableMessage reusable=(ReusableMessage)msg;
    reusable.formatTo(getMessageTextForWriting());
    if (parameters != null) {
      parameters=reusable.swapParameters(parameters);
      parameterCount=reusable.getParameterCount();
    }
  }
 else {
    if (!Constants.FORMAT_MESSAGES_IN_BACKGROUND && msg != null) {
      msg.getFormattedMessage();
    }
    this.message=msg;
  }
}"
90499,"@Override public T build(){
  T configuration;
  try {
    if (source == null) {
      source=ConfigurationSource.NULL_SOURCE;
    }
    final Constructor<T> constructor=clazz.getConstructor(ConfigurationSource.class,Component.class);
    configuration=constructor.newInstance(source,root);
    configuration.setMonitorInterval(monitorInterval);
    if (name != null) {
      configuration.setName(name);
    }
    if (level != null) {
      configuration.getStatusConfiguration().withStatus(level);
    }
    if (verbosity != null) {
      configuration.getStatusConfiguration().withVerbosity(verbosity);
    }
    if (packages != null) {
      configuration.setPluginPackages(packages);
    }
    if (shutdownFlag != null) {
      configuration.setShutdownHook(shutdownFlag);
    }
    if (advertiser != null) {
      configuration.createAdvertiser(advertiser,source);
    }
  }
 catch (  final Exception ex) {
    throw new IllegalArgumentException(""String_Node_Str"",ex);
  }
  configuration.getStatusConfiguration().initialize();
  configuration.initialize();
  return configuration;
}","@Override public T build(boolean initialize){
  T configuration;
  try {
    if (source == null) {
      source=ConfigurationSource.NULL_SOURCE;
    }
    final Constructor<T> constructor=clazz.getConstructor(ConfigurationSource.class,Component.class);
    configuration=constructor.newInstance(source,root);
    configuration.setMonitorInterval(monitorInterval);
    configuration.getRootNode().getAttributes().putAll(root.getAttributes());
    if (name != null) {
      configuration.setName(name);
    }
    if (level != null) {
      configuration.getStatusConfiguration().withStatus(level);
    }
    if (verbosity != null) {
      configuration.getStatusConfiguration().withVerbosity(verbosity);
    }
    if (packages != null) {
      configuration.setPluginPackages(packages);
    }
    if (shutdownFlag != null) {
      configuration.setShutdownHook(shutdownFlag);
    }
    if (advertiser != null) {
      configuration.createAdvertiser(advertiser,source);
    }
  }
 catch (  final Exception ex) {
    throw new IllegalArgumentException(""String_Node_Str"",ex);
  }
  configuration.getStatusConfiguration().initialize();
  if (initialize) {
    configuration.initialize();
  }
  return configuration;
}"
90500,"/** 
 * Construct the ComponsiteConfiguration.
 * @param configurations The List of Configurations to merge.
 */
public CompositeConfiguration(List<? extends AbstractConfiguration> configurations){
  super(ConfigurationSource.NULL_SOURCE);
  this.configurations=configurations;
  String mergeStrategyClassName=PropertiesUtil.getProperties().getStringProperty(MERGE_STRATEGY_PROPERTY,DefaultMergeStrategy.class.getName());
  try {
    mergeStrategy=LoaderUtil.newInstanceOf(mergeStrategyClassName);
  }
 catch (  ClassNotFoundException|IllegalAccessException|NoSuchMethodException|InvocationTargetException|InstantiationException ex) {
    mergeStrategy=new DefaultMergeStrategy();
  }
}","/** 
 * Construct the ComponsiteConfiguration.
 * @param configurations The List of Configurations to merge.
 */
public CompositeConfiguration(List<? extends AbstractConfiguration> configurations){
  super(ConfigurationSource.NULL_SOURCE);
  rootNode=configurations.get(0).getRootNode();
  this.configurations=configurations;
  String mergeStrategyClassName=PropertiesUtil.getProperties().getStringProperty(MERGE_STRATEGY_PROPERTY,DefaultMergeStrategy.class.getName());
  try {
    mergeStrategy=LoaderUtil.newInstanceOf(mergeStrategyClassName);
  }
 catch (  ClassNotFoundException|IllegalAccessException|NoSuchMethodException|InvocationTargetException|InstantiationException ex) {
    mergeStrategy=new DefaultMergeStrategy();
  }
  for (  AbstractConfiguration config : configurations) {
    mergeStrategy.mergeRootProperties(rootNode,config);
  }
  final StatusConfiguration statusConfig=new StatusConfiguration().withVerboseClasses(VERBOSE_CLASSES).withStatus(getDefaultStatus());
  for (  final Map.Entry<String,String> entry : rootNode.getAttributes().entrySet()) {
    final String key=entry.getKey();
    final String value=getStrSubstitutor().replace(entry.getValue());
    if (""String_Node_Str"".equalsIgnoreCase(key)) {
      statusConfig.withStatus(value.toUpperCase());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(key)) {
      statusConfig.withDestination(value);
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(key)) {
      isShutdownHookEnabled=!""String_Node_Str"".equalsIgnoreCase(value);
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(key)) {
      statusConfig.withVerbosity(value);
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(key)) {
      pluginPackages.addAll(Arrays.asList(value.split(Patterns.COMMA_SEPARATOR)));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(key)) {
      setName(value);
    }
  }
  statusConfig.initialize();
}"
90501,"@Override public void setup(){
  AbstractConfiguration targetConfiguration=configurations.get(0);
  staffChildConfiguration(targetConfiguration);
  WatchManager watchManager=targetConfiguration.getWatchManager();
  rootNode=targetConfiguration.getRootNode();
  for (  AbstractConfiguration sourceConfiguration : configurations.subList(1,configurations.size())) {
    staffChildConfiguration(sourceConfiguration);
    Node sourceRoot=sourceConfiguration.getRootNode();
    mergeStrategy.mergConfigurations(rootNode,sourceRoot,getPluginManager());
    if (LOGGER.isEnabled(Level.ALL)) {
      StringBuilder sb=new StringBuilder();
      printNodes(""String_Node_Str"",rootNode,sb);
      System.out.println(sb.toString());
    }
    int monitorInterval=sourceConfiguration.getWatchManager().getIntervalSeconds();
    if (monitorInterval > 0) {
      if (monitorInterval < watchManager.getIntervalSeconds()) {
        watchManager.setIntervalSeconds(monitorInterval);
      }
      WatchManager sourceWatchManager=sourceConfiguration.getWatchManager();
      Map<File,FileWatcher> watchers=sourceWatchManager.getWatchers();
      FileWatcher fileWatcher=new ConfiguratonFileWatcher(this,listeners);
      for (      Map.Entry<File,FileWatcher> entry : watchers.entrySet()) {
        if (entry.getValue() instanceof ConfiguratonFileWatcher) {
          watchManager.watchFile(entry.getKey(),fileWatcher);
        }
      }
    }
  }
  final StatusConfiguration statusConfig=new StatusConfiguration().withVerboseClasses(VERBOSE_CLASSES).withStatus(getDefaultStatus());
  for (  final Map.Entry<String,String> entry : rootNode.getAttributes().entrySet()) {
    final String key=entry.getKey();
    final String value=getStrSubstitutor().replace(entry.getValue());
    if (""String_Node_Str"".equalsIgnoreCase(key)) {
      statusConfig.withStatus(value);
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(key)) {
      statusConfig.withDestination(value);
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(key)) {
      isShutdownHookEnabled=!""String_Node_Str"".equalsIgnoreCase(value);
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(key)) {
      statusConfig.withVerbosity(value);
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(key)) {
      pluginPackages.addAll(Arrays.asList(value.split(Patterns.COMMA_SEPARATOR)));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(key)) {
      setName(value);
    }
  }
  statusConfig.initialize();
}","@Override public void setup(){
  AbstractConfiguration targetConfiguration=configurations.get(0);
  staffChildConfiguration(targetConfiguration);
  WatchManager watchManager=getWatchManager();
  WatchManager targetWatchManager=targetConfiguration.getWatchManager();
  FileWatcher fileWatcher=new ConfiguratonFileWatcher(this,listeners);
  if (targetWatchManager.getIntervalSeconds() > 0) {
    watchManager.setIntervalSeconds(targetWatchManager.getIntervalSeconds());
    Map<File,FileWatcher> watchers=targetWatchManager.getWatchers();
    for (    Map.Entry<File,FileWatcher> entry : watchers.entrySet()) {
      if (entry.getValue() instanceof ConfiguratonFileWatcher) {
        watchManager.watchFile(entry.getKey(),fileWatcher);
      }
    }
  }
  for (  AbstractConfiguration sourceConfiguration : configurations.subList(1,configurations.size())) {
    staffChildConfiguration(sourceConfiguration);
    Node sourceRoot=sourceConfiguration.getRootNode();
    mergeStrategy.mergConfigurations(rootNode,sourceRoot,getPluginManager());
    if (LOGGER.isEnabled(Level.ALL)) {
      StringBuilder sb=new StringBuilder();
      printNodes(""String_Node_Str"",rootNode,sb);
      System.out.println(sb.toString());
    }
    int monitorInterval=sourceConfiguration.getWatchManager().getIntervalSeconds();
    if (monitorInterval > 0) {
      int currentInterval=watchManager.getIntervalSeconds();
      if (currentInterval <= 0 || monitorInterval < currentInterval) {
        watchManager.setIntervalSeconds(monitorInterval);
      }
      WatchManager sourceWatchManager=sourceConfiguration.getWatchManager();
      Map<File,FileWatcher> watchers=sourceWatchManager.getWatchers();
      for (      Map.Entry<File,FileWatcher> entry : watchers.entrySet()) {
        if (entry.getValue() instanceof ConfiguratonFileWatcher) {
          watchManager.watchFile(entry.getKey(),fileWatcher);
        }
      }
    }
  }
}"
90502,"@Override public Configuration reconfigure(){
  List<AbstractConfiguration> configs=new ArrayList<>();
  ConfigurationFactory factory=ConfigurationFactory.getInstance();
  for (  AbstractConfiguration config : configurations) {
    ConfigurationSource source=config.getConfigurationSource();
    URI sourceURI=source.getURI();
    Configuration currentConfig;
    if (sourceURI != null) {
      LOGGER.warn(""String_Node_Str"",config.getName());
      currentConfig=factory.getConfiguration(config.getName(),sourceURI);
      if (currentConfig == null) {
        LOGGER.warn(""String_Node_Str"",config.getName());
        currentConfig=config;
      }
    }
 else {
      currentConfig=config;
    }
    configs.add((AbstractConfiguration)currentConfig);
  }
  return new CompositeConfiguration(configs);
}","@Override public Configuration reconfigure(){
  LOGGER.debug(""String_Node_Str"");
  List<AbstractConfiguration> configs=new ArrayList<>();
  ConfigurationFactory factory=ConfigurationFactory.getInstance();
  for (  AbstractConfiguration config : configurations) {
    ConfigurationSource source=config.getConfigurationSource();
    URI sourceURI=source.getURI();
    Configuration currentConfig;
    if (sourceURI != null) {
      LOGGER.warn(""String_Node_Str"",config.getName());
      currentConfig=factory.getConfiguration(config.getName(),sourceURI);
      if (currentConfig == null) {
        LOGGER.warn(""String_Node_Str"",config.getName());
        currentConfig=config;
      }
    }
 else {
      currentConfig=config;
    }
    configs.add((AbstractConfiguration)currentConfig);
  }
  return new CompositeConfiguration(configs);
}"
90503,"/** 
 * Merge the source Configuration into the target Configuration.
 * @param target        The target node to merge into.
 * @param source        The source node.
 * @param pluginManager The PluginManager.
 */
public void mergConfigurations(Node target,Node source,PluginManager pluginManager){
  for (  Map.Entry<String,String> attribute : source.getAttributes().entrySet()) {
    boolean isFound=false;
    for (    Map.Entry<String,String> targetAttribute : target.getAttributes().entrySet()) {
      if (targetAttribute.getKey().equalsIgnoreCase(attribute.getKey())) {
        if (attribute.getKey().equalsIgnoreCase(STATUS)) {
          Level targetLevel=Level.getLevel(targetAttribute.getValue());
          Level sourceLevel=Level.getLevel(attribute.getValue());
          if (targetLevel != null && sourceLevel != null) {
            if (sourceLevel.isLessSpecificThan(targetLevel)) {
              targetAttribute.setValue(attribute.getValue());
            }
          }
        }
 else {
          if (attribute.getKey().equalsIgnoreCase(""String_Node_Str"")) {
            int sourceInterval=Integer.parseInt(attribute.getValue());
            int targetInterval=Integer.parseInt(targetAttribute.getValue());
            if (targetInterval == 0 || sourceInterval < targetInterval) {
              targetAttribute.setValue(attribute.getValue());
            }
          }
 else {
            targetAttribute.setValue(attribute.getValue());
          }
        }
        isFound=true;
      }
    }
    if (!isFound) {
      target.getAttributes().put(attribute.getKey(),attribute.getValue());
    }
  }
  for (  Node sourceChildNode : source.getChildren()) {
    boolean isFilter=isFilterNode(sourceChildNode);
    boolean isMerged=false;
    for (    Node targetChildNode : target.getChildren()) {
      if (isFilter) {
        if (isFilterNode(targetChildNode)) {
          updateFilterNode(target,targetChildNode,sourceChildNode,pluginManager);
          isMerged=true;
          break;
        }
 else {
          continue;
        }
      }
      if (!targetChildNode.getName().equalsIgnoreCase(sourceChildNode.getName())) {
        continue;
      }
switch (targetChildNode.getName().toLowerCase()) {
case PROPERTIES:
case SCRIPTS:
case APPENDERS:
{
          for (          Node node : sourceChildNode.getChildren()) {
            for (            Node targetNode : targetChildNode.getChildren()) {
              if (targetNode.getAttributes().get(NAME).equals(node.getAttributes().get(NAME))) {
                targetChildNode.getChildren().remove(targetNode);
                break;
              }
            }
            targetChildNode.getChildren().add(node);
          }
          isMerged=true;
          break;
        }
case LOGGERS:
{
        Map<String,Node> targetLoggers=new HashMap<>();
        for (        Node node : targetChildNode.getChildren()) {
          targetLoggers.put(node.getName(),node);
        }
        for (        Node node : sourceChildNode.getChildren()) {
          Node targetNode=getLoggerNode(targetChildNode,node.getAttributes().get(NAME));
          Node loggerNode=new Node(targetChildNode,node.getName(),node.getType());
          if (targetNode != null) {
            for (            Node sourceLoggerChild : node.getChildren()) {
              if (isFilterNode(sourceLoggerChild)) {
                boolean foundFilter=false;
                for (                Node targetChild : targetNode.getChildren()) {
                  if (isFilterNode(targetChild)) {
                    updateFilterNode(loggerNode,targetChild,sourceLoggerChild,pluginManager);
                    foundFilter=true;
                    break;
                  }
                }
                if (!foundFilter) {
                  Node childNode=new Node(loggerNode,sourceLoggerChild.getName(),sourceLoggerChild.getType());
                  targetNode.getChildren().add(childNode);
                }
              }
 else {
                Node childNode=new Node(loggerNode,sourceLoggerChild.getName(),sourceLoggerChild.getType());
                childNode.getAttributes().putAll(sourceLoggerChild.getAttributes());
                if (childNode.getName().equalsIgnoreCase(""String_Node_Str"")) {
                  for (                  Node targetChild : targetNode.getChildren()) {
                    if (isSameReference(targetChild,childNode)) {
                      targetNode.getChildren().remove(targetChild);
                      break;
                    }
                  }
                }
 else {
                  for (                  Node targetChild : targetNode.getChildren()) {
                    if (isSameName(targetChild,childNode)) {
                      targetNode.getChildren().remove(targetChild);
                      break;
                    }
                  }
                }
                targetNode.getChildren().add(childNode);
              }
            }
          }
 else {
            loggerNode.getAttributes().putAll(node.getAttributes());
            loggerNode.getChildren().addAll(node.getChildren());
            targetChildNode.getChildren().add(loggerNode);
          }
        }
        isMerged=true;
        break;
      }
default :
{
      targetChildNode.getChildren().addAll(sourceChildNode.getChildren());
      isMerged=true;
      break;
    }
}
}
if (!isMerged) {
target.getChildren().add(sourceChildNode);
}
}
}","/** 
 * Merge the source Configuration into the target Configuration.
 * @param target        The target node to merge into.
 * @param source        The source node.
 * @param pluginManager The PluginManager.
 */
@Override public void mergConfigurations(Node target,Node source,PluginManager pluginManager){
  for (  Node sourceChildNode : source.getChildren()) {
    boolean isFilter=isFilterNode(sourceChildNode);
    boolean isMerged=false;
    for (    Node targetChildNode : target.getChildren()) {
      if (isFilter) {
        if (isFilterNode(targetChildNode)) {
          updateFilterNode(target,targetChildNode,sourceChildNode,pluginManager);
          isMerged=true;
          break;
        }
 else {
          continue;
        }
      }
      if (!targetChildNode.getName().equalsIgnoreCase(sourceChildNode.getName())) {
        continue;
      }
switch (targetChildNode.getName().toLowerCase()) {
case PROPERTIES:
case SCRIPTS:
case APPENDERS:
{
          for (          Node node : sourceChildNode.getChildren()) {
            for (            Node targetNode : targetChildNode.getChildren()) {
              if (targetNode.getAttributes().get(NAME).equals(node.getAttributes().get(NAME))) {
                targetChildNode.getChildren().remove(targetNode);
                break;
              }
            }
            targetChildNode.getChildren().add(node);
          }
          isMerged=true;
          break;
        }
case LOGGERS:
{
        Map<String,Node> targetLoggers=new HashMap<>();
        for (        Node node : targetChildNode.getChildren()) {
          targetLoggers.put(node.getName(),node);
        }
        for (        Node node : sourceChildNode.getChildren()) {
          Node targetNode=getLoggerNode(targetChildNode,node.getAttributes().get(NAME));
          Node loggerNode=new Node(targetChildNode,node.getName(),node.getType());
          if (targetNode != null) {
            for (            Node sourceLoggerChild : node.getChildren()) {
              if (isFilterNode(sourceLoggerChild)) {
                boolean foundFilter=false;
                for (                Node targetChild : targetNode.getChildren()) {
                  if (isFilterNode(targetChild)) {
                    updateFilterNode(loggerNode,targetChild,sourceLoggerChild,pluginManager);
                    foundFilter=true;
                    break;
                  }
                }
                if (!foundFilter) {
                  Node childNode=new Node(loggerNode,sourceLoggerChild.getName(),sourceLoggerChild.getType());
                  targetNode.getChildren().add(childNode);
                }
              }
 else {
                Node childNode=new Node(loggerNode,sourceLoggerChild.getName(),sourceLoggerChild.getType());
                childNode.getAttributes().putAll(sourceLoggerChild.getAttributes());
                if (childNode.getName().equalsIgnoreCase(""String_Node_Str"")) {
                  for (                  Node targetChild : targetNode.getChildren()) {
                    if (isSameReference(targetChild,childNode)) {
                      targetNode.getChildren().remove(targetChild);
                      break;
                    }
                  }
                }
 else {
                  for (                  Node targetChild : targetNode.getChildren()) {
                    if (isSameName(targetChild,childNode)) {
                      targetNode.getChildren().remove(targetChild);
                      break;
                    }
                  }
                }
                targetNode.getChildren().add(childNode);
              }
            }
          }
 else {
            loggerNode.getAttributes().putAll(node.getAttributes());
            loggerNode.getChildren().addAll(node.getChildren());
            targetChildNode.getChildren().add(loggerNode);
          }
        }
        isMerged=true;
        break;
      }
default :
{
      targetChildNode.getChildren().addAll(sourceChildNode.getChildren());
      isMerged=true;
      break;
    }
}
}
if (!isMerged) {
target.getChildren().add(sourceChildNode);
}
}
}"
90504,"@Override public Configuration reconfigure(){
  try {
    final ConfigurationSource source=getConfigurationSource().resetInputStream();
    if (source == null) {
      return null;
    }
    final PropertiesConfigurationFactory factory=new PropertiesConfigurationFactory();
    final PropertiesConfiguration config=factory.getConfiguration(source);
    return config == null || config.getState() != State.INITIALIZED ? null : config;
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"",getConfigurationSource(),ex);
  }
  return null;
}","@Override public Configuration reconfigure(){
  try {
    final ConfigurationSource source=getConfigurationSource().resetInputStream();
    if (source == null) {
      return null;
    }
    final PropertiesConfigurationFactory factory=new PropertiesConfigurationFactory();
    final PropertiesConfiguration config=factory.getConfiguration(source);
    return config == null || config.getState() != State.INITIALIZING ? null : config;
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"",getConfigurationSource(),ex);
  }
  return null;
}"
90505,"@Override public PropertiesConfiguration build(){
  builder.setStatusLevel(Level.toLevel(rootProperties.getProperty(STATUS_KEY),Level.ERROR)).setShutdownHook(rootProperties.getProperty(SHUTDOWN_HOOK)).setVerbosity(rootProperties.getProperty(VERBOSE)).setPackages(rootProperties.getProperty(PACKAGES)).setConfigurationName(rootProperties.getProperty(CONFIG_NAME)).setMonitorInterval(rootProperties.getProperty(MONITOR_INTERVAL,""String_Node_Str"")).setAdvertiser(rootProperties.getProperty(ADVERTISER_KEY));
  final Properties propertyPlaceholders=PropertiesUtil.extractSubset(rootProperties,""String_Node_Str"");
  for (  final String key : propertyPlaceholders.stringPropertyNames()) {
    builder.addProperty(key,propertyPlaceholders.getProperty(key));
  }
  final Map<String,Properties> scripts=PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties,""String_Node_Str""));
  for (  final Map.Entry<String,Properties> entry : scripts.entrySet()) {
    final Properties scriptProps=entry.getValue();
    final String type=(String)scriptProps.remove(""String_Node_Str"");
    if (type == null) {
      throw new ConfigurationException(""String_Node_Str"");
    }
    if (type.equalsIgnoreCase(""String_Node_Str"")) {
      builder.add(createScript(scriptProps));
    }
 else {
      builder.add(createScriptFile(scriptProps));
    }
  }
  final Properties levelProps=PropertiesUtil.extractSubset(rootProperties,""String_Node_Str"");
  if (levelProps.size() > 0) {
    for (    final String key : levelProps.stringPropertyNames()) {
      builder.add(builder.newCustomLevel(key,Integer.parseInt(levelProps.getProperty(key))));
    }
  }
  final Map<String,Properties> filters=PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties,""String_Node_Str""));
  for (  final Map.Entry<String,Properties> entry : filters.entrySet()) {
    builder.add(createFilter(entry.getKey().trim(),entry.getValue()));
  }
  final Map<String,Properties> appenders=PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties,""String_Node_Str""));
  for (  final Map.Entry<String,Properties> entry : appenders.entrySet()) {
    builder.add(createAppender(entry.getKey().trim(),entry.getValue()));
  }
  final Map<String,Properties> loggers=PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties,""String_Node_Str""));
  for (  final Map.Entry<String,Properties> entry : loggers.entrySet()) {
    final String name=entry.getKey().trim();
    if (!name.equals(LoggerConfig.ROOT)) {
      builder.add(createLogger(name,entry.getValue()));
    }
  }
  final Properties props=PropertiesUtil.extractSubset(rootProperties,""String_Node_Str"");
  if (props.size() > 0) {
    builder.add(createRootLogger(props));
  }
  return builder.build();
}","@Override public PropertiesConfiguration build(){
  Map<String,String> rootProps=new HashMap<>();
  for (  String key : rootProperties.stringPropertyNames()) {
    if (!key.contains(""String_Node_Str"")) {
      builder.addRootProperty(key,rootProperties.getProperty(key));
    }
  }
  builder.setStatusLevel(Level.toLevel(rootProperties.getProperty(STATUS_KEY),Level.ERROR)).setShutdownHook(rootProperties.getProperty(SHUTDOWN_HOOK)).setVerbosity(rootProperties.getProperty(VERBOSE)).setPackages(rootProperties.getProperty(PACKAGES)).setConfigurationName(rootProperties.getProperty(CONFIG_NAME)).setMonitorInterval(rootProperties.getProperty(MONITOR_INTERVAL,""String_Node_Str"")).setAdvertiser(rootProperties.getProperty(ADVERTISER_KEY));
  final Properties propertyPlaceholders=PropertiesUtil.extractSubset(rootProperties,""String_Node_Str"");
  for (  final String key : propertyPlaceholders.stringPropertyNames()) {
    builder.addProperty(key,propertyPlaceholders.getProperty(key));
  }
  final Map<String,Properties> scripts=PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties,""String_Node_Str""));
  for (  final Map.Entry<String,Properties> entry : scripts.entrySet()) {
    final Properties scriptProps=entry.getValue();
    final String type=(String)scriptProps.remove(""String_Node_Str"");
    if (type == null) {
      throw new ConfigurationException(""String_Node_Str"");
    }
    if (type.equalsIgnoreCase(""String_Node_Str"")) {
      builder.add(createScript(scriptProps));
    }
 else {
      builder.add(createScriptFile(scriptProps));
    }
  }
  final Properties levelProps=PropertiesUtil.extractSubset(rootProperties,""String_Node_Str"");
  if (levelProps.size() > 0) {
    for (    final String key : levelProps.stringPropertyNames()) {
      builder.add(builder.newCustomLevel(key,Integer.parseInt(levelProps.getProperty(key))));
    }
  }
  final Map<String,Properties> filters=PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties,""String_Node_Str""));
  for (  final Map.Entry<String,Properties> entry : filters.entrySet()) {
    builder.add(createFilter(entry.getKey().trim(),entry.getValue()));
  }
  final Map<String,Properties> appenders=PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties,""String_Node_Str""));
  for (  final Map.Entry<String,Properties> entry : appenders.entrySet()) {
    builder.add(createAppender(entry.getKey().trim(),entry.getValue()));
  }
  final Map<String,Properties> loggers=PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties,""String_Node_Str""));
  for (  final Map.Entry<String,Properties> entry : loggers.entrySet()) {
    final String name=entry.getKey().trim();
    if (!name.equals(LoggerConfig.ROOT)) {
      builder.add(createLogger(name,entry.getValue()));
    }
  }
  final Properties props=PropertiesUtil.extractSubset(rootProperties,""String_Node_Str"");
  if (props.size() > 0) {
    builder.add(createRootLogger(props));
  }
  return builder.build(false);
}"
90506,"private boolean configureExistingStatusConsoleListener(){
  boolean configured=false;
  for (  final StatusListener statusListener : this.logger.getListeners()) {
    if (statusListener instanceof StatusConsoleListener) {
      final StatusConsoleListener listener=(StatusConsoleListener)statusListener;
      listener.setLevel(this.status);
      if (this.verbosity == Verbosity.QUIET) {
        listener.setFilters(this.verboseClasses);
      }
      configured=true;
    }
  }
  return configured;
}","private boolean configureExistingStatusConsoleListener(){
  boolean configured=false;
  for (  final StatusListener statusListener : this.logger.getListeners()) {
    if (statusListener instanceof StatusConsoleListener) {
      final StatusConsoleListener listener=(StatusConsoleListener)statusListener;
      listener.setLevel(this.status);
      this.logger.updateListenerLevel(this.status);
      if (this.verbosity == Verbosity.QUIET) {
        listener.setFilters(this.verboseClasses);
      }
      configured=true;
    }
  }
  return configured;
}"
90507,"private void setMessage(final Message msg){
  if (msg instanceof ReusableMessage) {
    ReusableMessage reusable=(ReusableMessage)msg;
    reusable.formatTo(getMessageTextForWriting());
    parameters=reusable.swapParameters(parameters);
    parameterCount=reusable.getParameterCount();
  }
 else {
    if (!Constants.FORMAT_MESSAGES_IN_BACKGROUND && msg != null) {
      msg.getFormattedMessage();
    }
    this.message=msg;
  }
}","private void setMessage(final Message msg){
  if (msg instanceof ReusableMessage) {
    ReusableMessage reusable=(ReusableMessage)msg;
    reusable.formatTo(getMessageTextForWriting());
    if (parameters != null) {
      parameters=reusable.swapParameters(parameters);
      parameterCount=reusable.getParameterCount();
    }
  }
 else {
    if (!Constants.FORMAT_MESSAGES_IN_BACKGROUND && msg != null) {
      msg.getFormattedMessage();
    }
    this.message=msg;
  }
}"
90508,"public void setMessage(final Message msg){
  if (msg instanceof ReusableMessage) {
    ReusableMessage reusable=(ReusableMessage)msg;
    reusable.formatTo(getMessageTextForWriting());
    parameters=reusable.swapParameters(parameters);
    parameterCount=reusable.getParameterCount();
  }
 else {
    if (!Constants.FORMAT_MESSAGES_IN_BACKGROUND && msg != null) {
      msg.getFormattedMessage();
    }
    this.message=msg;
  }
}","public void setMessage(final Message msg){
  if (msg instanceof ReusableMessage) {
    ReusableMessage reusable=(ReusableMessage)msg;
    reusable.formatTo(getMessageTextForWriting());
    if (parameters != null) {
      parameters=reusable.swapParameters(parameters);
      parameterCount=reusable.getParameterCount();
    }
  }
 else {
    if (!Constants.FORMAT_MESSAGES_IN_BACKGROUND && msg != null) {
      msg.getFormattedMessage();
    }
    this.message=msg;
  }
}"
90509,"@Override public boolean isEnabled(final Level level,final Marker marker,final String data,final Throwable t){
  return isEnabled(level,marker,new SimpleMessage(data),t);
}","@Override public boolean isEnabled(final Level level,final Marker marker,final String data,final Throwable t){
  return isEnabled(level,marker,(Message)new SimpleMessage(data),t);
}"
90510,"@Test public void testTimestampMessage(){
  final Logger log=context.getLogger(""String_Node_Str"");
  log.info(new TimeMsg(""String_Node_Str"",123456789000L));
  final List<String> msgs=app.getMessages();
  assertNotNull(msgs);
  assertEquals(1,msgs.size());
  final String NL=System.lineSeparator();
  assertEquals(""String_Node_Str"" + NL,msgs.get(0));
}","@Test public void testTimestampMessage(){
  final Logger log=context.getLogger(""String_Node_Str"");
  log.info((Message)new TimeMsg(""String_Node_Str"",123456789000L));
  final List<String> msgs=app.getMessages();
  assertNotNull(msgs);
  assertEquals(1,msgs.size());
  final String NL=System.lineSeparator();
  assertEquals(""String_Node_Str"" + NL,msgs.get(0));
}"
90511,"@Test public void testAsyncLogWritesToLog() throws Exception {
  final File file=new File(""String_Node_Str"",""String_Node_Str"");
  file.delete();
  final Logger log=LogManager.getLogger(""String_Node_Str"");
  assertFalse(PoisonClock.called);
  log.info(new TimeMsg(""String_Node_Str"",123456789000L));
  assertTrue(PoisonClock.called);
  CoreLoggerContexts.stopLoggerContext(false,file);
  final BufferedReader reader=new BufferedReader(new FileReader(file));
  final String line1=reader.readLine();
  reader.close();
  file.delete();
  assertNotNull(line1);
  assertTrue(""String_Node_Str"",line1.equals(""String_Node_Str""));
}","@Test public void testAsyncLogWritesToLog() throws Exception {
  final File file=new File(""String_Node_Str"",""String_Node_Str"");
  file.delete();
  final Logger log=LogManager.getLogger(""String_Node_Str"");
  assertFalse(PoisonClock.called);
  log.info((Message)new TimeMsg(""String_Node_Str"",123456789000L));
  assertTrue(PoisonClock.called);
  CoreLoggerContexts.stopLoggerContext(false,file);
  final BufferedReader reader=new BufferedReader(new FileReader(file));
  final String line1=reader.readLine();
  reader.close();
  file.delete();
  assertNotNull(line1);
  assertTrue(""String_Node_Str"",line1.equals(""String_Node_Str""));
}"
90512,"@BenchmarkMode(Mode.Throughput) @OutputTimeUnit(TimeUnit.SECONDS) @Benchmark public void testDebugMessageDisabledThroughput(final Blackhole bh){
  logger.debug(new SimpleMessage(msg));
}","@BenchmarkMode(Mode.Throughput) @OutputTimeUnit(TimeUnit.SECONDS) @Benchmark public void testDebugMessageDisabledThroughput(final Blackhole bh){
  logger.debug((Message)new SimpleMessage(msg));
}"
90513,"@BenchmarkMode(Mode.SampleTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) @Benchmark public void testDebugDisabledMessageResponseTime(final Blackhole bh){
  logger.debug(new SimpleMessage(msg));
}","@BenchmarkMode(Mode.SampleTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) @Benchmark public void testDebugDisabledMessageResponseTime(final Blackhole bh){
  logger.debug((Message)new SimpleMessage(msg));
}"
90514,"/** 
 * {@inheritDoc}
 */
@Override public void format(final LogEvent event,final StringBuilder toAppendTo){
  ThrowableProxy proxy=null;
  if (event instanceof Log4jLogEvent) {
    proxy=event.getThrownProxy();
  }
  final Throwable throwable=event.getThrown();
  if (throwable != null && options.anyLines()) {
    if (proxy == null) {
      super.format(event,toAppendTo);
      return;
    }
    final String trace=proxy.getCauseStackTraceAsString(options.getPackages());
    final int len=toAppendTo.length();
    if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {
      toAppendTo.append(' ');
    }
    if (!options.allLines() || !Constants.LINE_SEPARATOR.equals(options.getSeparator())) {
      final StringBuilder sb=new StringBuilder();
      final String[] array=trace.split(Constants.LINE_SEPARATOR);
      final int limit=options.minLines(array.length) - 1;
      for (int i=0; i <= limit; ++i) {
        sb.append(array[i]);
        if (i < limit) {
          sb.append(options.getSeparator());
        }
      }
      toAppendTo.append(sb.toString());
    }
 else {
      toAppendTo.append(trace);
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void format(final LogEvent event,final StringBuilder toAppendTo){
  ThrowableProxy proxy=event.getThrownProxy();
  final Throwable throwable=event.getThrown();
  if (throwable != null && options.anyLines()) {
    if (proxy == null) {
      super.format(event,toAppendTo);
      return;
    }
    final String trace=proxy.getCauseStackTraceAsString(options.getPackages());
    final int len=toAppendTo.length();
    if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {
      toAppendTo.append(' ');
    }
    if (!options.allLines() || !Constants.LINE_SEPARATOR.equals(options.getSeparator())) {
      final StringBuilder sb=new StringBuilder();
      final String[] array=trace.split(Constants.LINE_SEPARATOR);
      final int limit=options.minLines(array.length) - 1;
      for (int i=0; i <= limit; ++i) {
        sb.append(array[i]);
        if (i < limit) {
          sb.append(options.getSeparator());
        }
      }
      toAppendTo.append(sb.toString());
    }
 else {
      toAppendTo.append(trace);
    }
  }
}"
90515,"public void clear(){
  loggerFqcn=null;
  marker=null;
  level=null;
  loggerName=null;
  message=null;
  thrown=null;
  thrownProxy=null;
  source=null;
  contextMap=null;
  contextStack=null;
  threadName=null;
}","public void clear(){
  loggerFqcn=null;
  marker=null;
  level=null;
  loggerName=null;
  message=null;
  thrown=null;
  thrownProxy=null;
  source=null;
  contextMap=null;
  contextStack=null;
}"
90516,"/** 
 * {@inheritDoc}
 */
@Override public void format(final LogEvent event,final StringBuilder toAppendTo){
  ThrowableProxy proxy=null;
  if (event instanceof Log4jLogEvent) {
    proxy=event.getThrownProxy();
  }
  final Throwable throwable=event.getThrown();
  if ((throwable != null || proxy != null) && options.anyLines()) {
    if (proxy == null) {
      super.format(event,toAppendTo);
      return;
    }
    final String extStackTrace=proxy.getExtendedStackTraceAsString(options.getPackages());
    final int len=toAppendTo.length();
    if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {
      toAppendTo.append(' ');
    }
    if (!options.allLines() || !Constants.LINE_SEPARATOR.equals(options.getSeparator())) {
      final StringBuilder sb=new StringBuilder();
      final String[] array=extStackTrace.split(Constants.LINE_SEPARATOR);
      final int limit=options.minLines(array.length) - 1;
      for (int i=0; i <= limit; ++i) {
        sb.append(array[i]);
        if (i < limit) {
          sb.append(options.getSeparator());
        }
      }
      toAppendTo.append(sb.toString());
    }
 else {
      toAppendTo.append(extStackTrace);
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void format(final LogEvent event,final StringBuilder toAppendTo){
  ThrowableProxy proxy=event.getThrownProxy();
  final Throwable throwable=event.getThrown();
  if ((throwable != null || proxy != null) && options.anyLines()) {
    if (proxy == null) {
      super.format(event,toAppendTo);
      return;
    }
    final String extStackTrace=proxy.getExtendedStackTraceAsString(options.getPackages());
    final int len=toAppendTo.length();
    if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {
      toAppendTo.append(' ');
    }
    if (!options.allLines() || !Constants.LINE_SEPARATOR.equals(options.getSeparator())) {
      final StringBuilder sb=new StringBuilder();
      final String[] array=extStackTrace.split(Constants.LINE_SEPARATOR);
      final int limit=options.minLines(array.length) - 1;
      for (int i=0; i <= limit; ++i) {
        sb.append(array[i]);
        if (i < limit) {
          sb.append(options.getSeparator());
        }
      }
      toAppendTo.append(sb.toString());
    }
 else {
      toAppendTo.append(extStackTrace);
    }
  }
}"
90517,"/** 
 * Some output streams synchronize writes while others do not. Synchronizing here insures that log events won't be intertwined.
 * @param bytes The serialized Log event.
 * @param offset The offset into the byte array.
 * @param length The number of bytes to write.
 * @param immediateFlush flushes immediately after writing.
 * @throws AppenderLoggingException if an error occurs.
 */
protected synchronized void write(final byte[] bytes,final int offset,final int length,boolean immediateFlush){
  if (immediateFlush && byteBuffer.position() == 0) {
    writeToDestination(bytes,offset,length);
    return;
  }
  if (length >= byteBuffer.capacity()) {
    flush();
    writeToDestination(bytes,offset,length);
  }
 else {
    if (length > byteBuffer.remaining()) {
      flush();
    }
    byteBuffer.put(bytes,offset,length);
  }
  if (immediateFlush) {
    flush();
  }
}","/** 
 * Some output streams synchronize writes while others do not. Synchronizing here insures that log events won't be intertwined.
 * @param bytes The serialized Log event.
 * @param offset The offset into the byte array.
 * @param length The number of bytes to write.
 * @param immediateFlush flushes immediately after writing.
 * @throws AppenderLoggingException if an error occurs.
 */
protected synchronized void write(final byte[] bytes,final int offset,final int length,boolean immediateFlush){
  if (immediateFlush && byteBuffer.position() == 0) {
    writeToDestination(bytes,offset,length);
    flushDestination();
    return;
  }
  if (length >= byteBuffer.capacity()) {
    flush();
    writeToDestination(bytes,offset,length);
  }
 else {
    if (length > byteBuffer.remaining()) {
      flush();
    }
    byteBuffer.put(bytes,offset,length);
  }
  if (immediateFlush) {
    flush();
  }
}"
90518,"/** 
 * Creates a LogEventProxy that can be serialized.
 * @return a LogEventProxy.
 */
protected Object writeReplace(){
  getThrownProxy();
  return new Log4jLogEvent.LogEventProxy(this,this.includeLocation);
}","/** 
 * Creates a LogEventProxy that can be serialized.
 * @return a LogEventProxy.
 */
protected Object writeReplace(){
  return new Log4jLogEvent.LogEventProxy(this,this.includeLocation);
}"
90519,"@Test public void testAppendDoesNotOverwriteExistingFile() throws IOException {
  final boolean isAppend=true;
  final File file=folder.newFile();
  assertEquals(0,file.length());
  final byte[] bytes=new byte[4 * 1024];
  try (FileOutputStream fos=new FileOutputStream(file)){
    fos.write(bytes,0,bytes.length);
    fos.flush();
  }
   assertEquals(""String_Node_Str"",bytes.length,file.length());
  final RandomAccessFileManager manager=RandomAccessFileManager.getFileManager(file.getAbsolutePath(),isAppend,true,RandomAccessFileManager.DEFAULT_BUFFER_SIZE,null,null);
  manager.write(bytes,0,bytes.length,false);
  final int expected=bytes.length * 2;
  assertEquals(""String_Node_Str"",expected,file.length());
}","@Test public void testAppendDoesNotOverwriteExistingFile() throws IOException {
  final boolean isAppend=true;
  final File file=folder.newFile();
  assertEquals(0,file.length());
  final byte[] bytes=new byte[4 * 1024];
  try (FileOutputStream fos=new FileOutputStream(file)){
    fos.write(bytes,0,bytes.length);
    fos.flush();
  }
   assertEquals(""String_Node_Str"",bytes.length,file.length());
  final RandomAccessFileManager manager=RandomAccessFileManager.getFileManager(file.getAbsolutePath(),isAppend,true,RandomAccessFileManager.DEFAULT_BUFFER_SIZE,null,null);
  manager.write(bytes,0,bytes.length,true);
  final int expected=bytes.length * 2;
  assertEquals(""String_Node_Str"",expected,file.length());
}"
90520,"/** 
 * Test method for  {@link org.apache.logging.log4j.core.appender.RandomAccessFileManager#write(byte[],int,int)}.
 */
@Test public void testWrite_dataExceedingBufferSize() throws IOException {
  final File file=folder.newFile();
  try (final RandomAccessFile raf=new RandomAccessFile(file,""String_Node_Str"")){
    final OutputStream os=NullOutputStream.NULL_OUTPUT_STREAM;
    final RandomAccessFileManager manager=new RandomAccessFileManager(raf,file.getName(),os,false,RandomAccessFileManager.DEFAULT_BUFFER_SIZE,null,null,true);
    manager.setByteBufferDestination(manager.createByteBufferDestination(false));
    final int size=RandomAccessFileManager.DEFAULT_BUFFER_SIZE * 3 + 1;
    final byte[] data=new byte[size];
    manager.write(data);
    assertEquals(RandomAccessFileManager.DEFAULT_BUFFER_SIZE * 3 + 1,raf.length());
    manager.flush();
    assertEquals(size,raf.length());
  }
 }","/** 
 * Test method for  {@link org.apache.logging.log4j.core.appender.RandomAccessFileManager#write(byte[],int,int)}.
 */
@Test public void testWrite_dataExceedingBufferSize() throws IOException {
  final File file=folder.newFile();
  try (final RandomAccessFile raf=new RandomAccessFile(file,""String_Node_Str"")){
    final OutputStream os=NullOutputStream.NULL_OUTPUT_STREAM;
    final RandomAccessFileManager manager=new RandomAccessFileManager(raf,file.getName(),os,RandomAccessFileManager.DEFAULT_BUFFER_SIZE,null,null,true);
    final int size=RandomAccessFileManager.DEFAULT_BUFFER_SIZE * 3 + 1;
    final byte[] data=new byte[size];
    manager.write(data);
    assertEquals(RandomAccessFileManager.DEFAULT_BUFFER_SIZE * 3 + 1,raf.length());
    manager.flush();
    assertEquals(size,raf.length());
  }
 }"
90521,"/** 
 * Test method for  {@link org.apache.logging.log4j.core.appender.RandomAccessFileManager#write(byte[],int,int)}.
 */
@Test public void testWrite_multiplesOfBufferSize() throws IOException {
  final File file=folder.newFile();
  try (final RandomAccessFile raf=new RandomAccessFile(file,""String_Node_Str"")){
    final OutputStream os=NullOutputStream.NULL_OUTPUT_STREAM;
    final RandomAccessFileManager manager=new RandomAccessFileManager(raf,file.getName(),os,false,RandomAccessFileManager.DEFAULT_BUFFER_SIZE,null,null,true);
    manager.setByteBufferDestination(manager.createByteBufferDestination(false));
    final int size=RandomAccessFileManager.DEFAULT_BUFFER_SIZE * 3;
    final byte[] data=new byte[size];
    manager.write(data);
    assertEquals(RandomAccessFileManager.DEFAULT_BUFFER_SIZE * 3,raf.length());
  }
 }","/** 
 * Test method for  {@link org.apache.logging.log4j.core.appender.RandomAccessFileManager#write(byte[],int,int)}.
 */
@Test public void testWrite_multiplesOfBufferSize() throws IOException {
  final File file=folder.newFile();
  try (final RandomAccessFile raf=new RandomAccessFile(file,""String_Node_Str"")){
    final OutputStream os=NullOutputStream.NULL_OUTPUT_STREAM;
    final RandomAccessFileManager manager=new RandomAccessFileManager(raf,file.getName(),os,RandomAccessFileManager.DEFAULT_BUFFER_SIZE,null,null,true);
    final int size=RandomAccessFileManager.DEFAULT_BUFFER_SIZE * 3;
    final byte[] data=new byte[size];
    manager.write(data);
    assertEquals(RandomAccessFileManager.DEFAULT_BUFFER_SIZE * 3,raf.length());
  }
 }"
90522,"@Test public void testWrite_dataExceedingMinBufferSize() throws IOException {
  final File file=folder.newFile();
  try (final RandomAccessFile raf=new RandomAccessFile(file,""String_Node_Str"")){
    final OutputStream os=NullOutputStream.NULL_OUTPUT_STREAM;
    final int bufferSize=1;
    final RandomAccessFileManager manager=new RandomAccessFileManager(raf,file.getName(),os,false,bufferSize,null,null,true);
    manager.setByteBufferDestination(manager.createByteBufferDestination(false));
    final int size=bufferSize * 3 + 1;
    final byte[] data=new byte[size];
    manager.write(data);
    assertEquals(bufferSize * 3 + 1,raf.length());
    manager.flush();
    assertEquals(size,raf.length());
  }
 }","@Test public void testWrite_dataExceedingMinBufferSize() throws IOException {
  final File file=folder.newFile();
  try (final RandomAccessFile raf=new RandomAccessFile(file,""String_Node_Str"")){
    final OutputStream os=NullOutputStream.NULL_OUTPUT_STREAM;
    final int bufferSize=1;
    final RandomAccessFileManager manager=new RandomAccessFileManager(raf,file.getName(),os,bufferSize,null,null,true);
    final int size=bufferSize * 3 + 1;
    final byte[] data=new byte[size];
    manager.write(data);
    assertEquals(bufferSize * 3 + 1,raf.length());
    manager.flush();
    assertEquals(size,raf.length());
  }
 }"
90523,"@Test public void testConfigurableBufferSize() throws IOException {
  final File file=folder.newFile();
  try (final RandomAccessFile raf=new RandomAccessFile(file,""String_Node_Str"")){
    final OutputStream os=NullOutputStream.NULL_OUTPUT_STREAM;
    final int bufferSize=4 * 1024;
    assertNotEquals(bufferSize,RandomAccessFileManager.DEFAULT_BUFFER_SIZE);
    final RandomAccessFileManager manager=new RandomAccessFileManager(raf,file.getName(),os,false,bufferSize,null,null,true);
    assertEquals(bufferSize,manager.getBufferSize());
  }
 }","@Test public void testConfigurableBufferSize() throws IOException {
  final File file=folder.newFile();
  try (final RandomAccessFile raf=new RandomAccessFile(file,""String_Node_Str"")){
    final OutputStream os=NullOutputStream.NULL_OUTPUT_STREAM;
    final int bufferSize=4 * 1024;
    assertNotEquals(bufferSize,RandomAccessFileManager.DEFAULT_BUFFER_SIZE);
    final RandomAccessFileManager manager=new RandomAccessFileManager(raf,file.getName(),os,bufferSize,null,null,true);
    assertEquals(bufferSize,manager.getBufferSize());
  }
 }"
90524,"@Test public void testNoAllocationDuringSteadyStateLogging() throws Throwable {
  final String javaHome=System.getProperty(""String_Node_Str"");
  final String javaBin=javaHome + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  final String classpath=System.getProperty(""String_Node_Str"");
  final String javaagent=""String_Node_Str"" + agentJar();
  final File tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  tempFile.deleteOnExit();
  final ProcessBuilder builder=new ProcessBuilder(javaBin,javaagent,""String_Node_Str"",classpath,GcFreeLoggingTest.class.getName());
  builder.redirectError(ProcessBuilder.Redirect.to(tempFile));
  builder.redirectOutput(ProcessBuilder.Redirect.to(tempFile));
  final Process process=builder.start();
  process.waitFor();
  process.exitValue();
  final String output=new String(Files.readAllBytes(tempFile.toPath()));
  final String NEWLINE=System.getProperty(""String_Node_Str"");
  assertEquals(""String_Node_Str"" + NEWLINE,output);
}","@Test public void testNoAllocationDuringSteadyStateLogging() throws Throwable {
  if (!Constants.ENABLE_THREADLOCALS || !Constants.ENABLE_DIRECT_ENCODERS) {
    return;
  }
  final String javaHome=System.getProperty(""String_Node_Str"");
  final String javaBin=javaHome + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  final String classpath=System.getProperty(""String_Node_Str"");
  final String javaagent=""String_Node_Str"" + agentJar();
  final File tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  tempFile.deleteOnExit();
  final ProcessBuilder builder=new ProcessBuilder(javaBin,javaagent,""String_Node_Str"",classpath,GcFreeLoggingTest.class.getName());
  builder.redirectError(ProcessBuilder.Redirect.to(tempFile));
  builder.redirectOutput(ProcessBuilder.Redirect.to(tempFile));
  final Process process=builder.start();
  process.waitFor();
  process.exitValue();
  final String output=new String(Files.readAllBytes(tempFile.toPath()));
  final String NEWLINE=System.getProperty(""String_Node_Str"");
  assertEquals(""String_Node_Str"" + NEWLINE,output);
}"
90525,"private void init(String messagePattern){
  this.messagePattern=messagePattern;
  this.indices=new int[messagePattern == null ? 0 : messagePattern.length() << 1];
  int usedCount=ParameterFormatter.countArgumentPlaceholders2(messagePattern,indices);
  initThrowable(argArray,usedCount);
  this.usedCount=Math.min(usedCount,(argArray == null) ? 0 : argArray.length);
}","private void init(String messagePattern){
  this.messagePattern=messagePattern;
  this.indices=new int[messagePattern == null ? 0 : messagePattern.length() >> 1];
  int usedCount=ParameterFormatter.countArgumentPlaceholders2(messagePattern,indices);
  initThrowable(argArray,usedCount);
  this.usedCount=Math.min(usedCount,(argArray == null) ? 0 : argArray.length);
}"
90526,"/** 
 * Counts the number of unescaped placeholders in the given messagePattern.
 * @param messagePattern the message pattern to be analyzed.
 * @return the number of unescaped placeholders.
 */
static int countArgumentPlaceholders2(final String messagePattern,final int[] indices){
  if (messagePattern == null) {
    return 0;
  }
  int length=messagePattern.length();
  int result=0;
  boolean isEscaped=false;
  for (int i=0; i < length - 1; i++) {
    final char curChar=messagePattern.charAt(i);
    if (curChar == ESCAPE_CHAR) {
      isEscaped=!isEscaped;
      indices[0]=-1;
    }
 else     if (curChar == DELIM_START) {
      if (!isEscaped && messagePattern.charAt(i + 1) == DELIM_STOP) {
        indices[result]=i;
        result++;
        i++;
      }
      isEscaped=false;
    }
 else {
      isEscaped=false;
    }
  }
  return result;
}","/** 
 * Counts the number of unescaped placeholders in the given messagePattern.
 * @param messagePattern the message pattern to be analyzed.
 * @return the number of unescaped placeholders.
 */
static int countArgumentPlaceholders2(final String messagePattern,final int[] indices){
  if (messagePattern == null) {
    return 0;
  }
  int length=messagePattern.length();
  int result=0;
  boolean isEscaped=false;
  for (int i=0; i < length - 1; i++) {
    final char curChar=messagePattern.charAt(i);
    if (curChar == ESCAPE_CHAR) {
      isEscaped=!isEscaped;
      indices[0]=-1;
      result++;
    }
 else     if (curChar == DELIM_START) {
      if (!isEscaped && messagePattern.charAt(i + 1) == DELIM_STOP) {
        indices[result]=i;
        result++;
        i++;
      }
      isEscaped=false;
    }
 else {
      isEscaped=false;
    }
  }
  return result;
}"
90527,"private void init(final String messagePattern,final int argCount,final Object[] paramArray){
  this.varargs=null;
  this.messagePattern=messagePattern;
  int usedCount=count(messagePattern,indices);
  initThrowable(paramArray,argCount,usedCount);
  this.argCount=Math.min(usedCount,argCount);
}","private void init(final String messagePattern,final int argCount,final Object[] paramArray){
  this.varargs=null;
  this.messagePattern=messagePattern;
  this.argCount=argCount;
  int placeholderCount=count(messagePattern,indices);
  initThrowable(paramArray,argCount,placeholderCount);
  this.usedCount=Math.min(placeholderCount,argCount);
}"
90528,"@Override public void formatTo(final StringBuilder buffer){
  if (indices[0] < 0) {
    ParameterFormatter.formatMessage(buffer,messagePattern,getParams(),argCount);
  }
 else {
    ParameterFormatter.formatMessage2(buffer,messagePattern,getParams(),argCount,indices);
  }
}","@Override public void formatTo(final StringBuilder buffer){
  if (indices[0] < 0) {
    ParameterFormatter.formatMessage(buffer,messagePattern,getParams(),argCount);
  }
 else {
    ParameterFormatter.formatMessage2(buffer,messagePattern,getParams(),usedCount,indices);
  }
}"
90529,"private void logDebugNormalApi(){
  root.debug(""String_Node_Str"",1,2,3);
  root.debug(""String_Node_Str"",2,3);
  root.debug(""String_Node_Str"",5,6);
  root.debug(""String_Node_Str"",7,8,9,10);
}","private void logDebugNormalApi(){
  root.debug(""String_Node_Str"",1,2,3);
  root.debug(""String_Node_Str"",2,3);
  root.debug(null,5,6);
  root.debug(""String_Node_Str"",7,8,9,10);
}"
90530,"private StringBuilder getBuffer(){
  StringBuilder result=buffer.get();
  if (result == null) {
    result=new StringBuilder(Math.min(512,messagePattern.length() * 2));
    buffer.set(result);
  }
  result.setLength(0);
  return result;
}","private StringBuilder getBuffer(){
  StringBuilder result=buffer.get();
  if (result == null) {
    final int currentPatternLength=messagePattern == null ? 0 : messagePattern.length();
    result=new StringBuilder(Math.min(512,currentPatternLength * 2));
    buffer.set(result);
  }
  result.setLength(0);
  return result;
}"
90531,"@Setup(Level.Trial) public void up(){
  new File(""String_Node_Str"").delete();
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  logger=LogManager.getLogger(getClass());
}","@Setup(Level.Trial) public void up(){
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  logger=LogManager.getLogger(getClass());
  new File(""String_Node_Str"").delete();
}"
90532,"private void init(String messagePattern){
  this.messagePattern=messagePattern;
  this.indices=new int[messagePattern == null ? 0 : messagePattern.length() << 1];
  final int usedCount=ParameterFormatter.countArgumentPlaceholders2(messagePattern,indices);
  initThrowable(argArray,usedCount);
}","private void init(String messagePattern){
  this.messagePattern=messagePattern;
  this.indices=new int[messagePattern == null ? 0 : messagePattern.length() << 1];
  int usedCount=ParameterFormatter.countArgumentPlaceholders2(messagePattern,indices);
  initThrowable(argArray,usedCount);
  this.usedCount=Math.min(usedCount,(argArray == null) ? 0 : argArray.length);
}"
90533,"@Override public void formatTo(final StringBuilder buffer){
  if (formattedMessage != null) {
    buffer.append(formattedMessage);
  }
 else {
    if (indices[0] < 0) {
      ParameterFormatter.formatMessage(buffer,messagePattern,argArray,argArray == null ? 0 : argArray.length);
    }
 else {
      ParameterFormatter.formatMessage2(buffer,messagePattern,argArray,argArray == null ? 0 : argArray.length,indices);
    }
  }
}","@Override public void formatTo(final StringBuilder buffer){
  if (formattedMessage != null) {
    buffer.append(formattedMessage);
  }
 else {
    if (indices[0] < 0) {
      ParameterFormatter.formatMessage(buffer,messagePattern,argArray,usedCount);
    }
 else {
      ParameterFormatter.formatMessage2(buffer,messagePattern,argArray,usedCount,indices);
    }
  }
}"
90534,"private void init(final String messagePattern,final int argCount,final Object[] paramArray){
  this.varargs=null;
  this.messagePattern=messagePattern;
  this.argCount=argCount;
  int usedCount=count(messagePattern,indices);
  initThrowable(paramArray,usedCount);
}","private void init(final String messagePattern,final int argCount,final Object[] paramArray){
  this.varargs=null;
  this.messagePattern=messagePattern;
  int usedCount=count(messagePattern,indices);
  initThrowable(paramArray,argCount,usedCount);
  this.argCount=Math.min(usedCount,argCount);
}"
90535,"private void initThrowable(final Object[] params,final int usedParams){
  if (usedParams < argCount && this.throwable == null && params[argCount - 1] instanceof Throwable) {
    this.throwable=(Throwable)params[argCount - 1];
    argCount--;
  }
}","private void initThrowable(final Object[] params,final int argCount,final int usedParams){
  if (usedParams < argCount && this.throwable == null && params[argCount - 1] instanceof Throwable) {
    this.throwable=(Throwable)params[argCount - 1];
  }
}"
90536,"@Test public void testNoArgs(){
  final String testMsg=""String_Node_Str"";
  ReusableParameterizedMessage msg=new ReusableParameterizedMessage();
  msg.set(testMsg,null);
  String result=msg.getFormattedMessage();
  assertEquals(testMsg,result);
  msg.set(testMsg,null,null);
  result=msg.getFormattedMessage();
  assertEquals(""String_Node_Str"",result);
}","@Test public void testNoArgs(){
  final String testMsg=""String_Node_Str"";
  ReusableParameterizedMessage msg=new ReusableParameterizedMessage();
  msg.set(testMsg,(Object[])null);
  String result=msg.getFormattedMessage();
  assertEquals(testMsg,result);
  msg.set(testMsg,null);
  result=msg.getFormattedMessage();
  assertEquals(testMsg,result);
  msg.set(testMsg,null,null);
  result=msg.getFormattedMessage();
  assertEquals(""String_Node_Str"",result);
}"
90537,"/** 
 * Release references held by ring buffer to allow objects to be garbage-collected.
 */
public void clear(){
  setValues(null,null,null,null,null,null,null,null,null,0,null,0,null,0,0);
  trimMessageText();
}","/** 
 * Release references held by ring buffer to allow objects to be garbage-collected.
 */
public void clear(){
  this.asyncLogger=null;
  this.loggerName=null;
  this.marker=null;
  this.fqcn=null;
  this.level=null;
  this.message=null;
  this.thrown=null;
  this.thrownProxy=null;
  this.contextMap=null;
  this.contextStack=null;
  this.location=null;
  trimMessageText();
}"
90538,"/** 
 * Returns the formatted object message.
 * @return the formatted object message.
 */
@Override public String getFormattedMessage(){
  if (objectString == null) {
    objectString=String.valueOf(obj);
  }
  return objectString;
}","/** 
 * Returns the formatted object message.
 * @return the formatted object message.
 */
@Override public String getFormattedMessage(){
  return String.valueOf(obj);
}"
90539,"private void init(String messagePattern,int argCount,Object[] paramArray){
  this.varargs=null;
  this.buffer.setLength(0);
  this.messagePattern=messagePattern;
  this.argCount=argCount;
  int usedCount=ParameterFormatter.countArgumentPlaceholders(messagePattern);
  initThrowable(paramArray,usedCount);
}","private void init(String messagePattern,int argCount,Object[] paramArray){
  this.varargs=null;
  this.messagePattern=messagePattern;
  this.argCount=argCount;
  int usedCount=ParameterFormatter.countArgumentPlaceholders(messagePattern);
  initThrowable(paramArray,usedCount);
}"
90540,"/** 
 * Returns the formatted message.
 * @return the formatted message.
 */
@Override public String getFormattedMessage(){
  formatTo(buffer);
  return buffer.toString();
}","/** 
 * Returns the formatted message.
 * @return the formatted message.
 */
@Override public String getFormattedMessage(){
  final StringBuilder sb=getBuffer();
  formatTo(sb);
  return sb.toString();
}"
90541,"public void encodeText(final CharSequence text,final ByteBufferDestination destination){
  charsetEncoder.reset();
  ByteBuffer byteBuf=destination.getByteBuffer();
  final CharBuffer charBuf=getCachedCharBuffer();
  int start=0;
  int todoChars=text.length();
  boolean endOfInput=true;
  do {
    charBuf.clear();
    int copied=copy(text,start,charBuf);
    start+=copied;
    todoChars-=copied;
    endOfInput=todoChars <= 0;
    charBuf.flip();
    byteBuf=encode(charBuf,endOfInput,destination,byteBuf);
  }
 while (!endOfInput);
}","public void encodeText(final CharBuffer charBuf,final ByteBufferDestination destination){
  charsetEncoder.reset();
  final ByteBuffer byteBuf=destination.getByteBuffer();
  encode(charBuf,true,destination,byteBuf);
}"
90542,"/** 
 * Copies characters from the CharSequence into the CharBuffer, starting at the specified offset and ending when either all characters have been copied or when the CharBuffer is full.
 * @return the number of characters that were copied
 */
static int copy(final CharSequence source,final int offset,final CharBuffer destination){
  final int length=Math.min(source.length() - offset,destination.remaining());
  for (int i=offset; i < offset + length; i++) {
    destination.put(source.charAt(i));
  }
  return length;
}","/** 
 * Copies characters from the StringBuilder into the CharBuffer, starting at the specified offset and ending when either all characters have been copied or when the CharBuffer is full.
 * @return the number of characters that were copied
 */
static int copy(final StringBuilder source,final int offset,final CharBuffer destination){
  final int length=Math.min(source.length() - offset,destination.remaining());
  final char[] array=destination.array();
  final int start=destination.position();
  source.getChars(offset,offset + length,array,start);
  destination.position(start + length);
  return length;
}"
90543,"public void runTestAndPrintResult(final IPerfTestRunner runner,final String name,final int threadCount,final String resultFile) throws Exception {
  final Histogram warmupHist=createHistogram();
  println(""String_Node_Str"");
  final long t1=System.nanoTime();
  final int LINES=50000;
  int iterations=0;
  final long stop=System.nanoTime() + TimeUnit.SECONDS.toNanos(10);
  do {
    runTest(runner,LINES,null,warmupHist,1);
    iterations++;
  }
 while (System.nanoTime() - stop < 0);
  printf(""String_Node_Str"",(System.nanoTime() - t1) / (1000.0 * 1000.0 * 1000.0),iterations);
  println(""String_Node_Str"");
  Thread.sleep(3000);
  Thread.sleep(7000);
  println(""String_Node_Str"");
  runSingleThreadedTest(runner,LINES * iterations,name,resultFile);
  Thread.sleep(1000);
}","public void runTestAndPrintResult(final IPerfTestRunner runner,final String name,final int threadCount,final String resultFile) throws Exception {
  final Histogram warmupHist=createHistogram();
  println(""String_Node_Str"");
  final long t1=System.nanoTime();
  final int LINES=50000;
  int iterations=0;
  final long stop=System.nanoTime() + TimeUnit.SECONDS.toNanos(10);
  do {
    runTest(runner,LINES,null,warmupHist,1);
    iterations++;
  }
 while (System.nanoTime() - stop < 0);
  printf(""String_Node_Str"",(System.nanoTime() - t1) / (1000.0 * 1000.0 * 1000.0),iterations);
  println(""String_Node_Str"");
  Thread.sleep(3000);
  Thread.sleep(7000);
  println(""String_Node_Str"");
  runSingleThreadedTest(runner,LINES,name,resultFile);
  Thread.sleep(1000);
}"
90544,"@Override public void formatTo(final StringBuilder buffer){
  buffer.append(stringBuilder);
  if (stringBuilder.length() > 512) {
    stringBuilder.setLength(512);
    stringBuilder.trimToSize();
  }
}","@Override public void formatTo(final StringBuilder buffer){
  buffer.append(stringBuilder);
  if (stringBuilder.length() > 518) {
    stringBuilder.setLength(518);
    stringBuilder.trimToSize();
  }
}"
90545,"public void setValues(final AsyncLogger anAsyncLogger,final String aLoggerName,final Marker aMarker,final String theFqcn,final Level aLevel,final Message msg,final Throwable aThrowable,final Map<String,String> aMap,final ContextStack aContextStack,final String aThreadName,final StackTraceElement aLocation,final long aCurrentTimeMillis,final long aNanoTime){
  this.asyncLogger=anAsyncLogger;
  this.loggerName=aLoggerName;
  this.marker=aMarker;
  this.fqcn=theFqcn;
  this.level=aLevel;
  if (msg instanceof ReusableMessage && ((ReusableMessage)msg).isReused()) {
    if (messageText == null) {
      messageText=new StringBuilder(128);
    }
    ((ReusableMessage)msg).formatTo(messageText);
  }
 else {
    this.message=msg;
  }
  this.thrown=aThrowable;
  this.thrownProxy=null;
  this.contextMap=aMap;
  this.contextStack=aContextStack;
  this.threadName=aThreadName;
  this.location=aLocation;
  this.currentTimeMillis=aCurrentTimeMillis;
  this.nanoTime=aNanoTime;
}","public void setValues(final AsyncLogger anAsyncLogger,final String aLoggerName,final Marker aMarker,final String theFqcn,final Level aLevel,final Message msg,final Throwable aThrowable,final Map<String,String> aMap,final ContextStack aContextStack,final String aThreadName,final StackTraceElement aLocation,final long aCurrentTimeMillis,final long aNanoTime){
  this.asyncLogger=anAsyncLogger;
  this.loggerName=aLoggerName;
  this.marker=aMarker;
  this.fqcn=theFqcn;
  this.level=aLevel;
  if (msg instanceof ReusableMessage && ((ReusableMessage)msg).isReused()) {
    if (messageText == null) {
      messageText=new StringBuilder(128);
    }
    messageText.setLength(0);
    ((ReusableMessage)msg).formatTo(messageText);
  }
 else {
    this.message=msg;
  }
  this.thrown=aThrowable;
  this.thrownProxy=null;
  this.contextMap=aMap;
  this.contextStack=aContextStack;
  this.threadName=aThreadName;
  this.location=aLocation;
  this.currentTimeMillis=aCurrentTimeMillis;
  this.nanoTime=aNanoTime;
}"
90546,"/** 
 * Counts the number of unescaped placeholders in the given messagePattern.
 * @param messagePattern the message pattern to be analyzed.
 * @return the number of unescaped placeholders.
 * @deprecated This method is no longer used internally and is scheduled to be deleted.
 */
public static int countArgumentPlaceholders(final String messagePattern){
  if (messagePattern == null) {
    return 0;
  }
  final int delim=messagePattern.indexOf(DELIM_START);
  if (delim == -1) {
    return 0;
  }
  int result=0;
  boolean isEscaped=false;
  for (int i=0; i < messagePattern.length(); i++) {
    final char curChar=messagePattern.charAt(i);
    if (curChar == ESCAPE_CHAR) {
      isEscaped=!isEscaped;
    }
 else     if (curChar == DELIM_START) {
      if (!isEscaped && i < messagePattern.length() - 1 && messagePattern.charAt(i + 1) == DELIM_STOP) {
        result++;
        i++;
      }
      isEscaped=false;
    }
 else {
      isEscaped=false;
    }
  }
  return result;
}","/** 
 * Counts the number of unescaped placeholders in the given messagePattern.
 * @param messagePattern the message pattern to be analyzed.
 * @return the number of unescaped placeholders.
 */
public static int countArgumentPlaceholders(final String messagePattern){
  if (messagePattern == null) {
    return 0;
  }
  int length=messagePattern.length();
  int result=0;
  boolean isEscaped=false;
  for (int i=0; i < length - 1; i++) {
    final char curChar=messagePattern.charAt(i);
    if (curChar == ESCAPE_CHAR) {
      isEscaped=!isEscaped;
    }
 else     if (curChar == DELIM_START) {
      if (!isEscaped && messagePattern.charAt(i + 1) == DELIM_STOP) {
        result++;
        i++;
      }
      isEscaped=false;
    }
 else {
      isEscaped=false;
    }
  }
  return result;
}"
90547,"private void initThrowable(final Throwable t){
  if (!isThrowableInitialized && t != null) {
    throwable=t;
  }
  isThrowableInitialized=true;
}","private void initThrowable(final Object[] params,final int usedParams){
  if (usedParams < argCount && this.throwable == null && params[argCount - 1] instanceof Throwable) {
    this.throwable=(Throwable)params[argCount - 1];
    argCount--;
  }
}"
90548,"@Override public void formatTo(final StringBuilder buffer){
  if (isThreadLocalMessageInitialized) {
    final StringBuilder msg=threadLocalStringBuilder.get();
    if (msg != buffer) {
      buffer.append(msg);
    }
    return;
  }
  final Throwable t=formatMessage(buffer,messagePattern,getParameters(),argCount,throwable);
  initThrowable(t);
  clearUnrolledArgs();
}","@Override public void formatTo(final StringBuilder buffer){
  if (isThreadLocalMessageInitialized) {
    final StringBuilder msg=threadLocalStringBuilder.get();
    if (msg != buffer) {
      buffer.append(msg);
    }
    return;
  }
  formatMessage(buffer,messagePattern,getParameters(),argCount);
  clearUnrolledArgs();
}"
90549,"/** 
 * Returns the Throwable that was given as the last argument, if any. It will not survive serialization. The Throwable exists as part of the message primarily so that it can be extracted from the end of the list of parameters and then be added to the LogEvent. As such, the Throwable in the event should not be used once the LogEvent has been constructed.
 * @return the Throwable, if any.
 */
@Override public Throwable getThrowable(){
  if (!isThrowableInitialized) {
    initFormattedMessage();
  }
  return throwable;
}","/** 
 * Returns the Throwable that was given as the last argument, if any. It will not survive serialization. The Throwable exists as part of the message primarily so that it can be extracted from the end of the list of parameters and then be added to the LogEvent. As such, the Throwable in the event should not be used once the LogEvent has been constructed.
 * @return the Throwable, if any.
 */
@Override public Throwable getThrowable(){
  return throwable;
}"
90550,"private void init(String messagePattern,int argCount){
  this.messagePattern=messagePattern;
  this.argCount=argCount;
  this.isThrowableInitialized=false;
  this.isThreadLocalMessageInitialized=false;
}","private void init(String messagePattern,int argCount){
  this.messagePattern=messagePattern;
  this.argCount=argCount;
  this.isThreadLocalMessageInitialized=false;
  int usedCount=countArgumentPlaceholders(messagePattern);
  initThrowable(getParameters(),usedCount);
}"
90551,"/** 
 * Replace placeholders in the given messagePattern with arguments.
 * @param buffer the buffer to write the formatted message into
 * @param messagePattern the message pattern containing placeholders.
 * @param arguments      the arguments to be used to replace placeholders.
 * @param err the Throwable passed to the constructor (or null if none)
 * @return the Throwable that was the last unused argument in the list, or the specified {@code err} Throwable
 */
private static Throwable formatMessage(final StringBuilder buffer,final String messagePattern,final Object[] arguments,final int argCount,final Throwable err){
  if (messagePattern == null || arguments == null || argCount == 0) {
    buffer.append(messagePattern);
    return err;
  }
  int escapeCounter=0;
  int currentArgument=0;
  int i=0;
  int len=messagePattern.length();
  for (; i < len - 1; i++) {
    final char curChar=messagePattern.charAt(i);
    if (curChar == ESCAPE_CHAR) {
      escapeCounter++;
    }
 else {
      if (isDelimPair(curChar,messagePattern,i)) {
        i++;
        writeEscapedEscapeChars(escapeCounter,buffer);
        if (isOdd(escapeCounter)) {
          writeDelimPair(buffer);
        }
 else {
          writeArgOrDelimPair(arguments,argCount,currentArgument,buffer);
          currentArgument++;
        }
      }
 else {
        handleLiteralChar(buffer,escapeCounter,curChar);
      }
      escapeCounter=0;
    }
  }
  handleRemainingCharIfAny(messagePattern,len,buffer,escapeCounter,i);
  return extractThrowable(arguments,argCount,currentArgument,err);
}","/** 
 * Replace placeholders in the given messagePattern with arguments.
 * @param buffer the buffer to write the formatted message into
 * @param messagePattern the message pattern containing placeholders.
 * @param arguments      the arguments to be used to replace placeholders.
 */
private static void formatMessage(final StringBuilder buffer,final String messagePattern,final Object[] arguments,final int argCount){
  if (messagePattern == null || arguments == null || argCount == 0) {
    buffer.append(messagePattern);
    return;
  }
  int escapeCounter=0;
  int currentArgument=0;
  int i=0;
  int len=messagePattern.length();
  for (; i < len - 1; i++) {
    final char curChar=messagePattern.charAt(i);
    if (curChar == ESCAPE_CHAR) {
      escapeCounter++;
    }
 else {
      if (isDelimPair(curChar,messagePattern,i)) {
        i++;
        writeEscapedEscapeChars(escapeCounter,buffer);
        if (isOdd(escapeCounter)) {
          writeDelimPair(buffer);
        }
 else {
          writeArgOrDelimPair(arguments,argCount,currentArgument,buffer);
          currentArgument++;
        }
      }
 else {
        handleLiteralChar(buffer,escapeCounter,curChar);
      }
      escapeCounter=0;
    }
  }
  handleRemainingCharIfAny(messagePattern,len,buffer,escapeCounter,i);
}"
90552,"/** 
 * Replace placeholders in the given messagePattern with arguments.
 * @param messagePattern the message pattern containing placeholders.
 * @param arguments      the arguments to be used to replace placeholders.
 * @return the formatted message.
 */
public static String format(final String messagePattern,final Object[] arguments){
  final StringBuilder result=getThreadLocalStringBuilder();
  final int argCount=arguments == null ? 0 : arguments.length;
  formatMessage(result,messagePattern,arguments,argCount,null);
  return result.toString();
}","/** 
 * Replace placeholders in the given messagePattern with arguments.
 * @param messagePattern the message pattern containing placeholders.
 * @param arguments      the arguments to be used to replace placeholders.
 * @return the formatted message.
 */
public static String format(final String messagePattern,final Object[] arguments){
  final StringBuilder result=getThreadLocalStringBuilder();
  final int argCount=arguments == null ? 0 : arguments.length;
  formatMessage(result,messagePattern,arguments,argCount);
  return result.toString();
}"
90553,"/** 
 * Constructor with a pattern and two parameters.
 * @param messagePattern The message pattern.
 * @param arg0 The first parameter.
 * @param arg1 The second parameter.
 */
public ParameterizedMessage(final String messagePattern,final Object arg0,final Object arg1){
  this.messagePattern=messagePattern;
  Object[] args=unrolledArgs();
  args[0]=arg0;
  args[1]=arg1;
  this.argCount=2;
}","/** 
 * Constructor with a pattern and two parameters.
 * @param messagePattern The message pattern.
 * @param arg0 The first parameter.
 * @param arg1 The second parameter.
 */
public ParameterizedMessage(final String messagePattern,final Object arg0,final Object arg1){
  Object[] args=unrolledArgs();
  args[0]=arg0;
  args[1]=arg1;
  init(messagePattern,2);
}"
90554,"/** 
 * Creates   {@link ReusableParameterizedMessage} instances.
 * @param message The message pattern.
 * @param params The message parameters.
 * @return The Message.
 * @see MessageFactory#newMessage(String,Object)
 */
@Override public Message newMessage(final String message,final Object... params){
  ReusableParameterizedMessage result=threadLocalMessage.get();
  if (result == null) {
    result=new ReusableParameterizedMessage();
    threadLocalMessage.set(result);
  }
 else {
    result.set(message,params);
  }
  return result;
}","/** 
 * Creates   {@link ReusableParameterizedMessage} instances.
 * @param message The message pattern.
 * @param params The message parameters.
 * @return The Message.
 * @see MessageFactory#newMessage(String,Object)
 */
@Override public Message newMessage(final String message,final Object... params){
  ReusableParameterizedMessage result=threadLocalMessage.get();
  if (result == null) {
    result=new ReusableParameterizedMessage();
    threadLocalMessage.set(result);
  }
  result.set(message,params);
  return result;
}"
90555,"@Override public synchronized void flush(){
  buffer.flip();
  try {
    randomAccessFile.write(buffer.array(),0,buffer.limit());
  }
 catch (  final IOException ex) {
    final String msg=""String_Node_Str"" + getName();
    throw new AppenderLoggingException(msg,ex);
  }
  buffer.clear();
}","@Override public synchronized void flush(){
  buffer.flip();
  try {
    randomAccessFile.write(buffer.array(),0,buffer.limit());
    size+=buffer.limit();
  }
 catch (  final IOException ex) {
    final String msg=""String_Node_Str"" + getName();
    throw new AppenderLoggingException(msg,ex);
  }
  buffer.clear();
}"
90556,"@Override protected synchronized void write(final byte[] bytes,int offset,int length,final boolean immediateFlush){
  super.write(bytes,offset,length,immediateFlush);
  int chunk=0;
  do {
    if (length > buffer.remaining()) {
      flush();
    }
    chunk=Math.min(length,buffer.remaining());
    buffer.put(bytes,offset,chunk);
    offset+=chunk;
    length-=chunk;
  }
 while (length > 0);
  if (immediateFlush || isImmediateFlush || isEndOfBatch.get() == Boolean.TRUE) {
    flush();
  }
}","@Override protected synchronized void write(final byte[] bytes,int offset,int length,final boolean immediateFlush){
  int chunk=0;
  do {
    if (length > buffer.remaining()) {
      flush();
    }
    chunk=Math.min(length,buffer.remaining());
    buffer.put(bytes,offset,chunk);
    offset+=chunk;
    length-=chunk;
  }
 while (length > 0);
  if (immediateFlush || isImmediateFlush || isEndOfBatch.get() == Boolean.TRUE) {
    flush();
  }
}"
90557,"private static Class<? extends MessageFactory> createClassForProperty(final String property,final Class<ParameterizedMessageFactory> defaultMessageFactoryClass){
  try {
    final String clsName=System.getProperty(property,defaultMessageFactoryClass.getName());
    return Class.forName(clsName).asSubclass(ParameterizedMessageFactory.class);
  }
 catch (  final Throwable t) {
    return defaultMessageFactoryClass;
  }
}","private static Class<? extends MessageFactory> createClassForProperty(final String property,final Class<ParameterizedMessageFactory> defaultMessageFactoryClass){
  try {
    final String clsName=System.getProperty(property,defaultMessageFactoryClass.getName());
    return Class.forName(clsName).asSubclass(MessageFactory.class);
  }
 catch (  final Throwable t) {
    return defaultMessageFactoryClass;
  }
}"
90558,"@Test public void testRecentFirst() throws Exception {
  SortingVisitor visitor=new SortingVisitor(new PathSortByModificationTime(true));
  Set<FileVisitOption> options=Collections.emptySet();
  Files.walkFileTree(base,options,1,visitor);
  List<PathWithAttributes> found=visitor.getSortedPaths();
  assertNotNull(found);
  assertEquals(""String_Node_Str"",3,found.size());
  assertEquals(""String_Node_Str"" + found,ccc,found.get(0));
  assertEquals(""String_Node_Str"" + found,bbb,found.get(1));
  assertEquals(""String_Node_Str"" + found,aaa,found.get(2));
}","@Test public void testRecentFirst() throws Exception {
  SortingVisitor visitor=new SortingVisitor(new PathSortByModificationTime(true));
  Set<FileVisitOption> options=Collections.emptySet();
  Files.walkFileTree(base,options,1,visitor);
  List<PathWithAttributes> found=visitor.getSortedPaths();
  assertNotNull(found);
  assertEquals(""String_Node_Str"",3,found.size());
  assertEquals(""String_Node_Str"" + found,ccc,found.get(0).getPath());
  assertEquals(""String_Node_Str"" + found,bbb,found.get(1).getPath());
  assertEquals(""String_Node_Str"" + found,aaa,found.get(2).getPath());
}"
90559,"@Test public void testRecentLast() throws Exception {
  SortingVisitor visitor=new SortingVisitor(new PathSortByModificationTime(false));
  Set<FileVisitOption> options=Collections.emptySet();
  Files.walkFileTree(base,options,1,visitor);
  List<PathWithAttributes> found=visitor.getSortedPaths();
  assertNotNull(found);
  assertEquals(""String_Node_Str"",3,found.size());
  assertEquals(""String_Node_Str"" + found,aaa,found.get(0));
  assertEquals(""String_Node_Str"" + found,bbb,found.get(1));
  assertEquals(""String_Node_Str"" + found,ccc,found.get(2));
}","@Test public void testRecentLast() throws Exception {
  SortingVisitor visitor=new SortingVisitor(new PathSortByModificationTime(false));
  Set<FileVisitOption> options=Collections.emptySet();
  Files.walkFileTree(base,options,1,visitor);
  List<PathWithAttributes> found=visitor.getSortedPaths();
  assertNotNull(found);
  assertEquals(""String_Node_Str"",3,found.size());
  assertEquals(""String_Node_Str"" + found,aaa,found.get(0).getPath());
  assertEquals(""String_Node_Str"" + found,bbb,found.get(1).getPath());
  assertEquals(""String_Node_Str"" + found,ccc,found.get(2).getPath());
}"
90560,"private static void copyFile(final File source,final File destination) throws IOException {
  if (!destination.exists()) {
    destination.createNewFile();
  }
  Files.copy(source.toPath(),destination.toPath());
}","private static void copyFile(final File source,final File destination) throws IOException {
  if (!destination.exists()) {
    destination.createNewFile();
  }
  try (FileInputStream srcStream=new FileInputStream(source);FileOutputStream destStream=new FileOutputStream(destination);FileChannel srcChannel=srcStream.getChannel();FileChannel destChannel=destStream.getChannel()){
    destChannel.transferFrom(srcChannel,0,srcChannel.size());
  }
 }"
90561,"/** 
 * Creates an FileRenameAction.
 * @param src              current file name.
 * @param dst              new file name.
 * @param renameEmptyFiles if true, rename file even if empty, otherwise delete empty files.
 */
public FileRenameAction(final File src,final File dst,final boolean renameEmptyFiles){
  source=src;
  destination=dst;
  this.renameEmptyFiles=renameEmptyFiles;
}","/** 
 * Creates an FileRenameAction.
 * @param src current file name.
 * @param dst new file name.
 * @param renameEmptyFiles if true, rename file even if empty, otherwise delete empty files.
 */
public FileRenameAction(final File src,final File dst,final boolean renameEmptyFiles){
  source=src;
  destination=dst;
  this.renameEmptyFiles=renameEmptyFiles;
}"
90562,"/** 
 * Rename file.
 * @param source           current file name.
 * @param destination      new file name.
 * @param renameEmptyFiles if true, rename file even if empty, otherwise delete empty files.
 * @return true if successfully renamed.
 */
public static boolean execute(final File source,final File destination,final boolean renameEmptyFiles){
  if (renameEmptyFiles || source.length() > 0) {
    final File parent=destination.getParentFile();
    if (parent != null && !parent.exists()) {
      parent.mkdirs();
      if (!parent.exists()) {
        LOGGER.error(""String_Node_Str"",parent.getAbsolutePath());
        return false;
      }
    }
    try {
      if (!source.renameTo(destination)) {
        try {
          copyFile(source,destination);
          return source.delete();
        }
 catch (        final IOException iex) {
          LOGGER.error(""String_Node_Str"",source.getAbsolutePath(),destination.getAbsolutePath(),iex.getMessage());
        }
      }
      return true;
    }
 catch (    final Exception ex) {
      try {
        copyFile(source,destination);
        return source.delete();
      }
 catch (      final IOException iex) {
        LOGGER.error(""String_Node_Str"",source.getAbsolutePath(),destination.getAbsolutePath(),iex.getMessage());
      }
    }
  }
 else {
    try {
      source.delete();
    }
 catch (    final Exception ex) {
      LOGGER.error(""String_Node_Str"" + source.getAbsolutePath());
    }
  }
  return false;
}","/** 
 * Rename file.
 * @param source current file name.
 * @param destination new file name.
 * @param renameEmptyFiles if true, rename file even if empty, otherwise delete empty files.
 * @return true if successfully renamed.
 */
public static boolean execute(final File source,final File destination,final boolean renameEmptyFiles){
  if (renameEmptyFiles || source.length() > 0) {
    final File parent=destination.getParentFile();
    if (parent != null && !parent.exists()) {
      parent.mkdirs();
      if (!parent.exists()) {
        LOGGER.error(""String_Node_Str"",parent.getAbsolutePath());
        return false;
      }
    }
    try {
      if (!source.renameTo(destination)) {
        try {
          copyFile(source,destination);
          return source.delete();
        }
 catch (        final IOException iex) {
          LOGGER.error(""String_Node_Str"",source.getAbsolutePath(),destination.getAbsolutePath(),iex.getMessage());
        }
      }
      return true;
    }
 catch (    final Exception ex) {
      try {
        copyFile(source,destination);
        return source.delete();
      }
 catch (      final IOException iex) {
        LOGGER.error(""String_Node_Str"",source.getAbsolutePath(),destination.getAbsolutePath(),iex.getMessage());
      }
    }
  }
 else {
    try {
      source.delete();
    }
 catch (    final Exception ex) {
      LOGGER.error(""String_Node_Str"" + source.getAbsolutePath());
    }
  }
  return false;
}"
90563,"@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  if (!(getName().equals(filePath))) {
    sb.append(""String_Node_Str"").append(getName()).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"").append(filePath);
  if (getLanguage() != null) {
    sb.append(""String_Node_Str"").append(getLanguage());
  }
  sb.append(""String_Node_Str"").append(isWatched);
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  if (!(getName().equals(filePath.toString()))) {
    sb.append(""String_Node_Str"").append(getName()).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"").append(filePath);
  if (getLanguage() != null) {
    sb.append(""String_Node_Str"").append(getLanguage());
  }
  sb.append(""String_Node_Str"").append(isWatched);
  return sb.toString();
}"
90564,"@PluginFactory public static ScriptFile createScript(@PluginAttribute(""String_Node_Str"") String name,@PluginAttribute(""String_Node_Str"") String language,@PluginAttribute(""String_Node_Str"") final String filePathOrUri,@PluginAttribute(""String_Node_Str"") final Boolean isWatched,@PluginAttribute(""String_Node_Str"") final Charset charset){
  if (filePathOrUri == null) {
    logger.error(""String_Node_Str"");
    return null;
  }
  if (name == null) {
    name=filePathOrUri;
  }
  final URI uri=NetUtils.toURI(filePathOrUri);
  final File file=FileUtils.fileFromUri(uri);
  if (language == null && file != null) {
    String fileExtension=FileUtils.getFileExtension(file);
    if (fileExtension != null) {
      ExtensionLanguageMapping mapping=ExtensionLanguageMapping.getByExtension(fileExtension);
      if (mapping != null) {
        language=mapping.getLanguage();
      }
    }
  }
  if (language == null) {
    logger.info(""String_Node_Str"",DEFAULT_LANGUAGE);
    language=DEFAULT_LANGUAGE;
  }
  final Charset actualCharset=charset == null ? Charset.defaultCharset() : charset;
  String scriptText;
  try (final Reader reader=new InputStreamReader(file != null ? new FileInputStream(file) : uri.toURL().openStream(),actualCharset)){
    scriptText=IOUtils.toString(reader);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e.getClass().getSimpleName(),language,filePathOrUri,actualCharset);
    return null;
  }
  Path path=file != null ? Paths.get(file.toURI()) : Paths.get(uri);
  if (path == null) {
    logger.error(""String_Node_Str"",uri.toString());
    return null;
  }
  return new ScriptFile(name,path,language,isWatched == null ? Boolean.FALSE : isWatched,scriptText);
}","@PluginFactory public static ScriptFile createScript(@PluginAttribute(""String_Node_Str"") String name,@PluginAttribute(""String_Node_Str"") String language,@PluginAttribute(""String_Node_Str"") final String filePathOrUri,@PluginAttribute(""String_Node_Str"") final Boolean isWatched,@PluginAttribute(""String_Node_Str"") final Charset charset){
  if (filePathOrUri == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (name == null) {
    name=filePathOrUri;
  }
  final URI uri=NetUtils.toURI(filePathOrUri);
  final File file=FileUtils.fileFromUri(uri);
  if (language == null && file != null) {
    String fileExtension=FileUtils.getFileExtension(file);
    if (fileExtension != null) {
      ExtensionLanguageMapping mapping=ExtensionLanguageMapping.getByExtension(fileExtension);
      if (mapping != null) {
        language=mapping.getLanguage();
      }
    }
  }
  if (language == null) {
    LOGGER.info(""String_Node_Str"",DEFAULT_LANGUAGE);
    language=DEFAULT_LANGUAGE;
  }
  final Charset actualCharset=charset == null ? Charset.defaultCharset() : charset;
  String scriptText;
  try (final Reader reader=new InputStreamReader(file != null ? new FileInputStream(file) : uri.toURL().openStream(),actualCharset)){
    scriptText=IOUtils.toString(reader);
  }
 catch (  IOException e) {
    LOGGER.error(""String_Node_Str"",e.getClass().getSimpleName(),language,filePathOrUri,actualCharset);
    return null;
  }
  Path path=file != null ? Paths.get(file.toURI()) : Paths.get(uri);
  if (path == null) {
    LOGGER.error(""String_Node_Str"",uri.toString());
    return null;
  }
  return new ScriptFile(name,path,language,isWatched == null ? Boolean.FALSE : isWatched,scriptText);
}"
90565,"/** 
 * Tear down the configuration.
 */
@Override public void stop(){
  this.setStopping();
  LOGGER.trace(""String_Node_Str"",this);
  for (  final LoggerConfig loggerConfig : loggerConfigs.values()) {
    loggerConfig.getReliabilityStrategy().beforeStopConfiguration(this);
  }
  final String cls=getClass().getSimpleName();
  LOGGER.trace(""String_Node_Str"",cls,loggerConfigs.size());
  LOGGER.trace(""String_Node_Str"",cls,loggerConfigs.size());
  for (  final LoggerConfig logger : loggerConfigs.values()) {
    logger.stop();
  }
  if (!root.isStopped()) {
    root.stop();
  }
  if (hasAsyncLoggers()) {
    LOGGER.trace(""String_Node_Str"",cls);
    asyncLoggerConfigDisruptor.stop();
  }
  LOGGER.trace(""String_Node_Str"",cls);
  final Appender[] array=appenders.values().toArray(new Appender[appenders.size()]);
  int asyncAppenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i] instanceof AsyncAppender) {
      array[i].stop();
      asyncAppenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",cls,asyncAppenderCount);
  LOGGER.trace(""String_Node_Str"",cls);
  for (  final LoggerConfig loggerConfig : loggerConfigs.values()) {
    loggerConfig.getReliabilityStrategy().beforeStopAppenders();
  }
  LOGGER.trace(""String_Node_Str"",cls);
  int appenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i].isStarted()) {
      array[i].stop();
      appenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",cls,appenderCount);
  LOGGER.trace(""String_Node_Str"",cls,loggerConfigs.size());
  for (  final LoggerConfig loggerConfig : loggerConfigs.values()) {
    loggerConfig.clearAppenders();
  }
  if (watchManager.isStarted()) {
    watchManager.stop();
  }
  configurationScheduler.stop();
  super.stop();
  if (advertiser != null && advertisement != null) {
    advertiser.unadvertise(advertisement);
  }
  LOGGER.debug(""String_Node_Str"",this);
}","/** 
 * Tear down the configuration.
 */
@Override public void stop(){
  this.setStopping();
  LOGGER.trace(""String_Node_Str"",this);
  for (  final LoggerConfig loggerConfig : loggerConfigs.values()) {
    loggerConfig.getReliabilityStrategy().beforeStopConfiguration(this);
  }
  root.getReliabilityStrategy().beforeStopConfiguration(this);
  final String cls=getClass().getSimpleName();
  LOGGER.trace(""String_Node_Str"",cls,loggerConfigs.size() + 1);
  if (!loggerConfigs.isEmpty()) {
    LOGGER.trace(""String_Node_Str"",cls,loggerConfigs.size());
    for (    final LoggerConfig logger : loggerConfigs.values()) {
      logger.stop();
    }
  }
  LOGGER.trace(""String_Node_Str"",cls);
  if (!root.isStopped()) {
    root.stop();
  }
  if (hasAsyncLoggers()) {
    LOGGER.trace(""String_Node_Str"",cls);
    asyncLoggerConfigDisruptor.stop();
  }
  final Appender[] array=appenders.values().toArray(new Appender[appenders.size()]);
  final List<Appender> async=getAsyncAppenders(array);
  if (!async.isEmpty()) {
    LOGGER.trace(""String_Node_Str"",cls,async.size());
    for (    Appender appender : async) {
      appender.stop();
    }
  }
  LOGGER.trace(""String_Node_Str"",cls);
  for (  final LoggerConfig loggerConfig : loggerConfigs.values()) {
    loggerConfig.getReliabilityStrategy().beforeStopAppenders();
  }
  root.getReliabilityStrategy().beforeStopAppenders();
  LOGGER.trace(""String_Node_Str"",cls);
  int appenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i].isStarted()) {
      array[i].stop();
      appenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",cls,appenderCount);
  LOGGER.trace(""String_Node_Str"",cls,loggerConfigs.size() + 1);
  for (  final LoggerConfig loggerConfig : loggerConfigs.values()) {
    loggerConfig.clearAppenders();
  }
  root.clearAppenders();
  if (watchManager.isStarted()) {
    watchManager.stop();
  }
  configurationScheduler.stop();
  super.stop();
  if (advertiser != null && advertisement != null) {
    advertiser.unadvertise(advertisement);
  }
  LOGGER.debug(""String_Node_Str"",this);
}"
90566,"/** 
 * Tear down the configuration.
 */
@Override public void stop(){
  this.setStopping();
  LOGGER.trace(""String_Node_Str"",this);
  for (  final LoggerConfig loggerConfig : loggerConfigs.values()) {
    loggerConfig.getReliabilityStrategy().beforeStopConfiguration(this);
  }
  final String cls=getClass().getSimpleName();
  LOGGER.trace(""String_Node_Str"",cls,loggerConfigs.size());
  LOGGER.trace(""String_Node_Str"",cls,loggerConfigs.size());
  for (  final LoggerConfig logger : loggerConfigs.values()) {
    logger.stop();
  }
  if (!root.isStopped()) {
    root.stop();
  }
  if (hasAsyncLoggers()) {
    LOGGER.trace(""String_Node_Str"",cls);
    asyncLoggerConfigDisruptor.stop();
  }
  LOGGER.trace(""String_Node_Str"",cls);
  final Appender[] array=appenders.values().toArray(new Appender[appenders.size()]);
  int asyncAppenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i] instanceof AsyncAppender) {
      array[i].stop();
      asyncAppenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",cls,asyncAppenderCount);
  LOGGER.trace(""String_Node_Str"",cls);
  for (  final LoggerConfig loggerConfig : loggerConfigs.values()) {
    loggerConfig.getReliabilityStrategy().beforeStopAppenders();
  }
  LOGGER.trace(""String_Node_Str"",cls);
  int appenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i].isStarted()) {
      array[i].stop();
      appenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",cls,appenderCount);
  LOGGER.trace(""String_Node_Str"",cls,loggerConfigs.size());
  for (  final LoggerConfig loggerConfig : loggerConfigs.values()) {
    loggerConfig.clearAppenders();
  }
  if (watchManager.isStarted()) {
    watchManager.stop();
  }
  if (executorService != null) {
    LOGGER.trace(""String_Node_Str"",cls);
    executorService.shutdown();
  }
  super.stop();
  if (advertiser != null && advertisement != null) {
    advertiser.unadvertise(advertisement);
  }
  LOGGER.debug(""String_Node_Str"",this);
}","/** 
 * Tear down the configuration.
 */
@Override public void stop(){
  this.setStopping();
  LOGGER.trace(""String_Node_Str"",this);
  for (  final LoggerConfig loggerConfig : loggerConfigs.values()) {
    loggerConfig.getReliabilityStrategy().beforeStopConfiguration(this);
  }
  root.getReliabilityStrategy().beforeStopConfiguration(this);
  final String cls=getClass().getSimpleName();
  LOGGER.trace(""String_Node_Str"",cls,loggerConfigs.size() + 1);
  if (!loggerConfigs.isEmpty()) {
    LOGGER.trace(""String_Node_Str"",cls,loggerConfigs.size());
    for (    final LoggerConfig logger : loggerConfigs.values()) {
      logger.stop();
    }
  }
  LOGGER.trace(""String_Node_Str"",cls);
  if (!root.isStopped()) {
    root.stop();
  }
  if (hasAsyncLoggers()) {
    LOGGER.trace(""String_Node_Str"",cls);
    asyncLoggerConfigDisruptor.stop();
  }
  final Appender[] array=appenders.values().toArray(new Appender[appenders.size()]);
  final List<Appender> async=getAsyncAppenders(array);
  if (!async.isEmpty()) {
    LOGGER.trace(""String_Node_Str"",cls,async.size());
    for (    Appender appender : async) {
      appender.stop();
    }
  }
  LOGGER.trace(""String_Node_Str"",cls);
  for (  final LoggerConfig loggerConfig : loggerConfigs.values()) {
    loggerConfig.getReliabilityStrategy().beforeStopAppenders();
  }
  root.getReliabilityStrategy().beforeStopAppenders();
  LOGGER.trace(""String_Node_Str"",cls);
  int appenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i].isStarted()) {
      array[i].stop();
      appenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",cls,appenderCount);
  LOGGER.trace(""String_Node_Str"",cls,loggerConfigs.size() + 1);
  for (  final LoggerConfig loggerConfig : loggerConfigs.values()) {
    loggerConfig.clearAppenders();
  }
  root.clearAppenders();
  if (watchManager.isStarted()) {
    watchManager.stop();
  }
  if (executorService != null) {
    LOGGER.trace(""String_Node_Str"",cls);
    executorService.shutdown();
  }
  super.stop();
  if (advertiser != null && advertisement != null) {
    advertiser.unadvertise(advertisement);
  }
  LOGGER.debug(""String_Node_Str"",this);
}"
90567,"private void initializeNonJndi(final String location){
  if (this.name == null) {
    this.name=this.servletContext.getServletContextName();
    LOGGER.debug(""String_Node_Str"",this.name);
  }
  if (this.name == null && location == null) {
    LOGGER.error(""String_Node_Str"");
    return;
  }
  final URI uri=getConfigURI(location);
  this.loggerContext=Configurator.initialize(this.name,this.getClassLoader(),uri,this.servletContext);
}","private void initializeNonJndi(final String location){
  if (this.name == null) {
    this.name=this.servletContext.getServletContextName();
    LOGGER.debug(""String_Node_Str"",this.name);
  }
  if (this.name == null) {
    this.name=this.servletContext.getContextPath();
    LOGGER.debug(""String_Node_Str"",this.name);
  }
  if (this.name == null && location == null) {
    LOGGER.error(""String_Node_Str"");
    return;
  }
  final URI uri=getConfigURI(location);
  this.loggerContext=Configurator.initialize(this.name,this.getClassLoader(),uri,this.servletContext);
}"
90568,"private static Formatter createFormatter(final String[] options){
  Objects.requireNonNull(options);
  if (options.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Objects.requireNonNull(options[0]);
  final String patternOption=options[0];
  if (UNIX_FORMAT.equals(patternOption)) {
    return new UnixFormatter();
  }
  if (UNIX_MILLIS_FORMAT.equals(patternOption)) {
    return new UnixMillisFormatter();
  }
  TimeZone tz=null;
  if (options.length > 1) {
    tz=TimeZone.getTimeZone(options[1]);
  }
  try {
    final FastDateFormat tempFormat=FastDateFormat.getInstance(patternOption,tz);
    return new PatternFormatter(tempFormat);
  }
 catch (  final IllegalArgumentException e) {
    LOGGER.warn(""String_Node_Str"" + patternOption,e);
    return createFormatter(FixedDateFormat.create(FixedFormat.DEFAULT));
  }
}","private static Formatter createFormatter(final String[] options){
  Objects.requireNonNull(options);
  if (options.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Objects.requireNonNull(options[0]);
  final String patternOption=options[0];
  if (UNIX_FORMAT.equals(patternOption)) {
    return new UnixFormatter();
  }
  if (UNIX_MILLIS_FORMAT.equals(patternOption)) {
    return new UnixMillisFormatter();
  }
  final FixedDateFormat.FixedFormat fixedFormat=FixedDateFormat.FixedFormat.lookup(patternOption);
  final String pattern=fixedFormat == null ? patternOption : fixedFormat.getPattern();
  TimeZone tz=null;
  if (options.length > 1 && options[1] != null) {
    tz=TimeZone.getTimeZone(options[1]);
  }
  try {
    final FastDateFormat tempFormat=FastDateFormat.getInstance(pattern,tz);
    return new PatternFormatter(tempFormat);
  }
 catch (  final IllegalArgumentException e) {
    LOGGER.warn(""String_Node_Str"" + pattern,e);
    return createFormatter(FixedDateFormat.create(FixedFormat.DEFAULT));
  }
}"
90569,"/** 
 * Create the RollingFileManager.
 * @param name The name of the entity to manage.
 * @param data The data required to create the entity.
 * @return a RollingFileManager.
 */
@Override public RollingFileManager createManager(final String name,final FactoryData data){
  final File file=new File(name);
  final File parent=file.getParentFile();
  if (null != parent && !parent.exists()) {
    parent.mkdirs();
  }
  try {
    file.createNewFile();
  }
 catch (  final IOException ioe) {
    LOGGER.error(""String_Node_Str"" + name,ioe);
    return null;
  }
  final long size=data.append ? file.length() : 0;
  final boolean writeHeader=!data.append || !file.exists();
  OutputStream os;
  try {
    os=new FileOutputStream(name,data.append);
    int bufferSize=data.bufferSize;
    if (data.bufferedIO) {
      os=new BufferedOutputStream(os,bufferSize);
    }
 else {
      bufferSize=-1;
    }
    final long time=file.lastModified();
    return new RollingFileManager(name,data.pattern,os,data.append,size,time,data.policy,data.strategy,data.advertiseURI,data.layout,bufferSize,writeHeader);
  }
 catch (  final FileNotFoundException ex) {
    LOGGER.error(""String_Node_Str"" + name + ""String_Node_Str""+ ex);
  }
  return null;
}","/** 
 * Create the RollingFileManager.
 * @param name The name of the entity to manage.
 * @param data The data required to create the entity.
 * @return a RollingFileManager.
 */
@Override public RollingFileManager createManager(final String name,final FactoryData data){
  final File file=new File(name);
  final File parent=file.getParentFile();
  if (null != parent && !parent.exists()) {
    parent.mkdirs();
  }
  final boolean writeHeader=!data.append || !file.exists();
  try {
    file.createNewFile();
  }
 catch (  final IOException ioe) {
    LOGGER.error(""String_Node_Str"" + name,ioe);
    return null;
  }
  final long size=data.append ? file.length() : 0;
  OutputStream os;
  try {
    os=new FileOutputStream(name,data.append);
    int bufferSize=data.bufferSize;
    if (data.bufferedIO) {
      os=new BufferedOutputStream(os,bufferSize);
    }
 else {
      bufferSize=-1;
    }
    final long time=file.lastModified();
    return new RollingFileManager(name,data.pattern,os,data.append,size,time,data.policy,data.strategy,data.advertiseURI,data.layout,bufferSize,writeHeader);
  }
 catch (  final FileNotFoundException ex) {
    LOGGER.error(""String_Node_Str"" + name + ""String_Node_Str""+ ex);
  }
  return null;
}"
90570,"/** 
 * Encode the specified string by casting each character to a byte.
 * @param s the string to encode
 * @return the encoded String
 * @see https://issues.apache.org/jira/browse/LOG4J2-1151
 */
private static byte[] encodeSingleByteChars(String s){
  final int length=s.length();
  final byte[] result=new byte[length];
  for (int i=0; i < length; i++) {
    result[i]=(byte)s.charAt(i);
  }
  return result;
}","/** 
 * Encode the specified string by casting each character to a byte.
 * @param s the string to encode
 * @return the encoded String
 * @see https://issues.apache.org/jira/browse/LOG4J2-1151
 */
private static byte[] encodeSingleByteChars(String s){
  final int length=s.length();
  final byte[] result=new byte[length];
  encode(s,0,length,result);
  return result;
}"
90571,"protected AbstractStringLayout(final Charset charset,final byte[] header,final byte[] footer){
  super(header,footer);
  this.charset=charset == null ? StandardCharsets.UTF_8 : charset;
  this.charsetName=this.charset.name();
  isDirectSingleByteMapping=StandardCharsets.ISO_8859_1.equals(charset) || StandardCharsets.US_ASCII.equals(charset);
}","protected AbstractStringLayout(final Charset charset,final byte[] header,final byte[] footer){
  super(header,footer);
  this.charset=charset == null ? StandardCharsets.UTF_8 : charset;
  this.charsetName=this.charset.name();
  useCustomEncoding=isPreJava8() && (StandardCharsets.ISO_8859_1.equals(charset) || StandardCharsets.US_ASCII.equals(charset));
}"
90572,"protected byte[] getBytes(final String s){
  if (isDirectSingleByteMapping) {
    return encodeSingleByteChars(s);
  }
  try {
    return s.getBytes(charsetName);
  }
 catch (  UnsupportedEncodingException e) {
    return s.getBytes(charset);
  }
}","protected byte[] getBytes(final String s){
  if (useCustomEncoding) {
    return encodeSingleByteChars(s);
  }
  try {
    return s.getBytes(charsetName);
  }
 catch (  UnsupportedEncodingException e) {
    return s.getBytes(charset);
  }
}"
90573,"@SuppressWarnings(""String_Node_Str"") private void testUnixTime(final String pattern) throws Exception {
  final PatternLayout layout=PatternLayout.newBuilder().withPattern(pattern + ""String_Node_Str"").withConfiguration(ctx.getConfiguration()).build();
  final LogEvent event1=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final byte[] result1=layout.toByteArray(event1);
  assertEquals(event1.getTimeMillis() + ""String_Node_Str"",new String(result1));
  final LogEvent event2=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final byte[] result2=layout.toByteArray(event2);
  assertEquals(event2.getTimeMillis() + ""String_Node_Str"",new String(result2));
}","private void testUnixTime(final String pattern) throws Exception {
  final PatternLayout layout=PatternLayout.newBuilder().withPattern(pattern + ""String_Node_Str"").withConfiguration(ctx.getConfiguration()).build();
  final LogEvent event1=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final byte[] result1=layout.toByteArray(event1);
  assertEquals(event1.getTimeMillis() + ""String_Node_Str"",new String(result1));
  final LogEvent event2=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final byte[] result2=layout.toByteArray(event2);
  assertEquals(event2.getTimeMillis() + ""String_Node_Str"",new String(result2));
}"
90574,"private static Formatter createFormatter(final String[] options){
  Objects.requireNonNull(options);
  if (options.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Objects.requireNonNull(options[0]);
  final String patternOption=options[0];
  if (UNIX_FORMAT.equals(patternOption)) {
    return new UnixFormatter();
  }
  if (UNIX_MILLIS_FORMAT.equals(patternOption)) {
    return new UnixMillisFormatter();
  }
  TimeZone tz=null;
  if (options.length > 1) {
    tz=TimeZone.getTimeZone(options[1]);
  }
  try {
    final FastDateFormat tempFormat=FastDateFormat.getInstance(patternOption,tz);
    return new PatternFormatter(tempFormat);
  }
 catch (  final IllegalArgumentException e) {
    LOGGER.warn(""String_Node_Str"" + patternOption,e);
    return createFormatter(FixedDateFormat.create(FixedFormat.DEFAULT));
  }
}","private static Formatter createFormatter(final String[] options){
  Objects.requireNonNull(options);
  if (options.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Objects.requireNonNull(options[0]);
  final String patternOption=options[0];
  if (UNIX_FORMAT.equals(patternOption)) {
    return new UnixFormatter();
  }
  if (UNIX_MILLIS_FORMAT.equals(patternOption)) {
    return new UnixMillisFormatter();
  }
  final FixedDateFormat.FixedFormat fixedFormat=FixedDateFormat.FixedFormat.lookup(patternOption);
  final String pattern=fixedFormat == null ? patternOption : fixedFormat.getPattern();
  TimeZone tz=null;
  if (options.length > 1 && options[1] != null) {
    tz=TimeZone.getTimeZone(options[1]);
  }
  try {
    final FastDateFormat tempFormat=FastDateFormat.getInstance(pattern,tz);
    return new PatternFormatter(tempFormat);
  }
 catch (  final IllegalArgumentException e) {
    LOGGER.warn(""String_Node_Str"" + pattern,e);
    return createFormatter(FixedDateFormat.create(FixedFormat.DEFAULT));
  }
}"
90575,"/** 
 * Encode the specified string by casting each character to a byte.
 * @param s the string to encode
 * @return the encoded String
 * @see https://issues.apache.org/jira/browse/LOG4J2-1151
 */
private static byte[] encodeSingleByteChars(String s){
  final int length=s.length();
  final byte[] result=new byte[length];
  for (int i=0; i < length; i++) {
    result[i]=(byte)s.charAt(i);
  }
  return result;
}","/** 
 * Encode the specified string by casting each character to a byte.
 * @param s the string to encode
 * @return the encoded String
 * @see https://issues.apache.org/jira/browse/LOG4J2-1151
 */
private static byte[] encodeSingleByteChars(String s){
  final int length=s.length();
  final byte[] result=new byte[length];
  encode(s,0,length,result);
  return result;
}"
90576,"protected AbstractStringLayout(final Charset charset,final byte[] header,final byte[] footer){
  super(header,footer);
  this.charset=charset == null ? StandardCharsets.UTF_8 : charset;
  this.charsetName=this.charset.name();
  isDirectSingleByteMapping=StandardCharsets.ISO_8859_1.equals(charset) || StandardCharsets.US_ASCII.equals(charset);
}","protected AbstractStringLayout(final Charset charset,final byte[] header,final byte[] footer){
  super(header,footer);
  this.charset=charset == null ? StandardCharsets.UTF_8 : charset;
  this.charsetName=this.charset.name();
  useCustomEncoding=isPreJava8() && (StandardCharsets.ISO_8859_1.equals(charset) || StandardCharsets.US_ASCII.equals(charset));
}"
90577,"protected byte[] getBytes(final String s){
  if (isDirectSingleByteMapping) {
    return encodeSingleByteChars(s);
  }
  try {
    return s.getBytes(charsetName);
  }
 catch (  UnsupportedEncodingException e) {
    return s.getBytes(charset);
  }
}","protected byte[] getBytes(final String s){
  if (useCustomEncoding) {
    return encodeSingleByteChars(s);
  }
  try {
    return s.getBytes(charsetName);
  }
 catch (  UnsupportedEncodingException e) {
    return s.getBytes(charset);
  }
}"
90578,"/** 
 * Create the RollingFileManager.
 * @param name The name of the entity to manage.
 * @param data The data required to create the entity.
 * @return a RollingFileManager.
 */
@Override public RollingFileManager createManager(final String name,final FactoryData data){
  final File file=new File(name);
  final File parent=file.getParentFile();
  if (null != parent && !parent.exists()) {
    parent.mkdirs();
  }
  try {
    file.createNewFile();
  }
 catch (  final IOException ioe) {
    LOGGER.error(""String_Node_Str"" + name,ioe);
    return null;
  }
  final long size=data.append ? file.length() : 0;
  final boolean writeHeader=!data.append || !file.exists();
  OutputStream os;
  try {
    os=new FileOutputStream(name,data.append);
    int bufferSize=data.bufferSize;
    if (data.bufferedIO) {
      os=new BufferedOutputStream(os,bufferSize);
    }
 else {
      bufferSize=-1;
    }
    final long time=file.lastModified();
    return new RollingFileManager(name,data.pattern,os,data.append,size,time,data.policy,data.strategy,data.advertiseURI,data.layout,bufferSize,writeHeader);
  }
 catch (  final FileNotFoundException ex) {
    LOGGER.error(""String_Node_Str"" + name + ""String_Node_Str""+ ex);
  }
  return null;
}","/** 
 * Create the RollingFileManager.
 * @param name The name of the entity to manage.
 * @param data The data required to create the entity.
 * @return a RollingFileManager.
 */
@Override public RollingFileManager createManager(final String name,final FactoryData data){
  final File file=new File(name);
  final File parent=file.getParentFile();
  if (null != parent && !parent.exists()) {
    parent.mkdirs();
  }
  final boolean writeHeader=!data.append || !file.exists();
  try {
    file.createNewFile();
  }
 catch (  final IOException ioe) {
    LOGGER.error(""String_Node_Str"" + name,ioe);
    return null;
  }
  final long size=data.append ? file.length() : 0;
  OutputStream os;
  try {
    os=new FileOutputStream(name,data.append);
    int bufferSize=data.bufferSize;
    if (data.bufferedIO) {
      os=new BufferedOutputStream(os,bufferSize);
    }
 else {
      bufferSize=-1;
    }
    final long time=file.lastModified();
    return new RollingFileManager(name,data.pattern,os,data.append,size,time,data.policy,data.strategy,data.advertiseURI,data.layout,bufferSize,writeHeader);
  }
 catch (  final FileNotFoundException ex) {
    LOGGER.error(""String_Node_Str"" + name + ""String_Node_Str""+ ex);
  }
  return null;
}"
90579,"@Test public void testJavaScriptPatternSelector() throws Exception {
  org.apache.logging.log4j.Logger logger=LogManager.getLogger(""String_Node_Str"");
  org.apache.logging.log4j.Logger logger2=LogManager.getLogger(""String_Node_Str"");
  logger.entry();
  logger.info(""String_Node_Str"");
  logger2.info(""String_Node_Str"");
  logger.exit();
  final ListAppender app=(ListAppender)context.getRequiredAppender(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",app);
  List<String> messages=app.getMessages();
  assertNotNull(""String_Node_Str"",messages);
  assertTrue(""String_Node_Str"" + messages.size(),messages.size() == 4);
  assertEquals(""String_Node_Str"",messages.get(0));
  assertEquals(""String_Node_Str"",messages.get(1));
  assertEquals(""String_Node_Str"",messages.get(2));
  app.clear();
}","@Test public void testJavaScriptPatternSelector() throws Exception {
  org.apache.logging.log4j.Logger logger=LogManager.getLogger(""String_Node_Str"");
  org.apache.logging.log4j.Logger logger2=LogManager.getLogger(""String_Node_Str"");
  logger.entry();
  logger.info(""String_Node_Str"");
  logger2.info(""String_Node_Str"");
  logger.exit();
  final ListAppender app=(ListAppender)context.getRequiredAppender(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",app);
  List<String> messages=app.getMessages();
  assertNotNull(""String_Node_Str"",messages);
  assertTrue(""String_Node_Str"" + messages.size(),messages.size() == 4);
  String expect=""String_Node_Str"" + ""String_Node_Str"";
  assertEquals(expect,messages.get(0));
  expect=""String_Node_Str"" + ""String_Node_Str"";
  assertEquals(expect,messages.get(1));
  assertEquals(""String_Node_Str"",messages.get(2));
  app.clear();
}"
90580,"@Test public void testMarkerPatternSelector() throws Exception {
  org.apache.logging.log4j.Logger logger=LogManager.getLogger(""String_Node_Str"");
  logger.entry();
  logger.info(""String_Node_Str"");
  logger.exit();
  final ListAppender app=(ListAppender)context.getRequiredAppender(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",app);
  List<String> messages=app.getMessages();
  assertNotNull(""String_Node_Str"",messages);
  assertTrue(""String_Node_Str"" + messages.size(),messages.size() == 3);
  assertEquals(""String_Node_Str"",messages.get(0));
  assertEquals(""String_Node_Str"",messages.get(1));
  app.clear();
}","@Test public void testMarkerPatternSelector() throws Exception {
  org.apache.logging.log4j.Logger logger=LogManager.getLogger(""String_Node_Str"");
  logger.entry();
  logger.info(""String_Node_Str"");
  logger.exit();
  final ListAppender app=(ListAppender)context.getRequiredAppender(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",app);
  List<String> messages=app.getMessages();
  assertNotNull(""String_Node_Str"",messages);
  assertTrue(""String_Node_Str"" + messages.size(),messages.size() == 3);
  final String expect=String.format(""String_Node_Str"" + ""String_Node_Str"");
  assertEquals(expect,messages.get(0));
  assertEquals(""String_Node_Str"",messages.get(1));
  app.clear();
}"
90581,"@Test public void testScriptPatternSelector() throws Exception {
  org.apache.logging.log4j.Logger logger=LogManager.getLogger(""String_Node_Str"");
  org.apache.logging.log4j.Logger logger2=LogManager.getLogger(""String_Node_Str"");
  logger.entry();
  logger.info(""String_Node_Str"");
  logger2.info(""String_Node_Str"");
  logger.exit();
  final ListAppender app=(ListAppender)context.getRequiredAppender(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",app);
  List<String> messages=app.getMessages();
  assertNotNull(""String_Node_Str"",messages);
  assertTrue(""String_Node_Str"" + messages.size(),messages.size() == 4);
  assertEquals(""String_Node_Str"",messages.get(0));
  assertEquals(""String_Node_Str"",messages.get(1));
  assertEquals(""String_Node_Str"",messages.get(2));
  app.clear();
}","@Test public void testScriptPatternSelector() throws Exception {
  org.apache.logging.log4j.Logger logger=LogManager.getLogger(""String_Node_Str"");
  org.apache.logging.log4j.Logger logger2=LogManager.getLogger(""String_Node_Str"");
  logger.entry();
  logger.info(""String_Node_Str"");
  logger2.info(""String_Node_Str"");
  logger.exit();
  final ListAppender app=(ListAppender)context.getRequiredAppender(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",app);
  List<String> messages=app.getMessages();
  assertNotNull(""String_Node_Str"",messages);
  assertTrue(""String_Node_Str"" + messages.size(),messages.size() == 4);
  String expect=""String_Node_Str"" + ""String_Node_Str"";
  assertEquals(expect,messages.get(0));
  expect=""String_Node_Str"" + ""String_Node_Str"";
  assertEquals(expect,messages.get(1));
  assertEquals(""String_Node_Str"",messages.get(2));
  app.clear();
}"
90582,"public String formatEvent(LogEvent event,Layout layout){
  return new String(layout.toByteArray(event));
}","public String formatEvent(LogEvent event,Layout<?> layout){
  return new String(layout.toByteArray(event));
}"
90583,"@Test public void testPatternSelector() throws Exception {
  PatternMatch[] patterns=new PatternMatch[1];
  patterns[0]=new PatternMatch(""String_Node_Str"",""String_Node_Str"");
  PatternSelector selector=MarkerPatternSelector.createSelector(patterns,""String_Node_Str"",true,true,ctx.getConfiguration());
  final PatternLayout layout=PatternLayout.newBuilder().withPatternSelector(selector).withConfiguration(ctx.getConfiguration()).build();
  final LogEvent event1=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setMarker(MarkerManager.getMarker(""String_Node_Str"")).setLevel(Level.TRACE).setIncludeLocation(true).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final String result1=new FauxLogger().formatEvent(event1,layout);
  assertTrue(""String_Node_Str"" + result1,result1.endsWith(""String_Node_Str""));
  final LogEvent event2=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final String result2=new String(layout.toByteArray(event2));
  assertTrue(""String_Node_Str"" + result2,result2.endsWith(""String_Node_Str""));
}","@Test public void testPatternSelector() throws Exception {
  PatternMatch[] patterns=new PatternMatch[1];
  patterns[0]=new PatternMatch(""String_Node_Str"",""String_Node_Str"");
  PatternSelector selector=MarkerPatternSelector.createSelector(patterns,""String_Node_Str"",true,true,ctx.getConfiguration());
  final PatternLayout layout=PatternLayout.newBuilder().withPatternSelector(selector).withConfiguration(ctx.getConfiguration()).build();
  final LogEvent event1=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setMarker(MarkerManager.getMarker(""String_Node_Str"")).setLevel(Level.TRACE).setIncludeLocation(true).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final String result1=new FauxLogger().formatEvent(event1,layout);
  final String expectSuffix1=String.format(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + result1,result1.endsWith(expectSuffix1));
  final LogEvent event2=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final String result2=new String(layout.toByteArray(event2));
  final String expectSuffix2=String.format(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + result2,result2.endsWith(expectSuffix2));
}"
90584,"private void testUnixTime(final String pattern) throws Exception {
  final PatternLayout layout=PatternLayout.newBuilder().withPattern(pattern + ""String_Node_Str"").withConfiguration(ctx.getConfiguration()).build();
  final LogEvent event1=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final byte[] result1=layout.toByteArray(event1);
  assertEquals(event1.getTimeMillis() + ""String_Node_Str"",new String(result1));
  final LogEvent event2=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final byte[] result2=layout.toByteArray(event2);
  assertEquals(event2.getTimeMillis() + ""String_Node_Str"",new String(result2));
}","@SuppressWarnings(""String_Node_Str"") private void testUnixTime(final String pattern) throws Exception {
  final PatternLayout layout=PatternLayout.newBuilder().withPattern(pattern + ""String_Node_Str"").withConfiguration(ctx.getConfiguration()).build();
  final LogEvent event1=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final byte[] result1=layout.toByteArray(event1);
  assertEquals(event1.getTimeMillis() + ""String_Node_Str"",new String(result1));
  final LogEvent event2=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final byte[] result2=layout.toByteArray(event2);
  assertEquals(event2.getTimeMillis() + ""String_Node_Str"",new String(result2));
}"
90585,"@Test public void testPatternSelector() throws Exception {
  org.apache.logging.log4j.Logger logger=LogManager.getLogger(""String_Node_Str"");
  logger.entry();
  logger.info(""String_Node_Str"");
  logger.exit();
  final ListAppender app=(ListAppender)context.getRequiredAppender(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",app);
  List<String> messages=app.getMessages();
  assertNotNull(""String_Node_Str"",messages);
  assertTrue(""String_Node_Str"" + messages.size(),messages.size() == 3);
  assertEquals(""String_Node_Str"",messages.get(0));
  assertEquals(""String_Node_Str"",messages.get(1));
}","@Test public void testPatternSelector() throws Exception {
  org.apache.logging.log4j.Logger logger=LogManager.getLogger(""String_Node_Str"");
  logger.entry();
  logger.info(""String_Node_Str"");
  logger.exit();
  final ListAppender app=(ListAppender)context.getRequiredAppender(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",app);
  List<String> messages=app.getMessages();
  assertNotNull(""String_Node_Str"",messages);
  assertTrue(""String_Node_Str"" + messages.size(),messages.size() == 3);
  final String expect=String.format(""String_Node_Str"" + ""String_Node_Str"");
  assertEquals(expect,messages.get(0));
  assertEquals(String.format(""String_Node_Str""),messages.get(1));
}"
90586,"public String formatEvent(LogEvent event,Layout layout){
  return new String(layout.toByteArray(event));
}","public String formatEvent(LogEvent event,Layout<?> layout){
  return new String(layout.toByteArray(event));
}"
90587,"@Test public void testPatternSelector() throws Exception {
  PatternMatch[] patterns=new PatternMatch[1];
  patterns[0]=new PatternMatch(""String_Node_Str"",""String_Node_Str"");
  PatternSelector selector=MarkerPatternSelector.createSelector(patterns,""String_Node_Str"",true,true,ctx.getConfiguration());
  final PatternLayout layout=PatternLayout.newBuilder().withPatternSelector(selector).withConfiguration(ctx.getConfiguration()).build();
  final LogEvent event1=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setMarker(MarkerManager.getMarker(""String_Node_Str"")).setLevel(Level.TRACE).setIncludeLocation(true).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final String result1=new FauxLogger().formatEvent(event1,layout);
  assertTrue(""String_Node_Str"" + result1,result1.endsWith(""String_Node_Str""));
  final LogEvent event2=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final String result2=new String(layout.toByteArray(event2));
  assertTrue(""String_Node_Str"" + result2,result2.endsWith(""String_Node_Str""));
}","@Test public void testPatternSelector() throws Exception {
  PatternMatch[] patterns=new PatternMatch[1];
  patterns[0]=new PatternMatch(""String_Node_Str"",""String_Node_Str"");
  PatternSelector selector=MarkerPatternSelector.createSelector(patterns,""String_Node_Str"",true,true,ctx.getConfiguration());
  final PatternLayout layout=PatternLayout.newBuilder().withPatternSelector(selector).withConfiguration(ctx.getConfiguration()).build();
  final LogEvent event1=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setMarker(MarkerManager.getMarker(""String_Node_Str"")).setLevel(Level.TRACE).setIncludeLocation(true).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final String result1=new FauxLogger().formatEvent(event1,layout);
  final String expectSuffix1=String.format(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + result1,result1.endsWith(expectSuffix1));
  final LogEvent event2=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final String result2=new String(layout.toByteArray(event2));
  final String expectSuffix2=String.format(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + result2,result2.endsWith(expectSuffix2));
}"
90588,"private void testUnixTime(final String pattern) throws Exception {
  final PatternLayout layout=PatternLayout.newBuilder().withPattern(pattern + ""String_Node_Str"").withConfiguration(ctx.getConfiguration()).build();
  final LogEvent event1=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final byte[] result1=layout.toByteArray(event1);
  assertEquals(event1.getTimeMillis() + ""String_Node_Str"",new String(result1));
  final LogEvent event2=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final byte[] result2=layout.toByteArray(event2);
  assertEquals(event2.getTimeMillis() + ""String_Node_Str"",new String(result2));
}","@SuppressWarnings(""String_Node_Str"") private void testUnixTime(final String pattern) throws Exception {
  final PatternLayout layout=PatternLayout.newBuilder().withPattern(pattern + ""String_Node_Str"").withConfiguration(ctx.getConfiguration()).build();
  final LogEvent event1=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final byte[] result1=layout.toByteArray(event1);
  assertEquals(event1.getTimeMillis() + ""String_Node_Str"",new String(result1));
  final LogEvent event2=Log4jLogEvent.newBuilder().setLoggerName(this.getClass().getName()).setLoggerFqcn(""String_Node_Str"").setLevel(Level.INFO).setMessage(new SimpleMessage(""String_Node_Str"")).build();
  final byte[] result2=layout.toByteArray(event2);
  assertEquals(event2.getTimeMillis() + ""String_Node_Str"",new String(result2));
}"
90589,"public AwaitCompletionReliabilityStrategy(final LoggerConfig loggerConfig){
  this.loggerConfig=loggerConfig;
}","public AwaitCompletionReliabilityStrategy(final LoggerConfig loggerConfig){
  this.loggerConfig=Objects.requireNonNull(loggerConfig,""String_Node_Str"");
}"
90590,"/** 
 * Sets the levels of <code>parentLogger</code> and all 'child' loggers to the given <code>level</level>.
 * @param parentLogger the parent logger
 * @param level the new level
 */
public static void setAllLevels(final String parentLogger,final Level level){
  final LoggerContext loggerContext=LoggerContext.getContext(false);
  final Configuration config=loggerContext.getConfiguration();
  boolean set=setLevel(parentLogger,level,config);
  for (  final Map.Entry<String,LoggerConfig> entry : config.getLoggers().entrySet()) {
    if (entry.getKey().startsWith(parentLogger)) {
      set|=setLevel(entry.getValue(),level);
    }
  }
  if (set) {
    loggerContext.updateLoggers();
  }
}","/** 
 * Sets the levels of <code>parentLogger</code> and all 'child' loggers to the given <code>level</code>.
 * @param parentLogger the parent logger
 * @param level the new level
 */
public static void setAllLevels(final String parentLogger,final Level level){
  final LoggerContext loggerContext=LoggerContext.getContext(false);
  final Configuration config=loggerContext.getConfiguration();
  boolean set=setLevel(parentLogger,level,config);
  for (  final Map.Entry<String,LoggerConfig> entry : config.getLoggers().entrySet()) {
    if (entry.getKey().startsWith(parentLogger)) {
      set|=setLevel(entry.getValue(),level);
    }
  }
  if (set) {
    loggerContext.updateLoggers();
  }
}"
90591,"/** 
 * Set the ConfigurationSource.
 * @param configurationSource the {@link ConfigurationSource).}
 * @return this builder instance
 */
@Override public ConfigurationBuilder<T> setConfigurationSource(final ConfigurationSource configurationSource){
  source=configurationSource;
  return this;
}","/** 
 * Set the ConfigurationSource.
 * @param configurationSource the {@link ConfigurationSource}
 * @return this builder instance
 */
@Override public ConfigurationBuilder<T> setConfigurationSource(final ConfigurationSource configurationSource){
  source=configurationSource;
  return this;
}"
90592,"/** 
 * <p>Formats a   {@code Date},   {@code Calendar} or{@code Long} (milliseconds) object.</p>See  {@link java.text.DateFormat#format(Object,StringBuilder,FieldPosition)}
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
StringBuilder format(Object obj,StringBuilder toAppendTo,FieldPosition pos);","/** 
 * <p>Formats a   {@code Date},   {@code Calendar} or{@code Long} (milliseconds) object.</p>See  {@link java.text.DateFormat#format(Object,StringBuffer,FieldPosition)}
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
StringBuilder format(Object obj,StringBuilder toAppendTo,FieldPosition pos);"
90593,"/** 
 * <p>Constructs a new FastDateParser.</p>
 * @param pattern non-null {@link java.text.SimpleDateFormat} compatiblepattern
 * @param timeZone non-null time zone to use
 * @param locale non-null locale
 * @param centuryStart The start of the century for 2 digit year parsing
 * @param lenient if true, non-standard values for Calendar fields should be accepted;if false, non-standard values will cause a ParseException to be thrown  {@link CalendaretLenient(boolean)}
 * @since 3.5
 */
protected FastDateParser(final String pattern,final TimeZone timeZone,final Locale locale,final Date centuryStart,final boolean lenient){
  this.pattern=pattern;
  this.timeZone=timeZone;
  this.locale=locale;
  this.lenient=lenient;
  final Calendar definingCalendar=Calendar.getInstance(timeZone,locale);
  int centuryStartYear;
  if (centuryStart != null) {
    definingCalendar.setTime(centuryStart);
    centuryStartYear=definingCalendar.get(Calendar.YEAR);
  }
 else   if (locale.equals(JAPANESE_IMPERIAL)) {
    centuryStartYear=0;
  }
 else {
    definingCalendar.setTime(new Date());
    centuryStartYear=definingCalendar.get(Calendar.YEAR) - 80;
  }
  century=centuryStartYear / 100 * 100;
  startYear=centuryStartYear - century;
  init(definingCalendar);
}","/** 
 * <p>Constructs a new FastDateParser.</p>
 * @param pattern non-null {@link java.text.SimpleDateFormat} compatiblepattern
 * @param timeZone non-null time zone to use
 * @param locale non-null locale
 * @param centuryStart The start of the century for 2 digit year parsing
 * @param lenient if true, non-standard values for Calendar fields should be accepted;if false, non-standard values will cause a ParseException to be thrown  {@link Calendar#setLenient(boolean)}
 * @since 3.5
 */
protected FastDateParser(final String pattern,final TimeZone timeZone,final Locale locale,final Date centuryStart,final boolean lenient){
  this.pattern=pattern;
  this.timeZone=timeZone;
  this.locale=locale;
  this.lenient=lenient;
  final Calendar definingCalendar=Calendar.getInstance(timeZone,locale);
  int centuryStartYear;
  if (centuryStart != null) {
    definingCalendar.setTime(centuryStart);
    centuryStartYear=definingCalendar.get(Calendar.YEAR);
  }
 else   if (locale.equals(JAPANESE_IMPERIAL)) {
    centuryStartYear=0;
  }
 else {
    definingCalendar.setTime(new Date());
    centuryStartYear=definingCalendar.get(Calendar.YEAR) - 80;
  }
  century=centuryStartYear / 100 * 100;
  startYear=centuryStartYear - century;
  init(definingCalendar);
}"
90594,"/** 
 * This implementation updates the ParsePosition if the parse succeeeds. However, unlike the method   {@link java.text.SimpleDateFormat#parse(String,ParsePosition)}it is not able to set the error Index - i.e.   {@link ParsePosition#getErrorIndex()} -  if the parse fails.<p> To determine if the parse has succeeded, the caller must check if the current parse position given by  {@link ParsePosition#getIndex()} has been updated. If the input buffer has been fullyparsed, then the index will point to just after the end of the input buffer.
 * @see org.apache.commons.lang3.time.DateParser#parse(java.lang.String,java.text.ParsePosition) {@inheritDoc}
 */
@Override public Date parse(final String source,final ParsePosition pos){
  final int offset=pos.getIndex();
  final Matcher matcher=parsePattern.matcher(source.substring(offset));
  if (!matcher.lookingAt()) {
    return null;
  }
  final Calendar cal=Calendar.getInstance(timeZone,locale);
  cal.clear();
  cal.setLenient(lenient);
  for (int i=0; i < strategies.length; ) {
    final Strategy strategy=strategies[i++];
    strategy.setCalendar(this,cal,matcher.group(i));
  }
  pos.setIndex(offset + matcher.end());
  return cal.getTime();
}","/** 
 * This implementation updates the ParsePosition if the parse succeeeds. However, unlike the method   {@link java.text.SimpleDateFormat#parse(String,ParsePosition)}it is not able to set the error Index - i.e.   {@link ParsePosition#getErrorIndex()} -  if the parse fails.<p> To determine if the parse has succeeded, the caller must check if the current parse position given by  {@link ParsePosition#getIndex()} has been updated. If the input buffer has been fullyparsed, then the index will point to just after the end of the input buffer. {@inheritDoc}
 */
@Override public Date parse(final String source,final ParsePosition pos){
  final int offset=pos.getIndex();
  final Matcher matcher=parsePattern.matcher(source.substring(offset));
  if (!matcher.lookingAt()) {
    return null;
  }
  final Calendar cal=Calendar.getInstance(timeZone,locale);
  cal.clear();
  cal.setLenient(lenient);
  for (int i=0; i < strategies.length; ) {
    final Strategy strategy=strategies[i++];
    strategy.setCalendar(this,cal,matcher.group(i));
  }
  pos.setIndex(offset + matcher.end());
  return cal.getTime();
}"
90595,"/** 
 * Returns the sum of the lengths of all Strings in the specified array.
 */
private static int sumStringLengths(final String[] arguments){
  int result=0;
  for (int i=0; i < arguments.length; i++) {
    result+=arguments[i].length();
  }
  return result;
}","/** 
 * Returns the sum of the lengths of all Strings in the specified array.
 */
private static int sumStringLengths(final String[] arguments){
  int result=0;
  for (int i=0; i < arguments.length; i++) {
    result+=String.valueOf(arguments[i]).length();
  }
  return result;
}"
90596,"/** 
 * Appends the argument at the specified argument index to the specified result char array at the specified position and returns the resulting position.
 */
private static int writeArgAt0(final String[] arguments,final int currentArgument,final char[] result,final int pos){
  final String arg=arguments[currentArgument];
  final int argLen=arg.length();
  arg.getChars(0,argLen,result,pos);
  return pos + argLen;
}","/** 
 * Appends the argument at the specified argument index to the specified result char array at the specified position and returns the resulting position.
 */
private static int writeArgAt0(final String[] arguments,final int currentArgument,final char[] result,final int pos){
  final String arg=String.valueOf(arguments[currentArgument]);
  int argLen=arg.length();
  arg.getChars(0,argLen,result,pos);
  return pos + argLen;
}"
90597,"/** 
 * Returns the FixedFormat with the name or pattern matching the specified string or   {@code null} if not found.
 */
public static FixedFormat lookup(String nameOrPattern){
  for (  FixedFormat type : FixedFormat.values()) {
    if (type.name().equals(nameOrPattern) || type.getPattern().equals(nameOrPattern)) {
      return type;
    }
  }
  return null;
}","/** 
 * Returns the FixedFormat with the name or pattern matching the specified string or   {@code null} if not found.
 */
public static FixedFormat lookup(final String nameOrPattern){
  for (  final FixedFormat type : FixedFormat.values()) {
    if (type.name().equals(nameOrPattern) || type.getPattern().equals(nameOrPattern)) {
      return type;
    }
  }
  return null;
}"
90598,"private int writeTime(int ms,char[] buffer,int pos){
  final int hours=ms / 3600000;
  ms-=3600000 * hours;
  final int minutes=ms / 60000;
  ms-=60000 * minutes;
  final int seconds=ms / 1000;
  ms-=1000 * seconds;
  int temp=hours / 10;
  buffer[pos++]=((char)(temp + '0'));
  buffer[pos++]=((char)(hours - 10 * temp + '0'));
  buffer[pos]=timeSeparatorChar;
  pos+=timeSeparatorLength;
  temp=minutes / 10;
  buffer[pos++]=((char)(temp + '0'));
  buffer[pos++]=((char)(minutes - 10 * temp + '0'));
  buffer[pos]=timeSeparatorChar;
  pos+=timeSeparatorLength;
  temp=seconds / 10;
  buffer[pos++]=((char)(temp + '0'));
  buffer[pos++]=((char)(seconds - 10 * temp + '0'));
  buffer[pos]=millisSeparatorChar;
  pos+=millisSeparatorLength;
  temp=ms / 100;
  buffer[pos++]=((char)(temp + '0'));
  ms-=100 * temp;
  temp=ms / 10;
  buffer[pos++]=((char)(temp + '0'));
  ms-=10 * temp;
  buffer[pos++]=((char)(ms + '0'));
  return pos;
}","private int writeTime(int ms,final char[] buffer,int pos){
  final int hours=ms / 3600000;
  ms-=3600000 * hours;
  final int minutes=ms / 60000;
  ms-=60000 * minutes;
  final int seconds=ms / 1000;
  ms-=1000 * seconds;
  int temp=hours / 10;
  buffer[pos++]=((char)(temp + '0'));
  buffer[pos++]=((char)(hours - 10 * temp + '0'));
  buffer[pos]=timeSeparatorChar;
  pos+=timeSeparatorLength;
  temp=minutes / 10;
  buffer[pos++]=((char)(temp + '0'));
  buffer[pos++]=((char)(minutes - 10 * temp + '0'));
  buffer[pos]=timeSeparatorChar;
  pos+=timeSeparatorLength;
  temp=seconds / 10;
  buffer[pos++]=((char)(temp + '0'));
  buffer[pos++]=((char)(seconds - 10 * temp + '0'));
  buffer[pos]=millisSeparatorChar;
  pos+=millisSeparatorLength;
  temp=ms / 100;
  buffer[pos++]=((char)(temp + '0'));
  ms-=100 * temp;
  temp=ms / 10;
  buffer[pos++]=((char)(temp + '0'));
  ms-=10 * temp;
  buffer[pos++]=((char)(ms + '0'));
  return pos;
}"
90599,"public int getDatePatternLength(){
  return getDatePattern() == null ? 0 : getDatePattern().length();
}","public int getDatePatternLength(){
  return getDatePattern() == null ? 0 : getDatePattern().length() - escapeCount;
}"
90600,"public static CustomTimeFormat createIfSupported(final String[] options){
  if (options == null || options.length == 0 || options.length > 1) {
    return null;
  }
  FixedFormat type=FixedFormat.lookup(options[0]);
  return type == null ? null : new CustomTimeFormat(type);
}","public static CustomTimeFormat createIfSupported(final String[] options){
  if (options == null || options.length == 0 || options.length > 1) {
    return null;
  }
  final FixedFormat type=FixedFormat.lookup(options[0]);
  return type == null ? null : new CustomTimeFormat(type);
}"
90601,"public int format(final long time,final char[] buffer,int startPos){
  final int ms=(int)(millisSinceMidnight(time));
  writeDate(buffer);
  return writeTime(ms,buffer,startPos + dateLength) - startPos;
}","public int format(final long time,final char[] buffer,final int startPos){
  final int ms=(int)(millisSinceMidnight(time));
  writeDate(buffer,startPos);
  return writeTime(ms,buffer,startPos + dateLength) - startPos;
}"
90602,"private void writeDate(char[] buffer){
  if (cachedDate != null) {
    System.arraycopy(cachedDate,0,buffer,0,dateLength);
  }
}","private void writeDate(final char[] buffer,final int startPos){
  if (cachedDate != null) {
    System.arraycopy(cachedDate,0,buffer,startPos,dateLength);
  }
}"
90603,"private void updateMidnightMillis(final long now){
  updateCachedDate(now);
  midnightToday=calcMidnightMillis(0);
  midnightTomorrow=calcMidnightMillis(1);
}","private void updateMidnightMillis(final long now){
  updateCachedDate(now);
  midnightToday=calcMidnightMillis(now,0);
  midnightTomorrow=calcMidnightMillis(now,1);
}"
90604,"private void FixedFormat(final String pattern,final String datePattern,char timeSeparator,int timeSepLength,char millisSeparator,int millisSepLength){
  this.timeSeparatorChar=timeSeparator;
  this.timeSeparatorLength=timeSepLength;
  this.millisSeparatorChar=millisSeparator;
  this.millisSeparatorLength=millisSepLength;
  this.pattern=Objects.requireNonNull(pattern);
  this.datePattern=datePattern;
}","private void FixedFormat(final String pattern,final String datePattern,final int escapeCount,final char timeSeparator,final int timeSepLength,final char millisSeparator,final int millisSepLength){
  this.timeSeparatorChar=timeSeparator;
  this.timeSeparatorLength=timeSepLength;
  this.millisSeparatorChar=millisSeparator;
  this.millisSeparatorLength=millisSepLength;
  this.pattern=Objects.requireNonNull(pattern);
  this.datePattern=datePattern;
  this.escapeCount=escapeCount;
}"
90605,"private void updateCachedDate(long now){
  if (fastDateFormat != null) {
    StringBuilder result=fastDateFormat.format(now,new StringBuilder());
    cachedDate=result.toString().toCharArray();
  }
}","private void updateCachedDate(final long now){
  if (fastDateFormat != null) {
    final StringBuilder result=fastDateFormat.format(now,new StringBuilder());
    cachedDate=result.toString().toCharArray();
  }
}"
90606,"/** 
 * Constructs a CustomTimeFormat for the specified fixed format. <p> Package protected for unit tests.
 * @param type the fixed format
 */
CustomTimeFormat(FixedFormat type){
  this.type=Objects.requireNonNull(type);
  this.timeSeparatorChar=type.timeSeparatorChar;
  this.timeSeparatorLength=type.timeSeparatorLength;
  this.millisSeparatorChar=type.millisSeparatorChar;
  this.millisSeparatorLength=type.millisSeparatorLength;
  this.length=type.getPattern().length();
  this.dateLength=type.getDatePatternLength();
  this.fastDateFormat=type.getFastDateFormat();
}","/** 
 * Constructs a CustomTimeFormat for the specified fixed format. <p> Package protected for unit tests.
 * @param type the fixed format
 */
CustomTimeFormat(final FixedFormat type){
  this.type=Objects.requireNonNull(type);
  this.timeSeparatorChar=type.timeSeparatorChar;
  this.timeSeparatorLength=type.timeSeparatorLength;
  this.millisSeparatorChar=type.millisSeparatorChar;
  this.millisSeparatorLength=type.millisSeparatorLength;
  this.length=type.getLength();
  this.dateLength=type.getDatePatternLength();
  this.fastDateFormat=type.getFastDateFormat();
}"
90607,"private long calcMidnightMillis(final int addDays){
  final Calendar cal=Calendar.getInstance();
  cal.set(Calendar.HOUR_OF_DAY,0);
  cal.set(Calendar.MINUTE,0);
  cal.set(Calendar.SECOND,0);
  cal.set(Calendar.MILLISECOND,0);
  cal.add(Calendar.DATE,addDays);
  return cal.getTimeInMillis();
}","static long calcMidnightMillis(final long time,final int addDays){
  final Calendar cal=Calendar.getInstance();
  cal.setTimeInMillis(time);
  cal.set(Calendar.HOUR_OF_DAY,0);
  cal.set(Calendar.MINUTE,0);
  cal.set(Calendar.SECOND,0);
  cal.set(Calendar.MILLISECOND,0);
  cal.add(Calendar.DATE,addDays);
  return cal.getTimeInMillis();
}"
90608,"@Override public void logMessage(final String fqcn,final Level level,final Marker marker,final Message msg,final Throwable throwable){
  final StringBuilder sb=new StringBuilder();
  if (showDateTime) {
    final Date now=new Date();
    String dateText;
synchronized (dateFormatter) {
      dateText=dateFormatter.format(now);
    }
    sb.append(dateText);
    sb.append(SPACE);
  }
  sb.append(level.toString());
  sb.append(SPACE);
  if (Strings.isNotEmpty(logName)) {
    sb.append(logName);
    sb.append(SPACE);
  }
  sb.append(msg.getFormattedMessage());
  if (showContextMap) {
    final Map<String,String> mdc=ThreadContext.getImmutableContext();
    if (mdc.size() > 0) {
      sb.append(SPACE);
      sb.append(mdc.toString());
      sb.append(SPACE);
    }
  }
  final Object[] params=msg.getParameters();
  Throwable t;
  if (throwable == null && params != null && params.length > 0 && params[params.length - 1] instanceof Throwable) {
    t=(Throwable)params[params.length - 1];
  }
 else {
    t=throwable;
  }
  if (t != null) {
    sb.append(SPACE);
    final ByteArrayOutputStream baos=new ByteArrayOutputStream();
    t.printStackTrace(new PrintStream(baos));
    sb.append(baos.toString());
  }
  stream.println(sb.toString());
}","@Override public void logMessage(final String fqcn,final Level level,final Marker marker,final Message msg,final Throwable throwable){
  final StringBuilder sb=new StringBuilder();
  if (showDateTime) {
    final Date now=new Date();
    String dateText;
synchronized (dateFormatter) {
      dateText=dateFormatter.format(now);
    }
    sb.append(dateText);
    sb.append(SPACE);
  }
  sb.append(level.toString());
  sb.append(SPACE);
  if (Strings.isNotEmpty(logName)) {
    sb.append(logName);
    sb.append(SPACE);
  }
  sb.append(msg.getFormattedMessage());
  if (showContextMap) {
    final Map<String,String> mdc=ThreadContext.getImmutableContext();
    if (mdc.size() > 0) {
      sb.append(SPACE);
      sb.append(mdc.toString());
      sb.append(SPACE);
    }
  }
  final Object[] params=msg.getParameters();
  Throwable t;
  if (throwable == null && params != null && params.length > 0 && params[params.length - 1] instanceof Throwable) {
    t=(Throwable)params[params.length - 1];
  }
 else {
    t=throwable;
  }
  stream.println(sb.toString());
  if (t != null) {
    stream.print(SPACE);
    t.printStackTrace(stream);
  }
}"
90609,"/** 
 * To prevent class loading issues during plugin discovery, this code cannot live within MongoDbProvider. This is because of how Java treats references to Exception classes different from references to other classes. When Java loads a class, it normally won't load that class's dependent classes until and unless A) they are used, B) the class being loaded extends or implements those classes, or C) those classes are the types of static members in the class. However, exceptions that a class uses are always loaded when the class is loaded, even before they are actually used.
 * @param database The database to authenticate
 * @param username The username to authenticate with
 * @param password The password to authenticate with
 */
static void authenticate(final DB database,final String username,final String password){
  try {
    if (!database.authenticate(username,password.toCharArray())) {
      LOGGER.error(""String_Node_Str"");
    }
  }
 catch (  final MongoException e) {
    LOGGER.error(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  final IllegalStateException e) {
    LOGGER.error(""String_Node_Str"" + ""String_Node_Str"",e);
  }
}","/** 
 * To prevent class loading issues during plugin discovery, this code cannot live within MongoDbProvider. This is because of how Java treats references to Exception classes different from references to other classes. When Java loads a class, it normally won't load that class's dependent classes until and unless A) they are used, B) the class being loaded extends or implements those classes, or C) those classes are the types of static members in the class. However, exceptions that a class uses are always loaded when the class is loaded, even before they are actually used.
 * @param database The database to authenticate
 * @param username The username to authenticate with
 * @param password The password to authenticate with
 */
static void authenticate(final DB database,final String username,final String password){
  try {
    if (!database.authenticate(username,password.toCharArray())) {
      LOGGER.error(""String_Node_Str"");
    }
  }
 catch (  final MongoException e) {
    LOGGER.error(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  final IllegalStateException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}"
90610,"@Override public StackTraceElement deserialize(final JsonParser jp,final DeserializationContext ctxt) throws IOException, JsonProcessingException {
  JsonToken t=jp.getCurrentToken();
  if (t == JsonToken.START_OBJECT) {
    String className=null, methodName=null, fileName=null;
    int lineNumber=-1;
    while ((t=jp.nextValue()) != JsonToken.END_OBJECT) {
      final String propName=jp.getCurrentName();
      if (""String_Node_Str"".equals(propName)) {
        className=jp.getText();
      }
 else       if (""String_Node_Str"".equals(propName)) {
        fileName=jp.getText();
      }
 else       if (""String_Node_Str"".equals(propName)) {
        if (t.isNumeric()) {
          lineNumber=jp.getIntValue();
        }
 else {
          try {
            lineNumber=Integer.valueOf(jp.getText().trim()).intValue();
          }
 catch (          final NumberFormatException e) {
            throw JsonMappingException.from(jp,""String_Node_Str"" + t + ""String_Node_Str"",e);
          }
        }
      }
 else       if (""String_Node_Str"".equals(propName)) {
        methodName=jp.getText();
      }
 else       if (""String_Node_Str"".equals(propName)) {
      }
 else {
        this.handleUnknownProperty(jp,ctxt,this._valueClass,propName);
      }
    }
    return new StackTraceElement(className,methodName,fileName,lineNumber);
  }
  throw ctxt.mappingException(this._valueClass,t);
}","@Override public StackTraceElement deserialize(final JsonParser jp,final DeserializationContext ctxt) throws IOException, JsonProcessingException {
  JsonToken t=jp.getCurrentToken();
  if (t == JsonToken.START_OBJECT) {
    String className=null, methodName=null, fileName=null;
    int lineNumber=-1;
    while ((t=jp.nextValue()) != JsonToken.END_OBJECT) {
      final String propName=jp.getCurrentName();
      if (""String_Node_Str"".equals(propName)) {
        className=jp.getText();
      }
 else       if (""String_Node_Str"".equals(propName)) {
        fileName=jp.getText();
      }
 else       if (""String_Node_Str"".equals(propName)) {
        if (t.isNumeric()) {
          lineNumber=jp.getIntValue();
        }
 else {
          try {
            lineNumber=Integer.parseInt(jp.getText().trim());
          }
 catch (          final NumberFormatException e) {
            throw JsonMappingException.from(jp,""String_Node_Str"" + t + ""String_Node_Str"",e);
          }
        }
      }
 else       if (""String_Node_Str"".equals(propName)) {
        methodName=jp.getText();
      }
 else       if (""String_Node_Str"".equals(propName)) {
      }
 else {
        this.handleUnknownProperty(jp,ctxt,this._valueClass,propName);
      }
    }
    return new StackTraceElement(className,methodName,fileName,lineNumber);
  }
  throw ctxt.mappingException(this._valueClass,t);
}"
90611,"@Setup(Level.Trial) public void up(){
  new File(""String_Node_Str"").delete();
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  logger=LogManager.getLogger(getClass());
  formatterLogger=LogManager.getLogger(""String_Node_Str"");
}","@Setup(Level.Trial) public void up(){
  new File(""String_Node_Str"").delete();
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  logger=LogManager.getLogger(getClass());
  formatterLogger=LogManager.getLogger(""String_Node_Str"",new StringFormatterMessageFactory());
}"
90612,"private <E extends Enum<E>>TypeConverter<? extends E> registerEnumType(final Type type){
  @SuppressWarnings(""String_Node_Str"") final TypeConverter<E> converter=new EnumConverter<E>((Class<E>)type);
  registry.putIfAbsent(type,converter);
  return converter;
}","private <E extends Enum<E>>TypeConverter<? extends E> registerEnumType(final Class<E> type){
  final TypeConverter<E> converter=new EnumConverter<E>(type);
  registry.putIfAbsent(type,converter);
  return converter;
}"
90613,"/** 
 * Finds a   {@link TypeConverter} for the given {@link Type}, falling back to an assignment-compatible TypeConverter if none exist for the given type. That is, if the given Type does not have a TypeConverter, but another Type which can be assigned to the given Type <em>does</em> have a TypeConverter, then that TypeConverter will be used and registered.
 * @param type the Type to find a TypeConverter for (must not be {@code null}).
 * @return a TypeConverter for the given Type.
 * @throws UnknownFormatConversionException if no TypeConverter can be found for the given type.
 */
public TypeConverter<?> findCompatibleConverter(final Type type){
  Assert.requireNonNull(type,""String_Node_Str"");
  final TypeConverter<?> primary=registry.get(type);
  if (primary != null) {
    return primary;
  }
  if (type instanceof Class<?> && ((Class<?>)type).isEnum()) {
    return registerEnumType(type);
  }
  for (  final Map.Entry<Type,TypeConverter<?>> entry : registry.entrySet()) {
    final Type key=entry.getKey();
    if (TypeUtil.isAssignable(type,key)) {
      LOGGER.debug(""String_Node_Str"",key,type);
      final TypeConverter<?> value=entry.getValue();
      registry.putIfAbsent(type,value);
      return value;
    }
  }
  throw new UnknownFormatConversionException(type.toString());
}","/** 
 * Finds a   {@link TypeConverter} for the given {@link Type}, falling back to an assignment-compatible TypeConverter if none exist for the given type. That is, if the given Type does not have a TypeConverter, but another Type which can be assigned to the given Type <em>does</em> have a TypeConverter, then that TypeConverter will be used and registered.
 * @param type the Type to find a TypeConverter for (must not be {@code null}).
 * @return a TypeConverter for the given Type.
 * @throws UnknownFormatConversionException if no TypeConverter can be found for the given type.
 */
public TypeConverter<?> findCompatibleConverter(final Type type){
  Assert.requireNonNull(type,""String_Node_Str"");
  final TypeConverter<?> primary=registry.get(type);
  if (primary != null) {
    return primary;
  }
  if (type instanceof Class<?> && ((Class<?>)type).isEnum()) {
    return registerEnumType(((Class<?>)type).asSubclass(Enum.class));
  }
  for (  final Map.Entry<Type,TypeConverter<?>> entry : registry.entrySet()) {
    final Type key=entry.getKey();
    if (TypeUtil.isAssignable(type,key)) {
      LOGGER.debug(""String_Node_Str"",key,type);
      final TypeConverter<?> value=entry.getValue();
      registry.putIfAbsent(type,value);
      return value;
    }
  }
  throw new UnknownFormatConversionException(type.toString());
}"
90614,"@Override public void logMessage(final String fqcn,final Level level,final Marker marker,final Message message,final Throwable t){
  if (locationAwareLogger != null) {
    if (message instanceof LoggerNameAwareMessage) {
      ((LoggerNameAwareMessage)message).setLoggerName(getName());
    }
    locationAwareLogger.log(getMarker(marker),fqcn,convertLevel(level),message.getFormattedMessage(),message.getParameters(),t);
  }
 else {
switch (level.getStandardLevel()) {
case DEBUG:
      logger.debug(fqcn,getMarker(marker),message.getFormattedMessage(),message.getParameters(),t);
    break;
case TRACE:
  logger.trace(fqcn,getMarker(marker),message.getFormattedMessage(),message.getParameters(),t);
break;
case INFO:
logger.info(fqcn,getMarker(marker),message.getFormattedMessage(),message.getParameters(),t);
break;
case WARN:
logger.warn(fqcn,getMarker(marker),message.getFormattedMessage(),message.getParameters(),t);
break;
case ERROR:
logger.error(fqcn,getMarker(marker),message.getFormattedMessage(),message.getParameters(),t);
break;
default :
logger.error(fqcn,getMarker(marker),message.getFormattedMessage(),message.getParameters(),t);
break;
}
}
}","@Override public void logMessage(final String fqcn,final Level level,final Marker marker,final Message message,final Throwable t){
  if (locationAwareLogger != null) {
    if (message instanceof LoggerNameAwareMessage) {
      ((LoggerNameAwareMessage)message).setLoggerName(getName());
    }
    locationAwareLogger.log(getMarker(marker),fqcn,convertLevel(level),message.getFormattedMessage(),message.getParameters(),t);
  }
 else {
switch (level.getStandardLevel()) {
case DEBUG:
      logger.debug(getMarker(marker),message.getFormattedMessage(),message.getParameters(),t);
    break;
case TRACE:
  logger.trace(getMarker(marker),message.getFormattedMessage(),message.getParameters(),t);
break;
case INFO:
logger.info(getMarker(marker),message.getFormattedMessage(),message.getParameters(),t);
break;
case WARN:
logger.warn(getMarker(marker),message.getFormattedMessage(),message.getParameters(),t);
break;
case ERROR:
logger.error(getMarker(marker),message.getFormattedMessage(),message.getParameters(),t);
break;
default :
logger.error(getMarker(marker),message.getFormattedMessage(),message.getParameters(),t);
break;
}
}
}"
90615,"public MessageFormatMessage(final String messagePattern,final Object... arguments){
  this.messagePattern=messagePattern;
  this.argArray=arguments;
  if (arguments != null && arguments.length > 0 && arguments[arguments.length - 1] instanceof Throwable) {
    this.throwable=(Throwable)arguments[arguments.length - 1];
  }
  getFormattedMessage();
}","public MessageFormatMessage(final String messagePattern,final Object... arguments){
  this.messagePattern=messagePattern;
  this.argArray=arguments;
  if (arguments != null && arguments.length > 0 && arguments[arguments.length - 1] instanceof Throwable) {
    this.throwable=(Throwable)arguments[arguments.length - 1];
  }
}"
90616,"/** 
 * Create the ObjectMessage.
 * @param obj The Object to format.
 */
public ObjectMessage(Object obj){
  if (obj == null) {
    obj=""String_Node_Str"";
  }
  this.obj=obj;
  objectString=String.valueOf(obj);
}","/** 
 * Create the ObjectMessage.
 * @param obj The Object to format.
 */
public ObjectMessage(Object obj){
  if (obj == null) {
    obj=""String_Node_Str"";
  }
  this.obj=obj;
}"
90617,"private void writeObject(final ObjectOutputStream out) throws IOException {
  out.defaultWriteObject();
  if (obj instanceof Serializable) {
    out.writeObject(obj);
  }
 else {
    out.writeObject(obj.toString());
  }
}","private void writeObject(final ObjectOutputStream out) throws IOException {
  out.defaultWriteObject();
  if (obj instanceof Serializable) {
    out.writeObject(obj);
  }
 else {
    out.writeObject(String.valueOf(obj));
  }
}"
90618,"@Override public boolean equals(final Object o){
  if (this == o) {
    return true;
  }
  if (o == null || getClass() != o.getClass()) {
    return false;
  }
  final ObjectMessage that=(ObjectMessage)o;
  return !(obj != null ? !obj.equals(that.obj) : that.obj != null);
}","@Override public boolean equals(final Object o){
  if (this == o) {
    return true;
  }
  if (o == null || getClass() != o.getClass()) {
    return false;
  }
  final ObjectMessage that=(ObjectMessage)o;
  return obj == null ? that.obj == null : obj.equals(that.obj);
}"
90619,"/** 
 * Returns the formatted object message.
 * @return the formatted object message.
 */
@Override public String getFormattedMessage(){
  return objectString;
}","/** 
 * Returns the formatted object message.
 * @return the formatted object message.
 */
@Override public String getFormattedMessage(){
  if (objectString == null) {
    objectString=String.valueOf(obj);
  }
  return objectString;
}"
90620,"/** 
 * Returns the object formatted using its toString method.
 * @return the String representation of the object.
 */
@Override public String getFormat(){
  return objectString;
}","/** 
 * Returns the object formatted using its toString method.
 * @return the String representation of the object.
 */
@Override public String getFormat(){
  return getFormattedMessage();
}"
90621,"@Override public String toString(){
  return ""String_Node_Str"" + objectString + ']';
}","@Override public String toString(){
  return ""String_Node_Str"" + getFormattedMessage() + ']';
}"
90622,"public StringFormattedMessage(final String messagePattern,final Object... arguments){
  this.messagePattern=messagePattern;
  this.argArray=arguments;
  if (arguments != null && arguments.length > 0 && arguments[arguments.length - 1] instanceof Throwable) {
    this.throwable=(Throwable)arguments[arguments.length - 1];
  }
  getFormattedMessage();
}","public StringFormattedMessage(final String messagePattern,final Object... arguments){
  this.messagePattern=messagePattern;
  this.argArray=arguments;
  if (arguments != null && arguments.length > 0 && arguments[arguments.length - 1] instanceof Throwable) {
    this.throwable=(Throwable)arguments[arguments.length - 1];
  }
}"
90623,"/** 
 * Actual writing occurs here. <p/>
 * @param logEvent The LogEvent.
 */
@Override public void append(LogEvent logEvent){
  if (!isStarted()) {
    throw new IllegalStateException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (!(logEvent instanceof Log4jLogEvent)) {
    if (!(logEvent instanceof RingBufferLogEvent)) {
      return;
    }
    logEvent=((RingBufferLogEvent)logEvent).createMemento();
  }
  final Log4jLogEvent coreEvent=(Log4jLogEvent)logEvent;
  boolean appendSuccessful=false;
  if (blocking) {
    if (isAppenderThread.get() == Boolean.TRUE && queue.remainingCapacity() == 0) {
      coreEvent.setEndOfBatch(false);
      appendSuccessful=thread.callAppenders(coreEvent);
    }
 else {
      try {
        queue.put(Log4jLogEvent.serialize(coreEvent,includeLocation));
        appendSuccessful=true;
      }
 catch (      final InterruptedException e) {
        LOGGER.warn(""String_Node_Str"",getName());
      }
    }
  }
 else {
    appendSuccessful=queue.offer(Log4jLogEvent.serialize(coreEvent,includeLocation));
    if (!appendSuccessful) {
      error(""String_Node_Str"" + getName() + ""String_Node_Str"");
    }
  }
  if (!appendSuccessful && errorAppender != null) {
    errorAppender.callAppender(coreEvent);
  }
}","/** 
 * Actual writing occurs here. <p/>
 * @param logEvent The LogEvent.
 */
@Override public void append(LogEvent logEvent){
  if (!isStarted()) {
    throw new IllegalStateException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (!(logEvent instanceof Log4jLogEvent)) {
    if (!(logEvent instanceof RingBufferLogEvent)) {
      return;
    }
    logEvent=((RingBufferLogEvent)logEvent).createMemento();
  }
  logEvent.getMessage().getFormattedMessage();
  final Log4jLogEvent coreEvent=(Log4jLogEvent)logEvent;
  boolean appendSuccessful=false;
  if (blocking) {
    if (isAppenderThread.get() == Boolean.TRUE && queue.remainingCapacity() == 0) {
      coreEvent.setEndOfBatch(false);
      appendSuccessful=thread.callAppenders(coreEvent);
    }
 else {
      try {
        queue.put(Log4jLogEvent.serialize(coreEvent,includeLocation));
        appendSuccessful=true;
      }
 catch (      final InterruptedException e) {
        LOGGER.warn(""String_Node_Str"",getName());
      }
    }
  }
 else {
    appendSuccessful=queue.offer(Log4jLogEvent.serialize(coreEvent,includeLocation));
    if (!appendSuccessful) {
      error(""String_Node_Str"" + getName() + ""String_Node_Str"");
    }
  }
  if (!appendSuccessful && errorAppender != null) {
    errorAppender.callAppender(coreEvent);
  }
}"
90624,"@Override public void logMessage(final String fqcn,final Level level,final Marker marker,final Message message,final Throwable thrown){
  Info info=threadlocalInfo.get();
  if (info == null) {
    info=new Info(new RingBufferLogEventTranslator(),Thread.currentThread().getName(),false);
    threadlocalInfo.set(info);
  }
  final Disruptor<RingBufferLogEvent> temp=disruptor;
  if (temp == null) {
    LOGGER.fatal(""String_Node_Str"");
    return;
  }
  if (info.isAppenderThread && temp.getRingBuffer().remainingCapacity() == 0) {
    config.loggerConfig.log(getName(),fqcn,marker,level,message,thrown);
    return;
  }
  final boolean includeLocation=config.loggerConfig.isIncludeLocation();
  info.translator.setValues(this,getName(),marker,fqcn,level,message,thrown,ThreadContext.getImmutableContext(),ThreadContext.getImmutableStack(),THREAD_NAME_STRATEGY.getThreadName(info),includeLocation ? location(fqcn) : null,message instanceof TimestampMessage ? ((TimestampMessage)message).getTimestamp() : clock.currentTimeMillis());
  try {
    disruptor.publishEvent(info.translator);
  }
 catch (  final NullPointerException npe) {
    LOGGER.fatal(""String_Node_Str"");
  }
}","@Override public void logMessage(final String fqcn,final Level level,final Marker marker,final Message message,final Throwable thrown){
  Info info=threadlocalInfo.get();
  if (info == null) {
    info=new Info(new RingBufferLogEventTranslator(),Thread.currentThread().getName(),false);
    threadlocalInfo.set(info);
  }
  final Disruptor<RingBufferLogEvent> temp=disruptor;
  if (temp == null) {
    LOGGER.fatal(""String_Node_Str"");
    return;
  }
  if (info.isAppenderThread && temp.getRingBuffer().remainingCapacity() == 0) {
    config.loggerConfig.log(getName(),fqcn,marker,level,message,thrown);
    return;
  }
  message.getFormattedMessage();
  final boolean includeLocation=config.loggerConfig.isIncludeLocation();
  info.translator.setValues(this,getName(),marker,fqcn,level,message,thrown,ThreadContext.getImmutableContext(),ThreadContext.getImmutableStack(),THREAD_NAME_STRATEGY.getThreadName(info),includeLocation ? location(fqcn) : null,message instanceof TimestampMessage ? ((TimestampMessage)message).getTimestamp() : clock.currentTimeMillis());
  try {
    disruptor.publishEvent(info.translator);
  }
 catch (  final NullPointerException npe) {
    LOGGER.fatal(""String_Node_Str"");
  }
}"
90625,"/** 
 * If possible, delegates the invocation to   {@code callAppenders} to anotherthread and returns  {@code true}. If this is not possible (if it detects that delegating to another thread would cause deadlock because the current call to Logger.log() originated from the appender thread and the ringbuffer is full) then this method does nothing and returns   {@code false}. It is the responsibility of the caller to process the event when this method returns   {@code false}.
 * @param event the event to delegate to another thread
 * @return {@code true} if delegation was successful, {@code false} if thecalling thread needs to process the event itself
 */
public boolean callAppendersFromAnotherThread(final LogEvent event){
  final Disruptor<Log4jEventWrapper> temp=disruptor;
  if (temp == null) {
    LOGGER.fatal(""String_Node_Str"");
    return true;
  }
  if (isAppenderThread.get() == Boolean.TRUE && temp.getRingBuffer().remainingCapacity() == 0) {
    return false;
  }
  try {
    LogEvent logEvent=event;
    if (event instanceof RingBufferLogEvent) {
      logEvent=((RingBufferLogEvent)event).createMemento();
    }
    disruptor.getRingBuffer().publishEvent(translator,logEvent,asyncLoggerConfig);
  }
 catch (  final NullPointerException npe) {
    LOGGER.fatal(""String_Node_Str"");
  }
  return true;
}","/** 
 * If possible, delegates the invocation to   {@code callAppenders} to anotherthread and returns  {@code true}. If this is not possible (if it detects that delegating to another thread would cause deadlock because the current call to Logger.log() originated from the appender thread and the ringbuffer is full) then this method does nothing and returns   {@code false}. It is the responsibility of the caller to process the event when this method returns   {@code false}.
 * @param event the event to delegate to another thread
 * @return {@code true} if delegation was successful, {@code false} if thecalling thread needs to process the event itself
 */
public boolean callAppendersFromAnotherThread(final LogEvent event){
  final Disruptor<Log4jEventWrapper> temp=disruptor;
  if (temp == null) {
    LOGGER.fatal(""String_Node_Str"");
    return true;
  }
  if (isAppenderThread.get() == Boolean.TRUE && temp.getRingBuffer().remainingCapacity() == 0) {
    return false;
  }
  try {
    LogEvent logEvent=event;
    if (event instanceof RingBufferLogEvent) {
      logEvent=((RingBufferLogEvent)event).createMemento();
    }
    logEvent.getMessage().getFormattedMessage();
    disruptor.getRingBuffer().publishEvent(translator,logEvent,asyncLoggerConfig);
  }
 catch (  final NullPointerException npe) {
    LOGGER.fatal(""String_Node_Str"");
  }
  return true;
}"
90626,"private URI getConfigURI(final String location){
  try {
    String configLocation=location;
    if (configLocation == null) {
      final String[] paths=SetUtils.prefixSet(servletContext.getResourcePaths(""String_Node_Str""),""String_Node_Str"");
      if (paths.length == 1) {
        configLocation=paths[0];
      }
 else       if (paths.length > 1) {
        final String prefix=""String_Node_Str"" + this.name + ""String_Node_Str"";
        final boolean found=false;
        for (        final String str : paths) {
          if (str.startsWith(prefix)) {
            configLocation=str;
            break;
          }
        }
        if (!found) {
          configLocation=paths[0];
        }
      }
    }
    if (configLocation != null) {
      final URL url=servletContext.getResource(configLocation);
      if (url != null) {
        return url.toURI();
      }
    }
  }
 catch (  final Exception ex) {
  }
  if (location != null) {
    try {
      return FileUtils.getCorrectedFilePathUri(location);
    }
 catch (    final Exception e) {
      this.servletContext.log(""String_Node_Str"" + location + ""String_Node_Str"",e);
    }
  }
  return null;
}","private URI getConfigURI(final String location){
  try {
    String configLocation=location;
    if (configLocation == null) {
      final String[] paths=SetUtils.prefixSet(servletContext.getResourcePaths(""String_Node_Str""),""String_Node_Str"");
      if (paths.length == 1) {
        configLocation=paths[0];
      }
 else       if (paths.length > 1) {
        final String prefix=""String_Node_Str"" + this.name + ""String_Node_Str"";
        boolean found=false;
        for (        final String str : paths) {
          if (str.startsWith(prefix)) {
            configLocation=str;
            found=true;
            break;
          }
        }
        if (!found) {
          configLocation=paths[0];
        }
      }
    }
    if (configLocation != null) {
      final URL url=servletContext.getResource(configLocation);
      if (url != null) {
        return url.toURI();
      }
    }
  }
 catch (  final Exception ex) {
  }
  if (location != null) {
    try {
      return FileUtils.getCorrectedFilePathUri(location);
    }
 catch (    final Exception e) {
      this.servletContext.log(""String_Node_Str"" + location + ""String_Node_Str"",e);
    }
  }
  return null;
}"
90627,"/** 
 * Returns a copy of the ContextStack.
 * @return a copy of the ContextStack.s
 */
ContextStack copy();","/** 
 * Returns a copy of the ContextStack.
 * @return a copy of the ContextStack.
 */
ContextStack copy();"
90628,"/** 
 * Gets an immutable copy of this current thread's context stack.
 * @return an immutable copy of the ThreadContext stack.
 */
public static ContextStack getImmutableStack(){
  return contextStack;
}","/** 
 * Gets an immutable copy of this current thread's context stack.
 * @return an immutable copy of the ThreadContext stack.
 */
public static ContextStack getImmutableStack(){
  ContextStack result=contextStack.getImmutableStackOrNull();
  return result == null ? EMPTY_STACK : result;
}"
90629,"@Override public boolean add(final String s){
  if (!useStack) {
    return false;
  }
  final List<String> list=stack.get();
  final List<String> copy=list == null ? new ArrayList<String>() : new ArrayList<String>(list);
  copy.add(s);
  stack.set(Collections.unmodifiableList(copy));
  return true;
}","@Override public boolean add(final String s){
  if (!useStack) {
    return false;
  }
  final MutableThreadContextStack copy=getNonNullStackCopy();
  copy.add(s);
  copy.freeze();
  stack.set(copy);
  return true;
}"
90630,"@Override public int getDepth(){
  final List<String> list=stack.get();
  return list == null ? 0 : list.size();
}","@Override public int getDepth(){
  final MutableThreadContextStack values=stack.get();
  return values == null ? 0 : values.getDepth();
}"
90631,"@Override public boolean containsAll(final Collection<?> objects){
  if (objects.isEmpty()) {
    return true;
  }
  final List<String> list=stack.get();
  return list != null && list.containsAll(objects);
}","@Override public boolean containsAll(final Collection<?> objects){
  if (objects.isEmpty()) {
    return true;
  }
  final MutableThreadContextStack values=stack.get();
  return values != null && values.containsAll(objects);
}"
90632,"@Override public boolean isEmpty(){
  final List<String> result=stack.get();
  return result == null || result.isEmpty();
}","@Override public boolean isEmpty(){
  final MutableThreadContextStack values=stack.get();
  return values == null || values.isEmpty();
}"
90633,"@Override public List<String> asList(){
  final List<String> list=stack.get();
  if (list == null) {
    return Collections.emptyList();
  }
  return list;
}","@Override public List<String> asList(){
  final MutableThreadContextStack values=stack.get();
  if (values == null) {
    return Collections.emptyList();
  }
  return values.asList();
}"
90634,"@Override public boolean remove(final Object o){
  if (!useStack) {
    return false;
  }
  final List<String> list=stack.get();
  if (list == null || list.size() == 0) {
    return false;
  }
  final List<String> copy=new ArrayList<String>(list);
  final boolean result=copy.remove(o);
  stack.set(Collections.unmodifiableList(copy));
  return result;
}","@Override public boolean remove(final Object o){
  if (!useStack) {
    return false;
  }
  final MutableThreadContextStack values=stack.get();
  if (values == null || values.size() == 0) {
    return false;
  }
  final MutableThreadContextStack copy=(MutableThreadContextStack)values.copy();
  final boolean result=copy.remove(o);
  copy.freeze();
  stack.set(copy);
  return result;
}"
90635,"@Override public String peek(){
  final List<String> list=stack.get();
  if (list == null || list.size() == 0) {
    return null;
  }
  final int last=list.size() - 1;
  return list.get(last);
}","@Override public String peek(){
  final MutableThreadContextStack values=stack.get();
  if (values == null || values.size() == 0) {
    return null;
  }
  return values.peek();
}"
90636,"@Override public String pop(){
  if (!useStack) {
    return Strings.EMPTY;
  }
  final List<String> list=stack.get();
  if (list == null || list.size() == 0) {
    throw new NoSuchElementException(""String_Node_Str"");
  }
  final List<String> copy=new ArrayList<String>(list);
  final int last=copy.size() - 1;
  final String result=copy.remove(last);
  stack.set(Collections.unmodifiableList(copy));
  return result;
}","@Override public String pop(){
  if (!useStack) {
    return Strings.EMPTY;
  }
  final MutableThreadContextStack values=stack.get();
  if (values == null || values.size() == 0) {
    throw new NoSuchElementException(""String_Node_Str"");
  }
  final MutableThreadContextStack copy=(MutableThreadContextStack)values.copy();
  final String result=copy.pop();
  copy.freeze();
  stack.set(copy);
  return result;
}"
90637,"@Override public boolean contains(final Object o){
  final List<String> result=stack.get();
  return result != null && result.contains(o);
}","@Override public boolean contains(final Object o){
  final MutableThreadContextStack values=stack.get();
  return values != null && values.contains(o);
}"
90638,"@Override public Iterator<String> iterator(){
  final List<String> immutable=stack.get();
  if (immutable == null) {
    final List<String> empty=Collections.emptyList();
    return empty.iterator();
  }
  return immutable.iterator();
}","@Override public Iterator<String> iterator(){
  final MutableThreadContextStack values=stack.get();
  if (values == null) {
    final List<String> empty=Collections.emptyList();
    return empty.iterator();
  }
  return values.iterator();
}"
90639,"@Override public boolean removeAll(final Collection<?> objects){
  if (!useStack || objects.isEmpty()) {
    return false;
  }
  final List<String> list=stack.get();
  if (list == null || list.isEmpty()) {
    return false;
  }
  final List<String> copy=new ArrayList<String>(list);
  final boolean result=copy.removeAll(objects);
  stack.set(Collections.unmodifiableList(copy));
  return result;
}","@Override public boolean removeAll(final Collection<?> objects){
  if (!useStack || objects.isEmpty()) {
    return false;
  }
  final MutableThreadContextStack values=stack.get();
  if (values == null || values.isEmpty()) {
    return false;
  }
  final MutableThreadContextStack copy=(MutableThreadContextStack)values.copy();
  final boolean result=copy.removeAll(objects);
  copy.freeze();
  stack.set(copy);
  return result;
}"
90640,"@Override public int size(){
  final List<String> result=stack.get();
  return result == null ? 0 : result.size();
}","@Override public int size(){
  final MutableThreadContextStack values=stack.get();
  return values == null ? 0 : values.size();
}"
90641,"@Override public void trim(final int depth){
  if (depth < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final List<String> list=stack.get();
  if (list == null) {
    return;
  }
  final List<String> copy=new ArrayList<String>();
  final int count=Math.min(depth,list.size());
  for (int i=0; i < count; i++) {
    copy.add(list.get(i));
  }
  stack.set(copy);
}","@Override public void trim(final int depth){
  if (depth < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final MutableThreadContextStack values=stack.get();
  if (values == null) {
    return;
  }
  final MutableThreadContextStack copy=(MutableThreadContextStack)values.copy();
  copy.trim(depth);
  copy.freeze();
  stack.set(copy);
}"
90642,"@Override public boolean addAll(final Collection<? extends String> strings){
  if (!useStack || strings.isEmpty()) {
    return false;
  }
  final List<String> list=stack.get();
  final List<String> copy=list == null ? new ArrayList<String>() : new ArrayList<String>(list);
  copy.addAll(strings);
  stack.set(Collections.unmodifiableList(copy));
  return true;
}","@Override public boolean addAll(final Collection<? extends String> strings){
  if (!useStack || strings.isEmpty()) {
    return false;
  }
  final MutableThreadContextStack copy=getNonNullStackCopy();
  copy.addAll(strings);
  copy.freeze();
  stack.set(copy);
  return true;
}"
90643,"@Override public int hashCode(){
  final List<String> list=stack.get();
  final int prime=31;
  int result=1;
  result=prime * result + ((list == null) ? 0 : list.hashCode());
  return result;
}","@Override public int hashCode(){
  final MutableThreadContextStack values=stack.get();
  final int prime=31;
  int result=1;
  result=prime * result + ((values == null) ? 0 : values.hashCode());
  return result;
}"
90644,"@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (obj instanceof DefaultThreadContextStack) {
    final DefaultThreadContextStack other=(DefaultThreadContextStack)obj;
    if (this.useStack != other.useStack) {
      return false;
    }
  }
  if (!(obj instanceof ThreadContextStack)) {
    return false;
  }
  final ThreadContextStack other=(ThreadContextStack)obj;
  final List<String> otherAsList=other.asList();
  final List<String> list=stack.get();
  if (list == null) {
    if (otherAsList != null) {
      return false;
    }
  }
 else   if (!list.equals(otherAsList)) {
    return false;
  }
  return true;
}","@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (obj instanceof DefaultThreadContextStack) {
    final DefaultThreadContextStack other=(DefaultThreadContextStack)obj;
    if (this.useStack != other.useStack) {
      return false;
    }
  }
  if (!(obj instanceof ThreadContextStack)) {
    return false;
  }
  final ThreadContextStack other=(ThreadContextStack)obj;
  final MutableThreadContextStack values=stack.get();
  if (values == null) {
    return other == null;
  }
  return values.equals(other);
}"
90645,"@Override public <T>T[] toArray(final T[] ts){
  final List<String> result=stack.get();
  if (result == null) {
    if (ts.length > 0) {
      ts[0]=null;
    }
    return ts;
  }
  return result.toArray(ts);
}","@Override public <T>T[] toArray(final T[] ts){
  final MutableThreadContextStack result=stack.get();
  if (result == null) {
    if (ts.length > 0) {
      ts[0]=null;
    }
    return ts;
  }
  return result.toArray(ts);
}"
90646,"@Override public String toString(){
  final List<String> list=stack.get();
  return list == null ? ""String_Node_Str"" : list.toString();
}","@Override public String toString(){
  final MutableThreadContextStack values=stack.get();
  return values == null ? ""String_Node_Str"" : values.toString();
}"
90647,"@Override public ThreadContextStack copy(){
  List<String> result=null;
  if (!useStack || (result=stack.get()) == null) {
    return new MutableThreadContextStack(new ArrayList<String>());
  }
  return new MutableThreadContextStack(result);
}","@Override public ThreadContextStack copy(){
  MutableThreadContextStack values=null;
  if (!useStack || (values=stack.get()) == null) {
    return new MutableThreadContextStack();
  }
  return values.copy();
}"
90648,"@Override public boolean retainAll(final Collection<?> objects){
  if (!useStack || objects.isEmpty()) {
    return false;
  }
  final List<String> list=stack.get();
  if (list == null || list.isEmpty()) {
    return false;
  }
  final List<String> copy=new ArrayList<String>(list);
  final boolean result=copy.retainAll(objects);
  stack.set(Collections.unmodifiableList(copy));
  return result;
}","@Override public boolean retainAll(final Collection<?> objects){
  if (!useStack || objects.isEmpty()) {
    return false;
  }
  final MutableThreadContextStack values=stack.get();
  if (values == null || values.isEmpty()) {
    return false;
  }
  final MutableThreadContextStack copy=(MutableThreadContextStack)values.copy();
  final boolean result=copy.retainAll(objects);
  copy.freeze();
  stack.set(copy);
  return result;
}"
90649,"public BasicConfiguration(){
  final LoggerConfig root=getRootLogger();
  setName(""String_Node_Str"");
  final String levelName=System.getProperty(DEFAULT_LEVEL);
  final Level level=(levelName != null && Level.getLevel(levelName) != null) ? Level.getLevel(levelName) : Level.DEBUG;
  root.setLevel(level);
}","public BasicConfiguration(){
  super(ConfigurationSource.NULL_SOURCE);
  final LoggerConfig root=getRootLogger();
  setName(""String_Node_Str"");
  final String levelName=System.getProperty(DEFAULT_LEVEL);
  final Level level=(levelName != null && Level.getLevel(levelName) != null) ? Level.getLevel(levelName) : Level.DEBUG;
  root.setLevel(level);
}"
90650,"public synchronized void setConfigLocation(final URI configLocation){
  this.configLocation=configLocation;
  reconfigure();
}","/** 
 * Sets the configLocation to the specified value and reconfigures this context.
 * @param configLocation the location of the new configuration
 */
public synchronized void setConfigLocation(final URI configLocation){
  this.configLocation=configLocation;
  reconfigure();
}"
90651,"public synchronized URI getConfigLocation(){
  return configLocation;
}","/** 
 * Returns the initial configuration location or   {@code null}. The returned value may not be the location of the current configuration. Use   {@link #getConfiguration()}.  {@link Configuration#getConfigurationSource() getConfigurationSource()}.  {@link ConfigurationSource#getLocation() getLocation()} to get the actual source of the current configuration.
 * @return the initial configuration location or {@code null}
 */
public synchronized URI getConfigLocation(){
  return configLocation;
}"
90652,"/** 
 * Constructor.
 */
protected AbstractConfiguration(){
  componentMap.put(Configuration.CONTEXT_PROPERTIES,properties);
  pluginManager=new PluginManager(""String_Node_Str"");
  rootNode=new Node();
}","/** 
 * Constructor.
 */
protected AbstractConfiguration(final ConfigurationSource configurationSource){
  this.configurationSource=Assert.requireNonNull(configurationSource,""String_Node_Str"");
  componentMap.put(Configuration.CONTEXT_PROPERTIES,properties);
  pluginManager=new PluginManager(""String_Node_Str"");
  rootNode=new Node();
}"
90653,"protected void createAdvertiser(String advertiserString,ConfigurationFactory.ConfigurationSource configSource,byte[] buffer,String contentType){
  if (advertiserString != null) {
    Node node=new Node(null,advertiserString,null);
    Map<String,String> attributes=node.getAttributes();
    attributes.put(""String_Node_Str"",new String(buffer));
    attributes.put(""String_Node_Str"",contentType);
    attributes.put(""String_Node_Str"",""String_Node_Str"");
    if (configSource.getLocation() != null) {
      attributes.put(""String_Node_Str"",configSource.getLocation());
    }
    advertiserNode=node;
  }
}","protected void createAdvertiser(String advertiserString,ConfigurationSource configSource,byte[] buffer,String contentType){
  if (advertiserString != null) {
    Node node=new Node(null,advertiserString,null);
    Map<String,String> attributes=node.getAttributes();
    attributes.put(""String_Node_Str"",new String(buffer));
    attributes.put(""String_Node_Str"",contentType);
    attributes.put(""String_Node_Str"",""String_Node_Str"");
    if (configSource.getLocation() != null) {
      attributes.put(""String_Node_Str"",configSource.getLocation());
    }
    advertiserNode=node;
  }
}"
90654,"/** 
 * Retrieve the configuration via the ClassLoader.
 * @param resource The resource to load.
 * @param loader The default ClassLoader to use.
 * @return The ConfigurationSource for the configuration.
 */
protected ConfigurationSource getInputFromResource(final String resource,final ClassLoader loader){
  final URL url=Loader.getResource(resource,loader);
  if (url == null) {
    return null;
  }
  InputStream is=null;
  try {
    is=url.openStream();
  }
 catch (  final IOException ioe) {
    LOGGER.catching(Level.DEBUG,ioe);
    return null;
  }
  if (is == null) {
    return null;
  }
  if (FileUtils.isFile(url)) {
    try {
      return new ConfigurationSource(is,FileUtils.fileFromUri(url.toURI()));
    }
 catch (    final URISyntaxException ex) {
      LOGGER.catching(Level.DEBUG,ex);
    }
  }
  return new ConfigurationSource(is,resource);
}","/** 
 * Retrieve the configuration via the ClassLoader.
 * @param resource The resource to load.
 * @param loader The default ClassLoader to use.
 * @return The ConfigurationSource for the configuration.
 */
protected ConfigurationSource getInputFromResource(final String resource,final ClassLoader loader){
  final URL url=Loader.getResource(resource,loader);
  if (url == null) {
    return null;
  }
  InputStream is=null;
  try {
    is=url.openStream();
  }
 catch (  final IOException ioe) {
    LOGGER.catching(Level.DEBUG,ioe);
    return null;
  }
  if (is == null) {
    return null;
  }
  if (FileUtils.isFile(url)) {
    try {
      return new ConfigurationSource(is,FileUtils.fileFromUri(url.toURI()));
    }
 catch (    final URISyntaxException ex) {
      LOGGER.catching(Level.DEBUG,ex);
    }
  }
  return new ConfigurationSource(is,url);
}"
90655,"/** 
 * Load the configuration from a URI.
 * @param configLocation A URI representing the location of the configuration.
 * @return The ConfigurationSource for the configuration.
 */
protected ConfigurationSource getInputFromUri(final URI configLocation){
  final File configFile=FileUtils.fileFromUri(configLocation);
  if (configFile != null && configFile.exists() && configFile.canRead()) {
    try {
      return new ConfigurationSource(new FileInputStream(configFile),configFile);
    }
 catch (    final FileNotFoundException ex) {
      LOGGER.error(""String_Node_Str"",configLocation.getPath(),ex);
    }
  }
  final String scheme=configLocation.getScheme();
  final boolean isClassLoaderScheme=scheme != null && scheme.equals(CLASS_LOADER_SCHEME);
  final boolean isClassPathScheme=scheme != null && !isClassLoaderScheme && scheme.equals(CLASS_PATH_SCHEME);
  if (scheme == null || isClassLoaderScheme || isClassPathScheme) {
    final ClassLoader loader=Loader.getThreadContextClassLoader();
    String path;
    if (isClassLoaderScheme || isClassPathScheme) {
      path=configLocation.getSchemeSpecificPart();
    }
 else {
      path=configLocation.getPath();
    }
    final ConfigurationSource source=getInputFromResource(path,loader);
    if (source != null) {
      return source;
    }
  }
  try {
    return new ConfigurationSource(configLocation.toURL().openStream(),configLocation.getPath());
  }
 catch (  final MalformedURLException ex) {
    LOGGER.error(""String_Node_Str"",configLocation.toString(),ex);
  }
catch (  final Exception ex) {
    LOGGER.error(""String_Node_Str"",configLocation.toString(),ex);
  }
  return null;
}","/** 
 * Load the configuration from a URI.
 * @param configLocation A URI representing the location of the configuration.
 * @return The ConfigurationSource for the configuration.
 */
protected ConfigurationSource getInputFromUri(final URI configLocation){
  final File configFile=FileUtils.fileFromUri(configLocation);
  if (configFile != null && configFile.exists() && configFile.canRead()) {
    try {
      return new ConfigurationSource(new FileInputStream(configFile),configFile);
    }
 catch (    final FileNotFoundException ex) {
      LOGGER.error(""String_Node_Str"",configLocation.getPath(),ex);
    }
  }
  final String scheme=configLocation.getScheme();
  final boolean isClassLoaderScheme=scheme != null && scheme.equals(CLASS_LOADER_SCHEME);
  final boolean isClassPathScheme=scheme != null && !isClassLoaderScheme && scheme.equals(CLASS_PATH_SCHEME);
  if (scheme == null || isClassLoaderScheme || isClassPathScheme) {
    final ClassLoader loader=Loader.getThreadContextClassLoader();
    String path;
    if (isClassLoaderScheme || isClassPathScheme) {
      path=configLocation.getSchemeSpecificPart();
    }
 else {
      path=configLocation.getPath();
    }
    final ConfigurationSource source=getInputFromResource(path,loader);
    if (source != null) {
      return source;
    }
  }
  try {
    return new ConfigurationSource(configLocation.toURL().openStream(),configLocation.toURL());
  }
 catch (  final MalformedURLException ex) {
    LOGGER.error(""String_Node_Str"",configLocation.toString(),ex);
  }
catch (  final Exception ex) {
    LOGGER.error(""String_Node_Str"",configLocation.toString(),ex);
  }
  return null;
}"
90656,"/** 
 * Initialize the configuration.
 */
@Override public void start(){
  LOGGER.debug(""String_Node_Str"",this);
  this.setStarting();
  pluginManager.collectPlugins();
  final PluginManager levelPlugins=new PluginManager(""String_Node_Str"");
  levelPlugins.collectPlugins();
  final Map<String,PluginType<?>> plugins=levelPlugins.getPlugins();
  if (plugins != null) {
    for (    final PluginType<?> type : plugins.values()) {
      try {
        Loader.initializeClass(type.getPluginClass().getName(),type.getPluginClass().getClassLoader());
      }
 catch (      final Exception ex) {
        LOGGER.error(""String_Node_Str"",type.getPluginClass().getName(),ex.getClass().getSimpleName(),ex.getMessage());
      }
    }
  }
  setup();
  setupAdvertisement();
  doConfigure();
  for (  final LoggerConfig logger : loggers.values()) {
    logger.start();
  }
  for (  final Appender appender : appenders.values()) {
    appender.start();
  }
  root.start();
  super.start();
  LOGGER.debug(""String_Node_Str"",this);
}","/** 
 * Initialize the configuration.
 */
@Override public void start(){
  LOGGER.debug(""String_Node_Str"",this);
  this.setStarting();
  pluginManager.collectPlugins();
  final PluginManager levelPlugins=new PluginManager(""String_Node_Str"");
  levelPlugins.collectPlugins();
  final Map<String,PluginType<?>> plugins=levelPlugins.getPlugins();
  if (plugins != null) {
    for (    final PluginType<?> type : plugins.values()) {
      try {
        Loader.initializeClass(type.getPluginClass().getName(),type.getPluginClass().getClassLoader());
      }
 catch (      final Exception ex) {
        LOGGER.error(""String_Node_Str"",type.getPluginClass().getName(),ex.getClass().getSimpleName(),ex.getMessage());
      }
    }
  }
  setup();
  setupAdvertisement();
  doConfigure();
  final Set<LoggerConfig> alreadyStarted=new HashSet<LoggerConfig>();
  for (  final LoggerConfig logger : loggers.values()) {
    logger.start();
    alreadyStarted.add(logger);
  }
  for (  final Appender appender : appenders.values()) {
    appender.start();
  }
  if (!alreadyStarted.contains(root)) {
    root.start();
  }
  super.start();
  LOGGER.debug(""String_Node_Str"",this);
}"
90657,"/** 
 * Tear down the configuration.
 */
@Override public void stop(){
  this.setStopping();
  LOGGER.trace(""String_Node_Str"",this);
  final LoggerContextFactory factory=LogManager.getFactory();
  if (factory instanceof Log4jContextFactory) {
    ContextSelector selector=((Log4jContextFactory)factory).getSelector();
    if (selector instanceof AsyncLoggerContextSelector) {
    }
  }
  Set<LoggerConfig> alreadyStopped=new HashSet<LoggerConfig>();
  int asyncLoggerConfigCount=0;
  for (  final LoggerConfig logger : loggers.values()) {
    if (logger instanceof AsyncLoggerConfig) {
      logger.stop();
      asyncLoggerConfigCount++;
      alreadyStopped.add(logger);
    }
  }
  if (root instanceof AsyncLoggerConfig) {
    root.stop();
    asyncLoggerConfigCount++;
    alreadyStopped.add(root);
  }
  LOGGER.trace(""String_Node_Str"",asyncLoggerConfigCount);
  final Appender[] array=appenders.values().toArray(new Appender[appenders.size()]);
  int asyncAppenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i] instanceof AsyncAppender) {
      array[i].stop();
      asyncAppenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",asyncAppenderCount);
  int appenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i].isStarted()) {
      array[i].stop();
      appenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",appenderCount);
  int loggerCount=0;
  for (  final LoggerConfig logger : loggers.values()) {
    logger.clearAppenders();
    if (alreadyStopped.contains(logger)) {
      continue;
    }
    logger.stop();
    loggerCount++;
  }
  LOGGER.trace(""String_Node_Str"",loggerCount);
  if (!alreadyStopped.contains(root)) {
    root.stop();
  }
  super.stop();
  if (advertiser != null && advertisement != null) {
    advertiser.unadvertise(advertisement);
  }
  LOGGER.debug(""String_Node_Str"",this);
}","/** 
 * Tear down the configuration.
 */
@Override public void stop(){
  this.setStopping();
  LOGGER.trace(""String_Node_Str"",this);
  final LoggerContextFactory factory=LogManager.getFactory();
  if (factory instanceof Log4jContextFactory) {
    ContextSelector selector=((Log4jContextFactory)factory).getSelector();
    if (selector instanceof AsyncLoggerContextSelector) {
    }
  }
  final Set<LoggerConfig> alreadyStopped=new HashSet<LoggerConfig>();
  int asyncLoggerConfigCount=0;
  for (  final LoggerConfig logger : loggers.values()) {
    if (logger instanceof AsyncLoggerConfig) {
      logger.stop();
      asyncLoggerConfigCount++;
      alreadyStopped.add(logger);
    }
  }
  if (root instanceof AsyncLoggerConfig) {
    root.stop();
    asyncLoggerConfigCount++;
    alreadyStopped.add(root);
  }
  LOGGER.trace(""String_Node_Str"",asyncLoggerConfigCount);
  final Appender[] array=appenders.values().toArray(new Appender[appenders.size()]);
  int asyncAppenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i] instanceof AsyncAppender) {
      array[i].stop();
      asyncAppenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",asyncAppenderCount);
  int appenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i].isStarted()) {
      array[i].stop();
      appenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",appenderCount);
  int loggerCount=0;
  for (  final LoggerConfig logger : loggers.values()) {
    logger.clearAppenders();
    if (alreadyStopped.contains(logger)) {
      continue;
    }
    logger.stop();
    loggerCount++;
  }
  LOGGER.trace(""String_Node_Str"",loggerCount);
  if (!alreadyStopped.contains(root)) {
    root.stop();
  }
  super.stop();
  if (advertiser != null && advertisement != null) {
    advertiser.unadvertise(advertisement);
  }
  LOGGER.debug(""String_Node_Str"",this);
}"
90658,"@Ignore @Test public void testFlushAtEndOfBatch() throws Exception {
  final File file=new File(""String_Node_Str"",""String_Node_Str"");
  file.delete();
  final Logger log=LogManager.getLogger(""String_Node_Str"");
  final String logMsg=""String_Node_Str"";
  log.info(logMsg);
  ((LifeCycle)LogManager.getContext()).stop();
  final BufferedReader reader=new BufferedReader(new FileReader(file));
  String line1;
  try {
    line1=reader.readLine();
  }
  finally {
    reader.close();
    file.delete();
  }
  assertNotNull(""String_Node_Str"",line1);
  final String msg1=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line1 + ""String_Node_Str""+ msg1+ ']',line1.contains(msg1));
  final String msg2=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line1 + ""String_Node_Str""+ msg2+ ']',line1.contains(msg2));
  final String msg3=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line1 + ""String_Node_Str""+ msg3+ ']',line1.contains(msg3));
  final String msg4=logMsg;
  assertTrue(""String_Node_Str"" + line1 + ""String_Node_Str""+ msg4+ ']',line1.contains(msg4));
  final String location=""String_Node_Str"";
  assertTrue(""String_Node_Str"",!line1.contains(location));
  assertTrue(line1.indexOf('\r') == -1);
  assertTrue(line1.indexOf('\n') == -1);
}","@Test public void testFlushAtEndOfBatch() throws Exception {
  final File file=new File(""String_Node_Str"",""String_Node_Str"");
  file.delete();
  final Logger log=LogManager.getLogger(""String_Node_Str"");
  final String logMsg=""String_Node_Str"";
  log.info(logMsg);
  ((LifeCycle)LogManager.getContext()).stop();
  final BufferedReader reader=new BufferedReader(new FileReader(file));
  String line1;
  try {
    line1=reader.readLine();
  }
  finally {
    reader.close();
    file.delete();
  }
  assertNotNull(""String_Node_Str"",line1);
  final String msg1=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line1 + ""String_Node_Str""+ msg1+ ']',line1.contains(msg1));
  final String msg2=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line1 + ""String_Node_Str""+ msg2+ ']',line1.contains(msg2));
  final String msg3=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line1 + ""String_Node_Str""+ msg3+ ']',line1.contains(msg3));
  final String msg4=logMsg;
  assertTrue(""String_Node_Str"" + line1 + ""String_Node_Str""+ msg4+ ']',line1.contains(msg4));
  final String location=""String_Node_Str"";
  assertTrue(""String_Node_Str"",!line1.contains(location));
  assertTrue(line1.indexOf('\r') == -1);
  assertTrue(line1.indexOf('\n') == -1);
}"
90659,"@Ignore @Test public void testFlushAtEndOfBatch() throws Exception {
  final File f=new File(""String_Node_Str"",""String_Node_Str"");
  f.delete();
  final Logger log=LogManager.getLogger(""String_Node_Str"");
  final String logMsg=""String_Node_Str"";
  log.info(logMsg);
  ((LifeCycle)LogManager.getContext()).stop();
  final BufferedReader reader=new BufferedReader(new FileReader(f));
  String line1;
  String line2;
  String line3;
  String line4;
  try {
    line1=reader.readLine();
    line2=reader.readLine();
    line3=reader.readLine();
    line4=reader.readLine();
  }
  finally {
    reader.close();
    f.delete();
  }
  assertNotNull(""String_Node_Str"",line1);
  final String msg1=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line1 + ""String_Node_Str""+ msg1+ ']',line1.equals(msg1));
  assertNotNull(""String_Node_Str"",line2);
  final String msg2=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line2 + ""String_Node_Str""+ msg2+ ']',line2.equals(msg2));
  assertNotNull(""String_Node_Str"",line3);
  final String msg3=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line3 + ""String_Node_Str""+ msg3+ ']',line3.contains(msg3));
  assertNotNull(""String_Node_Str"",line4);
  final String msg4=logMsg;
  assertTrue(""String_Node_Str"" + line4 + ""String_Node_Str""+ msg4+ ']',line4.contains(msg4));
  final String location=""String_Node_Str"";
  assertTrue(""String_Node_Str"",!line1.contains(location));
}","@Test public void testFlushAtEndOfBatch() throws Exception {
  final File f=new File(""String_Node_Str"",""String_Node_Str"");
  f.delete();
  final Logger log=LogManager.getLogger(""String_Node_Str"");
  final String logMsg=""String_Node_Str"";
  log.info(logMsg);
  ((LifeCycle)LogManager.getContext()).stop();
  final BufferedReader reader=new BufferedReader(new FileReader(f));
  String line1;
  String line2;
  String line3;
  String line4;
  try {
    line1=reader.readLine();
    line2=reader.readLine();
    line3=reader.readLine();
    line4=reader.readLine();
  }
  finally {
    reader.close();
    f.delete();
  }
  assertNotNull(""String_Node_Str"",line1);
  final String msg1=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line1 + ""String_Node_Str""+ msg1+ ']',line1.equals(msg1));
  assertNotNull(""String_Node_Str"",line2);
  final String msg2=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line2 + ""String_Node_Str""+ msg2+ ']',line2.equals(msg2));
  assertNotNull(""String_Node_Str"",line3);
  final String msg3=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line3 + ""String_Node_Str""+ msg3+ ']',line3.contains(msg3));
  assertNotNull(""String_Node_Str"",line4);
  final String msg4=logMsg;
  assertTrue(""String_Node_Str"" + line4 + ""String_Node_Str""+ msg4+ ']',line4.contains(msg4));
  final String location=""String_Node_Str"";
  assertTrue(""String_Node_Str"",!line1.contains(location));
}"
90660,"@Ignore @Test public void testFlushAtEndOfBatch() throws Exception {
  final File f=new File(""String_Node_Str"",""String_Node_Str"");
  f.delete();
  final Logger log=LogManager.getLogger(""String_Node_Str"");
  final String logMsg=""String_Node_Str"";
  log.info(logMsg);
  ((LifeCycle)LogManager.getContext()).stop();
  final BufferedReader reader=new BufferedReader(new FileReader(f));
  String line1;
  String line2;
  String line3;
  try {
    line1=reader.readLine();
    line2=reader.readLine();
    line3=reader.readLine();
  }
  finally {
    reader.close();
    f.delete();
  }
  assertNotNull(""String_Node_Str"",line1);
  assertNotNull(""String_Node_Str"",line1);
  final String msg1=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line1 + ""String_Node_Str""+ msg1+ ']',line1.contains(msg1));
  assertNotNull(""String_Node_Str"",line2);
  final String msg2=logMsg;
  assertTrue(""String_Node_Str"" + line2 + ""String_Node_Str""+ msg2+ ']',line2.contains(msg2));
  assertNotNull(""String_Node_Str"",line3);
  final String msg3=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line3 + ""String_Node_Str""+ msg3+ ']',line3.contains(msg3));
  final String location=""String_Node_Str"";
  assertTrue(""String_Node_Str"",!line1.contains(location));
}","@Test public void testFlushAtEndOfBatch() throws Exception {
  final File f=new File(""String_Node_Str"",""String_Node_Str"");
  f.delete();
  final Logger log=LogManager.getLogger(""String_Node_Str"");
  final String logMsg=""String_Node_Str"";
  log.info(logMsg);
  ((LifeCycle)LogManager.getContext()).stop();
  final BufferedReader reader=new BufferedReader(new FileReader(f));
  String line1;
  String line2;
  String line3;
  try {
    line1=reader.readLine();
    line2=reader.readLine();
    line3=reader.readLine();
  }
  finally {
    reader.close();
    f.delete();
  }
  assertNotNull(""String_Node_Str"",line1);
  assertNotNull(""String_Node_Str"",line1);
  final String msg1=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line1 + ""String_Node_Str""+ msg1+ ']',line1.contains(msg1));
  assertNotNull(""String_Node_Str"",line2);
  final String msg2=logMsg;
  assertTrue(""String_Node_Str"" + line2 + ""String_Node_Str""+ msg2+ ']',line2.contains(msg2));
  assertNotNull(""String_Node_Str"",line3);
  final String msg3=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + line3 + ""String_Node_Str""+ msg3+ ']',line3.contains(msg3));
  final String location=""String_Node_Str"";
  assertTrue(""String_Node_Str"",!line1.contains(location));
}"
90661,"/** 
 * Tear down the configuration.
 */
@Override public void stop(){
  this.setStopping();
  LOGGER.trace(""String_Node_Str"");
  final LoggerContextFactory factory=LogManager.getFactory();
  if (factory instanceof Log4jContextFactory) {
    ContextSelector selector=((Log4jContextFactory)factory).getSelector();
    if (selector instanceof AsyncLoggerContextSelector) {
    }
  }
  int asyncLoggerConfigCount=0;
  for (  final LoggerConfig logger : loggers.values()) {
    if (logger instanceof AsyncLoggerConfig) {
      logger.stop();
      asyncLoggerConfigCount++;
    }
  }
  if (root instanceof AsyncLoggerConfig) {
    root.stop();
    asyncLoggerConfigCount++;
  }
  LOGGER.trace(""String_Node_Str"",asyncLoggerConfigCount);
  final Appender[] array=appenders.values().toArray(new Appender[appenders.size()]);
  int asyncAppenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i] instanceof AsyncAppender) {
      array[i].stop();
      asyncAppenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",asyncAppenderCount);
  int appenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i].isStarted()) {
      array[i].stop();
      appenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",appenderCount);
  int loggerCount=0;
  for (  final LoggerConfig logger : loggers.values()) {
    logger.clearAppenders();
    logger.stop();
    loggerCount++;
  }
  LOGGER.trace(""String_Node_Str"",loggerCount);
  root.stop();
  super.stop();
  if (advertiser != null && advertisement != null) {
    advertiser.unadvertise(advertisement);
  }
}","/** 
 * Tear down the configuration.
 */
@Override public void stop(){
  this.setStopping();
  LOGGER.trace(""String_Node_Str"");
  final LoggerContextFactory factory=LogManager.getFactory();
  if (factory instanceof Log4jContextFactory) {
    ContextSelector selector=((Log4jContextFactory)factory).getSelector();
    if (selector instanceof AsyncLoggerContextSelector) {
    }
  }
  Set<LoggerConfig> alreadyStopped=new HashSet<LoggerConfig>();
  int asyncLoggerConfigCount=0;
  for (  final LoggerConfig logger : loggers.values()) {
    if (logger instanceof AsyncLoggerConfig) {
      logger.stop();
      asyncLoggerConfigCount++;
      alreadyStopped.add(logger);
    }
  }
  if (root instanceof AsyncLoggerConfig) {
    root.stop();
    asyncLoggerConfigCount++;
    alreadyStopped.add(root);
  }
  LOGGER.trace(""String_Node_Str"",asyncLoggerConfigCount);
  final Appender[] array=appenders.values().toArray(new Appender[appenders.size()]);
  int asyncAppenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i] instanceof AsyncAppender) {
      array[i].stop();
      asyncAppenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",asyncAppenderCount);
  int appenderCount=0;
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i].isStarted()) {
      array[i].stop();
      appenderCount++;
    }
  }
  LOGGER.trace(""String_Node_Str"",appenderCount);
  int loggerCount=0;
  for (  final LoggerConfig logger : loggers.values()) {
    logger.clearAppenders();
    if (alreadyStopped.contains(logger)) {
      continue;
    }
    logger.stop();
    loggerCount++;
  }
  LOGGER.trace(""String_Node_Str"",loggerCount);
  if (!alreadyStopped.contains(root)) {
    root.stop();
  }
  super.stop();
  if (advertiser != null && advertisement != null) {
    advertiser.unadvertise(advertisement);
  }
}"
90662,"@Override public DatagramSocketManager createManager(final String name,final FactoryData data){
  InetAddress inetAddress;
  final OutputStream os=new DatagramOutputStream(data.host,data.port,data.layout.getHeader(),data.layout.getFooter());
  try {
    inetAddress=InetAddress.getByName(data.host);
  }
 catch (  final UnknownHostException ex) {
    LOGGER.error(""String_Node_Str"" + data.host,ex);
    return null;
  }
  return new DatagramSocketManager(name,os,inetAddress,data.host,data.port,data.layout);
}","@Override public DatagramSocketManager createManager(final String name,final FactoryData data){
  InetAddress inetAddress;
  try {
    inetAddress=InetAddress.getByName(data.host);
  }
 catch (  final UnknownHostException ex) {
    LOGGER.error(""String_Node_Str"" + data.host,ex);
    return null;
  }
  final OutputStream os=new DatagramOutputStream(data.host,data.port,data.layout.getHeader(),data.layout.getFooter());
  return new DatagramSocketManager(name,os,inetAddress,data.host,data.port,data.layout);
}"
90663,"/** 
 * Create a Flume Avro Appender.
 * @param agents An array of Agents.
 * @param properties Properties to pass to the embedded agent.
 * @param embedded true if the embedded agent manager should be used. otherwise the Avro manager will be used.<b>Note: </b><i>The embedded attribute is deprecated in favor of specifying the type attribute.</i>
 * @param type Avro (default), Embedded, or Persistent.
 * @param dataDir The directory where the Flume FileChannel should write its data.
 * @param connectionTimeout The amount of time in milliseconds to wait before a connection times out. Minimum is1000.
 * @param requestTimeout The amount of time in milliseconds to wait before a request times out. Minimum is 1000.
 * @param agentRetries The number of times to retry an agent before failing to the next agent.
 * @param maxDelay The maximum number of seconds to wait for a complete batch.
 * @param name The name of the Appender.
 * @param ignore If {@code ""true""} (default) exceptions encountered when appending events are logged; otherwisethey are propagated to the caller.
 * @param excludes A comma separated list of MDC elements to exclude.
 * @param includes A comma separated list of MDC elements to include.
 * @param required A comma separated list of MDC elements that are required.
 * @param mdcPrefix The prefix to add to MDC key names.
 * @param eventPrefix The prefix to add to event key names.
 * @param compressBody If true the event body will be compressed.
 * @param batchSize Number of events to include in a batch. Defaults to 1.
 * @param lockTimeoutRetries Times to retry a lock timeout when writing to Berkeley DB.
 * @param factory The factory to use to create Flume events.
 * @param layout The layout to format the event.
 * @param filter A Filter to filter events.
 * @return A Flume Avro Appender.
 */
@PluginFactory public static FlumeAppender createAppender(@PluginElement(""String_Node_Str"") Agent[] agents,@PluginElement(""String_Node_Str"") final Property[] properties,@PluginAttribute(""String_Node_Str"") final String embedded,@PluginAttribute(""String_Node_Str"") final String type,@PluginAttribute(""String_Node_Str"") final String dataDir,@PluginAttribute(""String_Node_Str"") final String connectionTimeout,@PluginAttribute(""String_Node_Str"") final String requestTimeout,@PluginAttribute(""String_Node_Str"") final String agentRetries,@PluginAttribute(""String_Node_Str"") final String maxDelay,@PluginAttribute(""String_Node_Str"") final String name,@PluginAttribute(""String_Node_Str"") final String ignore,@PluginAttribute(""String_Node_Str"") final String excludes,@PluginAttribute(""String_Node_Str"") final String includes,@PluginAttribute(""String_Node_Str"") final String required,@PluginAttribute(""String_Node_Str"") final String mdcPrefix,@PluginAttribute(""String_Node_Str"") final String eventPrefix,@PluginAttribute(""String_Node_Str"") final String compressBody,@PluginAttribute(""String_Node_Str"") final String batchSize,@PluginAttribute(""String_Node_Str"") final String lockTimeoutRetries,@PluginElement(""String_Node_Str"") final FlumeEventFactory factory,@PluginElement(""String_Node_Str"") Layout<? extends Serializable> layout,@PluginElement(""String_Node_Str"") final Filter filter){
  final boolean embed=embedded != null ? Boolean.parseBoolean(embedded) : (agents == null || agents.length == 0) && properties != null && properties.length > 0;
  final boolean ignoreExceptions=Booleans.parseBoolean(ignore,true);
  final boolean compress=Booleans.parseBoolean(compressBody,true);
  ManagerType managerType;
  if (type != null) {
    if (embed && embedded != null) {
      try {
        managerType=ManagerType.getType(type);
        LOGGER.warn(""String_Node_Str"" + type);
      }
 catch (      final Exception ex) {
        LOGGER.warn(""String_Node_Str"" + type + ""String_Node_Str"");
        managerType=ManagerType.EMBEDDED;
      }
    }
 else {
      try {
        managerType=ManagerType.getType(type);
      }
 catch (      final Exception ex) {
        LOGGER.warn(""String_Node_Str"" + type + ""String_Node_Str"");
        managerType=ManagerType.EMBEDDED;
      }
    }
  }
 else   if (embed) {
    managerType=ManagerType.EMBEDDED;
  }
 else {
    managerType=ManagerType.AVRO;
  }
  final int batchCount=Integers.parseInt(batchSize,1);
  final int connectTimeout=Integers.parseInt(connectionTimeout,0);
  final int reqTimeout=Integers.parseInt(requestTimeout,0);
  final int retries=Integers.parseInt(agentRetries,0);
  final int lockTimeoutRetryCount=Integers.parseInt(lockTimeoutRetries,DEFAULT_LOCK_TIMEOUT_RETRY_COUNT);
  final int delay=Integers.parseInt(maxDelay,DEFAULT_MAX_DELAY);
  if (layout == null) {
    layout=Rfc5424Layout.createLayout(null,null,null,""String_Node_Str"",null,mdcPrefix,eventPrefix,null,null,null,null,excludes,includes,required,null,null,null,null);
  }
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  AbstractFlumeManager manager;
switch (managerType) {
case EMBEDDED:
    manager=FlumeEmbeddedManager.getManager(name,agents,properties,batchCount,dataDir);
  break;
case AVRO:
if (agents == null || agents.length == 0) {
  LOGGER.debug(""String_Node_Str"");
  agents=new Agent[]{Agent.createAgent(null,null)};
}
manager=FlumeAvroManager.getManager(name,agents,batchCount,retries,connectTimeout,reqTimeout);
break;
case PERSISTENT:
if (agents == null || agents.length == 0) {
LOGGER.debug(""String_Node_Str"");
agents=new Agent[]{Agent.createAgent(null,null)};
}
manager=FlumePersistentManager.getManager(name,agents,properties,batchCount,retries,connectTimeout,reqTimeout,delay,lockTimeoutRetryCount,dataDir);
break;
default :
LOGGER.debug(""String_Node_Str"");
if (agents == null || agents.length == 0) {
LOGGER.debug(""String_Node_Str"");
agents=new Agent[]{Agent.createAgent(null,null)};
}
manager=FlumeAvroManager.getManager(name,agents,batchCount,retries,connectTimeout,reqTimeout);
}
if (manager == null) {
return null;
}
return new FlumeAppender(name,filter,layout,ignoreExceptions,includes,excludes,required,mdcPrefix,eventPrefix,compress,factory,manager);
}","/** 
 * Create a Flume Avro Appender.
 * @param agents An array of Agents.
 * @param properties Properties to pass to the embedded agent.
 * @param embedded true if the embedded agent manager should be used. otherwise the Avro manager will be used.<b>Note: </b><i>The embedded attribute is deprecated in favor of specifying the type attribute.</i>
 * @param type Avro (default), Embedded, or Persistent.
 * @param dataDir The directory where the Flume FileChannel should write its data.
 * @param connectionTimeout The amount of time in milliseconds to wait before a connection times out. Minimum is1000.
 * @param requestTimeout The amount of time in milliseconds to wait before a request times out. Minimum is 1000.
 * @param agentRetries The number of times to retry an agent before failing to the next agent.
 * @param maxDelay The maximum number of seconds to wait for a complete batch.
 * @param name The name of the Appender.
 * @param ignore If {@code ""true""} (default) exceptions encountered when appending events are logged; otherwisethey are propagated to the caller.
 * @param excludes A comma separated list of MDC elements to exclude.
 * @param includes A comma separated list of MDC elements to include.
 * @param required A comma separated list of MDC elements that are required.
 * @param mdcPrefix The prefix to add to MDC key names.
 * @param eventPrefix The prefix to add to event key names.
 * @param compressBody If true the event body will be compressed.
 * @param batchSize Number of events to include in a batch. Defaults to 1.
 * @param lockTimeoutRetries Times to retry a lock timeout when writing to Berkeley DB.
 * @param factory The factory to use to create Flume events.
 * @param layout The layout to format the event.
 * @param filter A Filter to filter events.
 * @return A Flume Avro Appender.
 */
@PluginFactory public static FlumeAppender createAppender(@PluginElement(""String_Node_Str"") Agent[] agents,@PluginElement(""String_Node_Str"") final Property[] properties,@PluginAttribute(""String_Node_Str"") final String embedded,@PluginAttribute(""String_Node_Str"") final String type,@PluginAttribute(""String_Node_Str"") final String dataDir,@PluginAttribute(""String_Node_Str"") final String connectionTimeout,@PluginAttribute(""String_Node_Str"") final String requestTimeout,@PluginAttribute(""String_Node_Str"") final String agentRetries,@PluginAttribute(""String_Node_Str"") final String maxDelay,@PluginAttribute(""String_Node_Str"") final String name,@PluginAttribute(""String_Node_Str"") final String ignore,@PluginAttribute(""String_Node_Str"") final String excludes,@PluginAttribute(""String_Node_Str"") final String includes,@PluginAttribute(""String_Node_Str"") final String required,@PluginAttribute(""String_Node_Str"") final String mdcPrefix,@PluginAttribute(""String_Node_Str"") final String eventPrefix,@PluginAttribute(""String_Node_Str"") final String compressBody,@PluginAttribute(""String_Node_Str"") final String batchSize,@PluginAttribute(""String_Node_Str"") final String lockTimeoutRetries,@PluginElement(""String_Node_Str"") final FlumeEventFactory factory,@PluginElement(""String_Node_Str"") Layout<? extends Serializable> layout,@PluginElement(""String_Node_Str"") final Filter filter){
  final boolean embed=embedded != null ? Boolean.parseBoolean(embedded) : (agents == null || agents.length == 0) && properties != null && properties.length > 0;
  final boolean ignoreExceptions=Booleans.parseBoolean(ignore,true);
  final boolean compress=Booleans.parseBoolean(compressBody,true);
  ManagerType managerType;
  if (type != null) {
    if (embed && embedded != null) {
      try {
        managerType=ManagerType.getType(type);
        LOGGER.warn(""String_Node_Str"" + type);
      }
 catch (      final Exception ex) {
        LOGGER.warn(""String_Node_Str"" + type + ""String_Node_Str"");
        managerType=ManagerType.EMBEDDED;
      }
    }
 else {
      try {
        managerType=ManagerType.getType(type);
      }
 catch (      final Exception ex) {
        LOGGER.warn(""String_Node_Str"" + type + ""String_Node_Str"");
        managerType=ManagerType.EMBEDDED;
      }
    }
  }
 else   if (embed) {
    managerType=ManagerType.EMBEDDED;
  }
 else {
    managerType=ManagerType.AVRO;
  }
  final int batchCount=Integers.parseInt(batchSize,1);
  final int connectTimeout=Integers.parseInt(connectionTimeout,0);
  final int reqTimeout=Integers.parseInt(requestTimeout,0);
  final int retries=Integers.parseInt(agentRetries,0);
  final int lockTimeoutRetryCount=Integers.parseInt(lockTimeoutRetries,DEFAULT_LOCK_TIMEOUT_RETRY_COUNT);
  final int delay=Integers.parseInt(maxDelay,DEFAULT_MAX_DELAY);
  if (layout == null) {
    final int enterpriseNumber=Integer.parseInt(Rfc5424Layout.DEFAULT_ENTERPRISE_NUMBER);
    layout=Rfc5424Layout.createLayout(null,null,enterpriseNumber,true,Rfc5424Layout.DEFAULT_MDCID,mdcPrefix,eventPrefix,false,null,null,null,excludes,includes,required,null,false,null,null);
  }
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  AbstractFlumeManager manager;
switch (managerType) {
case EMBEDDED:
    manager=FlumeEmbeddedManager.getManager(name,agents,properties,batchCount,dataDir);
  break;
case AVRO:
if (agents == null || agents.length == 0) {
  LOGGER.debug(""String_Node_Str"");
  agents=new Agent[]{Agent.createAgent(null,null)};
}
manager=FlumeAvroManager.getManager(name,agents,batchCount,retries,connectTimeout,reqTimeout);
break;
case PERSISTENT:
if (agents == null || agents.length == 0) {
LOGGER.debug(""String_Node_Str"");
agents=new Agent[]{Agent.createAgent(null,null)};
}
manager=FlumePersistentManager.getManager(name,agents,properties,batchCount,retries,connectTimeout,reqTimeout,delay,lockTimeoutRetryCount,dataDir);
break;
default :
LOGGER.debug(""String_Node_Str"");
if (agents == null || agents.length == 0) {
LOGGER.debug(""String_Node_Str"");
agents=new Agent[]{Agent.createAgent(null,null)};
}
manager=FlumeAvroManager.getManager(name,agents,batchCount,retries,connectTimeout,reqTimeout);
}
if (manager == null) {
return null;
}
return new FlumeAppender(name,filter,layout,ignoreExceptions,includes,excludes,required,mdcPrefix,eventPrefix,compress,factory,manager);
}"
90664,"@Test public void testJavaIoSerializable() throws Exception {
  final Log4jLogEvent evt=new Log4jLogEvent(""String_Node_Str"",null,Strings.EMPTY,Level.INFO,new SimpleMessage(""String_Node_Str""),null);
  final ByteArrayOutputStream arr=new ByteArrayOutputStream();
  final ObjectOutputStream out=new ObjectOutputStream(arr);
  out.writeObject(evt);
  final ByteArrayInputStream inArr=new ByteArrayInputStream(arr.toByteArray());
  final ObjectInputStream in=new ObjectInputStream(inArr);
  final Log4jLogEvent evt2=(Log4jLogEvent)in.readObject();
  assertEquals(evt.getTimeMillis(),evt2.getTimeMillis());
  assertEquals(evt.getLoggerFqcn(),evt2.getLoggerFqcn());
  assertEquals(evt.getLevel(),evt2.getLevel());
  assertEquals(evt.getLoggerName(),evt2.getLoggerName());
  assertEquals(evt.getMarker(),evt2.getMarker());
  assertEquals(evt.getContextMap(),evt2.getContextMap());
  assertEquals(evt.getContextStack(),evt2.getContextStack());
  assertEquals(evt.getMessage(),evt2.getMessage());
  assertEquals(evt.getSource(),evt2.getSource());
  assertEquals(evt.getThreadName(),evt2.getThreadName());
  assertEquals(evt.getThrown(),evt2.getThrown());
  assertEquals(evt.isEndOfBatch(),evt2.isEndOfBatch());
  assertEquals(evt.isIncludeLocation(),evt2.isIncludeLocation());
}","@Test public void testJavaIoSerializable() throws Exception {
  final Log4jLogEvent evt=new Log4jLogEvent(""String_Node_Str"",null,Strings.EMPTY,Level.INFO,new SimpleMessage(""String_Node_Str""),null);
  byte[] binary=serialize(evt);
  final Log4jLogEvent evt2=deserialize(binary);
  assertEquals(evt.getTimeMillis(),evt2.getTimeMillis());
  assertEquals(evt.getLoggerFqcn(),evt2.getLoggerFqcn());
  assertEquals(evt.getLevel(),evt2.getLevel());
  assertEquals(evt.getLoggerName(),evt2.getLoggerName());
  assertEquals(evt.getMarker(),evt2.getMarker());
  assertEquals(evt.getContextMap(),evt2.getContextMap());
  assertEquals(evt.getContextStack(),evt2.getContextStack());
  assertEquals(evt.getMessage(),evt2.getMessage());
  assertEquals(evt.getSource(),evt2.getSource());
  assertEquals(evt.getThreadName(),evt2.getThreadName());
  assertEquals(evt.getThrown(),evt2.getThrown());
  assertEquals(evt.isEndOfBatch(),evt2.isEndOfBatch());
  assertEquals(evt.isIncludeLocation(),evt2.isIncludeLocation());
}"
90665,"@Test public void testJavaIoSerializableWithThrown() throws Exception {
  final Error thrown=new InternalError(""String_Node_Str"");
  final Log4jLogEvent evt=new Log4jLogEvent(""String_Node_Str"",null,Strings.EMPTY,Level.INFO,new SimpleMessage(""String_Node_Str""),thrown);
  final ByteArrayOutputStream arr=new ByteArrayOutputStream();
  final ObjectOutputStream out=new ObjectOutputStream(arr);
  out.writeObject(evt);
  final ByteArrayInputStream inArr=new ByteArrayInputStream(arr.toByteArray());
  final ObjectInputStream in=new ObjectInputStream(inArr);
  final Log4jLogEvent evt2=(Log4jLogEvent)in.readObject();
  assertEquals(evt.getTimeMillis(),evt2.getTimeMillis());
  assertEquals(evt.getLoggerFqcn(),evt2.getLoggerFqcn());
  assertEquals(evt.getLevel(),evt2.getLevel());
  assertEquals(evt.getLoggerName(),evt2.getLoggerName());
  assertEquals(evt.getMarker(),evt2.getMarker());
  assertEquals(evt.getContextMap(),evt2.getContextMap());
  assertEquals(evt.getContextStack(),evt2.getContextStack());
  assertEquals(evt.getMessage(),evt2.getMessage());
  assertEquals(evt.getSource(),evt2.getSource());
  assertEquals(evt.getThreadName(),evt2.getThreadName());
  assertEquals(evt.getThrown().getClass(),evt2.getThrown().getClass());
  assertEquals(evt.getThrown().getMessage(),evt2.getThrown().getMessage());
  assertEquals(evt.getThrownProxy(),evt2.getThrownProxy());
  assertEquals(evt.isEndOfBatch(),evt2.isEndOfBatch());
  assertEquals(evt.isIncludeLocation(),evt2.isIncludeLocation());
}","@Test public void testJavaIoSerializableWithThrown() throws Exception {
  final Error thrown=new InternalError(""String_Node_Str"");
  final Log4jLogEvent evt=new Log4jLogEvent(""String_Node_Str"",null,Strings.EMPTY,Level.INFO,new SimpleMessage(""String_Node_Str""),thrown);
  byte[] binary=serialize(evt);
  final Log4jLogEvent evt2=deserialize(binary);
  assertEquals(evt.getTimeMillis(),evt2.getTimeMillis());
  assertEquals(evt.getLoggerFqcn(),evt2.getLoggerFqcn());
  assertEquals(evt.getLevel(),evt2.getLevel());
  assertEquals(evt.getLoggerName(),evt2.getLoggerName());
  assertEquals(evt.getMarker(),evt2.getMarker());
  assertEquals(evt.getContextMap(),evt2.getContextMap());
  assertEquals(evt.getContextStack(),evt2.getContextStack());
  assertEquals(evt.getMessage(),evt2.getMessage());
  assertEquals(evt.getSource(),evt2.getSource());
  assertEquals(evt.getThreadName(),evt2.getThreadName());
  assertNull(evt2.getThrown());
  assertNotNull(evt2.getThrownProxy());
  assertEquals(evt.getThrownProxy(),evt2.getThrownProxy());
  assertEquals(evt.isEndOfBatch(),evt2.isEndOfBatch());
  assertEquals(evt.isIncludeLocation(),evt2.isIncludeLocation());
}"
90666,"private ThrowableProxy[] toSuppressedProxies(final Throwable thrown){
  try {
    final Throwable[] suppressed=Throwables.getSuppressed(thrown);
    if (suppressed == null) {
      return null;
    }
    final ThrowableProxy[] proxies=new ThrowableProxy[suppressed.length];
    for (int i=0; i < suppressed.length; i++) {
      proxies[i]=new ThrowableProxy(suppressed[i]);
    }
    return proxies;
  }
 catch (  final Exception e) {
    StatusLogger.getLogger().error(e);
  }
  return null;
}","private ThrowableProxy[] toSuppressedProxies(final Throwable thrown){
  try {
    final Throwable[] suppressed=Throwables.getSuppressed(thrown);
    if (suppressed == null) {
      return EMPTY_THROWABLE_PROXY_ARRAY;
    }
    final ThrowableProxy[] proxies=new ThrowableProxy[suppressed.length];
    for (int i=0; i < suppressed.length; i++) {
      proxies[i]=new ThrowableProxy(suppressed[i]);
    }
    return proxies;
  }
 catch (  final Exception e) {
    StatusLogger.getLogger().error(e);
  }
  return null;
}"
90667,"private void testAllFeatures(final boolean includeSource,final boolean compact,final boolean includeContext) throws Exception {
  final Log4jLogEvent expected=LogEventFixtures.createLogEvent();
  final AbstractJacksonLayout layout=JSONLayout.createLayout(Boolean.toString(includeSource),Boolean.toString(includeContext),""String_Node_Str"",Boolean.toString(compact),""String_Node_Str"");
  final String str=layout.toSerializable(expected);
  final String propSep=this.toPropertySeparator(compact);
  assertEquals(str,!compact,str.contains(""String_Node_Str""));
  assertEquals(str,includeSource,str.contains(""String_Node_Str""));
  assertEquals(str,includeContext,str.contains(""String_Node_Str""));
  final Log4jLogEvent actual=new Log4jJsonObjectMapper().readValue(str,Log4jLogEvent.class);
  LogEventFixtures.assertEqualLogEvents(expected,actual,includeSource,includeContext);
  if (includeContext) {
    this.checkMapEntry(""String_Node_Str"",""String_Node_Str"",compact,str);
    this.checkMapEntry(""String_Node_Str"",""String_Node_Str"",compact,str);
  }
  assertNull(actual.getThrown());
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  if (includeContext) {
    this.checkPropertyName(""String_Node_Str"",compact,str);
  }
  this.checkPropertyName(""String_Node_Str"",compact,str);
  if (includeSource) {
    this.checkPropertyName(""String_Node_Str"",compact,str);
  }
  this.checkProperty(""String_Node_Str"",""String_Node_Str"",compact,str);
  this.checkProperty(""String_Node_Str"",""String_Node_Str"",compact,str);
}","private void testAllFeatures(final boolean includeSource,final boolean compact,final boolean includeContext) throws Exception {
  final Log4jLogEvent expected=LogEventFixtures.createLogEvent();
  final AbstractJacksonLayout layout=JSONLayout.createLayout(Boolean.toString(includeSource),Boolean.toString(includeContext),""String_Node_Str"",Boolean.toString(compact),""String_Node_Str"");
  final String str=layout.toSerializable(expected);
  final String propSep=this.toPropertySeparator(compact);
  assertEquals(str,!compact,str.contains(""String_Node_Str""));
  assertEquals(str,includeSource,str.contains(""String_Node_Str""));
  assertEquals(str,includeContext,str.contains(""String_Node_Str""));
  final Log4jLogEvent actual=new Log4jJsonObjectMapper().readValue(str,Log4jLogEvent.class);
  LogEventFixtures.assertEqualLogEvents(expected,actual,includeSource,includeContext);
  if (includeContext) {
    this.checkMapEntry(""String_Node_Str"",""String_Node_Str"",compact,str);
    this.checkMapEntry(""String_Node_Str"",""String_Node_Str"",compact,str);
  }
  assertNull(actual.getThrown());
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  if (Throwables.isSuppressedAvailable()) {
    this.checkPropertyName(""String_Node_Str"",compact,str);
  }
  this.checkPropertyName(""String_Node_Str"",compact,str);
  this.checkPropertyName(""String_Node_Str"",compact,str);
  if (includeContext) {
    this.checkPropertyName(""String_Node_Str"",compact,str);
  }
  this.checkPropertyName(""String_Node_Str"",compact,str);
  if (includeSource) {
    this.checkPropertyName(""String_Node_Str"",compact,str);
  }
  this.checkProperty(""String_Node_Str"",""String_Node_Str"",compact,str);
  this.checkProperty(""String_Node_Str"",""String_Node_Str"",compact,str);
}"
90668,"/** 
 * @param includeSource TODO
 * @param compact
 * @param includeContext TODO
 * @throws IOException
 * @throws JsonParseException
 * @throws JsonMappingException
 */
private void testAllFeatures(final boolean includeSource,final boolean compact,final boolean includeContext) throws IOException, JsonParseException, JsonMappingException {
  final Log4jLogEvent expected=LogEventFixtures.createLogEvent();
  final XMLLayout layout=XMLLayout.createLayout(Boolean.toString(includeSource),Boolean.toString(includeContext),""String_Node_Str"",Boolean.toString(compact),""String_Node_Str"");
  final String str=layout.toSerializable(expected);
  assertEquals(str,!compact,str.contains(""String_Node_Str""));
  assertEquals(str,includeSource,str.contains(""String_Node_Str""));
  assertEquals(str,includeContext,str.contains(""String_Node_Str""));
  final Log4jLogEvent actual=new Log4jXmlObjectMapper().readValue(str,Log4jLogEvent.class);
  LogEventFixtures.assertEqualLogEvents(expected,actual,includeSource,includeContext);
  if (includeContext) {
    this.checkElement(""String_Node_Str"",""String_Node_Str"",compact,str);
    this.checkElement(""String_Node_Str"",""String_Node_Str"",compact,str);
  }
  assertNull(actual.getThrown());
  assertTrue(str,str.contains(""String_Node_Str""));
  assertTrue(str,str.contains(""String_Node_Str""));
  assertTrue(str,str.contains(""String_Node_Str""));
  assertTrue(str,str.contains(""String_Node_Str""));
  assertTrue(str,str.contains(""String_Node_Str""));
  assertTrue(str,str.contains(""String_Node_Str""));
  assertTrue(str,str.contains(""String_Node_Str""));
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkElementName(""String_Node_Str"",compact,str,true,true);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkElementName(""String_Node_Str"",compact,str,false,true);
  this.checkElementName(""String_Node_Str"",compact,str,false,true);
  this.checkElementName(""String_Node_Str"",compact,str,true,true);
  this.checkElementName(""String_Node_Str"",compact,str,true,true);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkElementName(""String_Node_Str"",compact,str,false,true);
  this.checkElementName(""String_Node_Str"",compact,str,false,true);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  if (includeContext) {
    this.checkElementName(""String_Node_Str"",compact,str,false,true);
  }
  this.checkElementName(""String_Node_Str"",compact,str,false,true);
  if (includeSource) {
    this.checkElementName(""String_Node_Str"",compact,str,true,false);
  }
  this.checkAttribute(""String_Node_Str"",""String_Node_Str"",compact,str);
  this.checkAttribute(""String_Node_Str"",""String_Node_Str"",compact,str);
}","/** 
 * @param includeSource TODO
 * @param compact
 * @param includeContext TODO
 * @throws IOException
 * @throws JsonParseException
 * @throws JsonMappingException
 */
private void testAllFeatures(final boolean includeSource,final boolean compact,final boolean includeContext) throws IOException, JsonParseException, JsonMappingException {
  final Log4jLogEvent expected=LogEventFixtures.createLogEvent();
  final XMLLayout layout=XMLLayout.createLayout(Boolean.toString(includeSource),Boolean.toString(includeContext),""String_Node_Str"",Boolean.toString(compact),""String_Node_Str"");
  final String str=layout.toSerializable(expected);
  assertEquals(str,!compact,str.contains(""String_Node_Str""));
  assertEquals(str,includeSource,str.contains(""String_Node_Str""));
  assertEquals(str,includeContext,str.contains(""String_Node_Str""));
  final Log4jLogEvent actual=new Log4jXmlObjectMapper().readValue(str,Log4jLogEvent.class);
  LogEventFixtures.assertEqualLogEvents(expected,actual,includeSource,includeContext);
  if (includeContext) {
    this.checkElement(""String_Node_Str"",""String_Node_Str"",compact,str);
    this.checkElement(""String_Node_Str"",""String_Node_Str"",compact,str);
  }
  assertNull(actual.getThrown());
  assertTrue(str,str.contains(""String_Node_Str""));
  assertTrue(str,str.contains(""String_Node_Str""));
  assertTrue(str,str.contains(""String_Node_Str""));
  assertTrue(str,str.contains(""String_Node_Str""));
  assertTrue(str,str.contains(""String_Node_Str""));
  assertTrue(str,str.contains(""String_Node_Str""));
  assertTrue(str,str.contains(""String_Node_Str""));
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkElementName(""String_Node_Str"",compact,str,true,true);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkElementName(""String_Node_Str"",compact,str,false,true);
  this.checkElementName(""String_Node_Str"",compact,str,false,true);
  this.checkElementName(""String_Node_Str"",compact,str,true,true);
  this.checkElementName(""String_Node_Str"",compact,str,true,true);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkElementName(""String_Node_Str"",compact,str,false,true);
  if (Throwables.isSuppressedAvailable()) {
    this.checkElementName(""String_Node_Str"",compact,str,false,true);
  }
  this.checkAttributeName(""String_Node_Str"",compact,str);
  this.checkAttributeName(""String_Node_Str"",compact,str);
  if (includeContext) {
    this.checkElementName(""String_Node_Str"",compact,str,false,true);
  }
  this.checkElementName(""String_Node_Str"",compact,str,false,true);
  if (includeSource) {
    this.checkElementName(""String_Node_Str"",compact,str,true,false);
  }
  this.checkAttribute(""String_Node_Str"",""String_Node_Str"",compact,str);
  this.checkAttribute(""String_Node_Str"",""String_Node_Str"",compact,str);
}"
90669,"public static void stop(){
  final Disruptor<RingBufferLogEvent> temp=disruptor;
  disruptor=null;
  if (temp == null) {
    return;
  }
  temp.shutdown();
  final RingBuffer<RingBufferLogEvent> ringBuffer=temp.getRingBuffer();
  for (int i=0; i < MAX_DRAIN_ATTEMPTS_BEFORE_SHUTDOWN; i++) {
    if (ringBuffer.hasAvailableCapacity(ringBuffer.getBufferSize())) {
      break;
    }
    try {
      Thread.sleep(SLEEP_MILLIS_BETWEEN_DRAIN_ATTEMPTS);
    }
 catch (    final InterruptedException e) {
    }
  }
  executor.shutdown();
  threadlocalInfo.remove();
}","public static void stop(){
  final Disruptor<RingBufferLogEvent> temp=disruptor;
  disruptor=null;
  if (temp == null) {
    return;
  }
  for (int i=0; hasBacklog(temp) && i < MAX_DRAIN_ATTEMPTS_BEFORE_SHUTDOWN; i++) {
    try {
      Thread.sleep(SLEEP_MILLIS_BETWEEN_DRAIN_ATTEMPTS);
    }
 catch (    final InterruptedException e) {
    }
  }
  temp.shutdown();
  executor.shutdown();
  threadlocalInfo.remove();
}"
90670,"/** 
 * Decreases the reference count. If the reference count reached zero, the Disruptor and its associated thread are shut down and their references set to   {@code null}.
 */
synchronized static void release(){
  if (--count > 0) {
    LOGGER.trace(""String_Node_Str"",count);
    return;
  }
  final Disruptor<Log4jEventWrapper> temp=disruptor;
  if (temp == null) {
    LOGGER.trace(""String_Node_Str"",count);
    return;
  }
  LOGGER.trace(""String_Node_Str"",count);
  disruptor=null;
  temp.shutdown();
  final RingBuffer<Log4jEventWrapper> ringBuffer=temp.getRingBuffer();
  for (int i=0; i < MAX_DRAIN_ATTEMPTS_BEFORE_SHUTDOWN; i++) {
    if (ringBuffer.hasAvailableCapacity(ringBuffer.getBufferSize())) {
      break;
    }
    try {
      Thread.sleep(HALF_A_SECOND);
    }
 catch (    final InterruptedException e) {
    }
  }
  executor.shutdown();
  executor=null;
}","/** 
 * Decreases the reference count. If the reference count reached zero, the Disruptor and its associated thread are shut down and their references set to   {@code null}.
 */
synchronized static void release(){
  if (--count > 0) {
    LOGGER.trace(""String_Node_Str"",count);
    return;
  }
  final Disruptor<Log4jEventWrapper> temp=disruptor;
  if (temp == null) {
    LOGGER.trace(""String_Node_Str"",count);
    count=0;
    return;
  }
  LOGGER.trace(""String_Node_Str"",count);
  disruptor=null;
  for (int i=0; hasBacklog(temp) && i < MAX_DRAIN_ATTEMPTS_BEFORE_SHUTDOWN; i++) {
    try {
      Thread.sleep(SLEEP_MILLIS_BETWEEN_DRAIN_ATTEMPTS);
    }
 catch (    final InterruptedException e) {
    }
  }
  temp.shutdown();
  executor.shutdown();
  executor=null;
}"
90671,"/** 
 * Tear down the configuration.
 */
@Override public void stop(){
  final LoggerContextFactory factory=LogManager.getFactory();
  if (factory instanceof Log4jContextFactory) {
    ContextSelector selector=((Log4jContextFactory)factory).getSelector();
    if (selector instanceof AsyncLoggerContextSelector) {
    }
  }
  Set<LoggerConfig> alreadyStopped=new HashSet<LoggerConfig>();
  for (  final LoggerConfig logger : loggers.values()) {
    if (logger instanceof AsyncLoggerConfig) {
      logger.clearAppenders();
      logger.stopFilter();
      alreadyStopped.add(logger);
    }
  }
  if (root instanceof AsyncLoggerConfig) {
    root.stopFilter();
    alreadyStopped.add(root);
  }
  final Appender[] array=appenders.values().toArray(new Appender[appenders.size()]);
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i] instanceof AsyncAppender) {
      array[i].stop();
    }
  }
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i].isStarted()) {
      array[i].stop();
    }
  }
  for (  final LoggerConfig logger : loggers.values()) {
    if (alreadyStopped.contains(logger)) {
      continue;
    }
    logger.clearAppenders();
    logger.stopFilter();
  }
  if (!alreadyStopped.contains(root)) {
    root.stopFilter();
  }
  stopFilter();
  if (advertiser != null && advertisement != null) {
    advertiser.unadvertise(advertisement);
  }
}","/** 
 * Tear down the configuration.
 */
@Override public void stop(){
  final LoggerContextFactory factory=LogManager.getFactory();
  if (factory instanceof Log4jContextFactory) {
    ContextSelector selector=((Log4jContextFactory)factory).getSelector();
    if (selector instanceof AsyncLoggerContextSelector) {
    }
  }
  for (  final LoggerConfig logger : loggers.values()) {
    if (logger instanceof AsyncLoggerConfig) {
      logger.stopFilter();
    }
  }
  if (root instanceof AsyncLoggerConfig) {
    root.stopFilter();
  }
  final Appender[] array=appenders.values().toArray(new Appender[appenders.size()]);
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i] instanceof AsyncAppender) {
      array[i].stop();
    }
  }
  for (int i=array.length - 1; i >= 0; --i) {
    if (array[i].isStarted()) {
      array[i].stop();
    }
  }
  for (  final LoggerConfig logger : loggers.values()) {
    logger.clearAppenders();
    logger.stopFilter();
  }
  root.stopFilter();
  stopFilter();
  if (advertiser != null && advertisement != null) {
    advertiser.unadvertise(advertisement);
  }
}"
90672,"@Test public void testConfig(){
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  final LoggerContext ctx=this.init.getContext();
  ctx.reconfigure();
  final Configuration config=ctx.getConfiguration();
  assertTrue(""String_Node_Str"",config instanceof XMLConfiguration);
  assertSame(StatusLogger.getLogger().getLevel(),Level.INFO);
  Layout<? extends Serializable> layout=PatternLayout.createLayout(PatternLayout.SIMPLE_CONVERSION_PATTERN,config,null,null,null,null,null,null);
  Appender appender=FileAppender.createAppender(LOG_FILE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",layout,null,""String_Node_Str"",null,config);
  appender.start();
  config.addAppender(appender);
  AppenderRef ref=AppenderRef.createAppenderRef(""String_Node_Str"",null,null);
  AppenderRef[] refs=new AppenderRef[]{ref};
  LoggerConfig loggerConfig=LoggerConfig.createLogger(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",refs,null,config,null);
  loggerConfig.addAppender(appender,null,null);
  config.addLogger(""String_Node_Str"",loggerConfig);
  ctx.updateLoggers();
  Logger logger=ctx.getLogger(CustomConfigurationTest.class.getName());
  logger.info(""String_Node_Str"");
  final File file=new File(LOG_FILE);
  assertTrue(""String_Node_Str"",file.exists());
  assertTrue(""String_Node_Str"",file.length() > 0);
}","@Test public void testConfig(){
  final LoggerContext ctx=this.init.getContext();
  ctx.reconfigure();
  final Configuration config=ctx.getConfiguration();
  assertTrue(""String_Node_Str"",config instanceof XMLConfiguration);
  for (  StatusListener listener : StatusLogger.getLogger().getListeners()) {
    if (listener instanceof StatusConsoleListener) {
      assertSame(listener.getStatusLevel(),Level.INFO);
      break;
    }
  }
  Layout<? extends Serializable> layout=PatternLayout.createLayout(PatternLayout.SIMPLE_CONVERSION_PATTERN,config,null,null,null,null,null,null);
  Appender appender=FileAppender.createAppender(LOG_FILE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",layout,null,""String_Node_Str"",null,config);
  appender.start();
  config.addAppender(appender);
  AppenderRef ref=AppenderRef.createAppenderRef(""String_Node_Str"",null,null);
  AppenderRef[] refs=new AppenderRef[]{ref};
  LoggerConfig loggerConfig=LoggerConfig.createLogger(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",refs,null,config,null);
  loggerConfig.addAppender(appender,null,null);
  config.addLogger(""String_Node_Str"",loggerConfig);
  ctx.updateLoggers();
  Logger logger=ctx.getLogger(CustomConfigurationTest.class.getName());
  logger.info(""String_Node_Str"");
  final File file=new File(LOG_FILE);
  assertTrue(""String_Node_Str"",file.exists());
  assertTrue(""String_Node_Str"",file.length() > 0);
}"
90673,"private static void encode(final ConcurrentMap<String,ConcurrentMap<String,PluginType<?>>> map){
  final String fileName=rootDir + PATH + FILENAME;
  DataOutputStream dos=null;
  try {
    final File file=new File(rootDir + PATH);
    file.mkdirs();
    final FileOutputStream fos=new FileOutputStream(fileName);
    final BufferedOutputStream bos=new BufferedOutputStream(fos);
    dos=new DataOutputStream(bos);
    dos.writeInt(map.size());
    for (    final Map.Entry<String,ConcurrentMap<String,PluginType<?>>> outer : map.entrySet()) {
      dos.writeUTF(outer.getKey());
      dos.writeInt(outer.getValue().size());
      for (      final Map.Entry<String,PluginType<?>> entry : outer.getValue().entrySet()) {
        dos.writeUTF(entry.getKey());
        final PluginType<?> pt=entry.getValue();
        dos.writeUTF(pt.getPluginClass().getName());
        dos.writeUTF(pt.getElementName());
        dos.writeBoolean(pt.isObjectPrintable());
        dos.writeBoolean(pt.isDeferChildren());
      }
    }
  }
 catch (  final Exception ex) {
    ex.printStackTrace();
  }
 finally {
    Closer.closeSilent(dos);
  }
}","private static void encode(final ConcurrentMap<String,ConcurrentMap<String,PluginType<?>>> map){
  final String fileName=rootDir + PATH + FILENAME;
  final File file=new File(rootDir + PATH);
  file.mkdirs();
  try {
    final DataOutputStream dos=new DataOutputStream(new BufferedOutputStream(new FileOutputStream(fileName)));
    try {
      dos.writeInt(map.size());
      for (      final Map.Entry<String,ConcurrentMap<String,PluginType<?>>> outer : map.entrySet()) {
        dos.writeUTF(outer.getKey());
        dos.writeInt(outer.getValue().size());
        for (        final Map.Entry<String,PluginType<?>> entry : outer.getValue().entrySet()) {
          dos.writeUTF(entry.getKey());
          final PluginType<?> pt=entry.getValue();
          dos.writeUTF(pt.getPluginClass().getName());
          dos.writeUTF(pt.getElementName());
          dos.writeBoolean(pt.isObjectPrintable());
          dos.writeBoolean(pt.isDeferChildren());
        }
      }
    }
 catch (    IOException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
 finally {
      Closer.closeSilent(dos);
    }
  }
 catch (  FileNotFoundException e) {
    LOGGER.error(""String_Node_Str"",fileName,e);
  }
}"
90674,"@Override public String toString(){
  final StringBuilder msg=new StringBuilder(""String_Node_Str"" + Plugin.class.getSimpleName());
  if (isA != null) {
    msg.append(""String_Node_Str"" + isA.getSimpleName());
  }
  return msg.toString();
}","@Override public String toString(){
  final StringBuilder msg=new StringBuilder(""String_Node_Str"").append(Plugin.class.getSimpleName());
  if (isA != null) {
    msg.append(""String_Node_Str"").append(isA.getSimpleName());
  }
  return msg.toString();
}"
90675,"@SuppressWarnings({""String_Node_Str""}) private static ConcurrentMap<String,ConcurrentMap<String,PluginType<?>>> decode(final ClassLoader classLoader){
  Enumeration<URL> resources;
  try {
    resources=classLoader.getResources(PATH + FILENAME);
  }
 catch (  final IOException ioe) {
    LOGGER.warn(""String_Node_Str"",ioe);
    return null;
  }
  final ConcurrentMap<String,ConcurrentMap<String,PluginType<?>>> map=new ConcurrentHashMap<String,ConcurrentMap<String,PluginType<?>>>();
  while (resources.hasMoreElements()) {
    DataInputStream dis=null;
    try {
      final URL url=resources.nextElement();
      LOGGER.debug(""String_Node_Str"",url.toExternalForm());
      final InputStream is=url.openStream();
      final BufferedInputStream bis=new BufferedInputStream(is);
      dis=new DataInputStream(bis);
      final int count=dis.readInt();
      for (int j=0; j < count; ++j) {
        final String type=dis.readUTF();
        final int entries=dis.readInt();
        ConcurrentMap<String,PluginType<?>> types=map.get(type);
        if (types == null) {
          types=new ConcurrentHashMap<String,PluginType<?>>(count);
        }
        for (int i=0; i < entries; ++i) {
          final String key=dis.readUTF();
          final String className=dis.readUTF();
          final String name=dis.readUTF();
          final boolean printable=dis.readBoolean();
          final boolean defer=dis.readBoolean();
          final Class<?> clazz=Class.forName(className);
          types.put(key,new PluginType(clazz,name,printable,defer));
        }
        map.putIfAbsent(type,types);
      }
    }
 catch (    final Exception ex) {
      LOGGER.warn(""String_Node_Str"",ex);
      return null;
    }
 finally {
      Closer.closeSilent(dis);
    }
  }
  return map.size() == 0 ? null : map;
}","private static ConcurrentMap<String,ConcurrentMap<String,PluginType<?>>> decode(final ClassLoader classLoader){
  Enumeration<URL> resources;
  try {
    resources=classLoader.getResources(PATH + FILENAME);
  }
 catch (  final IOException ioe) {
    LOGGER.warn(""String_Node_Str"",ioe);
    return null;
  }
  final ConcurrentMap<String,ConcurrentMap<String,PluginType<?>>> map=new ConcurrentHashMap<String,ConcurrentMap<String,PluginType<?>>>();
  while (resources.hasMoreElements()) {
    final URL url=resources.nextElement();
    LOGGER.debug(""String_Node_Str"",url.toExternalForm());
    InputStream is;
    try {
      is=url.openStream();
    }
 catch (    final IOException e) {
      LOGGER.warn(""String_Node_Str"",url.toExternalForm(),e);
      continue;
    }
    final DataInputStream dis=new DataInputStream(new BufferedInputStream(is));
    try {
      final int count=dis.readInt();
      for (int j=0; j < count; ++j) {
        final String type=dis.readUTF();
        final int entries=dis.readInt();
        ConcurrentMap<String,PluginType<?>> types=map.get(type);
        if (types == null) {
          types=new ConcurrentHashMap<String,PluginType<?>>(count);
        }
        for (int i=0; i < entries; ++i) {
          final String key=dis.readUTF();
          final String className=dis.readUTF();
          final String name=dis.readUTF();
          final boolean printable=dis.readBoolean();
          final boolean defer=dis.readBoolean();
          try {
            final PluginType<?> pluginType=loadPluginType(className,name,printable,defer);
            types.put(key,pluginType);
          }
 catch (          final ClassNotFoundException e) {
            LOGGER.info(""String_Node_Str"",className,e);
          }
        }
        map.putIfAbsent(type,types);
      }
    }
 catch (    final IOException ex) {
      LOGGER.warn(""String_Node_Str"",ex);
    }
 finally {
      Closer.closeSilent(dis);
    }
  }
  return map.isEmpty() ? null : map;
}"
90676,"protected PluginAliasesElementVisitor(){
  super(Collections.<PluginEntry>emptyList());
}","private PluginAliasesElementVisitor(final Elements elements){
  super(Collections.<PluginEntry>emptyList());
  this.elements=elements;
}"
90677,"private void collectPlugins(final Iterable<? extends Element> elements){
  for (  final Element element : elements) {
    final Plugin plugin=element.getAnnotation(Plugin.class);
    final PluginEntry entry=element.accept(pluginVisitor,plugin);
    pluginCategories.putIfAbsent(entry.getCategory(),new ConcurrentHashMap<String,PluginEntry>());
    final ConcurrentMap<String,PluginEntry> category=pluginCategories.get(entry.getCategory());
    category.put(entry.getKey(),entry);
    final Collection<PluginEntry> entries=element.accept(pluginAliasesVisitor,plugin);
    for (    final PluginEntry pluginEntry : entries) {
      category.put(pluginEntry.getKey(),pluginEntry);
    }
  }
}","private void collectPlugins(final Iterable<? extends Element> elements){
  final Elements elementUtils=processingEnv.getElementUtils();
  final ElementVisitor<PluginEntry,Plugin> pluginVisitor=new PluginElementVisitor(elementUtils);
  final ElementVisitor<Collection<PluginEntry>,Plugin> pluginAliasesVisitor=new PluginAliasesElementVisitor(elementUtils);
  for (  final Element element : elements) {
    final Plugin plugin=element.getAnnotation(Plugin.class);
    final PluginEntry entry=element.accept(pluginVisitor,plugin);
    pluginCategories.putIfAbsent(entry.getCategory(),new ConcurrentHashMap<String,PluginEntry>());
    final ConcurrentMap<String,PluginEntry> category=pluginCategories.get(entry.getCategory());
    category.put(entry.getKey(),entry);
    final Collection<PluginEntry> entries=element.accept(pluginAliasesVisitor,plugin);
    for (    final PluginEntry pluginEntry : entries) {
      category.put(pluginEntry.getKey(),pluginEntry);
    }
  }
}"
90678,"@Override public Collection<PluginEntry> visitType(final TypeElement e,final Plugin plugin){
  final PluginAliases aliases=e.getAnnotation(PluginAliases.class);
  if (aliases == null) {
    return DEFAULT_VALUE;
  }
  final Collection<PluginEntry> entries=new ArrayList<PluginEntry>(aliases.value().length);
  for (  final String alias : aliases.value()) {
    final PluginEntry entry=new PluginEntry();
    entry.setKey(alias.toLowerCase());
    entry.setClassName(e.getQualifiedName().toString());
    entry.setName(Plugin.EMPTY.equals(plugin.elementType()) ? alias : plugin.elementType());
    entry.setPrintable(plugin.printObject());
    entry.setDefer(plugin.deferChildren());
    entry.setCategory(plugin.category());
    entries.add(entry);
  }
  return entries;
}","@Override public Collection<PluginEntry> visitType(final TypeElement e,final Plugin plugin){
  final PluginAliases aliases=e.getAnnotation(PluginAliases.class);
  if (aliases == null) {
    return DEFAULT_VALUE;
  }
  final Collection<PluginEntry> entries=new ArrayList<PluginEntry>(aliases.value().length);
  for (  final String alias : aliases.value()) {
    final PluginEntry entry=new PluginEntry();
    entry.setKey(alias.toLowerCase());
    entry.setClassName(elements.getBinaryName(e).toString());
    entry.setName(Plugin.EMPTY.equals(plugin.elementType()) ? alias : plugin.elementType());
    entry.setPrintable(plugin.printObject());
    entry.setDefer(plugin.deferChildren());
    entry.setCategory(plugin.category());
    entries.add(entry);
  }
  return entries;
}"
90679,"private void verifyFakePluginEntry(final String name,final PluginEntry fake){
  assertNotNull(""String_Node_Str"" + name.toLowerCase() + ""String_Node_Str"",fake);
  assertEquals(FakePlugin.class.getName(),fake.getClassName());
  assertEquals(name.toLowerCase(),fake.getKey());
  assertEquals(""String_Node_Str"",p.elementType());
  assertEquals(name,fake.getName());
  assertEquals(p.printObject(),fake.isPrintable());
  assertEquals(p.deferChildren(),fake.isDefer());
}","private void verifyFakePluginEntry(final String name,final PluginEntry fake){
  assertNotNull(""String_Node_Str"" + name.toLowerCase() + ""String_Node_Str"",fake);
  assertEquals(FakePlugin.class.getName(),fake.getClassName());
  assertEquals(name.toLowerCase(),fake.getKey());
  assertEquals(Plugin.EMPTY,p.elementType());
  assertEquals(name,fake.getName());
  assertEquals(p.printObject(),fake.isPrintable());
  assertEquals(p.deferChildren(),fake.isDefer());
}"
90680,"@Test public void testLogToFile() throws Exception {
  final Logger logger=this.ctx.getLogger(FILE_LOGGER_NAME);
  final long random=ThreadLocalRandom.current().nextLong();
  logger.debug(""String_Node_Str"",random);
  int count=0;
  String line=""String_Node_Str"";
  final BufferedReader in=new BufferedReader(new FileReader(this.logFileName));
  try {
    while (in.ready()) {
      ++count;
      line=in.readLine();
    }
  }
  finally {
    in.close();
  }
  assertThat(count,is(equalTo(1)));
  assertThat(line,endsWith(Long.toString(random)));
}","@Test public void testLogToFile() throws Exception {
  final Logger logger=this.ctx.getLogger(FILE_LOGGER_NAME);
  final long random=this.random.nextLong();
  logger.debug(""String_Node_Str"",random);
  int count=0;
  String line=""String_Node_Str"";
  final BufferedReader in=new BufferedReader(new FileReader(this.logFileName));
  try {
    while (in.ready()) {
      ++count;
      line=in.readLine();
    }
  }
  finally {
    in.close();
  }
  assertThat(count,is(equalTo(1)));
  assertThat(line,endsWith(Long.toString(random)));
}"
90681,"/** 
 * Add an event.
 * @param marker The Marker
 * @param fqcn   The fully qualified class name of the <b>caller</b>
 * @param level  The logging level
 * @param msg    The message associated with the event.
 * @param t      A Throwable or null.
 */
@Override public void logMessage(final String fqcn,final Level level,final Marker marker,final Message msg,final Throwable t){
  StackTraceElement element=null;
  if (fqcn != null) {
    element=getStackTraceElement(fqcn,Thread.currentThread().getStackTrace());
  }
  final StatusData data=new StatusData(element,level,msg,t);
  msgLock.lock();
  try {
    messages.add(data);
  }
  finally {
    msgLock.unlock();
  }
  if (listeners.size() > 0) {
    for (    final StatusListener listener : listeners) {
      if (data.getLevel().isAtLeastAsSpecificAs(listener.getStatusLevel())) {
        listener.log(data);
      }
    }
  }
 else {
    logger.logMessage(fqcn,level,marker,msg,t);
  }
}","/** 
 * Add an event.
 * @param marker The Marker
 * @param fqcn   The fully qualified class name of the <b>caller</b>
 * @param level  The logging level
 * @param msg    The message associated with the event.
 * @param t      A Throwable or null.
 */
@Override public void logMessage(final String fqcn,final Level level,final Marker marker,final Message msg,final Throwable t){
  StackTraceElement element=null;
  if (fqcn != null) {
    element=getStackTraceElement(fqcn,Thread.currentThread().getStackTrace());
  }
  final StatusData data=new StatusData(element,level,msg,t);
  msgLock.lock();
  try {
    messages.add(data);
  }
  finally {
    msgLock.unlock();
  }
  if (listeners.size() > 0) {
    for (    final StatusListener listener : listeners) {
      if (data.getLevel().isMoreSpecificThan(listener.getStatusLevel())) {
        listener.log(data);
      }
    }
  }
 else {
    logger.logMessage(fqcn,level,marker,msg,t);
  }
}"
90682,"/** 
 * Decide if we're going to log <code>event</code> based on whether the maximum burst of log statements has been exceeded.
 * @param level The log level.
 * @return The onMatch value if the filter passes, onMismatch otherwise.
 */
private Result filter(final Level level){
  if (this.level.isAtLeastAsSpecificAs(level)) {
    LogDelay delay=history.poll();
    while (delay != null) {
      available.add(delay);
      delay=history.poll();
    }
    delay=available.poll();
    if (delay != null) {
      delay.setDelay(burstInterval);
      history.add(delay);
      return onMatch;
    }
    return onMismatch;
  }
  return onMatch;
}","/** 
 * Decide if we're going to log <code>event</code> based on whether the maximum burst of log statements has been exceeded.
 * @param level The log level.
 * @return The onMatch value if the filter passes, onMismatch otherwise.
 */
private Result filter(final Level level){
  if (this.level.isMoreSpecificThan(level)) {
    LogDelay delay=history.poll();
    while (delay != null) {
      available.add(delay);
      delay=history.poll();
    }
    delay=available.poll();
    if (delay != null) {
      delay.setDelay(burstInterval);
      history.add(delay);
      return onMatch;
    }
    return onMismatch;
  }
  return onMatch;
}"
90683,"private Result filter(final Level level){
  final Object value=ThreadContext.get(key);
  if (value != null) {
    Level ctxLevel=levelMap.get(value);
    if (ctxLevel == null) {
      ctxLevel=defaultThreshold;
    }
    return level.isAtLeastAsSpecificAs(ctxLevel) ? onMatch : onMismatch;
  }
  return Result.NEUTRAL;
}","private Result filter(final Level level){
  final Object value=ThreadContext.get(key);
  if (value != null) {
    Level ctxLevel=levelMap.get(value);
    if (ctxLevel == null) {
      ctxLevel=defaultThreshold;
    }
    return level.isMoreSpecificThan(ctxLevel) ? onMatch : onMismatch;
  }
  return Result.NEUTRAL;
}"
90684,"private Result filter(final Level level){
  return level.isAtLeastAsSpecificAs(this.level) ? onMatch : onMismatch;
}","private Result filter(final Level level){
  return level.isMoreSpecificThan(this.level) ? onMatch : onMismatch;
}"
90685,"/** 
 * Format as a String.
 * @param event The Logging Event.
 * @return A String containing the LogEvent as HTML.
 */
@Override public String toSerializable(final LogEvent event){
  final StringBuilder sbuf=new StringBuilder(BUF_SIZE);
  sbuf.append(Constants.LINE_SEP).append(""String_Node_Str"").append(Constants.LINE_SEP);
  sbuf.append(""String_Node_Str"");
  sbuf.append(event.getMillis() - jvmStartTime);
  sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  final String escapedThread=Transform.escapeHtmlTags(event.getThreadName());
  sbuf.append(""String_Node_Str"").append(escapedThread).append(""String_Node_Str"");
  sbuf.append(escapedThread);
  sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  sbuf.append(""String_Node_Str"");
  if (event.getLevel().equals(Level.DEBUG)) {
    sbuf.append(""String_Node_Str"");
    sbuf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));
    sbuf.append(""String_Node_Str"");
  }
 else   if (event.getLevel().isAtLeastAsSpecificAs(Level.WARN)) {
    sbuf.append(""String_Node_Str"");
    sbuf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));
    sbuf.append(""String_Node_Str"");
  }
 else {
    sbuf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));
  }
  sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  String escapedLogger=Transform.escapeHtmlTags(event.getLoggerName());
  if (escapedLogger.isEmpty()) {
    escapedLogger=""String_Node_Str"";
  }
  sbuf.append(""String_Node_Str"").append(escapedLogger).append(""String_Node_Str"");
  sbuf.append(escapedLogger);
  sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  if (locationInfo) {
    final StackTraceElement element=event.getSource();
    sbuf.append(""String_Node_Str"");
    sbuf.append(Transform.escapeHtmlTags(element.getFileName()));
    sbuf.append(':');
    sbuf.append(element.getLineNumber());
    sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  }
  sbuf.append(""String_Node_Str"");
  sbuf.append(Transform.escapeHtmlTags(event.getMessage().getFormattedMessage()).replaceAll(REGEXP,""String_Node_Str""));
  sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  if (event.getContextStack().getDepth() > 0) {
    sbuf.append(""String_Node_Str"").append(fontSize);
    sbuf.append(""String_Node_Str"");
    sbuf.append(""String_Node_Str"");
    sbuf.append(""String_Node_Str"").append(Transform.escapeHtmlTags(event.getContextStack().toString()));
    sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  }
  if (event.getContextMap().size() > 0) {
    sbuf.append(""String_Node_Str"").append(fontSize);
    sbuf.append(""String_Node_Str"");
    sbuf.append(""String_Node_Str"");
    sbuf.append(""String_Node_Str"").append(Transform.escapeHtmlTags(event.getContextMap().toString()));
    sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  }
  final Throwable throwable=event.getThrown();
  if (throwable != null) {
    sbuf.append(""String_Node_Str"").append(fontSize);
    sbuf.append(""String_Node_Str"");
    appendThrowableAsHTML(throwable,sbuf);
    sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  }
  return sbuf.toString();
}","/** 
 * Format as a String.
 * @param event The Logging Event.
 * @return A String containing the LogEvent as HTML.
 */
@Override public String toSerializable(final LogEvent event){
  final StringBuilder sbuf=new StringBuilder(BUF_SIZE);
  sbuf.append(Constants.LINE_SEP).append(""String_Node_Str"").append(Constants.LINE_SEP);
  sbuf.append(""String_Node_Str"");
  sbuf.append(event.getMillis() - jvmStartTime);
  sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  final String escapedThread=Transform.escapeHtmlTags(event.getThreadName());
  sbuf.append(""String_Node_Str"").append(escapedThread).append(""String_Node_Str"");
  sbuf.append(escapedThread);
  sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  sbuf.append(""String_Node_Str"");
  if (event.getLevel().equals(Level.DEBUG)) {
    sbuf.append(""String_Node_Str"");
    sbuf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));
    sbuf.append(""String_Node_Str"");
  }
 else   if (event.getLevel().isMoreSpecificThan(Level.WARN)) {
    sbuf.append(""String_Node_Str"");
    sbuf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));
    sbuf.append(""String_Node_Str"");
  }
 else {
    sbuf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));
  }
  sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  String escapedLogger=Transform.escapeHtmlTags(event.getLoggerName());
  if (escapedLogger.isEmpty()) {
    escapedLogger=""String_Node_Str"";
  }
  sbuf.append(""String_Node_Str"").append(escapedLogger).append(""String_Node_Str"");
  sbuf.append(escapedLogger);
  sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  if (locationInfo) {
    final StackTraceElement element=event.getSource();
    sbuf.append(""String_Node_Str"");
    sbuf.append(Transform.escapeHtmlTags(element.getFileName()));
    sbuf.append(':');
    sbuf.append(element.getLineNumber());
    sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  }
  sbuf.append(""String_Node_Str"");
  sbuf.append(Transform.escapeHtmlTags(event.getMessage().getFormattedMessage()).replaceAll(REGEXP,""String_Node_Str""));
  sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  if (event.getContextStack().getDepth() > 0) {
    sbuf.append(""String_Node_Str"").append(fontSize);
    sbuf.append(""String_Node_Str"");
    sbuf.append(""String_Node_Str"");
    sbuf.append(""String_Node_Str"").append(Transform.escapeHtmlTags(event.getContextStack().toString()));
    sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  }
  if (event.getContextMap().size() > 0) {
    sbuf.append(""String_Node_Str"").append(fontSize);
    sbuf.append(""String_Node_Str"");
    sbuf.append(""String_Node_Str"");
    sbuf.append(""String_Node_Str"").append(Transform.escapeHtmlTags(event.getContextMap().toString()));
    sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  }
  final Throwable throwable=event.getThrown();
  if (throwable != null) {
    sbuf.append(""String_Node_Str"").append(fontSize);
    sbuf.append(""String_Node_Str"");
    appendThrowableAsHTML(throwable,sbuf);
    sbuf.append(""String_Node_Str"").append(Constants.LINE_SEP);
  }
  return sbuf.toString();
}"
90686,"/** 
 * Returns the next potential rollover time.
 * @param current The current time.
 * @param increment The increment to the next time.
 * @param modulus If true the time will be rounded to occur on a boundary aligned with the increment.
 * @return the next potential rollover time and the timestamp for the target file.
 */
public long getNextTime(final long current,final int increment,final boolean modulus){
  prevFileTime=nextFileTime;
  long nextTime;
  if (frequency == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final Calendar currentCal=Calendar.getInstance();
  currentCal.setTimeInMillis(current);
  final Calendar cal=Calendar.getInstance();
  cal.set(currentCal.get(Calendar.YEAR),0,1,0,0,0);
  cal.set(Calendar.MILLISECOND,0);
  if (frequency == RolloverFrequency.ANNUALLY) {
    increment(cal,Calendar.YEAR,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.YEAR,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  if (frequency == RolloverFrequency.MONTHLY) {
    increment(cal,Calendar.MONTH,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.MONTH,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  if (frequency == RolloverFrequency.WEEKLY) {
    increment(cal,Calendar.WEEK_OF_YEAR,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.WEEK_OF_YEAR,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  cal.set(Calendar.DAY_OF_YEAR,currentCal.get(Calendar.DAY_OF_YEAR));
  if (frequency == RolloverFrequency.DAILY) {
    increment(cal,Calendar.DAY_OF_YEAR,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.DAY_OF_YEAR,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  cal.set(Calendar.HOUR,currentCal.get(Calendar.HOUR));
  if (frequency == RolloverFrequency.HOURLY) {
    increment(cal,Calendar.HOUR,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.HOUR,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  cal.set(Calendar.MINUTE,currentCal.get(Calendar.MINUTE));
  if (frequency == RolloverFrequency.EVERY_MINUTE) {
    increment(cal,Calendar.MINUTE,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.MINUTE,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  cal.set(Calendar.SECOND,currentCal.get(Calendar.SECOND));
  if (frequency == RolloverFrequency.EVERY_SECOND) {
    increment(cal,Calendar.SECOND,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.SECOND,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  increment(cal,Calendar.MILLISECOND,increment,modulus);
  nextTime=cal.getTimeInMillis();
  cal.add(Calendar.MILLISECOND,-1);
  nextFileTime=cal.getTimeInMillis();
  return nextTime;
}","/** 
 * Returns the next potential rollover time.
 * @param current The current time.
 * @param increment The increment to the next time.
 * @param modulus If true the time will be rounded to occur on a boundary aligned with the increment.
 * @return the next potential rollover time and the timestamp for the target file.
 */
public long getNextTime(final long current,final int increment,final boolean modulus){
  prevFileTime=nextFileTime;
  long nextTime;
  if (frequency == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final Calendar currentCal=Calendar.getInstance();
  currentCal.setTimeInMillis(current);
  final Calendar cal=Calendar.getInstance();
  cal.set(currentCal.get(Calendar.YEAR),0,1,0,0,0);
  cal.set(Calendar.MILLISECOND,0);
  if (frequency == RolloverFrequency.ANNUALLY) {
    increment(cal,Calendar.YEAR,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.YEAR,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  cal.set(Calendar.MONTH,currentCal.get(Calendar.MONTH));
  if (frequency == RolloverFrequency.MONTHLY) {
    increment(cal,Calendar.MONTH,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.MONTH,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  if (frequency == RolloverFrequency.WEEKLY) {
    cal.set(Calendar.WEEK_OF_YEAR,currentCal.get(Calendar.WEEK_OF_YEAR));
    increment(cal,Calendar.WEEK_OF_YEAR,increment,modulus);
    cal.set(Calendar.DAY_OF_WEEK,currentCal.getFirstDayOfWeek());
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.WEEK_OF_YEAR,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  cal.set(Calendar.DAY_OF_YEAR,currentCal.get(Calendar.DAY_OF_YEAR));
  if (frequency == RolloverFrequency.DAILY) {
    increment(cal,Calendar.DAY_OF_YEAR,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.DAY_OF_YEAR,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  cal.set(Calendar.HOUR_OF_DAY,currentCal.get(Calendar.HOUR_OF_DAY));
  if (frequency == RolloverFrequency.HOURLY) {
    increment(cal,Calendar.HOUR_OF_DAY,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.HOUR_OF_DAY,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  cal.set(Calendar.MINUTE,currentCal.get(Calendar.MINUTE));
  if (frequency == RolloverFrequency.EVERY_MINUTE) {
    increment(cal,Calendar.MINUTE,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.MINUTE,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  cal.set(Calendar.SECOND,currentCal.get(Calendar.SECOND));
  if (frequency == RolloverFrequency.EVERY_SECOND) {
    increment(cal,Calendar.SECOND,increment,modulus);
    nextTime=cal.getTimeInMillis();
    cal.add(Calendar.SECOND,-1);
    nextFileTime=cal.getTimeInMillis();
    return nextTime;
  }
  cal.set(Calendar.MILLISECOND,currentCal.get(Calendar.MILLISECOND));
  increment(cal,Calendar.MILLISECOND,increment,modulus);
  nextTime=cal.getTimeInMillis();
  cal.add(Calendar.MILLISECOND,-1);
  nextFileTime=cal.getTimeInMillis();
  return nextTime;
}"
90687,"/** 
 * Reconfigure the context.
 */
public synchronized void reconfigure(){
  LOGGER.debug(""String_Node_Str"" + name);
  final Configuration instance=ConfigurationFactory.getInstance().getConfiguration(name,configLocation);
  setConfiguration(instance);
  LOGGER.debug(""String_Node_Str"");
}","/** 
 * Reconfigure the context.
 */
public synchronized void reconfigure(){
  LOGGER.debug(""String_Node_Str"" + name);
  final Configuration instance=ConfigurationFactory.getInstance().getConfiguration(name,configLocation);
  setConfiguration(instance);
  try {
    Server.reregisterMBeansAfterReconfigure();
  }
 catch (  final Exception ex) {
    LOGGER.error(""String_Node_Str"",ex);
  }
  LOGGER.debug(""String_Node_Str"");
}"
90688,"/** 
 * Constructor that initializes the ContextSelector.
 */
public Log4jContextFactory(){
  final String sel=PropertiesUtil.getProperties().getStringProperty(Constants.LOG4J_CONTEXT_SELECTOR);
  if (sel != null) {
    try {
      final Class<?> clazz=Loader.loadClass(sel);
      if (clazz != null && ContextSelector.class.isAssignableFrom(clazz)) {
        selector=(ContextSelector)clazz.newInstance();
      }
    }
 catch (    final Exception ex) {
      LOGGER.error(""String_Node_Str"" + sel,ex);
    }
  }
  if (selector == null) {
    selector=new ClassLoaderContextSelector();
  }
  try {
    Server.registerMBeans(selector);
  }
 catch (  final Exception ex) {
    LOGGER.error(""String_Node_Str"",ex);
  }
}","/** 
 * Constructor that initializes the ContextSelector.
 */
public Log4jContextFactory(){
  final String sel=PropertiesUtil.getProperties().getStringProperty(Constants.LOG4J_CONTEXT_SELECTOR);
  if (sel != null) {
    try {
      final Class<?> clazz=Loader.loadClass(sel);
      if (clazz != null && ContextSelector.class.isAssignableFrom(clazz)) {
        selector=(ContextSelector)clazz.newInstance();
      }
    }
 catch (    final Exception ex) {
      LOGGER.error(""String_Node_Str"" + sel,ex);
    }
  }
  if (selector == null) {
    selector=new ClassLoaderContextSelector();
  }
}"
90689,"private static void unregisterAllMatching(final String search,final MBeanServer mbs){
  try {
    final ObjectName pattern=new ObjectName(search);
    final Set<ObjectName> found=mbs.queryNames(pattern,null);
    for (    final ObjectName objectName : found) {
      mbs.unregisterMBean(objectName);
    }
  }
 catch (  final Exception ex) {
    StatusLogger.getLogger().error(""String_Node_Str"" + search,ex);
  }
}","private static void unregisterAllMatching(final String search,final MBeanServer mbs){
  try {
    final ObjectName pattern=new ObjectName(search);
    final Set<ObjectName> found=mbs.queryNames(pattern,null);
    for (    final ObjectName objectName : found) {
      LOGGER.debug(""String_Node_Str"",objectName);
      mbs.unregisterMBean(objectName);
    }
  }
 catch (  final Exception ex) {
    LOGGER.error(""String_Node_Str"" + search,ex);
  }
}"
90690,"private static void registerContextSelector(final ContextSelector selector,final MBeanServer mbs,final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException {
  final ContextSelectorAdmin mbean=new ContextSelectorAdmin(selector);
  mbs.registerMBean(mbean,mbean.getObjectName());
}","private static void registerContextSelector(final ContextSelector selector,final MBeanServer mbs,final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException {
  final ContextSelectorAdmin mbean=new ContextSelectorAdmin(selector);
  register(mbs,mbean,mbean.getObjectName());
}"
90691,"private static void registerAppenders(final LoggerContext ctx,final MBeanServer mbs,final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException {
  final Map<String,Appender> map=ctx.getConfiguration().getAppenders();
  for (  final String name : map.keySet()) {
    final Appender appender=map.get(name);
    if (appender instanceof AsyncAppender) {
      AsyncAppender async=((AsyncAppender)appender);
      final AsyncAppenderAdmin mbean=new AsyncAppenderAdmin(ctx.getName(),async);
      mbs.registerMBean(mbean,mbean.getObjectName());
    }
 else {
      final AppenderAdmin mbean=new AppenderAdmin(ctx.getName(),appender);
      mbs.registerMBean(mbean,mbean.getObjectName());
    }
  }
}","private static void registerAppenders(final LoggerContext ctx,final MBeanServer mbs,final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException {
  final Map<String,Appender> map=ctx.getConfiguration().getAppenders();
  for (  final String name : map.keySet()) {
    final Appender appender=map.get(name);
    if (appender instanceof AsyncAppender) {
      AsyncAppender async=((AsyncAppender)appender);
      final AsyncAppenderAdmin mbean=new AsyncAppenderAdmin(ctx.getName(),async);
      register(mbs,mbean,mbean.getObjectName());
    }
 else {
      final AppenderAdmin mbean=new AppenderAdmin(ctx.getName(),appender);
      register(mbs,mbean,mbean.getObjectName());
    }
  }
}"
90692,"/** 
 * Creates MBeans to instrument the specified selector and other classes in the log4j class hierarchy and registers the MBeans in the specified MBean server so they can be accessed by remote clients.
 * @param selector starting point in the log4j class hierarchy
 * @param mbs the MBean Server to register the instrumented objects in
 * @throws JMException if a problem occurs during registration
 */
public static void registerMBeans(final ContextSelector selector,final MBeanServer mbs) throws JMException {
  if (Boolean.getBoolean(PROPERTY_DISABLE_JMX)) {
    StatusLogger.getLogger().debug(""String_Node_Str"");
    return;
  }
  final Executor executor=Executors.newFixedThreadPool(1);
  registerStatusLogger(mbs,executor);
  registerContextSelector(selector,mbs,executor);
  final List<LoggerContext> contexts=selector.getLoggerContexts();
  registerContexts(contexts,mbs,executor);
  for (  final LoggerContext context : contexts) {
    context.addPropertyChangeListener(new PropertyChangeListener(){
      @Override public void propertyChange(      final PropertyChangeEvent evt){
        if (!LoggerContext.PROPERTY_CONFIG.equals(evt.getPropertyName())) {
          return;
        }
        unregisterLoggerConfigs(context.getName(),mbs);
        unregisterAsyncLoggerConfigRingBufferAdmins(context.getName(),mbs);
        unregisterAppenders(context.getName(),mbs);
        unregisterAsyncAppenders(context.getName(),mbs);
        try {
          registerLoggerConfigs(context,mbs,executor);
          registerAppenders(context,mbs,executor);
        }
 catch (        final Exception ex) {
          StatusLogger.getLogger().error(""String_Node_Str"",ex);
        }
      }
    }
);
  }
}","/** 
 * Creates MBeans to instrument the specified selector and other classes in the log4j class hierarchy and registers the MBeans in the specified MBean server so they can be accessed by remote clients.
 * @param selector starting point in the log4j class hierarchy
 * @param mbs the MBean Server to register the instrumented objects in
 * @throws JMException if a problem occurs during registration
 */
public static void registerMBeans(final ContextSelector selector,final MBeanServer mbs) throws JMException {
  if (Boolean.getBoolean(PROPERTY_DISABLE_JMX)) {
    LOGGER.debug(""String_Node_Str"");
    return;
  }
  registerStatusLogger(mbs,executor);
  registerContextSelector(selector,mbs,executor);
  final List<LoggerContext> contexts=selector.getLoggerContexts();
  registerContexts(contexts,mbs,executor);
}"
90693,"/** 
 * Registers MBeans for all contexts in the list. First unregisters each context (and nested loggers, appender etc) to prevent InstanceAlreadyExistsExceptions.
 */
private static void registerContexts(final List<LoggerContext> contexts,final MBeanServer mbs,final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException {
  for (  final LoggerContext ctx : contexts) {
    unregisterContext(ctx.getName());
    final LoggerContextAdmin mbean=new LoggerContextAdmin(ctx,executor);
    mbs.registerMBean(mbean,mbean.getObjectName());
    if (ctx instanceof AsyncLoggerContext) {
      RingBufferAdmin rbmbean=AsyncLogger.createRingBufferAdmin(ctx.getName());
      mbs.registerMBean(rbmbean,rbmbean.getObjectName());
    }
  }
}","/** 
 * Registers MBeans for all contexts in the list. First unregisters each context (and nested loggers, appender etc) to prevent InstanceAlreadyExistsExceptions.
 */
private static void registerContexts(final List<LoggerContext> contexts,final MBeanServer mbs,final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException {
  for (  final LoggerContext ctx : contexts) {
    unregisterContext(ctx.getName());
    final LoggerContextAdmin mbean=new LoggerContextAdmin(ctx,executor);
    register(mbs,mbean,mbean.getObjectName());
    if (ctx instanceof AsyncLoggerContext) {
      RingBufferAdmin rbmbean=AsyncLogger.createRingBufferAdmin(ctx.getName());
      register(mbs,rbmbean,rbmbean.getObjectName());
    }
  }
}"
90694,"private static void registerStatusLogger(final MBeanServer mbs,final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException {
  final StatusLoggerAdmin mbean=new StatusLoggerAdmin(executor);
  mbs.registerMBean(mbean,mbean.getObjectName());
}","private static void registerStatusLogger(final MBeanServer mbs,final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException {
  final StatusLoggerAdmin mbean=new StatusLoggerAdmin(executor);
  register(mbs,mbean,mbean.getObjectName());
}"
90695,"private static void registerLoggerConfigs(final LoggerContext ctx,final MBeanServer mbs,final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException {
  final Map<String,LoggerConfig> map=ctx.getConfiguration().getLoggers();
  for (  final String name : map.keySet()) {
    final LoggerConfig cfg=map.get(name);
    final LoggerConfigAdmin mbean=new LoggerConfigAdmin(ctx.getName(),cfg);
    mbs.registerMBean(mbean,mbean.getObjectName());
    if (cfg instanceof AsyncLoggerConfig) {
      AsyncLoggerConfig async=(AsyncLoggerConfig)cfg;
      RingBufferAdmin rbmbean=async.createRingBufferAdmin(ctx.getName());
      mbs.registerMBean(rbmbean,rbmbean.getObjectName());
    }
  }
}","private static void registerLoggerConfigs(final LoggerContext ctx,final MBeanServer mbs,final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException {
  final Map<String,LoggerConfig> map=ctx.getConfiguration().getLoggers();
  for (  final String name : map.keySet()) {
    final LoggerConfig cfg=map.get(name);
    final LoggerConfigAdmin mbean=new LoggerConfigAdmin(ctx.getName(),cfg);
    register(mbs,mbean,mbean.getObjectName());
    if (cfg instanceof AsyncLoggerConfig) {
      AsyncLoggerConfig async=(AsyncLoggerConfig)cfg;
      RingBufferAdmin rbmbean=async.createRingBufferAdmin(ctx.getName());
      register(mbs,rbmbean,rbmbean.getObjectName());
    }
  }
}"
90696,"@Override public void log(final Marker marker,final String fqcn,final Level level,final Message data,final Throwable t){
  Info info=threadlocalInfo.get();
  if (info == null) {
    info=new Info(new RingBufferLogEventTranslator(),Thread.currentThread().getName());
    threadlocalInfo.set(info);
  }
  final boolean includeLocation=config.loggerConfig.isIncludeLocation();
  info.translator.setValues(this,getName(),marker,fqcn,level,data,t,ThreadContext.getImmutableContext(),ThreadContext.getImmutableStack(),THREAD_NAME_STRATEGY.getThreadName(info),includeLocation ? location(fqcn) : null,clock.currentTimeMillis());
  disruptor.publishEvent(info.translator);
}","@Override public void log(final Marker marker,final String fqcn,final Level level,final Message data,final Throwable t){
  Info info=threadlocalInfo.get();
  if (info == null) {
    info=new Info(new RingBufferLogEventTranslator(),Thread.currentThread().getName(),false);
    threadlocalInfo.set(info);
  }
  if (info.isAppenderThread && disruptor.getRingBuffer().remainingCapacity() == 0) {
    config.loggerConfig.log(getName(),marker,fqcn,level,data,t);
    return;
  }
  final boolean includeLocation=config.loggerConfig.isIncludeLocation();
  info.translator.setValues(this,getName(),marker,fqcn,level,data,t,ThreadContext.getImmutableContext(),ThreadContext.getImmutableStack(),THREAD_NAME_STRATEGY.getThreadName(info),includeLocation ? location(fqcn) : null,clock.currentTimeMillis());
  disruptor.publishEvent(info.translator);
}"
90697,"public Info(RingBufferLogEventTranslator translator,String threadName){
  this.translator=translator;
  this.cachedThreadName=threadName;
}","public Info(RingBufferLogEventTranslator translator,String threadName,boolean appenderThread){
  this.translator=translator;
  this.cachedThreadName=threadName;
  this.isAppenderThread=appenderThread;
}"
90698,"/** 
 * Passes on the event to a separate thread that will call  {@link #asyncCallAppenders(LogEvent)}.
 */
@Override protected void callAppenders(final LogEvent event){
  event.getSource();
  event.getThreadName();
  helper.callAppendersFromAnotherThread(event);
}","/** 
 * Passes on the event to a separate thread that will call  {@link #asyncCallAppenders(LogEvent)}.
 */
@Override protected void callAppenders(final LogEvent event){
  event.getSource();
  event.getThreadName();
  if (!helper.callAppendersFromAnotherThread(event)) {
    super.callAppenders(event);
  }
}"
90699,"private static synchronized void initDisruptor(){
  if (disruptor != null) {
    LOGGER.trace(""String_Node_Str"",count);
    return;
  }
  LOGGER.trace(""String_Node_Str"",count);
  final int ringBufferSize=calculateRingBufferSize();
  final WaitStrategy waitStrategy=createWaitStrategy();
  executor=Executors.newSingleThreadExecutor(threadFactory);
  disruptor=new Disruptor<Log4jEventWrapper>(FACTORY,ringBufferSize,executor,ProducerType.MULTI,waitStrategy);
  final EventHandler<Log4jEventWrapper>[] handlers=new Log4jEventWrapperHandler[]{new Log4jEventWrapperHandler()};
  final ExceptionHandler errorHandler=getExceptionHandler();
  disruptor.handleExceptionsWith(errorHandler);
  disruptor.handleEventsWith(handlers);
  LOGGER.debug(""String_Node_Str"",disruptor.getRingBuffer().getBufferSize(),waitStrategy.getClass().getSimpleName(),errorHandler);
  disruptor.start();
}","private static synchronized void initDisruptor(){
  if (disruptor != null) {
    LOGGER.trace(""String_Node_Str"",count);
    return;
  }
  LOGGER.trace(""String_Node_Str"",count);
  final int ringBufferSize=calculateRingBufferSize();
  final WaitStrategy waitStrategy=createWaitStrategy();
  executor=Executors.newSingleThreadExecutor(threadFactory);
  initThreadLocalForExecutorThread();
  disruptor=new Disruptor<Log4jEventWrapper>(FACTORY,ringBufferSize,executor,ProducerType.MULTI,waitStrategy);
  final EventHandler<Log4jEventWrapper>[] handlers=new Log4jEventWrapperHandler[]{new Log4jEventWrapperHandler()};
  final ExceptionHandler errorHandler=getExceptionHandler();
  disruptor.handleExceptionsWith(errorHandler);
  disruptor.handleEventsWith(handlers);
  LOGGER.debug(""String_Node_Str"",disruptor.getRingBuffer().getBufferSize(),waitStrategy.getClass().getSimpleName(),errorHandler);
  disruptor.start();
}"
90700,"public void callAppendersFromAnotherThread(final LogEvent event){
  disruptor.getRingBuffer().publishEvent(translator,event,asyncLoggerConfig);
}","/** 
 * If possible, delegates the invocation to   {@code callAppenders} to anotherthread and returns  {@code true}. If this is not possible (if it detects that delegating to another thread would cause deadlock because the current call to Logger.log() originated from the appender thread and the ringbuffer is full) then this method does nothing and returns   {@code false}. It is the responsibility of the caller to process the event when this method returns   {@code false}.
 * @param event the event to delegate to another thread
 * @return {@code true} if delegation was successful, {@code false} if thecalling thread needs to process the event itself
 */
public boolean callAppendersFromAnotherThread(final LogEvent event){
  if (isAppenderThread.get() == Boolean.TRUE && disruptor.getRingBuffer().remainingCapacity() == 0) {
    return false;
  }
  disruptor.getRingBuffer().publishEvent(translator,event,asyncLoggerConfig);
  return true;
}"
90701,"@Test public void testCachedThreadNameStrategyReturnsCachedThreadName() throws Exception {
  final String original=""String_Node_Str"";
  Thread.currentThread().setName(original);
  AsyncLogger.Info info=new AsyncLogger.Info(null,original);
  assertEquals(original,AsyncLogger.ThreadNameStrategy.CACHED.getThreadName(info));
  final String name2=""String_Node_Str"";
  Thread.currentThread().setName(name2);
  assertEquals(original,AsyncLogger.ThreadNameStrategy.CACHED.getThreadName(info));
}","@Test public void testCachedThreadNameStrategyReturnsCachedThreadName() throws Exception {
  final String original=""String_Node_Str"";
  Thread.currentThread().setName(original);
  AsyncLogger.Info info=new AsyncLogger.Info(null,original,false);
  assertEquals(original,AsyncLogger.ThreadNameStrategy.CACHED.getThreadName(info));
  final String name2=""String_Node_Str"";
  Thread.currentThread().setName(name2);
  assertEquals(original,AsyncLogger.ThreadNameStrategy.CACHED.getThreadName(info));
}"
90702,"@Test public void testUncachedThreadNameStrategyReturnsCurrentThreadName() throws Exception {
  AsyncLogger.Info info=new AsyncLogger.Info(null,""String_Node_Str"");
  final String name1=""String_Node_Str"";
  Thread.currentThread().setName(name1);
  assertEquals(name1,AsyncLogger.ThreadNameStrategy.UNCACHED.getThreadName(info));
  final String name2=""String_Node_Str"";
  Thread.currentThread().setName(name2);
  assertEquals(name2,AsyncLogger.ThreadNameStrategy.UNCACHED.getThreadName(info));
}","@Test public void testUncachedThreadNameStrategyReturnsCurrentThreadName() throws Exception {
  AsyncLogger.Info info=new AsyncLogger.Info(null,""String_Node_Str"",false);
  final String name1=""String_Node_Str"";
  Thread.currentThread().setName(name1);
  assertEquals(name1,AsyncLogger.ThreadNameStrategy.UNCACHED.getThreadName(info));
  final String name2=""String_Node_Str"";
  Thread.currentThread().setName(name2);
  assertEquals(name2,AsyncLogger.ThreadNameStrategy.UNCACHED.getThreadName(info));
}"
90703,"@Override public void run(){
  while (!shutdown) {
    Serializable s;
    try {
      s=queue.take();
      if (s != null && s instanceof String && SHUTDOWN.equals(s.toString())) {
        shutdown=true;
        continue;
      }
    }
 catch (    final InterruptedException ex) {
      continue;
    }
    final Log4jLogEvent event=Log4jLogEvent.deserialize(s);
    event.setEndOfBatch(queue.isEmpty());
    boolean success=false;
    for (    final AppenderControl control : appenders) {
      try {
        control.callAppender(event);
        success=true;
      }
 catch (      final Exception ex) {
      }
    }
    if (!success && errorAppender != null) {
      try {
        errorAppender.callAppender(event);
      }
 catch (      final Exception ex) {
      }
    }
  }
  while (!queue.isEmpty()) {
    try {
      final Serializable s=queue.take();
      if (s instanceof Log4jLogEvent) {
        final Log4jLogEvent event=Log4jLogEvent.deserialize(s);
        event.setEndOfBatch(queue.isEmpty());
        for (        final AppenderControl control : appenders) {
          control.callAppender(event);
        }
      }
    }
 catch (    final InterruptedException ex) {
    }
  }
}","@Override public void run(){
  isAppenderThread.set(Boolean.TRUE);
  while (!shutdown) {
    Serializable s;
    try {
      s=queue.take();
      if (s != null && s instanceof String && SHUTDOWN.equals(s.toString())) {
        shutdown=true;
        continue;
      }
    }
 catch (    final InterruptedException ex) {
      continue;
    }
    final Log4jLogEvent event=Log4jLogEvent.deserialize(s);
    event.setEndOfBatch(queue.isEmpty());
    boolean success=callAppenders(event);
    if (!success && errorAppender != null) {
      try {
        errorAppender.callAppender(event);
      }
 catch (      final Exception ex) {
      }
    }
  }
  while (!queue.isEmpty()) {
    try {
      final Serializable s=queue.take();
      if (s instanceof Log4jLogEvent) {
        final Log4jLogEvent event=Log4jLogEvent.deserialize(s);
        event.setEndOfBatch(queue.isEmpty());
        callAppenders(event);
      }
    }
 catch (    final InterruptedException ex) {
    }
  }
}"
90704,"/** 
 * Actual writing occurs here. <p/>
 * @param event The LogEvent.
 */
@Override public void append(final LogEvent event){
  if (!isStarted()) {
    throw new IllegalStateException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (event instanceof Log4jLogEvent) {
    boolean appendSuccessful=false;
    if (blocking) {
      try {
        queue.put(Log4jLogEvent.serialize((Log4jLogEvent)event,includeLocation));
        appendSuccessful=true;
      }
 catch (      final InterruptedException e) {
        LOGGER.warn(""String_Node_Str"",getName());
      }
    }
 else {
      appendSuccessful=queue.offer(Log4jLogEvent.serialize((Log4jLogEvent)event,includeLocation));
      if (!appendSuccessful) {
        error(""String_Node_Str"" + getName() + ""String_Node_Str"");
      }
    }
    if ((!appendSuccessful) && (errorAppender != null)) {
      errorAppender.callAppender(event);
    }
  }
}","/** 
 * Actual writing occurs here. <p/>
 * @param evt The LogEvent.
 */
@Override public void append(final LogEvent evt){
  if (!isStarted()) {
    throw new IllegalStateException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (!(evt instanceof Log4jLogEvent)) {
    return;
  }
  Log4jLogEvent event=(Log4jLogEvent)evt;
  boolean appendSuccessful=false;
  if (blocking) {
    if (isAppenderThread.get() == Boolean.TRUE && queue.remainingCapacity() == 0) {
      event.setEndOfBatch(false);
      appendSuccessful=thread.callAppenders(event);
    }
 else {
      try {
        queue.put(Log4jLogEvent.serialize(event,includeLocation));
        appendSuccessful=true;
      }
 catch (      final InterruptedException e) {
        LOGGER.warn(""String_Node_Str"",getName());
      }
    }
  }
 else {
    appendSuccessful=queue.offer(Log4jLogEvent.serialize(event,includeLocation));
    if (!appendSuccessful) {
      error(""String_Node_Str"" + getName() + ""String_Node_Str"");
    }
  }
  if ((!appendSuccessful) && (errorAppender != null)) {
    errorAppender.callAppender(event);
  }
}"
90705,"/** 
 * Unregisters all MBeans associated with the specified logger context (including MBeans for   {@code LoggerConfig}s and   {@code Appender}s from the platform MBean server.
 * @param loggerContextName name of the logger context to unregister
 * @param mbs the MBean Server to unregister the instrumented objects from
 * @throws JMException if a problem occurs during de-registration
 */
public static void unregisterContext(String contextName,MBeanServer mbs){
  final String pattern=LoggerContextAdminMBean.PATTERN;
  final String search=String.format(pattern,contextName,""String_Node_Str"");
  unregisterAllMatching(search,mbs);
}","/** 
 * Unregisters all MBeans associated with the specified logger context (including MBeans for   {@code LoggerConfig}s and   {@code Appender}s from the platform MBean server.
 * @param loggerContextName name of the logger context to unregister
 * @param mbs the MBean Server to unregister the instrumented objects from
 */
public static void unregisterContext(String contextName,MBeanServer mbs){
  final String pattern=LoggerContextAdminMBean.PATTERN;
  final String search=String.format(pattern,contextName,""String_Node_Str"");
  unregisterAllMatching(search,mbs);
  unregisterLoggerConfigs(contextName,mbs);
  unregisterAppenders(contextName,mbs);
}"
90706,"/** 
 * Send the contents of the cyclic buffer as an e-mail message.
 * @param layout The layout for formatting the events.
 * @param appendEvent The event that triggered the send.
 */
public void sendEvents(final Layout<?> layout,final LogEvent appendEvent){
  if (message == null) {
    connect();
  }
  try {
    final LogEvent[] priorEvents=buffer.removeAll();
    if (priorEvents == null || priorEvents.length == 0) {
      return;
    }
    final byte[] rawBytes=formatContentToBytes(priorEvents,appendEvent,layout);
    final String contentType=layout.getContentType();
    final String encoding=getEncoding(rawBytes,contentType);
    final byte[] encodedBytes=encodeContentToBytes(rawBytes,encoding);
    final InternetHeaders headers=getHeaders(contentType,encoding);
    final MimeMultipart mp=getMimeMultipart(encodedBytes,headers);
    sendMultipartMessage(message,mp);
  }
 catch (  final MessagingException e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new LoggingException(""String_Node_Str"",e);
  }
catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new LoggingException(""String_Node_Str"",e);
  }
catch (  final RuntimeException e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new LoggingException(""String_Node_Str"",e);
  }
}","/** 
 * Send the contents of the cyclic buffer as an e-mail message.
 * @param layout The layout for formatting the events.
 * @param appendEvent The event that triggered the send.
 */
public void sendEvents(final Layout<?> layout,final LogEvent appendEvent){
  if (message == null) {
    connect();
  }
  try {
    final LogEvent[] priorEvents=buffer.removeAll();
    final byte[] rawBytes=formatContentToBytes(priorEvents,appendEvent,layout);
    final String contentType=layout.getContentType();
    final String encoding=getEncoding(rawBytes,contentType);
    final byte[] encodedBytes=encodeContentToBytes(rawBytes,encoding);
    final InternetHeaders headers=getHeaders(contentType,encoding);
    final MimeMultipart mp=getMimeMultipart(encodedBytes,headers);
    sendMultipartMessage(message,mp);
  }
 catch (  final MessagingException e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new LoggingException(""String_Node_Str"",e);
  }
catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new LoggingException(""String_Node_Str"",e);
  }
catch (  final RuntimeException e) {
    LOGGER.error(""String_Node_Str"",e);
    throw new LoggingException(""String_Node_Str"",e);
  }
}"
90707,"@Test public void testDelivery(){
  final SMTPAppender appender=SMTPAppender.createAppender(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,HOST,PORT,null,null,""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"");
  appender.start();
  final LoggerContext context=(LoggerContext)LogManager.getContext();
  final Logger root=context.getLogger(""String_Node_Str"");
  root.addAppender(appender);
  root.setAdditive(false);
  root.setLevel(Level.DEBUG);
  final SimpleSmtpServer server=SimpleSmtpServer.start(PORTNUM);
  root.debug(""String_Node_Str"");
  root.debug(""String_Node_Str"");
  root.debug(""String_Node_Str"");
  root.debug(""String_Node_Str"");
  root.error(""String_Node_Str"",new RuntimeException(""String_Node_Str""));
  server.stop();
  assertTrue(server.getReceivedEmailSize() == 1);
  final SmtpMessage email=server.getReceivedEmail().next();
  assertEquals(""String_Node_Str"",email.getHeaderValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",email.getHeaderValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",email.getHeaderValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",email.getHeaderValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",email.getHeaderValue(""String_Node_Str""));
  final String body=email.getBody();
  assertFalse(body.contains(""String_Node_Str""));
  assertTrue(body.contains(""String_Node_Str""));
  assertTrue(body.contains(""String_Node_Str""));
  assertTrue(body.contains(""String_Node_Str""));
  assertTrue(body.contains(""String_Node_Str""));
  assertTrue(body.contains(""String_Node_Str""));
  assertTrue(body.contains(""String_Node_Str""));
}","@Test public void testDelivery(){
  final SMTPAppender appender=SMTPAppender.createAppender(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,HOST,PORT,null,null,""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"");
  appender.start();
  final LoggerContext context=(LoggerContext)LogManager.getContext();
  final Logger root=context.getLogger(""String_Node_Str"");
  root.addAppender(appender);
  root.setAdditive(false);
  root.setLevel(Level.DEBUG);
  final SimpleSmtpServer server=SimpleSmtpServer.start(PORTNUM);
  root.debug(""String_Node_Str"");
  root.debug(""String_Node_Str"");
  root.debug(""String_Node_Str"");
  root.debug(""String_Node_Str"");
  root.error(""String_Node_Str"",new RuntimeException(""String_Node_Str""));
  root.error(""String_Node_Str"");
  server.stop();
  assertTrue(server.getReceivedEmailSize() == 2);
  final Iterator<SmtpMessage> messages=server.getReceivedEmail();
  final SmtpMessage email=messages.next();
  assertEquals(""String_Node_Str"",email.getHeaderValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",email.getHeaderValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",email.getHeaderValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",email.getHeaderValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",email.getHeaderValue(""String_Node_Str""));
  final String body=email.getBody();
  assertFalse(body.contains(""String_Node_Str""));
  assertTrue(body.contains(""String_Node_Str""));
  assertTrue(body.contains(""String_Node_Str""));
  assertTrue(body.contains(""String_Node_Str""));
  assertTrue(body.contains(""String_Node_Str""));
  assertTrue(body.contains(""String_Node_Str""));
  assertTrue(body.contains(""String_Node_Str""));
  assertFalse(body.contains(""String_Node_Str""));
  final SmtpMessage email2=(SmtpMessage)messages.next();
  final String body2=email2.getBody();
  assertFalse(body2.contains(""String_Node_Str""));
  assertFalse(body2.contains(""String_Node_Str""));
  assertTrue(body2.contains(""String_Node_Str""));
}"
90708,"@Override public void flush(){
  buffer.flip();
  try {
    randomAccessFile.write(buffer.array(),0,buffer.limit());
  }
 catch (  final IOException ex) {
    final String msg=""String_Node_Str"" + getName();
    throw new AppenderRuntimeException(msg,ex);
  }
  buffer.clear();
}","@Override public synchronized void flush(){
  buffer.flip();
  try {
    randomAccessFile.write(buffer.array(),0,buffer.limit());
  }
 catch (  final IOException ex) {
    final String msg=""String_Node_Str"" + getName();
    throw new AppenderRuntimeException(msg,ex);
  }
  buffer.clear();
}"
90709,"@Override public void close(){
  flush();
  try {
    randomAccessFile.close();
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"" + getName() + ""String_Node_Str""+ ex);
  }
}","@Override public synchronized void close(){
  flush();
  try {
    randomAccessFile.close();
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"" + getName() + ""String_Node_Str""+ ex);
  }
}"
90710,"/** 
 * Flush any buffers.
 */
public void flush(){
  try {
    os.flush();
  }
 catch (  final IOException ex) {
    final String msg=""String_Node_Str"" + getName();
    throw new AppenderRuntimeException(msg,ex);
  }
}","/** 
 * Flush any buffers.
 */
public synchronized void flush(){
  try {
    os.flush();
  }
 catch (  final IOException ex) {
    final String msg=""String_Node_Str"" + getName();
    throw new AppenderRuntimeException(msg,ex);
  }
}"
90711,"protected void close(){
  final OutputStream stream=os;
  if (stream == System.out || stream == System.err) {
    return;
  }
  try {
    stream.close();
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"" + getName() + ""String_Node_Str""+ ex);
  }
}","protected synchronized void close(){
  final OutputStream stream=os;
  if (stream == System.out || stream == System.err) {
    return;
  }
  try {
    stream.close();
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"" + getName() + ""String_Node_Str""+ ex);
  }
}"
90712,"@Override public void flush(){
  buffer.flip();
  try {
    randomAccessFile.write(buffer.array(),0,buffer.limit());
  }
 catch (  final IOException ex) {
    final String msg=""String_Node_Str"" + getName();
    throw new AppenderRuntimeException(msg,ex);
  }
  buffer.clear();
}","@Override public synchronized void flush(){
  buffer.flip();
  try {
    randomAccessFile.write(buffer.array(),0,buffer.limit());
  }
 catch (  final IOException ex) {
    final String msg=""String_Node_Str"" + getName();
    throw new AppenderRuntimeException(msg,ex);
  }
  buffer.clear();
}"
90713,"@Override public void close(){
  flush();
  try {
    randomAccessFile.close();
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"" + getName() + ""String_Node_Str""+ ex);
  }
}","@Override public synchronized void close(){
  flush();
  try {
    randomAccessFile.close();
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"" + getName() + ""String_Node_Str""+ ex);
  }
}"
90714,"@Override @SuppressWarnings(""String_Node_Str"") public java.util.logging.Logger getParentLogger(){
  throw new UnsupportedOperationException();
}","@SuppressWarnings(""String_Node_Str"") public java.util.logging.Logger getParentLogger(){
  throw new UnsupportedOperationException();
}"
90715,"/** 
 * Factory method for creating a connection source within the plugin manager.
 * @param className The name of a public class that contains a static method capable of returning either a{@link DataSource} or a {@link Connection}.
 * @param methodName The name of the public static method on the aforementioned class that returns the data sourceor connection. If this method returns a  {@link Connection}, it should return a new connection every call.
 * @return the created connection source.
 */
@PluginFactory public static FactoryMethodConnectionSource createConnectionSource(@PluginAttr(""String_Node_Str"") final String className,@PluginAttr(""String_Node_Str"") final String methodName){
  if (Strings.isEmpty(className) || Strings.isEmpty(methodName)) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  final Method method;
  try {
    final Class<?> factoryClass=Class.forName(className);
    method=factoryClass.getMethod(methodName);
  }
 catch (  final Exception e) {
    LOGGER.error(e.toString(),e);
    return null;
  }
  final Class<?> returnType=method.getReturnType();
  String returnTypeString=returnType.getName();
  DataSource dataSource;
  if (returnType == DataSource.class) {
    try {
      dataSource=(DataSource)method.invoke(null);
      returnTypeString+=""String_Node_Str"" + dataSource + ""String_Node_Str"";
    }
 catch (    final Exception e) {
      LOGGER.error(e.toString(),e);
      return null;
    }
  }
 else   if (returnType == Connection.class) {
    dataSource=new DataSource(){
      @Override public Connection getConnection() throws SQLException {
        try {
          return (Connection)method.invoke(null);
        }
 catch (        final Exception e) {
          throw new SQLException(""String_Node_Str"",e);
        }
      }
      @Override public Connection getConnection(      final String username,      final String password) throws SQLException {
        throw new UnsupportedOperationException();
      }
      @Override public int getLoginTimeout() throws SQLException {
        throw new UnsupportedOperationException();
      }
      @Override public PrintWriter getLogWriter() throws SQLException {
        throw new UnsupportedOperationException();
      }
      @Override @SuppressWarnings(""String_Node_Str"") public java.util.logging.Logger getParentLogger(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean isWrapperFor(      final Class<?> iface) throws SQLException {
        return false;
      }
      @Override public void setLoginTimeout(      final int seconds) throws SQLException {
        throw new UnsupportedOperationException();
      }
      @Override public void setLogWriter(      final PrintWriter out) throws SQLException {
        throw new UnsupportedOperationException();
      }
      @Override public <T>T unwrap(      final Class<T> iface) throws SQLException {
        return null;
      }
    }
;
  }
 else {
    LOGGER.error(""String_Node_Str"",className,methodName,returnType.getName());
    return null;
  }
  return new FactoryMethodConnectionSource(dataSource,className,methodName,returnTypeString);
}","/** 
 * Factory method for creating a connection source within the plugin manager.
 * @param className The name of a public class that contains a static method capable of returning either a{@link DataSource} or a {@link Connection}.
 * @param methodName The name of the public static method on the aforementioned class that returns the data sourceor connection. If this method returns a  {@link Connection}, it should return a new connection every call.
 * @return the created connection source.
 */
@PluginFactory public static FactoryMethodConnectionSource createConnectionSource(@PluginAttr(""String_Node_Str"") final String className,@PluginAttr(""String_Node_Str"") final String methodName){
  if (Strings.isEmpty(className) || Strings.isEmpty(methodName)) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  final Method method;
  try {
    final Class<?> factoryClass=Class.forName(className);
    method=factoryClass.getMethod(methodName);
  }
 catch (  final Exception e) {
    LOGGER.error(e.toString(),e);
    return null;
  }
  final Class<?> returnType=method.getReturnType();
  String returnTypeString=returnType.getName();
  DataSource dataSource;
  if (returnType == DataSource.class) {
    try {
      dataSource=(DataSource)method.invoke(null);
      returnTypeString+=""String_Node_Str"" + dataSource + ""String_Node_Str"";
    }
 catch (    final Exception e) {
      LOGGER.error(e.toString(),e);
      return null;
    }
  }
 else   if (returnType == Connection.class) {
    dataSource=new DataSource(){
      @Override public Connection getConnection() throws SQLException {
        try {
          return (Connection)method.invoke(null);
        }
 catch (        final Exception e) {
          throw new SQLException(""String_Node_Str"",e);
        }
      }
      @Override public Connection getConnection(      final String username,      final String password) throws SQLException {
        throw new UnsupportedOperationException();
      }
      @Override public int getLoginTimeout() throws SQLException {
        throw new UnsupportedOperationException();
      }
      @Override public PrintWriter getLogWriter() throws SQLException {
        throw new UnsupportedOperationException();
      }
      @SuppressWarnings(""String_Node_Str"") public java.util.logging.Logger getParentLogger(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean isWrapperFor(      final Class<?> iface) throws SQLException {
        return false;
      }
      @Override public void setLoginTimeout(      final int seconds) throws SQLException {
        throw new UnsupportedOperationException();
      }
      @Override public void setLogWriter(      final PrintWriter out) throws SQLException {
        throw new UnsupportedOperationException();
      }
      @Override public <T>T unwrap(      final Class<T> iface) throws SQLException {
        return null;
      }
    }
;
  }
 else {
    LOGGER.error(""String_Node_Str"",className,methodName,returnType.getName());
    return null;
  }
  return new FactoryMethodConnectionSource(dataSource,className,methodName,returnTypeString);
}"
90716,"protected void setOutputStream(final OutputStream os){
  this.os=os;
  if (header != null) {
    try {
      this.os.write(header,0,header.length);
    }
 catch (    final IOException ioe) {
      LOGGER.error(""String_Node_Str"",ioe);
    }
  }
}","protected void setOutputStream(final OutputStream os){
  if (header != null) {
    try {
      os.write(header,0,header.length);
      this.os=os;
    }
 catch (    final IOException ioe) {
      LOGGER.error(""String_Node_Str"",ioe);
    }
  }
}"
90717,"protected void close(){
  if (os == System.out || os == System.err) {
    return;
  }
  try {
    os.close();
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"" + getName() + ""String_Node_Str""+ ex);
  }
}","protected void close(){
  OutputStream stream=os;
  if (stream == System.out || stream == System.err) {
    return;
  }
  try {
    stream.close();
  }
 catch (  final IOException ex) {
    LOGGER.error(""String_Node_Str"" + getName() + ""String_Node_Str""+ ex);
  }
}"
90718,"private Node constructNode(final String name,final Node parent,final JsonNode jsonNode){
  final PluginType type=getPluginManager().getPluginType(name);
  final Node node=new Node(parent,name,type);
  processAttributes(node,jsonNode);
  final Iterator<Map.Entry<String,JsonNode>> iter=jsonNode.getFields();
  final List<Node> children=node.getChildren();
  while (iter.hasNext()) {
    final Map.Entry<String,JsonNode> entry=iter.next();
    final JsonNode n=entry.getValue();
    if (n.isArray() || n.isObject()) {
      if (type == null) {
        status.add(new Status(name,n,ErrorType.CLASS_NOT_FOUND));
      }
      if (n.isArray()) {
        LOGGER.debug(""String_Node_Str"" + entry.getKey());
        for (int i=0; i < n.size(); ++i) {
          final String pluginType=getType(n.get(i),entry.getKey());
          final PluginType entryType=getPluginManager().getPluginType(pluginType);
          final Node item=new Node(node,entry.getKey(),entryType);
          processAttributes(item,n.get(i));
          if (pluginType.equals(entry.getKey())) {
            LOGGER.debug(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ i+ ""String_Node_Str"");
          }
 else {
            LOGGER.debug(""String_Node_Str"" + pluginType + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ i+ ""String_Node_Str"");
          }
          final Iterator<Map.Entry<String,JsonNode>> itemIter=n.get(i).getFields();
          final List<Node> itemChildren=item.getChildren();
          while (itemIter.hasNext()) {
            final Map.Entry<String,JsonNode> itemEntry=itemIter.next();
            if (itemEntry.getValue().isObject()) {
              LOGGER.debug(""String_Node_Str"" + itemEntry.getKey());
              itemChildren.add(constructNode(itemEntry.getKey(),item,itemEntry.getValue()));
            }
          }
          children.add(item);
        }
      }
 else {
        LOGGER.debug(""String_Node_Str"" + entry.getKey());
        children.add(constructNode(entry.getKey(),node,n));
      }
    }
  }
  String t;
  if (type == null) {
    t=""String_Node_Str"";
  }
 else {
    t=type.getElementName() + ""String_Node_Str"" + type.getPluginClass();
  }
  final String p=node.getParent() == null ? ""String_Node_Str"" : node.getParent().getName() == null ? ""String_Node_Str"" : node.getParent().getName();
  LOGGER.debug(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ p+ ""String_Node_Str""+ t);
  return node;
}","private Node constructNode(final String name,final Node parent,final JsonNode jsonNode){
  final PluginType<?> type=getPluginManager().getPluginType(name);
  final Node node=new Node(parent,name,type);
  processAttributes(node,jsonNode);
  final Iterator<Map.Entry<String,JsonNode>> iter=jsonNode.getFields();
  final List<Node> children=node.getChildren();
  while (iter.hasNext()) {
    final Map.Entry<String,JsonNode> entry=iter.next();
    final JsonNode n=entry.getValue();
    if (n.isArray() || n.isObject()) {
      if (type == null) {
        status.add(new Status(name,n,ErrorType.CLASS_NOT_FOUND));
      }
      if (n.isArray()) {
        LOGGER.debug(""String_Node_Str"" + entry.getKey());
        for (int i=0; i < n.size(); ++i) {
          final String pluginType=getType(n.get(i),entry.getKey());
          final PluginType<?> entryType=getPluginManager().getPluginType(pluginType);
          final Node item=new Node(node,entry.getKey(),entryType);
          processAttributes(item,n.get(i));
          if (pluginType.equals(entry.getKey())) {
            LOGGER.debug(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ i+ ""String_Node_Str"");
          }
 else {
            LOGGER.debug(""String_Node_Str"" + pluginType + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ i+ ""String_Node_Str"");
          }
          final Iterator<Map.Entry<String,JsonNode>> itemIter=n.get(i).getFields();
          final List<Node> itemChildren=item.getChildren();
          while (itemIter.hasNext()) {
            final Map.Entry<String,JsonNode> itemEntry=itemIter.next();
            if (itemEntry.getValue().isObject()) {
              LOGGER.debug(""String_Node_Str"" + itemEntry.getKey());
              itemChildren.add(constructNode(itemEntry.getKey(),item,itemEntry.getValue()));
            }
          }
          children.add(item);
        }
      }
 else {
        LOGGER.debug(""String_Node_Str"" + entry.getKey());
        children.add(constructNode(entry.getKey(),node,n));
      }
    }
  }
  String t;
  if (type == null) {
    t=""String_Node_Str"";
  }
 else {
    t=type.getElementName() + ""String_Node_Str"" + type.getPluginClass();
  }
  final String p=node.getParent() == null ? ""String_Node_Str"" : node.getParent().getName() == null ? ""String_Node_Str"" : node.getParent().getName();
  LOGGER.debug(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ p+ ""String_Node_Str""+ t);
  return node;
}"
90719,"public JSONConfiguration(final ConfigurationFactory.ConfigurationSource configSource){
  this.configFile=configSource.getFile();
  byte[] buffer;
  try {
    final InputStream configStream=configSource.getInputStream();
    buffer=toByteArray(configStream);
    configStream.close();
    final InputStream is=new ByteArrayInputStream(buffer);
    final ObjectMapper mapper=new ObjectMapper().configure(JsonParser.Feature.ALLOW_COMMENTS,true);
    root=mapper.readTree(is);
    if (root.size() == 1) {
      final Iterator<JsonNode> i=root.getElements();
      root=i.next();
    }
    processAttributes(rootNode,root);
    Level status=Level.OFF;
    boolean verbose=false;
    PrintStream stream=System.out;
    for (    final Map.Entry<String,String> entry : rootNode.getAttributes().entrySet()) {
      if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        status=Level.toLevel(getSubst().replace(entry.getValue()),null);
        if (status == null) {
          status=Level.ERROR;
          messages.add(""String_Node_Str"" + entry.getValue() + ""String_Node_Str"");
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final String dest=entry.getValue();
        if (dest != null) {
          if (dest.equalsIgnoreCase(""String_Node_Str"")) {
            stream=System.err;
          }
 else {
            try {
              final File destFile=FileUtils.fileFromURI(new URI(dest));
              stream=new PrintStream(new FileOutputStream(destFile));
            }
 catch (            final URISyntaxException use) {
              System.err.println(""String_Node_Str"" + dest + ""String_Node_Str"");
            }
          }
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        verbose=Boolean.parseBoolean(getSubst().replace(entry.getValue()));
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final String[] packages=getSubst().replace(entry.getValue()).split(""String_Node_Str"");
        for (        final String p : packages) {
          PluginManager.addPackage(p);
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        setName(getSubst().replace(entry.getValue()));
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final int interval=Integer.parseInt(getSubst().replace(entry.getValue()));
        if (interval > 0 && configFile != null) {
          monitor=new FileConfigurationMonitor(this,configFile,listeners,interval);
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final String advertiserString=getSubst().replace(entry.getValue());
        if (advertiserString != null) {
          @SuppressWarnings(""String_Node_Str"") final PluginType<Advertiser> type=getPluginManager().getPluginType(advertiserString);
          if (type != null) {
            final Class<Advertiser> clazz=type.getPluginClass();
            advertiser=clazz.newInstance();
            advertisedConfiguration=new HashMap<String,String>();
            advertisedConfiguration.put(""String_Node_Str"",new String(buffer));
            advertisedConfiguration.put(""String_Node_Str"",""String_Node_Str"");
            advertisedConfiguration.put(""String_Node_Str"",""String_Node_Str"");
            if (configSource.getLocation() != null) {
              advertisedConfiguration.put(""String_Node_Str"",configSource.getLocation());
            }
          }
        }
      }
    }
    final Iterator<StatusListener> statusIter=((StatusLogger)LOGGER).getListeners();
    boolean found=false;
    while (statusIter.hasNext()) {
      final StatusListener listener=statusIter.next();
      if (listener instanceof StatusConsoleListener) {
        found=true;
        ((StatusConsoleListener)listener).setLevel(status);
        if (!verbose) {
          ((StatusConsoleListener)listener).setFilters(VERBOSE_CLASSES);
        }
      }
    }
    if (!found && status != Level.OFF) {
      final StatusConsoleListener listener=new StatusConsoleListener(status,stream);
      if (!verbose) {
        listener.setFilters(VERBOSE_CLASSES);
      }
      ((StatusLogger)LOGGER).registerListener(listener);
      for (      final String msg : messages) {
        LOGGER.error(msg);
      }
    }
    if (getName() == null) {
      setName(configSource.getLocation());
    }
  }
 catch (  final Exception ex) {
    LOGGER.error(""String_Node_Str"" + configSource.getLocation(),ex);
    ex.printStackTrace();
  }
}","public JSONConfiguration(final ConfigurationFactory.ConfigurationSource configSource){
  this.configFile=configSource.getFile();
  byte[] buffer;
  try {
    final InputStream configStream=configSource.getInputStream();
    buffer=toByteArray(configStream);
    configStream.close();
    final InputStream is=new ByteArrayInputStream(buffer);
    final ObjectMapper mapper=new ObjectMapper().configure(JsonParser.Feature.ALLOW_COMMENTS,true);
    root=mapper.readTree(is);
    if (root.size() == 1) {
      final Iterator<JsonNode> i=root.getElements();
      root=i.next();
    }
    processAttributes(rootNode,root);
    Level status=Level.OFF;
    boolean verbose=false;
    PrintStream stream=System.out;
    for (    final Map.Entry<String,String> entry : rootNode.getAttributes().entrySet()) {
      if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        status=Level.toLevel(getSubst().replace(entry.getValue()),null);
        if (status == null) {
          status=Level.ERROR;
          messages.add(""String_Node_Str"" + entry.getValue() + ""String_Node_Str"");
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final String dest=entry.getValue();
        if (dest != null) {
          if (dest.equalsIgnoreCase(""String_Node_Str"")) {
            stream=System.err;
          }
 else {
            try {
              final File destFile=FileUtils.fileFromURI(new URI(dest));
              final String enc=Charset.defaultCharset().name();
              stream=new PrintStream(new FileOutputStream(destFile),true,enc);
            }
 catch (            final URISyntaxException use) {
              System.err.println(""String_Node_Str"" + dest + ""String_Node_Str"");
            }
          }
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        verbose=Boolean.parseBoolean(getSubst().replace(entry.getValue()));
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final String[] packages=getSubst().replace(entry.getValue()).split(""String_Node_Str"");
        for (        final String p : packages) {
          PluginManager.addPackage(p);
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        setName(getSubst().replace(entry.getValue()));
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final int interval=Integer.parseInt(getSubst().replace(entry.getValue()));
        if (interval > 0 && configFile != null) {
          monitor=new FileConfigurationMonitor(this,configFile,listeners,interval);
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final String advertiserString=getSubst().replace(entry.getValue());
        if (advertiserString != null) {
          @SuppressWarnings(""String_Node_Str"") final PluginType<Advertiser> type=getPluginManager().getPluginType(advertiserString);
          if (type != null) {
            final Class<Advertiser> clazz=type.getPluginClass();
            advertiser=clazz.newInstance();
            advertisedConfiguration=new HashMap<String,String>();
            advertisedConfiguration.put(""String_Node_Str"",new String(buffer));
            advertisedConfiguration.put(""String_Node_Str"",""String_Node_Str"");
            advertisedConfiguration.put(""String_Node_Str"",""String_Node_Str"");
            if (configSource.getLocation() != null) {
              advertisedConfiguration.put(""String_Node_Str"",configSource.getLocation());
            }
          }
        }
      }
    }
    final Iterator<StatusListener> statusIter=((StatusLogger)LOGGER).getListeners();
    boolean found=false;
    while (statusIter.hasNext()) {
      final StatusListener listener=statusIter.next();
      if (listener instanceof StatusConsoleListener) {
        found=true;
        ((StatusConsoleListener)listener).setLevel(status);
        if (!verbose) {
          ((StatusConsoleListener)listener).setFilters(VERBOSE_CLASSES);
        }
      }
    }
    if (!found && status != Level.OFF) {
      final StatusConsoleListener listener=new StatusConsoleListener(status,stream);
      if (!verbose) {
        listener.setFilters(VERBOSE_CLASSES);
      }
      ((StatusLogger)LOGGER).registerListener(listener);
      for (      final String msg : messages) {
        LOGGER.error(msg);
      }
    }
    if (getName() == null) {
      setName(configSource.getLocation());
    }
  }
 catch (  final Exception ex) {
    LOGGER.error(""String_Node_Str"" + configSource.getLocation(),ex);
    ex.printStackTrace();
  }
}"
90720,"public XMLConfiguration(final ConfigurationFactory.ConfigurationSource configSource){
  this.configFile=configSource.getFile();
  byte[] buffer=null;
  try {
    final InputStream configStream=configSource.getInputStream();
    buffer=toByteArray(configStream);
    configStream.close();
    final InputSource source=new InputSource(new ByteArrayInputStream(buffer));
    final DocumentBuilder builder=DocumentBuilderFactory.newInstance().newDocumentBuilder();
    final Document document=builder.parse(source);
    rootElement=document.getDocumentElement();
    final Map<String,String> attrs=processAttributes(rootNode,rootElement);
    Level status=Level.OFF;
    boolean verbose=false;
    PrintStream stream=System.out;
    for (    final Map.Entry<String,String> entry : attrs.entrySet()) {
      if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        status=Level.toLevel(getSubst().replace(entry.getValue()),null);
        if (status == null) {
          status=Level.ERROR;
          messages.add(""String_Node_Str"" + entry.getValue() + ""String_Node_Str"");
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final String dest=entry.getValue();
        if (dest != null) {
          if (dest.equalsIgnoreCase(""String_Node_Str"")) {
            stream=System.err;
          }
 else {
            try {
              final File destFile=FileUtils.fileFromURI(new URI(dest));
              stream=new PrintStream(new FileOutputStream(destFile));
            }
 catch (            final URISyntaxException use) {
              System.err.println(""String_Node_Str"" + dest + ""String_Node_Str"");
            }
          }
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        verbose=Boolean.parseBoolean(getSubst().replace(entry.getValue()));
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(getSubst().replace(entry.getKey()))) {
        final String[] packages=entry.getValue().split(""String_Node_Str"");
        for (        final String p : packages) {
          PluginManager.addPackage(p);
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        setName(getSubst().replace(entry.getValue()));
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        strict=Boolean.parseBoolean(getSubst().replace(entry.getValue()));
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        schema=getSubst().replace(entry.getValue());
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final int interval=Integer.parseInt(getSubst().replace(entry.getValue()));
        if (interval > 0 && configFile != null) {
          monitor=new FileConfigurationMonitor(this,configFile,listeners,interval);
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final String advertiserString=getSubst().replace(entry.getValue());
        if (advertiserString != null) {
          @SuppressWarnings(""String_Node_Str"") final PluginType<Advertiser> type=getPluginManager().getPluginType(advertiserString);
          if (type != null) {
            final Class<Advertiser> clazz=type.getPluginClass();
            try {
              advertiser=clazz.newInstance();
              advertisedConfiguration=new HashMap<String,String>();
              advertisedConfiguration.put(""String_Node_Str"",new String(buffer));
              advertisedConfiguration.put(""String_Node_Str"",""String_Node_Str"");
              advertisedConfiguration.put(""String_Node_Str"",""String_Node_Str"");
              if (configSource.getLocation() != null) {
                advertisedConfiguration.put(""String_Node_Str"",configSource.getLocation());
              }
            }
 catch (            InstantiationException e) {
              System.err.println(""String_Node_Str"" + advertiserString);
            }
catch (            IllegalAccessException e) {
              System.err.println(""String_Node_Str"" + advertiserString);
            }
          }
        }
      }
    }
    final Iterator<StatusListener> iter=((StatusLogger)LOGGER).getListeners();
    boolean found=false;
    while (iter.hasNext()) {
      final StatusListener listener=iter.next();
      if (listener instanceof StatusConsoleListener) {
        found=true;
        ((StatusConsoleListener)listener).setLevel(status);
        if (!verbose) {
          ((StatusConsoleListener)listener).setFilters(VERBOSE_CLASSES);
        }
      }
    }
    if (!found && status != Level.OFF) {
      final StatusConsoleListener listener=new StatusConsoleListener(status,stream);
      if (!verbose) {
        listener.setFilters(VERBOSE_CLASSES);
      }
      ((StatusLogger)LOGGER).registerListener(listener);
      for (      final String msg : messages) {
        LOGGER.error(msg);
      }
    }
  }
 catch (  final SAXException domEx) {
    LOGGER.error(""String_Node_Str"" + configSource.getLocation(),domEx);
  }
catch (  final IOException ioe) {
    LOGGER.error(""String_Node_Str"" + configSource.getLocation(),ioe);
  }
catch (  final ParserConfigurationException pex) {
    LOGGER.error(""String_Node_Str"" + configSource.getLocation(),pex);
  }
  if (strict && schema != null && buffer != null) {
    InputStream is=null;
    try {
      is=getClass().getClassLoader().getResourceAsStream(schema);
    }
 catch (    final Exception ex) {
      LOGGER.error(""String_Node_Str"" + schema);
    }
    if (is != null) {
      final Source src=new StreamSource(is,LOG4J_XSD);
      final SchemaFactory factory=SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
      Schema schema=null;
      try {
        schema=factory.newSchema(src);
      }
 catch (      final SAXException ex) {
        LOGGER.error(""String_Node_Str"",ex);
      }
      if (schema != null) {
        validator=schema.newValidator();
        try {
          validator.validate(new StreamSource(new ByteArrayInputStream(buffer)));
        }
 catch (        final IOException ioe) {
          LOGGER.error(""String_Node_Str"",ioe);
        }
catch (        final SAXException ex) {
          LOGGER.error(""String_Node_Str"",ex);
        }
      }
    }
  }
  if (getName() == null) {
    setName(configSource.getLocation());
  }
}","public XMLConfiguration(final ConfigurationFactory.ConfigurationSource configSource){
  this.configFile=configSource.getFile();
  byte[] buffer=null;
  try {
    final InputStream configStream=configSource.getInputStream();
    buffer=toByteArray(configStream);
    configStream.close();
    final InputSource source=new InputSource(new ByteArrayInputStream(buffer));
    final DocumentBuilder builder=DocumentBuilderFactory.newInstance().newDocumentBuilder();
    final Document document=builder.parse(source);
    rootElement=document.getDocumentElement();
    final Map<String,String> attrs=processAttributes(rootNode,rootElement);
    Level status=Level.OFF;
    boolean verbose=false;
    PrintStream stream=System.out;
    for (    final Map.Entry<String,String> entry : attrs.entrySet()) {
      if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        status=Level.toLevel(getSubst().replace(entry.getValue()),null);
        if (status == null) {
          status=Level.ERROR;
          messages.add(""String_Node_Str"" + entry.getValue() + ""String_Node_Str"");
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final String dest=entry.getValue();
        if (dest != null) {
          if (dest.equalsIgnoreCase(""String_Node_Str"")) {
            stream=System.err;
          }
 else {
            try {
              final File destFile=FileUtils.fileFromURI(new URI(dest));
              final String enc=Charset.defaultCharset().name();
              stream=new PrintStream(new FileOutputStream(destFile),true,enc);
            }
 catch (            final URISyntaxException use) {
              System.err.println(""String_Node_Str"" + dest + ""String_Node_Str"");
            }
          }
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        verbose=Boolean.parseBoolean(getSubst().replace(entry.getValue()));
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(getSubst().replace(entry.getKey()))) {
        final String[] packages=entry.getValue().split(""String_Node_Str"");
        for (        final String p : packages) {
          PluginManager.addPackage(p);
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        setName(getSubst().replace(entry.getValue()));
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        strict=Boolean.parseBoolean(getSubst().replace(entry.getValue()));
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        schema=getSubst().replace(entry.getValue());
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final int interval=Integer.parseInt(getSubst().replace(entry.getValue()));
        if (interval > 0 && configFile != null) {
          monitor=new FileConfigurationMonitor(this,configFile,listeners,interval);
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        final String advertiserString=getSubst().replace(entry.getValue());
        if (advertiserString != null) {
          @SuppressWarnings(""String_Node_Str"") final PluginType<Advertiser> type=getPluginManager().getPluginType(advertiserString);
          if (type != null) {
            final Class<Advertiser> clazz=type.getPluginClass();
            try {
              advertiser=clazz.newInstance();
              advertisedConfiguration=new HashMap<String,String>();
              advertisedConfiguration.put(""String_Node_Str"",new String(buffer));
              advertisedConfiguration.put(""String_Node_Str"",""String_Node_Str"");
              advertisedConfiguration.put(""String_Node_Str"",""String_Node_Str"");
              if (configSource.getLocation() != null) {
                advertisedConfiguration.put(""String_Node_Str"",configSource.getLocation());
              }
            }
 catch (            InstantiationException e) {
              System.err.println(""String_Node_Str"" + advertiserString);
            }
catch (            IllegalAccessException e) {
              System.err.println(""String_Node_Str"" + advertiserString);
            }
          }
        }
      }
    }
    final Iterator<StatusListener> iter=((StatusLogger)LOGGER).getListeners();
    boolean found=false;
    while (iter.hasNext()) {
      final StatusListener listener=iter.next();
      if (listener instanceof StatusConsoleListener) {
        found=true;
        ((StatusConsoleListener)listener).setLevel(status);
        if (!verbose) {
          ((StatusConsoleListener)listener).setFilters(VERBOSE_CLASSES);
        }
      }
    }
    if (!found && status != Level.OFF) {
      final StatusConsoleListener listener=new StatusConsoleListener(status,stream);
      if (!verbose) {
        listener.setFilters(VERBOSE_CLASSES);
      }
      ((StatusLogger)LOGGER).registerListener(listener);
      for (      final String msg : messages) {
        LOGGER.error(msg);
      }
    }
  }
 catch (  final SAXException domEx) {
    LOGGER.error(""String_Node_Str"" + configSource.getLocation(),domEx);
  }
catch (  final IOException ioe) {
    LOGGER.error(""String_Node_Str"" + configSource.getLocation(),ioe);
  }
catch (  final ParserConfigurationException pex) {
    LOGGER.error(""String_Node_Str"" + configSource.getLocation(),pex);
  }
  if (strict && schema != null && buffer != null) {
    InputStream is=null;
    try {
      is=getClass().getClassLoader().getResourceAsStream(schema);
    }
 catch (    final Exception ex) {
      LOGGER.error(""String_Node_Str"" + schema);
    }
    if (is != null) {
      final Source src=new StreamSource(is,LOG4J_XSD);
      final SchemaFactory factory=SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
      Schema schema=null;
      try {
        schema=factory.newSchema(src);
      }
 catch (      final SAXException ex) {
        LOGGER.error(""String_Node_Str"",ex);
      }
      if (schema != null) {
        validator=schema.newValidator();
        try {
          validator.validate(new StreamSource(new ByteArrayInputStream(buffer)));
        }
 catch (        final IOException ioe) {
          LOGGER.error(""String_Node_Str"",ioe);
        }
catch (        final SAXException ex) {
          LOGGER.error(""String_Node_Str"",ex);
        }
      }
    }
  }
  if (getName() == null) {
    setName(configSource.getLocation());
  }
}"
90721,"private void constructHierarchy(final Node node,final Element element){
  processAttributes(node,element);
  final StringBuffer buffer=new StringBuffer();
  final NodeList list=element.getChildNodes();
  final List<Node> children=node.getChildren();
  for (int i=0; i < list.getLength(); i++) {
    final org.w3c.dom.Node w3cNode=list.item(i);
    if (w3cNode instanceof Element) {
      final Element child=(Element)w3cNode;
      final String name=getType(child);
      final PluginType type=getPluginManager().getPluginType(name);
      final Node childNode=new Node(node,name,type);
      constructHierarchy(childNode,child);
      if (type == null) {
        final String value=childNode.getValue();
        if (!childNode.hasChildren() && value != null) {
          node.getAttributes().put(name,value);
        }
 else {
          status.add(new Status(name,element,ErrorType.CLASS_NOT_FOUND));
        }
      }
 else {
        children.add(childNode);
      }
    }
 else     if (w3cNode instanceof Text) {
      final Text data=(Text)w3cNode;
      buffer.append(data.getData());
    }
  }
  final String text=buffer.toString().trim();
  if (text.length() > 0 || (!node.hasChildren() && !node.isRoot())) {
    node.setValue(text);
  }
}","private void constructHierarchy(final Node node,final Element element){
  processAttributes(node,element);
  final StringBuffer buffer=new StringBuffer();
  final NodeList list=element.getChildNodes();
  final List<Node> children=node.getChildren();
  for (int i=0; i < list.getLength(); i++) {
    final org.w3c.dom.Node w3cNode=list.item(i);
    if (w3cNode instanceof Element) {
      final Element child=(Element)w3cNode;
      final String name=getType(child);
      final PluginType<?> type=getPluginManager().getPluginType(name);
      final Node childNode=new Node(node,name,type);
      constructHierarchy(childNode,child);
      if (type == null) {
        final String value=childNode.getValue();
        if (!childNode.hasChildren() && value != null) {
          node.getAttributes().put(name,value);
        }
 else {
          status.add(new Status(name,element,ErrorType.CLASS_NOT_FOUND));
        }
      }
 else {
        children.add(childNode);
      }
    }
 else     if (w3cNode instanceof Text) {
      final Text data=(Text)w3cNode;
      buffer.append(data.getData());
    }
  }
  final String text=buffer.toString().trim();
  if (text.length() > 0 || (!node.hasChildren() && !node.isRoot())) {
    node.setValue(text);
  }
}"
90722,"/** 
 * Main startup for the receiver.
 * @param args The command line arguments.
 * @throws Exception if an error occurs.
 */
public static void main(final String[] args) throws Exception {
  if (args.length != 4) {
    usage(""String_Node_Str"");
  }
  final String qcfBindingName=args[0];
  final String queueBindingName=args[1];
  final String username=args[2];
  final String password=args[3];
  new JMSQueueReceiver(qcfBindingName,queueBindingName,username,password);
  final BufferedReader stdin=new BufferedReader(new InputStreamReader(System.in));
  System.out.println(""String_Node_Str"");
  while (true) {
    final String s=stdin.readLine();
    if (s.equalsIgnoreCase(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
  }
}","/** 
 * Main startup for the receiver.
 * @param args The command line arguments.
 * @throws Exception if an error occurs.
 */
public static void main(final String[] args) throws Exception {
  if (args.length != 4) {
    usage(""String_Node_Str"");
  }
  final String qcfBindingName=args[0];
  final String queueBindingName=args[1];
  final String username=args[2];
  final String password=args[3];
  new JMSQueueReceiver(qcfBindingName,queueBindingName,username,password);
  final Charset enc=Charset.defaultCharset();
  final BufferedReader stdin=new BufferedReader(new InputStreamReader(System.in,enc));
  System.out.println(""String_Node_Str"");
  while (true) {
    final String s=stdin.readLine();
    if (s.equalsIgnoreCase(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
  }
}"
90723,"/** 
 * Main startup for the receiver.
 * @param args The command line arguments.
 * @throws Exception if an error occurs.
 */
public static void main(final String[] args) throws Exception {
  if (args.length != 4) {
    usage(""String_Node_Str"");
  }
  final String tcfBindingName=args[0];
  final String topicBindingName=args[1];
  final String username=args[2];
  final String password=args[3];
  new JMSTopicReceiver(tcfBindingName,topicBindingName,username,password);
  final BufferedReader stdin=new BufferedReader(new InputStreamReader(System.in));
  System.out.println(""String_Node_Str"");
  while (true) {
    final String s=stdin.readLine();
    if (s.equalsIgnoreCase(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
  }
}","/** 
 * Main startup for the receiver.
 * @param args The command line arguments.
 * @throws Exception if an error occurs.
 */
public static void main(final String[] args) throws Exception {
  if (args.length != 4) {
    usage(""String_Node_Str"");
  }
  final String tcfBindingName=args[0];
  final String topicBindingName=args[1];
  final String username=args[2];
  final String password=args[3];
  new JMSTopicReceiver(tcfBindingName,topicBindingName,username,password);
  final Charset enc=Charset.defaultCharset();
  final BufferedReader stdin=new BufferedReader(new InputStreamReader(System.in,enc));
  System.out.println(""String_Node_Str"");
  while (true) {
    final String s=stdin.readLine();
    if (s.equalsIgnoreCase(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
  }
}"
90724,"/** 
 * Main startup for the server.
 * @param args The command line arguments.
 * @throws Exception if an error occurs.
 */
public static void main(final String[] args) throws Exception {
  if (args.length < 1 || args.length > 2) {
    System.err.println(""String_Node_Str"");
    printUsage();
    return;
  }
  final int port=Integer.parseInt(args[0]);
  if (port <= 0 || port >= MAX_PORT) {
    System.err.println(""String_Node_Str"");
    printUsage();
    return;
  }
  if (args.length == 2 && args[1].length() > 0) {
    ConfigurationFactory.setConfigurationFactory(new ServerConfigurationFactory(args[1]));
  }
  logger=LogManager.getLogger(SocketServer.class.getName());
  final SocketServer sserver=new SocketServer(port);
  final Thread server=new Thread(sserver);
  server.start();
  final BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));
  while (true) {
    final String line=reader.readLine();
    if (line.equalsIgnoreCase(""String_Node_Str"") || line.equalsIgnoreCase(""String_Node_Str"") || line.equalsIgnoreCase(""String_Node_Str"")) {
      sserver.shutdown();
      server.join();
      break;
    }
  }
}","/** 
 * Main startup for the server.
 * @param args The command line arguments.
 * @throws Exception if an error occurs.
 */
public static void main(final String[] args) throws Exception {
  if (args.length < 1 || args.length > 2) {
    System.err.println(""String_Node_Str"");
    printUsage();
    return;
  }
  final int port=Integer.parseInt(args[0]);
  if (port <= 0 || port >= MAX_PORT) {
    System.err.println(""String_Node_Str"");
    printUsage();
    return;
  }
  if (args.length == 2 && args[1].length() > 0) {
    ConfigurationFactory.setConfigurationFactory(new ServerConfigurationFactory(args[1]));
  }
  logger=LogManager.getLogger(SocketServer.class.getName());
  final SocketServer sserver=new SocketServer(port);
  final Thread server=new Thread(sserver);
  server.start();
  final Charset enc=Charset.defaultCharset();
  final BufferedReader reader=new BufferedReader(new InputStreamReader(System.in,enc));
  while (true) {
    final String line=reader.readLine();
    if (line.equalsIgnoreCase(""String_Node_Str"") || line.equalsIgnoreCase(""String_Node_Str"") || line.equalsIgnoreCase(""String_Node_Str"")) {
      sserver.shutdown();
      server.join();
      break;
    }
  }
}"
90725,"/** 
 * Create a Console Appender.
 * @param layout The layout to use (required).
 * @param filter The Filter or null.
 * @param t The target (""SYSTEM_OUT"" or ""SYSTEM_ERR""). The default is ""SYSTEM_OUT"".
 * @param follow If true will follow changes to the underlying output stream.
 * @param name The name of the Appender (required).
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @return The ConsoleAppender.
 */
@PluginFactory public static <S extends Serializable>ConsoleAppender<S> createAppender(@PluginElement(""String_Node_Str"") Layout<S> layout,@PluginElement(""String_Node_Str"") final Filter filter,@PluginAttr(""String_Node_Str"") final String t,@PluginAttr(""String_Node_Str"") final String name,@PluginAttr(""String_Node_Str"") final String follow,@PluginAttr(""String_Node_Str"") final String suppress){
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (layout == null) {
    @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) Layout<S> l=(Layout<S>)PatternLayout.createLayout(null,null,null,null,null);
    layout=l;
  }
  final boolean isFollow=follow == null ? false : Boolean.valueOf(follow);
  final boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  final Target target=t == null ? Target.SYSTEM_OUT : Target.valueOf(t);
  return new ConsoleAppender<S>(name,layout,filter,getManager(isFollow,target),handleExceptions);
}","/** 
 * Create a Console Appender.
 * @param layout The layout to use (required).
 * @param filter The Filter or null.
 * @param t The target (""SYSTEM_OUT"" or ""SYSTEM_ERR""). The default is ""SYSTEM_OUT"".
 * @param follow If true will follow changes to the underlying output stream.
 * @param name The name of the Appender (required).
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @return The ConsoleAppender.
 */
@PluginFactory public static <S extends Serializable>ConsoleAppender<S> createAppender(@PluginElement(""String_Node_Str"") Layout<S> layout,@PluginElement(""String_Node_Str"") final Filter filter,@PluginAttr(""String_Node_Str"") final String t,@PluginAttr(""String_Node_Str"") final String name,@PluginAttr(""String_Node_Str"") final String follow,@PluginAttr(""String_Node_Str"") final String suppress){
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (layout == null) {
    @SuppressWarnings({""String_Node_Str""}) Layout<S> l=(Layout<S>)PatternLayout.createLayout(null,null,null,null,null);
    layout=l;
  }
  final boolean isFollow=follow == null ? false : Boolean.valueOf(follow);
  final boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  final Target target=t == null ? Target.SYSTEM_OUT : Target.valueOf(t);
  return new ConsoleAppender<S>(name,layout,filter,getManager(isFollow,target),handleExceptions);
}"
90726,"private static OutputStream getOutputStream(final boolean follow,final Target target){
  final PrintStream printStream=target == Target.SYSTEM_OUT ? follow ? new PrintStream(new SystemOutStream()) : System.out : follow ? new PrintStream(new SystemErrStream()) : System.err;
  PropertiesUtil propsUtil=PropertiesUtil.getProperties();
  if (!propsUtil.getStringProperty(""String_Node_Str"").startsWith(""String_Node_Str"") || propsUtil.getBooleanProperty(""String_Node_Str"")) {
    return printStream;
  }
 else {
    try {
      final ClassLoader loader=Loader.getClassLoader();
      final Class<?> clazz=loader.loadClass(""String_Node_Str"");
      final Constructor<?> constructor=clazz.getConstructor(OutputStream.class);
      return (OutputStream)constructor.newInstance(printStream);
    }
 catch (    final ClassNotFoundException cnfe) {
      LOGGER.debug(""String_Node_Str"");
    }
catch (    final NoSuchMethodException nsme) {
      LOGGER.warn(""String_Node_Str"");
    }
catch (    final Exception ex) {
      LOGGER.warn(""String_Node_Str"");
    }
    return printStream;
  }
}","private static OutputStream getOutputStream(final boolean follow,final Target target){
  final String enc=Charset.defaultCharset().name();
  PrintStream printStream=null;
  try {
    printStream=target == Target.SYSTEM_OUT ? follow ? new PrintStream(new SystemOutStream(),true,enc) : System.out : follow ? new PrintStream(new SystemErrStream(),true,enc) : System.err;
  }
 catch (  UnsupportedEncodingException ex) {
    throw new IllegalStateException(""String_Node_Str"" + enc,ex);
  }
  PropertiesUtil propsUtil=PropertiesUtil.getProperties();
  if (!propsUtil.getStringProperty(""String_Node_Str"").startsWith(""String_Node_Str"") || propsUtil.getBooleanProperty(""String_Node_Str"")) {
    return printStream;
  }
 else {
    try {
      final ClassLoader loader=Loader.getClassLoader();
      final Class<?> clazz=loader.loadClass(""String_Node_Str"");
      final Constructor<?> constructor=clazz.getConstructor(OutputStream.class);
      return (OutputStream)constructor.newInstance(printStream);
    }
 catch (    final ClassNotFoundException cnfe) {
      LOGGER.debug(""String_Node_Str"");
    }
catch (    final NoSuchMethodException nsme) {
      LOGGER.warn(""String_Node_Str"");
    }
catch (    final Exception ex) {
      LOGGER.warn(""String_Node_Str"");
    }
    return printStream;
  }
}"
90727,"/** 
 * Formats the Log Event as a byte array.
 * @param event The Log Event.
 * @return The formatted event as a byte array.
 */
@Override public byte[] toByteArray(final LogEvent event){
  return encoder.getBytes(toSerializable(event));
}","/** 
 * Formats the Log Event as a byte array.
 * @param event The Log Event.
 * @return The formatted event as a byte array.
 */
@Override public byte[] toByteArray(final LogEvent event){
  return toSerializable(event).getBytes(charset);
}"
90728,"protected AbstractStringLayout(final Charset charset){
  this.charset=charset;
  boolean useClass=false;
  try {
    if (String.class.getMethod(""String_Node_Str"",new Class[]{Charset.class}) != null) {
      useClass=true;
    }
  }
 catch (  final NoSuchMethodException ex) {
  }
  encoder=useClass ? new ClassEncoder() : new NameEncoder();
}","protected AbstractStringLayout(final Charset charset){
  this.charset=charset;
}"
90729,"/** 
 * Obtains an instance of pattern converter.
 * @param options options, may be null. May contain a list of level names andThe value that should be displayed for the Level.
 * @return instance of pattern converter.
 */
public static LevelPatternConverter newInstance(final String[] options){
  if (options == null || options.length == 0) {
    return INSTANCE;
  }
  final EnumMap<Level,String> levelMap=new EnumMap<Level,String>(Level.class);
  final String[] definitions=options[0].split(""String_Node_Str"");
  for (  final String def : definitions) {
    final String[] pair=def.split(""String_Node_Str"");
    if (pair == null || pair.length != 2) {
      LOGGER.error(""String_Node_Str"",def);
      continue;
    }
    final Level level=Level.toLevel(pair[0].trim(),null);
    if (level == null) {
      LOGGER.error(""String_Node_Str"",pair[0].trim());
    }
    levelMap.put(level,pair[1].trim());
  }
  if (levelMap.size() == 0) {
    return INSTANCE;
  }
  for (  final Level level : Level.values()) {
    if (!levelMap.containsKey(level)) {
      levelMap.put(level,level.toString());
    }
  }
  return new LevelPatternConverter(levelMap);
}","/** 
 * Obtains an instance of pattern converter.
 * @param options options, may be null. May contain a list of level names andThe value that should be displayed for the Level.
 * @return instance of pattern converter.
 */
public static LevelPatternConverter newInstance(final String[] options){
  if (options == null || options.length == 0) {
    return INSTANCE;
  }
  final EnumMap<Level,String> levelMap=new EnumMap<Level,String>(Level.class);
  final String[] definitions=options[0].split(""String_Node_Str"");
  for (  final String def : definitions) {
    final String[] pair=def.split(""String_Node_Str"");
    if (pair == null || pair.length != 2) {
      LOGGER.error(""String_Node_Str"",def);
      continue;
    }
    final Level level=Level.toLevel(pair[0].trim(),null);
    if (level == null) {
      LOGGER.error(""String_Node_Str"",pair[0].trim());
    }
 else {
      levelMap.put(level,pair[1].trim());
    }
  }
  if (levelMap.size() == 0) {
    return INSTANCE;
  }
  for (  final Level level : Level.values()) {
    if (!levelMap.containsKey(level)) {
      levelMap.put(level,level.toString());
    }
  }
  return new LevelPatternConverter(levelMap);
}"
90730,"public static void main(String[] args) throws Exception {
  final String ALL_ASYNC=""String_Node_Str"" + AsyncLoggerContextSelector.class.getName();
  final String CACHEDCLOCK=""String_Node_Str"";
  final String SYSCLOCK=""String_Node_Str"";
  final String LOG12=RunLog4j1.class.getName();
  final String LOG20=RunLog4j2.class.getName();
  final String LOGBK=RunLogback.class.getName();
  long start=System.nanoTime();
  List<Setup> tests=new ArrayList<PerfTestDriver.Setup>();
  tests.add(s(""String_Node_Str"",LOG20,""String_Node_Str"",ALL_ASYNC,SYSCLOCK));
  tests.add(s(""String_Node_Str"",LOG20,""String_Node_Str""));
  tests.add(s(""String_Node_Str"",LOGBK,""String_Node_Str""));
  tests.add(s(""String_Node_Str"",LOG12,""String_Node_Str""));
  tests.add(s(""String_Node_Str"",LOG20,""String_Node_Str""));
  tests.add(s(""String_Node_Str"",LOGBK,""String_Node_Str""));
  tests.add(s(""String_Node_Str"",LOG12,""String_Node_Str""));
  tests.add(s(""String_Node_Str"",LOG20,""String_Node_Str""));
  final int MAX_THREADS=16;
  for (int i=2; i <= MAX_THREADS; i*=2) {
    tests.add(m(""String_Node_Str"",LOGBK,""String_Node_Str"",i));
    tests.add(m(""String_Node_Str"",LOG12,""String_Node_Str"",i));
    tests.add(m(""String_Node_Str"",LOG20,""String_Node_Str"",i));
    tests.add(m(""String_Node_Str"",LOGBK,""String_Node_Str"",i));
    tests.add(m(""String_Node_Str"",LOG12,""String_Node_Str"",i));
    tests.add(m(""String_Node_Str"",LOG20,""String_Node_Str"",i));
    tests.add(m(""String_Node_Str"",LOG20,""String_Node_Str"",i,ALL_ASYNC,SYSCLOCK));
    tests.add(m(""String_Node_Str"",LOG20,""String_Node_Str"",i));
  }
  String java=args.length > 0 ? args[0] : ""String_Node_Str"";
  int repeat=args.length > 1 ? Integer.parseInt(args[1]) : 5;
  int x=0;
  for (  Setup config : tests) {
    System.out.print(config.description());
    ProcessBuilder pb=config.throughputTest(java);
    pb.redirectErrorStream(true);
    long t1=System.nanoTime();
    runPerfTest(repeat,x++,config,pb);
    System.out.printf(""String_Node_Str"",(System.nanoTime() - t1) / (1000.0 * 1000.0 * 1000.0));
    FileReader reader=new FileReader(config._temp);
    CharBuffer buffer=CharBuffer.allocate(256 * 1024);
    reader.read(buffer);
    reader.close();
    config._temp.delete();
    buffer.flip();
    String raw=buffer.toString();
    System.out.print(raw);
    Stats stats=new Stats(raw,repeat);
    System.out.println(stats);
    System.out.println(""String_Node_Str"");
    config._stats=stats;
  }
  new File(""String_Node_Str"").delete();
  System.out.printf(""String_Node_Str"",(System.nanoTime() - start) / (60.0 * 1000.0 * 1000.0* 1000.0));
  printRanking(tests.toArray(new Setup[tests.size()]));
}","public static void main(String[] args) throws Exception {
  final String ALL_ASYNC=""String_Node_Str"" + AsyncLoggerContextSelector.class.getName();
  final String CACHEDCLOCK=""String_Node_Str"";
  final String SYSCLOCK=""String_Node_Str"";
  final String LOG12=RunLog4j1.class.getName();
  final String LOG20=RunLog4j2.class.getName();
  final String LOGBK=RunLogback.class.getName();
  long start=System.nanoTime();
  List<Setup> tests=new ArrayList<PerfTestDriver.Setup>();
  tests.add(s(""String_Node_Str"",LOG20,""String_Node_Str"",ALL_ASYNC,SYSCLOCK));
  tests.add(s(""String_Node_Str"",LOG20,""String_Node_Str""));
  tests.add(s(""String_Node_Str"",LOGBK,""String_Node_Str""));
  tests.add(s(""String_Node_Str"",LOG12,""String_Node_Str""));
  tests.add(s(""String_Node_Str"",LOG20,""String_Node_Str""));
  tests.add(s(""String_Node_Str"",LOGBK,""String_Node_Str""));
  tests.add(s(""String_Node_Str"",LOG12,""String_Node_Str""));
  tests.add(s(""String_Node_Str"",LOG20,""String_Node_Str""));
  final int MAX_THREADS=16;
  for (int i=2; i <= MAX_THREADS; i*=2) {
    tests.add(m(""String_Node_Str"",LOGBK,""String_Node_Str"",i));
    tests.add(m(""String_Node_Str"",LOG12,""String_Node_Str"",i));
    tests.add(m(""String_Node_Str"",LOG20,""String_Node_Str"",i));
    tests.add(m(""String_Node_Str"",LOGBK,""String_Node_Str"",i));
    tests.add(m(""String_Node_Str"",LOG12,""String_Node_Str"",i));
    tests.add(m(""String_Node_Str"",LOG20,""String_Node_Str"",i));
    tests.add(m(""String_Node_Str"",LOG20,""String_Node_Str"",i,ALL_ASYNC,SYSCLOCK));
    tests.add(m(""String_Node_Str"",LOG20,""String_Node_Str"",i));
  }
  String java=args.length > 0 ? args[0] : ""String_Node_Str"";
  int repeat=args.length > 1 ? Integer.parseInt(args[1]) : 5;
  int x=0;
  for (  Setup config : tests) {
    System.out.print(config.description());
    ProcessBuilder pb=config.throughputTest(java);
    pb.redirectErrorStream(true);
    long t1=System.nanoTime();
    runPerfTest(repeat,x++,config,pb);
    System.out.printf(""String_Node_Str"",(System.nanoTime() - t1) / (1000.0 * 1000.0 * 1000.0));
    FileReader reader=new FileReader(config._temp);
    CharBuffer buffer=CharBuffer.allocate(256 * 1024);
    reader.read(buffer);
    reader.close();
    config._temp.delete();
    buffer.flip();
    String raw=buffer.toString();
    System.out.print(raw);
    Stats stats=new Stats(raw);
    System.out.println(stats);
    System.out.println(""String_Node_Str"");
    config._stats=stats;
  }
  new File(""String_Node_Str"").delete();
  System.out.printf(""String_Node_Str"",(System.nanoTime() - start) / (60.0 * 1000.0 * 1000.0* 1000.0));
  printRanking(tests.toArray(new Setup[tests.size()]));
}"
90731,"public Stats(String raw,int repeat){
  String[] lines=raw.split(""String_Node_Str"");
  long totalOps=0;
  for (  String line : lines) {
    if (line.startsWith(""String_Node_Str"")) {
      _latencyRowCount++;
      String[] parts=line.split(""String_Node_Str"");
      int i=0;
      _average+=Long.parseLong(parts[i++].split(""String_Node_Str"")[1]);
      _pct99+=Long.parseLong(parts[i++].split(""String_Node_Str"")[1]);
      _pct99_99+=Long.parseLong(parts[i++].split(""String_Node_Str"")[1]);
      _count+=Integer.parseInt(parts[i].split(""String_Node_Str"")[1]);
    }
 else {
      _throughputRowCount++;
      String number=line.substring(0,line.indexOf(' '));
      long opsPerSec=Long.parseLong(number);
      totalOps+=opsPerSec;
    }
  }
  _averageOpsPerSec=totalOps / _throughputRowCount;
}","public Stats(String raw){
  String[] lines=raw.split(""String_Node_Str"");
  long totalOps=0;
  for (  String line : lines) {
    if (line.startsWith(""String_Node_Str"")) {
      _latencyRowCount++;
      String[] parts=line.split(""String_Node_Str"");
      int i=0;
      _average+=Long.parseLong(parts[i++].split(""String_Node_Str"")[1]);
      _pct99+=Long.parseLong(parts[i++].split(""String_Node_Str"")[1]);
      _pct99_99+=Long.parseLong(parts[i++].split(""String_Node_Str"")[1]);
      _count+=Integer.parseInt(parts[i].split(""String_Node_Str"")[1]);
    }
 else {
      _throughputRowCount++;
      String number=line.substring(0,line.indexOf(' '));
      long opsPerSec=Long.parseLong(number);
      totalOps+=opsPerSec;
    }
  }
  _averageOpsPerSec=totalOps / _throughputRowCount;
}"
90732,"/** 
 * @see AppenderAdminMBean#PATTERN 
 */
public ObjectName getObjectName(){
  return objectName;
}","/** 
 * Returns the   {@code ObjectName} of this mbean.
 * @return the {@code ObjectName}
 * @see AppenderAdminMBean#PATTERN
 */
public ObjectName getObjectName(){
  return objectName;
}"
90733,"/** 
 * Throws a   {@code NullPointerException} if the specified parameter is{@code null}, otherwise returns the specified parameter. <p> Usage: <pre> // earlier you would write this: public SomeConstructor(Object param) { if (param == null) { throw new NullPointerException(name + &quot; is null&quot;); } this.field = param; } // now you can do the same in one line: public SomeConstructor(Object param) { this.field = Assert.isNotNull(param); } </pre>
 * @param checkMe the parameter to check
 * @param name name of the parameter to use in the error message if{@code null}
 * @return the specified parameter
 */
public static <T>T isNotNull(T checkMe,String name){
  if (checkMe == null) {
    throw new NullPointerException(name + ""String_Node_Str"");
  }
  return checkMe;
}","/** 
 * Throws a   {@code NullPointerException} if the specified parameter is{@code null}, otherwise returns the specified parameter. <p> Usage: <pre> // earlier you would write this: public SomeConstructor(Object param) { if (param == null) { throw new NullPointerException(name + &quot; is null&quot;); } this.field = param; } // now you can do the same in one line: public SomeConstructor(Object param) { this.field = Assert.isNotNull(param); } </pre>
 * @param < T > the type of the parameter to check and return
 * @param checkMe the parameter to check
 * @param name name of the parameter to use in the error message if{@code null}
 * @return the specified parameter
 */
public static <T>T isNotNull(T checkMe,String name){
  if (checkMe == null) {
    throw new NullPointerException(name + ""String_Node_Str"");
  }
  return checkMe;
}"
90734,"private void populateWidgets(){
  try {
    configTextArea.setText(contextAdmin.getConfigText());
  }
 catch (  Exception ex) {
    StringWriter sw=new StringWriter(2048);
    ex.printStackTrace(new PrintWriter(sw));
    configTextArea.setText(sw.toString());
  }
  String uri=contextAdmin.getConfigLocationURI();
  locationTextField.setText(uri);
}","private void populateWidgets(){
  try {
    configTextArea.setText(contextAdmin.getConfigText());
  }
 catch (  Exception ex) {
    StringWriter sw=new StringWriter(ERR_MSG_INITIAL_BUFFER_SIZE);
    ex.printStackTrace(new PrintWriter(sw));
    configTextArea.setText(sw.toString());
  }
  String uri=contextAdmin.getConfigLocationURI();
  locationTextField.setText(uri);
}"
90735,"private void createWidgets(){
  configTextArea=new JTextArea(CONFIG_TEXT_ROWS,CONFIG_TEXT_COLS);
  configTextArea.setBackground(Color.white);
  configTextArea.setForeground(Color.black);
  configTextArea.setFont(new Font(""String_Node_Str"",Font.PLAIN,configTextArea.getFont().getSize()));
  JScrollPane scrollConfig=new JScrollPane(configTextArea);
  locationTextField=new JTextField(LOCATION_TEXT_COLS);
  locationLabel=new JLabel(""String_Node_Str"");
  locationLabel.setLabelFor(locationTextField);
  buttonSendLocation=new JButton(actionReconfigureFromLocation);
  buttonSendConfigText=new JButton(actionReconfigureFromText);
  JPanel north=new JPanel();
  north.setLayout(new BoxLayout(north,BoxLayout.LINE_AXIS));
  north.add(locationLabel);
  north.add(locationTextField);
  north.add(buttonSendLocation);
  north.add(Box.createRigidArea(new Dimension(20,0)));
  north.add(buttonSendConfigText);
  this.setLayout(new BorderLayout());
  this.add(north,BorderLayout.NORTH);
  this.add(scrollConfig,BorderLayout.CENTER);
}","private void createWidgets(){
  configTextArea=new JTextArea(CONFIG_TEXT_ROWS,CONFIG_TEXT_COLS);
  configTextArea.setBackground(Color.white);
  configTextArea.setForeground(Color.black);
  configTextArea.setFont(new Font(""String_Node_Str"",Font.PLAIN,configTextArea.getFont().getSize()));
  JScrollPane scrollConfig=new JScrollPane(configTextArea);
  locationTextField=new JTextField(LOCATION_TEXT_COLS);
  locationLabel=new JLabel(""String_Node_Str"");
  locationLabel.setLabelFor(locationTextField);
  buttonSendLocation=new JButton(actionReconfigureFromLocation);
  buttonSendConfigText=new JButton(actionReconfigureFromText);
  JPanel north=new JPanel();
  north.setLayout(new BoxLayout(north,BoxLayout.LINE_AXIS));
  north.add(locationLabel);
  north.add(locationTextField);
  north.add(buttonSendLocation);
  north.add(Box.createRigidArea(new Dimension(HORIZONTAL_GAP,0)));
  north.add(buttonSendConfigText);
  this.setLayout(new BorderLayout());
  this.add(north,BorderLayout.NORTH);
  this.add(scrollConfig,BorderLayout.CENTER);
}"
90736,"/** 
 * Connects to the specified location and shows this panel in a window. <p> Useful links: http://www.componative.com/content/controller/developer/insights /jconsole3/
 * @param args must have at least one parameter, which specifies the location to connect to. Must be of the form  {@code host:port} or{@code service:jmx:rmi:///jndi/rmi://<host>:<port>/jmxrmi} or{@code service:jmx:rmi://<host>:<port>/jndi/rmi://<host>:<port>/jmxrmi}
 */
public static void main(String[] args) throws Exception {
  if (args.length < 1) {
    usage();
    return;
  }
  String serviceUrl=args[0];
  if (!serviceUrl.startsWith(""String_Node_Str"")) {
    serviceUrl=""String_Node_Str"" + args[0] + ""String_Node_Str"";
  }
  JMXServiceURL url=new JMXServiceURL(serviceUrl);
  Map<String,String> paramMap=new HashMap<String,String>();
  for (  Object objKey : System.getProperties().keySet()) {
    String key=(String)objKey;
    paramMap.put(key,System.getProperties().getProperty(key));
  }
  JMXConnector connector=JMXConnectorFactory.connect(url,paramMap);
  final Client client=new Client(connector);
  final String title=""String_Node_Str"" + url;
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      installLookAndFeel();
      try {
        ClientGUI gui=new ClientGUI(client);
        JFrame frame=new JFrame(title);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.getContentPane().add(gui,BorderLayout.CENTER);
        frame.pack();
        frame.setVisible(true);
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        StringWriter sr=new StringWriter();
        ex.printStackTrace(new PrintWriter(sr));
        JOptionPane.showMessageDialog(null,sr.toString(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
}","/** 
 * Connects to the specified location and shows this panel in a window. <p> Useful links: http://www.componative.com/content/controller/developer/insights /jconsole3/
 * @param args must have at least one parameter, which specifies thelocation to connect to. Must be of the form  {@code host:port}or   {@code service:jmx:rmi:///jndi/rmi://<host>:<port>/jmxrmi}or  {@code service:jmx:rmi://<host>:<port>/jndi/rmi://<host>:<port>/jmxrmi}
 * @throws Exception if anything goes wrong
 */
public static void main(String[] args) throws Exception {
  if (args.length < 1) {
    usage();
    return;
  }
  String serviceUrl=args[0];
  if (!serviceUrl.startsWith(""String_Node_Str"")) {
    serviceUrl=""String_Node_Str"" + args[0] + ""String_Node_Str"";
  }
  JMXServiceURL url=new JMXServiceURL(serviceUrl);
  Map<String,String> paramMap=new HashMap<String,String>();
  for (  Object objKey : System.getProperties().keySet()) {
    String key=(String)objKey;
    paramMap.put(key,System.getProperties().getProperty(key));
  }
  JMXConnector connector=JMXConnectorFactory.connect(url,paramMap);
  final Client client=new Client(connector);
  final String title=""String_Node_Str"" + url;
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      installLookAndFeel();
      try {
        ClientGUI gui=new ClientGUI(client);
        JFrame frame=new JFrame(title);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.getContentPane().add(gui,BorderLayout.CENTER);
        frame.pack();
        frame.setVisible(true);
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        StringWriter sr=new StringWriter();
        ex.printStackTrace(new PrintWriter(sr));
        JOptionPane.showMessageDialog(null,sr.toString(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
}"
90737,"/** 
 * @see ContextSelectorAdminMBean#NAME 
 */
public ObjectName getObjectName(){
  return objectName;
}","/** 
 * Returns the   {@code ObjectName} of this mbean.
 * @return the {@code ObjectName}
 * @see ContextSelectorAdminMBean#NAME
 */
public ObjectName getObjectName(){
  return objectName;
}"
90738,"/** 
 * @see LoggerConfigAdminMBean#PATTERN 
 */
public ObjectName getObjectName(){
  return objectName;
}","/** 
 * Returns the   {@code ObjectName} of this mbean.
 * @return the {@code ObjectName}
 * @see LoggerConfigAdminMBean#PATTERN
 */
public ObjectName getObjectName(){
  return objectName;
}"
90739,"/** 
 * Constructs a new   {@code LoggerContextAdmin} with the {@code Executor} tobe used for sending  {@code Notification}s asynchronously to listeners.
 * @param executor
 */
public LoggerContextAdmin(LoggerContext loggerContext,Executor executor){
  super(executor,createNotificationInfo());
  this.loggerContext=Assert.isNotNull(loggerContext,""String_Node_Str"");
  try {
    String ctxName=Server.escape(loggerContext.getName());
    String name=String.format(PATTERN,ctxName);
    objectName=new ObjectName(name);
  }
 catch (  Exception e) {
    throw new IllegalStateException(e);
  }
  loggerContext.addPropertyChangeListener(this);
}","/** 
 * Constructs a new   {@code LoggerContextAdmin} with the {@code Executor} tobe used for sending  {@code Notification}s asynchronously to listeners.
 * @param executor used to send notifications asynchronously
 * @param loggerContext the instrumented object
 */
public LoggerContextAdmin(LoggerContext loggerContext,Executor executor){
  super(executor,createNotificationInfo());
  this.loggerContext=Assert.isNotNull(loggerContext,""String_Node_Str"");
  try {
    String ctxName=Server.escape(loggerContext.getName());
    String name=String.format(PATTERN,ctxName);
    objectName=new ObjectName(name);
  }
 catch (  Exception e) {
    throw new IllegalStateException(e);
  }
  loggerContext.addPropertyChangeListener(this);
}"
90740,"/** 
 * @see LoggerContextAdminMBean#PATTERN 
 */
public ObjectName getObjectName(){
  return objectName;
}","/** 
 * Returns the   {@code ObjectName} of this mbean.
 * @return the {@code ObjectName}
 * @see LoggerContextAdminMBean#PATTERN
 */
public ObjectName getObjectName(){
  return objectName;
}"
90741,"/** 
 * Returns the configuration text, which may be the contents of the configuration file or the text that was last set with a call to  {@code setConfigText}.
 * @return the configuration text
 */
String getConfigText() throws IOException ;","/** 
 * Returns the configuration text, which may be the contents of the configuration file or the text that was last set with a call to  {@code setConfigText}.
 * @return the configuration text
 * @throws IOException if a problem occurred reading the contents of theconfig file.
 */
String getConfigText() throws IOException ;"
90742,"/** 
 * Sets the configuration location to the specified URI. This will cause the instrumented   {@code LoggerContext} to reconfigure.
 * @param configLocationURI location of the configuration file in{@link URI} format.
 * @throws URISyntaxException if the format of the specifiedconfigLocationURI is incorrect
 * @throws IOException if an error occurred reading the specified location
 */
void setConfigLocationURI(String configLocation) throws URISyntaxException, IOException ;","/** 
 * Sets the configuration location to the specified URI. This will cause the instrumented   {@code LoggerContext} to reconfigure.
 * @param configLocation location of the configuration file in{@link java.net.URI} format.
 * @throws URISyntaxException if the format of the specifiedconfigLocationURI is incorrect
 * @throws IOException if an error occurred reading the specified location
 */
void setConfigLocationURI(String configLocation) throws URISyntaxException, IOException ;"
90743,"/** 
 * Constructs a new   {@code StatusLoggerAdmin} with the {@code Executor} tobe used for sending  {@code Notification}s asynchronously to listeners.
 * @param executor
 */
public StatusLoggerAdmin(Executor executor){
  super(executor,createNotificationInfo());
  try {
    objectName=new ObjectName(NAME);
  }
 catch (  Exception e) {
    throw new IllegalStateException(e);
  }
  StatusLogger.getLogger().registerListener(this);
}","/** 
 * Constructs a new   {@code StatusLoggerAdmin} with the {@code Executor} tobe used for sending  {@code Notification}s asynchronously to listeners.
 * @param executor used to send notifications asynchronously
 */
public StatusLoggerAdmin(Executor executor){
  super(executor,createNotificationInfo());
  try {
    objectName=new ObjectName(NAME);
  }
 catch (  Exception e) {
    throw new IllegalStateException(e);
  }
  StatusLogger.getLogger().registerListener(this);
}"
90744,"/** 
 * @see StatusLoggerAdminMBean#NAME 
 */
public ObjectName getObjectName(){
  return objectName;
}","/** 
 * Returns the   {@code ObjectName} of this mbean.
 * @return the {@code ObjectName}
 * @see StatusLoggerAdminMBean#NAME
 */
public ObjectName getObjectName(){
  return objectName;
}"
90745,"/** 
 * Create a Flume Avro Appender.
 * @param agents An array of Agents.
 * @param delay The amount of time in milliseconds to wait between retries.
 * @param agentRetries The number of times to retry an agent before failing to the next agent.
 * @param name The name of the Appender.
 * @param suppress If true exceptions will be handled in the appender.
 * @param excludes A comma separated list of MDC elements to exclude.
 * @param includes A comma separated list of MDC elements to include.
 * @param required A comma separated list of MDC elements that are required.
 * @param mdcPrefix The prefix to add to MDC key names.
 * @param eventPrefix The prefix to add to event key names.
 * @param compressBody If true the event body will be compressed.
 * @param batchSize Number of events to include in a batch. Defaults to 1.
 * @param factory The factory to use to create Flume events.
 * @param layout The layout to format the event.
 * @param filter A Filter to filter events.
 * @return A Flume Avro Appender.
 */
@PluginFactory public static FlumeAppender createAppender(@PluginElement(""String_Node_Str"") Agent[] agents,@PluginElement(""String_Node_Str"") final Property[] properties,@PluginAttr(""String_Node_Str"") final String embedded,@PluginAttr(""String_Node_Str"") final String dataDir,@PluginAttr(""String_Node_Str"") final String delay,@PluginAttr(""String_Node_Str"") final String agentRetries,@PluginAttr(""String_Node_Str"") final String name,@PluginAttr(""String_Node_Str"") final String suppress,@PluginAttr(""String_Node_Str"") final String excludes,@PluginAttr(""String_Node_Str"") final String includes,@PluginAttr(""String_Node_Str"") final String required,@PluginAttr(""String_Node_Str"") final String mdcPrefix,@PluginAttr(""String_Node_Str"") final String eventPrefix,@PluginAttr(""String_Node_Str"") final String compressBody,@PluginAttr(""String_Node_Str"") final String batchSize,@PluginElement(""String_Node_Str"") final FlumeEventFactory factory,@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") final Filter filter){
  final boolean embed=embedded != null ? Boolean.valueOf(embedded) : (agents == null || agents.length == 0) && properties != null && properties.length > 0;
  final boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  final boolean compress=compressBody == null ? true : Boolean.valueOf(compressBody);
  final int batchCount=batchSize == null ? 1 : Integer.parseInt(batchSize);
  final int reconnectDelay=delay == null ? 0 : Integer.parseInt(delay);
  final int retries=agentRetries == null ? 0 : Integer.parseInt(agentRetries);
  if (layout == null) {
    layout=RFC5424Layout.createLayout(null,null,null,""String_Node_Str"",null,null,null,null,excludes,includes,required,null,null,null,null);
  }
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  AbstractFlumeManager manager;
  if (embed) {
    manager=FlumeEmbeddedManager.getManager(name,agents,properties,batchCount,dataDir);
  }
 else {
    if (agents == null || agents.length == 0) {
      LOGGER.debug(""String_Node_Str"");
      agents=new Agent[]{Agent.createAgent(null,null)};
    }
    manager=FlumeAvroManager.getManager(name,agents,batchCount);
  }
  if (manager == null) {
    return null;
  }
  return new FlumeAppender(name,filter,layout,handleExceptions,includes,excludes,required,mdcPrefix,eventPrefix,compress,reconnectDelay,retries,factory,manager);
}","/** 
 * Create a Flume Avro Appender.
 * @param agents An array of Agents.
 * @param properties Properties to pass to the embedded agent.
 * @param embedded true if the embedded agent manager should be used. otherwise the Avro mangaer will be used.
 * @param dataDir The directory where the Flume FileChannel should write its data.
 * @param delay The amount of time in milliseconds to wait between retries.
 * @param agentRetries The number of times to retry an agent before failing to the next agent.
 * @param name The name of the Appender.
 * @param suppress If true exceptions will be handled in the appender.
 * @param excludes A comma separated list of MDC elements to exclude.
 * @param includes A comma separated list of MDC elements to include.
 * @param required A comma separated list of MDC elements that are required.
 * @param mdcPrefix The prefix to add to MDC key names.
 * @param eventPrefix The prefix to add to event key names.
 * @param compressBody If true the event body will be compressed.
 * @param batchSize Number of events to include in a batch. Defaults to 1.
 * @param factory The factory to use to create Flume events.
 * @param layout The layout to format the event.
 * @param filter A Filter to filter events.
 * @return A Flume Avro Appender.
 */
@PluginFactory public static FlumeAppender createAppender(@PluginElement(""String_Node_Str"") Agent[] agents,@PluginElement(""String_Node_Str"") final Property[] properties,@PluginAttr(""String_Node_Str"") final String embedded,@PluginAttr(""String_Node_Str"") final String dataDir,@PluginAttr(""String_Node_Str"") final String delay,@PluginAttr(""String_Node_Str"") final String agentRetries,@PluginAttr(""String_Node_Str"") final String name,@PluginAttr(""String_Node_Str"") final String suppress,@PluginAttr(""String_Node_Str"") final String excludes,@PluginAttr(""String_Node_Str"") final String includes,@PluginAttr(""String_Node_Str"") final String required,@PluginAttr(""String_Node_Str"") final String mdcPrefix,@PluginAttr(""String_Node_Str"") final String eventPrefix,@PluginAttr(""String_Node_Str"") final String compressBody,@PluginAttr(""String_Node_Str"") final String batchSize,@PluginElement(""String_Node_Str"") final FlumeEventFactory factory,@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") final Filter filter){
  final boolean embed=embedded != null ? Boolean.valueOf(embedded) : (agents == null || agents.length == 0) && properties != null && properties.length > 0;
  final boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  final boolean compress=compressBody == null ? true : Boolean.valueOf(compressBody);
  final int batchCount=batchSize == null ? 1 : Integer.parseInt(batchSize);
  final int reconnectDelay=delay == null ? 0 : Integer.parseInt(delay);
  final int retries=agentRetries == null ? 0 : Integer.parseInt(agentRetries);
  if (layout == null) {
    layout=RFC5424Layout.createLayout(null,null,null,""String_Node_Str"",null,null,null,null,excludes,includes,required,null,null,null,null);
  }
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  AbstractFlumeManager manager;
  if (embed) {
    manager=FlumeEmbeddedManager.getManager(name,agents,properties,batchCount,dataDir);
  }
 else {
    if (agents == null || agents.length == 0) {
      LOGGER.debug(""String_Node_Str"");
      agents=new Agent[]{Agent.createAgent(null,null)};
    }
    manager=FlumeAvroManager.getManager(name,agents,batchCount);
  }
  if (manager == null) {
    return null;
  }
  return new FlumeAppender(name,filter,layout,handleExceptions,includes,excludes,required,mdcPrefix,eventPrefix,compress,reconnectDelay,retries,factory,manager);
}"
90746,"/** 
 * Returns a FlumeAvroManager.
 * @param agents The agents to use.
 * @param batchSize The number of events to include in a batch.
 * @return A FlumeAvroManager.
 */
public static FlumeAvroManager getManager(final String name,final Agent[] agents,int batchSize){
  if (agents == null || agents.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (batchSize <= 0) {
    batchSize=1;
  }
  final StringBuilder sb=new StringBuilder(""String_Node_Str"");
  boolean first=true;
  for (  final Agent agent : agents) {
    if (!first) {
      sb.append(""String_Node_Str"");
    }
    sb.append(agent.getHost()).append(""String_Node_Str"").append(agent.getPort());
    first=false;
  }
  sb.append(""String_Node_Str"");
  return (FlumeAvroManager)getManager(sb.toString(),factory,new FactoryData(name,agents,batchSize));
}","/** 
 * Returns a FlumeAvroManager.
 * @param name The name of the manager.
 * @param agents The agents to use.
 * @param batchSize The number of events to include in a batch.
 * @return A FlumeAvroManager.
 */
public static FlumeAvroManager getManager(final String name,final Agent[] agents,int batchSize){
  if (agents == null || agents.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (batchSize <= 0) {
    batchSize=1;
  }
  final StringBuilder sb=new StringBuilder(""String_Node_Str"");
  boolean first=true;
  for (  final Agent agent : agents) {
    if (!first) {
      sb.append(""String_Node_Str"");
    }
    sb.append(agent.getHost()).append(""String_Node_Str"").append(agent.getPort());
    first=false;
  }
  sb.append(""String_Node_Str"");
  return (FlumeAvroManager)getManager(sb.toString(),factory,new FactoryData(name,agents,batchSize));
}"
90747,"/** 
 * Returns a FlumeEmbeddedManager.
 * @param agents The agents to use.
 * @param batchSize The number of events to include in a batch.
 * @return A FlumeAvroManager.
 */
public static FlumeEmbeddedManager getManager(final String name,final Agent[] agents,final Property[] properties,int batchSize,final String dataDir){
  if (batchSize <= 0) {
    batchSize=1;
  }
  if ((agents == null || agents.length == 0) && (properties == null || properties.length == 0)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (agents != null && agents.length > 0 && properties != null && properties.length > 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final StringBuilder sb=new StringBuilder();
  boolean first=true;
  if (agents != null && agents.length > 0) {
    sb.append(""String_Node_Str"");
    for (    final Agent agent : agents) {
      if (!first) {
        sb.append(""String_Node_Str"");
      }
      sb.append(agent.getHost()).append(""String_Node_Str"").append(agent.getPort());
      first=false;
    }
    sb.append(""String_Node_Str"");
  }
 else {
    String sep=""String_Node_Str"";
    sb.append(name).append(""String_Node_Str"");
    final StringBuilder props=new StringBuilder();
    for (    final Property prop : properties) {
      props.append(sep);
      props.append(prop.getName()).append(""String_Node_Str"").append(prop.getValue());
      sep=""String_Node_Str"";
    }
    sb.append(NameUtil.md5(props.toString()));
  }
  return (FlumeEmbeddedManager)getManager(sb.toString(),factory,new FactoryData(name,agents,properties,batchSize,dataDir));
}","/** 
 * Returns a FlumeEmbeddedManager.
 * @param name The name of the manager.
 * @param agents The agents to use.
 * @param properties Properties for the embedded manager.
 * @param batchSize The number of events to include in a batch.
 * @param dataDir The directory where the Flume FileChannel should write to.
 * @return A FlumeAvroManager.
 */
public static FlumeEmbeddedManager getManager(final String name,final Agent[] agents,final Property[] properties,int batchSize,final String dataDir){
  if (batchSize <= 0) {
    batchSize=1;
  }
  if ((agents == null || agents.length == 0) && (properties == null || properties.length == 0)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (agents != null && agents.length > 0 && properties != null && properties.length > 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final StringBuilder sb=new StringBuilder();
  boolean first=true;
  if (agents != null && agents.length > 0) {
    sb.append(""String_Node_Str"");
    for (    final Agent agent : agents) {
      if (!first) {
        sb.append(""String_Node_Str"");
      }
      sb.append(agent.getHost()).append(""String_Node_Str"").append(agent.getPort());
      first=false;
    }
    sb.append(""String_Node_Str"");
  }
 else {
    String sep=""String_Node_Str"";
    sb.append(name).append(""String_Node_Str"");
    final StringBuilder props=new StringBuilder();
    for (    final Property prop : properties) {
      props.append(sep);
      props.append(prop.getName()).append(""String_Node_Str"").append(prop.getValue());
      sep=""String_Node_Str"";
    }
    sb.append(NameUtil.md5(props.toString()));
  }
  return (FlumeEmbeddedManager)getManager(sb.toString(),factory,new FactoryData(name,agents,properties,batchSize,dataDir));
}"
90748,"private Properties createProperties(final String name,final Agent[] agents,final Property[] properties,final int batchSize,String dataDir){
  final Properties props=new Properties();
  if ((agents == null || agents.length == 0) && (properties == null || properties.length == 0)) {
    LOGGER.error(""String_Node_Str"");
    throw new ConfigurationException(""String_Node_Str"");
  }
  if ((agents != null && agents.length > 0 && properties != null && properties.length > 0)) {
    LOGGER.error(""String_Node_Str"");
    throw new ConfigurationException(""String_Node_Str"");
  }
  if (agents != null && agents.length > 0) {
    props.put(name + ""String_Node_Str"",FlumeEmbeddedManager.SOURCE_NAME);
    props.put(name + ""String_Node_Str"" + FlumeEmbeddedManager.SOURCE_NAME+ ""String_Node_Str"",sourceType);
    props.put(name + ""String_Node_Str"",""String_Node_Str"");
    props.put(name + ""String_Node_Str"",""String_Node_Str"");
    if (dataDir != null && dataDir.length() > 0) {
      if (!dataDir.endsWith(Constants.LINE_SEP)) {
        dataDir=dataDir + Constants.LINE_SEP;
      }
      props.put(name + ""String_Node_Str"",dataDir + ""String_Node_Str"");
      props.put(name + ""String_Node_Str"",dataDir + ""String_Node_Str"");
    }
    final StringBuilder sb=new StringBuilder();
    String leading=""String_Node_Str"";
    int priority=agents.length;
    for (int i=0; i < agents.length; ++i) {
      sb.append(leading).append(""String_Node_Str"").append(i);
      leading=""String_Node_Str"";
      final String prefix=name + ""String_Node_Str"" + i;
      props.put(prefix + ""String_Node_Str"",""String_Node_Str"");
      props.put(prefix + ""String_Node_Str"",""String_Node_Str"");
      props.put(prefix + ""String_Node_Str"",agents[i].getHost());
      props.put(prefix + ""String_Node_Str"",Integer.toString(agents[i].getPort()));
      props.put(prefix + ""String_Node_Str"",Integer.toString(batchSize));
      props.put(name + ""String_Node_Str"" + i,Integer.toString(priority));
      --priority;
    }
    props.put(name + ""String_Node_Str"",sb.toString());
    props.put(name + ""String_Node_Str"",""String_Node_Str"");
    props.put(name + ""String_Node_Str"",sb.toString());
    props.put(name + ""String_Node_Str"",""String_Node_Str"");
    final String sourceChannels=""String_Node_Str"";
    props.put(name + ""String_Node_Str"",sourceChannels);
    props.put(name + ""String_Node_Str"" + FlumeEmbeddedManager.SOURCE_NAME+ ""String_Node_Str"",sourceChannels);
  }
 else {
    String channels=null;
    String[] sinks=null;
    props.put(name + ""String_Node_Str"",FlumeEmbeddedManager.SOURCE_NAME);
    props.put(name + ""String_Node_Str"" + FlumeEmbeddedManager.SOURCE_NAME+ ""String_Node_Str"",sourceType);
    for (    final Property property : properties) {
      final String key=property.getName();
      if (key == null || key.length() == 0) {
        final String msg=""String_Node_Str"";
        LOGGER.error(msg);
        throw new ConfigurationException(msg);
      }
      final String upperKey=key.toUpperCase(Locale.ENGLISH);
      if (upperKey.startsWith(name.toUpperCase(Locale.ENGLISH))) {
        final String msg=""String_Node_Str"" + key;
        LOGGER.error(msg);
        throw new ConfigurationException(msg);
      }
      if (upperKey.startsWith(""String_Node_Str"")) {
        final String msg=""String_Node_Str"" + key;
        LOGGER.error(msg);
        throw new ConfigurationException(msg);
      }
      final String value=property.getValue();
      if (value == null || value.length() == 0) {
        final String msg=""String_Node_Str"" + key + ""String_Node_Str"";
        LOGGER.error(msg);
        throw new ConfigurationException(msg);
      }
      if (upperKey.equals(""String_Node_Str"")) {
        channels=value.trim();
      }
 else       if (upperKey.equals(""String_Node_Str"")) {
        sinks=value.trim().split(""String_Node_Str"");
      }
      props.put(name + '.' + key,value);
    }
    String sourceChannels=channels;
    if (channels == null) {
      sourceChannels=""String_Node_Str"";
      props.put(name + ""String_Node_Str"",sourceChannels);
    }
    props.put(name + ""String_Node_Str"" + FlumeEmbeddedManager.SOURCE_NAME+ ""String_Node_Str"",sourceChannels);
    if (sinks == null || sinks.length == 0) {
      final String msg=""String_Node_Str"";
      LOGGER.error(msg);
      throw new ConfigurationException(msg);
    }
  }
  return props;
}","private Properties createProperties(final String name,final Agent[] agents,final Property[] properties,final int batchSize,String dataDir){
  final Properties props=new Properties();
  if ((agents == null || agents.length == 0) && (properties == null || properties.length == 0)) {
    LOGGER.error(""String_Node_Str"");
    throw new ConfigurationException(""String_Node_Str"");
  }
  if ((agents != null && agents.length > 0 && properties != null && properties.length > 0)) {
    LOGGER.error(""String_Node_Str"");
    throw new ConfigurationException(""String_Node_Str"");
  }
  if (agents != null && agents.length > 0) {
    props.put(name + ""String_Node_Str"",FlumeEmbeddedManager.SOURCE_NAME);
    props.put(name + ""String_Node_Str"" + FlumeEmbeddedManager.SOURCE_NAME+ ""String_Node_Str"",SOURCE_TYPE);
    props.put(name + ""String_Node_Str"",""String_Node_Str"");
    props.put(name + ""String_Node_Str"",""String_Node_Str"");
    if (dataDir != null && dataDir.length() > 0) {
      if (!dataDir.endsWith(Constants.LINE_SEP)) {
        dataDir=dataDir + Constants.LINE_SEP;
      }
      props.put(name + ""String_Node_Str"",dataDir + ""String_Node_Str"");
      props.put(name + ""String_Node_Str"",dataDir + ""String_Node_Str"");
    }
    final StringBuilder sb=new StringBuilder();
    String leading=""String_Node_Str"";
    int priority=agents.length;
    for (int i=0; i < agents.length; ++i) {
      sb.append(leading).append(""String_Node_Str"").append(i);
      leading=""String_Node_Str"";
      final String prefix=name + ""String_Node_Str"" + i;
      props.put(prefix + ""String_Node_Str"",""String_Node_Str"");
      props.put(prefix + ""String_Node_Str"",""String_Node_Str"");
      props.put(prefix + ""String_Node_Str"",agents[i].getHost());
      props.put(prefix + ""String_Node_Str"",Integer.toString(agents[i].getPort()));
      props.put(prefix + ""String_Node_Str"",Integer.toString(batchSize));
      props.put(name + ""String_Node_Str"" + i,Integer.toString(priority));
      --priority;
    }
    props.put(name + ""String_Node_Str"",sb.toString());
    props.put(name + ""String_Node_Str"",""String_Node_Str"");
    props.put(name + ""String_Node_Str"",sb.toString());
    props.put(name + ""String_Node_Str"",""String_Node_Str"");
    final String sourceChannels=""String_Node_Str"";
    props.put(name + ""String_Node_Str"",sourceChannels);
    props.put(name + ""String_Node_Str"" + FlumeEmbeddedManager.SOURCE_NAME+ ""String_Node_Str"",sourceChannels);
  }
 else {
    String channels=null;
    String[] sinks=null;
    props.put(name + ""String_Node_Str"",FlumeEmbeddedManager.SOURCE_NAME);
    props.put(name + ""String_Node_Str"" + FlumeEmbeddedManager.SOURCE_NAME+ ""String_Node_Str"",SOURCE_TYPE);
    for (    final Property property : properties) {
      final String key=property.getName();
      if (key == null || key.length() == 0) {
        final String msg=""String_Node_Str"";
        LOGGER.error(msg);
        throw new ConfigurationException(msg);
      }
      final String upperKey=key.toUpperCase(Locale.ENGLISH);
      if (upperKey.startsWith(name.toUpperCase(Locale.ENGLISH))) {
        final String msg=""String_Node_Str"" + key;
        LOGGER.error(msg);
        throw new ConfigurationException(msg);
      }
      if (upperKey.startsWith(""String_Node_Str"")) {
        final String msg=""String_Node_Str"" + key;
        LOGGER.error(msg);
        throw new ConfigurationException(msg);
      }
      final String value=property.getValue();
      if (value == null || value.length() == 0) {
        final String msg=""String_Node_Str"" + key + ""String_Node_Str"";
        LOGGER.error(msg);
        throw new ConfigurationException(msg);
      }
      if (upperKey.equals(""String_Node_Str"")) {
        channels=value.trim();
      }
 else       if (upperKey.equals(""String_Node_Str"")) {
        sinks=value.trim().split(""String_Node_Str"");
      }
      props.put(name + '.' + key,value);
    }
    String sourceChannels=channels;
    if (channels == null) {
      sourceChannels=""String_Node_Str"";
      props.put(name + ""String_Node_Str"",sourceChannels);
    }
    props.put(name + ""String_Node_Str"" + FlumeEmbeddedManager.SOURCE_NAME+ ""String_Node_Str"",sourceChannels);
    if (sinks == null || sinks.length == 0) {
      final String msg=""String_Node_Str"";
      LOGGER.error(msg);
      throw new ConfigurationException(msg);
    }
  }
  return props;
}"
90749,"public void stop(){
  logger.info(""String_Node_Str"");
  supervisor.stop();
  lifecycleState=LifecycleState.STOP;
}","public void stop(){
  LOGGER.info(""String_Node_Str"");
  supervisor.stop();
  lifecycleState=LifecycleState.STOP;
}"
90750,"public void start(){
  Preconditions.checkState(nodeManager != null,""String_Node_Str"");
  supervisor.start();
  logger.info(""String_Node_Str"");
  supervisor.supervise(nodeManager,new LifecycleSupervisor.SupervisorPolicy.AlwaysRestartPolicy(),LifecycleState.START);
  lifecycleState=LifecycleState.START;
}","public void start(){
  Preconditions.checkState(nodeManager != null,""String_Node_Str"");
  supervisor.start();
  LOGGER.info(""String_Node_Str"");
  supervisor.supervise(nodeManager,new LifecycleSupervisor.SupervisorPolicy.AlwaysRestartPolicy(),LifecycleState.START);
  lifecycleState=LifecycleState.START;
}"
90751,"@Override public synchronized void stop(){
  super.stop();
  logger.info(""String_Node_Str"",sourceCounter);
}","@Override public synchronized void stop(){
  super.stop();
  LOGGER.info(""String_Node_Str"",sourceCounter);
}"
90752,"@Override public synchronized void start(){
  super.start();
  logger.info(""String_Node_Str"");
}","@Override public synchronized void start(){
  super.start();
  LOGGER.info(""String_Node_Str"");
}"
90753,"public void send(final FlumeEvent event){
  sourceCounter.incrementAppendReceivedCount();
  sourceCounter.incrementEventReceivedCount();
  try {
    getChannelProcessor().processEvent(event);
  }
 catch (  final ChannelException ex) {
    logger.warn(""String_Node_Str"" + event,ex);
    throw ex;
  }
  sourceCounter.incrementAppendAcceptedCount();
  sourceCounter.incrementEventAcceptedCount();
}","public void send(final FlumeEvent event){
  sourceCounter.incrementAppendReceivedCount();
  sourceCounter.incrementEventReceivedCount();
  try {
    getChannelProcessor().processEvent(event);
  }
 catch (  final ChannelException ex) {
    LOGGER.warn(""String_Node_Str"" + event,ex);
    throw ex;
  }
  sourceCounter.incrementAppendAcceptedCount();
  sourceCounter.incrementEventAcceptedCount();
}"
90754,"@Override protected void log(final Marker marker,final String fqcn,final Level level,final Message data,final Throwable t){
  if (locationAwareLogger != null) {
    if (data instanceof LoggerNameAwareMessage) {
      ((LoggerNameAwareMessage)data).setLoggerName(getName());
    }
    locationAwareLogger.log(getMarker(marker),fqcn,convertLevel(level),data.getFormattedMessage(),data.getParameters(),t);
  }
 else {
switch (level) {
case DEBUG:
      logger.debug(getMarker(marker),data.getFormattedMessage(),data.getParameters(),t);
case TRACE:
    logger.trace(getMarker(marker),data.getFormattedMessage(),data.getParameters(),t);
case INFO:
  logger.info(getMarker(marker),data.getFormattedMessage(),data.getParameters(),t);
case WARN:
logger.warn(getMarker(marker),data.getFormattedMessage(),data.getParameters(),t);
case ERROR:
logger.error(getMarker(marker),data.getFormattedMessage(),data.getParameters(),t);
default :
logger.error(getMarker(marker),data.getFormattedMessage(),data.getParameters(),t);
}
}
}","@Override protected void log(final Marker marker,final String fqcn,final Level level,final Message data,final Throwable t){
  if (locationAwareLogger != null) {
    if (data instanceof LoggerNameAwareMessage) {
      ((LoggerNameAwareMessage)data).setLoggerName(getName());
    }
    locationAwareLogger.log(getMarker(marker),fqcn,convertLevel(level),data.getFormattedMessage(),data.getParameters(),t);
  }
 else {
switch (level) {
case DEBUG:
      logger.debug(getMarker(marker),data.getFormattedMessage(),data.getParameters(),t);
    break;
case TRACE:
  logger.trace(getMarker(marker),data.getFormattedMessage(),data.getParameters(),t);
break;
case INFO:
logger.info(getMarker(marker),data.getFormattedMessage(),data.getParameters(),t);
break;
case WARN:
logger.warn(getMarker(marker),data.getFormattedMessage(),data.getParameters(),t);
break;
case ERROR:
logger.error(getMarker(marker),data.getFormattedMessage(),data.getParameters(),t);
break;
default :
logger.error(getMarker(marker),data.getFormattedMessage(),data.getParameters(),t);
break;
}
}
}"
90755,"public LoggerContext getContext(final String FQCN,final ClassLoader loader,final boolean currentContext){
  return context;
}","public LoggerContext getContext(final String fqcn,final ClassLoader loader,final boolean currentContext){
  return context;
}"
90756,"/** 
 * Creates   {@link StringFormattedMessage} instances.
 * @see MessageFactory#newMessage(String,Object)
 */
@Override public Message newMessage(final String message,final Object... params){
  return new FormattedMessage(message,params);
}","/** 
 * Creates   {@link StringFormattedMessage} instances.
 * @param message The message format.
 * @param params Message parameters.
 * @return The Message object.
 * @see MessageFactory#newMessage(String,Object)
 */
@Override public Message newMessage(final String message,final Object... params){
  return new FormattedMessage(message,params);
}"
90757,"/** 
 * Creates   {@link org.apache.logging.log4j.message.StringFormattedMessage} instances.
 * @see org.apache.logging.log4j.message.MessageFactory#newMessage(String,Object)
 */
@Override public Message newMessage(final String message,final Object... params){
  if (bundle == null) {
    return new LocalizedMessage(bundleId,message,params);
  }
  return new LocalizedMessage(bundle,message,params);
}","/** 
 * Creates   {@link org.apache.logging.log4j.message.StringFormattedMessage} instances.
 * @param message The message format String.
 * @param params The parameters for the message.
 * @return The Message.
 * @see org.apache.logging.log4j.message.MessageFactory#newMessage(String,Object)
 */
@Override public Message newMessage(final String message,final Object... params){
  if (bundle == null) {
    return new LocalizedMessage(bundleId,message,params);
  }
  return new LocalizedMessage(bundle,message,params);
}"
90758,"/** 
 * Creates   {@link org.apache.logging.log4j.message.StringFormattedMessage} instances.
 * @see org.apache.logging.log4j.message.MessageFactory#newMessage(String,Object)
 */
@Override public Message newMessage(final String message,final Object... params){
  return new MessageFormatMessage(message,params);
}","/** 
 * Creates   {@link org.apache.logging.log4j.message.StringFormattedMessage} instances.
 * @param message The message pattern.
 * @param params Parameters to the message.
 * @return The Message.
 * @see org.apache.logging.log4j.message.MessageFactory#newMessage(String,Object)
 */
@Override public Message newMessage(final String message,final Object... params){
  return new MessageFormatMessage(message,params);
}"
90759,"/** 
 * Set the name of this appender. The name is used by other components to identify this appender.
 * @since 0.8.1
 */
public void setName(String name);","/** 
 * Set the name of this appender. The name is used by other components to identify this appender.
 * @param name The appender name.
 * @since 0.8.1
 */
void setName(String name);"
90760,"/** 
 * Returns the head Filter. The Filters are organized in a linked list and so all Filters on this Appender are available through the result.
 * @return the head Filter or null, if no Filters are present
 * @since 1.1
 */
public Filter getFilter();","/** 
 * Returns the head Filter. The Filters are organized in a linked list and so all Filters on this Appender are available through the result.
 * @return the head Filter or null, if no Filters are present
 * @since 1.1
 */
Filter getFilter();"
90761,"/** 
 * Returns the   {@link ErrorHandler} for this appender.
 * @since 1.1
 */
public ErrorHandler getErrorHandler();","/** 
 * Returns the   {@link ErrorHandler} for this appender.
 * @return The error handler.
 * @since 1.1
 */
ErrorHandler getErrorHandler();"
90762,"/** 
 * Returns this appenders layout.
 * @since 1.1
 */
public Layout getLayout();","/** 
 * Returns this appenders layout.
 * @return the Layout.
 * @since 1.1
 */
Layout getLayout();"
90763,"/** 
 * Get the name of this appender.
 * @return name, may be null.
 */
public String getName();","/** 
 * Get the name of this appender.
 * @return name, may be null.
 */
String getName();"
90764,"/** 
 * Log in <code>Appender</code> specific way. When appropriate, Loggers will call the <code>doAppend</code> method of appender implementations in order to log.
 */
public void doAppend(LoggingEvent event);","/** 
 * Log in <code>Appender</code> specific way. When appropriate, Loggers will call the <code>doAppend</code> method of appender implementations in order to log.
 * @param event The LoggingEvent.
 */
void doAppend(LoggingEvent event);"
90765,"/** 
 * Set the   {@link ErrorHandler} for this appender.
 * @since 0.9.0
 */
public void setErrorHandler(ErrorHandler errorHandler);","/** 
 * Set the   {@link ErrorHandler} for this appender.
 * @param errorHandler The error handler.
 * @since 0.9.0
 */
void setErrorHandler(ErrorHandler errorHandler);"
90766,"/** 
 * Add a filter to the end of the filter list.
 * @since 0.9.0
 */
void addFilter(Filter newFilter);","/** 
 * Add a filter to the end of the filter list.
 * @param newFilter The filter to add.
 * @since 0.9.0
 */
void addFilter(Filter newFilter);"
90767,"/** 
 * Configurators call this method to determine if the appender requires a layout. If this method returns   {@code true}, meaning that layout is required, then the configurator will configure an layout using the configuration information at its disposal.  If this method returns   {@code false}, meaning that a layout is not required, then layout configuration will be skipped even if there is available layout configuration information at the disposal of the configurator.. <p/> <p>In the rather exceptional case, where the appender implementation admits a layout but can also work without it, then the appender should return   {@code true}.
 * @since 0.8.4
 */
public boolean requiresLayout();","/** 
 * Configurators call this method to determine if the appender requires a layout. If this method returns   {@code true}, meaning that layout is required, then the configurator will configure an layout using the configuration information at its disposal.  If this method returns   {@code false}, meaning that a layout is not required, then layout configuration will be skipped even if there is available layout configuration information at the disposal of the configurator.. <p/> <p>In the rather exceptional case, where the appender implementation admits a layout but can also work without it, then the appender should return   {@code true}.
 * @return true if a Layout is required.
 * @since 0.8.4
 */
boolean requiresLayout();"
90768,"/** 
 * Clear the list of filters by removing all the filters in it.
 * @since 0.9.0
 */
public void clearFilters();","/** 
 * Clear the list of filters by removing all the filters in it.
 * @since 0.9.0
 */
void clearFilters();"
90769,"/** 
 * Set the   {@link Layout} for this appender.
 * @since 0.8.1
 */
public void setLayout(Layout layout);","/** 
 * Set the   {@link Layout} for this appender.
 * @param layout The Layout.
 * @since 0.8.1
 */
void setLayout(Layout layout);"
90770,"/** 
 * Release any resources allocated within the appender such as file handles, network connections, etc. <p/> <p>It is a programming error to append to a closed appender.
 * @since 0.8.4
 */
public void close();","/** 
 * Release any resources allocated within the appender such as file handles, network connections, etc. <p/> <p>It is a programming error to append to a closed appender.
 * @since 0.8.4
 */
void close();"
90771,"/** 
 * No-op implementation.
 */
public static void configure(final Appender appender){
}","/** 
 * No-op implementation.
 * @param appender The appender.
 */
public static void configure(final Appender appender){
}"
90772,"/** 
 * Returns all the currently defined categories in the default hierarchy as an   {@link java.util.Enumeration Enumeration}. <p>The root category is <em>not</em> included in the returned  {@link Enumeration}.
 * @deprecated Please use {@link LogManager#getCurrentLoggers()} instead.
 */
@Deprecated public static Enumeration getCurrentCategories(){
  return LogManager.getCurrentLoggers();
}","/** 
 * Returns all the currently defined categories in the default hierarchy as an   {@link java.util.Enumeration Enumeration}. <p>The root category is <em>not</em> included in the returned  {@link Enumeration}.
 * @return and Enumeration of the Categories.
 * @deprecated Please use {@link LogManager#getCurrentLoggers()} instead.
 */
@Deprecated public static Enumeration getCurrentCategories(){
  return LogManager.getCurrentLoggers();
}"
90773,"/** 
 * Is the appender passed as parameter attached to this category?
 * @param appender The Appender to add.
 */
public boolean isAttached(final Appender appender){
  return false;
}","/** 
 * Is the appender passed as parameter attached to this category?
 * @param appender The Appender to add.
 * @return true if the appender is attached.
 */
public boolean isAttached(final Appender appender){
  return false;
}"
90774,"/** 
 * Returns the footer for the layout format. The base class returns <code>null</code>.
 */
public String getFooter(){
  return null;
}","/** 
 * Returns the footer for the layout format. The base class returns <code>null</code>.
 * @return The footer.
 */
public String getFooter(){
  return null;
}"
90775,"/** 
 * Implement this method to create your own layout format.
 */
public abstract String format(LoggingEvent event);","/** 
 * Implement this method to create your own layout format.
 * @param event The LoggingEvent.
 * @return The formatted LoggingEvent.
 */
public abstract String format(LoggingEvent event);"
90776,"/** 
 * Returns the content type output by this layout. The base class returns ""text/plain"".
 */
public String getContentType(){
  return ""String_Node_Str"";
}","/** 
 * Returns the content type output by this layout. The base class returns ""text/plain"".
 * @return the type of content rendered by the Layout.
 */
public String getContentType(){
  return ""String_Node_Str"";
}"
90777,"/** 
 * If the layout handles the throwable object contained within  {@link LoggingEvent}, then the layout should return  {@code false}. Otherwise, if the layout ignores throwable object, then the layout should return   {@code true}. If ignoresThrowable is true, the appender is responsible for rendering the throwable. <p/> <p>The   {@link SimpleLayout},   {@link TTCCLayout},   {@link PatternLayout} all return {@code true}. The   {@link org.apache.log4j.xml.XMLLayout} returns {@code false}.
 * @since 0.8.4
 */
public abstract boolean ignoresThrowable();","/** 
 * If the layout handles the throwable object contained within  {@link LoggingEvent}, then the layout should return  {@code false}. Otherwise, if the layout ignores throwable object, then the layout should return   {@code true}. If ignoresThrowable is true, the appender is responsible for rendering the throwable. <p/> <p>The   {@link SimpleLayout},   {@link TTCCLayout},   {@link PatternLayout} all return {@code true}. The   {@link org.apache.log4j.xml.XMLLayout} returns {@code false}.
 * @return true if the Layout ignores Throwables.
 * @since 0.8.4
 */
public abstract boolean ignoresThrowable();"
90778,"/** 
 * Returns the header for the layout format. The base class returns <code>null</code>.
 */
public String getHeader(){
  return null;
}","/** 
 * Returns the header for the layout format. The base class returns <code>null</code>.
 * @return The header.
 */
public String getHeader(){
  return null;
}"
90779,"/** 
 * No-op implementation.
 * @param selector The RepositorySelector.
 * @param guard prevents calls at the incorrect time.
 * @throws IllegalArgumentException
 */
public static void setRepositorySelector(final RepositorySelector selector,final Object guard) throws IllegalArgumentException {
}","/** 
 * No-op implementation.
 * @param selector The RepositorySelector.
 * @param guard prevents calls at the incorrect time.
 * @throws IllegalArgumentException if a parameter is invalid.
 */
public static void setRepositorySelector(final RepositorySelector selector,final Object guard) throws IllegalArgumentException {
}"
90780,"/** 
 * Set the next filter pointer.
 */
public void setNext(final Filter next){
  this.next=next;
}","/** 
 * Set the next filter pointer.
 * @param next The next Filter.
 */
public void setNext(final Filter next){
  this.next=next;
}"
90781,"/** 
 * <p>If the decision is <code>DENY</code>, then the event will be dropped. If the decision is <code>NEUTRAL</code>, then the next filter, if any, will be invoked. If the decision is ACCEPT then the event will be logged without consulting with other filters in the chain.
 * @param event The LoggingEvent to decide upon.
 * @return decision The decision of the filter.
 */
abstract public int decide(LoggingEvent event);","/** 
 * <p>If the decision is <code>DENY</code>, then the event will be dropped. If the decision is <code>NEUTRAL</code>, then the next filter, if any, will be invoked. If the decision is ACCEPT then the event will be logged without consulting with other filters in the chain.
 * @param event The LoggingEvent to decide upon.
 * @return decision The decision of the filter.
 */
public abstract int decide(LoggingEvent event);"
90782,"/** 
 * Return the pointer to the next filter;
 */
public Filter getNext(){
  return next;
}","/** 
 * Return the pointer to the next filter.
 * @return The next Filter.
 */
public Filter getNext(){
  return next;
}"
90783,public abstract void resetConfiguration();,abstract void resetConfiguration();
90784,"/** 
 * Add a   {@link HierarchyEventListener} event to the repository.
 */
public void addHierarchyEventListener(HierarchyEventListener listener);","/** 
 * Add a   {@link HierarchyEventListener} event to the repository.
 */
void addHierarchyEventListener(HierarchyEventListener listener);"
90785,"public Logger getLogger(String name,LoggerFactory factory);","Logger getLogger(String name,LoggerFactory factory);"
90786,"/** 
 * Another form of   {@link #setThreshold(Level)} accepting a stringparameter instead of a <code>Level</code>.
 */
public void setThreshold(String val);","/** 
 * Another form of   {@link #setThreshold(Level)} accepting a stringparameter instead of a <code>Level</code>.
 */
void setThreshold(String val);"
90787,"public abstract void fireAddAppenderEvent(Category logger,Appender appender);","abstract void fireAddAppenderEvent(Category logger,Appender appender);"
90788,"/** 
 * Deprecated. Please use   {@link #getCurrentLoggers} instead.
 */
public Enumeration getCurrentCategories();","/** 
 * Deprecated. Please use   {@link #getCurrentLoggers} instead.
 */
Enumeration getCurrentCategories();"
90789,public abstract Logger exists(String name);,abstract Logger exists(String name);
90790,"/** 
 * Get the repository-wide threshold. See   {@link #setThreshold(Level)} for an explanation.
 */
public Level getThreshold();","/** 
 * Get the repository-wide threshold. See   {@link #setThreshold(Level)} for an explanation.
 */
Level getThreshold();"
90791,public Enumeration getCurrentLoggers();,Enumeration getCurrentLoggers();
90792,public Logger getRootLogger();,Logger getRootLogger();
90793,public abstract void shutdown();,abstract void shutdown();
90794,public void emitNoAppenderWarning(Category cat);,void emitNoAppenderWarning(Category cat);
90795,"/** 
 * Returns a   {@link org.apache.log4j.spi.LoggerRepository} depending on thecontext. Implementors must make sure that a valid (non-null) LoggerRepository is returned.
 */
public LoggerRepository getLoggerRepository();","/** 
 * Returns a   {@link org.apache.log4j.spi.LoggerRepository} depending on thecontext. Implementors must make sure that a valid (non-null) LoggerRepository is returned.
 * @return a LoggerRepository.
 */
LoggerRepository getLoggerRepository();"
90796,"/** 
 * Returns this appender's layout.
 * @return the Layout for the Appender or null if none is configured.
 * @issue LOG4J2-36 Refactor into Channel
 */
Layout<T> getLayout();","/** 
 * Returns this appender's layout.
 * @return the Layout for the Appender or null if none is configured.
 */
Layout<T> getLayout();"
90797,"/** 
 * Cause a reconfiguration to take place when the underlying configuration file changes.
 * @param reconfigurable The Configuration that can be reconfigured.
 */
public synchronized void onChange(final Reconfigurable reconfigurable){
  logger.debug(""String_Node_Str"" + name);
  final Configuration config=reconfigurable.reconfigure();
  if (config != null) {
    setConfiguration(config);
    logger.debug(""String_Node_Str"");
  }
 else {
    logger.debug(""String_Node_Str"");
  }
}","/** 
 * Cause a reconfiguration to take place when the underlying configuration file changes.
 * @param reconfigurable The Configuration that can be reconfigured.
 */
public synchronized void onChange(final Reconfigurable reconfigurable){
  LOGGER.debug(""String_Node_Str"" + name);
  final Configuration config=reconfigurable.reconfigure();
  if (config != null) {
    setConfiguration(config);
    LOGGER.debug(""String_Node_Str"");
  }
 else {
    LOGGER.debug(""String_Node_Str"");
  }
}"
90798,"/** 
 * Obtain a Logger from the Context.
 * @param name The name of the Logger to return.
 * @param messageFactory The message factory is used only when creating a logger, subsequent use does not change the logger but will log a warning if mismatched.
 * @return The Logger.
 */
public Logger getLogger(final String name,final MessageFactory messageFactory){
  Logger logger=loggers.get(name);
  if (logger != null) {
    AbstractLogger.checkMessageFactory(logger,messageFactory);
    return logger;
  }
  logger=newInstance(this,name,messageFactory);
  final Logger prev=loggers.putIfAbsent(name,logger);
  return prev == null ? logger : prev;
}","/** 
 * Obtain a Logger from the Context.
 * @param name The name of the Logger to return.
 * @param messageFactory The message factory is used only when creating a logger, subsequent use does not changethe logger but will log a warning if mismatched.
 * @return The Logger.
 */
public Logger getLogger(final String name,final MessageFactory messageFactory){
  Logger logger=loggers.get(name);
  if (logger != null) {
    AbstractLogger.checkMessageFactory(logger,messageFactory);
    return logger;
  }
  logger=newInstance(this,name,messageFactory);
  final Logger prev=loggers.putIfAbsent(name,logger);
  return prev == null ? logger : prev;
}"
90799,"/** 
 * Reconfigure the context.
 */
public synchronized void reconfigure(){
  logger.debug(""String_Node_Str"" + name);
  final Configuration instance=ConfigurationFactory.getInstance().getConfiguration(name,configLocation);
  setConfiguration(instance);
  logger.debug(""String_Node_Str"");
}","/** 
 * Reconfigure the context.
 */
public synchronized void reconfigure(){
  LOGGER.debug(""String_Node_Str"" + name);
  final Configuration instance=ConfigurationFactory.getInstance().getConfiguration(name,configLocation);
  setConfiguration(instance);
  LOGGER.debug(""String_Node_Str"");
}"
90800,"/** 
 * Retrieves a Manager if it has been previously created or creates a new Manager.
 * @param name The name of the Manager to retrieve.
 * @param factory The Factory to use to create the Manager.
 * @param data An Object that should be passed to the factory when creating the Manager.
 * @param < M > The Type of the Manager to be created.
 * @return A Manager with the specified name and type.
 */
public static <M extends AbstractManager,T>M getManager(final String name,final ManagerFactory<M,T> factory,final T data){
  lock.lock();
  try {
    M manager=(M)map.get(name);
    if (manager == null) {
      manager=factory.createManager(name,data);
      if (manager == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      map.put(name,manager);
    }
    manager.count++;
    return manager;
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Retrieves a Manager if it has been previously created or creates a new Manager.
 * @param name The name of the Manager to retrieve.
 * @param factory The Factory to use to create the Manager.
 * @param data An Object that should be passed to the factory when creating the Manager.
 * @param < M > The Type of the Manager to be created.
 * @param < T > The type of the Factory data.
 * @return A Manager with the specified name and type.
 */
public static <M extends AbstractManager,T>M getManager(final String name,final ManagerFactory<M,T> factory,final T data){
  LOCK.lock();
  try {
    M manager=(M)MAP.get(name);
    if (manager == null) {
      manager=factory.createManager(name,data);
      if (manager == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      MAP.put(name,manager);
    }
    manager.count++;
    return manager;
  }
  finally {
    LOCK.unlock();
  }
}"
90801,"/** 
 * Called to signify that this Manager is no longer required by an Appender.
 */
public void release(){
  lock.lock();
  try {
    --count;
    if (count <= 0) {
      map.remove(name);
      LOGGER.debug(""String_Node_Str"",this.getClass().getSimpleName(),getName());
      releaseSub();
    }
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Called to signify that this Manager is no longer required by an Appender.
 */
public void release(){
  LOCK.lock();
  try {
    --count;
    if (count <= 0) {
      MAP.remove(name);
      LOGGER.debug(""String_Node_Str"",this.getClass().getSimpleName(),getName());
      releaseSub();
    }
  }
  finally {
    LOCK.unlock();
  }
}"
90802,"/** 
 * Determines if a Manager with the specified name exists.
 * @param name The name of the Manager.
 * @return True if the Manager exists, false otherwise.
 */
public static boolean hasManager(final String name){
  lock.lock();
  try {
    return map.containsKey(name);
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Determines if a Manager with the specified name exists.
 * @param name The name of the Manager.
 * @return True if the Manager exists, false otherwise.
 */
public static boolean hasManager(final String name){
  LOCK.lock();
  try {
    return MAP.containsKey(name);
  }
  finally {
    LOCK.unlock();
  }
}"
90803,"/** 
 * Create an AsynchAppender.
 * @param appenderRefs The Appenders to reference.
 * @param errorRef An optional Appender to write to if the queue is full or other errors occur.
 * @param blocking True if the Appender should wait when the queue is full. The default is true.
 * @param size The size of the event queue. The default is 128.
 * @param name The name of the Appender.
 * @param filter The Filter or null.
 * @param config The Configuration.
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @return The AsynchAppender.
 */
@PluginFactory public static <S extends Serializable>AsynchAppender<S> createAppender(@PluginElement(""String_Node_Str"") final AppenderRef[] appenderRefs,@PluginAttr(""String_Node_Str"") final String errorRef,@PluginAttr(""String_Node_Str"") final String blocking,@PluginAttr(""String_Node_Str"") final String size,@PluginAttr(""String_Node_Str"") final String name,@PluginElement(""String_Node_Str"") final Filter filter,@PluginConfiguration final Configuration config,@PluginAttr(""String_Node_Str"") final String suppress){
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (appenderRefs == null) {
    LOGGER.error(""String_Node_Str"",name);
  }
  final boolean isBlocking=blocking == null ? true : Boolean.valueOf(blocking);
  final int queueSize=size == null ? DEFAULT_QUEUE_SIZE : Integer.parseInt(size);
  final boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  return new AsynchAppender<S>(name,filter,appenderRefs,errorRef,queueSize,isBlocking,handleExceptions,config);
}","/** 
 * Create an AsynchAppender.
 * @param appenderRefs The Appenders to reference.
 * @param errorRef An optional Appender to write to if the queue is full or other errors occur.
 * @param blocking True if the Appender should wait when the queue is full. The default is true.
 * @param size The size of the event queue. The default is 128.
 * @param name The name of the Appender.
 * @param filter The Filter or null.
 * @param config The Configuration.
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @param < S > The actual type of the Serializable.
 * @return The AsynchAppender.
 */
@PluginFactory public static <S extends Serializable>AsynchAppender<S> createAppender(@PluginElement(""String_Node_Str"") final AppenderRef[] appenderRefs,@PluginAttr(""String_Node_Str"") final String errorRef,@PluginAttr(""String_Node_Str"") final String blocking,@PluginAttr(""String_Node_Str"") final String size,@PluginAttr(""String_Node_Str"") final String name,@PluginElement(""String_Node_Str"") final Filter filter,@PluginConfiguration final Configuration config,@PluginAttr(""String_Node_Str"") final String suppress){
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (appenderRefs == null) {
    LOGGER.error(""String_Node_Str"",name);
  }
  final boolean isBlocking=blocking == null ? true : Boolean.valueOf(blocking);
  final int queueSize=size == null ? DEFAULT_QUEUE_SIZE : Integer.parseInt(size);
  final boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  return new AsynchAppender<S>(name,filter,appenderRefs,errorRef,queueSize,isBlocking,handleExceptions,config);
}"
90804,"/** 
 * Create a Console Appender.
 * @param layout The layout to use (required).
 * @param filter The Filter or null.
 * @param t The target (""SYSTEM_OUT"" or ""SYSTEM_ERR""). The default is ""SYSTEM_OUT"".
 * @param name The name of the Appender (required).
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @return The ConsoleAppender.
 */
@PluginFactory public static ConsoleAppender createAppender(@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") final Filter filter,@PluginAttr(""String_Node_Str"") final String t,@PluginAttr(""String_Node_Str"") final String name,@PluginAttr(""String_Node_Str"") final String follow,@PluginAttr(""String_Node_Str"") final String suppress){
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (layout == null) {
    layout=PatternLayout.createLayout(null,null,null,null);
  }
  final boolean isFollow=follow == null ? false : Boolean.valueOf(follow);
  final boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  final Target target=t == null ? Target.SYSTEM_OUT : Target.valueOf(t);
  return new ConsoleAppender(name,layout,filter,getManager(isFollow,target),handleExceptions);
}","/** 
 * Create a Console Appender.
 * @param layout The layout to use (required).
 * @param filter The Filter or null.
 * @param t The target (""SYSTEM_OUT"" or ""SYSTEM_ERR""). The default is ""SYSTEM_OUT"".
 * @param follow If true will follow changes to the underlying output stream.
 * @param name The name of the Appender (required).
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @return The ConsoleAppender.
 */
@PluginFactory public static ConsoleAppender createAppender(@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") final Filter filter,@PluginAttr(""String_Node_Str"") final String t,@PluginAttr(""String_Node_Str"") final String name,@PluginAttr(""String_Node_Str"") final String follow,@PluginAttr(""String_Node_Str"") final String suppress){
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (layout == null) {
    layout=PatternLayout.createLayout(null,null,null,null);
  }
  final boolean isFollow=follow == null ? false : Boolean.valueOf(follow);
  final boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  final Target target=t == null ? Target.SYSTEM_OUT : Target.valueOf(t);
  return new ConsoleAppender(name,layout,filter,getManager(isFollow,target),handleExceptions);
}"
90805,"/** 
 * Returns the appender references.
 * @param refs The references to return.
 * @return The appender references.
 */
@PluginFactory public static String[] createFailovers(@PluginElement(""String_Node_Str"") final AppenderRef... refs){
  if (refs == null) {
    logger.error(""String_Node_Str"");
    return null;
  }
  final String[] arr=new String[refs.length];
  for (int i=0; i < refs.length; ++i) {
    arr[i]=refs[i].getRef();
  }
  return arr;
}","/** 
 * Returns the appender references.
 * @param refs The references to return.
 * @return The appender references.
 */
@PluginFactory public static String[] createFailovers(@PluginElement(""String_Node_Str"") final AppenderRef... refs){
  if (refs == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  final String[] arr=new String[refs.length];
  for (int i=0; i < refs.length; ++i) {
    arr[i]=refs[i].getRef();
  }
  return arr;
}"
90806,"/** 
 * Returns the FileManager.
 * @param fileName The name of the file to manage.
 * @param append true if the file should be appended to, false if it should be overwritten.
 * @param locking true if the file should be locked while writing, false otherwise.
 * @param bufferedIO true if the contents should be buffered as they are written.
 * @return A FileManager for the File.
 */
public static FileManager getFileManager(final String fileName,final boolean append,boolean locking,final boolean bufferedIO){
  if (locking && bufferedIO) {
    locking=false;
  }
  return (FileManager)getManager(fileName,new FactoryData(append,locking,bufferedIO),factory);
}","/** 
 * Returns the FileManager.
 * @param fileName The name of the file to manage.
 * @param append true if the file should be appended to, false if it should be overwritten.
 * @param locking true if the file should be locked while writing, false otherwise.
 * @param bufferedIO true if the contents should be buffered as they are written.
 * @return A FileManager for the File.
 */
public static FileManager getFileManager(final String fileName,final boolean append,boolean locking,final boolean bufferedIO){
  if (locking && bufferedIO) {
    locking=false;
  }
  return (FileManager)getManager(fileName,new FactoryData(append,locking,bufferedIO),FACTORY);
}"
90807,"public MimeMessageBuilder setFrom(final String from) throws MessagingException {
  InternetAddress address=parseAddress(from);
  if (null != address) {
    message.setFrom(address);
  }
 else {
    message.setFrom();
  }
  return this;
}","public MimeMessageBuilder setFrom(final String from) throws MessagingException {
  InternetAddress address=parseAddress(from);
  if (null != address) {
    message.setFrom(address);
  }
 else {
    try {
      message.setFrom();
    }
 catch (    Exception ex) {
      message.setFrom(null);
    }
  }
  return this;
}"
90808,"public SMTPManager createManager(final String name,final FactoryData data){
  final String prefix=""String_Node_Str"" + data.protocol;
  Properties properties=PropertiesUtil.getSystemProperties();
  properties.put(""String_Node_Str"",data.protocol);
  if (null != data.host) {
    properties.put(prefix + ""String_Node_Str"",data.host);
  }
  if (data.port > 0) {
    properties.put(prefix + ""String_Node_Str"",String.valueOf(data.port));
  }
  final Authenticator authenticator=buildAuthenticator(data.username,data.password);
  if (null != authenticator) {
    properties.put(prefix + ""String_Node_Str"",""String_Node_Str"");
  }
  final Session session=Session.getInstance(properties,authenticator);
  session.setProtocolForAddress(""String_Node_Str"",data.protocol);
  session.setDebug(data.isDebug);
  MimeMessage message;
  try {
    message=new MimeMessageBuilder(session).setFrom(data.from).setReplyTo(data.replyto).setRecipients(Message.RecipientType.TO,data.to).setRecipients(Message.RecipientType.CC,data.cc).setRecipients(Message.RecipientType.BCC,data.bcc).setSubject(data.subject).getMimeMessage();
  }
 catch (  MessagingException e) {
    LOGGER.error(""String_Node_Str"",e);
    message=null;
  }
  return new SMTPManager(name,session,message,data);
}","public SMTPManager createManager(final String name,final FactoryData data){
  final String prefix=""String_Node_Str"" + data.protocol;
  Properties properties=PropertiesUtil.getSystemProperties();
  properties.put(""String_Node_Str"",data.protocol);
  if (properties.getProperty(""String_Node_Str"") == null) {
    properties.put(""String_Node_Str"",NetUtils.getLocalHostname());
  }
  if (null != data.host) {
    properties.put(prefix + ""String_Node_Str"",data.host);
  }
  if (data.port > 0) {
    properties.put(prefix + ""String_Node_Str"",String.valueOf(data.port));
  }
  final Authenticator authenticator=buildAuthenticator(data.username,data.password);
  if (null != authenticator) {
    properties.put(prefix + ""String_Node_Str"",""String_Node_Str"");
  }
  final Session session=Session.getInstance(properties,authenticator);
  session.setProtocolForAddress(""String_Node_Str"",data.protocol);
  session.setDebug(data.isDebug);
  MimeMessage message;
  try {
    message=new MimeMessageBuilder(session).setFrom(data.from).setReplyTo(data.replyto).setRecipients(Message.RecipientType.TO,data.to).setRecipients(Message.RecipientType.CC,data.cc).setRecipients(Message.RecipientType.BCC,data.bcc).setSubject(data.subject).getMimeMessage();
  }
 catch (  MessagingException e) {
    LOGGER.error(""String_Node_Str"",e);
    message=null;
  }
  return new SMTPManager(name,session,message,data);
}"
90809,"@Test public void testMessageFactorySetFrom() throws MessagingException {
  final MimeMessageBuilder builder=new MimeMessageBuilder(null);
  final String address=""String_Node_Str"";
  assertNull(builder.getMimeMessage().getFrom());
  builder.setFrom(null);
  assertArrayEquals(new Address[]{InternetAddress.getLocalAddress(null)},builder.getMimeMessage().getFrom());
  builder.setFrom(address);
  assertArrayEquals(new Address[]{new InternetAddress(address)},builder.getMimeMessage().getFrom());
}","@Test public void testMessageFactorySetFrom() throws MessagingException {
  final MimeMessageBuilder builder=new MimeMessageBuilder(null);
  final String address=""String_Node_Str"";
  assertNull(builder.getMimeMessage().getFrom());
  builder.setFrom(null);
  Address[] array=null;
  Address addr=InternetAddress.getLocalAddress(null);
  if (addr != null) {
    array=new Address[]{addr};
  }
  assertArrayEquals(array,builder.getMimeMessage().getFrom());
  builder.setFrom(address);
  assertArrayEquals(new Address[]{new InternetAddress(address)},builder.getMimeMessage().getFrom());
}"
90810,"@Test public void testInfo(){
  currentLevel=Level.INFO;
  currentEvent=events[0];
  info(""String_Node_Str"");
  info(null,""String_Node_Str"");
  currentEvent=events[1];
  info(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"");
  currentEvent=events[2];
  info(""String_Node_Str"",t);
  info(null,""String_Node_Str"",t);
  currentEvent=events[3];
  info(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"",t);
  currentEvent=events[4];
  info(obj);
  currentEvent=events[5];
  info(MarkerManager.getMarker(""String_Node_Str""),obj);
  currentEvent=events[6];
  info(obj,t);
  info(null,obj,t);
  currentEvent=events[7];
  info(MarkerManager.getMarker(""String_Node_Str""),obj,t);
  currentEvent=events[8];
  info(pattern,p1,p2);
  currentEvent=events[9];
  info(MarkerManager.getMarker(""String_Node_Str""),pattern,p1,p2);
  currentEvent=events[10];
  info(simple);
  info(null,simple);
  info(null,simple,null);
  currentEvent=events[11];
  info(simple,t);
  info(null,simple,t);
  currentEvent=events[12];
  info(MarkerManager.getMarker(""String_Node_Str""),simple,null);
  currentEvent=events[13];
  info(MarkerManager.getMarker(""String_Node_Str""),simple,t);
}","@Test public void testInfo(){
  currentLevel=Level.INFO;
  currentEvent=events[0];
  info(""String_Node_Str"");
  info(null,""String_Node_Str"");
  currentEvent=events[1];
  info(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"");
  currentEvent=events[2];
  info(""String_Node_Str"",t);
  info(null,""String_Node_Str"",t);
  currentEvent=events[3];
  info(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"",t);
  currentEvent=events[4];
  info(obj);
  currentEvent=events[5];
  info(MarkerManager.getMarker(""String_Node_Str""),obj);
  currentEvent=events[6];
  info(obj,t);
  info(null,obj,t);
  currentEvent=events[7];
  info(MarkerManager.getMarker(""String_Node_Str""),obj,t);
  currentEvent=events[8];
  info(pattern,p1,p2);
  currentEvent=events[9];
  info(MarkerManager.getMarker(""String_Node_Str""),pattern,p1,p2);
  currentEvent=events[10];
  info(simple);
  info(null,simple);
  info(null,simple,null);
  currentEvent=events[11];
  info(simple,t);
  info(null,simple,t);
  currentEvent=events[12];
  info(MarkerManager.getMarker(""String_Node_Str""),simple,null);
  currentEvent=events[13];
  info(MarkerManager.getMarker(""String_Node_Str""),simple,t);
  currentEvent=events[14];
  info(MarkerManager.getMarker(""String_Node_Str""),simple);
}"
90811,"@Test public void testFatal(){
  currentLevel=Level.FATAL;
  currentEvent=events[0];
  fatal(""String_Node_Str"");
  fatal(null,""String_Node_Str"");
  currentEvent=events[1];
  fatal(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"");
  currentEvent=events[2];
  fatal(""String_Node_Str"",t);
  fatal(null,""String_Node_Str"",t);
  currentEvent=events[3];
  fatal(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"",t);
  currentEvent=events[4];
  fatal(obj);
  currentEvent=events[5];
  fatal(MarkerManager.getMarker(""String_Node_Str""),obj);
  currentEvent=events[6];
  fatal(obj,t);
  fatal(null,obj,t);
  currentEvent=events[7];
  fatal(MarkerManager.getMarker(""String_Node_Str""),obj,t);
  currentEvent=events[8];
  fatal(pattern,p1,p2);
  currentEvent=events[9];
  fatal(MarkerManager.getMarker(""String_Node_Str""),pattern,p1,p2);
  currentEvent=events[10];
  fatal(simple);
  fatal(null,simple);
  fatal(null,simple,null);
  currentEvent=events[11];
  fatal(simple,t);
  fatal(null,simple,t);
  currentEvent=events[12];
  fatal(MarkerManager.getMarker(""String_Node_Str""),simple,null);
  currentEvent=events[13];
  fatal(MarkerManager.getMarker(""String_Node_Str""),simple,t);
}","@Test public void testFatal(){
  currentLevel=Level.FATAL;
  currentEvent=events[0];
  fatal(""String_Node_Str"");
  fatal(null,""String_Node_Str"");
  currentEvent=events[1];
  fatal(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"");
  currentEvent=events[2];
  fatal(""String_Node_Str"",t);
  fatal(null,""String_Node_Str"",t);
  currentEvent=events[3];
  fatal(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"",t);
  currentEvent=events[4];
  fatal(obj);
  currentEvent=events[5];
  fatal(MarkerManager.getMarker(""String_Node_Str""),obj);
  currentEvent=events[6];
  fatal(obj,t);
  fatal(null,obj,t);
  currentEvent=events[7];
  fatal(MarkerManager.getMarker(""String_Node_Str""),obj,t);
  currentEvent=events[8];
  fatal(pattern,p1,p2);
  currentEvent=events[9];
  fatal(MarkerManager.getMarker(""String_Node_Str""),pattern,p1,p2);
  currentEvent=events[10];
  fatal(simple);
  fatal(null,simple);
  fatal(null,simple,null);
  currentEvent=events[11];
  fatal(simple,t);
  fatal(null,simple,t);
  currentEvent=events[12];
  fatal(MarkerManager.getMarker(""String_Node_Str""),simple,null);
  currentEvent=events[13];
  fatal(MarkerManager.getMarker(""String_Node_Str""),simple,t);
  currentEvent=events[14];
  fatal(MarkerManager.getMarker(""String_Node_Str""),simple);
}"
90812,"@Test public void testDebug(){
  currentLevel=Level.DEBUG;
  currentEvent=events[0];
  debug(""String_Node_Str"");
  debug(null,""String_Node_Str"");
  currentEvent=events[1];
  debug(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"");
  currentEvent=events[2];
  debug(""String_Node_Str"",t);
  debug(null,""String_Node_Str"",t);
  currentEvent=events[3];
  debug(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"",t);
  currentEvent=events[4];
  debug(obj);
  currentEvent=events[5];
  debug(MarkerManager.getMarker(""String_Node_Str""),obj);
  currentEvent=events[6];
  debug(obj,t);
  debug(null,obj,t);
  currentEvent=events[7];
  debug(MarkerManager.getMarker(""String_Node_Str""),obj,t);
  currentEvent=events[8];
  debug(pattern,p1,p2);
  currentEvent=events[9];
  debug(MarkerManager.getMarker(""String_Node_Str""),pattern,p1,p2);
  currentEvent=events[10];
  debug(simple);
  debug(null,simple);
  debug(null,simple,null);
  currentEvent=events[11];
  debug(simple,t);
  debug(null,simple,t);
  currentEvent=events[12];
  debug(MarkerManager.getMarker(""String_Node_Str""),simple,null);
  currentEvent=events[13];
  debug(MarkerManager.getMarker(""String_Node_Str""),simple,t);
}","@Test public void testDebug(){
  currentLevel=Level.DEBUG;
  currentEvent=events[0];
  debug(""String_Node_Str"");
  debug(null,""String_Node_Str"");
  currentEvent=events[1];
  debug(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"");
  currentEvent=events[2];
  debug(""String_Node_Str"",t);
  debug(null,""String_Node_Str"",t);
  currentEvent=events[3];
  debug(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"",t);
  currentEvent=events[4];
  debug(obj);
  currentEvent=events[5];
  debug(MarkerManager.getMarker(""String_Node_Str""),obj);
  currentEvent=events[6];
  debug(obj,t);
  debug(null,obj,t);
  currentEvent=events[7];
  debug(MarkerManager.getMarker(""String_Node_Str""),obj,t);
  currentEvent=events[8];
  debug(pattern,p1,p2);
  currentEvent=events[9];
  debug(MarkerManager.getMarker(""String_Node_Str""),pattern,p1,p2);
  currentEvent=events[10];
  debug(simple);
  debug(null,simple);
  debug(null,simple,null);
  currentEvent=events[11];
  debug(simple,t);
  debug(null,simple,t);
  currentEvent=events[12];
  debug(MarkerManager.getMarker(""String_Node_Str""),simple,null);
  currentEvent=events[13];
  debug(MarkerManager.getMarker(""String_Node_Str""),simple,t);
  currentEvent=events[14];
  debug(MarkerManager.getMarker(""String_Node_Str""),simple);
}"
90813,"@Test public void testWarn(){
  currentLevel=Level.WARN;
  currentEvent=events[0];
  warn(""String_Node_Str"");
  warn(null,""String_Node_Str"");
  currentEvent=events[1];
  warn(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"");
  currentEvent=events[2];
  warn(""String_Node_Str"",t);
  warn(null,""String_Node_Str"",t);
  currentEvent=events[3];
  warn(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"",t);
  currentEvent=events[4];
  warn(obj);
  currentEvent=events[5];
  warn(MarkerManager.getMarker(""String_Node_Str""),obj);
  currentEvent=events[6];
  warn(obj,t);
  warn(null,obj,t);
  currentEvent=events[7];
  warn(MarkerManager.getMarker(""String_Node_Str""),obj,t);
  currentEvent=events[8];
  warn(pattern,p1,p2);
  currentEvent=events[9];
  warn(MarkerManager.getMarker(""String_Node_Str""),pattern,p1,p2);
  currentEvent=events[10];
  warn(simple);
  warn(null,simple);
  warn(null,simple,null);
  currentEvent=events[11];
  warn(simple,t);
  warn(null,simple,t);
  currentEvent=events[12];
  warn(MarkerManager.getMarker(""String_Node_Str""),simple,null);
  currentEvent=events[13];
  warn(MarkerManager.getMarker(""String_Node_Str""),simple,t);
}","@Test public void testWarn(){
  currentLevel=Level.WARN;
  currentEvent=events[0];
  warn(""String_Node_Str"");
  warn(null,""String_Node_Str"");
  currentEvent=events[1];
  warn(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"");
  currentEvent=events[2];
  warn(""String_Node_Str"",t);
  warn(null,""String_Node_Str"",t);
  currentEvent=events[3];
  warn(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"",t);
  currentEvent=events[4];
  warn(obj);
  currentEvent=events[5];
  warn(MarkerManager.getMarker(""String_Node_Str""),obj);
  currentEvent=events[6];
  warn(obj,t);
  warn(null,obj,t);
  currentEvent=events[7];
  warn(MarkerManager.getMarker(""String_Node_Str""),obj,t);
  currentEvent=events[8];
  warn(pattern,p1,p2);
  currentEvent=events[9];
  warn(MarkerManager.getMarker(""String_Node_Str""),pattern,p1,p2);
  currentEvent=events[10];
  warn(simple);
  warn(null,simple);
  warn(null,simple,null);
  currentEvent=events[11];
  warn(simple,t);
  warn(null,simple,t);
  currentEvent=events[12];
  warn(MarkerManager.getMarker(""String_Node_Str""),simple,null);
  currentEvent=events[13];
  warn(MarkerManager.getMarker(""String_Node_Str""),simple,t);
  currentEvent=events[14];
  warn(MarkerManager.getMarker(""String_Node_Str""),simple);
}"
90814,"@Test public void testTrace(){
  currentLevel=Level.TRACE;
  currentEvent=events[0];
  trace(""String_Node_Str"");
  trace(null,""String_Node_Str"");
  currentEvent=events[1];
  trace(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"");
  currentEvent=events[2];
  trace(""String_Node_Str"",t);
  trace(null,""String_Node_Str"",t);
  currentEvent=events[3];
  trace(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"",t);
  currentEvent=events[4];
  trace(obj);
  currentEvent=events[5];
  trace(MarkerManager.getMarker(""String_Node_Str""),obj);
  currentEvent=events[6];
  trace(obj,t);
  trace(null,obj,t);
  currentEvent=events[7];
  trace(MarkerManager.getMarker(""String_Node_Str""),obj,t);
  currentEvent=events[8];
  trace(pattern,p1,p2);
  currentEvent=events[9];
  trace(MarkerManager.getMarker(""String_Node_Str""),pattern,p1,p2);
  currentEvent=events[10];
  trace(simple);
  trace(null,simple);
  trace(null,simple,null);
  currentEvent=events[11];
  trace(simple,t);
  trace(null,simple,t);
  currentEvent=events[12];
  trace(MarkerManager.getMarker(""String_Node_Str""),simple,null);
  currentEvent=events[13];
  trace(MarkerManager.getMarker(""String_Node_Str""),simple,t);
}","@Test public void testTrace(){
  currentLevel=Level.TRACE;
  currentEvent=events[0];
  trace(""String_Node_Str"");
  trace(null,""String_Node_Str"");
  currentEvent=events[1];
  trace(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"");
  currentEvent=events[2];
  trace(""String_Node_Str"",t);
  trace(null,""String_Node_Str"",t);
  currentEvent=events[3];
  trace(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"",t);
  currentEvent=events[4];
  trace(obj);
  currentEvent=events[5];
  trace(MarkerManager.getMarker(""String_Node_Str""),obj);
  currentEvent=events[6];
  trace(obj,t);
  trace(null,obj,t);
  currentEvent=events[7];
  trace(MarkerManager.getMarker(""String_Node_Str""),obj,t);
  currentEvent=events[8];
  trace(pattern,p1,p2);
  currentEvent=events[9];
  trace(MarkerManager.getMarker(""String_Node_Str""),pattern,p1,p2);
  currentEvent=events[10];
  trace(simple);
  trace(null,simple);
  trace(null,simple,null);
  currentEvent=events[11];
  trace(simple,t);
  trace(null,simple,t);
  currentEvent=events[12];
  trace(MarkerManager.getMarker(""String_Node_Str""),simple,null);
  currentEvent=events[13];
  trace(MarkerManager.getMarker(""String_Node_Str""),simple,t);
  currentEvent=events[14];
  trace(MarkerManager.getMarker(""String_Node_Str""),simple);
}"
90815,"@Test public void testError(){
  currentLevel=Level.ERROR;
  currentEvent=events[0];
  error(""String_Node_Str"");
  error(null,""String_Node_Str"");
  currentEvent=events[1];
  error(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"");
  currentEvent=events[2];
  error(""String_Node_Str"",t);
  error(null,""String_Node_Str"",t);
  currentEvent=events[3];
  error(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"",t);
  currentEvent=events[4];
  error(obj);
  currentEvent=events[5];
  error(MarkerManager.getMarker(""String_Node_Str""),obj);
  currentEvent=events[6];
  error(obj,t);
  error(null,obj,t);
  currentEvent=events[7];
  error(MarkerManager.getMarker(""String_Node_Str""),obj,t);
  currentEvent=events[8];
  error(pattern,p1,p2);
  currentEvent=events[9];
  error(MarkerManager.getMarker(""String_Node_Str""),pattern,p1,p2);
  currentEvent=events[10];
  error(simple);
  error(null,simple);
  error(null,simple,null);
  currentEvent=events[11];
  error(simple,t);
  error(null,simple,t);
  currentEvent=events[12];
  error(MarkerManager.getMarker(""String_Node_Str""),simple,null);
  currentEvent=events[13];
  error(MarkerManager.getMarker(""String_Node_Str""),simple,t);
}","@Test public void testError(){
  currentLevel=Level.ERROR;
  currentEvent=events[0];
  error(""String_Node_Str"");
  error(null,""String_Node_Str"");
  currentEvent=events[1];
  error(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"");
  currentEvent=events[2];
  error(""String_Node_Str"",t);
  error(null,""String_Node_Str"",t);
  currentEvent=events[3];
  error(MarkerManager.getMarker(""String_Node_Str""),""String_Node_Str"",t);
  currentEvent=events[4];
  error(obj);
  currentEvent=events[5];
  error(MarkerManager.getMarker(""String_Node_Str""),obj);
  currentEvent=events[6];
  error(obj,t);
  error(null,obj,t);
  currentEvent=events[7];
  error(MarkerManager.getMarker(""String_Node_Str""),obj,t);
  currentEvent=events[8];
  error(pattern,p1,p2);
  currentEvent=events[9];
  error(MarkerManager.getMarker(""String_Node_Str""),pattern,p1,p2);
  currentEvent=events[10];
  error(simple);
  error(null,simple);
  error(null,simple,null);
  currentEvent=events[11];
  error(simple,t);
  error(null,simple,t);
  currentEvent=events[12];
  error(MarkerManager.getMarker(""String_Node_Str""),simple,null);
  currentEvent=events[13];
  error(MarkerManager.getMarker(""String_Node_Str""),simple,t);
  currentEvent=events[14];
  error(MarkerManager.getMarker(""String_Node_Str""),simple);
}"
90816,"/** 
 * Returns this appenders layout.
 * @return the Layout for the Appender or null if none is configured.
 * @issue LOG4J2-36 Refactor into Channel
 */
Layout getLayout();","/** 
 * Returns this appenders layout.
 * @return the Layout for the Appender or null if none is configured.
 * @issue LOG4J2-36 Refactor into Channel
 */
Layout<?> getLayout();"
90817,"/** 
 * Returns the Layout for the appender.
 * @return The Layout used to format the event.
 */
public Layout getLayout(){
  return layout;
}","/** 
 * Returns the Layout for the appender.
 * @return The Layout used to format the event.
 */
public Layout<?> getLayout(){
  return layout;
}"
90818,"/** 
 * Constructor.
 * @param name The Appender name.
 * @param filter The Filter to associate with the Appender.
 * @param layout The layout to use to format the event.
 * @param handleException If true, exceptions will be logged and suppressed. If false errors will belogged and then passed to the application.
 */
protected AbstractAppender(String name,Filter filter,Layout layout,boolean handleException){
  super(filter);
  this.name=name;
  this.layout=layout;
  this.handleException=handleException;
}","/** 
 * Constructor.
 * @param name The Appender name.
 * @param filter The Filter to associate with the Appender.
 * @param layout The layout to use to format the event.
 * @param handleException If true, exceptions will be logged and suppressed. If false errors will belogged and then passed to the application.
 */
protected AbstractAppender(String name,Filter filter,Layout<?> layout,boolean handleException){
  super(filter);
  this.name=name;
  this.layout=layout;
  this.handleException=handleException;
}"
90819,"@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || getClass() != o.getClass()) {
    return false;
  }
  MapMessage that=(MapMessage)o;
  return this.data.equals(that.data);
}","@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || this.getClass() != o.getClass()) {
    return false;
  }
  MapMessage that=(MapMessage)o;
  return this.data.equals(that.data);
}"
90820,"/** 
 * Checks whether this Marker is an instance of the specified Marker.
 * @param m The Marker name to check.
 * @return true of this Marker or one of its ancestors matches the specified name, false otherwise.
 */
boolean isInstanceOf(String name);","/** 
 * Checks whether this Marker is an instance of the specified Marker.
 * @param name The name of the Marker.
 * @return true of this Marker or one of its ancestors matches the specified name, false otherwise.
 */
boolean isInstanceOf(String name);"
90821,"/** 
 * Cause a reconfiguration to take place when the underlying configuration file changes.
 */
public synchronized void onChange(Reconfigurable reconfigurable){
  logger.debug(""String_Node_Str"" + contextName);
  Configuration config=reconfigurable.reconfigure();
  if (config != null) {
    setConfiguration(config);
    logger.debug(""String_Node_Str"");
  }
 else {
    logger.debug(""String_Node_Str"");
  }
}","/** 
 * Cause a reconfiguration to take place when the underlying configuration file changes.
 * @param reconfigurable The Configuration that can be reconfigured.
 */
public synchronized void onChange(Reconfigurable reconfigurable){
  logger.debug(""String_Node_Str"" + contextName);
  Configuration config=reconfigurable.reconfigure();
  if (config != null) {
    setConfiguration(config);
    logger.debug(""String_Node_Str"");
  }
 else {
    logger.debug(""String_Node_Str"");
  }
}"
90822,"/** 
 * Constructor.
 * @param file The File to monitor.
 * @param listeners The List of ConfigurationListeners to notify upon a change.
 * @param interval The monitor interval in seconds. The minimum interval is 30 seconds.
 */
public FileConfigurationMonitor(Reconfigurable reconfigurable,File file,List<ConfigurationListener> listeners,int interval){
  this.reconfigurable=reconfigurable;
  this.file=file;
  this.lastModified=file.lastModified();
  this.listeners=listeners;
  this.interval=(interval < MIN_INTERVAL ? MIN_INTERVAL : interval) * MILLIS_PER_SECOND;
  this.nextCheck=System.currentTimeMillis() + interval;
}","/** 
 * Constructor.
 * @param reconfigurable The Configuration that can be reconfigured.
 * @param file The File to monitor.
 * @param listeners The List of ConfigurationListeners to notify upon a change.
 * @param interval The monitor interval in seconds. The minimum interval is 30 seconds.
 */
public FileConfigurationMonitor(Reconfigurable reconfigurable,File file,List<ConfigurationListener> listeners,int interval){
  this.reconfigurable=reconfigurable;
  this.file=file;
  this.lastModified=file.lastModified();
  this.listeners=listeners;
  this.interval=(interval < MIN_INTERVAL ? MIN_INTERVAL : interval) * MILLIS_PER_SECOND;
  this.nextCheck=System.currentTimeMillis() + interval;
}"
90823,"public void contextInitialized(ServletContextEvent event){
  ServletContext context=event.getServletContext();
  String locn=context.getInitParameter(LOG4J_CONFIG);
  String name=context.getInitParameter(LOG4J_CONTEXT_NAME);
  if (name == null) {
    name=context.getServletContextName();
  }
  if (name == null && locn == null) {
    context.log(""String_Node_Str"");
    return;
  }
  context.setAttribute(LOG4J_CONTEXT_ATTRIBUTE,Configurator.initialize(name,getClassLoader(context),locn));
}","/** 
 * Initialize Logging for the web application.
 * @param event The ServletContextEvent.
 */
public void contextInitialized(ServletContextEvent event){
  ServletContext context=event.getServletContext();
  String locn=context.getInitParameter(LOG4J_CONFIG);
  String name=context.getInitParameter(LOG4J_CONTEXT_NAME);
  if (name == null) {
    name=context.getServletContextName();
  }
  if (name == null && locn == null) {
    context.log(""String_Node_Str"");
    return;
  }
  context.setAttribute(LOG4J_CONTEXT_ATTRIBUTE,Configurator.initialize(name,getClassLoader(context),locn));
}"
90824,"public void contextDestroyed(ServletContextEvent event){
  LoggerContext ctx=(LoggerContext)event.getServletContext().getAttribute(LOG4J_CONTEXT_ATTRIBUTE);
  Configurator.shutdown(ctx);
}","/** 
 * Shutdown logging for the web application.
 * @param event The ServletContextEvent.
 */
public void contextDestroyed(ServletContextEvent event){
  LoggerContext ctx=(LoggerContext)event.getServletContext().getAttribute(LOG4J_CONTEXT_ATTRIBUTE);
  Configurator.shutdown(ctx);
}"
90825,"/** 
 * Creates the StatusConsoleListener using the supplied Level.
 * @param level The Level of status messages that should appear on the console.
 */
public StatusConsoleListener(Level level,PrintStream stream){
  this.level=level;
  this.stream=stream;
}","/** 
 * Creates the StatusConsoleListener using the supplied Level.
 * @param level The Level of status messages that should appear on the console.
 * @param stream The PrintStream to write to.
 */
public StatusConsoleListener(Level level,PrintStream stream){
  this.level=level;
  this.stream=stream;
}"
90826,"/** 
 * Returns a String representation of this instance in the form   {@code ""name:level[ in context_name]""}.
 */
@Override public String toString(){
  final String nameLevel=""String_Node_Str"" + name + ""String_Node_Str""+ getLevel();
  if (context == null) {
    return nameLevel;
  }
  final String contextName=context.getName();
  return contextName == null ? nameLevel : nameLevel + ""String_Node_Str"" + contextName;
}","/** 
 * Returns a String representation of this instance in the form   {@code ""name:level[ in context_name]""}.
 * @return A String describing this Logger instance.
 */
@Override public String toString(){
  final String nameLevel=""String_Node_Str"" + name + ""String_Node_Str""+ getLevel();
  if (context == null) {
    return nameLevel;
  }
  final String contextName=context.getName();
  return contextName == null ? nameLevel : nameLevel + ""String_Node_Str"" + contextName;
}"
90827,"/** 
 * Log a message with the specific Marker at the ERROR level.
 * @param marker the marker data specific to this log statement
 * @param msg    the message string to be logged
 * @param t      A Throwable or null.
 */
public void error(Marker marker,Message msg,Throwable t){
  if (isEnabled(Level.TRACE,marker,msg,t)) {
    log(marker,FQCN,Level.TRACE,msg,t);
  }
}","/** 
 * Log a message with the specific Marker at the ERROR level.
 * @param marker the marker data specific to this log statement
 * @param msg    the message string to be logged
 * @param t      A Throwable or null.
 */
public void error(Marker marker,Message msg,Throwable t){
  if (isEnabled(Level.ERROR,marker,msg,t)) {
    log(marker,FQCN,Level.ERROR,msg,t);
  }
}"
90828,"private static OutputStreamManager getManager(Target target){
  String type=target.name();
  OutputStream os=target == Target.SYSTEM_OUT ? System.out : System.err;
  OutputStreamManager manager=OutputStreamManager.getManager(target.name(),factory,new FactoryData(os,type));
  return manager;
}","private static OutputStreamManager getManager(Target target){
  String type=target.name();
  OutputStream os=target == Target.SYSTEM_OUT ? System.out : System.err;
  OutputStreamManager manager=OutputStreamManager.getManager(target.name(),new FactoryData(os,type),factory);
  return manager;
}"
90829,"/** 
 * Return the FileManager.
 * @param fileName The name of the file to manage.
 * @param append true if the file should be appended to, false if it should be overwritten.
 * @param locking true if the file should be locked while writing, false otherwise.
 * @param bufferedIO true if the contents should be buffered as they are written.
 * @return A FileManager for the File.
 */
public static FileManager getFileManager(String fileName,boolean append,boolean locking,boolean bufferedIO){
  if (locking && bufferedIO) {
    locking=false;
  }
  return (FileManager)getManager(fileName,factory,new FactoryData(append,locking,bufferedIO));
}","/** 
 * Return the FileManager.
 * @param fileName The name of the file to manage.
 * @param append true if the file should be appended to, false if it should be overwritten.
 * @param locking true if the file should be locked while writing, false otherwise.
 * @param bufferedIO true if the contents should be buffered as they are written.
 * @return A FileManager for the File.
 */
public static FileManager getFileManager(String fileName,boolean append,boolean locking,boolean bufferedIO){
  if (locking && bufferedIO) {
    locking=false;
  }
  return (FileManager)getManager(fileName,new FactoryData(append,locking,bufferedIO),factory);
}"
90830,"/** 
 * Create a Manager.
 * @param name The name of the stream to manage.
 * @param factory The factory to use to create the Manager.
 * @param data The data to pass to the Manager.
 * @return An OutputStreamManager.
 */
public static OutputStreamManager getManager(String name,ManagerFactory<OutputStreamManager,Object> factory,Object data){
  return AbstractManager.getManager(name,factory,data);
}","/** 
 * Create a Manager.
 * @param name The name of the stream to manage.
 * @param data The data to pass to the Manager.
 * @param factory The factory to use to create the Manager.
 * @return An OutputStreamManager.
 */
public static OutputStreamManager getManager(String name,Object data,ManagerFactory<OutputStreamManager,Object> factory){
  return AbstractManager.getManager(name,factory,data);
}"
90831,"/** 
 * Return a RollingFileManager.
 * @param fileName The file name.
 * @param pattern The pattern for rolling file.
 * @param append true if the file should be appended to.
 * @param bufferedIO true if data should be buffered.
 * @return A RollingFileManager.
 */
public static RollingFileManager getFileManager(String fileName,String pattern,boolean append,boolean bufferedIO){
  return (RollingFileManager)getManager(fileName,factory,new FactoryData(pattern,append,bufferedIO));
}","/** 
 * Return a RollingFileManager.
 * @param fileName The file name.
 * @param pattern The pattern for rolling file.
 * @param append true if the file should be appended to.
 * @param bufferedIO true if data should be buffered.
 * @return A RollingFileManager.
 */
public static RollingFileManager getFileManager(String fileName,String pattern,boolean append,boolean bufferedIO){
  return (RollingFileManager)getManager(fileName,new FactoryData(pattern,append,bufferedIO),factory);
}"
90832,"private static void versionCheck(){
  Method[] methods=Throwable.class.getMethods();
  for (  Method method : methods) {
    if (method.getName().equals(""String_Node_Str"")) {
      getSuppressed=method;
    }
  }
}","private static void versionCheck(){
  Method[] methods=Throwable.class.getMethods();
  for (  Method method : methods) {
    if (method.getName().equals(""String_Node_Str"")) {
      getSuppressed=method;
    }
 else     if (method.getName().equals(""String_Node_Str"")) {
      addSuppressed=method;
    }
  }
}"
90833,"/** 
 * Constructs the wrapper for a Throwable that is referenced as the cause by another Throwable.
 * @param parent The Throwable referencing this Throwable.
 * @param stack The Class stack.
 * @param map The cache containing the packaging data.
 * @param cause The Throwable to wrap.
 */
private ThrowableProxy(Throwable parent,Stack<Class> stack,Map<String,CacheEntry> map,Throwable cause){
  this.throwable=cause;
  callerPackageData=resolvePackageData(stack,map,parent.getStackTrace(),cause.getStackTrace());
  this.cause=(throwable.getCause() == null) ? null : new ThrowableProxy(parent,stack,map,throwable.getCause());
  suppressed=getSuppressed(throwable);
}","/** 
 * Constructs the wrapper for a Throwable that is referenced as the cause by another Throwable.
 * @param parent The Throwable referencing this Throwable.
 * @param stack The Class stack.
 * @param map The cache containing the packaging data.
 * @param cause The Throwable to wrap.
 */
private ThrowableProxy(Throwable parent,Stack<Class> stack,Map<String,CacheEntry> map,Throwable cause){
  this.throwable=cause;
  callerPackageData=resolvePackageData(stack,map,parent.getStackTrace(),cause.getStackTrace());
  this.cause=(throwable.getCause() == null) ? null : new ThrowableProxy(parent,stack,map,throwable.getCause());
  setSuppressed(throwable);
}"
90834,"/** 
 * Format the suppressed Throwables.
 * @return The formatted suppressed Throwables.
 */
public String getSuppressedStackTrace(){
  if (suppressed == null || suppressed.length == 0) {
    return ""String_Node_Str"";
  }
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  for (  ThrowableProxy proxy : suppressed) {
    sb.append(proxy.getExtendedStackTrace());
  }
  return sb.toString();
}","/** 
 * Format the suppressed Throwables.
 * @return The formatted suppressed Throwables.
 */
public String getSuppressedStackTrace(){
  ThrowableProxy[] suppressed=getSuppressedProxies();
  if (suppressed == null || suppressed.length == 0) {
    return ""String_Node_Str"";
  }
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  for (  ThrowableProxy proxy : suppressed) {
    sb.append(proxy.getExtendedStackTrace());
  }
  return sb.toString();
}"
90835,"/** 
 * Obtain a SocketManager.
 * @param host The host to connect to.
 * @param port The port on the host.
 * @return A DatagramSocketManager.
 */
public static DatagramSocketManager getSocketManager(String host,int port){
  if (host == null || host.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (port <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return (DatagramSocketManager)getManager(""String_Node_Str"" + host + ""String_Node_Str""+ port,factory,new FactoryData(host,port));
}","/** 
 * Obtain a SocketManager.
 * @param host The host to connect to.
 * @param port The port on the host.
 * @return A DatagramSocketManager.
 */
public static DatagramSocketManager getSocketManager(String host,int port){
  if (host == null || host.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (port <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return (DatagramSocketManager)getManager(""String_Node_Str"" + host + ""String_Node_Str""+ port,new FactoryData(host,port),factory);
}"
90836,"/** 
 * Obtain a TCPSocketManager.
 * @param host The host to connect to.
 * @param port The port on the host.
 * @param delay The interval to pause between retries.
 * @return A TCPSocketManager.
 */
public static TCPSocketManager getSocketManager(String host,int port,int delay){
  if (host == null || host.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (port <= 0) {
    port=DEFAULT_PORT;
  }
  if (delay == 0) {
    delay=DEFAULT_RECONNECTION_DELAY;
  }
  return (TCPSocketManager)getManager(""String_Node_Str"" + host + ""String_Node_Str""+ port,factory,new FactoryData(host,port,delay));
}","/** 
 * Obtain a TCPSocketManager.
 * @param host The host to connect to.
 * @param port The port on the host.
 * @param delay The interval to pause between retries.
 * @return A TCPSocketManager.
 */
public static TCPSocketManager getSocketManager(String host,int port,int delay){
  if (host == null || host.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (port <= 0) {
    port=DEFAULT_PORT;
  }
  if (delay == 0) {
    delay=DEFAULT_RECONNECTION_DELAY;
  }
  return (TCPSocketManager)getManager(""String_Node_Str"" + host + ""String_Node_Str""+ port,new FactoryData(host,port,delay),factory);
}"
90837,"/** 
 * Create a Flume Avro Appender.
 * @param agents An array of Agents.
 * @param delay The amount of time in milliseconds to wait between retries.
 * @param agentRetries The number of times to retry an agent before failing to the next agent.
 * @param name The name of the Appender.
 * @param suppress If true exceptions will be handled in the appender.
 * @param excludes A comma separated list of MDC elements to exclude.
 * @param includes A comma separated list of MDC elements to include.
 * @param required A comma separated list of MDC elements that are required.
 * @param mdcPrefix The prefix to add to MDC key names.
 * @param eventPrefix The prefix to add to event key names.
 * @param compressBody If true the event body will be compressed.
 * @param batchSize Number of events to include in a batch. Defaults to 1.
 * @param factory The factory to use to create Flume events.
 * @param layout The layout to format the event.
 * @param filter A Filter to filter events.
 * @return A Flume Avro Appender.
 */
@PluginFactory public static FlumeAvroAppender createAppender(@PluginElement(""String_Node_Str"") Agent[] agents,@PluginAttr(""String_Node_Str"") String delay,@PluginAttr(""String_Node_Str"") String agentRetries,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String suppress,@PluginAttr(""String_Node_Str"") String excludes,@PluginAttr(""String_Node_Str"") String includes,@PluginAttr(""String_Node_Str"") String required,@PluginAttr(""String_Node_Str"") String mdcPrefix,@PluginAttr(""String_Node_Str"") String eventPrefix,@PluginAttr(""String_Node_Str"") String compressBody,@PluginAttr(""String_Node_Str"") String batchSize,@PluginElement(""String_Node_Str"") FlumeEventFactory factory,@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") Filter filter){
  String hostname;
  try {
    hostname=InetAddress.getLocalHost().getHostName();
  }
 catch (  Exception ex) {
    LOGGER.error(""String_Node_Str"",ex);
    return null;
  }
  if (agents == null || agents.length == 0) {
    LOGGER.debug(""String_Node_Str"");
    agents=new Agent[]{Agent.createAgent(null,null)};
  }
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  boolean compress=compressBody == null ? true : Boolean.valueOf(compressBody);
  int batchCount=batchSize == null ? 1 : Integer.parseInt(batchSize);
  int reconnectDelay=delay == null ? 0 : Integer.parseInt(delay);
  int retries=agentRetries == null ? 0 : Integer.parseInt(agentRetries);
  if (layout == null) {
    layout=RFC5424Layout.createLayout(null,null,null,""String_Node_Str"",null,null,null,null,excludes,includes,required,null,null);
  }
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  FlumeAvroManager manager=FlumeAvroManager.getManager(agents,batchCount);
  if (manager == null) {
    return null;
  }
  return new FlumeAvroAppender(name,filter,layout,handleExceptions,hostname,includes,excludes,required,mdcPrefix,eventPrefix,compress,reconnectDelay,retries,factory,manager);
}","/** 
 * Create a Flume Avro Appender.
 * @param agents An array of Agents.
 * @param delay The amount of time in milliseconds to wait between retries.
 * @param agentRetries The number of times to retry an agent before failing to the next agent.
 * @param name The name of the Appender.
 * @param suppress If true exceptions will be handled in the appender.
 * @param excludes A comma separated list of MDC elements to exclude.
 * @param includes A comma separated list of MDC elements to include.
 * @param required A comma separated list of MDC elements that are required.
 * @param mdcPrefix The prefix to add to MDC key names.
 * @param eventPrefix The prefix to add to event key names.
 * @param compressBody If true the event body will be compressed.
 * @param batchSize Number of events to include in a batch. Defaults to 1.
 * @param factory The factory to use to create Flume events.
 * @param layout The layout to format the event.
 * @param filter A Filter to filter events.
 * @return A Flume Avro Appender.
 */
@PluginFactory public static FlumeAvroAppender createAppender(@PluginElement(""String_Node_Str"") Agent[] agents,@PluginAttr(""String_Node_Str"") String delay,@PluginAttr(""String_Node_Str"") String agentRetries,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String suppress,@PluginAttr(""String_Node_Str"") String excludes,@PluginAttr(""String_Node_Str"") String includes,@PluginAttr(""String_Node_Str"") String required,@PluginAttr(""String_Node_Str"") String mdcPrefix,@PluginAttr(""String_Node_Str"") String eventPrefix,@PluginAttr(""String_Node_Str"") String compressBody,@PluginAttr(""String_Node_Str"") String batchSize,@PluginElement(""String_Node_Str"") FlumeEventFactory factory,@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") Filter filter){
  String hostname;
  try {
    hostname=getHostName();
  }
 catch (  Exception ex) {
    LOGGER.error(""String_Node_Str"",ex);
    return null;
  }
  if (agents == null || agents.length == 0) {
    LOGGER.debug(""String_Node_Str"");
    agents=new Agent[]{Agent.createAgent(null,null)};
  }
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  boolean compress=compressBody == null ? true : Boolean.valueOf(compressBody);
  int batchCount=batchSize == null ? 1 : Integer.parseInt(batchSize);
  int reconnectDelay=delay == null ? 0 : Integer.parseInt(delay);
  int retries=agentRetries == null ? 0 : Integer.parseInt(agentRetries);
  if (layout == null) {
    layout=RFC5424Layout.createLayout(null,null,null,""String_Node_Str"",null,null,null,null,excludes,includes,required,null,null);
  }
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  FlumeAvroManager manager=FlumeAvroManager.getManager(agents,batchCount);
  if (manager == null) {
    return null;
  }
  return new FlumeAvroAppender(name,filter,layout,handleExceptions,hostname,includes,excludes,required,mdcPrefix,eventPrefix,compress,reconnectDelay,retries,factory,manager);
}"
90838,"/** 
 * Log an exception or error to be thrown. This may be coded as <br /> throw logger.throwing(debug, myException);
 * @param level The logging Level.
 * @param t The Throwable.
 * @return the Throwable.
 */
<T extends Throwable>T throwing(Level level,T t);","/** 
 * Log an exception or error to be thrown. This may be coded as <br /> throw logger.throwing(debug, myException);
 * @param < T > the Throwable type.
 * @param level The logging Level.
 * @param t The Throwable.
 * @return the Throwable.
 */
<T extends Throwable>T throwing(Level level,T t);"
90839,"/** 
 * Log exiting from a method with the result. This may be coded as <br /> return logger.exit(myResult);
 * @param result The result being returned from the method call.
 * @return the result.
 */
<R>R exit(R result);","/** 
 * Log exiting from a method with the result. This may be coded as <br /> return logger.exit(myResult);
 * @param < R > The type of the parameter and object being returned.
 * @param result The result being returned from the method call.
 * @return the result.
 */
<R>R exit(R result);"
90840,"/** 
 * Format the message according the the specified format.
 * @param formats An array of Strings that provide extra information about how to format the message.StructuredDataMessage accepts only a format of ""FULL"" which will cause the event type to be prepended and the event message to be appended. Specifying any other value will cause only the StructuredData to be included. The default is ""FULL"".
 * @return
 */
@Override public String getFormattedMessage(String[] formats){
  if (formats != null && formats.length > 0) {
    for (    String format : formats) {
      if (format.equalsIgnoreCase(FULL)) {
        return asString(FULL,null);
      }
    }
    return asString(null,null);
  }
 else {
    return asString(FULL,null);
  }
}","/** 
 * Format the message according the the specified format.
 * @param formats An array of Strings that provide extra information about how to format the message.StructuredDataMessage accepts only a format of ""FULL"" which will cause the event type to be prepended and the event message to be appended. Specifying any other value will cause only the StructuredData to be included. The default is ""FULL"".
 * @return the formatted message.
 */
@Override public String getFormattedMessage(String[] formats){
  if (formats != null && formats.length > 0) {
    for (    String format : formats) {
      if (format.equalsIgnoreCase(FULL)) {
        return asString(FULL,null);
      }
    }
    return asString(null,null);
  }
 else {
    return asString(FULL,null);
  }
}"
90841,"/** 
 * Log an exception or error to be thrown.
 * @param level The logging Level.
 * @param t     The Throwable.
 * @return the Throwable.
 */
public <T extends Throwable>T throwing(Level level,T t){
  if (isEnabled(level,THROWING_MARKER,(Object)null,null)) {
    log(THROWING_MARKER,FQCN,level,new SimpleMessage(""String_Node_Str""),t);
  }
  return t;
}","/** 
 * Log an exception or error to be thrown.
 * @param < T > the type of the Throwable.
 * @param level The logging Level.
 * @param t     The Throwable.
 * @return the Throwable.
 */
public <T extends Throwable>T throwing(Level level,T t){
  if (isEnabled(level,THROWING_MARKER,(Object)null,null)) {
    log(THROWING_MARKER,FQCN,level,new SimpleMessage(""String_Node_Str""),t);
  }
  return t;
}"
90842,"/** 
 * Log exiting from a method with the result.
 * @param result The result being returned from the method call.
 * @return the Throwable.
 */
public <R>R exit(R result){
  if (isEnabled(Level.TRACE,EXIT_MARKER,(Object)null,null)) {
    log(EXIT_MARKER,FQCN,Level.TRACE,exitMsg(result),null);
  }
  return result;
}","/** 
 * Log exiting from a method with the result.
 * @param < R > The type of the parameter and object being returned.
 * @param result The result being returned from the method call.
 * @return the Throwable.
 */
public <R>R exit(R result){
  if (isEnabled(Level.TRACE,EXIT_MARKER,(Object)null,null)) {
    log(EXIT_MARKER,FQCN,Level.TRACE,exitMsg(result),null);
  }
  return result;
}"
90843,"@Test public void testFull(){
  ExtendedThrowablePatternConverter converter=ExtendedThrowablePatternConverter.newInstance(null);
  Throwable cause=new NullPointerException(""String_Node_Str"");
  Throwable parent=new IllegalArgumentException(""String_Node_Str"",cause);
  LogEvent event=new Log4jLogEvent(""String_Node_Str"",null,this.getClass().getName(),Level.DEBUG,new SimpleMessage(""String_Node_Str""),parent);
  StringBuilder sb=new StringBuilder();
  converter.format(event,sb);
  StringWriter sw=new StringWriter();
  PrintWriter pw=new PrintWriter(sw);
  parent.printStackTrace(pw);
  String result=sb.toString();
  result=result.replaceAll(""String_Node_Str"",""String_Node_Str"");
  assertEquals(sw.toString(),result);
}","@Test public void testFull(){
  ExtendedThrowablePatternConverter converter=ExtendedThrowablePatternConverter.newInstance(null);
  Throwable cause=new NullPointerException(""String_Node_Str"");
  Throwable parent=new IllegalArgumentException(""String_Node_Str"",cause);
  LogEvent event=new Log4jLogEvent(""String_Node_Str"",null,this.getClass().getName(),Level.DEBUG,new SimpleMessage(""String_Node_Str""),parent);
  StringBuilder sb=new StringBuilder();
  converter.format(event,sb);
  StringWriter sw=new StringWriter();
  PrintWriter pw=new PrintWriter(sw);
  parent.printStackTrace(pw);
  String result=sb.toString();
  result=result.replaceAll(""String_Node_Str"",""String_Node_Str"");
  String expected=sw.toString().replaceAll(""String_Node_Str"",""String_Node_Str"");
  assertEquals(expected,result);
}"
90844,"@Test public void testReplacement(){
  ThreadContext.put(""String_Node_Str"",""String_Node_Str"");
  LogEvent event=new Log4jLogEvent(RegexReplacementConverterTest.class.getName(),null,null,Level.DEBUG,new SimpleMessage(""String_Node_Str""),null);
  StringBuilder sb=new StringBuilder();
  LoggerContext ctx=(LoggerContext)LogManager.getContext();
  String[] options=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  RegexReplacementConverter converter=RegexReplacementConverter.newInstance(ctx.getConfiguration(),options);
  converter.format(event,sb);
  assertEquals(""String_Node_Str"",sb.toString());
}","@Test public void testReplacement(){
  ThreadContext.put(""String_Node_Str"",""String_Node_Str"");
  LogEvent event=new Log4jLogEvent(RegexReplacementConverterTest.class.getName(),null,null,Level.DEBUG,new SimpleMessage(""String_Node_Str""),null);
  StringBuilder sb=new StringBuilder();
  LoggerContext ctx=(LoggerContext)LogManager.getContext();
  String[] options=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  RegexReplacementConverter converter=RegexReplacementConverter.newInstance(ctx.getConfiguration(),options);
  converter.format(event,sb);
  assertEquals(""String_Node_Str"" + LINE_SEP,sb.toString());
}"
90845,"@Test public void testReplacement(){
  logger.error(this.getClass().getName());
  List<String> msgs=app.getMessages();
  assertNotNull(msgs);
  assertTrue(""String_Node_Str"" + msgs.size(),msgs.size() == 1);
  assertTrue(""String_Node_Str"",msgs.get(0).endsWith(""String_Node_Str""));
  app.clear();
  ThreadContext.put(""String_Node_Str"",""String_Node_Str"");
  logger.error(""String_Node_Str"");
  msgs=app.getMessages();
  assertNotNull(msgs);
  assertTrue(""String_Node_Str"" + msgs.size(),msgs.size() == 1);
  assertEquals(""String_Node_Str"",msgs.get(0));
  app.clear();
}","@Test public void testReplacement(){
  logger.error(this.getClass().getName());
  List<String> msgs=app.getMessages();
  assertNotNull(msgs);
  assertTrue(""String_Node_Str"" + msgs.size(),msgs.size() == 1);
  assertTrue(""String_Node_Str"" + EXPECTED + ""String_Node_Str""+ msgs.get(0),msgs.get(0).endsWith(EXPECTED));
  app.clear();
  ThreadContext.put(""String_Node_Str"",""String_Node_Str"");
  logger.error(""String_Node_Str"");
  msgs=app.getMessages();
  assertNotNull(msgs);
  assertTrue(""String_Node_Str"" + msgs.size(),msgs.size() == 1);
  assertEquals(""String_Node_Str"" + LINE_SEP,msgs.get(0));
  app.clear();
}"
90846,"@Test public void testConverter(){
  logger2.error(this.getClass().getName());
  List<String> msgs=app2.getMessages();
  assertNotNull(msgs);
  assertTrue(""String_Node_Str"" + msgs.size(),msgs.size() == 1);
  assertTrue(""String_Node_Str"",msgs.get(0).endsWith(""String_Node_Str""));
  app2.clear();
}","@Test public void testConverter(){
  logger2.error(this.getClass().getName());
  List<String> msgs=app2.getMessages();
  assertNotNull(msgs);
  assertTrue(""String_Node_Str"" + msgs.size(),msgs.size() == 1);
  assertTrue(""String_Node_Str"" + EXPECTED + ""String_Node_Str""+ msgs.get(0),msgs.get(0).endsWith(EXPECTED));
  app2.clear();
}"
90847,"private void write(byte[] bytes){
  if (raw) {
    data.add(bytes);
    return;
  }
  String str=new String(bytes);
  if (newLine) {
    int index=0;
    while (index < str.length()) {
      int end=str.indexOf(LINE_SEP,index);
      if (index == end) {
        if (!messages.get(messages.size() - LINE_SEP.length()).equals(""String_Node_Str"")) {
          messages.add(""String_Node_Str"");
        }
      }
 else       if (end >= 0) {
        messages.add(str.substring(index,end));
      }
 else {
        messages.add(str.substring(index));
        break;
      }
      index=end + LINE_SEP.length();
    }
  }
 else {
    messages.add(str);
  }
}","private void write(byte[] bytes){
  if (raw) {
    data.add(bytes);
    return;
  }
  String str=new String(bytes);
  if (newLine) {
    int index=0;
    while (index < str.length()) {
      int end;
      int wend=str.indexOf(WINDOWS_LINE_SEP,index);
      int lend=str.indexOf(""String_Node_Str"",index);
      int length;
      if (wend >= 0 && wend < lend) {
        end=wend;
        length=2;
      }
 else {
        end=lend;
        length=1;
      }
      if (index == end) {
        if (!messages.get(messages.size() - length).equals(""String_Node_Str"")) {
          messages.add(""String_Node_Str"");
        }
      }
 else       if (end >= 0) {
        messages.add(str.substring(index,end));
      }
 else {
        messages.add(str.substring(index));
        break;
      }
      index=end + length;
    }
  }
 else {
    messages.add(str);
  }
}"
90848,"/** 
 * Log events and specify the logging level.
 * @param msg The event StructuredDataMessage.
 * @param level The logging Level.
 */
public static void logEvent(StructuredDataMessage msg,Level level){
  logger.log(marker,FQCN,level,msg,null);
}","/** 
 * Log events and specify the logging level.
 * @param msg The event StructuredDataMessage.
 * @param level The logging Level.
 */
public static void logEvent(StructuredDataMessage msg,Level level){
  logger.log(EVENT_MARKER,FQCN,level,msg,null);
}"
90849,"public void printThreadInfo(StringBuilder sb){
  sb.append(""String_Node_Str"").append(name).append(""String_Node_Str"");
  if (isDaemon) {
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"").append(priority).append(""String_Node_Str"").append(id).append(""String_Node_Str"");
  if (threadGroupName != null) {
    sb.append(""String_Node_Str"").append(threadGroupName).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(state.name()).append(""String_Node_Str"");
}","/** 
 * Print the thread information.
 * @param sb The StringBuilder.
 */
public void printThreadInfo(StringBuilder sb){
  sb.append(""String_Node_Str"").append(name).append(""String_Node_Str"");
  if (isDaemon) {
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"").append(priority).append(""String_Node_Str"").append(id).append(""String_Node_Str"");
  if (threadGroupName != null) {
    sb.append(""String_Node_Str"").append(threadGroupName).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(state.name()).append(""String_Node_Str"");
}"
90850,"@Override public int hashCode(){
  int result=(int)(id ^ (id >>> 32));
  result=31 * result + (name != null ? name.hashCode() : 0);
  return result;
}","@Override public int hashCode(){
  int result=(int)(id ^ (id >>> HASH_SHIFT));
  result=HASH_MULTIPLIER * result + (name != null ? name.hashCode() : 0);
  return result;
}"
90851,"public void printStack(StringBuilder sb,StackTraceElement[] trace){
  for (  StackTraceElement element : trace) {
    sb.append(""String_Node_Str"").append(element).append(""String_Node_Str"");
  }
}","/** 
 * Format the StackTraceElements.
 * @param sb The StringBuilder.
 * @param trace The stack trace element array to format.
 */
public void printStack(StringBuilder sb,StackTraceElement[] trace){
  for (  StackTraceElement element : trace) {
    sb.append(""String_Node_Str"").append(element).append(""String_Node_Str"");
  }
}"
90852,"public BasicThreadInformation(Thread thread){
  this.id=thread.getId();
  this.name=thread.getName();
  this.longName=thread.toString();
  this.state=thread.getState();
  this.priority=thread.getPriority();
  this.isAlive=thread.isAlive();
  this.isDaemon=thread.isDaemon();
  ThreadGroup group=thread.getThreadGroup();
  threadGroupName=group == null ? null : group.getName();
}","/** 
 * The Constructor.
 * @param thread The Thread to capture.
 */
public BasicThreadInformation(Thread thread){
  this.id=thread.getId();
  this.name=thread.getName();
  this.longName=thread.toString();
  this.state=thread.getState();
  this.priority=thread.getPriority();
  this.isAlive=thread.isAlive();
  this.isDaemon=thread.isDaemon();
  ThreadGroup group=thread.getThreadGroup();
  threadGroupName=group == null ? null : group.getName();
}"
90853,"/** 
 * Returns an array with a single element, a Map containing the ThreadInformation as the key and the StackTraceElement array as the value;
 * @return the ""parameters"" to this Message.
 */
public Object[] getParameters(){
  return null;
}","/** 
 * Returns an array with a single element, a Map containing the ThreadInformation as the key. and the StackTraceElement array as the value;
 * @return the ""parameters"" to this Message.
 */
public Object[] getParameters(){
  return null;
}"
90854,"private String computeTimeStampString(long now){
  long last;
synchronized (this) {
    last=lastTimestamp;
    if (now == lastTimestamp) {
      return timestamppStr;
    }
  }
  StringBuilder buf=new StringBuilder();
  Calendar cal=new GregorianCalendar();
  cal.setTimeInMillis(now);
  buf.append(Integer.toString(cal.get(Calendar.YEAR)));
  buf.append(""String_Node_Str"");
  pad(cal.get(Calendar.MONTH) + 1,TWO_DIGITS,buf);
  buf.append(""String_Node_Str"");
  pad(cal.get(Calendar.DAY_OF_MONTH),TWO_DIGITS,buf);
  buf.append(""String_Node_Str"");
  pad(cal.get(Calendar.HOUR_OF_DAY),TWO_DIGITS,buf);
  buf.append(""String_Node_Str"");
  pad(cal.get(Calendar.MINUTE),TWO_DIGITS,buf);
  buf.append(""String_Node_Str"");
  pad(cal.get(Calendar.SECOND),TWO_DIGITS,buf);
  int millis=cal.get(Calendar.MILLISECOND);
  if (millis != 0) {
    buf.append(""String_Node_Str"");
    pad((int)((float)millis / 10F),THREE_DIGITS,buf);
  }
  int tzmin=(cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET)) / MILLIS_PER_MINUTE;
  if (tzmin == 0) {
    buf.append(""String_Node_Str"");
  }
 else {
    if (tzmin < 0) {
      tzmin=-tzmin;
      buf.append(""String_Node_Str"");
    }
 else {
      buf.append(""String_Node_Str"");
    }
    int tzhour=tzmin / MINUTES_PER_HOUR;
    tzmin-=tzhour * MINUTES_PER_HOUR;
    pad(tzhour,TWO_DIGITS,buf);
    buf.append(""String_Node_Str"");
    pad(tzmin,TWO_DIGITS,buf);
  }
synchronized (this) {
    if (last == lastTimestamp) {
      lastTimestamp=now;
      timestamppStr=buf.toString();
    }
  }
  return buf.toString();
}","private String computeTimeStampString(long now){
  long last;
synchronized (this) {
    last=lastTimestamp;
    if (now == lastTimestamp) {
      return timestamppStr;
    }
  }
  StringBuilder buf=new StringBuilder();
  Calendar cal=new GregorianCalendar();
  cal.setTimeInMillis(now);
  buf.append(Integer.toString(cal.get(Calendar.YEAR)));
  buf.append(""String_Node_Str"");
  pad(cal.get(Calendar.MONTH) + 1,TWO_DIGITS,buf);
  buf.append(""String_Node_Str"");
  pad(cal.get(Calendar.DAY_OF_MONTH),TWO_DIGITS,buf);
  buf.append(""String_Node_Str"");
  pad(cal.get(Calendar.HOUR_OF_DAY),TWO_DIGITS,buf);
  buf.append(""String_Node_Str"");
  pad(cal.get(Calendar.MINUTE),TWO_DIGITS,buf);
  buf.append(""String_Node_Str"");
  pad(cal.get(Calendar.SECOND),TWO_DIGITS,buf);
  int millis=cal.get(Calendar.MILLISECOND);
  if (millis != 0) {
    buf.append(""String_Node_Str"");
    pad(millis,THREE_DIGITS,buf);
  }
  int tzmin=(cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET)) / MILLIS_PER_MINUTE;
  if (tzmin == 0) {
    buf.append(""String_Node_Str"");
  }
 else {
    if (tzmin < 0) {
      tzmin=-tzmin;
      buf.append(""String_Node_Str"");
    }
 else {
      buf.append(""String_Node_Str"");
    }
    int tzhour=tzmin / MINUTES_PER_HOUR;
    tzmin-=tzhour * MINUTES_PER_HOUR;
    pad(tzhour,TWO_DIGITS,buf);
    buf.append(""String_Node_Str"");
    pad(tzmin,TWO_DIGITS,buf);
  }
synchronized (this) {
    if (last == lastTimestamp) {
      lastTimestamp=now;
      timestamppStr=buf.toString();
    }
  }
  return buf.toString();
}"
90855,"protected static Object lookup(Context ctx,String name) throws NamingException {
  try {
    return ctx.lookup(name);
  }
 catch (  NameNotFoundException e) {
    LOGGER.error(""String_Node_Str"" + name + ""String_Node_Str"");
    throw e;
  }
}","/** 
 * Looks up the name in the context.
 * @param ctx The Context.
 * @param name The name to locate.
 * @return The object to be located.
 * @throws NamingException If an error occurs locating the name.
 */
protected static Object lookup(Context ctx,String name) throws NamingException {
  try {
    return ctx.lookup(name);
  }
 catch (  NameNotFoundException e) {
    LOGGER.error(""String_Node_Str"" + name + ""String_Node_Str"");
    throw e;
  }
}"
90856,"protected static Properties getEnvironment(String factoryName,String providerURL,String urlPkgPrefixes,String securityPrincipalName,String securityCredentials){
  Properties props=new Properties();
  if (factoryName != null) {
    props.put(Context.INITIAL_CONTEXT_FACTORY,factoryName);
    if (providerURL != null) {
      props.put(Context.PROVIDER_URL,providerURL);
    }
 else {
      LOGGER.warn(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (urlPkgPrefixes != null) {
      props.put(Context.URL_PKG_PREFIXES,urlPkgPrefixes);
    }
    if (securityPrincipalName != null) {
      props.put(Context.SECURITY_PRINCIPAL,securityPrincipalName);
      if (securityCredentials != null) {
        props.put(Context.SECURITY_CREDENTIALS,securityCredentials);
      }
 else {
        LOGGER.warn(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    return props;
  }
  return null;
}","/** 
 * Sets up the properties to pass to the InitialContext.
 * @param factoryName The fully qualified class name of the InitialContextFactory.
 * @param providerURL The URL of the provider to use.
 * @param urlPkgPrefixes A colon-separated list of package prefixes for the class name of the factory class thatwill create a URL context factory
 * @param securityPrincipalName The name of the identity of the Principal.
 * @param securityCredentials The security credentials of the Principal.
 * @return The Properties.
 */
protected static Properties getEnvironment(String factoryName,String providerURL,String urlPkgPrefixes,String securityPrincipalName,String securityCredentials){
  Properties props=new Properties();
  if (factoryName != null) {
    props.put(Context.INITIAL_CONTEXT_FACTORY,factoryName);
    if (providerURL != null) {
      props.put(Context.PROVIDER_URL,providerURL);
    }
 else {
      LOGGER.warn(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (urlPkgPrefixes != null) {
      props.put(Context.URL_PKG_PREFIXES,urlPkgPrefixes);
    }
    if (securityPrincipalName != null) {
      props.put(Context.SECURITY_PRINCIPAL,securityPrincipalName);
      if (securityCredentials != null) {
        props.put(Context.SECURITY_CREDENTIALS,securityCredentials);
      }
 else {
        LOGGER.warn(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    return props;
  }
  return null;
}"
90857,"public AbstractJMSManager(String name){
  super(name);
}","/** 
 * The Constructor.
 * @param name The name of the Appender.
 */
public AbstractJMSManager(String name){
  super(name);
}"
90858,"protected static Context createContext(String factoryName,String providerURL,String urlPkgPrefixes,String securityPrincipalName,String securityCredentials) throws NamingException {
  Properties props=getEnvironment(factoryName,providerURL,urlPkgPrefixes,securityPrincipalName,securityCredentials);
  return new InitialContext(props);
}","/** 
 * Create the InitialContext.
 * @param factoryName The fully qualified class name of the InitialContextFactory.
 * @param providerURL The URL of the provider to use.
 * @param urlPkgPrefixes A colon-separated list of package prefixes for the class name of the factory class thatwill create a URL context factory
 * @param securityPrincipalName The name of the identity of the Principal.
 * @param securityCredentials The security credentials of the Principal.
 * @return the InitialContext.
 * @throws NamingException if a naming error occurs.
 */
protected static Context createContext(String factoryName,String providerURL,String urlPkgPrefixes,String securityPrincipalName,String securityCredentials) throws NamingException {
  Properties props=getEnvironment(factoryName,providerURL,urlPkgPrefixes,securityPrincipalName,securityCredentials);
  return new InitialContext(props);
}"
90859,"public synchronized void send(Serializable object,Session session,MessageProducer producer) throws Exception {
  try {
    Message msg;
    if (object instanceof String) {
      msg=session.createTextMessage();
      ((TextMessage)msg).setText((String)object);
    }
 else {
      msg=session.createObjectMessage();
      ((ObjectMessage)msg).setObject(object);
    }
    producer.send(msg);
  }
 catch (  JMSException ex) {
    LOGGER.error(""String_Node_Str"" + getName());
    throw ex;
  }
}","/** 
 * Send the Object.
 * @param object The Object to send.
 * @param session The Session.
 * @param producer The MessageProducer.
 * @throws Exception if an error occurs.
 */
public synchronized void send(Serializable object,Session session,MessageProducer producer) throws Exception {
  try {
    Message msg;
    if (object instanceof String) {
      msg=session.createTextMessage();
      ((TextMessage)msg).setText((String)object);
    }
 else {
      msg=session.createObjectMessage();
      ((ObjectMessage)msg).setObject(object);
    }
    producer.send(msg);
  }
 catch (  JMSException ex) {
    LOGGER.error(""String_Node_Str"" + getName());
    throw ex;
  }
}"
90860,"protected Object lookup(Context ctx,String name) throws NamingException {
  try {
    return ctx.lookup(name);
  }
 catch (  NameNotFoundException e) {
    logger.error(""String_Node_Str"" + name + ""String_Node_Str"");
    throw e;
  }
}","/** 
 * Looks up an object from the Context.
 * @param ctx The Context.
 * @param name The name of the object to locate.
 * @return The object.
 * @throws NamingException if an error occurs.
 */
protected Object lookup(Context ctx,String name) throws NamingException {
  try {
    return ctx.lookup(name);
  }
 catch (  NameNotFoundException e) {
    logger.error(""String_Node_Str"" + name + ""String_Node_Str"");
    throw e;
  }
}"
90861,"public void onMessage(javax.jms.Message message){
  try {
    if (message instanceof ObjectMessage) {
      ObjectMessage objectMessage=(ObjectMessage)message;
      log((LogEvent)objectMessage.getObject());
    }
 else {
      logger.warn(""String_Node_Str"" + message.getJMSType() + ""String_Node_Str"");
    }
  }
 catch (  JMSException jmse) {
    logger.error(""String_Node_Str"",jmse);
  }
}","/** 
 * Listener that receives the event.
 * @param message The received message.
 */
public void onMessage(javax.jms.Message message){
  try {
    if (message instanceof ObjectMessage) {
      ObjectMessage objectMessage=(ObjectMessage)message;
      log((LogEvent)objectMessage.getObject());
    }
 else {
      logger.warn(""String_Node_Str"" + message.getJMSType() + ""String_Node_Str"");
    }
  }
 catch (  JMSException jmse) {
    logger.error(""String_Node_Str"",jmse);
  }
}"
90862,"public AbstractSocketManager(String name,OutputStream os,InetAddress addr,String host,int port){
  super(os,name);
  this.address=addr;
  this.host=host;
  this.port=port;
}","/** 
 * The Constructor.
 * @param name The unique name of this connection.
 * @param os The OutputStream to manage.
 * @param addr The internet address.
 * @param host The target host name.
 * @param port The target port number.
 */
public AbstractSocketManager(String name,OutputStream os,InetAddress addr,String host,int port){
  super(os,name);
  this.address=addr;
  this.host=host;
  this.port=port;
}"
90863,"public DatagramOutputStream(String host,int port){
  this.port=port;
  try {
    address=InetAddress.getByName(host);
  }
 catch (  UnknownHostException ex) {
    String msg=""String_Node_Str"" + host;
    logger.error(msg,ex);
    throw new AppenderRuntimeException(msg,ex);
  }
  try {
    ds=new DatagramSocket();
  }
 catch (  SocketException ex) {
    String msg=""String_Node_Str"" + host;
    logger.error(msg,ex);
    throw new AppenderRuntimeException(msg,ex);
  }
}","/** 
 * The Constructor.
 * @param host The host to connect to.
 * @param port The port on the host.
 */
public DatagramOutputStream(String host,int port){
  this.port=port;
  try {
    address=InetAddress.getByName(host);
  }
 catch (  UnknownHostException ex) {
    String msg=""String_Node_Str"" + host;
    LOGGER.error(msg,ex);
    throw new AppenderRuntimeException(msg,ex);
  }
  try {
    ds=new DatagramSocket();
  }
 catch (  SocketException ex) {
    String msg=""String_Node_Str"" + host;
    LOGGER.error(msg,ex);
    throw new AppenderRuntimeException(msg,ex);
  }
}"
90864,"public DatagramSocketManager(OutputStream os,String name,String host,int port){
  super(name,os,null,host,port);
}","/** 
 * The Constructor.
 * @param os The OutputStream.
 * @param name The unique name of the connection.
 * @param host The host to connect to.
 * @param port The port on the host.
 */
protected DatagramSocketManager(OutputStream os,String name,String host,int port){
  super(name,os,null,host,port);
}"
90865,"public static DatagramSocketManager getSocketManager(String host,int port){
  if (host == null || host.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (port <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return (DatagramSocketManager)getManager(""String_Node_Str"" + host + ""String_Node_Str""+ port,factory,new FactoryData(host,port));
}","/** 
 * Obtain a SocketManager.
 * @param host The host to connect to.
 * @param port The port on the host.
 * @return A DatagramSocketManager.
 */
public static DatagramSocketManager getSocketManager(String host,int port){
  if (host == null || host.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (port <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return (DatagramSocketManager)getManager(""String_Node_Str"" + host + ""String_Node_Str""+ port,factory,new FactoryData(host,port));
}"
90866,"public Throwable getThrown(){
  return event.getThrown();
}","/** 
 * Return the Throwable associated with the event, if any.
 * @return the Throwable.
 */
public Throwable getThrown(){
  return event.getThrown();
}"
90867,"public Message getMessage(){
  return event.getMessage();
}","/** 
 * Return the Message.
 * @return the Message.
 */
public Message getMessage(){
  return event.getMessage();
}"
90868,"public void setBody(byte[] body){
  if (body == null || body.length == 0) {
    this.body=new byte[0];
    return;
  }
  if (compress) {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    try {
      GZIPOutputStream os=new GZIPOutputStream(baos);
      os.write(body);
      os.close();
    }
 catch (    IOException ioe) {
      throw new LoggingException(""String_Node_Str"",ioe);
    }
    this.body=baos.toByteArray();
  }
 else {
    this.body=body;
  }
}","/** 
 * Set the body in the event.
 * @param body The body to add to the event.
 */
public void setBody(byte[] body){
  if (body == null || body.length == 0) {
    this.body=new byte[0];
    return;
  }
  if (compress) {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    try {
      GZIPOutputStream os=new GZIPOutputStream(baos);
      os.write(body);
      os.close();
    }
 catch (    IOException ioe) {
      throw new LoggingException(""String_Node_Str"",ioe);
    }
    this.body=baos.toByteArray();
  }
 else {
    this.body=body;
  }
}"
90869,"public long getMillis(){
  return event.getMillis();
}","/** 
 * Return the event timestamp.
 * @return the event timestamp.
 */
public long getMillis(){
  return event.getMillis();
}"
90870,"public Level getLevel(){
  return event.getLevel();
}","/** 
 * Return the logging Level.
 * @return the Level.
 */
public Level getLevel(){
  return event.getLevel();
}"
90871,"public Map<String,String> getContextMap(){
  return ctx;
}","/** 
 * Return a copy of the context Map.
 * @return a copy of the context Map.
 */
public Map<String,String> getContextMap(){
  return ctx;
}"
90872,"public FlumeEvent(LogEvent event,String hostname,String includes,String excludes,String required,String mdcPrefix,String eventPrefix,boolean compress){
  this.event=event;
  this.hostname=hostname;
  this.compress=compress;
  if (mdcPrefix == null) {
    mdcPrefix=DEFAULT_MDC_PREFIX;
  }
  if (eventPrefix == null) {
    eventPrefix=DEFAULT_EVENT_PREFIX;
  }
  this.fields=new HashMap<String,byte[]>();
  Map<String,String> mdc=event.getContextMap();
  if (includes != null) {
    String[] array=includes.split(""String_Node_Str"");
    if (array.length > 0) {
      for (      String str : array) {
        if (mdc.containsKey(str)) {
          ctx.put(str,mdc.get(str));
        }
      }
    }
  }
 else   if (excludes != null) {
    String[] array=excludes.split(""String_Node_Str"");
    if (array.length > 0) {
      List<String> list=Arrays.asList(array);
      for (      Map.Entry<String,String> entry : mdc.entrySet()) {
        if (!list.contains(entry.getKey())) {
          ctx.put(entry.getKey(),entry.getValue());
        }
      }
    }
  }
  if (required != null) {
    String[] array=required.split(""String_Node_Str"");
    if (array.length > 0) {
      for (      String str : array) {
        if (!mdc.containsKey(str)) {
          throw new LoggingException(""String_Node_Str"" + str + ""String_Node_Str"");
        }
      }
    }
  }
  Message message=event.getMessage();
  if (message instanceof MapMessage) {
    if (message instanceof StructuredDataMessage) {
      addStructuredData(eventPrefix,fields,(StructuredDataMessage)message);
    }
    addMapData(eventPrefix,fields,(MapMessage)message);
  }
  addContextData(mdcPrefix,fields,ctx);
  addGuid(fields);
}","/** 
 * Construct the FlumeEvent.
 * @param event The Log4j LogEvent.
 * @param hostname The host name.
 * @param includes A comma separated list of MDC elements to include.
 * @param excludes A comma separated list of MDC elements to exclude.
 * @param required A comma separated list of MDC elements that are required to be defined.
 * @param mdcPrefix The value to prefix to MDC keys.
 * @param eventPrefix The value to prefix to event keys.
 * @param compress If true the event body should be compressed.
 */
public FlumeEvent(LogEvent event,String hostname,String includes,String excludes,String required,String mdcPrefix,String eventPrefix,boolean compress){
  this.event=event;
  this.hostname=hostname;
  this.compress=compress;
  if (mdcPrefix == null) {
    mdcPrefix=DEFAULT_MDC_PREFIX;
  }
  if (eventPrefix == null) {
    eventPrefix=DEFAULT_EVENT_PREFIX;
  }
  this.fields=new HashMap<String,byte[]>();
  Map<String,String> mdc=event.getContextMap();
  if (includes != null) {
    String[] array=includes.split(""String_Node_Str"");
    if (array.length > 0) {
      for (      String str : array) {
        if (mdc.containsKey(str)) {
          ctx.put(str,mdc.get(str));
        }
      }
    }
  }
 else   if (excludes != null) {
    String[] array=excludes.split(""String_Node_Str"");
    if (array.length > 0) {
      List<String> list=Arrays.asList(array);
      for (      Map.Entry<String,String> entry : mdc.entrySet()) {
        if (!list.contains(entry.getKey())) {
          ctx.put(entry.getKey(),entry.getValue());
        }
      }
    }
  }
  if (required != null) {
    String[] array=required.split(""String_Node_Str"");
    if (array.length > 0) {
      for (      String str : array) {
        if (!mdc.containsKey(str)) {
          throw new LoggingException(""String_Node_Str"" + str + ""String_Node_Str"");
        }
      }
    }
  }
  Message message=event.getMessage();
  if (message instanceof MapMessage) {
    if (message instanceof StructuredDataMessage) {
      addStructuredData(eventPrefix,fields,(StructuredDataMessage)message);
    }
    addMapData(eventPrefix,fields,(MapMessage)message);
  }
  addContextData(mdcPrefix,fields,ctx);
  addGuid(fields);
}"
90873,"public String getFQCN(){
  return event.getFQCN();
}","/** 
 * Get the Frequently Qualified Class Name.
 * @return the FQCN String.
 */
public String getFQCN(){
  return event.getFQCN();
}"
90874,"public Marker getMarker(){
  return event.getMarker();
}","/** 
 * Return the Marker.
 * @return the Marker.
 */
public Marker getMarker(){
  return event.getMarker();
}"
90875,"public Stack<String> getContextStack(){
  return event.getContextStack();
}","/** 
 * Return a copy of the context stack.
 * @return a copy of the context stack.
 */
public Stack<String> getContextStack(){
  return event.getContextStack();
}"
90876,"public StackTraceElement getSource(){
  return event.getSource();
}","/** 
 * Return the StackTraceElement for the caller of the logging API.
 * @return the StackTraceElement of the caller.
 */
public StackTraceElement getSource(){
  return event.getSource();
}"
90877,"public String getThreadName(){
  return event.getThreadName();
}","/** 
 * Return the name of the Thread.
 * @return the name of the Thread.
 */
public String getThreadName(){
  return event.getThreadName();
}"
90878,"public String getLoggerName(){
  return event.getLoggerName();
}","/** 
 * Return the logger name.
 * @return the logger name.
 */
public String getLoggerName(){
  return event.getLoggerName();
}"
90879,"FlumeEvent createEvent(LogEvent event,String hostname,String includes,String excludes,String required,String mdcPrefix,String eventPrefix,boolean compress);","/** 
 * Create a Flume event.
 * @param event The Log4j LogEvent.
 * @param hostname The name of the host.
 * @param includes A comma separated list of MDC elements to include.
 * @param excludes A comma separated list of MDC elements to exclude.
 * @param required A comma separated list of MDC elements that are required.
 * @param mdcPrefix The value to prefix to MDC keys.
 * @param eventPrefix The value to prefix to event keys.
 * @param compress If true the event body should be compressed.
 * @return A FlumeEvent.
 */
FlumeEvent createEvent(LogEvent event,String hostname,String includes,String excludes,String required,String mdcPrefix,String eventPrefix,boolean compress);"
90880,"public String toString(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(mode);
  sb.append(""String_Node_Str"");
  boolean first=true;
  for (  Map.Entry<String,String> entry : map.entrySet()) {
    if (!first) {
      sb.append(""String_Node_Str"");
    }
    sb.append(entry.getKey()).append(""String_Node_Str"").append(entry.getValue());
    first=false;
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","/** 
 * Keys should be updated.
 */
@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(mode);
  sb.append(""String_Node_Str"");
  boolean first=true;
  for (  Map.Entry<String,String> entry : map.entrySet()) {
    if (!first) {
      sb.append(""String_Node_Str"");
    }
    sb.append(entry.getKey()).append(""String_Node_Str"").append(entry.getValue());
    first=false;
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
90881,"/** 
 * The factory method to create the MapRewritePolicy.
 * @param mode The string representation of the Mode.
 * @param pairs key/value pairs for the new Map keys and values.
 * @return The MapRewritePolicy.
 */
@PluginFactory public static MapRewritePolicy createPolicy(@PluginAttr(""String_Node_Str"") String mode,@PluginElement(""String_Node_Str"") KeyValuePair[] pairs){
  Mode op;
  if (mode == null) {
    op=Mode.Add;
  }
 else {
    op=Mode.valueOf(mode);
    if (op == null) {
      logger.error(""String_Node_Str"" + mode);
      return null;
    }
  }
  if (pairs == null || pairs.length == 0) {
    logger.error(""String_Node_Str"");
    return null;
  }
  Map<String,String> map=new HashMap<String,String>();
  for (  KeyValuePair pair : pairs) {
    String key=pair.getKey();
    if (key == null) {
      logger.error(""String_Node_Str"");
      continue;
    }
    String value=pair.getValue();
    if (value == null) {
      logger.error(""String_Node_Str"" + key + ""String_Node_Str"");
      continue;
    }
    map.put(pair.getKey(),pair.getValue());
  }
  if (map.size() == 0) {
    logger.error(""String_Node_Str"");
    return null;
  }
  return new MapRewritePolicy(map,op);
}","/** 
 * The factory method to create the MapRewritePolicy.
 * @param mode The string representation of the Mode.
 * @param pairs key/value pairs for the new Map keys and values.
 * @return The MapRewritePolicy.
 */
@PluginFactory public static MapRewritePolicy createPolicy(@PluginAttr(""String_Node_Str"") String mode,@PluginElement(""String_Node_Str"") KeyValuePair[] pairs){
  Mode op;
  if (mode == null) {
    op=Mode.Add;
  }
 else {
    op=Mode.valueOf(mode);
    if (op == null) {
      LOGGER.error(""String_Node_Str"" + mode);
      return null;
    }
  }
  if (pairs == null || pairs.length == 0) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  Map<String,String> map=new HashMap<String,String>();
  for (  KeyValuePair pair : pairs) {
    String key=pair.getKey();
    if (key == null) {
      LOGGER.error(""String_Node_Str"");
      continue;
    }
    String value=pair.getValue();
    if (value == null) {
      LOGGER.error(""String_Node_Str"" + key + ""String_Node_Str"");
      continue;
    }
    map.put(pair.getKey(),pair.getValue());
  }
  if (map.size() == 0) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  return new MapRewritePolicy(map,op);
}"
90882,"public AppenderWrapper(Appender appender){
  super(appender);
}","/** 
 * Constructor.
 * @param appender The Appender to wrap.
 */
public AppenderWrapper(Appender appender){
  super(appender);
}"
90883,"@PluginFactory public static RewriteAppender createAppender(@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String suppress,@PluginElement(""String_Node_Str"") String[] appenderRefs,@PluginConfiguration Configuration config,@PluginElement(""String_Node_Str"") RewritePolicy rewritePolicy,@PluginElement(""String_Node_Str"") Filter filter){
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (appenderRefs == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  return new RewriteAppender(name,filter,handleExceptions,appenderRefs,rewritePolicy,config);
}","/** 
 * Create a RewriteAppender.
 * @param name The name of the Appender.
 * @param suppress If true, exceptions will be handled in the Appender.
 * @param appenderRefs An array of Appender names to call.
 * @param config The Configuration.
 * @param rewritePolicy The policy to use to modify the event.
 * @param filter A Filter to filter events.
 * @return The created RewriteAppender.
 */
@PluginFactory public static RewriteAppender createAppender(@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String suppress,@PluginElement(""String_Node_Str"") String[] appenderRefs,@PluginConfiguration Configuration config,@PluginElement(""String_Node_Str"") RewritePolicy rewritePolicy,@PluginElement(""String_Node_Str"") Filter filter){
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (appenderRefs == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  return new RewriteAppender(name,filter,handleExceptions,appenderRefs,rewritePolicy,config);
}"
90884,"public void append(LogEvent event){
  if (rewritePolicy != null) {
    event=rewritePolicy.rewrite(event);
  }
  for (  AppenderControl control : appenders.values()) {
    control.callAppender(event);
  }
}","/** 
 * Modify the event and pass to the subordinate Appenders.
 * @param event The LogEvent.
 */
public void append(LogEvent event){
  if (rewritePolicy != null) {
    event=rewritePolicy.rewrite(event);
  }
  for (  AppenderControl control : appenders.values()) {
    control.callAppender(event);
  }
}"
90885,"@PluginFactory public static DefaultRolloverStrategy createStrategy(@PluginAttr(""String_Node_Str"") String max,@PluginAttr(""String_Node_Str"") String min){
  int minIndex;
  if (min != null) {
    minIndex=Integer.parseInt(min);
    if (minIndex < 1) {
      logger.error(""String_Node_Str"" + MIN_WINDOW_SIZE);
      minIndex=MIN_WINDOW_SIZE;
    }
  }
 else {
    minIndex=MIN_WINDOW_SIZE;
  }
  int maxIndex;
  if (max != null) {
    maxIndex=Integer.parseInt(max);
    if (maxIndex < minIndex) {
      maxIndex=minIndex < DEFAULT_WINDOW_SIZE ? DEFAULT_WINDOW_SIZE : minIndex;
      logger.error(""String_Node_Str"" + maxIndex);
    }
  }
 else {
    maxIndex=DEFAULT_WINDOW_SIZE;
  }
  return new DefaultRolloverStrategy(minIndex,maxIndex);
}","/** 
 * Create the DefaultRolloverStrategy.
 * @param max The maximum number of files to keep.
 * @param min The minimum number of files to keep.
 * @return A DefaultRolloverStrategy.
 */
@PluginFactory public static DefaultRolloverStrategy createStrategy(@PluginAttr(""String_Node_Str"") String max,@PluginAttr(""String_Node_Str"") String min){
  int minIndex;
  if (min != null) {
    minIndex=Integer.parseInt(min);
    if (minIndex < 1) {
      LOGGER.error(""String_Node_Str"" + MIN_WINDOW_SIZE);
      minIndex=MIN_WINDOW_SIZE;
    }
  }
 else {
    minIndex=MIN_WINDOW_SIZE;
  }
  int maxIndex;
  if (max != null) {
    maxIndex=Integer.parseInt(max);
    if (maxIndex < minIndex) {
      maxIndex=minIndex < DEFAULT_WINDOW_SIZE ? DEFAULT_WINDOW_SIZE : minIndex;
      LOGGER.error(""String_Node_Str"" + maxIndex);
    }
  }
 else {
    maxIndex=DEFAULT_WINDOW_SIZE;
  }
  return new DefaultRolloverStrategy(minIndex,maxIndex);
}"
90886,"public RolloverDescription rollover(RollingFileManager manager) throws SecurityException {
  if (maxIndex >= 0) {
    int purgeStart=minIndex;
    if (!purge(purgeStart,maxIndex,manager)) {
      return null;
    }
    StringBuilder buf=new StringBuilder();
    manager.getProcessor().formatFileName(purgeStart,buf);
    String currentFileName=manager.getFileName();
    String renameTo=buf.toString();
    String compressedName=renameTo;
    Action compressAction=null;
    if (renameTo.endsWith(""String_Node_Str"")) {
      renameTo=renameTo.substring(0,renameTo.length() - 3);
      compressAction=new GZCompressAction(new File(renameTo),new File(compressedName),true);
    }
 else     if (renameTo.endsWith(""String_Node_Str"")) {
      renameTo=renameTo.substring(0,renameTo.length() - 4);
      compressAction=new ZipCompressAction(new File(renameTo),new File(compressedName),true);
    }
    FileRenameAction renameAction=new FileRenameAction(new File(currentFileName),new File(renameTo),false);
    return new RolloverDescriptionImpl(currentFileName,false,renameAction,compressAction);
  }
  return null;
}","/** 
 * Perform the rollover.
 * @param manager The RollingFileManager name for current active log file.
 * @return A RolloverDescription.
 * @throws SecurityException if an error occurs.
 */
public RolloverDescription rollover(RollingFileManager manager) throws SecurityException {
  if (maxIndex >= 0) {
    int purgeStart=minIndex;
    if (!purge(purgeStart,maxIndex,manager)) {
      return null;
    }
    StringBuilder buf=new StringBuilder();
    manager.getProcessor().formatFileName(purgeStart,buf);
    String currentFileName=manager.getFileName();
    String renameTo=buf.toString();
    String compressedName=renameTo;
    Action compressAction=null;
    if (renameTo.endsWith(""String_Node_Str"")) {
      renameTo=renameTo.substring(0,renameTo.length() - 3);
      compressAction=new GZCompressAction(new File(renameTo),new File(compressedName),true);
    }
 else     if (renameTo.endsWith(""String_Node_Str"")) {
      renameTo=renameTo.substring(0,renameTo.length() - 4);
      compressAction=new ZipCompressAction(new File(renameTo),new File(compressedName),true);
    }
    FileRenameAction renameAction=new FileRenameAction(new File(currentFileName),new File(renameTo),false);
    return new RolloverDescriptionImpl(currentFileName,false,renameAction,compressAction);
  }
  return null;
}"
90887,"/** 
 * Purge and rename old log files in preparation for rollover
 * @param lowIndex  low index
 * @param highIndex high index.  Log file associated with high index will be deleted if needed.
 * @param manager The RollingFileManager
 * @return true if purge was successful and rollover should be attempted.
 */
private boolean purge(final int lowIndex,final int highIndex,RollingFileManager manager){
  int suffixLength=0;
  List<FileRenameAction> renames=new ArrayList<FileRenameAction>();
  StringBuilder buf=new StringBuilder();
  manager.getProcessor().formatFileName(lowIndex,buf);
  String lowFilename=buf.toString();
  if (lowFilename.endsWith(""String_Node_Str"")) {
    suffixLength=3;
  }
 else   if (lowFilename.endsWith(""String_Node_Str"")) {
    suffixLength=4;
  }
  for (int i=lowIndex; i <= highIndex; i++) {
    File toRename=new File(lowFilename);
    boolean isBase=false;
    if (suffixLength > 0) {
      File toRenameBase=new File(lowFilename.substring(0,lowFilename.length() - suffixLength));
      if (toRename.exists()) {
        if (toRenameBase.exists()) {
          toRenameBase.delete();
        }
      }
 else {
        toRename=toRenameBase;
        isBase=true;
      }
    }
    if (toRename.exists()) {
      if (i == highIndex) {
        if (!toRename.delete()) {
          return false;
        }
        break;
      }
      buf.setLength(0);
      manager.getProcessor().formatFileName(i + 1,buf);
      String highFilename=buf.toString();
      String renameTo=highFilename;
      if (isBase) {
        renameTo=highFilename.substring(0,highFilename.length() - suffixLength);
      }
      renames.add(new FileRenameAction(toRename,new File(renameTo),true));
      lowFilename=highFilename;
    }
 else {
      break;
    }
  }
  for (int i=renames.size() - 1; i >= 0; i--) {
    Action action=renames.get(i);
    try {
      if (!action.execute()) {
        return false;
      }
    }
 catch (    Exception ex) {
      logger.warn(""String_Node_Str"",ex);
      return false;
    }
  }
  return true;
}","/** 
 * Purge and rename old log files in preparation for rollover
 * @param lowIndex  low index
 * @param highIndex high index.  Log file associated with high index will be deleted if needed.
 * @param manager The RollingFileManager
 * @return true if purge was successful and rollover should be attempted.
 */
private boolean purge(final int lowIndex,final int highIndex,RollingFileManager manager){
  int suffixLength=0;
  List<FileRenameAction> renames=new ArrayList<FileRenameAction>();
  StringBuilder buf=new StringBuilder();
  manager.getProcessor().formatFileName(lowIndex,buf);
  String lowFilename=buf.toString();
  if (lowFilename.endsWith(""String_Node_Str"")) {
    suffixLength=3;
  }
 else   if (lowFilename.endsWith(""String_Node_Str"")) {
    suffixLength=4;
  }
  for (int i=lowIndex; i <= highIndex; i++) {
    File toRename=new File(lowFilename);
    boolean isBase=false;
    if (suffixLength > 0) {
      File toRenameBase=new File(lowFilename.substring(0,lowFilename.length() - suffixLength));
      if (toRename.exists()) {
        if (toRenameBase.exists()) {
          toRenameBase.delete();
        }
      }
 else {
        toRename=toRenameBase;
        isBase=true;
      }
    }
    if (toRename.exists()) {
      if (i == highIndex) {
        if (!toRename.delete()) {
          return false;
        }
        break;
      }
      buf.setLength(0);
      manager.getProcessor().formatFileName(i + 1,buf);
      String highFilename=buf.toString();
      String renameTo=highFilename;
      if (isBase) {
        renameTo=highFilename.substring(0,highFilename.length() - suffixLength);
      }
      renames.add(new FileRenameAction(toRename,new File(renameTo),true));
      lowFilename=highFilename;
    }
 else {
      break;
    }
  }
  for (int i=renames.size() - 1; i >= 0; i--) {
    Action action=renames.get(i);
    try {
      if (!action.execute()) {
        return false;
      }
    }
 catch (    Exception ex) {
      LOGGER.warn(""String_Node_Str"",ex);
      return false;
    }
  }
  return true;
}"
90888,"public String toString(){
  return ""String_Node_Str"" + minIndex + ""String_Node_Str""+ maxIndex+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + minIndex + ""String_Node_Str""+ maxIndex+ ""String_Node_Str"";
}"
90889,"/** 
 * The handler must be set before the appender is started.
 */
public void setHandler(ErrorHandler handler){
  if (handler == null) {
    logger.error(""String_Node_Str"");
  }
  if (isStarted()) {
    logger.error(""String_Node_Str"");
    return;
  }
  this.handler=handler;
}","/** 
 * The handler must be set before the appender is started.
 * @param handler The ErrorHandler to use.
 */
public void setHandler(ErrorHandler handler){
  if (handler == null) {
    LOGGER.error(""String_Node_Str"");
  }
  if (isStarted()) {
    LOGGER.error(""String_Node_Str"");
    return;
  }
  this.handler=handler;
}"
90890,"public AppenderBase(String name,Filter filter,Layout layout,boolean handleException){
  super(filter);
  this.name=name;
  this.layout=layout;
  this.handleException=handleException;
}","/** 
 * Constructor.
 * @param name The Appender name.
 * @param filter The Filter to associate with the Appender.
 * @param layout The layout to use to format the event.
 * @param handleException If true, exceptions will be logged and suppressed. If false errors will belogged and then passed to the application.
 */
protected AppenderBase(String name,Filter filter,Layout layout,boolean handleException){
  super(filter);
  this.name=name;
  this.layout=layout;
  this.handleException=handleException;
}"
90891,"public Layout getLayout(){
  return layout;
}","/** 
 * Returns the Layout for the appender.
 * @return The Layout used to format the event.
 */
public Layout getLayout(){
  return layout;
}"
90892,"public String getName(){
  return name;
}","/** 
 * Returns the name of the Appender.
 * @return The name of the Appender.
 */
public String getName(){
  return name;
}"
90893,"public void stop(){
  this.started=false;
  stopFilter();
}","/** 
 * Stop the Appender.
 */
public void stop(){
  this.started=false;
  stopFilter();
}"
90894,"public void start(){
  startFilter();
  this.started=true;
}","/** 
 * Start the Appender.
 */
public void start(){
  startFilter();
  this.started=true;
}"
90895,"public String toString(){
  return name;
}","@Override public String toString(){
  return name;
}"
90896,"public boolean isStarted(){
  return started;
}","/** 
 * Returns true if the Appender is started, false otherwise.
 * @return true if the Appender is started, false otherwise.
 */
public boolean isStarted(){
  return started;
}"
90897,"public ErrorHandler getHandler(){
  return handler;
}","/** 
 * Return the ErrorHandler, if any.
 * @return The ErrorHandler.
 */
public ErrorHandler getHandler(){
  return handler;
}"
90898,"public void close(){
}","/** 
 * Close the stream associated with the Appender.
 */
public void close(){
}"
90899,"/** 
 * Some appenders need to propogate exceptions back to the application. When suppressException is false the AppenderControl will allow the exception to percolate.
 */
public boolean isExceptionSuppressed(){
  return handleException;
}","/** 
 * Some appenders need to propogate exceptions back to the application. When suppressException is false the AppenderControl will allow the exception to percolate.
 * @return true if exceptions will be supressed, false otherwise.
 */
public boolean isExceptionSuppressed(){
  return handleException;
}"
90900,"/** 
 * Standard error output 
 */
private ConsoleAppender(String name,Layout layout,Filter filter,OutputStreamManager manager,boolean handleExceptions){
  super(name,layout,filter,handleExceptions,true,manager);
}","/** 
 * Standard error output. 
 */
private ConsoleAppender(String name,Layout layout,Filter filter,OutputStreamManager manager,boolean handleExceptions){
  super(name,layout,filter,handleExceptions,true,manager);
}"
90901,"public OutputStreamManager createManager(String name,FactoryData data){
  return new OutputStreamManager(data.os,data.type);
}","/** 
 * Create an OutputStreamManager.
 * @param name The name of the entity to manage.
 * @param data The data required to create the entity.
 * @return The OutputStreamManager
 */
public OutputStreamManager createManager(String name,FactoryData data){
  return new OutputStreamManager(data.os,data.type);
}"
90902,"public FactoryData(OutputStream os,String type){
  this.os=os;
  this.type=type;
}","/** 
 * Constructor.
 * @param os The OutputStream.
 * @param type The name of the target.
 */
public FactoryData(OutputStream os,String type){
  this.os=os;
  this.type=type;
}"
90903,"/** 
 * Create a Console Appender.
 * @param layout The layout to use (required).
 * @param filter The Filter or null.
 * @param t The target (""SYSTEM_OUT"" or ""SYSTEM_ERR""). The default is ""SYSTEM_OUT"".
 * @param name The name of the Appender (required).
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @return The ConsoleAppender.
 */
@PluginFactory public static ConsoleAppender createAppender(@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") Filter filter,@PluginAttr(""String_Node_Str"") String t,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String suppress){
  if (name == null) {
    logger.error(""String_Node_Str"");
    return null;
  }
  if (layout == null) {
    layout=PatternLayout.createLayout(null,null,null,null);
  }
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  Target target=t == null ? Target.SYSTEM_OUT : Target.valueOf(t);
  return new ConsoleAppender(name,layout,filter,getManager(target),handleExceptions);
}","/** 
 * Create a Console Appender.
 * @param layout The layout to use (required).
 * @param filter The Filter or null.
 * @param t The target (""SYSTEM_OUT"" or ""SYSTEM_ERR""). The default is ""SYSTEM_OUT"".
 * @param name The name of the Appender (required).
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @return The ConsoleAppender.
 */
@PluginFactory public static ConsoleAppender createAppender(@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") Filter filter,@PluginAttr(""String_Node_Str"") String t,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String suppress){
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (layout == null) {
    layout=PatternLayout.createLayout(null,null,null,null);
  }
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  Target target=t == null ? Target.SYSTEM_OUT : Target.valueOf(t);
  return new ConsoleAppender(name,layout,filter,getManager(target),handleExceptions);
}"
90904,"/** 
 * Handle an error with a message, and exception and a logging event.
 * @param msg The message.
 * @param event The LogEvent.
 * @param t The Throwable.
 */
public void error(String msg,LogEvent event,Throwable t){
  long current=System.currentTimeMillis();
  if (lastException + EXCEPTION_INTERVAL < current || exceptionCount++ < MAX_EXCEPTIONS) {
    logger.error(msg,t);
  }
  lastException=current;
  if (!appender.isExceptionSuppressed() && t != null) {
    throw new AppenderRuntimeException(msg,t);
  }
}","/** 
 * Handle an error with a message, and exception and a logging event.
 * @param msg The message.
 * @param event The LogEvent.
 * @param t The Throwable.
 */
public void error(String msg,LogEvent event,Throwable t){
  long current=System.currentTimeMillis();
  if (lastException + EXCEPTION_INTERVAL < current || exceptionCount++ < MAX_EXCEPTIONS) {
    LOGGER.error(msg,t);
  }
  lastException=current;
  if (!appender.isExceptionSuppressed() && t != null) {
    throw new AppenderRuntimeException(msg,t);
  }
}"
90905,"@Override public void start(){
  Map<String,Appender> map=config.getAppenders();
  int errors=0;
  if (map.containsKey(primaryRef)) {
    primary=new AppenderControl(map.get(primaryRef));
  }
 else {
    logger.error(""String_Node_Str"" + primaryRef);
    ++errors;
  }
  for (  String name : failovers) {
    if (map.containsKey(name)) {
      failoverAppenders.add(new AppenderControl(map.get(name)));
    }
 else {
      logger.error(""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  if (failoverAppenders.size() == 0) {
    logger.error(""String_Node_Str"");
    ++errors;
  }
  if (errors == 0) {
    super.start();
  }
}","@Override public void start(){
  Map<String,Appender> map=config.getAppenders();
  int errors=0;
  if (map.containsKey(primaryRef)) {
    primary=new AppenderControl(map.get(primaryRef));
  }
 else {
    LOGGER.error(""String_Node_Str"" + primaryRef);
    ++errors;
  }
  for (  String name : failovers) {
    if (map.containsKey(name)) {
      failoverAppenders.add(new AppenderControl(map.get(name)));
    }
 else {
      LOGGER.error(""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  if (failoverAppenders.size() == 0) {
    LOGGER.error(""String_Node_Str"");
    ++errors;
  }
  if (errors == 0) {
    super.start();
  }
}"
90906,"/** 
 * Create a Failover Appender
 * @param name The name of the Appender (required).
 * @param primary The name of the primary Appender (required).
 * @param failovers The name of one or more Appenders to fail over to (at least one is required).
 * @param config The current Configuration (passed by the Configuration when the appender is created).
 * @param filter A Filter (optional).
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @return The FailoverAppender that was created.
 */
@PluginFactory public static FailoverAppender createAppender(@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String primary,@PluginElement(""String_Node_Str"") String[] failovers,@PluginConfiguration Configuration config,@PluginElement(""String_Node_Str"") Filter filter,@PluginAttr(""String_Node_Str"") String suppress){
  if (name == null) {
    logger.error(""String_Node_Str"");
    return null;
  }
  if (primary == null) {
    logger.error(""String_Node_Str"");
    return null;
  }
  if (failovers == null || failovers.length == 0) {
    logger.error(""String_Node_Str"");
    return null;
  }
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  return new FailoverAppender(name,filter,primary,failovers,config,handleExceptions);
}","/** 
 * Create a Failover Appender.
 * @param name The name of the Appender (required).
 * @param primary The name of the primary Appender (required).
 * @param failovers The name of one or more Appenders to fail over to (at least one is required).
 * @param config The current Configuration (passed by the Configuration when the appender is created).
 * @param filter A Filter (optional).
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @return The FailoverAppender that was created.
 */
@PluginFactory public static FailoverAppender createAppender(@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String primary,@PluginElement(""String_Node_Str"") String[] failovers,@PluginConfiguration Configuration config,@PluginElement(""String_Node_Str"") Filter filter,@PluginAttr(""String_Node_Str"") String suppress){
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (primary == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (failovers == null || failovers.length == 0) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  return new FailoverAppender(name,filter,primary,failovers,config,handleExceptions);
}"
90907,"private Object createPluginObject(PluginType type,Node node,LogEvent event){
  Class clazz=type.getPluginClass();
  if (Map.class.isAssignableFrom(clazz)) {
    try {
      Map<String,Object> map=(Map<String,Object>)clazz.newInstance();
      for (      Node child : node.getChildren()) {
        map.put(child.getName(),child.getObject());
      }
      return map;
    }
 catch (    Exception ex) {
      LOGGER.warn(""String_Node_Str"" + type.getElementName() + ""String_Node_Str""+ clazz);
    }
  }
  if (List.class.isAssignableFrom(clazz)) {
    try {
      List<Object> list=(List<Object>)clazz.newInstance();
      for (      Node child : node.getChildren()) {
        list.add(child.getObject());
      }
      return list;
    }
 catch (    Exception ex) {
      LOGGER.warn(""String_Node_Str"" + type.getElementName() + ""String_Node_Str""+ clazz);
    }
  }
  Method factoryMethod=null;
  for (  Method method : clazz.getMethods()) {
    if (method.isAnnotationPresent(PluginFactory.class)) {
      factoryMethod=method;
      break;
    }
  }
  if (factoryMethod == null) {
    return null;
  }
  Annotation[][] parmArray=factoryMethod.getParameterAnnotations();
  Class[] parmClasses=factoryMethod.getParameterTypes();
  if (parmArray.length != parmClasses.length) {
    LOGGER.error(""String_Node_Str"");
  }
  Object[] parms=new Object[parmClasses.length];
  int index=0;
  Map<String,String> attrs=node.getAttributes();
  List<Node> children=node.getChildren();
  StringBuilder sb=new StringBuilder();
  List<Node> used=new ArrayList<Node>();
  for (  Annotation[] parmTypes : parmArray) {
    for (    Annotation a : parmTypes) {
      if (sb.length() == 0) {
        sb.append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"");
      }
      if (a instanceof PluginNode) {
        parms[index]=node;
        sb.append(""String_Node_Str"").append(node.getName());
      }
 else       if (a instanceof PluginConfiguration) {
        parms[index]=this;
        if (this.name != null) {
          sb.append(""String_Node_Str"").append(name).append(""String_Node_Str"");
        }
 else {
          sb.append(""String_Node_Str"");
        }
      }
 else       if (a instanceof PluginValue) {
        String name=((PluginValue)a).value();
        String v=node.getValue();
        if (v == null) {
          v=getAttrValue(""String_Node_Str"",attrs);
        }
        String value=subst.replace(event,v);
        sb.append(name + ""String_Node_Str"" + ""String_Node_Str""+ value+ ""String_Node_Str"");
        parms[index]=value;
      }
 else       if (a instanceof PluginAttr) {
        String name=((PluginAttr)a).value();
        String value=subst.replace(event,getAttrValue(name,attrs));
        sb.append(name + ""String_Node_Str"" + ""String_Node_Str""+ value+ ""String_Node_Str"");
        parms[index]=value;
      }
 else       if (a instanceof PluginElement) {
        PluginElement elem=(PluginElement)a;
        String name=elem.value();
        if (parmClasses[index].isArray()) {
          Class parmClass=parmClasses[index].getComponentType();
          List<Object> list=new ArrayList<Object>();
          sb.append(name).append(""String_Node_Str"");
          boolean first=true;
          for (          Node child : children) {
            PluginType childType=child.getType();
            if (elem.value().equalsIgnoreCase(childType.getElementName()) || parmClass.isAssignableFrom(childType.getPluginClass())) {
              used.add(child);
              if (!first) {
                sb.append(""String_Node_Str"");
              }
              first=false;
              Object obj=child.getObject();
              if (obj == null) {
                System.out.println(""String_Node_Str"" + child.getName());
              }
              if (obj.getClass().isArray()) {
                printArray(sb,(Object[])obj);
                parms[index]=obj;
                break;
              }
              sb.append(child.toString());
              list.add(obj);
            }
          }
          sb.append(""String_Node_Str"");
          if (parms[index] != null) {
            break;
          }
          Object[] array=(Object[])Array.newInstance(parmClass,list.size());
          int i=0;
          for (          Object obj : list) {
            array[i]=obj;
            ++i;
          }
          parms[index]=array;
        }
 else {
          Class parmClass=parmClasses[index];
          boolean present=false;
          for (          Node child : children) {
            PluginType childType=child.getType();
            if (elem.value().equals(childType.getElementName()) || parmClass.isAssignableFrom(childType.getPluginClass())) {
              sb.append(child.getName()).append(""String_Node_Str"").append(child.toString()).append(""String_Node_Str"");
              present=true;
              used.add(child);
              parms[index]=child.getObject();
              break;
            }
          }
          if (!present) {
            sb.append(""String_Node_Str"");
          }
        }
      }
    }
    ++index;
  }
  if (sb.length() > 0) {
    sb.append(""String_Node_Str"");
  }
  if (attrs.size() > 0) {
    StringBuilder eb=new StringBuilder();
    for (    String key : attrs.keySet()) {
      if (eb.length() == 0) {
        eb.append(node.getName());
        eb.append(""String_Node_Str"");
        if (attrs.size() == 1) {
          eb.append(""String_Node_Str"");
        }
 else {
          eb.append(""String_Node_Str"");
        }
      }
 else {
        eb.append(""String_Node_Str"");
      }
      eb.append(""String_Node_Str"");
      eb.append(key);
      eb.append(""String_Node_Str"");
    }
    LOGGER.error(eb.toString());
  }
  if (!type.isDeferChildren() && used.size() != children.size()) {
    for (    Node child : children) {
      if (used.contains(child)) {
        continue;
      }
      String nodeType=node.getType().getElementName();
      String start=nodeType.equals(node.getName()) ? node.getName() : nodeType + ""String_Node_Str"" + node.getName();
      LOGGER.error(start + ""String_Node_Str"" + child.getName());
    }
  }
  try {
    int mod=factoryMethod.getModifiers();
    if (!Modifier.isStatic(mod)) {
      LOGGER.error(factoryMethod.getName() + ""String_Node_Str"" + clazz.getName()+ ""String_Node_Str""+ node.getName());
      return null;
    }
    LOGGER.debug(""String_Node_Str"" + factoryMethod.getName() + ""String_Node_Str""+ clazz.getName()+ ""String_Node_Str""+ node.getName()+ sb.toString());
    return factoryMethod.invoke(null,parms);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + factoryMethod.getName() + ""String_Node_Str""+ clazz.getName()+ ""String_Node_Str""+ node.getName(),e);
  }
  return null;
}","private Object createPluginObject(PluginType type,Node node,LogEvent event){
  Class clazz=type.getPluginClass();
  if (Map.class.isAssignableFrom(clazz)) {
    try {
      Map<String,Object> map=(Map<String,Object>)clazz.newInstance();
      for (      Node child : node.getChildren()) {
        map.put(child.getName(),child.getObject());
      }
      return map;
    }
 catch (    Exception ex) {
      LOGGER.warn(""String_Node_Str"" + type.getElementName() + ""String_Node_Str""+ clazz);
    }
  }
  if (List.class.isAssignableFrom(clazz)) {
    try {
      List<Object> list=(List<Object>)clazz.newInstance();
      for (      Node child : node.getChildren()) {
        list.add(child.getObject());
      }
      return list;
    }
 catch (    Exception ex) {
      LOGGER.warn(""String_Node_Str"" + type.getElementName() + ""String_Node_Str""+ clazz);
    }
  }
  Method factoryMethod=null;
  for (  Method method : clazz.getMethods()) {
    if (method.isAnnotationPresent(PluginFactory.class)) {
      factoryMethod=method;
      break;
    }
  }
  if (factoryMethod == null) {
    return null;
  }
  Annotation[][] parmArray=factoryMethod.getParameterAnnotations();
  Class[] parmClasses=factoryMethod.getParameterTypes();
  if (parmArray.length != parmClasses.length) {
    LOGGER.error(""String_Node_Str"");
  }
  Object[] parms=new Object[parmClasses.length];
  int index=0;
  Map<String,String> attrs=node.getAttributes();
  List<Node> children=node.getChildren();
  StringBuilder sb=new StringBuilder();
  List<Node> used=new ArrayList<Node>();
  for (  Annotation[] parmTypes : parmArray) {
    for (    Annotation a : parmTypes) {
      if (sb.length() == 0) {
        sb.append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"");
      }
      if (a instanceof PluginNode) {
        parms[index]=node;
        sb.append(""String_Node_Str"").append(node.getName());
      }
 else       if (a instanceof PluginConfiguration) {
        parms[index]=this;
        if (this.name != null) {
          sb.append(""String_Node_Str"").append(name).append(""String_Node_Str"");
        }
 else {
          sb.append(""String_Node_Str"");
        }
      }
 else       if (a instanceof PluginValue) {
        String name=((PluginValue)a).value();
        String v=node.getValue();
        if (v == null) {
          v=getAttrValue(""String_Node_Str"",attrs);
        }
        String value=subst.replace(event,v);
        sb.append(name).append(""String_Node_Str"").append(value).append(""String_Node_Str"");
        parms[index]=value;
      }
 else       if (a instanceof PluginAttr) {
        String name=((PluginAttr)a).value();
        String value=subst.replace(event,getAttrValue(name,attrs));
        sb.append(name).append(""String_Node_Str"").append(value).append(""String_Node_Str"");
        parms[index]=value;
      }
 else       if (a instanceof PluginElement) {
        PluginElement elem=(PluginElement)a;
        String name=elem.value();
        if (parmClasses[index].isArray()) {
          Class parmClass=parmClasses[index].getComponentType();
          List<Object> list=new ArrayList<Object>();
          sb.append(name).append(""String_Node_Str"");
          boolean first=true;
          for (          Node child : children) {
            PluginType childType=child.getType();
            if (elem.value().equalsIgnoreCase(childType.getElementName()) || parmClass.isAssignableFrom(childType.getPluginClass())) {
              used.add(child);
              if (!first) {
                sb.append(""String_Node_Str"");
              }
              first=false;
              Object obj=child.getObject();
              if (obj == null) {
                System.out.println(""String_Node_Str"" + child.getName());
              }
              if (obj.getClass().isArray()) {
                printArray(sb,(Object[])obj);
                parms[index]=obj;
                break;
              }
              sb.append(child.toString());
              list.add(obj);
            }
          }
          sb.append(""String_Node_Str"");
          if (parms[index] != null) {
            break;
          }
          Object[] array=(Object[])Array.newInstance(parmClass,list.size());
          int i=0;
          for (          Object obj : list) {
            array[i]=obj;
            ++i;
          }
          parms[index]=array;
        }
 else {
          Class parmClass=parmClasses[index];
          boolean present=false;
          for (          Node child : children) {
            PluginType childType=child.getType();
            if (elem.value().equals(childType.getElementName()) || parmClass.isAssignableFrom(childType.getPluginClass())) {
              sb.append(child.getName()).append(""String_Node_Str"").append(child.toString()).append(""String_Node_Str"");
              present=true;
              used.add(child);
              parms[index]=child.getObject();
              break;
            }
          }
          if (!present) {
            sb.append(""String_Node_Str"");
          }
        }
      }
    }
    ++index;
  }
  if (sb.length() > 0) {
    sb.append(""String_Node_Str"");
  }
  if (attrs.size() > 0) {
    StringBuilder eb=new StringBuilder();
    for (    String key : attrs.keySet()) {
      if (eb.length() == 0) {
        eb.append(node.getName());
        eb.append(""String_Node_Str"");
        if (attrs.size() == 1) {
          eb.append(""String_Node_Str"");
        }
 else {
          eb.append(""String_Node_Str"");
        }
      }
 else {
        eb.append(""String_Node_Str"");
      }
      eb.append(""String_Node_Str"");
      eb.append(key);
      eb.append(""String_Node_Str"");
    }
    LOGGER.error(eb.toString());
  }
  if (!type.isDeferChildren() && used.size() != children.size()) {
    for (    Node child : children) {
      if (used.contains(child)) {
        continue;
      }
      String nodeType=node.getType().getElementName();
      String start=nodeType.equals(node.getName()) ? node.getName() : nodeType + ""String_Node_Str"" + node.getName();
      LOGGER.error(start + ""String_Node_Str"" + child.getName());
    }
  }
  try {
    int mod=factoryMethod.getModifiers();
    if (!Modifier.isStatic(mod)) {
      LOGGER.error(factoryMethod.getName() + ""String_Node_Str"" + clazz.getName()+ ""String_Node_Str""+ node.getName());
      return null;
    }
    LOGGER.debug(""String_Node_Str"",factoryMethod.getName(),clazz.getName(),node.getName(),sb.toString());
    return factoryMethod.invoke(null,parms);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"" + factoryMethod.getName() + ""String_Node_Str""+ clazz.getName()+ ""String_Node_Str""+ node.getName(),e);
  }
  return null;
}"
90908,"/** 
 * Constructor.
 * @param file The File to monitor.
 * @param listeners The List of ConfigurationListeners to notify upon a change.
 * @param interval The monitor interval in seconds. The minimum interval is 30 seconds.
 */
public FileConfigurationMonitor(File file,List<ConfigurationListener> listeners,int interval){
  this.file=file;
  this.lastModified=file.lastModified();
  this.listeners=listeners;
  this.interval=(interval < MIN_INTERVAL ? MIN_INTERVAL : interval) * 1000;
  this.nextCheck=System.currentTimeMillis() + interval;
}","/** 
 * Constructor.
 * @param file The File to monitor.
 * @param listeners The List of ConfigurationListeners to notify upon a change.
 * @param interval The monitor interval in seconds. The minimum interval is 30 seconds.
 */
public FileConfigurationMonitor(File file,List<ConfigurationListener> listeners,int interval){
  this.file=file;
  this.lastModified=file.lastModified();
  this.listeners=listeners;
  this.interval=(interval < MIN_INTERVAL ? MIN_INTERVAL : interval) * MILLIS_PER_SECOND;
  this.nextCheck=System.currentTimeMillis() + interval;
}"
90909,"protected byte[] toByteArray(InputStream is) throws IOException {
  ByteArrayOutputStream buffer=new ByteArrayOutputStream();
  int nRead;
  byte[] data=new byte[16384];
  while ((nRead=is.read(data,0,data.length)) != -1) {
    buffer.write(data,0,nRead);
  }
  return buffer.toByteArray();
}","protected byte[] toByteArray(InputStream is) throws IOException {
  ByteArrayOutputStream buffer=new ByteArrayOutputStream();
  int nRead;
  byte[] data=new byte[BUF_SIZE];
  while ((nRead=is.read(data,0,data.length)) != -1) {
    buffer.write(data,0,nRead);
  }
  return buffer.toByteArray();
}"
90910,"public JSONConfiguration(InputSource source,File configFile){
  byte[] buffer;
  try {
    buffer=toByteArray(source.getByteStream());
    InputStream is=new ByteArrayInputStream(buffer);
    source=new InputSource(is);
    ObjectMapper mapper=new ObjectMapper().configure(JsonParser.Feature.ALLOW_COMMENTS,true);
    root=mapper.readTree(is);
    if (root.size() == 1) {
      Iterator<JsonNode> i=root.getElements();
      root=i.next();
    }
    processAttributes(rootNode,root);
    Level status=Level.OFF;
    boolean verbose=false;
    for (    Map.Entry<String,String> entry : rootNode.getAttributes().entrySet()) {
      if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        status=Level.toLevel(entry.getValue().toUpperCase(),Level.OFF);
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        verbose=Boolean.parseBoolean(entry.getValue());
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        String[] packages=entry.getValue().split(""String_Node_Str"");
        for (        String p : packages) {
          PluginManager.addPackage(p);
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        setName(entry.getValue());
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        int interval=Integer.parseInt(entry.getValue());
        if (interval > 0 && configFile != null) {
          monitor=new FileConfigurationMonitor(configFile,listeners,interval);
        }
      }
    }
    Iterator<StatusListener> statusIter=((StatusLogger)LOGGER).getListeners();
    boolean found=false;
    while (statusIter.hasNext()) {
      StatusListener listener=statusIter.next();
      if (listener instanceof StatusConsoleListener) {
        found=true;
        ((StatusConsoleListener)listener).setLevel(status);
        if (!verbose) {
          ((StatusConsoleListener)listener).setFilters(verboseClasses);
        }
      }
    }
    if (!found && status != Level.OFF) {
      StatusConsoleListener listener=new StatusConsoleListener(status);
      if (!verbose) {
        listener.setFilters(verboseClasses);
      }
      ((StatusLogger)LOGGER).registerListener(listener);
    }
    if (getName() == null) {
      setName(source.getSystemId());
    }
  }
 catch (  Exception ex) {
    LOGGER.error(""String_Node_Str"" + source.getSystemId(),ex);
    ex.printStackTrace();
  }
}","public JSONConfiguration(InputSource source,File configFile){
  byte[] buffer;
  try {
    buffer=toByteArray(source.getByteStream());
    InputStream is=new ByteArrayInputStream(buffer);
    source=new InputSource(is);
    ObjectMapper mapper=new ObjectMapper().configure(JsonParser.Feature.ALLOW_COMMENTS,true);
    root=mapper.readTree(is);
    if (root.size() == 1) {
      Iterator<JsonNode> i=root.getElements();
      root=i.next();
    }
    processAttributes(rootNode,root);
    Level status=Level.OFF;
    boolean verbose=false;
    for (    Map.Entry<String,String> entry : rootNode.getAttributes().entrySet()) {
      if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        status=Level.toLevel(entry.getValue().toUpperCase(),Level.OFF);
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        verbose=Boolean.parseBoolean(entry.getValue());
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        String[] packages=entry.getValue().split(""String_Node_Str"");
        for (        String p : packages) {
          PluginManager.addPackage(p);
        }
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        setName(entry.getValue());
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(entry.getKey())) {
        int interval=Integer.parseInt(entry.getValue());
        if (interval > 0 && configFile != null) {
          monitor=new FileConfigurationMonitor(configFile,listeners,interval);
        }
      }
    }
    Iterator<StatusListener> statusIter=((StatusLogger)LOGGER).getListeners();
    boolean found=false;
    while (statusIter.hasNext()) {
      StatusListener listener=statusIter.next();
      if (listener instanceof StatusConsoleListener) {
        found=true;
        ((StatusConsoleListener)listener).setLevel(status);
        if (!verbose) {
          ((StatusConsoleListener)listener).setFilters(VERBOSE_CLASSES);
        }
      }
    }
    if (!found && status != Level.OFF) {
      StatusConsoleListener listener=new StatusConsoleListener(status);
      if (!verbose) {
        listener.setFilters(VERBOSE_CLASSES);
      }
      ((StatusLogger)LOGGER).registerListener(listener);
    }
    if (getName() == null) {
      setName(source.getSystemId());
    }
  }
 catch (  Exception ex) {
    LOGGER.error(""String_Node_Str"" + source.getSystemId(),ex);
    ex.printStackTrace();
  }
}"
90911,"/** 
 * Create a File Appender.
 * @param fileName The name and path of the file.
 * @param append ""True"" if the file should be appended to, ""false"" if it should be overwritten.The default is ""true"".
 * @param locking ""True"" if the file should be locked. The default is ""false"".
 * @param name The name of the Appender.
 * @param immediateFlush ""true"" if the contents should be flushed on every write, ""false"" otherwise. The defaultis ""true"".
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @param bufferedIO ""true"" if I/O should be buffered, ""false"" otherwise. The default is ""true"".
 * @param layout The layout to use to format the event. If no layout is provided the default PatternLayoutwill be used.
 * @param filter The filter, if any, to use.
 * @return The FileAppender.
 */
@PluginFactory public static FileAppender createAppender(@PluginAttr(""String_Node_Str"") String fileName,@PluginAttr(""String_Node_Str"") String append,@PluginAttr(""String_Node_Str"") String locking,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String immediateFlush,@PluginAttr(""String_Node_Str"") String suppress,@PluginAttr(""String_Node_Str"") String bufferedIO,@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") Filter filter){
  boolean isAppend=append == null ? true : Boolean.valueOf(append);
  boolean isLocking=locking == null ? false : Boolean.valueOf(locking);
  boolean isBuffered=bufferedIO == null ? true : Boolean.valueOf(bufferedIO);
  ;
  if (isLocking && isBuffered) {
    if (bufferedIO != null) {
      LOGGER.warn(""String_Node_Str"" + fileName);
    }
    isBuffered=false;
  }
  boolean isFlush=immediateFlush == null ? true : Boolean.valueOf(immediateFlush);
  ;
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (fileName == null) {
    LOGGER.error(""String_Node_Str"" + name);
    return null;
  }
  FileManager manager=FileManager.getFileManager(fileName,isAppend,isLocking,isBuffered);
  if (manager == null) {
    return null;
  }
  if (layout == null) {
    layout=PatternLayout.createLayout(null,null,null,null);
  }
  return new FileAppender(name,layout,filter,manager,fileName,handleExceptions,isFlush);
}","/** 
 * Create a File Appender.
 * @param fileName The name and path of the file.
 * @param append ""True"" if the file should be appended to, ""false"" if it should be overwritten.The default is ""true"".
 * @param locking ""True"" if the file should be locked. The default is ""false"".
 * @param name The name of the Appender.
 * @param immediateFlush ""true"" if the contents should be flushed on every write, ""false"" otherwise. The defaultis ""true"".
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @param bufferedIO ""true"" if I/O should be buffered, ""false"" otherwise. The default is ""true"".
 * @param layout The layout to use to format the event. If no layout is provided the default PatternLayoutwill be used.
 * @param filter The filter, if any, to use.
 * @return The FileAppender.
 */
@PluginFactory public static FileAppender createAppender(@PluginAttr(""String_Node_Str"") String fileName,@PluginAttr(""String_Node_Str"") String append,@PluginAttr(""String_Node_Str"") String locking,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String immediateFlush,@PluginAttr(""String_Node_Str"") String suppress,@PluginAttr(""String_Node_Str"") String bufferedIO,@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") Filter filter){
  boolean isAppend=append == null ? true : Boolean.valueOf(append);
  boolean isLocking=locking == null ? false : Boolean.valueOf(locking);
  boolean isBuffered=bufferedIO == null ? true : Boolean.valueOf(bufferedIO);
  if (isLocking && isBuffered) {
    if (bufferedIO != null) {
      LOGGER.warn(""String_Node_Str"" + fileName);
    }
    isBuffered=false;
  }
  boolean isFlush=immediateFlush == null ? true : Boolean.valueOf(immediateFlush);
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (fileName == null) {
    LOGGER.error(""String_Node_Str"" + name);
    return null;
  }
  FileManager manager=FileManager.getFileManager(fileName,isAppend,isLocking,isBuffered);
  if (manager == null) {
    return null;
  }
  if (layout == null) {
    layout=PatternLayout.createLayout(null,null,null,null);
  }
  return new FileAppender(name,layout,filter,manager,fileName,handleExceptions,isFlush);
}"
90912,"protected void close(){
  if (os == System.out || os == System.err) {
    return;
  }
  try {
    os.close();
  }
 catch (  IOException ex) {
    logger.error(""String_Node_Str"" + getName() + ""String_Node_Str""+ ex);
  }
}","protected void close(){
  if (os == System.out || os == System.err) {
    return;
  }
  try {
    os.close();
  }
 catch (  IOException ex) {
    LOGGER.error(""String_Node_Str"" + getName() + ""String_Node_Str""+ ex);
  }
}"
90913,"/** 
 * Set the header to write when the stream is opened.
 * @param header The header.
 */
public synchronized void setHeader(byte[] header){
  if (header != null) {
    try {
      this.os.write(header,0,header.length);
    }
 catch (    IOException ioe) {
      logger.error(""String_Node_Str"",ioe);
    }
  }
}","/** 
 * Set the header to write when the stream is opened.
 * @param header The header.
 */
public synchronized void setHeader(byte[] header){
  if (header != null) {
    try {
      this.os.write(header,0,header.length);
    }
 catch (    IOException ioe) {
      LOGGER.error(""String_Node_Str"",ioe);
    }
  }
}"
90914,"/** 
 * Create a RollingFileAppender.
 * @param fileName The name of the file that is actively written to. (required).
 * @param filePattern The pattern of the file name to use on rollover. (required).
 * @param append If true, events are appended to the file. If false, the fileis overwritten when opened. Defaults to ""true""
 * @param name The name of the Appender (required).
 * @param bufferedIO When true, I/O will be buffered. Defaults to ""true"".
 * @param immediateFlush When true, events are immediately flushed. Defaults to ""true"".
 * @param policy The triggering policy. (required).
 * @param strategy The rollover strategy. Defaults to DefaultRolloverStrategy.
 * @param layout The layout to use (defaults to the default PatternLayout).
 * @param filter The Filter or null.
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @return A RollingFileAppender.
 */
@PluginFactory public static RollingFileAppender createAppender(@PluginAttr(""String_Node_Str"") String fileName,@PluginAttr(""String_Node_Str"") String filePattern,@PluginAttr(""String_Node_Str"") String append,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String bufferedIO,@PluginAttr(""String_Node_Str"") String immediateFlush,@PluginElement(""String_Node_Str"") TriggeringPolicy policy,@PluginElement(""String_Node_Str"") RolloverStrategy strategy,@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") Filter filter,@PluginAttr(""String_Node_Str"") String suppress){
  boolean isAppend=append == null ? true : Boolean.valueOf(append);
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  boolean isBuffered=bufferedIO == null ? true : Boolean.valueOf(bufferedIO);
  ;
  boolean isFlush=immediateFlush == null ? true : Boolean.valueOf(immediateFlush);
  ;
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (fileName == null) {
    LOGGER.error(""String_Node_Str"" + name);
    return null;
  }
  if (filePattern == null) {
    LOGGER.error(""String_Node_Str"" + name);
    return null;
  }
  if (policy == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (strategy == null) {
    strategy=DefaultRolloverStrategy.createStrategy(null,null);
  }
  RollingFileManager manager=RollingFileManager.getFileManager(fileName,filePattern,isAppend,isBuffered);
  if (manager == null) {
    return null;
  }
  if (layout == null) {
    layout=PatternLayout.createLayout(null,null,null,null);
  }
  return new RollingFileAppender(name,layout,policy,strategy,filter,manager,fileName,filePattern,handleExceptions,isFlush);
}","/** 
 * Create a RollingFileAppender.
 * @param fileName The name of the file that is actively written to. (required).
 * @param filePattern The pattern of the file name to use on rollover. (required).
 * @param append If true, events are appended to the file. If false, the fileis overwritten when opened. Defaults to ""true""
 * @param name The name of the Appender (required).
 * @param bufferedIO When true, I/O will be buffered. Defaults to ""true"".
 * @param immediateFlush When true, events are immediately flushed. Defaults to ""true"".
 * @param policy The triggering policy. (required).
 * @param strategy The rollover strategy. Defaults to DefaultRolloverStrategy.
 * @param layout The layout to use (defaults to the default PatternLayout).
 * @param filter The Filter or null.
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @return A RollingFileAppender.
 */
@PluginFactory public static RollingFileAppender createAppender(@PluginAttr(""String_Node_Str"") String fileName,@PluginAttr(""String_Node_Str"") String filePattern,@PluginAttr(""String_Node_Str"") String append,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String bufferedIO,@PluginAttr(""String_Node_Str"") String immediateFlush,@PluginElement(""String_Node_Str"") TriggeringPolicy policy,@PluginElement(""String_Node_Str"") RolloverStrategy strategy,@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") Filter filter,@PluginAttr(""String_Node_Str"") String suppress){
  boolean isAppend=append == null ? true : Boolean.valueOf(append);
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  boolean isBuffered=bufferedIO == null ? true : Boolean.valueOf(bufferedIO);
  boolean isFlush=immediateFlush == null ? true : Boolean.valueOf(immediateFlush);
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (fileName == null) {
    LOGGER.error(""String_Node_Str"" + name);
    return null;
  }
  if (filePattern == null) {
    LOGGER.error(""String_Node_Str"" + name);
    return null;
  }
  if (policy == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  if (strategy == null) {
    strategy=DefaultRolloverStrategy.createStrategy(null,null);
  }
  RollingFileManager manager=RollingFileManager.getFileManager(fileName,filePattern,isAppend,isBuffered);
  if (manager == null) {
    return null;
  }
  if (layout == null) {
    layout=PatternLayout.createLayout(null,null,null,null);
  }
  return new RollingFileAppender(name,layout,policy,strategy,filter,manager,fileName,filePattern,handleExceptions,isFlush);
}"
90915,"/** 
 * @param host The name of the host to connect to.
 * @param portNum The port to connect to on the target host.
 * @param protocol The Protocol to use.
 * @param delay The interval in which failed writes should be retried.
 * @param name The name of the Appender.
 * @param immediateFlush ""true"" if data should be flushed on each write.
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @param layout The layout to use (defaults to SerlializedLayout).
 * @param filter The Filter or null.
 * @return A SocketAppender.
 */
@PluginFactory public static SocketAppender createAppender(@PluginAttr(""String_Node_Str"") String host,@PluginAttr(""String_Node_Str"") String portNum,@PluginAttr(""String_Node_Str"") String protocol,@PluginAttr(""String_Node_Str"") String delay,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String immediateFlush,@PluginAttr(""String_Node_Str"") String suppress,@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") Filter filter){
  boolean isFlush=immediateFlush == null ? true : Boolean.valueOf(immediateFlush);
  ;
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  int reconnectDelay=delay == null ? 0 : Integer.parseInt(delay);
  int port=portNum == null ? 0 : Integer.parseInt(portNum);
  if (layout == null) {
    layout=SerializedLayout.createLayout();
  }
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  AbstractSocketManager manager=createSocketManager(protocol,host,port,reconnectDelay);
  if (manager == null) {
    return null;
  }
  return new SocketAppender(name,layout,filter,manager,handleExceptions,isFlush);
}","/** 
 * @param host The name of the host to connect to.
 * @param portNum The port to connect to on the target host.
 * @param protocol The Protocol to use.
 * @param delay The interval in which failed writes should be retried.
 * @param name The name of the Appender.
 * @param immediateFlush ""true"" if data should be flushed on each write.
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @param layout The layout to use (defaults to SerlializedLayout).
 * @param filter The Filter or null.
 * @return A SocketAppender.
 */
@PluginFactory public static SocketAppender createAppender(@PluginAttr(""String_Node_Str"") String host,@PluginAttr(""String_Node_Str"") String portNum,@PluginAttr(""String_Node_Str"") String protocol,@PluginAttr(""String_Node_Str"") String delay,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String immediateFlush,@PluginAttr(""String_Node_Str"") String suppress,@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") Filter filter){
  boolean isFlush=immediateFlush == null ? true : Boolean.valueOf(immediateFlush);
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  int reconnectDelay=delay == null ? 0 : Integer.parseInt(delay);
  int port=portNum == null ? 0 : Integer.parseInt(portNum);
  if (layout == null) {
    layout=SerializedLayout.createLayout();
  }
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  AbstractSocketManager manager=createSocketManager(protocol,host,port,reconnectDelay);
  if (manager == null) {
    return null;
  }
  return new SocketAppender(name,layout,filter,manager,handleExceptions,isFlush);
}"
90916,"/** 
 * Create a SyslogAppender.
 * @param host The name of the host to connect to.
 * @param portNum The port to connect to on the target host.
 * @param protocol The Protocol to use.
 * @param delay The interval in which failed writes should be retried.
 * @param name The name of the Appender.
 * @param immediateFlush ""true"" if data should be flushed on each write.
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @param facility The Facility is used to try to classify the message.
 * @param id The default structured data id to use when formatting according to RFC 5424.
 * @param ein The IANA enterprise number.
 * @param includeMDC Indicates whether data from the ThreadContextMap will be included in the RFC 5424 Syslogrecord. Defaults to ""true:.
 * @param mdcId The id to use for the MDC Structured Data Element.
 * @param includeNL If true, a newline will be appended to the end of the syslog record. The default is false.
 * @param appName The value to use as the APP-NAME in the RFC 5424 syslog record.
 * @param msgId The default value to be used in the MSGID field of RFC 5424 syslog records.
 * @param excludes A comma separated list of mdc keys that should be excluded from the LogEvent.
 * @param includes A comma separated list of mdc keys that should be included in the FlumeEvent.
 * @param required A comma separated list of mdc keys that must be present in the MDC.
 * @param format If set to ""RFC5424"" the data will be formatted in accordance with RFC 5424. Otherwise,it will be formatted as a BSD Syslog record.
 * @param filter A Filter to determine if the event should be handled by this Appender.
 * @param config The Configuration.
 * @param charset The character set to use when converting the syslog String to a byte array.
 * @return A SyslogAppender.
 */
@PluginFactory public static SyslogAppender createAppender(@PluginAttr(""String_Node_Str"") String host,@PluginAttr(""String_Node_Str"") String portNum,@PluginAttr(""String_Node_Str"") String protocol,@PluginAttr(""String_Node_Str"") String delay,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String immediateFlush,@PluginAttr(""String_Node_Str"") String suppress,@PluginAttr(""String_Node_Str"") String facility,@PluginAttr(""String_Node_Str"") String id,@PluginAttr(""String_Node_Str"") String ein,@PluginAttr(""String_Node_Str"") String includeMDC,@PluginAttr(""String_Node_Str"") String mdcId,@PluginAttr(""String_Node_Str"") String includeNL,@PluginAttr(""String_Node_Str"") String appName,@PluginAttr(""String_Node_Str"") String msgId,@PluginAttr(""String_Node_Str"") String excludes,@PluginAttr(""String_Node_Str"") String includes,@PluginAttr(""String_Node_Str"") String required,@PluginAttr(""String_Node_Str"") String format,@PluginElement(""String_Node_Str"") Filter filter,@PluginConfiguration Configuration config,@PluginAttr(""String_Node_Str"") String charset){
  boolean isFlush=immediateFlush == null ? true : Boolean.valueOf(immediateFlush);
  ;
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  int reconnectDelay=delay == null ? 0 : Integer.parseInt(delay);
  int port=portNum == null ? 0 : Integer.parseInt(portNum);
  Charset c=Charset.isSupported(""String_Node_Str"") ? Charset.forName(""String_Node_Str"") : Charset.defaultCharset();
  if (charset != null) {
    if (Charset.isSupported(charset)) {
      c=Charset.forName(charset);
    }
 else {
      LOGGER.error(""String_Node_Str"" + charset + ""String_Node_Str""+ c.displayName());
    }
  }
  Layout layout=(format.equalsIgnoreCase(RFC5424)) ? RFC5424Layout.createLayout(facility,id,ein,includeMDC,mdcId,includeNL,appName,msgId,excludes,includes,required,charset,config) : SyslogLayout.createLayout(facility,includeNL,charset);
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  AbstractSocketManager manager=createSocketManager(protocol,host,port,reconnectDelay);
  if (manager == null) {
    return null;
  }
  return new SyslogAppender(name,layout,filter,handleExceptions,isFlush,manager);
}","/** 
 * Create a SyslogAppender.
 * @param host The name of the host to connect to.
 * @param portNum The port to connect to on the target host.
 * @param protocol The Protocol to use.
 * @param delay The interval in which failed writes should be retried.
 * @param name The name of the Appender.
 * @param immediateFlush ""true"" if data should be flushed on each write.
 * @param suppress ""true"" if exceptions should be hidden from the application, ""false"" otherwise.The default is ""true"".
 * @param facility The Facility is used to try to classify the message.
 * @param id The default structured data id to use when formatting according to RFC 5424.
 * @param ein The IANA enterprise number.
 * @param includeMDC Indicates whether data from the ThreadContextMap will be included in the RFC 5424 Syslogrecord. Defaults to ""true:.
 * @param mdcId The id to use for the MDC Structured Data Element.
 * @param includeNL If true, a newline will be appended to the end of the syslog record. The default is false.
 * @param appName The value to use as the APP-NAME in the RFC 5424 syslog record.
 * @param msgId The default value to be used in the MSGID field of RFC 5424 syslog records.
 * @param excludes A comma separated list of mdc keys that should be excluded from the LogEvent.
 * @param includes A comma separated list of mdc keys that should be included in the FlumeEvent.
 * @param required A comma separated list of mdc keys that must be present in the MDC.
 * @param format If set to ""RFC5424"" the data will be formatted in accordance with RFC 5424. Otherwise,it will be formatted as a BSD Syslog record.
 * @param filter A Filter to determine if the event should be handled by this Appender.
 * @param config The Configuration.
 * @param charset The character set to use when converting the syslog String to a byte array.
 * @return A SyslogAppender.
 */
@PluginFactory public static SyslogAppender createAppender(@PluginAttr(""String_Node_Str"") String host,@PluginAttr(""String_Node_Str"") String portNum,@PluginAttr(""String_Node_Str"") String protocol,@PluginAttr(""String_Node_Str"") String delay,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String immediateFlush,@PluginAttr(""String_Node_Str"") String suppress,@PluginAttr(""String_Node_Str"") String facility,@PluginAttr(""String_Node_Str"") String id,@PluginAttr(""String_Node_Str"") String ein,@PluginAttr(""String_Node_Str"") String includeMDC,@PluginAttr(""String_Node_Str"") String mdcId,@PluginAttr(""String_Node_Str"") String includeNL,@PluginAttr(""String_Node_Str"") String appName,@PluginAttr(""String_Node_Str"") String msgId,@PluginAttr(""String_Node_Str"") String excludes,@PluginAttr(""String_Node_Str"") String includes,@PluginAttr(""String_Node_Str"") String required,@PluginAttr(""String_Node_Str"") String format,@PluginElement(""String_Node_Str"") Filter filter,@PluginConfiguration Configuration config,@PluginAttr(""String_Node_Str"") String charset){
  boolean isFlush=immediateFlush == null ? true : Boolean.valueOf(immediateFlush);
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  int reconnectDelay=delay == null ? 0 : Integer.parseInt(delay);
  int port=portNum == null ? 0 : Integer.parseInt(portNum);
  Charset c=Charset.isSupported(""String_Node_Str"") ? Charset.forName(""String_Node_Str"") : Charset.defaultCharset();
  if (charset != null) {
    if (Charset.isSupported(charset)) {
      c=Charset.forName(charset);
    }
 else {
      LOGGER.error(""String_Node_Str"" + charset + ""String_Node_Str""+ c.displayName());
    }
  }
  Layout layout=(format.equalsIgnoreCase(RFC5424)) ? RFC5424Layout.createLayout(facility,id,ein,includeMDC,mdcId,includeNL,appName,msgId,excludes,includes,required,charset,config) : SyslogLayout.createLayout(facility,includeNL,charset);
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  AbstractSocketManager manager=createSocketManager(protocol,host,port,reconnectDelay);
  if (manager == null) {
    return null;
  }
  return new SyslogAppender(name,layout,filter,handleExceptions,isFlush,manager);
}"
90917,"public int getPort(){
  return port;
}","/** 
 * Retrieve the port number.
 * @return The port number.
 */
public int getPort(){
  return port;
}"
90918,"public String toString(){
  return ""String_Node_Str"" + host + ""String_Node_Str""+ port;
}","@Override public String toString(){
  return ""String_Node_Str"" + host + ""String_Node_Str""+ port;
}"
90919,"public String getHost(){
  return host;
}","/** 
 * Retrieve the host name.
 * @return The name of the host.
 */
public String getHost(){
  return host;
}"
90920,"@PluginFactory public static Agent createAgent(@PluginAttr(""String_Node_Str"") String host,@PluginAttr(""String_Node_Str"") String port){
  if (host == null) {
    host=DEFAULT_HOST;
  }
  int portNum;
  if (port != null) {
    try {
      portNum=Integer.parseInt(port);
    }
 catch (    Exception ex) {
      logger.error(""String_Node_Str"" + port,ex);
      return null;
    }
  }
 else {
    portNum=DEFAULT_PORT;
  }
  return new Agent(host,portNum);
}","/** 
 * Create an Agent.
 * @param host The host name.
 * @param port The port number.
 * @return The Agent.
 */
@PluginFactory public static Agent createAgent(@PluginAttr(""String_Node_Str"") String host,@PluginAttr(""String_Node_Str"") String port){
  if (host == null) {
    host=DEFAULT_HOST;
  }
  int portNum;
  if (port != null) {
    try {
      portNum=Integer.parseInt(port);
    }
 catch (    Exception ex) {
      LOGGER.error(""String_Node_Str"" + port,ex);
      return null;
    }
  }
 else {
    portNum=DEFAULT_PORT;
  }
  return new Agent(host,portNum);
}"
90921,"public FlumeEvent createEvent(LogEvent event,String hostname,String includes,String excludes,String required,String mdcPrefix,String eventPrefix,boolean compress){
  return new FlumeEvent(event,hostname,mdcIncludes,mdcExcludes,mdcRequired,mdcPrefix,eventPrefix,compressBody);
}","/** 
 * Create a Flume event.
 * @param event The Log4j LogEvent.
 * @param hostname The host name.
 * @param includes comma separated list of mdc elements to include.
 * @param excludes comma separated list of mdc elements to exclude.
 * @param required comma separated list of mdc elements that must be present with a value.
 * @param mdcPrefix The prefix to add to MDC key names.
 * @param eventPrefix The prefix to add to event fields.
 * @param compress If true the body will be compressed.
 * @return A Flume Event.
 */
public FlumeEvent createEvent(LogEvent event,String hostname,String includes,String excludes,String required,String mdcPrefix,String eventPrefix,boolean compress){
  return new FlumeEvent(event,hostname,mdcIncludes,mdcExcludes,mdcRequired,mdcPrefix,eventPrefix,compressBody);
}"
90922,"@PluginFactory public static FlumeAvroAppender createAppender(@PluginElement(""String_Node_Str"") Agent[] agents,@PluginAttr(""String_Node_Str"") String delay,@PluginAttr(""String_Node_Str"") String agentRetries,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String suppress,@PluginAttr(""String_Node_Str"") String excludes,@PluginAttr(""String_Node_Str"") String includes,@PluginAttr(""String_Node_Str"") String required,@PluginAttr(""String_Node_Str"") String mdcPrefix,@PluginAttr(""String_Node_Str"") String eventPrefix,@PluginAttr(""String_Node_Str"") String compressBody,@PluginElement(""String_Node_Str"") FlumeEventFactory factory,@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") Filter filter){
  String hostname;
  try {
    hostname=InetAddress.getLocalHost().getHostName();
  }
 catch (  Exception ex) {
    LOGGER.error(""String_Node_Str"",ex);
    return null;
  }
  if (agents == null || agents.length == 0) {
    LOGGER.debug(""String_Node_Str"");
    agents=new Agent[]{Agent.createAgent(null,null)};
  }
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  boolean compress=compressBody == null ? true : Boolean.valueOf(compressBody);
  int reconnectDelay=delay == null ? 0 : Integer.parseInt(delay);
  int retries=agentRetries == null ? 0 : Integer.parseInt(agentRetries);
  if (layout == null) {
    layout=RFC5424Layout.createLayout(null,null,null,null,""String_Node_Str"",null,null,null,null,excludes,includes,required,null);
  }
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  FlumeAvroManager manager=FlumeAvroManager.getManager(agents);
  if (manager == null) {
    return null;
  }
  return new FlumeAvroAppender(name,filter,layout,handleExceptions,hostname,includes,excludes,required,mdcPrefix,eventPrefix,compress,reconnectDelay,retries,factory,manager);
}","/** 
 * Create a Flume Avro Appender.
 * @param agents An array of Agents.
 * @param delay The amount of time in milliseconds to wait between retries.
 * @param agentRetries The number of times to retry an agent before failing to the next agent.
 * @param name The name of the Appender.
 * @param suppress If true exceptions will be handled in the appender.
 * @param excludes A comma separated list of MDC elements to exclude.
 * @param includes A comma separated list of MDC elements to include.
 * @param required A comma separated list of MDC elements that are required.
 * @param mdcPrefix The prefix to add to MDC key names.
 * @param eventPrefix The prefix to add to event key names.
 * @param compressBody If true the event body will be compressed.
 * @param factory The factory to use to create Flume events.
 * @param layout The layout to format the event.
 * @param filter A Filter to filter events.
 * @return A Flume Avro Appender.
 */
@PluginFactory public static FlumeAvroAppender createAppender(@PluginElement(""String_Node_Str"") Agent[] agents,@PluginAttr(""String_Node_Str"") String delay,@PluginAttr(""String_Node_Str"") String agentRetries,@PluginAttr(""String_Node_Str"") String name,@PluginAttr(""String_Node_Str"") String suppress,@PluginAttr(""String_Node_Str"") String excludes,@PluginAttr(""String_Node_Str"") String includes,@PluginAttr(""String_Node_Str"") String required,@PluginAttr(""String_Node_Str"") String mdcPrefix,@PluginAttr(""String_Node_Str"") String eventPrefix,@PluginAttr(""String_Node_Str"") String compressBody,@PluginElement(""String_Node_Str"") FlumeEventFactory factory,@PluginElement(""String_Node_Str"") Layout layout,@PluginElement(""String_Node_Str"") Filter filter){
  String hostname;
  try {
    hostname=InetAddress.getLocalHost().getHostName();
  }
 catch (  Exception ex) {
    LOGGER.error(""String_Node_Str"",ex);
    return null;
  }
  if (agents == null || agents.length == 0) {
    LOGGER.debug(""String_Node_Str"");
    agents=new Agent[]{Agent.createAgent(null,null)};
  }
  boolean handleExceptions=suppress == null ? true : Boolean.valueOf(suppress);
  boolean compress=compressBody == null ? true : Boolean.valueOf(compressBody);
  int reconnectDelay=delay == null ? 0 : Integer.parseInt(delay);
  int retries=agentRetries == null ? 0 : Integer.parseInt(agentRetries);
  if (layout == null) {
    layout=RFC5424Layout.createLayout(null,null,null,null,""String_Node_Str"",null,null,null,null,excludes,includes,required,null);
  }
  if (name == null) {
    LOGGER.error(""String_Node_Str"");
    return null;
  }
  FlumeAvroManager manager=FlumeAvroManager.getManager(agents);
  if (manager == null) {
    return null;
  }
  return new FlumeAvroAppender(name,filter,layout,handleExceptions,hostname,includes,excludes,required,mdcPrefix,eventPrefix,compress,reconnectDelay,retries,factory,manager);
}"
90923,"public void append(LogEvent event){
  FlumeEvent flumeEvent=factory.createEvent(event,hostname,mdcIncludes,mdcExcludes,mdcRequired,mdcPrefix,eventPrefix,compressBody);
  flumeEvent.setBody(getLayout().format(flumeEvent));
  manager.send(flumeEvent,reconnectDelay,retries);
}","/** 
 * Publish the event.
 * @param event The LogEvent.
 */
public void append(LogEvent event){
  FlumeEvent flumeEvent=factory.createEvent(event,hostname,mdcIncludes,mdcExcludes,mdcRequired,mdcPrefix,eventPrefix,compressBody);
  flumeEvent.setBody(getLayout().format(flumeEvent));
  manager.send(flumeEvent,reconnectDelay,retries);
}"
90924,"@Test public void testClassName(){
  Category category=Category.getInstance(""String_Node_Str"");
  Layout layout=PatternLayout.createLayout(""String_Node_Str"",null,null,null);
  ListAppender appender=new ListAppender(""String_Node_Str"",null,layout,false,false);
  appender.start();
  category.setAdditivity(false);
  category.getLogger().addAppender(appender);
  category.error(""String_Node_Str"");
  List<String> msgs=appender.getMessages();
  assertTrue(""String_Node_Str"" + msgs.size(),msgs.size() == 1);
  String msg=msgs.get(0);
  appender.clear();
  String expected=""String_Node_Str"";
  assertTrue(""String_Node_Str"",msg.endsWith(expected));
}","@Test public void testClassName(){
  Category category=Category.getInstance(""String_Node_Str"");
  Layout layout=PatternLayout.createLayout(""String_Node_Str"",null,null,null);
  ListAppender appender=new ListAppender(""String_Node_Str"",null,layout,false,false);
  appender.start();
  category.setAdditivity(false);
  category.getLogger().addAppender(appender);
  category.error(""String_Node_Str"");
  List<String> msgs=appender.getMessages();
  assertTrue(""String_Node_Str"" + msgs.size(),msgs.size() == 1);
  String msg=msgs.get(0);
  appender.clear();
  String expected=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + msg + ""String_Node_Str""+ ""String_Node_Str""+ expected+ ""String_Node_Str"",msg.endsWith(expected));
}"
90925,"@Test public void testClassName(){
  Category category=Category.getInstance(""String_Node_Str"");
  Layout layout=PatternLayout.createLayout(""String_Node_Str"",null);
  ListAppender appender=new ListAppender(""String_Node_Str"",null,layout,false,false);
  appender.start();
  category.setAdditivity(false);
  category.getLogger().addAppender(appender);
  category.error(""String_Node_Str"");
  List<String> msgs=appender.getMessages();
  assertTrue(""String_Node_Str"" + msgs.size(),msgs.size() == 1);
  String msg=msgs.get(0);
  appender.clear();
  String expected=""String_Node_Str"";
  assertTrue(""String_Node_Str"",msg.endsWith(expected));
}","@Test public void testClassName(){
  Category category=Category.getInstance(""String_Node_Str"");
  Layout layout=PatternLayout.createLayout(""String_Node_Str"",null,null,null);
  ListAppender appender=new ListAppender(""String_Node_Str"",null,layout,false,false);
  appender.start();
  category.setAdditivity(false);
  category.getLogger().addAppender(appender);
  category.error(""String_Node_Str"");
  List<String> msgs=appender.getMessages();
  assertTrue(""String_Node_Str"" + msgs.size(),msgs.size() == 1);
  String msg=msgs.get(0);
  appender.clear();
  String expected=""String_Node_Str"";
  assertTrue(""String_Node_Str"",msg.endsWith(expected));
}"
90926,"public boolean hasLogger(String name){
  return loggers.containsKey(name);
}","/** 
 * Determine if the specified Logger exists.
 * @param name The Logger name to search for.
 * @return True if the Logger exists, false otherwise.
 */
public boolean hasLogger(String name){
  return loggers.containsKey(name);
}"
90927,"public void onChange(){
  reconfigure();
}","/** 
 * Cause a reconfiguration to take place when the underlying configuration file changes.
 */
public void onChange(){
  reconfigure();
}"
90928,"public void updateLoggers(Configuration config){
  for (  Logger logger : loggers.values()) {
    logger.updateConfiguration(config);
  }
}","/** 
 * Cause all Logger to be updated against the specified Configuration.
 * @param config The Configuration.
 */
public void updateLoggers(Configuration config){
  for (  Logger logger : loggers.values()) {
    logger.updateConfiguration(config);
  }
}"
90929,"public Logger getLogger(LoggerFactory factory,String name){
  Logger logger=loggers.get(name);
  if (logger != null) {
    return logger;
  }
  logger=(Logger)factory.newInstance(this,name);
  Logger prev=loggers.putIfAbsent(name,logger);
  return prev == null ? logger : prev;
}","/** 
 * Obtain a Logger from the Context using the specified LoggerFactory.
 * @param factory The LoggerFactory.
 * @param name The name of the Logger.
 * @return The Logger.
 */
public Logger getLogger(LoggerFactory factory,String name){
  Logger logger=loggers.get(name);
  if (logger != null) {
    return logger;
  }
  logger=(Logger)factory.newInstance(this,name);
  Logger prev=loggers.putIfAbsent(name,logger);
  return prev == null ? logger : prev;
}"
90930,"public void removeFiler(Filter filter){
  config.removeFilter(filter);
}","/** 
 * Removes a Filter from the current Configuration.
 * @param filter The Filter to remove.
 */
public void removeFiler(Filter filter){
  config.removeFilter(filter);
}"
90931,"public LoggerContext(String name,Object externalContext,String configLocn){
  contextName=name;
  this.externalContext=externalContext;
  if (configLocn != null) {
    URI uri;
    try {
      uri=new File(configLocn).toURI();
    }
 catch (    Exception ex) {
      uri=null;
    }
    configLocation=uri;
  }
 else {
    configLocation=null;
  }
  reconfigure();
}","/** 
 * Constructor taking a name external context and a configuration location String. The location must be resolvable to a File.
 * @param name The configuration location.
 * @param externalContext The external context.
 * @param configLocn The configuration location.
 */
public LoggerContext(String name,Object externalContext,String configLocn){
  contextName=name;
  this.externalContext=externalContext;
  if (configLocn != null) {
    URI uri;
    try {
      uri=new File(configLocn).toURI();
    }
 catch (    Exception ex) {
      uri=null;
    }
    configLocation=uri;
  }
 else {
    configLocation=null;
  }
  reconfigure();
}"
90932,"public Object getExternalContext(){
  return this.externalContext;
}","/** 
 * Return the external context.
 * @return The external context.
 */
public Object getExternalContext(){
  return this.externalContext;
}"
90933,"public Configuration getConfiguration(){
  return config;
}","/** 
 * Return the current Configuration. The Configuration will be replaced when a reconfigure occurs.
 * @return The Configuration.
 */
public Configuration getConfiguration(){
  return config;
}"
90934,"public void addFilter(Filter filter){
  config.addFilter(filter);
}","/** 
 * Add a Filter to the Configuration. Filters that are added through the API will be lost when a reconfigure occurs.
 * @param filter The Filter to add.
 */
public void addFilter(Filter filter){
  config.addFilter(filter);
}"
90935,"public void setExternalContext(Object context){
  this.externalContext=context;
}","/** 
 * Set the external context.
 * @param context The external context.
 */
public void setExternalContext(Object context){
  this.externalContext=context;
}"
90936,"public static long getStartTime(){
  return JVM_START_TIME;
}","/** 
 * The time the LoggerContext class was loaded as a long.
 * @return The time the LoggerContext was loaded.
 */
public static long getStartTime(){
  return JVM_START_TIME;
}"
90937,"/** 
 * Set the Configuration to be used.
 */
public synchronized Configuration setConfiguration(Configuration config){
  if (config == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  Configuration prev=this.config;
  config.addListener(this);
  config.start();
  this.config=config;
  updateLoggers();
  if (prev != null) {
    prev.removeListener(this);
    prev.stop();
  }
  return prev;
}","/** 
 * Set the Configuration to be used.
 * @param config The new Configuration.
 * @return The previous Configuration.
 */
public synchronized Configuration setConfiguration(Configuration config){
  if (config == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  Configuration prev=this.config;
  config.addListener(this);
  config.start();
  this.config=config;
  updateLoggers();
  if (prev != null) {
    prev.removeListener(this);
    prev.stop();
  }
  return prev;
}"
90938,"public synchronized void shutdown(){
  updateLoggers(new NullConfiguration());
  config.stop();
  externalContext=null;
}","/** 
 * Shutdown the logging system.
 */
public synchronized void shutdown(){
  updateLoggers(new NullConfiguration());
  config.stop();
  externalContext=null;
}"
90939,"public LoggingException(Exception ex){
  super(ex);
}","/** 
 * Constructs a Logging Exception with a chained Exception and no message.
 * @param ex The chained Exception.
 */
public LoggingException(Exception ex){
  super(ex);
}"
90940,"public static <T extends AbstractManager>T getManager(String name,ManagerFactory<T,Object> factory,Object data){
  lock.lock();
  try {
    T manager=(T)map.get(name);
    if (manager == null) {
      manager=factory.createManager(name,data);
      if (manager == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      map.put(name,manager);
    }
    manager.count++;
    return manager;
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Retrieves a Manager if it has been previously created or creates a new Manager.
 * @param name The name of the Manager to retrieve.
 * @param factory The Factory to use to create the Manager.
 * @param data An Object that should be passed to the factory when creating the Manager.
 * @param < T > The Type of the Manager to be created.
 * @return A Manager with the specified name and type.
 */
public static <T extends AbstractManager>T getManager(String name,ManagerFactory<T,Object> factory,Object data){
  lock.lock();
  try {
    T manager=(T)map.get(name);
    if (manager == null) {
      manager=factory.createManager(name,data);
      if (manager == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      map.put(name,manager);
    }
    manager.count++;
    return manager;
  }
  finally {
    lock.unlock();
  }
}"
90941,"public String getName(){
  return name;
}","/** 
 * Return the name of the Manager.
 * @return The name of the Manager.
 */
public String getName(){
  return name;
}"
90942,"public void release(){
  lock.lock();
  try {
    --count;
    if (count <= 0) {
      map.remove(name);
      releaseSub();
    }
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Called to signify that this Manager is no longer required by an Appender.
 */
public void release(){
  lock.lock();
  try {
    --count;
    if (count <= 0) {
      map.remove(name);
      releaseSub();
    }
  }
  finally {
    lock.unlock();
  }
}"
90943,public abstract void releaseSub();,"/** 
 * May be overriden by Managers to perform processing while the Manager is being released and the lock is held.
 */
protected void releaseSub(){
}"
90944,"public static boolean hasManager(String name){
  lock.lock();
  try {
    return map.containsKey(name);
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Determines if a Manager with the specified name exists.
 * @param name The name of the Manager.
 * @return True if the Manager exists, false otherwise.
 */
public static boolean hasManager(String name){
  lock.lock();
  try {
    return map.containsKey(name);
  }
  finally {
    lock.unlock();
  }
}"
90945,"/** 
 * This method performs a deep toString of the given Object. Primitive arrays are converted using their respective Arrays.toString methods while special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could contain themselves. <p/> It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior. They only check if the container is directly contained in itself, but not if a contained container contains the original one. Because of that, Arrays.toString(Object[]) isn't safe either. Confusing? Just read the last paragraph again and check the respective toString() implementation. <p/> This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o) would produce a relatively hard-to-debug StackOverflowError.
 * @param o The object.
 * @return The String representation.
 */
public static String deepToString(Object o){
  if (o == null) {
    return null;
  }
  if (o instanceof String) {
    return (String)o;
  }
  StringBuilder str=new StringBuilder();
  Set dejaVu=new HashSet();
  recursiveDeepToString(o,str,dejaVu);
  return str.toString();
}","/** 
 * This method performs a deep toString of the given Object. Primitive arrays are converted using their respective Arrays.toString methods while special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could contain themselves. <p/> It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior. They only check if the container is directly contained in itself, but not if a contained container contains the original one. Because of that, Arrays.toString(Object[]) isn't safe either. Confusing? Just read the last paragraph again and check the respective toString() implementation. <p/> This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o) would produce a relatively hard-to-debug StackOverflowError.
 * @param o The object.
 * @return The String representation.
 */
public static String deepToString(Object o){
  if (o == null) {
    return null;
  }
  if (o instanceof String) {
    return (String)o;
  }
  StringBuilder str=new StringBuilder();
  Set<String> dejaVu=new HashSet<String>();
  recursiveDeepToString(o,str,dejaVu);
  return str.toString();
}"
90946,"/** 
 * This method performs a deep toString of the given Object. Primitive arrays are converted using their respective Arrays.toString methods while special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could contain themselves. <p/> dejaVu is used in case of those container types to prevent an endless recursion. <p/> It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior. They only check if the container is directly contained in itself, but not if a contained container contains the original one. Because of that, Arrays.toString(Object[]) isn't safe either. Confusing? Just read the last paragraph again and check the respective toString() implementation. <p/> This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o) would produce a relatively hard-to-debug StackOverflowError.
 * @param o      the Object to convert into a String
 * @param str    the StringBuilder that o will be appended to
 * @param dejaVu a list of container identities that were already used.
 */
private static void recursiveDeepToString(Object o,StringBuilder str,Set dejaVu){
  if (o == null) {
    str.append(""String_Node_Str"");
    return;
  }
  if (o instanceof String) {
    str.append(o);
    return;
  }
  Class oClass=o.getClass();
  if (oClass.isArray()) {
    if (oClass == byte[].class) {
      str.append(Arrays.toString((byte[])o));
    }
 else     if (oClass == short[].class) {
      str.append(Arrays.toString((short[])o));
    }
 else     if (oClass == int[].class) {
      str.append(Arrays.toString((int[])o));
    }
 else     if (oClass == long[].class) {
      str.append(Arrays.toString((long[])o));
    }
 else     if (oClass == float[].class) {
      str.append(Arrays.toString((float[])o));
    }
 else     if (oClass == double[].class) {
      str.append(Arrays.toString((double[])o));
    }
 else     if (oClass == boolean[].class) {
      str.append(Arrays.toString((boolean[])o));
    }
 else     if (oClass == char[].class) {
      str.append(Arrays.toString((char[])o));
    }
 else {
      String id=identityToString(o);
      if (dejaVu.contains(id)) {
        str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);
      }
 else {
        dejaVu.add(id);
        Object[] oArray=(Object[])o;
        str.append(""String_Node_Str"");
        boolean first=true;
        for (int i=0; i < oArray.length; ++i) {
          Object current=oArray[i];
          if (first) {
            first=false;
          }
 else {
            str.append(""String_Node_Str"");
          }
          recursiveDeepToString(current,str,new HashSet(dejaVu));
        }
        str.append(""String_Node_Str"");
      }
    }
  }
 else   if (o instanceof Map) {
    String id=identityToString(o);
    if (dejaVu.contains(id)) {
      str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);
    }
 else {
      dejaVu.add(id);
      Map oMap=(Map)o;
      str.append(""String_Node_Str"");
      boolean isFirst=true;
      Iterator iter=oMap.entrySet().iterator();
      while (iter.hasNext()) {
        Map.Entry current=(Map.Entry)iter.next();
        if (isFirst) {
          isFirst=false;
        }
 else {
          str.append(""String_Node_Str"");
        }
        Object key=current.getKey();
        Object value=current.getValue();
        recursiveDeepToString(key,str,new HashSet(dejaVu));
        str.append(""String_Node_Str"");
        recursiveDeepToString(value,str,new HashSet(dejaVu));
      }
      str.append(""String_Node_Str"");
    }
  }
 else   if (o instanceof Collection) {
    String id=identityToString(o);
    if (dejaVu.contains(id)) {
      str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);
    }
 else {
      dejaVu.add(id);
      Collection oCol=(Collection)o;
      str.append(""String_Node_Str"");
      boolean isFirst=true;
      Iterator iter=oCol.iterator();
      while (iter.hasNext()) {
        Object current=iter.next();
        if (isFirst) {
          isFirst=false;
        }
 else {
          str.append(""String_Node_Str"");
        }
        recursiveDeepToString(current,str,new HashSet(dejaVu));
      }
      str.append(""String_Node_Str"");
    }
  }
 else   if (o instanceof Date) {
    Date date=(Date)o;
    SimpleDateFormat format=new SimpleDateFormat(""String_Node_Str"");
    str.append(format.format(date));
  }
 else {
    try {
      str.append(o.toString());
    }
 catch (    Throwable t) {
      str.append(ERROR_PREFIX);
      str.append(identityToString(o));
      str.append(ERROR_SEPARATOR);
      String msg=t.getMessage();
      String className=t.getClass().getName();
      str.append(className);
      if (!className.equals(msg)) {
        str.append(ERROR_MSG_SEPARATOR);
        str.append(msg);
      }
      str.append(ERROR_SUFFIX);
    }
  }
}","/** 
 * This method performs a deep toString of the given Object. Primitive arrays are converted using their respective Arrays.toString methods while special handling is implemented for ""container types"", i.e. Object[], Map and Collection because those could contain themselves. <p/> dejaVu is used in case of those container types to prevent an endless recursion. <p/> It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior. They only check if the container is directly contained in itself, but not if a contained container contains the original one. Because of that, Arrays.toString(Object[]) isn't safe either. Confusing? Just read the last paragraph again and check the respective toString() implementation. <p/> This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o) would produce a relatively hard-to-debug StackOverflowError.
 * @param o      the Object to convert into a String
 * @param str    the StringBuilder that o will be appended to
 * @param dejaVu a list of container identities that were already used.
 */
private static void recursiveDeepToString(Object o,StringBuilder str,Set<String> dejaVu){
  if (o == null) {
    str.append(""String_Node_Str"");
    return;
  }
  if (o instanceof String) {
    str.append(o);
    return;
  }
  Class oClass=o.getClass();
  if (oClass.isArray()) {
    if (oClass == byte[].class) {
      str.append(Arrays.toString((byte[])o));
    }
 else     if (oClass == short[].class) {
      str.append(Arrays.toString((short[])o));
    }
 else     if (oClass == int[].class) {
      str.append(Arrays.toString((int[])o));
    }
 else     if (oClass == long[].class) {
      str.append(Arrays.toString((long[])o));
    }
 else     if (oClass == float[].class) {
      str.append(Arrays.toString((float[])o));
    }
 else     if (oClass == double[].class) {
      str.append(Arrays.toString((double[])o));
    }
 else     if (oClass == boolean[].class) {
      str.append(Arrays.toString((boolean[])o));
    }
 else     if (oClass == char[].class) {
      str.append(Arrays.toString((char[])o));
    }
 else {
      String id=identityToString(o);
      if (dejaVu.contains(id)) {
        str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);
      }
 else {
        dejaVu.add(id);
        Object[] oArray=(Object[])o;
        str.append(""String_Node_Str"");
        boolean first=true;
        for (        Object current : oArray) {
          if (first) {
            first=false;
          }
 else {
            str.append(""String_Node_Str"");
          }
          recursiveDeepToString(current,str,new HashSet<String>(dejaVu));
        }
        str.append(""String_Node_Str"");
      }
    }
  }
 else   if (o instanceof Map) {
    String id=identityToString(o);
    if (dejaVu.contains(id)) {
      str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);
    }
 else {
      dejaVu.add(id);
      Map oMap=(Map)o;
      str.append(""String_Node_Str"");
      boolean isFirst=true;
      for (      Object o1 : oMap.entrySet()) {
        Map.Entry current=(Map.Entry)o1;
        if (isFirst) {
          isFirst=false;
        }
 else {
          str.append(""String_Node_Str"");
        }
        Object key=current.getKey();
        Object value=current.getValue();
        recursiveDeepToString(key,str,new HashSet<String>(dejaVu));
        str.append(""String_Node_Str"");
        recursiveDeepToString(value,str,new HashSet<String>(dejaVu));
      }
      str.append(""String_Node_Str"");
    }
  }
 else   if (o instanceof Collection) {
    String id=identityToString(o);
    if (dejaVu.contains(id)) {
      str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);
    }
 else {
      dejaVu.add(id);
      Collection oCol=(Collection)o;
      str.append(""String_Node_Str"");
      boolean isFirst=true;
      for (      Object anOCol : oCol) {
        if (isFirst) {
          isFirst=false;
        }
 else {
          str.append(""String_Node_Str"");
        }
        recursiveDeepToString(anOCol,str,new HashSet<String>(dejaVu));
      }
      str.append(""String_Node_Str"");
    }
  }
 else   if (o instanceof Date) {
    Date date=(Date)o;
    SimpleDateFormat format=new SimpleDateFormat(""String_Node_Str"");
    str.append(format.format(date));
  }
 else {
    try {
      str.append(o.toString());
    }
 catch (    Throwable t) {
      str.append(ERROR_PREFIX);
      str.append(identityToString(o));
      str.append(ERROR_SEPARATOR);
      String msg=t.getMessage();
      String className=t.getClass().getName();
      str.append(className);
      if (!className.equals(msg)) {
        str.append(ERROR_MSG_SEPARATOR);
        str.append(msg);
      }
      str.append(ERROR_SUFFIX);
    }
  }
}"
90947,"public int hashCode(){
  int result=messagePattern != null ? messagePattern.hashCode() : 0;
  result=31 * result + (stringArgs != null ? Arrays.hashCode(stringArgs) : 0);
  return result;
}","public int hashCode(){
  int result=messagePattern != null ? messagePattern.hashCode() : 0;
  result=HASHVAL * result + (stringArgs != null ? Arrays.hashCode(stringArgs) : 0);
  return result;
}"
90948,"/** 
 * @doubt Not quite sure what is going on with the loop, but looks like it mightdrop only the deepest call from the fully qualified class, not all of them. (RG) The loop finds the FQCN and on the next iteration returns the StackTraceElement of the caller of FQCN. Don't know what you mean by ""not all of them"" as it only returns a single element. Say that FQCN is ""MySpecializedLogger"" and the stack trace returned from getStackTrace is: Log4jLogEvent.getSource MySpecializedLogger.log MySpecializedLogger.info ClientClass.doSomething ClientClass.main When walking the stack, next will be set to true  at MySpecializedLogger.log and MySpecializerLogger.info will be returned (at least from code inspection).
 */
public StackTraceElement getSource(){
  if (fqcnOfLogger == null) {
    return null;
  }
  if (location == null) {
    StackTraceElement[] stackTrace=Thread.currentThread().getStackTrace();
    boolean next=false;
    for (    StackTraceElement element : stackTrace) {
      if (next) {
        location=element;
        break;
      }
      String className=element.getClassName();
      if (fqcnOfLogger.equals(className)) {
        next=true;
      }
 else       if (NOT_AVAIL.equals(className)) {
        break;
      }
    }
  }
  return location;
}","/** 
 * Return the StackTraceElement for the caller. This will be the entry that occurs right before the first occurrence of FQCN as a class name.
 */
public StackTraceElement getSource(){
  if (fqcnOfLogger == null) {
    return null;
  }
  if (location == null) {
    StackTraceElement[] stackTrace=Thread.currentThread().getStackTrace();
    boolean next=false;
    for (    StackTraceElement element : stackTrace) {
      String className=element.getClassName();
      if (next) {
        if (fqcnOfLogger.equals(className)) {
          continue;
        }
        location=element;
        break;
      }
      if (fqcnOfLogger.equals(className)) {
        next=true;
      }
 else       if (NOT_AVAIL.equals(className)) {
        break;
      }
    }
  }
  return location;
}"
90949,"public synchronized void setLevel(Level level){
  config.level=level;
  config.intLevel=level.intLevel();
}","public synchronized void setLevel(Level level){
  if (level != null) {
    config=new PrivateConfig(config,level);
  }
}"
90950,"/** 
 * This method isn't synchronized to serialized updates to config. Rather, by doing this it is guaranteed that all threads will see the update without having to declare the variable volatile.
 * @param config The new Configuration.
 * @doubt lost me on the comment, this.config is declared volatile. (RG) Me too.
 */
void updateConfiguration(Configuration config){
  this.config=new PrivateConfig(config,this);
}","/** 
 * There are two ways that could be used to guarantee all threads are aware of changes to config. 1. synchronize this method. Accessors don't need to be synchronized as Java wil treat all variables within a synchronized block as volatile. 2. Declare the variable volatile. Option 2 is used here as the performance cost is very low and it does a better job at documenting how it is used.
 * @param config The new Configuration.
 */
void updateConfiguration(Configuration config){
  this.config=new PrivateConfig(config,this);
}"
90951,"public ClearPinDialog(final Context context,boolean hidden,boolean randomizePin){
  super(context,hidden,true,randomizePin);
  final MbwManager mbwManager=MbwManager.getInstance(context);
  Button btnForgotPin=(Button)findViewById(R.id.btn_forgot_pin);
  if (mbwManager.getPin().isResettable()) {
    Optional<Integer> resetPinRemainingBlocksCount=mbwManager.getResetPinRemainingBlocksCount();
    if (resetPinRemainingBlocksCount.or(1) == 0) {
      btnForgotPin.setText(""String_Node_Str"");
      btnForgotPin.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          mbwManager.savePin(Pin.CLEAR_PIN);
          if (onPinValid != null)           onPinValid.pinEntered(ClearPinDialog.this,Pin.CLEAR_PIN);
        }
      }
);
    }
 else     if (resetPinRemainingBlocksCount.isPresent()) {
      btnForgotPin.setText(String.format(context.getString(R.string.pin_forgotten_reset_wait_button_text),Utils.formatBlockcountAsApproxDuration(this.getContext(),resetPinRemainingBlocksCount.get())));
      btnForgotPin.setEnabled(false);
    }
 else {
      btnForgotPin.setOnClickListener(startResetListener(context,mbwManager));
    }
  }
 else {
    btnForgotPin.setVisibility(View.GONE);
  }
}","public ClearPinDialog(final Context context,boolean hidden){
  super(context,hidden,true);
  final MbwManager mbwManager=MbwManager.getInstance(context);
  Button btnForgotPin=(Button)findViewById(R.id.btn_forgot_pin);
  if (mbwManager.getPin().isResettable()) {
    Optional<Integer> resetPinRemainingBlocksCount=mbwManager.getResetPinRemainingBlocksCount();
    if (resetPinRemainingBlocksCount.or(1) == 0) {
      btnForgotPin.setText(""String_Node_Str"");
      btnForgotPin.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          mbwManager.savePin(Pin.CLEAR_PIN);
          if (onPinValid != null)           onPinValid.pinEntered(ClearPinDialog.this,Pin.CLEAR_PIN);
        }
      }
);
    }
 else     if (resetPinRemainingBlocksCount.isPresent()) {
      btnForgotPin.setText(String.format(context.getString(R.string.pin_forgotten_reset_wait_button_text),Utils.formatBlockcountAsApproxDuration(this.getContext(),resetPinRemainingBlocksCount.get())));
      btnForgotPin.setEnabled(false);
    }
 else {
      btnForgotPin.setOnClickListener(startResetListener(context,mbwManager));
    }
  }
 else {
    btnForgotPin.setVisibility(View.GONE);
  }
}"
90952,"public LedgerPinDialog(Context context,boolean hidden,boolean randomizePin){
  super(context,hidden,true,randomizePin);
}","public LedgerPinDialog(Context context,boolean hidden){
  super(context,hidden,true);
}"
90953,"public void showSetPinDialog(final Activity activity,final Optional<Runnable> afterDialogClosed){
  if (this.getMetadataStorage().getMasterSeedBackupState() != MetadataStorage.BackupState.VERIFIED) {
    Utils.showSimpleMessageDialog(activity,R.string.pin_backup_first,afterDialogClosed.get());
    return;
  }
  final NewPinDialog _dialog=new NewPinDialog(activity,false,randomizePin);
  _dialog.setOnPinValid(new PinDialog.OnPinEntered(){
    private String newPin=null;
    @Override public void pinEntered(    PinDialog dialog,    Pin pin){
      if (newPin == null) {
        newPin=pin.getPin();
        dialog.setTitle(R.string.pin_confirm_pin);
      }
 else       if (newPin.equals(pin.getPin())) {
        MbwManager.this.savePin(pin);
        Toast.makeText(activity,R.string.pin_set,Toast.LENGTH_LONG).show();
        dialog.dismiss();
        if (afterDialogClosed.isPresent()) {
          afterDialogClosed.get().run();
        }
      }
 else {
        Toast.makeText(activity,R.string.pin_codes_dont_match,Toast.LENGTH_LONG).show();
        MbwManager.this.vibrate();
        dialog.dismiss();
        if (afterDialogClosed.isPresent()) {
          afterDialogClosed.get().run();
        }
      }
    }
  }
);
  this.runPinProtectedFunction(activity,new Runnable(){
    @Override public void run(){
      _dialog.show();
    }
  }
);
}","public void showSetPinDialog(final Activity activity,final Optional<Runnable> afterDialogClosed){
  if (this.getMetadataStorage().getMasterSeedBackupState() != MetadataStorage.BackupState.VERIFIED) {
    Utils.showSimpleMessageDialog(activity,R.string.pin_backup_first,afterDialogClosed.get());
    return;
  }
  final NewPinDialog _dialog=new NewPinDialog(activity,false);
  _dialog.setOnPinValid(new PinDialog.OnPinEntered(){
    private String newPin=null;
    @Override public void pinEntered(    PinDialog dialog,    Pin pin){
      if (newPin == null) {
        newPin=pin.getPin();
        dialog.setTitle(R.string.pin_confirm_pin);
      }
 else       if (newPin.equals(pin.getPin())) {
        MbwManager.this.savePin(pin);
        Toast.makeText(activity,R.string.pin_set,Toast.LENGTH_LONG).show();
        dialog.dismiss();
        if (afterDialogClosed.isPresent()) {
          afterDialogClosed.get().run();
        }
      }
 else {
        Toast.makeText(activity,R.string.pin_codes_dont_match,Toast.LENGTH_LONG).show();
        MbwManager.this.vibrate();
        dialog.dismiss();
        if (afterDialogClosed.isPresent()) {
          afterDialogClosed.get().run();
        }
      }
    }
  }
);
  this.runPinProtectedFunction(activity,new Runnable(){
    @Override public void run(){
      _dialog.show();
    }
  }
);
}"
90954,"private MbwManager(Context evilContext){
  Queue<LogEntry> unsafeWapiLogs=EvictingQueue.create(100);
  _wapiLogs=Queues.synchronizedQueue(unsafeWapiLogs);
  _applicationContext=Preconditions.checkNotNull(evilContext.getApplicationContext());
  _environment=MbwEnvironment.verifyEnvironment();
  String version=VersionManager.determineVersion(_applicationContext);
  SharedPreferences preferences=getPreferences();
  configuration=new WalletConfiguration(preferences,getNetwork());
  _eventBus=new Bus();
  _eventBus.register(this);
  try {
    setTorMode(ServerEndpointType.Types.valueOf(preferences.getString(Constants.TOR_MODE,""String_Node_Str"")));
  }
 catch (  IllegalArgumentException ex) {
    setTorMode(ServerEndpointType.Types.ONLY_HTTPS);
  }
  _wapi=initWapi();
  _httpErrorCollector=HttpErrorCollector.registerInVM(_applicationContext,_wapi);
  _randomSource=new AndroidRandomSource();
  TradeSessionDb tradeSessionDb=new TradeSessionDb(_applicationContext);
  _ltApi=initLt();
  _localTraderManager=new LocalTraderManager(_applicationContext,tradeSessionDb,getLtApi(),this);
  _pin=new Pin(preferences.getString(Constants.PIN_SETTING,""String_Node_Str""),preferences.getString(Constants.PIN_SETTING_RESETTABLE,""String_Node_Str"").equals(""String_Node_Str""));
  _pinRequiredOnStartup=preferences.getBoolean(Constants.PIN_SETTING_REQUIRED_ON_STARTUP,false);
  randomizePin=preferences.getBoolean(Constants.RANDOMIZE_PIN,true);
  _minerFee=MinerFee.fromString(preferences.getString(Constants.MINER_FEE_SETTING,MinerFee.NORMAL.toString()));
  _enableContinuousFocus=preferences.getBoolean(Constants.ENABLE_CONTINUOUS_FOCUS_SETTING,false);
  _keyManagementLocked=preferences.getBoolean(Constants.KEY_MANAGEMENT_LOCKED_SETTING,false);
  DisplayMetrics dm=new DisplayMetrics();
  WindowManager windowManager=(WindowManager)_applicationContext.getSystemService(Context.WINDOW_SERVICE);
  windowManager.getDefaultDisplay().getMetrics(dm);
  _storage=new MetadataStorage(_applicationContext);
  _language=preferences.getString(Constants.LANGUAGE_SETTING,Locale.getDefault().getLanguage());
  _versionManager=new VersionManager(_applicationContext,_language,new AndroidAsyncApi(_wapi,_eventBus),version,_eventBus);
  Set<String> currencyList=getPreferences().getStringSet(Constants.SELECTED_CURRENCIES,null);
  Set<String> fiatCurrencies=new HashSet<>();
  if (currencyList == null || currencyList.isEmpty()) {
    fiatCurrencies.add(Constants.DEFAULT_CURRENCY);
  }
 else {
    fiatCurrencies.addAll(currencyList);
  }
  _exchangeRateManager=new ExchangeRateManager(_applicationContext,_wapi,getNetwork(),getMetadataStorage());
  _currencySwitcher=new CurrencySwitcher(_exchangeRateManager,fiatCurrencies,getPreferences().getString(Constants.FIAT_CURRENCY_SETTING,Constants.DEFAULT_CURRENCY),Denomination.fromString(preferences.getString(Constants.BITCOIN_DENOMINATION_SETTING,Denomination.BTC.toString())));
  ActivityManager am=(ActivityManager)_applicationContext.getSystemService(Context.ACTIVITY_SERVICE);
  int memoryClass=am.getMemoryClass();
  _deviceScryptParameters=memoryClass > 20 ? MrdExport.V1.ScryptParameters.DEFAULT_PARAMS : MrdExport.V1.ScryptParameters.LOW_MEM_PARAMS;
  _trezorManager=new TrezorManager(_applicationContext,getNetwork(),getEventBus());
  _keepkeyManager=new KeepKeyManager(_applicationContext,getNetwork(),getEventBus());
  _ledgerManager=new LedgerManager(_applicationContext,getNetwork(),getEventBus());
  _walletManager=createWalletManager(_applicationContext,_environment);
  _eventTranslator=new EventTranslator(new Handler(),_eventBus);
  _exchangeRateManager.subscribe(_eventTranslator);
  _walletManager.addObserver(_eventTranslator);
  _coinapultManager=createCoinapultManager();
  if (_coinapultManager.isPresent()) {
    addExtraAccounts(_coinapultManager.get());
  }
  new InitColuManagerTask().execute();
  setCurrencyList(fiatCurrencies);
  migrateOldKeys();
  createTempWalletManager();
  _versionManager.initBackgroundVersionChecker();
  _blockExplorerManager=new BlockExplorerManager(this,_environment.getBlockExplorerList(),getPreferences().getString(Constants.BLOCK_EXPLORER,_environment.getBlockExplorerList().get(0).getIdentifier()));
}","private MbwManager(Context evilContext){
  Queue<LogEntry> unsafeWapiLogs=EvictingQueue.create(100);
  _wapiLogs=Queues.synchronizedQueue(unsafeWapiLogs);
  _applicationContext=Preconditions.checkNotNull(evilContext.getApplicationContext());
  _environment=MbwEnvironment.verifyEnvironment();
  String version=VersionManager.determineVersion(_applicationContext);
  SharedPreferences preferences=getPreferences();
  configuration=new WalletConfiguration(preferences,getNetwork());
  _eventBus=new Bus();
  _eventBus.register(this);
  try {
    setTorMode(ServerEndpointType.Types.valueOf(preferences.getString(Constants.TOR_MODE,""String_Node_Str"")));
  }
 catch (  IllegalArgumentException ex) {
    setTorMode(ServerEndpointType.Types.ONLY_HTTPS);
  }
  _wapi=initWapi();
  _httpErrorCollector=HttpErrorCollector.registerInVM(_applicationContext,_wapi);
  _randomSource=new AndroidRandomSource();
  TradeSessionDb tradeSessionDb=new TradeSessionDb(_applicationContext);
  _ltApi=initLt();
  _localTraderManager=new LocalTraderManager(_applicationContext,tradeSessionDb,getLtApi(),this);
  _pin=new Pin(preferences.getString(Constants.PIN_SETTING,""String_Node_Str""),preferences.getString(Constants.PIN_SETTING_RESETTABLE,""String_Node_Str"").equals(""String_Node_Str""));
  _pinRequiredOnStartup=preferences.getBoolean(Constants.PIN_SETTING_REQUIRED_ON_STARTUP,false);
  randomizePinPad=preferences.getBoolean(Constants.RANDOMIZE_PIN,true);
  _minerFee=MinerFee.fromString(preferences.getString(Constants.MINER_FEE_SETTING,MinerFee.NORMAL.toString()));
  _enableContinuousFocus=preferences.getBoolean(Constants.ENABLE_CONTINUOUS_FOCUS_SETTING,false);
  _keyManagementLocked=preferences.getBoolean(Constants.KEY_MANAGEMENT_LOCKED_SETTING,false);
  DisplayMetrics dm=new DisplayMetrics();
  WindowManager windowManager=(WindowManager)_applicationContext.getSystemService(Context.WINDOW_SERVICE);
  windowManager.getDefaultDisplay().getMetrics(dm);
  _storage=new MetadataStorage(_applicationContext);
  _language=preferences.getString(Constants.LANGUAGE_SETTING,Locale.getDefault().getLanguage());
  _versionManager=new VersionManager(_applicationContext,_language,new AndroidAsyncApi(_wapi,_eventBus),version,_eventBus);
  Set<String> currencyList=getPreferences().getStringSet(Constants.SELECTED_CURRENCIES,null);
  Set<String> fiatCurrencies=new HashSet<>();
  if (currencyList == null || currencyList.isEmpty()) {
    fiatCurrencies.add(Constants.DEFAULT_CURRENCY);
  }
 else {
    fiatCurrencies.addAll(currencyList);
  }
  _exchangeRateManager=new ExchangeRateManager(_applicationContext,_wapi,getNetwork(),getMetadataStorage());
  _currencySwitcher=new CurrencySwitcher(_exchangeRateManager,fiatCurrencies,getPreferences().getString(Constants.FIAT_CURRENCY_SETTING,Constants.DEFAULT_CURRENCY),Denomination.fromString(preferences.getString(Constants.BITCOIN_DENOMINATION_SETTING,Denomination.BTC.toString())));
  ActivityManager am=(ActivityManager)_applicationContext.getSystemService(Context.ACTIVITY_SERVICE);
  int memoryClass=am.getMemoryClass();
  _deviceScryptParameters=memoryClass > 20 ? MrdExport.V1.ScryptParameters.DEFAULT_PARAMS : MrdExport.V1.ScryptParameters.LOW_MEM_PARAMS;
  _trezorManager=new TrezorManager(_applicationContext,getNetwork(),getEventBus());
  _keepkeyManager=new KeepKeyManager(_applicationContext,getNetwork(),getEventBus());
  _ledgerManager=new LedgerManager(_applicationContext,getNetwork(),getEventBus());
  _walletManager=createWalletManager(_applicationContext,_environment);
  _eventTranslator=new EventTranslator(new Handler(),_eventBus);
  _exchangeRateManager.subscribe(_eventTranslator);
  _walletManager.addObserver(_eventTranslator);
  _coinapultManager=createCoinapultManager();
  if (_coinapultManager.isPresent()) {
    addExtraAccounts(_coinapultManager.get());
  }
  new InitColuManagerTask().execute();
  setCurrencyList(fiatCurrencies);
  migrateOldKeys();
  createTempWalletManager();
  _versionManager.initBackgroundVersionChecker();
  _blockExplorerManager=new BlockExplorerManager(this,_environment.getBlockExplorerList(),getPreferences().getString(Constants.BLOCK_EXPLORER,_environment.getBlockExplorerList().get(0).getIdentifier()));
}"
90955,"private PinDialog runPinProtectedFunctionInternal(Activity activity,Runnable fun,boolean cancelable){
  if (isPinProtected() && !lastPinAgeOkay.get()) {
    PinDialog d=new PinDialog(activity,true,cancelable,randomizePin);
    runPinProtectedFunction(activity,d,fun);
    return d;
  }
 else {
    fun.run();
    return null;
  }
}","private PinDialog runPinProtectedFunctionInternal(Activity activity,Runnable fun,boolean cancelable){
  if (isPinProtected() && !lastPinAgeOkay.get()) {
    PinDialog d=new PinDialog(activity,true,cancelable);
    runPinProtectedFunction(activity,d,fun);
    return d;
  }
 else {
    fun.run();
    return null;
  }
}"
90956,"public void showClearPinDialog(final Activity activity,final Optional<Runnable> afterDialogClosed){
  this.runPinProtectedFunction(activity,new ClearPinDialog(activity,true,randomizePin),new Runnable(){
    @Override public void run(){
      MbwManager.this.savePin(Pin.CLEAR_PIN);
      Toast.makeText(_applicationContext,R.string.pin_cleared,Toast.LENGTH_LONG).show();
      if (afterDialogClosed.isPresent()) {
        afterDialogClosed.get().run();
      }
    }
  }
);
}","public void showClearPinDialog(final Activity activity,final Optional<Runnable> afterDialogClosed){
  this.runPinProtectedFunction(activity,new ClearPinDialog(activity,true),new Runnable(){
    @Override public void run(){
      MbwManager.this.savePin(Pin.CLEAR_PIN);
      Toast.makeText(_applicationContext,R.string.pin_cleared,Toast.LENGTH_LONG).show();
      if (afterDialogClosed.isPresent()) {
        afterDialogClosed.get().run();
      }
    }
  }
);
}"
90957,"public NewPinDialog(final Context context,boolean hidden,boolean randomizePin){
  super(context,hidden,true,randomizePin);
  this.setTitle(R.string.pin_enter_new_pin);
  MbwManager mbwManager=MbwManager.getInstance(context);
  cbResettablePin=(CheckBox)findViewById(R.id.cb_resettable_pin);
  cbResettablePin.setChecked(mbwManager.getPin().isSet());
  cbResettablePin.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton compoundButton,    boolean b){
      updateResetInfo(context);
    }
  }
);
  updateResetInfo(context);
}","public NewPinDialog(final Context context,boolean hidden){
  super(context,hidden,true);
  this.setTitle(R.string.pin_enter_new_pin);
  MbwManager mbwManager=MbwManager.getInstance(context);
  cbResettablePin=(CheckBox)findViewById(R.id.cb_resettable_pin);
  cbResettablePin.setChecked(mbwManager.getPin().isSet());
  cbResettablePin.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton compoundButton,    boolean b){
      updateResetInfo(context);
    }
  }
);
  updateResetInfo(context);
}"
90958,"public PinDialog(Context context,boolean hidden,boolean cancelable,boolean randomizePin){
  super(context);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE,WindowManager.LayoutParams.FLAG_SECURE);
  this.hidden=hidden;
  setCancelable(cancelable);
  setCanceledOnTouchOutside(false);
  loadLayout();
  initPinPad();
  enteredPin=""String_Node_Str"";
  clearDigits();
  updatePinDisplay();
  this.randomizePin=randomizePin;
  this.setTitle(R.string.pin_enter_pin);
}","public PinDialog(Context context,boolean hidden,boolean cancelable){
  super(context);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE,WindowManager.LayoutParams.FLAG_SECURE);
  pinPadIsRandomized=MbwManager.getInstance(context).isPinPadRandomized();
  this.hidden=hidden;
  setCancelable(cancelable);
  setCanceledOnTouchOutside(false);
  loadLayout();
  initPinPad();
  enteredPin=""String_Node_Str"";
  clearDigits();
  updatePinDisplay();
  this.setTitle(R.string.pin_enter_pin);
}"
90959,"protected void initPinPad(){
  disps.add((TextView)findViewById(R.id.pin_char_1));
  disps.add((TextView)findViewById(R.id.pin_char_2));
  disps.add((TextView)findViewById(R.id.pin_char_3));
  disps.add((TextView)findViewById(R.id.pin_char_4));
  disps.add((TextView)findViewById(R.id.pin_char_5));
  disps.add((TextView)findViewById(R.id.pin_char_6));
  buttons.add(((Button)findViewById(R.id.pin_button0)));
  buttons.add(((Button)findViewById(R.id.pin_button1)));
  buttons.add(((Button)findViewById(R.id.pin_button2)));
  buttons.add(((Button)findViewById(R.id.pin_button3)));
  buttons.add(((Button)findViewById(R.id.pin_button4)));
  buttons.add(((Button)findViewById(R.id.pin_button5)));
  buttons.add(((Button)findViewById(R.id.pin_button6)));
  buttons.add(((Button)findViewById(R.id.pin_button7)));
  buttons.add(((Button)findViewById(R.id.pin_button8)));
  buttons.add(((Button)findViewById(R.id.pin_button9)));
  Random random=new Random(100);
  ArrayList<Integer> numbers=new ArrayList<>();
  if (randomizePin) {
    while (numbers.size() != 10) {
      int num=Math.abs(random.nextInt() % 10);
      if (!numbers.contains(num)) {
        numbers.add(num);
      }
    }
  }
 else {
    for (int i=0; i < 10; i++) {
      numbers.add(i);
    }
  }
  for (int i=0; i < 10; i++) {
    buttons.get(i).setText(numbers.get(i).toString());
  }
  btnClear=(Button)findViewById(R.id.pin_clr);
  btnBack=(Button)findViewById(R.id.pin_back);
  for (  Button b : buttons) {
    final int num=Integer.parseInt(b.getText().toString());
    b.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        addDigit(String.valueOf(num));
      }
    }
);
  }
  btnBack.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      removeLastDigit();
    }
  }
);
  btnClear.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      clearDigits();
      updatePinDisplay();
    }
  }
);
}","protected void initPinPad(){
  disps.add((TextView)findViewById(R.id.pin_char_1));
  disps.add((TextView)findViewById(R.id.pin_char_2));
  disps.add((TextView)findViewById(R.id.pin_char_3));
  disps.add((TextView)findViewById(R.id.pin_char_4));
  disps.add((TextView)findViewById(R.id.pin_char_5));
  disps.add((TextView)findViewById(R.id.pin_char_6));
  buttons.add(((Button)findViewById(R.id.pin_button0)));
  buttons.add(((Button)findViewById(R.id.pin_button1)));
  buttons.add(((Button)findViewById(R.id.pin_button2)));
  buttons.add(((Button)findViewById(R.id.pin_button3)));
  buttons.add(((Button)findViewById(R.id.pin_button4)));
  buttons.add(((Button)findViewById(R.id.pin_button5)));
  buttons.add(((Button)findViewById(R.id.pin_button6)));
  buttons.add(((Button)findViewById(R.id.pin_button7)));
  buttons.add(((Button)findViewById(R.id.pin_button8)));
  buttons.add(((Button)findViewById(R.id.pin_button9)));
  ArrayList<Integer> numbers=new ArrayList<>();
  for (int i=0; i < 10; i++) {
    numbers.add(i);
  }
  if (pinPadIsRandomized) {
    Collections.shuffle(numbers);
  }
  for (int i=0; i < 10; i++) {
    buttons.get(i).setText(numbers.get(i).toString());
  }
  btnClear=(Button)findViewById(R.id.pin_clr);
  btnBack=(Button)findViewById(R.id.pin_back);
  for (  Button b : buttons) {
    final int num=Integer.parseInt(b.getText().toString());
    b.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        addDigit(String.valueOf(num));
      }
    }
);
  }
  btnBack.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      removeLastDigit();
    }
  }
);
  btnClear.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      clearDigits();
      updatePinDisplay();
    }
  }
);
}"
90960,"public TrezorPinDialog(Context context,boolean hidden,boolean randomizePin){
  super(context,hidden,true,randomizePin);
}","public TrezorPinDialog(Context context,boolean hidden){
  super(context,hidden,true);
}"
90961,"@Override public boolean onPreferenceChange(final Preference preference,Object o){
  boolean checked=!((CheckBoxPreference)preference).isChecked();
  if (_mbwManager.isPinProtected()) {
    _mbwManager.setRandomizePin(checked);
  }
 else {
    _mbwManager.setRandomizePin(false);
  }
  update();
  return false;
}","@Override public boolean onPreferenceChange(final Preference preference,Object o){
  boolean checked=!((CheckBoxPreference)preference).isChecked();
  if (_mbwManager.isPinProtected()) {
    _mbwManager.setPinPadRandomized(checked);
  }
 else {
    _mbwManager.setPinPadRandomized(false);
  }
  update();
  return false;
}"
90962,"void update(){
  setPin.setChecked(_mbwManager.isPinProtected());
  setPinRequiredStartup.setChecked(_mbwManager.isPinProtected() && _mbwManager.getPinRequiredOnStartup());
  randomizePin.setChecked(_mbwManager.isPinProtected() && _mbwManager.isRandomizePin());
}","void update(){
  setPin.setChecked(_mbwManager.isPinProtected());
  setPinRequiredStartup.setChecked(_mbwManager.isPinProtected() && _mbwManager.getPinRequiredOnStartup());
  randomizePin.setChecked(_mbwManager.isPinProtected() && _mbwManager.isPinPadRandomized());
}"
90963,"@Subscribe public void onPinMatrixRequest(ExternalSignatureDeviceManager.OnPinMatrixRequest event){
  TrezorPinDialog pin=new TrezorPinDialog(ExtSigAccountSelectorActivity.this,true,MbwManager.getInstance(this).isRandomizePin());
  pin.setOnPinValid(new PinDialog.OnPinEntered(){
    @Override public void pinEntered(    PinDialog dialog,    Pin pin){
      ((ExternalSignatureDeviceManager)masterseedScanManager).enterPin(pin.getPin());
      dialog.dismiss();
    }
  }
);
  pin.show();
  updateUi();
}","@Subscribe public void onPinMatrixRequest(ExternalSignatureDeviceManager.OnPinMatrixRequest event){
  TrezorPinDialog pin=new TrezorPinDialog(ExtSigAccountSelectorActivity.this,true);
  pin.setOnPinValid(new PinDialog.OnPinEntered(){
    @Override public void pinEntered(    PinDialog dialog,    Pin pin){
      ((ExternalSignatureDeviceManager)masterseedScanManager).enterPin(pin.getPin());
      dialog.dismiss();
    }
  }
);
  pin.show();
  updateUi();
}"
90964,"@Subscribe() public void onPinRequest(LedgerManager.OnPinRequest event){
  LedgerPinDialog pin=new LedgerPinDialog(this,true,MbwManager.getInstance(this).isRandomizePin());
  pin.setTitle(R.string.ledger_enter_pin);
  pin.setOnPinValid(new PinDialog.OnPinEntered(){
    @Override public void pinEntered(    PinDialog dialog,    Pin pin){
      ((LedgerManager)masterseedScanManager).enterPin(pin.getPin());
      dialog.dismiss();
    }
  }
);
  pin.show();
}","@Subscribe() public void onPinRequest(LedgerManager.OnPinRequest event){
  LedgerPinDialog pin=new LedgerPinDialog(this,true);
  pin.setTitle(R.string.ledger_enter_pin);
  pin.setOnPinValid(new PinDialog.OnPinEntered(){
    @Override public void pinEntered(    PinDialog dialog,    Pin pin){
      ((LedgerManager)masterseedScanManager).enterPin(pin.getPin());
      dialog.dismiss();
    }
  }
);
  pin.show();
}"
90965,"@Subscribe() public void onPinRequest(LedgerManager.OnPinRequest event){
  LedgerPinDialog pin=new LedgerPinDialog(this,true,MbwManager.getInstance(this).isRandomizePin());
  pin.setTitle(R.string.ledger_enter_pin);
  pin.setOnPinValid(new PinDialog.OnPinEntered(){
    @Override public void pinEntered(    PinDialog dialog,    Pin pin){
      ((LedgerManager)masterseedScanManager).enterPin(pin.getPin());
      dialog.dismiss();
    }
  }
);
  pin.show();
}","@Subscribe() public void onPinRequest(LedgerManager.OnPinRequest event){
  LedgerPinDialog pin=new LedgerPinDialog(this,true);
  pin.setTitle(R.string.ledger_enter_pin);
  pin.setOnPinValid(new PinDialog.OnPinEntered(){
    @Override public void pinEntered(    PinDialog dialog,    Pin pin){
      ((LedgerManager)masterseedScanManager).enterPin(pin.getPin());
      dialog.dismiss();
    }
  }
);
  pin.show();
}"
90966,"private boolean showPinPad(int title,final PinDialog.OnPinEntered callback){
  LedgerPinDialog pin=new LedgerPinDialog(LedgerSignTransactionActivity.this,true,MbwManager.getInstance(this).isRandomizePin());
  pin.setTitle(title);
  pin.setOnPinValid(callback);
  pin.show();
  return true;
}","private boolean showPinPad(int title,final PinDialog.OnPinEntered callback){
  LedgerPinDialog pin=new LedgerPinDialog(LedgerSignTransactionActivity.this,true);
  pin.setTitle(title);
  pin.setOnPinValid(callback);
  pin.show();
  return true;
}"
90967,"private void archive(final WalletAccount account){
  CurrencyBasedBalance balance=Preconditions.checkNotNull(account.getCurrencyBasedBalance());
  final WalletAccount linkedAccount=getLinkedAccount(account);
  new AlertDialog.Builder(getActivity()).setTitle(R.string.archiving_account_title).setMessage(createArchiveDialogText(account,linkedAccount)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
      account.archiveAccount();
      WalletAccount linkedAccount=Utils.getLinkedAccount(account,_mbwManager.getColuManager().getAccounts().values());
      if (linkedAccount != null) {
        linkedAccount.archiveAccount();
      }
      WalletAccount correspondingBCHAccount=_mbwManager.getWalletManager(false).getAccount(MbwManager.getBitcoinCashAccountId(account));
      if (correspondingBCHAccount != null) {
        correspondingBCHAccount.archiveAccount();
      }
      _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
      eventBus.post(new AccountChanged(account.getId()));
      updateIncludingMenus();
      _toaster.toast(R.string.archived,false);
    }
  }
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
    }
  }
).show();
}","private void archive(final WalletAccount account){
  CurrencyBasedBalance balance=Preconditions.checkNotNull(account.getCurrencyBasedBalance());
  final WalletAccount linkedAccount=getLinkedAccount(account);
  new AlertDialog.Builder(getActivity()).setTitle(R.string.archiving_account_title).setMessage(Html.fromHtml(createArchiveDialogText(account,linkedAccount))).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
      account.archiveAccount();
      WalletAccount linkedAccount=Utils.getLinkedAccount(account,_mbwManager.getColuManager().getAccounts().values());
      if (linkedAccount != null) {
        linkedAccount.archiveAccount();
      }
      WalletAccount correspondingBCHAccount=_mbwManager.getWalletManager(false).getAccount(MbwManager.getBitcoinCashAccountId(account));
      if (correspondingBCHAccount != null) {
        correspondingBCHAccount.archiveAccount();
      }
      _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
      eventBus.post(new AccountChanged(account.getId()));
      updateIncludingMenus();
      _toaster.toast(R.string.archived,false);
    }
  }
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
    }
  }
).show();
}"
90968,"@Override public void onCreate(){
  int loadedBouncy=Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(),1);
  if (loadedBouncy == -1) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    Log.d(""String_Node_Str"",""String_Node_Str"");
  }
  SettingsPreference.getInstance().init(this);
  INSTANCE=this;
  if (BuildConfig.DEBUG) {
    StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectAll().penaltyLog().build());
  }
  super.onCreate();
  CommunicationManager.init(this);
  pairSpvModules(CommunicationManager.getInstance());
  cleanModulesIfFirstRun(this,getSharedPreferences(BCHHelper.BCH_PREFS,MODE_PRIVATE));
  moduleMessageReceiver=new MbwMessageReceiver(this);
  MbwManager mbwManager=MbwManager.getInstance(this);
  applyLanguageChange(getBaseContext(),mbwManager.getLanguage());
  IntentFilter connectivityChangeFilter=new IntentFilter(""String_Node_Str"");
  initNetworkStateHandler(connectivityChangeFilter);
}","@Override public void onCreate(){
  int loadedBouncy=Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(),1);
  if (loadedBouncy == -1) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    Log.d(""String_Node_Str"",""String_Node_Str"");
  }
  SettingsPreference.getInstance().init(this);
  INSTANCE=this;
  if (BuildConfig.DEBUG) {
    StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectAll().penaltyLog().build());
  }
  super.onCreate();
  CommunicationManager.init(this);
  pairSpvModules(CommunicationManager.getInstance());
  cleanModulesIfFirstRun(this,getSharedPreferences(BCHHelper.BCH_PREFS,MODE_PRIVATE));
  moduleMessageReceiver=new MbwMessageReceiver(this);
  mbwManager=MbwManager.getInstance(this);
  applyLanguageChange(getBaseContext(),mbwManager.getLanguage());
  IntentFilter connectivityChangeFilter=new IntentFilter(""String_Node_Str"");
  initNetworkStateHandler(connectivityChangeFilter);
  registerActivityLifecycleCallbacks(new ApplicationLifecycleHandler());
}"
90969,"/** 
 * Called when the activity is first created.
 */
@Override public void onCreate(Bundle savedInstanceState){
  this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.export_as_qr_code_activity);
  Utils.preventScreenshots(this);
  _mbwManager=MbwManager.getInstance(getApplication());
  accountData=(ExportableAccount.Data)getIntent().getSerializableExtra(ACCOUNT);
  if (accountData == null || (!accountData.publicData.isPresent() && !accountData.privateData.isPresent())) {
    finish();
    return;
  }
  swSelectData=(Switch)findViewById(R.id.swSelectData);
  if (accountData.privateData.isPresent()) {
    swSelectData.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
      @Override public void onCheckedChanged(      CompoundButton compoundButton,      boolean b){
        updateData();
      }
    }
);
  }
 else {
    swSelectData.setVisibility(View.GONE);
  }
  findViewById(R.id.llPrivKeyWarning).setOnLongClickListener(new View.OnLongClickListener(){
    @Override public boolean onLongClick(    View view){
      hasWarningAccepted=true;
      updateData();
      return true;
    }
  }
);
  updateData();
}","/** 
 * Called when the activity is first created.
 */
@Override public void onCreate(Bundle savedInstanceState){
  this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.export_as_qr_code_activity);
  Utils.preventScreenshots(this);
  _mbwManager=MbwManager.getInstance(getApplication());
  accountData=(ExportableAccount.Data)getIntent().getSerializableExtra(ACCOUNT);
  if (accountData == null || (!accountData.publicData.isPresent() && !accountData.privateData.isPresent())) {
    finish();
    return;
  }
  swSelectData=(SwitchCompat)findViewById(R.id.swSelectData);
  TextView privateText=(TextView)findViewById(R.id.prv_key);
  TextView formatBlock1=(TextView)findViewById(R.id.block_1);
  TextView formatBlock2=(TextView)findViewById(R.id.block_2);
  if (accountData.privateData.isPresent()) {
    swSelectData.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
      @Override public void onCheckedChanged(      CompoundButton compoundButton,      boolean b){
        updateData();
      }
    }
);
  }
 else {
    swSelectData.setVisibility(View.GONE);
    privateText.setVisibility(View.GONE);
    formatBlock1.setVisibility(View.GONE);
    formatBlock2.setVisibility(View.GONE);
  }
  findViewById(R.id.llPrivKeyWarning).setOnLongClickListener(new View.OnLongClickListener(){
    @Override public boolean onLongClick(    View view){
      hasWarningAccepted=true;
      updateData();
      return true;
    }
  }
);
  updateData();
}"
90970,"/** 
 * Called when the activity is first created.
 */
@Override public void onCreate(Bundle savedInstanceState){
  this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.export_as_qr_code_activity);
  Utils.preventScreenshots(this);
  _mbwManager=MbwManager.getInstance(getApplication());
  accountData=(ExportableAccount.Data)getIntent().getSerializableExtra(ACCOUNT);
  if (accountData == null || (!accountData.publicData.isPresent() && !accountData.privateData.isPresent())) {
    finish();
    return;
  }
  swSelectData=(SwitchCompat)findViewById(R.id.swSelectData);
  TextView privateText=(TextView)findViewById(R.id.prv_key);
  TextView formatBlock1=(TextView)findViewById(R.id.block_1);
  TextView formatBlock2=(TextView)findViewById(R.id.block_2);
  if (accountData.privateData.isPresent()) {
    swSelectData.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
      @Override public void onCheckedChanged(      CompoundButton compoundButton,      boolean b){
        updateData();
      }
    }
);
  }
 else {
    swSelectData.setVisibility(View.GONE);
    privateText.setVisibility(View.GONE);
    formatBlock1.setVisibility(View.GONE);
    formatBlock2.setVisibility(View.GONE);
  }
  findViewById(R.id.llPrivKeyWarning).setOnLongClickListener(new View.OnLongClickListener(){
    @Override public boolean onLongClick(    View view){
      hasWarningAccepted=true;
      updateData();
      return true;
    }
  }
);
  updateData();
}","/** 
 * Called when the activity is first created.
 */
@Override public void onCreate(Bundle savedInstanceState){
  this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.export_as_qr_code_activity);
  Utils.preventScreenshots(this);
  _mbwManager=MbwManager.getInstance(getApplication());
  accountData=(ExportableAccount.Data)getIntent().getSerializableExtra(ACCOUNT);
  if (accountData == null || (!accountData.publicData.isPresent() && !accountData.privateData.isPresent())) {
    finish();
    return;
  }
  swSelectData=(SwitchCompat)findViewById(R.id.swSelectData);
  TextView privateText=(TextView)findViewById(R.id.prv_key);
  TextView publicText=(TextView)findViewById(R.id.pub_key);
  if (accountData.privateData.isPresent()) {
    swSelectData.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
      @Override public void onCheckedChanged(      CompoundButton compoundButton,      boolean b){
        updateData();
      }
    }
);
  }
 else {
    swSelectData.setVisibility(View.GONE);
    privateText.setVisibility(View.GONE);
    publicText.setVisibility(View.GONE);
  }
  findViewById(R.id.llPrivKeyWarning).setOnLongClickListener(new View.OnLongClickListener(){
    @Override public boolean onLongClick(    View view){
      hasWarningAccepted=true;
      updateData();
      return true;
    }
  }
);
  updateData();
}"
90971,"public static Resources getResourcesByLocale(Resources res,String localeName){
  Configuration conf=new Configuration(res.getConfiguration());
  conf.locale=new Locale(localeName);
  return new Resources(res.getAssets(),res.getDisplayMetrics(),conf);
}","public static Resources getResourcesByLocale(Context context,String localeName){
  Configuration conf=context.getResources().getConfiguration();
  conf=new Configuration(conf);
  conf.setLocale(new Locale(localeName));
  Context localizedContext=context.createConfigurationContext(conf);
  return localizedContext.getResources();
}"
90972,"private String getLanguageSettingTitle(){
  String displayed=getResources().getString(R.string.pref_language);
  String english=Utils.getResourcesByLocale(getResources(),""String_Node_Str"").getString(R.string.pref_language);
  return english.equals(displayed) ? displayed : displayed + ""String_Node_Str"" + english;
}","private String getLanguageSettingTitle(){
  String displayed=getResources().getString(R.string.pref_language);
  String english=Utils.getResourcesByLocale(getActivity(),""String_Node_Str"").getString(R.string.pref_language);
  return english.equals(displayed) ? displayed : displayed + ""String_Node_Str"" + english;
}"
90973,"@Override public void putTransactions(List<TransactionEx> transactions){
  StringBuilder updateQuery=new StringBuilder(""String_Node_Str"" + txTableName + ""String_Node_Str"");
  updateQuery.append(Strings.repeat(""String_Node_Str"",transactions.size() - 1));
  updateQuery.append(""String_Node_Str"");
  SQLiteStatement updateStatement=_database.compileStatement(updateQuery.toString());
  for (int x=0; x < transactions.size(); x++) {
    updateStatement.bindBlob(x + 1,transactions.get(x).txid.getBytes());
    updateStatement.bindBlob(x + 2,transactions.get(x).hash.getBytes());
    updateStatement.bindLong(x + 3,transactions.get(x).height == -1 ? Integer.MAX_VALUE : transactions.get(x).height);
    updateStatement.bindLong(x + 4,transactions.get(x).time);
    updateStatement.bindBlob(x + 5,transactions.get(x).binary);
  }
  updateStatement.executeInsert();
  for (  TransactionEx transaction : transactions) {
    putReferencedOutputs(transaction.binary);
  }
}","@Override public void putTransactions(List<TransactionEx> transactions){
  _database.beginTransaction();
  String updateQuery=""String_Node_Str"" + txTableName + ""String_Node_Str""+ Strings.repeat(""String_Node_Str"",transactions.size() - 1)+ ""String_Node_Str"";
  SQLiteStatement updateStatement=_database.compileStatement(updateQuery);
  try {
    for (int x=0; x < transactions.size(); x++) {
      int index=x * 5;
      updateStatement.bindBlob(index + 1,transactions.get(x).txid.getBytes());
      updateStatement.bindBlob(index + 2,transactions.get(x).hash.getBytes());
      updateStatement.bindLong(index + 3,transactions.get(x).height == -1 ? Integer.MAX_VALUE : transactions.get(x).height);
      updateStatement.bindLong(index + 4,transactions.get(x).time);
      updateStatement.bindBlob(index + 5,transactions.get(x).binary);
    }
    updateStatement.executeInsert();
    for (    TransactionEx transaction : transactions) {
      putReferencedOutputs(transaction.binary);
    }
    _database.setTransactionSuccessful();
  }
  finally {
    _database.endTransaction();
  }
}"
90974,"@Override public void putTransactions(List<TransactionEx> transactions){
  String updateQuery=""String_Node_Str"" + txTableName + ""String_Node_Str""+ Strings.repeat(""String_Node_Str"",transactions.size() - 1)+ ""String_Node_Str"";
  SQLiteStatement updateStatement=_database.compileStatement(updateQuery);
  for (int x=0; x < transactions.size(); x++) {
    int index=x * 5;
    updateStatement.bindBlob(index + 1,transactions.get(x).txid.getBytes());
    updateStatement.bindBlob(index + 2,transactions.get(x).hash.getBytes());
    updateStatement.bindLong(index + 3,transactions.get(x).height == -1 ? Integer.MAX_VALUE : transactions.get(x).height);
    updateStatement.bindLong(index + 4,transactions.get(x).time);
    updateStatement.bindBlob(index + 5,transactions.get(x).binary);
  }
  updateStatement.executeInsert();
  for (  TransactionEx transaction : transactions) {
    putReferencedOutputs(transaction.binary);
  }
}","@Override public void putTransactions(List<TransactionEx> transactions){
  _database.beginTransaction();
  String updateQuery=""String_Node_Str"" + txTableName + ""String_Node_Str""+ Strings.repeat(""String_Node_Str"",transactions.size() - 1)+ ""String_Node_Str"";
  SQLiteStatement updateStatement=_database.compileStatement(updateQuery);
  try {
    for (int x=0; x < transactions.size(); x++) {
      int index=x * 5;
      updateStatement.bindBlob(index + 1,transactions.get(x).txid.getBytes());
      updateStatement.bindBlob(index + 2,transactions.get(x).hash.getBytes());
      updateStatement.bindLong(index + 3,transactions.get(x).height == -1 ? Integer.MAX_VALUE : transactions.get(x).height);
      updateStatement.bindLong(index + 4,transactions.get(x).time);
      updateStatement.bindBlob(index + 5,transactions.get(x).binary);
    }
    updateStatement.executeInsert();
    for (    TransactionEx transaction : transactions) {
      putReferencedOutputs(transaction.binary);
    }
    _database.setTransactionSuccessful();
  }
  finally {
    _database.endTransaction();
  }
}"
90975,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  _mbwManager=MbwManager.getInstance(this);
  WalletApplication.applyLanguageChange(getBaseContext(),_mbwManager.getLanguage());
  mViewPager=new ViewPager(this);
  mViewPager.setId(R.id.pager);
  setContentView(mViewPager);
  ActionBar bar=getSupportActionBar();
  bar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
  bar.setDisplayShowTitleEnabled(false);
  bar.setDisplayShowHomeEnabled(true);
  bar.setIcon(R.drawable.action_bar_logo);
  getWindow().setBackgroundDrawableResource(R.drawable.background_witherrors_dimmed);
  mTabsAdapter=new TabsAdapter(this,mViewPager,_mbwManager);
  mAccountsTab=bar.newTab();
  mTabsAdapter.addTab(mAccountsTab.setText(getString(R.string.tab_accounts)),AccountsFragment.class,null);
  mBalanceTab=bar.newTab();
  mTabsAdapter.addTab(mBalanceTab.setText(getString(R.string.tab_balance)),BalanceMasterFragment.class,null);
  mTabsAdapter.addTab(bar.newTab().setText(getString(R.string.tab_transactions)),TransactionHistoryFragment.class,null);
  mRecommendationsTab=bar.newTab();
  mTabsAdapter.addTab(mRecommendationsTab.setText(getString(R.string.tab_partners)),RecommendationsFragment.class,null);
  final Bundle addressBookConfig=new Bundle();
  addressBookConfig.putBoolean(AddressBookFragment.SELECT_ONLY,false);
  mTabsAdapter.addTab(bar.newTab().setText(getString(R.string.tab_addresses)),AddressBookFragment.class,addressBookConfig);
  addressBookTabIndex=mTabsAdapter.getCount() - 1;
  bar.selectTab(mBalanceTab);
  _toaster=new Toaster(this);
  ChangeLog cl=new DarkThemeChangeLog(this);
  if (cl.isFirstRun() && cl.getChangeLog(false).size() > 0 && !cl.isFirstRunEver()) {
    cl.getLogDialog().show();
  }
  checkTorState();
  if (savedInstanceState != null) {
    _lastSync=savedInstanceState.getLong(LAST_SYNC,0);
    _isAppStart=savedInstanceState.getBoolean(APP_START,true);
  }
  if (_isAppStart) {
    _mbwManager.getVersionManager().showFeatureWarningIfNeeded(this,Feature.APP_START);
    checkGapBug();
    _isAppStart=false;
  }
  BCHHelper.firstBCHPages(this);
  _mbwManager.importLabelsToBch(_mbwManager.getWalletManager(false));
  ModularisationVersionHelper.notifyWrongModuleVersion(this);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  _mbwManager=MbwManager.getInstance(this);
  WalletApplication.applyLanguageChange(getBaseContext(),_mbwManager.getLanguage());
  mViewPager=new ViewPager(this);
  mViewPager.setId(R.id.pager);
  setContentView(mViewPager);
  ActionBar bar=getSupportActionBar();
  bar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
  bar.setDisplayShowTitleEnabled(false);
  bar.setDisplayShowHomeEnabled(true);
  bar.setIcon(R.drawable.action_bar_logo);
  getWindow().setBackgroundDrawableResource(R.drawable.background_main);
  mTabsAdapter=new TabsAdapter(this,mViewPager,_mbwManager);
  mAccountsTab=bar.newTab();
  mTabsAdapter.addTab(mAccountsTab.setText(getString(R.string.tab_accounts)),AccountsFragment.class,null);
  mBalanceTab=bar.newTab();
  mTabsAdapter.addTab(mBalanceTab.setText(getString(R.string.tab_balance)),BalanceMasterFragment.class,null);
  mTabsAdapter.addTab(bar.newTab().setText(getString(R.string.tab_transactions)),TransactionHistoryFragment.class,null);
  mRecommendationsTab=bar.newTab();
  mTabsAdapter.addTab(mRecommendationsTab.setText(getString(R.string.tab_partners)),RecommendationsFragment.class,null);
  final Bundle addressBookConfig=new Bundle();
  addressBookConfig.putBoolean(AddressBookFragment.SELECT_ONLY,false);
  mTabsAdapter.addTab(bar.newTab().setText(getString(R.string.tab_addresses)),AddressBookFragment.class,addressBookConfig);
  addressBookTabIndex=mTabsAdapter.getCount() - 1;
  bar.selectTab(mBalanceTab);
  _toaster=new Toaster(this);
  ChangeLog cl=new DarkThemeChangeLog(this);
  if (cl.isFirstRun() && cl.getChangeLog(false).size() > 0 && !cl.isFirstRunEver()) {
    cl.getLogDialog().show();
  }
  checkTorState();
  if (savedInstanceState != null) {
    _lastSync=savedInstanceState.getLong(LAST_SYNC,0);
    _isAppStart=savedInstanceState.getBoolean(APP_START,true);
  }
  if (_isAppStart) {
    _mbwManager.getVersionManager().showFeatureWarningIfNeeded(this,Feature.APP_START);
    checkGapBug();
    _isAppStart=false;
  }
  BCHHelper.firstBCHPages(this);
  _mbwManager.importLabelsToBch(_mbwManager.getWalletManager(false));
  ModularisationVersionHelper.notifyWrongModuleVersion(this);
}"
90976,"@Override public boolean onOptionsItemSelected(MenuItem item){
  final int itemId=item.getItemId();
switch (itemId) {
case R.id.miColdStorage:
    InstantWalletActivity.callMe(this);
  return true;
case R.id.miSettings:
{
  Intent intent=new Intent(this,SettingsActivity.class);
  startActivityForResult(intent,REQUEST_SETTING_CHANGED);
  return true;
}
case R.id.miBackup:
Utils.pinProtectedWordlistBackup(this);
return true;
case R.id.miRefresh:
SyncMode syncMode=SyncMode.NORMAL_FORCED;
if (new Random().nextInt(5) == 0) {
syncMode=SyncMode.FULL_SYNC_CURRENT_ACCOUNT_FORCED;
}
 else if (mViewPager.getCurrentItem() == TAB_ID_ACCOUNTS) {
syncMode=SyncMode.NORMAL_ALL_ACCOUNTS_FORCED;
}
_mbwManager.getWalletManager(false).startSynchronization(syncMode);
_mbwManager.getColuManager().startSynchronization();
_mbwManager.getExchangeRateManager().requestOptionalRefresh();
return true;
case R.id.miHelp:
openMyceliumHelp();
break;
case R.id.miAbout:
{
Intent intent=new Intent(this,AboutActivity.class);
startActivity(intent);
break;
}
case R.id.miRescanTransactions:
_mbwManager.getSelectedAccount().dropCachedData();
_mbwManager.getWalletManager(false).startSynchronization(SyncMode.FULL_SYNC_CURRENT_ACCOUNT_FORCED);
_mbwManager.getColuManager().startSynchronization();
break;
case R.id.miVerifyMessage:
startActivity(new Intent(this,MessageVerifyActivity.class));
break;
}
return super.onOptionsItemSelected(item);
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  final int itemId=item.getItemId();
switch (itemId) {
case R.id.miColdStorage:
    InstantWalletActivity.callMe(this);
  return true;
case R.id.miSettings:
{
  Intent intent=new Intent(this,SettingsActivity.class);
  startActivityForResult(intent,REQUEST_SETTING_CHANGED);
  return true;
}
case R.id.miBackup:
Utils.pinProtectedWordlistBackup(this);
return true;
case R.id.miRefresh:
SyncMode syncMode=SyncMode.NORMAL_FORCED;
if (new Random().nextInt(5) == 0) {
syncMode=SyncMode.FULL_SYNC_CURRENT_ACCOUNT_FORCED;
}
 else if (mViewPager.getCurrentItem() == TAB_ID_ACCOUNTS) {
syncMode=SyncMode.NORMAL_ALL_ACCOUNTS_FORCED;
}
_mbwManager.getWalletManager(false).startSynchronization(syncMode);
_mbwManager.getColuManager().startSynchronization();
_mbwManager.getExchangeRateManager().requestOptionalRefresh();
showRefresh();
return true;
case R.id.miHelp:
openMyceliumHelp();
break;
case R.id.miAbout:
{
Intent intent=new Intent(this,AboutActivity.class);
startActivity(intent);
break;
}
case R.id.miRescanTransactions:
_mbwManager.getSelectedAccount().dropCachedData();
_mbwManager.getWalletManager(false).startSynchronization(SyncMode.FULL_SYNC_CURRENT_ACCOUNT_FORCED);
_mbwManager.getColuManager().startSynchronization();
break;
case R.id.miVerifyMessage:
startActivity(new Intent(this,MessageVerifyActivity.class));
break;
}
return super.onOptionsItemSelected(item);
}"
90977,"public void setRefreshAnimation(){
  if (refreshItem != null) {
    if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
      if (commonSyncState != WalletManager.State.SYNCHRONIZING) {
        commonSyncState=WalletManager.State.SYNCHRONIZING;
        MenuItem menuItem=refreshItem.setActionView(R.layout.actionbar_indeterminate_progress);
        ImageView ivTorIcon=menuItem.getActionView().findViewById(R.id.ivTorIcon);
        if (_mbwManager.getTorMode() == ServerEndpointType.Types.ONLY_TOR && _mbwManager.getTorManager() != null) {
          ivTorIcon.setVisibility(View.VISIBLE);
          if (_mbwManager.getTorManager().getInitState() == 100) {
            ivTorIcon.setImageResource(R.drawable.tor);
          }
 else {
            ivTorIcon.setImageResource(R.drawable.tor_gray);
          }
        }
 else {
          ivTorIcon.setVisibility(View.GONE);
        }
      }
    }
 else {
      commonSyncState=WalletManager.State.READY;
      refreshItem.setActionView(null);
    }
  }
}","public void setRefreshAnimation(){
  if (refreshItem != null) {
    if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
      if (commonSyncState != WalletManager.State.SYNCHRONIZING) {
        showRefresh();
      }
    }
 else {
      commonSyncState=WalletManager.State.READY;
      refreshItem.setActionView(null);
    }
  }
}"
90978,"@Override public int hashCode(){
  return outPoint.hash.hashCode() + outPoint.index;
}","@Override public int hashCode(){
  return outPoint.txid.hashCode() + outPoint.index;
}"
90979,"public OutPoint(ByteReader reader) throws InsufficientBytesException {
  this.hash=reader.getSha256Hash();
  this.index=(int)reader.getCompactInt();
}","public OutPoint(ByteReader reader) throws InsufficientBytesException {
  this.txid=reader.getSha256Hash();
  this.index=(int)reader.getCompactInt();
}"
90980,"@Override public int hashCode(){
  return hash.hashCode() + index;
}","@Override public int hashCode(){
  return txid.hashCode() + index;
}"
90981,"@Override public boolean equals(Object other){
  if (!(other instanceof OutPoint)) {
    return false;
  }
  return hash.equals(((OutPoint)other).hash) && index == ((OutPoint)other).index;
}","@Override public boolean equals(Object other){
  if (!(other instanceof OutPoint)) {
    return false;
  }
  return txid.equals(((OutPoint)other).txid) && index == ((OutPoint)other).index;
}"
90982,"@Override public String toString(){
  return String.valueOf(hash) + ':' + index;
}","@Override public String toString(){
  return String.valueOf(txid) + ':' + index;
}"
90983,"public ByteWriter toByteWriter(ByteWriter writer){
  writer.putSha256Hash(hash);
  writer.putCompactInt(index);
  return writer;
}","public ByteWriter toByteWriter(ByteWriter writer){
  writer.putSha256Hash(txid);
  writer.putCompactInt(index);
  return writer;
}"
90984,"@Override public int hashCode(){
  return outPoint.hash.hashCode() + outPoint.index;
}","@Override public int hashCode(){
  return outPoint.txid.hashCode() + outPoint.index;
}"
90985,"@Override public String toString(){
  return String.valueOf(getHash()) + ""String_Node_Str"" + inputs.length+ ""String_Node_Str""+ outputs.length;
}","@Override public String toString(){
  return String.valueOf(getId()) + ""String_Node_Str"" + inputs.length+ ""String_Node_Str""+ outputs.length;
}"
90986,"public void toByteWriter(ByteWriter writer){
  writer.putSha256Hash(outPoint.hash,true);
  writer.putIntLE(outPoint.index);
  byte[] script=getScript().getScriptBytes();
  writer.putCompactInt(script.length);
  writer.putBytes(script);
  writer.putIntLE(sequence);
}","public void toByteWriter(ByteWriter writer){
  writer.putSha256Hash(outPoint.txid,true);
  writer.putIntLE(outPoint.index);
  byte[] script=getScript().getScriptBytes();
  writer.putCompactInt(script.length);
  writer.putBytes(script);
  writer.putIntLE(sequence);
}"
90987,"public byte[] getUnmalleableBytes(){
  byte[] scriptBytes=script.getUnmalleableBytes();
  if (scriptBytes == null) {
    return null;
  }
  ByteWriter writer=new ByteWriter(32 + 4 + scriptBytes.length+ 4);
  writer.putSha256Hash(outPoint.hash,true);
  writer.putIntLE(outPoint.index);
  writer.putBytes(scriptBytes);
  writer.putIntLE(sequence);
  return writer.toBytes();
}","public byte[] getUnmalleableBytes(){
  byte[] scriptBytes=script.getUnmalleableBytes();
  if (scriptBytes == null) {
    return null;
  }
  ByteWriter writer=new ByteWriter(32 + 4 + scriptBytes.length+ 4);
  writer.putSha256Hash(outPoint.txid,true);
  writer.putIntLE(outPoint.index);
  writer.putBytes(scriptBytes);
  writer.putIntLE(sequence);
  return writer.toBytes();
}"
90988,"@Override public int hashCode(){
  return outPoint.hash.hashCode() + outPoint.index;
}","@Override public int hashCode(){
  return outPoint.txid.hashCode() + outPoint.index;
}"
90989,"@Override public String toString(){
  return ""String_Node_Str"" + outPoint.hash + ':'+ outPoint.index+ ""String_Node_Str""+ script.getScriptBytes().length;
}","@Override public String toString(){
  return ""String_Node_Str"" + outPoint.txid + ':'+ outPoint.index+ ""String_Node_Str""+ script.getScriptBytes().length;
}"
90990,"@Override public int hashCode(){
  return outPoint.hash.hashCode() + outPoint.index;
}","@Override public int hashCode(){
  return outPoint.txid.hashCode() + outPoint.index;
}"
90991,"/** 
 * takes 32 bytes and stores them as hash. does not actually hash, this is done in HashUtils
 * @param bytes to be stored
 */
public static Sha256Hash of(byte[] bytes){
  return new Sha256Hash(bytes);
}","/** 
 * takes 32 bytes and stores them as hash. does not actually txid, this is done in HashUtils
 * @param bytes to be stored
 */
public static Sha256Hash of(byte[] bytes){
  return new Sha256Hash(bytes);
}"
90992,"/** 
 * Takes 64 bytes and stores them as hash. does not actually hash, this is done in HashUtils
 * @param bytes to be stored
 */
public static Sha512Hash of(byte[] bytes){
  return new Sha512Hash(bytes);
}","/** 
 * Takes 64 bytes and stores them as hash. does not actually txid, this is done in HashUtils
 * @param bytes to be stored
 */
public static Sha512Hash of(byte[] bytes){
  return new Sha512Hash(bytes);
}"
90993,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
switch (requestCode) {
case IMPORT_WORDLIST:
    if (resultCode != RESULT_OK) {
      initMasterSeed();
      return;
    }
  UUID accountid=(UUID)data.getSerializableExtra(AddAccountActivity.RESULT_KEY);
WalletAccount account=_mbwManager.getWalletManager(false).getAccount(accountid);
String defaultName=getString(R.string.account) + ""String_Node_Str"" + (((Bip44Account)account).getAccountIndex() + 1);
_mbwManager.getMetadataStorage().storeAccountLabel(accountid,defaultName);
delayedFinish.run();
return;
case StringHandlerActivity.IMPORT_ENCRYPTED_BIP38_PRIVATE_KEY_CODE:
String content=data.getStringExtra(""String_Node_Str"");
if (content != null) {
InMemoryPrivateKey key=InMemoryPrivateKey.fromBase58String(content,_mbwManager.getNetwork()).get();
UUID onTheFlyAccount=MbwManager.getInstance(this).createOnTheFlyAccount(key);
SendInitializationActivity.callMe(this,onTheFlyAccount,true);
finish();
return;
}
case REQUEST_FROM_URI:
if (resultCode == RESULT_OK) {
Bundle extras=Preconditions.checkNotNull(data.getExtras());
for (String key : extras.keySet()) {
if (!key.equals(Constants.TRANSACTION_HASH_INTENT_KEY)) {
data.removeExtra(key);
}
}
setResult(RESULT_OK,data);
}
 else {
setResult(RESULT_CANCELED);
}
break;
default :
setResult(RESULT_CANCELED);
}
finish();
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
switch (requestCode) {
case IMPORT_WORDLIST:
    if (resultCode != RESULT_OK) {
      initMasterSeed();
      return;
    }
  UUID accountid=(UUID)data.getSerializableExtra(AddAccountActivity.RESULT_KEY);
WalletAccount account=_mbwManager.getWalletManager(false).getAccount(accountid);
String defaultName=getString(R.string.account) + ""String_Node_Str"" + (((Bip44Account)account).getAccountIndex() + 1);
_mbwManager.getMetadataStorage().storeAccountLabel(accountid,defaultName);
delayedFinish.run();
return;
case StringHandlerActivity.IMPORT_ENCRYPTED_BIP38_PRIVATE_KEY_CODE:
String content=data.getStringExtra(""String_Node_Str"");
if (content != null) {
InMemoryPrivateKey key=InMemoryPrivateKey.fromBase58String(content,_mbwManager.getNetwork()).get();
UUID onTheFlyAccount=MbwManager.getInstance(this).createOnTheFlyAccount(key);
SendInitializationActivity.callMe(this,onTheFlyAccount,true);
finish();
return;
}
case REQUEST_FROM_URI:
if (resultCode == RESULT_OK) {
Bundle extras=Preconditions.checkNotNull(data.getExtras());
for (String key : extras.keySet()) {
if (!key.equals(Constants.TRANSACTION_ID_INTENT_KEY)) {
data.removeExtra(key);
}
}
setResult(RESULT_OK,data);
}
 else {
setResult(RESULT_CANCELED);
}
break;
default :
setResult(RESULT_CANCELED);
}
finish();
}"
90994,"private void setResultOkay(){
  if (_transactionLabel != null) {
    _mbwManager.getMetadataStorage().storeTransactionLabel(_transaction.getHash(),_transactionLabel);
  }
  Intent result=new Intent().putExtra(Constants.TRANSACTION_FIAT_VALUE_KEY,_fiatValue).putExtra(Constants.TRANSACTION_HASH_INTENT_KEY,_transaction.getHash().toString());
  setResult(RESULT_OK,result);
}","private void setResultOkay(){
  if (_transactionLabel != null) {
    _mbwManager.getMetadataStorage().storeTransactionLabel(_transaction.getId(),_transactionLabel);
  }
  Intent result=new Intent().putExtra(Constants.TRANSACTION_FIAT_VALUE_KEY,_fiatValue).putExtra(Constants.TRANSACTION_ID_INTENT_KEY,_transaction.getId().toString());
  setResult(RESULT_OK,result);
}"
90995,"public void onActivityResult(final int requestCode,final int resultCode,final Intent intent){
  Log.d(TAG,""String_Node_Str"" + requestCode + ""String_Node_Str""+ resultCode);
  if (requestCode == SCAN_RESULT_CODE) {
    if (resultCode != RESULT_OK) {
      if (intent != null) {
        String error=intent.getStringExtra(StringHandlerActivity.RESULT_ERROR);
        if (error != null) {
          makeText(this,error,LENGTH_LONG).show();
        }
      }
    }
 else {
      StringHandlerActivity.ResultType type=(StringHandlerActivity.ResultType)intent.getSerializableExtra(StringHandlerActivity.RESULT_TYPE_KEY);
      if (type == StringHandlerActivity.ResultType.PRIVATE_KEY) {
        InMemoryPrivateKey key=StringHandlerActivity.getPrivateKey(intent);
        _receivingAddress=key.getPublicKey().toAddress(_mbwManager.getNetwork());
      }
 else       if (type == StringHandlerActivity.ResultType.ADDRESS) {
        _receivingAddress=StringHandlerActivity.getAddress(intent);
      }
 else       if (type == StringHandlerActivity.ResultType.URI_WITH_ADDRESS) {
        BitcoinUriWithAddress uri=StringHandlerActivity.getUriWithAddress(intent);
        if (uri.callbackURL != null) {
          _bitcoinUri=uri;
          _paymentFetched=false;
          verifyPaymentRequest(_bitcoinUri);
          return;
        }
        _receivingAddress=uri.address;
        _transactionLabel=uri.label;
        if (uri.amount != null && uri.amount > 0) {
          if (!CurrencyValue.isNullOrZero(_amountToSend)) {
            makeText(this,R.string.amount_changed,LENGTH_LONG).show();
          }
          setAmountToSend(ExactBitcoinValue.from(uri.amount));
        }
      }
 else       if (type == StringHandlerActivity.ResultType.URI) {
        BitcoinUri uri=StringHandlerActivity.getUri(intent);
        if (uri.callbackURL != null) {
          _bitcoinUri=uri;
          _paymentFetched=false;
          verifyPaymentRequest(_bitcoinUri);
          return;
        }
      }
 else       if (type == StringHandlerActivity.ResultType.HD_NODE) {
        setReceivingAddressFromKeynode(StringHandlerActivity.getHdKeyNode(intent));
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + type.toString());
      }
    }
    _transactionStatus=tryCreateUnsignedTransaction();
    updateUi();
  }
 else   if (requestCode == ADDRESS_BOOK_RESULT_CODE && resultCode == RESULT_OK) {
    String s=Preconditions.checkNotNull(intent.getStringExtra(AddressBookFragment.ADDRESS_RESULT_NAME));
    String result=s.trim();
    Address address=Address.fromString(result,_mbwManager.getNetwork());
    if (address == null) {
      return;
    }
    _receivingAddress=address;
    if (intent.getExtras().containsKey(AddressBookFragment.ADDRESS_RESULT_LABEL)) {
      _receivingLabel=intent.getStringExtra(AddressBookFragment.ADDRESS_RESULT_LABEL);
    }
    _transactionStatus=tryCreateUnsignedTransaction();
    updateUi();
  }
 else   if (requestCode == MANUAL_ENTRY_RESULT_CODE && resultCode == RESULT_OK) {
    _receivingAddress=Preconditions.checkNotNull((Address)intent.getSerializableExtra(ManualAddressEntry.ADDRESS_RESULT_NAME));
    _transactionStatus=tryCreateUnsignedTransaction();
    updateUi();
  }
 else   if (requestCode == GET_AMOUNT_RESULT_CODE && resultCode == RESULT_OK) {
    CurrencyValue enteredAmount=(CurrencyValue)intent.getSerializableExtra(GetAmountActivity.AMOUNT);
    setAmountToSend(enteredAmount);
    if (!CurrencyValue.isNullOrZero(_amountToSend)) {
      _transactionStatus=tryCreateUnsignedTransaction();
    }
    updateUi();
  }
 else   if (requestCode == SIGN_TRANSACTION_REQUEST_CODE) {
    if (resultCode == RESULT_OK) {
      _signedTransaction=(Transaction)Preconditions.checkNotNull(intent.getSerializableExtra(""String_Node_Str""));
      if (_paymentRequestHandler != null && _paymentRequestHandler.getPaymentRequestInformation().hasPaymentCallbackUrl()) {
        if (!_paymentRequestHandler.getPaymentRequestInformation().isExpired()) {
          _paymentRequestHandler.sendResponse(_signedTransaction,_account.getReceivingAddress().get());
        }
 else {
          makeText(this,getString(R.string.payment_request_not_sent_expired),LENGTH_LONG).show();
        }
      }
 else {
        BroadcastTransactionActivity.callMe(this,_account.getId(),_isColdStorage,_signedTransaction,_transactionLabel,getFiatValue(),BROADCAST_REQUEST_CODE);
      }
    }
  }
 else   if (requestCode == BROADCAST_REQUEST_CODE) {
    if (resultCode == RESULT_OK) {
      transactionFiatValuePref.edit().putString(intent.getStringExtra(Constants.TRANSACTION_HASH_INTENT_KEY),intent.getStringExtra(Constants.TRANSACTION_FIAT_VALUE_KEY)).apply();
    }
    this.setResult(resultCode,intent);
    finish();
  }
 else   if (requestCode == REQUEST_PAYMENT_HANDLER) {
    if (resultCode == RESULT_OK) {
      _paymentRequestHandlerUuid=Preconditions.checkNotNull(intent.getStringExtra(""String_Node_Str""));
      if (_paymentRequestHandlerUuid != null) {
        _paymentRequestHandler=(PaymentRequestHandler)_mbwManager.getBackgroundObjectsCache().getIfPresent(_paymentRequestHandlerUuid);
      }
 else {
        _paymentRequestHandler=null;
      }
      _transactionStatus=tryCreateUnsignedTransaction();
      updateUi();
    }
 else {
      setResult(RESULT_CANCELED);
      finish();
    }
  }
 else   if (requestCode == REQUET_BTC_ACCOUNT) {
    if (resultCode == RESULT_OK) {
      UUID id=(UUID)intent.getSerializableExtra(AddressBookFragment.ADDRESS_RESULT_ID);
      fundColuAccount=_mbwManager.getWalletManager(false).getAccount(id);
    }
  }
 else {
    super.onActivityResult(requestCode,resultCode,intent);
  }
}","public void onActivityResult(final int requestCode,final int resultCode,final Intent intent){
  Log.d(TAG,""String_Node_Str"" + requestCode + ""String_Node_Str""+ resultCode);
  if (requestCode == SCAN_RESULT_CODE) {
    if (resultCode != RESULT_OK) {
      if (intent != null) {
        String error=intent.getStringExtra(StringHandlerActivity.RESULT_ERROR);
        if (error != null) {
          makeText(this,error,LENGTH_LONG).show();
        }
      }
    }
 else {
      StringHandlerActivity.ResultType type=(StringHandlerActivity.ResultType)intent.getSerializableExtra(StringHandlerActivity.RESULT_TYPE_KEY);
      if (type == StringHandlerActivity.ResultType.PRIVATE_KEY) {
        InMemoryPrivateKey key=StringHandlerActivity.getPrivateKey(intent);
        _receivingAddress=key.getPublicKey().toAddress(_mbwManager.getNetwork());
      }
 else       if (type == StringHandlerActivity.ResultType.ADDRESS) {
        _receivingAddress=StringHandlerActivity.getAddress(intent);
      }
 else       if (type == StringHandlerActivity.ResultType.URI_WITH_ADDRESS) {
        BitcoinUriWithAddress uri=StringHandlerActivity.getUriWithAddress(intent);
        if (uri.callbackURL != null) {
          _bitcoinUri=uri;
          _paymentFetched=false;
          verifyPaymentRequest(_bitcoinUri);
          return;
        }
        _receivingAddress=uri.address;
        _transactionLabel=uri.label;
        if (uri.amount != null && uri.amount > 0) {
          if (!CurrencyValue.isNullOrZero(_amountToSend)) {
            makeText(this,R.string.amount_changed,LENGTH_LONG).show();
          }
          setAmountToSend(ExactBitcoinValue.from(uri.amount));
        }
      }
 else       if (type == StringHandlerActivity.ResultType.URI) {
        BitcoinUri uri=StringHandlerActivity.getUri(intent);
        if (uri.callbackURL != null) {
          _bitcoinUri=uri;
          _paymentFetched=false;
          verifyPaymentRequest(_bitcoinUri);
          return;
        }
      }
 else       if (type == StringHandlerActivity.ResultType.HD_NODE) {
        setReceivingAddressFromKeynode(StringHandlerActivity.getHdKeyNode(intent));
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + type.toString());
      }
    }
    _transactionStatus=tryCreateUnsignedTransaction();
    updateUi();
  }
 else   if (requestCode == ADDRESS_BOOK_RESULT_CODE && resultCode == RESULT_OK) {
    String s=Preconditions.checkNotNull(intent.getStringExtra(AddressBookFragment.ADDRESS_RESULT_NAME));
    String result=s.trim();
    Address address=Address.fromString(result,_mbwManager.getNetwork());
    if (address == null) {
      return;
    }
    _receivingAddress=address;
    if (intent.getExtras().containsKey(AddressBookFragment.ADDRESS_RESULT_LABEL)) {
      _receivingLabel=intent.getStringExtra(AddressBookFragment.ADDRESS_RESULT_LABEL);
    }
    _transactionStatus=tryCreateUnsignedTransaction();
    updateUi();
  }
 else   if (requestCode == MANUAL_ENTRY_RESULT_CODE && resultCode == RESULT_OK) {
    _receivingAddress=Preconditions.checkNotNull((Address)intent.getSerializableExtra(ManualAddressEntry.ADDRESS_RESULT_NAME));
    _transactionStatus=tryCreateUnsignedTransaction();
    updateUi();
  }
 else   if (requestCode == GET_AMOUNT_RESULT_CODE && resultCode == RESULT_OK) {
    CurrencyValue enteredAmount=(CurrencyValue)intent.getSerializableExtra(GetAmountActivity.AMOUNT);
    setAmountToSend(enteredAmount);
    if (!CurrencyValue.isNullOrZero(_amountToSend)) {
      _transactionStatus=tryCreateUnsignedTransaction();
    }
    updateUi();
  }
 else   if (requestCode == SIGN_TRANSACTION_REQUEST_CODE) {
    if (resultCode == RESULT_OK) {
      _signedTransaction=(Transaction)Preconditions.checkNotNull(intent.getSerializableExtra(""String_Node_Str""));
      if (_paymentRequestHandler != null && _paymentRequestHandler.getPaymentRequestInformation().hasPaymentCallbackUrl()) {
        if (!_paymentRequestHandler.getPaymentRequestInformation().isExpired()) {
          _paymentRequestHandler.sendResponse(_signedTransaction,_account.getReceivingAddress().get());
        }
 else {
          makeText(this,getString(R.string.payment_request_not_sent_expired),LENGTH_LONG).show();
        }
      }
 else {
        BroadcastTransactionActivity.callMe(this,_account.getId(),_isColdStorage,_signedTransaction,_transactionLabel,getFiatValue(),BROADCAST_REQUEST_CODE);
      }
    }
  }
 else   if (requestCode == BROADCAST_REQUEST_CODE) {
    if (resultCode == RESULT_OK) {
      transactionFiatValuePref.edit().putString(intent.getStringExtra(Constants.TRANSACTION_ID_INTENT_KEY),intent.getStringExtra(Constants.TRANSACTION_FIAT_VALUE_KEY)).apply();
    }
    this.setResult(resultCode,intent);
    finish();
  }
 else   if (requestCode == REQUEST_PAYMENT_HANDLER) {
    if (resultCode == RESULT_OK) {
      _paymentRequestHandlerUuid=Preconditions.checkNotNull(intent.getStringExtra(""String_Node_Str""));
      if (_paymentRequestHandlerUuid != null) {
        _paymentRequestHandler=(PaymentRequestHandler)_mbwManager.getBackgroundObjectsCache().getIfPresent(_paymentRequestHandlerUuid);
      }
 else {
        _paymentRequestHandler=null;
      }
      _transactionStatus=tryCreateUnsignedTransaction();
      updateUi();
    }
 else {
      setResult(RESULT_CANCELED);
      finish();
    }
  }
 else   if (requestCode == REQUET_BTC_ACCOUNT) {
    if (resultCode == RESULT_OK) {
      UUID id=(UUID)intent.getSerializableExtra(AddressBookFragment.ADDRESS_RESULT_ID);
      fundColuAccount=_mbwManager.getWalletManager(false).getAccount(id);
    }
  }
 else {
    super.onActivityResult(requestCode,resultCode,intent);
  }
}"
90996,"@Override public List<TransactionEx> getTransactionHistory(int offset,int limit){
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str"",new String[]{Integer.toString(limit),Integer.toString(offset)});
    while (cursor.moveToNext()) {
      TransactionEx tex=new TransactionEx(new Sha256Hash(cursor.getBlob(0)),cursor.getInt(1),cursor.getInt(2),cursor.getBlob(3));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override public List<TransactionEx> getTransactionHistory(int offset,int limit){
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str"",new String[]{Integer.toString(limit),Integer.toString(offset)});
    while (cursor.moveToNext()) {
      Sha256Hash txid=new Sha256Hash(cursor.getBlob(0));
      TransactionEx tex=new TransactionEx(txid,txid,cursor.getInt(1),cursor.getInt(2),cursor.getBlob(3));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}"
90997,"private void putReferencedOutputs(byte[] rawTx){
  try {
    final Transaction transaction=Transaction.fromBytes(rawTx);
    final List<OutPoint> refersOutpoint=new ArrayList<>();
    for (    TransactionInput input : transaction.inputs) {
      refersOutpoint.add(input.outPoint);
    }
    putTxRefersParentTransaction(transaction.getHash(),refersOutpoint);
  }
 catch (  Transaction.TransactionParsingException e) {
    Log.w(LOG_TAG,""String_Node_Str"" + e.getMessage());
  }
}","private void putReferencedOutputs(byte[] rawTx){
  try {
    final Transaction transaction=Transaction.fromBytes(rawTx);
    final List<OutPoint> refersOutpoint=new ArrayList<>();
    for (    TransactionInput input : transaction.inputs) {
      refersOutpoint.add(input.outPoint);
    }
    putTxRefersParentTransaction(transaction.getId(),refersOutpoint);
  }
 catch (  Transaction.TransactionParsingException e) {
    Log.w(LOG_TAG,""String_Node_Str"" + e.getMessage());
  }
}"
90998,"@Override public Collection<TransactionEx> getYoungTransactions(int maxConfirmations,int blockChainHeight){
  int maxHeight=blockChainHeight - maxConfirmations + 1;
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str"",new String[]{Integer.toString(maxHeight)});
    while (cursor.moveToNext()) {
      int height=cursor.getInt(1);
      if (height == Integer.MAX_VALUE) {
        height=-1;
      }
      TransactionEx tex=new TransactionEx(new Sha256Hash(cursor.getBlob(0)),height,cursor.getInt(2),cursor.getBlob(3));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override public Collection<TransactionEx> getYoungTransactions(int maxConfirmations,int blockChainHeight){
  int maxHeight=blockChainHeight - maxConfirmations + 1;
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str"",new String[]{Integer.toString(maxHeight)});
    while (cursor.moveToNext()) {
      int height=cursor.getInt(1);
      if (height == Integer.MAX_VALUE) {
        height=-1;
      }
      Sha256Hash txid=new Sha256Hash(cursor.getBlob(0));
      TransactionEx tex=new TransactionEx(txid,txid,height,cursor.getInt(2),cursor.getBlob(3));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}"
90999,"@Override public List<TransactionEx> getTransactionsSince(long since){
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str""+ ""String_Node_Str"",new String[]{Long.toString(since / 1000)});
    while (cursor.moveToNext()) {
      TransactionEx tex=new TransactionEx(new Sha256Hash(cursor.getBlob(0)),cursor.getInt(1),cursor.getInt(2),cursor.getBlob(3));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override public List<TransactionEx> getTransactionsSince(long since){
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str""+ ""String_Node_Str"",new String[]{Long.toString(since / 1000)});
    while (cursor.moveToNext()) {
      Sha256Hash txid=new Sha256Hash(cursor.getBlob(0));
      TransactionEx tex=new TransactionEx(txid,txid,cursor.getInt(1),cursor.getInt(2),cursor.getBlob(3));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}"
91000,"@Override public TransactionEx getTransaction(Sha256Hash hash){
  Cursor cursor=null;
  try {
    SQLiteQueryWithBlobs blobQuery=new SQLiteQueryWithBlobs(_db);
    blobQuery.bindBlob(1,hash.getBytes());
    cursor=blobQuery.query(false,txTableName,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",null,null,null,null,null);
    if (cursor.moveToNext()) {
      int height=cursor.getInt(0);
      if (height == Integer.MAX_VALUE) {
        height=-1;
      }
      return new TransactionEx(hash,height,cursor.getInt(1),cursor.getBlob(2));
    }
    return null;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override public TransactionEx getTransaction(Sha256Hash txid){
  Cursor cursor=null;
  try {
    SQLiteQueryWithBlobs blobQuery=new SQLiteQueryWithBlobs(_db);
    blobQuery.bindBlob(1,txid.getBytes());
    cursor=blobQuery.query(false,txTableName,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",null,null,null,null,null);
    if (cursor.moveToNext()) {
      int height=cursor.getInt(0);
      if (height == Integer.MAX_VALUE) {
        height=-1;
      }
      return new TransactionEx(txid,txid,height,cursor.getInt(1),cursor.getBlob(2));
    }
    return null;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}"
