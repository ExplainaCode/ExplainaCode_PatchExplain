record_number,buggy_code,fixed_code
76001,"/** 
 * Create a new effigy in the given container by reading the specified URL. If the specified URL is null, then create a blank effigy. The blank effigy will have a new model associated with it. If this effigy factory contains an entity named ""blank"", then the new model will be a clone of that entity.  Otherwise, it will be an instance of TypedCompositeActor. If the URL does not end with extension "".xml"" or "".moml"", then return null.  If the URL points to an XML file that is not a MoML file, then also return null. The specified base is used to expand any relative file references within the URL.
 * @param container The container for the effigy.
 * @param base The base for relative file references, or null ifthere are no relative file references.
 * @param in The input URL.
 * @return A new instance of PtolemyEffigy, or null if the URLdoes not specify a Ptolemy II model.
 * @exception Exception If the URL cannot be read, or if the datais malformed in some way.
 */
public Effigy createEffigy(CompositeEntity container,URL base,URL in) throws Exception {
  if (in == null) {
    PtolemyEffigy effigy=new PtolemyEffigy(container,container.uniqueName(""String_Node_Str""));
    NamedObj entity=getEntity(""String_Node_Str"");
    if (entity != null) {
      effigy.setModel((NamedObj)entity.clone(new Workspace()));
    }
 else {
      effigy.setModel(new TypedCompositeActor(new Workspace()));
    }
    return effigy;
  }
 else {
    String extension=getExtension(in);
    if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str"")) {
      return null;
    }
    NamedObj toplevel=_parser.parse(base,in.openStream());
    if (toplevel != null) {
      PtolemyEffigy effigy=new PtolemyEffigy(container,container.uniqueName(""String_Node_Str""));
      effigy.setModel(toplevel);
      URLAttribute url=new URLAttribute(toplevel,toplevel.uniqueName(""String_Node_Str""));
      url.setURL(in);
      effigy.url.setURL(in);
      return effigy;
    }
    return null;
  }
}","/** 
 * Create a new effigy in the given container by reading the specified URL. If the specified URL is null, then create a blank effigy. The blank effigy will have a new model associated with it. If this effigy factory contains an entity named ""blank"", then the new model will be a clone of that entity.  Otherwise, it will be an instance of TypedCompositeActor. If the URL does not end with extension "".xml"" or "".moml"", then return null.  If the URL points to an XML file that is not a MoML file, then also return null. The specified base is used to expand any relative file references within the URL.
 * @param container The container for the effigy.
 * @param base The base for relative file references, or null ifthere are no relative file references.
 * @param in The input URL.
 * @return A new instance of PtolemyEffigy, or null if the URLdoes not specify a Ptolemy II model.
 * @exception Exception If the URL cannot be read, or if the datais malformed in some way.
 */
public Effigy createEffigy(CompositeEntity container,URL base,URL in) throws Exception {
  if (in == null) {
    PtolemyEffigy effigy=new PtolemyEffigy(container,container.uniqueName(""String_Node_Str""));
    NamedObj entity=getEntity(""String_Node_Str"");
    if (entity != null) {
      effigy.setModel((NamedObj)entity.clone(new Workspace()));
    }
 else {
      effigy.setModel(new TypedCompositeActor(new Workspace()));
    }
    return effigy;
  }
 else {
    String extension=getExtension(in);
    if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str"")) {
      return null;
    }
    _parser.reset();
    NamedObj toplevel=_parser.parse(base,in.openStream());
    if (toplevel != null) {
      PtolemyEffigy effigy=new PtolemyEffigy(container,container.uniqueName(""String_Node_Str""));
      effigy.setModel(toplevel);
      URLAttribute url=new URLAttribute(toplevel,toplevel.uniqueName(""String_Node_Str""));
      url.setURL(in);
      effigy.url.setURL(in);
      return effigy;
    }
    return null;
  }
}"
76002,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). This uses the clone() method of java.lang.Object, which makes a field-by-field copy. It then adjusts the workspace reference and clones the attributes on the attribute list, if there is one. In addition, if this object has the MoML element name ""class"", as determined by getMoMLElementName(), then the new object will not export its contents when exportMoML() is called, but rather will declare that it extends this one, and will export only its attributes. This method read-synchronizes on the workspace.
 * @param ws The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #getMoMLElementName()
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  try {
    _workspace.getReadAccess();
    NamedObj newobj=(NamedObj)super.clone();
    newobj._attributes=null;
    newobj._workspace=ws;
    newobj._fullNameVersion=-1;
    newobj._changeListeners=new LinkedList();
    Iterator params=attributeList().iterator();
    while (params.hasNext()) {
      Attribute p=(Attribute)params.next();
      Attribute np=(Attribute)p.clone(ws);
      try {
        np.setContainer(newobj);
      }
 catch (      KernelException ex) {
        throw new CloneNotSupportedException(""String_Node_Str"" + getFullName() + ""String_Node_Str""+ ex.getMessage());
      }
    }
    if (_debugging) {
      if (ws == null) {
        _debug(""String_Node_Str"",getFullName(),""String_Node_Str"");
      }
 else {
        _debug(""String_Node_Str"",getFullName(),""String_Node_Str"",ws.getFullName());
      }
    }
    if (getMoMLElementName().equals(""String_Node_Str"")) {
      newobj._setDeferMoMLDefinitionTo(this);
    }
    return newobj;
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). This uses the clone() method of java.lang.Object, which makes a field-by-field copy. It then adjusts the workspace reference and clones the attributes on the attribute list, if there is one. In addition, if this object has the MoML element name ""class"", as determined by getMoMLElementName(), then the new object will not export its contents when exportMoML() is called, but rather will declare that it extends this one, and will export only its attributes. This method read-synchronizes on the workspace.
 * @param ws The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #getMoMLElementName()
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  try {
    _workspace.getReadAccess();
    NamedObj newobj=(NamedObj)super.clone();
    newobj._attributes=null;
    newobj._workspace=ws;
    newobj._fullNameVersion=-1;
    newobj._changeListeners=new LinkedList();
    newobj._deferredFrom=null;
    if (_deferTo != null) {
      _deferTo._deferredFrom.add(newobj);
    }
    Iterator params=attributeList().iterator();
    while (params.hasNext()) {
      Attribute p=(Attribute)params.next();
      Attribute np=(Attribute)p.clone(ws);
      try {
        np.setContainer(newobj);
      }
 catch (      KernelException ex) {
        throw new CloneNotSupportedException(""String_Node_Str"" + getFullName() + ""String_Node_Str""+ ex.getMessage());
      }
    }
    if (_debugging) {
      if (ws == null) {
        _debug(""String_Node_Str"",getFullName(),""String_Node_Str"");
      }
 else {
        _debug(""String_Node_Str"",getFullName(),""String_Node_Str"",ws.getFullName());
      }
    }
    if (getMoMLElementName().equals(""String_Node_Str"")) {
      newobj._setDeferMoMLDefinitionTo(this);
    }
    return newobj;
  }
  finally {
    _workspace.doneReading();
  }
}"
76003,"/** 
 * Calculate the function on the given argument.
 * @param in The input value.
 * @return The result of applying the function.
 */
private double _doFunction(double in1,double in2){
  double result;
switch (_function) {
case EXP:
    result=Math.exp(in1);
  break;
case LOG:
result=Math.log(in1);
break;
case SQUARE:
result=in1 * in1;
break;
case SQRT:
result=Math.sqrt(in1);
break;
case REMAINDER:
result=in1 % in2;
break;
default :
throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + getFullName() + ""String_Node_Str"");
}
return result;
}","/** 
 * Calculate the function on the given argument.
 * @param in The input value.
 * @return The result of applying the function.
 */
private double _doFunction(double input1,double input2){
  double result;
switch (_function) {
case EXP:
    result=Math.exp(input1);
  break;
case LOG:
result=Math.log(input1);
break;
case SQUARE:
result=input1 * input1;
break;
case SQRT:
result=Math.sqrt(input1);
break;
case REMAINDER:
result=input1 % input2;
break;
default :
throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + getFullName() + ""String_Node_Str"");
}
return result;
}"
76004,"/** 
 * Compute the specified math function of the input. Consumes at most one token on each input port during firing. If there is no input, then produce no output.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  if (firstOperand.hasToken(0)) {
    double in1=((DoubleToken)firstOperand.get(0)).doubleValue();
    double in2=0;
    if (_function == REMAINDER) {
      if (secondOperand.hasToken(0)) {
        in2=((DoubleToken)secondOperand.get(0)).doubleValue();
      }
    }
    output.send(0,new DoubleToken(_doFunction(in1,in2)));
  }
}","/** 
 * Compute the specified math function of the input. Consumes at most one token on each input port during firing. If there is no input, then produce no output.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  if (firstOperand.hasToken(0)) {
    double input1=((DoubleToken)firstOperand.get(0)).doubleValue();
    double input2=0;
    if (_function == REMAINDER) {
      if (secondOperand.hasToken(0)) {
        input2=((DoubleToken)secondOperand.get(0)).doubleValue();
      }
    }
    output.send(0,new DoubleToken(_doFunction(input1,input2)));
  }
}"
76005,"/** 
 * Invoke a specified number of iterations of this actor. Each iteration computes the math function specified by the <i>function</i> parameter on a single token. An invocation of this method therefore applies the function to <i>count</i> successive input tokens. <p> This method should be called instead of the usual prefire(), fire(), postfire() methods when this actor is used in a domain that supports vectorized actors.  This leads to more efficient execution.
 * @param count The number of iterations to perform.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, return NOT_READY, and do not consume any input tokens.
 * @exception IllegalActionException Should not be thrown
 */
public int iterate(int count) throws IllegalActionException {
  if (count > _resultArray.length) {
    _resultArray=new DoubleToken[count];
  }
  if (firstOperand.hasToken(0,count)) {
    Token[] inArray1=firstOperand.get(0,count);
    if (_function == REMAINDER) {
      if (secondOperand.hasToken(0,count)) {
        Token[] inArray2=secondOperand.get(0,count);
        for (int i=0; i < count; i++) {
          double input1=((DoubleToken)(inArray1[i])).doubleValue();
          double input2=((DoubleToken)(inArray2[i])).doubleValue();
          _resultArray[i]=new DoubleToken(_doFunction(input1,input2));
        }
        output.send(0,_resultArray,count);
        return COMPLETED;
      }
 else {
        return NOT_READY;
      }
    }
 else {
      for (int i=0; i < count; i++) {
        double input1=((DoubleToken)(inArray1[i])).doubleValue();
        _resultArray[i]=new DoubleToken(_doFunction(input1,0));
      }
      output.send(0,_resultArray,count);
      return COMPLETED;
    }
  }
 else {
    return NOT_READY;
  }
}","/** 
 * Invoke a specified number of iterations of this actor. Each iteration computes the math function specified by the <i>function</i> parameter on a single token. An invocation of this method therefore applies the function to <i>count</i> successive input tokens. <p> This method should be called instead of the usual prefire(), fire(), postfire() methods when this actor is used in a domain that supports vectorized actors.  This leads to more efficient execution.
 * @param count The number of iterations to perform.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, return NOT_READY, and do not consume any input tokens.
 * @exception IllegalActionException Not thrown in this base class
 */
public int iterate(int count) throws IllegalActionException {
  if (count > _resultArray.length) {
    _resultArray=new DoubleToken[count];
  }
  if (firstOperand.hasToken(0,count)) {
    Token[] inArray1=firstOperand.get(0,count);
    if (_function == REMAINDER) {
      if (secondOperand.hasToken(0,count)) {
        Token[] inArray2=secondOperand.get(0,count);
        for (int i=0; i < count; i++) {
          double input1=((DoubleToken)(inArray1[i])).doubleValue();
          double input2=((DoubleToken)(inArray2[i])).doubleValue();
          _resultArray[i]=new DoubleToken(_doFunction(input1,input2));
        }
        output.send(0,_resultArray,count);
        return COMPLETED;
      }
 else {
        return NOT_READY;
      }
    }
 else {
      for (int i=0; i < count; i++) {
        double input1=((DoubleToken)(inArray1[i])).doubleValue();
        _resultArray[i]=new DoubleToken(_doFunction(input1,0));
      }
      output.send(0,_resultArray,count);
      return COMPLETED;
    }
  }
 else {
    return NOT_READY;
  }
}"
76006,"/** 
 * Construct a frame to control the specified Ptolemy II model. After constructing this, it is necessary to call setVisible(true) to make the frame appear. This creates an instance of ModelPane and puts it in a top-level window. This is typically done by calling show() on the controlling tableau.
 * @see ModelPane
 * @see Tableau#show()
 * @param model The model to put in this frame, or null if none.
 * @param tableau The tableau responsible for this frame, or null if none.
 */
public ModelFrame(CompositeActor model,Tableau tableau){
  super(model,tableau);
  _pane=new ModelPane(model);
  getContentPane().add(_pane,BorderLayout.CENTER);
  _pane.setDefaultButton();
}","/** 
 * Construct a frame to control the specified Ptolemy II model. After constructing this, it is necessary to call setVisible(true) to make the frame appear. This creates an instance of ModelPane and puts it in a top-level window. This is typically done by calling show() on the controlling tableau.
 * @see ModelPane
 * @see Tableau#show()
 * @param model The model to put in this frame, or null if none.
 * @param tableau The tableau responsible for this frame, or null if none.
 */
public ModelFrame(CompositeActor model,Tableau tableau){
  super(model,tableau);
  _pane=new ModelPane(model);
  getContentPane().add(_pane,BorderLayout.CENTER);
  Manager manager=model.getManager();
  if (manager != null) {
    manager.addExecutionListener(this);
  }
  _pane.setDefaultButton();
}"
76007,"/** 
 * Populate the actor by reading the file specified by the <i>source</i> parameter.  Note that the exception thrown here is a runtime exception, inappropriately.  This is because execution of this method is deferred to the last possible moment, and it is often evaluated in a context where a compile-time exception cannot be thrown.  Thus, extra care should be exercised to provide valid MoML specifications.
 * @exception InvalidStateException If the source cannot be read, or ifan exception is thrown parsing its MoML data.
 */
public void populate() throws InvalidStateException {
  try {
    if (_populating)     return;
    if (_cloning)     return;
    _populating=true;
    if (!_configureDone) {
      _configureDone=true;
      if (_parser == null) {
        _parser=new MoMLParser(workspace());
      }
      _parser.setContext(this);
      if (_source != null && !_source.equals(""String_Node_Str"")) {
        URL xmlFile=new URL(_base,_source);
        InputStream stream=xmlFile.openStream();
        _parser.parse(xmlFile,stream);
        stream.close();
      }
      if (_text != null && !_text.equals(""String_Node_Str"")) {
        String trimmed=_text.trim();
        if (trimmed.startsWith(""String_Node_Str"") && trimmed.endsWith(""String_Node_Str"")) {
          trimmed=trimmed.substring(2,trimmed.length() - 2).trim();
          if (trimmed.startsWith(""String_Node_Str"")) {
            trimmed=trimmed.substring(4).trim();
            _parser.parse(_base,trimmed);
          }
        }
 else {
          _parser.parse(_base,_text);
        }
      }
    }
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
    throw new InvalidStateException(this,ex.getMessage());
  }
 finally {
    _populating=false;
  }
}","/** 
 * Populate the actor by reading the file specified by the <i>source</i> parameter.  Note that the exception thrown here is a runtime exception, inappropriately.  This is because execution of this method is deferred to the last possible moment, and it is often evaluated in a context where a compile-time exception cannot be thrown.  Thus, extra care should be exercised to provide valid MoML specifications.
 * @exception InvalidStateException If the source cannot be read, or ifan exception is thrown parsing its MoML data.
 */
public void populate() throws InvalidStateException {
  try {
    if (_populating)     return;
    if (_cloning)     return;
    _populating=true;
    if (!_configureDone) {
      System.out.println(""String_Node_Str"");
      (new Exception()).printStackTrace();
      _configureDone=true;
      if (_parser == null) {
        _parser=new MoMLParser(workspace());
      }
      _parser.setContext(this);
      if (_source != null && !_source.equals(""String_Node_Str"")) {
        URL xmlFile=new URL(_base,_source);
        InputStream stream=xmlFile.openStream();
        _parser.parse(xmlFile,stream);
        stream.close();
      }
      if (_text != null && !_text.equals(""String_Node_Str"")) {
        String trimmed=_text.trim();
        if (trimmed.startsWith(""String_Node_Str"") && trimmed.endsWith(""String_Node_Str"")) {
          trimmed=trimmed.substring(2,trimmed.length() - 2).trim();
          if (trimmed.startsWith(""String_Node_Str"")) {
            trimmed=trimmed.substring(4).trim();
            _parser.parse(_base,trimmed);
          }
        }
 else {
          _parser.parse(_base,_text);
        }
      }
    }
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
    throw new InvalidStateException(this,ex.getMessage());
  }
 finally {
    _populating=false;
  }
}"
76008,"/** 
 * Returns a new RecordToken representing the additive identity. The returned token has the same set of labels as this one, and each field contains the additive identity of the corresponding field of this one.
 * @return An RecordToken.
 * @exception IllegalActionException If additive identity is notsupported by the element token.
 */
public Token zero() throws IllegalActionException {
  Set labelSet=_fields.keySet();
  int size=labelSet.size();
  String[] labels=new String[size];
  Token[] values=new Token[size];
  Iterator iter=labelSet.iterator();
  int i=0;
  while (iter.hasNext()) {
    labels[i]=(String)iter.next();
    values[i]=this.get(labels[i]).zero();
  }
  return new RecordToken(labels,values);
}","/** 
 * Returns a new RecordToken representing the additive identity. The returned token has the same set of labels as this one, and each field contains the additive identity of the corresponding field of this one.
 * @return An RecordToken.
 * @exception IllegalActionException If additive identity is notsupported by the element token.
 */
public Token zero() throws IllegalActionException {
  Object[] labelsObj=_fields.keySet().toArray();
  String[] labels=new String[labelsObj.length];
  Token[] values=new Token[labels.length];
  for (int i=0; i < labels.length; i++) {
    labels[i]=(String)labelsObj[i];
    values[i]=this.get(labels[i]).zero();
  }
  return new RecordToken(labels,values);
}"
76009,"/** 
 * Returns a new RecordToken representing the multiplicative identity. The returned token has the same set of labels as this one, and each field contains the multiplicative identity of the corresponding field of this one.
 * @return An RecordToken.
 * @exception IllegalActionException If multiplicative identity is notsupported by the element token.
 */
public Token one() throws IllegalActionException {
  Set labelSet=_fields.keySet();
  int size=labelSet.size();
  String[] labels=new String[size];
  Token[] values=new Token[size];
  Iterator iter=labelSet.iterator();
  int i=0;
  while (iter.hasNext()) {
    labels[i]=(String)iter.next();
    values[i]=this.get(labels[i]).one();
  }
  return new RecordToken(labels,values);
}","/** 
 * Returns a new RecordToken representing the multiplicative identity. The returned token has the same set of labels as this one, and each field contains the multiplicative identity of the corresponding field of this one.
 * @return An RecordToken.
 * @exception IllegalActionException If multiplicative identity is notsupported by the element token.
 */
public Token one() throws IllegalActionException {
  Object[] labelsObj=_fields.keySet().toArray();
  String[] labels=new String[labelsObj.length];
  Token[] values=new Token[labels.length];
  for (int i=0; i < labels.length; i++) {
    labels[i]=(String)labelsObj[i];
    values[i]=this.get(labels[i]).one();
  }
  return new RecordToken(labels,values);
}"
76010,"/** 
 * Convert the argument token into a RecordToken having this type, if losslessly conversion can be done.  The argument must be an RecordToken, and its type must be a subtype of this record type. If this type is a variable, convert the the argument into a substitution instance of this variable.
 * @param t A token.
 * @return An RecordToken.
 * @exception IllegalActionException If lossless conversioncannot be done.
 */
public Token convert(Token t) throws IllegalActionException {
  if (!isCompatible(t)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  RecordToken argRecTok=(RecordToken)t;
  String[] labels=(String[])_fields.keySet().toArray();
  Token[] values=new Token[labels.length];
  for (int i=0; i < labels.length; i++) {
    Token orgToken=argRecTok.get(labels[i]);
    FieldType fieldType=(FieldType)_fields.get(labels[i]);
    Type type=fieldType._resolvedType;
    values[i]=type.convert(orgToken);
  }
  return new RecordToken(labels,values);
}","/** 
 * Convert the argument token into a RecordToken having this type, if losslessly conversion can be done.  The argument must be an RecordToken, and its type must be a subtype of this record type. If this type is a variable, convert the the argument into a substitution instance of this variable.
 * @param t A token.
 * @return An RecordToken.
 * @exception IllegalActionException If lossless conversioncannot be done.
 */
public Token convert(Token t) throws IllegalActionException {
  if (!isCompatible(t)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + t.toString() + ""String_Node_Str""+ this.toString());
  }
  RecordToken argRecTok=(RecordToken)t;
  Object[] labelsObj=_fields.keySet().toArray();
  String[] labels=new String[labelsObj.length];
  Token[] values=new Token[labelsObj.length];
  for (int i=0; i < labelsObj.length; i++) {
    labels[i]=(String)labelsObj[i];
    Token orgToken=argRecTok.get(labels[i]);
    FieldType fieldType=(FieldType)_fields.get(labels[i]);
    Type type=fieldType._resolvedType;
    values[i]=type.convert(orgToken);
  }
  return new RecordToken(labels,values);
}"
76011,"/** 
 * Test if the argument token is compatible with this type. If this type is a constant, the argument is compatible if it can be converted losslessly to a token of this type; If this type is a variable, the argument is compatible if its type is a substitution instance of this type, or if it can be converted losslessly to a substitution instance of this type. 
 * @param t A Token.
 * @return True if the argument is compatible with this type.
 */
public boolean isCompatible(Token t){
  if (!(t.getType() instanceof RecordToken)) {
    return false;
  }
  RecordToken argRecTok=(RecordToken)t;
  Iterator iter=_fields.keySet().iterator();
  while (iter.hasNext()) {
    String label=(String)iter.next();
    if (argRecTok.get(label) == null) {
      return false;
    }
    FieldType fieldType=(FieldType)_fields.get(label);
    Type type=fieldType._declaredType;
    Token value=(Token)argRecTok.get(label);
    if (!type.isCompatible(value)) {
      return false;
    }
  }
  return true;
}","/** 
 * Test if the argument token is compatible with this type. If this type is a constant, the argument is compatible if it can be converted losslessly to a token of this type; If this type is a variable, the argument is compatible if its type is a substitution instance of this type, or if it can be converted losslessly to a substitution instance of this type. 
 * @param t A Token.
 * @return True if the argument is compatible with this type.
 */
public boolean isCompatible(Token t){
  if (!(t instanceof RecordToken)) {
    return false;
  }
  RecordToken argRecTok=(RecordToken)t;
  Iterator iter=_fields.keySet().iterator();
  while (iter.hasNext()) {
    String label=(String)iter.next();
    if (argRecTok.get(label) == null) {
      return false;
    }
    FieldType fieldType=(FieldType)_fields.get(label);
    Type type=fieldType._declaredType;
    Token value=(Token)argRecTok.get(label);
    if (!type.isCompatible(value)) {
      return false;
    }
  }
  return true;
}"
76012,"/** 
 * Return a deep copy of this RecordType if it is a variable, or itself if it is a constant.
 * @return A RecordType.
 */
public Object clone(){
  if (isConstant()) {
    return this;
  }
 else {
    String[] labels=(String[])_fields.keySet().toArray();
    Type[] types=new Type[labels.length];
    for (int i=0; i < labels.length; i++) {
      FieldType fieldType=(FieldType)_fields.get(labels[i]);
      types[i]=fieldType._declaredType;
    }
    RecordType newObj=new RecordType(labels,types);
    try {
      newObj.updateType(this);
    }
 catch (    IllegalActionException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
    }
    return newObj;
  }
}","/** 
 * Return a deep copy of this RecordType if it is a variable, or itself if it is a constant.
 * @return A RecordType.
 */
public Object clone(){
  if (isConstant()) {
    return this;
  }
 else {
    Object[] labelsObj=_fields.keySet().toArray();
    String[] labels=new String[labelsObj.length];
    Type[] types=new Type[labelsObj.length];
    for (int i=0; i < labels.length; i++) {
      labels[i]=(String)labelsObj[i];
      FieldType fieldType=(FieldType)_fields.get(labels[i]);
      types[i]=fieldType._declaredType;
    }
    RecordType newObj=new RecordType(labels,types);
    try {
      newObj.updateType(this);
    }
 catch (    IllegalActionException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
    }
    return newObj;
  }
}"
76013,"/** 
 * Update this Type to the specified RecordType. The specified type must be a substitution instance of this type. This method will only update the component whose declared type is BaseType.ANY, and leave the constant part of this type intact.
 * @param st A StructuredType.
 * @exception IllegalActionException If the specified type is not asubstitution instance of this type.
 */
public void updateType(StructuredType newType) throws IllegalActionException {
  if (!this.isSubstitutionInstance(newType)) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Iterator iter=_fields.keySet().iterator();
  while (iter.hasNext()) {
    String label=(String)iter.next();
    FieldType fieldType=(FieldType)this.get(label);
    if (fieldType.isSettable()) {
      Type newFieldType=((RecordType)newType).get(label);
      fieldType.setValue(newFieldType);
    }
  }
}","/** 
 * Update this Type to the specified RecordType. The specified type must be a substitution instance of this type. This method will only update the component whose declared type is BaseType.ANY, and leave the constant part of this type intact.
 * @param st A StructuredType.
 * @exception IllegalActionException If the specified type is not asubstitution instance of this type.
 */
public void updateType(StructuredType newType) throws IllegalActionException {
  if (!this.isSubstitutionInstance(newType)) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Iterator iter=_fields.keySet().iterator();
  while (iter.hasNext()) {
    String label=(String)iter.next();
    FieldType fieldType=(FieldType)_fields.get(label);
    if (fieldType.isSettable()) {
      Type newFieldType=((RecordType)newType).get(label);
      fieldType.setValue(newFieldType);
    }
  }
}"
76014,"/** 
 * Construct a RecordToken with the specified labeles and values.  The labels and values array must have the same length, and have one to correspondance. That is, the i'th entry in the labels array is the label for the i'th value in the values array. Both arrays must be non-empty.
 * @param labels An array of labels.
 * @param values An array of Tokens.
 * @exception IllegalArgumentException If the labels or the values arraydo not have the same length; or is empty; or contains null element; or the labels array contains duplicate elements.
 */
public RecordToken(String[] labels,Token[] values){
  if (labels == null || values == null || labels.length != values.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < labels.length; i++) {
    if (labels[i] == null || values[i] == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    if (_fields.containsKey(labels[i])) {
      _fields.put(labels[i],values[i]);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + labels[i]);
    }
  }
}","/** 
 * Construct a RecordToken with the specified labeles and values.  The labels and values array must have the same length, and have one to correspondance. That is, the i'th entry in the labels array is the label for the i'th value in the values array. Both arrays must be non-empty.
 * @param labels An array of labels.
 * @param values An array of Tokens.
 * @exception IllegalArgumentException If the labels or the values arraydo not have the same length; or is empty; or contains null element; or the labels array contains duplicate elements.
 */
public RecordToken(String[] labels,Token[] values){
  if (labels == null || values == null || labels.length != values.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < labels.length; i++) {
    if (labels[i] == null || values[i] == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    if (!_fields.containsKey(labels[i])) {
      _fields.put(labels[i],values[i]);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + labels[i]);
    }
  }
}"
76015,"private void _updateLinks(ComponentRelation relation){
  List linkedPortList=relation.linkedPortList();
  int allPortCount=linkedPortList.size();
  Iterator links=_linkSet.iterator();
  while (links.hasNext()) {
    Link link=(Link)links.next();
    if (link.getRelation() != relation)     continue;
    Object tail=link.getTail();
    if (tail instanceof Location) {
      tail=((Location)tail).getContainer();
    }
    if (tail != null && linkedPortList.contains(tail)) {
      linkedPortList.remove(tail);
    }
    Object head=link.getHead();
    if (head instanceof Location) {
      head=((Location)head).getContainer();
    }
    if (head != null && linkedPortList.contains(head)) {
      linkedPortList.remove(head);
    }
  }
  int unlinkedPortCount=linkedPortList.size();
  if (unlinkedPortCount == 0)   return;
  Iterator vertexes=relation.attributeList(Vertex.class).iterator();
  Vertex rootVertex=null;
  while (vertexes.hasNext()) {
    Vertex v=(Vertex)vertexes.next();
    if (v.getLinkedVertex() == null) {
      rootVertex=v;
    }
  }
  if (rootVertex == null && allPortCount == 2 && unlinkedPortCount == 2) {
    Port port1=(Port)linkedPortList.get(0);
    Port port2=(Port)linkedPortList.get(1);
    Object head=null;
    Object tail=null;
    if (port1.getContainer().equals(getRoot())) {
      head=_getLocation(port1);
    }
 else {
      head=port1;
    }
    if (port2.getContainer().equals(getRoot())) {
      tail=_getLocation(port2);
    }
 else {
      tail=port2;
    }
    Link link;
    try {
      link=new Link();
      _linkSet.add(link);
    }
 catch (    Exception e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
    }
    link.setRelation(relation);
    link.setHead(head);
    link.setTail(tail);
  }
 else {
    if (rootVertex == null) {
      try {
        rootVertex=new Vertex(relation,relation.uniqueName(""String_Node_Str""));
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
    }
    Iterator ports=linkedPortList.iterator();
    while (ports.hasNext()) {
      Port port=(Port)ports.next();
      Object head=null;
      if (port.getContainer().equals(getRoot())) {
        head=_getLocation(port);
      }
 else {
        head=port;
      }
      Link link;
      try {
        link=new Link();
        _linkSet.add(link);
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
      link.setRelation(relation);
      link.setHead(head);
      link.setTail(rootVertex);
    }
  }
}","private void _updateLinks(ComponentRelation relation){
  List linkedPortList=relation.linkedPortList();
  int allPortCount=linkedPortList.size();
  Iterator links=_linkSet.iterator();
  while (links.hasNext()) {
    Link link=(Link)links.next();
    if (link.getRelation() != relation)     continue;
    Object tail=link.getTail();
    Object tailObj=getSemanticObject(tail);
    if (tailObj != null && linkedPortList.contains(tailObj)) {
      linkedPortList.remove(tailObj);
    }
    Object head=link.getHead();
    Object headObj=getSemanticObject(head);
    if (headObj != null && linkedPortList.contains(headObj)) {
      linkedPortList.remove(headObj);
    }
  }
  int unlinkedPortCount=linkedPortList.size();
  if (unlinkedPortCount == 0)   return;
  Iterator vertexes=relation.attributeList(Vertex.class).iterator();
  Vertex rootVertex=null;
  while (vertexes.hasNext()) {
    Vertex v=(Vertex)vertexes.next();
    if (v.getLinkedVertex() == null) {
      rootVertex=v;
    }
  }
  if (rootVertex == null && allPortCount == 2 && unlinkedPortCount == 2) {
    Port port1=(Port)linkedPortList.get(0);
    Port port2=(Port)linkedPortList.get(1);
    Object head=null;
    Object tail=null;
    if (port1.getContainer().equals(getRoot())) {
      head=_getLocation(port1);
    }
 else {
      head=port1;
    }
    if (port2.getContainer().equals(getRoot())) {
      tail=_getLocation(port2);
    }
 else {
      tail=port2;
    }
    Link link;
    try {
      link=new Link();
      _linkSet.add(link);
    }
 catch (    Exception e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
    }
    link.setRelation(relation);
    link.setHead(head);
    link.setTail(tail);
  }
 else {
    if (rootVertex == null) {
      try {
        rootVertex=new Vertex(relation,relation.uniqueName(""String_Node_Str""));
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
    }
    Iterator ports=linkedPortList.iterator();
    while (ports.hasNext()) {
      Port port=(Port)ports.next();
      Object head=null;
      if (port.getContainer().equals(getRoot())) {
        head=_getLocation(port);
      }
 else {
        head=port;
      }
      Link link;
      try {
        link=new Link();
        _linkSet.add(link);
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
      link.setRelation(relation);
      link.setHead(head);
      link.setTail(rootVertex);
    }
  }
}"
76016,"/** 
 * Connect the given edge to the given head node. This class queues a new change request with the ptolemy model to make this modification.
 * @param edge The edge, which is assumed to be a link.
 * @param head The new head for the edge, which is assumed tobe a location representing a port, a port or a vertex.
 */
public void setHead(final Object edge,final Object newLinkHead){
  final Link link=(Link)edge;
  NamedObj linkHead=(NamedObj)link.getHead();
  NamedObj linkTail=(NamedObj)link.getTail();
  Relation linkRelation=(Relation)link.getRelation();
  final StringBuffer moml=new StringBuffer();
  final StringBuffer failmoml=new StringBuffer();
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  String relationName=""String_Node_Str"";
  try {
    _unlinkMoML(moml,linkHead,linkTail,linkRelation);
    relationName=_linkMoML(moml,failmoml,(NamedObj)newLinkHead,linkTail);
  }
 catch (  Exception ex) {
    throw new GraphException(ex);
  }
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final String relationNameToAdd=relationName;
  ChangeRequest request=new MoMLChangeRequest(PtolemyGraphModel.this,getToplevel(),moml.toString()){
    protected void _execute() throws Exception {
      super._execute();
      link.setHead(newLinkHead);
      if (relationNameToAdd != null) {
        link.setRelation(getToplevel().getRelation(relationNameToAdd));
      }
 else {
        link.setRelation(null);
      }
    }
  }
;
  request.addChangeListener(new ChangeListener(){
    public void changeFailed(    ChangeRequest change,    Exception exception){
      _linkSet.remove(link);
      link.setHead(null);
      link.setTail(null);
      link.setRelation(null);
      ChangeRequest request=new MoMLChangeRequest(PtolemyGraphModel.this,getToplevel(),failmoml.toString());
      getToplevel().requestChange(request);
    }
    public void changeExecuted(    ChangeRequest change){
      if (GraphUtilities.isPartiallyContainedEdge(edge,getRoot(),PtolemyGraphModel.this)) {
        _linkSet.add(edge);
      }
 else {
        _linkSet.remove(edge);
      }
    }
  }
);
  getToplevel().requestChange(request);
}","/** 
 * Connect the given edge to the given head node. This class queues a new change request with the ptolemy model to make this modification.
 * @param edge The edge, which is assumed to be a link.
 * @param head The new head for the edge, which is assumed tobe a location representing a port, a port or a vertex.
 */
public void setHead(final Object edge,final Object newLinkHead){
  final Link link=(Link)edge;
  NamedObj linkHead=(NamedObj)link.getHead();
  NamedObj linkTail=(NamedObj)link.getTail();
  Relation linkRelation=(Relation)link.getRelation();
  final StringBuffer moml=new StringBuffer();
  final StringBuffer failmoml=new StringBuffer();
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  String relationName=""String_Node_Str"";
  try {
    _unlinkMoML(moml,linkHead,linkTail,linkRelation);
    relationName=_linkMoML(moml,failmoml,(NamedObj)newLinkHead,linkTail);
  }
 catch (  Exception ex) {
    throw new GraphException(ex);
  }
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final String relationNameToAdd=relationName;
  ChangeRequest request=new MoMLChangeRequest(PtolemyGraphModel.this,getToplevel(),moml.toString()){
    protected void _execute() throws Exception {
      super._execute();
      link.setHead(newLinkHead);
      if (relationNameToAdd != null) {
        ComponentRelation relation=(ComponentRelation)getToplevel().getRelation(relationNameToAdd);
        link.setRelation(relation);
      }
 else {
        link.setRelation(null);
      }
    }
  }
;
  request.addChangeListener(new ChangeListener(){
    public void changeFailed(    ChangeRequest change,    Exception exception){
      _linkSet.remove(link);
      link.setHead(null);
      link.setTail(null);
      link.setRelation(null);
      ChangeRequest request=new MoMLChangeRequest(PtolemyGraphModel.this,getToplevel(),failmoml.toString());
      getToplevel().requestChange(request);
    }
    public void changeExecuted(    ChangeRequest change){
      if (GraphUtilities.isPartiallyContainedEdge(edge,getRoot(),PtolemyGraphModel.this)) {
        _linkSet.add(edge);
      }
 else {
        _linkSet.remove(edge);
      }
    }
  }
);
  getToplevel().requestChange(request);
}"
76017,"/** 
 * Append moml to the given buffer that connects a link with the given head, tail, and relation.  This may require addinging an anonymous relation to the ptolemy model.  If this is required, the name of the relation is returned.   If no relation need be added, then null is returned.
 */
private String _linkMoML(StringBuffer moml,StringBuffer failmoml,NamedObj linkHead,NamedObj linkTail) throws Exception {
  if (linkHead != null && linkTail != null) {
    NamedObj head=(NamedObj)getSemanticObject(linkHead);
    NamedObj tail=(NamedObj)getSemanticObject(linkTail);
    if (head instanceof ComponentPort && tail instanceof ComponentPort) {
      ComponentPort headPort=(ComponentPort)head;
      ComponentPort tailPort=(ComponentPort)tail;
      String relationName=getToplevel().uniqueName(""String_Node_Str"");
      moml.append(""String_Node_Str"" + relationName + ""String_Node_Str"");
      moml.append(""String_Node_Str"" + headPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      moml.append(""String_Node_Str"" + tailPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      failmoml.append(""String_Node_Str"" + headPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      failmoml.append(""String_Node_Str"" + tailPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      failmoml.append(""String_Node_Str"" + relationName + ""String_Node_Str"");
      return relationName;
    }
 else     if (head instanceof ComponentPort && linkTail instanceof Vertex) {
      moml.append(""String_Node_Str"" + head.getName(getToplevel()) + ""String_Node_Str""+ tail.getName(getToplevel())+ ""String_Node_Str"");
      return linkTail.getName(getToplevel());
    }
 else     if (tail instanceof ComponentPort && linkHead instanceof Vertex) {
      moml.append(""String_Node_Str"" + tail.getName(getToplevel()) + ""String_Node_Str""+ head.getName(getToplevel())+ ""String_Node_Str"");
      return linkHead.getName(getToplevel());
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + head + ""String_Node_Str""+ tail);
    }
  }
 else {
    return null;
  }
}","/** 
 * Append moml to the given buffer that connects a link with the given head, tail, and relation.  This may require addinging an anonymous relation to the ptolemy model.  If this is required, the name of the relation is returned.   If no relation need be added, then null is returned.
 */
private String _linkMoML(StringBuffer moml,StringBuffer failmoml,NamedObj linkHead,NamedObj linkTail) throws Exception {
  if (linkHead != null && linkTail != null) {
    NamedObj head=(NamedObj)getSemanticObject(linkHead);
    NamedObj tail=(NamedObj)getSemanticObject(linkTail);
    if (head instanceof ComponentPort && tail instanceof ComponentPort) {
      ComponentPort headPort=(ComponentPort)head;
      ComponentPort tailPort=(ComponentPort)tail;
      String relationName=getToplevel().uniqueName(""String_Node_Str"");
      moml.append(""String_Node_Str"" + relationName + ""String_Node_Str"");
      moml.append(""String_Node_Str"" + headPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      moml.append(""String_Node_Str"" + tailPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      failmoml.append(""String_Node_Str"" + headPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      failmoml.append(""String_Node_Str"" + tailPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      failmoml.append(""String_Node_Str"" + relationName + ""String_Node_Str"");
      return relationName;
    }
 else     if (head instanceof ComponentPort && linkTail instanceof Vertex) {
      moml.append(""String_Node_Str"" + head.getName(getToplevel()) + ""String_Node_Str""+ tail.getName(getToplevel())+ ""String_Node_Str"");
      return tail.getName(getToplevel());
    }
 else     if (tail instanceof ComponentPort && linkHead instanceof Vertex) {
      moml.append(""String_Node_Str"" + tail.getName(getToplevel()) + ""String_Node_Str""+ head.getName(getToplevel())+ ""String_Node_Str"");
      return head.getName(getToplevel());
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + head + ""String_Node_Str""+ tail);
    }
  }
 else {
    return null;
  }
}"
76018,"/** 
 * Constructor an with the specified container and name. This is protected because there is no reason to create an instance of this class, but derived classes will want to invoke the constructor of the superclass.
 * @param container The container.
 * @param name The name.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
protected DEActor(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
}","/** 
 * Construct an actor with the specified container and name. This is protected because there is no reason to create an instance of this class, but derived classes will want to invoke the constructor of the superclass.
 * @param container The container.
 * @param name The name.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
protected DEActor(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
}"
76019,"/** 
 * Return the earliest event in the queue without dequeueing it. This method is synchronized since there may be actors running under different threads in the DE domain.
 * @return The smallest event in the queue.
 * @exception InvalidStateException If the queue is empty.
 */
public synchronized final DEEvent get(){
  return (DEEvent)_cQueue.get();
}","/** 
 * Return the earliest event in the queue without removing the event from the queue. This method is synchronized since there may be actors running under different threads in the DE domain.
 * @return The smallest event in the queue.
 * @exception InvalidStateException If the queue is empty.
 */
public synchronized final DEEvent get(){
  return (DEEvent)_cQueue.get();
}"
76020,"/** 
 * Update the director parameters when the attributes are changed. Changes to <i>isCQAdaptive</i>, <i>minBinCount</i>, and <i>binCountFactor</i> parameters will only be effective on the next time the model is executed.
 * @param attr The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class. May be needed by derived classes.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"",attribute.getName());
  if (attribute == stopWhenQueueIsEmpty) {
    _stopWhenQueueIsEmpty=((BooleanToken)stopWhenQueueIsEmpty.getToken()).booleanValue();
  }
  if (attribute == synchronizeToRealTime) {
    _synchronizeToRealTime=((BooleanToken)synchronizeToRealTime.getToken()).booleanValue();
  }
}","/** 
 * Update the director parameters when the attributes are changed. Changes to <i>isCQAdaptive</i>, <i>minBinCount</i>, and <i>binCountFactor</i> parameters will only be effective on the next time the model is executed.
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class. May be needed by derived classes.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"",attribute.getName());
  if (attribute == stopWhenQueueIsEmpty) {
    _stopWhenQueueIsEmpty=((BooleanToken)stopWhenQueueIsEmpty.getToken()).booleanValue();
  }
  if (attribute == synchronizeToRealTime) {
    _synchronizeToRealTime=((BooleanToken)synchronizeToRealTime.getToken()).booleanValue();
  }
}"
76021,"private Actor _dequeueEvents(){
  Actor actorToFire=null;
  DEEvent currentEvent=null, nextEvent=null;
  int currentDepth=0;
  if (_eventQueue == null)   return null;
  while (true) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
 else {
      if (actorToFire != null && _eventQueue.isEmpty())       break;
      _stopRequested=false;
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
synchronized (_eventQueue) {
          try {
            _eventQueue.wait();
          }
 catch (          InterruptedException e) {
            break;
          }
        }
      }
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      _eventQueue.take();
      currentEvent=nextEvent;
      actorToFire=currentEvent.actor();
      if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
        if (_debugging)         _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
        actorToFire=null;
        continue;
      }
      double currentTime=currentEvent.timeStamp();
      if (_synchronizeToRealTime) {
        long elapsedTime=System.currentTimeMillis() - _realStartTime;
        double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
        if (currentTime > elapsedTimeInSeconds) {
          long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
          if (timeToWait > 0) {
            if (_debugging) {
              _debug(""String_Node_Str"" + timeToWait);
            }
synchronized (_eventQueue) {
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
      if (_debugging)       _debug(""String_Node_Str"",Double.toString(currentTime));
      try {
        setCurrentTime(currentTime);
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
      currentDepth=currentEvent.depth();
      _microstep=currentEvent.microstep();
      if (currentTime > getStopTime()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        return null;
      }
      DEReceiver rec=currentEvent.receiver();
      if (rec != null) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",rec.getContainer().getName());
        rec._triggerEvent(currentEvent.token());
      }
    }
 else {
      if (nextEvent.isSimultaneousWith(currentEvent) && nextEvent.actor() == currentEvent.actor()) {
        _eventQueue.take();
        DEReceiver rec=nextEvent.receiver();
        if (rec != null) {
          rec._triggerEvent(nextEvent.token());
        }
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}","private Actor _dequeueEvents(){
  Actor actorToFire=null;
  DEEvent currentEvent=null, nextEvent=null;
  int currentDepth=0;
  if (_eventQueue == null)   return null;
  while (true) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
 else {
      if (actorToFire != null && _eventQueue.isEmpty())       break;
      _stopRequested=false;
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
synchronized (_eventQueue) {
          try {
            _eventQueue.wait();
          }
 catch (          InterruptedException e) {
            break;
          }
        }
      }
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      _eventQueue.take();
      currentEvent=nextEvent;
      actorToFire=currentEvent.actor();
      if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
        if (_debugging)         _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
        actorToFire=null;
        continue;
      }
      double currentTime=currentEvent.timeStamp();
      if (_synchronizeToRealTime) {
        long elapsedTime=System.currentTimeMillis() - _realStartTime;
        double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
        if (currentTime > elapsedTimeInSeconds) {
          long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
          if (timeToWait > 0) {
            if (_debugging) {
              _debug(""String_Node_Str"" + timeToWait);
            }
synchronized (_eventQueue) {
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
      if (_debugging)       _debug(""String_Node_Str"",Double.toString(currentTime));
      try {
        setCurrentTime(currentTime);
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
      currentDepth=currentEvent.depth();
      _microstep=currentEvent.microstep();
      if (currentTime > getStopTime()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        return null;
      }
      DEReceiver receiver=currentEvent.receiver();
      if (receiver != null) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",receiver.getContainer().getName());
        receiver._triggerEvent(currentEvent.token());
      }
    }
 else {
      if (nextEvent.isSimultaneousWith(currentEvent) && nextEvent.actor() == currentEvent.actor()) {
        _eventQueue.take();
        DEReceiver receiver=nextEvent.receiver();
        if (receiver != null) {
          receiver._triggerEvent(nextEvent.token());
        }
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}"
76022,"private DirectedAcyclicGraph _constructDirectedGraph() throws IllegalActionException {
  DirectedAcyclicGraph dag=new DirectedAcyclicGraph();
  Nameable container=getContainer();
  if (!(container instanceof CompositeActor))   return dag;
  CompositeActor castContainer=(CompositeActor)container;
  Iterator actors=castContainer.deepEntityList().iterator();
  while (actors.hasNext()) {
    dag.add(actors.next());
  }
  actors=castContainer.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    Iterator ports=actor.inputPortList().iterator();
    while (ports.hasNext()) {
      IOPort inputPort=(IOPort)ports.next();
      Set delayPorts=null;
      if (inputPort instanceof DEIOPort) {
        DEIOPort dePort=(DEIOPort)inputPort;
        delayPorts=dePort.getDelayToPorts();
      }
      Iterator triggers=((Actor)inputPort.getContainer()).outputPortList().iterator();
      while (triggers.hasNext()) {
        IOPort outPort=(IOPort)triggers.next();
        if (delayPorts != null && delayPorts.contains(outPort)) {
          continue;
        }
        Iterator inPortIter=outPort.deepConnectedInPortList().iterator();
        while (inPortIter.hasNext()) {
          IOPort pp=(IOPort)inPortIter.next();
          Actor destination=(Actor)(pp.getContainer());
          if (destination.equals(actor)) {
            throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName());
          }
          if (dag.contains(destination)) {
            dag.addEdge(actor,destination);
          }
 else {
            throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName() + ""String_Node_Str""+ ((Nameable)destination).getFullName());
          }
        }
      }
    }
  }
  if (!dag.isAcyclic()) {
    Object[] cycleNodes=dag.cycleNodes();
    StringBuffer names=new StringBuffer();
    for (int i=0; i < cycleNodes.length; i++) {
      if (cycleNodes[i] instanceof Nameable) {
        if (i > 0)         names.append(""String_Node_Str"");
        names.append(((Nameable)cycleNodes[i]).getFullName());
      }
    }
    throw new IllegalActionException(this,""String_Node_Str"" + names.toString());
  }
  return dag;
}","private DirectedAcyclicGraph _constructDirectedGraph() throws IllegalActionException {
  DirectedAcyclicGraph dag=new DirectedAcyclicGraph();
  Nameable container=getContainer();
  if (!(container instanceof CompositeActor))   return dag;
  CompositeActor castContainer=(CompositeActor)container;
  Iterator actors=castContainer.deepEntityList().iterator();
  while (actors.hasNext()) {
    dag.add(actors.next());
  }
  actors=castContainer.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    Iterator ports=actor.inputPortList().iterator();
    while (ports.hasNext()) {
      IOPort inputPort=(IOPort)ports.next();
      Set delayPorts=null;
      if (inputPort instanceof DEIOPort) {
        DEIOPort dePort=(DEIOPort)inputPort;
        delayPorts=dePort.getDelayToPorts();
      }
      Iterator triggers=((Actor)inputPort.getContainer()).outputPortList().iterator();
      while (triggers.hasNext()) {
        IOPort outPort=(IOPort)triggers.next();
        if (delayPorts != null && delayPorts.contains(outPort)) {
          continue;
        }
        Iterator inPortIterator=outPort.deepConnectedInPortList().iterator();
        while (inPortIterator.hasNext()) {
          IOPort port=(IOPort)inPortIterator.next();
          Actor destination=(Actor)(port.getContainer());
          if (destination.equals(actor)) {
            throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName());
          }
          if (dag.contains(destination)) {
            dag.addEdge(actor,destination);
          }
 else {
            throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName() + ""String_Node_Str""+ ((Nameable)destination).getFullName());
          }
        }
      }
    }
  }
  if (!dag.isAcyclic()) {
    Object[] cycleNodes=dag.cycleNodes();
    StringBuffer names=new StringBuffer();
    for (int i=0; i < cycleNodes.length; i++) {
      if (cycleNodes[i] instanceof Nameable) {
        if (i > 0)         names.append(""String_Node_Str"");
        names.append(((Nameable)cycleNodes[i]).getFullName());
      }
    }
    throw new IllegalActionException(this,""String_Node_Str"" + names.toString());
  }
  return dag;
}"
76023,"/** 
 * Construct a DEIOPort with the specified container and name that is either an input, an output, or both, depending on the third and fourth arguments. The specified container must implement the Actor interface or an exception will be thrown.
 * @param container The container actor.
 * @param name The name of the port.
 * @param isinput True if this is to be an input port.
 * @param isoutput True if this is to be an output port.
 * @exception IllegalActionException If the port is not of an acceptableclass for the container, or if the container does not implement the Actor interface.
 * @exception NameDuplicationException If the name coincides witha port already in the container.
 */
public DEIOPort(ComponentEntity container,String name,boolean isinput,boolean isoutput) throws IllegalActionException, NameDuplicationException {
  super(container,name,isinput,isoutput);
}","/** 
 * Construct a DEIOPort with the specified container and name that is either an input, an output, or both, depending on the third and fourth arguments. The specified container must implement the Actor interface or an exception will be thrown.
 * @param container The container actor.
 * @param name The name of the port.
 * @param isInput True if this is to be an input port.
 * @param isOutput True if this is to be an output port.
 * @exception IllegalActionException If the port is not of an acceptableclass for the container, or if the container does not implement the Actor interface.
 * @exception NameDuplicationException If the name coincides witha port already in the container.
 */
public DEIOPort(ComponentEntity container,String name,boolean isInput,boolean isOutput) throws IllegalActionException, NameDuplicationException {
  super(container,name,isInput,isOutput);
}"
76024,"/** 
 * Send a token with the specified time delay to the receivers connected on the specified channel.  The time stamp of the token is equal to current time plus the specified delay. If the specified delay is zero, then the event is queued to be processed in the next microstep.
 * @param channelindex The index of the channel, from 0 to width-1.
 * @param token The token to send.
 * @param delay The time delay of the token being sent.
 * @exception IllegalActionException If the port is not an output,or if the index is out of range.
 */
public void send(int channelindex,Token token,double delay) throws IllegalActionException {
  _delay=delay;
  _useDelay=true;
  send(channelindex,token);
}","/** 
 * Send a token with the specified time delay to the receivers connected on the specified channel.  The time stamp of the token is equal to current time plus the specified delay. If the specified delay is zero, then the event is queued to be processed in the next microstep.
 * @param channelIndex The index of the channel, from 0 to width-1.
 * @param token The token to send.
 * @param delay The time delay of the token being sent.
 * @exception IllegalActionException If the port is not an output,or if the index is out of range.
 */
public void send(int channelIndex,Token token,double delay) throws IllegalActionException {
  _delay=delay;
  _useDelay=true;
  send(channelIndex,token);
}"
76025,"/** 
 * Get a token from the receiver.  The token returned is one that was put in the receiver with a time stamp equal to or earlier than the current time.  Note that there might be multiple such tokens in the receiver. In that case, FIFO behaviour is used with respect to the put() method. If there is no such token, throw an exception. This method is synhronized since the actor may not execute in the same thread as the director.
 * @return A token.
 * @exception NoTokenException If there are no more tokens. This isa runtime exception, so it need not be declared explicitly.
 */
public synchronized Token get() throws NoTokenException {
  if (_tokens.isEmpty()) {
    throw new NoTokenException(getContainer(),""String_Node_Str"");
  }
  return (Token)_tokens.removeFirst();
}","/** 
 * Get a token from the receiver.  The token returned is one that was put in the receiver with a time stamp equal to or earlier than the current time.  Note that there might be multiple such tokens in the receiver. In that case, FIFO behaviour is used with respect to the put() method. If there is no such token, throw an exception. This method is synchronized since the actor may not execute in the same thread as the director.
 * @return A token.
 * @exception NoTokenException If there are no more tokens. This isa runtime exception, so it need not be declared explicitly.
 */
public synchronized Token get() throws NoTokenException {
  if (_tokens.isEmpty()) {
    throw new NoTokenException(getContainer(),""String_Node_Str"");
  }
  return (Token)_tokens.removeFirst();
}"
76026,"/** 
 * Set the delay for the next call to put().  This causes the director to make the token available for the get() method at some future time, i.e. current time plus the specified delay.  This value of delay is only used in the next call to put(). If the specified delay is zero, then the next event is queued to be processed in the next microstep. This method is synhronized since the actor may not execute in the same thread as the director.
 * @param delay The delay.
 * @exception IllegalActionException If the delay is negative.
 */
public synchronized void setDelay(double delay) throws IllegalActionException {
  if (delay < 0.0) {
    throw new IllegalActionException(getContainer(),""String_Node_Str"");
  }
  _delay=delay;
  _useDelay=true;
}","/** 
 * Set the delay for the next call to put().  This causes the director to make the token available for the get() method at some future time, i.e. current time plus the specified delay.  This value of delay is only used in the next call to put(). If the specified delay is zero, then the next event is queued to be processed in the next microstep. This method is synchronized since the actor may not execute in the same thread as the director.
 * @param delay The delay.
 * @exception IllegalActionException If the delay is negative.
 */
public synchronized void setDelay(double delay) throws IllegalActionException {
  if (delay < 0.0) {
    throw new IllegalActionException(getContainer(),""String_Node_Str"");
  }
  _delay=delay;
  _useDelay=true;
}"
76027,"/** 
 * Put a token into this receiver with a future time stamp. This token will be available to the get() method at the time specified. Note that the time should be greater than or equal to the current time of the director, otherwise an exception will be thrown. This method is synhronized since the actor may not execute in the same thread as the director.
 * @param token The token to be put.
 * @param time The time stamp of the token
 * @exception IllegalActionException If time is less than thecurrent time of the director, or no director is available.
 */
public synchronized void put(Token token,double time) throws IllegalActionException {
  DEDirector dir=getDirector();
  double now=dir.getCurrentTime();
  if (time < now) {
    throw new IllegalActionException(getContainer(),""String_Node_Str"");
  }
  if (time == now) {
    dir._enqueueEvent(this,token);
  }
 else {
    dir._enqueueEvent(this,token,time);
  }
}","/** 
 * Put a token into this receiver with a future time stamp. This token will be available to the get() method at the time specified. Note that the time should be greater than or equal to the current time of the director, otherwise an exception will be thrown. This method is synchronized since the actor may not execute in the same thread as the director.
 * @param token The token to be put.
 * @param time The time stamp of the token
 * @exception IllegalActionException If time is less than thecurrent time of the director, or no director is available.
 */
public synchronized void put(Token token,double time) throws IllegalActionException {
  DEDirector dir=getDirector();
  double now=dir.getCurrentTime();
  if (time < now) {
    throw new IllegalActionException(getContainer(),""String_Node_Str"");
  }
  if (time == now) {
    dir._enqueueEvent(this,token);
  }
 else {
    dir._enqueueEvent(this,token,time);
  }
}"
76028,"private void _emptyPorts(){
  Iterator ports=inputPortList().iterator();
  while (ports.hasNext()) {
    IOPort port=(IOPort)ports.next();
    for (int ch=0; ch < port.getWidth(); ch++) {
      try {
        while (port.hasToken(ch)) {
          port.get(ch);
        }
      }
 catch (      IllegalActionException e) {
        e.printStackTrace();
        throw new InternalErrorException(e.getMessage());
      }
    }
  }
}","private void _emptyPorts(){
  Iterator ports=inputPortList().iterator();
  while (ports.hasNext()) {
    IOPort port=(IOPort)ports.next();
    for (int channel=0; channel < port.getWidth(); channel++) {
      try {
        while (port.hasToken(channel)) {
          port.get(channel);
        }
      }
 catch (      IllegalActionException e) {
        e.printStackTrace();
        throw new InternalErrorException(e.getMessage());
      }
    }
  }
}"
76029,"/** 
 * Queue a change request.  Delegate the change request to the container of this actor, if there is one.  If there is none, then delegate to the Manager.  If the actor has no manager then execute the request  immediately.  Any listeners that have been registered using addChangeListener() will be notified of success (or failure) of the request. <p> For the benefit of process-oriented domains, which may not have finite iterations, this method also calls stopFire() on the top-level composite actor, requesting that directors in such domains return from their fire() method (concluding the current iteration) as soon as practical, at which time the specified change will be executed.
 * @param change The requested change.
 */
public void requestChange(ChangeRequest change){
  CompositeEntity container=(CompositeEntity)getContainer();
  if (container == null) {
    Manager manager=getManager();
    if (manager == null) {
      change.setListeners(_changeListeners);
      change.execute();
    }
 else {
      manager.requestChange(change);
      stopFire();
    }
  }
 else {
    container.requestChange(change);
  }
}","/** 
 * Queue a change request.  Delegate the change request to the container of this actor, if there is one.  If there is none, then delegate to the Manager.  If the actor has no manager then execute the request  immediately.  Any listeners that have been registered using addChangeListener() will be notified of success (or failure) of the request. <p> For the benefit of process-oriented domains, which may not have finite iterations, this method also calls stopFire() on the top-level composite actor, requesting that directors in such domains return from their fire() method (concluding the current iteration) as soon as practical, at which time the specified change will be executed.
 * @param change The requested change.
 */
public void requestChange(ChangeRequest change){
  CompositeEntity container=(CompositeEntity)getContainer();
  if (container == null) {
    change.setListeners(_changeListeners);
    Manager manager=getManager();
    if (manager == null) {
      change.execute();
    }
 else {
      manager.requestChange(change);
    }
  }
 else {
    container.requestChange(change);
  }
}"
76030,"/** 
 * Queue a change request, or if the model is idle, execute it immediately.  If the request is queued, then it will be executed at the next opportunity, between top-level iterations of the model. Notify any change listeners when the change is executed.
 * @param change The requested change.
 */
public void requestChange(ChangeRequest change){
  change.setListeners(_changeListeners);
  if (_state == IDLE) {
    change.execute();
  }
 else {
    if (_changeRequests == null) {
      _changeRequests=new LinkedList();
    }
    _changeRequests.add(change);
  }
}","/** 
 * Queue a change request, or if the model is idle, execute it immediately.  If the request is queued, then it will be executed at the next opportunity, between top-level iterations of the model. Notify any change listeners when the change is executed.
 * @param change The requested change.
 */
public void requestChange(ChangeRequest change){
  if (_state == IDLE) {
    change.execute();
  }
 else {
    if (_changeRequests == null) {
      _changeRequests=new LinkedList();
    }
    _changeRequests.add(change);
    _container.stopFire();
  }
}"
76031,"public Object visitClassDeclNode(ClassDeclNode node,LinkedList args){
  Object classDeclObj=args.get(0);
  if (classDeclObj instanceof ClassDecl) {
    ClassDecl classDecl=(ClassDecl)classDeclObj;
    if (classDecl.category == CG_INTERFACE) {
      int classPublic=classDecl.getModifiers() & PUBLIC_MOD;
      int modifiers=node.getModifiers();
      modifiers|=(classPublic | STATIC_MOD | FINAL_MOD);
      node.setModifiers(modifiers);
    }
  }
  ClassDecl me=(ClassDecl)JavaDecl.getDecl((NamedNode)node);
  if (!me.addVisitor(_myClass)) {
    return null;
  }
  TreeNode superClass=node.getSuperClass();
  ClassDecl superDecl;
  if (me == StaticResolution.OBJECT_DECL) {
    superDecl=null;
  }
 else   if (superClass == AbsentTreeNode.instance) {
    superDecl=StaticResolution.OBJECT_DECL;
  }
 else {
    superDecl=(ClassDecl)JavaDecl.getDecl((NamedNode)superClass);
  }
  if ((superDecl != null) && (superDecl.category != CG_CLASS)) {
    ApplicationUtility.error(""String_Node_Str"" + node.getName().getIdent() + ""String_Node_Str""+ superDecl.getName());
  }
  if (superDecl != null) {
    node.setSuperClass(superDecl.getDefType());
  }
  me.setSuperClass(superDecl);
  LinkedList declInterfaceList=new LinkedList();
  Iterator interfaceItr=node.getInterfaces().iterator();
  while (interfaceItr.hasNext()) {
    ClassDecl intf=(ClassDecl)JavaDecl.getDecl((NamedNode)interfaceItr.next());
    if (intf.category != CG_INTERFACE) {
      ApplicationUtility.error(""String_Node_Str"" + node.getName().getIdent() + ""String_Node_Str""+ intf.getName());
    }
    declInterfaceList.addLast(intf);
  }
  me.setInterfaces(declInterfaceList);
  _addUserTypeToEnclosingClassEnviron(args.get(1),me);
  LinkedList childArgs=new LinkedList();
  childArgs.addLast(me);
  childArgs.addLast(me.getEnviron());
  TNLManip.traverseList(this,childArgs,node.getMembers());
  return null;
}","public Object visitClassDeclNode(ClassDeclNode node,LinkedList args){
  Object classDeclObj=args.get(0);
  if (classDeclObj instanceof ClassDecl) {
    ClassDecl classDecl=(ClassDecl)classDeclObj;
    if (classDecl.category == CG_INTERFACE) {
      int classPublic=classDecl.getModifiers() & PUBLIC_MOD;
      int modifiers=node.getModifiers();
      modifiers|=(classPublic | STATIC_MOD | FINAL_MOD);
      node.setModifiers(modifiers);
    }
  }
  ClassDecl me=(ClassDecl)JavaDecl.getDecl((NamedNode)node);
  if (!me.addVisitor(_myClass)) {
    return null;
  }
  TreeNode superClass=node.getSuperClass();
  ClassDecl superDecl;
  if (me == StaticResolution.OBJECT_DECL) {
    superDecl=null;
  }
 else   if (superClass == AbsentTreeNode.instance) {
    superDecl=StaticResolution.OBJECT_DECL;
  }
 else {
    try {
      superDecl=(ClassDecl)JavaDecl.getDecl(superClass);
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + node + ""String_Node_Str""+ args.get(0)+ ""String_Node_Str""+ superClass+ ""String_Node_Str""+ superClass.toString()+ ""String_Node_Str""+ e);
    }
  }
  if ((superDecl != null) && (superDecl.category != CG_CLASS)) {
    ApplicationUtility.error(""String_Node_Str"" + node.getName().getIdent() + ""String_Node_Str""+ superDecl.getName());
  }
  if (superDecl != null) {
    node.setSuperClass(superDecl.getDefType());
  }
  me.setSuperClass(superDecl);
  LinkedList declInterfaceList=new LinkedList();
  Iterator interfaceItr=node.getInterfaces().iterator();
  while (interfaceItr.hasNext()) {
    ClassDecl intf=(ClassDecl)JavaDecl.getDecl((NamedNode)interfaceItr.next());
    if (intf.category != CG_INTERFACE) {
      ApplicationUtility.error(""String_Node_Str"" + node.getName().getIdent() + ""String_Node_Str""+ intf.getName());
    }
    declInterfaceList.addLast(intf);
  }
  me.setInterfaces(declInterfaceList);
  _addUserTypeToEnclosingClassEnviron(args.get(1),me);
  LinkedList childArgs=new LinkedList();
  childArgs.addLast(me);
  childArgs.addLast(me.getEnviron());
  TNLManip.traverseList(this,childArgs,node.getMembers());
  return null;
}"
76032,"/** 
 * Propagate the number of fractional firings decided for this actor through the specified input port.   Set and verify the fractional firing for each Actor that is connected through this input port. Any actors that we calculate their firing vector for the first time are moved from RemainingActors to pendingActors.
 * @param currentPort The port that we are propagating from.
 * @param firings The current Map of fractional firings for eachActor.
 * @param remainingActors The set of actors that have not had theirfractional firing set.
 * @param pendingActors The set of actors that have had their rateset, but have not been propagated onwards.
 * @exception NotSchedulableException If the CompositeActor is notschedulable.
 * @exception IllegalActionException If any called method throws it.
 */
private void _propagateInputPort(IOPort currentPort,Map firings,LinkedList remainingActors,LinkedList pendingActors) throws NotSchedulableException, IllegalActionException {
  ComponentEntity currentActor=(ComponentEntity)currentPort.getContainer();
  int currentRate=getTokenConsumptionRate(currentPort);
  if (currentRate > 0) {
    Iterator connectedPorts=currentPort.deepConnectedOutPortList().iterator();
    while (connectedPorts.hasNext()) {
      IOPort connectedPort=(IOPort)connectedPorts.next();
      ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
      if (_debugging)       _debug(""String_Node_Str"" + connectedActor.getName());
      int connectedRate=getTokenProductionRate(connectedPort);
      Fraction currentFiring=(Fraction)firings.get(currentActor);
      Fraction desiredFiring=currentFiring.multiply(new Fraction(currentRate,connectedRate));
      try {
        Fraction presentFiring=(Fraction)firings.get(connectedActor);
        if (presentFiring.equals(Fraction.ZERO)) {
          firings.put(connectedActor,desiredFiring);
          remainingActors.remove(connectedActor);
          pendingActors.addLast(connectedActor);
        }
 else         if (!presentFiring.equals(desiredFiring))         throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
 catch (      NoSuchElementException e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ((ComponentEntity)connectedActor).getName() + ""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"");
        _debug(firings.toString());
      }
    }
  }
}","/** 
 * Propagate the number of fractional firings decided for this actor through the specified input port.   Set and verify the fractional firing for each Actor that is connected through this input port. Any actors that we calculate their firing vector for the first time are moved from RemainingActors to pendingActors.
 * @param currentPort The port that we are propagating from.
 * @param firings The current Map of fractional firings for eachActor.
 * @param remainingActors The set of actors that have not had theirfractional firing set.
 * @param pendingActors The set of actors that have had their rateset, but have not been propagated onwards.
 * @exception NotSchedulableException If the CompositeActor is notschedulable.
 * @exception IllegalActionException If any called method throws it.
 */
private void _propagateInputPort(IOPort currentPort,Map firings,LinkedList remainingActors,LinkedList pendingActors) throws NotSchedulableException, IllegalActionException {
  ComponentEntity currentActor=(ComponentEntity)currentPort.getContainer();
  int currentRate=getTokenConsumptionRate(currentPort);
  if (currentRate > 0) {
    Iterator connectedPorts=currentPort.deepConnectedOutPortList().iterator();
    while (connectedPorts.hasNext()) {
      IOPort connectedPort=(IOPort)connectedPorts.next();
      ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
      if (_debugging)       _debug(""String_Node_Str"" + connectedActor.getName());
      int connectedRate=getTokenProductionRate(connectedPort);
      Fraction currentFiring=(Fraction)firings.get(currentActor);
      Fraction desiredFiring=currentFiring.multiply(new Fraction(currentRate,connectedRate));
      try {
        Fraction presentFiring=(Fraction)firings.get(connectedActor);
        if (presentFiring == null) {
        }
 else         if (presentFiring.equals(Fraction.ZERO)) {
          firings.put(connectedActor,desiredFiring);
          remainingActors.remove(connectedActor);
          pendingActors.addLast(connectedActor);
        }
 else         if (!presentFiring.equals(desiredFiring))         throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
 catch (      NoSuchElementException e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ((ComponentEntity)connectedActor).getName() + ""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"");
        _debug(firings.toString());
      }
    }
  }
}"
76033,"/** 
 * Create a simple one-line text display, a non-editable value that is set externally using the setDisplay() method.
 * @param name The name used to identify the entry (when calling get).
 * @param label The label to attach to the entry.
 * @param theValue Default string to display.
 */
public void addDisplay(String name,String label,String theValue){
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  lbl.setBackground(_background);
  JTextArea displayField=new JTextArea(theValue,1,10);
  displayField.setEditable(false);
  displayField.setBackground(_background);
  _addPair(name,lbl,displayField);
}","/** 
 * Create a simple one-line text display, a non-editable value that is set externally using the setDisplay() method.
 * @param name The name used to identify the entry (when calling get).
 * @param label The label to attach to the entry.
 * @param theValue Default string to display.
 */
public void addDisplay(String name,String label,String theValue){
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  lbl.setBackground(_background);
  JTextArea displayField=new JTextArea(theValue,1,10);
  displayField.setEditable(false);
  displayField.setBackground(_background);
  _addPair(name,lbl,displayField,displayField);
}"
76034,"/** 
 * Create a bank of radio buttons.  A radio button provides a list of choices, only one of which may be chosen at a time.
 * @param name The name used to identify the entry (when calling get).
 * @param label The label to attach to the entry.
 * @param values The list of possible choices.
 * @param defaultValue Default value.
 */
public void addRadioButtons(String name,String label,String[] values,String defaultValue){
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  lbl.setBackground(_background);
  FlowLayout flow=new FlowLayout();
  flow.setAlignment(FlowLayout.LEFT);
  Panel buttonPanel=new Panel(flow);
  ButtonGroup group=new ButtonGroup();
  QueryActionListener listener=new QueryActionListener(name);
  JRadioButton[] buttons=new JRadioButton[values.length];
  for (int i=0; i < values.length; i++) {
    JRadioButton checkbox=new JRadioButton(values[i]);
    buttons[i]=checkbox;
    checkbox.setBackground(_background);
    checkbox.setOpaque(false);
    if (values[i].equals(defaultValue)) {
      checkbox.setSelected(true);
    }
    group.add(checkbox);
    buttonPanel.add(checkbox);
    checkbox.addActionListener(listener);
  }
  _addPair(name,lbl,buttonPanel);
  _entries.put(name,buttons);
}","/** 
 * Create a bank of radio buttons.  A radio button provides a list of choices, only one of which may be chosen at a time.
 * @param name The name used to identify the entry (when calling get).
 * @param label The label to attach to the entry.
 * @param values The list of possible choices.
 * @param defaultValue Default value.
 */
public void addRadioButtons(String name,String label,String[] values,String defaultValue){
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  lbl.setBackground(_background);
  FlowLayout flow=new FlowLayout();
  flow.setAlignment(FlowLayout.LEFT);
  Panel buttonPanel=new Panel(flow);
  ButtonGroup group=new ButtonGroup();
  QueryActionListener listener=new QueryActionListener(name);
  JRadioButton[] buttons=new JRadioButton[values.length];
  for (int i=0; i < values.length; i++) {
    JRadioButton checkbox=new JRadioButton(values[i]);
    buttons[i]=checkbox;
    checkbox.setBackground(_background);
    checkbox.setOpaque(false);
    if (values[i].equals(defaultValue)) {
      checkbox.setSelected(true);
    }
    group.add(checkbox);
    buttonPanel.add(checkbox);
    checkbox.addActionListener(listener);
  }
  _addPair(name,lbl,buttonPanel,buttons);
}"
76035,"/** 
 * Add a label and a widget to the panel.
 * @param name The name of the entry.
 * @param label The label.
 * @param widget The interactive entry to the right of the label.
 */
protected void _addPair(String name,JLabel label,Component widget){
  _constraints.gridwidth=1;
  _grid.setConstraints(label,_constraints);
  _entryPanel.add(label);
  _constraints.gridwidth=GridBagConstraints.REMAINDER;
  _grid.setConstraints(widget,_constraints);
  _entryPanel.add(widget);
  _entries.put(name,widget);
  _labels.put(name,label);
  _previous.put(name,stringValue(name));
}","/** 
 * Add a label and a widget to the panel.
 * @param name The name of the entry.
 * @param label The label.
 * @param widget The interactive entry to the right of the label.
 * @param entry The object that contains user data.
 */
protected void _addPair(String name,JLabel label,Component widget,Object entry){
  _constraints.gridwidth=1;
  _grid.setConstraints(label,_constraints);
  _entryPanel.add(label);
  _constraints.gridwidth=GridBagConstraints.REMAINDER;
  _grid.setConstraints(widget,_constraints);
  _entryPanel.add(widget);
  _entries.put(name,entry);
  _labels.put(name,label);
  _previous.put(name,stringValue(name));
}"
76036,"/** 
 * Create an on-off check box.
 * @param name The name used to identify the entry (when calling get).
 * @param label The label to attach to the entry.
 * @param defaultValue The default value (true for on).
 */
public void addCheckBox(String name,String label,boolean defaultValue){
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  lbl.setBackground(_background);
  JRadioButton checkbox=new JRadioButton();
  checkbox.setBackground(_background);
  checkbox.setOpaque(false);
  checkbox.setSelected(defaultValue);
  _addPair(name,lbl,checkbox);
  checkbox.addItemListener(new QueryItemListener(name));
}","/** 
 * Create an on-off check box.
 * @param name The name used to identify the entry (when calling get).
 * @param label The label to attach to the entry.
 * @param defaultValue The default value (true for on).
 */
public void addCheckBox(String name,String label,boolean defaultValue){
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  lbl.setBackground(_background);
  JRadioButton checkbox=new JRadioButton();
  checkbox.setBackground(_background);
  checkbox.setOpaque(false);
  checkbox.setSelected(defaultValue);
  _addPair(name,lbl,checkbox,checkbox);
  checkbox.addItemListener(new QueryItemListener(name));
}"
76037,"/** 
 * Create a single-line entry box with the specified name, label, and default value.  To control the width of the box, call setTextWidth() first.
 * @param name The name used to identify the entry (when accessingthe entry).
 * @param label The label to attach to the entry.
 * @param defaultValue Default value to appear in the entry box.
 */
public void addLine(String name,String label,String defaultValue){
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  lbl.setBackground(_background);
  JTextField entryBox=new JTextField(defaultValue,_width);
  entryBox.setBackground(Color.white);
  _addPair(name,lbl,entryBox);
  entryBox.addActionListener(new QueryActionListener(name));
  entryBox.addFocusListener(new QueryFocusListener(name));
}","/** 
 * Create a single-line entry box with the specified name, label, and default value.  To control the width of the box, call setTextWidth() first.
 * @param name The name used to identify the entry (when accessingthe entry).
 * @param label The label to attach to the entry.
 * @param defaultValue Default value to appear in the entry box.
 */
public void addLine(String name,String label,String defaultValue){
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  lbl.setBackground(_background);
  JTextField entryBox=new JTextField(defaultValue,_width);
  entryBox.setBackground(Color.white);
  _addPair(name,lbl,entryBox,entryBox);
  entryBox.addActionListener(new QueryActionListener(name));
  entryBox.addFocusListener(new QueryFocusListener(name));
}"
76038,"/** 
 * Create a choice menu.
 * @param name The name used to identify the entry (when calling get).
 * @param label The label to attach to the entry.
 * @param values The list of possible choices.
 * @param defaultChoice Default choice.
 * @param editable True if an arbitrary choice can be entered, in additionto the choices in values.
 */
public void addChoice(String name,String label,String[] values,String defaultChoice,boolean editable){
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  lbl.setBackground(_background);
  JComboBox combobox=new JComboBox(values);
  combobox.setEditable(editable);
  combobox.setBackground(Color.white);
  combobox.setSelectedItem(defaultChoice);
  _addPair(name,lbl,combobox);
  combobox.addItemListener(new QueryItemListener(name));
}","/** 
 * Create a choice menu.
 * @param name The name used to identify the entry (when calling get).
 * @param label The label to attach to the entry.
 * @param values The list of possible choices.
 * @param defaultChoice Default choice.
 * @param editable True if an arbitrary choice can be entered, in additionto the choices in values.
 */
public void addChoice(String name,String label,String[] values,String defaultChoice,boolean editable){
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  lbl.setBackground(_background);
  JComboBox combobox=new JComboBox(values);
  combobox.setEditable(editable);
  combobox.setBackground(Color.white);
  combobox.setSelectedItem(defaultChoice);
  _addPair(name,lbl,combobox,combobox);
  combobox.addItemListener(new QueryItemListener(name));
}"
76039,"/** 
 * Create a slider with the specified name, label, default value, maximum, and minimum.
 * @param name The name used to identify the slider.
 * @param label The label to attach to the slider.
 * @param defaultValue Initial position of slider.
 * @param maximum Maximum value of slider.
 * @param minimum Minimum value of slider.
 * @exception IllegalArgumentException If the desired default valueis not between the minimum and maximum.
 */
public void addSlider(String name,String label,int defaultValue,int minimum,int maximum) throws IllegalArgumentException {
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  if (minimum > maximum) {
    int temp=minimum;
    minimum=maximum;
    maximum=temp;
  }
  if ((defaultValue > maximum) || (defaultValue < minimum)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + defaultValue + ""String_Node_Str""+ ""String_Node_Str"");
  }
  JSlider slider=new JSlider(minimum,maximum,defaultValue);
  _addPair(name,lbl,slider);
  slider.addChangeListener(new SliderListener(name));
}","/** 
 * Create a slider with the specified name, label, default value, maximum, and minimum.
 * @param name The name used to identify the slider.
 * @param label The label to attach to the slider.
 * @param defaultValue Initial position of slider.
 * @param maximum Maximum value of slider.
 * @param minimum Minimum value of slider.
 * @exception IllegalArgumentException If the desired default valueis not between the minimum and maximum.
 */
public void addSlider(String name,String label,int defaultValue,int minimum,int maximum) throws IllegalArgumentException {
  JLabel lbl=new JLabel(label + ""String_Node_Str"");
  if (minimum > maximum) {
    int temp=minimum;
    minimum=maximum;
    maximum=temp;
  }
  if ((defaultValue > maximum) || (defaultValue < minimum)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + defaultValue + ""String_Node_Str""+ ""String_Node_Str"");
  }
  JSlider slider=new JSlider(minimum,maximum,defaultValue);
  _addPair(name,lbl,slider,slider);
  slider.addChangeListener(new SliderListener(name));
}"
76040,"/** 
 * Construct a mutation request to be executed in the specified context. The context is typically a Ptolemy II container, such as an entity, within which the objects specified by the MoML code will be placed. This method resets and uses a parser that is a static member of this class. A listener to changes will probably want to check the originator so that when it is notified of errors or successful completion of changes, it can tell whether the change is one it requested. Alternatively, it can call waitForCompletion().
 * @param originator The originator of the change request.
 * @param context The context in which to execute the MoML.
 * @param request The mutation request in MoML.
 */
public MoMLChangeRequest(Object originator,NamedObj context,String request){
  super(originator,request);
  _staticParser.reset();
  _parser=_staticParser;
  _parser.setContext(context);
}","/** 
 * Construct a mutation request to be executed in the specified context. The context is typically a Ptolemy II container, such as an entity, within which the objects specified by the MoML code will be placed. This method resets and uses a parser that is a static member of this class. A listener to changes will probably want to check the originator so that when it is notified of errors or successful completion of changes, it can tell whether the change is one it requested. Alternatively, it can call waitForCompletion().
 * @param originator The originator of the change request.
 * @param context The context in which to execute the MoML.
 * @param request The mutation request in MoML.
 */
public MoMLChangeRequest(Object originator,NamedObj context,String request){
  super(originator,request);
  _parser=_staticParser;
  _context=context;
}"
76041,"/** 
 * Execute the change by evaluating the request using the specified parser.
 * @exception Exception If an exception is thrownwhile evaluating the request.
 */
protected void _execute() throws Exception {
  _parser.parse(getDescription());
}","/** 
 * Execute the change by evaluating the request using the specified parser.
 * @exception Exception If an exception is thrownwhile evaluating the request.
 */
protected void _execute() throws Exception {
  _parser.reset();
  if (_context != null) {
    _parser.setContext(_context);
  }
  _parser.parse(getDescription());
}"
76042,"/** 
 * Write a MoML description of the contents of this object, which in this class is the configuration information. This method is called by exportMoML().  Each description is indented according to the specified depth and terminated with a newline character.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @exception IOException If an I/O error occurs.
 */
protected void _exportMoMLContents(Writer output,int depth) throws IOException {
  super._exportMoMLContents(output,depth);
  String header=""String_Node_Str"" + ""String_Node_Str"";
  output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + header+ ""String_Node_Str"");
  PrintWriter print=new PrintWriter(output);
  histogram.writeFormat(print);
  output.write(""String_Node_Str"" + _getIndentPrefix(depth) + ""String_Node_Str"");
}","/** 
 * Write a MoML description of the contents of this object, which in this class is the configuration information. This method is called by exportMoML().  Each description is indented according to the specified depth and terminated with a newline character.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @exception IOException If an I/O error occurs.
 */
protected void _exportMoMLContents(Writer output,int depth) throws IOException {
  super._exportMoMLContents(output,depth);
  String header=""String_Node_Str"" + ""String_Node_Str"";
  if (histogram != null) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + header+ ""String_Node_Str"");
    PrintWriter print=new PrintWriter(output);
    histogram.writeFormat(print);
    output.write(""String_Node_Str"" + _getIndentPrefix(depth) + ""String_Node_Str"");
  }
}"
76043,"/** 
 * Notify all registered listeners that something changed for the  specified entry, if it indeed has changed.  The stringValue() method is used to check the current value against the previously notified value, or the original value if there have been no notifications.
 * @param name The entry that may have changed.
 */
void _notifyListeners(String name){
  if (_listeners != null) {
    String previous=(String)_previous.get(name);
    String newValue=stringValue(name);
    if (newValue.equals(previous))     return;
    _previous.put(name,newValue);
    Enumeration listeners=_listeners.elements();
    while (listeners.hasMoreElements()) {
      QueryListener queueListener=(QueryListener)(listeners.nextElement());
      queueListener.changed(name);
    }
  }
}","/** 
 * Notify all registered listeners that something changed for the  specified entry, if it indeed has changed.  The stringValue() method is used to check the current value against the previously notified value, or the original value if there have been no notifications.
 * @param name The entry that may have changed.
 */
void _notifyListeners(String name){
  if (_listeners != null) {
    String previous=(String)_previous.get(name);
    String newValue=stringValue(name);
    if (newValue.equals(previous)) {
      return;
    }
    _previous.put(name,newValue);
    Enumeration listeners=_listeners.elements();
    while (listeners.hasMoreElements()) {
      QueryListener queryListener=(QueryListener)(listeners.nextElement());
      queryListener.changed(name);
    }
  }
}"
76044,"/** 
 * Set the value in the entry with the given name. The second argument must be a string that can be parsed to the proper type for the given entry, or an exception is thrown. Note that this does NOT trigger the notification of listeners, and intended to allow a way to set the query to reflect the current state.
 * @param name The name used to identify the entry (when calling get).
 * @param value The value to set the entry to.
 * @exception NoSuchElementException If there is no item with thespecified name.  Note that this is a runtime exception, so it need not be declared explicitly.
 * @exception IllegalArgumentException If the value does not parseto the appropriate type.
 */
public void set(String name,String value) throws NoSuchElementException, IllegalArgumentException {
  Object result=_entries.get(name);
  if (result == null) {
    throw new NoSuchElementException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  if (result instanceof JTextField) {
    ((JTextField)result).setText(value);
  }
 else   if (result instanceof JTextArea) {
    ((JTextArea)result).setText(value);
  }
 else   if (result instanceof JRadioButton) {
    Boolean flag=new Boolean(value);
    setBoolean(name,flag.booleanValue());
  }
 else   if (result instanceof JSlider) {
    Integer parsed=new Integer(value);
    ((JSlider)result).setValue(parsed.intValue());
  }
 else   if (result instanceof JComboBox) {
    ((JComboBox)result).setSelectedItem(value);
  }
 else   if (result instanceof JRadioButton[]) {
    JRadioButton[] buttons=(JRadioButton[])result;
    for (int i=0; i < buttons.length; i++) {
      if (value.equals(buttons[i].getText())) {
        buttons[i].setSelected(true);
      }
 else {
        buttons[i].setSelected(false);
      }
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + result.getClass());
  }
}","/** 
 * Set the value in the entry with the given name. The second argument must be a string that can be parsed to the proper type for the given entry, or an exception is thrown. Note that this does NOT trigger the notification of listeners, and intended to allow a way to set the query to reflect the current state.
 * @param name The name used to identify the entry (when calling get).
 * @param value The value to set the entry to.
 * @exception NoSuchElementException If there is no item with thespecified name.  Note that this is a runtime exception, so it need not be declared explicitly.
 * @exception IllegalArgumentException If the value does not parseto the appropriate type.
 */
public void set(String name,String value) throws NoSuchElementException, IllegalArgumentException {
  Object result=_entries.get(name);
  if (result == null) {
    throw new NoSuchElementException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  if (result instanceof JTextField) {
    ((JTextField)result).setText(value);
  }
 else   if (result instanceof JTextArea) {
    ((JTextArea)result).setText(value);
  }
 else   if (result instanceof JRadioButton) {
    Boolean flag=new Boolean(value);
    setBoolean(name,flag.booleanValue());
  }
 else   if (result instanceof JSlider) {
    Integer parsed=new Integer(value);
    ((JSlider)result).setValue(parsed.intValue());
  }
 else   if (result instanceof JComboBox) {
    ((JComboBox)result).setSelectedItem(value);
  }
 else   if (result instanceof JRadioButton[]) {
    JRadioButton[] buttons=(JRadioButton[])result;
    for (int i=0; i < buttons.length; i++) {
      if (value.equals(buttons[i].getText())) {
        buttons[i].setSelected(true);
      }
 else {
        buttons[i].setSelected(false);
      }
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + result.getClass());
  }
  _previous.put(name,value);
}"
76045,"/** 
 * Specify a message to be displayed above the query.
 * @param message The message to display.
 */
public void setMessage(String message){
  if (_messageArea == null) {
    _messageArea=new JTextArea(message);
    _messageArea.setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
    _messageArea.setEditable(false);
    _messageArea.setLineWrap(true);
    _messageArea.setWrapStyleWord(true);
    _messageArea.setBackground(getBackground());
    _messageArea.setAlignmentX(0.0f);
    _messagePanel.setLayout(new BoxLayout(_messagePanel,BoxLayout.Y_AXIS));
    _messagePanel.add(_messageArea);
    Component strut=Box.createVerticalStrut(10);
    _messagePanel.add(strut);
  }
 else {
    _messageArea.setText(message);
  }
  validate();
}","/** 
 * Specify a message to be displayed above the query.
 * @param message The message to display.
 */
public void setMessage(String message){
  if (_messageArea == null) {
    _messageArea=new JTextArea(message);
    _messageArea.setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
    _messageArea.setEditable(false);
    _messageArea.setLineWrap(true);
    _messageArea.setWrapStyleWord(true);
    _messageArea.setBackground(getBackground());
    _messageArea.setAlignmentX(0.0f);
    _messagePanel.setLayout(new BoxLayout(_messagePanel,BoxLayout.Y_AXIS));
    _messagePanel.add(_messageArea);
    _messagePanel.add(Box.createRigidArea(new Dimension(0,10)));
  }
 else {
    _messageArea.setText(message);
  }
  validate();
}"
76046,"/** 
 * Request restoration of the parameter values to what they were when this object was created.  The actual restoration occurs later, in the UI thread, in order to allow all pending changes to the parameter values to be processed first.
 */
public void restore(){
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      Iterator entries=_originalValues.entrySet().iterator();
      while (entries.hasNext()) {
        Map.Entry entry=(Map.Entry)entries.next();
        Parameter param=(Parameter)_object.getAttribute((String)entry.getKey());
        param.setExpression((String)entry.getValue());
      }
    }
  }
);
}","/** 
 * Request restoration of the parameter values to what they were when this object was created.  The actual restoration occurs later, in the UI thread, in order to allow all pending changes to the parameter values to be processed first.
 */
public void restore(){
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      Iterator entries=_originalValues.entrySet().iterator();
      while (entries.hasNext()) {
        Map.Entry entry=(Map.Entry)entries.next();
        Parameter param=(Parameter)_object.getAttribute((String)entry.getKey());
        param.setExpression((String)entry.getValue());
        try {
          param.getToken();
        }
 catch (        IllegalActionException ex) {
        }
      }
    }
  }
);
}"
76047,"public void run(){
  Iterator entries=_originalValues.entrySet().iterator();
  while (entries.hasNext()) {
    Map.Entry entry=(Map.Entry)entries.next();
    Parameter param=(Parameter)_object.getAttribute((String)entry.getKey());
    param.setExpression((String)entry.getValue());
  }
}","public void run(){
  Iterator entries=_originalValues.entrySet().iterator();
  while (entries.hasNext()) {
    Map.Entry entry=(Map.Entry)entries.next();
    Parameter param=(Parameter)_object.getAttribute((String)entry.getKey());
    param.setExpression((String)entry.getValue());
    try {
      param.getToken();
    }
 catch (    IllegalActionException ex) {
    }
  }
}"
76048,"/** 
 * Construct a configurer for the specified object.
 * @param object The object to configure.
 */
public Configurer(NamedObj object){
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  _object=object;
  Iterator params=object.attributeList(Parameter.class).iterator();
  while (params.hasNext()) {
    Parameter param=(Parameter)params.next();
    _originalValues.put(param.getName(),param.stringRepresentation());
  }
  boolean foundOne=false;
  Iterator editors=object.attributeList(EditorPaneFactory.class).iterator();
  while (editors.hasNext()) {
    foundOne=true;
    EditorPaneFactory editor=(EditorPaneFactory)editors.next();
    Component pane=editor.createEditorPane();
    add(pane);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
  if (!foundOne) {
    try {
      EditorPaneFactory editor=new EditorPaneFactory(object,object.uniqueName(""String_Node_Str""));
      Component pane=editor.createEditorPane();
      add(pane);
      if (pane instanceof CloseListener) {
        _closeListeners.add(pane);
      }
    }
 catch (    NameDuplicationException ex) {
      throw new InternalErrorException(ex.toString());
    }
catch (    IllegalActionException ex) {
      throw new InternalErrorException(ex.toString());
    }
  }
}","/** 
 * Construct a configurer for the specified object.
 * @param object The object to configure.
 */
public Configurer(final NamedObj object){
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  _object=object;
  Iterator params=object.attributeList(Parameter.class).iterator();
  while (params.hasNext()) {
    Parameter param=(Parameter)params.next();
    _originalValues.put(param.getName(),param.stringRepresentation());
  }
  boolean foundOne=false;
  Iterator editors=object.attributeList(EditorPaneFactory.class).iterator();
  while (editors.hasNext()) {
    foundOne=true;
    EditorPaneFactory editor=(EditorPaneFactory)editors.next();
    Component pane=editor.createEditorPane();
    add(pane);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
  if (!foundOne) {
    Component pane=EditorPaneFactory.createEditorPane(object);
    add(pane);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
}"
76049,"/** 
 * Return a new widget for configuring the container.
 * @return A new widget for configuring the container.
 */
public Component createEditorPane(){
  Nameable handler=getContainer();
  while (handler != null && !(handler instanceof CompositeEntity)) {
    handler=handler.getContainer();
  }
  PtolemyQuery query=new PtolemyQuery((CompositeEntity)handler);
  query.setTextWidth(25);
  NamedObj container=(NamedObj)getContainer();
  Iterator params=container.attributeList(Parameter.class).iterator();
  boolean foundOne=false;
  while (params.hasNext()) {
    foundOne=true;
    Parameter param=(Parameter)params.next();
    query.addStyledEntry(param);
  }
  if (!foundOne) {
    return new JLabel(container.getName() + ""String_Node_Str"");
  }
  return query;
}","/** 
 * Return a new widget for configuring the specified object. This can be used for objects that do not contain an instance of EditorPaneFactory as an attribute.
 * @return A new widget for configuring the specified object.
 */
public static Component createEditorPane(NamedObj object){
  PtolemyQuery query=new PtolemyQuery(object);
  query.setTextWidth(25);
  Iterator params=object.attributeList(Parameter.class).iterator();
  boolean foundOne=false;
  while (params.hasNext()) {
    foundOne=true;
    Parameter param=(Parameter)params.next();
    query.addStyledEntry(param);
  }
  if (!foundOne) {
    return new JLabel(object.getName() + ""String_Node_Str"");
  }
  return query;
}"
76050,"/** 
 * Return an AST that contains a class declaration. 
 */
public static ClassDeclNode ASTClassDeclNode(Class myClass){
  int modifiers=Modifier.convertModifiers(myClass.getModifiers());
  String fullClassName=myClass.getName();
  NameNode className=new NameNode(AbsentTreeNode.instance,fullClassName.substring(1 + fullClassName.lastIndexOf('.')));
  List interfaceList=new LinkedList();
  Class interfaceClasses[]=myClass.getInterfaces();
  for (int i=0; i < interfaceClasses.length; i++) {
    int interfaceModifiers=Modifier.convertModifiers(interfaceClasses[i].getModifiers());
    String fullInterfaceName=interfaceClasses[i].getName();
    TypeNode interfaceDeclNode=new TypeNameNode(new NameNode(AbsentTreeNode.instance,fullInterfaceName.substring(1 + fullInterfaceName.lastIndexOf('.'))));
    interfaceList.add(interfaceDeclNode);
  }
  LinkedList memberList=new LinkedList();
  memberList.addAll(constructorsASTList(myClass));
  memberList.addAll(methodsASTList(myClass));
  memberList.addAll(fieldsASTList(myClass));
  TreeNode superClass=null;
  if (myClass.getPackage() == null) {
    superClass=(TreeNode)_makeNameNode(""String_Node_Str"");
  }
 else {
    superClass=(TreeNode)_makeNameNode(myClass.getSuperclass().getName());
  }
  ClassDeclNode classDeclNode=new ClassDeclNode(modifiers,className,interfaceList,memberList,superClass);
  return classDeclNode;
}","/** 
 * Return an AST that contains a class declaration. 
 */
public static ClassDeclNode ASTClassDeclNode(Class myClass){
  int modifiers=Modifier.convertModifiers(myClass.getModifiers());
  String fullClassName=myClass.getName();
  NameNode className=new NameNode(AbsentTreeNode.instance,fullClassName.substring(1 + fullClassName.lastIndexOf('.')));
  List interfaceList=new LinkedList();
  Class interfaceClasses[]=myClass.getInterfaces();
  for (int i=0; i < interfaceClasses.length; i++) {
    int interfaceModifiers=Modifier.convertModifiers(interfaceClasses[i].getModifiers());
    String fullInterfaceName=interfaceClasses[i].getName();
    TypeNode interfaceDeclNode=new TypeNameNode(new NameNode(AbsentTreeNode.instance,fullInterfaceName.substring(1 + fullInterfaceName.lastIndexOf('.'))));
    interfaceList.add(interfaceDeclNode);
  }
  LinkedList memberList=new LinkedList();
  memberList.addAll(constructorsASTList(myClass));
  memberList.addAll(methodsASTList(myClass));
  memberList.addAll(fieldsASTList(myClass));
  TreeNode superClass=null;
  if (myClass.getPackage() == null) {
    superClass=(TreeNode)_makeNameNode(""String_Node_Str"");
  }
 else {
    if (myClass.getSuperclass() != null) {
      superClass=(TreeNode)_makeNameNode(myClass.getSuperclass().getName());
    }
  }
  ClassDeclNode classDeclNode=new ClassDeclNode(modifiers,className,interfaceList,memberList,superClass);
  return classDeclNode;
}"
76051,"public final boolean matches(String name,int mask){
  if ((category & mask) != 0) {
    return (name.equals(ANY_NAME) || name.equals(_name));
  }
  return false;
}","public final boolean matches(String name,int mask){
  if ((category & mask) != 0) {
    return (name.equals(ANY_NAME) || _name.equals(ANY_NAME) || name.equals(_name));
  }
  if (category == 0 && mask == 0) {
    return (name.equals(ANY_NAME) || name.equals(_name));
  }
  return false;
}"
76052,"/** 
 * Constuct an environment nested inside the parent argument, with the given List of Decl's in this environment itself.
 */
public Environ(Environ parent,List declList){
  _parent=parent;
  _declList=declList;
}","/** 
 * Construct an environment nested inside the parent argument, with the given List of Decl's in this environment itself.
 */
public Environ(Environ parent,List declList){
  _parent=parent;
  _declList=declList;
}"
76053,"/** 
 * Create an entity controller associated with the specified graph controller.
 * @param controller The associated graph controller.
 */
public EntityController(GraphController controller){
  super(controller);
  setNodeRenderer(new EntityRenderer());
  SelectionModel sm=controller.getSelectionModel();
  NodeInteractor interactor=(NodeInteractor)getNodeInteractor();
  interactor.setSelectionModel(sm);
  VergilApplication application=VergilApplication.getInstance();
  Action action=application.getAction(""String_Node_Str"");
  ActionInteractor actionInteractor=new ActionInteractor(action);
  actionInteractor.setConsuming(false);
  actionInteractor.setMouseFilter(new MouseFilter(1,0,0,2));
  interactor.addInteractor(actionInteractor);
  interactor.setDragInteractor(interactor.getDragInteractor());
  _menuCreator=new MenuCreator(new EntityContextMenuFactory(controller));
  interactor.addInteractor(_menuCreator);
  Filter portFilter=new Filter(){
    public boolean accept(    Object o){
      if (o instanceof Port) {
        return true;
      }
 else {
        return false;
      }
    }
  }
;
  GlobalLayout layout=new EntityLayout();
  controller.addGraphViewListener(new IncrementalLayoutListener(new IncrLayoutAdapter(layout),portFilter));
}","/** 
 * Create an entity controller associated with the specified graph controller.
 * @param controller The associated graph controller.
 */
public EntityController(GraphController controller){
  super(controller);
  setNodeRenderer(new EntityRenderer());
  SelectionModel sm=controller.getSelectionModel();
  NodeInteractor interactor=(NodeInteractor)getNodeInteractor();
  interactor.setSelectionModel(sm);
  VergilApplication application=VergilApplication.getInstance();
  Action action=application.getAction(""String_Node_Str"");
  ActionInteractor actionInteractor=new ActionInteractor(action);
  actionInteractor.setConsuming(false);
  actionInteractor.setMouseFilter(new MouseFilter(1,0,0,2));
  interactor.addInteractor(actionInteractor);
  interactor.setDragInteractor(interactor.getDragInteractor());
  _menuCreator=new MenuCreator(new EntityContextMenuFactory(controller));
  interactor.addInteractor(_menuCreator);
  Filter portFilter=new Filter(){
    public boolean accept(    Object o){
      GraphModel model=getController().getGraphModel();
      if (o instanceof Port && model.getParent(o) instanceof Icon) {
        return true;
      }
 else {
        return false;
      }
    }
  }
;
  GlobalLayout layout=new EntityLayout();
  controller.addGraphViewListener(new IncrementalLayoutListener(new IncrLayoutAdapter(layout),portFilter));
}"
76054,"public boolean accept(Object o){
  if (o instanceof Port) {
    return true;
  }
 else {
    return false;
  }
}","public boolean accept(Object o){
  GraphModel model=getController().getGraphModel();
  if (o instanceof Port && model.getParent(o) instanceof Icon) {
    return true;
  }
 else {
    return false;
  }
}"
76055,"private byte[] _doubleArrayToByteArray(double[][] doubleArray,int bytesPerSample,int channels){
  int lengthInSamples=doubleArray[0].length;
  double maxSample;
  if (bytesPerSample == 2) {
    maxSample=32768;
  }
 else   if (bytesPerSample == 1) {
    maxSample=128;
  }
 else   if (bytesPerSample == 3) {
    maxSample=8388608;
  }
 else   if (bytesPerSample == 4) {
    maxSample=147483648e9;
  }
 else {
    maxSample=0;
  }
  byte[] byteArray=new byte[lengthInSamples * bytesPerSample * channels];
  byte[] b=new byte[bytesPerSample];
  for (int currSamp=0; currSamp < lengthInSamples; currSamp++) {
    int l;
    for (int currChannel=0; currChannel < channels; currChannel++) {
      if (doubleArray[currChannel][currSamp] > 1) {
        l=(int)maxSample;
      }
 else       if (doubleArray[currChannel][currSamp] < -1) {
        l=(int)(-maxSample);
      }
 else {
        l=(int)(doubleArray[currChannel][currSamp] * maxSample);
      }
      for (int i=0; i < bytesPerSample; i+=1, l>>=8)       b[bytesPerSample - i - 1]=(byte)l;
      for (int i=0; i < bytesPerSample; i+=1) {
        byteArray[currSamp * bytesPerSample * channels + bytesPerSample * currChannel + i]=b[i];
      }
    }
  }
  return byteArray;
}","private byte[] _doubleArrayToByteArray(double[][] doubleArray,int bytesPerSample,int channels){
  int lengthInSamples=doubleArray[0].length;
  double maxSample;
  if (bytesPerSample == 2) {
    maxSample=32768;
  }
 else   if (bytesPerSample == 1) {
    maxSample=128;
  }
 else   if (bytesPerSample == 3) {
    maxSample=8388608;
  }
 else   if (bytesPerSample == 4) {
    maxSample=147483648e9;
  }
 else {
    maxSample=0;
  }
  byte[] byteArray=new byte[lengthInSamples * bytesPerSample * channels];
  byte[] b=new byte[bytesPerSample];
  for (int currSamp=0; currSamp < lengthInSamples; currSamp++) {
    int l;
    for (int currChannel=0; currChannel < channels; currChannel++) {
      if (doubleArray[currChannel][currSamp] >= 1) {
        l=(int)maxSample - 1;
      }
 else       if (doubleArray[currChannel][currSamp] <= -1) {
        l=(int)(-maxSample) + 1;
      }
 else {
        l=(int)(doubleArray[currChannel][currSamp] * maxSample);
      }
      for (int i=0; i < bytesPerSample; i+=1, l>>=8)       b[bytesPerSample - i - 1]=(byte)l;
      for (int i=0; i < bytesPerSample; i+=1) {
        byteArray[currSamp * bytesPerSample * channels + bytesPerSample * currChannel + i]=b[i];
      }
    }
  }
  return byteArray;
}"
76056,"private byte[] _intArrayToByteArray(int[][] intArray,int bytesPerSample,int channels){
  int lengthInSamples=intArray[0].length;
  byte[] byteArray=new byte[lengthInSamples * bytesPerSample * channels];
  byte[] b=new byte[bytesPerSample];
  for (int currSamp=0; currSamp < lengthInSamples; currSamp++) {
    for (int currChannel=0; currChannel < channels; currChannel++) {
      int l=intArray[currChannel][currSamp];
      for (int i=0; i < bytesPerSample; i+=1, l>>=8)       b[bytesPerSample - i - 1]=(byte)l;
      for (int i=0; i < bytesPerSample; i+=1) {
        byteArray[currSamp * bytesPerSample * channels + bytesPerSample * currChannel + i]=b[i];
      }
    }
  }
  return byteArray;
}","private byte[] _intArrayToByteArray(int[][] intArray,int bytesPerSample,int channels){
  int lengthInSamples=intArray[0].length;
  byte[] byteArray=new byte[lengthInSamples * bytesPerSample * channels];
  byte[] b=new byte[bytesPerSample];
  for (int currSamp=0; currSamp < lengthInSamples; currSamp++) {
    for (int currChannel=0; currChannel < channels; currChannel++) {
      int l=intArray[currChannel][currSamp];
      int maxSample;
      if (bytesPerSample == 2) {
        maxSample=32768;
      }
 else       if (bytesPerSample == 1) {
        maxSample=128;
      }
 else       if (bytesPerSample == 3) {
        maxSample=8388608;
      }
 else       if (bytesPerSample == 4) {
        maxSample=1474836480;
      }
 else {
        maxSample=0;
      }
      if (l > (maxSample - 1)) {
        l=maxSample - 1;
      }
 else       if (l < (-maxSample + 1)) {
        l=-maxSample + 1;
      }
      for (int i=0; i < bytesPerSample; i+=1, l>>=8)       b[bytesPerSample - i - 1]=(byte)l;
      for (int i=0; i < bytesPerSample; i+=1) {
        byteArray[currSamp * bytesPerSample * channels + bytesPerSample * currChannel + i]=b[i];
      }
    }
  }
  return byteArray;
}"
76057,"/** 
 * Check parameters and begin the sound capture process. If the capture source is a sound file, the file is opened for writing. Any existing file of the same name will be silently overwritten.
 * @exception IllegalActionException If the parametersare out of range.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (_debugging)   _debug(""String_Node_Str"");
  _initializeCapture();
  _haveASample=false;
}","/** 
 * Check parameters and begin the sound capture process. If the capture source is a sound file, the file is opened for writing. Any existing file of the same name will be silently overwritten.
 * @exception IllegalActionException If the parametersare out of range.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (_debugging)   _debug(""String_Node_Str"");
  _initializeCapture();
  _safeToInitialize=true;
  _haveASample=false;
}"
76058,"/** 
 * Stop capturing audio. This method should be called when no more calls to getSamples(). are required, so that the system resources involved in the audio capture may be freed.
 * @exception IOException If there is a problem closing theaudio resources.
 */
public void stopCapture() throws IOException {
  _isAudioCaptureActive=false;
  if (_audioInputStream != null) {
    _audioInputStream.close();
  }
  if (_properFormatAudioInputStream != null) {
    _properFormatAudioInputStream.close();
  }
  if (_targetLine != null) {
    _targetLine.close();
  }
}","/** 
 * Stop capturing audio. This method should be called when no more calls to getSamples(). are required, so that the system resources involved in the audio capture may be freed.
 * @exception IOException If there is a problem closing theaudio resources.
 */
public void stopCapture() throws IOException {
  _isAudioCaptureActive=false;
  if (_audioInputStream != null) {
    _audioInputStream.close();
  }
  if (_properFormatAudioInputStream != null) {
    _properFormatAudioInputStream.close();
  }
  if (_targetLine != null) {
    if (_targetLine.isOpen() == true) {
      _targetLine.stop();
      _targetLine.close();
      _targetLine=null;
    }
  }
}"
76059,"/** 
 * Stop playing/writing audio. This method should be called when no more calls to putSamples(). are required, so that the system resources involved in the audio playback may be freed. <p> If the ""write audio data to file"" constructor was used, then the sound file specified by the constructor is saved and closed.
 * @exception IOException If there is a problem closing theaudio resources, or if the ""write audio data  to file"" constructor was used  and the sound file has an unsupported format.
 */
public void stopPlayback() throws IOException {
  _isAudioPlaybackActive=false;
  if (_playbackMode == ""String_Node_Str"") {
    if (_sourceLine != null) {
      _sourceLine.stop();
      _sourceLine.close();
    }
    _sourceLine=null;
  }
 else   if (_playbackMode == ""String_Node_Str"") {
    _stopPlaybackToFile();
  }
 else {
  }
}","/** 
 * Stop playing/writing audio. This method should be called when no more calls to putSamples(). are required, so that the system resources involved in the audio playback may be freed. <p> If the ""write audio data to file"" constructor was used, then the sound file specified by the constructor is saved and closed.
 * @exception IOException If there is a problem closing theaudio resources, or if the ""write audio data  to file"" constructor was used  and the sound file has an unsupported format.
 */
public void stopPlayback() throws IOException {
  _isAudioPlaybackActive=false;
  if (_playbackMode == ""String_Node_Str"") {
    if (_sourceLine != null) {
      _sourceLine.drain();
      _sourceLine.stop();
      _sourceLine.close();
    }
    _sourceLine=null;
  }
 else   if (_playbackMode == ""String_Node_Str"") {
    _stopPlaybackToFile();
  }
 else {
  }
}"
76060,"/** 
 * Handle change requests for all parameters. An exception is thrown if the requested change is not allowed.
 * @exception IllegalActionException If the change is notallowed.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"" + attribute.getName());
  if (attribute == channels) {
    _channels=((IntToken)channels.getToken()).intValue();
    if (_channels < 1) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _channels + ""String_Node_Str""+ ""String_Node_Str"");
    }
    if ((_inArray == null) || (_channels != _inArray.length)) {
      _inArray=new Token[_channels][];
    }
    if ((_audioPutArray == null) || (_channels != _audioPutArray.length)) {
      _audioPutArray=new double[_channels][];
    }
  }
 else   if (attribute == pathName) {
  }
 else   if (attribute == sampleRate) {
  }
 else   if (attribute == sampleSizeInBits) {
  }
 else   if (attribute == bufferSize) {
    int intBufferSize=((IntToken)bufferSize.getToken()).intValue();
    if (intBufferSize < _putFactor) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + intBufferSize + ""String_Node_Str""+ ""String_Node_Str""+ _putFactor+ ""String_Node_Str"");
    }
    _putSampleSize=intBufferSize / _putFactor;
    for (int i=0; i < _channels; i++) {
      _audioPutArray[i]=new double[_putSampleSize];
    }
  }
 else {
    super.attributeChanged(attribute);
    return;
  }
  if (_safeToInitialize == true) {
    _initializePlayback();
  }
}","/** 
 * Handle change requests for all parameters. An exception is thrown if the requested change is not allowed.
 * @exception IllegalActionException If the change is notallowed.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"" + attribute.getName());
  if (attribute == channels) {
    _channels=((IntToken)channels.getToken()).intValue();
    if (_channels < 1) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _channels + ""String_Node_Str""+ ""String_Node_Str"");
    }
    if ((_inArray == null) || (_channels != _inArray.length)) {
      _inArray=new Token[_channels][];
    }
    if ((_audioPutArray == null) || (_channels != _audioPutArray.length)) {
      _audioPutArray=new double[_channels][];
    }
    for (int i=0; i < _channels; i++) {
      _audioPutArray[i]=new double[_putSampleSize];
    }
  }
 else   if (attribute == pathName) {
  }
 else   if (attribute == sampleRate) {
  }
 else   if (attribute == sampleSizeInBits) {
  }
 else   if (attribute == bufferSize) {
    int intBufferSize=((IntToken)bufferSize.getToken()).intValue();
    if (intBufferSize < _putFactor) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + intBufferSize + ""String_Node_Str""+ ""String_Node_Str""+ _putFactor+ ""String_Node_Str"");
    }
    _putSampleSize=intBufferSize / _putFactor;
    for (int i=0; i < _channels; i++) {
      _audioPutArray[i]=new double[_putSampleSize];
    }
  }
 else {
    super.attributeChanged(attribute);
    return;
  }
  if (_safeToInitialize == true) {
    _initializePlayback();
  }
}"
76061,"/** 
 * If there are at least <i>count</i> tokens on the input port, invoke <i>count</i> iterations of this actor. Otherwise, do nothing, and return a value of COMPLETED. One token is read from each channel in an iteration.  The audio output is either a sound file and/or the speaker, depending on the current  mode, which is controlled by the value of the <i>pathName</i>  parameter.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, throw an exception.
 * @exception IllegalActionException If the <i>count</i> samplescannot be written to the audio output device.
 */
public int iterate(int count) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"" + count);
  for (int j=0; j < _channels; j++) {
    if (input.hasToken(j,count)) {
      _inArray[j]=input.get(j,count);
    }
 else {
      return COMPLETED;
    }
  }
  for (int k=0; k < count; k++) {
    for (int m=0; m < _channels; m++) {
      double deleteMePlease=((DoubleToken)_inArray[m][k]).doubleValue();
      _audioPutArray[m][_curElement]=((DoubleToken)_inArray[m][k]).doubleValue();
    }
    _curElement++;
    if (_curElement == _putSampleSize) {
      try {
        _soundPlayback.putSamples(_audioPutArray);
      }
 catch (      Exception ex) {
        throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
      }
      _curElement=0;
    }
  }
  return COMPLETED;
}","/** 
 * If there are at least <i>count</i> tokens on the input port, invoke <i>count</i> iterations of this actor. Otherwise, do nothing, and return a value of COMPLETED. One token is read from each channel in an iteration.  The audio output is either a sound file and/or the speaker, depending on the current  mode, which is controlled by the value of the <i>pathName</i>  parameter.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, throw an exception.
 * @exception IllegalActionException If the <i>count</i> samplescannot be written to the audio output device.
 */
public int iterate(int count) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"" + count);
  for (int j=0; j < _channels; j++) {
    if (input.hasToken(j,count)) {
      _inArray[j]=input.get(j,count);
    }
 else {
      return COMPLETED;
    }
  }
  for (int k=0; k < count; k++) {
    for (int m=0; m < _channels; m++) {
      _audioPutArray[m][_curElement]=((DoubleToken)_inArray[m][k]).doubleValue();
    }
    _curElement++;
    if (_curElement == _putSampleSize) {
      try {
        _soundPlayback.putSamples(_audioPutArray);
      }
 catch (      Exception ex) {
        throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
      }
      _curElement=0;
    }
  }
  return COMPLETED;
}"
76062,"/** 
 * Initialize/Reinitialize audio resources. First stop playback, and close any open sound files, if necessary. Then reread all parameters, create a new SoundPlayback object, and start playback of audio. <p> This method is synchronized since it is not safe to call SoundCapture methods while this method is executing.
 * @exception IllegalActionException If there is a problem initializingaudio playback.
 */
private synchronized void _initializeCapture() throws IllegalActionException {
  String modeStr=((StringToken)pathName.getToken()).stringValue();
  if (_debugging)   _debug(""String_Node_Str"" + modeStr);
  if (modeStr.equals(""String_Node_Str"")) {
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    _soundCapture=new SoundCapture((float)sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,_getSampleSize);
    try {
      _soundCapture.startCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
  }
 else {
    String theURL=((StringToken)pathName.getToken()).stringValue();
    _soundCapture=new SoundCapture(theURL,_getSampleSize);
    try {
      _soundCapture.startCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
    _channels=_soundCapture.getChannels();
    channels.setToken(new IntToken(_channels));
  }
}","/** 
 * Initialize/Reinitialize audio resources. First stop playback, and close any open sound files, if necessary. Then reread all parameters, create a new SoundPlayback object, and start playback of audio. <p> This method is synchronized since it is not safe to call SoundCapture methods while this method is executing.
 * @exception IllegalActionException If there is a problem initializingaudio playback.
 */
private synchronized void _initializeCapture() throws IllegalActionException {
  if (_soundCapture != null) {
    try {
      _soundCapture.stopCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
  }
  String modeStr=((StringToken)pathName.getToken()).stringValue();
  if (modeStr.equals(""String_Node_Str"")) {
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    _soundCapture=new SoundCapture((float)sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,_getSampleSize);
    try {
      _soundCapture.startCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
  }
 else {
    String theURL=((StringToken)pathName.getToken()).stringValue();
    _soundCapture=new SoundCapture(theURL,_getSampleSize);
    try {
      _soundCapture.startCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
    _channels=_soundCapture.getChannels();
    channels.setToken(new IntToken(_channels));
  }
}"
76063,"/** 
 * If there are at least <i>count</i> tokens on the input port, invoke <i>count</i> iterations of this actor. Otherwise, do nothing, and return a value of COMPLETED. One token is read from each channel in an iteration.  The audio output is either a sound file and/or the speaker, depending on the current  mode, which is controlled by the value of the <i>pathName</i>  parameter.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, throw an exception.
 * @exception IllegalActionException If the <i>count</i> samplescannot be written to the audio output device.
 */
public int iterate(int count) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"" + count);
  for (int j=0; j < _channels; j++) {
    if (input.hasToken(j,count)) {
      _inArray[j]=input.get(j,count);
    }
 else {
      return COMPLETED;
    }
  }
  for (int k=0; k < count; k++) {
    for (int m=0; m < _channels; m++) {
      _audioPutArray[m][_curElement]=((DoubleToken)_inArray[m][k]).doubleValue();
    }
    _curElement++;
    if (_curElement == _putSampleSize) {
      try {
        _soundPlayback.putSamples(_audioPutArray);
      }
 catch (      Exception ex) {
        throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
      }
      _curElement=0;
    }
  }
  return COMPLETED;
}","/** 
 * If there are at least <i>count</i> tokens on the input port, invoke <i>count</i> iterations of this actor. Otherwise, do nothing, and return a value of NOT_READY. One token is read from each channel in an iteration.  The audio output is either a sound file and/or the speaker, depending on the current  mode, which is controlled by the value of the <i>pathName</i>  parameter. <p> This method should be called instead of the prefire(),  fire(), and postfire() methods when this actor is used in a domain that supports vectorized actors. It is recommended for performance reasons that a large value of <i>count</i> be used  when this actor is used in live playback mode. This actor is  optimized to provide good performance even if the value of  <i>count</i> changes often.
 * @param count The number of iterations to perform.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, return NOT_READY if there are not enough tokens on the input port, or throw an exception if there is a problem writing audio samples to the audio sink.
 * @exception IllegalActionException If the <i>count</i> samplescannot be written to the audio output device.
 */
public int iterate(int count) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"" + count);
  for (int j=0; j < _channels; j++) {
    if (input.hasToken(j,count)) {
      _inArray[j]=input.get(j,count);
    }
 else {
      return NOT_READY;
    }
  }
  for (int k=0; k < count; k++) {
    for (int m=0; m < _channels; m++) {
      _audioPutArray[m][_curElement]=((DoubleToken)_inArray[m][k]).doubleValue();
    }
    _curElement++;
    if (_curElement == _putSampleSize) {
      try {
        _soundPlayback.putSamples(_audioPutArray);
      }
 catch (      Exception ex) {
        throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
      }
      _curElement=0;
    }
  }
  return COMPLETED;
}"
76064,"/** 
 * Invoke <i>count</i> iterations of this actor. This method causes audio samples to be captured from the audio source, which can be a sound file or live capture from the audio input device (e.g., the microphone or line-in). One token is written to the output port in an iteration.  When live capture mode is used, this method should be invoked  often enough to prevent overflow of the internal audio capture  buffer. Overflow should be avoided, since it will result in loss  of data.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Return STOP_ITERATING if the end of the soundfile is reached.
 * @exception IllegalActionException If audio cannot be captured.
 */
public int iterate(int count) throws IllegalActionException {
  if (count > _audioSendArray.length) {
    _audioSendArray=new DoubleToken[count];
  }
  for (int i=0; i < count; i++) {
    if (_haveASample == false) {
      try {
        _audioInDoubleArray=_soundCapture.getSamples();
      }
 catch (      Exception ex) {
        throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
      }
      _getSamplesArrayPointer=0;
      if (_audioInDoubleArray != null) {
        _haveASample=true;
      }
    }
    if (_haveASample == true) {
      for (int j=0; j < _channels; j++) {
        _audioSendArray[i]=new DoubleToken(_audioInDoubleArray[j][_getSamplesArrayPointer]);
      }
      _getSamplesArrayPointer++;
      if ((_audioInDoubleArray[0].length - _getSamplesArrayPointer) <= 0) {
        _haveASample=false;
      }
    }
  }
  if (_audioInDoubleArray != null) {
    for (int j=0; j < _channels; j++) {
      output.send(j,_audioSendArray,count);
    }
    return COMPLETED;
  }
 else {
    for (int i=0; i < count; i++) {
      _audioSendArray[i]=new DoubleToken(0);
    }
    for (int j=0; j < _channels; j++) {
      output.send(j,_audioSendArray,count);
    }
    return STOP_ITERATING;
  }
}","/** 
 * Invoke <i>count</i> iterations of this actor. This method causes audio samples to be captured from the audio source, which can be a sound file or live capture from the audio input device (e.g., the microphone or line-in). One token is written to the output port in an iteration.  When live capture mode is used, this method should be invoked  often enough to prevent overflow of the internal audio capture  buffer. Overflow should be avoided, since it will result in loss  of data. <p> This method should be called instead of the prefire(),  fire(), and postfire() methods when this actor is used in a domain that supports vectorized actors. It is recommended for performance reasons that a large value of <i>count</i> be used  when this actor is used in live capture mode. This actor is  optimized to provide good performance even if the value of  <i>count</i> changes often.
 * @param count The number of iterations to perform.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Return STOP_ITERATING if the end of the sound file is reached.
 * @exception IllegalActionException If there is a problem capturingaudio.
 */
public int iterate(int count) throws IllegalActionException {
  if (count > _audioSendArray.length) {
    _audioSendArray=new DoubleToken[count];
  }
  for (int i=0; i < count; i++) {
    if (_haveASample == false) {
      try {
        _audioInDoubleArray=_soundCapture.getSamples();
      }
 catch (      Exception ex) {
        throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
      }
      _getSamplesArrayPointer=0;
      if (_audioInDoubleArray != null) {
        _haveASample=true;
      }
    }
    if (_haveASample == true) {
      for (int j=0; j < _channels; j++) {
        _audioSendArray[i]=new DoubleToken(_audioInDoubleArray[j][_getSamplesArrayPointer]);
      }
      _getSamplesArrayPointer++;
      if ((_audioInDoubleArray[0].length - _getSamplesArrayPointer) <= 0) {
        _haveASample=false;
      }
    }
  }
  if (_audioInDoubleArray != null) {
    for (int j=0; j < _channels; j++) {
      output.send(j,_audioSendArray,count);
    }
    return COMPLETED;
  }
 else {
    for (int i=0; i < count; i++) {
      _audioSendArray[i]=new DoubleToken(0);
    }
    for (int j=0; j < _channels; j++) {
      output.send(j,_audioSendArray,count);
    }
    return STOP_ITERATING;
  }
}"
76065,"/** 
 * Set current time to zero, invoke the preinitialize() methods of all actors deeply contained by the container, and calculate priorities for simultaneous events. To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their preinitialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If there is a delay-free loop, orif the preinitialize() method of the container or one of the deeply contained actors throws it.
 */
public void preinitialize() throws IllegalActionException {
  _eventQueue=new DECQEventQueue(((IntToken)minBinCount.getToken()).intValue(),((IntToken)binCountFactor.getToken()).intValue(),((BooleanToken)isCQAdaptive.getToken()).booleanValue());
  Iterator listeners=_debugListeners.iterator();
  while (listeners.hasNext()) {
    DebugListener listener=(DebugListener)listeners.next();
    _eventQueue.addDebugListener(listener);
  }
  _deadActors=null;
  _currentTime=0.0;
  _noMoreActorsToFire=false;
  _microstep=0;
  _startTime=Double.MAX_VALUE;
  super.preinitialize();
}","/** 
 * Set current time to zero, invoke the preinitialize() methods of all actors deeply contained by the container, and calculate priorities for simultaneous events. To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their preinitialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If there is a delay-free loop, orif the preinitialize() method of the container or one of the deeply contained actors throws it.
 */
public void preinitialize() throws IllegalActionException {
  _eventQueue=new DECQEventQueue(((IntToken)minBinCount.getToken()).intValue(),((IntToken)binCountFactor.getToken()).intValue(),((BooleanToken)isCQAdaptive.getToken()).booleanValue());
  if (_debugListeners != null) {
    Iterator listeners=_debugListeners.iterator();
    while (listeners.hasNext()) {
      DebugListener listener=(DebugListener)listeners.next();
      _eventQueue.addDebugListener(listener);
    }
  }
  _deadActors=null;
  _currentTime=0.0;
  _noMoreActorsToFire=false;
  _microstep=0;
  _startTime=Double.MAX_VALUE;
  super.preinitialize();
}"
76066,"/** 
 * Return true if put() will succeed in accepting a token.
 * @return A boolean indicating whether a token can be put in thisreceiver.
 * @exception IllegalActionException If the number of tokens is lessthan one.
 */
public boolean hasRoom(int tokens) throws IllegalActionException {
  if (tokens < 1)   throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  return (_queue.size() + tokens) < _queue.getCapacity();
}","/** 
 * Return true if put() will succeed in accepting the specified number of tokesn.
 * @param tokens The number of tokens.
 * @return A boolean indicating whether a token can be put in thisreceiver.
 * @exception IllegalActionException If the number of tokens is lessthan one.
 */
public boolean hasRoom(int tokens) throws IllegalActionException {
  if (_queue.getCapacity() == INFINITE_CAPACITY) {
    return true;
  }
  if (tokens < 1)   throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  return (_queue.size() + tokens) < _queue.getCapacity();
}"
76067,"/** 
 * Delete a node from its parent graph and notify graph listeners with a NODE_REMOVED event.
 */
public void removeNode(final Vertex vertex){
  final ComponentRelation relation=(ComponentRelation)vertex.getContainer();
  _doChangeRequest(new RemoveRelation(vertex,relation));
}","/** 
 * Delete a node from its parent graph and notify graph listeners with a NODE_REMOVED event.
 */
public void removeNode(Object eventSource,final Vertex vertex){
  final ComponentRelation relation=(ComponentRelation)vertex.getContainer();
  _doChangeRequest(new RemoveRelation(vertex,relation));
}"
76068,"/** 
 * Initialize the applet.
 */
public void init(){
  super.init();
  getContentPane().setLayout(new BorderLayout(5,5));
  getContentPane().add(_createRunControls(3),BorderLayout.NORTH);
  constructPtolemyModel();
  _divaPanel=new JPanel(new BorderLayout());
  _divaPanel.setBorder(new TitledBorder(new LineBorder(Color.black),""String_Node_Str""));
  _divaPanel.setBackground(getBackground());
  _divaPanel.setSize(new Dimension(600,350));
  _divaPanel.setBackground(getBackground());
  getContentPane().add(_divaPanel,BorderLayout.CENTER);
  _graph=constructDivaGraph();
  final MutableGraphModel finalGraphModel=_graph;
  final GraphController gc=new BusContentionGraphController();
  final GraphPane gp=new GraphPane(gc,_graph);
  _jgraph=new JGraph(gp);
  _divaPanel.add(_jgraph,BorderLayout.NORTH);
  _jgraph.setPreferredSize(new Dimension(600,400));
  try {
    SwingUtilities.invokeAndWait(new Runnable(){
      public void run(){
        doLayout(finalGraphModel,gp);
      }
    }
);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(0);
  }
  _jgraph.setBackground(getBackground());
  StateListener listener=new StateListener((GraphPane)_jgraph.getCanvasPane());
  _processActor1.addListeners(listener);
  _processActor2.addListeners(listener);
  _processActor3.addListeners(listener);
}","/** 
 * Initialize the applet.
 */
public void init(){
  super.init();
  getContentPane().setLayout(new BorderLayout(5,5));
  getContentPane().add(_createRunControls(2),BorderLayout.NORTH);
  constructPtolemyModel();
  _divaPanel=new JPanel(new BorderLayout());
  _divaPanel.setBorder(new TitledBorder(new LineBorder(Color.black),""String_Node_Str""));
  _divaPanel.setBackground(getBackground());
  _divaPanel.setPreferredSize(new Dimension(500,450));
  _divaPanel.setBackground(getBackground());
  getContentPane().add(_divaPanel,BorderLayout.SOUTH);
  _graph=constructGraph();
  final BasicGraphModel finalGraphModel=_graph;
  final GraphController gc=new BusContentionGraphController();
  final GraphPane gp=new GraphPane(gc,_graph);
  _jgraph=new JGraph(gp);
  _jgraph.repaint();
  _divaPanel.add(_jgraph,BorderLayout.CENTER);
  _jgraph.setBackground(getBackground());
  StateListener listener=new StateListener((GraphPane)_jgraph.getCanvasPane());
  _processActor1.addListeners(listener);
  _processActor2.addListeners(listener);
  _processActor3.addListeners(listener);
}"
76069,"/** 
 * Override the baseclass start method so that the model does not immediately begin executing as soon as the the applet page is displayed. Execution begins once the ""Go"" button is depressed.
 */
public void start(){
}","/** 
 * Override the baseclass start method so that the model does not immediately begin executing as soon as the the applet page is displayed. Execution begins once the ""Go"" button is depressed. Layout the graph visualization, since this can't be done in the init method, because the graph hasn't yet been displayed.
 */
public void start(){
  doLayout(_graph,_jgraph.getGraphPane());
}"
76070,"/** 
 * Layout the graph again.
 */
public void doLayout(GraphModel graph,GraphPane gp){
  try {
    final GraphModel layoutGraph=graph;
    final GraphController gc=gp.getGraphController();
    final GraphPane pane=gp;
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        LevelLayout staticLayout=new LevelLayout();
        staticLayout.setOrientation(LevelLayout.HORIZONTAL);
        LayoutTarget target=new BasicLayoutTarget(gc);
        staticLayout.layout(target,layoutGraph.getRoot());
        pane.repaint();
      }
    }
);
  }
 catch (  Exception e) {
    System.out.println(e);
  }
}","/** 
 * Layout the graph again.
 */
public void doLayout(GraphModel graph,GraphPane gp){
  try {
    final GraphModel layoutGraph=graph;
    final GraphController gc=gp.getGraphController();
    final GraphPane pane=gp;
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        LayoutTarget target=new BasicLayoutTarget(gc);
        LevelLayout staticLayout=new LevelLayout(target);
        staticLayout.setOrientation(LevelLayout.HORIZONTAL);
        staticLayout.layout(layoutGraph.getRoot());
        pane.repaint();
      }
    }
);
  }
 catch (  Exception e) {
    System.out.println(e);
  }
}"
76071,"/** 
 * Initialize the applet.
 */
public void init(){
  super.init();
  getContentPane().setLayout(new BorderLayout(5,5));
  JPanel topPanel=new JPanel();
  topPanel.setSize(new Dimension(600,200));
  getContentPane().setBackground(getBackground());
  topPanel.setBackground(getBackground());
  topPanel.add(_createRunControls(3),BorderLayout.NORTH);
  _plotPanel=new JPanel();
  _plotPanel.setSize(new Dimension(600,200));
  _plotPanel.setBackground(getBackground());
  topPanel.add(_plotPanel,BorderLayout.CENTER);
  getContentPane().add(topPanel,BorderLayout.NORTH);
  constructPtolemyModel();
  _divaPanel=new JPanel(new BorderLayout());
  _divaPanel.setSize(new Dimension(600,400));
  _divaPanel.setBackground(getBackground());
  getContentPane().add(_divaPanel,BorderLayout.CENTER);
  _graph=constructDivaGraph();
  final MutableGraphModel finalGraphModel=_graph;
  final GraphController gc=new LocalZenoGraphController();
  final GraphPane gp=new GraphPane(gc,_graph);
  _jgraph=new JGraph(gp);
  _divaPanel.add(_jgraph,BorderLayout.NORTH);
  _jgraph.setPreferredSize(new Dimension(600,400));
  try {
    SwingUtilities.invokeAndWait(new Runnable(){
      public void run(){
        doLayout(finalGraphModel,gp);
      }
    }
);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.exit(0);
  }
  StateListener listener=new StateListener((GraphPane)_jgraph.getCanvasPane());
  _join1.addListeners(listener);
  _join2.addListeners(listener);
  _fork1.addListeners(listener);
  _fork2.addListeners(listener);
  _fBack1.addListeners(listener);
  _fBack2.addListeners(listener);
  _rcvr1.addListeners(listener);
  _rcvr2.addListeners(listener);
  _clock.addListeners(listener);
}","/** 
 * Initialize the applet.
 */
public void init(){
  super.init();
  getContentPane().setLayout(new BorderLayout(5,5));
  JPanel topPanel=new JPanel();
  topPanel.setSize(new Dimension(600,200));
  getContentPane().setBackground(getBackground());
  topPanel.setBackground(getBackground());
  topPanel.add(_createRunControls(2),BorderLayout.NORTH);
  _plotPanel=new JPanel();
  _plotPanel.setSize(new Dimension(600,200));
  _plotPanel.setBackground(getBackground());
  topPanel.add(_plotPanel,BorderLayout.CENTER);
  getContentPane().add(topPanel,BorderLayout.NORTH);
  constructPtolemyModel();
  _divaPanel=new JPanel(new BorderLayout());
  _divaPanel.setSize(new Dimension(600,400));
  _divaPanel.setBackground(getBackground());
  getContentPane().add(_divaPanel,BorderLayout.CENTER);
  _graph=constructDivaGraph();
  final MutableGraphModel finalGraphModel=_graph;
  final GraphController gc=new LocalZenoGraphController();
  final GraphPane gp=new GraphPane(gc,_graph);
  _jgraph=new JGraph(gp);
  _divaPanel.add(_jgraph,BorderLayout.CENTER);
  StateListener listener=new StateListener((GraphPane)_jgraph.getCanvasPane());
  _join1.addListeners(listener);
  _join2.addListeners(listener);
  _fork1.addListeners(listener);
  _fork2.addListeners(listener);
  _fBack1.addListeners(listener);
  _fBack2.addListeners(listener);
  _rcvr1.addListeners(listener);
  _rcvr2.addListeners(listener);
  _clock.addListeners(listener);
}"
76072,"/** 
 * Override the baseclass start method so that the model does not immediately begin executing as soon as the the applet page is displayed. Execution begins once the ""Go"" button is depressed.
 */
public void start(){
}","/** 
 * Override the baseclass start method so that the model does not immediately begin executing as soon as the the applet page is displayed. Execution begins once the ""Go"" button is depressed. Layout the graph visualization, since this can't be done in the init method, because the graph hasn't yet been displayed.
 */
public void start(){
  doLayout(_graph,_jgraph.getGraphPane());
}"
76073,"/** 
 * Layout the graph again.
 */
public void doLayout(GraphModel graph,GraphPane gp){
  try {
    final GraphModel layoutGraph=graph;
    final GraphController gc=gp.getGraphController();
    final GraphPane pane=gp;
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        LevelLayout staticLayout=new LevelLayout();
        staticLayout.setOrientation(LevelLayout.HORIZONTAL);
        LayoutTarget target=new BasicLayoutTarget(gc);
        staticLayout.layout(target,layoutGraph.getRoot());
        pane.repaint();
      }
    }
);
  }
 catch (  Exception e) {
    System.out.println(e);
  }
}","/** 
 * Layout the graph again.
 */
public void doLayout(GraphModel graph,GraphPane gp){
  try {
    final GraphModel layoutGraph=graph;
    final GraphController gc=gp.getGraphController();
    final GraphPane pane=gp;
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        LayoutTarget target=new BasicLayoutTarget(gc);
        LevelLayout staticLayout=new LevelLayout(target);
        staticLayout.setOrientation(LevelLayout.HORIZONTAL);
        staticLayout.layout(layoutGraph.getRoot());
        pane.repaint();
      }
    }
);
  }
 catch (  Exception e) {
    System.out.println(e);
  }
}"
76074,"/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A LinkedList of the Actors in the order they should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
private LinkedList _scheduleConnectedActors(LinkedList actorList) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  LinkedList newSchedule=new LinkedList();
  Map waitingTokens=new TreeMap(new NamedObjComparator());
  Map firingsRemainingVector=new TreeMap(new NamedObjComparator());
  firingsRemainingVector.putAll(_firingvector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Iterator ainputports=a.inputPortList().iterator();
      while (ainputports.hasNext()) {
        IOPort ainputport=(IOPort)ainputports.next();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.put(ainputport,tokencount);
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Iterator aoutputports=a.outputPortList().iterator();
      while (aoutputports.hasNext()) {
        IOPort aOutputPort=(IOPort)aoutputports.next();
        int count=getTokenInitProduction(aOutputPort);
        if (_debugging)         _debug(""String_Node_Str"" + count + ""String_Node_Str""+ aOutputPort);
        if (count > 0) {
          _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
        }
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.addFirst((ComponentEntity)a);
      if (_debugging)       _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
    }
    while (readyToScheduleActorList.size() > 0) {
      if (_debugging)       _debug(""String_Node_Str"");
      Iterator ports=waitingTokens.keySet().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        int tokencount[]=(int[])waitingTokens.get(port);
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getFullName());
          _debug(""String_Node_Str"" + tokencount.length);
        }
        for (int channel=0; channel < tokencount.length; channel++)         if (_debugging)         _debug(""String_Node_Str"" + channel + ""String_Node_Str""+ tokencount[channel]+ ""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"");
        Iterator actorsLeft=readyToScheduleActorList.iterator();
        while (actorsLeft.hasNext()) {
          Entity e=(Entity)actorsLeft.next();
          _debug(e.getFullName());
        }
        _debug(""String_Node_Str"");
        actorsLeft=unscheduledActorList.iterator();
        while (actorsLeft.hasNext()) {
          Entity e=(Entity)actorsLeft.next();
          _debug(e.getFullName());
        }
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor))       ;
      if (_debugging) {
        _debug(""String_Node_Str"" + currentActor.getName());
      }
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.addLast(currentActor);
      Iterator aOutputPorts=((Actor)currentActor).outputPortList().iterator();
      while (aOutputPorts.hasNext()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.next();
        int count=getTokenProductionRate(aOutputPort);
        _simulateTokensCreated(aOutputPort,count,unscheduledActorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      firingsRemaining-=1;
      firingsRemainingVector.put(currentActor,new Integer(firingsRemaining));
      if (_debugging) {
        _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      }
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          _debug(""String_Node_Str"" + currentActor);
          while (readyToScheduleActorList.remove(currentActor))           ;
          while (unscheduledActorList.remove(currentActor))           ;
          _debug(""String_Node_Str"");
          actorsLeft=readyToScheduleActorList.iterator();
          while (actorsLeft.hasNext()) {
            Entity e=(Entity)actorsLeft.next();
            if (_debugging)             _debug(e.getFullName());
          }
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1 && unscheduledActorList.contains(currentActor))           readyToScheduleActorList.addLast(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    if (_debugging)     _debug(""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    String s=new String(""String_Node_Str"");
    Iterator actors=unscheduledActorList.iterator();
    while (actors.hasNext()) {
      Entity actor=(Entity)actors.next();
      s+=actor.getFullName() + ""String_Node_Str"";
    }
    throw new NotSchedulableException(s);
  }
  Iterator eschedule=newSchedule.iterator();
  if (_debugging) {
    _debug(""String_Node_Str"");
    while (eschedule.hasNext()) {
      _debug(((ComponentEntity)eschedule.next()).toString());
    }
  }
  return newSchedule;
}","/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A LinkedList of the Actors in the order they should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
private LinkedList _scheduleConnectedActors(LinkedList actorList) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  LinkedList newSchedule=new LinkedList();
  Map waitingTokens=new TreeMap(new NamedObjComparator());
  Map firingsRemainingVector=new TreeMap(new NamedObjComparator());
  firingsRemainingVector.putAll(_firingvector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Iterator ainputports=a.inputPortList().iterator();
      while (ainputports.hasNext()) {
        IOPort ainputport=(IOPort)ainputports.next();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.put(ainputport,tokencount);
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Iterator aoutputports=a.outputPortList().iterator();
      while (aoutputports.hasNext()) {
        IOPort aOutputPort=(IOPort)aoutputports.next();
        int count=getTokenInitProduction(aOutputPort);
        if (_debugging)         _debug(""String_Node_Str"" + count + ""String_Node_Str""+ aOutputPort);
        if (count > 0) {
          _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
        }
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.addFirst((ComponentEntity)a);
      if (_debugging)       _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
    }
    while (readyToScheduleActorList.size() > 0) {
      if (_debugging)       _debug(""String_Node_Str"");
      Iterator ports=waitingTokens.keySet().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        int tokencount[]=(int[])waitingTokens.get(port);
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getFullName());
          _debug(""String_Node_Str"" + tokencount.length);
        }
        for (int channel=0; channel < tokencount.length; channel++)         if (_debugging)         _debug(""String_Node_Str"" + channel + ""String_Node_Str""+ tokencount[channel]+ ""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"");
        Iterator actorsLeft=readyToScheduleActorList.iterator();
        while (actorsLeft.hasNext()) {
          Entity e=(Entity)actorsLeft.next();
          _debug(e.getFullName());
        }
        _debug(""String_Node_Str"");
        actorsLeft=unscheduledActorList.iterator();
        while (actorsLeft.hasNext()) {
          Entity e=(Entity)actorsLeft.next();
          _debug(e.getFullName());
        }
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor))       ;
      if (_debugging) {
        _debug(""String_Node_Str"" + currentActor.getName());
      }
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.addLast(currentActor);
      Iterator aOutputPorts=((Actor)currentActor).outputPortList().iterator();
      while (aOutputPorts.hasNext()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.next();
        int count=getTokenProductionRate(aOutputPort);
        _simulateTokensCreated(aOutputPort,count,unscheduledActorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      firingsRemaining-=1;
      firingsRemainingVector.put(currentActor,new Integer(firingsRemaining));
      if (_debugging) {
        _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      }
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          _debug(""String_Node_Str"" + currentActor);
          while (readyToScheduleActorList.remove(currentActor))           ;
          while (unscheduledActorList.remove(currentActor))           ;
          _debug(""String_Node_Str"");
          Iterator actorsLeft=readyToScheduleActorList.iterator();
          while (actorsLeft.hasNext()) {
            Entity e=(Entity)actorsLeft.next();
            if (_debugging)             _debug(e.getFullName());
          }
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1 && unscheduledActorList.contains(currentActor))           readyToScheduleActorList.addLast(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    if (_debugging)     _debug(""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    String s=new String(""String_Node_Str"");
    Iterator actors=unscheduledActorList.iterator();
    while (actors.hasNext()) {
      Entity actor=(Entity)actors.next();
      s+=actor.getFullName() + ""String_Node_Str"";
    }
    throw new NotSchedulableException(s);
  }
  Iterator eschedule=newSchedule.iterator();
  if (_debugging) {
    _debug(""String_Node_Str"");
    while (eschedule.hasNext()) {
      _debug(((ComponentEntity)eschedule.next()).toString());
    }
  }
  return newSchedule;
}"
76075,"/** 
 * Invoke a specified number of iterations of this actor. An iteration has the effect of invoking prefire(), fire(), and  postfire(), in that order. If prefire() returns true, then fire() will be called once, followed by postfire(). Otherwise, fire() and postfire() are not invoked, and this method will return a value of false. This method will return true if  the actor was successfully iterated the specified number of  times. Otherwise, a value of false will be returned. <p> This base class method actually invokes prefire(), fire(),  and postfire(), as described above. 
 * @param count The number of iterations to perform.
 * @return True if the actor was successfully iterated thespecified number of times. Otherwise, return false.
 * @exception IllegalActionException If one of the Executablemethods throws it.
 */
public boolean iterate(int count) throws IllegalActionException {
  int n=0;
  while (n < count) {
    if (prefire()) {
      fire();
      postfire();
    }
 else     break;
    count++;
  }
  if (count == n) {
    return (true);
  }
 else {
    return (false);
  }
}","/** 
 * Invoke a specified number of iterations of this actor. An iteration has the effect of invoking prefire(), fire(), and  postfire(), in that order. In an iteration, if prefire()  returns true, then fire() will be called once, followed by  an invocation of postfire(). Otherwise, if prefire() returns  false, fire() and postfire() are not invoked, and an exception  will be thrown. This method will return the value returned by the  last invocation postfire().  <p> This base class method actually invokes prefire(), fire(),  and postfire(), as described above. 
 * @param count The number of iterations to perform.
 * @return True if the actor was successfully iterated thespecified number of times. Otherwise, return false.
 * @exception IllegalActionException If one of the Executablemethods throws it, or if prefire() returns false.
 */
public boolean iterate(int count) throws IllegalActionException {
  int n=0;
  boolean returnVal=false;
  while (n < count) {
    if (prefire()) {
      fire();
      returnVal=postfire();
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + count + ""String_Node_Str"");
    }
    n++;
  }
  return returnVal;
}"
76076,"/** 
 * Increment the count of actors waiting for the queued topology changes to be processed. Check for a resultant deadlock or pausing of the execution. If either of them is detected, then notify the directing thread of the same. This method is normally called by processes or actors that queue requests for changes to the topology and do not wish to continue their execution until their requests are processed. This method is not used by the base director and is provided for use by the deriveed classes.
 */
protected synchronized void _informOfMutationBlock(){
  _mutationBlockCount++;
  if (_areActorsDeadlocked()) {
    notifyAll();
  }
  return;
}","/** 
 * Increment the count of actors waiting for the queued topology changes to be processed. Check for a resultant deadlock or pausing of the execution. If either of them is detected, then notify the directing thread of the same. This method is normally called by processes or actors that queue requests for changes to the topology and do not wish to continue their execution until their requests are processed. This method is not used by the base director and is provided for use by the deriveed classes.
 */
protected synchronized void _informOfMutationBlock(){
  _mutationBlockCount++;
  notifyAll();
}"
76077,"/** 
 * Return true if the containing composite actor contains active processes and the composite actor has input ports. Return false otherwise. This method should normally be called only after detecting a real deadlock. True is returned to indicate that the composite actor can start its execution again if it receives data on any of its input ports.
 * @return true to indicate that the composite actor can continueexecuting on receiving additional input on its input ports.
 * @exception IllegalActionException Not thrown in this base class. May bethrown by derived classes.
 */
public boolean postfire() throws IllegalActionException {
  if (!((((CompositeActor)getContainer()).inputPortList()).isEmpty()) && _getActiveActorsCount() != 0) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Return true if the containing composite actor contains active processes and the composite actor has input ports. Return false otherwise. This method should normally be called only after detecting a real deadlock. True is returned to indicate that the composite actor can start its execution again if it receives data on any of its input ports.
 * @return true to indicate that the composite actor can continueexecuting on receiving additional input on its input ports.
 * @exception IllegalActionException Not thrown in this base class. May bethrown by derived classes.
 */
public boolean postfire() throws IllegalActionException {
  if (!((((CompositeActor)getContainer()).inputPortList()).isEmpty()) && _getActiveActorsCount() != 0) {
    System.out.println(""String_Node_Str"" + _notDone);
    return _notDone;
  }
 else {
    System.out.println(""String_Node_Str"" + _notDone + ""String_Node_Str"");
    return _notDone;
  }
}"
76078,"/** 
 * Decrement the count of processes waiting for the topology change requests (mutation requests) to be processed. This method is not used by the base director and is provided for use by the derived classes.
 */
protected synchronized void _informOfMutationUnblock(){
  _mutationBlockCount--;
  return;
}","/** 
 * Decrement the count of processes waiting for the topology change requests (mutation requests) to be processed. This method is not used by the base director and is provided for use by the derived classes.
 */
protected synchronized void _informOfMutationUnblock(){
  _mutationBlockCount--;
}"
76079,"/** 
 * Resolve an artificial deadlock and return true. If the deadlock is not an artificial deadlock (it is a real deadlock), then return false. If it is an artificial deadlock, select the receiver with the smallest queue capacity on which any process is blocked on a write and increment the capacity of the contained queue. If the capacity is non-negative, then increment the capacity by 1. Otherwise set the capacity to 1. Unblock the process blocked on this receiver. Notify the thread corresponding to the blocked process and return true. <pP If derived classes introduce new forms of deadlocks, they should override this method to introduce mechanisms of handling those deadlocks. This method is called from the fire() method of the director alone.
 * @return True after handling an artificial deadlock. Otherwise returnfalse.
 * @exception IllegalActionException Not thrown in this base class.This might be thrown by derived classes.
 */
protected boolean _resolveDeadlock() throws IllegalActionException {
  if (_writeBlockCount == 0) {
    return false;
  }
 else {
    _incrementLowestWriteCapacityPort();
    return true;
  }
}","/** 
 * Resolve an artificial deadlock and return true. If the deadlock is not an artificial deadlock (it is a real deadlock), then return false. If it is an artificial deadlock, select the receiver with the smallest queue capacity on which any process is blocked on a write and increment the capacity of the contained queue. If the capacity is non-negative, then increment the capacity by 1. Otherwise set the capacity to 1. Unblock the process blocked on this receiver. Notify the thread corresponding to the blocked process and return true. <pP If derived classes introduce new forms of deadlocks, they should override this method to introduce mechanisms of handling those deadlocks. This method is called from the fire() method of the director alone.
 * @return True after handling an artificial deadlock. Otherwise returnfalse.
 * @exception IllegalActionException Not thrown in this base class.This might be thrown by derived classes.
 */
protected boolean _resolveDeadlock() throws IllegalActionException {
  if (_writeBlockCount == 0 && _readBlockCount > 0) {
    return false;
  }
 else   if (_getActiveActorsCount() == 0) {
    return false;
  }
 else {
    System.out.println(""String_Node_Str"");
    _incrementLowestWriteCapacityPort();
    return true;
  }
}"
76080,"/** 
 * Double the capacity of one of the queues with the smallest capacity belonging to a receiver on which a process is blocked while attempting to write. <p>Traverse through the list of receivers on which a process is blocked on a write and choose the one containing the queue with the smallest capacity. Double the capacity if the capacity is non-negative. In case the capacity is negative, set the capacity to 1. Unblock the process blocked on a write to the receiver containing this queue. Notify the thread corresponding to the blocked process to resume its execution and return.
 */
protected void _incrementLowestWriteCapacityPort(){
  PNQueueReceiver smallestCapacityQueue=null;
  int smallestCapacity=-1;
  Iterator receivers=_writeblockedQueues.iterator();
  while (receivers.hasNext()) {
    PNQueueReceiver queue=(PNQueueReceiver)receivers.next();
    if (smallestCapacity == -1) {
      smallestCapacityQueue=queue;
      smallestCapacity=queue.getCapacity();
    }
 else     if (smallestCapacity > queue.getCapacity()) {
      smallestCapacityQueue=queue;
      smallestCapacity=queue.getCapacity();
    }
  }
  try {
    if (smallestCapacityQueue.getCapacity() <= 0) {
      smallestCapacityQueue.setCapacity(1);
    }
 else {
      smallestCapacityQueue.setCapacity(smallestCapacityQueue.getCapacity() * 2);
    }
    _actorUnBlocked(smallestCapacityQueue);
    smallestCapacityQueue.setWritePending(false);
synchronized (smallestCapacityQueue) {
      smallestCapacityQueue.notifyAll();
    }
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e.toString());
  }
  return;
}","/** 
 * Double the capacity of one of the queues with the smallest capacity belonging to a receiver on which a process is blocked while attempting to write. <p>Traverse through the list of receivers on which a process is blocked on a write and choose the one containing the queue with the smallest capacity. Double the capacity if the capacity is non-negative. In case the capacity is negative, set the capacity to 1. Unblock the process blocked on a write to the receiver containing this queue. Notify the thread corresponding to the blocked process to resume its execution and return.
 */
protected void _incrementLowestWriteCapacityPort(){
  PNQueueReceiver smallestCapacityQueue=null;
  int smallestCapacity=-1;
  Iterator receivers=_writeblockedQueues.iterator();
  if (!receivers.hasNext()) {
    return;
  }
  while (receivers.hasNext()) {
    PNQueueReceiver queue=(PNQueueReceiver)receivers.next();
    if (smallestCapacity == -1) {
      smallestCapacityQueue=queue;
      smallestCapacity=queue.getCapacity();
    }
 else     if (smallestCapacity > queue.getCapacity()) {
      smallestCapacityQueue=queue;
      smallestCapacity=queue.getCapacity();
    }
  }
  try {
    if (smallestCapacityQueue.getCapacity() <= 0) {
      smallestCapacityQueue.setCapacity(1);
    }
 else {
      smallestCapacityQueue.setCapacity(smallestCapacityQueue.getCapacity() * 2);
    }
    _actorUnBlocked(smallestCapacityQueue);
    smallestCapacityQueue.setWritePending(false);
synchronized (smallestCapacityQueue) {
      smallestCapacityQueue.notifyAll();
    }
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e.toString());
  }
  return;
}"
76081,"/** 
 * Wait until the detection of a deadlock. If the deadlock is real, then return. Else (for an artificial deadlock), handle the deadlock by incrementing the capacity of a receiver with the smallest capacity amongst the receivers on which a process is blocked on a write. The derived directors can override this method to handle other forms of deadlock that they define and perform actions accordingly. This method is synchronized on the director.
 * @exception IllegalActionException Not thrown in this base class. Maybethrown by derived classes.
 */
public void fire() throws IllegalActionException {
  Workspace workspace=workspace();
  while (_readBlockCount != _getActiveActorsCount()) {
synchronized (this) {
      while (!_areActorsDeadlocked()) {
        workspace.wait(this);
      }
      _notDone=_resolveDeadlock();
    }
  }
  return;
}","/** 
 * Wait until the detection of a deadlock. If the deadlock is real, then return. Else (for an artificial deadlock), handle the deadlock by incrementing the capacity of a receiver with the smallest capacity amongst the receivers on which a process is blocked on a write. The derived directors can override this method to handle other forms of deadlock that they define and perform actions accordingly. This method is synchronized on the director.
 * @exception IllegalActionException Not thrown in this base class. Maybethrown by derived classes.
 */
public void fire() throws IllegalActionException {
  Workspace workspace=workspace();
  System.out.println(""String_Node_Str"");
  while (_readBlockCount != _getActiveActorsCount()) {
    System.out.println(""String_Node_Str"");
synchronized (this) {
      while (!_areActorsDeadlocked()) {
        workspace.wait(this);
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + _getActiveActorsCount() + ""String_Node_Str""+ _readBlockCount+ ""String_Node_Str""+ _writeBlockCount);
        Iterator threads=_actorThreadList.iterator();
      }
      System.out.println(""String_Node_Str"");
      _notDone=_resolveDeadlock();
      System.out.println(""String_Node_Str"");
    }
  }
  System.out.println(""String_Node_Str"");
  return;
}"
76082,"/** 
 * Increment by 1 the count of processes blocked while reading from a receiver and notify all process listeners of the blocking of the process. Check for a deadlock or pausing of the execution as a result of the process blocking on a read. If either of them is detected, then notify the directing thread of the same.
 */
protected synchronized void _actorBlocked(ProcessReceiver rcvr){
  if (rcvr.isReadBlocked()) {
    _readBlockCount++;
  }
  if (rcvr.isWriteBlocked()) {
    _writeblockedQueues.add(rcvr);
    _writeBlockCount++;
  }
  if (_areActorsDeadlocked()) {
    notifyAll();
  }
  return;
}","/** 
 * Increment by 1 the count of processes blocked while reading from a receiver and notify all process listeners of the blocking of the process. Check for a deadlock or pausing of the execution as a result of the process blocking on a read. If either of them is detected, then notify the directing thread of the same.
 */
protected synchronized void _actorBlocked(ProcessReceiver rcvr){
  if (rcvr.isReadBlocked()) {
    _readBlockCount++;
  }
  if (rcvr.isWriteBlocked()) {
    _writeblockedQueues.add(rcvr);
    _writeBlockCount++;
  }
  notifyAll();
}"
76083,"/** 
 * Suspend the calling thread until a deadlock or request for topology changes is detected. On resuming, process the requests for topology changes if any, or handle the various deadlocks appropriately. If requested, process the queued topology change requests. Registered topology listeners are informed of each change in a series of calls after successful completion of each request. If any queued request fails, the request is undone, and no further requests are processed. Note that change requests processed successfully prior to the failed request are <i>not</i> undone. Initialize any new actors created, create receivers for them, initialize the receivers and create new threads for the new actors created. After all threads are created, resume the execution and start the threads for the newly created actors. If the resumption was on detection of a deadlock, break the deadlock if possible. If the deadlock is an artificial deadlock, then select the receiver with the smallest queue capacity on which any process is blocked on a write and increment the capacity of the contained queue. If the capacity is non-negative, then increment the capacity by 1. Otherwise set the capacity to 1. Unblock the process blocked on this receiver. Notify the thread corresponding to the blocked process. If the deadlock detected is a real deadlock, then do nothing. This method is synchronized on the director. This method is normally called by the directing thread.
 * @exception IllegalActionException If any of the called methods throwit.
 */
public void fire() throws IllegalActionException {
  Workspace worksp=workspace();
synchronized (this) {
    _mutationBlockCount=0;
    _mutationsRequested=false;
    while ((_readBlockCount != _getActiveActorsCount()) && !_areActorsStopped()) {
      while (!_areActorsDeadlocked() && !_areActorsStopped()) {
        worksp.wait(this);
      }
      if (!_areActorsStopped()) {
        _notDone=_resolveDeadlock();
      }
    }
  }
  return;
}","/** 
 * Suspend the calling thread until a deadlock or request for topology changes is detected. On resuming, process the requests for topology changes if any, or handle the various deadlocks appropriately. If requested, process the queued topology change requests. Registered topology listeners are informed of each change in a series of calls after successful completion of each request. If any queued request fails, the request is undone, and no further requests are processed. Note that change requests processed successfully prior to the failed request are <i>not</i> undone. Initialize any new actors created, create receivers for them, initialize the receivers and create new threads for the new actors created. After all threads are created, resume the execution and start the threads for the newly created actors. If the resumption was on detection of a deadlock, break the deadlock if possible. If the deadlock is an artificial deadlock, then select the receiver with the smallest queue capacity on which any process is blocked on a write and increment the capacity of the contained queue. If the capacity is non-negative, then increment the capacity by 1. Otherwise set the capacity to 1. Unblock the process blocked on this receiver. Notify the thread corresponding to the blocked process. If the deadlock detected is a real deadlock, then do nothing. This method is synchronized on the director. This method is normally called by the directing thread.
 * @exception IllegalActionException If any of the called methods throwit.
 */
public void fire() throws IllegalActionException {
  Workspace worksp=workspace();
synchronized (this) {
    _mutationBlockCount=0;
    _mutationsRequested=false;
    while (_readBlockCount != _getActiveActorsCount()) {
      while (!_areActorsDeadlocked()) {
        worksp.wait(this);
      }
      _notDone=_resolveDeadlock();
    }
  }
  return;
}"
76084,"/** 
 * Increment by 1 the count of actors waiting for the time to advance. Check for a resultant deadlock or pausing of the execution. If either of them is detected, then notify the directing thread of the same.
 */
protected synchronized void _informOfDelayBlock(){
  _delayBlockCount++;
  if (_areActorsDeadlocked()) {
    notifyAll();
  }
  return;
}","/** 
 * Increment by 1 the count of actors waiting for the time to advance. Check for a resultant deadlock or pausing of the execution. If either of them is detected, then notify the directing thread of the same.
 */
protected synchronized void _informOfDelayBlock(){
  _delayBlockCount++;
  notifyAll();
}"
76085,"/** 
 * Suspend the calling thread until a deadlock is detected. On resuming, handle the various deadlocks appropriately. Break the deadlock if possible. If the deadlock is an artificial deadlock, then select the receiver with the smallest queue capacity on which any process is blocked on a write and increment the capacity of the contained queue. If the capacity is non-negative, then increment the capacity by 1. Otherwise set the capacity to 1. Unblock the process blocked on this receiver. Notify the thread corresponding to the blocked process. If the deadlock is a timed deadlock, process any pending topology change requests. If there are no pending requests, then advance the time to the earliest value when a time-blocked process can be awakened. If the deadlock detected is a real deadlock, then do nothing. If processing the queued topology change requests, then inform the registered topology listeners of each change in a series of calls after successful completion of each request. If any queued request fails, the request is undone, and no further requests are processed. Note that change requests processed successfully prior to the failed request are <i>not</i> undone. Create receivers for any new actors created, initialize the new actors, and create new threads for these actors. After all threads are created, resume the execution and start the threads for the newly created actors. This method returns only on occurrence of a real deadlock. <b>This method is synchronized on the director. This method is normally called by the directing thread. </b>
 * @exception IllegalActionException If any of the called methods throwit.
 */
public void fire() throws IllegalActionException {
  boolean timedmut;
  Workspace worksp=workspace();
synchronized (this) {
    _mutationBlockCount=0;
    _mutationsRequested=false;
    while (_readBlockCount != _getActiveActorsCount() && !_areActorsStopped()) {
      while (!_areActorsDeadlocked() && !_areActorsStopped()) {
        worksp.wait(this);
      }
      if (!_areActorsStopped()) {
        _notDone=_resolveDeadlock();
      }
    }
  }
  return;
}","/** 
 * Suspend the calling thread until a deadlock is detected. On resuming, handle the various deadlocks appropriately. Break the deadlock if possible. If the deadlock is an artificial deadlock, then select the receiver with the smallest queue capacity on which any process is blocked on a write and increment the capacity of the contained queue. If the capacity is non-negative, then increment the capacity by 1. Otherwise set the capacity to 1. Unblock the process blocked on this receiver. Notify the thread corresponding to the blocked process. If the deadlock is a timed deadlock, process any pending topology change requests. If there are no pending requests, then advance the time to the earliest value when a time-blocked process can be awakened. If the deadlock detected is a real deadlock, then do nothing. If processing the queued topology change requests, then inform the registered topology listeners of each change in a series of calls after successful completion of each request. If any queued request fails, the request is undone, and no further requests are processed. Note that change requests processed successfully prior to the failed request are <i>not</i> undone. Create receivers for any new actors created, initialize the new actors, and create new threads for these actors. After all threads are created, resume the execution and start the threads for the newly created actors. This method returns only on occurrence of a real deadlock. <b>This method is synchronized on the director. This method is normally called by the directing thread. </b>
 * @exception IllegalActionException If any of the called methods throwit.
 */
public void fire() throws IllegalActionException {
  boolean timedmut;
  Workspace worksp=workspace();
synchronized (this) {
    _mutationBlockCount=0;
    _mutationsRequested=false;
    while (_readBlockCount != _getActiveActorsCount()) {
      while (!_areActorsDeadlocked()) {
        worksp.wait(this);
      }
      _notDone=_resolveDeadlock();
    }
  }
  return;
}"
76086,"/** 
 * Execute the model.  Begin with the initialization phase, followed by a sequence of iterations, followed by a wrapup phase. The sequence of iterations concludes when the postfire() method of the container (the top-level composite actor) returns false, or when the finish() method is called. <p> The execution is performed in the calling thread (the current thread), so this method returns only after execution finishes. If you wish to perform execution in a new thread, use startRun() instead.  Even if an exception occurs during the execution, the wrapup() method is called (in a finally clause).  It is up to the caller to handle (i.e. report) the exception. If you do not wish to handle exceptions, but want to execute within the calling thread, use run().
 * @exception KernelException If the model throws it.
 * @exception IllegalActionException If the model is already running, orif there is no container.
 */
public synchronized void execute() throws KernelException, IllegalActionException {
  long startTime=(new Date()).getTime();
  boolean completedSuccessfully=false;
  try {
    initialize();
    if (_debugging)     _debug(""String_Node_Str"");
    while (!_finishRequested) {
      if (!iterate())       break;
      if (_pauseRequested) {
        _setState(PAUSED);
        while (_pauseRequested) {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
    completedSuccessfully=true;
  }
  finally {
    wrapup();
    if (_state != IDLE) {
      _setState(IDLE);
    }
    _finishRequested=false;
    if (completedSuccessfully) {
      _notifyListenersOfCompletion();
    }
  }
  long endTime=(new Date()).getTime();
  System.out.println(""String_Node_Str"" + (endTime - startTime) + ""String_Node_Str"");
}","/** 
 * Execute the model.  Begin with the initialization phase, followed by a sequence of iterations, followed by a wrapup phase. The sequence of iterations concludes when the postfire() method of the container (the top-level composite actor) returns false, or when the finish() method is called. <p> The execution is performed in the calling thread (the current thread), so this method returns only after execution finishes. If you wish to perform execution in a new thread, use startRun() instead.  Even if an exception occurs during the execution, the wrapup() method is called (in a finally clause).  It is up to the caller to handle (i.e. report) the exception. If you do not wish to handle exceptions, but want to execute within the calling thread, use run().
 * @exception KernelException If the model throws it.
 * @exception IllegalActionException If the model is already running, orif there is no container.
 */
public synchronized void execute() throws KernelException, IllegalActionException {
  long startTime=(new Date()).getTime();
  boolean completedSuccessfully=false;
  try {
    initialize();
    if (_debugging)     _debug(""String_Node_Str"");
    while (!_finishRequested) {
      if (!iterate())       break;
      if (_pauseRequested) {
        _setState(PAUSED);
        while (_pauseRequested) {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
    completedSuccessfully=true;
  }
  finally {
    try {
      wrapup();
    }
  finally {
      if (_state != IDLE) {
        _setState(IDLE);
      }
      _finishRequested=false;
      if (completedSuccessfully) {
        _notifyListenersOfCompletion();
      }
    }
  }
  long endTime=(new Date()).getTime();
  System.out.println(""String_Node_Str"" + (endTime - startTime) + ""String_Node_Str"");
}"
76087,"/** 
 * Set the visibility of the Fill button. This is deprecated.  Use setButtons().
 * @deprecated
 */
protected void _setButtonsVisibility(boolean vis){
  _fillButton.setVisible(vis);
}","/** 
 * Set the visibility of the Fill button. This is deprecated.  Use setButtons().
 * @deprecated
 */
protected void _setButtonsVisibility(boolean vis){
  _fillButton.setVisible(vis);
  _formatButton.setVisible(vis);
  _resetButton.setVisible(vis);
}"
76088,"/** 
 * Construct a plot box with a default configuration. 
 */
public PlotBox(){
  setOpaque(true);
  setLayout(new FlowLayout(FlowLayout.RIGHT));
  addMouseListener(new ZoomListener());
  addKeyListener(new CommandListener());
  addMouseMotionListener(new DragListener());
  _measureFonts();
  requestFocus();
}","/** 
 * Construct a plot box with a default configuration. 
 */
public PlotBox(){
  setOpaque(true);
  setLayout(new FlowLayout(FlowLayout.RIGHT,2,2));
  addMouseListener(new ZoomListener());
  addKeyListener(new CommandListener());
  addMouseMotionListener(new DragListener());
  _measureFonts();
  requestFocus();
}"
76089,"/** 
 * Rescale so that the data that is currently plotted just fits. This is done based on the protected variables _xBottom, _xTop, _yBottom, and _yTop.  It is up to derived classes to ensure that variables are valid. This method calls repaint(), which eventually causes the display to be updated.
 */
public synchronized void fillPlot(){
  _setXRange(_xBottom,_xTop);
  _setYRange(_yBottom,_yTop);
  repaint();
  requestFocus();
}","/** 
 * Rescale so that the data that is currently plotted just fits. This is done based on the protected variables _xBottom, _xTop, _yBottom, and _yTop.  It is up to derived classes to ensure that variables are valid. This method calls repaint(), which eventually causes the display to be updated.
 */
public synchronized void fillPlot(){
  setXRange(_xBottom,_xTop);
  setYRange(_yBottom,_yTop);
  repaint();
  requestFocus();
}"
76090,"/** 
 * Control whether the X axis is wrapped. If it is, then X values that are out of range are remapped to be in range using modulo arithmetic.
 * @param wrap If true, wrapping of the X axis is enabled.
 */
public void setWrap(boolean wrap){
  _wrap=wrap;
}","/** 
 * Specify whether the X axis is wrapped. If it is, then X values that are out of range are remapped to be in range using modulo arithmetic. The X range is determined by the most recent call to setXRange() (or the most recent zoom). If the X range has not been set, then use the default X range, or if data has been plotted, then the current fill range.
 * @param wrap If true, wrapping of the X axis is enabled.
 */
public void setWrap(boolean wrap){
  _wrap=wrap;
  if (!_xRangeGiven) {
    if (_xBottom > _xTop) {
      setXRange(0,0);
    }
 else {
      setXRange(_xBottom,_xTop);
    }
  }
  _wrapLow=_xlowgiven;
  _wrapHigh=_xhighgiven;
}"
76091,"/** 
 * If the argument is true, make a fill button visible at the upper right.  This button auto-scales the plot. NOTE: The button may infringe on the title space, if the title is long.  In an application, it is preferable to provide a menu with the fill command.  This way, when printing the plot, the printed plot will not have a spurious button.  Thus, this method should be used only by applets, which normally do not have menus. This method should only be called from within the event dispatch thread, since it interacts with swing.
 */
public synchronized void setButtons(boolean visible){
  if (_fillButton == null) {
    _fillButton=new JButton(""String_Node_Str"");
    _fillButton.addActionListener(new FillButtonListener());
    add(_fillButton);
  }
  _fillButton.setVisible(visible);
  requestFocus();
}","/** 
 * If the argument is true, make a fill button visible at the upper right.  This button auto-scales the plot. NOTE: The button may infringe on the title space, if the title is long.  In an application, it is preferable to provide a menu with the fill command.  This way, when printing the plot, the printed plot will not have a spurious button.  Thus, this method should be used only by applets, which normally do not have menus. This method should only be called from within the event dispatch thread, since it interacts with swing.
 */
public synchronized void setButtons(boolean visible){
  if (_resetButton == null) {
    URL img=getClass().getResource(""String_Node_Str"");
    ImageIcon resetIcon=new ImageIcon(img);
    _resetButton=new JButton(resetIcon);
    _resetButton.setBorderPainted(false);
    _resetButton.setPreferredSize(new Dimension(20,20));
    _resetButton.setToolTipText(""String_Node_Str"");
    _resetButton.addActionListener(new ButtonListener());
    add(_resetButton);
  }
  _resetButton.setVisible(visible);
  if (_formatButton == null) {
    URL img=getClass().getResource(""String_Node_Str"");
    ImageIcon formatIcon=new ImageIcon(img);
    _formatButton=new JButton(formatIcon);
    _formatButton.setBorderPainted(false);
    _formatButton.setPreferredSize(new Dimension(20,20));
    _formatButton.setToolTipText(""String_Node_Str"");
    _formatButton.addActionListener(new ButtonListener());
    add(_formatButton);
  }
  _formatButton.setVisible(visible);
  if (_fillButton == null) {
    URL img=getClass().getResource(""String_Node_Str"");
    ImageIcon fillIcon=new ImageIcon(img);
    _fillButton=new JButton(fillIcon);
    _fillButton.setBorderPainted(false);
    _fillButton.setPreferredSize(new Dimension(20,20));
    _fillButton.setToolTipText(""String_Node_Str"");
    _fillButton.addActionListener(new ButtonListener());
    add(_fillButton);
  }
  _fillButton.setVisible(visible);
  requestFocus();
}"
76092,"/** 
 * Set the Y (vertical) range of the plot.  If this is not done explicitly, then the range is computed automatically from data available when the plot is drawn.  If min and max are identical, then the range is arbitrarily spread by 0.1.
 * @param min The bottom extent of the range.
 * @param max The top extent of the range.
 */
public synchronized void setYRange(double min,double max){
  _yRangeGiven=true;
  _ylowgiven=min;
  _yhighgiven=max;
  _setYRange(min,max);
}","/** 
 * Set the Y (vertical) range of the plot.  If this is not done explicitly, then the range is computed automatically from data available when the plot is drawn.  If min and max are identical, then the range is arbitrarily spread by 0.1.
 * @param min The bottom extent of the range.
 * @param max The top extent of the range.
 */
public synchronized void setYRange(double min,double max){
  _yRangeGiven=true;
  _ylowgiven=min;
  _yhighgiven=max;
  if (!_originalYRangeGiven) {
    _originalYlow=min;
    _originalYhigh=max;
    _originalYRangeGiven=true;
  }
  _setYRange(min,max);
}"
76093,"/** 
 * Draw the axes using the current range, label, and title information. If the second argument is true, clear the display before redrawing. This method is called by paintComponent().  To cause it to be called you would normally call repaint(), which eventually causes paintComponent() to be called. <p> Note that this is synchronized so that points are not added by other threads while the drawing is occurring.  This method should be called only from the event dispatch thread, consistent with swing policy.
 * @param graphics The graphics context.
 * @param clearfirst If true, clear the plot before proceeding.
 */
protected synchronized void _drawPlot(Graphics graphics,boolean clearfirst){
  if (graphics == null)   return;
  Rectangle drawRect=getBounds();
  graphics.setPaintMode();
  if (_errorMsg != null) {
    int fheight=_labelFontMetrics.getHeight() + 2;
    int msgy=fheight;
    graphics.setColor(Color.black);
    for (int i=0; i < _errorMsg.length; i++) {
      graphics.drawString(_errorMsg[i],10,msgy);
      msgy+=fheight;
      System.err.println(_errorMsg[i]);
    }
    return;
  }
  if (!_xRangeGiven) {
    if (_xBottom > _xTop) {
      _setXRange(0,0);
    }
 else {
      _setXRange(_xBottom,_xTop);
    }
  }
  if (!_yRangeGiven) {
    if (_yBottom > _yTop) {
      _setYRange(0,0);
    }
 else {
      _setYRange(_yBottom,_yTop);
    }
  }
  int titley=0;
  int titlefontheight=_titleFontMetrics.getHeight();
  if (_title == null) {
    _title=""String_Node_Str"";
  }
  if (_title != null || _yExp != 0) {
    titley=titlefontheight + _topPadding;
  }
  graphics.setFont(_labelFont);
  int labelheight=_labelFontMetrics.getHeight();
  int halflabelheight=labelheight / 2;
  int ySPos=drawRect.height - 5;
  int xSPos=drawRect.width - _rightPadding;
  if (_xlog)   _xExp=(int)Math.floor(_xtickMin);
  if (_xExp != 0 && _xticks == null) {
    String superscript=Integer.toString(_xExp);
    xSPos-=_superscriptFontMetrics.stringWidth(superscript);
    graphics.setFont(_superscriptFont);
    if (!_xlog) {
      graphics.drawString(superscript,xSPos,ySPos - halflabelheight);
      xSPos-=_labelFontMetrics.stringWidth(""String_Node_Str"");
      graphics.setFont(_labelFont);
      graphics.drawString(""String_Node_Str"",xSPos,ySPos);
    }
    _bottomPadding=(3 * labelheight) / 2 + 5;
  }
  if (_xlabel != null && _bottomPadding < labelheight + 5) {
    _bottomPadding=labelheight + 5;
  }
  _uly=titley + 5;
  _lry=drawRect.height - labelheight - _bottomPadding- 3;
  int height=_lry - _uly;
  _yscale=height / (_yMax - _yMin);
  _ytickscale=height / (_ytickMax - _ytickMin);
  int ny=2 + height / (labelheight + 10);
  double yStep=_roundUp((_ytickMax - _ytickMin) / (double)ny);
  double yStart=yStep * Math.ceil(_ytickMin / yStep);
  int widesty=0;
  String ylabels[]=new String[ny];
  int ylabwidth[]=new int[ny];
  int ind=0;
  if (_yticks == null) {
    Vector ygrid=null;
    if (_ylog) {
      ygrid=_gridInit(yStart,yStep,true,null);
    }
    int numfracdigits=_numFracDigits(yStep);
    double yTmpStart=yStart;
    if (_ylog)     yTmpStart=_gridStep(ygrid,yStart,yStep,_ylog);
    for (double ypos=yTmpStart; ypos <= _ytickMax; ypos=_gridStep(ygrid,ypos,yStep,_ylog)) {
      if (ind >= ny)       break;
      String yticklabel;
      if (_ylog) {
        yticklabel=_formatLogNum(ypos,numfracdigits);
      }
 else {
        yticklabel=_formatNum(ypos,numfracdigits);
      }
      ylabels[ind]=yticklabel;
      int lw=_labelFontMetrics.stringWidth(yticklabel);
      ylabwidth[ind++]=lw;
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
 else {
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      int lw=_labelFontMetrics.stringWidth(label);
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
  if (_ylabel != null) {
    _ulx=widesty + _labelFontMetrics.stringWidth(""String_Node_Str"") + _leftPadding;
  }
 else {
    _ulx=widesty + _leftPadding;
  }
  int legendwidth=_drawLegend(graphics,drawRect.width - _rightPadding,_uly);
  _lrx=drawRect.width - legendwidth - _rightPadding;
  int width=_lrx - _ulx;
  _xscale=width / (_xMax - _xMin);
  _xtickscale=width / (_xtickMax - _xtickMin);
  graphics.setColor(Color.white);
  graphics.fillRect(_ulx,_uly,width,height);
  graphics.setColor(_foreground);
  graphics.drawRect(_ulx,_uly,width,height);
  int tickLength=5;
  int xCoord1=_ulx + tickLength;
  int xCoord2=_lrx - tickLength;
  if (_yticks == null) {
    Vector ygrid=null;
    double yTmpStart=yStart;
    if (_ylog) {
      ygrid=_gridInit(yStart,yStep,true,null);
      yTmpStart=_gridStep(ygrid,yStart,yStep,_ylog);
      ny=ind;
    }
    ind=0;
    boolean needExponent=_ylog;
    for (double ypos=yTmpStart; ypos <= _ytickMax; ypos=_gridStep(ygrid,ypos,yStep,_ylog)) {
      if (ind >= ny)       break;
      int yCoord1=_lry - (int)((ypos - _ytickMin) * _ytickscale);
      int offset=0;
      if (ind > 0 && !_ylog)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      if (_ylog && ylabels[ind].indexOf('e') != -1)       needExponent=false;
      graphics.drawString(ylabels[ind],_ulx - ylabwidth[ind++] - 4,yCoord1 + offset);
    }
    if (_ylog) {
      Vector unlabeledgrid=_gridInit(yStart,yStep,false,ygrid);
      if (unlabeledgrid.size() > 0) {
        double tmpStep=(yStep > 1.0) ? 1.0 : yStep;
        for (double ypos=_gridStep(unlabeledgrid,yStart,tmpStep,_ylog); ypos <= _ytickMax; ypos=_gridStep(unlabeledgrid,ypos,tmpStep,_ylog)) {
          int yCoord1=_lry - (int)((ypos - _ytickMin) * _ytickscale);
          if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
            graphics.setColor(Color.lightGray);
            graphics.drawLine(_ulx + 1,yCoord1,_lrx - 1,yCoord1);
            graphics.setColor(_foreground);
          }
        }
      }
      if (needExponent) {
        _yExp=(int)Math.floor(yTmpStart);
      }
 else {
        _yExp=0;
      }
    }
    if (_yExp != 0) {
      graphics.drawString(""String_Node_Str"",2,titley);
      graphics.setFont(_superscriptFont);
      graphics.drawString(Integer.toString(_yExp),_labelFontMetrics.stringWidth(""String_Node_Str"") + 2,titley - halflabelheight);
      graphics.setFont(_labelFont);
    }
  }
 else {
    Enumeration nt=_yticks.elements();
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double ypos=((Double)(nt.nextElement())).doubleValue();
      if (ypos > _yMax || ypos < _yMin)       continue;
      int yCoord1=_lry - (int)((ypos - _yMin) * _yscale);
      int offset=0;
      if (ypos < _lry - labelheight)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(label,_ulx - _labelFontMetrics.stringWidth(label) - 3,yCoord1 + offset);
    }
  }
  int yCoord1=_uly + tickLength;
  int yCoord2=_lry - tickLength;
  if (_xticks == null) {
    int nx=10;
    double xStep=0.0;
    int numfracdigits=0;
    int charwidth=_labelFontMetrics.stringWidth(""String_Node_Str"");
    if (_xlog) {
      nx=2 + width / ((charwidth * 6) + 10);
    }
 else {
      int count=0;
      while (count++ <= 10) {
        xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
        numfracdigits=_numFracDigits(xStep);
        int intdigits=_numIntDigits(_xtickMax);
        int inttemp=_numIntDigits(_xtickMin);
        if (intdigits < inttemp) {
          intdigits=inttemp;
        }
        int maxlabelwidth=charwidth * (numfracdigits + 2 + intdigits);
        int savenx=nx;
        nx=2 + width / (maxlabelwidth + 10);
        if (nx - savenx <= 1 || savenx - nx <= 1)         break;
      }
    }
    xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
    numfracdigits=_numFracDigits(xStep);
    double xStart=xStep * Math.ceil(_xtickMin / xStep);
    Vector xgrid=null;
    double xTmpStart=xStart;
    if (_xlog) {
      xgrid=_gridInit(xStart,xStep,true,null);
      xTmpStart=_gridRoundUp(xgrid,xStart);
    }
    boolean needExponent=_xlog;
    for (double xpos=xTmpStart; xpos <= _xtickMax; xpos=_gridStep(xgrid,xpos,xStep,_xlog)) {
      String xticklabel;
      if (_xlog) {
        xticklabel=_formatLogNum(xpos,numfracdigits);
        if (xticklabel.indexOf('e') != -1)         needExponent=false;
      }
 else {
        xticklabel=_formatNum(xpos,numfracdigits);
      }
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - _labelFontMetrics.stringWidth(xticklabel) / 2;
      graphics.drawString(xticklabel,labxpos,_lry + 3 + labelheight);
    }
    if (_xlog) {
      double tmpStep=(xStep > 1.0) ? 1.0 : xStep;
      xTmpStart=tmpStep * Math.ceil(_xtickMin / tmpStep);
      Vector unlabeledgrid=_gridInit(xTmpStart,tmpStep,false,xgrid);
      if (unlabeledgrid.size() > 0) {
        for (double xpos=_gridStep(unlabeledgrid,xTmpStart,tmpStep,_xlog); xpos <= _xtickMax; xpos=_gridStep(unlabeledgrid,xpos,tmpStep,_xlog)) {
          xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
          if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
            graphics.setColor(Color.lightGray);
            graphics.drawLine(xCoord1,_uly + 1,xCoord1,_lry - 1);
            graphics.setColor(_foreground);
          }
        }
      }
      if (needExponent) {
        _xExp=(int)Math.floor(xTmpStart);
        graphics.setFont(_superscriptFont);
        graphics.drawString(Integer.toString(_xExp),xSPos,ySPos - halflabelheight);
        xSPos-=_labelFontMetrics.stringWidth(""String_Node_Str"");
        graphics.setFont(_labelFont);
        graphics.drawString(""String_Node_Str"",xSPos,ySPos);
      }
 else {
        _xExp=0;
      }
    }
  }
 else {
    Enumeration nt=_xticks.elements();
    Enumeration nl=_xticklabels.elements();
    double preLength=0.0;
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double xpos=((Double)(nt.nextElement())).doubleValue();
      if (xpos > _xMax || xpos < _xMin)       continue;
      xCoord1=_ulx + (int)((xpos - _xMin) * _xscale);
      int labxpos=xCoord1 - _labelFontMetrics.stringWidth(label) / 2;
      if (labxpos > preLength) {
        preLength=xCoord1 + _labelFontMetrics.stringWidth(label) / 2 + 10;
        graphics.drawString(label,labxpos,_lry + 3 + labelheight);
        graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
        graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
        if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
          graphics.setColor(Color.lightGray);
          graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
          graphics.setColor(_foreground);
        }
      }
    }
  }
  graphics.setColor(_foreground);
  if (_title != null) {
    graphics.setFont(_titleFont);
    int titlex=_ulx + (width - _titleFontMetrics.stringWidth(_title)) / 2;
    graphics.drawString(_title,titlex,titley);
  }
  graphics.setFont(_labelFont);
  if (_xlabel != null) {
    int labelx=_ulx + (width - _labelFontMetrics.stringWidth(_xlabel)) / 2;
    graphics.drawString(_xlabel,labelx,ySPos);
  }
  int charcenter=2 + _labelFontMetrics.stringWidth(""String_Node_Str"") / 2;
  int charheight=labelheight;
  if (_ylabel != null) {
    int yl=_ylabel.length();
    int starty=_uly + (_lry - _uly) / 2 - yl * charheight / 2 + charheight;
    for (int i=0; i < yl; i++) {
      String nchar=_ylabel.substring(i,i + 1);
      int cwidth=_labelFontMetrics.stringWidth(nchar);
      graphics.drawString(nchar,charcenter - cwidth / 2,starty);
      starty+=charheight;
    }
  }
}","/** 
 * Draw the axes using the current range, label, and title information. If the second argument is true, clear the display before redrawing. This method is called by paintComponent().  To cause it to be called you would normally call repaint(), which eventually causes paintComponent() to be called. <p> Note that this is synchronized so that points are not added by other threads while the drawing is occurring.  This method should be called only from the event dispatch thread, consistent with swing policy.
 * @param graphics The graphics context.
 * @param clearfirst If true, clear the plot before proceeding.
 */
protected synchronized void _drawPlot(Graphics graphics,boolean clearfirst){
  if (graphics == null)   return;
  Rectangle drawRect=getBounds();
  graphics.setPaintMode();
  if (_errorMsg != null) {
    int fheight=_labelFontMetrics.getHeight() + 2;
    int msgy=fheight;
    graphics.setColor(Color.black);
    for (int i=0; i < _errorMsg.length; i++) {
      graphics.drawString(_errorMsg[i],10,msgy);
      msgy+=fheight;
      System.err.println(_errorMsg[i]);
    }
    return;
  }
  if (!_xRangeGiven) {
    if (_xBottom > _xTop) {
      _setXRange(0,0);
    }
 else {
      _setXRange(_xBottom,_xTop);
    }
  }
  if (!_yRangeGiven) {
    if (_yBottom > _yTop) {
      _setYRange(0,0);
    }
 else {
      _setYRange(_yBottom,_yTop);
    }
  }
  int titley=0;
  int titlefontheight=_titleFontMetrics.getHeight();
  if (_title == null) {
    _title=""String_Node_Str"";
  }
  if (_title != null || _yExp != 0) {
    titley=titlefontheight + _topPadding;
  }
  Font previousFont=graphics.getFont();
  graphics.setFont(_labelFont);
  int labelheight=_labelFontMetrics.getHeight();
  int halflabelheight=labelheight / 2;
  int ySPos=drawRect.height - 5;
  int xSPos=drawRect.width - _rightPadding;
  if (_xlog)   _xExp=(int)Math.floor(_xtickMin);
  if (_xExp != 0 && _xticks == null) {
    String superscript=Integer.toString(_xExp);
    xSPos-=_superscriptFontMetrics.stringWidth(superscript);
    graphics.setFont(_superscriptFont);
    if (!_xlog) {
      graphics.drawString(superscript,xSPos,ySPos - halflabelheight);
      xSPos-=_labelFontMetrics.stringWidth(""String_Node_Str"");
      graphics.setFont(_labelFont);
      graphics.drawString(""String_Node_Str"",xSPos,ySPos);
    }
    _bottomPadding=(3 * labelheight) / 2 + 5;
  }
  if (_xlabel != null && _bottomPadding < labelheight + 5) {
    _bottomPadding=labelheight + 5;
  }
  _uly=titley + 5;
  _lry=drawRect.height - labelheight - _bottomPadding- 3;
  int height=_lry - _uly;
  _yscale=height / (_yMax - _yMin);
  _ytickscale=height / (_ytickMax - _ytickMin);
  int ny=2 + height / (labelheight + 10);
  double yStep=_roundUp((_ytickMax - _ytickMin) / (double)ny);
  double yStart=yStep * Math.ceil(_ytickMin / yStep);
  int widesty=0;
  String ylabels[]=new String[ny];
  int ylabwidth[]=new int[ny];
  int ind=0;
  if (_yticks == null) {
    Vector ygrid=null;
    if (_ylog) {
      ygrid=_gridInit(yStart,yStep,true,null);
    }
    int numfracdigits=_numFracDigits(yStep);
    double yTmpStart=yStart;
    if (_ylog)     yTmpStart=_gridStep(ygrid,yStart,yStep,_ylog);
    for (double ypos=yTmpStart; ypos <= _ytickMax; ypos=_gridStep(ygrid,ypos,yStep,_ylog)) {
      if (ind >= ny)       break;
      String yticklabel;
      if (_ylog) {
        yticklabel=_formatLogNum(ypos,numfracdigits);
      }
 else {
        yticklabel=_formatNum(ypos,numfracdigits);
      }
      ylabels[ind]=yticklabel;
      int lw=_labelFontMetrics.stringWidth(yticklabel);
      ylabwidth[ind++]=lw;
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
 else {
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      int lw=_labelFontMetrics.stringWidth(label);
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
  if (_ylabel != null) {
    _ulx=widesty + _labelFontMetrics.stringWidth(""String_Node_Str"") + _leftPadding;
  }
 else {
    _ulx=widesty + _leftPadding;
  }
  int legendwidth=_drawLegend(graphics,drawRect.width - _rightPadding,_uly);
  _lrx=drawRect.width - legendwidth - _rightPadding;
  int width=_lrx - _ulx;
  _xscale=width / (_xMax - _xMin);
  _xtickscale=width / (_xtickMax - _xtickMin);
  graphics.setColor(Color.white);
  graphics.fillRect(_ulx,_uly,width,height);
  graphics.setColor(_foreground);
  graphics.drawRect(_ulx,_uly,width,height);
  int tickLength=5;
  int xCoord1=_ulx + tickLength;
  int xCoord2=_lrx - tickLength;
  if (_yticks == null) {
    Vector ygrid=null;
    double yTmpStart=yStart;
    if (_ylog) {
      ygrid=_gridInit(yStart,yStep,true,null);
      yTmpStart=_gridStep(ygrid,yStart,yStep,_ylog);
      ny=ind;
    }
    ind=0;
    boolean needExponent=_ylog;
    for (double ypos=yTmpStart; ypos <= _ytickMax; ypos=_gridStep(ygrid,ypos,yStep,_ylog)) {
      if (ind >= ny)       break;
      int yCoord1=_lry - (int)((ypos - _ytickMin) * _ytickscale);
      int offset=0;
      if (ind > 0 && !_ylog)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      if (_ylog && ylabels[ind].indexOf('e') != -1)       needExponent=false;
      graphics.drawString(ylabels[ind],_ulx - ylabwidth[ind++] - 4,yCoord1 + offset);
    }
    if (_ylog) {
      Vector unlabeledgrid=_gridInit(yStart,yStep,false,ygrid);
      if (unlabeledgrid.size() > 0) {
        double tmpStep=(yStep > 1.0) ? 1.0 : yStep;
        for (double ypos=_gridStep(unlabeledgrid,yStart,tmpStep,_ylog); ypos <= _ytickMax; ypos=_gridStep(unlabeledgrid,ypos,tmpStep,_ylog)) {
          int yCoord1=_lry - (int)((ypos - _ytickMin) * _ytickscale);
          if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
            graphics.setColor(Color.lightGray);
            graphics.drawLine(_ulx + 1,yCoord1,_lrx - 1,yCoord1);
            graphics.setColor(_foreground);
          }
        }
      }
      if (needExponent) {
        _yExp=(int)Math.floor(yTmpStart);
      }
 else {
        _yExp=0;
      }
    }
    if (_yExp != 0) {
      graphics.drawString(""String_Node_Str"",2,titley);
      graphics.setFont(_superscriptFont);
      graphics.drawString(Integer.toString(_yExp),_labelFontMetrics.stringWidth(""String_Node_Str"") + 2,titley - halflabelheight);
      graphics.setFont(_labelFont);
    }
  }
 else {
    Enumeration nt=_yticks.elements();
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double ypos=((Double)(nt.nextElement())).doubleValue();
      if (ypos > _yMax || ypos < _yMin)       continue;
      int yCoord1=_lry - (int)((ypos - _yMin) * _yscale);
      int offset=0;
      if (ypos < _lry - labelheight)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(label,_ulx - _labelFontMetrics.stringWidth(label) - 3,yCoord1 + offset);
    }
  }
  int yCoord1=_uly + tickLength;
  int yCoord2=_lry - tickLength;
  if (_xticks == null) {
    int nx=10;
    double xStep=0.0;
    int numfracdigits=0;
    int charwidth=_labelFontMetrics.stringWidth(""String_Node_Str"");
    if (_xlog) {
      nx=2 + width / ((charwidth * 6) + 10);
    }
 else {
      int count=0;
      while (count++ <= 10) {
        xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
        numfracdigits=_numFracDigits(xStep);
        int intdigits=_numIntDigits(_xtickMax);
        int inttemp=_numIntDigits(_xtickMin);
        if (intdigits < inttemp) {
          intdigits=inttemp;
        }
        int maxlabelwidth=charwidth * (numfracdigits + 2 + intdigits);
        int savenx=nx;
        nx=2 + width / (maxlabelwidth + 10);
        if (nx - savenx <= 1 || savenx - nx <= 1)         break;
      }
    }
    xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
    numfracdigits=_numFracDigits(xStep);
    double xStart=xStep * Math.ceil(_xtickMin / xStep);
    Vector xgrid=null;
    double xTmpStart=xStart;
    if (_xlog) {
      xgrid=_gridInit(xStart,xStep,true,null);
      xTmpStart=_gridRoundUp(xgrid,xStart);
    }
    boolean needExponent=_xlog;
    for (double xpos=xTmpStart; xpos <= _xtickMax; xpos=_gridStep(xgrid,xpos,xStep,_xlog)) {
      String xticklabel;
      if (_xlog) {
        xticklabel=_formatLogNum(xpos,numfracdigits);
        if (xticklabel.indexOf('e') != -1)         needExponent=false;
      }
 else {
        xticklabel=_formatNum(xpos,numfracdigits);
      }
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - _labelFontMetrics.stringWidth(xticklabel) / 2;
      graphics.drawString(xticklabel,labxpos,_lry + 3 + labelheight);
    }
    if (_xlog) {
      double tmpStep=(xStep > 1.0) ? 1.0 : xStep;
      xTmpStart=tmpStep * Math.ceil(_xtickMin / tmpStep);
      Vector unlabeledgrid=_gridInit(xTmpStart,tmpStep,false,xgrid);
      if (unlabeledgrid.size() > 0) {
        for (double xpos=_gridStep(unlabeledgrid,xTmpStart,tmpStep,_xlog); xpos <= _xtickMax; xpos=_gridStep(unlabeledgrid,xpos,tmpStep,_xlog)) {
          xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
          if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
            graphics.setColor(Color.lightGray);
            graphics.drawLine(xCoord1,_uly + 1,xCoord1,_lry - 1);
            graphics.setColor(_foreground);
          }
        }
      }
      if (needExponent) {
        _xExp=(int)Math.floor(xTmpStart);
        graphics.setFont(_superscriptFont);
        graphics.drawString(Integer.toString(_xExp),xSPos,ySPos - halflabelheight);
        xSPos-=_labelFontMetrics.stringWidth(""String_Node_Str"");
        graphics.setFont(_labelFont);
        graphics.drawString(""String_Node_Str"",xSPos,ySPos);
      }
 else {
        _xExp=0;
      }
    }
  }
 else {
    Enumeration nt=_xticks.elements();
    Enumeration nl=_xticklabels.elements();
    double preLength=0.0;
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double xpos=((Double)(nt.nextElement())).doubleValue();
      if (xpos > _xMax || xpos < _xMin)       continue;
      xCoord1=_ulx + (int)((xpos - _xMin) * _xscale);
      int labxpos=xCoord1 - _labelFontMetrics.stringWidth(label) / 2;
      if (labxpos > preLength) {
        preLength=xCoord1 + _labelFontMetrics.stringWidth(label) / 2 + 10;
        graphics.drawString(label,labxpos,_lry + 3 + labelheight);
        graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
        graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
        if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
          graphics.setColor(Color.lightGray);
          graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
          graphics.setColor(_foreground);
        }
      }
    }
  }
  graphics.setColor(_foreground);
  if (_title != null) {
    graphics.setFont(_titleFont);
    int titlex=_ulx + (width - _titleFontMetrics.stringWidth(_title)) / 2;
    graphics.drawString(_title,titlex,titley);
  }
  graphics.setFont(_labelFont);
  if (_xlabel != null) {
    int labelx=_ulx + (width - _labelFontMetrics.stringWidth(_xlabel)) / 2;
    graphics.drawString(_xlabel,labelx,ySPos);
  }
  int charcenter=2 + _labelFontMetrics.stringWidth(""String_Node_Str"") / 2;
  int charheight=labelheight;
  if (_ylabel != null) {
    int yl=_ylabel.length();
    int starty=_uly + (_lry - _uly) / 2 - yl * charheight / 2 + charheight;
    for (int i=0; i < yl; i++) {
      String nchar=_ylabel.substring(i,i + 1);
      int cwidth=_labelFontMetrics.stringWidth(nchar);
      graphics.drawString(nchar,charcenter - cwidth / 2,starty);
      starty+=charheight;
    }
  }
  graphics.setFont(previousFont);
}"
76094,"void _zoom(int x,int y){
  _zooming=false;
  Graphics graphics=getGraphics();
  if (graphics == null)   return;
  boolean handled=false;
  if ((_zoomin == true) && (_drawn == true)) {
    if (_zoomxn != -1 || _zoomyn != -1) {
      int minx=Math.min(_zoomx,_zoomxn);
      int maxx=Math.max(_zoomx,_zoomxn);
      int miny=Math.min(_zoomy,_zoomyn);
      int maxy=Math.max(_zoomy,_zoomyn);
      graphics.setXORMode(_boxColor);
      graphics.drawRect(minx,miny,maxx - minx,maxy - miny);
      graphics.setPaintMode();
      if (y > _lry)       y=_lry;
      if (y < _uly)       y=_uly;
      if (x > _lrx)       x=_lrx;
      if (x < _ulx)       x=_ulx;
      if ((Math.abs(_zoomx - x) > 5) && (Math.abs(_zoomy - y) > 5)) {
        double a=_xMin + (_zoomx - _ulx) / _xscale;
        double b=_xMin + (x - _ulx) / _xscale;
        if (a < b)         _setXRange(a,b);
 else         _setXRange(b,a);
        a=_yMax - (_zoomy - _uly) / _yscale;
        b=_yMax - (y - _uly) / _yscale;
        if (a < b)         setYRange(a,b);
 else         setYRange(b,a);
      }
      repaint();
      handled=true;
    }
  }
 else   if ((_zoomout == true) && (_drawn == true)) {
    graphics.setXORMode(_boxColor);
    int x_diff=Math.abs(_zoomx - _zoomxn);
    int y_diff=Math.abs(_zoomy - _zoomyn);
    graphics.drawRect(_zoomx - 15 - x_diff,_zoomy - 15 - y_diff,30 + x_diff * 2,30 + y_diff * 2);
    graphics.setPaintMode();
    double a=(double)(Math.abs(_zoomx - x)) / 30.0;
    double b=(double)(Math.abs(_zoomy - y)) / 30.0;
    double newx1=_xMax + (_xMax - _xMin) * a;
    double newx2=_xMin - (_xMax - _xMin) * a;
    double newy1=_yMax + (_yMax - _yMin) * b;
    double newy2=_yMin - (_yMax - _yMin) * b;
    zoom(newx2,newy2,newx1,newy1);
    handled=true;
  }
 else   if (_drawn == false) {
    repaint();
    handled=true;
  }
  _drawn=false;
  _zoomin=_zoomout=false;
  _zoomxn=_zoomyn=_zoomx=_zoomy=-1;
}","void _zoom(int x,int y){
  _zooming=false;
  Graphics graphics=getGraphics();
  if (graphics == null)   return;
  boolean handled=false;
  if ((_zoomin == true) && (_drawn == true)) {
    if (_zoomxn != -1 || _zoomyn != -1) {
      int minx=Math.min(_zoomx,_zoomxn);
      int maxx=Math.max(_zoomx,_zoomxn);
      int miny=Math.min(_zoomy,_zoomyn);
      int maxy=Math.max(_zoomy,_zoomyn);
      graphics.setXORMode(_boxColor);
      graphics.drawRect(minx,miny,maxx - minx,maxy - miny);
      graphics.setPaintMode();
      if (y > _lry)       y=_lry;
      if (y < _uly)       y=_uly;
      if (x > _lrx)       x=_lrx;
      if (x < _ulx)       x=_ulx;
      if ((Math.abs(_zoomx - x) > 5) && (Math.abs(_zoomy - y) > 5)) {
        double a=_xMin + (_zoomx - _ulx) / _xscale;
        double b=_xMin + (x - _ulx) / _xscale;
        if (a < b)         setXRange(a,b);
 else         setXRange(b,a);
        a=_yMax - (_zoomy - _uly) / _yscale;
        b=_yMax - (y - _uly) / _yscale;
        if (a < b)         setYRange(a,b);
 else         setYRange(b,a);
      }
      repaint();
      handled=true;
    }
  }
 else   if ((_zoomout == true) && (_drawn == true)) {
    graphics.setXORMode(_boxColor);
    int x_diff=Math.abs(_zoomx - _zoomxn);
    int y_diff=Math.abs(_zoomy - _zoomyn);
    graphics.drawRect(_zoomx - 15 - x_diff,_zoomy - 15 - y_diff,30 + x_diff * 2,30 + y_diff * 2);
    graphics.setPaintMode();
    double a=(double)(Math.abs(_zoomx - x)) / 30.0;
    double b=(double)(Math.abs(_zoomy - y)) / 30.0;
    double newx1=_xMax + (_xMax - _xMin) * a;
    double newx2=_xMin - (_xMax - _xMin) * a;
    double newy1=_yMax + (_yMax - _yMin) * b;
    double newy2=_yMin - (_yMax - _yMin) * b;
    zoom(newx2,newy2,newx1,newy1);
    handled=true;
  }
 else   if (_drawn == false) {
    repaint();
    handled=true;
  }
  _drawn=false;
  _zoomin=_zoomout=false;
  _zoomxn=_zoomyn=_zoomx=_zoomy=-1;
}"
76095,"public void actionPerformed(ActionEvent event){
  fillPlot();
}","public void actionPerformed(ActionEvent event){
  if (event.getSource() == _fillButton) {
    fillPlot();
  }
 else   if (event.getSource() == _resetButton) {
    resetAxes();
  }
 else   if (event.getSource() == _formatButton) {
    PlotFormatter fmt=new PlotFormatter(PlotBox.this);
    fmt.openModal();
  }
}"
76096,"private int _drawLegend(Graphics graphics,int urx,int ury){
  if (graphics == null)   return 0;
  graphics.setFont(_labelFont);
  int spacing=_labelFontMetrics.getHeight();
  Enumeration v=_legendStrings.elements();
  Enumeration i=_legendDatasets.elements();
  int ypos=ury + spacing;
  int maxwidth=0;
  while (v.hasMoreElements()) {
    String legend=(String)v.nextElement();
    int dataset=((Integer)i.nextElement()).intValue();
    if (dataset >= 0) {
      if (_usecolor) {
        int color=dataset % _colors.length;
        graphics.setColor(_colors[color]);
      }
      _drawPoint(graphics,dataset,urx - 3,ypos - 3,false);
      graphics.setColor(_foreground);
      int width=_labelFontMetrics.stringWidth(legend);
      if (width > maxwidth)       maxwidth=width;
      graphics.drawString(legend,urx - 15 - width,ypos);
      ypos+=spacing;
    }
  }
  return 22 + maxwidth;
}","private int _drawLegend(Graphics graphics,int urx,int ury){
  if (graphics == null)   return 0;
  Font previousFont=graphics.getFont();
  graphics.setFont(_labelFont);
  int spacing=_labelFontMetrics.getHeight();
  Enumeration v=_legendStrings.elements();
  Enumeration i=_legendDatasets.elements();
  int ypos=ury + spacing;
  int maxwidth=0;
  while (v.hasMoreElements()) {
    String legend=(String)v.nextElement();
    int dataset=((Integer)i.nextElement()).intValue();
    if (dataset >= 0) {
      if (_usecolor) {
        int color=dataset % _colors.length;
        graphics.setColor(_colors[color]);
      }
      _drawPoint(graphics,dataset,urx - 3,ypos - 3,false);
      graphics.setColor(_foreground);
      int width=_labelFontMetrics.stringWidth(legend);
      if (width > maxwidth)       maxwidth=width;
      graphics.drawString(legend,urx - 15 - width,ypos);
      ypos+=spacing;
    }
  }
  graphics.setFont(previousFont);
  return 22 + maxwidth;
}"
76097,"/** 
 * Set the X (horizontal) range of the plot.  If this is not done explicitly, then the range is computed automatically from data available when the plot is drawn.  If min and max are identical, then the range is arbitrarily spread by 1.
 * @param min The left extent of the range.
 * @param max The right extent of the range.
 */
public synchronized void setXRange(double min,double max){
  _xRangeGiven=true;
  _xlowgiven=min;
  _xhighgiven=max;
  _setXRange(min,max);
}","/** 
 * Set the X (horizontal) range of the plot.  If this is not done explicitly, then the range is computed automatically from data available when the plot is drawn.  If min and max are identical, then the range is arbitrarily spread by 1.
 * @param min The left extent of the range.
 * @param max The right extent of the range.
 */
public synchronized void setXRange(double min,double max){
  _xRangeGiven=true;
  _xlowgiven=min;
  _xhighgiven=max;
  if (!_originalXRangeGiven) {
    _originalXlow=min;
    _originalXhigh=max;
    _originalXRangeGiven=true;
  }
  _setXRange(min,max);
}"
76098,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the <code>init</code> and <code>step</code> public members to the parameters of the new actor.
 * @param ws The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  Ramp newobj=(Ramp)super.clone(ws);
  output.setTypeEquals(BaseType.DOUBLE);
  return newobj;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the <code>init</code> and <code>step</code> public members to the parameters of the new actor.
 * @param ws The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  CurrentTime newobj=(CurrentTime)super.clone(ws);
  output.setTypeEquals(BaseType.DOUBLE);
  return newobj;
}"
76099,"/** 
 * Update the director parameters when the attributes are changed. Only the stopWhenQueueIsEmpty parameter is effective at run time.
 * @param attr The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class. May be needed by derived classes.
 */
public void attributeChanged(Attribute attr) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"",attr.getName());
  if (attr == stopWhenQueueIsEmpty) {
    _stopWhenQueueIsEmpty=((BooleanToken)stopWhenQueueIsEmpty.getToken()).booleanValue();
  }
}","/** 
 * Update the director parameters when the attributes are changed. Only the stopWhenQueueIsEmpty parameter is effective at run time.
 * @param attr The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class. May be needed by derived classes.
 */
public void attributeChanged(Attribute attr) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"",attr.getName());
  if (attr == stopWhenQueueIsEmpty) {
    _stopWhenQueueIsEmpty=((BooleanToken)stopWhenQueueIsEmpty.getToken()).booleanValue();
  }
  if (attr == synchronizeToRealTime) {
    _synchronizeToRealTime=((BooleanToken)synchronizeToRealTime.getToken()).booleanValue();
  }
}"
76100,"/** 
 * Advance current time to the next event in the event queue, and fire one or more actors that have events at that time. Each actor is iterated repeatedly (prefire(), fire(), postfire()), until either it has no more input tokens at the current time, or its prefire() method returns false. If there are no events in the event queue, then the behavior depends on whether stopWhenQueueIsEmpty() has been called.  If it has, and was given the argument false, then this thread will stall until inputs become available on the input queue.  Otherwise, time will advance to the stop time and the execution will halt.
 * @exception IllegalActionException If the firing actor throws it.
 */
public void fire() throws IllegalActionException {
  boolean _timeHasNotAdvanced=true;
  while (true) {
    Actor actorToFire=_dequeueEvents();
    if (actorToFire == null) {
      if (_debugging)       _debug(""String_Node_Str"");
      _noMoreActorsToFire=true;
      return;
    }
    if (actorToFire == getContainer()) {
      return;
    }
    boolean refire=false;
    do {
      if (_debugging) {
        _debug(""String_Node_Str"",((Entity)actorToFire).getName(),""String_Node_Str"",Double.toString(getCurrentTime()));
      }
      if (!actorToFire.prefire()) {
        if (_debugging)         _debug(""String_Node_Str"");
        break;
      }
      actorToFire.fire();
      if (!actorToFire.postfire()) {
        if (_debugging)         _debug(""String_Node_Str"",((Entity)actorToFire).getName());
        disableActor(actorToFire);
      }
      refire=false;
      Iterator inputPorts=actorToFire.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort port=(IOPort)inputPorts.next();
        for (int i=0; i < port.getWidth(); i++) {
          if (port.hasToken(i)) {
            refire=true;
            break;
          }
        }
        if (refire == true)         break;
      }
    }
 while (refire);
    try {
      DEEvent next=_eventQueue.get();
      if (next.timeStamp() > getCurrentTime())       break;
 else       if (next.timeStamp() < getCurrentTime()) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
 catch (    IllegalActionException e) {
      break;
    }
  }
}","/** 
 * Advance current time to the next event in the event queue, and fire one or more actors that have events at that time. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the time stamp of the event. Each actor is iterated repeatedly (prefire(), fire(), postfire()), until either it has no more input tokens at the current time, or its prefire() method returns false. If there are no events in the event queue, then the behavior depends on whether stopWhenQueueIsEmpty() has been called.  If it has, and was given the argument false, then this thread will stall until inputs become available on the input queue.  Otherwise, time will advance to the stop time and the execution will halt.
 * @exception IllegalActionException If the firing actor throws it.
 */
public void fire() throws IllegalActionException {
  boolean _timeHasNotAdvanced=true;
  while (true) {
    Actor actorToFire=_dequeueEvents();
    if (_debugging) {
      _debug(""String_Node_Str"" + ((NamedObj)actorToFire).getFullName());
    }
    if (actorToFire == null) {
      if (_debugging)       _debug(""String_Node_Str"");
      _noMoreActorsToFire=true;
      return;
    }
    if (actorToFire == getContainer()) {
      return;
    }
    boolean refire=false;
    do {
      if (_debugging) {
        _debug(""String_Node_Str"",((Entity)actorToFire).getName(),""String_Node_Str"",Double.toString(getCurrentTime()));
      }
      if (!actorToFire.prefire()) {
        if (_debugging)         _debug(""String_Node_Str"");
        break;
      }
      actorToFire.fire();
      if (!actorToFire.postfire()) {
        if (_debugging)         _debug(""String_Node_Str"",((Entity)actorToFire).getName());
        disableActor(actorToFire);
      }
      refire=false;
      Iterator inputPorts=actorToFire.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort port=(IOPort)inputPorts.next();
        for (int i=0; i < port.getWidth(); i++) {
          if (port.hasToken(i)) {
            refire=true;
            break;
          }
        }
        if (refire == true)         break;
      }
    }
 while (refire);
    try {
      DEEvent next=_eventQueue.get();
      if (next.timeStamp() > getCurrentTime())       break;
 else       if (next.timeStamp() < getCurrentTime()) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
 catch (    IllegalActionException e) {
      break;
    }
  }
}"
76101,"private void _initParameters(){
  try {
    stopTime=new Parameter(this,""String_Node_Str"",new DoubleToken(Double.MAX_VALUE));
    stopTime.setTypeEquals(BaseType.DOUBLE);
    stopWhenQueueIsEmpty=new Parameter(this,""String_Node_Str"",new BooleanToken(true));
    stopWhenQueueIsEmpty.setTypeEquals(BaseType.BOOLEAN);
    isCQAdaptive=new Parameter(this,""String_Node_Str"",new BooleanToken(true));
    isCQAdaptive.setTypeEquals(BaseType.BOOLEAN);
    minBinCount=new Parameter(this,""String_Node_Str"",new IntToken(2));
    minBinCount.setTypeEquals(BaseType.INT);
    binCountFactor=new Parameter(this,""String_Node_Str"",new IntToken(2));
    binCountFactor.setTypeEquals(BaseType.INT);
  }
 catch (  KernelException e) {
    throw new InternalErrorException(""String_Node_Str"" + e.getMessage());
  }
}","private void _initParameters(){
  try {
    stopTime=new Parameter(this,""String_Node_Str"",new DoubleToken(Double.MAX_VALUE));
    stopTime.setTypeEquals(BaseType.DOUBLE);
    stopWhenQueueIsEmpty=new Parameter(this,""String_Node_Str"",new BooleanToken(true));
    stopWhenQueueIsEmpty.setTypeEquals(BaseType.BOOLEAN);
    synchronizeToRealTime=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
    synchronizeToRealTime.setTypeEquals(BaseType.BOOLEAN);
    isCQAdaptive=new Parameter(this,""String_Node_Str"",new BooleanToken(true));
    isCQAdaptive.setTypeEquals(BaseType.BOOLEAN);
    minBinCount=new Parameter(this,""String_Node_Str"",new IntToken(2));
    minBinCount.setTypeEquals(BaseType.INT);
    binCountFactor=new Parameter(this,""String_Node_Str"",new IntToken(2));
    binCountFactor.setTypeEquals(BaseType.INT);
  }
 catch (  KernelException e) {
    throw new InternalErrorException(""String_Node_Str"" + e.getMessage());
  }
}"
76102,"private Actor _dequeueEvents(){
  Actor actorToFire=null;
  DEEvent currentEvent=null, nextEvent=null;
  int currentDepth=0;
  while (true) {
    if (_stopWhenQueueIsEmpty) {
      try {
        nextEvent=(DEEvent)_eventQueue.get();
      }
 catch (      IllegalActionException ex) {
        break;
      }
    }
 else {
      _stopRequested=false;
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
synchronized (_eventQueue) {
          try {
            _eventQueue.wait();
          }
 catch (          InterruptedException e) {
            break;
          }
        }
      }
      try {
        nextEvent=(DEEvent)_eventQueue.get();
      }
 catch (      IllegalActionException ex) {
        break;
      }
    }
    if (actorToFire == null) {
      try {
        _eventQueue.take();
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
      currentEvent=nextEvent;
      actorToFire=currentEvent.actor();
      if (_deadActors != null && _deadActors.contains(actorToFire)) {
        if (_debugging)         _debug(""String_Node_Str"",((Entity)actorToFire).getFullName());
        actorToFire=null;
        continue;
      }
      double currentTime=currentEvent.timeStamp();
      if (_debugging)       _debug(""String_Node_Str"",Double.toString(currentTime));
      try {
        setCurrentTime(currentTime);
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
      if (currentTime < _startTime) {
        _startTime=currentTime;
      }
      currentDepth=currentEvent.depth();
      _microstep=currentEvent.microstep();
      if (currentTime > getStopTime()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        return null;
      }
      DEReceiver rec=currentEvent.receiver();
      if (rec != null) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",rec.getContainer().getName());
        rec._triggerEvent(currentEvent.token());
      }
    }
 else {
      if (nextEvent.isSimultaneousWith(currentEvent) && nextEvent.actor() == currentEvent.actor()) {
        try {
          _eventQueue.take();
        }
 catch (        IllegalActionException ex) {
          throw new InternalErrorException(ex.toString());
        }
        DEReceiver rec=nextEvent.receiver();
        if (rec != null) {
          rec._triggerEvent(nextEvent.token());
        }
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}","private Actor _dequeueEvents(){
  Actor actorToFire=null;
  DEEvent currentEvent=null, nextEvent=null;
  int currentDepth=0;
  while (true) {
    if (_stopWhenQueueIsEmpty) {
      try {
        nextEvent=(DEEvent)_eventQueue.get();
      }
 catch (      IllegalActionException ex) {
        break;
      }
    }
 else {
      if (actorToFire != null && _eventQueue.isEmpty())       break;
      _stopRequested=false;
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
synchronized (_eventQueue) {
          try {
            _eventQueue.wait();
          }
 catch (          InterruptedException e) {
            break;
          }
        }
      }
      try {
        nextEvent=(DEEvent)_eventQueue.get();
      }
 catch (      IllegalActionException ex) {
        break;
      }
    }
    if (actorToFire == null) {
      try {
        _eventQueue.take();
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
      currentEvent=nextEvent;
      actorToFire=currentEvent.actor();
      if (_deadActors != null && _deadActors.contains(actorToFire)) {
        if (_debugging)         _debug(""String_Node_Str"",((Entity)actorToFire).getFullName());
        actorToFire=null;
        continue;
      }
      double currentTime=currentEvent.timeStamp();
      if (_synchronizeToRealTime) {
        long elapsedTime=System.currentTimeMillis() - _realStartTime;
        double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
        if (currentTime > elapsedTimeInSeconds) {
          long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
          if (timeToWait > 0) {
            if (_debugging) {
              _debug(""String_Node_Str"" + timeToWait);
            }
synchronized (_eventQueue) {
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
      if (_debugging)       _debug(""String_Node_Str"",Double.toString(currentTime));
      try {
        setCurrentTime(currentTime);
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
      if (currentTime < _startTime) {
        _startTime=currentTime;
      }
      currentDepth=currentEvent.depth();
      _microstep=currentEvent.microstep();
      if (currentTime > getStopTime()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        return null;
      }
      DEReceiver rec=currentEvent.receiver();
      if (rec != null) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",rec.getContainer().getName());
        rec._triggerEvent(currentEvent.token());
      }
    }
 else {
      if (nextEvent.isSimultaneousWith(currentEvent) && nextEvent.actor() == currentEvent.actor()) {
        try {
          _eventQueue.take();
        }
 catch (        IllegalActionException ex) {
          throw new InternalErrorException(ex.toString());
        }
        DEReceiver rec=nextEvent.receiver();
        if (rec != null) {
          rec._triggerEvent(nextEvent.token());
        }
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}"
76103,"/** 
 * Clone the director into the specified workspace. This calls the base class and then copies the parameter of this director.  The new actor will have the same parameter values as the old.
 * @param ws The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If one of the attributescannot be cloned.
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  DEDirector newobj=(DEDirector)(super.clone(ws));
  newobj.stopTime=(Parameter)newobj.getAttribute(""String_Node_Str"");
  newobj.stopWhenQueueIsEmpty=(Parameter)newobj.getAttribute(""String_Node_Str"");
  newobj.isCQAdaptive=(Parameter)newobj.getAttribute(""String_Node_Str"");
  newobj.minBinCount=(Parameter)newobj.getAttribute(""String_Node_Str"");
  newobj.binCountFactor=(Parameter)newobj.getAttribute(""String_Node_Str"");
  return newobj;
}","/** 
 * Clone the director into the specified workspace. This calls the base class and then copies the parameter of this director.  The new actor will have the same parameter values as the old.
 * @param ws The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If one of the attributescannot be cloned.
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  DEDirector newobj=(DEDirector)(super.clone(ws));
  newobj.stopTime=(Parameter)newobj.getAttribute(""String_Node_Str"");
  newobj.stopWhenQueueIsEmpty=(Parameter)newobj.getAttribute(""String_Node_Str"");
  newobj.synchronizeToRealTime=(Parameter)newobj.getAttribute(""String_Node_Str"");
  newobj.isCQAdaptive=(Parameter)newobj.getAttribute(""String_Node_Str"");
  newobj.minBinCount=(Parameter)newobj.getAttribute(""String_Node_Str"");
  newobj.binCountFactor=(Parameter)newobj.getAttribute(""String_Node_Str"");
  return newobj;
}"
76104,"/** 
 * Invoke the initialize() method of each deeply contained actor, and then check the event queue for any events. If there are any, and the director is embedded in an opaque composite actor, then request a firing of the outside director. This method should be invoked once per execution, after the initialization phase, but before any iteration.  Since type resolution has been completed, the initialize() method of a contained actor may produce output or schedule events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (_isEmbedded() && !_eventQueue.isEmpty()) {
    _requestFiring();
  }
}","/** 
 * Invoke the initialize() method of each deeply contained actor, and then check the event queue for any events. If there are any, and the director is embedded in an opaque composite actor, then request a firing of the outside director. This method should be invoked once per execution, after the initialization phase, but before any iteration.  Since type resolution has been completed, the initialize() method of a contained actor may produce output or schedule events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (_isEmbedded() && !_eventQueue.isEmpty()) {
    _requestFiring();
  }
  _realStartTime=System.currentTimeMillis();
}"
76105,"/** 
 * Configure the histogram with data from the specified input stream, which is assumed to be in PlotML format.  This should be called after place(), if place() is going to be called at all.
 * @param base The base relative to which references within the inputstream are found, or null if this is not known.
 * @param in InputStream
 * @exception Exception If the stream cannot be read or its syntaxis incorrect.
 */
public void configure(URL base,InputStream in) throws Exception {
  if (histogram == null) {
    place(_container);
  }
  HistogramMLParser parser=new HistogramMLParser(histogram);
  parser.parse(base,in);
}","/** 
 * Configure the histogram with data from the specified input stream, which is assumed to be in PlotML format.  If this is called before the plotter has been created (by calling place() or initialize()), then reading of the input stream is deferred until the plotter is created.
 * @param base The base relative to which references within the inputstream are found, or null if this is not known.
 * @param in InputStream
 * @exception Exception If the stream cannot be read or its syntaxis incorrect.
 */
public void configure(URL base,InputStream in) throws Exception {
  if (histogram != null) {
    HistogramMLParser parser=new HistogramMLParser(histogram);
    parser.parse(base,in);
    _configureBase=null;
    _configureIn=null;
  }
 else {
    _configureBase=base;
    _configureIn=in;
  }
}"
76106,"/** 
 * If the histogram has not already been created, create it using place().
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (histogram == null) {
    place(_container);
  }
 else {
    histogram.clear(false);
  }
  histogram.repaint();
}","/** 
 * If the histogram has not already been created, create it using place(). If configuration specified by a call to configure() has not yet been processed, process it.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (histogram == null) {
    place(_container);
  }
 else {
    histogram.clear(false);
  }
  histogram.repaint();
}"
76107,"/** 
 * Specify the graphical container into which this histogram should be placed. This method needs to be called before the first call to initialize(). Otherwise, the histogram will be placed in its own frame. The histogram is also placed in its own frame if this method is called with the argument null. If the argument is an instance of Histogram, then plot data to that instance.  If a container has been specified but it is not an instance of Histogram, then create a new instance of Histogram and place it in that container using its add() method.
 * @param container The container into which to place the histogram.
 */
public void place(Container container){
  _container=container;
  if (_container == null) {
    histogram=new Histogram();
    PlotFrame frame=new PlotFrame(getFullName(),histogram);
  }
 else {
    if (_container instanceof Histogram) {
      histogram=(Histogram)_container;
    }
 else {
      histogram=new Histogram();
      _container.add(histogram);
      histogram.setButtons(true);
      histogram.setBackground(_container.getBackground());
    }
  }
}","/** 
 * Specify the graphical container into which this histogram should be placed. This method needs to be called before the first call to initialize(). Otherwise, the histogram will be placed in its own frame. The histogram is also placed in its own frame if this method is called with the argument null. If the argument is an instance of Histogram, then plot data to that instance.  If a container has been specified but it is not an instance of Histogram, then create a new instance of Histogram and place it in that container using its add() method. <p> If configure() has been called (prior to the plot getting created), then the configuration that it specified has been deferred. That configuration is performed at this time.
 * @param container The container into which to place the histogram.
 */
public void place(Container container){
  _container=container;
  if (_container == null) {
    histogram=new Histogram();
    PlotFrame frame=new PlotFrame(getFullName(),histogram);
  }
 else {
    if (_container instanceof Histogram) {
      histogram=(Histogram)_container;
    }
 else {
      histogram=new Histogram();
      _container.add(histogram);
      histogram.setButtons(true);
      histogram.setBackground(_container.getBackground());
    }
  }
  if (_configureIn != null) {
    try {
      configure(_configureBase,_configureIn);
    }
 catch (    Exception ex) {
      getManager().notifyListenersOfException(ex);
    }
  }
}"
76108,"/** 
 * Configure the plot with data from the specified input stream, which is assumed to be in PlotML format.  This should be called after place(), if place() is going to be called at all.
 * @param base The base relative to which references within the inputstream are found, or null if this is not known.
 * @param in InputStream
 * @exception Exception If the stream cannot be read or its syntaxis incorrect.
 */
public void configure(URL base,InputStream in) throws Exception {
  if (plot == null) {
    place(_container);
  }
  PlotMLParser parser=new PlotMLParser(plot);
  parser.parse(base,in);
}","/** 
 * Configure the plot with data from the specified input stream, which is assumed to be in PlotML format.  If this is called before the plotter has been created (by calling place() or initialize()), then reading of the input stream is deferred until the plotter is created.
 * @param base The base relative to which references within the inputstream are found, or null if this is not known.
 * @param in InputStream
 * @exception Exception If the stream cannot be read or its syntaxis incorrect.
 */
public void configure(URL base,InputStream in) throws Exception {
  if (plot != null) {
    PlotMLParser parser=new PlotMLParser(plot);
    parser.parse(base,in);
    _configureBase=null;
    _configureIn=null;
  }
 else {
    _configureBase=base;
    _configureIn=in;
  }
}"
76109,"/** 
 * If the plot has not already been created, create it.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (plot == null) {
    place(_container);
  }
  if (_frame != null) {
    _frame.setVisible(true);
  }
  int width=plot.getNumDataSets();
  int offset=((IntToken)startingDataset.getToken()).intValue();
  for (int i=width - 1; i >= 0; i--) {
    plot.clear(i + offset);
  }
  plot.repaint();
}","/** 
 * If the plot has not already been created, create it. If configuration specified by a call to configure() has not yet been processed, process it.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (plot == null) {
    place(_container);
  }
  if (_frame != null) {
    _frame.setVisible(true);
  }
  int width=plot.getNumDataSets();
  int offset=((IntToken)startingDataset.getToken()).intValue();
  for (int i=width - 1; i >= 0; i--) {
    plot.clear(i + offset);
  }
  plot.repaint();
}"
76110,"/** 
 * Specify the container into which this plot should be placed. This method needs to be called before the first call to initialize() or configure(). Otherwise, the plot will be placed in its own frame. The plot is also placed in its own frame if this method is called with a null argument.  The size of the plot, unfortunately, cannot be effectively determined from the size of the container because the container may not yet be laid out (its size will be zero).  Thus, you will have to explicitly set the size of the plot by calling plot.setSize(). The background of the plot is set equal to that of the container (unless it is null).
 * @param container The container into which to place the plot.
 */
public void place(Container container){
  _container=container;
  if (_container == null) {
    plot=new Plot();
    _frame=new PlotFrame(getFullName(),plot);
    _frame.setVisible(true);
  }
 else {
    if (_container instanceof Plot) {
      plot=(Plot)_container;
    }
 else {
      if (plot == null) {
        plot=new Plot();
        plot.setButtons(true);
      }
      _container.add(plot);
      plot.setBackground(_container.getBackground());
    }
  }
}","/** 
 * Specify the container into which this plot should be placed. This method needs to be called before the first call to initialize() or configure(). Otherwise, the plot will be placed in its own frame. The plot is also placed in its own frame if this method is called with a null argument.  The size of the plot, unfortunately, cannot be effectively determined from the size of the container because the container may not yet be laid out (its size will be zero).  Thus, you will have to explicitly set the size of the plot by calling plot.setSize(). The background of the plot is set equal to that of the container (unless it is null). <p> If configure() has been called (prior to the plot getting created), then the configuration that it specified has been deferred. That configuration is performed at this time.
 * @param container The container into which to place the plot.
 */
public void place(Container container){
  _container=container;
  if (_container == null) {
    plot=new Plot();
    _frame=new PlotFrame(getFullName(),plot);
    _frame.setVisible(true);
  }
 else {
    if (_container instanceof Plot) {
      plot=(Plot)_container;
    }
 else {
      if (plot == null) {
        plot=new Plot();
        plot.setButtons(true);
      }
      _container.add(plot);
      plot.setBackground(_container.getBackground());
    }
  }
  if (_configureIn != null) {
    try {
      configure(_configureBase,_configureIn);
    }
 catch (    Exception ex) {
      getManager().notifyListenersOfException(ex);
    }
  }
}"
76111,"private double[][] _byteArrayToDoubleArray(byte[] byteArray,int bytesPerSample,int channels){
  int lengthInSamples=byteArray.length / (bytesPerSample * channels);
  double[][] doubleArray=new double[channels][lengthInSamples];
  double maxSampleReciprocal;
  if (bytesPerSample == 2) {
    maxSampleReciprocal=3.0517578125e-5;
  }
 else   if (bytesPerSample == 1) {
    maxSampleReciprocal=7.8125e-3;
  }
 else   if (bytesPerSample == 3) {
    maxSampleReciprocal=1.1920928955e07;
  }
 else   if (bytesPerSample == 4) {
    maxSampleReciprocal=4.655661287308e-10;
  }
 else {
    maxSampleReciprocal=0;
  }
  byte[] b=new byte[bytesPerSample];
  for (int currSamp=0; currSamp < lengthInSamples; currSamp++) {
    for (int currChannel=0; currChannel < channels; currChannel++) {
      for (int i=0; i < bytesPerSample; i+=1) {
        b[i]=byteArray[currSamp * bytesPerSample * channels + bytesPerSample * currChannel + i];
      }
      int result=(b[0] >> 7);
      for (int i=0; i < bytesPerSample; i+=1)       result=(result << 8) + (b[i] & 0xff);
      doubleArray[currChannel][currSamp]=((double)result * maxSampleReciprocal);
    }
  }
  return doubleArray;
}","private double[][] _byteArrayToDoubleArray(byte[] byteArray,int bytesPerSample,int channels){
  int lengthInSamples=byteArray.length / (bytesPerSample * channels);
  if ((channels != _doubleArray.length) || (lengthInSamples != _doubleArray[0].length)) {
    _doubleArray=new double[channels][lengthInSamples];
  }
  double maxSampleReciprocal;
  if (bytesPerSample == 2) {
    maxSampleReciprocal=3.0517578125e-5;
  }
 else   if (bytesPerSample == 1) {
    maxSampleReciprocal=7.8125e-3;
  }
 else   if (bytesPerSample == 3) {
    maxSampleReciprocal=1.1920928955e07;
  }
 else   if (bytesPerSample == 4) {
    maxSampleReciprocal=4.655661287308e-10;
  }
 else {
    maxSampleReciprocal=0;
  }
  if (bytesPerSample != _b.length) {
    _b=new byte[bytesPerSample];
  }
  for (int currSamp=0; currSamp < lengthInSamples; currSamp++) {
    for (int currChannel=0; currChannel < channels; currChannel++) {
      for (int i=0; i < bytesPerSample; i+=1) {
        _b[i]=byteArray[currSamp * bytesPerSample * channels + bytesPerSample * currChannel + i];
      }
      int result=(_b[0] >> 7);
      for (int i=0; i < bytesPerSample; i+=1)       result=(result << 8) + (_b[i] & 0xff);
      _doubleArray[currChannel][currSamp]=((double)result * maxSampleReciprocal);
    }
  }
  return _doubleArray;
}"
76112,"private int[][] _byteArrayToIntArray(byte[] byteArray,int bytesPerSample,int channels){
  int lengthInSamples=byteArray.length / (bytesPerSample * channels);
  int[][] intArray=new int[channels][lengthInSamples];
  byte[] b=new byte[bytesPerSample];
  for (int currSamp=0; currSamp < lengthInSamples; currSamp++) {
    for (int currChannel=0; currChannel < channels; currChannel++) {
      for (int i=0; i < bytesPerSample; i+=1) {
        b[i]=byteArray[currSamp * bytesPerSample * channels + bytesPerSample * currChannel + i];
      }
      int result=(b[0] >> 7);
      for (int i=0; i < bytesPerSample; i+=1)       result=(result << 8) + (b[i] & 0xff);
      intArray[currChannel][currSamp]=result;
    }
  }
  return intArray;
}","private int[][] _byteArrayToIntArray(byte[] byteArray,int bytesPerSample,int channels){
  int lengthInSamples=byteArray.length / (bytesPerSample * channels);
  if ((channels != _doubleArray.length) || (lengthInSamples != _doubleArray[0].length)) {
    _intArray=new int[channels][lengthInSamples];
  }
  if (bytesPerSample != _b.length) {
    _b=new byte[bytesPerSample];
  }
  for (int currSamp=0; currSamp < lengthInSamples; currSamp++) {
    for (int currChannel=0; currChannel < channels; currChannel++) {
      for (int i=0; i < bytesPerSample; i+=1) {
        _b[i]=byteArray[currSamp * bytesPerSample * channels + bytesPerSample * currChannel + i];
      }
      int result=(_b[0] >> 7);
      for (int i=0; i < bytesPerSample; i+=1)       result=(result << 8) + (_b[i] & 0xff);
      _intArray[currChannel][currSamp]=result;
    }
  }
  return _intArray;
}"
76113,"/** 
 * Set the vector length. The vector length of an acotor is defined as the number of tokens that are consumed and/or produced when the actor is fired. If a vectorizable actor is used in a domain that supports vectorized actors, then the director may invoke this method to set the vector length. This method is not guaranteed to be invoked, so a  vectorizable actor should use a default vector length of 1. An exception will occur if the requested vector length is less than 1.
 * @param vectorLength The requested vector length to use forthe actor.
 * @exception IllegalActionException If the requested vector lengthis invalid or cannot be set.
 */
public void setVectorLength(int vectorLength) throws IllegalActionException ;","/** 
 * Set the vector length. The vector length of an actor is defined as the number of tokens that are consumed and/or produced when the actor is fired. If a vectorizable actor is used in a domain that supports vectorized actors, then the director may invoke this method to set the vector length. This method is not guaranteed to be invoked, so a  vectorizable actor should use a default vector length of 1. An exception will occur if the requested vector length is less than 1.
 * @param vectorLength The requested vector length to use forthe actor.
 * @exception IllegalActionException If the requested vector lengthis invalid or cannot be set.
 */
public void setVectorLength(int vectorLength) throws IllegalActionException ;"
76114,"/** 
 * Return the value of this token as a string that can be parsed by the expression language to recover a token with the same value. The exact form of the number depends on its value, and may be either decimal or exponential.  In general, exponential is used for numbers whose magnitudes are very large or very small, except for zero which is always represented as 0.0.  The behavior is roughly the same as Double.toString(), except that we limit the precision to seven fractional digits.  If you really must have better precision,  then use <code>Double.toString(token.doubleValue())</code>.
 * @return A String representing the double value of this token.
 */
public String toString(){
  double mag=Math.abs(_value);
  if (mag == 0.0 || (mag < 1000000 && mag > .001))   return _regularFormat.format(_value);
 else   return _exponentialFormat.format(_value);
}","/** 
 * Return the value of this token as a string that can be parsed by the expression language to recover a token with the same value. The exact form of the number depends on its value, and may be either decimal or exponential.  In general, exponential is used for numbers whose magnitudes are very large or very small, except for zero which is always represented as 0.0.  The behavior is roughly the same as Double.toString(), except that we limit the precision to seven fractional digits.  If you really must have better precision,  then use <code>Double.toString(token.doubleValue())</code>.
 * @return A String representing the double value of this token.
 */
public String toString(){
  double mag=Math.abs(_value);
  if (mag == 0.0 || (mag < 1000000 && mag > .001)) {
    if (_regularFormat == null) {
      _regularFormat=new DecimalFormat(""String_Node_Str"");
    }
    return _regularFormat.format(_value);
  }
 else {
    if (_exponentialFormat == null) {
      _exponentialFormat=new DecimalFormat(""String_Node_Str"");
    }
    return _exponentialFormat.format(_value);
  }
}"
76115,"/** 
 * Create receivers and invoke the preinitialize() methods of all actors deeply contained by the container of this director.  Propagate the consumption and production rates of the current state out to the corresponding ports of the container of this director. Note that in HDF, distinct current refinements may have distinct type signatures (port rates). This method is invoked once per execution, before any iteration, and before the initialize() method.
 * @exception IllegalActionException If the preinitialize() method ofone of the associated actors throws it, or there is no controller.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  _buildLocalReceiverMaps();
  FSMActor ctrl=getController();
  State initialState=ctrl.getInitialState();
  TypedCompositeActor curRefinement=(TypedCompositeActor)initialState.getRefinement();
  if (curRefinement != null) {
    CompositeActor container=(CompositeActor)getContainer();
    if (_debugging)     _debug(""String_Node_Str"" + ((Nameable)container).getName());
    SDFDirector sdfDir=(SDFDirector)(container.getExecutiveDirector());
    Scheduler s=sdfDir.getScheduler();
    _updateInputTokenConsumptionRates(curRefinement);
    _updateOutputTokenProductionRates(curRefinement);
    if (_debugging)     _debug(""String_Node_Str"" + ""String_Node_Str"");
    s.setValid(false);
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * Create receivers and invoke the preinitialize() methods of all actors deeply contained by the container of this director.  Propagate the consumption and production rates of the current state out to the corresponding ports of the container of this director. Note that in HDF, distinct current refinements may have distinct type signatures (port rates). This method is invoked once per execution, before any iteration, and before the initialize() method.
 * @exception IllegalActionException If the preinitialize() method ofone of the associated actors throws it, or there is no controller.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  _buildLocalReceiverMaps();
  FSMActor ctrl=getController();
  State initialState=ctrl.getInitialState();
  TypedCompositeActor curRefinement=(TypedCompositeActor)initialState.getRefinement();
  if (curRefinement != null) {
    SDFDirector refinementDir=(SDFDirector)curRefinement.getDirector();
    Scheduler refinmentSched=refinementDir.getScheduler();
    refinmentSched.setValid(false);
    refinmentSched.schedule();
    if (_debugging)     _debug(""String_Node_Str"" + refinementDir.getFullName());
    CompositeActor container=(CompositeActor)getContainer();
    if (_debugging)     _debug(""String_Node_Str"" + ((Nameable)container).getName());
    SDFDirector sdfDir=(SDFDirector)(container.getExecutiveDirector());
    Scheduler s=sdfDir.getScheduler();
    _updateInputTokenConsumptionRates(curRefinement);
    _updateOutputTokenProductionRates(curRefinement);
    if (_debugging)     _debug(""String_Node_Str"" + ""String_Node_Str"");
    s.setValid(false);
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
76116,"public Object visitAllocateAnonymousClassNode(AllocateAnonymousClassNode node,LinkedList args){
}","public Object visitAllocateAnonymousClassNode(AllocateAnonymousClassNode node,LinkedList args){
  LinkedList retList=new LinkedList();
  TreeNode enclosingInstance=node.getEnclosingInstance();
  int enclosingID=enclosingInstance.classID();
  if ((enclosingID != ABSENTTREENODE_ID) && (enclosingID != THISNODE_ID)) {
    LinkedList enclosingStringList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_ENCLOSINGINSTANCE);
    retList.addLast(_parenExpr(enclosingInstance,enclosingStringList));
    retList.addLast(""String_Node_Str"");
  }
  retList.addLast(""String_Node_Str"");
  retList.addLast(node.childReturnValueAt(node.CHILD_INDEX_SUPERTYPE));
  retList.addLast(""String_Node_Str"");
  retList.addLast(_commaList((List)node.childReturnValueAt(node.CHILD_INDEX_SUPERARGS)));
  retList.addLast(""String_Node_Str"");
  retList.addLast(node.childReturnValueAt(node.CHILD_INDEX_MEMBERS));
  retList.addLast(""String_Node_Str"");
  return retList;
}"
76117,"/** 
 * Update the parameter if it has been changed. The new parameter will be used only after this method is called.
 * @exception IllegalActionException If the sampling rate set isless than or equal to 0.
 */
public void attributeChanged(Attribute att) throws IllegalActionException {
  double p=((DoubleToken)samplePeriod.getToken()).doubleValue();
  if (p <= 0) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _samplePeriod=p;
}","/** 
 * Update the parameter if it has been changed. The new parameter will be used only after this method is called.
 * @exception IllegalActionException If the sampling rate set isless than or equal to 0.
 */
public void attributeChanged(Attribute att) throws IllegalActionException {
  double p=((DoubleToken)samplePeriod.getToken()).doubleValue();
  if (p <= 0) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
 else {
    _samplePeriod=p;
  }
}"
76118,"/** 
 * Emit the current event, which has the token of the latest input token.
 */
public void emitCurrentEvents(){
  if (_hasCurrentEvent) {
    try {
      for (int i=0; i < Math.min(input.getWidth(),output.getWidth()); i++) {
        if (input.hasToken(i)) {
          output.send(i,input.get(i));
        }
      }
      _hasCurrentEvent=false;
    }
 catch (    IllegalActionException e) {
      throw new InternalErrorException(""String_Node_Str"");
    }
  }
}","/** 
 * Emit the current event, which has the token of the latest input token.
 */
public void emitCurrentEvents(){
  if (_hasCurrentEvent) {
    try {
      for (int i=0; i < Math.min(input.getWidth(),output.getWidth()); i++) {
        if (input.hasToken(i)) {
          output.send(i,input.get(i));
        }
      }
      _hasCurrentEvent=false;
      _nextSamplingTime+=_samplePeriod;
      getDirector().fireAt(this,_nextSamplingTime);
    }
 catch (    IllegalActionException e) {
      throw new InternalErrorException(""String_Node_Str"");
    }
  }
}"
76119,"/** 
 * Request the first sampling time as a director refire.
 * @exception IllegalActionException If thrown by the supper class.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (input.hasToken(0)) {
    input.get(0);
  }
  _hasCurrentEvent=false;
  CTDirector dir=(CTDirector)getDirector();
  _nextSamplingTime=dir.getCurrentTime() + _samplePeriod;
  dir.fireAt(this,_nextSamplingTime);
  if (_debugging)   _debug(getFullName() + ""String_Node_Str"" + _nextSamplingTime);
}","/** 
 * Request the first sampling time as a director refire.
 * @exception IllegalActionException If thrown by the supper class.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (input.hasToken(0)) {
    input.get(0);
  }
  _hasCurrentEvent=false;
  CTDirector dir=(CTDirector)getDirector();
  _nextSamplingTime=dir.getCurrentTime();
  dir.fireAt(this,dir.getCurrentTime());
  if (_debugging)   _debug(getFullName() + ""String_Node_Str"" + _nextSamplingTime);
}"
76120,"/** 
 * Return true if the mode controller wishes to be scheduled for another iteration. Postfire the refinement of the current state of the mode controller and take out event outputs that the refinement generates. Examine the outgoing transitions of the current state. Throw an exception if there is more than one transition enabled. If there is exactly one transition enabled then it is chosen and the choice actions contained by the transition are executed. Execute the commit actions contained by the last chosen transition of the mode controller and set its current state to the destination state of the transition.
 * @return True if the mode controller wishes to be scheduled foranother iteration.
 * @exception IllegalActionException If thrown by any action, orthere is no controller, or there is more than one transition enabled.
 */
public boolean postfire() throws IllegalActionException {
  FSMActor ctrl=getController();
  Actor ref=ctrl.currentState().getRefinement();
  if (ref != null) {
    ref.postfire();
    Iterator outports=ref.outputPortList().iterator();
    while (outports.hasNext()) {
      IOPort p=(IOPort)outports.next();
      transferOutputs(p);
    }
    ctrl._setInputsFromRefinement();
  }
  State st=ctrl.currentState();
  Transition tr=ctrl._chooseTransition(st.outgoingPort.linkedRelationList());
  if (_debugging && tr != null) {
    _debug(tr.getFullName(),""String_Node_Str"");
  }
  CompositeActor hs=(CompositeActor)getContainer();
  CTDirector dir=(CTDirector)hs.getExecutiveDirector();
  return super.postfire();
}","/** 
 * Return true if the mode controller wishes to be scheduled for another iteration. Postfire the refinement of the current state of the mode controller and take out event outputs that the refinement generates. Examine the outgoing transitions of the current state. Throw an exception if there is more than one transition enabled. If there is exactly one transition enabled then it is chosen and the choice actions contained by the transition are executed. Execute the commit actions contained by the last chosen transition of the mode controller and set its current state to the destination state of the transition.
 * @return True if the mode controller wishes to be scheduled foranother iteration.
 * @exception IllegalActionException If thrown by any action, orthere is no controller, or there is more than one transition enabled.
 */
public boolean postfire() throws IllegalActionException {
  FSMActor ctrl=getController();
  Actor ref=ctrl.currentState().getRefinement();
  if (ref != null) {
    ref.postfire();
    Iterator outports=ref.outputPortList().iterator();
    while (outports.hasNext()) {
      IOPort p=(IOPort)outports.next();
      transferOutputs(p);
    }
    ctrl._setInputsFromRefinement();
  }
  State st=ctrl.currentState();
  Transition tr=ctrl._chooseTransition(st.outgoingPort.linkedRelationList());
  if (_debugging && tr != null) {
    _debug(tr.getFullName(),""String_Node_Str"");
  }
  return super.postfire();
}"
76121,"/** 
 * Execute the directed (sub)system to the fire end time. If this is a top-level director, the fire end time if the current time at the beginning of the fire() method plus the the step size of one successful step. Otherwise, it executes until one of the following conditions is satisfied. 1) The fire end time computed in the prefire() method is reached. 2) An event is generated. It saves the state of the system at the current time of the executive director as the ""known good"" state, and runs ahead of that time. The ""known good"" state is used for roll back.
 * @exception IllegalActionException If thrown by the ODE solver,or the prefire(), fire(), or postfire() methods of an actor.
 */
public void fire() throws IllegalActionException {
  if (_isTopLevel()) {
    super.fire();
    return;
  }
  CompositeActor ca=(CompositeActor)getContainer();
  Director exe=ca.getExecutiveDirector();
  if (_isEventPhase()) {
    if (_debugging)     _debug(getFullName(),""String_Node_Str"");
    _eventPhaseExecution();
    _setEventPhase(false);
    if (_debugging)     _debug(getFullName(),""String_Node_Str"" + exe.getCurrentTime(),""String_Node_Str"");
    exe.fireAt(ca,exe.getCurrentTime());
    return;
  }
 else {
    while (true) {
      if (isBPIteration()) {
        _markStates();
      }
      _setIterationBeginTime(getCurrentTime());
      fireAt(null,getIterationEndTime());
      setCurrentStepSize(getSuggestedNextStepSize());
      _processBreakpoints();
      if (_debugging)       _debug(getName(),""String_Node_Str"" + getCurrentStepSize() + ""String_Node_Str""+ getCurrentTime()+ ""String_Node_Str""+ (getCurrentStepSize() + getCurrentTime()));
      _fireOneIteration();
      if (_isStoppedByEvent()) {
        if (_debugging) {
          _debug(getFullName() + ""String_Node_Str"",""String_Node_Str"" + getCurrentTime(),""String_Node_Str"" + getCurrentTime(),""String_Node_Str"");
        }
        exe.fireAt(ca,getCurrentTime());
        _setEventPhase(true);
        return;
      }
 else       if (Math.abs(getCurrentTime() - getIterationEndTime()) < getTimeResolution()) {
        if (_debugging) {
          _debug(getFullName() + ""String_Node_Str"",""String_Node_Str"" + getCurrentTime(),""String_Node_Str"" + getIterationEndTime(),""String_Node_Str"");
        }
        exe.fireAt(ca,getIterationEndTime());
        _setEventPhase(false);
        return;
      }
 else {
        throw new InternalErrorException(""String_Node_Str"" + getFullName());
      }
    }
  }
}","/** 
 * Execute the directed (sub)system to the fire end time. If this is a top-level director, the fire end time if the current time at the beginning of the fire() method plus the the step size of one successful step. Otherwise, it executes until one of the following conditions is satisfied. 1) The fire end time computed in the prefire() method is reached. 2) An event is generated. It saves the state of the system at the current time of the executive director as the ""known good"" state, and runs ahead of that time. The ""known good"" state is used for roll back.
 * @exception IllegalActionException If thrown by the ODE solver,or the prefire(), fire(), or postfire() methods of an actor.
 */
public void fire() throws IllegalActionException {
  if (_isTopLevel()) {
    super.fire();
    return;
  }
  CompositeActor ca=(CompositeActor)getContainer();
  Director exe=ca.getExecutiveDirector();
  if (_isEventPhase()) {
    if (_debugging)     _debug(getFullName(),""String_Node_Str"");
    _eventPhaseExecution();
    _setEventPhase(false);
    if (_debugging)     _debug(getFullName(),""String_Node_Str"" + exe.getCurrentTime(),""String_Node_Str"");
    exe.fireAt(ca,exe.getCurrentTime());
    return;
  }
 else {
    while (true) {
      if (isBPIteration()) {
        _markStates();
      }
      _setIterationBeginTime(getCurrentTime());
      fireAt(null,getIterationEndTime());
      setCurrentStepSize(getSuggestedNextStepSize());
      _processBreakpoints();
      if (_debugging)       _debug(getName(),""String_Node_Str"" + getCurrentStepSize() + ""String_Node_Str""+ getCurrentTime()+ ""String_Node_Str""+ (getCurrentStepSize() + getCurrentTime()));
      _fireOneIteration();
      if (_isStoppedByEvent()) {
        if (_debugging) {
          _debug(getFullName() + ""String_Node_Str"",""String_Node_Str"" + getCurrentTime(),""String_Node_Str"" + getCurrentTime(),""String_Node_Str"");
        }
        exe.fireAt(ca,getCurrentTime());
        _setEventPhase(true);
        return;
      }
 else       if (Math.abs(getCurrentTime() - getIterationEndTime()) < getTimeResolution()) {
        if (_debugging) {
          _debug(getFullName() + ""String_Node_Str"",""String_Node_Str"" + getCurrentTime(),""String_Node_Str"" + getIterationEndTime(),""String_Node_Str"");
        }
        exe.fireAt(ca,getIterationEndTime());
        _setEventPhase(false);
        return;
      }
    }
  }
}"
76122,"public void executionFinished(Manager manager){
  _controller.rerender();
}","public void executionFinished(Manager manager){
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      _controller.rerender();
    }
  }
);
}"
76123,"public Object visitMethodDeclNode(MethodDeclNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  NameContext subCtx=new NameContext(ctx);
  subCtx.encLoop=null;
  subCtx.breakTarget=null;
  Environ env=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  subCtx.environ=env;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setParams(TNLManip.traverseList(this,node,childArgs,node.getParams()));
  TreeNode body=node.getBody();
  if (body != AbsentTreeNode.instance) {
    node.setBody((BlockNode)body.accept(this,childArgs));
  }
  return node;
}","public Object visitMethodDeclNode(MethodDeclNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  NameContext subCtx=new NameContext(ctx);
  subCtx.encLoop=null;
  subCtx.breakTarget=null;
  Environ newEnv1=new Environ(ctx.environ);
  subCtx.environ=newEnv1;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setParams(TNLManip.traverseList(this,node,childArgs,node.getParams()));
  TreeNode body=node.getBody();
  subCtx.environ=new Environ(newEnv1);
  if (body != AbsentTreeNode.instance) {
    node.setBody((BlockNode)body.accept(this,childArgs));
  }
  return node;
}"
76124,"public Object visitLocalVarDeclNode(LocalVarDeclNode node,LinkedList args){
  node.setInitExpr((TreeNode)node.getInitExpr().accept(this,args));
  NameContext ctx=(NameContext)args.get(0);
  Environ env=ctx.environ;
  NameNode name=node.getName();
  String varName=name.getIdent();
  Decl other=env.lookup(varName,CG_FORMAL);
  if (other != null) {
    ApplicationUtility.error(""String_Node_Str"" + varName);
  }
 else {
    other=env.lookupProper(varName,CG_LOCALVAR);
    if (other != null) {
      ApplicationUtility.error(""String_Node_Str"" + varName);
    }
  }
  LocalVarDecl d=new LocalVarDecl(varName,node.getDefType(),node.getModifiers(),node);
  env.add(d);
  name.setProperty(DECL_KEY,d);
  return node;
}","public Object visitLocalVarDeclNode(LocalVarDeclNode node,LinkedList args){
  node.setInitExpr((TreeNode)node.getInitExpr().accept(this,args));
  NameContext ctx=(NameContext)args.get(0);
  Environ env=ctx.environ;
  NameNode name=node.getName();
  String varName=name.getIdent();
  Decl other=env.lookup(varName,CG_FORMAL);
  if (other != null) {
    ApplicationUtility.error(""String_Node_Str"" + varName);
  }
  other=env.lookupProper(varName,CG_LOCALVAR);
  if (other != null) {
    ApplicationUtility.error(""String_Node_Str"" + varName);
  }
  LocalVarDecl d=new LocalVarDecl(varName,node.getDefType(),node.getModifiers(),node);
  env.add(d);
  name.setProperty(DECL_KEY,d);
  return node;
}"
76125,"public Object visitObjectFieldAccessNode(ObjectFieldAccessNode node,LinkedList args){
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  subCtx.resolveAsObject=true;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setObject((ExprNode)(node.getObject().accept(this,childArgs)));
  return node;
}","public Object visitObjectFieldAccessNode(ObjectFieldAccessNode node,LinkedList args){
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  subCtx.resolveAsObject=true;
  node.setObject((ExprNode)(node.getObject().accept(this,TNLManip.cons(subCtx))));
  return node;
}"
76126,"public Object visitSwitchNode(SwitchNode node,LinkedList args){
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  node.setExpr((ExprNode)node.getExpr().accept(this,args));
  subCtx.breakTarget=node;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setSwitchBlocks(TNLManip.traverseList(this,node,childArgs,node.getSwitchBlocks()));
  return node;
}","public Object visitSwitchNode(SwitchNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  NameContext subCtx=new NameContext(ctx);
  node.setExpr((ExprNode)node.getExpr().accept(this,args));
  subCtx.breakTarget=node;
  subCtx.environ=new Environ(ctx.environ);
  node.setSwitchBlocks(TNLManip.traverseList(this,node,TNLManip.cons(subCtx),node.getSwitchBlocks()));
  return node;
}"
76127,"public Object visitLabeledStmtNode(LabeledStmtNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  Environ env=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  NameNode label=node.getName();
  String labelString=label.getIdent();
  Decl other=ctx.environ.lookup(labelString,CG_STMTLABEL);
  if (other != null) {
    ApplicationUtility.error(""String_Node_Str"" + labelString);
  }
  StmtLblDecl d=new StmtLblDecl(labelString,node);
  label.setProperty(DECL_KEY,d);
  env.add(d);
  NameContext subCtx=new NameContext(ctx);
  subCtx.environ=env;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setStmt((StatementNode)node.getStmt().accept(this,childArgs));
  return node;
}","public Object visitLabeledStmtNode(LabeledStmtNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  NameNode label=node.getName();
  String labelString=label.getIdent();
  Decl other=ctx.environ.lookup(labelString,CG_STMTLABEL);
  Environ newEnv=new Environ(ctx.environ);
  if (other != null) {
    ApplicationUtility.error(""String_Node_Str"" + labelString);
  }
  StmtLblDecl d=new StmtLblDecl(labelString,node);
  label.setProperty(DECL_KEY,d);
  newEnv.add(d);
  NameContext subCtx=new NameContext(ctx);
  subCtx.environ=newEnv;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setStmt((StatementNode)node.getStmt().accept(this,childArgs));
  return node;
}"
76128,"protected Object _visitUserTypeDeclNode(UserTypeDeclNode node,LinkedList args){
  NameContext ctx=new NameContext();
  ctx.environ=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  ClassDecl decl=(ClassDecl)JavaDecl.getDecl((NamedNode)node);
  ctx.currentClass=decl.getDefType();
  LinkedList childArgs=TNLManip.cons(ctx);
  node.setMembers(TNLManip.traverseList(this,node,childArgs,node.getMembers()));
  return node;
}","protected Object _visitUserTypeDeclNode(UserTypeDeclNode node,LinkedList args){
  NameContext ctx=new NameContext();
  ClassDecl decl=(ClassDecl)JavaDecl.getDecl((NamedNode)node);
  ctx.environ=decl.getEnviron();
  ctx.currentClass=decl.getDefType();
  LinkedList childArgs=TNLManip.cons(ctx);
  node.setMembers(TNLManip.traverseList(this,node,childArgs,node.getMembers()));
  return node;
}"
76129,"public Object visitTypeFieldAccessNode(TypeFieldAccessNode node,LinkedList args){
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  subCtx.resolveAsObject=true;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setFType((TypeNameNode)node.getFType().accept(this,childArgs));
  return node;
}","public Object visitTypeFieldAccessNode(TypeFieldAccessNode node,LinkedList args){
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  subCtx.resolveAsObject=true;
  LinkedList childArgs=TNLManip.cons(subCtx);
  return node;
}"
76130,"public Object visitCatchNode(CatchNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  NameContext subCtx=new NameContext(ctx);
  Environ env=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  subCtx.environ=env;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setParam((ParameterNode)node.getParam().accept(this,childArgs));
  node.setBlock((BlockNode)node.getBlock().accept(this,childArgs));
  return node;
}","public Object visitCatchNode(CatchNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  NameContext subCtx=new NameContext(ctx);
  subCtx.environ=new Environ(ctx.environ);
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setParam((ParameterNode)node.getParam().accept(this,childArgs));
  node.setBlock((BlockNode)node.getBlock().accept(this,childArgs));
  return node;
}"
76131,"public Object visitParameterNode(ParameterNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  Environ env=ctx.environ;
  NameNode name=node.getName();
  String varName=name.getIdent();
  Decl other=env.lookup(varName,CG_FORMAL | CG_LOCALVAR);
  if (other != null) {
    ApplicationUtility.error(""String_Node_Str"" + varName);
  }
  FormalParameterDecl d=new FormalParameterDecl(varName,node.getDefType(),node.getModifiers(),node);
  env.add(d);
  name.setProperty(DECL_KEY,d);
  return node;
}","public Object visitParameterNode(ParameterNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  Environ env=ctx.environ;
  NameNode name=node.getName();
  String varName=name.getIdent();
  Decl other=env.lookup(varName,CG_FORMAL | CG_LOCALVAR);
  if (other != null) {
    ApplicationUtility.error(""String_Node_Str"" + varName);
  }
  FormalParameterDecl d=new FormalParameterDecl(varName,node.getDefType(),node.getModifiers(),node);
  name.setProperty(DECL_KEY,d);
  env.add(d);
  return node;
}"
76132,"public Object visitBlockNode(BlockNode node,LinkedList args){
  NameContext subctx=new NameContext((NameContext)args.get(0));
  subctx.environ=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  LinkedList childArgs=TNLManip.cons(subctx);
  node.setStmts(TNLManip.traverseList(this,node,childArgs,node.getStmts()));
  return node;
}","public Object visitBlockNode(BlockNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  NameContext subctx=new NameContext(ctx);
  subctx.environ=new Environ(ctx.environ);
  node.setStmts(TNLManip.traverseList(this,node,TNLManip.cons(subctx),node.getStmts()));
  return node;
}"
76133,"public Object visitConstructorDeclNode(ConstructorDeclNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  NameContext subCtx=new NameContext(ctx);
  subCtx.encLoop=null;
  subCtx.breakTarget=null;
  Environ env=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  subCtx.environ=env;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setParams(TNLManip.traverseList(this,node,childArgs,node.getParams()));
  node.setConstructorCall((ConstructorCallNode)node.getConstructorCall().accept(this,childArgs));
  node.setBody((BlockNode)node.getBody().accept(this,childArgs));
  return node;
}","public Object visitConstructorDeclNode(ConstructorDeclNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  NameContext subCtx=new NameContext(ctx);
  subCtx.encLoop=null;
  subCtx.breakTarget=null;
  Environ newEnv1=new Environ(ctx.environ);
  subCtx.environ=newEnv1;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setParams(TNLManip.traverseList(this,node,childArgs,node.getParams()));
  subCtx.environ=new Environ(newEnv1);
  node.setConstructorCall((ConstructorCallNode)node.getConstructorCall().accept(this,childArgs));
  node.setBody((BlockNode)node.getBody().accept(this,childArgs));
  return node;
}"
76134,"public Object visitForNode(ForNode node,LinkedList args){
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  Environ env=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  subCtx.environ=env;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setInit(TNLManip.traverseList(this,node,childArgs,node.getInit()));
  subCtx.breakTarget=node;
  subCtx.encLoop=node;
  node.setTest((ExprNode)node.getTest().accept(this,childArgs));
  node.setUpdate(TNLManip.traverseList(this,node,childArgs,node.getUpdate()));
  node.setStmt((StatementNode)node.getStmt().accept(this,childArgs));
  return node;
}","public Object visitForNode(ForNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  NameContext subCtx=new NameContext(ctx);
  subCtx.environ=new Environ(ctx.environ);
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setInit(TNLManip.traverseList(this,node,childArgs,node.getInit()));
  subCtx.breakTarget=node;
  subCtx.encLoop=node;
  node.setTest((ExprNode)node.getTest().accept(this,childArgs));
  node.setUpdate(TNLManip.traverseList(this,node,childArgs,node.getUpdate()));
  node.setStmt((StatementNode)node.getStmt().accept(this,childArgs));
  return node;
}"
76135,"public Object visitMethodCallNode(MethodCallNode node,LinkedList args){
  node.setArgs(TNLManip.traverseList(this,node,args,node.getArgs()));
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  subCtx.resolveAsObject=false;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setMethod((ExprNode)node.getMethod().accept(this,childArgs));
  return node;
}","public Object visitMethodCallNode(MethodCallNode node,LinkedList args){
  node.setArgs(TNLManip.traverseList(this,node,args,node.getArgs()));
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  subCtx.resolveAsObject=false;
  node.setMethod((ExprNode)node.getMethod().accept(this,TNLManip.cons(subCtx)));
  return node;
}"
76136,"protected JumpStmtNode _resolveJump(JumpStmtNode node,TreeNode noLabel,Environ env){
  TreeNode label=node.getLabel();
  if (label == AbsentTreeNode.instance) {
    node.setProperty(JUMP_DESTINATION_KEY,noLabel);
  }
 else {
    NameNode labelName=(NameNode)label;
    String labelString=labelName.getIdent();
    StmtLblDecl dest=(StmtLblDecl)env.lookup(labelString,CG_STMTLABEL);
    if (dest == null) {
      ApplicationUtility.error(""String_Node_Str"" + labelString + ""String_Node_Str"");
    }
    labelName.setProperty(DECL_KEY,dest);
    LabeledStmtNode labeledStmtNode=(LabeledStmtNode)dest.getSource();
    node.setProperty(JUMP_DESTINATION_KEY,labeledStmtNode.getStmt());
  }
  return node;
}","protected static JumpStmtNode _resolveJump(JumpStmtNode node,TreeNode noLabel,Environ env){
  TreeNode label=node.getLabel();
  if (label == AbsentTreeNode.instance) {
    node.setProperty(JUMP_DESTINATION_KEY,noLabel);
  }
 else {
    NameNode labelName=(NameNode)label;
    String labelString=labelName.getIdent();
    StmtLblDecl dest=(StmtLblDecl)env.lookup(labelString,CG_STMTLABEL);
    if (dest == null) {
      ApplicationUtility.error(""String_Node_Str"" + labelString + ""String_Node_Str"");
    }
    labelName.setProperty(DECL_KEY,dest);
    LabeledStmtNode labeledStmtNode=(LabeledStmtNode)dest.getSource();
    node.setProperty(JUMP_DESTINATION_KEY,labeledStmtNode.getStmt());
  }
  return node;
}"
76137,"public Object visitLoopNode(LoopNode node,LinkedList args){
  node.setTest((ExprNode)node.getTest().accept(this,args));
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  subCtx.breakTarget=node;
  subCtx.encLoop=node;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setForeStmt((TreeNode)node.getForeStmt().accept(this,childArgs));
  node.setAftStmt((TreeNode)node.getAftStmt().accept(this,childArgs));
  return node;
}","public Object visitLoopNode(LoopNode node,LinkedList args){
  node.setTest((ExprNode)node.getTest().accept(this,args));
  NameContext ctx=(NameContext)args.get(0);
  NameContext subCtx=new NameContext(ctx);
  subCtx.breakTarget=node;
  subCtx.encLoop=node;
  subCtx.environ=new Environ(ctx.environ);
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setForeStmt((TreeNode)node.getForeStmt().accept(this,childArgs));
  node.setAftStmt((TreeNode)node.getAftStmt().accept(this,childArgs));
  return node;
}"
76138,"/** 
 * Visit the types defined in this file. 
 */
public Object visitCompileUnitNode(CompileUnitNode node,LinkedList args){
  _currentPackage=(PackageDecl)node.getDefinedProperty(PACKAGE_KEY);
  LinkedList childArgs=new LinkedList();
  childArgs.add(node.getDefinedProperty(ENVIRON_KEY));
  TNLManip.traverseList(this,node,childArgs,node.getDefTypes());
  return null;
}","/** 
 * Visit the types defined in this file. 
 */
public Object visitCompileUnitNode(CompileUnitNode node,LinkedList args){
  _currentPackage=(PackageDecl)node.getDefinedProperty(PACKAGE_KEY);
  TNLManip.traverseList(this,node,TNLManip.cons(node.getDefinedProperty(ENVIRON_KEY)),node.getDefTypes());
  return null;
}"
76139,"public Object visitAllocateNode(AllocateNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  String enclosingInstance=(String)node.childReturnValueAt(node.CHILD_INDEX_ENCLOSINGINSTANCE);
  if (!enclosingInstance.equals(""String_Node_Str"")) {
    sb.append(enclosingInstance + '.');
  }
  List argsList=(List)node.childReturnValueAt(node.CHILD_INDEX_ARGS);
  sb.append(""String_Node_Str"" + (String)node.childReturnValueAt(node.CHILD_INDEX_DTYPE) + '('+ _commaList(argsList)+ ')');
  return sb.toString();
}","public Object visitAllocateNode(AllocateNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  String enclosingInstance=(String)node.childReturnValueAt(node.CHILD_INDEX_ENCLOSINGINSTANCE);
  if (!(enclosingInstance.equals(""String_Node_Str"") || enclosingInstance.equals(""String_Node_Str""))) {
    sb.append(enclosingInstance + '.');
  }
  List argsList=(List)node.childReturnValueAt(node.CHILD_INDEX_ARGS);
  sb.append(""String_Node_Str"" + (String)node.childReturnValueAt(node.CHILD_INDEX_DTYPE) + '('+ _commaList(argsList)+ ')');
  return sb.toString();
}"
76140,"public static final void checkClassModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | PROTECTED_MOD | PRIVATE_MOD| FINAL_MOD| ABSTRACT_MOD| STRICTFP_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"" + toString(modifiers));
  }
}","public static final void checkClassModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | PROTECTED_MOD | PRIVATE_MOD| FINAL_MOD| ABSTRACT_MOD| STATIC_MOD| STRICTFP_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"" + toString(modifiers));
  }
}"
76141,"public static final void checkInterfaceModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | PROTECTED_MOD | PRIVATE_MOD| FINAL_MOD| ABSTRACT_MOD| STRICTFP_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"" + toString(modifiers));
  }
}","public static final void checkInterfaceModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | PROTECTED_MOD | PRIVATE_MOD| FINAL_MOD| ABSTRACT_MOD| STATIC_MOD| STRICTFP_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"" + toString(modifiers));
  }
}"
76142,"public Object visitImportNode(ImportNode node,LinkedList args){
  NameNode name=node.getName();
  StaticResolution.resolveAName(name,(Environ)StaticResolution.SYSTEM_PACKAGE.getEnviron(),null,null,JavaDecl.CG_USERTYPE);
  JavaDecl old=(JavaDecl)_fileEnv.lookupProper(name.getIdent());
  JavaDecl current=(JavaDecl)name.getProperty(DECL_KEY);
  if ((old != null) && (old != current)) {
    if (old != current) {
      throw new RuntimeException(""String_Node_Str"" + old.getName());
    }
  }
  _fileEnv.parent().parent().add((ClassDecl)name.getDefinedProperty(DECL_KEY));
  return null;
}","public Object visitImportNode(ImportNode node,LinkedList args){
  NameNode name=node.getName();
  StaticResolution.resolveAName(name,(Environ)StaticResolution.SYSTEM_PACKAGE.getEnviron(),null,null,CG_USERTYPE);
  JavaDecl old=(JavaDecl)_fileEnv.lookupProper(name.getIdent());
  JavaDecl current=(JavaDecl)name.getProperty(DECL_KEY);
  if ((old != null) && (old != current)) {
    if (old != current) {
      throw new RuntimeException(""String_Node_Str"" + old.getName());
    }
  }
  _importEnv.add((ClassDecl)name.getDefinedProperty(DECL_KEY));
  return null;
}"
76143,"protected final void _importOnDemand(String qualName){
  NameNode name=(NameNode)StaticResolution.makeNameNode(qualName);
  StaticResolution.resolveAName(name,StaticResolution.SYSTEM_PACKAGE.getEnviron(),null,null,JavaDecl.CG_PACKAGE);
  _importOnDemand((PackageDecl)name.getDefinedProperty(DECL_KEY));
}","protected final void _importOnDemand(String qualName){
  NameNode name=(NameNode)StaticResolution.makeNameNode(qualName);
  StaticResolution.resolveAName(name,StaticResolution.SYSTEM_PACKAGE.getEnviron(),null,null,CG_PACKAGE);
  _importOnDemand((PackageDecl)name.getDefinedProperty(DECL_KEY));
}"
76144,"public Object visitImportOnDemandNode(ImportOnDemandNode node,LinkedList args){
  NameNode name=node.getName();
  StaticResolution.resolveAName(name,StaticResolution.SYSTEM_PACKAGE.getEnviron(),null,null,JavaDecl.CG_PACKAGE);
  PackageDecl decl=(PackageDecl)name.getDefinedProperty(DECL_KEY);
  _importOnDemand(decl);
  return null;
}","public Object visitImportOnDemandNode(ImportOnDemandNode node,LinkedList args){
  NameNode name=node.getName();
  StaticResolution.resolveAName(name,StaticResolution.SYSTEM_PACKAGE.getEnviron(),null,null,CG_PACKAGE);
  PackageDecl decl=(PackageDecl)name.getDefinedProperty(DECL_KEY);
  _importOnDemand(decl);
  return null;
}"
76145,"public Object visitCompileUnitNode(CompileUnitNode node,LinkedList args){
  _compileUnit=node;
  _fileEnv=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  if (!node.hasProperty(IMPORTED_PACKAGES_KEY)) {
    _importedPackages=new LinkedList();
    node.setProperty(IMPORTED_PACKAGES_KEY,_importedPackages);
  }
 else {
    _importedPackages=(Collection)node.getDefinedProperty(IMPORTED_PACKAGES_KEY);
  }
  _importOnDemand(""String_Node_Str"");
  TNLManip.traverseList(this,node,null,node.getImports());
  return null;
}","public Object visitCompileUnitNode(CompileUnitNode node,LinkedList args){
  _compileUnit=node;
  _fileEnv=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  _importEnv=_fileEnv.parent().parent();
  if (!node.hasProperty(IMPORTED_PACKAGES_KEY)) {
    _importedPackages=new LinkedList();
    node.setProperty(IMPORTED_PACKAGES_KEY,_importedPackages);
  }
 else {
    _importedPackages=(Collection)node.getDefinedProperty(IMPORTED_PACKAGES_KEY);
  }
  _importOnDemand(""String_Node_Str"");
  TNLManip.traverseList(this,node,null,node.getImports());
  return null;
}"
76146,"int yyparse(){
  int yyn;
  int yym;
  int yystate;
  String yys;
  boolean doaction;
  init_stacks();
  yynerrs=0;
  yyerrflag=0;
  yychar=-1;
  yystate=0;
  state_push(yystate);
  while (true) {
    doaction=true;
    if (yydebug)     debug(""String_Node_Str"");
    for (yyn=yydefred[yystate]; yyn == 0; yyn=yydefred[yystate]) {
      if (yydebug)       debug(""String_Node_Str"" + yyn + ""String_Node_Str""+ yystate+ ""String_Node_Str""+ yychar);
      if (yychar < 0) {
        yychar=yylex();
        if (yychar < 0) {
          yychar=0;
          if (yydebug)           yylexdebug(yystate,yychar);
        }
      }
      yyn=yysindex[yystate];
      if ((yyn != 0) && (yyn+=yychar) >= 0 && yyn <= YYTABLESIZE && yycheck[yyn] == yychar) {
        if (yydebug)         debug(""String_Node_Str"" + yystate + ""String_Node_Str""+ yytable[yyn]+ ""String_Node_Str"");
        yystate=yytable[yyn];
        state_push(yystate);
        val_push(yylval);
        yychar=-1;
        if (yyerrflag > 0)         --yyerrflag;
        doaction=false;
        break;
      }
      yyn=yyrindex[yystate];
      if ((yyn != 0) && (yyn+=yychar) >= 0 && yyn <= YYTABLESIZE && yycheck[yyn] == yychar) {
        if (yydebug)         debug(""String_Node_Str"");
        yyn=yytable[yyn];
        doaction=true;
        break;
      }
 else {
        if (yyerrflag == 0) {
          yyerror(""String_Node_Str"");
          yynerrs++;
        }
        if (yyerrflag < 3) {
          yyerrflag=3;
          while (true) {
            if (stateptr < 0) {
              yyerror(""String_Node_Str"");
              return 1;
            }
            yyn=yysindex[state_peek(0)];
            if ((yyn != 0) && (yyn+=YYERRCODE) >= 0 && yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE) {
              if (yydebug)               debug(""String_Node_Str"" + state_peek(0) + ""String_Node_Str""+ yytable[yyn]+ ""String_Node_Str"");
              yystate=yytable[yyn];
              state_push(yystate);
              val_push(yylval);
              doaction=false;
              break;
            }
 else {
              if (yydebug)               debug(""String_Node_Str"" + state_peek(0) + ""String_Node_Str"");
              if (stateptr < 0) {
                yyerror(""String_Node_Str"");
                return 1;
              }
              state_pop();
              val_pop();
            }
          }
        }
 else {
          if (yychar == 0)           return 1;
          if (yydebug) {
            yys=null;
            if (yychar <= YYMAXTOKEN)             yys=yyname[yychar];
            if (yys == null)             yys=""String_Node_Str"";
            debug(""String_Node_Str"" + yystate + ""String_Node_Str""+ yychar+ ""String_Node_Str""+ yys+ ""String_Node_Str"");
          }
          yychar=-1;
        }
      }
    }
    if (!doaction)     continue;
    yym=yylen[yyn];
    if (yydebug)     debug(""String_Node_Str"" + yystate + ""String_Node_Str""+ yym+ ""String_Node_Str""+ yyn+ ""String_Node_Str""+ yyrule[yyn]+ ""String_Node_Str"");
    if (yym > 0) {
      try {
        yyval=(JavaParserval)val_peek(yym - 1).clone();
      }
 catch (      CloneNotSupportedException e) {
        yyerror(""String_Node_Str"");
      }
    }
 else {
      yyval=new JavaParserval();
    }
switch (yyn) {
case 1:
{
        _theAST=(CompileUnitNode)val_peek(0).obj;
      }
    break;
case 2:
{
    yyval.obj=new IntLitNode(val_peek(0).sval);
  }
break;
case 3:
{
yyval.obj=new LongLitNode(val_peek(0).sval);
}
break;
case 4:
{
yyval.obj=new FloatLitNode(val_peek(0).sval);
}
break;
case 5:
{
yyval.obj=new DoubleLitNode(val_peek(0).sval);
}
break;
case 6:
{
yyval.obj=new BoolLitNode(""String_Node_Str"");
}
break;
case 7:
{
yyval.obj=new BoolLitNode(""String_Node_Str"");
}
break;
case 8:
{
yyval.obj=new CharLitNode(val_peek(0).sval);
}
break;
case 9:
{
yyval.obj=new StringLitNode(val_peek(0).sval);
}
break;
case 14:
{
yyval.obj=BoolTypeNode.instance;
}
break;
case 15:
{
yyval.obj=CharTypeNode.instance;
}
break;
case 16:
{
yyval.obj=ByteTypeNode.instance;
}
break;
case 17:
{
yyval.obj=ShortTypeNode.instance;
}
break;
case 18:
{
yyval.obj=IntTypeNode.instance;
}
break;
case 19:
{
yyval.obj=FloatTypeNode.instance;
}
break;
case 20:
{
yyval.obj=LongTypeNode.instance;
}
break;
case 21:
{
yyval.obj=DoubleTypeNode.instance;
}
break;
case 22:
{
yyval.obj=new TypeNameNode((NameNode)val_peek(0).obj);
}
break;
case 23:
{
yyval.obj=new ArrayTypeNode((TypeNode)val_peek(1).obj);
}
break;
case 24:
{
yyval.obj=new CompileUnitNode((TreeNode)val_peek(2).obj,(List)val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 25:
{
yyval.obj=val_peek(1).obj;
}
break;
case 26:
{
yyval.obj=AbsentTreeNode.instance;
}
break;
case 27:
{
yyval.obj=new LinkedList();
}
break;
case 28:
{
yyval.obj=cons(val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 29:
{
yyval.obj=new LinkedList();
}
break;
case 30:
{
yyval.obj=cons(val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 31:
{
yyval.obj=val_peek(0).obj;
}
break;
case 36:
{
yyval.obj=new ImportNode((NameNode)val_peek(1).obj);
}
break;
case 37:
{
yyval.obj=new ImportOnDemandNode((NameNode)val_peek(3).obj);
}
break;
case 38:
{
NameNode name=(NameNode)val_peek(3).obj;
List body=(List)val_peek(0).obj;
Iterator bodyItr=body.iterator();
boolean constructorFound=false;
while (!constructorFound && bodyItr.hasNext()) {
Object member=bodyItr.next();
if (member instanceof ConstructorDeclNode) {
constructorFound=true;
}
}
if (!constructorFound) {
body.add(new ConstructorDeclNode(Modifier.PUBLIC_MOD,new NameNode(name.getQualifier(),name.getIdent()),new LinkedList(),new LinkedList(),new BlockNode(new LinkedList()),new SuperConstructorCallNode(new LinkedList())));
}
yyval.obj=new ClassDeclNode(val_peek(5).ival,name,(List)val_peek(1).obj,(List)body,(TypeNameNode)val_peek(2).obj);
}
break;
case 39:
{
yyval.obj=val_peek(0).obj;
}
break;
case 40:
{
yyval.obj=new TypeNameNode(new NameNode(AbsentTreeNode.instance,""String_Node_Str""));
}
break;
case 41:
{
yyval.obj=val_peek(0).obj;
}
break;
case 42:
{
yyval.obj=new LinkedList();
}
break;
case 43:
{
yyval.obj=val_peek(1).obj;
}
break;
case 44:
{
}
break;
case 45:
{
yyval.obj=new LinkedList();
}
break;
case 47:
{
yyval.obj=appendLists((List)val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 49:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 50:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 51:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 52:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 53:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 54:
{
yyval.obj=cons(val_peek(1).obj);
}
break;
case 55:
{
Modifier.checkFieldModifiers(val_peek(3).ival);
List result=new LinkedList();
List varDecls=(List)val_peek(1).obj;
Iterator itr=varDecls.iterator();
while (itr.hasNext()) {
DeclaratorNode decl=(DeclaratorNode)itr.next();
result=cons(new FieldDeclNode(val_peek(3).ival,makeArrayType((TypeNode)val_peek(2).obj,decl.getDims()),decl.getName(),decl.getInitExpr()),result);
}
yyval.obj=result;
}
break;
case 56:
{
}
break;
case 57:
{
yyval.ival=Modifier.NO_MOD;
}
break;
case 58:
{
yyval.ival=val_peek(0).ival;
}
break;
case 59:
{
yyval.ival=(val_peek(1).ival | val_peek(0).ival);
if ((val_peek(1).ival & val_peek(0).ival) != 0) {
yyerror(""String_Node_Str"");
}
}
break;
case 60:
{
yyval.ival=Modifier.PUBLIC_MOD;
}
break;
case 61:
{
yyval.ival=Modifier.PROTECTED_MOD;
}
break;
case 62:
{
yyval.ival=Modifier.PRIVATE_MOD;
}
break;
case 63:
{
yyval.ival=Modifier.STATIC_MOD;
}
break;
case 64:
{
yyval.ival=Modifier.FINAL_MOD;
}
break;
case 65:
{
yyval.ival=Modifier.ABSTRACT_MOD;
}
break;
case 66:
{
yyval.ival=Modifier.NATIVE_MOD;
}
break;
case 67:
{
yyval.ival=Modifier.SYNCHRONIZED_MOD;
}
break;
case 68:
{
yyval.ival=Modifier.TRANSIENT_MOD;
}
break;
case 69:
{
yyval.ival=Modifier.VOLATILE_MOD;
}
break;
case 70:
{
yyval.ival=Modifier.STRICTFP_MOD;
}
break;
case 71:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 72:
{
yyval.obj=cons(val_peek(0).obj,(List)val_peek(2).obj);
}
break;
case 73:
{
yyval.obj=new DeclaratorNode(val_peek(0).ival,(NameNode)val_peek(1).obj,AbsentTreeNode.instance);
}
break;
case 74:
{
yyval.obj=new DeclaratorNode(val_peek(2).ival,(NameNode)val_peek(3).obj,(ExprNode)val_peek(0).obj);
}
break;
case 77:
{
Modifier.checkMethodModifiers(val_peek(8).ival);
yyval.obj=new MethodDeclNode(val_peek(8).ival,(NameNode)val_peek(6).obj,(List)val_peek(4).obj,(List)val_peek(1).obj,(TreeNode)val_peek(0).obj,makeArrayType((TypeNode)val_peek(7).obj,val_peek(2).ival));
}
break;
case 78:
{
Modifier.checkMethodModifiers(val_peek(8).ival);
yyval.obj=new MethodDeclNode(val_peek(8).ival,(NameNode)val_peek(6).obj,(List)val_peek(4).obj,(List)val_peek(1).obj,(TreeNode)val_peek(0).obj,makeArrayType((TypeNode)val_peek(7).obj,val_peek(2).ival));
}
break;
case 79:
{
yyval.obj=VoidTypeNode.instance;
}
break;
case 80:
{
}
break;
case 81:
{
yyval.obj=new LinkedList();
}
break;
case 82:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 83:
{
yyval.obj=cons(val_peek(2).obj,(List)val_peek(0).obj);
}
break;
case 84:
{
Modifier.checkParameterModifiers(val_peek(3).ival);
yyval.obj=new ParameterNode(val_peek(3).ival,makeArrayType((TypeNode)val_peek(2).obj,val_peek(0).ival),(NameNode)val_peek(1).obj);
}
break;
case 85:
{
}
break;
case 86:
{
yyval.obj=new LinkedList();
}
break;
case 87:
{
yyval.obj=val_peek(0).obj;
}
break;
case 88:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 89:
{
yyval.obj=cons(val_peek(2).obj,(List)val_peek(0).obj);
}
break;
case 91:
{
yyval.obj=AbsentTreeNode.instance;
}
break;
case 92:
{
Modifier.checkConstructorModifiers(val_peek(9).ival);
yyval.obj=new ConstructorDeclNode(val_peek(9).ival,new NameNode(AbsentTreeNode.instance,val_peek(8).sval),(List)val_peek(6).obj,(List)val_peek(4).obj,new BlockNode((List)val_peek(1).obj),(ConstructorCallNode)val_peek(2).obj);
}
break;
case 93:
{
Modifier.checkConstructorModifiers(val_peek(8).ival);
yyval.obj=new ConstructorDeclNode(val_peek(8).ival,new NameNode(AbsentTreeNode.instance,val_peek(7).sval),(List)val_peek(5).obj,(List)val_peek(3).obj,new BlockNode((List)val_peek(1).obj),new SuperConstructorCallNode(new LinkedList()));
}
break;
case 94:
{
yyval.obj=new ThisConstructorCallNode((List)val_peek(2).obj);
}
break;
case 95:
{
yyval.obj=new SuperConstructorCallNode((List)val_peek(2).obj);
}
break;
case 96:
{
yyval.obj=new StaticInitNode((BlockNode)val_peek(0).obj);
}
break;
case 97:
{
yyval.obj=new InstanceInitNode((BlockNode)val_peek(0).obj);
}
break;
case 98:
{
Modifier.checkInterfaceModifiers(val_peek(4).ival);
yyval.obj=new InterfaceDeclNode(val_peek(4).ival,(NameNode)val_peek(2).obj,(List)val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 99:
{
}
break;
case 100:
{
yyval.obj=new LinkedList();
}
break;
case 101:
{
yyval.obj=val_peek(0).obj;
}
break;
case 102:
{
yyval.obj=val_peek(1).obj;
}
break;
case 103:
{
yyval.obj=new LinkedList();
}
break;
case 104:
{
yyval.obj=appendLists((List)val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 106:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 107:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 108:
{
yyval.obj=cons(val_peek(1).obj);
}
break;
case 109:
{
int modifiers=val_peek(3).ival;
modifiers|=(Modifier.STATIC_MOD | Modifier.FINAL_MOD);
Modifier.checkConstantFieldModifiers(modifiers);
List varDecls=(List)val_peek(1).obj;
Iterator itr=varDecls.iterator();
List result=new LinkedList();
while (itr.hasNext()) {
DeclaratorNode decl=(DeclaratorNode)itr.next();
result=cons(new FieldDeclNode(modifiers,makeArrayType((TypeNode)val_peek(2).obj,decl.getDims()),decl.getName(),decl.getInitExpr()),result);
}
yyval.obj=result;
}
break;
case 110:
{
Modifier.checkMethodSignatureModifiers(val_peek(8).ival);
yyval.obj=new MethodDeclNode(val_peek(8).ival,(NameNode)val_peek(6).obj,(List)val_peek(4).obj,(List)val_peek(1).obj,AbsentTreeNode.instance,makeArrayType((TypeNode)val_peek(7).obj,val_peek(2).ival));
}
break;
case 111:
{
Modifier.checkMethodSignatureModifiers(val_peek(8).ival);
yyval.obj=new MethodDeclNode(val_peek(8).ival,(NameNode)val_peek(6).obj,(List)val_peek(4).obj,(List)val_peek(1).obj,AbsentTreeNode.instance,makeArrayType((TypeNode)val_peek(7).obj,val_peek(2).ival));
}
break;
case 112:
{
yyval.obj=new ArrayInitNode((List)val_peek(1).obj);
}
break;
case 113:
{
yyval.obj=new ArrayInitNode((List)val_peek(2).obj);
}
break;
case 114:
{
yyval.obj=new ArrayInitNode(new LinkedList());
}
break;
case 115:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 116:
{
yyval.obj=append((List)val_peek(2).obj,val_peek(0).obj);
}
break;
case 119:
{
yyval.obj=new BlockNode((List)val_peek(1).obj);
}
break;
case 120:
{
}
break;
case 121:
{
yyval.obj=new LinkedList();
}
break;
case 122:
{
yyval.obj=val_peek(0).obj;
}
break;
case 123:
{
yyval.obj=appendLists((List)val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 124:
{
yyval.obj=val_peek(0).obj;
}
break;
case 125:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 126:
{
yyval.obj=cons(new UserTypeDeclStmtNode((UserTypeDeclNode)val_peek(0).obj));
}
break;
case 127:
{
Modifier.checkLocalVariableModifiers(val_peek(3).ival);
List varDecls=(List)val_peek(1).obj;
List result=new LinkedList();
Iterator itr=varDecls.iterator();
while (itr.hasNext()) {
DeclaratorNode decl=(DeclaratorNode)itr.next();
result=cons(new LocalVarDeclNode(val_peek(3).ival,makeArrayType((TypeNode)val_peek(2).obj,decl.getDims()),decl.getName(),decl.getInitExpr()),result);
}
yyval.obj=result;
}
break;
case 128:
{
List varDecls=(List)val_peek(1).obj;
List result=new LinkedList();
Iterator itr=varDecls.iterator();
while (itr.hasNext()) {
DeclaratorNode decl=(DeclaratorNode)itr.next();
result=cons(new LocalVarDeclNode(Modifier.NO_MOD,makeArrayType((TypeNode)val_peek(2).obj,decl.getDims()),decl.getName(),decl.getInitExpr()),result);
}
yyval.obj=result;
}
break;
case 131:
{
yyval.obj=new ExprStmtNode((ExprNode)val_peek(1).obj);
}
break;
case 137:
{
yyval.obj=new EmptyStmtNode();
}
break;
case 138:
{
yyval.obj=new LabeledStmtNode((NameNode)val_peek(2).obj,(StatementNode)val_peek(0).obj);
}
break;
case 139:
{
yyval.obj=val_peek(0).obj;
}
break;
case 140:
{
yyval.obj=val_peek(0).obj;
}
break;
case 141:
{
yyval.obj=val_peek(0).obj;
}
break;
case 142:
{
yyval.obj=val_peek(0).obj;
}
break;
case 143:
{
yyval.obj=val_peek(0).obj;
}
break;
case 144:
{
yyval.obj=val_peek(0).obj;
}
break;
case 145:
{
yyval.obj=val_peek(0).obj;
}
break;
case 146:
{
yyval.obj=new IfStmtNode((ExprNode)val_peek(2).obj,(StatementNode)val_peek(0).obj,AbsentTreeNode.instance);
}
break;
case 147:
{
yyval.obj=new IfStmtNode((ExprNode)val_peek(4).obj,(StatementNode)val_peek(2).obj,(TreeNode)val_peek(0).obj);
}
break;
case 148:
{
yyval.obj=new SwitchNode((ExprNode)val_peek(2).obj,(List)val_peek(0).obj);
}
break;
case 149:
{
yyval.obj=val_peek(1).obj;
}
break;
case 150:
{
yyval.obj=new LinkedList();
}
break;
case 151:
{
yyval.obj=cons(new SwitchBranchNode((List)val_peek(2).obj,(List)val_peek(1).obj),(List)val_peek(0).obj);
}
break;
case 152:
{
yyval.obj=cons(new SwitchBranchNode((List)val_peek(0).obj,new LinkedList()));
}
break;
case 153:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 154:
{
yyval.obj=cons(val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 155:
{
yyval.obj=new CaseNode((TreeNode)val_peek(1).obj);
}
break;
case 156:
{
yyval.obj=new CaseNode(AbsentTreeNode.instance);
}
break;
case 157:
{
yyval.obj=new LoopNode(new EmptyStmtNode(),(ExprNode)val_peek(2).obj,(TreeNode)val_peek(0).obj);
}
break;
case 158:
{
yyval.obj=new LoopNode((TreeNode)val_peek(5).obj,(ExprNode)val_peek(2).obj,new EmptyStmtNode());
}
break;
case 159:
{
yyval.obj=new ForNode((List)val_peek(5).obj,(ExprNode)val_peek(4).obj,(List)val_peek(2).obj,(StatementNode)val_peek(0).obj);
}
break;
case 160:
{
yyval.obj=new ForNode((List)val_peek(4).obj,new BoolLitNode(""String_Node_Str""),(List)val_peek(2).obj,(StatementNode)val_peek(0).obj);
}
break;
case 161:
{
yyval.obj=val_peek(1).obj;
}
break;
case 162:
{
yyval.obj=val_peek(0).obj;
}
break;
case 163:
{
}
break;
case 164:
{
yyval.obj=new LinkedList();
}
break;
case 165:
{
}
break;
case 166:
{
yyval.obj=new LinkedList();
}
break;
case 167:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 168:
{
yyval.obj=cons(val_peek(2).obj,(List)val_peek(0).obj);
}
break;
case 169:
{
yyval.obj=new BreakNode((TreeNode)val_peek(1).obj);
}
break;
case 170:
{
yyval.obj=new ContinueNode((TreeNode)val_peek(1).obj);
}
break;
case 171:
{
yyval.obj=new ReturnNode((TreeNode)val_peek(1).obj);
}
break;
case 172:
{
yyval.obj=new ThrowNode((ExprNode)val_peek(1).obj);
}
break;
case 173:
{
}
break;
case 174:
{
yyval.obj=AbsentTreeNode.instance;
}
break;
case 175:
{
yyval.obj=new SynchronizedNode((ExprNode)val_peek(2).obj,(TreeNode)val_peek(0).obj);
}
break;
case 176:
{
yyval.obj=new TryNode((BlockNode)val_peek(1).obj,new LinkedList(),(TreeNode)val_peek(0).obj);
}
break;
case 177:
{
yyval.obj=new TryNode((BlockNode)val_peek(1).obj,(List)val_peek(0).obj,AbsentTreeNode.instance);
}
break;
case 178:
{
yyval.obj=new TryNode((BlockNode)val_peek(2).obj,(List)val_peek(1).obj,(TreeNode)val_peek(0).obj);
}
break;
case 179:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 180:
{
yyval.obj=cons(val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 181:
{
yyval.obj=new CatchNode((ParameterNode)val_peek(2).obj,(BlockNode)val_peek(0).obj);
}
break;
case 182:
{
yyval.obj=val_peek(0).obj;
}
break;
case 183:
{
yyval.obj=new ObjectNode((NameNode)val_peek(0).obj);
}
break;
case 185:
{
yyval.obj=new TypeClassAccessNode(new TypeNameNode((NameNode)val_peek(2).obj));
}
break;
case 186:
{
yyval.obj=new TypeClassAccessNode((TypeNode)val_peek(2).obj);
}
break;
case 187:
{
yyval.obj=new TypeClassAccessNode((TypeNode)val_peek(2).obj);
}
break;
case 188:
{
yyval.obj=new OuterThisAccessNode(new TypeNameNode((NameNode)val_peek(2).obj));
}
break;
case 189:
{
yyval.obj=new OuterSuperAccessNode(new TypeNameNode((NameNode)val_peek(2).obj));
}
break;
case 193:
{
yyval.obj=new NullPntrNode();
}
break;
case 194:
{
yyval.obj=new ThisNode();
}
break;
case 195:
{
yyval.obj=val_peek(1).obj;
}
break;
case 196:
{
yyval.obj=new ObjectNode((NameNode)val_peek(1).obj);
}
break;
case 198:
{
yyval.obj=val_peek(0).obj;
}
break;
case 200:
{
yyval.obj=new TypeClassAccessNode((TypeNode)val_peek(2).obj);
}
break;
case 201:
{
yyval.obj=val_peek(0).obj;
}
break;
case 203:
{
yyval.obj=new NameNode(AbsentTreeNode.instance,val_peek(0).sval);
}
break;
case 204:
{
yyval.obj=new NameNode((NameNode)val_peek(2).obj,val_peek(0).sval);
}
break;
case 205:
{
yyval.obj=new ArrayAccessNode(new ObjectNode((NameNode)val_peek(3).obj),(ExprNode)val_peek(1).obj);
}
break;
case 206:
{
yyval.obj=new ArrayAccessNode((ExprNode)val_peek(3).obj,(ExprNode)val_peek(1).obj);
}
break;
case 207:
{
yyval.obj=new ObjectFieldAccessNode((ExprNode)val_peek(2).obj,(NameNode)val_peek(0).obj);
}
break;
case 208:
{
yyval.obj=new SuperFieldAccessNode((NameNode)val_peek(0).obj);
}
break;
case 209:
{
yyval.obj=new MethodCallNode(new ObjectNode((NameNode)val_peek(3).obj),(List)val_peek(1).obj);
}
break;
case 210:
{
yyval.obj=new MethodCallNode((FieldAccessNode)val_peek(3).obj,(List)val_peek(1).obj);
}
break;
case 211:
{
}
break;
case 212:
{
yyval.obj=new LinkedList();
}
break;
case 213:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 214:
{
yyval.obj=cons(val_peek(2).obj,(List)val_peek(0).obj);
}
break;
case 215:
{
yyval.obj=new AllocateNode((TypeNameNode)val_peek(3).obj,(List)val_peek(1).obj,AbsentTreeNode.instance);
}
break;
case 216:
{
yyval.obj=new AllocateAnonymousClassNode((TypeNameNode)val_peek(4).obj,(List)val_peek(2).obj,(List)val_peek(0).obj,AbsentTreeNode.instance);
}
break;
case 217:
{
yyval.obj=new AllocateArrayNode((TypeNode)val_peek(2).obj,(List)val_peek(1).obj,val_peek(0).ival,AbsentTreeNode.instance);
}
break;
case 218:
{
yyval.obj=new AllocateArrayNode((TypeNode)val_peek(2).obj,new LinkedList(),val_peek(1).ival,(TreeNode)val_peek(0).obj);
}
break;
case 219:
{
yyval.obj=new AllocateArrayNode((TypeNode)val_peek(2).obj,(List)val_peek(1).obj,val_peek(0).ival,AbsentTreeNode.instance);
}
break;
case 220:
{
yyval.obj=new AllocateArrayNode((TypeNode)val_peek(2).obj,new LinkedList(),val_peek(1).ival,(TreeNode)val_peek(0).obj);
}
break;
case 221:
{
yyval.obj=new AllocateNode(new TypeNameNode(new NameNode(AbsentTreeNode.instance,val_peek(3).sval)),(List)val_peek(1).obj,(ExprNode)val_peek(6).obj);
}
break;
case 222:
{
yyval.obj=new AllocateAnonymousClassNode(new TypeNameNode(new NameNode(AbsentTreeNode.instance,val_peek(4).sval)),(List)val_peek(2).obj,(List)val_peek(0).obj,(ExprNode)val_peek(7).obj);
}
break;
case 223:
{
yyval.obj=new AllocateNode(new TypeNameNode(new NameNode(AbsentTreeNode.instance,val_peek(3).sval)),(List)val_peek(1).obj,new ObjectNode((NameNode)val_peek(6).obj));
}
break;
case 224:
{
yyval.obj=new AllocateAnonymousClassNode(new TypeNameNode(new NameNode(AbsentTreeNode.instance,val_peek(4).sval)),(List)val_peek(2).obj,(List)val_peek(0).obj,new ObjectNode((NameNode)val_peek(7).obj));
}
break;
case 225:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 226:
{
yyval.obj=cons(val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 227:
{
yyval.obj=val_peek(1).obj;
}
break;
case 228:
{
}
break;
case 229:
{
yyval.ival=0;
}
break;
case 230:
{
yyval.ival=1;
}
break;
case 231:
{
yyval.ival=val_peek(1).ival + 1;
}
break;
case 235:
{
yyval.obj=new PostIncrNode((ExprNode)val_peek(1).obj);
}
break;
case 236:
{
yyval.obj=new PostDecrNode((ExprNode)val_peek(1).obj);
}
break;
case 239:
{
yyval.obj=new UnaryPlusNode((ExprNode)val_peek(0).obj);
}
break;
case 240:
{
yyval.obj=new UnaryMinusNode((ExprNode)val_peek(0).obj);
}
break;
case 242:
{
yyval.obj=new PreIncrNode((ExprNode)val_peek(0).obj);
}
break;
case 243:
{
yyval.obj=new PreDecrNode((ExprNode)val_peek(0).obj);
}
break;
case 245:
{
yyval.obj=new ComplementNode((ExprNode)val_peek(0).obj);
}
break;
case 246:
{
yyval.obj=new NotNode((ExprNode)val_peek(0).obj);
}
break;
case 248:
{
yyval.obj=new CastNode((TypeNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 249:
{
yyval.obj=new CastNode((TypeNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 250:
{
yyval.obj=new CastNode(new TypeNameNode((NameNode)val_peek(2).obj),(ExprNode)val_peek(0).obj);
}
break;
case 251:
{
}
break;
case 252:
{
yyval.obj=AbsentTreeNode.instance;
}
break;
case 254:
{
yyval.obj=new MultNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 255:
{
yyval.obj=new DivNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 256:
{
yyval.obj=new RemNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 257:
{
yyval.obj=new PlusNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 258:
{
yyval.obj=new MinusNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 259:
{
yyval.obj=new LeftShiftLogNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 260:
{
yyval.obj=new RightShiftLogNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 261:
{
yyval.obj=new RightShiftArithNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 262:
{
yyval.obj=new LTNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 263:
{
yyval.obj=new GTNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 264:
{
yyval.obj=new LENode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 265:
{
yyval.obj=new GENode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 266:
{
yyval.obj=new InstanceOfNode((ExprNode)val_peek(2).obj,(TypeNode)val_peek(0).obj);
}
break;
case 267:
{
yyval.obj=new EQNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 268:
{
yyval.obj=new NENode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 269:
{
yyval.obj=new BitAndNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 270:
{
yyval.obj=new BitOrNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 271:
{
yyval.obj=new BitXorNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 272:
{
yyval.obj=new CandNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 273:
{
yyval.obj=new CorNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 274:
{
yyval.obj=new IfExprNode((ExprNode)val_peek(4).obj,(ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 276:
{
yyval.obj=new AssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 277:
{
yyval.obj=new MultAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 278:
{
yyval.obj=new DivAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 279:
{
yyval.obj=new RemAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 280:
{
yyval.obj=new PlusAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 281:
{
yyval.obj=new MinusAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 282:
{
yyval.obj=new LeftShiftLogAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 283:
{
yyval.obj=new RightShiftLogAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 284:
{
yyval.obj=new RightShiftArithAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 285:
{
yyval.obj=new BitAndAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 286:
{
yyval.obj=new BitXorAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 287:
{
yyval.obj=new BitOrAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
}
if (yydebug) debug(""String_Node_Str"");
state_drop(yym);
yystate=state_peek(0);
val_drop(yym);
yym=yylhs[yyn];
if (yystate == 0 && yym == 0) {
debug(""String_Node_Str"" + YYFINAL + ""String_Node_Str"");
yystate=YYFINAL;
state_push(YYFINAL);
val_push(yyval);
if (yychar < 0) {
yychar=yylex();
if (yychar < 0) yychar=0;
if (yydebug) yylexdebug(yystate,yychar);
}
if (yychar == 0) break;
}
 else {
yyn=yygindex[yym];
if ((yyn != 0) && (yyn+=yystate) >= 0 && yyn <= YYTABLESIZE && yycheck[yyn] == yystate) yystate=yytable[yyn];
 else yystate=yydgoto[yym];
debug(""String_Node_Str"" + state_peek(0) + ""String_Node_Str""+ yystate+ ""String_Node_Str"");
state_push(yystate);
val_push(yyval);
}
}
return 0;
}","int yyparse(){
  int yyn;
  int yym;
  int yystate;
  String yys;
  boolean doaction;
  init_stacks();
  yynerrs=0;
  yyerrflag=0;
  yychar=-1;
  yystate=0;
  state_push(yystate);
  while (true) {
    doaction=true;
    if (yydebug)     debug(""String_Node_Str"");
    for (yyn=yydefred[yystate]; yyn == 0; yyn=yydefred[yystate]) {
      if (yydebug)       debug(""String_Node_Str"" + yyn + ""String_Node_Str""+ yystate+ ""String_Node_Str""+ yychar);
      if (yychar < 0) {
        yychar=yylex();
        if (yychar < 0) {
          yychar=0;
          if (yydebug)           yylexdebug(yystate,yychar);
        }
      }
      yyn=yysindex[yystate];
      if ((yyn != 0) && (yyn+=yychar) >= 0 && yyn <= YYTABLESIZE && yycheck[yyn] == yychar) {
        if (yydebug)         debug(""String_Node_Str"" + yystate + ""String_Node_Str""+ yytable[yyn]+ ""String_Node_Str"");
        yystate=yytable[yyn];
        state_push(yystate);
        val_push(yylval);
        yychar=-1;
        if (yyerrflag > 0)         --yyerrflag;
        doaction=false;
        break;
      }
      yyn=yyrindex[yystate];
      if ((yyn != 0) && (yyn+=yychar) >= 0 && yyn <= YYTABLESIZE && yycheck[yyn] == yychar) {
        if (yydebug)         debug(""String_Node_Str"");
        yyn=yytable[yyn];
        doaction=true;
        break;
      }
 else {
        if (yyerrflag == 0) {
          yyerror(""String_Node_Str"");
          yynerrs++;
        }
        if (yyerrflag < 3) {
          yyerrflag=3;
          while (true) {
            if (stateptr < 0) {
              yyerror(""String_Node_Str"");
              return 1;
            }
            yyn=yysindex[state_peek(0)];
            if ((yyn != 0) && (yyn+=YYERRCODE) >= 0 && yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE) {
              if (yydebug)               debug(""String_Node_Str"" + state_peek(0) + ""String_Node_Str""+ yytable[yyn]+ ""String_Node_Str"");
              yystate=yytable[yyn];
              state_push(yystate);
              val_push(yylval);
              doaction=false;
              break;
            }
 else {
              if (yydebug)               debug(""String_Node_Str"" + state_peek(0) + ""String_Node_Str"");
              if (stateptr < 0) {
                yyerror(""String_Node_Str"");
                return 1;
              }
              state_pop();
              val_pop();
            }
          }
        }
 else {
          if (yychar == 0)           return 1;
          if (yydebug) {
            yys=null;
            if (yychar <= YYMAXTOKEN)             yys=yyname[yychar];
            if (yys == null)             yys=""String_Node_Str"";
            debug(""String_Node_Str"" + yystate + ""String_Node_Str""+ yychar+ ""String_Node_Str""+ yys+ ""String_Node_Str"");
          }
          yychar=-1;
        }
      }
    }
    if (!doaction)     continue;
    yym=yylen[yyn];
    if (yydebug)     debug(""String_Node_Str"" + yystate + ""String_Node_Str""+ yym+ ""String_Node_Str""+ yyn+ ""String_Node_Str""+ yyrule[yyn]+ ""String_Node_Str"");
    if (yym > 0) {
      try {
        yyval=(JavaParserval)val_peek(yym - 1).clone();
      }
 catch (      CloneNotSupportedException e) {
        yyerror(""String_Node_Str"");
      }
    }
 else {
      yyval=new JavaParserval();
    }
switch (yyn) {
case 1:
{
        _theAST=(CompileUnitNode)val_peek(0).obj;
      }
    break;
case 2:
{
    yyval.obj=new IntLitNode(val_peek(0).sval);
  }
break;
case 3:
{
yyval.obj=new LongLitNode(val_peek(0).sval);
}
break;
case 4:
{
yyval.obj=new FloatLitNode(val_peek(0).sval);
}
break;
case 5:
{
yyval.obj=new DoubleLitNode(val_peek(0).sval);
}
break;
case 6:
{
yyval.obj=new BoolLitNode(""String_Node_Str"");
}
break;
case 7:
{
yyval.obj=new BoolLitNode(""String_Node_Str"");
}
break;
case 8:
{
yyval.obj=new CharLitNode(val_peek(0).sval);
}
break;
case 9:
{
yyval.obj=new StringLitNode(val_peek(0).sval);
}
break;
case 14:
{
yyval.obj=BoolTypeNode.instance;
}
break;
case 15:
{
yyval.obj=CharTypeNode.instance;
}
break;
case 16:
{
yyval.obj=ByteTypeNode.instance;
}
break;
case 17:
{
yyval.obj=ShortTypeNode.instance;
}
break;
case 18:
{
yyval.obj=IntTypeNode.instance;
}
break;
case 19:
{
yyval.obj=FloatTypeNode.instance;
}
break;
case 20:
{
yyval.obj=LongTypeNode.instance;
}
break;
case 21:
{
yyval.obj=DoubleTypeNode.instance;
}
break;
case 22:
{
yyval.obj=new TypeNameNode((NameNode)val_peek(0).obj);
}
break;
case 23:
{
yyval.obj=new ArrayTypeNode((TypeNode)val_peek(1).obj);
}
break;
case 24:
{
yyval.obj=new CompileUnitNode((TreeNode)val_peek(2).obj,(List)val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 25:
{
yyval.obj=val_peek(1).obj;
}
break;
case 26:
{
yyval.obj=AbsentTreeNode.instance;
}
break;
case 27:
{
yyval.obj=new LinkedList();
}
break;
case 28:
{
yyval.obj=cons(val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 29:
{
yyval.obj=new LinkedList();
}
break;
case 30:
{
yyval.obj=cons(val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 31:
{
yyval.obj=val_peek(0).obj;
}
break;
case 36:
{
yyval.obj=new ImportNode((NameNode)val_peek(1).obj);
}
break;
case 37:
{
yyval.obj=new ImportOnDemandNode((NameNode)val_peek(3).obj);
}
break;
case 38:
{
NameNode name=(NameNode)val_peek(3).obj;
List body=(List)val_peek(0).obj;
Iterator bodyItr=body.iterator();
boolean constructorFound=false;
while (!constructorFound && bodyItr.hasNext()) {
Object member=bodyItr.next();
if (member instanceof ConstructorDeclNode) {
constructorFound=true;
}
}
if (!constructorFound) {
body.add(new ConstructorDeclNode(Modifier.PUBLIC_MOD,new NameNode(name.getQualifier(),name.getIdent()),new LinkedList(),new LinkedList(),new BlockNode(new LinkedList()),new SuperConstructorCallNode(new LinkedList())));
}
yyval.obj=new ClassDeclNode(val_peek(5).ival,name,(List)val_peek(1).obj,(List)body,(TypeNameNode)val_peek(2).obj);
}
break;
case 39:
{
yyval.obj=val_peek(0).obj;
}
break;
case 40:
{
yyval.obj=new TypeNameNode(new NameNode(AbsentTreeNode.instance,""String_Node_Str""));
}
break;
case 41:
{
yyval.obj=val_peek(0).obj;
}
break;
case 42:
{
yyval.obj=new LinkedList();
}
break;
case 43:
{
yyval.obj=val_peek(1).obj;
}
break;
case 44:
{
}
break;
case 45:
{
yyval.obj=new LinkedList();
}
break;
case 47:
{
yyval.obj=appendLists((List)val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 49:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 50:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 51:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 52:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 53:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 54:
{
yyval.obj=cons(val_peek(1).obj);
}
break;
case 55:
{
Modifier.checkFieldModifiers(val_peek(3).ival);
List result=new LinkedList();
List varDecls=(List)val_peek(1).obj;
Iterator itr=varDecls.iterator();
while (itr.hasNext()) {
DeclaratorNode decl=(DeclaratorNode)itr.next();
result=cons(new FieldDeclNode(val_peek(3).ival,TypeUtility.makeArrayType((TypeNode)val_peek(2).obj,decl.getDims()),decl.getName(),decl.getInitExpr()),result);
}
yyval.obj=result;
}
break;
case 56:
{
}
break;
case 57:
{
yyval.ival=Modifier.NO_MOD;
}
break;
case 58:
{
yyval.ival=val_peek(0).ival;
}
break;
case 59:
{
yyval.ival=(val_peek(1).ival | val_peek(0).ival);
if ((val_peek(1).ival & val_peek(0).ival) != 0) {
yyerror(""String_Node_Str"");
}
}
break;
case 60:
{
yyval.ival=Modifier.PUBLIC_MOD;
}
break;
case 61:
{
yyval.ival=Modifier.PROTECTED_MOD;
}
break;
case 62:
{
yyval.ival=Modifier.PRIVATE_MOD;
}
break;
case 63:
{
yyval.ival=Modifier.STATIC_MOD;
}
break;
case 64:
{
yyval.ival=Modifier.FINAL_MOD;
}
break;
case 65:
{
yyval.ival=Modifier.ABSTRACT_MOD;
}
break;
case 66:
{
yyval.ival=Modifier.NATIVE_MOD;
}
break;
case 67:
{
yyval.ival=Modifier.SYNCHRONIZED_MOD;
}
break;
case 68:
{
yyval.ival=Modifier.TRANSIENT_MOD;
}
break;
case 69:
{
yyval.ival=Modifier.VOLATILE_MOD;
}
break;
case 70:
{
yyval.ival=Modifier.STRICTFP_MOD;
}
break;
case 71:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 72:
{
yyval.obj=cons(val_peek(0).obj,(List)val_peek(2).obj);
}
break;
case 73:
{
yyval.obj=new DeclaratorNode(val_peek(0).ival,(NameNode)val_peek(1).obj,AbsentTreeNode.instance);
}
break;
case 74:
{
yyval.obj=new DeclaratorNode(val_peek(2).ival,(NameNode)val_peek(3).obj,(ExprNode)val_peek(0).obj);
}
break;
case 77:
{
Modifier.checkMethodModifiers(val_peek(8).ival);
yyval.obj=new MethodDeclNode(val_peek(8).ival,(NameNode)val_peek(6).obj,(List)val_peek(4).obj,(List)val_peek(1).obj,(TreeNode)val_peek(0).obj,TypeUtility.makeArrayType((TypeNode)val_peek(7).obj,val_peek(2).ival));
}
break;
case 78:
{
Modifier.checkMethodModifiers(val_peek(8).ival);
yyval.obj=new MethodDeclNode(val_peek(8).ival,(NameNode)val_peek(6).obj,(List)val_peek(4).obj,(List)val_peek(1).obj,(TreeNode)val_peek(0).obj,TypeUtility.makeArrayType((TypeNode)val_peek(7).obj,val_peek(2).ival));
}
break;
case 79:
{
yyval.obj=VoidTypeNode.instance;
}
break;
case 80:
{
}
break;
case 81:
{
yyval.obj=new LinkedList();
}
break;
case 82:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 83:
{
yyval.obj=cons(val_peek(2).obj,(List)val_peek(0).obj);
}
break;
case 84:
{
Modifier.checkParameterModifiers(val_peek(3).ival);
yyval.obj=new ParameterNode(val_peek(3).ival,TypeUtility.makeArrayType((TypeNode)val_peek(2).obj,val_peek(0).ival),(NameNode)val_peek(1).obj);
}
break;
case 85:
{
}
break;
case 86:
{
yyval.obj=new LinkedList();
}
break;
case 87:
{
yyval.obj=val_peek(0).obj;
}
break;
case 88:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 89:
{
yyval.obj=cons(val_peek(2).obj,(List)val_peek(0).obj);
}
break;
case 91:
{
yyval.obj=AbsentTreeNode.instance;
}
break;
case 92:
{
Modifier.checkConstructorModifiers(val_peek(9).ival);
yyval.obj=new ConstructorDeclNode(val_peek(9).ival,new NameNode(AbsentTreeNode.instance,val_peek(8).sval),(List)val_peek(6).obj,(List)val_peek(4).obj,new BlockNode((List)val_peek(1).obj),(ConstructorCallNode)val_peek(2).obj);
}
break;
case 93:
{
Modifier.checkConstructorModifiers(val_peek(8).ival);
yyval.obj=new ConstructorDeclNode(val_peek(8).ival,new NameNode(AbsentTreeNode.instance,val_peek(7).sval),(List)val_peek(5).obj,(List)val_peek(3).obj,new BlockNode((List)val_peek(1).obj),new SuperConstructorCallNode(new LinkedList()));
}
break;
case 94:
{
yyval.obj=new ThisConstructorCallNode((List)val_peek(2).obj);
}
break;
case 95:
{
yyval.obj=new SuperConstructorCallNode((List)val_peek(2).obj);
}
break;
case 96:
{
yyval.obj=new StaticInitNode((BlockNode)val_peek(0).obj);
}
break;
case 97:
{
yyval.obj=new InstanceInitNode((BlockNode)val_peek(0).obj);
}
break;
case 98:
{
Modifier.checkInterfaceModifiers(val_peek(4).ival);
yyval.obj=new InterfaceDeclNode(val_peek(4).ival,(NameNode)val_peek(2).obj,(List)val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 99:
{
}
break;
case 100:
{
yyval.obj=new LinkedList();
}
break;
case 101:
{
yyval.obj=val_peek(0).obj;
}
break;
case 102:
{
yyval.obj=val_peek(1).obj;
}
break;
case 103:
{
yyval.obj=new LinkedList();
}
break;
case 104:
{
yyval.obj=appendLists((List)val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 106:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 107:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 108:
{
yyval.obj=cons(val_peek(1).obj);
}
break;
case 109:
{
int modifiers=val_peek(3).ival;
modifiers|=(Modifier.STATIC_MOD | Modifier.FINAL_MOD);
Modifier.checkConstantFieldModifiers(modifiers);
List varDecls=(List)val_peek(1).obj;
Iterator itr=varDecls.iterator();
List result=new LinkedList();
while (itr.hasNext()) {
DeclaratorNode decl=(DeclaratorNode)itr.next();
result=cons(new FieldDeclNode(modifiers,TypeUtility.makeArrayType((TypeNode)val_peek(2).obj,decl.getDims()),decl.getName(),decl.getInitExpr()),result);
}
yyval.obj=result;
}
break;
case 110:
{
Modifier.checkMethodSignatureModifiers(val_peek(8).ival);
yyval.obj=new MethodDeclNode(val_peek(8).ival,(NameNode)val_peek(6).obj,(List)val_peek(4).obj,(List)val_peek(1).obj,AbsentTreeNode.instance,TypeUtility.makeArrayType((TypeNode)val_peek(7).obj,val_peek(2).ival));
}
break;
case 111:
{
Modifier.checkMethodSignatureModifiers(val_peek(8).ival);
yyval.obj=new MethodDeclNode(val_peek(8).ival,(NameNode)val_peek(6).obj,(List)val_peek(4).obj,(List)val_peek(1).obj,AbsentTreeNode.instance,TypeUtility.makeArrayType((TypeNode)val_peek(7).obj,val_peek(2).ival));
}
break;
case 112:
{
yyval.obj=new ArrayInitNode((List)val_peek(1).obj);
}
break;
case 113:
{
yyval.obj=new ArrayInitNode((List)val_peek(2).obj);
}
break;
case 114:
{
yyval.obj=new ArrayInitNode(new LinkedList());
}
break;
case 115:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 116:
{
yyval.obj=append((List)val_peek(2).obj,val_peek(0).obj);
}
break;
case 119:
{
yyval.obj=new BlockNode((List)val_peek(1).obj);
}
break;
case 120:
{
}
break;
case 121:
{
yyval.obj=new LinkedList();
}
break;
case 122:
{
yyval.obj=val_peek(0).obj;
}
break;
case 123:
{
yyval.obj=appendLists((List)val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 124:
{
yyval.obj=val_peek(0).obj;
}
break;
case 125:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 126:
{
yyval.obj=cons(new UserTypeDeclStmtNode((UserTypeDeclNode)val_peek(0).obj));
}
break;
case 127:
{
Modifier.checkLocalVariableModifiers(val_peek(3).ival);
List varDecls=(List)val_peek(1).obj;
List result=new LinkedList();
Iterator itr=varDecls.iterator();
while (itr.hasNext()) {
DeclaratorNode decl=(DeclaratorNode)itr.next();
result=cons(new LocalVarDeclNode(val_peek(3).ival,TypeUtility.makeArrayType((TypeNode)val_peek(2).obj,decl.getDims()),decl.getName(),decl.getInitExpr()),result);
}
yyval.obj=result;
}
break;
case 128:
{
List varDecls=(List)val_peek(1).obj;
List result=new LinkedList();
Iterator itr=varDecls.iterator();
while (itr.hasNext()) {
DeclaratorNode decl=(DeclaratorNode)itr.next();
result=cons(new LocalVarDeclNode(Modifier.NO_MOD,TypeUtility.makeArrayType((TypeNode)val_peek(2).obj,decl.getDims()),decl.getName(),decl.getInitExpr()),result);
}
yyval.obj=result;
}
break;
case 131:
{
yyval.obj=new ExprStmtNode((ExprNode)val_peek(1).obj);
}
break;
case 137:
{
yyval.obj=new EmptyStmtNode();
}
break;
case 138:
{
yyval.obj=new LabeledStmtNode((NameNode)val_peek(2).obj,(StatementNode)val_peek(0).obj);
}
break;
case 139:
{
yyval.obj=val_peek(0).obj;
}
break;
case 140:
{
yyval.obj=val_peek(0).obj;
}
break;
case 141:
{
yyval.obj=val_peek(0).obj;
}
break;
case 142:
{
yyval.obj=val_peek(0).obj;
}
break;
case 143:
{
yyval.obj=val_peek(0).obj;
}
break;
case 144:
{
yyval.obj=val_peek(0).obj;
}
break;
case 145:
{
yyval.obj=val_peek(0).obj;
}
break;
case 146:
{
yyval.obj=new IfStmtNode((ExprNode)val_peek(2).obj,(StatementNode)val_peek(0).obj,AbsentTreeNode.instance);
}
break;
case 147:
{
yyval.obj=new IfStmtNode((ExprNode)val_peek(4).obj,(StatementNode)val_peek(2).obj,(TreeNode)val_peek(0).obj);
}
break;
case 148:
{
yyval.obj=new SwitchNode((ExprNode)val_peek(2).obj,(List)val_peek(0).obj);
}
break;
case 149:
{
yyval.obj=val_peek(1).obj;
}
break;
case 150:
{
yyval.obj=new LinkedList();
}
break;
case 151:
{
yyval.obj=cons(new SwitchBranchNode((List)val_peek(2).obj,(List)val_peek(1).obj),(List)val_peek(0).obj);
}
break;
case 152:
{
yyval.obj=cons(new SwitchBranchNode((List)val_peek(0).obj,new LinkedList()));
}
break;
case 153:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 154:
{
yyval.obj=cons(val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 155:
{
yyval.obj=new CaseNode((TreeNode)val_peek(1).obj);
}
break;
case 156:
{
yyval.obj=new CaseNode(AbsentTreeNode.instance);
}
break;
case 157:
{
yyval.obj=new LoopNode(new EmptyStmtNode(),(ExprNode)val_peek(2).obj,(TreeNode)val_peek(0).obj);
}
break;
case 158:
{
yyval.obj=new LoopNode((TreeNode)val_peek(5).obj,(ExprNode)val_peek(2).obj,new EmptyStmtNode());
}
break;
case 159:
{
yyval.obj=new ForNode((List)val_peek(5).obj,(ExprNode)val_peek(4).obj,(List)val_peek(2).obj,(StatementNode)val_peek(0).obj);
}
break;
case 160:
{
yyval.obj=new ForNode((List)val_peek(4).obj,new BoolLitNode(""String_Node_Str""),(List)val_peek(2).obj,(StatementNode)val_peek(0).obj);
}
break;
case 161:
{
yyval.obj=val_peek(1).obj;
}
break;
case 162:
{
yyval.obj=val_peek(0).obj;
}
break;
case 163:
{
}
break;
case 164:
{
yyval.obj=new LinkedList();
}
break;
case 165:
{
}
break;
case 166:
{
yyval.obj=new LinkedList();
}
break;
case 167:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 168:
{
yyval.obj=cons(val_peek(2).obj,(List)val_peek(0).obj);
}
break;
case 169:
{
yyval.obj=new BreakNode((TreeNode)val_peek(1).obj);
}
break;
case 170:
{
yyval.obj=new ContinueNode((TreeNode)val_peek(1).obj);
}
break;
case 171:
{
yyval.obj=new ReturnNode((TreeNode)val_peek(1).obj);
}
break;
case 172:
{
yyval.obj=new ThrowNode((ExprNode)val_peek(1).obj);
}
break;
case 173:
{
}
break;
case 174:
{
yyval.obj=AbsentTreeNode.instance;
}
break;
case 175:
{
yyval.obj=new SynchronizedNode((ExprNode)val_peek(2).obj,(TreeNode)val_peek(0).obj);
}
break;
case 176:
{
yyval.obj=new TryNode((BlockNode)val_peek(1).obj,new LinkedList(),(TreeNode)val_peek(0).obj);
}
break;
case 177:
{
yyval.obj=new TryNode((BlockNode)val_peek(1).obj,(List)val_peek(0).obj,AbsentTreeNode.instance);
}
break;
case 178:
{
yyval.obj=new TryNode((BlockNode)val_peek(2).obj,(List)val_peek(1).obj,(TreeNode)val_peek(0).obj);
}
break;
case 179:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 180:
{
yyval.obj=cons(val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 181:
{
yyval.obj=new CatchNode((ParameterNode)val_peek(2).obj,(BlockNode)val_peek(0).obj);
}
break;
case 182:
{
yyval.obj=val_peek(0).obj;
}
break;
case 183:
{
yyval.obj=new ObjectNode((NameNode)val_peek(0).obj);
}
break;
case 185:
{
yyval.obj=new TypeClassAccessNode(new TypeNameNode((NameNode)val_peek(2).obj));
}
break;
case 186:
{
yyval.obj=new TypeClassAccessNode((TypeNode)val_peek(2).obj);
}
break;
case 187:
{
yyval.obj=new TypeClassAccessNode((TypeNode)val_peek(2).obj);
}
break;
case 188:
{
yyval.obj=new OuterThisAccessNode(new TypeNameNode((NameNode)val_peek(2).obj));
}
break;
case 189:
{
yyval.obj=new OuterSuperAccessNode(new TypeNameNode((NameNode)val_peek(2).obj));
}
break;
case 193:
{
yyval.obj=new NullPntrNode();
}
break;
case 194:
{
yyval.obj=new ThisNode();
}
break;
case 195:
{
yyval.obj=val_peek(1).obj;
}
break;
case 196:
{
yyval.obj=new ObjectNode((NameNode)val_peek(1).obj);
}
break;
case 198:
{
yyval.obj=val_peek(0).obj;
}
break;
case 200:
{
yyval.obj=new TypeClassAccessNode((TypeNode)val_peek(2).obj);
}
break;
case 201:
{
yyval.obj=val_peek(0).obj;
}
break;
case 203:
{
yyval.obj=new NameNode(AbsentTreeNode.instance,val_peek(0).sval);
}
break;
case 204:
{
yyval.obj=new NameNode((NameNode)val_peek(2).obj,val_peek(0).sval);
}
break;
case 205:
{
yyval.obj=new ArrayAccessNode(new ObjectNode((NameNode)val_peek(3).obj),(ExprNode)val_peek(1).obj);
}
break;
case 206:
{
yyval.obj=new ArrayAccessNode((ExprNode)val_peek(3).obj,(ExprNode)val_peek(1).obj);
}
break;
case 207:
{
yyval.obj=new ObjectFieldAccessNode((ExprNode)val_peek(2).obj,(NameNode)val_peek(0).obj);
}
break;
case 208:
{
yyval.obj=new SuperFieldAccessNode((NameNode)val_peek(0).obj);
}
break;
case 209:
{
yyval.obj=new MethodCallNode(new ObjectNode((NameNode)val_peek(3).obj),(List)val_peek(1).obj);
}
break;
case 210:
{
yyval.obj=new MethodCallNode((FieldAccessNode)val_peek(3).obj,(List)val_peek(1).obj);
}
break;
case 211:
{
}
break;
case 212:
{
yyval.obj=new LinkedList();
}
break;
case 213:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 214:
{
yyval.obj=cons(val_peek(2).obj,(List)val_peek(0).obj);
}
break;
case 215:
{
yyval.obj=new AllocateNode((TypeNameNode)val_peek(3).obj,(List)val_peek(1).obj,AbsentTreeNode.instance);
}
break;
case 216:
{
yyval.obj=new AllocateAnonymousClassNode((TypeNameNode)val_peek(4).obj,(List)val_peek(2).obj,(List)val_peek(0).obj,AbsentTreeNode.instance);
}
break;
case 217:
{
yyval.obj=new AllocateArrayNode((TypeNode)val_peek(2).obj,(List)val_peek(1).obj,val_peek(0).ival,AbsentTreeNode.instance);
}
break;
case 218:
{
yyval.obj=new AllocateArrayNode((TypeNode)val_peek(2).obj,new LinkedList(),val_peek(1).ival,(TreeNode)val_peek(0).obj);
}
break;
case 219:
{
yyval.obj=new AllocateArrayNode((TypeNode)val_peek(2).obj,(List)val_peek(1).obj,val_peek(0).ival,AbsentTreeNode.instance);
}
break;
case 220:
{
yyval.obj=new AllocateArrayNode((TypeNode)val_peek(2).obj,new LinkedList(),val_peek(1).ival,(TreeNode)val_peek(0).obj);
}
break;
case 221:
{
yyval.obj=new AllocateNode(new TypeNameNode(new NameNode(AbsentTreeNode.instance,val_peek(3).sval)),(List)val_peek(1).obj,(ExprNode)val_peek(6).obj);
}
break;
case 222:
{
yyval.obj=new AllocateAnonymousClassNode(new TypeNameNode(new NameNode(AbsentTreeNode.instance,val_peek(4).sval)),(List)val_peek(2).obj,(List)val_peek(0).obj,(ExprNode)val_peek(7).obj);
}
break;
case 223:
{
yyval.obj=new AllocateNode(new TypeNameNode(new NameNode(AbsentTreeNode.instance,val_peek(3).sval)),(List)val_peek(1).obj,new ObjectNode((NameNode)val_peek(6).obj));
}
break;
case 224:
{
yyval.obj=new AllocateAnonymousClassNode(new TypeNameNode(new NameNode(AbsentTreeNode.instance,val_peek(4).sval)),(List)val_peek(2).obj,(List)val_peek(0).obj,new ObjectNode((NameNode)val_peek(7).obj));
}
break;
case 225:
{
yyval.obj=cons(val_peek(0).obj);
}
break;
case 226:
{
yyval.obj=cons(val_peek(1).obj,(List)val_peek(0).obj);
}
break;
case 227:
{
yyval.obj=val_peek(1).obj;
}
break;
case 228:
{
}
break;
case 229:
{
yyval.ival=0;
}
break;
case 230:
{
yyval.ival=1;
}
break;
case 231:
{
yyval.ival=val_peek(1).ival + 1;
}
break;
case 235:
{
yyval.obj=new PostIncrNode((ExprNode)val_peek(1).obj);
}
break;
case 236:
{
yyval.obj=new PostDecrNode((ExprNode)val_peek(1).obj);
}
break;
case 239:
{
yyval.obj=new UnaryPlusNode((ExprNode)val_peek(0).obj);
}
break;
case 240:
{
yyval.obj=new UnaryMinusNode((ExprNode)val_peek(0).obj);
}
break;
case 242:
{
yyval.obj=new PreIncrNode((ExprNode)val_peek(0).obj);
}
break;
case 243:
{
yyval.obj=new PreDecrNode((ExprNode)val_peek(0).obj);
}
break;
case 245:
{
yyval.obj=new ComplementNode((ExprNode)val_peek(0).obj);
}
break;
case 246:
{
yyval.obj=new NotNode((ExprNode)val_peek(0).obj);
}
break;
case 248:
{
yyval.obj=new CastNode((TypeNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 249:
{
yyval.obj=new CastNode((TypeNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 250:
{
yyval.obj=new CastNode(new TypeNameNode((NameNode)val_peek(2).obj),(ExprNode)val_peek(0).obj);
}
break;
case 251:
{
}
break;
case 252:
{
yyval.obj=AbsentTreeNode.instance;
}
break;
case 254:
{
yyval.obj=new MultNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 255:
{
yyval.obj=new DivNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 256:
{
yyval.obj=new RemNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 257:
{
yyval.obj=new PlusNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 258:
{
yyval.obj=new MinusNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 259:
{
yyval.obj=new LeftShiftLogNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 260:
{
yyval.obj=new RightShiftLogNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 261:
{
yyval.obj=new RightShiftArithNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 262:
{
yyval.obj=new LTNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 263:
{
yyval.obj=new GTNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 264:
{
yyval.obj=new LENode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 265:
{
yyval.obj=new GENode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 266:
{
yyval.obj=new InstanceOfNode((ExprNode)val_peek(2).obj,(TypeNode)val_peek(0).obj);
}
break;
case 267:
{
yyval.obj=new EQNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 268:
{
yyval.obj=new NENode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 269:
{
yyval.obj=new BitAndNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 270:
{
yyval.obj=new BitOrNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 271:
{
yyval.obj=new BitXorNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 272:
{
yyval.obj=new CandNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 273:
{
yyval.obj=new CorNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 274:
{
yyval.obj=new IfExprNode((ExprNode)val_peek(4).obj,(ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 276:
{
yyval.obj=new AssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 277:
{
yyval.obj=new MultAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 278:
{
yyval.obj=new DivAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 279:
{
yyval.obj=new RemAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 280:
{
yyval.obj=new PlusAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 281:
{
yyval.obj=new MinusAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 282:
{
yyval.obj=new LeftShiftLogAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 283:
{
yyval.obj=new RightShiftLogAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 284:
{
yyval.obj=new RightShiftArithAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 285:
{
yyval.obj=new BitAndAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 286:
{
yyval.obj=new BitXorAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
case 287:
{
yyval.obj=new BitOrAssignNode((ExprNode)val_peek(2).obj,(ExprNode)val_peek(0).obj);
}
break;
}
if (yydebug) debug(""String_Node_Str"");
state_drop(yym);
yystate=state_peek(0);
val_drop(yym);
yym=yylhs[yyn];
if (yystate == 0 && yym == 0) {
debug(""String_Node_Str"" + YYFINAL + ""String_Node_Str"");
yystate=YYFINAL;
state_push(YYFINAL);
val_push(yyval);
if (yychar < 0) {
yychar=yylex();
if (yychar < 0) yychar=0;
if (yydebug) yylexdebug(yystate,yychar);
}
if (yychar == 0) break;
}
 else {
yyn=yygindex[yym];
if ((yyn != 0) && (yyn+=yystate) >= 0 && yyn <= YYTABLESIZE && yycheck[yyn] == yystate) yystate=yytable[yyn];
 else yystate=yydgoto[yym];
debug(""String_Node_Str"" + state_peek(0) + ""String_Node_Str""+ yystate+ ""String_Node_Str"");
state_push(yystate);
val_push(yyval);
}
}
return 0;
}"
76147,"public Object visitObjectFieldAccessNode(ObjectFieldAccessNode node,LinkedList args){
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  subCtx.resolveAsObject=true;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setObject((ExprNode)node.getObject().accept(this,childArgs));
  return node;
}","public Object visitObjectFieldAccessNode(ObjectFieldAccessNode node,LinkedList args){
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  subCtx.resolveAsObject=true;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setObject((ExprNode)(node.getObject().accept(this,childArgs)));
  return node;
}"
76148,"protected Object _visitUserTypeDeclNode(UserTypeDeclNode node,LinkedList args){
  NameContext ctx=new NameContext();
  ctx.environ=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  ClassDecl decl=(ClassDecl)JavaDecl.getDecl((NamedNode)node);
  ctx.currentClass=decl.getDefType();
  LinkedList childArgs=TNLManip.cons(ctx);
  TNLManip.traverseList(this,node,childArgs,node.getMembers());
  return node;
}","protected Object _visitUserTypeDeclNode(UserTypeDeclNode node,LinkedList args){
  NameContext ctx=new NameContext();
  ctx.environ=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  ClassDecl decl=(ClassDecl)JavaDecl.getDecl((NamedNode)node);
  ctx.currentClass=decl.getDefType();
  LinkedList childArgs=TNLManip.cons(ctx);
  node.setMembers(TNLManip.traverseList(this,node,childArgs,node.getMembers()));
  return node;
}"
76149,"public Object visitCatchNode(CatchNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  NameContext subCtx=new NameContext(ctx);
  Environ env=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  subCtx.environ=env;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.getParam().accept(this,childArgs);
  return node;
}","public Object visitCatchNode(CatchNode node,LinkedList args){
  NameContext ctx=(NameContext)args.get(0);
  NameContext subCtx=new NameContext(ctx);
  Environ env=(Environ)node.getDefinedProperty(ENVIRON_KEY);
  subCtx.environ=env;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setParam((ParameterNode)node.getParam().accept(this,childArgs));
  node.setBlock((BlockNode)node.getBlock().accept(this,childArgs));
  return node;
}"
76150,"public Object visitMethodCallNode(MethodCallNode node,LinkedList args){
  TNLManip.traverseList(this,node,args,node.getArgs());
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  subCtx.resolveAsObject=false;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setMethod((ExprNode)node.getMethod().accept(this,childArgs));
  return node;
}","public Object visitMethodCallNode(MethodCallNode node,LinkedList args){
  node.setArgs(TNLManip.traverseList(this,node,args,node.getArgs()));
  NameContext subCtx=new NameContext((NameContext)args.get(0));
  subCtx.resolveAsObject=false;
  LinkedList childArgs=TNLManip.cons(subCtx);
  node.setMethod((ExprNode)node.getMethod().accept(this,childArgs));
  return node;
}"
76151,"/** 
 * The default visit method. Visits all child nodes with the same environment as in the argument list. Only nodes that do not have their own environment should call this method.
 */
protected Object _defaultVisit(TreeNode node,LinkedList args){
  return TNLManip.traverseList(this,node,args,node.children());
}","/** 
 * The default visit method. Visits all child nodes with the same environment as in the argument list. Nodes that do not have their own environment should call this method.
 */
protected Object _defaultVisit(TreeNode node,LinkedList args){
  return TNLManip.traverseList(this,node,args,node.children());
}"
76152,"/** 
 * Return true if this branch is permitted to begin an  engagement with the branch controller; return false otherwise. During an engagement a branch is able transfer a token between its producer receiver and its consumer receiver.
 * @return True if this branch may engage with itsbranch controller.
 */
public boolean isBranchPermitted(){
  try {
    if (!_prodRcvr.hasRoom()) {
      return false;
    }
  }
 catch (  IllegalActionException e) {
  }
  if (_controller.isEngagementEnabled(this)) {
    return true;
  }
  return false;
}","/** 
 * Return true if this branch is permitted to begin an  engagement with the branch controller; return false otherwise. During an engagement a branch is able transfer a token between its producer receiver and its consumer receiver.
 * @return True if this branch may engage with itsbranch controller.
 */
public boolean isBranchPermitted(){
  try {
    if (!_consRcvr.hasRoom()) {
      System.out.println(""String_Node_Str"");
      return false;
    }
  }
 catch (  IllegalActionException e) {
  }
  if (_controller.isEngagementEnabled(this)) {
    return true;
  }
  System.out.println(""String_Node_Str"");
  return false;
}"
76153,"/** 
 * Transfer a single token between the producer receiver and  the consumer receiver. If a TerminateBranchException is thrown, then reset this receiver and return.  FIXME: Can we optimize this?
 */
public void transferTokens(){
  try {
    Token token=_prodRcvr.get(this);
    _consRcvr.put(token,this);
    _controller.engagementSucceeded(this);
  }
 catch (  TerminateBranchException e) {
    _controller.disengageBranch(this);
    reset();
    return;
  }
}","/** 
 * Transfer a single token between the producer receiver and  the consumer receiver. If a TerminateBranchException is thrown, then reset this receiver and return.  FIXME: Can we optimize this?
 */
public void transferTokens(){
  try {
    System.out.println(""String_Node_Str"");
    newIteration();
    Token token=_prodRcvr.get(this);
    System.out.println(""String_Node_Str"");
    _consRcvr.put(token,this);
    System.out.println(""String_Node_Str"");
    _controller.engagementSucceeded(this);
    System.out.println(""String_Node_Str"");
  }
 catch (  TerminateBranchException e) {
    _controller.disengageBranch(this);
    reset();
    return;
  }
}"
76154,"/** 
 * Return true if the receiver containing this boundary detector  is contained on the outside of a boundary port. A boundary port is an opaque port that is contained by a composite actor. If the containing receiver is  contained on the outside of a boundary port then return true; otherwise return false. This method is not synchronized so the caller should be.
 * @return True if the containing receiver is contained on the outside of a boundary port; return false otherwise.
 */
public boolean isOutsideBoundary(){
  if (_outsideBoundaryCacheIsOn) {
    return _isInsideBoundaryValue;
  }
 else {
    IOPort innerPort=(IOPort)_rcvr.getContainer();
    if (innerPort == null) {
      _outsideBoundaryCacheIsOn=false;
      _isOutsideBoundaryValue=false;
      return _isOutsideBoundaryValue;
    }
    ComponentEntity innerEntity=(ComponentEntity)innerPort.getContainer();
    if (!innerEntity.isAtomic() && innerPort.isOpaque()) {
      if (innerPort.isOutput() && !innerPort.isInput()) {
        _isOutsideBoundaryValue=false;
      }
 else       if (!innerPort.isOutput() && innerPort.isInput()) {
        _isOutsideBoundaryValue=true;
      }
 else       if (!innerPort.isOutput() && !innerPort.isInput()) {
        _isOutsideBoundaryValue=false;
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
      _outsideBoundaryCacheIsOn=true;
      return _isOutsideBoundaryValue;
    }
    _outsideBoundaryCacheIsOn=true;
    _isOutsideBoundaryValue=false;
    return _isOutsideBoundaryValue;
  }
}","/** 
 * Return true if the receiver containing this boundary detector  is contained on the outside of a boundary port. A boundary  port is an opaque port that is contained by a composite actor.  If the containing receiver is contained on the outside of a  boundary port then return true; otherwise return false. This  method is not synchronized so the caller should be.
 * @return True if the containing receiver is contained on the outside of a boundary port; return false otherwise.
 */
public boolean isOutsideBoundary(){
  if (_outsideBoundaryCacheIsOn) {
    return _isInsideBoundaryValue;
  }
 else {
    IOPort innerPort=(IOPort)_rcvr.getContainer();
    if (innerPort == null) {
      _outsideBoundaryCacheIsOn=false;
      _isOutsideBoundaryValue=false;
      return _isOutsideBoundaryValue;
    }
    ComponentEntity innerEntity=(ComponentEntity)innerPort.getContainer();
    if (!innerEntity.isAtomic() && innerPort.isOpaque()) {
      if (innerPort.isOutput() && !innerPort.isInput()) {
        _isOutsideBoundaryValue=false;
      }
 else       if (!innerPort.isOutput() && innerPort.isInput()) {
        _isOutsideBoundaryValue=true;
      }
 else       if (!innerPort.isOutput() && !innerPort.isInput()) {
        _isOutsideBoundaryValue=false;
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
      _outsideBoundaryCacheIsOn=true;
      return _isOutsideBoundaryValue;
    }
    _outsideBoundaryCacheIsOn=true;
    _isOutsideBoundaryValue=false;
    return _isOutsideBoundaryValue;
  }
}"
76155,"/** 
 * Return true if the receiver containing this boundary detector is connected to the inside of a boundary port. A boundary port is an opaque port that is contained by a composite actor. If the containing receiver is connected  to the inside of a boundary port, then return true; otherwise return false. This method is not synchronized so the caller should be.
 * @return True if the containing receiver is connected to the inside of a boundary port; return false otherwise.
 */
public boolean isConnectedToBoundary(){
  if (_connectedBoundaryCacheIsOn) {
    return _isConnectedBoundaryValue;
  }
 else {
    IOPort innerPort=(IOPort)_rcvr.getContainer();
    if (innerPort == null) {
      _connectedBoundaryCacheIsOn=false;
      _isConnectedBoundaryValue=false;
      return _isConnectedBoundaryValue;
    }
    ComponentEntity innerEntity=(ComponentEntity)innerPort.getContainer();
    Port outerPort=null;
    ComponentEntity outerEntity=null;
    Iterator ports=innerPort.connectedPortList().iterator();
    int cnt=0;
    while (ports.hasNext()) {
      outerPort=(Port)ports.next();
      outerEntity=(ComponentEntity)outerPort.getContainer();
      if (outerEntity == innerEntity.getContainer()) {
        try {
          Receiver[][] rcvrs=((IOPort)outerPort).deepGetReceivers();
          for (int i=0; i < rcvrs.length; i++) {
            for (int j=0; j < rcvrs[i].length; j++) {
              if (_rcvr == rcvrs[i][j]) {
                _connectedBoundaryCacheIsOn=true;
                _isConnectedBoundaryValue=true;
                return true;
              }
            }
          }
        }
 catch (        IllegalActionException e) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
    _connectedBoundaryCacheIsOn=true;
    _isConnectedBoundaryValue=false;
    return _isConnectedBoundaryValue;
  }
}","/** 
 * Return true if the receiver containing this boundary detector is connected to a boundary port. A boundary port is an opaque  port that is contained by a composite actor. If the containing  receiver is connected to a boundary port, then return true;  otherwise return false.  This method is not synchronized so the caller should be.
 * @return True if the containing receiver is connected to the inside of a boundary port; return false otherwise.
 */
public boolean isConnectedToBoundary(){
  if (_connectedBoundaryCacheIsOn) {
    return _isConnectedBoundaryValue;
  }
 else {
    IOPort contPort=(IOPort)_rcvr.getContainer();
    if (contPort == null) {
      _connectedBoundaryCacheIsOn=false;
      _isConnectedBoundaryValue=false;
      return _isConnectedBoundaryValue;
    }
    ComponentEntity contEntity=(ComponentEntity)contPort.getContainer();
    IOPort connectedPort=null;
    ComponentEntity connectedEntity=null;
    Iterator ports=contPort.connectedPortList().iterator();
    int cnt=0;
    while (ports.hasNext()) {
      connectedPort=(IOPort)ports.next();
      connectedEntity=(ComponentEntity)connectedPort.getContainer();
      if (connectedEntity == contEntity.getContainer() && connectedPort.isInput()) {
        try {
          Receiver[][] rcvrs=connectedPort.deepGetReceivers();
          for (int i=0; i < rcvrs.length; i++) {
            for (int j=0; j < rcvrs[i].length; j++) {
              if (_rcvr == rcvrs[i][j]) {
                _connectedBoundaryCacheIsOn=true;
                _isConnectedBoundaryValue=true;
                return true;
              }
            }
          }
        }
 catch (        IllegalActionException e) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 else       if (connectedPort.isOpaque() && !connectedEntity.isAtomic() && connectedPort.isOutput()) {
        Receiver[][] rcvrs=connectedPort.getRemoteReceivers();
        for (int i=0; i < rcvrs.length; i++) {
          for (int j=0; j < rcvrs[i].length; j++) {
            if (_rcvr == rcvrs[i][j]) {
              _connectedBoundaryCacheIsOn=true;
              _isConnectedBoundaryValue=true;
              return true;
            }
          }
        }
      }
    }
    _connectedBoundaryCacheIsOn=true;
    _isConnectedBoundaryValue=false;
    return _isConnectedBoundaryValue;
  }
}"
76156,"/** 
 * Construct a Branch object.
 */
public Branch(BoundaryReceiver prodRcvr,BoundaryReceiver consRcvr,BranchController cntlr) throws IllegalActionException {
  _controller=cntlr;
  if (!prodRcvr.isProducerReceiver()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  _prodRcvr=prodRcvr;
  if (!consRcvr.isConsumerReceiver()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  _consRcvr=consRcvr;
}","/** 
 * Construct a Branch object.
 */
public Branch(BoundaryReceiver prodRcvr,BoundaryReceiver consRcvr,BranchController cntlr) throws IllegalActionException {
  _controller=cntlr;
  if (!prodRcvr.isProducerReceiver()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  _prodRcvr=prodRcvr;
  if (!consRcvr.isConsumerReceiver()) {
    String name=((Nameable)consRcvr.getContainer()).getName();
    throw new IllegalActionException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  _consRcvr=consRcvr;
}"
76157,"/** 
 * Add branches corresponding to the channels of the port argument. The port must be contained by the same actor that contains this controller. If branches corresponding to the port have already been added to this controller, then an IllegalActionException will be thrown. If the input/output polarity of this port does not match that of ports for whom branches have been previously added to this controller, then throw an IllegalActionException.
 * @param port The port for which branches will be added to thiscontroller.
 * @exception IllegalActionException If branches for theport have been previously added to this controller or if the port input/output polarity does not match that of ports for whom branches were previously add to this controller.
 */
public void addBranches(IOPort port) throws IllegalActionException {
  if (port.getContainer() != getParent()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (_ports == null) {
    _ports=new LinkedList();
  }
  if (_ports.contains(port)) {
    throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (_hasInputPorts() && !port.isInput()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (_hasOutputPorts() && !port.isOutput()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  _ports.add(port);
  Branch branch=null;
  BoundaryReceiver prodRcvr=null;
  BoundaryReceiver consRcvr=null;
  Receiver[][] prodRcvrs=null;
  Receiver[][] consRcvrs=null;
  for (int i=0; i < port.getWidth(); i++) {
    if (port.isInput()) {
      prodRcvrs=port.getReceivers();
      consRcvrs=port.deepGetReceivers();
    }
 else     if (port.isOutput()) {
      prodRcvrs=port.getReceivers();
      consRcvrs=port.getRemoteReceivers();
    }
 else {
      throw new IllegalActionException(""String_Node_Str"");
    }
    prodRcvr=(BoundaryReceiver)prodRcvrs[i][0];
    consRcvr=(BoundaryReceiver)consRcvrs[i][0];
    branch=new Branch(prodRcvr,consRcvr,this);
    _branches.add(branch);
  }
}","/** 
 * Add branches corresponding to the channels of the port argument. The port must be contained by the same actor that contains this controller. If branches corresponding to the port have already been added to this controller, then an IllegalActionException will be thrown. If the input/output polarity of this port does not match that of ports for whom branches have been previously added to this controller, then throw an IllegalActionException.
 * @param port The port for which branches will be added to thiscontroller.
 * @exception IllegalActionException If branches for theport have been previously added to this controller or if the port input/output polarity does not match that of ports for whom branches were previously add to this controller.
 */
public void addBranches(IOPort port) throws IllegalActionException {
  if (port.getContainer() != getParent()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (_ports == null) {
    _ports=new LinkedList();
  }
  if (_ports.contains(port)) {
    throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (_hasInputPorts() && !port.isInput()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (_hasOutputPorts() && !port.isOutput()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  _ports.add(port);
  Branch branch=null;
  BoundaryReceiver prodRcvr=null;
  BoundaryReceiver consRcvr=null;
  Receiver[][] prodRcvrs=null;
  Receiver[][] consRcvrs=null;
  for (int i=0; i < port.getWidth(); i++) {
    if (port.isInput()) {
      prodRcvrs=port.getReceivers();
      consRcvrs=port.deepGetReceivers();
    }
 else     if (port.isOutput()) {
      prodRcvrs=port.getInsideReceivers();
      consRcvrs=port.getRemoteReceivers();
    }
 else {
      throw new IllegalActionException(""String_Node_Str"");
    }
    prodRcvr=(BoundaryReceiver)prodRcvrs[i][0];
    consRcvr=(BoundaryReceiver)consRcvrs[i][0];
    branch=new Branch(prodRcvr,consRcvr,this);
    _branches.add(branch);
  }
}"
76158,"/** 
 * Transfer a single token between the producer receiver and  the consumer receiver. If a TerminateBranchException is thrown, then reset this receiver and return.  FIXME: Can we optimize this?
 */
public void transferTokens(){
  try {
    Token token=_prodRcvr.get(this);
    _consRcvr.put(token,this);
  }
 catch (  TerminateBranchException e) {
    reset();
    return;
  }
}","/** 
 * Transfer a single token between the producer receiver and  the consumer receiver. If a TerminateBranchException is thrown, then reset this receiver and return.  FIXME: Can we optimize this?
 */
public void transferTokens(){
  try {
    Token token=_prodRcvr.get(this);
    _consRcvr.put(token,this);
    _controller.engagementSucceeded(this);
  }
 catch (  TerminateBranchException e) {
    _controller.disengageBranch(this);
    reset();
    return;
  }
}"
76159,"/** 
 * Restart this controller by resetting the branches that it controls and setting flags so engagements can take place. This method is synchronized and will notify any  threads that are synchronized to this object.
 */
public synchronized void restart(){
  _iterationIsOverCache=true;
  _engagements.clear();
  _branchesBlocked=0;
  _branchesActive=0;
  Branch branch=null;
  Iterator branches=_branches.iterator();
  while (branches.hasNext()) {
    branch=(Branch)branches.next();
    branch.reset();
  }
  _iterationIsOverCache=false;
  notifyAll();
}","/** 
 * Restart this controller by resetting the branches that it controls and setting flags so engagements can take place. This method is synchronized and will notify any  threads that are synchronized to this object.
 */
public synchronized void restart(){
  _iterationIsOverCache=true;
  _engagements.clear();
  _branchesBlocked=0;
  Branch branch=null;
  Iterator branches=_branches.iterator();
  while (branches.hasNext()) {
    branch=(Branch)branches.next();
    branch.reset();
  }
  _iterationIsOverCache=false;
  notifyAll();
}"
76160,"/** 
 * Register the branch passed as an argument as having  successfully completed an engagement. If the number of engagements permitted during an iteration of this branch controller is bounded, then increment the number of completed engagements for the branch. If the number of engagements per iteration is unbounded then or this controller is not active, then simply  return.
 * @param branch The Branch with a successful engagement.
 */
public void engagementSucceeded(Branch branch){
synchronized (this) {
    if (!isActive()) {
      return;
    }
    if (_maxEngagements < 0 && _maxEngagers < 0) {
      return;
    }
    if (!_engagements.contains(branch)) {
    }
 else     if (_iterationIsOverCache) {
    }
    if (branch.numberOfCompletedEngagements() < _maxEngagements) {
      branch.completeEngagement();
    }
 else {
    }
    notifyAll();
  }
}","/** 
 * Register the branch passed as an argument as having  successfully completed an engagement. If the number of engagements permitted during an iteration of this branch controller is bounded, then increment the number of completed engagements for the branch. If the number of engagements per iteration is unbounded then or this controller is not active, then simply  return.
 * @param branch The Branch with a successful engagement.
 * @exception TerminateBranchException If this controlleris inactive, its iteration is over or the branch is not currently engaged.
 */
public void engagementSucceeded(Branch branch) throws TerminateBranchException {
synchronized (this) {
    if (!isActive() || _iterationIsOverCache) {
      throw new TerminateBranchException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_maxEngagements < 0 && _maxEngagers < 0) {
      return;
    }
    if (!_engagements.contains(branch)) {
      throw new TerminateBranchException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    if (branch.numberOfCompletedEngagements() < _maxEngagements) {
      branch.completeEngagement();
    }
 else {
      throw new TerminateBranchException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    notifyAll();
  }
}"
76161,"/** 
 * Called by ConditionalSend and ConditionalReceive to check if the calling branch is the first branch to be ready to rendezvous. If it is, it sets a private variable to its branch ID so that subsequent calls to this method by other branches know that they are not first.
 * @param branchNumber The ID assigned to the calling branchupon creation.
 * @return True if the calling branch is the first branch to tryto rendezvous, otherwise false.
 */
public boolean isEngagementEnabled(Branch branch){
synchronized (this) {
    if (!_iterationIsOverCache || !isActive()) {
      return false;
    }
    if (_maxEngagements < 0 && _maxEngagers < 0) {
      return true;
    }
    if (_engagements.contains(branch)) {
      if (branch.numberOfCompletedEngagements() < _maxEngagements) {
        return true;
      }
      return false;
    }
 else     if (_engagements.size() < _maxEngagers) {
      _engagements.add(branch);
      return true;
    }
    return false;
  }
}","/** 
 * Called by ConditionalSend and ConditionalReceive to check if the calling branch is the first branch to be ready to rendezvous. If it is, it sets a private variable to its branch ID so that subsequent calls to this method by other branches know that they are not first.
 * @param branchNumber The ID assigned to the calling branchupon creation.
 * @return True if the calling branch is the first branch to tryto rendezvous, otherwise false.
 */
public boolean isEngagementEnabled(Branch branch){
synchronized (this) {
    if (_iterationIsOverCache || !isActive()) {
      return false;
    }
    if (_maxEngagements < 0 && _maxEngagers < 0) {
      branch.beginEngagement();
      return true;
    }
    if (_engagements.contains(branch)) {
      if (branch.numberOfCompletedEngagements() < _maxEngagements) {
        branch.beginEngagement();
        return true;
      }
      return false;
    }
 else     if (_engagements.size() < _maxEngagers) {
      if (branch.numberOfCompletedEngagements() < _maxEngagements) {
        _engagements.add(branch);
        branch.beginEngagement();
        return true;
      }
      return false;
    }
    return false;
  }
}"
76162,"/** 
 * Return true if this controller is active; return false  otherwise.
 * @return True if this controller is active; false otherwise.
 */
public boolean isActive(){
  return _active;
}","/** 
 * Return true if this controller is active; return false  otherwise.
 * @return True if this controller is active; false otherwise.
 */
public boolean isActive(){
  return _isActive;
}"
76163,"/** 
 * Release the status of the calling branch as the first branch to be ready to rendezvous. This method is only called when both sides of a communication at a receiver are conditional. In this case, both of the branches have to be the first branches, for their respective actors, for the rendezvous to go ahead. If one branch registers as being first, for its actor, but the other branch cannot, then the status of the first branch needs to be released to allow other branches the possibility of succeeding.
 * @param branchNumber The ID assigned to the branch upon creation.
 */
public void disengageBranch(Branch branch){
synchronized (this) {
    if (_maxEngagements < 0 && _maxEngagers < 0) {
      return;
    }
    if (_engagements.contains(branch)) {
      if (branch.numberOfCompletedEngagements() == 0) {
        _engagements.remove(branch);
      }
    }
 else {
    }
  }
}","/** 
 * Release the status of the calling branch as the first branch to be ready to rendezvous. This method is only called when both sides of a communication at a receiver are conditional. In this case, both of the branches have to be the first branches, for their respective actors, for the rendezvous to go ahead. If one branch registers as being first, for its actor, but the other branch cannot, then the status of the first branch needs to be released to allow other branches the possibility of succeeding.
 * @param branchNumber The ID assigned to the branch upon creation.
 */
public void disengageBranch(Branch branch){
synchronized (this) {
    if (_maxEngagements < 0 && _maxEngagers < 0) {
      return;
    }
    if (_engagements.contains(branch)) {
      if (branch.numberOfCompletedEngagements() == 0) {
        _engagements.remove(branch);
      }
    }
  }
}"
76164,"/** 
 */
public void setActive(boolean active){
  _active=active;
}","/** 
 */
public void setActive(boolean active){
  _isActive=active;
}"
76165,"/** 
 * Construct a DoubleMatrixToken with the specified 2-D array. If copy is DO_COPY, make a copy of the array and store the copy, so that changes on the specified array after this token is constructed will not affect the content of this token. If copy is DO_NOT_COPY, just reference the array (do not copy its contents). This saves some time and memory. The argument array should NOT be modified after this constructor  is called to preserve immutability.          
 * @exception NullPointerException If the specified arrayis null.
 */
protected ComplexMatrixToken(final Complex[][] value,int copy){
  _rowCount=value.length;
  _columnCount=value[0].length;
  if (copy == DO_NOT_COPY) {
    _value=value;
  }
 else {
    _value=new Complex[_rowCount][_columnCount];
    for (int i=0; i < _rowCount; i++) {
      System.arraycopy(value[i],0,_value,0,_columnCount);
    }
  }
}","/** 
 * Construct a DoubleMatrixToken with the specified 2-D array. If copy is DO_COPY, make a copy of the array and store the copy, so that changes on the specified array after this token is constructed will not affect the content of this token. If copy is DO_NOT_COPY, just reference the array (do not copy its contents). This saves some time and memory. The argument array should NOT be modified after this constructor  is called to preserve immutability.          
 * @exception NullPointerException If the specified arrayis null.
 */
protected ComplexMatrixToken(final Complex[][] value,int copy){
  _rowCount=value.length;
  _columnCount=value[0].length;
  if (copy == DO_NOT_COPY) {
    _value=value;
  }
 else {
    _value=ComplexMatrixMath.allocCopy(value);
  }
}"
76166,"/** 
 * Increase the count of branches that are blocked trying to rendezvous. If all the enabled branches (for the CIF or CDO currently being executed) are blocked, register this actor as being blocked.
 */
protected void _branchBlocked(ProcessReceiver rcvr){
synchronized (_internalLock) {
    if (rcvr.isReadBlocked()) {
      if (rcvr.isConnectedToBoundary()) {
        _extReadBranchesBlocked++;
      }
      _intReadBranchesBlocked++;
    }
    if (rcvr.isWriteBlocked()) {
      _writeBranchesBlocked++;
    }
    registerBlock();
  }
}","/** 
 * Increase the count of branches that are blocked trying to rendezvous. If all the enabled branches (for the CIF or CDO currently being executed) are blocked, register this actor as being blocked.
 */
protected void _branchBlocked(CSPReceiver rcvr){
synchronized (_internalLock) {
    _branchesBlocked++;
    if (_branchesBlocked == _branchesStarted) {
      _getDirector()._actorBlocked(rcvr);
      _blocked=true;
    }
  }
}"
76167,"/** 
 * Determine which branch succeeds with a rendezvous. This method is central to nondeterministic rendezvous. It is passed in an array of branches, each element of which represents one of the conditional rendezvous branches. If the guard for the branch is false then the branch is not enabled.  It returns the id of the successful branch, or -1 if none of the branches were enabled. <p> If exactly one branch is enabled, then the communication is performed directly and the id of the enabled branch  is returned. If more than one branch is enabled, a thread  is created and started for each enabled branch. These threads try to rendezvous until one succeeds. After a thread succeeds the other threads are killed, and the id of the successful branch is returned. <p>
 * @param branches The set of conditional branches involved.
 * @return The ID of the successful branch, or -1 if none of thebranches were enabled.
 */
public int chooseBranch(ConditionalBranch[] branches){
  try {
synchronized (_internalLock) {
      _resetConditionalState();
      _threadList=new LinkedList();
      ConditionalBranch onlyBranch=null;
      for (int i=0; i < branches.length; i++) {
        if (branches[i].getGuard()) {
          Nameable act=(Nameable)branches[i].getController().getParent();
          String name=act.getName() + branches[i].getID();
          Thread t=new Thread((Runnable)branches[i],name);
          _threadList.add(0,t);
          onlyBranch=branches[i];
        }
      }
      int num=_threadList.size();
      if (num == 0) {
        return _successfulBranch;
      }
 else       if (num == 1) {
        if (onlyBranch instanceof ConditionalSend) {
          Token t=onlyBranch.getToken();
          onlyBranch.getReceiver().put(t);
          return onlyBranch.getID();
        }
 else {
          Token tmp=onlyBranch.getReceiver().get();
          onlyBranch.setToken(tmp);
          return onlyBranch.getID();
        }
      }
 else {
        Iterator threads=_threadList.iterator();
        while (threads.hasNext()) {
          Thread thread=(Thread)threads.next();
          thread.start();
          _branchesActive++;
        }
        _branchesStarted=_branchesActive;
        while ((_successfulBranch == -1) && (_branchesActive > 0)) {
          _internalLock.wait();
        }
      }
    }
    LinkedList tmp=new LinkedList();
    for (int i=0; i < branches.length; i++) {
      if ((i != _successfulBranch) && (branches[i].getGuard())) {
        Receiver rec=branches[i].getReceiver();
        tmp.add(0,rec);
        branches[i].setAlive(false);
      }
    }
    (new NotifyThread(tmp)).start();
synchronized (_internalLock) {
      while (_branchesActive != 0) {
        _internalLock.wait();
      }
      if (_branchesActive != 0) {
        throw new InvalidStateException(((Nameable)getParent()).getName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException ex) {
    throw new TerminateProcessException(((Nameable)getParent()).getName() + ""String_Node_Str"");
  }
  if (_successfulBranch == -1) {
    if (_blocked) {
    }
    throw new TerminateProcessException(((Nameable)getParent()).getName() + ""String_Node_Str"" + ""String_Node_Str"");
  }
  _threadList=null;
  return _successfulBranch;
}","/** 
 * Determine which branch succeeds with a rendezvous. This method is central to nondeterministic rendezvous. It is passed in an array of branches, each element of which represents one of the conditional rendezvous branches. If the guard for the branch is false then the branch is not enabled.  It returns the id of the successful branch, or -1 if none of the branches were enabled. <p> If exactly one branch is enabled, then the communication is performed directly and the id of the enabled branch  is returned. If more than one branch is enabled, a thread  is created and started for each enabled branch. These threads try to rendezvous until one succeeds. After a thread succeeds the other threads are killed, and the id of the successful branch is returned. <p>
 * @param branches The set of conditional branches involved.
 * @return The ID of the successful branch, or -1 if none of thebranches were enabled.
 */
public int chooseBranch(ConditionalBranch[] branches){
  try {
synchronized (_internalLock) {
      _resetConditionalState();
      _threadList=new LinkedList();
      ConditionalBranch onlyBranch=null;
      for (int i=0; i < branches.length; i++) {
        if (branches[i].getGuard()) {
          Nameable act=(Nameable)branches[i].getController().getParent();
          String name=act.getName() + branches[i].getID();
          Thread t=new Thread((Runnable)branches[i],name);
          _threadList.add(0,t);
          onlyBranch=branches[i];
        }
      }
      int num=_threadList.size();
      if (num == 0) {
        return _successfulBranch;
      }
 else       if (num == 1) {
        if (onlyBranch instanceof ConditionalSend) {
          Token t=onlyBranch.getToken();
          onlyBranch.getReceiver().put(t);
          return onlyBranch.getID();
        }
 else {
          Token tmp=onlyBranch.getReceiver().get();
          onlyBranch.setToken(tmp);
          return onlyBranch.getID();
        }
      }
 else {
        Iterator threads=_threadList.iterator();
        while (threads.hasNext()) {
          Thread thread=(Thread)threads.next();
          thread.start();
          _branchesActive++;
        }
        _branchesStarted=_branchesActive;
        while ((_successfulBranch == -1) && (_branchesActive > 0)) {
          _internalLock.wait();
        }
      }
    }
    LinkedList tmp=new LinkedList();
    for (int i=0; i < branches.length; i++) {
      if ((i != _successfulBranch) && (branches[i].getGuard())) {
        Receiver rec=branches[i].getReceiver();
        tmp.add(0,rec);
        branches[i].setAlive(false);
      }
    }
    (new NotifyThread(tmp)).start();
synchronized (_internalLock) {
      while (_branchesActive != 0) {
        _internalLock.wait();
      }
      if (_branchesActive != 0) {
        throw new InvalidStateException(((Nameable)getParent()).getName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException ex) {
    throw new TerminateProcessException(((Nameable)getParent()).getName() + ""String_Node_Str"");
  }
  if (_successfulBranch == -1) {
    if (_blocked) {
      _getDirector()._actorUnBlocked(new CSPReceiver());
    }
    throw new TerminateProcessException(((Nameable)getParent()).getName() + ""String_Node_Str"" + ""String_Node_Str"");
  }
  _threadList=null;
  return _successfulBranch;
}"
76168,"/** 
 * Decrease the count of branches that are read blocked. If the actor was previously registered as being blocked,  register this actor with the director as no longer being  blocked.
 */
protected void _branchUnblocked(ProcessReceiver rcvr){
synchronized (_internalLock) {
    if (_blocked) {
      if (_intReadBranchesBlocked + _extReadBranchesBlocked + _writeBranchesBlocked != _branchesStarted) {
        throw new InternalErrorException(((Nameable)getParent()).getName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
      _getDirector()._actorUnBlocked(new CSPReceiver());
      _blocked=false;
    }
    if (rcvr.isReadBlocked()) {
      if (rcvr.isConnectedToBoundary()) {
        _extReadBranchesBlocked--;
      }
      _intReadBranchesBlocked--;
    }
    if (rcvr.isWriteBlocked()) {
      _writeBranchesBlocked--;
    }
  }
}","/** 
 * Decrease the count of branches that are read blocked. If the actor was previously registered as being blocked,  register this actor with the director as no longer being  blocked.
 */
protected void _branchUnblocked(CSPReceiver rcvr){
synchronized (_internalLock) {
    if (_blocked) {
      if (_branchesBlocked != _branchesStarted) {
        throw new InternalErrorException(((Nameable)getParent()).getName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
      _getDirector()._actorUnBlocked(rcvr);
      _blocked=false;
    }
  }
}"
76169,"private void _resetConditionalState(){
synchronized (_internalLock) {
    _blocked=false;
    _branchesActive=0;
    _intReadBranchesBlocked=0;
    _extReadBranchesBlocked=0;
    _writeBranchesBlocked=0;
    _branchesStarted=0;
    _branchTrying=-1;
    _successfulBranch=-1;
    _threadList=null;
  }
}","private void _resetConditionalState(){
synchronized (_internalLock) {
    _blocked=false;
    _branchesActive=0;
    _branchesBlocked=0;
    _branchesStarted=0;
    _branchTrying=-1;
    _successfulBranch=-1;
    _threadList=null;
  }
}"
76170,"/** 
 * Check parameters and begin the sound capture process. If the capture source is a sound file, the file is reopened and capture is reset to the beginning of the file.
 * @exception IllegalActionException If the parametersare out of range.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    String theURL=((StringToken)pathName.getToken()).toString();
    _soundCapture=new SoundCapture(theURL,_productionRate);
    try {
      _soundCapture.startCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
    _channels=_soundCapture.getChannels();
    channels.setToken(new IntToken(_channels));
  }
 else   if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    int getSamplesSizeInt=_productionRate;
    _soundCapture=new SoundCapture((float)sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,getSamplesSizeInt);
    try {
      _soundCapture.startCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + source.getFullName() + ""String_Node_Str"");
  }
  _audioTokenArray=new DoubleToken[_productionRate];
}","/** 
 * Check parameters and begin the sound capture process. If the capture source is a sound file, the file is reopened and capture is reset to the beginning of the file.
 * @exception IllegalActionException If the parametersare out of range.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (((StringToken)source.getToken()).toString().equals(""String_Node_Str"")) {
    String theURL=((StringToken)pathName.getToken()).toString();
    _soundCapture=new SoundCapture(theURL,_productionRate);
    try {
      _soundCapture.startCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
    _channels=_soundCapture.getChannels();
    channels.setToken(new IntToken(_channels));
  }
 else   if (((StringToken)source.getToken()).toString().equals(""String_Node_Str"")) {
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    int getSamplesSizeInt=_productionRate;
    _soundCapture=new SoundCapture((float)sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,getSamplesSizeInt);
    try {
      _soundCapture.startCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + source.getFullName() + ""String_Node_Str"");
  }
  _audioTokenArray=new DoubleToken[_productionRate];
}"
76171,"/** 
 */
public void run(){
synchronized (this) {
    try {
      activateBranches();
      while (isActive()) {
        while (!isIterationOver()) {
          wait();
          if (isDeadlocked() && !isIterationOver()) {
            while (isDeadlocked() && !isIterationOver()) {
              _getDirector()._branchBlocked(this);
              wait();
            }
            _getDirector()._branchUnBlocked(this);
          }
        }
        if (isIterationOver() && isActive()) {
          while (isIterationOver() && isActive()) {
            _getDirector()._branchBlocked(this);
            wait();
          }
          _getDirector()._branchUnBlocked(this);
        }
      }
    }
 catch (    InterruptedException e) {
    }
  }
}","/** 
 */
public void run(){
synchronized (this) {
    try {
      activateBranches();
      while (isActive()) {
        while (!isIterationOver()) {
          wait();
          if (isDeadlocked() && !isIterationOver()) {
            while (isDeadlocked() && !isIterationOver()) {
              _getDirector()._branchCntlrBlocked();
              wait();
            }
            _getDirector()._branchCntlrUnBlocked();
          }
        }
        if (isIterationOver() && isActive()) {
          while (isIterationOver() && isActive()) {
            _getDirector()._branchCntlrBlocked();
            wait();
          }
          _getDirector()._branchCntlrUnBlocked();
        }
      }
    }
 catch (    InterruptedException e) {
    }
  }
}"
76172,"/** 
 * Return a new String representing the array, formatted as specified by the ArrayStringFormat argument. To get a String in the Ptolemy expression language format, call this method with ArrayStringFormat.exprASFormat as the format argument.
 */
public static final String toString(final Complex[] array,ArrayStringFormat format){
}","/** 
 * Return a new String representing the array, formatted as specified by the ArrayStringFormat argument. To get a String in the Ptolemy expression language format, call this method with ArrayStringFormat.exprASFormat as the format argument.
 */
public static final String toString(final Complex[] array,ArrayStringFormat format){
  int length=array.length;
  StringBuffer sb=new StringBuffer();
  sb.append(format.vectorBeginString());
  for (int i=0; i < length; i++) {
    sb.append(format.complexString(array[i]));
    if (i < (length - 1)) {
      sb.append(format.elementDelimiterString());
    }
  }
  sb.append(format.vectorEndString());
  return sb.toString();
}"
76173,"/** 
 * Return a new String representing the matrix, formatted as specified by the ArrayStringFormat argument. To get a String in the Ptolemy expression language format, call this method with ArrayStringFormat.exprASFormat as the format argument.
 */
public static final String toString(final Complex[][] matrix,final ArrayStringFormat asf){
  StringBuffer sb=new StringBuffer();
  sb.append(asf.matrixBeginString());
  for (int i=0; i < _rows(matrix); i++) {
    sb.append(asf.vectorBeginString());
    for (int j=0; j < _columns(matrix); j++) {
      sb.append(asf.complexString(matrix[i][j]));
      if (j < (_columns(matrix) - 1)) {
        sb.append(asf.elementDelimiterString());
      }
    }
    sb.append(asf.vectorEndString());
    if (i < (_rows(matrix) - 1)) {
      sb.append(asf.vectorDelimiterString());
    }
  }
  sb.append(asf.matrixEndString());
  return new String(sb);
}","/** 
 * Return a new String representing the matrix, formatted as specified by the ArrayStringFormat argument. To get a String in the Ptolemy expression language format, call this method with ArrayStringFormat.exprASFormat as the format argument.
 */
public static final String toString(final Complex[][] matrix,final ArrayStringFormat asf){
  StringBuffer sb=new StringBuffer();
  sb.append(asf.matrixBeginString());
  for (int i=0; i < _rows(matrix); i++) {
    sb.append(asf.vectorBeginString());
    for (int j=0; j < _columns(matrix); j++) {
      sb.append(asf.complexString(matrix[i][j]));
      if (j < (_columns(matrix) - 1)) {
        sb.append(asf.elementDelimiterString());
      }
    }
    sb.append(asf.vectorEndString());
    if (i < (_rows(matrix) - 1)) {
      sb.append(asf.vectorDelimiterString());
    }
  }
  sb.append(asf.matrixEndString());
  return sb.toString();
}"
76174,"/** 
 * Read the value of the <i>value</i> parameter and output <i>rate</i> many tokens with that value.
 * @exception IllegalActionException If it is thrown by thesend() method sending out the token.
 */
public void fire() throws IllegalActionException {
  super.fire();
  DoubleToken[] resultTokenArray=new DoubleToken[_rate];
  double valueDouble=((DoubleToken)value.getToken()).doubleValue();
  for (int i=0; i < _rate; i++) {
    resultTokenArray[i]=new DoubleToken(valueDouble);
  }
  output.sendArray(0,resultTokenArray);
}","/** 
 * Read the value of the <i>value</i> parameter and output <i>rate</i> many tokens with that value.
 * @exception IllegalActionException If it is thrown by thesend() method sending out the token.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Token[] resultTokenArray=new Token[_rate];
  for (int i=0; i < _rate; i++) {
    resultTokenArray[i]=value.getToken();
  }
  output.sendArray(0,resultTokenArray);
}"
76175,"/** 
 * Construct a constant source with the given container and name. Create the <i>value</i> parameter, initialize its value to the default value of an DoubleToken with value 1.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public SDFConst(TypedCompositeActor container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  value=new Parameter(this,""String_Node_Str"",new DoubleToken(1));
  output.setTypeEquals(BaseType.DOUBLE);
  ;
}","/** 
 * Construct a constant source with the given container and name. Create the <i>value</i> parameter, initialize its value to the default value of an IntToken with value 1.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public SDFConst(TypedCompositeActor container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  value=new Parameter(this,""String_Node_Str"",new IntToken(1));
  output.setTypeAtLeast(value);
}"
76176,"public String methodBody(){
  if (_construct) {
    StringBuffer sb=new StringBuffer();
    if (_superParams > 0) {
      Iterator argsItr=_superArgs.listIterator();
      sb.append(ident);
      sb.append(ident);
      sb.append(""String_Node_Str"");
      for (int i=0; i < _superParams; i++) {
        sb.append((String)argsItr.next());
        if (i < (_superParams - 1)) {
          sb.append(""String_Node_Str"");
        }
      }
      sb.append(""String_Node_Str"");
    }
    if (_defConstruct) {
      Iterator typeItr=_paramTypes.listIterator();
      Iterator nameItr=_paramNames.listIterator();
      Iterator varPlaceItr=_varPlacements.listIterator();
      int varCount=0;
      do {
        String typeStr=(String)typeItr.next();
        String nameStr=(String)nameItr.next();
        char placement=((Character)varPlaceItr.next()).charValue();
        if (varCount >= _superParams) {
          sb.append(ident);
          sb.append(ident);
switch (placement) {
case 'l':
            sb.append(""String_Node_Str"");
          sb.append(nameStr);
        sb.append(""String_Node_Str"");
      break;
case 'm':
case 'h':
    sb.append('_');
  sb.append(nameStr);
sb.append(""String_Node_Str"");
sb.append(nameStr);
sb.append(';');
break;
case 'p':
sb.append(""String_Node_Str"");
sb.append(nameStr);
sb.append(""String_Node_Str"");
sb.append(_wrapPrimitive(typeStr,nameStr));
sb.append(""String_Node_Str"");
break;
case 'n':
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
if (typeItr.hasNext()) {
sb.append('\n');
}
}
varCount++;
}
 while (typeItr.hasNext());
}
return sb.toString();
}
if (_methodBody != null) {
return ident + ident + _methodBody;
}
if (_returnType.equals(""String_Node_Str"") || _returnType.equals(""String_Node_Str"")) {
return ""String_Node_Str"";
}
if (_returnType.equals(""String_Node_Str"")) {
return ident + ident + ""String_Node_Str"";
}
if (_returnType.equals(""String_Node_Str"") || _returnType.equals(""String_Node_Str"") || _returnType.equals(""String_Node_Str"")) {
return ident + ident + ""String_Node_Str"";
}
if (_returnType.equals(""String_Node_Str"")) {
return ident + ident + ""String_Node_Str"";
}
if (_returnType.equals(""String_Node_Str"")) {
return ident + ident + ""String_Node_Str"";
}
if (_returnType.equals(""String_Node_Str"")) {
return ident + ident + ""String_Node_Str"";
}
if (_returnType.equals(""String_Node_Str"")) {
return ident + ident + ""String_Node_Str"";
}
return ident + ident + ""String_Node_Str"";
}","public String methodBody(){
  if (_methodBody != null) {
    return ident + ident + _methodBody;
  }
  if (_construct) {
    StringBuffer sb=new StringBuffer();
    if (_superParams > 0) {
      Iterator argsItr=_superArgs.listIterator();
      sb.append(ident + ident);
      sb.append(""String_Node_Str"");
      for (int i=0; i < _superParams; i++) {
        sb.append((String)argsItr.next());
        if (i < (_superParams - 1)) {
          sb.append(""String_Node_Str"");
        }
      }
      sb.append(""String_Node_Str"");
    }
    if (_defConstruct) {
      Iterator typeItr=_paramTypes.listIterator();
      Iterator nameItr=_paramNames.listIterator();
      Iterator varPlaceItr=_varPlacements.listIterator();
      int varCount=0;
      do {
        String typeStr=(String)typeItr.next();
        String nameStr=(String)nameItr.next();
        char placement=((Character)varPlaceItr.next()).charValue();
        if (varCount >= _superParams) {
          sb.append(ident);
          sb.append(ident);
switch (placement) {
case 'l':
            sb.append(""String_Node_Str"" + nameStr + ""String_Node_Str"");
          break;
case 'm':
case 'h':
        sb.append(""String_Node_Str"" + nameStr + ""String_Node_Str""+ nameStr+ ""String_Node_Str"");
      break;
case 'p':
    sb.append(""String_Node_Str"" + nameStr + ""String_Node_Str""+ _wrapPrimitive(typeStr,nameStr)+ ""String_Node_Str"");
  break;
case 'n':
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
if (typeItr.hasNext()) {
sb.append('\n');
}
}
varCount++;
}
 while (typeItr.hasNext());
}
return sb.toString();
}
if (_returnType.equals(""String_Node_Str"") || _returnType.equals(""String_Node_Str"")) {
return ""String_Node_Str"";
}
if (_returnType.equals(""String_Node_Str"")) {
return ident + ident + ""String_Node_Str"";
}
if (_returnType.equals(""String_Node_Str"") || _returnType.equals(""String_Node_Str"") || _returnType.equals(""String_Node_Str"")) {
return ident + ident + ""String_Node_Str"";
}
if (_returnType.equals(""String_Node_Str"")) {
return ident + ident + ""String_Node_Str"";
}
if (_returnType.equals(""String_Node_Str"")) {
return ident + ident + ""String_Node_Str"";
}
if (_returnType.equals(""String_Node_Str"")) {
return ident + ident + ""String_Node_Str"";
}
if (_returnType.equals(""String_Node_Str"")) {
return ident + ident + ""String_Node_Str"";
}
return ident + ident + ""String_Node_Str"";
}"
76177,"public MethodSignature(String name,int dummy){
  Character firstLetter=new Character(Character.toUpperCase(name.charAt(0)));
  String partName=firstLetter.toString() + name.substring(1);
  _name=""String_Node_Str"" + partName;
  _returnType=""String_Node_Str"";
  _methodBody=""String_Node_Str"";
}","/** 
 * A hasX() method that returns true. 
 */
public MethodSignature(String name,int dummy){
  _modifiers=""String_Node_Str"";
  Character firstLetter=new Character(Character.toUpperCase(name.charAt(0)));
  String partName=firstLetter.toString() + name.substring(1);
  _name=""String_Node_Str"" + partName;
  _returnType=""String_Node_Str"";
  _methodBody=""String_Node_Str"";
}"
76178,"protected void _generateNodeFile(String typeName,String parentTypeName,boolean isConcrete,boolean isSingleton,boolean isInterface,LinkedList methodList,LinkedList implList) throws IOException {
  File fdest=new File(typeName + ""String_Node_Str"");
  if (!fdest.createNewFile()) {
    fdest.delete();
    fdest=new File(typeName + ""String_Node_Str"");
    fdest.createNewFile();
  }
  FileWriter fw=new FileWriter(fdest);
  StringBuffer sb=new StringBuffer();
  sb.append(_nodeHeader);
  sb.append(""String_Node_Str"");
  boolean concreteClass=isConcrete && !isInterface;
  if (!isConcrete && !isInterface) {
    sb.append(""String_Node_Str"");
  }
 else   if (isSingleton) {
    sb.append(""String_Node_Str"");
  }
  sb.append(isInterface ? ""String_Node_Str"" : ""String_Node_Str"");
  sb.append(typeName);
  if (!parentTypeName.equals(""String_Node_Str"")) {
    sb.append(""String_Node_Str"");
    sb.append(parentTypeName);
  }
  Iterator implItr=implList.listIterator();
  if (implItr.hasNext()) {
    sb.append(""String_Node_Str"");
    do {
      String interfaceName=(String)implItr.next();
      sb.append(interfaceName);
      if (implItr.hasNext()) {
        sb.append(""String_Node_Str"");
      }
    }
 while (implItr.hasNext());
  }
  sb.append(""String_Node_Str"");
  String idString=null;
  if (concreteClass) {
    idString=typeName.toUpperCase() + ""String_Node_Str"";
    methodList.add(new ClassField(""String_Node_Str"",idString,""String_Node_Str"",Integer.toString(_classCount)));
    _classCount++;
  }
  Iterator methodItr=methodList.listIterator();
  while (methodItr.hasNext()) {
    Object o=methodItr.next();
    if (o instanceof MethodSignature) {
      sb.append(o.toString());
      sb.append('\n');
    }
  }
  methodItr=methodList.listIterator();
  while (methodItr.hasNext()) {
    Object o=methodItr.next();
    if (o instanceof ClassField) {
      sb.append(o.toString());
      sb.append('\n');
    }
  }
  if (concreteClass) {
    sb.append(""String_Node_Str"");
    sb.append(idString);
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  fw.write(sb.toString());
  fw.close();
}","protected void _generateNodeFile(String typeName,String parentTypeName,boolean isConcrete,boolean isSingleton,boolean isInterface,LinkedList methodList,LinkedList implList) throws IOException {
  File fdest=new File(typeName + ""String_Node_Str"");
  if (!fdest.createNewFile()) {
    fdest.delete();
    fdest=new File(typeName + ""String_Node_Str"");
    fdest.createNewFile();
  }
  FileWriter fw=new FileWriter(fdest);
  StringBuffer sb=new StringBuffer();
  sb.append(_nodeHeader);
  sb.append(""String_Node_Str"");
  boolean concreteClass=isConcrete && !isInterface;
  if (!isConcrete && !isInterface) {
    sb.append(""String_Node_Str"");
  }
 else   if (isSingleton) {
    sb.append(""String_Node_Str"");
  }
  sb.append(isInterface ? ""String_Node_Str"" : ""String_Node_Str"");
  sb.append(typeName);
  if (!parentTypeName.equals(""String_Node_Str"")) {
    sb.append(""String_Node_Str"");
    sb.append(parentTypeName);
  }
  Iterator implItr=implList.listIterator();
  if (implItr.hasNext()) {
    sb.append(""String_Node_Str"");
    do {
      String interfaceName=(String)implItr.next();
      sb.append(interfaceName);
      if (implItr.hasNext()) {
        sb.append(""String_Node_Str"");
      }
    }
 while (implItr.hasNext());
  }
  sb.append(""String_Node_Str"");
  if (concreteClass) {
    String idString=typeName.toUpperCase() + ""String_Node_Str"";
    methodList.add(new ClassField(""String_Node_Str"",idString,""String_Node_Str"",Integer.toString(_classCount)));
    methodList.add(new MethodSignature(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new LinkedList(),new LinkedList(),""String_Node_Str"" + idString + ""String_Node_Str""));
    _classCount++;
  }
  if (isSingleton) {
    ClassField cf=new ClassField(typeName,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + typeName + ""String_Node_Str"");
    methodList.addLast(cf);
    MethodSignature ms=new MethodSignature(typeName);
    methodList.addLast(ms);
    methodList.add(new MethodSignature(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new LinkedList(),new LinkedList(),""String_Node_Str""));
  }
  Iterator methodItr=methodList.listIterator();
  while (methodItr.hasNext()) {
    Object o=methodItr.next();
    if (o instanceof MethodSignature) {
      sb.append(o.toString() + ""String_Node_Str"");
    }
  }
  methodItr=methodList.listIterator();
  while (methodItr.hasNext()) {
    Object o=methodItr.next();
    if (o instanceof ClassField) {
      sb.append(o.toString() + ""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  fw.write(sb.toString());
  fw.close();
}"
76179,"public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(ident);
  sb.append(_modifiers);
  sb.append(' ');
  sb.append(_type);
  sb.append(' ');
  if (!_modifiers.startsWith(""String_Node_Str"")) {
    sb.append(""String_Node_Str"");
  }
  sb.append(_name);
  if (_init != null) {
    sb.append(""String_Node_Str"");
    sb.append(_init);
  }
  sb.append(';');
  return sb.toString();
}","public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(ident);
  sb.append(_modifiers);
  sb.append(' ');
  sb.append(_type);
  sb.append(' ');
  if (!_modifiers.startsWith(""String_Node_Str"")) {
    sb.append(""String_Node_Str"");
  }
  sb.append(_name);
  if (_init != null) {
    sb.append(""String_Node_Str"" + _init);
  }
  sb.append(';');
  return sb.toString();
}"
76180,"protected String _readBlock(String marker) throws IOException {
  while ((_lastLine != null) && _lastLine.equals(""String_Node_Str"")) {
    _lastLine=_ifs.readLine();
  }
  String beginTag=""String_Node_Str"" + marker + ""String_Node_Str"";
  String endTag=""String_Node_Str"" + marker + ""String_Node_Str"";
  if ((_lastLine == null) || !_lastLine.equals(beginTag)) {
    return ""String_Node_Str"";
  }
  StringBuffer sb=new StringBuffer();
  boolean endHeader=false;
  do {
    _lastLine=_ifs.readLine();
    endHeader=((_lastLine == null) || _lastLine.equals(endTag));
    if (!endHeader) {
      sb.append(_lastLine);
      sb.append('\n');
    }
  }
 while (!endHeader);
  _lastLine=_ifs.readLine();
  sb.append('\n');
  return sb.toString();
}","protected String _readBlock(String marker) throws IOException {
  while ((_lastLine != null) && _lastLine.equals(""String_Node_Str"")) {
    _lastLine=_ifs.readLine();
  }
  String beginTag=""String_Node_Str"" + marker + ""String_Node_Str"";
  String endTag=""String_Node_Str"" + marker + ""String_Node_Str"";
  if ((_lastLine == null) || !_lastLine.equals(beginTag)) {
    return ""String_Node_Str"";
  }
  StringBuffer sb=new StringBuffer();
  boolean endHeader=false;
  do {
    _lastLine=_ifs.readLine();
    endHeader=((_lastLine == null) || _lastLine.equals(endTag));
    if (!endHeader) {
      sb.append(_lastLine + ""String_Node_Str"");
    }
  }
 while (!endHeader);
  _lastLine=_ifs.readLine();
  sb.append('\n');
  return sb.toString();
}"
76181,"protected void _readClassInfo() throws IOException {
  StringTokenizer strTokenizer;
  String className;
  String marker;
  do {
    if ((_lastLine != null) && (_lastLine.length() > 4) && !(_lastLine.startsWith(""String_Node_Str""))) {
      strTokenizer=new StringTokenizer(_lastLine);
      className=strTokenizer.nextToken();
      ApplicationUtility.trace(""String_Node_Str"" + className);
      try {
        _typeList.addLast(className);
      }
 catch (      NullPointerException e) {
        System.err.println(""String_Node_Str"" + _lastLine);
        return;
      }
      String nextToken=strTokenizer.nextToken();
      boolean isSingleton;
      boolean isInterface;
      try {
        isSingleton=nextToken.startsWith(""String_Node_Str"");
        _isSingletonList.addLast(new Boolean(isSingleton));
        _isConcreteList.addLast(new Boolean(isSingleton || nextToken.startsWith(""String_Node_Str"")));
        isInterface=nextToken.startsWith(""String_Node_Str"");
        _isInterfaceList.addLast(new Boolean(isInterface));
        _isInTreeList.addLast(new Boolean(!nextToken.endsWith(""String_Node_Str"")));
      }
 catch (      NullPointerException e) {
        System.err.println(""String_Node_Str"" + _lastLine);
        return;
      }
      try {
        nextToken=strTokenizer.nextToken();
        _parentTypeList.addLast(nextToken);
      }
 catch (      NullPointerException e) {
        System.err.println(""String_Node_Str"" + _lastLine);
        return;
      }
      LinkedList methodList=new LinkedList();
      LinkedList implList=new LinkedList();
      if (isSingleton) {
        ClassField cf=new ClassField(className,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + className + ""String_Node_Str"");
        methodList.addLast(cf);
        MethodSignature ms=new MethodSignature(className);
        methodList.addLast(ms);
      }
      while (strTokenizer.hasMoreTokens()) {
        marker=strTokenizer.nextToken();
        char markChar=marker.charAt(0);
switch (markChar) {
case 'c':
case 'm':
{
            MethodSignature ms=new MethodSignature(markChar,strTokenizer,className,_defaultPlacement,isInterface);
            methodList.addLast(ms);
          }
        break;
case 'k':
{
        MethodSignature ms=new MethodSignature(markChar,strTokenizer,className,_defaultPlacement,isInterface);
        methodList.addLast(ms);
        LinkedList accessorMethodList=ms.accessors();
        methodList.addAll(accessorMethodList);
      }
    break;
case 'i':
{
    boolean isName;
    do {
      nextToken=strTokenizer.nextToken();
      isName=((nextToken != null) && !nextToken.equals(""String_Node_Str""));
      if (isName) {
        implList.addLast(nextToken);
      }
    }
 while (isName);
  }
break;
default :
throw new RuntimeException(""String_Node_Str"" + marker);
}
}
_methodListList.addLast(methodList);
_implListList.addLast(implList);
}
_lastLine=_ifs.readLine();
}
 while (_lastLine != null);
}","protected void _readClassInfo() throws IOException {
  StringTokenizer strTokenizer;
  String className;
  String marker;
  do {
    if ((_lastLine != null) && (_lastLine.length() > 4) && !(_lastLine.startsWith(""String_Node_Str""))) {
      strTokenizer=new StringTokenizer(_lastLine);
      className=strTokenizer.nextToken();
      ApplicationUtility.trace(""String_Node_Str"" + className);
      try {
        _typeList.addLast(className);
      }
 catch (      NullPointerException e) {
        System.err.println(""String_Node_Str"" + _lastLine);
        return;
      }
      String nextToken=strTokenizer.nextToken();
      boolean isSingleton;
      boolean isInterface;
      try {
        isSingleton=nextToken.startsWith(""String_Node_Str"");
        _isSingletonList.addLast(new Boolean(isSingleton));
        _isConcreteList.addLast(new Boolean(isSingleton || nextToken.startsWith(""String_Node_Str"")));
        isInterface=nextToken.startsWith(""String_Node_Str"");
        _isInterfaceList.addLast(new Boolean(isInterface));
        _isInTreeList.addLast(new Boolean(!nextToken.endsWith(""String_Node_Str"")));
      }
 catch (      NullPointerException e) {
        System.err.println(""String_Node_Str"" + _lastLine);
        return;
      }
      try {
        nextToken=strTokenizer.nextToken();
        _parentTypeList.addLast(nextToken);
      }
 catch (      NullPointerException e) {
        System.err.println(""String_Node_Str"" + _lastLine);
        return;
      }
      LinkedList methodList=new LinkedList();
      LinkedList implList=new LinkedList();
      while (strTokenizer.hasMoreTokens()) {
        marker=strTokenizer.nextToken();
        char markChar=marker.charAt(0);
switch (markChar) {
case 'c':
case 'm':
{
            MethodSignature ms=new MethodSignature(markChar,strTokenizer,className,_defaultPlacement,isInterface);
            methodList.addLast(ms);
          }
        break;
case 'k':
{
        MethodSignature ms=new MethodSignature(markChar,strTokenizer,className,_defaultPlacement,isInterface);
        methodList.addLast(ms);
        LinkedList accessorMethodList=ms.accessors();
        methodList.addAll(accessorMethodList);
      }
    break;
case 'i':
{
    boolean isName;
    do {
      nextToken=strTokenizer.nextToken();
      isName=((nextToken != null) && !nextToken.equals(""String_Node_Str""));
      if (isName) {
        implList.addLast(nextToken);
      }
    }
 while (isName);
  }
break;
default :
throw new RuntimeException(""String_Node_Str"" + marker);
}
}
_methodListList.addLast(methodList);
_implListList.addLast(implList);
}
_lastLine=_ifs.readLine();
}
 while (_lastLine != null);
}"
76182,"/** 
 * Define a property. Return false if the property is already defined. 
 */
public boolean defineProperty(Object property){
  Object obj=setProperty(property,NullValue.instance);
  return (obj == null);
}","/** 
 * Define a property. Return false if the property is already defined. 
 */
public boolean defineProperty(Integer property){
  Object obj=setProperty(property,NullValue.instance);
  return (obj == null);
}"
76183,"/** 
 * Get a property. Throw a RuntimeException if the property in not defined. 
 */
public Object getDefinedProperty(Object property){
  Object retval=_propertyMap.get(property);
  if (retval == null) {
    throw new RuntimeException(""String_Node_Str"" + property + ""String_Node_Str"");
  }
  return retval;
}","/** 
 * Get a property. Throw a RuntimeException if the property in not defined. 
 */
public Object getDefinedProperty(Integer property){
  Object retval=_propertyMap.get(property);
  if (retval == null) {
    throw new RuntimeException(""String_Node_Str"" + property + ""String_Node_Str"");
  }
  return retval;
}"
76184,"/** 
 * Get a property. If the property is not defined, returned null. 
 */
public Object getProperty(Object property){
  return _propertyMap.get(property);
}","/** 
 * Get a property. If the property is not defined, returned null. 
 */
public Object getProperty(Integer property){
  return _propertyMap.get(property);
}"
76185,"/** 
 * Set a property. The property may or may not have been defined already. 
 */
public Object setProperty(Object property,Object obj){
  if (obj == null) {
    obj=NullValue.instance;
  }
  return _propertyMap.put(property,obj);
}","/** 
 * Set a property. The property may or may not have been defined already. 
 */
public Object setProperty(Integer property,Object obj){
  if (obj == null) {
    obj=NullValue.instance;
  }
  return _propertyMap.put(property,obj);
}"
76186,"/** 
 * Set a property. Throw a RuntimeException if the property in not defined. 
 */
public Object setDefinedProperty(Object property,Object obj){
  if (obj == null) {
    obj=NullValue.instance;
  }
  Object retval=_propertyMap.put(property,obj);
  if (retval == null) {
    throw new RuntimeException(""String_Node_Str"" + property + ""String_Node_Str"");
  }
  return retval;
}","/** 
 * Set a property. Throw a RuntimeException if the property in not defined. 
 */
public Object setDefinedProperty(Integer property,Object obj){
  if (obj == null) {
    obj=NullValue.instance;
  }
  Object retval=_propertyMap.put(property,obj);
  if (retval == null) {
    throw new RuntimeException(""String_Node_Str"" + property + ""String_Node_Str"");
  }
  return retval;
}"
76187,"/** 
 * Remove a property, returning the value of the property if the property is defined. If the property is not defined, return null.
 */
public Object removeProperty(Object property){
  return _propertyMap.remove(property);
}","/** 
 * Remove a property, returning the value of the property if the property is defined. If the property is not defined, return null.
 */
public Object removeProperty(Integer property){
  return _propertyMap.remove(property);
}"
76188,"/** 
 * Return true iff this instance has the specified property. 
 */
public boolean hasProperty(Object property){
  return _propertyMap.containsKey(property);
}","/** 
 * Return true iff this instance has the specified property. 
 */
public boolean hasProperty(Integer property){
  return _propertyMap.containsKey(property);
}"
76189,"public static final LinkedList traverseList(IVisitor v,TreeNode parent,LinkedList args,List childList){
  boolean anyNonNullRetval=false;
  Object retval;
  LinkedList retList=new LinkedList();
  Iterator itr=childList.listIterator();
  while (itr.hasNext()) {
    Object obj=itr.next();
    if (obj instanceof TreeNode) {
      TreeNode node=(TreeNode)obj;
      retval=node.accept(v,args);
      if (retval == null) {
        retList.addLast(NullValue.instance);
      }
 else {
        retList.addLast(retval);
      }
    }
 else     if (obj instanceof List) {
      retval=(Object)traverseList(v,null,args,(List)obj);
      retList.addLast(retval);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + obj.getClass());
    }
  }
  return retList;
}","public static final LinkedList traverseList(IVisitor v,TreeNode parent,LinkedList args,List childList){
  Object retval;
  LinkedList retList=new LinkedList();
  Iterator itr=childList.listIterator();
  while (itr.hasNext()) {
    Object obj=itr.next();
    if (obj instanceof TreeNode) {
      TreeNode node=(TreeNode)obj;
      retval=node.accept(v,args);
      if (retval == null) {
        retList.addLast(NullValue.instance);
      }
 else {
        retList.addLast(retval);
      }
    }
 else     if (obj instanceof List) {
      retval=(Object)traverseList(v,null,args,(List)obj);
      retList.addLast(retval);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + obj.getClass());
    }
  }
  return retList;
}"
76190,"public Object childReturnValueAt(int index){
  LinkedList retList=(LinkedList)getDefinedProperty(""String_Node_Str"");
  return retList.get(index);
}","public Object childReturnValueAt(int index){
  LinkedList retList=(LinkedList)getDefinedProperty(CHILD_RETURN_VALUES_KEY);
  return retList.get(index);
}"
76191,"public Object accept(IVisitor v,LinkedList visitorArgs){
  Object retval;
switch (v.traversalMethod()) {
case IVisitor.TM_CHILDREN_FIRST:
{
      traverseChildren(v,visitorArgs);
      retval=acceptHere(v,visitorArgs);
      removeProperty(""String_Node_Str"");
    }
  break;
case IVisitor.TM_SELF_FIRST:
{
  retval=acceptHere(v,visitorArgs);
  traverseChildren(v,visitorArgs);
}
break;
case IVisitor.TM_CUSTOM:
{
retval=acceptHere(v,visitorArgs);
}
break;
default :
{
throw new RuntimeException(""String_Node_Str"");
}
}
return retval;
}","public Object accept(IVisitor v,LinkedList visitorArgs){
  Object retval;
switch (v.traversalMethod()) {
case IVisitor.TM_CHILDREN_FIRST:
{
      traverseChildren(v,visitorArgs);
      retval=acceptHere(v,visitorArgs);
      removeProperty(CHILD_RETURN_VALUES_KEY);
    }
  break;
case IVisitor.TM_SELF_FIRST:
{
  retval=acceptHere(v,visitorArgs);
  traverseChildren(v,visitorArgs);
}
break;
case IVisitor.TM_CUSTOM:
{
retval=acceptHere(v,visitorArgs);
}
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
return retval;
}"
76192,"public Object childReturnValueFor(Object child){
  ListIterator itr=_childList.listIterator();
  int index=0;
  while (itr.hasNext()) {
    if (child == itr.next()) {
      return childReturnValueAt(index);
    }
    index++;
  }
  ApplicationUtility.error(""String_Node_Str"");
  return null;
}","public Object childReturnValueFor(Object child){
  Iterator itr=_childList.iterator();
  int index=0;
  while (itr.hasNext()) {
    if (child == itr.next()) {
      return childReturnValueAt(index);
    }
    index++;
  }
  ApplicationUtility.error(""String_Node_Str"");
  return null;
}"
76193,"public void traverseChildren(IVisitor v,LinkedList args){
  LinkedList retList=TNLManip.traverseList(v,this,args,_childList);
  setProperty(""String_Node_Str"",retList);
}","public void traverseChildren(IVisitor v,LinkedList args){
  LinkedList retList=TNLManip.traverseList(v,this,args,_childList);
  setProperty(CHILD_RETURN_VALUES_KEY,retList);
}"
76194,"/** 
 * Construct a scheduler in the given workspace with the name ""Scheduler"". If the workspace argument is null, use the default workspace. The scheduler is added to the list of objects in the workspace. Increment the version number of the workspace.
 * @param workspace Object for synchronization and version tracking.
 */
public Scheduler(Workspace ws){
  super(ws);
  try {
    setName(_DEFAULT_SCHEDULER_NAME);
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(ex.toString());
  }
}","/** 
 * Construct a scheduler in the given workspace with the name ""Scheduler"". If the workspace argument is null, use the default workspace. The scheduler is added to the list of objects in the workspace. Increment the version number of the workspace.
 * @param workspace Object for synchronization and version tracking.
 */
public Scheduler(Workspace workspace){
  super(workspace);
  try {
    setName(_DEFAULT_SCHEDULER_NAME);
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(ex.toString());
  }
}"
76195,"/** 
 * Clone the scheduler into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new scheduler with no container, and no valid schedule.
 * @param ws The workspace for the cloned object.
 * @exception CloneNotSupportedException If one of the attributescannot be cloned.
 * @return The new Scheduler.
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  Scheduler newobj=(Scheduler)super.clone(ws);
  newobj._container=null;
  newobj._valid=false;
  newobj._cachedSchedule=null;
  return newobj;
}","/** 
 * Clone the scheduler into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new scheduler with no container, and no valid schedule.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If one of the attributescannot be cloned.
 * @return The new Scheduler.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Scheduler newobj=(Scheduler)super.clone(workspace);
  newobj._container=null;
  newobj._valid=false;
  newobj._cachedSchedule=null;
  return newobj;
}"
76196,"/** 
 * Notify this query that the value of the specified variable has changed.  This is called by an attached parameter when its value changes.
 * @param variable The variable that has changed.
 */
public void valueChanged(Variable variable){
  if (_listening) {
    set(variable.getName(),variable.stringRepresentation());
  }
}","/** 
 * Notify this query that the value of the specified variable has changed.  This is called by an attached parameter when its value changes. Note that more than one entry may be attached to the same variable. In this case, all such entries will be notified.
 * @param variable The variable that has changed.
 */
public void valueChanged(Variable variable){
  if (_parameters.containsValue(variable)) {
    List entryNameList=(List)_varToListOfEntries.get(variable);
    Iterator entryNames=entryNameList.iterator();
    while (entryNames.hasNext()) {
      String name=(String)entryNames.next();
      Map ignoreVarChangePart2=(Map)_ignoreVarChangePart1.get(variable);
      if (((Boolean)ignoreVarChangePart2.get(name)).booleanValue() == false) {
        set(name,variable.stringRepresentation());
        _ignoreEntryChange.put(name,new Boolean(true));
      }
 else {
        ignoreVarChangePart2.put(name,new Boolean(false));
      }
    }
  }
 else {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + variable.getFullName());
  }
}"
76197,"/** 
 * Construct a panel with no queries in it.
 */
public PtolemyQuery(){
  super();
  this.addQueryListener(this);
  _parameters=new HashMap();
}","/** 
 * Construct a panel with no queries in it. When an entry changes, a change request is queued with the director. The director will then schedule the corresponding variable's value to be updated at an appropriate time in  the execution of the model. Note that only one PtolemyQuerey object is allowed per director. 
 * @param director The director for a model. This shouldbe the director associated with all variables that are attached to query entries.
 */
public PtolemyQuery(Director director){
  super();
  _constructorDirector=true;
  this.addQueryListener(this);
  _parameters=new HashMap();
  this._director=director;
  _ignoreValueChanged=0;
  _ignoreChanged=0;
  _varToListOfEntries=new HashMap();
  _ignoreEntryChange=new HashMap();
  _ignoreVarChangePart1=new HashMap();
}"
76198,"/** 
 * Attach a variable <i>var</i> to an entry, <i>entryName</i>, of a Query. After attaching the <i>var</i> to the entry, automatically set <i>var</i> when <i>entryName</i> changes. If <i>var</i> has previously been attached to an entry, then the old value is replaced with <i>entryName</i>.
 * @param var The variable to attach to an entry.
 * @param entryName The entry to attach the variable to.
 */
public void attachParameter(Variable var,String entryName){
  _parameters.put(entryName,var);
  var.addValueListener(this);
  String tip=Documentation.consolidate(var);
  if (tip != null) {
    setToolTip(entryName,tip);
  }
}","/** 
 * Attach a variable <i>var</i> to an entry, <i>entryName</i>, of a Query. After attaching the <i>var</i> to the entry, automatically set <i>var</i> when <i>entryName</i> changes. If <i>var</i> has previously been attached to an entry, then the old value is replaced with <i>entryName</i>.
 * @param var The variable to attach to an entry.
 * @param entryName The entry to attach the variable to.
 */
public void attachParameter(Variable var,String entryName){
  _parameters.put(entryName,var);
  var.addValueListener(this);
  String tip=Documentation.consolidate(var);
  if (tip != null) {
    setToolTip(entryName,tip);
  }
  if (_varToListOfEntries.get(var) == null) {
    List entryNameList=new LinkedList();
    entryNameList.add(entryName);
    _varToListOfEntries.put(var,entryNameList);
  }
 else {
    List entryNameList=(List)_varToListOfEntries.get(var);
    Iterator entryNames=entryNameList.iterator();
    boolean found=false;
    while (entryNames.hasNext()) {
      String name=(String)entryNames.next();
      if (name == entryName) {
        found=true;
      }
    }
    if (found == false) {
      entryNameList.add(entryName);
    }
  }
  if (_ignoreEntryChange.containsKey(entryName) == false) {
    _ignoreEntryChange.put(entryName,new Boolean(false));
  }
  if (_ignoreVarChangePart1.containsKey(var) == false) {
    Map ignoreVarChangePart2=new HashMap();
    ignoreVarChangePart2.put(entryName,new Boolean(false));
    _ignoreVarChangePart1.put(var,ignoreVarChangePart2);
  }
 else {
    Map ignoreVarChangePart2=(Map)_ignoreVarChangePart1.get(var);
    if (ignoreVarChangePart2.containsKey(entryName) == false) {
      ignoreVarChangePart2.put(entryName,new Boolean(false));
      ;
    }
  }
}"
76199,"/** 
 * Set the Variable to the value of the Query entry. This method is called whenever an entry changes.
 * @param name The entry that has changed.
 */
public void changed(String name){
  if (_parameters.containsKey(name)) {
    Variable var=(Variable)(_parameters.get(name));
    _listening=false;
    var.setExpression(stringValue(name));
    try {
      var.getToken();
    }
 catch (    IllegalActionException ex) {
    }
    _listening=true;
  }
}","/** 
 * Set the variable to the value of the Query entry. This method is called whenever an entry changes.
 * @param name The name of the entry that has changed.
 */
public void changed(String name){
  if (_parameters.containsKey(name)) {
    Variable var=(Variable)(_parameters.get(name));
    if (((Boolean)_ignoreEntryChange.get(name)).booleanValue() == false) {
      _ignoreValueChanged=_ignoreValueChanged + 1;
      if (_constructorDirector == false) {
        _director=((Actor)var.getContainer()).getDirector();
      }
      if (_director == null) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + var.getFullName());
      }
      _director.requestChange(new SetParameter((Parameter)var,(Parameter)var,stringValue(name)));
    }
 else {
      _ignoreEntryChange.put(name,new Boolean(false));
    }
  }
}"
76200,"/** 
 * Output the sample value of the sound file corresponding to the current index.
 */
public void fire() throws IllegalActionException {
}","/** 
 * Output the sample value of the sound file corresponding to the current index.
 */
public void fire() throws IllegalActionException {
  input.getArray(0,audioTokenArray);
  int i;
  for (i=0; i < consumptionRate; i++) {
    audioInDoubleArray[i]=audioTokenArray[i].doubleValue();
  }
  double[] currPitchArray=pd.performPitchDetect(audioInDoubleArray);
  for (i=0; i < productionRate; i++) {
    audioTokenArray[i]=new DoubleToken(currPitchArray[i]);
  }
  output.sendArray(0,audioTokenArray);
}"
76201,"/** 
 * Construct an actor with the given container and name. In addition to invoking the base class constructors, construct the parameters and initialize them to their default vaules.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public AudioSource(TypedCompositeActor container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new SDFIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(BaseType.DOUBLE);
  output.setMultiport(true);
  pathName=new Parameter(this,""String_Node_Str"",new StringToken(""String_Node_Str""));
  source=new Parameter(this,""String_Node_Str"",new StringToken(""String_Node_Str""));
  source.setTypeEquals(BaseType.STRING);
  sampleRate=new Parameter(this,""String_Node_Str"",new IntToken(44100));
  sampleRate.setTypeEquals(BaseType.INT);
  sampleSizeInBits=new Parameter(this,""String_Node_Str"",new IntToken(16));
  sampleSizeInBits.setTypeEquals(BaseType.INT);
  channels=new Parameter(this,""String_Node_Str"",new IntToken(1));
  channels.setTypeEquals(BaseType.INT);
  bufferSize=new Parameter(this,""String_Node_Str"",new IntToken(4096));
  bufferSize.setTypeEquals(BaseType.INT);
  tokenProductionRate=new Parameter(this,""String_Node_Str"",new IntToken(256));
}","/** 
 * Construct an actor with the given container and name. In addition to invoking the base class constructors, construct the parameters and initialize them to their default values.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public AudioSource(TypedCompositeActor container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new SDFIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(BaseType.DOUBLE);
  output.setMultiport(true);
  pathName=new Parameter(this,""String_Node_Str"",new StringToken(""String_Node_Str""));
  source=new Parameter(this,""String_Node_Str"",new StringToken(""String_Node_Str""));
  source.setTypeEquals(BaseType.STRING);
  sampleRate=new Parameter(this,""String_Node_Str"",new IntToken(44100));
  sampleRate.setTypeEquals(BaseType.INT);
  sampleSizeInBits=new Parameter(this,""String_Node_Str"",new IntToken(16));
  sampleSizeInBits.setTypeEquals(BaseType.INT);
  channels=new Parameter(this,""String_Node_Str"",new IntToken(1));
  channels.setTypeEquals(BaseType.INT);
  bufferSize=new Parameter(this,""String_Node_Str"",new IntToken(4096));
  bufferSize.setTypeEquals(BaseType.INT);
  tokenProductionRate=new Parameter(this,""String_Node_Str"",new IntToken(256));
}"
76202,"/** 
 * Check parameters and begin the sound capture process. If the capture source is a sound file, the file is reopened and caputre is reset to the begining of the file.
 * @exception IllegalActionException If the parametersare out of range.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    String theURL=((StringToken)pathName.getToken()).toString();
    _soundCapture=new SoundCapture(true,theURL,_productionRate);
    _soundCapture.startCapture();
    _channels=_soundCapture.getChannels();
    channels.setToken(new IntToken(_channels));
  }
 else   if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    String theFileName=((StringToken)pathName.getToken()).toString();
    _soundCapture=new SoundCapture(false,theFileName,_productionRate);
    _soundCapture.startCapture();
    _channels=_soundCapture.getChannels();
    channels.setToken(new IntToken(_channels));
  }
 else   if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    int getSamplesSizeInt=_productionRate;
    _soundCapture=new SoundCapture((float)sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,getSamplesSizeInt);
    _soundCapture.startCapture();
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + source.getFullName() + ""String_Node_Str"");
  }
  _audioTokenArray=new DoubleToken[_productionRate];
}","/** 
 * Check parameters and begin the sound capture process. If the capture source is a sound file, the file is reopened and capture is reset to the beginning of the file.
 * @exception IllegalActionException If the parametersare out of range.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    String theURL=((StringToken)pathName.getToken()).toString();
    _soundCapture=new SoundCapture(true,theURL,_productionRate);
    _soundCapture.startCapture();
    _channels=_soundCapture.getChannels();
    channels.setToken(new IntToken(_channels));
  }
 else   if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    String theFileName=((StringToken)pathName.getToken()).toString();
    _soundCapture=new SoundCapture(false,theFileName,_productionRate);
    _soundCapture.startCapture();
    _channels=_soundCapture.getChannels();
    channels.setToken(new IntToken(_channels));
  }
 else   if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    int getSamplesSizeInt=_productionRate;
    _soundCapture=new SoundCapture((float)sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,getSamplesSizeInt);
    _soundCapture.startCapture();
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + source.getFullName() + ""String_Node_Str"");
  }
  _audioTokenArray=new DoubleToken[_productionRate];
}"
76203,"/** 
 * Construct a NoTokenException originating from the given object, with the given error message.
 * @param obj The originating object.
 * @param message The message.
 */
public NoTokenException(Nameable obj,String detail){
  String name;
  if (obj == null) {
    name=new String(""String_Node_Str"");
    ;
  }
 else {
    try {
      name=obj.getFullName();
    }
 catch (    InvalidStateException ex) {
      name=obj.getName();
    }
  }
  _setMessage(name + ""String_Node_Str"" + detail);
}","/** 
 * Construct a NoTokenException originating from the given object, with the given error message.
 * @param obj The originating object.
 * @param message The message.
 */
public NoTokenException(Nameable obj,String message){
  String name;
  if (obj == null) {
    name=new String(""String_Node_Str"");
    ;
  }
 else {
    try {
      name=obj.getFullName();
    }
 catch (    InvalidStateException ex) {
      name=obj.getName();
    }
  }
  _setMessage(name + ""String_Node_Str"" + message);
}"
76204,"/** 
 * Remove a change listener. If the specified listener is not on the list, do nothing.
 * @param listener The listener to remove.
 */
public void removeChangeListener(ChangeListener change){
  if (_changeListeners == null) {
    return;
  }
  _changeListeners.remove(change);
}","/** 
 * Remove a change listener. If the specified listener is not on the list, do nothing.
 * @param listener The listener to remove.
 */
public void removeChangeListener(ChangeListener listener){
  if (_changeListeners == null) {
    return;
  }
  _changeListeners.remove(listener);
}"
76205,"/** 
 * Set the state of execution and notify listeners if the state actually changes.
 * @param newstate The new state.
 */
protected void _setState(State newstate){
  if (_state != newstate) {
    _state=newstate;
    _notifyListenersOfStateChange();
  }
}","/** 
 * Set the state of execution and notify listeners if the state actually changes.
 * @param newState The new state.
 */
protected void _setState(State newState){
  if (_state != newState) {
    _state=newState;
    _notifyListenersOfStateChange();
  }
}"
76206,"/** 
 * Construct an IOPort with a container and a name that is either an input, an output, or both, depending on the third and fourth arguments. The specified container must implement the Actor interface or an exception will be thrown.
 * @param container The container actor.
 * @param name The name of the port.
 * @param isinput True if this is to be an input port.
 * @param isoutput True if this is to be an output port.
 * @exception IllegalActionException If the port is not of an acceptableclass for the container, or if the container does not implement the Actor interface.
 * @exception NameDuplicationException If the name coincides witha port already in the container.
 */
public IOPort(ComponentEntity container,String name,boolean isinput,boolean isoutput) throws IllegalActionException, NameDuplicationException {
  this(container,name);
  setInput(isinput);
  setOutput(isoutput);
}","/** 
 * Construct an IOPort with a container and a name that is either an input, an output, or both, depending on the third and fourth arguments. The specified container must implement the Actor interface or an exception will be thrown.
 * @param container The container actor.
 * @param name The name of the port.
 * @param isInput True if this is to be an input port.
 * @param isOutput True if this is to be an output port.
 * @exception IllegalActionException If the port is not of an acceptableclass for the container, or if the container does not implement the Actor interface.
 * @exception NameDuplicationException If the name coincides witha port already in the container.
 */
public IOPort(ComponentEntity container,String name,boolean isInput,boolean isOutput) throws IllegalActionException, NameDuplicationException {
  this(container,name);
  setInput(isInput);
  setOutput(isOutput);
}"
76207,"/** 
 * Get a token from the specified channel. If the channel has a group with more than one receiver (something that is possible if this is a transparent port), then this method calls get() on all receivers, but returns only the first non-null token returned by these calls. Normally this method is not used on transparent ports. If there is no token to return, then throw an exception. <p> Some of this method is read-synchronized on the workspace. Since it is possible for a thread to block while executing a get, it is important that the thread does not hold read access on the workspace when it is blocked. Thus this method releases read access on the workspace before calling get.
 * @param channelindex The channel index.
 * @return A token from the specified channel.
 * @exception NoTokenException If there is no token.
 * @exception IllegalActionException If there is no director, and henceno receivers have been created, if the port is not an input port, or if the channel index is out of range.
 */
public Token get(int channelindex) throws NoTokenException, IllegalActionException {
  Receiver[][] localRec;
  try {
    try {
      _workspace.getReadAccess();
      localRec=getReceivers();
      if (localRec[channelindex] == null) {
        throw new NoTokenException(this,""String_Node_Str"" + channelindex + ""String_Node_Str"");
      }
    }
  finally {
      _workspace.doneReading();
    }
    Token tt=null;
    for (int j=0; j < localRec[channelindex].length; j++) {
      Token ttt=localRec[channelindex][j].get();
      if (tt == null)       tt=ttt;
    }
    if (tt == null) {
      throw new NoTokenException(this,""String_Node_Str"");
    }
    return tt;
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * Get a token from the specified channel. If the channel has a group with more than one receiver (something that is possible if this is a transparent port), then this method calls get() on all receivers, but returns only the first non-null token returned by these calls. Normally this method is not used on transparent ports. If there is no token to return, then throw an exception. <p> Some of this method is read-synchronized on the workspace. Since it is possible for a thread to block while executing a get, it is important that the thread does not hold read access on the workspace when it is blocked. Thus this method releases read access on the workspace before calling get.
 * @param channelIndex The channel index.
 * @return A token from the specified channel.
 * @exception NoTokenException If there is no token.
 * @exception IllegalActionException If there is no director, and henceno receivers have been created, if the port is not an input port, or if the channel index is out of range.
 */
public Token get(int channelIndex) throws NoTokenException, IllegalActionException {
  Receiver[][] localRec;
  try {
    try {
      _workspace.getReadAccess();
      localRec=getReceivers();
      if (localRec[channelIndex] == null) {
        throw new NoTokenException(this,""String_Node_Str"" + channelIndex + ""String_Node_Str"");
      }
    }
  finally {
      _workspace.doneReading();
    }
    Token tt=null;
    for (int j=0; j < localRec[channelIndex].length; j++) {
      Token ttt=localRec[channelIndex][j].get();
      if (tt == null)       tt=ttt;
    }
    if (tt == null) {
      throw new NoTokenException(this,""String_Node_Str"");
    }
    return tt;
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
76208,"/** 
 * Return true if the specified channel can accept a token via the put() method.  If this port is not an output, or the channel index is out of range, then throws IllegalActionException.  If there are multiple receivers in the group associated with the channel, then return true only if all the receivers can accept a token.
 * @param channelindex The channel index.
 * @return True if there is room for a token in the channel.
 * @exception IllegalActionException If the receivers do not supportthis query, if this is not an output port, or if the channel index is out of range.
 */
public boolean hasRoom(int channelindex) throws IllegalActionException {
  try {
    Receiver[][] farRecs=getRemoteReceivers();
    if (farRecs == null || farRecs[channelindex] == null) {
      return false;
    }
    for (int j=0; j < farRecs[channelindex].length; j++) {
      if (!farRecs[channelindex][j].hasRoom())       return false;
    }
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  return true;
}","/** 
 * Return true if the specified channel can accept a token via the put() method.  If this port is not an output, or the channel index is out of range, then throws IllegalActionException.  If there are multiple receivers in the group associated with the channel, then return true only if all the receivers can accept a token.
 * @param channelIndex The channel index.
 * @return True if there is room for a token in the channel.
 * @exception IllegalActionException If the receivers do not supportthis query, if this is not an output port, or if the channel index is out of range.
 */
public boolean hasRoom(int channelIndex) throws IllegalActionException {
  try {
    Receiver[][] farRecs=getRemoteReceivers();
    if (farRecs == null || farRecs[channelIndex] == null) {
      return false;
    }
    for (int j=0; j < farRecs[channelIndex].length; j++) {
      if (!farRecs[channelIndex][j].hasRoom())       return false;
    }
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  return true;
}"
76209,"/** 
 * If the argument is true, make the port an output port. If the argument is false, make the port not an output port. This has no effect if the port is a transparent port that is linked on the inside to output ports.  In that case, the port is an output port regardless of whether and how this method is called. This method is write-synchronized on the workspace.
 * @param isoutput True to make the port an output.
 */
public void setOutput(boolean isoutput){
  _workspace.getWriteAccess();
  _isoutput=isoutput;
  _workspace.doneWriting();
}","/** 
 * If the argument is true, make the port an output port. If the argument is false, make the port not an output port. This has no effect if the port is a transparent port that is linked on the inside to output ports.  In that case, the port is an output port regardless of whether and how this method is called. This method is write-synchronized on the workspace.
 * @param isOutput True to make the port an output.
 */
public void setOutput(boolean isOutput){
  _workspace.getWriteAccess();
  _isOutput=isOutput;
  _workspace.doneWriting();
}"
76210,"/** 
 * Return true if the port is an input.  The port is an input if either setInput() has been called with a <i>true</i> argument, or it is connected on the inside to an input port, or if it is connected on the inside to the inside of an output port. In other words, it is an input if data can be put directly into it or sent through it to an input. This method is read-synchronized on the workspace.
 * @return True if the port is an input.
 */
public boolean isInput(){
  long version=_workspace.getVersion();
  if (_insideinputversion != version) {
    try {
      _workspace.getReadAccess();
      Iterator ports=deepInsidePortList().iterator();
      while (ports.hasNext()) {
        IOPort p=(IOPort)ports.next();
        if (p != this && p.isInput())         _isinput=true;
      }
      _insideinputversion=version;
    }
  finally {
      _workspace.doneReading();
    }
  }
  return _isinput;
}","/** 
 * Return true if the port is an input.  The port is an input if either setInput() has been called with a <i>true</i> argument, or it is connected on the inside to an input port, or if it is connected on the inside to the inside of an output port. In other words, it is an input if data can be put directly into it or sent through it to an input. This method is read-synchronized on the workspace.
 * @return True if the port is an input.
 */
public boolean isInput(){
  long version=_workspace.getVersion();
  if (_insideinputversion != version) {
    try {
      _workspace.getReadAccess();
      Iterator ports=deepInsidePortList().iterator();
      while (ports.hasNext()) {
        IOPort p=(IOPort)ports.next();
        if (p != this && p.isInput())         _isInput=true;
      }
      _insideinputversion=version;
    }
  finally {
      _workspace.doneReading();
    }
  }
  return _isInput;
}"
76211,"/** 
 * If the argument is true, make the port a multiport. That is, make it capable of linking with multiple IORelations, or with IORelations that have width greater than one. If the argument is false, allow only links with a single IORelation of width one. This has no effect if the port is a transparent port that is linked on the inside to a multiport.  In that case, the port is a multiport regardless of whether and how this method is called. This method is write-synchronized on the workspace.
 * @param ismultiport True to make the port a multiport.
 */
public void setMultiport(boolean ismultiport){
  _workspace.getWriteAccess();
  _ismultiport=ismultiport;
  _workspace.doneWriting();
}","/** 
 * If the argument is true, make the port a multiport. That is, make it capable of linking with multiple IORelations, or with IORelations that have width greater than one. If the argument is false, allow only links with a single IORelation of width one. This has no effect if the port is a transparent port that is linked on the inside to a multiport.  In that case, the port is a multiport regardless of whether and how this method is called. This method is write-synchronized on the workspace.
 * @param isMulitport True to make the port a multiport.
 */
public void setMultiport(boolean isMulitport){
  _workspace.getWriteAccess();
  _isMulitport=isMulitport;
  _workspace.doneWriting();
}"
76212,"/** 
 * Write a MoML description of the contents of this object, which in this class is the attributes plus possibly a special attribute to indicate whether the port is a multiport.  This method is called by _exportMoML().  If there are attributes, then each attribute description is indented according to the specified depth and terminated with a newline character.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @exception IOException If an I/O error occurs.
 */
protected void _exportMoMLContents(Writer output,int depth) throws IOException {
  if (_isinput) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
  }
  if (_isoutput) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
  }
  if (_ismultiport) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
  }
  super._exportMoMLContents(output,depth);
}","/** 
 * Write a MoML description of the contents of this object, which in this class is the attributes plus possibly a special attribute to indicate whether the port is a multiport.  This method is called by _exportMoML().  If there are attributes, then each attribute description is indented according to the specified depth and terminated with a newline character.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @exception IOException If an I/O error occurs.
 */
protected void _exportMoMLContents(Writer output,int depth) throws IOException {
  if (_isInput) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
  }
  if (_isOutput) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
  }
  if (_isMulitport) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
  }
  super._exportMoMLContents(output,depth);
}"
76213,"/** 
 * Return true if the port is a multiport.  The port is a multiport if setMultiport() has been called with a true argument.
 * @return True if the port is a multiport.
 */
public boolean isMultiport(){
  return _ismultiport;
}","/** 
 * Return true if the port is a multiport.  The port is a multiport if setMultiport() has been called with a true argument.
 * @return True if the port is a multiport.
 */
public boolean isMultiport(){
  return _isMulitport;
}"
76214,"/** 
 * If the argument is true, make the port an input port. If the argument is false, make the port not an input port. This has no effect if the port is a transparent port. In that case, the port is an input port regardless of whether and how this method is called. This method is write-synchronized on the workspace.
 * @param isinput True to make the port an input.
 */
public void setInput(boolean isinput){
  _workspace.getWriteAccess();
  _isinput=isinput;
  _workspace.doneWriting();
}","/** 
 * If the argument is true, make the port an input port. If the argument is false, make the port not an input port. This has no effect if the port is a transparent port. In that case, the port is an input port regardless of whether and how this method is called. This method is write-synchronized on the workspace.
 * @param isInput True to make the port an input.
 */
public void setInput(boolean isInput){
  _workspace.getWriteAccess();
  _isInput=isInput;
  _workspace.doneWriting();
}"
76215,"/** 
 * Return true if the port is an output. The port is an output if either setOutput() has been called with a true argument, or it is connected on the inside to an output port, or it is connected on the inside to the inside of an input port. This method is read-synchronized on the workspace.
 * @return True if the port is an output.
 */
public boolean isOutput(){
  long version=_workspace.getVersion();
  if (_insideoutputversion != version) {
    try {
      _workspace.getReadAccess();
      Iterator ports=deepInsidePortList().iterator();
      while (ports.hasNext()) {
        IOPort p=(IOPort)ports.next();
        if (p != this && p.isOutput())         _isoutput=true;
      }
      _insideoutputversion=version;
    }
  finally {
      _workspace.doneReading();
    }
  }
  return _isoutput;
}","/** 
 * Return true if the port is an output. The port is an output if either setOutput() has been called with a true argument, or it is connected on the inside to an output port, or it is connected on the inside to the inside of an input port. This method is read-synchronized on the workspace.
 * @return True if the port is an output.
 */
public boolean isOutput(){
  long version=_workspace.getVersion();
  if (_insideoutputversion != version) {
    try {
      _workspace.getReadAccess();
      Iterator ports=deepInsidePortList().iterator();
      while (ports.hasNext()) {
        IOPort p=(IOPort)ports.next();
        if (p != this && p.isOutput())         _isOutput=true;
      }
      _insideoutputversion=version;
    }
  finally {
      _workspace.doneReading();
    }
  }
  return _isOutput;
}"
76216,"/** 
 * Return true if the specified channel has a token to deliver via the get() method.  If this port is not an input, or if the channel index is out of range, then throw an exception. Note that this does not report any tokens in inside receivers of an output port. Those are accessible only through getInsideReceivers().
 * @param channelindex The channel index.
 * @return True if there is a token in the channel.
 * @exception IllegalActionException If the receivers do not supportthis query, if there is no director, and hence no receivers, if the port is not an input port, or if the channel index is out of range.
 */
public boolean hasToken(int channelindex) throws IllegalActionException {
  try {
    Receiver[][] recs=getReceivers();
    if (recs == null || recs[channelindex] == null) {
      return false;
    }
    for (int j=0; j < recs[channelindex].length; j++) {
      if (recs[channelindex][j].hasToken())       return true;
    }
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  return false;
}","/** 
 * Return true if the specified channel has a token to deliver via the get() method.  If this port is not an input, or if the channel index is out of range, then throw an exception. Note that this does not report any tokens in inside receivers of an output port. Those are accessible only through getInsideReceivers().
 * @param channelIndex The channel index.
 * @return True if there is a token in the channel.
 * @exception IllegalActionException If the receivers do not supportthis query, if there is no director, and hence no receivers, if the port is not an input port, or if the channel index is out of range.
 */
public boolean hasToken(int channelIndex) throws IllegalActionException {
  try {
    Receiver[][] recs=getReceivers();
    if (recs == null || recs[channelIndex] == null) {
      return false;
    }
    for (int j=0; j < recs[channelIndex].length; j++) {
      if (recs[channelIndex][j].hasToken())       return true;
    }
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  return false;
}"
76217,"/** 
 * Send the specified token to all receivers connected to the specified channel.  Tokens are in general immutable, so each receiver is given a reference to the same token and no clones are made. If the port is not connected to anything, or receivers have not been created in the remote port, or the channel index is out of range, or the port is not an output port, then just silently return.  This behavior makes it easy to leave output ports unconnected when you are not interested in the output.  The transfer is accomplished by calling the put() method of the remote receivers. If the port is not connected to anything, or receivers have not been created in the remote port, then just return. <p> Some of this method is read-synchronized on the workspace. Since it is possible for a thread to block while executing a put, it is important that the thread does not hold read access on the workspace when it is blocked. Thus this method releases read access on the workspace before calling put.
 * @param channelindex The index of the channel, from 0 to width-1
 * @param token The token to send
 * @exception NoRoomException If there is no room in the receiver.
 * @exception IllegalActionException Not thrown in this base class.
 */
public void send(int channelindex,Token token) throws IllegalActionException, NoRoomException {
  Receiver[][] farRec;
  try {
    try {
      _workspace.getReadAccess();
      farRec=getRemoteReceivers();
      if (farRec == null || farRec[channelindex] == null)       return;
    }
  finally {
      _workspace.doneReading();
    }
    for (int j=0; j < farRec[channelindex].length; j++) {
      farRec[channelindex][j].put(token);
    }
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
}","/** 
 * Send the specified token to all receivers connected to the specified channel.  Tokens are in general immutable, so each receiver is given a reference to the same token and no clones are made. If the port is not connected to anything, or receivers have not been created in the remote port, or the channel index is out of range, or the port is not an output port, then just silently return.  This behavior makes it easy to leave output ports unconnected when you are not interested in the output.  The transfer is accomplished by calling the put() method of the remote receivers. If the port is not connected to anything, or receivers have not been created in the remote port, then just return. <p> Some of this method is read-synchronized on the workspace. Since it is possible for a thread to block while executing a put, it is important that the thread does not hold read access on the workspace when it is blocked. Thus this method releases read access on the workspace before calling put.
 * @param channelIndex The index of the channel, from 0 to width-1
 * @param token The token to send
 * @exception NoRoomException If there is no room in the receiver.
 * @exception IllegalActionException Not thrown in this base class.
 */
public void send(int channelIndex,Token token) throws IllegalActionException, NoRoomException {
  Receiver[][] farRec;
  try {
    try {
      _workspace.getReadAccess();
      farRec=getRemoteReceivers();
      if (farRec == null || farRec[channelIndex] == null)       return;
    }
  finally {
      _workspace.doneReading();
    }
    for (int j=0; j < farRec[channelIndex].length; j++) {
      farRec[channelIndex][j].put(token);
    }
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
}"
76218,"/** 
 * Construct a TypedIOPort with a container and a name that is either an input, an output, or both, depending on the third and fourth arguments. The specified container must implement the TypedActor interface or an exception will be thrown.
 * @param container The container actor.
 * @param name The name of the port.
 * @param isinput True if this is to be an input port.
 * @param isoutput True if this is to be an output port.
 * @exception IllegalActionException If the port is not of an acceptableclass for the container, or if the container does not implement the TypedActor interface.
 * @exception NameDuplicationException If the name coincides witha port already in the container.
 */
public TypedIOPort(ComponentEntity container,String name,boolean isinput,boolean isoutput) throws IllegalActionException, NameDuplicationException {
  super(container,name,isinput,isoutput);
}","/** 
 * Construct a TypedIOPort with a container and a name that is either an input, an output, or both, depending on the third and fourth arguments. The specified container must implement the TypedActor interface or an exception will be thrown.
 * @param container The container actor.
 * @param name The name of the port.
 * @param isInput True if this is to be an input port.
 * @param isOutput True if this is to be an output port.
 * @exception IllegalActionException If the port is not of an acceptableclass for the container, or if the container does not implement the TypedActor interface.
 * @exception NameDuplicationException If the name coincides witha port already in the container.
 */
public TypedIOPort(ComponentEntity container,String name,boolean isInput,boolean isOutput) throws IllegalActionException, NameDuplicationException {
  super(container,name,isInput,isOutput);
}"
76219,"/** 
 * Construct a sound playback object. This constructor creates an object that writes audio to a sound file. To create a new sound file, call the <i>startPlayback()</i> method. Thereafter, each call to <i>putSamples()</i> will add <i>putSamplesSize</i> many samples to the sound file. To close and save the sound file, call method <i>stopPlayback</i>.
 * @param fileName The file name to create. If the file alreadyexists, overwrite it. Valid sound file formats are WAVE (.wav), AIFF (.aif, .aiff), AU (.au). The file format to write is determined automatically from the file extension.
 * @param sampleRate Sample rate in Hz. Must be in the range: 8000to 48000.
 * @param sampleSizeInBits Number of bits per sample (valid choices are8 or 16).
 * @param channels Number of audio channels. 1 for mono, 2 forstereo, etc.
 * @param putSamplesSize Size of the array parameter of<i>putSamples()</i>. For performance reasons, the size should be chosen smaller than <i>bufferSize</i>. Typical values are 1/2 to 1/16th of <i>bufferSize</i>.
 */
public SoundPlayback(String fileName,float sampleRate,int sampleSizeInBits,int channels,int bufferSize,int putSamplesSize){
  System.out.println(""String_Node_Str"");
  this._playbackMode=""String_Node_Str"";
  this._fileName=fileName;
  this._sampleSizeInBits=sampleSizeInBits;
  this._sampleRate=sampleRate;
  this._channels=channels;
  this._productionRate=putSamplesSize;
  System.out.println(""String_Node_Str"" + sampleSizeInBits);
  System.out.println(""String_Node_Str"" + sampleRate);
  System.out.println(""String_Node_Str"" + channels);
  System.out.println(""String_Node_Str"" + bufferSize);
  System.out.println(""String_Node_Str"" + putSamplesSize);
}","/** 
 * Construct a sound playback object. This constructor creates an object that writes audio to a sound file. To create a new sound file, call the <i>startPlayback()</i> method. Thereafter, each call to <i>putSamples()</i> will add <i>putSamplesSize</i> many samples to the sound file. To close and save the sound file, call method <i>stopPlayback</i>.
 * @param fileName The file name to create. If the file alreadyexists, overwrite it. Valid sound file formats are WAVE (.wav), AIFF (.aif, .aiff), AU (.au). The file format to write is determined automatically from the file extension.
 * @param sampleRate Sample rate in Hz. Must be in the range: 8000to 48000.
 * @param sampleSizeInBits Number of bits per sample (valid choices are8 or 16).
 * @param channels Number of audio channels. 1 for mono, 2 forstereo, etc.
 * @param putSamplesSize Size of the array parameter of<i>putSamples()</i>. For performance reasons, the size should be chosen smaller than <i>bufferSize</i>. Typical values are 1/2 to 1/16 th of <i>bufferSize</i>.
 */
public SoundPlayback(String fileName,float sampleRate,int sampleSizeInBits,int channels,int bufferSize,int putSamplesSize){
  System.out.println(""String_Node_Str"");
  this._playbackMode=""String_Node_Str"";
  this._fileName=fileName;
  this._sampleSizeInBits=sampleSizeInBits;
  this._sampleRate=sampleRate;
  this._channels=channels;
  this._productionRate=putSamplesSize;
  System.out.println(""String_Node_Str"" + sampleSizeInBits);
  System.out.println(""String_Node_Str"" + sampleRate);
  System.out.println(""String_Node_Str"" + channels);
  System.out.println(""String_Node_Str"" + bufferSize);
  System.out.println(""String_Node_Str"" + putSamplesSize);
}"
76220,"/** 
 * Read <i>tokenConsumptionRate</i> tokens from each channel. Write these tokens to a sound file and/or send them to the speaker, depending on the current mode, which is determined by the value of <i>sink</i>.
 * @exception IllegalActionException If there is no director.
 */
public boolean postfire() throws IllegalActionException {
  for (int j=0; j < _channels; j++) {
    DoubleToken[] audioTokenArray=new DoubleToken[_consumptionRate];
    input.getArray(j,audioTokenArray);
    for (int i=0; i < _consumptionRate; i++) {
      _audioInDoubleArray[j][i]=audioTokenArray[i].doubleValue();
    }
  }
  _soundPlayback.putSamples(_audioInDoubleArray);
  return true;
}","/** 
 * Read <i>tokenConsumptionRate</i> tokens from each channel. Write these tokens to a sound file and/or send them to the speaker, depending on the current mode, which is determined by the value of <i>sink</i>.
 * @exception IllegalActionException If there is no director.
 */
public boolean postfire() throws IllegalActionException {
  for (int j=0; j < _channels; j++) {
    input.getArray(j,_audioTokenArray);
    for (int i=0; i < _consumptionRate; i++) {
      _audioInDoubleArray[j][i]=_audioTokenArray[i].doubleValue();
    }
  }
  _soundPlayback.putSamples(_audioInDoubleArray);
  return true;
}"
76221,"/** 
 * Open the specified file, if any.  Note changes to the fileName parameter during execution are ignored until the next execution.
 * @exception IllegalActionException If the file cannot be opened,or if the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  System.out.println(""String_Node_Str"");
  if (((StringToken)sink.getToken()).toString() == ""String_Node_Str"") {
    System.out.println(""String_Node_Str"");
    String pathNameString=((StringToken)pathName.getToken()).toString();
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    _soundPlayback=new SoundPlayback(pathNameString,sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,_consumptionRate);
  }
 else   if (((StringToken)sink.getToken()).toString() == ""String_Node_Str"") {
    System.out.println(""String_Node_Str"");
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    _soundPlayback=new SoundPlayback(sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,_consumptionRate);
    System.out.println(""String_Node_Str"");
  }
 else   if (((StringToken)sink.getToken()).toString() == ""String_Node_Str"") {
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + sink.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  _soundPlayback.startPlayback();
  System.out.println(""String_Node_Str"");
}","/** 
 * Open the specified file, if any.  Note changes to the fileName parameter during execution are ignored until the next execution.
 * @exception IllegalActionException If the file cannot be opened,or if the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  System.out.println(""String_Node_Str"");
  if (((StringToken)sink.getToken()).toString() == ""String_Node_Str"") {
    System.out.println(""String_Node_Str"");
    String pathNameString=((StringToken)pathName.getToken()).toString();
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    _soundPlayback=new SoundPlayback(pathNameString,sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,_consumptionRate);
  }
 else   if (((StringToken)sink.getToken()).toString() == ""String_Node_Str"") {
    System.out.println(""String_Node_Str"");
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    _soundPlayback=new SoundPlayback(sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,_consumptionRate);
    System.out.println(""String_Node_Str"");
  }
 else   if (((StringToken)sink.getToken()).toString() == ""String_Node_Str"") {
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + sink.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  _soundPlayback.startPlayback();
  System.out.println(""String_Node_Str"");
  _audioTokenArray=new DoubleToken[_consumptionRate];
}"
76222,"/** 
 * Output sample values of the sound file. Semantically, only one token (a DoubleToken) is output. In the actual implementation, however, the number of tokens output is equal to the token production rate.
 * @return True if there are samples available from theaudio source. False if there are no more samples (end of sound file reached).
 */
public boolean postfire() throws IllegalActionException {
  _audioInDoubleArray=_soundCapture.getSamples();
  if (_audioInDoubleArray != null) {
    for (int j=0; j < _channels; j++) {
      _audioTokenArray=new DoubleToken[_productionRate];
      for (int i=0; i < _productionRate; i++) {
        _audioTokenArray[i]=new DoubleToken(_audioInDoubleArray[j][i]);
      }
      output.sendArray(j,_audioTokenArray);
    }
    return true;
  }
 else {
    _audioTokenArray=new DoubleToken[_productionRate];
    for (int i=0; i < _productionRate; i++) {
      _audioTokenArray[i]=new DoubleToken(0);
    }
    for (int j=0; j < _channels; j++) {
      output.sendArray(j,_audioTokenArray);
    }
    System.out.println(""String_Node_Str"");
    return false;
  }
}","/** 
 * Output sample values of the sound file. Semantically, only one token (a DoubleToken) is output. In the actual implementation, however, the number of tokens output is equal to the token production rate.
 * @return True if there are samples available from theaudio source. False if there are no more samples (end of sound file reached).
 */
public boolean postfire() throws IllegalActionException {
  _audioInDoubleArray=_soundCapture.getSamples();
  if (_audioInDoubleArray != null) {
    for (int j=0; j < _channels; j++) {
      for (int i=0; i < _productionRate; i++) {
        _audioTokenArray[i]=new DoubleToken(_audioInDoubleArray[j][i]);
      }
      output.sendArray(j,_audioTokenArray);
    }
    return true;
  }
 else {
    for (int i=0; i < _productionRate; i++) {
      _audioTokenArray[i]=new DoubleToken(0);
    }
    for (int j=0; j < _channels; j++) {
      output.sendArray(j,_audioTokenArray);
    }
    System.out.println(""String_Node_Str"");
    return false;
  }
}"
76223,"/** 
 * Check parameters and begin the sound capture process. If the capture source is a sound file, the file is reopened and caputre is reset to the begining of the file.
 * @exception IllegalActionException If the parametersare out of range.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  System.out.println(""String_Node_Str"");
  if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    String theURL=((StringToken)pathName.getToken()).toString();
    _soundCapture=new SoundCapture(true,theURL,_productionRate);
  }
 else   if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    String theFileName=((StringToken)pathName.getToken()).toString();
    _soundCapture=new SoundCapture(false,theFileName,_productionRate);
  }
 else   if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    int getSamplesSizeInt=_productionRate;
    _soundCapture=new SoundCapture((float)sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,getSamplesSizeInt);
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + source.getFullName() + ""String_Node_Str"");
  }
  _soundCapture.startCapture();
}","/** 
 * Check parameters and begin the sound capture process. If the capture source is a sound file, the file is reopened and caputre is reset to the begining of the file.
 * @exception IllegalActionException If the parametersare out of range.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    String theURL=((StringToken)pathName.getToken()).toString();
    _soundCapture=new SoundCapture(true,theURL,_productionRate);
    _soundCapture.startCapture();
    _channels=_soundCapture.getChannels();
    channels.setToken(new IntToken(_channels));
  }
 else   if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    String theFileName=((StringToken)pathName.getToken()).toString();
    _soundCapture=new SoundCapture(false,theFileName,_productionRate);
    _soundCapture.startCapture();
    _channels=_soundCapture.getChannels();
    channels.setToken(new IntToken(_channels));
  }
 else   if (((StringToken)source.getToken()).toString() == ""String_Node_Str"") {
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    int getSamplesSizeInt=_productionRate;
    _soundCapture=new SoundCapture((float)sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,getSamplesSizeInt);
    _soundCapture.startCapture();
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + source.getFullName() + ""String_Node_Str"");
  }
  _audioTokenArray=new DoubleToken[_productionRate];
}"
76224,"/** 
 * Output the sample value of the sound file corresponding to the current index.
 */
public void fire() throws IllegalActionException {
  input.getArray(0,audioTokenArray);
  int i;
  for (i=0; i < consumptionRate; i++) {
    audioInDoubleArray[i]=audioTokenArray[i].doubleValue();
  }
  double[] currPitchArray=pd.performPitchDetect(audioInDoubleArray);
  for (i=0; i < productionRate; i++) {
    audioTokenArray[i]=new DoubleToken(currPitchArray[i]);
  }
  output.sendArray(0,audioTokenArray);
}","/** 
 * Output the sample value of the sound file corresponding to the current index.
 */
public void fire() throws IllegalActionException {
}"
76225,"/** 
 * Clone the actor into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a composite actor with clones of the ports of the original actor, the contained actors, and the contained relations. The ports of the returned actor are not connected to anything. The connections of the relations are duplicated in the new composite, unless they cross levels, in which case an exception is thrown. The local director is cloned, if there is one. The executive director is not cloned. NOTE: This will not work if there are level-crossing transitions.
 * @param ws The workspace for the cloned object.
 * @exception CloneNotSupportedException If the actor containslevel crossing transitions so that its connections cannot be cloned, or if one of the attributes cannot be cloned.
 * @return A new CompositeActor.
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  CompositeActor newobj=(CompositeActor)super.clone(ws);
  if (_director != null) {
    newobj._director=(Director)_director.clone();
  }
 else {
    newobj._director=null;
  }
  newobj._inputPortsVersion=-1;
  newobj._outputPortsVersion=-1;
  return newobj;
}","/** 
 * Clone the actor into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a composite actor with clones of the ports of the original actor, the contained actors, and the contained relations. The ports of the returned actor are not connected to anything. The connections of the relations are duplicated in the new composite, unless they cross levels, in which case an exception is thrown. The local director is cloned, if there is one. The executive director is not cloned. NOTE: This will not work if there are level-crossing transitions.
 * @param ws The workspace for the cloned object.
 * @exception CloneNotSupportedException If the actor containslevel crossing transitions so that its connections cannot be cloned, or if one of the attributes cannot be cloned.
 * @return A new CompositeActor.
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  CompositeActor newobj=(CompositeActor)super.clone(ws);
  if (_director != null) {
    newobj._director=(Director)_director.clone();
    newobj._director._makeDirectorOf(newobj);
  }
 else {
    newobj._director=null;
  }
  newobj._inputPortsVersion=-1;
  newobj._outputPortsVersion=-1;
  return newobj;
}"
76226,"/** 
 * Return the name of this document factory.
 */
public String getName(){
  return ""String_Node_Str"";
}","/** 
 * Return a string which is the name associated with this document factory.
 */
public String getName(){
  return ""String_Node_Str"";
}"
76227,"public PtolemyPackage(VergilApplication application){
  _application=application;
  Action action;
  JMenu menuDevel=new JMenu(""String_Node_Str"");
  menuDevel.setMnemonic('D');
  _application.addMenu(menuDevel);
  action=new AbstractAction(""String_Node_Str""){
    public void actionPerformed(    ActionEvent e){
      Document d=_application.getCurrentDocument();
      if (d == null) {
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(d.toString());
      }
    }
  }
;
  _application.addMenuItem(menuDevel,action,'P',""String_Node_Str"");
  action=new AbstractAction(""String_Node_Str""){
    public void actionPerformed(    ActionEvent e){
      PtolemyDocument d=(PtolemyDocument)_application.getCurrentDocument();
      if (d == null) {
        return;
      }
      try {
        CompositeActor toplevel=(CompositeActor)d.getModel();
        if (toplevel.getDirector() == null) {
          ptolemy.domains.sdf.kernel.SDFDirector director=new ptolemy.domains.sdf.kernel.SDFDirector(toplevel.workspace());
          toplevel.setDirector(director);
          director.iterations.setExpression(""String_Node_Str"");
        }
        Manager manager=toplevel.getManager();
        if (manager == null) {
          manager=new Manager(toplevel.workspace(),""String_Node_Str"");
          toplevel.setManager(manager);
          manager.addExecutionListener(new VergilExecutionListener());
        }
        if (_executionFrame != null) {
          _executionFrame.getContentPane().removeAll();
        }
 else {
          _executionFrame=new JFrame();
        }
        ModelPane modelPane=new ModelPane(toplevel);
        _executionFrame.getContentPane().add(modelPane,BorderLayout.NORTH);
        JPanel displayPanel=new JPanel();
        displayPanel.setLayout(new BoxLayout(displayPanel,BoxLayout.Y_AXIS));
        modelPane.setDisplayPane(displayPanel);
        for (Iterator i=toplevel.deepEntityList().iterator(); i.hasNext(); ) {
          Object o=i.next();
          if (o instanceof Placeable) {
            ((Placeable)o).place(displayPanel);
          }
        }
        if (_executionFrame != null) {
          _executionFrame.setVisible(true);
        }
        final JFrame packframe=_executionFrame;
        Action packer=new AbstractAction(){
          public void actionPerformed(          ActionEvent event){
            packframe.getContentPane().doLayout();
            packframe.repaint();
            packframe.pack();
          }
        }
;
        javax.swing.Timer timer=new javax.swing.Timer(200,packer);
        timer.setRepeats(false);
        timer.start();
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        throw new GraphException(ex.getMessage());
      }
    }
  }
;
  _application.addMenuItem(menuDevel,action,'E',""String_Node_Str"");
  JToolBar tb=new JToolBar();
  Container pane=((DesktopFrame)_application.getApplicationFrame()).getToolBarPane();
  pane.add(tb);
  String dflt=""String_Node_Str"";
  _layoutComboBox=new JComboBox();
  dflt=""String_Node_Str"";
  _layoutComboBox.addItem(dflt);
  _layoutComboBox.addItem(""String_Node_Str"");
  _layoutComboBox.setSelectedItem(dflt);
  _layoutComboBox.setMaximumSize(_layoutComboBox.getMinimumSize());
  _layoutComboBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      if (e.getStateChange() == ItemEvent.SELECTED) {
        VergilDocument d=(VergilDocument)_application.getCurrentDocument();
        JGraph jg=(JGraph)_application.getView(d);
        redoLayout(jg,(String)e.getItem());
      }
    }
  }
);
  tb.add(_layoutComboBox);
  _directorModel=new DefaultComboBoxModel();
  _directorModel.addElement(new SDFDirector());
  _directorModel.addElement(new PNDirector());
  _directorComboBox=new JComboBox(_directorModel);
  _directorComboBox.setRenderer(new DirectorCellRenderer());
  _directorComboBox.setMaximumSize(_directorComboBox.getMinimumSize());
  _directorComboBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      if (e.getStateChange() == ItemEvent.SELECTED) {
        Director director=(Director)e.getItem();
        PtolemyDocument d=(PtolemyDocument)_application.getCurrentDocument();
        CompositeEntity entity=d.getModel();
        if (entity instanceof Actor) {
          CompositeActor actor=(CompositeActor)entity;
          try {
            Director clone=(Director)director.clone(actor.workspace());
            actor.setDirector(clone);
          }
 catch (          Exception ex) {
            System.out.println(ex.getMessage());
            ex.printStackTrace();
          }
        }
      }
    }
  }
);
  tb.add(_directorComboBox);
}","public PtolemyPackage(VergilApplication application){
  _application=application;
  Action action;
  JMenu menuDevel=new JMenu(""String_Node_Str"");
  menuDevel.setMnemonic('D');
  _application.addMenu(menuDevel);
  action=new AbstractAction(""String_Node_Str""){
    public void actionPerformed(    ActionEvent e){
      Document d=_application.getCurrentDocument();
      if (d == null) {
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(d.toString());
      }
    }
  }
;
  _application.addMenuItem(menuDevel,action,'P',""String_Node_Str"");
  action=new AbstractAction(""String_Node_Str""){
    public void actionPerformed(    ActionEvent e){
      PtolemyDocument d=(PtolemyDocument)_application.getCurrentDocument();
      if (d == null) {
        return;
      }
      try {
        CompositeActor toplevel=(CompositeActor)d.getModel();
        if (toplevel.getDirector() == null) {
          ptolemy.domains.sdf.kernel.SDFDirector director=new ptolemy.domains.sdf.kernel.SDFDirector(toplevel.workspace());
          toplevel.setDirector(director);
          director.iterations.setExpression(""String_Node_Str"");
        }
        Manager manager=toplevel.getManager();
        if (manager == null) {
          manager=new Manager(toplevel.workspace(),""String_Node_Str"");
          toplevel.setManager(manager);
          manager.addExecutionListener(new VergilExecutionListener());
        }
        if (_executionFrame != null) {
          _executionFrame.getContentPane().removeAll();
        }
 else {
          _executionFrame=new JFrame();
        }
        ModelPane modelPane=new ModelPane(toplevel);
        _executionFrame.getContentPane().add(modelPane,BorderLayout.NORTH);
        JPanel displayPanel=new JPanel();
        displayPanel.setLayout(new BoxLayout(displayPanel,BoxLayout.Y_AXIS));
        modelPane.setDisplayPane(displayPanel);
        for (Iterator i=toplevel.deepEntityList().iterator(); i.hasNext(); ) {
          Object o=i.next();
          if (o instanceof Placeable) {
            ((Placeable)o).place(displayPanel);
          }
        }
        if (_executionFrame != null) {
          _executionFrame.setVisible(true);
        }
        final JFrame packframe=_executionFrame;
        Action packer=new AbstractAction(){
          public void actionPerformed(          ActionEvent event){
            packframe.getContentPane().doLayout();
            packframe.repaint();
            packframe.pack();
          }
        }
;
        javax.swing.Timer timer=new javax.swing.Timer(200,packer);
        timer.setRepeats(false);
        timer.start();
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        throw new GraphException(ex.getMessage());
      }
    }
  }
;
  _application.addMenuItem(menuDevel,action,'E',""String_Node_Str"");
  JToolBar tb=new JToolBar();
  Container pane=((DesktopFrame)_application.getApplicationFrame()).getToolBarPane();
  pane.add(tb);
  String dflt=""String_Node_Str"";
  _layoutComboBox=new JComboBox();
  dflt=""String_Node_Str"";
  _layoutComboBox.addItem(dflt);
  _layoutComboBox.setSelectedItem(dflt);
  _layoutComboBox.addItem(""String_Node_Str"");
  _layoutComboBox.addItem(""String_Node_Str"");
  _layoutComboBox.setMaximumSize(_layoutComboBox.getMinimumSize());
  _layoutComboBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      if (e.getStateChange() == ItemEvent.SELECTED) {
        VergilDocument d=(VergilDocument)_application.getCurrentDocument();
        JGraph jg=(JGraph)_application.getView(d);
        redoLayout(jg,(String)e.getItem());
      }
    }
  }
);
  tb.add(_layoutComboBox);
  _directorModel=new DefaultComboBoxModel();
  _directorModel.addElement(new SDFDirector());
  _directorModel.addElement(new PNDirector());
  _directorComboBox=new JComboBox(_directorModel);
  _directorComboBox.setRenderer(new DirectorCellRenderer());
  _directorComboBox.setMaximumSize(_directorComboBox.getMinimumSize());
  _directorComboBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      if (e.getStateChange() == ItemEvent.SELECTED) {
        Director director=(Director)e.getItem();
        PtolemyDocument d=(PtolemyDocument)_application.getCurrentDocument();
        CompositeEntity entity=d.getModel();
        if (entity instanceof Actor) {
          CompositeActor actor=(CompositeActor)entity;
          try {
            Director clone=(Director)director.clone(actor.workspace());
            actor.setDirector(clone);
          }
 catch (          Exception ex) {
            System.out.println(ex.getMessage());
            ex.printStackTrace();
          }
        }
      }
    }
  }
);
  tb.add(_directorComboBox);
  application.addDocumentFactory(new PtolemyDocument.Factory());
}"
76228,"/** 
 * Parse the xml libraries
 */
public void parseLibraries(){
  URL iconlibURL=null;
  URL entitylibURL=null;
  try {
    iconlibURL=getGUIResources().getResource(""String_Node_Str"");
    entitylibURL=getGUIResources().getResource(""String_Node_Str"");
    MoMLParser parser;
    parser=new MoMLParser();
    _iconLibrary=(CompositeEntity)parser.parse(iconlibURL,iconlibURL.openStream());
    LibraryIcon.setIconLibrary(_iconLibrary);
    parser=new MoMLParser();
    _entityLibrary=(CompositeEntity)parser.parse(entitylibURL,entitylibURL.openStream());
  }
 catch (  Exception e) {
    System.out.println(e);
  }
}","/** 
 * Parse the entity and icon xml libraries.  Set the entity and icon libraries for this application.
 */
public void parseLibraries(){
  URL iconlibURL=null;
  URL entitylibURL=null;
  try {
    iconlibURL=getGUIResources().getResource(""String_Node_Str"");
    entitylibURL=getGUIResources().getResource(""String_Node_Str"");
    MoMLParser parser;
    parser=new MoMLParser();
    _iconLibrary=(CompositeEntity)parser.parse(iconlibURL,iconlibURL.openStream());
    LibraryIcon.setIconLibrary(_iconLibrary);
    parser=new MoMLParser();
    _entityLibrary=(CompositeEntity)parser.parse(entitylibURL,entitylibURL.openStream());
  }
 catch (  Exception e) {
    System.out.println(e);
  }
}"
76229,"/** 
 * Create and run a new graph application
 */
public static void main(String argv[]){
  VergilApplication ge=new VergilApplication();
  ge.setVisible(true);
}","/** 
 * Create and run a new graph application.
 */
public static void main(String argv[]){
  VergilApplication ge=new VergilApplication();
  ge.setVisible(true);
}"
76230,"/** 
 * Get the title of this application
 */
public String getTitle(){
  return ""String_Node_Str"";
}","/** 
 * Get the title of this application.  Return the string ""Vergil"".
 */
public String getTitle(){
  return ""String_Node_Str"";
}"
76231,"/** 
 * Remove a factory that creates new documents for use by subclasses constructors only.
 */
protected void removeDocumentFactory(VergilDocumentFactory df){
  int index=_documentFactoryList.indexOf(df);
  _documentFactoryList.remove(df);
  _fileNewMenu.remove(_fileNewMenu.getItem(index));
}","/** 
 * Remove the given factory that creates new documents from this application.  Remove its entry in the file->new menu.
 */
protected void removeDocumentFactory(VergilDocumentFactory df){
  int index=_documentFactoryList.indexOf(df);
  _documentFactoryList.remove(df);
  _fileNewMenu.remove(_fileNewMenu.getItem(index));
}"
76232,"/** 
 * Return the icon library associated with this Vergil
 */
public CompositeEntity getIconLibrary(){
  return _iconLibrary;
}","/** 
 * Return the icon library associated with this Vergil.
 */
public CompositeEntity getIconLibrary(){
  return _iconLibrary;
}"
76233,"/** 
 * Set the given document to be the current document, and raise the internal window that corresponds to that component. In this class, there are some things that we want to enable and disable if there are no documents present.
 */
public void setCurrentDocument(Document d){
  super.setCurrentDocument(d);
  if (d == null) {
    Action saveAction=getAction(DefaultActions.SAVE);
    saveAction.setEnabled(false);
    Action saveAsAction=getAction(DefaultActions.SAVE_AS);
    saveAsAction.setEnabled(false);
  }
 else {
    Action saveAction=getAction(DefaultActions.SAVE);
    saveAction.setEnabled(true);
    Action saveAsAction=getAction(DefaultActions.SAVE_AS);
    saveAsAction.setEnabled(true);
  }
}","/** 
 * Set the given document to be the current document, and raise the internal window that corresponds to that component. If there are no documents present, then disable the appropriate  menu entries.
 */
public void setCurrentDocument(Document d){
  super.setCurrentDocument(d);
  if (d == null) {
    Action saveAction=getAction(DefaultActions.SAVE);
    saveAction.setEnabled(false);
    Action saveAsAction=getAction(DefaultActions.SAVE_AS);
    saveAsAction.setEnabled(false);
  }
 else {
    Action saveAction=getAction(DefaultActions.SAVE);
    saveAction.setEnabled(true);
    Action saveAsAction=getAction(DefaultActions.SAVE_AS);
    saveAsAction.setEnabled(true);
  }
}"
76234,"/** 
 * Return the document factory with the given name. public DocumentFactory getDocumentFactory(name) {  return (DocumentFactory)_documentFactoryList.get(name); } /** Return the entity library for this application.
 */
public CompositeEntity getEntityLibrary(){
  return _entityLibrary;
}","/** 
 * Return the entity library for this application.
 */
public CompositeEntity getEntityLibrary(){
  return _entityLibrary;
}"
76235,"/** 
 * Add a factory that creates new documents.  The factory will appear in the list of factories with the given name.
 */
protected void addDocumentFactory(VergilDocumentFactory df){
  _documentFactoryList.add(df);
  _fileNewMenu.add(df.getName());
}","/** 
 * Add the factory that creates new documents.  Also add create a new action and add it to the file->new menu that will create documents with the given factory.
 */
protected void addDocumentFactory(VergilDocumentFactory df){
  final VergilDocumentFactory factory=df;
  final VergilApplication app=this;
  _documentFactoryList.add(factory);
  Action action=new AbstractAction(factory.getName()){
    public void actionPerformed(    ActionEvent e){
      Document doc=factory.createDocument(app);
      addDocument(doc);
      displayDocument(doc);
      setCurrentDocument(doc);
    }
  }
;
  _fileNewMenu.add(action);
}"
76236,"/** 
 * Redisplay a document after it appears on the screen. This method should be overridden by applications that need to perform some form of update when the component appears on the screen. This class executes a graph layout algorithm on the document
 */
public void redisplay(Document d,JComponent c){
  JGraph jgraph=(JGraph)c;
}","/** 
 * Redisplay a document after it appears on the screen. In this class, do nothing.
 */
public void redisplay(Document d,JComponent c){
  JGraph jgraph=(JGraph)c;
}"
76237,"/** 
 * Construct a new graph editing application.
 */
public VergilApplication(){
  super();
  JTreePane treepane=new JTreePane(""String_Node_Str"");
  DesktopFrame frame=new DesktopFrame(this,treepane);
  setApplicationFrame(frame);
  DefaultStoragePolicy storage=new DefaultStoragePolicy();
  setStoragePolicy(storage);
  FileFilter ff=new FileFilter(){
    public boolean accept(    File file){
      if (file.isDirectory()) {
        return true;
      }
 else {
        return GUIUtilities.getFileExtension(file).toLowerCase().equals(""String_Node_Str"");
      }
    }
    public String getDescription(){
      return ""String_Node_Str"";
    }
  }
;
  JFileChooser fc;
  fc=storage.getOpenFileChooser();
  fc.addChoosableFileFilter(ff);
  fc.setFileFilter(ff);
  fc=storage.getSaveFileChooser();
  fc.addChoosableFileFilter(ff);
  fc.setFileFilter(ff);
  addDocumentFactory(new PtolemyDocument.Factory());
  initializeMenuBar(frame.getJMenuBar());
  initializeToolBar(frame.getJToolBar());
  JPanel toolBarPane=frame.getToolBarPane();
  toolBarPane.setLayout(new FlowLayout(FlowLayout.LEFT,0,0));
  SwingUtilities.invokeLater(new PaletteInitializer());
  Icon icon=getResources().getImageIcon(""String_Node_Str"");
  Image iconImage=getResources().getImage(""String_Node_Str"");
  frame.setFrameIcon(icon);
  frame.setIconImage(iconImage);
  setCurrentDocument(null);
  addDocumentListener(new Focuser());
  SwingUtilities.updateComponentTreeUI(treepane);
  Action action=getAction(DefaultActions.NEW);
  javax.swing.Timer timer=new javax.swing.Timer(200,action);
  timer.setRepeats(false);
  timer.start();
  new PtolemyPackage(this);
}","/** 
 * Construct a new graph editing application.
 */
public VergilApplication(){
  super();
  JTreePane treepane=new JTreePane(""String_Node_Str"");
  DesktopFrame frame=new DesktopFrame(this,treepane);
  setApplicationFrame(frame);
  DefaultStoragePolicy storage=new DefaultStoragePolicy();
  setStoragePolicy(storage);
  FileFilter ff=new FileFilter(){
    public boolean accept(    File file){
      if (file.isDirectory()) {
        return true;
      }
 else {
        return GUIUtilities.getFileExtension(file).toLowerCase().equals(""String_Node_Str"");
      }
    }
    public String getDescription(){
      return ""String_Node_Str"";
    }
  }
;
  JFileChooser fc;
  fc=storage.getOpenFileChooser();
  fc.addChoosableFileFilter(ff);
  fc.setFileFilter(ff);
  fc=storage.getSaveFileChooser();
  fc.addChoosableFileFilter(ff);
  fc.setFileFilter(ff);
  initializeMenuBar(frame.getJMenuBar());
  initializeToolBar(frame.getJToolBar());
  JPanel toolBarPane=frame.getToolBarPane();
  toolBarPane.setLayout(new FlowLayout(FlowLayout.LEFT,0,0));
  SwingUtilities.invokeLater(new PaletteInitializer());
  Icon icon=getResources().getImageIcon(""String_Node_Str"");
  Image iconImage=getResources().getImage(""String_Node_Str"");
  frame.setFrameIcon(icon);
  frame.setIconImage(iconImage);
  setCurrentDocument(null);
  addDocumentListener(new Focuser());
  SwingUtilities.updateComponentTreeUI(treepane);
  Action action=getAction(DefaultActions.NEW);
  javax.swing.Timer timer=new javax.swing.Timer(200,action);
  timer.setRepeats(false);
  timer.start();
  new PtolemyPackage(this);
}"
76238,"/** 
 * Add a menu to the menu bar of this application.
 */
public void addMenu(JMenu menu){
  JFrame frame=getApplicationFrame();
  if (frame == null)   return;
  JMenuBar menuBar=frame.getJMenuBar();
  menuBar.add(menu);
}","/** 
 * Add the menu to the menu bar of this application.
 */
public void addMenu(JMenu menu){
  JFrame frame=getApplicationFrame();
  if (frame == null)   return;
  JMenuBar menuBar=frame.getJMenuBar();
  menuBar.add(menu);
}"
76239,"/** 
 * Remove the menu to the menu bar of this application.
 */
public void removeMenu(JMenu menu){
  JFrame frame=getApplicationFrame();
  if (frame == null)   return;
  JMenuBar menuBar=frame.getJMenuBar();
  menuBar.remove(menu);
}","/** 
 * Remove the given menu from the menu bar of this application.
 */
public void removeMenu(JMenu menu){
  JFrame frame=getApplicationFrame();
  if (frame == null)   return;
  JMenuBar menuBar=frame.getJMenuBar();
  menuBar.remove(menu);
}"
76240,"public void createTreeNodes(JTreePane pane,String parent,CompositeEntity library){
  Iterator entities=library.entityList().iterator();
  int i=0;
  while (entities.hasNext()) {
    Entity entity=(Entity)entities.next();
    if (!(entity instanceof CompositeEntity)) {
      GraphPalette palette=(GraphPalette)pane.getComponentAt(library.getFullName());
      ptolemy.moml.Icon icon=(ptolemy.moml.Icon)entity.getAttribute(""String_Node_Str"");
      palette.addNode(icon,60,50 + (i++) * 50);
    }
    if (entity instanceof CompositeEntity) {
      GraphPalette palette=new GraphPalette();
      pane.addEntry(parent,entity.getFullName(),palette);
      createTreeNodes(pane,entity.getFullName(),(CompositeEntity)entity);
    }
  }
}","/** 
 * Populate the tree pane with icons for each entity in the given composite entity.
 * @param pane The tree pane.
 * @param parent The name of the node in the tree to add the icons to.
 * @param library The composite entity to add icons for.
 */
public void createTreeNodes(JTreePane pane,String parent,CompositeEntity library){
  Iterator entities=library.entityList().iterator();
  int i=0;
  while (entities.hasNext()) {
    Entity entity=(Entity)entities.next();
    if (!(entity instanceof CompositeEntity)) {
      GraphPalette palette=(GraphPalette)pane.getComponentAt(library.getFullName());
      ptolemy.moml.Icon icon=(ptolemy.moml.Icon)entity.getAttribute(""String_Node_Str"");
      palette.addNode(icon,60,50 + (i++) * 50);
    }
    if (entity instanceof CompositeEntity) {
      GraphPalette palette=new GraphPalette();
      pane.addEntry(parent,entity.getFullName(),palette);
      createTreeNodes(pane,entity.getFullName(),(CompositeEntity)entity);
    }
  }
}"
76241,"public void contentsChanged(ListDataEvent e){
  System.out.println(""String_Node_Str"");
  VergilDocument document=(VergilDocument)getCurrentDocument();
  if (document == null)   return;
  JComponent component=getView(document);
  if (component == null)   return;
  if (!component.hasFocus()) {
    component.requestFocus();
  }
}","public void contentsChanged(ListDataEvent e){
  VergilDocument document=(VergilDocument)getCurrentDocument();
  if (document == null)   return;
  JComponent component=getView(document);
  if (component == null)   return;
  if (!component.hasFocus()) {
    component.requestFocus();
  }
}"
76242,"/** 
 * Return the name of this Factory
 */
public String getName();","/** 
 * Return a string which is the name associated with this document factory.
 */
public String getName();"
76243,"/** 
 * Return a new instance of a BasicGraph with the given semantic object.
 */
public Graph createGraph(Object semanticObject){
  Graph g=new BasicGraph();
  g.setSemanticObject(semanticObject);
  if (semanticObject instanceof CompositeEntity) {
    CompositeEntity toplevel=(CompositeEntity)semanticObject;
    Iterator entities=toplevel.entityList().iterator();
    while (entities.hasNext()) {
      Entity entity=(Entity)entities.next();
      Icon icon=(Icon)entity.getAttribute(""String_Node_Str"");
      if (icon == null) {
        try {
          icon=new EditorIcon(entity);
        }
 catch (        Exception e) {
          throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
        }
      }
      addNode(createCompositeNode(icon),g);
    }
    Iterator relations=toplevel.relationList().iterator();
    while (relations.hasNext()) {
      Relation relation=(Relation)relations.next();
      Iterator attributes=relation.attributeList().iterator();
      Node rootVertex=null;
      while (attributes.hasNext()) {
        Attribute a=(Attribute)attributes.next();
        if (a instanceof Vertex) {
          Node n=createNode(a);
          if (((Vertex)a).getLinkedVertex() == null) {
            rootVertex=n;
          }
          addNode(n,g);
        }
      }
      int count=0;
      Enumeration links=relation.linkedPorts();
      while (links.hasMoreElements()) {
        links.nextElement();
        count++;
      }
      if (rootVertex == null && count == 2) {
        links=relation.linkedPorts();
        Port port1=(Port)links.nextElement();
        Port port2=(Port)links.nextElement();
        Node node1=_findNode(g,port1);
        Node node2=_findNode(g,port2);
        Edge newEdge=createEdge(null);
        super.setEdgeHead(newEdge,node1);
        super.setEdgeTail(newEdge,node2);
      }
 else {
        if (rootVertex == null) {
          try {
            Vertex v=new Vertex(relation,relation.uniqueName(""String_Node_Str""));
            rootVertex=createNode(v);
          }
 catch (          Exception e) {
            throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
          }
          addNode(rootVertex,g);
        }
        links=relation.linkedPorts();
        while (links.hasMoreElements()) {
          Port port=(Port)links.nextElement();
          Node foundNode=_findNode(g,port);
          Edge newEdge=createEdge(null);
          super.setEdgeHead(newEdge,foundNode);
          super.setEdgeTail(newEdge,rootVertex);
        }
      }
    }
  }
  return g;
}","/** 
 * Return a new instance of a BasicGraph with the given semantic object.
 */
public Graph createGraph(Object semanticObject){
  Graph g=new BasicGraph();
  g.setSemanticObject(semanticObject);
  if (semanticObject instanceof CompositeEntity) {
    CompositeEntity toplevel=(CompositeEntity)semanticObject;
    Iterator entities=toplevel.entityList().iterator();
    while (entities.hasNext()) {
      Entity entity=(Entity)entities.next();
      Icon icon=(Icon)entity.getAttribute(""String_Node_Str"");
      if (icon == null) {
        try {
          icon=new EditorIcon(entity);
        }
 catch (        Exception e) {
          throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
        }
      }
      addNode(createCompositeNode(icon),g);
    }
    Iterator relations=toplevel.relationList().iterator();
    while (relations.hasNext()) {
      Relation relation=(Relation)relations.next();
      Iterator attributes=relation.attributeList().iterator();
      Node rootVertex=null;
      while (attributes.hasNext()) {
        Attribute a=(Attribute)attributes.next();
        if (a instanceof Vertex) {
          Node n=createNode(a);
          if (((Vertex)a).getLinkedVertex() == null) {
            rootVertex=n;
          }
          addNode(n,g);
        }
      }
      int count=0;
      Enumeration links=relation.linkedPorts();
      while (links.hasMoreElements()) {
        links.nextElement();
        count++;
      }
      if (rootVertex == null && count == 2) {
        links=relation.linkedPorts();
        Port port1=(Port)links.nextElement();
        Port port2=(Port)links.nextElement();
        Node node1=_findNode(g,port1);
        Node node2=_findNode(g,port2);
        Edge newEdge=createEdge(relation);
        super.setEdgeHead(newEdge,node1);
        super.setEdgeTail(newEdge,node2);
      }
 else {
        if (rootVertex == null) {
          try {
            Vertex v=new Vertex(relation,relation.uniqueName(""String_Node_Str""));
            rootVertex=createNode(v);
          }
 catch (          Exception e) {
            throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
          }
          addNode(rootVertex,g);
        }
        links=relation.linkedPorts();
        while (links.hasMoreElements()) {
          Port port=(Port)links.nextElement();
          Node foundNode=_findNode(g,port);
          Edge newEdge=createEdge(null);
          super.setEdgeHead(newEdge,foundNode);
          super.setEdgeTail(newEdge,rootVertex);
        }
      }
    }
  }
  return g;
}"
76244,"/** 
 * Begin capturing audio. This method must be invoked prior to the first invocation of <i>getSamples</i>. This method must not be called more than once between invocations of <i>stopAudio()</i>.
 */
public void startCapture(){
  System.out.println(""String_Node_Str"");
  if (_constructorWasCalled != true) {
    System.out.println(""String_Node_Str"");
  }
  if (_isRealTime == true) {
    _startCaptureRealTime();
  }
 else {
    _startCaptureFromFile();
  }
}","/** 
 * Begin capturing audio. This method must be invoked prior to the first invocation of <i>getSamples</i>. This method must not be called more than once between invocations of <i>stopAudio()</i>.
 */
public void startCapture(){
  if (_isRealTime == true) {
    _startCaptureRealTime();
  }
 else {
    _startCaptureFromFile();
  }
}"
76245,"/** 
 * Construct a sound capture object. This constructor creates an object that captures audio from a sound file.
 * @param isURL True means that a URL to a file is given. False meansthat the file name specifies the location of the file on the local filesystem.
 * @param fileName The name of the file. This can be either a URLfile name or a local file sytem file name.
 * @param getSamplesSize Size of the array returned by<i>getSamples()</i>.
 */
public SoundCapture(boolean isURL,String fileName,int getSamplesSize){
  System.out.println(""String_Node_Str"");
  this._isRealTime=false;
  this._isURL=isURL;
  this._fileName=fileName;
  this._productionRate=getSamplesSize;
  this._constructorWasCalled=true;
}","/** 
 * Construct a sound capture object. This constructor creates an object that captures audio from a sound file.
 * @param isURL True means that a URL to a file is given. False meansthat the file name specifies the location of the file on the local filesystem.
 * @param fileName The name of the file. This can be either a URLfile name or a local file sytem file name.
 * @param getSamplesSize Size of the array returned by<i>getSamples()</i>.
 */
public SoundCapture(boolean isURL,String fileName,int getSamplesSize){
  System.out.println(""String_Node_Str"");
  this._isRealTime=false;
  this._isURL=isURL;
  this._fileName=fileName;
  this._productionRate=getSamplesSize;
}"
76246,"/** 
 * Construct a SqrtRaisedCosineSampleGenerator.
 * @param firstZeroCrossing The time of the first zero crossing ofthe corresponding raised cosine pulse.
 * @param excess The excess bandwidth of the corresponding raisedcosine pulse.
 */
public SqrtRaisedCosineSampleGenerator(double firstZeroCrossing,double excess){
  _excess=excess;
  _oneOverFZC=1.0 / firstZeroCrossing;
  _sqrtFZC=Math.sqrt(firstZeroCrossing);
  _squareFZC=firstZeroCrossing * firstZeroCrossing;
  _onePlus=(1.0 + _excess) * Math.PI * _oneOverFZC;
  _oneMinus=(1.0 - _excess) * Math.PI * _oneOverFZC;
  _fourExcess=4.0 * _excess;
  _eightExcessPI=8.0 * _excess * Math.PI;
  _sixteenExcess=16.0 * _excess;
  _sampleAtZero=((_fourExcess / Math.PI) + 1.0 - _excess) / _sqrtFZC;
  _fourExcessOverPISqrtFZC=_fourExcess / (Math.PI * _sqrtFZC);
  _fzcSqrtFZCOverEightExcessPI=firstZeroCrossing * _sqrtFZC / _eightExcessPI;
  _fzcOverFourExcess=firstZeroCrossing / _fourExcess;
  _oneMinusFZCOverFourExcess=_oneMinus * firstZeroCrossing / _fourExcess;
}","/** 
 * Construct a SqrtRaisedCosineSampleGenerator.
 * @param firstZeroCrossing The time of the first zero crossing ofthe corresponding raised cosine pulse.
 * @param excess The excess bandwidth of the corresponding raisedcosine pulse.
 */
public SqrtRaisedCosineSampleGenerator(double firstZeroCrossing,double excess){
  _excess=excess;
  _oneOverFZC=1.0 / firstZeroCrossing;
  _sqrtFZC=Math.sqrt(firstZeroCrossing);
  _squareFZC=firstZeroCrossing * firstZeroCrossing;
  _onePlus=(1.0 + _excess) * Math.PI * _oneOverFZC;
  _oneMinus=(1.0 - _excess) * Math.PI * _oneOverFZC;
  _fourExcess=4.0 * _excess;
  _eightExcessPI=8.0 * _excess * Math.PI;
  _sixteenExcessSquared=_fourExcess * _fourExcess;
  double fourExcessOverPI=_fourExcess / Math.PI;
  double oneOverSqrtFZC=1.0 / _sqrtFZC;
  _sampleAtZero=(fourExcessOverPI + 1.0 - _excess) * oneOverSqrtFZC;
  _fourExcessOverPISqrtFZC=fourExcessOverPI * oneOverSqrtFZC;
  _fzcSqrtFZCOverEightExcessPI=firstZeroCrossing * _sqrtFZC / _eightExcessPI;
  _fzcOverFourExcess=firstZeroCrossing / _fourExcess;
  _oneMinusFZCOverFourExcess=_oneMinus * _fzcOverFourExcess;
}"
76247,"public final double sampleAt(double time){
  if (time == 0.0) {
    return _sampleAtZero;
  }
  double x=time * _oneOverFZC;
  if (_excess == 0.0) {
    return _sqrtFZC * Math.sin(Math.PI * x) / (Math.PI * time);
  }
  double squareTime=time * time;
  double oneMinusTime=_oneMinus * time;
  double onePlusTime=_onePlus * time;
  double denominator=squareTime * _sixteenExcess - _squareFZC;
  if (close(denominator,0.0)) {
    double oneOverTime=1.0 / time;
    return _fzcSqrtFZCOverEightExcessPI * oneOverTime * (_onePlus * Math.sin(onePlusTime) - _oneMinusFZCOverFourExcess * oneOverTime * Math.cos(oneMinusTime) + _fzcOverFourExcess * squareTime * Math.sin(oneMinusTime));
  }
  return _fourExcessOverPISqrtFZC * (Math.cos(onePlusTime) + Math.sin(oneMinusTime) / (x * _fourExcess)) / (1.0 - _sixteenExcess * x * x);
}","public final double sampleAt(double time){
  if (time == 0.0) {
    return _sampleAtZero;
  }
  double x=time * _oneOverFZC;
  if (_excess == 0.0) {
    return _sqrtFZC * Math.sin(Math.PI * x) / (Math.PI * time);
  }
  double oneMinusTime=_oneMinus * time;
  double onePlusTime=_onePlus * time;
  double denominator=time * time * _sixteenExcessSquared - _squareFZC;
  if (close(denominator,0.0)) {
    double oneOverTime=1.0 / time;
    double oneOverTimeSquared=oneOverTime * oneOverTime;
    return _fzcSqrtFZCOverEightExcessPI * oneOverTime * (_onePlus * Math.sin(onePlusTime) - _oneMinusFZCOverFourExcess * oneOverTime * Math.cos(oneMinusTime) + _fzcOverFourExcess * oneOverTimeSquared * Math.sin(oneMinusTime));
  }
  return _fourExcessOverPISqrtFZC * (Math.cos(onePlusTime) + Math.sin(oneMinusTime) / (x * _fourExcess)) / (1.0 - _sixteenExcessSquared * x * x);
}"
76248,"/** 
 * Read a pxgraph-compatible binary or ASCII encoded file.
 * @param in The input stream.
 * @exception java.io.IOException If an I/O error occurs.
 */
public void read(InputStream inputstream) throws IOException {
  DataInputStream in=new DataInputStream(new BufferedInputStream(inputstream));
  if (binary) {
    int c;
    float x=0, y=0, pointCount=0;
    boolean byteSwapped=false;
    boolean connected=false;
    byte input[]=new byte[4];
    int currentdataset=0;
switch (_endian) {
case _NATIVE_ENDIAN:
      try {
        if (System.getProperty(""String_Node_Str"").equals(""String_Node_Str"")) {
          byteSwapped=true;
        }
      }
 catch (      SecurityException e) {
      }
    break;
case _BIG_ENDIAN:
  break;
case _LITTLE_ENDIAN:
byteSwapped=true;
break;
default :
throw new IOException(""String_Node_Str"" + _endian + ""String_Node_Str"");
}
try {
c=in.readByte();
if (c != 'd') {
int bits=c;
bits=bits << 8;
bits+=in.readByte();
bits=bits << 8;
bits+=in.readByte();
bits=bits << 8;
bits+=in.readByte();
x=Float.intBitsToFloat(bits);
y=in.readFloat();
_plot.addPoint(currentdataset,x,y,connected);
connected=true;
while (true) {
x=in.readFloat();
y=in.readFloat();
_plot.addPoint(currentdataset,x,y,connected);
connected=true;
}
}
 else {
while (true) {
switch (c) {
case 'd':
if (byteSwapped) {
  in.readFully(input);
  x=Float.intBitsToFloat(((input[3] & 0xFF) << 24) | ((input[2] & 0xFF) << 16) | ((input[1] & 0xFF) << 8)| (input[0] & 0xFF));
  in.readFully(input);
  y=Float.intBitsToFloat(((input[3] & 0xFF) << 24) | ((input[2] & 0xFF) << 16) | ((input[1] & 0xFF) << 8)| (input[0] & 0xFF));
}
 else {
  x=in.readFloat();
  y=in.readFloat();
}
pointCount++;
_plot.addPoint(currentdataset,x,y,connected);
connected=true;
break;
case 'e':
connected=false;
break;
case 'n':
StringBuffer datasetname=new StringBuffer();
currentdataset++;
while (c != '\n') datasetname.append(in.readChar());
_plot.addLegend(currentdataset,datasetname.toString());
_plot.setConnected(true);
break;
case 'm':
connected=false;
break;
default :
throw new IOException(""String_Node_Str"" + (char)c + ""String_Node_Str""+ ""String_Node_Str""+ c+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ pointCount+ ""String_Node_Str"");
}
c=in.readByte();
}
}
}
 catch (EOFException e) {
}
}
 else {
_plot.read(inputstream);
}
}","/** 
 * Read a pxgraph-compatible binary or ASCII encoded file.
 * @param in The input stream.
 * @exception java.io.IOException If an I/O error occurs.
 */
public void read(InputStream inputstream) throws IOException {
  DataInputStream in=new DataInputStream(new BufferedInputStream(inputstream));
  if (_binary) {
    int c;
    float x=0, y=0, pointCount=0;
    boolean byteSwapped=false;
    boolean connected=false;
    byte input[]=new byte[4];
    if (_connected)     connected=true;
switch (_endian) {
case _NATIVE_ENDIAN:
      try {
        if (System.getProperty(""String_Node_Str"").equals(""String_Node_Str"")) {
          byteSwapped=true;
        }
      }
 catch (      SecurityException e) {
      }
    break;
case _BIG_ENDIAN:
  break;
case _LITTLE_ENDIAN:
byteSwapped=true;
break;
default :
throw new IOException(""String_Node_Str"" + _endian + ""String_Node_Str"");
}
try {
_firstinset=true;
_sawfirstdataset=false;
c=in.readByte();
if (c != 'd') {
int bits=c;
bits=bits << 8;
bits+=in.readByte();
bits=bits << 8;
bits+=in.readByte();
bits=bits << 8;
bits+=in.readByte();
x=Float.intBitsToFloat(bits);
y=in.readFloat();
connected=_addLegendIfNecessary(connected);
_plot.addPoint(_currentdataset,x,y,connected);
if (_connected) connected=true;
while (true) {
x=in.readFloat();
y=in.readFloat();
connected=_addLegendIfNecessary(connected);
_plot.addPoint(_currentdataset,x,y,connected);
if (_connected) connected=true;
}
}
 else {
while (true) {
switch (c) {
case 'd':
if (byteSwapped) {
  in.readFully(input);
  x=Float.intBitsToFloat(((input[3] & 0xFF) << 24) | ((input[2] & 0xFF) << 16) | ((input[1] & 0xFF) << 8)| (input[0] & 0xFF));
  in.readFully(input);
  y=Float.intBitsToFloat(((input[3] & 0xFF) << 24) | ((input[2] & 0xFF) << 16) | ((input[1] & 0xFF) << 8)| (input[0] & 0xFF));
}
 else {
  x=in.readFloat();
  y=in.readFloat();
}
pointCount++;
connected=_addLegendIfNecessary(connected);
_plot.addPoint(_currentdataset,x,y,connected);
if (_connected) connected=true;
break;
case 'e':
connected=false;
break;
case 'n':
_firstinset=true;
_sawfirstdataset=true;
StringBuffer datasetname=new StringBuffer();
_currentdataset++;
while (c != '\n') datasetname.append(in.readChar());
_plot.addLegend(_currentdataset,datasetname.toString());
_plot.setConnected(true);
break;
case 'm':
connected=false;
break;
default :
throw new IOException(""String_Node_Str"" + (char)c + ""String_Node_Str""+ ""String_Node_Str""+ c+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ pointCount+ ""String_Node_Str"");
}
c=in.readByte();
}
}
}
 catch (EOFException e) {
}
}
 else {
_plot.read(inputstream);
}
}"
76249,"/** 
 * Parse pxgraph style command-line arguments, using the specified base URL for any relative URL references.
 * @param args A set of command-line arguments.
 * @param base A base URL for relative URL references, or null ifthere is none.
 * @return The number of arguments read.
 * @exception CmdLineArgException If there is a problem parsingthe command line arguments.
 * @exception FileNotFoundException If a file is specified that is notfound.
 * @exception IOException If an error occurs reading an input file.
 */
public int parseArgs(String args[],URL base) throws CmdLineArgException, FileNotFoundException, IOException {
  int i=0, j, argumentsRead=0;
  boolean sawbararg=false;
  boolean sawnlarg=false;
  String savedmarks=""String_Node_Str"";
  binary=false;
  int width=400, height=400;
  String arg;
  String unsupportedOptions[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  while (args != null && i < args.length && (args[i].startsWith(""String_Node_Str"") || args[i].startsWith(""String_Node_Str""))) {
    arg=args[i++];
    if (arg.startsWith(""String_Node_Str"")) {
      boolean badarg=false;
      for (j=0; j < unsupportedOptions.length; j++) {
        if (arg.equals(unsupportedOptions[j])) {
          System.err.println(""String_Node_Str"" + arg + ""String_Node_Str"");
          i++;
          badarg=true;
        }
      }
      if (badarg)       continue;
      if (arg.equals(""String_Node_Str"")) {
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setBackground(Plot.getColorByName(args[i++]));
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        double[] spec=_parseDoubles(args[i++]);
        if (spec.length == 1) {
          _plot.setBars(spec[0],0);
        }
 else {
          _plot.setBars(spec[0],spec[1]);
        }
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setLabelFont(args[i++]);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        double[] spec=_parseDoubles(args[i++]);
        if (spec.length == 1) {
          throw new CmdLineArgException(""String_Node_Str"" + arg + ""String_Node_Str"");
        }
 else {
          _plot.setXRange(spec[0],spec[1]);
        }
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        double[] spec=_parseDoubles(args[i++]);
        if (spec.length == 1) {
          throw new CmdLineArgException(""String_Node_Str"" + arg + ""String_Node_Str"");
        }
 else {
          _plot.setYRange(spec[0],spec[1]);
        }
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        String title=args[i++];
        _plot.setTitle(title);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setTitleFont(args[i++]);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setXLabel(args[i++]);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setYLabel(args[i++]);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        sawbararg=true;
        if (sawnlarg) {
          _plot.setImpulses(true);
        }
 else {
          _plot.setBars(true);
          _plot.setMarksStyle(""String_Node_Str"");
        }
        _plot.setConnected(false);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        binary=true;
        _endian=_NATIVE_ENDIAN;
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        binary=true;
        _endian=_BIG_ENDIAN;
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        binary=true;
        _endian=_LITTLE_ENDIAN;
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _debug=10;
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _debug=(int)Integer.valueOf(args[i++]).intValue();
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setForeground(_plot.getColorByName(args[i++]));
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setImpulses(true);
        _plot.setConnected(false);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setXLog(true);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setYLog(true);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setMarksStyle(""String_Node_Str"");
        savedmarks=""String_Node_Str"";
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setMarksStyle(""String_Node_Str"");
        savedmarks=""String_Node_Str"";
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        sawnlarg=true;
        if (sawbararg) {
          _plot.setMarksStyle(savedmarks);
          _plot.setBars(false);
          _plot.setImpulses(true);
        }
        _plot.setConnected(false);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        i++;
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setMarksStyle(""String_Node_Str"");
        savedmarks=""String_Node_Str"";
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setMarksStyle(""String_Node_Str"");
        savedmarks=""String_Node_Str"";
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setBackground(_plot.getColorByName(""String_Node_Str""));
        _plot.setForeground(_plot.getColorByName(""String_Node_Str""));
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setGrid(false);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
        continue;
      }
 else       if (arg.length() > 1 && arg.charAt(0) == '-') {
        try {
          Integer datasetnumberint=new Integer(arg.substring(1));
          int datasetnumber=datasetnumberint.intValue();
          if (datasetnumber >= 0) {
            _plot.addLegend(datasetnumber,args[i++]);
            continue;
          }
        }
 catch (        NumberFormatException e) {
        }
      }
    }
 else {
      if (arg.startsWith(""String_Node_Str"")) {
        width=(int)Integer.valueOf(arg.substring(1,arg.indexOf('x'))).intValue();
        int plusIndex=arg.indexOf('+');
        int minusIndex=arg.indexOf('-');
        if (plusIndex != -1 || minusIndex != -1) {
          if (plusIndex != -1 && minusIndex != -1) {
            int index=minusIndex;
            if (plusIndex < minusIndex) {
              index=plusIndex;
            }
            height=Integer.valueOf(arg.substring(arg.indexOf('x') + 1,index)).intValue();
          }
 else {
            if (plusIndex != -1) {
              height=Integer.valueOf(arg.substring(arg.indexOf('x') + 1,plusIndex)).intValue();
            }
 else {
              height=Integer.valueOf(arg.substring(arg.indexOf('x') + 1,minusIndex)).intValue();
            }
          }
        }
 else {
          if (arg.length() > arg.indexOf('x')) {
            height=Integer.valueOf(arg.substring(arg.indexOf('x') + 1,arg.length())).intValue();
          }
        }
        continue;
      }
    }
    throw new CmdLineArgException(""String_Node_Str"" + arg + ""String_Node_Str"");
  }
  argumentsRead=i++;
  _plot.setSize(width,height);
  for (i=argumentsRead; i < args.length; i++) {
    InputStream instream;
    try {
      URL inurl=new URL(base,args[i]);
      instream=inurl.openStream();
    }
 catch (    MalformedURLException ex) {
      instream=new FileInputStream(args[i]);
    }
    read(instream);
  }
  return argumentsRead;
}","/** 
 * Parse pxgraph style command-line arguments, using the specified base URL for any relative URL references.
 * @param args A set of command-line arguments.
 * @param base A base URL for relative URL references, or null ifthere is none.
 * @return The number of arguments read.
 * @exception CmdLineArgException If there is a problem parsingthe command line arguments.
 * @exception FileNotFoundException If a file is specified that is notfound.
 * @exception IOException If an error occurs reading an input file.
 */
public int parseArgs(String args[],URL base) throws CmdLineArgException, FileNotFoundException, IOException {
  int i=0, j, argumentsRead=0;
  boolean sawbararg=false;
  boolean sawnlarg=false;
  String savedmarks=""String_Node_Str"";
  _binary=false;
  int width=400, height=400;
  String arg;
  String unsupportedOptions[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  while (args != null && i < args.length && (args[i].startsWith(""String_Node_Str"") || args[i].startsWith(""String_Node_Str""))) {
    arg=args[i++];
    if (arg.startsWith(""String_Node_Str"")) {
      boolean badarg=false;
      for (j=0; j < unsupportedOptions.length; j++) {
        if (arg.equals(unsupportedOptions[j])) {
          System.err.println(""String_Node_Str"" + arg + ""String_Node_Str"");
          i++;
          badarg=true;
        }
      }
      if (badarg)       continue;
      if (arg.equals(""String_Node_Str"")) {
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setBackground(Plot.getColorByName(args[i++]));
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        double[] spec=_parseDoubles(args[i++]);
        if (spec.length == 1) {
          _plot.setBars(spec[0],0);
        }
 else {
          _plot.setBars(spec[0],spec[1]);
        }
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setLabelFont(args[i++]);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        double[] spec=_parseDoubles(args[i++]);
        if (spec.length == 1) {
          throw new CmdLineArgException(""String_Node_Str"" + arg + ""String_Node_Str"");
        }
 else {
          _plot.setXRange(spec[0],spec[1]);
        }
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        double[] spec=_parseDoubles(args[i++]);
        if (spec.length == 1) {
          throw new CmdLineArgException(""String_Node_Str"" + arg + ""String_Node_Str"");
        }
 else {
          _plot.setYRange(spec[0],spec[1]);
        }
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        String title=args[i++];
        _plot.setTitle(title);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setTitleFont(args[i++]);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setXLabel(args[i++]);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setYLabel(args[i++]);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        sawbararg=true;
        if (sawnlarg) {
          _plot.setImpulses(true);
        }
 else {
          _plot.setBars(true);
          _plot.setMarksStyle(""String_Node_Str"");
        }
        _plot.setConnected(false);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _binary=true;
        _endian=_NATIVE_ENDIAN;
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _binary=true;
        _endian=_BIG_ENDIAN;
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _binary=true;
        _endian=_LITTLE_ENDIAN;
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _debug=10;
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _debug=(int)Integer.valueOf(args[i++]).intValue();
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setForeground(_plot.getColorByName(args[i++]));
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setImpulses(true);
        _plot.setConnected(false);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setXLog(true);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setYLog(true);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setMarksStyle(""String_Node_Str"");
        savedmarks=""String_Node_Str"";
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setMarksStyle(""String_Node_Str"");
        savedmarks=""String_Node_Str"";
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        sawnlarg=true;
        if (sawbararg) {
          _plot.setMarksStyle(savedmarks);
          _plot.setBars(false);
          _plot.setImpulses(true);
        }
        _plot.setConnected(false);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        i++;
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setMarksStyle(""String_Node_Str"");
        savedmarks=""String_Node_Str"";
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setMarksStyle(""String_Node_Str"");
        savedmarks=""String_Node_Str"";
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setBackground(_plot.getColorByName(""String_Node_Str""));
        _plot.setForeground(_plot.getColorByName(""String_Node_Str""));
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        continue;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        _plot.setGrid(false);
        continue;
      }
 else       if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
        continue;
      }
 else       if (arg.length() > 1 && arg.charAt(0) == '-') {
        try {
          Integer datasetnumberint=new Integer(arg.substring(1));
          int datasetnumber=datasetnumberint.intValue();
          if (datasetnumber >= 0) {
            _plot.addLegend(datasetnumber,args[i++]);
            continue;
          }
        }
 catch (        NumberFormatException e) {
        }
      }
    }
 else {
      if (arg.startsWith(""String_Node_Str"")) {
        width=(int)Integer.valueOf(arg.substring(1,arg.indexOf('x'))).intValue();
        int plusIndex=arg.indexOf('+');
        int minusIndex=arg.indexOf('-');
        if (plusIndex != -1 || minusIndex != -1) {
          if (plusIndex != -1 && minusIndex != -1) {
            int index=minusIndex;
            if (plusIndex < minusIndex) {
              index=plusIndex;
            }
            height=Integer.valueOf(arg.substring(arg.indexOf('x') + 1,index)).intValue();
          }
 else {
            if (plusIndex != -1) {
              height=Integer.valueOf(arg.substring(arg.indexOf('x') + 1,plusIndex)).intValue();
            }
 else {
              height=Integer.valueOf(arg.substring(arg.indexOf('x') + 1,minusIndex)).intValue();
            }
          }
        }
 else {
          if (arg.length() > arg.indexOf('x')) {
            height=Integer.valueOf(arg.substring(arg.indexOf('x') + 1,arg.length())).intValue();
          }
        }
        continue;
      }
    }
    throw new CmdLineArgException(""String_Node_Str"" + arg + ""String_Node_Str"");
  }
  argumentsRead=i++;
  _plot.setSize(width,height);
  for (i=argumentsRead; i < args.length; i++) {
    InputStream instream;
    try {
      URL inurl=new URL(base,args[i]);
      instream=inurl.openStream();
    }
 catch (    MalformedURLException ex) {
      instream=new FileInputStream(args[i]);
    }
    read(instream);
  }
  return argumentsRead;
}"
76250,"/** 
 * Return a token from the queue. If no token is available, then throw a NoTokenException. If at any point during this method this receiver is scheduled for termination, then throw a TerminateProcessException to cease execution of the actor that contains this receiver. <P> IMPORTANT: This method is designed to be called after hasToken() has been called. Verify that this method is safe to call by calling hasToken() first. Note that this method does not perform a blocking read but hasToken() does.
 * @return The oldest token on this queue.
 * @exception NoTokenException If this method is called whilehasToken() returns false.
 * @see hasToken()
 */
public Token get() throws NoTokenException {
  DDEDirector director=(DDEDirector)((Actor)getContainer().getContainer()).getDirector();
synchronized (this) {
    if (_terminate) {
      throw new TerminateProcessException(""String_Node_Str"");
    }
    Token token=super.get();
    if (_writePending) {
      director.removeWriteBlock(this);
      _writePending=false;
      notifyAll();
    }
    Thread thread=Thread.currentThread();
    if (thread instanceof DDEThread) {
      TimeKeeper timeKeeper=((DDEThread)thread).getTimeKeeper();
      timeKeeper.sendOutNullTokens(this);
    }
    return token;
  }
}","/** 
 * Return a token from the queue. If no token is available, then throw a NoTokenException. If at any point during this method this receiver is scheduled for termination, then throw a TerminateProcessException to cease execution of the actor that contains this receiver. <P> IMPORTANT: This method is designed to be called after hasToken() has been called. Verify that this method is safe to call by calling hasToken() first. Note that this method does not perform a blocking read but hasToken() does.
 * @return The oldest token on this queue.
 * @exception NoTokenException If this method is called whilehasToken() returns false.
 * @see #hasToken()
 */
public Token get() throws NoTokenException {
  DDEDirector director=(DDEDirector)((Actor)getContainer().getContainer()).getDirector();
synchronized (this) {
    if (_terminate) {
      throw new TerminateProcessException(""String_Node_Str"");
    }
    Token token=super.get();
    if (_writePending) {
      director.removeWriteBlock(this);
      _writePending=false;
      notifyAll();
    }
    Thread thread=Thread.currentThread();
    if (thread instanceof DDEThread) {
      TimeKeeper timeKeeper=((DDEThread)thread).getTimeKeeper();
      timeKeeper.sendOutNullTokens(this);
    }
    return token;
  }
}"
76251,"/** 
 * Initialize the applet.
 */
public void init(){
  super.init();
  try {
    setSize(600,600);
    getContentPane().setLayout(new BoxLayout(getContentPane(),BoxLayout.Y_AXIS));
    _query=new Query();
    _query.setBackground(getBackground());
    _query.addQueryListener(this);
    _query.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    _query.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    getContentPane().add(_query);
    _eventplot=new SequencePlotter(_toplevel,""String_Node_Str"");
    _eventplot.place(getContentPane());
    _eventplot.plot.setBackground(getBackground());
    _eventplot.plot.setGrid(false);
    _eventplot.plot.setTitle(""String_Node_Str"");
    _eventplot.plot.addLegend(0,""String_Node_Str"");
    _eventplot.plot.setXLabel(""String_Node_Str"");
    _eventplot.plot.setYLabel(""String_Node_Str"");
    _eventplot.plot.setXRange(0.0,21.0);
    _eventplot.plot.setYRange(-1.0,1000.0);
    _eventplot.plot.setSize(450,200);
    _eventplot.plot.setConnected(false);
    _eventplot.plot.setImpulses(true);
    _eventplot.plot.setMarksStyle(""String_Node_Str"");
    _eventplot.fillOnWrapup.setToken(new BooleanToken(false));
    _ND_6=new ND_6(_toplevel,""String_Node_Str"");
    _ND_66=new ND_66(_toplevel,""String_Node_Str"");
    _ND_14=new ND_14(_toplevel,""String_Node_Str"");
    _ND_36=new ND_36(_toplevel,""String_Node_Str"");
    _ND_86=new ND_86(_toplevel,""String_Node_Str"");
    _s2m=new StreamToMatrix(_toplevel,""String_Node_Str"");
    _matrixViewer=new MatrixViewer(_toplevel,""String_Node_Str"");
    _matrixViewer.place(getContentPane());
    _toplevel.connect(_ND_6.out0,_ND_36.in1);
    _toplevel.connect(_ND_6.out1,_ND_66.in1);
    _toplevel.connect(_ND_14.out0,_ND_36.in3);
    _toplevel.connect(_ND_14.out1,_ND_66.in3);
    _toplevel.connect(_ND_36.out0,_ND_36.in0);
    _toplevel.connect(_ND_36.out1,_ND_86.in0);
    _toplevel.connect(_ND_36.out2,_ND_66.in5);
    _toplevel.connect(_ND_66.out0,_ND_66.in0);
    _toplevel.connect(_ND_66.out1,_ND_86.in1);
    _toplevel.connect(_ND_66.out2,_ND_36.in2);
    _toplevel.connect(_ND_66.out3,_ND_66.in2);
    _toplevel.connect(_ND_66.out4,_ND_66.in4);
    Relation t=_toplevel.connect(_ND_86.out0,_eventplot.input);
    _s2m.input.link(t);
    _toplevel.connect(_s2m.output,_matrixViewer.input);
    _initCompleted=true;
    getContentPane().add(_createRunControls(2));
  }
 catch (  Exception ex) {
    report(""String_Node_Str"",ex);
  }
  return;
}","/** 
 * Initialize the applet.
 */
public void init(){
  super.init();
  try {
    setSize(600,600);
    getContentPane().setLayout(new BoxLayout(getContentPane(),BoxLayout.Y_AXIS));
    _query=new Query();
    _query.setBackground(getBackground());
    _query.addQueryListener(this);
    _query.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    _query.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    getContentPane().add(_query);
    _eventplot=new SequencePlotter(_toplevel,""String_Node_Str"");
    _eventplot.place(getContentPane());
    _eventplot.plot.setBackground(getBackground());
    _eventplot.plot.setGrid(false);
    _eventplot.plot.setTitle(""String_Node_Str"");
    _eventplot.plot.addLegend(0,""String_Node_Str"");
    _eventplot.plot.setXLabel(""String_Node_Str"");
    _eventplot.plot.setYLabel(""String_Node_Str"");
    _eventplot.plot.setXRange(0.0,21.0);
    _eventplot.plot.setYRange(-1.0,1000.0);
    _eventplot.plot.setSize(450,200);
    _eventplot.plot.setConnected(false);
    _eventplot.plot.setImpulses(true);
    _eventplot.plot.setMarksStyle(""String_Node_Str"");
    _eventplot.fillOnWrapup.setToken(new BooleanToken(false));
    _ND_6=new ND_6(_toplevel,""String_Node_Str"");
    _ND_66=new ND_66(_toplevel,""String_Node_Str"");
    _ND_14=new ND_14(_toplevel,""String_Node_Str"");
    _ND_36=new ND_36(_toplevel,""String_Node_Str"");
    _ND_86=new ND_86(_toplevel,""String_Node_Str"");
    _s2m=new StreamToMatrix(_toplevel,""String_Node_Str"");
    _matrixViewer=new MatrixViewer(_toplevel,""String_Node_Str"");
    _matrixViewer.place(getContentPane());
    _matrixViewer.setSize(1,1);
    _toplevel.connect(_ND_6.out0,_ND_36.in1);
    _toplevel.connect(_ND_6.out1,_ND_66.in1);
    _toplevel.connect(_ND_14.out0,_ND_36.in3);
    _toplevel.connect(_ND_14.out1,_ND_66.in3);
    _toplevel.connect(_ND_36.out0,_ND_36.in0);
    _toplevel.connect(_ND_36.out1,_ND_86.in0);
    _toplevel.connect(_ND_36.out2,_ND_66.in5);
    _toplevel.connect(_ND_66.out0,_ND_66.in0);
    _toplevel.connect(_ND_66.out1,_ND_86.in1);
    _toplevel.connect(_ND_66.out2,_ND_36.in2);
    _toplevel.connect(_ND_66.out3,_ND_66.in2);
    _toplevel.connect(_ND_66.out4,_ND_66.in4);
    Relation t=_toplevel.connect(_ND_86.out0,_eventplot.input);
    _s2m.input.link(t);
    _toplevel.connect(_s2m.output,_matrixViewer.input);
    _initCompleted=true;
    getContentPane().add(_createRunControls(2));
  }
 catch (  Exception ex) {
    report(""String_Node_Str"",ex);
  }
  return;
}"
76252,"/** 
 * Changing of a parameter has occured. First check if the parameter (K or N) falls within the range of allowed values. Then propagate the new parameter value to the various actors in the model. If a valid change of a parameter took place, execute the model again.
 * @param name The name of the entry that changed.
 */
public void changed(String name){
  try {
    boolean done=false;
    if (name == ""String_Node_Str"") {
      int k=(int)_query.intValue(""String_Node_Str"");
      if ((k < 501) && (k > 0)) {
        _ND_6.parameter_K.setToken(new IntToken((int)_query.intValue(""String_Node_Str"")));
        _ND_14.parameter_K.setToken(new IntToken((int)_query.intValue(""String_Node_Str"")));
        _ND_66.parameter_K.setToken(new IntToken((int)_query.intValue(""String_Node_Str"")));
        _ND_36.parameter_K.setToken(new IntToken((int)_query.intValue(""String_Node_Str"")));
        _ND_86.parameter_K.setToken(new IntToken((int)_query.intValue(""String_Node_Str"")));
        done=true;
      }
 else {
        throw new IllegalActionException(""String_Node_Str"");
      }
    }
    if (name == ""String_Node_Str"") {
      int n=(int)_query.intValue(""String_Node_Str"");
      if ((n < 17) && (n > 1)) {
        _s2m.dimension.setToken(new IntToken((int)_query.intValue(""String_Node_Str"")));
        _ND_6.parameter_N.setToken(new IntToken((int)_query.intValue(""String_Node_Str"")));
        _ND_14.parameter_N.setToken(new IntToken((int)_query.intValue(""String_Node_Str"")));
        _ND_66.parameter_N.setToken(new IntToken((int)_query.intValue(""String_Node_Str"")));
        _ND_36.parameter_N.setToken(new IntToken((int)_query.intValue(""String_Node_Str"")));
        _ND_86.parameter_N.setToken(new IntToken((int)_query.intValue(""String_Node_Str"")));
        done=true;
      }
 else {
        throw new IllegalActionException(""String_Node_Str"");
      }
    }
    if (done) {
      _go();
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex.toString());
  }
}","/** 
 * Changing of a parameter has occured. First check if the parameter (K or N) falls within the range of allowed values. Then propagate the new parameter value to the various actors in the model. If a valid change of a parameter took place, execute the model again.
 * @param name The name of the entry that changed.
 */
public void changed(String name){
  try {
    boolean done=false;
    if (name == ""String_Node_Str"") {
      int k=(int)_query.intValue(""String_Node_Str"");
      if ((0 < k) && (k < 501)) {
        _ND_6.parameter_K.setToken(new IntToken(k));
        _ND_14.parameter_K.setToken(new IntToken(k));
        _ND_66.parameter_K.setToken(new IntToken(k));
        _ND_36.parameter_K.setToken(new IntToken(k));
        _ND_86.parameter_K.setToken(new IntToken(k));
        done=true;
      }
 else {
        report(""String_Node_Str"");
      }
    }
 else {
      if (name == ""String_Node_Str"") {
        int n=(int)_query.intValue(""String_Node_Str"");
        if ((1 < n) && (n < 17)) {
          _s2m.dimension.setToken(new IntToken(n));
          _ND_6.parameter_N.setToken(new IntToken(n));
          _ND_14.parameter_N.setToken(new IntToken(n));
          _ND_66.parameter_N.setToken(new IntToken(n));
          _ND_36.parameter_N.setToken(new IntToken(n));
          _ND_86.parameter_N.setToken(new IntToken(n));
          done=true;
        }
 else {
          report(""String_Node_Str"");
        }
      }
    }
    if (done) {
      _go();
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex.toString());
  }
}"
76253,"/** 
 * Initialize the applet.
 */
public void init(){
  super.init();
  try {
    getContentPane().add(_createRunControls(2),BorderLayout.NORTH);
    _toplevel.setName(""String_Node_Str"");
    CTMultiSolverDirector topdir=new CTMultiSolverDirector(_toplevel,""String_Node_Str"");
    Const source=new Const(_toplevel,""String_Node_Str"");
    source.value.setToken(new DoubleToken(1.0));
    TimedPlotter responsePlot=new TimedPlotter(_toplevel,""String_Node_Str"");
    responsePlot.place(getContentPane());
    responsePlot.plot.setBackground(getBackground());
    responsePlot.plot.setGrid(true);
    responsePlot.plot.setTitle(""String_Node_Str"");
    responsePlot.plot.addLegend(0,""String_Node_Str"");
    responsePlot.plot.setConnected(true);
    responsePlot.plot.setImpulses(false);
    responsePlot.plot.setXRange(0.0,5.0);
    responsePlot.plot.setYRange(-0.1,0.3);
    responsePlot.plot.setSize(500,300);
    CTCompositeActor hs=new CTCompositeActor(_toplevel,""String_Node_Str"");
    TypedIOPort hsin=(TypedIOPort)hs.newPort(""String_Node_Str"");
    hsin.setInput(true);
    hsin.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort hsst=(TypedIOPort)hs.newPort(""String_Node_Str"");
    hsst.setOutput(true);
    hsst.setTypeEquals(BaseType.DOUBLE);
    HSController ctrl=new HSController(hs,""String_Node_Str"");
    FSMState ctrlInc=new FSMState(ctrl,""String_Node_Str"");
    FSMState ctrlDec=new FSMState(ctrl,""String_Node_Str"");
    ctrl.setInitialState(ctrlInc);
    FSMTransition ctrlTr1=ctrl.createTransition(ctrlInc,ctrlDec);
    ctrlTr1.setTriggerEvent(""String_Node_Str"");
    HSInit hsinit1=new HSInit(ctrlTr1,""String_Node_Str"",""String_Node_Str"");
    FSMTransition ctrlTr2=ctrl.createTransition(ctrlDec,ctrlInc);
    ctrlTr2.setTriggerEvent(""String_Node_Str"");
    HSInit hsinit2=new HSInit(ctrlTr2,""String_Node_Str"",""String_Node_Str"");
    HSDirector hsdir=new HSDirector(hs,""String_Node_Str"");
    hsdir.setController(ctrl);
    CTCompositeActor ctInc=new CTCompositeActor(hs,""String_Node_Str"");
    CTZeroOrderHold ctIncH=new CTZeroOrderHold(ctInc,""String_Node_Str"");
    Integrator ctIncI=new Integrator(ctInc,""String_Node_Str"");
    CTZeroCrossingDetector ctIncD=new CTZeroCrossingDetector(ctInc,""String_Node_Str"");
    Expression ctIncGF=new Expression(ctInc,""String_Node_Str"");
    TypedIOPort ctIncGFi=(TypedIOPort)ctIncGF.newPort(""String_Node_Str"");
    ctIncGFi.setInput(true);
    ctIncGFi.setTypeEquals(BaseType.DOUBLE);
    ctIncGF.output.setTypeEquals(BaseType.DOUBLE);
    ctIncGF.expression.setExpression(""String_Node_Str"");
    TypedIOPort ctIncIn=(TypedIOPort)ctInc.newPort(""String_Node_Str"");
    ctIncIn.setInput(true);
    ctIncIn.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort ctIncOut=(TypedIOPort)ctInc.newPort(""String_Node_Str"");
    ctIncOut.setOutput(true);
    ctIncOut.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort ctIncSt=(TypedIOPort)ctInc.newPort(""String_Node_Str"");
    ctIncSt.setOutput(true);
    ctIncSt.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort ctIncTr=(TypedIOPort)ctInc.newPort(""String_Node_Str"");
    ctIncTr.setOutput(true);
    ctIncTr.setTypeEquals(BaseType.DOUBLE);
    ctInc.connect(ctIncIn,ctIncH.input);
    ctInc.connect(ctIncH.output,ctIncI.input);
    Relation ctIncR2=ctInc.newRelation(""String_Node_Str"");
    ctIncGF.output.link(ctIncR2);
    ctIncD.trigger.link(ctIncR2);
    ctIncTr.link(ctIncR2);
    ctInc.connect(ctIncD.output,ctIncOut);
    TypedIORelation ctIncR1=(TypedIORelation)ctInc.newRelation(""String_Node_Str"");
    ctIncI.output.link(ctIncR1);
    ctIncD.input.link(ctIncR1);
    ctIncGFi.link(ctIncR1);
    ctIncSt.link(ctIncR1);
    CTEmbeddedDirector ctIncDir=new CTEmbeddedDirector(ctInc,""String_Node_Str"");
    CTCompositeActor ctDec=new CTCompositeActor(hs,""String_Node_Str"");
    CTZeroOrderHold ctDecH=new CTZeroOrderHold(ctDec,""String_Node_Str"");
    Integrator ctDecI=new Integrator(ctDec,""String_Node_Str"");
    Scale ctGain=new Scale(ctDec,""String_Node_Str"");
    CTZeroCrossingDetector ctDecD=new CTZeroCrossingDetector(ctDec,""String_Node_Str"");
    Expression ctDecGF=new Expression(ctDec,""String_Node_Str"");
    TypedIOPort ctDecGFi=(TypedIOPort)ctDecGF.newPort(""String_Node_Str"");
    ctDecGFi.setInput(true);
    ctDecGFi.setTypeEquals(BaseType.DOUBLE);
    ctDecGF.output.setTypeEquals(BaseType.DOUBLE);
    ctDecGF.expression.setExpression(""String_Node_Str"");
    TypedIOPort ctDecIn=(TypedIOPort)ctDec.newPort(""String_Node_Str"");
    ctDecIn.setInput(true);
    ctDecIn.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort ctDecOut=(TypedIOPort)ctDec.newPort(""String_Node_Str"");
    ctDecOut.setOutput(true);
    ctDecOut.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort ctDecSt=(TypedIOPort)ctDec.newPort(""String_Node_Str"");
    ctDecSt.setOutput(true);
    ctDecSt.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort ctDecTr=(TypedIOPort)ctDec.newPort(""String_Node_Str"");
    ctDecTr.setOutput(true);
    ctDecTr.setTypeEquals(BaseType.DOUBLE);
    ctDec.connect(ctDecIn,ctDecH.input);
    ctDec.connect(ctDecH.output,ctGain.input);
    ctDec.connect(ctGain.output,ctDecI.input);
    Relation ctDecR2=ctDec.newRelation(""String_Node_Str"");
    ctDecGF.output.link(ctDecR2);
    ctDecD.trigger.link(ctDecR2);
    ctDecTr.link(ctDecR2);
    ctDec.connect(ctDecD.output,ctDecOut);
    TypedIORelation ctDecR1=(TypedIORelation)ctDec.newRelation(""String_Node_Str"");
    ctDecI.output.link(ctDecR1);
    ctDecD.input.link(ctDecR1);
    ctDecGFi.link(ctDecR1);
    ctDecSt.link(ctDecR1);
    CTEmbeddedDirector ctDecDir=new CTEmbeddedDirector(ctDec,""String_Node_Str"");
    ctrlInc.setRefinement(ctInc);
    ctrlDec.setRefinement(ctDec);
    TypedIORelation hsr1=(TypedIORelation)hs.newRelation(""String_Node_Str"");
    hsin.link(hsr1);
    ctIncIn.link(hsr1);
    ctDecIn.link(hsr1);
    TypedIORelation hsr2=(TypedIORelation)hs.newRelation(""String_Node_Str"");
    ctIncOut.link(hsr2);
    ctDecOut.link(hsr2);
    TypedIORelation hsr3=(TypedIORelation)hs.newRelation(""String_Node_Str"");
    hsst.link(hsr3);
    ctIncSt.link(hsr3);
    ctDecSt.link(hsr3);
    Relation hsr4=hs.newRelation(""String_Node_Str"");
    ctIncTr.link(hsr4);
    ctDecTr.link(hsr4);
    _toplevel.connect(source.output,hsin);
    _toplevel.connect(hsst,responsePlot.input);
    topdir.setStopTime(5.0);
    ctIncDir.InitStepSize.setToken(new DoubleToken(0.01));
    ctIncDir.MinStepSize.setToken(new DoubleToken(1e-3));
    ctIncDir.MaxStepSize.setToken(new DoubleToken(0.05));
    StringToken tok=new StringToken(""String_Node_Str"");
    ctIncDir.BreakpointODESolver.setToken(tok);
    Parameter dfsol=(Parameter)ctIncDir.getAttribute(""String_Node_Str"");
    tok=new StringToken(""String_Node_Str"");
    ctIncDir.ODESolver.setToken(tok);
    ctDecDir.InitStepSize.setToken(new DoubleToken(0.01));
    ctDecDir.MinStepSize.setToken(new DoubleToken(1e-3));
    ctDecDir.MaxStepSize.setToken(new DoubleToken(0.05));
    tok=new StringToken(""String_Node_Str"");
    ctDecDir.BreakpointODESolver.setToken(tok);
    tok=new StringToken(""String_Node_Str"");
    ctDecDir.ODESolver.setToken(tok);
    ctGain.factor.setToken(new DoubleToken(-1.0));
    topdir.InitStepSize.setToken(new DoubleToken(0.01));
    topdir.MinStepSize.setToken(new DoubleToken(1e-3));
    topdir.MaxStepSize.setToken(new DoubleToken(0.05));
    tok=new StringToken(""String_Node_Str"");
    topdir.BreakpointODESolver.setToken(tok);
    tok=new StringToken(""String_Node_Str"");
    topdir.ODESolver.setToken(tok);
  }
 catch (  KernelException ex) {
    report(""String_Node_Str"",ex);
  }
}","/** 
 * Initialize the applet.
 */
public void init(){
  super.init();
  try {
    getContentPane().add(_createRunControls(2),BorderLayout.NORTH);
    _toplevel.setName(""String_Node_Str"");
    CTMultiSolverDirector topdir=new CTMultiSolverDirector(_toplevel,""String_Node_Str"");
    StreamListener dbl=new StreamListener();
    Const source=new Const(_toplevel,""String_Node_Str"");
    source.value.setToken(new DoubleToken(1.0));
    TimedPlotter responsePlot=new TimedPlotter(_toplevel,""String_Node_Str"");
    responsePlot.place(getContentPane());
    responsePlot.plot.setBackground(getBackground());
    responsePlot.plot.setGrid(true);
    responsePlot.plot.setTitle(""String_Node_Str"");
    responsePlot.plot.addLegend(0,""String_Node_Str"");
    responsePlot.plot.setConnected(true);
    responsePlot.plot.setImpulses(false);
    responsePlot.plot.setXRange(0.0,5.0);
    responsePlot.plot.setYRange(-0.1,0.3);
    responsePlot.plot.setSize(500,300);
    CTCompositeActor hs=new CTCompositeActor(_toplevel,""String_Node_Str"");
    TypedIOPort hsin=(TypedIOPort)hs.newPort(""String_Node_Str"");
    hsin.setInput(true);
    hsin.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort hsst=(TypedIOPort)hs.newPort(""String_Node_Str"");
    hsst.setOutput(true);
    hsst.setTypeEquals(BaseType.DOUBLE);
    HSController ctrl=new HSController(hs,""String_Node_Str"");
    FSMState ctrlInc=new FSMState(ctrl,""String_Node_Str"");
    FSMState ctrlDec=new FSMState(ctrl,""String_Node_Str"");
    ctrl.setInitialState(ctrlInc);
    FSMTransition ctrlTr1=ctrl.createTransition(ctrlInc,ctrlDec);
    ctrlTr1.setTriggerEvent(""String_Node_Str"");
    HSInit hsinit1=new HSInit(ctrlTr1,""String_Node_Str"",""String_Node_Str"");
    FSMTransition ctrlTr2=ctrl.createTransition(ctrlDec,ctrlInc);
    ctrlTr2.setTriggerEvent(""String_Node_Str"");
    HSInit hsinit2=new HSInit(ctrlTr2,""String_Node_Str"",""String_Node_Str"");
    HSDirector hsdir=new HSDirector(hs,""String_Node_Str"");
    hsdir.setController(ctrl);
    CTCompositeActor ctInc=new CTCompositeActor(hs,""String_Node_Str"");
    CTZeroOrderHold ctIncH=new CTZeroOrderHold(ctInc,""String_Node_Str"");
    Integrator ctIncI=new Integrator(ctInc,""String_Node_Str"");
    CTZeroCrossingDetector ctIncD=new CTZeroCrossingDetector(ctInc,""String_Node_Str"");
    Expression ctIncGF=new Expression(ctInc,""String_Node_Str"");
    TypedIOPort ctIncGFi=(TypedIOPort)ctIncGF.newPort(""String_Node_Str"");
    ctIncGFi.setInput(true);
    ctIncGFi.setTypeEquals(BaseType.DOUBLE);
    ctIncGF.output.setTypeEquals(BaseType.DOUBLE);
    ctIncGF.expression.setExpression(""String_Node_Str"");
    TypedIOPort ctIncIn=(TypedIOPort)ctInc.newPort(""String_Node_Str"");
    ctIncIn.setInput(true);
    ctIncIn.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort ctIncOut=(TypedIOPort)ctInc.newPort(""String_Node_Str"");
    ctIncOut.setOutput(true);
    ctIncOut.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort ctIncSt=(TypedIOPort)ctInc.newPort(""String_Node_Str"");
    ctIncSt.setOutput(true);
    ctIncSt.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort ctIncTr=(TypedIOPort)ctInc.newPort(""String_Node_Str"");
    ctIncTr.setOutput(true);
    ctIncTr.setTypeEquals(BaseType.DOUBLE);
    ctInc.connect(ctIncIn,ctIncH.input);
    ctInc.connect(ctIncH.output,ctIncI.input);
    Relation ctIncR2=ctInc.newRelation(""String_Node_Str"");
    ctIncGF.output.link(ctIncR2);
    ctIncD.trigger.link(ctIncR2);
    ctIncTr.link(ctIncR2);
    ctInc.connect(ctIncD.output,ctIncOut);
    TypedIORelation ctIncR1=(TypedIORelation)ctInc.newRelation(""String_Node_Str"");
    ctIncI.output.link(ctIncR1);
    ctIncD.input.link(ctIncR1);
    ctIncGFi.link(ctIncR1);
    ctIncSt.link(ctIncR1);
    CTEmbeddedDirector ctIncDir=new CTEmbeddedDirector(ctInc,""String_Node_Str"");
    CTCompositeActor ctDec=new CTCompositeActor(hs,""String_Node_Str"");
    CTZeroOrderHold ctDecH=new CTZeroOrderHold(ctDec,""String_Node_Str"");
    Integrator ctDecI=new Integrator(ctDec,""String_Node_Str"");
    Scale ctGain=new Scale(ctDec,""String_Node_Str"");
    CTZeroCrossingDetector ctDecD=new CTZeroCrossingDetector(ctDec,""String_Node_Str"");
    Expression ctDecGF=new Expression(ctDec,""String_Node_Str"");
    TypedIOPort ctDecGFi=(TypedIOPort)ctDecGF.newPort(""String_Node_Str"");
    ctDecGFi.setInput(true);
    ctDecGFi.setTypeEquals(BaseType.DOUBLE);
    ctDecGF.output.setTypeEquals(BaseType.DOUBLE);
    ctDecGF.expression.setExpression(""String_Node_Str"");
    TypedIOPort ctDecIn=(TypedIOPort)ctDec.newPort(""String_Node_Str"");
    ctDecIn.setInput(true);
    ctDecIn.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort ctDecOut=(TypedIOPort)ctDec.newPort(""String_Node_Str"");
    ctDecOut.setOutput(true);
    ctDecOut.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort ctDecSt=(TypedIOPort)ctDec.newPort(""String_Node_Str"");
    ctDecSt.setOutput(true);
    ctDecSt.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort ctDecTr=(TypedIOPort)ctDec.newPort(""String_Node_Str"");
    ctDecTr.setOutput(true);
    ctDecTr.setTypeEquals(BaseType.DOUBLE);
    ctDec.connect(ctDecIn,ctDecH.input);
    ctDec.connect(ctDecH.output,ctGain.input);
    ctDec.connect(ctGain.output,ctDecI.input);
    Relation ctDecR2=ctDec.newRelation(""String_Node_Str"");
    ctDecGF.output.link(ctDecR2);
    ctDecD.trigger.link(ctDecR2);
    ctDecTr.link(ctDecR2);
    ctDec.connect(ctDecD.output,ctDecOut);
    TypedIORelation ctDecR1=(TypedIORelation)ctDec.newRelation(""String_Node_Str"");
    ctDecI.output.link(ctDecR1);
    ctDecD.input.link(ctDecR1);
    ctDecGFi.link(ctDecR1);
    ctDecSt.link(ctDecR1);
    CTEmbeddedDirector ctDecDir=new CTEmbeddedDirector(ctDec,""String_Node_Str"");
    ctrlInc.setRefinement(ctInc);
    ctrlDec.setRefinement(ctDec);
    TypedIORelation hsr1=(TypedIORelation)hs.newRelation(""String_Node_Str"");
    hsin.link(hsr1);
    ctIncIn.link(hsr1);
    ctDecIn.link(hsr1);
    TypedIORelation hsr2=(TypedIORelation)hs.newRelation(""String_Node_Str"");
    ctIncOut.link(hsr2);
    ctDecOut.link(hsr2);
    TypedIORelation hsr3=(TypedIORelation)hs.newRelation(""String_Node_Str"");
    hsst.link(hsr3);
    ctIncSt.link(hsr3);
    ctDecSt.link(hsr3);
    Relation hsr4=hs.newRelation(""String_Node_Str"");
    ctIncTr.link(hsr4);
    ctDecTr.link(hsr4);
    _toplevel.connect(source.output,hsin);
    _toplevel.connect(hsst,responsePlot.input);
    topdir.setStopTime(5.0);
    ctIncDir.InitStepSize.setToken(new DoubleToken(0.01));
    ctIncDir.MinStepSize.setToken(new DoubleToken(1e-3));
    ctIncDir.MaxStepSize.setToken(new DoubleToken(0.05));
    StringToken tok=new StringToken(""String_Node_Str"");
    ctIncDir.BreakpointODESolver.setToken(tok);
    Parameter dfsol=(Parameter)ctIncDir.getAttribute(""String_Node_Str"");
    tok=new StringToken(""String_Node_Str"");
    ctIncDir.ODESolver.setToken(tok);
    ctDecDir.InitStepSize.setToken(new DoubleToken(0.01));
    ctDecDir.MinStepSize.setToken(new DoubleToken(1e-3));
    ctDecDir.MaxStepSize.setToken(new DoubleToken(0.05));
    tok=new StringToken(""String_Node_Str"");
    ctDecDir.BreakpointODESolver.setToken(tok);
    tok=new StringToken(""String_Node_Str"");
    ctDecDir.ODESolver.setToken(tok);
    ctGain.factor.setToken(new DoubleToken(-1.0));
    topdir.InitStepSize.setToken(new DoubleToken(0.01));
    topdir.MinStepSize.setToken(new DoubleToken(1e-3));
    topdir.MaxStepSize.setToken(new DoubleToken(0.05));
    tok=new StringToken(""String_Node_Str"");
    topdir.BreakpointODESolver.setToken(tok);
    tok=new StringToken(""String_Node_Str"");
    topdir.ODESolver.setToken(tok);
  }
 catch (  KernelException ex) {
    report(""String_Node_Str"",ex);
  }
}"
76254,"/** 
 * Return true if this is an embedded director and the current fire is successful. The success is determined by asking all the step size control actors in the output schedule. If this is a top level director, then return true always.
 * @return True if the current step is successful.
 */
public boolean isThisStepSuccessful(){
  try {
    if (!_isStateAcceptable()) {
      _stateAcceptable=false;
      return false;
    }
 else     if (!_isOutputAcceptable()) {
      _outputAcceptable=false;
      return false;
    }
 else {
      _stateAcceptable=true;
      _outputAcceptable=true;
      return true;
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Return true if this is an embedded director and the current fire is successful. The success is determined by asking all the step size control actors in the output schedule. If this is a top level director, then return true always.
 * @return True if the current step is successful.
 */
public boolean isThisStepSuccessful(){
  try {
    _debug(getName() + ""String_Node_Str"");
    if (!_isStateAcceptable()) {
      _stateAcceptable=false;
      return false;
    }
 else     if (!_isOutputAcceptable()) {
      _outputAcceptable=false;
      return false;
    }
 else {
      _stateAcceptable=true;
      _outputAcceptable=true;
      return true;
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}"
76255,"/** 
 * Return an Enumeration of the detail schedules. The first element in the Enumeration is the states schedule, then transition schedule, then output schedule, and then event generating schedule. Each schedule is an Enumeration of actors in their topological order. Each schedule can also be accessed by individual getXXSchedule method.
 * @return an Enumeration of sub-schedules.
 * @exception NotSchedulableException either the system constructionis wrong or arithmetic loop exists.
 */
protected Enumeration _schedule() throws NotSchedulableException {
  CTDirector dir=(CTDirector)getContainer();
  if (dir == null) {
    return null;
  }
  CompositeActor ca=(CompositeActor)(dir.getContainer());
  if (ca == null) {
    return null;
  }
  _stateschedule=new LinkedList();
  _transitionschedule=new LinkedList();
  _outputschedule=new LinkedList();
  _statessc=new LinkedList();
  _outputssc=new LinkedList();
  LinkedList _scheList=new LinkedList();
  _classifyActors();
  DirectedAcyclicGraph g=_toArithGraph(ca.deepEntityList());
  DirectedAcyclicGraph gd=_toGraph(dynamicActorList());
  if (!g.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"");
  }
  int numofdyn=_dynam.size();
  if (numofdyn > 0) {
    Object[] dynactors=_dynam.toArray();
    Object[] xsort=gd.topologicalSort(dynactors);
    for (int i=0; i < xsort.length; i++) {
      Actor a=(Actor)xsort[i];
      _stateschedule.addFirst(a);
      if (a instanceof CTStepSizeControlActor) {
        _statessc.addFirst(a);
      }
    }
    _scheList.addLast(_stateschedule);
    Object[] fx=g.backwardReachableNodes(dynactors);
    Object[] fxsort=g.topologicalSort(fx);
    for (int i=0; i < fxsort.length; i++) {
      Actor a=(Actor)fxsort[i];
      _transitionschedule.addLast(a);
      if (a instanceof CTStepSizeControlActor) {
        _statessc.addFirst(a);
      }
    }
    _scheList.addLast(_transitionschedule);
  }
  int numofsink=_sink.size();
  if (numofsink > 0) {
    Object[] sinkactors=_sink.toArray();
    Object[] gx=g.backwardReachableNodes(sinkactors);
    Object[] gxsort=g.topologicalSort(gx);
    for (int i=0; i < gxsort.length; i++) {
      Actor a=(Actor)gxsort[i];
      _outputschedule.addLast(a);
      if (a instanceof CTStepSizeControlActor) {
        _outputssc.addFirst(a);
      }
    }
    _outputschedule.addAll(_sink);
    _scheList.addLast(_outputschedule);
  }
  return Collections.enumeration(_scheList);
}","/** 
 * Return an Enumeration of the detail schedules. The first element in the Enumeration is the states schedule, then transition schedule, then output schedule, and then event generating schedule. Each schedule is an Enumeration of actors in their topological order. Each schedule can also be accessed by individual getXXSchedule method.
 * @return an Enumeration of sub-schedules.
 * @exception NotSchedulableException either the system constructionis wrong or arithmetic loop exists.
 */
protected Enumeration _schedule() throws NotSchedulableException {
  CTDirector dir=(CTDirector)getContainer();
  if (dir == null) {
    return null;
  }
  CompositeActor ca=(CompositeActor)(dir.getContainer());
  if (ca == null) {
    return null;
  }
  _stateschedule=new LinkedList();
  _transitionschedule=new LinkedList();
  _outputschedule=new LinkedList();
  _statessc=new LinkedList();
  _outputssc=new LinkedList();
  LinkedList _scheList=new LinkedList();
  _classifyActors();
  DirectedAcyclicGraph g=_toArithGraph(ca.deepEntityList());
  DirectedAcyclicGraph gd=_toGraph(dynamicActorList());
  if (!g.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"");
  }
  int numofdyn=_dynam.size();
  if (numofdyn > 0) {
    Object[] dynactors=_dynam.toArray();
    Object[] xsort=gd.topologicalSort(dynactors);
    for (int i=0; i < xsort.length; i++) {
      Actor a=(Actor)xsort[i];
      _stateschedule.addFirst(a);
      if (a instanceof CTStepSizeControlActor) {
        _statessc.addFirst(a);
      }
    }
    _scheList.addLast(_stateschedule);
    Object[] fx=g.backwardReachableNodes(dynactors);
    Object[] fxsort=g.topologicalSort(fx);
    for (int i=0; i < fxsort.length; i++) {
      Actor a=(Actor)fxsort[i];
      _transitionschedule.addLast(a);
      if (a instanceof CTStepSizeControlActor) {
        _statessc.addFirst(a);
      }
    }
    _scheList.addLast(_transitionschedule);
  }
  int numofsink=_sink.size();
  if (numofsink > 0) {
    Object[] sinkactors=_sink.toArray();
    Object[] gx=g.backwardReachableNodes(sinkactors);
    Object[] gxsort=g.topologicalSort(gx);
    for (int i=0; i < gxsort.length; i++) {
      Actor a=(Actor)gxsort[i];
      _outputschedule.addLast(a);
      if (a instanceof CTStepSizeControlActor) {
        _outputssc.addLast(a);
      }
    }
    for (int i=0; i < sinkactors.length; i++) {
      Actor a=(Actor)sinkactors[i];
      _outputschedule.addLast(a);
      if (a instanceof CTStepSizeControlActor) {
        _outputssc.addLast(a);
      }
    }
    _scheList.addLast(_outputschedule);
  }
  return Collections.enumeration(_scheList);
}"
76256,"/** 
 * Return true if the newly resolved state is acceptable. It does it by asking all the step control actors in the state transition and dynamic schedule. If one of them returns false, then the method returns false.
 * @exception IllegalActionException If the scheduler throws it.
 */
protected boolean _isStateAcceptable() throws IllegalActionException {
  boolean successful=true;
  CTScheduler sched=(CTScheduler)getScheduler();
  Iterator sscs=sched.stateTransitionSSCActorList().iterator();
  while (sscs.hasNext()) {
    CTStepSizeControlActor a=(CTStepSizeControlActor)sscs.next();
    successful=successful && a.isThisStepSuccessful();
  }
  return successful;
}","/** 
 * Return true if the newly resolved state is acceptable. It does it by asking all the step control actors in the state transition and dynamic schedule. If one of them returns false, then the method returns false.
 * @exception IllegalActionException If the scheduler throws it.
 */
protected boolean _isStateAcceptable() throws IllegalActionException {
  boolean successful=true;
  CTScheduler sched=(CTScheduler)getScheduler();
  Iterator sscs=sched.stateTransitionSSCActorList().iterator();
  while (sscs.hasNext()) {
    CTStepSizeControlActor a=(CTStepSizeControlActor)sscs.next();
    if (_debugging)     _debug(""String_Node_Str"" + ((NamedObj)a).getName());
    successful=successful && a.isThisStepSuccessful();
  }
  return successful;
}"
76257,"/** 
 * Return true if the newly resolved state is acceptable. It does it by asking all the step control actors in the state transition and dynamic schedule. If one of them returns false, then the method returns false.
 * @exception IllegalActionException If the scheduler throws it.
 */
protected boolean _isOutputAcceptable() throws IllegalActionException {
  boolean successful=true;
  CTScheduler sched=(CTScheduler)getScheduler();
  Iterator sscs=sched.outputSSCActorList().iterator();
  while (sscs.hasNext()) {
    CTStepSizeControlActor a=(CTStepSizeControlActor)sscs.next();
    successful=successful && a.isThisStepSuccessful();
  }
  return successful;
}","/** 
 * Return true if the newly resolved state is acceptable. It does it by asking all the step control actors in the state transition and dynamic schedule. If one of them returns false, then the method returns false.
 * @exception IllegalActionException If the scheduler throws it.
 */
protected boolean _isOutputAcceptable() throws IllegalActionException {
  boolean successful=true;
  CTScheduler sched=(CTScheduler)getScheduler();
  Iterator sscs=sched.outputSSCActorList().iterator();
  while (sscs.hasNext()) {
    System.out.println(""String_Node_Str"");
    CTStepSizeControlActor a=(CTStepSizeControlActor)sscs.next();
    if (_debugging)     _debug(""String_Node_Str"" + ((NamedObj)a).getName());
    successful=successful && a.isThisStepSuccessful();
  }
  return successful;
}"
76258,"/** 
 * Consume the input token and the trigger token. The trigger token will be used for finding the zero crossing in isThisStepSuccessful() method.
 * @exception IllegalActionException If no token is available.
 */
public void fire() throws IllegalActionException {
  _thisTrg=((DoubleToken)trigger.get(0)).doubleValue();
  _debug(getFullName() + ""String_Node_Str"" + _thisTrg);
  _inputToken=input.get(0);
}","/** 
 * Consume the input token and the trigger token. The trigger token will be used for finding the zero crossing in isThisStepSuccessful() method.
 * @exception IllegalActionException If no token is available.
 */
public void fire() throws IllegalActionException {
  _thisTrg=((DoubleToken)trigger.get(0)).doubleValue();
  if (_debugging)   _debug(getFullName() + ""String_Node_Str"" + _thisTrg);
  _inputToken=input.get(0);
}"
76259,"/** 
 * Emit the event at current time if there is any. There will be no current event after emitting it. If there is no current event, do nothing.
 * @exception IllegalActionException If the event cannot be broadcasted.
 */
public void emitCurrentEvents() throws IllegalActionException {
  _debug(this.getFullName() + ""String_Node_Str"");
  if (_eventNow) {
    _debug(getFullName() + ""String_Node_Str"" + _inputToken.toString());
    output.broadcast(_inputToken);
    _eventNow=false;
  }
}","/** 
 * Emit the event at current time if there is any. There will be no current event after emitting it. If there is no current event, do nothing.
 * @exception IllegalActionException If the event cannot be broadcasted.
 */
public void emitCurrentEvents() throws IllegalActionException {
  if (_debugging)   _debug(this.getFullName() + ""String_Node_Str"");
  if (_eventNow) {
    if (_debugging)     _debug(getFullName() + ""String_Node_Str"" + _inputToken.toString());
    output.broadcast(_inputToken);
    _eventNow=false;
  }
}"
76260,"/** 
 * Set up parameters and internal state, so that it has no history before the first firing.
 * @exception IllegalActionException If thrown by the super class.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  updateParameters();
  _first=true;
  _debug(getFullName() + ""String_Node_Str"");
}","/** 
 * Set up parameters and internal state, so that it has no history before the first firing.
 * @exception IllegalActionException If thrown by the super class.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  updateParameters();
  _first=true;
  if (_debugging)   _debug(getFullName() + ""String_Node_Str"");
}"
76261,"/** 
 * Return true if this step does not cross zero. The current trigger token will be compared to the history trigger token. If they cross the zero threshold, this step is not successful. A special case is taken care such that if the history trigger and the current trigger are both zero, then no new event is triggered. If this step crosses zero, then the refined integration step size is computed.
 */
public boolean isThisStepSuccessful(){
  if (_first) {
    _first=false;
    return true;
  }
  _debug(this.getFullName() + ""String_Node_Str"" + _thisTrg);
  _debug(this.getFullName() + ""String_Node_Str"" + _lastTrg);
  if (Math.abs(_thisTrg) < _errorTolerance) {
    if (_enabled) {
      _eventNow=true;
      _debug(getFullName() + ""String_Node_Str"" + getDirector().getCurrentTime());
      _enabled=false;
    }
    _eventMissed=false;
    return true;
  }
 else {
    if (!_enabled) {
      _enabled=true;
    }
 else {
      if ((_lastTrg * _thisTrg) < 0.0) {
        CTDirector dir=(CTDirector)getDirector();
        _eventMissed=true;
        _refineStep=(-_lastTrg * dir.getCurrentStepSize()) / (_thisTrg - _lastTrg);
        _debug(getFullName() + ""String_Node_Str"" + _refineStep);
        return false;
      }
    }
    _eventMissed=false;
    return true;
  }
}","/** 
 * Return true if this step does not cross zero. The current trigger token will be compared to the history trigger token. If they cross the zero threshold, this step is not successful. A special case is taken care such that if the history trigger and the current trigger are both zero, then no new event is triggered. If this step crosses zero, then the refined integration step size is computed.
 */
public boolean isThisStepSuccessful(){
  if (_first) {
    _first=false;
    return true;
  }
  if (_debugging) {
    _debug(this.getFullName() + ""String_Node_Str"" + _thisTrg);
    _debug(this.getFullName() + ""String_Node_Str"" + _lastTrg);
  }
  if (Math.abs(_thisTrg) < _errorTolerance) {
    if (_enabled) {
      _eventNow=true;
      if (_debugging)       _debug(getFullName() + ""String_Node_Str"" + getDirector().getCurrentTime());
      _enabled=false;
    }
    _eventMissed=false;
    return true;
  }
 else {
    if (!_enabled) {
      _enabled=true;
    }
 else {
      if ((_lastTrg * _thisTrg) < 0.0) {
        CTDirector dir=(CTDirector)getDirector();
        _eventMissed=true;
        _refineStep=(-_lastTrg * dir.getCurrentStepSize()) / (_thisTrg - _lastTrg);
        if (_debugging)         _debug(getFullName() + ""String_Node_Str"" + _refineStep);
        return false;
      }
    }
    _eventMissed=false;
    return true;
  }
}"
76262,"/** 
 * Return a Fixvalue for the value and precision given. The value is rounded to the nearest value that can be presented with the given precision, possibly introducing quantization errors.  
 * @param value The value for which to create a Fixpoint
 * @param precision The precision of the Fixpoint
 * @return A Fixvalue for the value with a given precision
 */
public static FixPoint round(double value,Precision precision){
  BigInteger tmpValue;
  BigInteger fxvalue;
  boolean overflow=false;
  double x=value;
  double maxValue=precision.findMax();
  double minValue=precision.findMin();
  if (x > maxValue) {
    overflow=true;
    x=maxValue;
  }
  if (x < minValue) {
    overflow=true;
    x=minValue;
  }
  int number=precision.getFractionBitLength();
  double resolution=Math.pow(2,-(number + 2));
  BigDecimal multiplier;
  if (x >= 0) {
    multiplier=new BigDecimal(x + resolution);
  }
 else {
    multiplier=new BigDecimal(x - resolution);
  }
  BigDecimal kl=_twoRaisedTo[number].multiply(multiplier);
  fxvalue=kl.toBigInteger();
  FixPoint fxp=new FixPoint(precision,fxvalue);
  if (overflow) {
  }
  return fxp;
}","/** 
 * Return a Fixvalue for the value and precision given. The value is rounded to the nearest value that can be presented with the given precision, possibly introducing quantization errors.  
 * @param value The value for which to create a Fixpoint
 * @param precision The precision of the Fixpoint
 * @return A Fixvalue for the value with a given precision
 */
public static FixPoint round(double value,Precision precision){
  BigInteger tmpValue;
  BigInteger fxvalue;
  boolean overflow=false;
  double x=value;
  double maxValue=precision.findMax();
  double minValue=precision.findMin();
  if (x > maxValue) {
    overflow=true;
    x=maxValue;
  }
  if (x < minValue) {
    overflow=true;
    x=minValue;
  }
  int number=precision.getFractionBitLength();
  double resolution=Math.pow(2,-(number + 1));
  BigDecimal multiplier;
  if (x >= 0) {
    multiplier=new BigDecimal(x + resolution);
  }
 else {
    multiplier=new BigDecimal(x - resolution);
  }
  BigDecimal kl=_twoRaisedTo[number].multiply(multiplier);
  fxvalue=kl.toBigInteger();
  FixPoint fxp=new FixPoint(precision,fxvalue);
  if (overflow) {
    fxp.setError(FixPoint.OVERFLOW);
  }
  return fxp;
}"
76263,"/** 
 * Clear the plot of data points in the specified dataset. This calls repaint() to request an update of the display.
 * @param dataset The dataset to clear.
 */
public synchronized void clear(int dataset){
  _checkDatasetIndex(dataset);
  Vector points=(Vector)_points.elementAt(dataset);
  _points.setElementAt(new Vector(),dataset);
  repaint();
}","/** 
 * Clear the plot of data points in the specified dataset. This calls repaint() to request an update of the display.
 * @param dataset The dataset to clear.
 */
public synchronized void clear(int dataset){
  _checkDatasetIndex(dataset);
  _xyInvalid=true;
  Vector points=(Vector)_points.elementAt(dataset);
  _points.setElementAt(new Vector(),dataset);
  repaint();
}"
76264,"public void fire() throws IllegalActionException {
  System.out.println(""String_Node_Str"");
  currentIterFireCount++;
  _takenTransition=null;
  FSMTransition trans;
  if (currentRefinement() != null) {
    System.out.println(""String_Node_Str"");
    currentRefinement().fire();
  }
  Enumeration nonPreTrans=_currentState.getNonPreemptiveTrans();
  while (nonPreTrans.hasMoreElements()) {
    trans=(FSMTransition)nonPreTrans.nextElement();
    System.out.println(""String_Node_Str"" + trans.getFullName());
    if (trans.isEnabled()) {
      System.out.println(""String_Node_Str"");
      if (_takenTransition != null) {
      }
 else {
        _takenTransition=trans;
      }
    }
  }
  System.out.println(""String_Node_Str"");
}","public void fire() throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"");
  currentIterFireCount++;
  _takenTransition=null;
  FSMTransition trans;
  if (currentRefinement() != null) {
    if (_debugging)     _debug(""String_Node_Str"");
    currentRefinement().fire();
  }
  Enumeration nonPreTrans=_currentState.getNonPreemptiveTrans();
  while (nonPreTrans.hasMoreElements()) {
    trans=(FSMTransition)nonPreTrans.nextElement();
    if (_debugging)     _debug(""String_Node_Str"" + trans.getFullName());
    if (trans.isEnabled()) {
      if (_debugging)       _debug(""String_Node_Str"");
      if (_takenTransition != null) {
      }
 else {
        _takenTransition=trans;
      }
    }
  }
  if (_debugging)   _debug(""String_Node_Str"");
}"
76265,"/** 
 * What does this do?
 */
public void preinitialize() throws IllegalActionException {
  System.out.println(""String_Node_Str"");
  try {
    _createReceivers();
    setupScope();
  }
 catch (  NameDuplicationException ex) {
    throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
  }
  if (_localVariables != null) {
    Enumeration localVars=_localVariables.getVariables();
    Variable var=null;
    while (localVars.hasMoreElements()) {
      var=(Variable)localVars.nextElement();
      var.reset();
    }
  }
  _setInputVars();
  _takenTransition=null;
  if (_initialTransitions != null) {
    Enumeration trs=_initialTransitions.elements();
    FSMTransition trans;
    while (trs.hasMoreElements()) {
      trans=(FSMTransition)trs.nextElement();
      if (trans.isEnabled()) {
        if (_takenTransition != null) {
        }
 else {
          _takenTransition=trans;
        }
      }
    }
  }
  if (_takenTransition != null) {
    _outputTriggerActions(_takenTransition.getTriggerActions());
    _updateLocalVariables(_takenTransition.getLocalVariableUpdates());
    _currentState=_takenTransition.destinationState();
  }
 else {
    _currentState=_initialState;
  }
  if (_currentState == null) {
  }
  TypedCompositeActor curRefinement=(TypedCompositeActor)currentRefinement();
  if (curRefinement != null) {
    _updateInputTokenConsumptionRates(curRefinement);
    _updateOutputTokenProductionRates(curRefinement);
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * What does this do?
 */
public void preinitialize() throws IllegalActionException {
  try {
    _createReceivers();
    setupScope();
  }
 catch (  NameDuplicationException ex) {
    throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
  }
  if (_localVariables != null) {
    Enumeration localVars=_localVariables.getVariables();
    Variable var=null;
    while (localVars.hasMoreElements()) {
      var=(Variable)localVars.nextElement();
      var.reset();
    }
  }
  _setInputVars();
  _takenTransition=null;
  if (_initialTransitions != null) {
    Enumeration trs=_initialTransitions.elements();
    FSMTransition trans;
    while (trs.hasMoreElements()) {
      trans=(FSMTransition)trs.nextElement();
      if (trans.isEnabled()) {
        if (_takenTransition != null) {
        }
 else {
          _takenTransition=trans;
        }
      }
    }
  }
  if (_takenTransition != null) {
    _outputTriggerActions(_takenTransition.getTriggerActions());
    _updateLocalVariables(_takenTransition.getLocalVariableUpdates());
    _currentState=_takenTransition.destinationState();
  }
 else {
    _currentState=_initialState;
  }
  if (_currentState == null) {
  }
  TypedCompositeActor curRefinement=(TypedCompositeActor)currentRefinement();
  if (curRefinement != null) {
    _updateInputTokenConsumptionRates(curRefinement);
    _updateOutputTokenProductionRates(curRefinement);
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
76266,"protected void _setInputVars() throws IllegalArgumentException, IllegalActionException {
  Enumeration inports=inputPorts();
  IOPort port;
  System.out.println(""String_Node_Str"");
  while (inports.hasMoreElements()) {
    port=(IOPort)inports.nextElement();
    if (port.numLinks() > 0) {
      if (port.hasToken(0)) {
        System.out.println(""String_Node_Str"" + port.getFullName() + ""String_Node_Str"");
        _inputStatusVars.setVarValue(port.getName(),PRESENT);
        _inputValueVars.setVarValue(port.getName(),port.get(0));
      }
 else {
        System.out.println(""String_Node_Str"" + port.getFullName() + ""String_Node_Str"");
        _inputStatusVars.setVarValue(port.getName(),ABSENT);
      }
    }
 else {
      Receiver[][] recs=port.getReceivers();
      if (recs != null) {
        Receiver rec=recs[0][0];
        if (rec.hasToken()) {
          _inputStatusVars.setVarValue(port.getName(),PRESENT);
          _inputValueVars.setVarValue(port.getName(),rec.get());
        }
 else {
          _inputStatusVars.setVarValue(port.getName(),ABSENT);
        }
      }
 else {
        _inputStatusVars.setVarValue(port.getName(),ABSENT);
      }
    }
  }
}","protected void _setInputVars() throws IllegalArgumentException, IllegalActionException {
  Enumeration inports=inputPorts();
  IOPort port;
  while (inports.hasMoreElements()) {
    port=(IOPort)inports.nextElement();
    if (port.numLinks() > 0) {
      if (port.hasToken(0)) {
        if (_debugging)         _debug(""String_Node_Str"" + port.getFullName() + ""String_Node_Str"");
        _inputStatusVars.setVarValue(port.getName(),PRESENT);
        _inputValueVars.setVarValue(port.getName(),port.get(0));
      }
 else {
        if (_debugging)         _debug(""String_Node_Str"" + port.getFullName() + ""String_Node_Str"");
        _inputStatusVars.setVarValue(port.getName(),ABSENT);
      }
    }
 else {
      Receiver[][] recs=port.getReceivers();
      if (recs != null) {
        Receiver rec=recs[0][0];
        if (rec.hasToken()) {
          _inputStatusVars.setVarValue(port.getName(),PRESENT);
          _inputValueVars.setVarValue(port.getName(),rec.get());
        }
 else {
          _inputStatusVars.setVarValue(port.getName(),ABSENT);
        }
      }
 else {
        _inputStatusVars.setVarValue(port.getName(),ABSENT);
      }
    }
  }
}"
76267,"/** 
 * Initialize the guard variables, which are used in the state transition expressions. Then Create receivers and then invoke the preinitialize() methods of all its deeply contained actors. This method is invoked once per execution, before any iteration, and before the initialize() method. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the preinitialize() method ofone of the associated actors throws it.
 */
public void preinitialize() throws IllegalActionException {
  CompositeActor container=((CompositeActor)getContainer());
  if (container != null) {
    if (_portNameToArrayFIFOQueue == null) {
      _portNameToArrayFIFOQueue=new HashMap();
    }
    Enumeration containPorts=container.getPorts();
    while (containPorts.hasMoreElements()) {
      TypedIOPort aPort=(TypedIOPort)containPorts.nextElement();
      if (_debugging)       _debug(""String_Node_Str"" + aPort.getName());
      ArrayFIFOQueue guardTokenArray=new ArrayFIFOQueue(getGuardTokenHistory());
      while (!guardTokenArray.isFull()) {
        Token tempToken=new IntToken(0);
        guardTokenArray.put(tempToken);
        if (_debugging)         _debug(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (!_portNameToArrayFIFOQueue.containsKey(aPort.getFullName())) {
        _portNameToArrayFIFOQueue.put(aPort.getFullName(),guardTokenArray);
      }
      _createGuardVariables(aPort);
    }
    Enumeration allactors=container.deepGetEntities();
    while (allactors.hasMoreElements()) {
      Actor actor=(Actor)allactors.nextElement();
      if (_debugging)       _debug(""String_Node_Str"",((NamedObj)actor).getFullName());
      actor.preinitialize();
    }
  }
  if (_debugging)   _debug(""String_Node_Str"");
}","/** 
 * Initialize the guard variables, which are used in the state transition expressions. Then Create receivers and then invoke the preinitialize() methods of all its deeply contained actors. This method is invoked once per execution, before any iteration, and before the initialize() method. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the preinitialize() method ofone of the associated actors throws it.
 */
public void preinitialize() throws IllegalActionException {
  CompositeActor container=((CompositeActor)getContainer());
  if (container != null) {
    if (_portNameToArrayFIFOQueue == null) {
      _portNameToArrayFIFOQueue=new HashMap();
    }
    Enumeration containPorts=container.getPorts();
    while (containPorts.hasMoreElements()) {
      TypedIOPort aPort=(TypedIOPort)containPorts.nextElement();
      ArrayFIFOQueue guardTokenArray=new ArrayFIFOQueue(getGuardTokenHistory());
      while (!guardTokenArray.isFull()) {
        Token tempToken=new IntToken(0);
        guardTokenArray.put(tempToken);
      }
      if (!_portNameToArrayFIFOQueue.containsKey(aPort.getFullName())) {
        _portNameToArrayFIFOQueue.put(aPort.getFullName(),guardTokenArray);
      }
      _createGuardVariables(aPort);
    }
    Enumeration allactors=container.deepGetEntities();
    while (allactors.hasMoreElements()) {
      Actor actor=(Actor)allactors.nextElement();
      actor.preinitialize();
    }
  }
}"
76268,"/** 
 * Return true if it transfers data from an input port of the container to the port(s) of the current refinement (an opaque composite actor). This method will transfer all available tokens on channel 0 of the input port. Put the transfered data in the FIFO token queue associated with the input port. This token queue has a length set by setGuardTokenHistory(). The token queue is used when evaluating state transition expressions. <p> The port argument must be an opaque input port.  If  channel 0 of the input port has no data, then that channel is ignored. <p> This assumes that the name of the refining state's port must have the same name  as the input port and is connected to the input port. Therefore, it is necessary that all input ports of a heterochronous dataflow actor that refines to an FSM be connected to the corresponding ports (with the same name) of all of the refining states in the FSM.
 * @param port The input port to transfer data from.
 * @exception IllegalActionException If the port is not an opaqueinput port or if the port is not connected to the current refining state of the FSM.
 * @return True if data are transfered.
 */
public boolean transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"");
  }
  boolean trans=false;
  Entity refine=(Entity)_controller.currentRefinement();
  if (refine == null) {
    if (_debugging)     _debug(""String_Node_Str"");
  }
 else {
    if (_debugging)     _debug(""String_Node_Str"" + refine.getFullName());
  }
  IOPort p;
  Receiver rec;
  ArrayFIFOQueue guardTokenArray=(ArrayFIFOQueue)_portNameToArrayFIFOQueue.get(port.getFullName());
  Token t=null;
  while (port.hasToken(0)) {
    try {
      t=port.get(0);
      guardTokenArray.take();
      guardTokenArray.put(t);
      if (_debugging)       _debug(""String_Node_Str"" + port.getFullName() + ""String_Node_Str"");
      if (_debugging)       _debug(""String_Node_Str"" + t.toString());
      if (_debugging)       _debug(""String_Node_Str"" + port.getName());
      if (_controller == null) {
        System.out.println(""String_Node_Str"");
      }
 else       if (refine == null) {
        if (_debugging)         _debug(""String_Node_Str"");
      }
 else {
        for (Enumeration e=refine.getPorts(); e.hasMoreElements(); ) {
          if (_debugging)           _debug(""String_Node_Str"" + e.nextElement());
        }
      }
      p=(IOPort)refine.getPort(port.getName());
      if (p != null) {
        rec=(p.getReceivers())[0][0];
        if (_debugging)         _debug(""String_Node_Str"");
        rec.put(t);
      }
 else {
        if (_debugging)         _debug(""String_Node_Str"");
        throw new IllegalActionException(this,port,""String_Node_Str"");
      }
      trans=true;
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
    }
  }
  Variable[] guardVarArray=(Variable[])_inputPortNameToVariableArray.get(port.getFullName());
  if (guardVarArray == null) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  int i;
  for (i=0; i < guardVarArray.length; i++) {
    (guardVarArray[i]).setToken((Token)guardTokenArray.get(guardVarArray.length - 1 - i));
  }
  return trans;
}","/** 
 * Return true if it transfers data from an input port of the container to the port(s) of the current refinement (an opaque composite actor). This method will transfer all available tokens on channel 0 of the input port. Put the transfered data in the FIFO token queue associated with the input port. This token queue has a length set by setGuardTokenHistory(). The token queue is used when evaluating state transition expressions. <p> The port argument must be an opaque input port.  If  channel 0 of the input port has no data, then that channel is ignored. <p> This assumes that the name of the refining state's port must have the same name  as the input port and is connected to the input port. Therefore, it is necessary that all input ports of a heterochronous dataflow actor that refines to an FSM be connected to the corresponding ports (with the same name) of all of the refining states in the FSM.
 * @param port The input port to transfer data from.
 * @exception IllegalActionException If the port is not an opaqueinput port or if the port is not connected to the current refining state of the FSM.
 * @return True if data are transfered.
 */
public boolean transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"");
  }
  boolean trans=false;
  Entity refine=(Entity)_controller.currentRefinement();
  if (refine == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
 else {
  }
  IOPort p;
  Receiver rec;
  ArrayFIFOQueue guardTokenArray=(ArrayFIFOQueue)_portNameToArrayFIFOQueue.get(port.getFullName());
  Token t=null;
  while (port.hasToken(0)) {
    try {
      t=port.get(0);
      guardTokenArray.take();
      guardTokenArray.put(t);
      if (_controller == null) {
        throw new IllegalActionException(this,""String_Node_Str"");
      }
 else       if (refine == null) {
        throw new IllegalActionException(this,""String_Node_Str"");
      }
 else {
      }
      p=(IOPort)refine.getPort(port.getName());
      if (p != null) {
        rec=(p.getReceivers())[0][0];
        rec.put(t);
      }
 else {
        throw new IllegalActionException(this,port,""String_Node_Str"");
      }
      trans=true;
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
    }
  }
  Variable[] guardVarArray=(Variable[])_inputPortNameToVariableArray.get(port.getFullName());
  if (guardVarArray == null) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  int i;
  for (i=0; i < guardVarArray.length; i++) {
    (guardVarArray[i]).setToken((Token)guardTokenArray.get(guardVarArray.length - 1 - i));
  }
  return trans;
}"
76269,"/** 
 * Invoke an iteration on all of the deeply contained actors of the container of this Director.  In general, this may be called more than once in the same iteration of the Directors container. An iteration is defined as multiple invocations of prefire(), until it returns true, any number of invocations of fire(), followed by one invocation of postfire(). Notice that we ignore the return value of postfire() in this base class.   In general, derived classes will want to do something intelligent with the returned value. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If any called method of thecontainer or one of the deeply contained actors throws it.
 */
public void fire() throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"");
  if (_controller != null) {
    _controller.fire();
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Invoke an iteration on all of the deeply contained actors of the container of this Director.  In general, this may be called more than once in the same iteration of the Directors container. An iteration is defined as multiple invocations of prefire(), until it returns true, any number of invocations of fire(), followed by one invocation of postfire(). Notice that we ignore the return value of postfire() in this base class.   In general, derived classes will want to do something intelligent with the returned value. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If any called method of thecontainer or one of the deeply contained actors throws it.
 */
public void fire() throws IllegalActionException {
  if (_controller != null) {
    _controller.fire();
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
}"
76270,"/** 
 * Create receivers and then invoke the initialize() methods of all its deeply contained actors. <p> This method should be invoked once per execution, before any iteration. It may produce output data. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the initialize() method of thecontainer or one of the deeply contained actors throws it.
 */
public void initialize() throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"");
  CompositeActor container=(CompositeActor)getContainer();
  if (container != null) {
    Enumeration allActors=container.deepGetEntities();
    while (allActors.hasMoreElements()) {
      Actor actor=(Actor)allActors.nextElement();
      if (actor == _controller) {
        continue;
      }
 else {
        if (_debugging)         _debug(""String_Node_Str"" + ""String_Node_Str"" + ((NamedObj)actor).getFullName());
        actor.initialize();
      }
    }
    if (_debugging)     _debug(""String_Node_Str"" + ""String_Node_Str"" + ((NamedObj)_controller).getFullName());
    _controller.initialize();
  }
}","/** 
 * Create receivers and then invoke the initialize() methods of all its deeply contained actors. <p> This method should be invoked once per execution, before any iteration. It may produce output data. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the initialize() method of thecontainer or one of the deeply contained actors throws it.
 */
public void initialize() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  if (container != null) {
    Enumeration allActors=container.deepGetEntities();
    while (allActors.hasMoreElements()) {
      Actor actor=(Actor)allActors.nextElement();
      if (actor == _controller) {
        continue;
      }
 else {
        actor.initialize();
      }
    }
    _controller.initialize();
  }
}"
76271,"/** 
 * Create the guard variables assiciated with <i>port</i> and add them to a protected queue containing all the guard variables associated with all of the ports of contained by the HDF composite actor with this director. <p> The number of guard variables created for <i>port</i> is the number returned by getGuardTokenHistory(). This variables of the queue are returned by _getTransitionGuardVars().
 * @param port The port to create guard variables for.
 */
private void _createGuardVariables(IOPort port) throws IllegalActionException {
  int history=getGuardTokenHistory();
  Variable[] guardVarArray=new Variable[history];
  if (port.isInput()) {
    if (_inputPortNameToVariableArray == null) {
      _inputPortNameToVariableArray=new HashMap();
    }
    if (!_inputPortNameToVariableArray.containsKey(port.getFullName())) {
      _inputPortNameToVariableArray.put(port.getFullName(),guardVarArray);
    }
  }
 else   if (port.isOutput()) {
    if (_outputPortNameToVariableArray == null) {
      _outputPortNameToVariableArray=new HashMap();
    }
    if (!_outputPortNameToVariableArray.containsKey(port.getFullName())) {
      _outputPortNameToVariableArray.put(port.getFullName(),guardVarArray);
    }
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  try {
    for (int i=0; i < history; i++) {
      Integer iInt=new Integer(i);
      String guardName=port.getName() + ""String_Node_Str"" + iInt.toString();
      if (_debugging)       _debug(""String_Node_Str"" + guardName);
      guardVarArray[i]=new Variable(this,guardName);
    }
    if (_allGuardVars == null) {
      _allGuardVars=new ArrayFIFOQueue();
    }
    _allGuardVars.putArray(guardVarArray);
  }
 catch (  NameDuplicationException ex) {
    System.err.println(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Create the guard variables assiciated with <i>port</i> and add them to a protected queue containing all the guard variables associated with all of the ports of contained by the HDF composite actor with this director. <p> The number of guard variables created for <i>port</i> is the number returned by getGuardTokenHistory(). This variables of the queue are returned by _getTransitionGuardVars().
 * @param port The port to create guard variables for.
 */
private void _createGuardVariables(IOPort port) throws IllegalActionException {
  int history=getGuardTokenHistory();
  Variable[] guardVarArray=new Variable[history];
  if (port.isInput()) {
    if (_inputPortNameToVariableArray == null) {
      _inputPortNameToVariableArray=new HashMap();
    }
    if (!_inputPortNameToVariableArray.containsKey(port.getFullName())) {
      _inputPortNameToVariableArray.put(port.getFullName(),guardVarArray);
    }
  }
 else   if (port.isOutput()) {
    if (_outputPortNameToVariableArray == null) {
      _outputPortNameToVariableArray=new HashMap();
    }
    if (!_outputPortNameToVariableArray.containsKey(port.getFullName())) {
      _outputPortNameToVariableArray.put(port.getFullName(),guardVarArray);
    }
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  try {
    for (int i=0; i < history; i++) {
      Integer iInt=new Integer(i);
      String guardName=port.getName() + ""String_Node_Str"" + iInt.toString();
      guardVarArray[i]=new Variable(this,guardName);
    }
    if (_allGuardVars == null) {
      _allGuardVars=new ArrayFIFOQueue();
    }
    _allGuardVars.putArray(guardVarArray);
  }
 catch (  NameDuplicationException ex) {
    System.err.println(""String_Node_Str"" + ex.getMessage());
  }
}"
76272,"/** 
 * Set the controller associated with this director. This method must be called in the model code.
 */
public void setController(HDFFSMController ctrl) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"");
  if (_controller == null) {
    if (getContainer() == null) {
      throw new IllegalActionException(this,ctrl,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (getContainer() != ctrl.getContainer()) {
      throw new IllegalActionException(this,ctrl,""String_Node_Str"" + ""String_Node_Str"");
    }
    _controller=ctrl;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Set the controller associated with this director. This method must be called in the model code.
 */
public void setController(HDFFSMController ctrl) throws IllegalActionException {
  if (_controller == null) {
    if (getContainer() == null) {
      throw new IllegalActionException(this,ctrl,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (getContainer() != ctrl.getContainer()) {
      throw new IllegalActionException(this,ctrl,""String_Node_Str"" + ""String_Node_Str"");
    }
    _controller=ctrl;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
}"
76273,"/** 
 * Return true if it transfers data from an output port of the current refinement (an opaque composite actor) to the ports it is connected to on the outside. This method will transfer all available tokens on channel 0 of the output port. Put the transfered data in the FIFO token queue associated with the output port. This token queue has a length set by setGuardTokenHistory(). The token queue is used when evaluating state transition expressions. <p> The port argument must be an opaque output port.  If  channel 0 of the output port has no data, then that channel is ignored. <p> This assumes that the name of the refining state's port must have the same name  as the output port and that is connected to the output port. Therefore, it is necessary that all output ports of a heterochronous dataflow actor that refines to an FSM be connected to the corresponding ports (with the same name) of all of the refining states in the FSM.
 * @param port The output port to transfer data from.
 * @exception IllegalActionException If the port is not an opaqueoutput port or if the port is not connected to the current refining state of the FSM.
 * @return True if data are transfered.
 */
public boolean transferOutputs(IOPort port) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"" + port.getName());
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"");
  }
  boolean trans=false;
  Receiver insideReceiver=(port.getInsideReceivers())[0][0];
  CompositeActor cont=(CompositeActor)getContainer();
  IOPort p=(IOPort)cont.getPort(port.getName());
  ArrayFIFOQueue guardTokenArray=(ArrayFIFOQueue)_portNameToArrayFIFOQueue.get(p.getFullName());
  while (insideReceiver.hasToken()) {
    try {
      Token t=insideReceiver.get();
      guardTokenArray.take();
      guardTokenArray.put(t);
      _controller.currentState().setLocalInputVar(port.getName(),t);
      if (p != null) {
        Receiver rec=(p.getInsideReceivers())[0][0];
        rec.put(t);
        if (_debugging)         _debug(""String_Node_Str"");
      }
 else {
        if (_debugging)         _debug(""String_Node_Str"");
        throw new IllegalActionException(this,port,""String_Node_Str"");
      }
      trans=true;
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
    }
  }
  Variable[] guardVarArray=(Variable[])_outputPortNameToVariableArray.get(p.getFullName());
  if (guardVarArray == null) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  int i;
  for (i=0; i < guardVarArray.length; i++) {
    (guardVarArray[i]).setToken((Token)guardTokenArray.get(guardVarArray.length - 1 - i));
  }
  return trans;
}","/** 
 * Return true if it transfers data from an output port of the current refinement (an opaque composite actor) to the ports it is connected to on the outside. This method will transfer all available tokens on channel 0 of the output port. Put the transfered data in the FIFO token queue associated with the output port. This token queue has a length set by setGuardTokenHistory(). The token queue is used when evaluating state transition expressions. <p> The port argument must be an opaque output port.  If  channel 0 of the output port has no data, then that channel is ignored. <p> This assumes that the name of the refining state's port must have the same name  as the output port and that is connected to the output port. Therefore, it is necessary that all output ports of a heterochronous dataflow actor that refines to an FSM be connected to the corresponding ports (with the same name) of all of the refining states in the FSM.
 * @param port The output port to transfer data from.
 * @exception IllegalActionException If the port is not an opaqueoutput port or if the port is not connected to the current refining state of the FSM.
 * @return True if data are transfered.
 */
public boolean transferOutputs(IOPort port) throws IllegalActionException {
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"");
  }
  boolean trans=false;
  Receiver insideReceiver=(port.getInsideReceivers())[0][0];
  CompositeActor cont=(CompositeActor)getContainer();
  IOPort p=(IOPort)cont.getPort(port.getName());
  ArrayFIFOQueue guardTokenArray=(ArrayFIFOQueue)_portNameToArrayFIFOQueue.get(p.getFullName());
  while (insideReceiver.hasToken()) {
    try {
      Token t=insideReceiver.get();
      guardTokenArray.take();
      guardTokenArray.put(t);
      _controller.currentState().setLocalInputVar(port.getName(),t);
      if (p != null) {
        Receiver rec=(p.getInsideReceivers())[0][0];
        rec.put(t);
      }
 else {
        throw new IllegalActionException(this,port,""String_Node_Str"");
      }
      trans=true;
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
    }
  }
  Variable[] guardVarArray=(Variable[])_outputPortNameToVariableArray.get(p.getFullName());
  if (guardVarArray == null) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  int i;
  for (i=0; i < guardVarArray.length; i++) {
    (guardVarArray[i]).setToken((Token)guardTokenArray.get(guardVarArray.length - 1 - i));
  }
  return trans;
}"
76274,"/** 
 * Return true if this transition is enabled.
 */
public boolean isEnabled() throws IllegalActionException {
  if (_teSet) {
    System.out.println(""String_Node_Str"" + this.getFullName());
    _te.getToken();
  }
  if (_tcSet) {
    System.out.println(""String_Node_Str"" + this.getFullName());
    _tc.getToken();
    if (((BooleanToken)_tc.getToken()).booleanValue() == false) {
      return false;
    }
  }
  System.out.println(""String_Node_Str"");
  return true;
}","/** 
 * Return true if this transition is enabled.
 */
public boolean isEnabled() throws IllegalActionException {
  if (_teSet) {
    if (_debugging)     _debug(""String_Node_Str"" + this.getFullName());
    _te.getToken();
  }
  if (_tcSet) {
    if (_debugging)     _debug(""String_Node_Str"" + this.getFullName());
    _tc.getToken();
    if (((BooleanToken)_tc.getToken()).booleanValue() == false) {
      return false;
    }
  }
  if (_debugging)   _debug(""String_Node_Str"");
  return true;
}"
76275,"/** 
 * Setup the scope of the guard (trigger condition). The scope consists of the guard variables. There is a sequence of guard variables associated with each port contained by the the local director's container (an opaque composite actor). For example, if the director's container has an input port called ""dataIn"", then the associated sequence of guard variables is dataIn$0, dataIn$1, dataIn$2, .... Here,  dataIn$0 denotes the most recently read token, dataIn$1 denotes the next most recently read token, and so on. <p> The director method setGuardTokenHistory() sets the number of guard tokens (largest n in dataIn$n).
 */
public void setupScope() throws NameDuplicationException, IllegalActionException {
  System.out.println(""String_Node_Str"");
  HDFFSMController ctrl=(HDFFSMController)getContainer();
  HDFFSMDirector direct=((HDFFSMDirector)ctrl.getDirector());
  Enumeration dirScopeVars=direct._getTransitionGuardVars();
  if (dirScopeVars != null) {
    while (dirScopeVars.hasMoreElements()) {
      Variable var1=(Variable)dirScopeVars.nextElement();
      _te.addToScope(var1);
      _tc.addToScope(var1);
    }
  }
 else {
    System.out.println(""String_Node_Str"");
  }
}","/** 
 * Setup the scope of the guard (trigger condition). The scope consists of the guard variables. There is a sequence of guard variables associated with each port contained by the the local director's container (an opaque composite actor). For example, if the director's container has an input port called ""dataIn"", then the associated sequence of guard variables is dataIn$0, dataIn$1, dataIn$2, .... Here,  dataIn$0 denotes the most recently read token, dataIn$1 denotes the next most recently read token, and so on. <p> The director method setGuardTokenHistory() sets the number of guard tokens (largest n in dataIn$n).
 */
public void setupScope() throws NameDuplicationException, IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"");
  HDFFSMController ctrl=(HDFFSMController)getContainer();
  HDFFSMDirector direct=((HDFFSMDirector)ctrl.getDirector());
  Enumeration dirScopeVars=direct._getTransitionGuardVars();
  if (dirScopeVars != null) {
    while (dirScopeVars.hasMoreElements()) {
      Variable var1=(Variable)dirScopeVars.nextElement();
      _te.addToScope(var1);
      _tc.addToScope(var1);
    }
  }
 else {
    if (_debugging)     _debug(""String_Node_Str"");
  }
}"
76276,"/** 
 * Create the guard variables assiciated with <i>port</i> and add them to a protected queue containing all the guard variables associated with all of the ports of contained by the HDF composite actor with this director. <p> The number of guard variables created for <i>port</i> is the number returned by getGuardTokenHistory(). This variables of the queue are returned by _getTransitionGuardVars().
 * @param port The port to create guard variables for.
 */
private void _createGuardVariables(IOPort port) throws IllegalActionException {
  int history=getGuardTokenHistory();
  Variable[] guardVarArray=new Variable[history];
  if (port.isInput()) {
    if (_inputPortNameToVariableArray == null) {
      _inputPortNameToVariableArray=new HashMap();
    }
    if (!_inputPortNameToVariableArray.containsKey(port.getFullName())) {
      _inputPortNameToVariableArray.put(port.getFullName(),guardVarArray);
    }
  }
 else   if (port.isOutput()) {
    if (_outputPortNameToVariableArray == null) {
      _outputPortNameToVariableArray=new HashMap();
    }
    if (!_outputPortNameToVariableArray.containsKey(port.getFullName())) {
      _outputPortNameToVariableArray.put(port.getFullName(),guardVarArray);
    }
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  try {
    for (int i=0; i < history; i++) {
      Integer iInt=new Integer(i);
      String guardName=port.getName() + ""String_Node_Str"" + iInt.toString();
      guardVarArray[i]=new Variable(this,guardName);
    }
    if (_allGuardVars == null) {
      _allGuardVars=new ArrayFIFOQueue();
    }
    _allGuardVars.putArray(guardVarArray);
  }
 catch (  NameDuplicationException ex) {
    System.err.println(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Create the guard variables assiciated with <i>port</i> and add them to a queue containing all the guard variables associated with all of the ports of contained by the HDF composite actor with this director. <p> The number of guard variables created for <i>port</i> is the number returned by getGuardTokenHistory(). This variables in the queue are returned by _getTransitionGuardVars().
 * @param port The port to create guard variables for.
 */
private void _createGuardVariables(IOPort port) throws IllegalActionException {
  int history=getGuardTokenHistory();
  Variable[] guardVarArray=new Variable[history];
  if (port.isInput()) {
    if (_inputPortNameToVariableArray == null) {
      _inputPortNameToVariableArray=new HashMap();
    }
    if (!_inputPortNameToVariableArray.containsKey(port.getFullName())) {
      _inputPortNameToVariableArray.put(port.getFullName(),guardVarArray);
      try {
        for (int i=0; i < history; i++) {
          Integer iInt=new Integer(i);
          String guardName=port.getName() + ""String_Node_Str"" + iInt.toString();
          guardVarArray[i]=new Variable(this,guardName);
        }
        if (_allGuardVars == null) {
          _allGuardVars=new ArrayFIFOQueue();
        }
        _allGuardVars.putArray(guardVarArray);
      }
 catch (      NameDuplicationException ex) {
        System.err.println(""String_Node_Str"" + ex.getMessage());
      }
    }
  }
 else   if (port.isOutput()) {
    if (_outputPortNameToVariableArray == null) {
      _outputPortNameToVariableArray=new HashMap();
    }
    if (!_outputPortNameToVariableArray.containsKey(port.getFullName())) {
      _outputPortNameToVariableArray.put(port.getFullName(),guardVarArray);
      try {
        for (int i=0; i < history; i++) {
          Integer iInt=new Integer(i);
          String guardName=port.getName() + ""String_Node_Str"" + iInt.toString();
          guardVarArray[i]=new Variable(this,guardName);
        }
        if (_allGuardVars == null) {
          _allGuardVars=new ArrayFIFOQueue();
        }
        _allGuardVars.putArray(guardVarArray);
      }
 catch (      NameDuplicationException ex) {
        System.err.println(""String_Node_Str"" + ex.getMessage());
      }
    }
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
}"
76277,"/** 
 * Return true if it transfers data from an input port of the container to the ports it is connected to on the inside.  The port argument must be an opaque input port.  If any channel of the input port has no data, then that channel is ignored.
 * @exception IllegalActionException If the port is not an opaqueinput port.
 * @return True if data are transfered.
 */
public boolean transferInputs(IOPort port) throws IllegalActionException {
  t=null;
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"");
  }
  boolean trans=false;
  Entity refine=(Entity)_controller.currentRefinement();
  if (refine == null) {
    System.out.println(""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"" + refine.getFullName());
  }
  IOPort p;
  Receiver rec;
  while (port.hasToken(0)) {
    try {
      t=port.get(0);
      ArrayFIFOQueue guardTokenArray=(ArrayFIFOQueue)inputPortNameToArrayFIFOQueue.get(port.getName());
      guardTokenArray.take();
      guardTokenArray.put(t);
      Variable[] guardVarArray=(Variable[])inputPortNameToVariableArray.get(port.getName());
      Token tempToken2=(Token)guardTokenArray.get(0);
      (guardVarArray[0]).setToken(tempToken2);
      System.out.println(""String_Node_Str"" + port.getFullName() + ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + t.toString());
      System.out.println(""String_Node_Str"" + port.getName());
      if (_controller == null) {
        System.out.println(""String_Node_Str"");
      }
 else       if (refine == null) {
        System.out.println(""String_Node_Str"");
      }
 else {
        for (Enumeration e=refine.getPorts(); e.hasMoreElements(); ) {
          System.out.println(""String_Node_Str"" + e.nextElement());
        }
      }
      p=(IOPort)refine.getPort(port.getName());
      if (p != null) {
        rec=(p.getReceivers())[0][0];
        System.out.println(""String_Node_Str"");
        rec.put(t);
      }
 else {
        System.out.println(""String_Node_Str"");
        throw new IllegalActionException(this,port,""String_Node_Str"");
      }
      trans=true;
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
    }
  }
  return trans;
}","/** 
 * Return true if it transfers data from an input port of the container to the ports it is connected to on the inside.  The port argument must be an opaque input port.  If any channel of the input port has no data, then that channel is ignored.
 * @exception IllegalActionException If the port is not an opaqueinput port.
 * @return True if data are transfered.
 */
public boolean transferInputs(IOPort port) throws IllegalActionException {
  t=null;
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"");
  }
  boolean trans=false;
  Entity refine=(Entity)_controller.currentRefinement();
  if (refine == null) {
    System.out.println(""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"" + refine.getFullName());
  }
  IOPort p;
  Receiver rec;
  ArrayFIFOQueue guardTokenArray=(ArrayFIFOQueue)inputPortNameToArrayFIFOQueue.get(port.getName());
  while (port.hasToken(0)) {
    try {
      t=port.get(0);
      guardTokenArray.take();
      guardTokenArray.put(t);
      System.out.println(""String_Node_Str"" + port.getFullName() + ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + t.toString());
      System.out.println(""String_Node_Str"" + port.getName());
      if (_controller == null) {
        System.out.println(""String_Node_Str"");
      }
 else       if (refine == null) {
        System.out.println(""String_Node_Str"");
      }
 else {
        for (Enumeration e=refine.getPorts(); e.hasMoreElements(); ) {
          System.out.println(""String_Node_Str"" + e.nextElement());
        }
      }
      p=(IOPort)refine.getPort(port.getName());
      if (p != null) {
        rec=(p.getReceivers())[0][0];
        System.out.println(""String_Node_Str"");
        rec.put(t);
      }
 else {
        System.out.println(""String_Node_Str"");
        throw new IllegalActionException(this,port,""String_Node_Str"");
      }
      trans=true;
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
    }
  }
  Variable[] guardVarArray=(Variable[])inputPortNameToVariableArray.get(port.getName());
  int i;
  for (i=0; i < guardVarArray.length; i++) {
    (guardVarArray[i]).setToken((Token)guardTokenArray.get(guardVarArray.length - 1 - i));
  }
  return trans;
}"
76278,"/** 
 * Override the baseclass start method so that the model does not immediately begin executing as soon as the the applet page is displayed. Execution begins once the ""Go"" button is depressed.
 */
public void start(){
}","/** 
 * Override the baseclass start method so that the model does not immediately begin executing as soon as the the applet page is displayed. Execution begins once the ""Go"" button is depressed.
 */
public void start(){
  _table.initialize(_philosophers);
}"
76279,"public void run(){
  while ((simulationThread != null) || simulationThread.isAlive()) {
    double currentTime=_localDirector.getCurrentTime();
    _currentTimeLabel.setText(""String_Node_Str"" + nf.format(currentTime));
    try {
      sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
}","public void run(){
  while (true) {
    if (simulationThread == null) {
      return;
    }
 else     if (!simulationThread.isAlive()) {
      return;
    }
    double currentTime=_localDirector.getCurrentTime();
    _currentTimeLabel.setText(""String_Node_Str"" + nf.format(currentTime));
    try {
      sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
}"
76280,"public boolean postfire(){
  return false;
}","/** 
 * Return true if this actor is enabled to proceed with additional iterations; return false otherwise.
 * @return True if continued execution is enabled; false otherwise.
 */
public boolean postfire(){
  return false;
}"
76281,"/** 
 * Executes the code in this actor. This actor randomly chooses whether to grab the chopstick to the left or right of it first. When it has one chopstick, it then tries to grab the other chopstick beside it. This process mimics the eating action of the philosopher twenty times, and then finishes normally.
 * @exception IllegalActionException If an error occurs duringexecuting the process.
 */
public void fire() throws IllegalActionException {
  Random rand=new Random();
  Token t=new IntToken(0);
  double interval=0.0;
  double rate=1;
  int count=0;
  try {
    while (count < 20) {
      rate=((DoubleToken)_thinking.getToken()).doubleValue();
      interval=(int)(rand.nextDouble() * rate * 1000);
      interval=interval / 1000;
      System.out.println(getName() + count + ""String_Node_Str""+ interval);
      Thread th=Thread.currentThread();
      th.sleep((long)interval * 1000);
      delay(interval);
      if (rand.nextDouble() > 0.5) {
        leftIn.get(0);
        gotLeft=true;
        _notifyListeners();
        waitingRight=true;
        rightIn.get(0);
        gotRight=true;
        waitingRight=false;
        _notifyListeners();
      }
 else {
        rightIn.get(0);
        gotRight=true;
        _notifyListeners();
        waitingLeft=true;
        leftIn.get(0);
        gotLeft=true;
        waitingLeft=false;
        _notifyListeners();
      }
      rate=((DoubleToken)_eating.getToken()).doubleValue();
      interval=(int)(rand.nextDouble() * rate * 2000);
      interval=interval / 1000;
      System.out.println(getName() + ""String_Node_Str"" + interval);
      th.sleep((long)interval * 1000);
      delay(interval);
      leftOut.send(0,t);
      gotLeft=false;
      rightOut.send(0,t);
      gotRight=false;
      _notifyListeners();
      count++;
    }
    return;
  }
 catch (  NoTokenException ex) {
    throw new IllegalActionException(getName() + ""String_Node_Str"" + ""String_Node_Str"");
  }
catch (  InterruptedException ex) {
    throw new IllegalActionException(getName() + ""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Executes the code in this actor. This actor randomly chooses whether to grab the chopstick to the left or right of it first. When it has one chopstick, it then tries to grab the other chopstick beside it. This process mimics the eating action of the philosopher twenty times, and then finishes normally.
 * @exception IllegalActionException If an error occurs duringexecuting the process.
 */
public void fire() throws IllegalActionException {
  Random rand=new Random();
  Token t=new IntToken(0);
  double interval=0.0;
  double rate=1;
  int count=0;
  try {
    while (count < 20) {
      rate=((DoubleToken)thinking.getToken()).doubleValue();
      interval=(int)(rand.nextDouble() * rate * 1000);
      interval=interval / 1000;
      System.out.println(getName() + count + ""String_Node_Str""+ interval);
      Thread th=Thread.currentThread();
      th.sleep((long)interval * 1000);
      delay(interval);
      if (rand.nextDouble() > 0.5) {
        leftIn.get(0);
        gotLeft=true;
        _notifyListeners();
        waitingRight=true;
        rightIn.get(0);
        gotRight=true;
        waitingRight=false;
        _notifyListeners();
      }
 else {
        rightIn.get(0);
        gotRight=true;
        _notifyListeners();
        waitingLeft=true;
        leftIn.get(0);
        gotLeft=true;
        waitingLeft=false;
        _notifyListeners();
      }
      rate=((DoubleToken)eating.getToken()).doubleValue();
      interval=(int)(rand.nextDouble() * rate * 2000);
      interval=interval / 1000;
      System.out.println(getName() + ""String_Node_Str"" + interval);
      th.sleep((long)interval * 1000);
      delay(interval);
      leftOut.send(0,t);
      gotLeft=false;
      rightOut.send(0,t);
      gotRight=false;
      _notifyListeners();
      count++;
    }
    return;
  }
 catch (  NoTokenException ex) {
    throw new IllegalActionException(getName() + ""String_Node_Str"" + ""String_Node_Str"");
  }
catch (  InterruptedException ex) {
    throw new IllegalActionException(getName() + ""String_Node_Str"" + ""String_Node_Str"");
  }
}"
76282,"/** 
 * Construct a Philosopher in the specified container with the specified name.  The name must be unique within the container or an exception is thrown. The container argument must not be null, or a NullPointerException will be thrown. The actor is created with two input ports and two output ports, all of width one. The input ports are called ""leftIn"" and ""rightIn"", and similarly, the output ports are called ""leftOut"" and ""rightOut"". <p> The default values of the eatingRate and thinkingRate parameters are 1.0. <p>
 * @param container The TypedCompositeActor that contains this actor.
 * @param name The actor's name.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the name argument coincides withan entity already in the container.
 */
public Philosopher(TypedCompositeActor cont,String name) throws IllegalActionException, NameDuplicationException {
  super(cont,name);
  leftIn=new TypedIOPort(this,""String_Node_Str"",true,false);
  leftOut=new TypedIOPort(this,""String_Node_Str"",false,true);
  rightIn=new TypedIOPort(this,""String_Node_Str"",true,false);
  rightOut=new TypedIOPort(this,""String_Node_Str"",false,true);
  leftIn.setTypeEquals(BaseType.GENERAL);
  rightIn.setTypeEquals(BaseType.GENERAL);
  leftOut.setTypeEquals(BaseType.INT);
  rightOut.setTypeEquals(BaseType.INT);
  _eating=new Parameter(this,""String_Node_Str"");
  _eating.setExpression(""String_Node_Str"");
  _thinking=new Parameter(this,""String_Node_Str"");
  _thinking.setExpression(""String_Node_Str"");
}","/** 
 * Construct a Philosopher in the specified container with the specified name.  The name must be unique within the container or an exception is thrown. The container argument must not be null, or a NullPointerException will be thrown. The actor is created with two input ports and two output ports, all of width one. The input ports are called ""leftIn"" and ""rightIn"", and similarly, the output ports are called ""leftOut"" and ""rightOut"". <p> The default values of the eatingRate and thinkingRate parameters are 1.0. <p>
 * @param container The TypedCompositeActor that contains this actor.
 * @param name The actor's name.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the name argument coincides withan entity already in the container.
 */
public Philosopher(TypedCompositeActor cont,String name) throws IllegalActionException, NameDuplicationException {
  super(cont,name);
  leftIn=new TypedIOPort(this,""String_Node_Str"",true,false);
  leftOut=new TypedIOPort(this,""String_Node_Str"",false,true);
  rightIn=new TypedIOPort(this,""String_Node_Str"",true,false);
  rightOut=new TypedIOPort(this,""String_Node_Str"",false,true);
  leftIn.setTypeEquals(BaseType.GENERAL);
  rightIn.setTypeEquals(BaseType.GENERAL);
  leftOut.setTypeEquals(BaseType.INT);
  rightOut.setTypeEquals(BaseType.INT);
  eating=new Parameter(this,""String_Node_Str"");
  eating.setExpression(""String_Node_Str"");
  thinking=new Parameter(this,""String_Node_Str"");
  thinking.setExpression(""String_Node_Str"");
}"
76283,public void philosopherChanged();,"/** 
 * Indicate to the object that implements this interface that the state of a philosopher has changed.
 * @see ptolemy.domains.csp.demo.Philosopher
 */
public void philosopherChanged();"
76284,"/** 
 * Constructs the new panel. Initializes the objects and the display.
 */
protected TablePanel(Philosopher[] philosophers){
  _philosophers=philosophers;
  for (int i=0; i < 5; i++) {
    philsLoc[i]=new PhilosopherCoords();
    chopsticksLoc[i]=new ChopstickCoords();
  }
  initPos();
}","/** 
 * Constructs the new panel. Initializes the objects and the display.
 */
protected TablePanel(Philosopher[] philosophers){
  initialize(philosophers);
}"
76285,"/** 
 * Return a string representing the (possibly unevaluated) value of this variable.  If the value has been set by an expression, then return that expression.  If the value has been set via a token, then return a string representation of the value of that token.  If neither, then return an empty string.
 * @return A string representation of this variable.
 */
public String stringRepresentation(){
  String value=getExpression();
  if (value == null) {
    ptolemy.data.Token token=null;
    try {
      token=getToken();
    }
 catch (    IllegalActionException ex) {
    }
    if (token != null) {
      value=token.toString();
    }
  }
  if (value != null) {
    value=""String_Node_Str"";
  }
  return value;
}","/** 
 * Return a string representing the (possibly unevaluated) value of this variable.  If the value has been set by an expression, then return that expression.  If the value has been set via a token, then return a string representation of the value of that token.  If neither, then return an empty string.
 * @return A string representation of this variable.
 */
public String stringRepresentation(){
  String value=getExpression();
  if (value == null) {
    ptolemy.data.Token token=null;
    try {
      token=getToken();
    }
 catch (    IllegalActionException ex) {
    }
    if (token != null) {
      value=token.toString();
    }
  }
  if (value == null) {
    value=""String_Node_Str"";
  }
  return value;
}"
76286,"/** 
 * Return true if it  transfers data from an input port of the container to the ports it is connected to on the inside.  The port argument must be an opaque input port.  If any channel of the input port has no data, then that channel is ignored.
 * @exception IllegalActionException If the port is not an opaqueinput port.
 * @param port The port to transfer tokens from.
 * @return True if data are tranfered.
 */
public boolean transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  boolean trans=false;
  Receiver[][] insiderecs=port.deepGetReceivers();
  for (int i=0; i < port.getWidth(); i++) {
    if (port.hasToken(i)) {
      try {
        Token t=port.get(i);
        if (insiderecs != null && insiderecs[i] != null) {
          if (_debugging)           _debug(getName(),""String_Node_Str"" + port.getName());
          for (int j=0; j < insiderecs[i].length; j++) {
            insiderecs[i][j].put(t);
          }
          trans=true;
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
      }
    }
  }
  return trans;
}","/** 
 * Return true if it  transfers data from an input port of the container to the ports it is connected to on the inside.  The port argument must be an opaque input port.  If any channel of the input port has no data, then that channel is ignored.
 * @exception IllegalActionException If the port is not an opaqueinput port.
 * @param port The port to transfer tokens from.
 * @return True if data are tranfered.
 */
public boolean transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  boolean trans=false;
  Receiver[][] insiderecs=port.deepGetReceivers();
  for (int i=0; i < port.getWidth(); i++) {
    while (port.hasToken(i)) {
      try {
        Token t=port.get(i);
        if (insiderecs != null && insiderecs[i] != null) {
          if (_debugging)           _debug(getName(),""String_Node_Str"" + port.getName());
          for (int j=0; j < insiderecs[i].length; j++) {
            insiderecs[i][j].put(t);
          }
          trans=true;
        }
      }
 catch (      NoTokenException ex) {
        throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
      }
    }
  }
  return trans;
}"
76287,"/** 
 * Return true if it  transfers data from an output port of the container to the ports it is connected to on the outside.  The port argument must be an opaque output port.  If any channel of the output port has no data, then that channel is ignored.
 * @exception IllegalActionException If the port is not an opaqueoutput port.
 * @param port The port to transfer tokens from.
 * @return True if data are transfered.
 */
public boolean transferOutputs(IOPort port) throws IllegalActionException {
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  boolean trans=false;
  Receiver[][] insiderecs=port.getInsideReceivers();
  if (insiderecs != null) {
    for (int i=0; i < insiderecs.length; i++) {
      if (insiderecs[i] != null) {
        for (int j=0; j < insiderecs[i].length; j++) {
          if (insiderecs[i][j].hasToken()) {
            try {
              Token t=insiderecs[i][j].get();
              port.send(i,t);
              trans=true;
            }
 catch (            NoTokenException ex) {
              throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
            }
          }
        }
      }
    }
  }
  return trans;
}","/** 
 * Return true if it  transfers data from an output port of the container to the ports it is connected to on the outside.  The port argument must be an opaque output port.  If any channel of the output port has no data, then that channel is ignored.
 * @exception IllegalActionException If the port is not an opaqueoutput port.
 * @param port The port to transfer tokens from.
 * @return True if data are transfered.
 */
public boolean transferOutputs(IOPort port) throws IllegalActionException {
  if (!port.isOutput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  boolean trans=false;
  Receiver[][] insiderecs=port.getInsideReceivers();
  if (insiderecs != null) {
    for (int i=0; i < insiderecs.length; i++) {
      if (insiderecs[i] != null) {
        for (int j=0; j < insiderecs[i].length; j++) {
          while (insiderecs[i][j].hasToken()) {
            try {
              Token t=insiderecs[i][j].get();
              port.send(i,t);
              trans=true;
            }
 catch (            NoTokenException ex) {
              throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
            }
          }
        }
      }
    }
  }
  return trans;
}"
76288,"/** 
 * End an element. This method calls the appropriate Plot methods. &AElig;lfred will call this method at the end of each element (including EMPTY elements).
 * @param elementName The element type name.
 */
public void endElement(String elementName) throws Exception {
  super.endElement(elementName);
  if (elementName.equals(""String_Node_Str"")) {
    ((Plot)_plot).setBars(_bars);
    ((Plot)_plot).setConnected(_connected);
  }
}","/** 
 * End an element. This method calls the appropriate Plot methods. &AElig;lfred will call this method at the end of each element (including EMPTY elements).
 * @param elementName The element type name.
 */
public void endElement(String elementName) throws Exception {
  super.endElement(elementName);
  if (elementName.equals(""String_Node_Str"")) {
    ((Plot)_plot).setConnected(_connected);
  }
}"
76289,"/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  _currentElement=elementName;
  try {
    if (elementName.equals(""String_Node_Str"")) {
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      _checkClass(_current,NamedObj.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object property=(Attribute)((NamedObj)_current).getAttribute(propertyName);
      String className=(String)_attributes.get(""String_Node_Str"");
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className);
      }
      if (property == null) {
        _checkForNull(newClass,""String_Node_Str"");
        Object[] arguments=new Object[2];
        arguments[0]=_current;
        arguments[1]=propertyName;
        property=_createInstance(newClass,arguments);
        if (value != null) {
          if (!(property instanceof Variable)) {
            throw new XmlException(""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
          }
          ((Variable)property).setExpression(value);
        }
      }
 else {
        if (newClass != null) {
          _checkClass(property,newClass,""String_Node_Str"" + propertyName + ""String_Node_Str""+ className);
        }
        if (value != null) {
          _checkClass(property,Variable.class,""String_Node_Str"" + propertyName + ""String_Node_Str""+ ""String_Node_Str"");
          ((Variable)property).setExpression(value);
        }
      }
      _containers.push(_current);
      _current=property;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj newEntity;
      if (_current != null) {
        _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
        _containers.push(_current);
        newEntity=_createEntity(className,entityName);
      }
 else {
        newEntity=_createEntity(className,entityName);
        _toplevel=newEntity;
      }
      newEntity.setMoMLElementName(""String_Node_Str"");
      _current=newEntity;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      if (source != null) {
        URL xmlFile=new URL(_base,source);
        InputStream stream=xmlFile.openStream();
        ((Configurable)_current).configure(_base,stream);
      }
      _currentCharData=new StringBuffer();
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      _containers.push(_current);
      Class newClass=Class.forName(className);
      _current=_createInstance(newClass,arguments);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentCharData=new StringBuffer();
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      NamedObj newEntity=_createEntity(className,entityName);
      if (_panel != null && newEntity instanceof Placeable) {
        ((Placeable)newEntity).place(_panel);
      }
      _containers.push(_current);
      _current=newEntity;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      String baseSpec=(String)_attributes.get(""String_Node_Str"");
      URL base=_base;
      if (baseSpec != null) {
        base=new URL(_base,baseSpec);
      }
      MoMLParser newParser=new MoMLParser(_workspace);
      URL xmlFile=new URL(base,source);
      NamedObj reference=newParser.parse(base,xmlFile.openStream());
      if (_imports == null) {
        _imports=new LinkedList();
      }
      _imports.add(0,reference);
      if (_current instanceof NamedObj) {
        NamedObj container=(NamedObj)_current;
        Import attr=new Import(container,container.uniqueName(""String_Node_Str""));
        attr.setSource(source);
        attr.setBase(_base);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      Relation tmpRelation=context.getRelation(relationName);
      _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
      ComponentRelation relation=(ComponentRelation)tmpRelation;
      port.link(relation);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String xSpec=(String)_attributes.get(""String_Node_Str"");
      String ySpec=(String)_attributes.get(""String_Node_Str"");
      String zSpec=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(xSpec,""String_Node_Str"");
      _checkClass(_current,Locatable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      double x=Double.parseDouble(xSpec);
      if (ySpec != null) {
        double y=Double.parseDouble(ySpec);
        if (zSpec != null) {
          double z=Double.parseDouble(zSpec);
          double[] location={x,y,z};
          ((Locatable)_current).setLocation(location);
        }
 else {
          double[] location={x,y};
          ((Locatable)_current).setLocation(location);
        }
      }
 else {
        double[] location={x};
        ((Locatable)_current).setLocation(location);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String modelName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(modelName,""String_Node_Str"");
      Object[] arguments=new Object[1];
      arguments[0]=_workspace;
      Class newClass=Class.forName(className);
      _toplevel=(NamedObj)_createInstance(newClass,arguments);
      _toplevel.setName(modelName);
      _toplevel.setMoMLElementName(""String_Node_Str"");
      _current=_toplevel;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className);
      }
      Port port=container.getPort(portName);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        _checkForNull(className,""String_Node_Str"");
        Object[] arguments=new Object[2];
        arguments[0]=container;
        arguments[1]=portName;
        port=(Port)_createInstance(newClass,arguments);
      }
      _containers.push(_current);
      _current=port;
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          ioport.setOutput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
          ioport.setInput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className);
      }
      Relation relation=container.getRelation(relationName);
      if (relation == null) {
        _checkForNull(newClass,""String_Node_Str"");
        Object[] arguments=new Object[2];
        arguments[0]=(CompositeEntity)_current;
        arguments[1]=relationName;
        _containers.push(_current);
        _current=_createInstance(newClass,arguments);
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _containers.push(_current);
        _current=relation;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      _checkClass(_current,NamedObj.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=(NamedObj)_current;
      arguments[1]=""String_Node_Str"";
      _containers.push(_current);
      Class newClass=Class.forName(className);
      _current=_createInstance(newClass,arguments);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex vertex=new Vertex((Relation)_current,vertexName);
      _containers.push(_current);
      _current=vertex;
    }
  }
 catch (  InvocationTargetException ex) {
    String msg=""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException().toString();
    throw new XmlException(msg,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
catch (  Exception ex) {
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      String msg=""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.toString();
      System.err.println(""String_Node_Str"");
      ex.printStackTrace();
      throw new XmlException(msg,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
    }
  }
  _attributes.clear();
}","/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  _currentElement=elementName;
  try {
    if (elementName.equals(""String_Node_Str"")) {
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      _checkClass(_current,NamedObj.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object property=(Attribute)((NamedObj)_current).getAttribute(propertyName);
      String className=(String)_attributes.get(""String_Node_Str"");
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className);
      }
      if (property == null) {
        _checkForNull(newClass,""String_Node_Str"");
        Object[] arguments=new Object[2];
        arguments[0]=_current;
        arguments[1]=propertyName;
        property=_createInstance(newClass,arguments);
        if (value != null) {
          if (!(property instanceof Variable)) {
            throw new XmlException(""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
          }
          ((Variable)property).setExpression(value);
        }
      }
 else {
        if (newClass != null) {
          _checkClass(property,newClass,""String_Node_Str"" + propertyName + ""String_Node_Str""+ className);
        }
        if (value != null) {
          _checkClass(property,Variable.class,""String_Node_Str"" + propertyName + ""String_Node_Str""+ ""String_Node_Str"");
          ((Variable)property).setExpression(value);
        }
      }
      _containers.push(_current);
      _current=property;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj newEntity;
      if (_current != null) {
        _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
        _containers.push(_current);
        newEntity=_createEntity(className,entityName);
      }
 else {
        newEntity=_createEntity(className,entityName);
        _toplevel=newEntity;
      }
      newEntity.setMoMLElementName(""String_Node_Str"");
      _current=newEntity;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      if (source != null) {
        URL xmlFile=new URL(_base,source);
        InputStream stream=xmlFile.openStream();
        ((Configurable)_current).configure(_base,stream);
      }
      _currentCharData=new StringBuffer();
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      _containers.push(_current);
      Class newClass=Class.forName(className);
      _current=_createInstance(newClass,arguments);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentCharData=new StringBuffer();
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      NamedObj newEntity=_createEntity(className,entityName);
      if (_panel != null && newEntity instanceof Placeable) {
        ((Placeable)newEntity).place(_panel);
      }
      _containers.push(_current);
      _current=newEntity;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      String baseSpec=(String)_attributes.get(""String_Node_Str"");
      URL base=_base;
      if (baseSpec != null) {
        base=new URL(_base,baseSpec);
      }
      MoMLParser newParser=new MoMLParser(_workspace);
      URL xmlFile=new URL(base,source);
      NamedObj reference=newParser.parse(xmlFile,xmlFile.openStream());
      if (_imports == null) {
        _imports=new LinkedList();
      }
      _imports.add(0,reference);
      if (_current instanceof NamedObj) {
        NamedObj container=(NamedObj)_current;
        Import attr=new Import(container,container.uniqueName(""String_Node_Str""));
        attr.setSource(source);
        attr.setBase(_base);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      Relation tmpRelation=context.getRelation(relationName);
      _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
      ComponentRelation relation=(ComponentRelation)tmpRelation;
      port.link(relation);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String xSpec=(String)_attributes.get(""String_Node_Str"");
      String ySpec=(String)_attributes.get(""String_Node_Str"");
      String zSpec=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(xSpec,""String_Node_Str"");
      _checkClass(_current,Locatable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      double x=Double.parseDouble(xSpec);
      if (ySpec != null) {
        double y=Double.parseDouble(ySpec);
        if (zSpec != null) {
          double z=Double.parseDouble(zSpec);
          double[] location={x,y,z};
          ((Locatable)_current).setLocation(location);
        }
 else {
          double[] location={x,y};
          ((Locatable)_current).setLocation(location);
        }
      }
 else {
        double[] location={x};
        ((Locatable)_current).setLocation(location);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String modelName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(modelName,""String_Node_Str"");
      Object[] arguments=new Object[1];
      arguments[0]=_workspace;
      Class newClass=Class.forName(className);
      _toplevel=(NamedObj)_createInstance(newClass,arguments);
      _toplevel.setName(modelName);
      _toplevel.setMoMLElementName(""String_Node_Str"");
      _current=_toplevel;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className);
      }
      Port port=container.getPort(portName);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        _checkForNull(className,""String_Node_Str"");
        Object[] arguments=new Object[2];
        arguments[0]=container;
        arguments[1]=portName;
        port=(Port)_createInstance(newClass,arguments);
      }
      _containers.push(_current);
      _current=port;
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          ioport.setOutput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
          ioport.setInput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className);
      }
      Relation relation=container.getRelation(relationName);
      if (relation == null) {
        _checkForNull(newClass,""String_Node_Str"");
        Object[] arguments=new Object[2];
        arguments[0]=(CompositeEntity)_current;
        arguments[1]=relationName;
        _containers.push(_current);
        _current=_createInstance(newClass,arguments);
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _containers.push(_current);
        _current=relation;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      _checkClass(_current,NamedObj.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=(NamedObj)_current;
      arguments[1]=""String_Node_Str"";
      _containers.push(_current);
      Class newClass=Class.forName(className);
      _current=_createInstance(newClass,arguments);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex vertex=new Vertex((Relation)_current,vertexName);
      _containers.push(_current);
      _current=vertex;
    }
  }
 catch (  InvocationTargetException ex) {
    String msg=""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException().toString();
    throw new XmlException(msg,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
catch (  Exception ex) {
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      String msg=""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.toString();
      System.err.println(""String_Node_Str"");
      ex.printStackTrace();
      throw new XmlException(msg,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
    }
  }
  _attributes.clear();
}"
76290,"/** 
 * After invoking super.init(), create and connect the actors.
 */
public void init(){
  super.init();
  getContentPane().add(_createRunControls(2),BorderLayout.SOUTH);
  try {
    Ramp rampSig=new Ramp(_toplevel,""String_Node_Str"");
    Sine sineSig=new Sine(_toplevel,""String_Node_Str"");
    sineSig.omega.setToken(new DoubleToken(0.1));
    Gaussian noise=new Gaussian(_toplevel,""String_Node_Str"");
    noise.standardDeviation.setToken(new DoubleToken(0.1));
    AddSubtractBroad add=new AddSubtractBroad(_toplevel,""String_Node_Str"");
    add.output.setMultiport(true);
    SequencePlotter hystplotter=new SequencePlotter(_toplevel,""String_Node_Str"");
    hystplotter.place(getContentPane());
    hystplotter.plot.setBackground(getBackground());
    hystplotter.plot.setGrid(false);
    hystplotter.plot.setTitle(""String_Node_Str"");
    hystplotter.plot.setXRange(0.0,150.0);
    hystplotter.plot.setWrap(true);
    hystplotter.plot.setYRange(-1.3,1.3);
    hystplotter.plot.setMarksStyle(""String_Node_Str"");
    hystplotter.plot.setPointsPersistence(150);
    TypedCompositeActor tempAct=new TypedCompositeActor(_toplevel,""String_Node_Str"");
    TypedIOPort tempActInPort=(TypedIOPort)tempAct.newPort(""String_Node_Str"");
    tempActInPort.setInput(true);
    tempActInPort.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort tempActOutPort=(TypedIOPort)tempAct.newPort(""String_Node_Str"");
    tempActOutPort.setOutput(true);
    tempActOutPort.setTypeEquals(BaseType.DOUBLE);
    HDFFSMController ctrl=new HDFFSMController(tempAct,""String_Node_Str"");
    StreamListener sa=new StreamListener();
    ctrl.addDebugListener(sa);
    HDFFSMState ctrls0=new HDFFSMState(ctrl,""String_Node_Str"");
    HDFFSMState ctrls1=new HDFFSMState(ctrl,""String_Node_Str"");
    ctrl.setInitialState(ctrls0);
    HDFFSMTransition ctrlTrs0Tos1=(HDFFSMTransition)ctrl.createTransition(ctrls0,ctrls1);
    ctrlTrs0Tos1.setTriggerEvent(""String_Node_Str"");
    ctrlTrs0Tos1.setTriggerCondition(""String_Node_Str"");
    HDFFSMTransition ctrlTrs0Tos0=(HDFFSMTransition)ctrl.createTransition(ctrls0,ctrls0);
    ctrlTrs0Tos0.setTriggerEvent(""String_Node_Str"");
    ctrlTrs0Tos0.setTriggerCondition(""String_Node_Str"");
    HDFFSMTransition ctrlTrs1Tos0=(HDFFSMTransition)ctrl.createTransition(ctrls1,ctrls0);
    ctrlTrs1Tos0.setTriggerEvent(""String_Node_Str"");
    ctrlTrs1Tos0.setTriggerCondition(""String_Node_Str"");
    HDFFSMTransition ctrlTrs1Tos1=(HDFFSMTransition)ctrl.createTransition(ctrls1,ctrls1);
    ctrlTrs1Tos1.setTriggerEvent(""String_Node_Str"");
    ctrlTrs1Tos1.setTriggerCondition(""String_Node_Str"");
    HDFFSMDirector ctrlDir=new HDFFSMDirector(tempAct,""String_Node_Str"");
    ctrlDir.setController(ctrl);
    StreamListener sa2=new StreamListener();
    ctrlDir.addDebugListener(sa2);
    TypedCompositeActor tempActState0=new TypedCompositeActor(tempAct,""String_Node_Str"");
    ctrls0.setRefinement(tempActState0);
    TypedIOPort tempActState0InPort=(TypedIOPort)tempActState0.newPort(""String_Node_Str"");
    tempActState0InPort.setInput(true);
    tempActState0InPort.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort tempActState0OutPort=(TypedIOPort)tempActState0.newPort(""String_Node_Str"");
    tempActState0OutPort.setOutput(true);
    tempActState0OutPort.setTypeEquals(BaseType.DOUBLE);
    try {
      SDFDirector _director0=new SDFDirector(tempActState0,""String_Node_Str"");
      Parameter iterparam0=_director0.iterations;
      iterparam0.setToken(new IntToken(iterations));
      SDFScheduler scheduler0=new SDFScheduler(_workspace);
      _director0.setScheduler(scheduler0);
      _director0.setScheduleValid(false);
    }
 catch (    Exception ex) {
      report(""String_Node_Str"",ex);
    }
    Const const0=new Const(tempActState0,""String_Node_Str"");
    const0.value.setToken(new DoubleToken(-1));
    tempActState0.connect(const0.output,tempActState0OutPort);
    TypedCompositeActor tempActState1=new TypedCompositeActor(tempAct,""String_Node_Str"");
    ctrls1.setRefinement(tempActState1);
    TypedIOPort tempActState1InPort=(TypedIOPort)tempActState1.newPort(""String_Node_Str"");
    tempActState1InPort.setInput(true);
    tempActState1InPort.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort tempActState1OutPort=(TypedIOPort)tempActState1.newPort(""String_Node_Str"");
    tempActState1OutPort.setOutput(true);
    tempActState1OutPort.setTypeEquals(BaseType.DOUBLE);
    TypedIORelation tempActInRel=(TypedIORelation)tempAct.newRelation(""String_Node_Str"");
    tempActInPort.link(tempActInRel);
    tempActState0InPort.link(tempActInRel);
    tempActState1InPort.link(tempActInRel);
    TypedIORelation tempActOutRel=(TypedIORelation)tempAct.newRelation(""String_Node_Str"");
    tempActOutPort.link(tempActInRel);
    tempActState0OutPort.link(tempActInRel);
    tempActState1OutPort.link(tempActInRel);
    try {
      SDFDirector _director1=new SDFDirector(tempActState1,""String_Node_Str"");
      Parameter iterparam1=_director1.iterations;
      iterparam1.setToken(new IntToken(iterations));
      SDFScheduler scheduler1=new SDFScheduler(_workspace);
      _director1.setScheduler(scheduler1);
      _director1.setScheduleValid(false);
    }
 catch (    Exception ex) {
      report(""String_Node_Str"",ex);
    }
    Const const1=new Const(tempActState1,""String_Node_Str"");
    const1.value.setToken(new DoubleToken(1));
    tempActState1.connect(const1.output,tempActState1OutPort);
    _toplevel.connect(rampSig.output,sineSig.input);
    _toplevel.connect(sineSig.output,add.plus);
    _toplevel.connect(noise.output,add.plus);
    _toplevel.connect(add.output,tempActInPort);
    _toplevel.connect(tempActOutPort,hystplotter.input);
    _toplevel.connect(add.output,hystplotter.input);
  }
 catch (  Exception ex) {
    report(""String_Node_Str"",ex);
  }
}","/** 
 * After invoking super.init(), create and connect the actors.
 */
public void init(){
  super.init();
  getContentPane().add(_createRunControls(2),BorderLayout.SOUTH);
  try {
    Ramp rampSig=new Ramp(_toplevel,""String_Node_Str"");
    Sine sineSig=new Sine(_toplevel,""String_Node_Str"");
    sineSig.omega.setToken(new DoubleToken(0.1));
    Gaussian noise=new Gaussian(_toplevel,""String_Node_Str"");
    noise.standardDeviation.setToken(new DoubleToken(0.2));
    AddSubtract add=new AddSubtract(_toplevel,""String_Node_Str"");
    SequencePlotter hystplotter=new SequencePlotter(_toplevel,""String_Node_Str"");
    hystplotter.place(getContentPane());
    hystplotter.plot.setBackground(getBackground());
    hystplotter.plot.setGrid(false);
    hystplotter.plot.setTitle(""String_Node_Str"");
    hystplotter.plot.setXRange(0.0,200.0);
    hystplotter.plot.setWrap(true);
    hystplotter.plot.setYRange(-1.3,1.3);
    hystplotter.plot.setMarksStyle(""String_Node_Str"");
    hystplotter.plot.setPointsPersistence(200);
    TypedCompositeActor tempAct=new TypedCompositeActor(_toplevel,""String_Node_Str"");
    TypedIOPort tempActInPort=(TypedIOPort)tempAct.newPort(""String_Node_Str"");
    tempActInPort.setInput(true);
    tempActInPort.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort tempActOutPort=(TypedIOPort)tempAct.newPort(""String_Node_Str"");
    tempActOutPort.setOutput(true);
    tempActOutPort.setTypeEquals(BaseType.DOUBLE);
    HDFFSMController ctrl=new HDFFSMController(tempAct,""String_Node_Str"");
    StreamListener sa=new StreamListener();
    ctrl.addDebugListener(sa);
    HDFFSMState ctrls0=new HDFFSMState(ctrl,""String_Node_Str"");
    HDFFSMState ctrls1=new HDFFSMState(ctrl,""String_Node_Str"");
    ctrl.setInitialState(ctrls0);
    HDFFSMTransition ctrlTrs0Tos1=(HDFFSMTransition)ctrl.createTransition(ctrls0,ctrls1);
    ctrlTrs0Tos1.setTriggerEvent(""String_Node_Str"");
    ctrlTrs0Tos1.setTriggerCondition(""String_Node_Str"");
    HDFFSMTransition ctrlTrs0Tos0=(HDFFSMTransition)ctrl.createTransition(ctrls0,ctrls0);
    ctrlTrs0Tos0.setTriggerEvent(""String_Node_Str"");
    ctrlTrs0Tos0.setTriggerCondition(""String_Node_Str"");
    HDFFSMTransition ctrlTrs1Tos0=(HDFFSMTransition)ctrl.createTransition(ctrls1,ctrls0);
    ctrlTrs1Tos0.setTriggerEvent(""String_Node_Str"");
    ctrlTrs1Tos0.setTriggerCondition(""String_Node_Str"");
    HDFFSMTransition ctrlTrs1Tos1=(HDFFSMTransition)ctrl.createTransition(ctrls1,ctrls1);
    ctrlTrs1Tos1.setTriggerEvent(""String_Node_Str"");
    ctrlTrs1Tos1.setTriggerCondition(""String_Node_Str"");
    HDFFSMDirector ctrlDir=new HDFFSMDirector(tempAct,""String_Node_Str"");
    ctrlDir.setController(ctrl);
    StreamListener sa2=new StreamListener();
    ctrlDir.addDebugListener(sa2);
    TypedCompositeActor tempActState0=new TypedCompositeActor(tempAct,""String_Node_Str"");
    ctrls0.setRefinement(tempActState0);
    TypedIOPort tempActState0InPort=(TypedIOPort)tempActState0.newPort(""String_Node_Str"");
    tempActState0InPort.setInput(true);
    tempActState0InPort.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort tempActState0OutPort=(TypedIOPort)tempActState0.newPort(""String_Node_Str"");
    tempActState0OutPort.setOutput(true);
    tempActState0OutPort.setTypeEquals(BaseType.DOUBLE);
    try {
      SDFDirector _director0=new SDFDirector(tempActState0,""String_Node_Str"");
      Parameter iterparam0=_director0.iterations;
      iterparam0.setToken(new IntToken(iterations));
      SDFScheduler scheduler0=new SDFScheduler(_workspace);
      _director0.setScheduler(scheduler0);
      _director0.setScheduleValid(false);
    }
 catch (    Exception ex) {
      report(""String_Node_Str"",ex);
    }
    Const const0=new Const(tempActState0,""String_Node_Str"");
    const0.value.setToken(new DoubleToken(-1));
    tempActState0.connect(const0.output,tempActState0OutPort);
    TypedCompositeActor tempActState1=new TypedCompositeActor(tempAct,""String_Node_Str"");
    ctrls1.setRefinement(tempActState1);
    TypedIOPort tempActState1InPort=(TypedIOPort)tempActState1.newPort(""String_Node_Str"");
    tempActState1InPort.setInput(true);
    tempActState1InPort.setTypeEquals(BaseType.DOUBLE);
    TypedIOPort tempActState1OutPort=(TypedIOPort)tempActState1.newPort(""String_Node_Str"");
    tempActState1OutPort.setOutput(true);
    tempActState1OutPort.setTypeEquals(BaseType.DOUBLE);
    TypedIORelation tempActInRel=(TypedIORelation)tempAct.newRelation(""String_Node_Str"");
    tempActInPort.link(tempActInRel);
    tempActState0InPort.link(tempActInRel);
    tempActState1InPort.link(tempActInRel);
    TypedIORelation tempActOutRel=(TypedIORelation)tempAct.newRelation(""String_Node_Str"");
    tempActOutPort.link(tempActInRel);
    tempActState0OutPort.link(tempActInRel);
    tempActState1OutPort.link(tempActInRel);
    try {
      SDFDirector _director1=new SDFDirector(tempActState1,""String_Node_Str"");
      Parameter iterparam1=_director1.iterations;
      iterparam1.setToken(new IntToken(iterations));
      SDFScheduler scheduler1=new SDFScheduler(_workspace);
      _director1.setScheduler(scheduler1);
      _director1.setScheduleValid(false);
    }
 catch (    Exception ex) {
      report(""String_Node_Str"",ex);
    }
    Const const1=new Const(tempActState1,""String_Node_Str"");
    const1.value.setToken(new DoubleToken(1));
    tempActState1.connect(const1.output,tempActState1OutPort);
    _toplevel.connect(rampSig.output,sineSig.input);
    _toplevel.connect(sineSig.output,add.plus);
    _toplevel.connect(noise.output,add.plus);
    _toplevel.connect(tempActOutPort,hystplotter.input);
    TypedIORelation noisyRel=(TypedIORelation)_toplevel.newRelation(""String_Node_Str"");
    (add.output).link(noisyRel);
    (tempActInPort).link(noisyRel);
    (hystplotter.input).link(noisyRel);
  }
 catch (  Exception ex) {
    report(""String_Node_Str"",ex);
  }
}"
76291,"/** 
 * Resolve an external entity.  This method returns null, which has the effect of defering to &AElig;lfred for resolution of the URI.  Derived classes may return a a modified URI (a string), an InputStream, or a Reader. In the latter two cases, the input character stream is provided.
 * @param publicId The public identifier, or null if none was supplied.
 * @param systemId The system identifier.
 * @return Null, indicating to use the default system identifier.
 */
public Object resolveEntity(String publicID,String systemID){
  if (publicID.equals(""String_Node_Str"")) {
    return new StringReader(MoML_DTD_1);
  }
 else {
    return null;
  }
}","/** 
 * Resolve an external entity.  This method returns null, which has the effect of defering to &AElig;lfred for resolution of the URI.  Derived classes may return a a modified URI (a string), an InputStream, or a Reader. In the latter two cases, the input character stream is provided.
 * @param publicId The public identifier, or null if none was supplied.
 * @param systemId The system identifier.
 * @return Null, indicating to use the default system identifier.
 */
public Object resolveEntity(String publicID,String systemID){
  if (publicID != null && publicID.equals(""String_Node_Str"")) {
    return new StringReader(MoML_DTD_1);
  }
 else {
    return null;
  }
}"
76292,"public void traverseChildren(IVisitor v,LinkedList args){
  LinkedList retList=TNLManip.traverseList(v,this,args,_childList);
  setProperty(""String_Node_Str"",(Object)retList);
}","public void traverseChildren(IVisitor v,LinkedList args){
  LinkedList retList=TNLManip.traverseList(v,this,args,_childList);
  setProperty(""String_Node_Str"",retList);
}"
76293,"public Object visitParameterNode(ParameterNode node,LinkedList args){
  String retval=new String();
  retval+=(String)node.childReturnValueAt(node.CHILD_INDEX_DTYPE);
  retval+=""String_Node_Str"" + node.getName().getIdent();
  return retval;
}","public Object visitParameterNode(ParameterNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  sb.append(Modifier.toString(node.getModifiers()));
  sb.append((String)node.childReturnValueAt(node.CHILD_INDEX_DTYPE));
  sb.append(""String_Node_Str"" + node.getName().getIdent());
  return sb.toString();
}"
76294,"public Object visitVarDeclNode(VarDeclNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  sb.append((String)node.childReturnValueAt(node.CHILD_INDEX_DTYPE));
  sb.append(' ');
  sb.append(node.getName().getIdent());
  sb.append(""String_Node_Str"");
  sb.append((String)node.childReturnValueAt(node.CHILD_INDEX_INITEXPR));
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public Object visitVarDeclNode(VarDeclNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  sb.append(Modifier.toString(node.getModifiers()));
  sb.append((String)node.childReturnValueAt(node.CHILD_INDEX_DTYPE));
  sb.append(' ');
  sb.append(node.getName().getIdent());
  sb.append(""String_Node_Str"");
  sb.append((String)node.childReturnValueAt(node.CHILD_INDEX_INITEXPR));
  return sb.toString();
}"
76295,"public Object visitCompileUnitNode(CompileUnitNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  String pkgStr=(String)node.childReturnValueAt(node.CHILD_INDEX_PKG);
  sb.append(pkgStr);
  sb.append('\n');
  LinkedList impList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_IMPORTS);
  ListIterator impItr=impList.listIterator();
  while (impItr.hasNext()) {
    sb.append((String)impItr.next());
  }
  sb.append('\n');
  LinkedList typeList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_DEFTYPES);
  ListIterator typeItr=typeList.listIterator();
  while (typeItr.hasNext()) {
    sb.append((String)typeItr.next());
    sb.append('\n');
  }
  return sb.toString();
}","public Object visitCompileUnitNode(CompileUnitNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  String pkgStr=(String)node.childReturnValueAt(node.CHILD_INDEX_PKG);
  if (pkgStr.length() > 0) {
    sb.append(""String_Node_Str"");
    sb.append(pkgStr);
    sb.append(""String_Node_Str"");
  }
  LinkedList impList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_IMPORTS);
  ListIterator impItr=impList.listIterator();
  while (impItr.hasNext()) {
    sb.append((String)impItr.next());
  }
  sb.append('\n');
  LinkedList typeList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_DEFTYPES);
  ListIterator typeItr=typeList.listIterator();
  while (typeItr.hasNext()) {
    sb.append((String)typeItr.next());
    sb.append('\n');
  }
  return sb.toString();
}"
76296,"public Object visitFieldDeclNode(FieldDeclNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  sb.append(Modifier.toString(node.getModifiers()));
  sb.append((String)node.childReturnValueAt(node.CHILD_INDEX_DTYPE));
  sb.append(' ');
  sb.append(node.getName().getIdent());
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public Object visitFieldDeclNode(FieldDeclNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  sb.append(Modifier.toString(node.getModifiers()));
  sb.append((String)node.childReturnValueAt(node.CHILD_INDEX_DTYPE));
  sb.append(' ');
  sb.append(node.getName().getIdent());
  String initStr=(String)node.childReturnValueAt(node.CHILD_INDEX_INITEXPR);
  if (initStr.length() > 0) {
    sb.append(""String_Node_Str"");
    sb.append(initStr);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
76297,"public Object visitBlockNode(BlockNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  LinkedList stmtList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_STMTS);
  LinkedList stmtTreeList=(LinkedList)node.getStmts();
  ListIterator stmtItr=stmtList.listIterator();
  ListIterator stmtTreeItr=stmtTreeList.listIterator();
  while (stmtItr.hasNext()) {
    sb.append((String)stmtItr.next());
    TreeNode stmt=(TreeNode)stmtTreeItr.next();
    if (stmt instanceof ExprNode) {
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public Object visitBlockNode(BlockNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  LinkedList stmtList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_STMTS);
  LinkedList stmtTreeList=(LinkedList)node.getStmts();
  ListIterator stmtItr=stmtList.listIterator();
  ListIterator stmtTreeItr=stmtTreeList.listIterator();
  while (stmtItr.hasNext()) {
    sb.append((String)stmtItr.next());
    TreeNode stmt=(TreeNode)stmtTreeItr.next();
    if ((stmt instanceof ExprNode) || (stmt instanceof VarDeclNode)) {
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
76298,"public Object visitConstructorDeclNode(ConstructorDeclNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  sb.append(Modifier.toString(node.getModifiers()));
  sb.append(node.getIdent());
  sb.append('(');
  LinkedList paramList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_PARAMS);
  sb.append(_commaList(paramList));
  sb.append(""String_Node_Str"");
  LinkedList throwsList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_THROWSLIST);
  if (!throwsList.isEmpty()) {
    sb.append(""String_Node_Str"");
    sb.append(_commaList(throwsList));
    sb.append(' ');
  }
  sb.append((String)node.childReturnValueAt(node.CHILD_INDEX_BODY));
  sb.append('\n');
  return sb.toString();
}","public Object visitConstructorDeclNode(ConstructorDeclNode node,LinkedList args){
  StringBuffer sb=new StringBuffer();
  sb.append(Modifier.toString(node.getModifiers()));
  sb.append(node.getIdent());
  sb.append('(');
  LinkedList paramList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_PARAMS);
  sb.append(_commaList(paramList));
  sb.append(""String_Node_Str"");
  LinkedList throwsList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_THROWSLIST);
  if (!throwsList.isEmpty()) {
    sb.append(""String_Node_Str"");
    sb.append(_commaList(throwsList));
    sb.append(' ');
  }
  sb.append(""String_Node_Str"");
  sb.append((String)node.childReturnValueAt(node.CHILD_INDEX_CONSTRUCTORCALL));
  String bodyStr=(String)node.childReturnValueAt(node.CHILD_INDEX_BODY);
  if (bodyStr.length() > 2) {
    bodyStr=bodyStr.substring(2);
    sb.append(bodyStr);
  }
  sb.append('\n');
  return sb.toString();
}"
76299,"/** 
 * Read at most one token from each input channel and display its string value on the screen.  Each value is terminated with a newline character.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      Token token=input.get(i);
      String value=token.stringValue();
      textArea.append(value + ""String_Node_Str"");
      JScrollBar bar=_scrollPane.getVerticalScrollBar();
      if (bar != null) {
        bar.setValue(bar.getMaximum() - bar.getVisibleAmount());
      }
    }
  }
}","/** 
 * Read at most one token from each input channel and display its string value on the screen.  Each value is terminated with a newline character.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      Token token=input.get(i);
      String value=token.stringValue();
      textArea.append(value + ""String_Node_Str"");
      try {
        int lineOffset=textArea.getLineEndOffset(textArea.getLineCount() - 1);
        textArea.setCaretPosition(lineOffset);
      }
 catch (      BadLocationException ex) {
      }
    }
  }
}"
76300,"/** 
 * Create a text area on the screen, if necessary, or clear the previously existing text area. If a grapical container has not been specified, place the text area into its own frame.  Otherwise, place it in the specified container.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (textArea == null) {
    place(_container);
  }
 else {
  }
}","/** 
 * Create a text area on the screen, if necessary, or clear the previously existing text area. If a grapical container has not been specified, place the text area into its own frame.  Otherwise, place it in the specified container.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (textArea == null) {
    place(_container);
  }
 else {
    textArea.setText(null);
  }
  if (_frame != null) {
    _frame.setVisible(true);
  }
}"
76301,"/** 
 * Specify the container in which the data should be displayed. An instance of JTextArea will be added to that container. This method needs to be called before the first call to initialize(). Otherwise, an instance of TextArea will be placed in its own frame. The text area is also placed in its own frame if this method is called with a null argument.
 * @param container The container into which to place the text area.
 */
public void place(Container container){
  _container=container;
  if (_container == null) {
    JFrame frame=new JFrame(getFullName());
    textArea=new JTextArea();
    _scrollPane=new JScrollPane(textArea);
    frame.getContentPane().add(_scrollPane);
  }
 else {
    textArea=new JTextArea();
    _scrollPane=new JScrollPane(textArea);
    _container.add(_scrollPane);
  }
}","/** 
 * Specify the container in which the data should be displayed. An instance of JTextArea will be added to that container. This method needs to be called before the first call to initialize(). Otherwise, an instance of TextArea will be placed in its own frame. The text area is also placed in its own frame if this method is called with a null argument.
 * @param container The container into which to place the text area.
 */
public void place(Container container){
  _container=container;
  if (_container == null) {
    JFrame _frame=new JFrame(getFullName());
    textArea=new JTextArea();
    _scrollPane=new JScrollPane(textArea);
    _frame.getContentPane().add(_scrollPane);
  }
 else {
    textArea=new JTextArea();
    _scrollPane=new JScrollPane(textArea);
    _container.add(_scrollPane);
  }
  textArea.setEditable(false);
}"
76302,"public Object visitDeclaratorNode(DeclaratorNode node,LinkedList args){
  return _defaultVisit((TreeNode)node,args);
}","public Object visitDeclaratorNode(DeclaratorNode node,LinkedList args){
  throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
}"
76303,"public static final void checkClassModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | PROTECTED_MOD | PRIVATE_MOD| FINAL_MOD| ABSTRACT_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public static final void checkClassModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | PROTECTED_MOD | PRIVATE_MOD| FINAL_MOD| ABSTRACT_MOD| STRICTFP_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"" + toString(modifiers));
  }
}"
76304,"public static final void checkMethodModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | PROTECTED_MOD | PRIVATE_MOD| STATIC_MOD| FINAL_MOD| ABSTRACT_MOD| NATIVE_MOD| SYNCHRONIZED_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public static final void checkMethodModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | PROTECTED_MOD | PRIVATE_MOD| STATIC_MOD| FINAL_MOD| ABSTRACT_MOD| NATIVE_MOD| SYNCHRONIZED_MOD| STRICTFP_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"" + toString(modifiers));
  }
}"
76305,"public static final void checkMethodSignatureModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | ABSTRACT_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public static final void checkMethodSignatureModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | ABSTRACT_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"" + toString(modifiers));
  }
}"
76306,"public static final String toString(final int modifier){
  StringBuffer modString=new StringBuffer();
  if (modifier == NO_MOD)   return ""String_Node_Str"";
  if ((modifier & PUBLIC_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & PROTECTED_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & PRIVATE_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & ABSTRACT_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & FINAL_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & NATIVE_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & SYNCHRONIZED_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & TRANSIENT_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & VOLATILE_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & STATIC_MOD) != 0)   modString.append(""String_Node_Str"");
  return modString.toString();
}","public static final String toString(final int modifier){
  StringBuffer modString=new StringBuffer();
  if (modifier == NO_MOD)   return ""String_Node_Str"";
  if ((modifier & PUBLIC_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & PROTECTED_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & PRIVATE_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & ABSTRACT_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & FINAL_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & NATIVE_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & SYNCHRONIZED_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & TRANSIENT_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & VOLATILE_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & STATIC_MOD) != 0)   modString.append(""String_Node_Str"");
  if ((modifier & STRICTFP_MOD) != 0)   modString.append(""String_Node_Str"");
  return modString.toString();
}"
76307,"public static final void checkConstantFieldModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | STATIC_MOD | FINAL_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public static final void checkConstantFieldModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | STATIC_MOD | FINAL_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"" + toString(modifiers));
  }
}"
76308,"public static final void checkFieldModifiers(int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | PROTECTED_MOD | PRIVATE_MOD| STATIC_MOD| FINAL_MOD| TRANSIENT_MOD| VOLATILE_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public static final void checkFieldModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | PROTECTED_MOD | PRIVATE_MOD| STATIC_MOD| FINAL_MOD| TRANSIENT_MOD| VOLATILE_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"" + toString(modifiers));
  }
}"
76309,"public static final void checkConstructorModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | PROTECTED_MOD | PRIVATE_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public static final void checkConstructorModifiers(final int modifiers){
  if ((modifiers & ~(PUBLIC_MOD | PROTECTED_MOD | PRIVATE_MOD)) != 0) {
    throw new RuntimeException(""String_Node_Str"" + toString(modifiers));
  }
}"
76310,"/** 
 * Open the document from its current file.  If successful, add a new Page to the document containing the model parsed from the current file.
 * @throws Exception  If there is no file, or if the I/O operation failed.
 */
public void open() throws Exception {
  if (getFile() == null) {
    throw new IllegalStateException(""String_Node_Str"" + getTitle() + ""String_Node_Str"");
  }
  String filename=getFile().getCanonicalPath();
  URL urlbase=new URL(""String_Node_Str"");
  URL schematicURL=new URL(urlbase,filename);
  System.out.println(""String_Node_Str"" + schematicURL);
  MoMLParser parser=new MoMLParser();
  CompositeEntity toplevel=(CompositeEntity)parser.parse(schematicURL,schematicURL.openStream());
  setGraph(toplevel);
}","/** 
 * Open the document from its current file.  If successful, add a new Page to the document containing the model parsed from the current file.
 * @throws Exception  If there is no file, or if the I/O operation failed.
 */
public void open() throws Exception {
  if (getFile() == null) {
    throw new IllegalStateException(""String_Node_Str"" + getTitle() + ""String_Node_Str"");
  }
  String filename=getFile().getAbsolutePath();
  URL schematicURL=new URL(""String_Node_Str"",null,filename);
  MoMLParser parser=new MoMLParser();
  CompositeEntity toplevel=(CompositeEntity)parser.parse(schematicURL,new FileInputStream(getFile()));
  setGraph(toplevel);
}"
76311,"/** 
 * Check if the value of this token is strictly less than that of the argument token.
 * @param arg A ScalarToken.
 * @return A BooleanToken with value true if this token is strictlyless than the argument.
 * @exception IllegalActionException If the type of the argument tokenis incomparable with the type of this token.
 */
public BooleanToken isLessThan(ScalarToken arg) throws IllegalActionException {
  int typeInfo=TypeLattice.compare(this,arg);
  if (typeInfo == CPO.INCOMPARABLE) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ arg.getType());
  }
  if (typeInfo == CPO.LOWER) {
    return arg.isLessThan(this);
  }
  ScalarToken longArg=arg;
  if (typeInfo == CPO.HIGHER) {
    longArg=(ScalarToken)convert(arg);
  }
  if (_value < longArg.intValue()) {
    return new BooleanToken(true);
  }
  return new BooleanToken(false);
}","/** 
 * Check if the value of this token is strictly less than that of the argument token.
 * @param arg A ScalarToken.
 * @return A BooleanToken with value true if this token is strictlyless than the argument.
 * @exception IllegalActionException If the type of the argument tokenis incomparable with the type of this token.
 */
public BooleanToken isLessThan(ScalarToken arg) throws IllegalActionException {
  int typeInfo=TypeLattice.compare(this,arg);
  if (typeInfo == CPO.INCOMPARABLE) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ arg.getType());
  }
  if (typeInfo == CPO.LOWER) {
    return arg.isLessThan(this);
  }
  ScalarToken longArg=arg;
  if (typeInfo == CPO.HIGHER) {
    longArg=(ScalarToken)convert(arg);
  }
  if (_value < longArg.longValue()) {
    return new BooleanToken(true);
  }
  return new BooleanToken(false);
}"
76312,"/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A LinkedList of the Actors in the order they should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
private LinkedList _scheduleConnectedActors(LinkedList actorList) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  LinkedList newSchedule=new LinkedList();
  Map waitingTokens=new TreeMap(new NamedObjComparator());
  Map firingsRemainingVector=new TreeMap(new NamedObjComparator());
  firingsRemainingVector.putAll(_firingvector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Enumeration ainputports=a.inputPorts();
      while (ainputports.hasMoreElements()) {
        IOPort ainputport=(IOPort)ainputports.nextElement();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.put(ainputport,tokencount);
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Enumeration aoutputports=a.outputPorts();
      while (aoutputports.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aoutputports.nextElement();
        int count=_getTokenInitProduction(aOutputPort);
        if (_debugging)         _debug(""String_Node_Str"" + count + ""String_Node_Str""+ aOutputPort);
        if (count > 0) {
          _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
        }
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.addFirst((ComponentEntity)a);
      if (_debugging)       _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
    }
    while (readyToScheduleActorList.size() > 0) {
      if (_debugging)       _debug(""String_Node_Str"");
      Iterator ports=waitingTokens.keySet().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        int tokencount[]=(int[])waitingTokens.get(port);
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getFullName());
          _debug(""String_Node_Str"" + tokencount.length);
        }
        for (int channel=0; channel < tokencount.length; channel++)         if (_debugging)         _debug(""String_Node_Str"" + channel + ""String_Node_Str""+ tokencount[channel]+ ""String_Node_Str"");
      }
      if (_debugging)       _debug(""String_Node_Str"");
      Iterator actorsLeft=readyToScheduleActorList.iterator();
      while (actorsLeft.hasNext()) {
        Entity e=(Entity)actorsLeft.next();
        if (_debugging)         _debug(e.getFullName());
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor))       ;
      if (_debugging) {
        _debug(""String_Node_Str"" + currentActor.getName());
      }
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.addLast(currentActor);
      Enumeration aOutputPorts=((Actor)currentActor).outputPorts();
      while (aOutputPorts.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.nextElement();
        int count=_getTokenProductionRate(aOutputPort);
        _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      firingsRemaining-=1;
      firingsRemainingVector.put(currentActor,new Integer(firingsRemaining));
      if (_debugging) {
        _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      }
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          while (unscheduledActorList.remove(currentActor))           ;
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1)           readyToScheduleActorList.addLast(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    if (_debugging)     _debug(""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    String s=new String(""String_Node_Str"");
    Iterator actors=unscheduledActorList.iterator();
    while (actors.hasNext()) {
      Entity actor=(Entity)actors.next();
      s+=actor.getFullName() + ""String_Node_Str"";
    }
    throw new NotSchedulableException(s);
  }
  Iterator eschedule=newSchedule.iterator();
  if (_debugging) {
    _debug(""String_Node_Str"");
    while (eschedule.hasNext()) {
      _debug(((ComponentEntity)eschedule.next()).toString());
    }
  }
  return newSchedule;
}","/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A LinkedList of the Actors in the order they should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
private LinkedList _scheduleConnectedActors(LinkedList actorList) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  LinkedList newSchedule=new LinkedList();
  Map waitingTokens=new TreeMap(new NamedObjComparator());
  Map firingsRemainingVector=new TreeMap(new NamedObjComparator());
  firingsRemainingVector.putAll(_firingvector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Enumeration ainputports=a.inputPorts();
      while (ainputports.hasMoreElements()) {
        IOPort ainputport=(IOPort)ainputports.nextElement();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.put(ainputport,tokencount);
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Enumeration aoutputports=a.outputPorts();
      while (aoutputports.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aoutputports.nextElement();
        int count=_getTokenInitProduction(aOutputPort);
        if (_debugging)         _debug(""String_Node_Str"" + count + ""String_Node_Str""+ aOutputPort);
        if (count > 0) {
          _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
        }
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.addFirst((ComponentEntity)a);
      if (_debugging)       _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
    }
    while (readyToScheduleActorList.size() > 0) {
      if (_debugging)       _debug(""String_Node_Str"");
      Iterator ports=waitingTokens.keySet().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        int tokencount[]=(int[])waitingTokens.get(port);
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getFullName());
          _debug(""String_Node_Str"" + tokencount.length);
        }
        for (int channel=0; channel < tokencount.length; channel++)         if (_debugging)         _debug(""String_Node_Str"" + channel + ""String_Node_Str""+ tokencount[channel]+ ""String_Node_Str"");
      }
      if (_debugging)       _debug(""String_Node_Str"");
      Iterator actorsLeft=readyToScheduleActorList.iterator();
      while (actorsLeft.hasNext()) {
        Entity e=(Entity)actorsLeft.next();
        if (_debugging)         _debug(e.getFullName());
      }
      if (_debugging)       _debug(""String_Node_Str"");
      actorsLeft=unscheduledActorList.iterator();
      while (actorsLeft.hasNext()) {
        Entity e=(Entity)actorsLeft.next();
        if (_debugging)         _debug(e.getFullName());
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor))       ;
      if (_debugging) {
        _debug(""String_Node_Str"" + currentActor.getName());
      }
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.addLast(currentActor);
      Enumeration aOutputPorts=((Actor)currentActor).outputPorts();
      while (aOutputPorts.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.nextElement();
        int count=_getTokenProductionRate(aOutputPort);
        _simulateTokensCreated(aOutputPort,count,unscheduledActorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      firingsRemaining-=1;
      firingsRemainingVector.put(currentActor,new Integer(firingsRemaining));
      if (_debugging) {
        _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      }
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          _debug(""String_Node_Str"" + currentActor);
          while (readyToScheduleActorList.remove(currentActor))           ;
          while (unscheduledActorList.remove(currentActor))           ;
          _debug(""String_Node_Str"");
          actorsLeft=readyToScheduleActorList.iterator();
          while (actorsLeft.hasNext()) {
            Entity e=(Entity)actorsLeft.next();
            if (_debugging)             _debug(e.getFullName());
          }
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1 && unscheduledActorList.contains(currentActor))           readyToScheduleActorList.addLast(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    if (_debugging)     _debug(""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    String s=new String(""String_Node_Str"");
    Iterator actors=unscheduledActorList.iterator();
    while (actors.hasNext()) {
      Entity actor=(Entity)actors.next();
      s+=actor.getFullName() + ""String_Node_Str"";
    }
    throw new NotSchedulableException(s);
  }
  Iterator eschedule=newSchedule.iterator();
  if (_debugging) {
    _debug(""String_Node_Str"");
    while (eschedule.hasNext()) {
      _debug(((ComponentEntity)eschedule.next()).toString());
    }
  }
  return newSchedule;
}"
76313,"/** 
 * Output the sample value of the sound file corresponding to the current index.
 */
public boolean postfire() throws IllegalActionException {
  try {
    int i;
    int numBytesRead;
    numBytesRead=properFormatAudioInputStream.read(data);
    if (numBytesRead == -1) {
      return false;
    }
 else     if (numBytesRead != data.length) {
      return false;
    }
    double[] audioInDoubleArray;
    audioInDoubleArray=_byteArrayToDoubleArray(data,frameSizeInBytes);
    DoubleToken[] audioTokenArray=new DoubleToken[productionRate];
    for (i=0; i < productionRate; i++) {
      audioTokenArray[i]=new DoubleToken(audioInDoubleArray[i]);
    }
    output.sendArray(0,audioTokenArray);
    output.sendArray(1,audioTokenArray);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex.getMessage());
  }
catch (  IOException ex) {
    throw new InternalErrorException(ex.getMessage());
  }
  return true;
}","/** 
 * Output the sample value of the sound file corresponding to the current index.
 */
public boolean postfire() throws IllegalActionException {
  try {
    int i;
    int numBytesRead;
    numBytesRead=properFormatAudioInputStream.read(data);
    if (numBytesRead == -1) {
      audioTokenArray=new DoubleToken[productionRate];
      for (i=0; i < productionRate; i++) {
        audioTokenArray[i]=new DoubleToken(0);
      }
      output.sendArray(0,audioTokenArray);
      output.sendArray(1,audioTokenArray);
      return false;
    }
 else     if (numBytesRead != data.length) {
      audioTokenArray=new DoubleToken[productionRate];
      for (i=0; i < productionRate; i++) {
        audioTokenArray[i]=new DoubleToken(0);
      }
      output.sendArray(0,audioTokenArray);
      output.sendArray(1,audioTokenArray);
      return false;
    }
    audioInDoubleArray=_byteArrayToDoubleArray(data,frameSizeInBytes);
    audioTokenArray=new DoubleToken[productionRate];
    for (i=0; i < productionRate; i++) {
      audioTokenArray[i]=new DoubleToken(audioInDoubleArray[i]);
    }
    output.sendArray(0,audioTokenArray);
    output.sendArray(1,audioTokenArray);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex.getMessage());
  }
catch (  IOException ex) {
    throw new InternalErrorException(ex.getMessage());
  }
  return true;
}"
76314,"/** 
 * Put an event into the event queue with the specified destination receiver, token, and depth.  The time stamp of the event is the current time, but the microstep is one larger than the current microstep.  This method is used by actors that declare that they introduce delay, but where the value of the delay is zero. This method must not be used before any firings have occurred (i.e. in the initialize() method) because current time has no meaning there.
 * @param receiver The destination receiver.
 * @param token The token destined for that receiver.
 * @param depth The depth.
 * @exception IllegalActionException If the delay is negative, or ifcurrent time has not been set.
 */
protected void _enqueueEvent(DEReceiver receiver,Token token,int depth) throws IllegalActionException {
  int microstep=0;
  if (_startTime == Double.MAX_VALUE) {
    Nameable destination=receiver.getContainer();
    throw new IllegalActionException(destination,""String_Node_Str"" + ""String_Node_Str"");
  }
  _eventQueue.put(new DEEvent(receiver,token,getCurrentTime(),_microstep + 1,depth));
}","/** 
 * Put an event into the event queue with the specified destination receiver, token, and depth.  The time stamp of the event is the current time, but the microstep is one larger than the current microstep.  This method is used by actors that declare that they introduce delay, but where the value of the delay is zero. This method must not be used before any firings have occurred (i.e. in the initialize() method) because current time has no meaning there.
 * @param receiver The destination receiver.
 * @param token The token destined for that receiver.
 * @param depth The depth.
 * @exception IllegalActionException If the delay is negative, or ifcurrent time has not been set.
 */
protected void _enqueueEvent(DEReceiver receiver,Token token,int depth) throws IllegalActionException {
  if (_startTime == Double.MAX_VALUE) {
    Nameable destination=receiver.getContainer();
    throw new IllegalActionException(destination,""String_Node_Str"" + ""String_Node_Str"");
  }
  _eventQueue.put(new DEEvent(receiver,token,getCurrentTime(),_microstep + 1,depth));
}"
76315,"/** 
 * Advance current time to the next event in the event queue, and fire one or more actors that have events at that time. Each actor is iterated repeatedly (prefire(), fire(), postfire()), until either it has no more input tokens at the current time, or its prefire() method returns false. If there are no events in the event queue, then the behavior depends on whether stopWhenQueueIsEmpty() has been called.  If it has, and was given the argument false, then this thread will stall until inputs become available on the input queue.  Otherwise, time will advance to the stop time and the execution will halt.
 * @exception IllegalActionException If the firing actor throws it.
 */
public void fire() throws IllegalActionException {
  boolean _timeHasNotAdvanced=true;
  while (true) {
    Actor actorToFire=_getActorToFire();
    if (actorToFire == null) {
      if (_debugging)       _debug(""String_Node_Str"");
      _noMoreActorsToFire=true;
      return;
    }
    if (actorToFire == getContainer()) {
      return;
    }
    boolean refire=false;
    do {
      if (_debugging) {
        _debug(""String_Node_Str"",((Entity)actorToFire).getName(),""String_Node_Str"",Double.toString(getCurrentTime()));
      }
      if (!actorToFire.prefire()) {
        if (_debugging)         _debug(""String_Node_Str"");
        break;
      }
      actorToFire.fire();
      if (!actorToFire.postfire()) {
        if (_debugging)         _debug(""String_Node_Str"",((Entity)actorToFire).getName());
        disableActor(actorToFire);
      }
      refire=false;
      Enumeration inputPorts=actorToFire.inputPorts();
      while (inputPorts.hasMoreElements()) {
        IOPort port=(IOPort)inputPorts.nextElement();
        for (int i=0; i < port.getWidth(); i++) {
          if (port.hasToken(i)) {
            refire=true;
            break;
          }
        }
        if (refire == true)         break;
      }
    }
 while (refire);
    try {
      DEEvent next=_eventQueue.get();
      if (next.timeStamp() > getCurrentTime())       break;
 else       if (next.timeStamp() < getCurrentTime()) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
 catch (    IllegalActionException e) {
      break;
    }
  }
}","/** 
 * Advance current time to the next event in the event queue, and fire one or more actors that have events at that time. Each actor is iterated repeatedly (prefire(), fire(), postfire()), until either it has no more input tokens at the current time, or its prefire() method returns false. If there are no events in the event queue, then the behavior depends on whether stopWhenQueueIsEmpty() has been called.  If it has, and was given the argument false, then this thread will stall until inputs become available on the input queue.  Otherwise, time will advance to the stop time and the execution will halt.
 * @exception IllegalActionException If the firing actor throws it.
 */
public void fire() throws IllegalActionException {
  boolean _timeHasNotAdvanced=true;
  while (true) {
    Actor actorToFire=_dequeueEvents();
    if (actorToFire == null) {
      if (_debugging)       _debug(""String_Node_Str"");
      _noMoreActorsToFire=true;
      return;
    }
    if (actorToFire == getContainer()) {
      return;
    }
    boolean refire=false;
    do {
      if (_debugging) {
        _debug(""String_Node_Str"",((Entity)actorToFire).getName(),""String_Node_Str"",Double.toString(getCurrentTime()));
      }
      if (!actorToFire.prefire()) {
        if (_debugging)         _debug(""String_Node_Str"");
        break;
      }
      actorToFire.fire();
      if (!actorToFire.postfire()) {
        if (_debugging)         _debug(""String_Node_Str"",((Entity)actorToFire).getName());
        disableActor(actorToFire);
      }
      refire=false;
      Enumeration inputPorts=actorToFire.inputPorts();
      while (inputPorts.hasMoreElements()) {
        IOPort port=(IOPort)inputPorts.nextElement();
        for (int i=0; i < port.getWidth(); i++) {
          if (port.hasToken(i)) {
            refire=true;
            break;
          }
        }
        if (refire == true)         break;
      }
    }
 while (refire);
    try {
      DEEvent next=_eventQueue.get();
      if (next.timeStamp() > getCurrentTime())       break;
 else       if (next.timeStamp() < getCurrentTime()) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
 catch (    IllegalActionException e) {
      break;
    }
  }
}"
76316,"public PtolemyQuery(){
  this.addQueryListener(this);
  _parameters=new HashMap();
}","/** 
 * Construct a panel with no queries in it.
 */
public PtolemyQuery(){
  super();
  this.addQueryListener(this);
  _parameters=new HashMap();
}"
76317,"/** 
 * After invoking super.init(), create and connect the actors.
 */
public void init(){
  super.init();
  add(_createRunControls(2));
  try {
    AudioSource soundSource=new AudioSource(_toplevel,""String_Node_Str"");
    soundSource.pathName.setToken(new StringToken(""String_Node_Str""));
    soundSource.isURL.setToken(new BooleanToken(false));
    AudioSink soundSink=new AudioSink(_toplevel,""String_Node_Str"");
    soundSink.fileName.setToken(new StringToken(""String_Node_Str""));
    int sampleRate=8000;
    soundSink.sampRate.setToken(new IntToken(sampleRate));
    _toplevel.connect(soundSource.output,soundSink.input);
  }
 catch (  Exception ex) {
    report(""String_Node_Str"",ex);
  }
}","/** 
 * After invoking super.init(), create and connect the actors.
 */
public void init(){
  super.init();
  add(_createRunControls(2));
  try {
    AudioSource soundSource=new AudioSource(_toplevel,""String_Node_Str"");
    soundSource.pathName.setToken(new StringToken(""String_Node_Str""));
    soundSource.isURL.setToken(new BooleanToken(false));
    AudioSink soundSink=new AudioSink(_toplevel,""String_Node_Str"");
    soundSink.fileName.setToken(new StringToken(""String_Node_Str""));
    int sampleRate=44100;
    soundSink.sampRate.setToken(new IntToken(sampleRate));
    _toplevel.connect(soundSource.output,soundSink.input);
  }
 catch (  Exception ex) {
    report(""String_Node_Str"",ex);
  }
}"
76318,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public CodeBook(TypedCompositeActor container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  new Parameter(this,""String_Node_Str"",new IntToken(""String_Node_Str""));
  output=(TypedIOPort)newPort(""String_Node_Str"");
  output.setOutput(true);
  output.setTypeEquals(ObjectToken.class);
  input=(TypedIOPort)newPort(""String_Node_Str"");
  input.setInput(true);
  input.setTypeEquals(Token.class);
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public CodeBook(TypedCompositeActor container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  new Parameter(this,""String_Node_Str"",new IntToken(""String_Node_Str""));
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.setTypeEquals(Token.class);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(ObjectToken.class);
}"
76319,"/** 
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  _debug(""String_Node_Str"");
  HashMap map=new HashMap();
  Vector codeVector=new Vector();
  int counter=0;
  for (int i=0; i < size; i++) {
    Token object=(Token)(input.get(0));
    String key=object.stringValue();
    if (map.containsKey(key)) {
      int temp=((Integer)map.get(key)).intValue();
      temp=temp + 1;
      map.put(key,new Integer(temp));
    }
 else {
      map.put(key,new Integer(1));
      codeVector.add(key);
      counter=counter + 1;
    }
  }
  _debug(""String_Node_Str"" + counter);
  HuffTree[] huffArray=new HuffTree[counter];
  int currentSize=counter;
  for (int j=0; j < counter; j++) {
    Object leafObject=codeVector.elementAt(j);
    String key=codeVector.elementAt(j).toString();
    int count=((Integer)map.get(key)).intValue();
    huffArray[j]=new HuffLeaf(key,(double)count / size);
    _debug(""String_Node_Str"" + j);
    _debug(huffArray[j].toString());
  }
  while (currentSize > 1) {
    _debug(""String_Node_Str"" + currentSize);
    for (int c=0; c < currentSize; c++) {
      _debug(huffArray[c].toString());
    }
    double minimum1=1.0;
    int first=0;
    double minimum2=1.0;
    int second=0;
    for (int i=0; i < currentSize; i++) {
      double currentProb=huffArray[i].getProb();
      if (currentProb < minimum1) {
        minimum1=currentProb;
        first=i;
        _debug(""String_Node_Str"" + first);
      }
    }
    for (int j=0; j < currentSize; j++) {
      double currentProb=huffArray[j].getProb();
      if ((currentProb < minimum2) && (j != first)) {
        minimum2=currentProb;
        _debug(""String_Node_Str"" + second);
        second=j;
      }
    }
    _debug(""String_Node_Str"" + first);
    _debug(""String_Node_Str"" + second);
    HuffTree tree=new HuffTree();
    tree.addLeft(huffArray[first]);
    tree.addRight(huffArray[second]);
    huffArray[first]=tree;
    huffArray[second]=huffArray[currentSize - 1];
    currentSize--;
  }
  System.out.println(huffArray[0].printPreOrder());
  ObjectToken token=new ObjectToken(huffArray[0]);
  output.broadcast(token);
}","/** 
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  _debug(""String_Node_Str"");
  HashMap map=new HashMap();
  Vector codeVector=new Vector();
  int counter=0;
  for (int i=0; i < size; i++) {
    Token object=(Token)(input.get(0));
    String key=object.stringValue();
    if (map.containsKey(key)) {
      int temp=((Integer)map.get(key)).intValue();
      temp=temp + 1;
      map.put(key,new Integer(temp));
    }
 else {
      map.put(key,new Integer(1));
      codeVector.add(key);
      counter=counter + 1;
    }
  }
  _debug(""String_Node_Str"" + counter);
  HuffTree[] huffArray=new HuffTree[counter];
  int currentSize=counter;
  for (int j=0; j < counter; j++) {
    Object leafObject=codeVector.elementAt(j);
    String key=codeVector.elementAt(j).toString();
    int count=((Integer)map.get(key)).intValue();
    huffArray[j]=new HuffLeaf(key,(double)count / size);
    _debug(""String_Node_Str"" + j);
    _debug(huffArray[j].toString());
  }
  while (currentSize > 1) {
    _debug(""String_Node_Str"" + currentSize);
    for (int c=0; c < currentSize; c++) {
      _debug(huffArray[c].toString());
    }
    double minimum1=1.0;
    int first=0;
    double minimum2=1.0;
    int second=0;
    for (int i=0; i < currentSize; i++) {
      double currentProb=huffArray[i].getProb();
      if (currentProb < minimum1) {
        minimum1=currentProb;
        first=i;
        _debug(""String_Node_Str"" + first);
      }
    }
    for (int j=0; j < currentSize; j++) {
      double currentProb=huffArray[j].getProb();
      if ((currentProb < minimum2) && (j != first)) {
        minimum2=currentProb;
        _debug(""String_Node_Str"" + second);
        second=j;
      }
    }
    _debug(""String_Node_Str"" + first);
    _debug(""String_Node_Str"" + second);
    HuffTree tree=new HuffTree();
    tree.addLeft(huffArray[first]);
    tree.addRight(huffArray[second]);
    huffArray[first]=tree;
    huffArray[second]=huffArray[currentSize - 1];
    currentSize--;
  }
  System.out.println(huffArray[0].printPreOrder());
  ObjectToken token=new ObjectToken(huffArray[0]);
  output.send(0,token);
}"
76320,"/** 
 * Remove the count oldest objects from the queue and return them. If there is no such object in the queue (the queue is empty), throw an exception. If the history mechanism is enabled, then put the taken object in the history queue. If the capacity of the history queue would be exceeded by this, then first remove the oldest object in the history queue.
 * @return An array of objects from the queue.
 * @exception NoSuchElementException If the queue is empty.
 */
public void takeArray(Object obj[]) throws NoSuchElementException {
  int count=obj.length;
  if (size() < count) {
    String str=""String_Node_Str"";
    if (_container != null) {
      str=""String_Node_Str"" + _container.getFullName();
    }
    throw new NoSuchElementException(""String_Node_Str"" + str + ""String_Node_Str"");
  }
  if (count <= (_queuearray.length - _queueback)) {
    System.arraycopy(_queuearray,_queueback,obj,0,count);
  }
 else {
    System.arraycopy(_queuearray,_queueback,obj,0,_queuearray.length - _queueback);
    System.arraycopy(_queuearray,0,obj,_queuearray.length - _queueback,count - (_queuearray.length - _queueback));
  }
  _queueback+=count;
  if (_queueback >= _queuearray.length)   _queueback=_queueback % _queuearray.length;
  _queuesize-=count;
  if (_historycapacity != 0) {
    if (_historycapacity == _historylist.size()) {
      _historylist.take();
    }
    _historylist.insertLast(obj);
  }
}","/** 
 * Remove the count oldest objects from the queue and return them. If there is no such object in the queue (the queue is empty), throw an exception. If the history mechanism is enabled, then put the taken object in the history queue. If the capacity of the history queue would be exceeded by this, then first remove the oldest object in the history queue.
 * @return An array of objects from the queue.
 * @exception NoSuchElementException If the queue is empty.
 */
public void takeArray(Object obj[]) throws NoSuchElementException {
  int count=obj.length;
  if (size() < count) {
    String str=""String_Node_Str"";
    if (_container != null) {
      str=""String_Node_Str"" + _container.getFullName();
    }
    throw new NoSuchElementException(""String_Node_Str"" + str + ""String_Node_Str"");
  }
  if (count <= (_queueArray.length - _queueBack)) {
    System.arraycopy(_queueArray,_queueBack,obj,0,count);
  }
 else {
    System.arraycopy(_queueArray,_queueBack,obj,0,_queueArray.length - _queueBack);
    System.arraycopy(_queueArray,0,obj,_queueArray.length - _queueBack,count - (_queueArray.length - _queueBack));
  }
  _queueBack+=count;
  if (_queueBack >= _queueArray.length)   _queueBack=_queueBack % _queueArray.length;
  _queueSize-=count;
  if (_historyCapacity != 0) {
    if (_historyCapacity == _historyList.size()) {
      _historyList.removeFirst();
      ;
    }
    _historyList.addLast(obj);
  }
}"
76321,"/** 
 * Return the capacity of the history queue. This will be zero if the history mechanism is disabled and INFINITE_CAPACITY if the history capacity is infinite.
 * @return The capacity of the history queue.
 */
public int getHistoryCapacity(){
  return _historycapacity;
}","/** 
 * Return the capacity of the history queue. This will be zero if the history mechanism is disabled and INFINITE_CAPACITY if the history capacity is infinite.
 * @return The capacity of the history queue.
 */
public int getHistoryCapacity(){
  return _historyCapacity;
}"
76322,"/** 
 * Return true if the number of objects in the queue is zero
 * @return A boolean indicating whether the queue is empty.
 */
public boolean isEmpty(){
  return (_queuesize == 0);
}","/** 
 * Return true if the number of objects in the queue is zero
 * @return A boolean indicating whether the queue is empty.
 */
public boolean isEmpty(){
  return (_queueSize == 0);
}"
76323,"/** 
 * Enumerate the objects in the history, which are the N most recent objects taken from the queue, beginning with the oldest, where N is less than or equal to the history capacity. If the history capacity is infinite, then the enumeration includes all objects previously taken from the queue. If the history capacity is zero, then return an empty enumeration.
 * @return An enumeration of objects in the history.
 * @see collections.LinkedList#elements()
 */
public CollectionEnumeration historyElements(){
  return _historylist.elements();
}","/** 
 * Enumerate the objects in the history, which are the N most recent objects taken from the queue, beginning with the oldest, where N is less than or equal to the history capacity. If the history capacity is infinite, then the enumeration includes all objects previously taken from the queue. If the history capacity is zero, then return an empty enumeration.
 * @return An enumeration of objects in the history.
 * @see collections.LinkedList#elements()
 */
public Enumeration historyElements(){
  return Collections.enumeration(_historyList);
}"
76324,"/** 
 * Put an object in the queue and return true if this will not cause the capacity to be exceeded. Otherwise, do not put the object in the queue and return false.
 * @param element An object to be put in the queue.
 * @return A boolean indicating success.
 */
public boolean put(Object element){
  if (_queuearray.length - _queuesize >= 1) {
    _queuearray[_queuefront++]=element;
    if (_queuefront >= _queuearray.length)     _queuefront=_queuefront % _queuearray.length;
    _queuesize++;
    return true;
  }
 else {
    if (_queuemaxcapacity == INFINITE_CAPACITY) {
      _resizeArray(_queuearray.length * 2);
      return put(element);
    }
 else     return false;
  }
}","/** 
 * Put an object in the queue and return true if this will not cause the capacity to be exceeded. Otherwise, do not put the object in the queue and return false.
 * @param element An object to be put in the queue.
 * @return A boolean indicating success.
 */
public boolean put(Object element){
  if (_queueArray.length - _queueSize >= 1) {
    _queueArray[_queueFront++]=element;
    if (_queueFront >= _queueArray.length)     _queueFront=_queueFront % _queueArray.length;
    _queueSize++;
    return true;
  }
 else {
    if (_queueMaxCapacity == INFINITE_CAPACITY) {
      _resizeArray(_queueArray.length * 2);
      return put(element);
    }
 else     return false;
  }
}"
76325,"/** 
 * Return the number of objects in the history.
 * @return The current number of objects in the history.
 */
public int historySize(){
  return _historylist.size();
}","/** 
 * Return the number of objects in the history.
 * @return The current number of objects in the history.
 */
public int historySize(){
  return _historyList.size();
}"
76326,"/** 
 * Remove the oldest object from the queue and return it. If there is no such object in the queue (the queue is empty), throw an exception. If the history mechanism is enabled, then put the taken object in the history queue. If the capacity of the history queue would be exceeded by this, then first remove the oldest object in the history queue.
 * @return An object from the queue.
 * @exception NoSuchElementException If the queue is empty.
 */
public Object take() throws NoSuchElementException {
  Object obj=null;
  try {
    if (isEmpty())     throw new NoSuchElementException(""String_Node_Str"");
    obj=_queuearray[_queueback];
    _queuearray[_queueback]=null;
    _queueback++;
    if (_queueback >= _queuearray.length)     _queueback=_queueback % _queuearray.length;
    _queuesize--;
  }
 catch (  NoSuchElementException ex) {
    String str=""String_Node_Str"";
    if (_container != null) {
      str=""String_Node_Str"" + _container.getFullName();
    }
    throw new NoSuchElementException(""String_Node_Str"" + str + ""String_Node_Str"");
  }
  if (_historycapacity != 0) {
    if (_historycapacity == _historylist.size()) {
      _historylist.take();
    }
    _historylist.insertLast(obj);
  }
  return obj;
}","/** 
 * Remove the oldest object from the queue and return it. If there is no such object in the queue (the queue is empty), throw an exception. If the history mechanism is enabled, then put the taken object in the history queue. If the capacity of the history queue would be exceeded by this, then first remove the oldest object in the history queue.
 * @return An object from the queue.
 * @exception NoSuchElementException If the queue is empty.
 */
public Object take() throws NoSuchElementException {
  Object obj=null;
  try {
    if (isEmpty())     throw new NoSuchElementException(""String_Node_Str"");
    obj=_queueArray[_queueBack];
    _queueArray[_queueBack]=null;
    _queueBack++;
    if (_queueBack >= _queueArray.length)     _queueBack=_queueBack % _queueArray.length;
    _queueSize--;
  }
 catch (  NoSuchElementException ex) {
    String str=""String_Node_Str"";
    if (_container != null) {
      str=""String_Node_Str"" + _container.getFullName();
    }
    throw new NoSuchElementException(""String_Node_Str"" + str + ""String_Node_Str"");
  }
  if (_historyCapacity != 0) {
    if (_historyCapacity == _historyList.size()) {
      _historyList.removeFirst();
      ;
    }
    _historyList.addLast(obj);
  }
  return obj;
}"
76327,"/** 
 * Copy constructor. Create a copy of the specified queue, but with no container. This is useful to permit enumerations over a queue while the queue continues to be modified. The objects in the queue themselves are not cloned.
 * @param model The queue to be copied.
 */
public ArrayFIFOQueue(ArrayFIFOQueue model){
  this();
synchronized (model) {
    _queuesize=model._queuesize;
    _queuearray=new Object[model._queuearray.length];
    _queuefront=model._queuefront;
    _queueback=model._queueback;
    System.arraycopy(model._queuearray,0,_queuearray,0,_queuearray.length);
    _historylist.appendElements(model.historyElements());
  }
}","/** 
 * Copy constructor. Create a copy of the specified queue, but with no container. This is useful to permit enumerations over a queue while the queue continues to be modified. The objects in the queue themselves are not cloned.
 * @param model The queue to be copied.
 */
public ArrayFIFOQueue(ArrayFIFOQueue model){
  this();
synchronized (model) {
    _queueSize=model._queueSize;
    _queueArray=new Object[model._queueArray.length];
    _queueFront=model._queueFront;
    _queueBack=model._queueBack;
    System.arraycopy(model._queueArray,0,_queueArray,0,_queueArray.length);
    _historyList.addAll(model._historyList);
  }
}"
76328,"/** 
 * Put an array of objects in the queue and return true if this will not cause the capacity to be exceeded. Otherwise, do not put any of the object in the queue and return false.
 * @param element An array of objects to be put in the queue.
 * @return A boolean indicating success.
 */
public boolean putArray(Object element[]){
  if (_queuearray.length - _queuesize >= element.length) {
    int i;
    if (element.length <= (_queuearray.length - _queuefront)) {
      System.arraycopy(element,0,_queuearray,_queuefront,element.length);
      _queuefront+=element.length;
      if (_queuefront >= _queuearray.length)       _queuefront=_queuefront % _queuearray.length;
      _queuesize+=element.length;
    }
 else {
      System.arraycopy(element,0,_queuearray,_queuefront,_queuearray.length - _queuefront);
      System.arraycopy(element,_queuearray.length - _queuefront,_queuearray,0,element.length - (_queuearray.length - _queuefront));
      _queuefront+=element.length;
      if (_queuefront >= _queuearray.length)       _queuefront=_queuefront % _queuearray.length;
      _queuesize+=element.length;
    }
    return true;
  }
 else {
    if (_queuemaxcapacity == INFINITE_CAPACITY) {
      try {
        _resizeArray(_queuearray.length * 2);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      return putArray(element);
    }
 else     return false;
  }
}","/** 
 * Put an array of objects in the queue and return true if this will not cause the capacity to be exceeded. Otherwise, do not put any of the object in the queue and return false.
 * @param element An array of objects to be put in the queue.
 * @return A boolean indicating success.
 */
public boolean putArray(Object element[]){
  if (_queueArray.length - _queueSize >= element.length) {
    int i;
    if (element.length <= (_queueArray.length - _queueFront)) {
      System.arraycopy(element,0,_queueArray,_queueFront,element.length);
      _queueFront+=element.length;
      if (_queueFront >= _queueArray.length)       _queueFront=_queueFront % _queueArray.length;
      _queueSize+=element.length;
    }
 else {
      System.arraycopy(element,0,_queueArray,_queueFront,_queueArray.length - _queueFront);
      System.arraycopy(element,_queueArray.length - _queueFront,_queueArray,0,element.length - (_queueArray.length - _queueFront));
      _queueFront+=element.length;
      if (_queueFront >= _queueArray.length)       _queueFront=_queueFront % _queueArray.length;
      _queueSize+=element.length;
    }
    return true;
  }
 else {
    if (_queueMaxCapacity == INFINITE_CAPACITY) {
      try {
        _resizeArray(_queueArray.length * 2);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      return putArray(element);
    }
 else     return false;
  }
}"
76329,"/** 
 * Return the number of objects in the queue.
 * @return The number of objects in the queue.
 */
public int size(){
  return _queuesize;
}","/** 
 * Return the number of objects in the queue.
 * @return The number of objects in the queue.
 */
public int size(){
  return _queueSize;
}"
76330,"/** 
 * Resize the internal circular array to have the given size.
 * @exception InternalErrorException If the proposed size is greater thanthe declared maximum size, or if the queue contains more objects than the proposed size or the proposed size is illegal. .
 */
private void _resizeArray(int newsize){
  if (newsize < 0) {
    throw new InternalErrorException(""String_Node_Str"" + newsize + ""String_Node_Str"");
  }
  if (size() > newsize) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if ((_queuemaxcapacity != INFINITE_CAPACITY) && (newsize > _queuemaxcapacity)) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Object newarray[]=new Object[newsize];
  if ((_queuefront < _queueback) || isFull()) {
    System.arraycopy(_queuearray,_queueback,newarray,0,_queuearray.length - _queueback);
    System.arraycopy(_queuearray,0,newarray,_queuearray.length - _queueback,_queuefront);
    _queuefront=_queuearray.length - _queueback + _queuefront;
  }
 else {
    System.arraycopy(_queuearray,_queueback,newarray,0,_queuefront - _queueback);
    _queuefront=_queuefront - _queueback;
  }
  _queuearray=newarray;
  _queueback=0;
}","/** 
 * Resize the internal circular array to have the given size.
 * @exception InternalErrorException If the proposed size is greater thanthe declared maximum size, or if the queue contains more objects than the proposed size or the proposed size is illegal. .
 */
private void _resizeArray(int newsize){
  if (newsize < 0) {
    throw new InternalErrorException(""String_Node_Str"" + newsize + ""String_Node_Str"");
  }
  if (size() > newsize) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if ((_queueMaxCapacity != INFINITE_CAPACITY) && (newsize > _queueMaxCapacity)) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  Object newarray[]=new Object[newsize];
  if ((_queueFront < _queueBack) || isFull()) {
    System.arraycopy(_queueArray,_queueBack,newarray,0,_queueArray.length - _queueBack);
    System.arraycopy(_queueArray,0,newarray,_queueArray.length - _queueBack,_queueFront);
    _queueFront=_queueArray.length - _queueBack + _queueFront;
  }
 else {
    System.arraycopy(_queueArray,_queueBack,newarray,0,_queueFront - _queueBack);
    _queueFront=_queueFront - _queueBack;
  }
  _queueArray=newarray;
  _queueBack=0;
}"
76331,"/** 
 * Enumerate the objects in the queue, beginning with the oldest.
 * @return An enumeration of objects.
 * @see collections.LinkedList#elements()
 */
public CollectionEnumeration elements(){
  LinkedList l=new LinkedList();
  int i;
  if ((_queuefront < _queueback) || isFull()) {
    for (i=_queueback; (i < _queuearray.length); i++)     l.insertLast(_queuearray[i]);
    for (i=0; (i < _queuefront); i++)     l.insertLast(_queuearray[i]);
  }
 else   for (i=_queueback; (i < _queuefront); i++)   l.insertLast(_queuearray[i]);
  return l.elements();
}","/** 
 * Enumerate the objects in the queue, beginning with the oldest.
 * @return An enumeration of objects.
 * @see collections.LinkedList#elements()
 */
public Enumeration elements(){
  return Collections.enumeration(elementList());
}"
76332,"/** 
 * Return an object in the queue or history. The object is not removed from the queue or history. If the offset argument is zero, return the oldest object in the queue. If the offset is 1, return the second oldest object, etc. If there is no such object in the queue (the offset is greater than or equal to the current queue size), throw an exception. If the argument is -1, return the most recent object that was put in the history. If the argument is -2, return the second most recent object in the history, etc. If there is no such object in the history (the history capacity is zero or the absolute value of the offset is greater than the current size of the history queue), throw an exception.
 * @param offset The position of the desired object.
 * @return The desired object in the queue or history.
 * @exception NoSuchElementException If the offset is out of range.
 */
public Object get(int offset) throws NoSuchElementException {
  Object obj=null;
  if (offset >= 0) {
    if (offset >= size()) {
      String str=""String_Node_Str"";
      if (_container != null) {
        str=""String_Node_Str"" + _container.getFullName();
      }
      throw new NoSuchElementException(""String_Node_Str"" + offset + ""String_Node_Str""+ str);
    }
    int loc=_queueback + offset;
    if (loc >= _queuearray.length)     loc=loc % _queuearray.length;
    obj=_queuearray[loc];
  }
 else {
    try {
      obj=_historylist.at(historySize() + offset);
    }
 catch (    NoSuchElementException ex) {
      String str=""String_Node_Str"";
      if (_container != null) {
        str=""String_Node_Str"" + _container.getFullName();
      }
      throw new NoSuchElementException(""String_Node_Str"" + offset + ""String_Node_Str""+ str);
    }
  }
  return obj;
}","/** 
 * Return an object in the queue or history. The object is not removed from the queue or history. If the offset argument is zero, return the oldest object in the queue. If the offset is 1, return the second oldest object, etc. If there is no such object in the queue (the offset is greater than or equal to the current queue size), throw an exception. If the argument is -1, return the most recent object that was put in the history. If the argument is -2, return the second most recent object in the history, etc. If there is no such object in the history (the history capacity is zero or the absolute value of the offset is greater than the current size of the history queue), throw an exception.
 * @param offset The position of the desired object.
 * @return The desired object in the queue or history.
 * @exception NoSuchElementException If the offset is out of range.
 */
public Object get(int offset) throws NoSuchElementException {
  Object obj=null;
  if (offset >= 0) {
    if (offset >= size()) {
      String str=""String_Node_Str"";
      if (_container != null) {
        str=""String_Node_Str"" + _container.getFullName();
      }
      throw new NoSuchElementException(""String_Node_Str"" + offset + ""String_Node_Str""+ str);
    }
    int loc=_queueBack + offset;
    if (loc >= _queueArray.length)     loc=loc % _queueArray.length;
    obj=_queueArray[loc];
  }
 else {
    try {
      obj=_historyList.get(historySize() + offset);
    }
 catch (    Exception ex) {
      String str=""String_Node_Str"";
      if (_container != null) {
        str=""String_Node_Str"" + _container.getFullName();
      }
      throw new NoSuchElementException(""String_Node_Str"" + offset + ""String_Node_Str""+ str);
    }
  }
  return obj;
}"
76333,"/** 
 * Return true if the number of objects in the queue equals the queue capacity.
 * @return A boolean indicating whether the queue is full.
 */
public boolean isFull(){
  return (_queuesize >= _queuearray.length);
}","/** 
 * Return true if the number of objects in the queue equals the queue capacity.
 * @return A boolean indicating whether the queue is full.
 */
public boolean isFull(){
  return (_queueSize >= _queueArray.length);
}"
76334,"/** 
 * Set queue capacity. Use INFINITE_CAPACITY to indicate unbounded capacity (which is the default). If the current size of the queue exceeds the desired capacity, throw an exception.
 * @param capacity The desired capacity.
 * @exception IllegalActionException If the queue contains moreobjects than the proposed capacity or the proposed capacity is illegal.
 */
public void setCapacity(int capacity) throws IllegalActionException {
  if (capacity == INFINITE_CAPACITY) {
    _queuemaxcapacity=INFINITE_CAPACITY;
    return;
  }
  if (capacity < -1) {
    throw new IllegalActionException(_container,""String_Node_Str"");
  }
  if (size() > capacity) {
    throw new IllegalActionException(_container,""String_Node_Str"" + ""String_Node_Str"");
  }
  _queuemaxcapacity=capacity;
  _resizeArray(capacity);
}","/** 
 * Set queue capacity. Use INFINITE_CAPACITY to indicate unbounded capacity (which is the default). If the current size of the queue exceeds the desired capacity, throw an exception.
 * @param capacity The desired capacity.
 * @exception IllegalActionException If the queue contains moreobjects than the proposed capacity or the proposed capacity is illegal.
 */
public void setCapacity(int capacity) throws IllegalActionException {
  if (capacity == INFINITE_CAPACITY) {
    _queueMaxCapacity=INFINITE_CAPACITY;
    return;
  }
  if (capacity < -1) {
    throw new IllegalActionException(_container,""String_Node_Str"");
  }
  if (size() > capacity) {
    throw new IllegalActionException(_container,""String_Node_Str"" + ""String_Node_Str"");
  }
  _queueMaxCapacity=capacity;
  _resizeArray(capacity);
}"
76335,"/** 
 * Return the queue capacity This will INFINITE_CAPACITY if the capacity is infinite.
 * @return The capacity of the queue.
 */
public int getCapacity(){
  return _queuemaxcapacity;
}","/** 
 * Return the queue capacity This will be INFINITE_CAPACITY if the capacity is infinite.
 * @return The capacity of the queue.
 */
public int getCapacity(){
  return _queueMaxCapacity;
}"
76336,"/** 
 * Set the capacity of the history queue. Use 0 to disable the history mechanism and INFINITE_CAPACITY to make the history capacity unbounded. If the size of the history queue exceeds the desired capacity, remove the oldest objects from the history queue until its size equals the proposed capacity. Note that this can be used to clear the history queue by supplying 0 as the argument.
 * @param capacity The desired capacity of the history queue.
 * @exception IllegalActionException If the desired capacityis illegal.
 */
public void setHistoryCapacity(int capacity) throws IllegalActionException {
  if (capacity > 0) {
    while (_historylist.size() > capacity) {
      _historylist.take();
    }
  }
 else   if (capacity == 0) {
    _historylist.clear();
  }
 else   if (capacity != INFINITE_CAPACITY) {
    throw new IllegalActionException(_container,""String_Node_Str"" + capacity);
  }
  _historycapacity=capacity;
}","/** 
 * Set the capacity of the history queue. Use 0 to disable the history mechanism and INFINITE_CAPACITY to make the history capacity unbounded. If the size of the history queue exceeds the desired capacity, remove the oldest objects from the history queue until its size equals the proposed capacity. Note that this can be used to clear the history queue by supplying 0 as the argument.
 * @param capacity The desired capacity of the history queue.
 * @exception IllegalActionException If the desired capacityis illegal.
 */
public void setHistoryCapacity(int capacity) throws IllegalActionException {
  if (capacity > 0) {
    while (_historyList.size() > capacity) {
      _historyList.removeFirst();
      ;
    }
  }
 else   if (capacity == 0) {
    _historyList.clear();
  }
 else   if (capacity != INFINITE_CAPACITY) {
    throw new IllegalActionException(_container,""String_Node_Str"" + capacity);
  }
  _historyCapacity=capacity;
}"
76337,"/** 
 * Set the firing vector, which is a LLMap associating an Actor with the number of times that it will fire during an SDF iteration. Every object that this Scheduler is responsible for should have an entry, even if it is zero indicating that the Actor has not yet had its firings determined.
 * @param newfiringvector A LLMap from ComponentEntity to Integer.
 */
private void _setFiringVector(LLMap newfiringvector){
  _firingvector=newfiringvector;
  _firingvectorvalid=true;
}","/** 
 * Set the firing vector, which is a Map associating an Actor with the number of times that it will fire during an SDF iteration. Every object that this Scheduler is responsible for should have an entry, even if it is zero indicating that the Actor has not yet had its firings determined.
 * @param newfiringvector A Map from ComponentEntity to Integer.
 */
private void _setFiringVector(Map newfiringvector){
  _firingvector=newfiringvector;
  _firingvectorvalid=true;
}"
76338,"/** 
 * Propagate the number of fractional firing decided for this actor through the specified output port.   Set or verify the fractional firing for each Actor that is connected through this output port. Any actors that we calculate their firing vector for the first time are moved from remainingActors to pendingActors.
 * @param currentPort The port that we are propagating from.
 * @param firings The current LLMap of fractional firings for eachActor.
 * @param remainingActors The set of actors that have not had theirfractional firing set.
 * @param pendingActors The set of actors that have had their rateset, but have not been propagated onwards.
 * @exception NotSchedulableException If the CompositeActor is notschedulable.
 * @exception IllegalActionException If any called method throws it.
 */
private void _propagateOutputPort(IOPort currentPort,LLMap firings,CircularList remainingActors,CircularList pendingActors) throws NotSchedulableException, IllegalActionException {
  ComponentEntity currentActor=(ComponentEntity)currentPort.getContainer();
  Enumeration connectedOutPorts=currentPort.deepConnectedOutPorts();
  while (connectedOutPorts.hasMoreElements()) {
    IOPort connectedPort=(IOPort)connectedOutPorts.nextElement();
    if (!connectedPort.getContainer().equals(currentPort.getContainer().getContainer())) {
      throw new NotSchedulableException(currentPort,connectedPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  int currentRate=_getTokenProductionRate(currentPort);
  if (currentRate > 0) {
    Enumeration connectedPorts=currentPort.deepConnectedInPorts();
    while (connectedPorts.hasMoreElements()) {
      IOPort connectedPort=(IOPort)connectedPorts.nextElement();
      ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
      _debug(""String_Node_Str"" + connectedActor.getName());
      int connectedRate=_getTokenConsumptionRate(connectedPort);
      Fraction currentFiring=(Fraction)firings.at(currentActor);
      Fraction desiredFiring=currentFiring.multiply(new Fraction(currentRate,connectedRate));
      try {
        Fraction presentFiring=(Fraction)firings.at(connectedActor);
        if (presentFiring.equals(Fraction.ZERO)) {
          firings.putAt(connectedActor,desiredFiring);
          remainingActors.removeOneOf(connectedActor);
          pendingActors.insertLast(connectedActor);
        }
 else         if (!presentFiring.equals(desiredFiring))         throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
 catch (      NoSuchElementException e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ((ComponentEntity)connectedActor).getName() + ""String_Node_Str"");
      }
      remainingActors.removeOneOf(connectedActor);
    }
  }
}","/** 
 * Propagate the number of fractional firing decided for this actor through the specified output port.   Set or verify the fractional firing for each Actor that is connected through this output port. Any actors that we calculate their firing vector for the first time are moved from remainingActors to pendingActors.
 * @param currentPort The port that we are propagating from.
 * @param firings The current Map of fractional firings for eachActor.
 * @param remainingActors The set of actors that have not had theirfractional firing set.
 * @param pendingActors The set of actors that have had their rateset, but have not been propagated onwards.
 * @exception NotSchedulableException If the CompositeActor is notschedulable.
 * @exception IllegalActionException If any called method throws it.
 */
private void _propagateOutputPort(IOPort currentPort,Map firings,LinkedList remainingActors,LinkedList pendingActors) throws NotSchedulableException, IllegalActionException {
  ComponentEntity currentActor=(ComponentEntity)currentPort.getContainer();
  Enumeration connectedOutPorts=currentPort.deepConnectedOutPorts();
  while (connectedOutPorts.hasMoreElements()) {
    IOPort connectedPort=(IOPort)connectedOutPorts.nextElement();
    if (!connectedPort.getContainer().equals(currentPort.getContainer().getContainer())) {
      throw new NotSchedulableException(currentPort,connectedPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  int currentRate=_getTokenProductionRate(currentPort);
  if (currentRate > 0) {
    Enumeration connectedPorts=currentPort.deepConnectedInPorts();
    while (connectedPorts.hasMoreElements()) {
      IOPort connectedPort=(IOPort)connectedPorts.nextElement();
      ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
      _debug(""String_Node_Str"" + connectedActor.getName());
      int connectedRate=_getTokenConsumptionRate(connectedPort);
      Fraction currentFiring=(Fraction)firings.get(currentActor);
      Fraction desiredFiring=currentFiring.multiply(new Fraction(currentRate,connectedRate));
      try {
        Fraction presentFiring=(Fraction)firings.get(connectedActor);
        if (presentFiring.equals(Fraction.ZERO)) {
          firings.put(connectedActor,desiredFiring);
          remainingActors.remove(connectedActor);
          pendingActors.addLast(connectedActor);
        }
 else         if (!presentFiring.equals(desiredFiring))         throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
 catch (      NoSuchElementException e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ((ComponentEntity)connectedActor).getName() + ""String_Node_Str"");
      }
      _debug(""String_Node_Str"");
      _debug(firings.toString());
    }
  }
}"
76339,"/** 
 * Propagate the number of fractional firings decided for this actor through the specified input port.   Set and verify the fractional firing for each Actor that is connected through this input port. Any actors that we calculate their firing vector for the first time are moved from RemainingActors to pendingActors.
 * @param currentPort The port that we are propagating from.
 * @param firings The current LLMap of fractional firings for eachActor.
 * @param remainingActors The set of actors that have not had theirfractional firing set.
 * @param pendingActors The set of actors that have had their rateset, but have not been propagated onwards.
 * @exception NotSchedulableException If the CompositeActor is notschedulable.
 * @exception IllegalActionException If any called method throws it.
 */
private void _propagateInputPort(IOPort currentPort,LLMap firings,CircularList remainingActors,CircularList pendingActors) throws NotSchedulableException, IllegalActionException {
  ComponentEntity currentActor=(ComponentEntity)currentPort.getContainer();
  int currentRate=_getTokenConsumptionRate(currentPort);
  if (currentRate > 0) {
    Enumeration connectedPorts=currentPort.deepConnectedOutPorts();
    while (connectedPorts.hasMoreElements()) {
      IOPort connectedPort=(IOPort)connectedPorts.nextElement();
      ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
      _debug(""String_Node_Str"" + connectedActor.getName());
      int connectedRate=_getTokenProductionRate(connectedPort);
      Fraction currentFiring=(Fraction)firings.at(currentActor);
      Fraction desiredFiring=currentFiring.multiply(new Fraction(currentRate,connectedRate));
      try {
        Fraction presentFiring=(Fraction)firings.at(connectedActor);
        if (presentFiring.equals(Fraction.ZERO)) {
          firings.putAt(connectedActor,desiredFiring);
          remainingActors.removeOneOf(connectedActor);
          pendingActors.insertLast(connectedActor);
        }
 else         if (!presentFiring.equals(desiredFiring))         throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
 catch (      NoSuchElementException e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ((ComponentEntity)connectedActor).getName() + ""String_Node_Str"");
      }
      _debug(""String_Node_Str"");
      _debug(firings.toString());
    }
  }
}","/** 
 * Propagate the number of fractional firings decided for this actor through the specified input port.   Set and verify the fractional firing for each Actor that is connected through this input port. Any actors that we calculate their firing vector for the first time are moved from RemainingActors to pendingActors.
 * @param currentPort The port that we are propagating from.
 * @param firings The current Map of fractional firings for eachActor.
 * @param remainingActors The set of actors that have not had theirfractional firing set.
 * @param pendingActors The set of actors that have had their rateset, but have not been propagated onwards.
 * @exception NotSchedulableException If the CompositeActor is notschedulable.
 * @exception IllegalActionException If any called method throws it.
 */
private void _propagateInputPort(IOPort currentPort,Map firings,LinkedList remainingActors,LinkedList pendingActors) throws NotSchedulableException, IllegalActionException {
  ComponentEntity currentActor=(ComponentEntity)currentPort.getContainer();
  int currentRate=_getTokenConsumptionRate(currentPort);
  if (currentRate > 0) {
    Enumeration connectedPorts=currentPort.deepConnectedOutPorts();
    while (connectedPorts.hasMoreElements()) {
      IOPort connectedPort=(IOPort)connectedPorts.nextElement();
      ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
      _debug(""String_Node_Str"" + connectedActor.getName());
      int connectedRate=_getTokenProductionRate(connectedPort);
      Fraction currentFiring=(Fraction)firings.get(currentActor);
      Fraction desiredFiring=currentFiring.multiply(new Fraction(currentRate,connectedRate));
      try {
        Fraction presentFiring=(Fraction)firings.get(connectedActor);
        if (presentFiring.equals(Fraction.ZERO)) {
          firings.put(connectedActor,desiredFiring);
          remainingActors.remove(connectedActor);
          pendingActors.addLast(connectedActor);
        }
 else         if (!presentFiring.equals(desiredFiring))         throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
 catch (      NoSuchElementException e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ((ComponentEntity)connectedActor).getName() + ""String_Node_Str"");
      }
      _debug(""String_Node_Str"");
      _debug(firings.toString());
    }
  }
}"
76340,"/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense. FIXME: This method destroys the firing vector.  This is not nice.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A CircularList of the Actors in the order they should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
private CircularList _scheduleConnectedActors(CircularList actorList) throws NotSchedulableException {
  CircularList readyToScheduleActorList=new CircularList();
  CircularList newSchedule=new CircularList();
  LLMap waitingTokens=new LLMap();
  CircularList unscheduledActorList=new CircularList();
  unscheduledActorList.appendElements(actorList.elements());
  try {
    Enumeration schedulableEntities=actorList.elements();
    while (schedulableEntities.hasMoreElements()) {
      Actor a=(Actor)schedulableEntities.nextElement();
      Enumeration ainputports=a.inputPorts();
      while (ainputports.hasMoreElements()) {
        IOPort ainputport=(IOPort)ainputports.nextElement();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.putAt(ainputport,tokencount);
      }
    }
    schedulableEntities=actorList.elements();
    while (schedulableEntities.hasMoreElements()) {
      Actor a=(Actor)schedulableEntities.nextElement();
      Enumeration aoutputports=a.outputPorts();
      while (aoutputports.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aoutputports.nextElement();
        int count=_getTokenInitProduction(aOutputPort);
        _debug(""String_Node_Str"" + count + ""String_Node_Str""+ aOutputPort);
        if (count > 0) {
          _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
        }
      }
    }
    schedulableEntities=actorList.elements();
    while (schedulableEntities.hasMoreElements()) {
      Actor a=(Actor)schedulableEntities.nextElement();
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.insertFirst((ComponentEntity)a);
      _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
    }
    while (readyToScheduleActorList.size() > 0) {
      _debug(""String_Node_Str"");
      Enumeration ports=waitingTokens.keys();
      while (ports.hasMoreElements()) {
        IOPort port=(IOPort)ports.nextElement();
        _debug(""String_Node_Str"" + port.getFullName());
        int tokencount[]=(int[])waitingTokens.at(port);
        _debug(""String_Node_Str"" + tokencount.length);
        for (int channel=0; channel < tokencount.length; channel++)         _debug(""String_Node_Str"" + channel + ""String_Node_Str""+ tokencount[channel]+ ""String_Node_Str"");
      }
      _debug(""String_Node_Str"");
      Enumeration actorsLeft=readyToScheduleActorList.elements();
      while (actorsLeft.hasMoreElements()) {
        Entity e=(Entity)actorsLeft.nextElement();
        _debug(e.getFullName());
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.at(0);
      readyToScheduleActorList.exclude(currentActor);
      _debug(""String_Node_Str"" + currentActor.getName());
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.insertLast(currentActor);
      Enumeration aOutputPorts=((Actor)currentActor).outputPorts();
      while (aOutputPorts.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.nextElement();
        int count=_getTokenProductionRate(aOutputPort);
        _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=_getFiringCount(currentActor);
      firingsRemaining-=1;
      _setFiringCount(currentActor,firingsRemaining);
      _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          unscheduledActorList.exclude(currentActor);
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1)           readyToScheduleActorList.insertLast(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    _debug(""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    String s=new String(""String_Node_Str"");
    Enumeration actors=unscheduledActorList.elements();
    while (actors.hasMoreElements()) {
      Entity actor=(Entity)actors.nextElement();
      s+=actor.getFullName() + ""String_Node_Str"";
    }
    throw new NotSchedulableException(s);
  }
  Enumeration eschedule=newSchedule.elements();
  _debug(""String_Node_Str"");
  while (eschedule.hasMoreElements())   _debug(((ComponentEntity)eschedule.nextElement()).toString());
  return newSchedule;
}","/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A LinkedList of the Actors in the order they should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
private LinkedList _scheduleConnectedActors(LinkedList actorList) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  LinkedList newSchedule=new LinkedList();
  Map waitingTokens=new TreeMap(new NamedObjComparator());
  Map firingsRemainingVector=new TreeMap(new NamedObjComparator());
  firingsRemainingVector.putAll(_firingvector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Enumeration ainputports=a.inputPorts();
      while (ainputports.hasMoreElements()) {
        IOPort ainputport=(IOPort)ainputports.nextElement();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.put(ainputport,tokencount);
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Enumeration aoutputports=a.outputPorts();
      while (aoutputports.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aoutputports.nextElement();
        int count=_getTokenInitProduction(aOutputPort);
        _debug(""String_Node_Str"" + count + ""String_Node_Str""+ aOutputPort);
        if (count > 0) {
          _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
        }
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.addFirst((ComponentEntity)a);
      _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
    }
    while (readyToScheduleActorList.size() > 0) {
      _debug(""String_Node_Str"");
      Iterator ports=waitingTokens.keySet().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        _debug(""String_Node_Str"" + port.getFullName());
        int tokencount[]=(int[])waitingTokens.get(port);
        _debug(""String_Node_Str"" + tokencount.length);
        for (int channel=0; channel < tokencount.length; channel++)         _debug(""String_Node_Str"" + channel + ""String_Node_Str""+ tokencount[channel]+ ""String_Node_Str"");
      }
      _debug(""String_Node_Str"");
      Iterator actorsLeft=readyToScheduleActorList.iterator();
      while (actorsLeft.hasNext()) {
        Entity e=(Entity)actorsLeft.next();
        _debug(e.getFullName());
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor))       ;
      _debug(""String_Node_Str"" + currentActor.getName());
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.addLast(currentActor);
      Enumeration aOutputPorts=((Actor)currentActor).outputPorts();
      while (aOutputPorts.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.nextElement();
        int count=_getTokenProductionRate(aOutputPort);
        _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      firingsRemaining-=1;
      firingsRemainingVector.put(currentActor,new Integer(firingsRemaining));
      _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          while (unscheduledActorList.remove(currentActor))           ;
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1)           readyToScheduleActorList.addLast(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    _debug(""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    String s=new String(""String_Node_Str"");
    Iterator actors=unscheduledActorList.iterator();
    while (actors.hasNext()) {
      Entity actor=(Entity)actors.next();
      s+=actor.getFullName() + ""String_Node_Str"";
    }
    throw new NotSchedulableException(s);
  }
  Iterator eschedule=newSchedule.iterator();
  _debug(""String_Node_Str"");
  while (eschedule.hasNext())   _debug(((ComponentEntity)eschedule.next()).toString());
  return newSchedule;
}"
76341,"/** 
 * Set the number of firings associated with the Actor.   This is equivalent to changing the entry in the FiringVector associated with with the entity to have a value count.
 */
private void _setFiringCount(Entity entity,int count){
  _firingvector=(LLMap)_firingvector.puttingAt(entity,new Integer(count));
}","/** 
 * Set the number of firings associated with the Actor.   This is equivalent to changing the entry in the FiringVector associated with with the entity to have a value count.
 */
private void _setFiringCount(Entity entity,int count){
  _firingvector.put(entity,new Integer(count));
}"
76342,"/** 
 * Normalize fractional firing ratios into a firing vector that corresponds to a single SDF iteration.   Multiply all of the fractions by the GCD of their denominators.
 * @param Firings LLMap of firing ratios to be normalized
 * @return The normalized firing vector.
 * @exception InternalErrorException If the calculated GCD does notnormalize all of the fractions.
 */
private LLMap _normalizeFirings(LLMap firings){
  Enumeration unnormalizedFirings=firings.elements();
  int lcm=1;
  _debug(""String_Node_Str"");
  while (unnormalizedFirings.hasMoreElements()) {
    Fraction f=(Fraction)unnormalizedFirings.nextElement();
    int den=f.getDenominator();
    lcm=Fraction.lcm(lcm,den);
  }
  _debug(""String_Node_Str"" + (new Integer(lcm)).toString());
  Enumeration Actors=firings.keys();
  Fraction lcmFraction=new Fraction(lcm);
  while (Actors.hasMoreElements()) {
    Object actor=Actors.nextElement();
    _debug(""String_Node_Str"" + ((ComponentEntity)actor).getName());
    Fraction reps=(Fraction)firings.at(actor);
    reps=reps.multiply(lcmFraction);
    if (reps.getDenominator() != 1)     throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    firings=(LLMap)firings.puttingAt(actor,new Integer(reps.getNumerator()));
  }
  return firings;
}","/** 
 * Normalize fractional firing ratios into a firing vector that corresponds to a single SDF iteration.   Multiply all of the fractions by the GCD of their denominators.
 * @param Firings Map of firing ratios to be normalized
 * @exception InternalErrorException If the calculated GCD does notnormalize all of the fractions.
 */
private void _normalizeFirings(Map firings){
  Iterator unnormalizedFirings=firings.values().iterator();
  int lcm=1;
  _debug(""String_Node_Str"");
  while (unnormalizedFirings.hasNext()) {
    Fraction f=(Fraction)unnormalizedFirings.next();
    int den=f.getDenominator();
    lcm=Fraction.lcm(lcm,den);
  }
  _debug(""String_Node_Str"" + (new Integer(lcm)).toString());
  Iterator Actors=firings.keySet().iterator();
  Fraction lcmFraction=new Fraction(lcm);
  while (Actors.hasNext()) {
    Object actor=Actors.next();
    _debug(""String_Node_Str"" + ((ComponentEntity)actor).getName());
    Fraction reps=(Fraction)firings.get(actor);
    reps=reps.multiply(lcmFraction);
    if (reps.getDenominator() != 1)     throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    firings.put(actor,new Integer(reps.getNumerator()));
  }
}"
76343,"/** 
 * Initialize the local data members of this object.  
 */
protected void _localMemberInitialize(){
  LLMap _firingvector=new LLMap();
  _firingvectorvalid=true;
}","/** 
 * Initialize the local data members of this object.  
 */
protected void _localMemberInitialize(){
  _firingvector=new TreeMap(new NamedObjComparator());
  _firingvectorvalid=true;
}"
76344,"/** 
 * Return the number of firings associated with the Actor.   This is equivalent to indexing into the Map returned by _getFiringVector and casting the result to an integer.
 */
private int _getFiringCount(Entity entity){
  _debug(_firingvector.toString());
  return ((Integer)_firingvector.at(entity)).intValue();
}","/** 
 * Return the number of firings associated with the Actor.   This is equivalent to indexing into the Map returned by _getFiringVector and casting the result to an integer.
 */
private int _getFiringCount(Entity entity){
  return ((Integer)_firingvector.get(entity)).intValue();
}"
76345,"/** 
 * Solve the Balance Equations for the list of connected Actors. For each actor, determine the ratio that determines the rate at which it should fire relative to the other actors for the graph to be live and operate within bounded memory.   This ratio is known as the fractional firing of the actor.
 * @param Actors The actors that we are interested in.
 * @return A LLMap that associates each actor with its fractionalfiring.
 * @exception NotSchedulableException If the graph is not consistentunder the synchronous dataflow model.
 * @exception NotSchedulableException If the graph is not connected.
 * @exception IllegalActionException If any called method throws it.
 */
private LLMap _solveBalanceEquations(Enumeration Actors) throws NotSchedulableException, IllegalActionException {
  LLMap firings=new LLMap();
  CircularList remainingActors=new CircularList();
  CircularList pendingActors=new CircularList();
  boolean done=false;
  remainingActors.appendElements(Actors);
  Enumeration enumActors=remainingActors.elements();
  while (enumActors.hasMoreElements()) {
    ComponentEntity e=(ComponentEntity)enumActors.nextElement();
    firings.putAt(e,Fraction.ZERO);
  }
  try {
    Actor a=(Actor)remainingActors.take();
    firings.putAt(a,new Fraction(1));
    pendingActors.insertLast(a);
  }
 catch (  NoSuchElementException e) {
    return firings;
  }
  while (!done)   try {
    _debug(""String_Node_Str"");
    _debug(pendingActors.toString());
    Actor currentActor=(Actor)pendingActors.take();
    _debug(""String_Node_Str"" + ((ComponentEntity)currentActor).getName());
    Enumeration AllPorts=((ComponentEntity)currentActor).getPorts();
    while (AllPorts.hasMoreElements()) {
      IOPort currentPort=(IOPort)AllPorts.nextElement();
      if (currentPort.isInput())       _propagateInputPort(currentPort,firings,remainingActors,pendingActors);
      if (currentPort.isOutput())       _propagateOutputPort(currentPort,firings,remainingActors,pendingActors);
    }
  }
 catch (  NoSuchElementException e) {
    done=true;
    if (remainingActors.elements().hasMoreElements()) {
      String msg=""String_Node_Str"";
      Enumeration actors=remainingActors.elements();
      while (actors.hasMoreElements()) {
        NamedObj actor=(NamedObj)(actors.nextElement());
        msg+=actor.getFullName() + ""String_Node_Str"";
      }
      throw new NotSchedulableException(msg);
    }
  }
  return firings;
}","/** 
 * Solve the Balance Equations for the list of connected Actors. For each actor, determine the ratio that determines the rate at which it should fire relative to the other actors for the graph to be live and operate within bounded memory.   This ratio is known as the fractional firing of the actor.
 * @param Actors The actors that we are interested in.
 * @return A Map that associates each actor with its fractionalfiring.
 * @exception NotSchedulableException If the graph is not consistentunder the synchronous dataflow model.
 * @exception NotSchedulableException If the graph is not connected.
 * @exception IllegalActionException If any called method throws it.
 */
private Map _solveBalanceEquations(List Actors) throws NotSchedulableException, IllegalActionException {
  Map firings=new TreeMap(new NamedObjComparator());
  LinkedList remainingActors=new LinkedList();
  LinkedList pendingActors=new LinkedList();
  boolean done=false;
  remainingActors.addAll(Actors);
  Iterator enumActors=remainingActors.iterator();
  while (enumActors.hasNext()) {
    ComponentEntity e=(ComponentEntity)enumActors.next();
    firings.put(e,Fraction.ZERO);
  }
  try {
    Actor a=(Actor)remainingActors.removeFirst();
    firings.put(a,new Fraction(1));
    pendingActors.addLast(a);
  }
 catch (  NoSuchElementException e) {
    return firings;
  }
  while (!done)   try {
    _debug(""String_Node_Str"");
    _debug(pendingActors.toString());
    Actor currentActor=(Actor)pendingActors.removeFirst();
    _debug(""String_Node_Str"" + ((ComponentEntity)currentActor).getName());
    Enumeration AllPorts=((ComponentEntity)currentActor).getPorts();
    while (AllPorts.hasMoreElements()) {
      IOPort currentPort=(IOPort)AllPorts.nextElement();
      if (currentPort.isInput())       _propagateInputPort(currentPort,firings,remainingActors,pendingActors);
      if (currentPort.isOutput())       _propagateOutputPort(currentPort,firings,remainingActors,pendingActors);
    }
  }
 catch (  NoSuchElementException e) {
    done=true;
    Iterator actors=remainingActors.iterator();
    if (actors.hasNext()) {
      String msg=""String_Node_Str"";
      while (actors.hasNext()) {
        NamedObj actor=(NamedObj)(actors.next());
        msg+=actor.getFullName() + ""String_Node_Str"";
      }
      throw new NotSchedulableException(msg);
    }
  }
  return firings;
}"
76346,"/** 
 * Count the number of inputports in the Actor that must be fulfilled before the actor can fire.  Ports that are connected to actors that we are not scheduling right now are assumed to be fulfilled.  Ports that have more tokens waiting on each of their channels than their input consumption rate are also already fulfilled.  All other ports are considered to be unfulfilled.
 * @param a The actor
 * @param unscheduledactors The set of actors that we are scheduling.
 * @param waitingTokens The Map of tokens currently waiting on all theinput ports.
 * @return The number of unfulfilled inputs of a.
 * @exception IllegalActionException If any called method throws it.
 */
private int _countUnfulfilledInputs(Actor a,CircularList actorList,LLMap waitingTokens) throws IllegalActionException {
  Enumeration ainputPorts=a.inputPorts();
  _debug(""String_Node_Str"" + ((Entity)a).getFullName());
  int inputCount=0;
  while (ainputPorts.hasMoreElements()) {
    IOPort ainputPort=(IOPort)ainputPorts.nextElement();
    _debug(""String_Node_Str"" + ainputPort.getFullName());
    Enumeration cports=ainputPort.deepConnectedOutPorts();
    boolean isonlyexternalport=true;
    while (cports.hasMoreElements()) {
      IOPort cport=(IOPort)cports.nextElement();
      if (actorList.includes(cport.getContainer()))       isonlyexternalport=false;
    }
    int threshold=_getTokenConsumptionRate(ainputPort);
    _debug(""String_Node_Str"" + threshold);
    int[] tokens=(int[])waitingTokens.at(ainputPort);
    boolean isalreadyfulfilled=true;
    int channel;
    for (channel=0; channel < ainputPort.getWidth(); channel++) {
      _debug(""String_Node_Str"" + channel);
      _debug(""String_Node_Str"" + tokens[channel]);
      if (tokens[channel] < threshold)       isalreadyfulfilled=false;
    }
    if (!isonlyexternalport && !isalreadyfulfilled)     inputCount++;
  }
  return inputCount;
}","/** 
 * Count the number of inputports in the Actor that must be fulfilled before the actor can fire.  Ports that are connected to actors that we are not scheduling right now are assumed to be fulfilled.  Ports that have more tokens waiting on each of their channels than their input consumption rate are also already fulfilled.  All other ports are considered to be unfulfilled.
 * @param a The actor
 * @param unscheduledactors The set of actors that we are scheduling.
 * @param waitingTokens The Map of tokens currently waiting on all theinput ports.
 * @return The number of unfulfilled inputs of a.
 * @exception IllegalActionException If any called method throws it.
 */
private int _countUnfulfilledInputs(Actor a,LinkedList actorList,Map waitingTokens) throws IllegalActionException {
  _debug(""String_Node_Str"" + ((Entity)a).getFullName());
  Enumeration ainputPorts=a.inputPorts();
  int inputCount=0;
  while (ainputPorts.hasMoreElements()) {
    IOPort ainputPort=(IOPort)ainputPorts.nextElement();
    _debug(""String_Node_Str"" + ainputPort.getFullName());
    Enumeration cports=ainputPort.deepConnectedOutPorts();
    boolean isonlyexternalport=true;
    while (cports.hasMoreElements()) {
      IOPort cport=(IOPort)cports.nextElement();
      if (actorList.contains(cport.getContainer()))       isonlyexternalport=false;
    }
    int threshold=_getTokenConsumptionRate(ainputPort);
    _debug(""String_Node_Str"" + threshold);
    int[] tokens=(int[])waitingTokens.get(ainputPort);
    boolean isalreadyfulfilled=true;
    int channel;
    for (channel=0; channel < ainputPort.getWidth(); channel++) {
      _debug(""String_Node_Str"" + channel);
      _debug(""String_Node_Str"" + tokens[channel]);
      if (tokens[channel] < threshold)       isalreadyfulfilled=false;
    }
    if (!isonlyexternalport && !isalreadyfulfilled)     inputCount++;
  }
  return inputCount;
}"
76347,"/** 
 * Return the scheduling sequence.  An exception will be thrown if the graph is not schedulable.  This occurs in the following circumstances: <ul> <li>The graph is not a connected graph. <li>No integer solution exists for the balance equations. <li>The graph contains cycles without delays (deadlock). <li>Multiple output ports are connected to the same broadcast relation. (equivalent to a non-deterministic merge) </ul>
 * @return An Enumeration of the deeply contained opaque entitiesin the firing order.
 * @exception NotScheduleableException If the CompositeActor is notschedulable.
 */
protected Enumeration _schedule() throws NotSchedulableException {
  StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
  CompositeActor ca=(CompositeActor)(dir.getContainer());
  CircularList AllActors=new CircularList();
  Enumeration Entities=ca.deepGetEntities();
  while (Entities.hasMoreElements()) {
    ComponentEntity a=(ComponentEntity)Entities.nextElement();
    if (a instanceof CompositeActor) {
      _debug(""String_Node_Str"");
      Director containedDirector=((CompositeActor)a).getDirector();
      if (containedDirector instanceof StaticSchedulingDirector) {
        Scheduler containedScheduler=((StaticSchedulingDirector)containedDirector).getScheduler();
        try {
          containedScheduler.schedule();
        }
 catch (        IllegalActionException e) {
          throw new InternalErrorException(e.getMessage());
        }
      }
    }
    if (a instanceof Actor)     AllActors.insertLast(a);
  }
  LLMap firings=null;
  try {
    firings=_solveBalanceEquations(AllActors.elements());
  }
 catch (  IllegalActionException ex) {
    throw new NotSchedulableException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  firings=_normalizeFirings(firings);
  _setFiringVector(firings);
  _debug(""String_Node_Str"");
  _debug(firings.toString());
  CircularList result=_scheduleConnectedActors(AllActors);
  _setFiringVector(firings);
  _debug(""String_Node_Str"");
  _debug(firings.toString());
  try {
    _setContainerRates();
  }
 catch (  IllegalActionException ex) {
    throw new NotSchedulableException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  setValid(true);
  return result.elements();
}","/** 
 * Return the scheduling sequence.  An exception will be thrown if the graph is not schedulable.  This occurs in the following circumstances: <ul> <li>The graph is not a connected graph. <li>No integer solution exists for the balance equations. <li>The graph contains cycles without delays (deadlock). <li>Multiple output ports are connected to the same broadcast relation. (equivalent to a non-deterministic merge) </ul>
 * @return An Enumeration of the deeply contained opaque entitiesin the firing order.
 * @exception NotScheduleableException If the CompositeActor is notschedulable.
 */
protected Enumeration _schedule() throws NotSchedulableException {
  StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
  CompositeActor ca=(CompositeActor)(dir.getContainer());
  LinkedList AllActors=new LinkedList();
  Enumeration Entities=ca.deepGetEntities();
  while (Entities.hasMoreElements()) {
    ComponentEntity a=(ComponentEntity)Entities.nextElement();
    if (a instanceof CompositeActor) {
      _debug(""String_Node_Str"");
      Director containedDirector=((CompositeActor)a).getDirector();
      if (containedDirector instanceof StaticSchedulingDirector) {
        Scheduler containedScheduler=((StaticSchedulingDirector)containedDirector).getScheduler();
        try {
          containedScheduler.schedule();
        }
 catch (        IllegalActionException e) {
          throw new InternalErrorException(e.getMessage());
        }
      }
    }
    if (a instanceof Actor)     AllActors.addLast(a);
  }
  Map firings=null;
  try {
    firings=_solveBalanceEquations(AllActors);
  }
 catch (  IllegalActionException ex) {
    throw new NotSchedulableException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  _normalizeFirings(firings);
  _setFiringVector(firings);
  _debug(""String_Node_Str"");
  _debug(firings.toString());
  LinkedList result=_scheduleConnectedActors(AllActors);
  _setFiringVector(firings);
  _debug(""String_Node_Str"");
  _debug(firings.toString());
  try {
    _setContainerRates();
  }
 catch (  IllegalActionException ex) {
    throw new NotSchedulableException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  setValid(true);
  return Collections.enumeration(result);
}"
76348,"/** 
 * Return the firing vector, which is a LLMap associating an Actor with the number of times that it will fire during an SDF iteration. The firing vector is only guaranteed to be valid if the schedule is valid.
 * @return A LLMap from ComponentEntity to Integer.
 */
private LLMap _getFiringVector(){
  return _firingvector;
}","/** 
 * Return the firing vector, which is a Map associating an Actor with the number of times that it will fire during an SDF iteration. The firing vector is only guaranteed to be valid if the schedule is valid.
 * @return A Map from ComponentEntity to Integer.
 */
private Map _getFiringVector(){
  return _firingvector;
}"
76349,"/** 
 * Simulate the consumption of tokens by the actor during an execution. The entries in LLMap will be modified to reflect the number of tokens still waiting after the actor has consumed tokens for a firing. Also determine if enough tokens still remain at the inputs of the actor for it to fire again immediately.
 * @param currentActor The actor that is being simulated.
 * @param waitingTokens A Map between each input IOPort and the number oftokens in the queue for that port.
 * @return boolean Whether or not the actor can fire again right awayafter it has consumed tokens.
 * @exception IllegalActionException if any called method throws it.
 */
private boolean _simulateInputConsumption(ComponentEntity currentActor,LLMap waitingTokens) throws IllegalActionException {
  boolean stillReadyToSchedule=true;
  Enumeration inputPorts=((Actor)currentActor).inputPorts();
  while (inputPorts.hasMoreElements()) {
    IOPort inputPort=(IOPort)inputPorts.nextElement();
    int[] tokens=(int[])waitingTokens.at(inputPort);
    int tokenrate=_getTokenConsumptionRate(inputPort);
    for (int channel=0; channel < inputPort.getWidth(); channel++) {
      tokens[channel]-=tokenrate;
      if (tokens[channel] < tokenrate)       stillReadyToSchedule=false;
    }
  }
  return stillReadyToSchedule;
}","/** 
 * Simulate the consumption of tokens by the actor during an execution. The entries in Map will be modified to reflect the number of tokens still waiting after the actor has consumed tokens for a firing. Also determine if enough tokens still remain at the inputs of the actor for it to fire again immediately.
 * @param currentActor The actor that is being simulated.
 * @param waitingTokens A Map between each input IOPort and the number oftokens in the queue for that port.
 * @return boolean Whether or not the actor can fire again right awayafter it has consumed tokens.
 * @exception IllegalActionException if any called method throws it.
 */
private boolean _simulateInputConsumption(ComponentEntity currentActor,Map waitingTokens) throws IllegalActionException {
  boolean stillReadyToSchedule=true;
  Enumeration inputPorts=((Actor)currentActor).inputPorts();
  while (inputPorts.hasMoreElements()) {
    IOPort inputPort=(IOPort)inputPorts.nextElement();
    int[] tokens=(int[])waitingTokens.get(inputPort);
    int tokenrate=_getTokenConsumptionRate(inputPort);
    for (int channel=0; channel < inputPort.getWidth(); channel++) {
      tokens[channel]-=tokenrate;
      if (tokens[channel] < tokenrate)       stillReadyToSchedule=false;
    }
  }
  return stillReadyToSchedule;
}"
76350,"/** 
 * Simulate the creation of tokens by the given output port when its actor fires.  If any actors that receive tokens are then ready to fire, given that only actors in the actor list are being scheduled, then add those actors to the list of actors that are ready to schedule. update the waiting tokens map with the tokens available on each channel of each port.
 */
private void _simulateTokensCreated(IOPort outputPort,int createdTokens,CircularList actorList,CircularList readyToScheduleActorList,LLMap waitingTokens) throws IllegalActionException {
  _debug(""String_Node_Str"" + createdTokens + ""String_Node_Str""+ outputPort.getFullName());
  Receiver[][] creceivers=outputPort.getRemoteReceivers();
  _debug(""String_Node_Str"" + creceivers.length);
  int sourcechannel;
  for (sourcechannel=0; sourcechannel < creceivers.length; sourcechannel++) {
    _debug(""String_Node_Str"" + creceivers[sourcechannel].length);
    int destinationreceiver;
    for (destinationreceiver=0; destinationreceiver < creceivers[sourcechannel].length; destinationreceiver++) {
      IOPort connectedPort=(IOPort)creceivers[sourcechannel][destinationreceiver].getContainer();
      ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
      if (actorList.includes(connectedActor)) {
        int destinationchannel=_getChannel(connectedPort,creceivers[sourcechannel][destinationreceiver]);
        int[] tokens=(int[])waitingTokens.at(connectedPort);
        tokens[destinationchannel]+=createdTokens;
        _debug(""String_Node_Str"" + destinationchannel + ""String_Node_Str""+ connectedPort.getName());
        int ival=_countUnfulfilledInputs((Actor)connectedActor,actorList,waitingTokens);
        int firingsRemaining=_getFiringCount(connectedActor);
        if ((ival <= 0) && (firingsRemaining > 0)) {
          readyToScheduleActorList.insertLast(connectedActor);
        }
      }
    }
  }
}","/** 
 * Simulate the creation of tokens by the given output port when its actor fires.  If any actors that receive tokens are then ready to fire, given that only actors in the actor list are being scheduled, then add those actors to the list of actors that are ready to schedule. update the waiting tokens map with the tokens available on each channel of each port.
 */
private void _simulateTokensCreated(IOPort outputPort,int createdTokens,LinkedList actorList,LinkedList readyToScheduleActorList,Map waitingTokens) throws IllegalActionException {
  _debug(""String_Node_Str"" + createdTokens + ""String_Node_Str""+ outputPort.getFullName());
  Receiver[][] creceivers=outputPort.getRemoteReceivers();
  _debug(""String_Node_Str"" + creceivers.length);
  int sourcechannel;
  for (sourcechannel=0; sourcechannel < creceivers.length; sourcechannel++) {
    _debug(""String_Node_Str"" + creceivers[sourcechannel].length);
    int destinationreceiver;
    for (destinationreceiver=0; destinationreceiver < creceivers[sourcechannel].length; destinationreceiver++) {
      IOPort connectedPort=(IOPort)creceivers[sourcechannel][destinationreceiver].getContainer();
      ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
      if (actorList.contains(connectedActor)) {
        int destinationchannel=_getChannel(connectedPort,creceivers[sourcechannel][destinationreceiver]);
        int[] tokens=(int[])waitingTokens.get(connectedPort);
        tokens[destinationchannel]+=createdTokens;
        _debug(""String_Node_Str"" + destinationchannel + ""String_Node_Str""+ connectedPort.getName());
        int ival=_countUnfulfilledInputs((Actor)connectedActor,actorList,waitingTokens);
        int firingsRemaining=_getFiringCount(connectedActor);
        if ((ival <= 0) && (firingsRemaining > 0)) {
          readyToScheduleActorList.addLast(connectedActor);
        }
      }
    }
  }
}"
76351,"public void run(){
  int readWriteDataSizeInFrames=1024;
  TargetDataLine targetLine;
  int sampleSizeInBitsInt=16;
  int channels=1;
  int frameSizeInBits=sampleSizeInBitsInt;
  double frameRate=sampleRate;
  boolean signed=true;
  boolean bigEndian=true;
  AudioFormat format=new AudioFormat((float)sampleRate,sampleSizeInBitsInt,channels,signed,bigEndian);
  int frameSizeInBytes=format.getFrameSize();
  DataLine.Info targetInfo=new DataLine.Info(TargetDataLine.class,null,null,new Class[0],format,readWriteDataSizeInFrames * 4);
  if (!AudioSystem.isSupportedLine(targetInfo)) {
    shutDown(""String_Node_Str"" + targetInfo + ""String_Node_Str"");
    return;
  }
  try {
    targetLine=(TargetDataLine)AudioSystem.getLine(targetInfo);
    targetLine.open(format,targetLine.getBufferSize());
  }
 catch (  LineUnavailableException ex) {
    shutDown(""String_Node_Str"" + ex);
    return;
  }
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + targetLine.getBufferSize());
  int targetBufferLengthInBytes=readWriteDataSizeInFrames * frameSizeInBytes;
  byte[] targetData=new byte[targetBufferLengthInBytes];
  int numFramesRead;
  DataLine.Info sourceInfo=new DataLine.Info(SourceDataLine.class,null,null,new Class[0],format,readWriteDataSizeInFrames * 4);
  if (!AudioSystem.isSupportedLine(sourceInfo)) {
    shutDown(""String_Node_Str"" + sourceInfo + ""String_Node_Str"");
    return;
  }
  SourceDataLine sourceLine;
  try {
    sourceLine=(SourceDataLine)AudioSystem.getLine(sourceInfo);
    sourceLine.open(format,sourceLine.getBufferSize());
  }
 catch (  LineUnavailableException ex) {
    shutDown(""String_Node_Str"" + ex);
    return;
  }
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + sourceLine.getBufferSize());
  double[] audioInDoubleArray;
  byte[] audioOutByteArray;
  int numBytesRead=0;
  targetLine.start();
  sourceLine.start();
  if (thread == null) {
    System.out.println(""String_Node_Str"");
  }
  PitchDetector pd=new PitchDetector(readWriteDataSizeInFrames);
  PitchShift ps=new PitchShift();
  double[] psArray1=new double[readWriteDataSizeInFrames];
  double[] psArray2=new double[readWriteDataSizeInFrames];
  double[] currPitchArray;
  while (thread != null) {
    try {
      if ((numFramesRead=targetLine.read(targetData,0,readWriteDataSizeInFrames)) == -1) {
        break;
      }
      audioInDoubleArray=_byteArrayToDoubleArray(targetData,frameSizeInBytes);
      currPitchArray=pd.performPitchDetect(audioInDoubleArray,(int)sampleRate);
      audioInDoubleArray=ps.performPitchShift(audioInDoubleArray,(float)sampleRate,currPitchArray,pitchScaleIn1);
      audioOutByteArray=_doubleArrayToByteArray(audioInDoubleArray,frameSizeInBytes);
      int numFramesRemaining=numFramesRead;
      while (numFramesRemaining > 0) {
        numFramesRemaining-=sourceLine.write(audioOutByteArray,0,numFramesRemaining);
      }
    }
 catch (    Exception e) {
      shutDown(""String_Node_Str"" + e);
      break;
    }
  }
  if (thread != null) {
    sourceLine.drain();
  }
  sourceLine.stop();
  sourceLine.close();
  sourceLine=null;
  shutDown(null);
}","public void run(){
  int readWriteDataSizeInFrames=750;
  int jsBufferSizeOverReadWriteSize=8;
  TargetDataLine targetLine;
  int sampleSizeInBitsInt=16;
  int channels=1;
  int frameSizeInBits=sampleSizeInBitsInt;
  double frameRate=sampleRate;
  boolean signed=true;
  boolean bigEndian=true;
  AudioFormat format=new AudioFormat((float)sampleRate,sampleSizeInBitsInt,channels,signed,bigEndian);
  int frameSizeInBytes=format.getFrameSize();
  DataLine.Info targetInfo=new DataLine.Info(TargetDataLine.class,null,null,new Class[0],format,AudioSystem.NOT_SPECIFIED);
  if (!AudioSystem.isSupportedLine(targetInfo)) {
    shutDown(""String_Node_Str"" + targetInfo + ""String_Node_Str"");
    return;
  }
  try {
    targetLine=(TargetDataLine)AudioSystem.getLine(targetInfo);
    targetLine.open(format,readWriteDataSizeInFrames * jsBufferSizeOverReadWriteSize);
  }
 catch (  LineUnavailableException ex) {
    shutDown(""String_Node_Str"" + ex);
    return;
  }
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + targetLine.getBufferSize());
  int targetBufferLengthInBytes=readWriteDataSizeInFrames * frameSizeInBytes;
  byte[] targetData=new byte[targetBufferLengthInBytes];
  int numFramesRead;
  DataLine.Info sourceInfo=new DataLine.Info(SourceDataLine.class,null,null,new Class[0],format,AudioSystem.NOT_SPECIFIED);
  if (!AudioSystem.isSupportedLine(sourceInfo)) {
    shutDown(""String_Node_Str"" + sourceInfo + ""String_Node_Str"");
    return;
  }
  SourceDataLine sourceLine;
  try {
    sourceLine=(SourceDataLine)AudioSystem.getLine(sourceInfo);
    sourceLine.open(format,readWriteDataSizeInFrames * jsBufferSizeOverReadWriteSize);
  }
 catch (  LineUnavailableException ex) {
    shutDown(""String_Node_Str"" + ex);
    return;
  }
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + sourceLine.getBufferSize());
  double[] audioInDoubleArray;
  byte[] audioOutByteArray;
  int numBytesRead=0;
  targetLine.start();
  sourceLine.start();
  if (thread == null) {
    System.out.println(""String_Node_Str"");
  }
  PitchDetector pd=new PitchDetector(readWriteDataSizeInFrames);
  PitchShift ps=new PitchShift();
  double[] psArray1=new double[readWriteDataSizeInFrames];
  double[] psArray2=new double[readWriteDataSizeInFrames];
  double[] currPitchArray;
  while (thread != null) {
    try {
      if ((numFramesRead=targetLine.read(targetData,0,readWriteDataSizeInFrames)) == -1) {
        break;
      }
      audioInDoubleArray=_byteArrayToDoubleArray(targetData,frameSizeInBytes);
      currPitchArray=pd.performPitchDetect(audioInDoubleArray,(int)sampleRate);
      audioInDoubleArray=ps.performPitchShift(audioInDoubleArray,(float)sampleRate,currPitchArray,pitchScaleIn1);
      audioOutByteArray=_doubleArrayToByteArray(audioInDoubleArray,frameSizeInBytes);
      int numFramesRemaining=numFramesRead;
      while (numFramesRemaining > 0) {
        numFramesRemaining-=sourceLine.write(audioOutByteArray,0,numFramesRemaining);
      }
    }
 catch (    Exception e) {
      shutDown(""String_Node_Str"" + e);
      break;
    }
  }
  if (thread != null) {
    sourceLine.drain();
  }
  sourceLine.stop();
  sourceLine.close();
  sourceLine=null;
  shutDown(null);
}"
76352,"public void run(){
  int readWriteDataSizeInFrames=1024;
  TargetDataLine targetLine;
  int sampleSizeInBitsInt=16;
  int channels=1;
  int frameSizeInBits=sampleSizeInBitsInt;
  double frameRate=sampleRate;
  boolean signed=true;
  boolean bigEndian=true;
  AudioFormat format=new AudioFormat((float)sampleRate,sampleSizeInBitsInt,channels,signed,bigEndian);
  int frameSizeInBytes=format.getFrameSize();
  DataLine.Info targetInfo=new DataLine.Info(TargetDataLine.class,null,null,new Class[0],format,readWriteDataSizeInFrames * 4);
  if (!AudioSystem.isSupportedLine(targetInfo)) {
    shutDown(""String_Node_Str"" + targetInfo + ""String_Node_Str"");
    return;
  }
  try {
    targetLine=(TargetDataLine)AudioSystem.getLine(targetInfo);
    targetLine.open(format,targetLine.getBufferSize());
  }
 catch (  LineUnavailableException ex) {
    shutDown(""String_Node_Str"" + ex);
    return;
  }
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + targetLine.getBufferSize());
  int targetBufferLengthInBytes=readWriteDataSizeInFrames * frameSizeInBytes;
  byte[] targetData=new byte[targetBufferLengthInBytes];
  int numFramesRead;
  DataLine.Info sourceInfo=new DataLine.Info(SourceDataLine.class,null,null,new Class[0],format,readWriteDataSizeInFrames * 4);
  if (!AudioSystem.isSupportedLine(sourceInfo)) {
    shutDown(""String_Node_Str"" + sourceInfo + ""String_Node_Str"");
    return;
  }
  SourceDataLine sourceLine;
  try {
    sourceLine=(SourceDataLine)AudioSystem.getLine(sourceInfo);
    sourceLine.open(format,sourceLine.getBufferSize());
  }
 catch (  LineUnavailableException ex) {
    shutDown(""String_Node_Str"" + ex);
    return;
  }
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + sourceLine.getBufferSize());
  double[] audioInDoubleArray;
  byte[] audioOutByteArray;
  int numBytesRead=0;
  targetLine.start();
  sourceLine.start();
  if (thread == null) {
    System.out.println(""String_Node_Str"");
  }
  PitchDetector pd=new PitchDetector(readWriteDataSizeInFrames);
  PitchShift ps=new PitchShift();
  PitchShift ps2=new PitchShift();
  PitchShift ps3=new PitchShift();
  double[] psArray1=new double[readWriteDataSizeInFrames];
  double[] psArray2=new double[readWriteDataSizeInFrames];
  double[] psArray3=new double[readWriteDataSizeInFrames];
  double[] currPitchArray;
  while (thread != null) {
    try {
      if ((numFramesRead=targetLine.read(targetData,0,readWriteDataSizeInFrames)) == -1) {
        break;
      }
      audioInDoubleArray=_byteArrayToDoubleArray(targetData,frameSizeInBytes);
      currPitchArray=pd.performPitchDetect(audioInDoubleArray,(int)sampleRate);
      psArray1=ps.performPitchShift(audioInDoubleArray,(float)sampleRate,currPitchArray,pitchScaleIn1);
      psArray2=ps2.performPitchShift(audioInDoubleArray,(float)sampleRate,currPitchArray,pitchScaleIn2);
      psArray3=ps3.performPitchShift(audioInDoubleArray,(float)sampleRate,currPitchArray,pitchScaleIn3);
      for (int ind3=0; ind3 < audioInDoubleArray.length; ind3++) {
        audioInDoubleArray[ind3]=(psArray1[ind3] + psArray2[ind3] + psArray3[ind3]) * 0.35;
      }
      audioOutByteArray=_doubleArrayToByteArray(audioInDoubleArray,frameSizeInBytes);
      int numFramesRemaining=numFramesRead;
      while (numFramesRemaining > 0) {
        numFramesRemaining-=sourceLine.write(audioOutByteArray,0,numFramesRemaining);
      }
    }
 catch (    Exception e) {
      shutDown(""String_Node_Str"" + e);
      break;
    }
  }
  if (thread != null) {
    sourceLine.drain();
  }
  sourceLine.stop();
  sourceLine.close();
  sourceLine=null;
  shutDown(null);
}","public void run(){
  int readWriteDataSizeInFrames=750;
  int jsBufferSizeOverReadWriteSize=8;
  TargetDataLine targetLine;
  int sampleSizeInBitsInt=16;
  int channels=1;
  int frameSizeInBits=sampleSizeInBitsInt;
  double frameRate=sampleRate;
  boolean signed=true;
  boolean bigEndian=true;
  AudioFormat format=new AudioFormat((float)sampleRate,sampleSizeInBitsInt,channels,signed,bigEndian);
  int frameSizeInBytes=format.getFrameSize();
  DataLine.Info targetInfo=new DataLine.Info(TargetDataLine.class,null,null,new Class[0],format,AudioSystem.NOT_SPECIFIED);
  if (!AudioSystem.isSupportedLine(targetInfo)) {
    shutDown(""String_Node_Str"" + targetInfo + ""String_Node_Str"");
    return;
  }
  try {
    targetLine=(TargetDataLine)AudioSystem.getLine(targetInfo);
    targetLine.open(format,readWriteDataSizeInFrames * jsBufferSizeOverReadWriteSize);
  }
 catch (  LineUnavailableException ex) {
    shutDown(""String_Node_Str"" + ex);
    return;
  }
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + targetLine.getBufferSize());
  int targetBufferLengthInBytes=readWriteDataSizeInFrames * frameSizeInBytes;
  byte[] targetData=new byte[targetBufferLengthInBytes];
  int numFramesRead;
  DataLine.Info sourceInfo=new DataLine.Info(SourceDataLine.class,null,null,new Class[0],format,AudioSystem.NOT_SPECIFIED);
  if (!AudioSystem.isSupportedLine(sourceInfo)) {
    shutDown(""String_Node_Str"" + sourceInfo + ""String_Node_Str"");
    return;
  }
  SourceDataLine sourceLine;
  try {
    sourceLine=(SourceDataLine)AudioSystem.getLine(sourceInfo);
    sourceLine.open(format,readWriteDataSizeInFrames * jsBufferSizeOverReadWriteSize);
  }
 catch (  LineUnavailableException ex) {
    shutDown(""String_Node_Str"" + ex);
    return;
  }
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + sourceLine.getBufferSize());
  double[] audioInDoubleArray;
  byte[] audioOutByteArray;
  int numBytesRead=0;
  targetLine.start();
  sourceLine.start();
  if (thread == null) {
    System.out.println(""String_Node_Str"");
  }
  PitchDetector pd=new PitchDetector(readWriteDataSizeInFrames);
  PitchShift ps=new PitchShift();
  PitchShift ps2=new PitchShift();
  PitchShift ps3=new PitchShift();
  double[] psArray1=new double[readWriteDataSizeInFrames];
  double[] psArray2=new double[readWriteDataSizeInFrames];
  double[] psArray3=new double[readWriteDataSizeInFrames];
  double[] currPitchArray;
  while (thread != null) {
    try {
      if ((numFramesRead=targetLine.read(targetData,0,readWriteDataSizeInFrames)) == -1) {
        break;
      }
      audioInDoubleArray=_byteArrayToDoubleArray(targetData,frameSizeInBytes);
      currPitchArray=pd.performPitchDetect(audioInDoubleArray,(int)sampleRate);
      psArray1=ps.performPitchShift(audioInDoubleArray,(float)sampleRate,currPitchArray,pitchScaleIn1);
      psArray2=ps2.performPitchShift(audioInDoubleArray,(float)sampleRate,currPitchArray,pitchScaleIn2);
      psArray3=ps3.performPitchShift(audioInDoubleArray,(float)sampleRate,currPitchArray,pitchScaleIn3);
      for (int ind3=0; ind3 < audioInDoubleArray.length; ind3++) {
        audioInDoubleArray[ind3]=(psArray1[ind3] + psArray2[ind3] + psArray3[ind3]) * 0.35;
      }
      audioOutByteArray=_doubleArrayToByteArray(audioInDoubleArray,frameSizeInBytes);
      int numFramesRemaining=numFramesRead;
      while (numFramesRemaining > 0) {
        numFramesRemaining-=sourceLine.write(audioOutByteArray,0,numFramesRemaining);
      }
    }
 catch (    Exception e) {
      shutDown(""String_Node_Str"" + e);
      break;
    }
  }
  if (thread != null) {
    sourceLine.drain();
  }
  sourceLine.stop();
  sourceLine.close();
  sourceLine=null;
  shutDown(null);
}"
76353,"/** 
 * Put an event into the event queue with the specified destination receiver, transferred token, time stamp and depth. The depth is used to prioritize events that have equal time stamps.  A smaller depth corresponds to a higher priority.
 * @param receiver The destination receiver.
 * @param token The token destined for that receiver.
 * @param time The time stamp of the event.
 * @param depth The depth.
 * @exception IllegalActionException If the delay is negative.
 */
protected void _enqueueEvent(DEReceiver receiver,Token token,double time,long depth) throws IllegalActionException {
  Nameable destination=receiver.getContainer();
  if (time < getCurrentTime()) {
    throw new IllegalActionException(destination,""String_Node_Str"");
  }
  DEEventTag key=new DEEventTag(time,depth);
  DEEvent event=new DEEvent(receiver,token,key);
  _eventQueue.put(event);
  _debug(""String_Node_Str"",destination.getFullName(),""String_Node_Str"" + time,""String_Node_Str"" + depth);
}","/** 
 * Put an event into the event queue with the specified destination receiver, transferred token, time stamp and depth. The depth is used to prioritize events that have equal time stamps.  A smaller depth corresponds to a higher priority.
 * @param receiver The destination receiver.
 * @param token The token destined for that receiver.
 * @param time The time stamp of the event.
 * @param depth The depth.
 * @exception IllegalActionException If the delay is negative.
 */
protected void _enqueueEvent(DEReceiver receiver,Token token,double time,long depth) throws IllegalActionException {
  Nameable destination=receiver.getContainer();
  if (time < getCurrentTime()) {
    throw new IllegalActionException(destination,""String_Node_Str"");
  }
  DEEventTag key=new DEEventTag(time,depth);
  DEEvent event=new DEEvent(receiver,token,key);
  _eventQueue.put(event);
}"
76354,"private DirectedAcyclicGraph _constructDirectedGraph() throws IllegalActionException {
  LinkedList portList=new LinkedList();
  DirectedAcyclicGraph dag=new DirectedAcyclicGraph();
  CompositeActor container=((CompositeActor)getContainer());
  if (container == null)   return dag;
  Enumeration actors=container.deepGetEntities();
  while (actors.hasMoreElements()) {
    dag.add(actors.nextElement());
  }
  actors=container.deepGetEntities();
  while (actors.hasMoreElements()) {
    Actor actor=(Actor)actors.nextElement();
    Enumeration ports=actor.inputPorts();
    while (ports.hasMoreElements()) {
      IOPort inputPort=(IOPort)ports.nextElement();
      Set delayPorts=null;
      if (inputPort instanceof DEIOPort) {
        DEIOPort dePort=(DEIOPort)inputPort;
        delayPorts=dePort.getDelayToPorts();
      }
      Enumeration triggers=((Actor)inputPort.getContainer()).outputPorts();
      while (triggers.hasMoreElements()) {
        IOPort outPort=(IOPort)triggers.nextElement();
        if (delayPorts != null && delayPorts.contains(outPort)) {
          continue;
        }
        Enumeration inPortEnum=outPort.deepConnectedInPorts();
        while (inPortEnum.hasMoreElements()) {
          IOPort pp=(IOPort)inPortEnum.nextElement();
          Actor destination=(Actor)(pp.getContainer());
          if (destination.equals(actor)) {
            throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName());
          }
          if (dag.contains(destination)) {
            dag.addEdge(actor,destination);
          }
 else {
            throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName() + ""String_Node_Str""+ ((Nameable)destination).getFullName());
          }
        }
      }
    }
    if (!dag.isAcyclic()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName());
    }
  }
  return dag;
}","private DirectedAcyclicGraph _constructDirectedGraph() throws IllegalActionException {
  DirectedAcyclicGraph dag=new DirectedAcyclicGraph();
  CompositeActor container=((CompositeActor)getContainer());
  if (container == null)   return dag;
  Enumeration actors=container.deepGetEntities();
  while (actors.hasMoreElements()) {
    dag.add(actors.nextElement());
  }
  actors=container.deepGetEntities();
  while (actors.hasMoreElements()) {
    Actor actor=(Actor)actors.nextElement();
    Enumeration ports=actor.inputPorts();
    while (ports.hasMoreElements()) {
      IOPort inputPort=(IOPort)ports.nextElement();
      Set delayPorts=null;
      if (inputPort instanceof DEIOPort) {
        DEIOPort dePort=(DEIOPort)inputPort;
        delayPorts=dePort.getDelayToPorts();
      }
      Enumeration triggers=((Actor)inputPort.getContainer()).outputPorts();
      while (triggers.hasMoreElements()) {
        IOPort outPort=(IOPort)triggers.nextElement();
        if (delayPorts != null && delayPorts.contains(outPort)) {
          continue;
        }
        Enumeration inPortEnum=outPort.deepConnectedInPorts();
        while (inPortEnum.hasMoreElements()) {
          IOPort pp=(IOPort)inPortEnum.nextElement();
          Actor destination=(Actor)(pp.getContainer());
          if (destination.equals(actor)) {
            throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName());
          }
          if (dag.contains(destination)) {
            dag.addEdge(actor,destination);
          }
 else {
            throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName() + ""String_Node_Str""+ ((Nameable)destination).getFullName());
          }
        }
      }
    }
  }
  if (!dag.isAcyclic()) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  return dag;
}"
76355,"/** 
 * If the topological sort is not valid, then compute it.
 * @return True.
 * @exception IllegalActionException If the graph has a zerodelay loop.
 */
public boolean prefire() throws IllegalActionException {
  if (!_sortValid) {
    _computeDepth();
  }
  return super.prefire();
}","/** 
 * If the topological sort is not valid, then compute it.
 * @return True.
 * @exception IllegalActionException If the graph has a zerodelay loop.
 */
public boolean prefire() throws IllegalActionException {
  if (!_sortValid) {
    _computeDepth();
    _sortValid=true;
  }
  return super.prefire();
}"
76356,"/** 
 * Set current time to zero, calculate priorities for simultaneous events, and invoke the initialize() methods of all actors deeply contained by the container.  To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their initialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If there is a delay-free loop, orif the initialize() method of the container or one of the deeply contained actors throws it.
 */
public void initialize() throws IllegalActionException {
  _eventQueue.clear();
  _deadActors=null;
  _currentTime=0.0;
  _noMoreActorsToFire=false;
  _startTime=Double.MAX_VALUE;
  _isInitialized=false;
  super.initialize();
  _isInitialized=true;
  if (_isEmbedded() && !_eventQueue.isEmpty()) {
    _requestFiring();
  }
}","/** 
 * Set current time to zero, calculate priorities for simultaneous events, and invoke the initialize() methods of all actors deeply contained by the container.  To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their initialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If there is a delay-free loop, orif the initialize() method of the container or one of the deeply contained actors throws it.
 */
public void initialize() throws IllegalActionException {
  _eventQueue.clear();
  _deadActors=null;
  _currentTime=0.0;
  _noMoreActorsToFire=false;
  _pendingEvents=new LinkedList();
  _startTime=Double.MAX_VALUE;
  _isInitialized=false;
  super.initialize();
  _isInitialized=true;
  if (_isEmbedded() && !_eventQueue.isEmpty()) {
    _requestFiring();
  }
}"
76357,"private Actor _getActorToFire(){
  Actor actorToFire=null;
  DEEvent currentEvent=null;
  FIFOQueue eventsToPutBack=new FIFOQueue();
  double currentTime=getCurrentTime();
  long currentDepth=0;
  while (true) {
    if (_stopWhenQueueIsEmpty) {
      try {
        currentEvent=(DEEvent)_eventQueue.take();
      }
 catch (      IllegalActionException ex) {
        break;
      }
    }
 else {
      while (true) {
        try {
          currentEvent=(DEEvent)_eventQueue.take();
        }
 catch (        IllegalActionException ex) {
          _debug(""String_Node_Str"");
synchronized (_eventQueue) {
            try {
              _eventQueue.wait();
            }
 catch (            InterruptedException e) {
            }
          }
          continue;
        }
        break;
      }
    }
    if (actorToFire == null) {
      actorToFire=currentEvent.getDestinationActor();
      if (_deadActors != null && _deadActors.contains(actorToFire)) {
        _debug(""String_Node_Str"",((Entity)actorToFire).getName());
        continue;
      }
      currentTime=currentEvent.getEventTag().timeStamp();
      currentDepth=currentEvent.getEventTag().receiverDepth();
      try {
        setCurrentTime(currentTime);
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
      _debug(""String_Node_Str"" + currentTime);
      if (currentTime < _startTime) {
        _startTime=currentTime;
      }
      if (currentTime > getStopTime()) {
        _debug(""String_Node_Str"");
        return null;
      }
      DEReceiver rec=currentEvent.getDestinationReceiver();
      if (rec != null) {
        rec._triggerEvent(currentEvent.getTransferredToken());
      }
    }
 else {
      double eventTime=currentEvent.getEventTag().timeStamp();
      long eventDepth=currentEvent.getEventTag().receiverDepth();
      if (eventTime < currentTime) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (eventTime > currentTime || eventDepth > currentDepth) {
        eventsToPutBack.put(currentEvent);
        break;
      }
 else {
        if (currentEvent.getDestinationActor() == actorToFire) {
          DEReceiver rec=currentEvent.getDestinationReceiver();
          if (rec != null) {
            rec._triggerEvent(currentEvent.getTransferredToken());
          }
        }
 else {
          eventsToPutBack.put(currentEvent);
        }
      }
    }
  }
  _debug(""String_Node_Str"");
  while (eventsToPutBack.size() > 0) {
    DEEvent event=(DEEvent)eventsToPutBack.take();
    _eventQueue.put(event);
  }
  return actorToFire;
}","private Actor _getActorToFire(){
  Actor actorToFire=null;
  DEEvent currentEvent=null;
  double currentTime=getCurrentTime();
  long currentDepth=0;
  while (_pendingEvents.size() > 0) {
    currentEvent=(DEEvent)_pendingEvents.remove(0);
    actorToFire=currentEvent.getDestinationActor();
    if (_deadActors != null && _deadActors.contains(actorToFire)) {
      _debug(""String_Node_Str"",((Entity)actorToFire).getFullName());
      actorToFire=null;
      continue;
    }
    currentTime=currentEvent.getEventTag().timeStamp();
    currentDepth=currentEvent.getEventTag().receiverDepth();
    break;
  }
  while (true) {
    if (_stopWhenQueueIsEmpty) {
      try {
        currentEvent=(DEEvent)_eventQueue.take();
      }
 catch (      IllegalActionException ex) {
        break;
      }
    }
 else {
      while (_eventQueue.isEmpty()) {
        _debug(""String_Node_Str"");
synchronized (_eventQueue) {
          try {
            _eventQueue.wait();
          }
 catch (          InterruptedException e) {
          }
        }
      }
      try {
        currentEvent=(DEEvent)_eventQueue.take();
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
    }
    if (actorToFire == null) {
      actorToFire=currentEvent.getDestinationActor();
      if (_deadActors != null && _deadActors.contains(actorToFire)) {
        _debug(""String_Node_Str"",((Entity)actorToFire).getFullName());
        actorToFire=null;
        continue;
      }
      currentTime=currentEvent.getEventTag().timeStamp();
      currentDepth=currentEvent.getEventTag().receiverDepth();
      try {
        setCurrentTime(currentTime);
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
      _debug(""String_Node_Str"" + currentTime);
      if (currentTime < _startTime) {
        _startTime=currentTime;
      }
      if (currentTime > getStopTime()) {
        _debug(""String_Node_Str"");
        return null;
      }
      DEReceiver rec=currentEvent.getDestinationReceiver();
      if (rec != null) {
        rec._triggerEvent(currentEvent.getTransferredToken());
      }
    }
 else {
      double eventTime=currentEvent.getEventTag().timeStamp();
      long eventDepth=currentEvent.getEventTag().receiverDepth();
      if (eventTime < currentTime) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (eventTime > currentTime || eventDepth > currentDepth) {
        _eventQueue.put(currentEvent);
        break;
      }
 else {
        DEReceiver rec=currentEvent.getDestinationReceiver();
        if (rec != null) {
          rec._triggerEvent(currentEvent.getTransferredToken());
        }
        if (currentEvent.getDestinationActor() != actorToFire) {
          _pendingEvents.add(currentEvent);
        }
      }
    }
  }
  return actorToFire;
}"
76358,"private boolean _isEmbedded(){
  if (getContainer().getContainer() == null) {
    return false;
  }
 else {
    return true;
  }
}","private boolean _isEmbedded(){
  return (getContainer().getContainer() != null);
}"
76359,"/** 
 * Construct an empty queue with the specified comparator, which is used to sort the entries, the specified minimum number of buckets, and the specified bin count factor. The bin count factor multiplies or divides the number of bins when the number of bins is changed.  It defaults to 2 if the other constructor is used. The minimum number of buckets is also the initial number of buckets.  It too defaults to 2 if the other constructor is used.
 * @param comparator The comparator used to sort entries.
 * @param minNumBucket The minimum number of buckets.
 * @param resizeFactor The threshold factor.
 */
public CalendarQueue(CQComparator comparator,int minNumBucket,int resizeFactor){
  this(comparator);
  _minNumBucket=minNumBucket;
  _queueResizeFactor=resizeFactor;
}","/** 
 * Construct an empty queue with the specified comparator, which is used to sort the entries, the specified minimum number of buckets, and the specified bin count factor. The bin count factor multiplies or divides the number of bins when the number of bins is changed.  It defaults to 2 if the other constructor is used. The minimum number of buckets is also the initial number of buckets.  It too defaults to 2 if the other constructor is used.
 * @param comparator The comparator used to sort entries.
 * @param minNumBuckets The minimum number of buckets.
 * @param resizeFactor The threshold factor.
 */
public CalendarQueue(CQComparator comparator,int minNumBuckets,int resizeFactor){
  this(comparator);
  _minNumBuckets=minNumBuckets;
  _queueResizeFactor=resizeFactor;
}"
76360,"/** 
 * Add an entry to the queue. An entry is given as an instance of CQEntry. This method always returns true.  A derived class, however, may return false if the entry is already on the queue and is not added again.  In this class, the entry is always added, even if an identical entry already exists on the queue.
 * @param key The key of the entry to be added to the queue.
 * @param value The value of the entry to be added to the queue.
 * @return True.
 * @exception IllegalArgumentException If the key is null.
 */
public synchronized boolean put(CQEntry cqEntry){
  if (cqEntry.key == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (_zeroRef == null) {
    _zeroRef=cqEntry.key;
    _qSize=0;
    _localInit(_minNumBucket,_cqComparator.getBinWidth(null),cqEntry.key);
  }
  long i=_getBinIndex(cqEntry.key);
  i=i % _nBuckets;
  if (i < 0)   i+=_nBuckets;
  if (_minKey == null || _cqComparator.compare(cqEntry.key,_minKey) < 0) {
    _minKey=cqEntry.key;
    _minVirtualBucket=_getBinIndex(_minKey);
    _minBucket=(int)(_minVirtualBucket % _nBuckets);
    if (_minBucket < 0)     _minBucket+=_nBuckets;
  }
  _bucket[(int)i].insert(cqEntry);
  ++_qSize;
  if (_qSize > _topThreshold) {
    _resize(_nBuckets * _queueResizeFactor);
  }
  notifyAll();
  return true;
}","/** 
 * Add an entry to the queue. An entry is given as an instance of CQEntry. This method always returns true.  A derived class, however, may return false if the entry is already on the queue and is not added again.  In this class, the entry is always added, even if an identical entry already exists on the queue.
 * @param key The key of the entry to be added to the queue.
 * @param value The value of the entry to be added to the queue.
 * @return True.
 * @exception IllegalArgumentException If the key is null.
 */
public synchronized boolean put(CQEntry cqEntry){
  if (cqEntry.key == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (_debugging)   _debug(""String_Node_Str"" + cqEntry.value + ""String_Node_Str""+ cqEntry.key);
  if (_zeroRef == null) {
    _zeroRef=cqEntry.key;
    _qSize=0;
    _localInit(_minNumBuckets,_cqComparator.getBinWidth(null),cqEntry.key);
    _sampleValid=false;
    _previousTakenKey=null;
  }
  long i=_getBinIndex(cqEntry.key);
  i=i % _nBuckets;
  if (i < 0)   i+=_nBuckets;
  if (_minKey == null || _cqComparator.compare(cqEntry.key,_minKey) < 0) {
    _minKey=cqEntry.key;
    _minVirtualBucket=_getBinIndex(_minKey);
    _minBucket=(int)(_minVirtualBucket % _nBuckets);
    if (_minBucket < 0)     _minBucket+=_nBuckets;
  }
  _bucket[(int)i].insert(cqEntry);
  ++_qSize;
  if (_qSize > _topThreshold)   _qSizeOverThreshold++;
  if (_qSizeOverThreshold > _RESIZE_LAG) {
    _resize(_nBuckets * _queueResizeFactor);
  }
  notifyAll();
  return true;
}"
76361,"private void _resize(int newsize){
  if (!_resizeEnabled)   return;
  Object new_width=_computeNewWidth();
  CQLinkedList[] old_bucket=_bucket;
  int old_nbuckets=_nBuckets;
  _localInit(newsize,new_width,_minKey);
  _qSize=0;
  _resizeEnabled=false;
  for (int i=0; i < old_nbuckets; i++) {
    while (!old_bucket[i].isEmpty()) {
      CQEntry entry=(CQEntry)old_bucket[i].take();
      put(entry);
    }
  }
  _resizeEnabled=true;
}","private void _resize(int newsize){
  if (!_resizeEnabled)   return;
  if (_debugging)   _debug(""String_Node_Str"" + newsize);
  Object new_width=_width;
  if (_sampleValid) {
    new_width=_cqComparator.getBinWidth(_sampleKeys);
    if (_debugging)     _debug(""String_Node_Str"" + new_width);
  }
  CQLinkedList[] old_bucket=_bucket;
  int old_nbuckets=_nBuckets;
  _localInit(newsize,new_width,_minKey);
  _qSize=0;
  boolean saveDebugging=_debugging;
  _debugging=false;
  _resizeEnabled=false;
  for (int i=0; i < old_nbuckets; i++) {
    while (!old_bucket[i].isEmpty()) {
      CQEntry entry=(CQEntry)old_bucket[i].take();
      put(entry);
    }
  }
  _debugging=saveDebugging;
  _resizeEnabled=true;
}"
76362,"/** 
 * Return the keys and values currently in the queue as a pair of arrays, but no more of them than the number given as an argument.  The return value is an array of arrays, where the 0 element is an array of keys and the 1 element is an array of values.  Each array has length equal to the argument or to the size of the queue, whichever is smaller. To get all the entries in the queue, call this method with argument Integer.MAX_VALUE.
 * @param limit The maximum number of keys and values desired.
 * @return The keys and values currently in the queue.
 */
public synchronized final Object[][] toArray(int limit){
  if (limit > _qSize)   limit=_qSize;
  Object[][] result=new Object[2][limit];
  int index=0;
  int currentBucket=_minBucket;
  long virtualBucket=_minVirtualBucket;
  long minimumNextVirtualBucket=Long.MAX_VALUE;
  int indexOfMinimum=currentBucket;
  int nextStartBucket=_minBucket;
  Object minKeySoFar=null;
  CQCell[] bucketHead=new CQCell[_bucket.length];
  for (int i=0; i < _bucket.length; i++) {
    bucketHead[i]=_bucket[i].head;
  }
  while (true) {
    if (bucketHead[currentBucket] != null) {
      Object nextKeyInBucket=bucketHead[currentBucket].contents.key;
      while (_getBinIndex(nextKeyInBucket) == virtualBucket) {
        result[0][index]=nextKeyInBucket;
        result[1][index]=bucketHead[currentBucket].contents.value;
        index++;
        if (index == limit)         return result;
        bucketHead[currentBucket]=bucketHead[currentBucket].next;
        if (bucketHead[currentBucket] == null)         break;
        nextKeyInBucket=bucketHead[currentBucket].contents.key;
      }
      long nextVirtualBucket=_getBinIndex(nextKeyInBucket);
      if (nextVirtualBucket < minimumNextVirtualBucket) {
        minimumNextVirtualBucket=nextVirtualBucket;
        nextStartBucket=currentBucket;
      }
    }
    ++currentBucket;
    ++virtualBucket;
    if (currentBucket == _nBuckets)     currentBucket=0;
    if (currentBucket == nextStartBucket) {
      if (minimumNextVirtualBucket == Long.MAX_VALUE) {
        throw new InternalErrorException(""String_Node_Str"");
      }
      virtualBucket=minimumNextVirtualBucket;
      minimumNextVirtualBucket=Long.MAX_VALUE;
    }
  }
}","/** 
 * Return the keys and values currently in the queue as a pair of arrays, but no more of them than the number given as an argument.  The return value is an array of arrays, where the 0 element is an array of keys and the 1 element is an array of values.  Each array has length equal to the argument or to the size of the queue, whichever is smaller. To get all the entries in the queue, call this method with argument Integer.MAX_VALUE.
 * @param limit The maximum number of keys and values desired.
 * @return The keys and values currently in the queue.
 */
public synchronized final Object[][] toArray(int limit){
  if (limit > _qSize)   limit=_qSize;
  Object[][] result=new Object[2][limit];
  if (_qSize == 0)   return result;
  int index=0;
  int currentBucket=_minBucket;
  long virtualBucket=_minVirtualBucket;
  long minimumNextVirtualBucket=Long.MAX_VALUE;
  int indexOfMinimum=currentBucket;
  int nextStartBucket=_minBucket;
  Object minKeySoFar=null;
  CQCell[] bucketHead=new CQCell[_bucket.length];
  for (int i=0; i < _bucket.length; i++) {
    bucketHead[i]=_bucket[i].head;
  }
  while (true) {
    if (bucketHead[currentBucket] != null) {
      Object nextKeyInBucket=bucketHead[currentBucket].contents.key;
      while (_getBinIndex(nextKeyInBucket) == virtualBucket) {
        result[0][index]=nextKeyInBucket;
        result[1][index]=bucketHead[currentBucket].contents.value;
        index++;
        if (index == limit)         return result;
        bucketHead[currentBucket]=bucketHead[currentBucket].next;
        if (bucketHead[currentBucket] == null)         break;
        nextKeyInBucket=bucketHead[currentBucket].contents.key;
      }
      long nextVirtualBucket=_getBinIndex(nextKeyInBucket);
      if (nextVirtualBucket < minimumNextVirtualBucket) {
        minimumNextVirtualBucket=nextVirtualBucket;
        nextStartBucket=currentBucket;
      }
    }
    ++currentBucket;
    ++virtualBucket;
    if (currentBucket == _nBuckets)     currentBucket=0;
    if (currentBucket == nextStartBucket) {
      if (minimumNextVirtualBucket == Long.MAX_VALUE) {
        throw new InternalErrorException(""String_Node_Str"" + _qSize);
      }
      virtualBucket=minimumNextVirtualBucket;
      minimumNextVirtualBucket=Long.MAX_VALUE;
    }
  }
}"
76363,"private Object _takeFromBucket(int index){
  CQEntry minEntry=(CQEntry)_bucket[index].take();
  _minBucket=index;
  _minKey=minEntry.key;
  _minVirtualBucket=_getBinIndex(_minKey);
  --_qSize;
  if (_qSize == 0)   _minKey=null;
  if (_qSize < _bottomThreshold) {
    if (_nBuckets / _queueResizeFactor > _minNumBucket) {
      _resize(_nBuckets / _queueResizeFactor);
    }
  }
  _takenKey=minEntry.key;
  return minEntry.value;
}","private Object _takeFromBucket(int index){
  CQEntry minEntry=(CQEntry)_bucket[index].take();
  _minBucket=index;
  _minKey=minEntry.key;
  _minVirtualBucket=_getBinIndex(_minKey);
  --_qSize;
  if (_qSize == 0)   _minKey=null;
  if (_qSize < _bottomThreshold)   _qSizeUnderThreshold++;
  if (_qSizeUnderThreshold > _RESIZE_LAG) {
    if (_nBuckets / _queueResizeFactor > _minNumBuckets) {
      _resize(_nBuckets / _queueResizeFactor);
    }
  }
  _takenKey=minEntry.key;
  return minEntry.value;
}"
76364,"private void _localInit(int nbuckets,Object bwidth,Object startKey){
  _width=bwidth;
  _nBuckets=nbuckets;
  _bucket=new CQLinkedList[_nBuckets];
  for (int i=0; i < _nBuckets; ++i) {
    _bucket[i]=new CQLinkedList();
  }
  _minKey=startKey;
  _minVirtualBucket=_getBinIndex(startKey);
  _minBucket=(int)(_minVirtualBucket % _nBuckets);
  if (_minBucket < 0)   _minBucket+=_nBuckets;
  _bottomThreshold=_nBuckets / _queueResizeFactor;
  _topThreshold=_nBuckets * _queueResizeFactor;
}","private void _localInit(int nbuckets,Object bwidth,Object startKey){
  _width=bwidth;
  _nBuckets=nbuckets;
  _bucket=new CQLinkedList[_nBuckets];
  for (int i=0; i < _nBuckets; ++i) {
    _bucket[i]=new CQLinkedList();
  }
  _minKey=startKey;
  _minVirtualBucket=_getBinIndex(startKey);
  _minBucket=(int)(_minVirtualBucket % _nBuckets);
  if (_minBucket < 0)   _minBucket+=_nBuckets;
  _bottomThreshold=_nBuckets / _queueResizeFactor;
  _topThreshold=_nBuckets * _queueResizeFactor;
  _qSizeOverThreshold=_qSizeUnderThreshold=0;
}"
76365,"/** 
 * Remove ignored tokens from this receiver. If the receiver time of this receiver is equal to TimedQueueReceiver.IGNORE, then take the oldest token off of the queue. If after doing so no other tokens are on the queue, then set the receiver time of this receiver to be equal to the current time of the time keeper controlling this receiver.
 * @see ptolemy.domains.dde.kernel.TimedQueueReceiver
 */
public synchronized void clearIgnoredTokens(){
  if (getRcvrTime() != TimedQueueReceiver.IGNORE) {
    return;
  }
  super.get();
  if ((getRcvrTime() == TimedQueueReceiver.IGNORE) && !super.hasToken()) {
    Thread thread=Thread.currentThread();
    DDEThread ddeThread;
    if (thread instanceof DDEThread) {
      ddeThread=(DDEThread)thread;
      TimeKeeper keeper=ddeThread.getTimeKeeper();
      setRcvrTime(keeper.getCurrentTime());
    }
  }
}","/** 
 * Remove ignored tokens from this receiver. If the receiver time of this receiver is equal to TimedQueueReceiver.IGNORE, then take the oldest token off of the queue. If after doing so no other tokens are on the queue, then set the receiver time of this receiver to be equal to the current time of the time keeper controlling this receiver.
 * @see ptolemy.domains.dde.kernel.TimedQueueReceiver
 */
public synchronized void clearIgnoredTokens(){
  if (getRcvrTime() != TimedQueueReceiver.IGNORE) {
    return;
  }
  String actorName=((Nameable)getContainer().getContainer()).getName();
  if (actorName.equals(""String_Node_Str"")) {
  }
  super.get();
  if ((getRcvrTime() == TimedQueueReceiver.IGNORE) && !super.hasToken()) {
    Thread thread=Thread.currentThread();
    DDEThread ddeThread;
    if (thread instanceof DDEThread) {
      ddeThread=(DDEThread)thread;
      TimeKeeper keeper=ddeThread.getTimeKeeper();
      if (actorName.equals(""String_Node_Str"")) {
        double time=keeper.getCurrentTime();
      }
      setRcvrTime(keeper.getCurrentTime());
    }
  }
}"
76366,"/** 
 * Do a blocking write on the queue. If at any point during this method this receiver is scheduled for termination, then throw a TerminateProcessException which will cease activity for the actor that contains this receiver. If the specified time stamp of the token is greater than the completionTime of this receiver, then set the time stamp to INACTIVE. If the queue is full, then inform the director that this receiver is blocking on a write and wait until room becomes available. When room becomes available, put the token and time stamp in the queue and inform the director that the block no longer exists.
 * @param token The token to put on the queue.
 * @param time The time stamp associated with the token.
 */
public void put(Token token,double time){
  IOPort port=(IOPort)getContainer();
  String portName=((Nameable)port).getName();
  if (portName.equals(""String_Node_Str"")) {
    System.out.println(portName + ""String_Node_Str"" + time);
  }
  Workspace workspace=getContainer().workspace();
  DDEDirector director=null;
  if (isOutsideBoundary()) {
    director=(DDEDirector)((Actor)getContainer().getContainer()).getExecutiveDirector();
  }
 else {
    director=(DDEDirector)((Actor)getContainer().getContainer()).getDirector();
  }
  _put(token,time,workspace,director);
}","/** 
 * Do a blocking write on the queue. If at any point during this method this receiver is scheduled for termination, then throw a TerminateProcessException which will cease activity for the actor that contains this receiver. If the specified time stamp of the token is greater than the completionTime of this receiver, then set the time stamp to INACTIVE. If the queue is full, then inform the director that this receiver is blocking on a write and wait until room becomes available. When room becomes available, put the token and time stamp in the queue and inform the director that the block no longer exists.
 * @param token The token to put on the queue.
 * @param time The time stamp associated with the token.
 */
public void put(Token token,double time){
  IOPort port=(IOPort)getContainer();
  String portName=((Nameable)port).getName();
  String actorName=((Nameable)port.getContainer()).getName();
  boolean realToken=false;
  boolean nullToken=false;
  if (token instanceof NullToken) {
    nullToken=true;
  }
 else {
    realToken=true;
  }
  Thread thread=Thread.currentThread();
  if (thread instanceof DDEThread) {
    String callingActor=((Nameable)((DDEThread)thread).getActor()).getName();
    if (realToken) {
      System.out.println(""String_Node_Str"" + portName + ""String_Node_Str""+ actorName+ ""String_Node_Str""+ time+ ""String_Node_Str""+ callingActor+ ""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"" + portName + ""String_Node_Str""+ actorName+ ""String_Node_Str""+ time+ ""String_Node_Str""+ callingActor+ ""String_Node_Str"");
    }
  }
  Workspace workspace=getContainer().workspace();
  DDEDirector director=null;
  if (isOutsideBoundary()) {
    director=(DDEDirector)((Actor)getContainer().getContainer()).getExecutiveDirector();
  }
 else {
    director=(DDEDirector)((Actor)getContainer().getContainer()).getDirector();
  }
  _put(token,time,workspace,director);
}"
76367,"/** 
 * This method provides the recursive functionality of  hasToken() for general receivers.
 */
private synchronized boolean _hasOutsideToken(Workspace workspace,DDEDirector director,TimeKeeper timeKeeper,boolean _hideNullTokens){
  timeKeeper.resortRcvrList();
  if (timeKeeper.getNextTime() == INACTIVE) {
    requestFinish();
  }
  if (getRcvrTime() == INACTIVE && !_terminate) {
    return false;
  }
  if (getRcvrTime() == IGNORE && !_terminate) {
    if (_ignoreNotSeen) {
      IOPort port=(IOPort)getContainer();
      Director insideDir=((Actor)port.getContainer()).getDirector();
      if (insideDir instanceof DDEDirector) {
        Receiver[][] rcvrs=null;
        try {
          rcvrs=port.deepGetReceivers();
        }
 catch (        IllegalActionException e) {
        }
        for (int i=0; i < rcvrs.length; i++) {
          for (int j=0; j < rcvrs[i].length; j++) {
            DDEReceiver rcvr=(DDEReceiver)rcvrs[i][j];
            rcvr.put(new Token(),TimedQueueReceiver.IGNORE);
          }
        }
      }
      _ignoreNotSeen=false;
      return false;
    }
 else {
      _ignoreNotSeen=true;
      clearIgnoredTokens();
      timeKeeper.setIgnoredTokens(false);
      return false;
    }
  }
  if (getRcvrTime() > timeKeeper.getNextTime() && !_terminate) {
    return false;
  }
  if (super.hasToken() && !_terminate) {
    if (!timeKeeper.hasMinRcvrTime()) {
      if (hasNullToken()) {
        if (timeKeeper.getHighestPriorityReal() != null) {
          return false;
        }
 else         if (this != timeKeeper.getHighestPriorityNull()) {
          return false;
        }
 else         if (!_hideNullTokens) {
          return true;
        }
 else {
          super.get();
          timeKeeper.sendOutNullTokens(this);
          return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
        }
      }
 else {
        return true;
      }
    }
 else {
      if (hasNullToken()) {
        if (!_hideNullTokens) {
          return true;
        }
        super.get();
        timeKeeper.sendOutNullTokens(this);
        return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
      }
      return true;
    }
  }
  if (!super.hasToken() && !_terminate) {
    _readPending=true;
    if (isConnectedToBoundary()) {
      director.addExternalReadBlock();
    }
 else {
      director.addInternalReadBlock();
    }
    while (_readPending && !_terminate) {
      workspace.wait(this);
    }
  }
  if (_terminate) {
    if (_readPending) {
      _readPending=false;
      if (isConnectedToBoundary()) {
        director.removeExternalReadBlock();
      }
 else {
        director.removeInternalReadBlock();
      }
    }
    throw new TerminateProcessException(""String_Node_Str"");
  }
 else {
    return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
  }
}","/** 
 * This method provides the recursive functionality of  hasToken() for general receivers.
 */
private synchronized boolean _hasOutsideToken(Workspace workspace,DDEDirector director,TimeKeeper timeKeeper,boolean _hideNullTokens){
  String actorName=((Nameable)getContainer().getContainer()).getName();
  String portName=((Nameable)getContainer()).getName();
  timeKeeper.resortRcvrList();
  if (timeKeeper.getNextTime() == INACTIVE) {
    requestFinish();
  }
  if (getRcvrTime() == INACTIVE && !_terminate) {
    return false;
  }
  if (getRcvrTime() == IGNORE && !_terminate) {
    if (actorName.equals(""String_Node_Str"")) {
      System.out.println(actorName + ""String_Node_Str"");
    }
    IOPort port=(IOPort)getContainer();
    Director insideDir=((Actor)port.getContainer()).getDirector();
    if (insideDir instanceof DDEDirector) {
      Receiver[][] rcvrs=null;
      try {
        rcvrs=port.deepGetReceivers();
      }
 catch (      IllegalActionException e) {
      }
      for (int i=0; i < rcvrs.length; i++) {
        for (int j=0; j < rcvrs[i].length; j++) {
          DDEReceiver rcvr=(DDEReceiver)rcvrs[i][j];
          rcvr.put(new Token(),TimedQueueReceiver.IGNORE);
        }
      }
    }
    return false;
  }
  if (getRcvrTime() > timeKeeper.getNextTime() && !_terminate) {
    return false;
  }
  if (super.hasToken() && !_terminate) {
    if (!timeKeeper.hasMinRcvrTime()) {
      if (hasNullToken()) {
        if (timeKeeper.getHighestPriorityReal() != null) {
          return false;
        }
 else         if (this != timeKeeper.getHighestPriorityNull()) {
          return false;
        }
 else         if (!_hideNullTokens) {
          return true;
        }
 else {
          super.get();
          timeKeeper.sendOutNullTokens(this);
          return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
        }
      }
 else {
        if (this == timeKeeper.getHighestPriorityReal()) {
          return true;
        }
        return false;
      }
    }
 else {
      if (hasNullToken()) {
        if (!_hideNullTokens) {
          return true;
        }
        super.get();
        timeKeeper.sendOutNullTokens(this);
        return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
      }
      return true;
    }
  }
  if (!super.hasToken() && !_terminate) {
    _readPending=true;
    if (isConnectedToBoundary()) {
      director.addExternalReadBlock();
    }
 else {
      director.addInternalReadBlock();
    }
    while (_readPending && !_terminate) {
      workspace.wait(this);
    }
  }
  if (_terminate) {
    if (_readPending) {
      _readPending=false;
      if (isConnectedToBoundary()) {
        director.removeExternalReadBlock();
      }
 else {
        director.removeInternalReadBlock();
      }
    }
    throw new TerminateProcessException(""String_Node_Str"");
  }
 else {
    return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
  }
}"
76368,"/** 
 * This method provides the recursive functionality of  hasToken() for general receivers.
 */
private synchronized boolean _hasToken(Workspace workspace,DDEDirector director,TimeKeeper timeKeeper,boolean _hideNullTokens){
  timeKeeper.resortRcvrList();
  if (timeKeeper.getNextTime() == INACTIVE) {
    requestFinish();
  }
  if (getRcvrTime() == INACTIVE && !_terminate) {
    return false;
  }
  if (getRcvrTime() == IGNORE && !_terminate) {
    if (_ignoreNotSeen) {
      _ignoreNotSeen=false;
      return false;
    }
 else {
      _ignoreNotSeen=true;
      clearIgnoredTokens();
      timeKeeper.setIgnoredTokens(false);
      return false;
    }
  }
  if (getRcvrTime() > timeKeeper.getNextTime() && !_terminate) {
    return false;
  }
  if (super.hasToken() && !_terminate) {
    if (!timeKeeper.hasMinRcvrTime()) {
      if (hasNullToken()) {
        if (timeKeeper.getHighestPriorityReal() != null) {
          return false;
        }
 else         if (this != timeKeeper.getHighestPriorityNull()) {
          return false;
        }
 else         if (!_hideNullTokens) {
          return true;
        }
 else {
          super.get();
          timeKeeper.sendOutNullTokens(this);
          return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
        }
      }
 else {
        return true;
      }
    }
 else {
      if (hasNullToken()) {
        if (!_hideNullTokens) {
          return true;
        }
        super.get();
        timeKeeper.sendOutNullTokens(this);
        return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
      }
      return true;
    }
  }
  if (!super.hasToken() && !_terminate) {
    _readPending=true;
    if (isConnectedToBoundary()) {
      director.addExternalReadBlock();
    }
 else {
      director.addInternalReadBlock();
    }
    while (_readPending && !_terminate) {
      workspace.wait(this);
    }
  }
  if (_terminate) {
    if (_readPending) {
      _readPending=false;
      if (isConnectedToBoundary()) {
        director.removeExternalReadBlock();
      }
 else {
        director.removeInternalReadBlock();
      }
    }
    throw new TerminateProcessException(""String_Node_Str"");
  }
 else {
    return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
  }
}","/** 
 * This method provides the recursive functionality of  hasToken() for general receivers.
 */
private synchronized boolean _hasToken(Workspace workspace,DDEDirector director,TimeKeeper timeKeeper,boolean _hideNullTokens){
  String actorName=((Nameable)getContainer().getContainer()).getName();
  String portName=((Nameable)getContainer()).getName();
  if (actorName.equals(""String_Node_Str"")) {
  }
  timeKeeper.resortRcvrList();
  if (timeKeeper.getNextTime() == INACTIVE) {
    requestFinish();
  }
  if (getRcvrTime() == INACTIVE && !_terminate) {
    return false;
  }
  if (getRcvrTime() == IGNORE && !_terminate) {
    if (actorName.equals(""String_Node_Str"")) {
      System.out.println(actorName + ""String_Node_Str"");
    }
    if (_ignoreNotSeen) {
      _ignoreNotSeen=false;
      return false;
    }
 else {
      _ignoreNotSeen=true;
      clearIgnoredTokens();
      timeKeeper.setIgnoredTokens(false);
      return false;
    }
  }
  if (getRcvrTime() > timeKeeper.getNextTime() && !_terminate) {
    return false;
  }
  if (super.hasToken() && !_terminate) {
    if (!timeKeeper.hasMinRcvrTime()) {
      if (hasNullToken()) {
        if (timeKeeper.getHighestPriorityReal() != null) {
          return false;
        }
 else         if (this != timeKeeper.getHighestPriorityNull()) {
          return false;
        }
 else         if (!_hideNullTokens) {
          return true;
        }
 else {
          super.get();
          timeKeeper.sendOutNullTokens(this);
          return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
        }
      }
 else {
        if (this == timeKeeper.getHighestPriorityReal()) {
          return true;
        }
        return false;
      }
    }
 else {
      if (hasNullToken()) {
        if (!_hideNullTokens) {
          return true;
        }
        super.get();
        timeKeeper.sendOutNullTokens(this);
        return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
      }
      return true;
    }
  }
  if (!super.hasToken() && !_terminate) {
    _readPending=true;
    if (isConnectedToBoundary()) {
      director.addExternalReadBlock();
    }
 else {
      director.addInternalReadBlock();
    }
    while (_readPending && !_terminate) {
      workspace.wait(this);
    }
  }
  if (_terminate) {
    if (_readPending) {
      _readPending=false;
      if (isConnectedToBoundary()) {
        director.removeExternalReadBlock();
      }
 else {
        director.removeInternalReadBlock();
      }
    }
    throw new TerminateProcessException(""String_Node_Str"");
  }
 else {
    return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
  }
}"
76369,"/** 
 * This method provides the recursive functionality of  hasToken() for general receivers.
 */
private synchronized boolean _hasInsideToken(Workspace workspace,DDEDirector director,TimeKeeper timeKeeper){
  if (getRcvrTime() == INACTIVE && !_terminate) {
    return false;
  }
  if (getRcvrTime() == IGNORE && !_terminate) {
    if (_ignoreNotSeen) {
      IOPort port=(IOPort)getContainer();
      Director outsideDir=((Actor)port.getContainer()).getExecutiveDirector();
      if (outsideDir instanceof DDEDirector) {
        Receiver[][] rcvrs=null;
        rcvrs=port.getRemoteReceivers();
        for (int i=0; i < rcvrs.length; i++) {
          for (int j=0; j < rcvrs[i].length; j++) {
            DDEReceiver rcvr=(DDEReceiver)rcvrs[i][j];
            rcvr.put(new Token(),TimedQueueReceiver.IGNORE);
          }
        }
      }
      _ignoreNotSeen=false;
      return false;
    }
 else {
      _ignoreNotSeen=true;
      clearIgnoredTokens();
      timeKeeper.setIgnoredTokens(false);
      return false;
    }
  }
  if (super.hasToken() && !_terminate) {
    if (hasNullToken()) {
      get();
      return _hasInsideToken(workspace,director,timeKeeper);
    }
    return true;
  }
  if (_terminate) {
    if (_readPending) {
      _readPending=false;
      director.removeInternalReadBlock();
    }
    throw new TerminateProcessException(""String_Node_Str"");
  }
  return false;
}","/** 
 * This method provides the recursive functionality of  hasToken() for general receivers.
 */
private synchronized boolean _hasInsideToken(Workspace workspace,DDEDirector director,TimeKeeper timeKeeper){
  String actorName=((Nameable)getContainer().getContainer()).getName();
  String portName=((Nameable)getContainer()).getName();
  if (getRcvrTime() == INACTIVE && !_terminate) {
    return false;
  }
  if (getRcvrTime() == IGNORE && !_terminate) {
    if (_ignoreNotSeen) {
      IOPort port=(IOPort)getContainer();
      Director outsideDir=((Actor)port.getContainer()).getExecutiveDirector();
      if (outsideDir instanceof DDEDirector) {
        Receiver[][] rcvrs=null;
        rcvrs=port.getRemoteReceivers();
        for (int i=0; i < rcvrs.length; i++) {
          for (int j=0; j < rcvrs[i].length; j++) {
            DDEReceiver rcvr=(DDEReceiver)rcvrs[i][j];
            rcvr.put(new Token(),TimedQueueReceiver.IGNORE);
          }
        }
      }
      _ignoreNotSeen=false;
      return false;
    }
 else {
      _ignoreNotSeen=true;
      clearIgnoredTokens();
      timeKeeper.setIgnoredTokens(false);
      return false;
    }
  }
  if (super.hasToken() && !_terminate) {
    if (hasNullToken()) {
      get();
      return _hasInsideToken(workspace,director,timeKeeper);
    }
    return true;
  }
  if (_terminate) {
    if (_readPending) {
      _readPending=false;
      director.removeInternalReadBlock();
    }
    throw new TerminateProcessException(""String_Node_Str"");
  }
  return false;
}"
76370,"/** 
 * Do a blocking read on the queue. If no token is available, then inform the director that this receiver is blocking on a read and wait until a token becomes available. When a token becomes available, determine if this queue has the unique oldest receiver time with respect to all of the receivers contained by the actor that contains this receiver; if so, return the token. If the receiver time is a non-unique minimum then determine if this receiver has the highest priority of all receivers that share the non-unique minimum receiver time and if so, return the token. Otherwise throw a NoTokenException. If at any point during this method this receiver is scheduled for termination, then throw a TerminateProcessException to cease execution of the actor that contains this receiver. <P> IMPORTANT: This method is designed to be called after hasToken() has been called. Verify that this method is safe to call by calling hasToken() first.
 * @return Token The oldest token on this queue if this queue hasthe minimum receiver time of all receivers contained by the actor that contains this receiver.
 * @exception NoTokenException If this method is called whilehasToken() returns false.
 */
public Token get() throws NoTokenException {
  DDEDirector director=(DDEDirector)((Actor)getContainer().getContainer()).getDirector();
synchronized (this) {
    if (_terminate) {
      throw new TerminateProcessException(""String_Node_Str"");
    }
    Token token=super.get();
    if (_writePending) {
      director.removeWriteBlock(this);
      _writePending=false;
      notifyAll();
    }
    Thread thread=Thread.currentThread();
    if (thread instanceof DDEThread) {
      TimeKeeper timeKeeper=((DDEThread)thread).getTimeKeeper();
      timeKeeper.sendOutNullTokens(this);
    }
    return token;
  }
}","/** 
 * Do a blocking read on the queue. If no token is available, then inform the director that this receiver is blocking on a read and wait until a token becomes available. When a token becomes available, determine if this queue has the unique oldest receiver time with respect to all of the receivers contained by the actor that contains this receiver; if so, return the token. If the receiver time is a non-unique minimum then determine if this receiver has the highest priority of all receivers that share the non-unique minimum receiver time and if so, return the token. Otherwise throw a NoTokenException. If at any point during this method this receiver is scheduled for termination, then throw a TerminateProcessException to cease execution of the actor that contains this receiver. <P> IMPORTANT: This method is designed to be called after hasToken() has been called. Verify that this method is safe to call by calling hasToken() first.
 * @return Token The oldest token on this queue if this queue hasthe minimum receiver time of all receivers contained by the actor that contains this receiver.
 * @exception NoTokenException If this method is called whilehasToken() returns false.
 */
public Token get() throws NoTokenException {
  DDEDirector director=(DDEDirector)((Actor)getContainer().getContainer()).getDirector();
  String actorName=((Nameable)getContainer().getContainer()).getName();
synchronized (this) {
    if (_terminate) {
      throw new TerminateProcessException(""String_Node_Str"");
    }
    Token token=super.get();
    if (_writePending) {
      director.removeWriteBlock(this);
      _writePending=false;
      notifyAll();
    }
    Thread thread=Thread.currentThread();
    if (thread instanceof DDEThread) {
      TimeKeeper timeKeeper=((DDEThread)thread).getTimeKeeper();
      timeKeeper.sendOutNullTokens(this);
    }
    return token;
  }
}"
76371,"/** 
 * This method provides the recursive functionality of put(Token, double).
 */
private void _put(Token token,double time,Workspace workspace,DDEDirector director){
synchronized (this) {
    String name=((Nameable)getContainer().getContainer()).getName();
    if (token instanceof NullToken) {
    }
 else {
    }
    if (time > getCompletionTime() && getCompletionTime() != ETERNITY && !_terminate) {
      time=INACTIVE;
    }
    if (super.hasRoom() && !_terminate) {
      super.put(token,time);
      if (_readPending) {
        if (isConnectedToBoundary()) {
          if (token instanceof NullToken) {
          }
 else {
          }
          director.removeExternalReadBlock();
        }
 else {
          director.removeInternalReadBlock();
        }
        _readPending=false;
        notifyAll();
      }
      return;
    }
    if (!super.hasRoom() && !_terminate) {
      _writePending=true;
      director.addWriteBlock(this);
      while (_writePending && !_terminate) {
        workspace.wait(this);
      }
    }
    if (_terminate) {
      if (_writePending) {
        _writePending=false;
        director.removeWriteBlock(this);
      }
      throw new TerminateProcessException(getContainer(),""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      _put(token,time,workspace,director);
    }
  }
}","/** 
 * This method provides the recursive functionality of put(Token, double).
 */
private void _put(Token token,double time,Workspace workspace,DDEDirector director){
synchronized (this) {
    String name=((Nameable)getContainer().getContainer()).getName();
    if (time > getCompletionTime() && getCompletionTime() != ETERNITY && !_terminate) {
      time=INACTIVE;
    }
    if (super.hasRoom() && !_terminate) {
      super.put(token,time);
      if (_readPending) {
        if (isConnectedToBoundary()) {
          if (token instanceof NullToken) {
          }
 else {
          }
          director.removeExternalReadBlock();
        }
 else {
          director.removeInternalReadBlock();
        }
        _readPending=false;
        notifyAll();
      }
      return;
    }
    if (!super.hasRoom() && !_terminate) {
      _writePending=true;
      director.addWriteBlock(this);
      while (_writePending && !_terminate) {
        workspace.wait(this);
      }
    }
    if (_terminate) {
      if (_writePending) {
        _writePending=false;
        director.removeWriteBlock(this);
      }
      throw new TerminateProcessException(getContainer(),""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      _put(token,time,workspace,director);
    }
  }
}"
76372,"/** 
 * @exception IllegalActionException If there are problems
 * @exception IllegalStateException If there are problems
 * @exception NameDuplicationException If there are problems
 */
public void makeConnections() throws IllegalActionException {
  TypedIOPort reqOut=(TypedIOPort)_controller.getPort(""String_Node_Str"");
  TypedIOPort reqIn=(TypedIOPort)_controller.getPort(""String_Node_Str"");
  TypedIOPort contendOut=(TypedIOPort)_controller.getPort(""String_Node_Str"");
  TypedIOPort contendIn=(TypedIOPort)_controller.getPort(""String_Node_Str"");
  TypedIOPort _alarmOut=(TypedIOPort)_alarm.getPort(""String_Node_Str"");
  TypedIOPort _alarmIn=(TypedIOPort)_alarm.getPort(""String_Node_Str"");
  TypedIOPort memOut=(TypedIOPort)_memory.getPort(""String_Node_Str"");
  TypedIOPort memIn=(TypedIOPort)_memory.getPort(""String_Node_Str"");
  TypedIOPort p1_ReqOut=(TypedIOPort)_proc1.getPort(""String_Node_Str"");
  TypedIOPort p2_ReqOut=(TypedIOPort)_proc2.getPort(""String_Node_Str"");
  TypedIOPort p3_ReqOut=(TypedIOPort)_proc3.getPort(""String_Node_Str"");
  TypedIOPort p1_ReqIn=(TypedIOPort)_proc1.getPort(""String_Node_Str"");
  TypedIOPort p2_ReqIn=(TypedIOPort)_proc2.getPort(""String_Node_Str"");
  TypedIOPort p3_ReqIn=(TypedIOPort)_proc3.getPort(""String_Node_Str"");
  TypedIOPort p1_MemOut=(TypedIOPort)_proc1.getPort(""String_Node_Str"");
  TypedIOPort p2_MemOut=(TypedIOPort)_proc2.getPort(""String_Node_Str"");
  TypedIOPort p3_MemOut=(TypedIOPort)_proc3.getPort(""String_Node_Str"");
  TypedIOPort p1_MemIn=(TypedIOPort)_proc1.getPort(""String_Node_Str"");
  TypedIOPort p2_MemIn=(TypedIOPort)_proc2.getPort(""String_Node_Str"");
  TypedIOPort p3_MemIn=(TypedIOPort)_proc3.getPort(""String_Node_Str"");
  TypedIORelation inReqs, outReqs, reads, writes, outContends, inContends;
  inReqs=(TypedIORelation)_topLevelActor.connect(reqIn,p1_ReqOut);
  inReqs=(TypedIORelation)_topLevelActor.connect(reqIn,p2_ReqOut);
  inReqs=(TypedIORelation)_topLevelActor.connect(reqIn,p3_ReqOut);
  outContends=(TypedIORelation)_topLevelActor.connect(contendOut,_alarmIn);
  inContends=(TypedIORelation)_topLevelActor.connect(contendIn,_alarmOut);
  outReqs=(TypedIORelation)_topLevelActor.connect(reqOut,p1_ReqIn);
  outReqs=(TypedIORelation)_topLevelActor.connect(reqOut,p2_ReqIn);
  outReqs=(TypedIORelation)_topLevelActor.connect(reqOut,p3_ReqIn);
  reads=(TypedIORelation)_topLevelActor.connect(memOut,p1_MemIn);
  reads=(TypedIORelation)_topLevelActor.connect(memOut,p2_MemIn);
  reads=(TypedIORelation)_topLevelActor.connect(memOut,p3_MemIn);
  writes=(TypedIORelation)_topLevelActor.connect(memIn,p1_MemOut);
  writes=(TypedIORelation)_topLevelActor.connect(memIn,p2_MemOut);
  writes=(TypedIORelation)_topLevelActor.connect(memIn,p3_MemOut);
  System.out.println();
  System.out.println();
  System.out.println();
}","/** 
 * Instantiate all ports in the model and connect them as appropriate.
 * @exception IllegalActionException If there are problems
 */
public void makeConnections() throws IllegalActionException {
  TypedIOPort reqOut=(TypedIOPort)_controller.getPort(""String_Node_Str"");
  TypedIOPort reqIn=(TypedIOPort)_controller.getPort(""String_Node_Str"");
  TypedIOPort contendOut=(TypedIOPort)_controller.getPort(""String_Node_Str"");
  TypedIOPort contendIn=(TypedIOPort)_controller.getPort(""String_Node_Str"");
  TypedIOPort _alarmOut=(TypedIOPort)_alarm.getPort(""String_Node_Str"");
  TypedIOPort _alarmIn=(TypedIOPort)_alarm.getPort(""String_Node_Str"");
  TypedIOPort memOut=(TypedIOPort)_memory.getPort(""String_Node_Str"");
  TypedIOPort memIn=(TypedIOPort)_memory.getPort(""String_Node_Str"");
  TypedIOPort p1_ReqOut=(TypedIOPort)_proc1.getPort(""String_Node_Str"");
  TypedIOPort p2_ReqOut=(TypedIOPort)_proc2.getPort(""String_Node_Str"");
  TypedIOPort p3_ReqOut=(TypedIOPort)_proc3.getPort(""String_Node_Str"");
  TypedIOPort p1_ReqIn=(TypedIOPort)_proc1.getPort(""String_Node_Str"");
  TypedIOPort p2_ReqIn=(TypedIOPort)_proc2.getPort(""String_Node_Str"");
  TypedIOPort p3_ReqIn=(TypedIOPort)_proc3.getPort(""String_Node_Str"");
  TypedIOPort p1_MemOut=(TypedIOPort)_proc1.getPort(""String_Node_Str"");
  TypedIOPort p2_MemOut=(TypedIOPort)_proc2.getPort(""String_Node_Str"");
  TypedIOPort p3_MemOut=(TypedIOPort)_proc3.getPort(""String_Node_Str"");
  TypedIOPort p1_MemIn=(TypedIOPort)_proc1.getPort(""String_Node_Str"");
  TypedIOPort p2_MemIn=(TypedIOPort)_proc2.getPort(""String_Node_Str"");
  TypedIOPort p3_MemIn=(TypedIOPort)_proc3.getPort(""String_Node_Str"");
  TypedIORelation inReqs, outReqs, reads, writes, outContends, inContends;
  inReqs=(TypedIORelation)_topLevelActor.connect(reqIn,p1_ReqOut);
  inReqs=(TypedIORelation)_topLevelActor.connect(reqIn,p2_ReqOut);
  inReqs=(TypedIORelation)_topLevelActor.connect(reqIn,p3_ReqOut);
  outContends=(TypedIORelation)_topLevelActor.connect(contendOut,_alarmIn);
  inContends=(TypedIORelation)_topLevelActor.connect(contendIn,_alarmOut);
  outReqs=(TypedIORelation)_topLevelActor.connect(reqOut,p1_ReqIn);
  outReqs=(TypedIORelation)_topLevelActor.connect(reqOut,p2_ReqIn);
  outReqs=(TypedIORelation)_topLevelActor.connect(reqOut,p3_ReqIn);
  reads=(TypedIORelation)_topLevelActor.connect(memOut,p1_MemIn);
  reads=(TypedIORelation)_topLevelActor.connect(memOut,p2_MemIn);
  reads=(TypedIORelation)_topLevelActor.connect(memOut,p3_MemIn);
  writes=(TypedIORelation)_topLevelActor.connect(memIn,p1_MemOut);
  writes=(TypedIORelation)_topLevelActor.connect(memIn,p2_MemOut);
  writes=(TypedIORelation)_topLevelActor.connect(memIn,p3_MemOut);
  System.out.println();
  System.out.println();
  System.out.println();
}"
76373,"/** 
 */
public BusContentionDemo(BusContentionGraphic bcg) throws IllegalActionException, NameDuplicationException {
  this();
  _proc1.setGraphicFrame(bcg);
  _proc2.setGraphicFrame(bcg);
  _proc3.setGraphicFrame(bcg);
}","/** 
 * Construct a BusContentionDemo object with the specified BusContentionGraphic.
 * @exception IllegalActionException If there are problems.
 * @exception NameDuplicationException If there are problems.
 */
public BusContentionDemo(BusContentionGraphic bcg) throws IllegalActionException, NameDuplicationException {
  this();
  _proc1.setGraphicFrame(bcg);
  _proc2.setGraphicFrame(bcg);
  _proc3.setGraphicFrame(bcg);
}"
76374,"/** 
 * @exception IllegalActionException If there are problems
 * @exception IllegalStateException If there are problems
 * @exception NameDuplicationException If there are problems
 */
public static void main(String args[]) throws IllegalActionException, IllegalStateException, NameDuplicationException {
  BusContentionDemo demo=new BusContentionDemo();
  demo.makeConnections();
  demo.run();
}","/** 
 * Start the BusContention demo.
 * @exception IllegalActionException If there are problems
 * @exception IllegalStateException If there are problems
 * @exception NameDuplicationException If there are problems
 */
public static void main(String args[]) throws IllegalActionException, IllegalStateException, NameDuplicationException {
  BusContentionDemo demo=new BusContentionDemo();
  demo.makeConnections();
  demo.run();
}"
76375,"/** 
 * @exception IllegalActionException If there are problems
 * @exception IllegalStateException If there are problems
 * @exception NameDuplicationException If there are problems
 */
public void run(){
  _manager.run();
  System.out.println();
  System.out.println();
  System.out.println();
}","/** 
 * Execute the model by calling the manager's run method.
 */
public void run(){
  _manager.run();
  System.out.println();
  System.out.println();
  System.out.println();
}"
76376,"/** 
 * While the current time is less then 50.0, return the delay value as specified in the super class. After the current time has exceeded 50, return a delay value of 0.001 for 200 firings. After the 200 firings are complete, resume returning the super class delay value.
 * @return
 */
public double getDelay(){
  if (_cntr < 200) {
    if (getCurrentTime() < 50.0) {
      return super.getDelay();
    }
 else {
      _cntr++;
      return 0.001;
    }
  }
  return super.getDelay();
}","/** 
 * While the current time is less then 50.0, return the delay value as specified in the super class. After the current time has exceeded 50, return a delay value of 0.001 for 200 firings. After the 200 firings are complete, resume returning the super class delay value.
 * @return The delay value depending upon whether time hasexceeded 50.0.
 */
public double getDelay(){
  if (_cntr < 200) {
    if (getCurrentTime() < 50.0) {
      return super.getDelay();
    }
 else {
      _cntr++;
      return 0.001;
    }
  }
  return super.getDelay();
}"
76377,"/** 
 * Send an array of tokens to all receivers connected to the specified channel.  Operation is similar to IOPort.send(), except that it sends a sequence of tokens in an array.   The token in the first position in the array is interpreted as the oldest token in the sequence, and the token in the last position of the array in interpreted as the newest token in the sequence. This method is provided for efficiency only, and is semantically equivalent to calling IOPort.put() consecutively for each element in the array.
 * @param channelindex The index of the channel, from 0 to width-1
 * @param tokens The tokens to send
 * @exception NoRoomException If there is no room in the receiver.
 * @exception IllegalActionException If the port is not an output, ifthe index is out of range, or if the array is null.
 */
public void sendArray(int channelindex,ptolemy.data.Token tokens[]) throws IllegalActionException, NoRoomException {
  Receiver[][] farRec;
  if (tokens == null)   throw new IllegalActionException(""String_Node_Str"");
  try {
    workspace().getReadAccess();
    if (!isOutput()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (channelindex >= getWidth() || channelindex < 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    farRec=getRemoteReceivers();
    if (farRec == null || farRec[channelindex] == null)     return;
  }
  finally {
    workspace().doneReading();
  }
  for (int j=0; j < farRec[channelindex].length; j++) {
    if (farRec[channelindex][j] instanceof SDFReceiver)     ((SDFReceiver)farRec[channelindex][j]).putArray(tokens);
 else     for (int i=0; i < tokens.length; i++) {
      farRec[channelindex][j].put(tokens[i]);
    }
  }
}","/** 
 * Send an array of tokens to all receivers connected to the specified channel.  Operation is similar to IOPort.send(), except that it sends a sequence of tokens in an array.    The token in the first position in the array is interpreted  as the oldest token in the sequence, and the token in the last position of the array is interpreted as the newest token in the sequence. This method is provided for efficiency only, and is semantically equivalent to calling IOPort.put() consecutively for each element in the array.  
 * @param channelindex The index of the channel, from 0 to width-1
 * @param tokens The tokens to send
 * @exception NoRoomException If there is no room in the receiver.
 * @exception IllegalActionException If the port is not an output, ifthe index is out of range, or if the array is null.
 */
public void sendArray(int channelindex,ptolemy.data.Token tokens[]) throws IllegalActionException, NoRoomException {
  Receiver[][] farRec;
  if (tokens == null)   throw new IllegalActionException(""String_Node_Str"");
  if (tokens.length == 0)   return;
  ptolemy.data.Token firstToken=firstToken=tokens[0];
  try {
    workspace().getReadAccess();
    if (!isOutput()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (channelindex >= getWidth() || channelindex < 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    Class _resolvedType=getType();
    int compare=TypeLattice.compare(firstToken.getClass(),_resolvedType);
    if (compare == CPO.HIGHER || compare == CPO.INCOMPARABLE) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + firstToken.getClass().getName() + ""String_Node_Str""+ getFullName()+ ""String_Node_Str""+ getType().getName());
    }
    for (int i=1; i < tokens.length; i++) {
      if (tokens[i].getClass() != firstToken.getClass())       throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str""+ tokens[i].getClass().getName()+ ""String_Node_Str""+ getFullName()+ ""String_Node_Str""+ getType().getName());
    }
    farRec=getRemoteReceivers();
    if (farRec == null || farRec[channelindex] == null)     return;
  }
  finally {
    workspace().doneReading();
  }
  try {
    for (int j=0; j < farRec[channelindex].length; j++) {
      TypedIOPort port=(TypedIOPort)farRec[channelindex][j].getContainer();
      Class farType=port.getType();
      if ((farRec[channelindex][j] instanceof SDFReceiver) && (farType.isInstance(firstToken))) {
        ((SDFReceiver)farRec[channelindex][j]).putArray(tokens);
      }
 else {
        Object[] arg=new Object[1];
        Method convert=_getConvertMethod(farType);
        for (int i=0; i < tokens.length; i++) {
          arg[0]=tokens[i];
          ptolemy.data.Token newToken=(ptolemy.data.Token)convert.invoke(null,arg);
          farRec[channelindex][j].put(newToken);
        }
      }
    }
  }
 catch (  IllegalAccessException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
catch (  InvocationTargetException ite) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ite.getMessage());
  }
}"
76378,"private synchronized void _edit(int x,int y){
  if (_dataset < 0)   return;
  Object[] save=new Object[2];
  save[0]=new Integer(_dataset);
  save[1]=getData(_dataset);
  _undoStack.push(save);
  _redoStack.clear();
  Graphics graphics=getGraphics();
  if (y > _lry)   y=_lry;
  if (y < _uly)   y=_uly;
  if (x > _lrx)   x=_lrx;
  if (x < _ulx)   x=_ulx;
  _editPoint(x,y);
  Vector pts=(Vector)_points.elementAt(_dataset);
  for (int i=0; i < pts.size(); i++) {
    PlotPoint pt=(PlotPoint)pts.elementAt(i);
    if ((pt.x >= _xMin) && (pt.x <= _xMax)) {
      int index=(int)((pt.x - _xMin) * _xscale) - (_lrx - _ulx - _editSpecX.length);
      if (index >= 0 && index < _editSpecX.length) {
        if (_editSpecSet[index]) {
          pt.y=_yMax - (_editSpecY[index] - _uly) / _yscale;
          if (pt.y < _yBottom)           _yBottom=pt.y;
          if (pt.y > _yTop)           _yTop=pt.y;
        }
      }
    }
  }
  repaint();
  graphics.setXORMode(_editColor);
  for (int i=0; i < _editSpecX.length; i++) {
    if (_editSpecSet[i]) {
      graphics.drawLine(_editSpecX[i],_editSpecY[i] - 1,_editSpecX[i],_editSpecY[i] + 1);
    }
  }
  graphics.setPaintMode();
}","private synchronized void _edit(int x,int y){
  if (_dataset < 0)   return;
  Object[] save=new Object[2];
  save[0]=new Integer(_dataset);
  save[1]=getData(_dataset);
  _undoStack.push(save);
  _redoStack.clear();
  Graphics graphics=getGraphics();
  if (y > _lry)   y=_lry;
  if (y < _uly)   y=_uly;
  if (x > _lrx)   x=_lrx;
  if (x < _ulx)   x=_ulx;
  _editPoint(x,y);
  Vector pts=(Vector)_points.elementAt(_dataset);
  for (int i=0; i < pts.size(); i++) {
    PlotPoint pt=(PlotPoint)pts.elementAt(i);
    if ((pt.x >= _xMin) && (pt.x <= _xMax)) {
      int index=(int)((pt.x - _xMin) * _xscale) - (_lrx - _ulx - _editSpecX.length);
      if (index >= 0 && index < _editSpecX.length) {
        if (_editSpecSet[index]) {
          pt.y=_yMax - (_editSpecY[index] - _uly) / _yscale;
          if (pt.y < _yBottom)           _yBottom=pt.y;
          if (pt.y > _yTop)           _yTop=pt.y;
        }
      }
    }
  }
  repaint();
  graphics.setXORMode(_editColor);
  for (int i=0; i < _editSpecX.length; i++) {
    if (_editSpecSet[i]) {
      graphics.drawLine(_editSpecX[i],_editSpecY[i] - 1,_editSpecX[i],_editSpecY[i] + 1);
    }
  }
  graphics.setPaintMode();
  _notifyListeners(_dataset);
}"
76379,"/** 
 * Constructor.
 */
public EditablePlot(){
  super();
  addMouseListener(new EditListener());
  addMouseMotionListener(new ModifyListener());
  addKeyListener(new UndoListener());
}","/** 
 * Constructor.
 */
public EditablePlot(){
  super();
  addMouseListener(new EditMouseListener());
  addMouseMotionListener(new ModifyListener());
  addKeyListener(new UndoListener());
}"
76380,"/** 
 * Redo the latest signal editing operation that was undone by calling undo(), if there was one.  Otherwise, do nothing.
 */
public void redo(){
  if (_redoStack.empty())   return;
  Object[] save=new Object[2];
  save[0]=new Integer(_dataset);
  save[1]=getData(_dataset);
  _undoStack.push(save);
  Object[] saved=(Object[])_redoStack.pop();
  _setData(((Integer)saved[0]).intValue(),(double[][])saved[1]);
  repaint();
}","/** 
 * Redo the latest signal editing operation that was undone by calling undo(), if there was one.  Otherwise, do nothing.
 */
public void redo(){
  if (_redoStack.empty())   return;
  Object[] save=new Object[2];
  save[0]=new Integer(_dataset);
  save[1]=getData(_dataset);
  _undoStack.push(save);
  Object[] saved=(Object[])_redoStack.pop();
  _setData(((Integer)saved[0]).intValue(),(double[][])saved[1]);
  repaint();
  _notifyListeners(_dataset);
}"
76381,"/** 
 * Undo the latest signal editing operation, if there was one. Otherwise, do nothing.
 */
public void undo(){
  if (_undoStack.empty())   return;
  Object[] save=new Object[2];
  save[0]=new Integer(_dataset);
  save[1]=getData(_dataset);
  _redoStack.push(save);
  Object[] saved=(Object[])_undoStack.pop();
  _setData(((Integer)saved[0]).intValue(),(double[][])saved[1]);
  repaint();
}","/** 
 * Undo the latest signal editing operation, if there was one. Otherwise, do nothing.
 */
public void undo(){
  if (_undoStack.empty())   return;
  Object[] save=new Object[2];
  save[0]=new Integer(_dataset);
  save[1]=getData(_dataset);
  _redoStack.push(save);
  Object[] saved=(Object[])_undoStack.pop();
  _setData(((Integer)saved[0]).intValue(),(double[][])saved[1]);
  repaint();
  _notifyListeners(_dataset);
}"
76382,"private synchronized void _editPoint(int x,int y){
  if (_dataset < 0)   return;
  Graphics graphics=getGraphics();
  if (y > _lry)   y=_lry;
  if (y < _uly)   y=_uly;
  if (x > _lrx)   x=_lrx;
  if (x < _ulx)   x=_ulx;
  if (x <= _currentEditX || x >= _lrx) {
    return;
  }
  int step=_currentEditX + 1;
  while (step <= x) {
    int index=step - (_lrx - _editSpecX.length);
    double proportion=(step - _currentEditX) / (double)(x - _currentEditX);
    int newY=(int)(_currentEditY + proportion * (y - _currentEditY));
    _editSpecX[index]=step;
    _editSpecY[index]=newY;
    _editSpecSet[index]=true;
    graphics.setXORMode(_editColor);
    graphics.drawLine(step,newY - 1,step,newY + 1);
    graphics.setPaintMode();
    step++;
  }
  _currentEditX=x;
  _currentEditY=y;
}","private synchronized void _editPoint(int x,int y){
  if (_dataset < 0)   return;
  Graphics graphics=getGraphics();
  if (y > _lry)   y=_lry;
  if (y < _uly)   y=_uly;
  if (x > _lrx)   x=_lrx;
  if (x < _ulx)   x=_ulx;
  if (x <= _currentEditX || x >= _lrx) {
    return;
  }
  int step=_currentEditX;
  while (step <= x) {
    int index=step - (_lrx - _editSpecX.length);
    double proportion=(step - _currentEditX) / (double)(x - _currentEditX);
    int newY=(int)(_currentEditY + proportion * (y - _currentEditY));
    if (!_editSpecSet[index]) {
      _editSpecX[index]=step;
      _editSpecY[index]=newY;
      _editSpecSet[index]=true;
      graphics.setXORMode(_editColor);
      graphics.drawLine(step,newY - 1,step,newY + 1);
      graphics.setPaintMode();
    }
    step++;
  }
  _currentEditX=x;
  _currentEditY=y;
}"
76383,"/** 
 * This method provides the recursive functionality of hasToken()
 */
private synchronized boolean _hasToken(Workspace workspace,DDEDirector director,TimeKeeper timeKeeper,boolean _hideNullTokens){
  timeKeeper.resortRcvrList();
  if (timeKeeper.getNextTime() == INACTIVE) {
    requestFinish();
  }
  if (getRcvrTime() == IGNORE && !_terminate) {
    if (_ignoreNotSeen) {
      _ignoreNotSeen=false;
      return false;
    }
 else {
      _ignoreNotSeen=true;
      clearIgnoredTokens();
      timeKeeper.setIgnoredTokens(false);
      return false;
    }
  }
  if (getRcvrTime() > timeKeeper.getNextTime() && !_terminate) {
    return false;
  }
  if (super.hasToken() && !_terminate) {
    if (!timeKeeper.hasMinRcvrTime()) {
      if (hasNullToken()) {
        if (timeKeeper.getHighestPriorityReal() != null) {
          return false;
        }
 else         if (this != timeKeeper.getHighestPriorityNull()) {
          return false;
        }
 else         if (!_hideNullTokens) {
          return true;
        }
 else {
          super.get();
          timeKeeper.sendOutNullTokens();
          return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
        }
      }
 else {
        return true;
      }
    }
 else {
      if (hasNullToken()) {
        if (!_hideNullTokens) {
          return true;
        }
        super.get();
        timeKeeper.sendOutNullTokens();
        return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
      }
      return true;
    }
  }
  if (!super.hasToken() && !_terminate) {
    _readPending=true;
    director.addReadBlock();
    while (_readPending && !_terminate) {
      workspace.wait(this);
    }
  }
  if (_terminate) {
    if (_readPending) {
      _readPending=false;
      director.removeReadBlock();
    }
    throw new TerminateProcessException(""String_Node_Str"");
  }
 else {
    return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
  }
}","/** 
 * This method provides the recursive functionality of hasToken()
 */
private synchronized boolean _hasToken(Workspace workspace,DDEDirector director,TimeKeeper timeKeeper,boolean _hideNullTokens){
  timeKeeper.resortRcvrList();
  if (timeKeeper.getNextTime() == INACTIVE) {
    requestFinish();
  }
  if (getRcvrTime() == INACTIVE && !_terminate) {
    return false;
  }
  if (getRcvrTime() == IGNORE && !_terminate) {
    if (_ignoreNotSeen) {
      _ignoreNotSeen=false;
      return false;
    }
 else {
      _ignoreNotSeen=true;
      clearIgnoredTokens();
      timeKeeper.setIgnoredTokens(false);
      return false;
    }
  }
  if (getRcvrTime() > timeKeeper.getNextTime() && !_terminate) {
    return false;
  }
  if (super.hasToken() && !_terminate) {
    if (!timeKeeper.hasMinRcvrTime()) {
      if (hasNullToken()) {
        if (timeKeeper.getHighestPriorityReal() != null) {
          return false;
        }
 else         if (this != timeKeeper.getHighestPriorityNull()) {
          return false;
        }
 else         if (!_hideNullTokens) {
          return true;
        }
 else {
          super.get();
          timeKeeper.sendOutNullTokens();
          return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
        }
      }
 else {
        return true;
      }
    }
 else {
      if (hasNullToken()) {
        if (!_hideNullTokens) {
          return true;
        }
        super.get();
        timeKeeper.sendOutNullTokens();
        return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
      }
      return true;
    }
  }
  if (!super.hasToken() && !_terminate) {
    _readPending=true;
    director.addReadBlock();
    while (_readPending && !_terminate) {
      workspace.wait(this);
    }
  }
  if (_terminate) {
    if (_readPending) {
      _readPending=false;
      director.removeReadBlock();
    }
    throw new TerminateProcessException(""String_Node_Str"");
  }
 else {
    return _hasToken(workspace,director,timeKeeper,_hideNullTokens);
  }
}"
76384,"/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense. FIXME: This method destroys the firing vector.  This is not nice.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A CircularList of the Actors in the order they should fire.
 * @exception InvalidStateException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state.
 */
private CircularList _scheduleConnectedActors(CircularList actorList){
  CircularList readyToScheduleActorList=new CircularList();
  CircularList newSchedule=new CircularList();
  boolean done=false;
  LLMap waitingTokens=new LLMap();
  CircularList unscheduledActorList=new CircularList();
  unscheduledActorList.appendElements(actorList.elements());
  Enumeration schedulableEntities=actorList.elements();
  try {
    while (schedulableEntities.hasMoreElements()) {
      Actor a=(Actor)schedulableEntities.nextElement();
      Enumeration ainputports=a.inputPorts();
      while (ainputports.hasMoreElements()) {
        IOPort ainputport=(IOPort)ainputports.nextElement();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.putAt(ainputport,tokencount);
        Enumeration crelations=ainputport.linkedRelations();
        int channelNumber=0;
        while (crelations.hasMoreElements()) {
          IORelation crelation=(IORelation)crelations.nextElement();
          Enumeration cports=crelation.linkedSourcePorts();
          if (!cports.hasMoreElements())           throw new IllegalActionException(crelation,ainputport,""String_Node_Str"" + ""String_Node_Str"");
          IOPort cport=(IOPort)cports.nextElement();
          if (cports.hasMoreElements())           throw new IllegalActionException(crelation,cport,""String_Node_Str"" + ""String_Node_Str"");
          ComponentEntity cactor=(ComponentEntity)cport.getContainer();
          int rate=_getTokenInitProduction(cport);
          if (rate > 0) {
            for (int j=0; j < crelation.getWidth(); j++)             tokencount[channelNumber++]+=_getTokenProductionRate(cport);
          }
        }
      }
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.insertFirst((ComponentEntity)a);
      _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ (new Integer(inputCount)).toString()+ ""String_Node_Str"");
    }
    while (!done) {
      _debug(""String_Node_Str"");
      _debug(waitingTokens.toString());
      _debug(""String_Node_Str"");
      Enumeration actorsLeft=readyToScheduleActorList.elements();
      while (actorsLeft.hasMoreElements()) {
        Entity e=(Entity)actorsLeft.nextElement();
        _debug(e.getFullName());
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.at(0);
      readyToScheduleActorList.exclude(currentActor);
      _debug(""String_Node_Str"" + currentActor.getName());
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.insertLast(currentActor);
      Enumeration aOutputPorts=((Actor)currentActor).outputPorts();
      while (aOutputPorts.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.nextElement();
        Integer createdTokens=new Integer(_getTokenProductionRate(aOutputPort));
        _simulateTokensCreated(aOutputPort,actorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=_getFiringCount(currentActor);
      firingsRemaining-=1;
      _setFiringCount(currentActor,firingsRemaining);
      _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          unscheduledActorList.removeOneOf(currentActor);
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1)           readyToScheduleActorList.insertLast(currentActor);
        }
      }
    }
  }
 catch (  NoSuchElementException e) {
    _debug(""String_Node_Str"");
    _debug(e.getMessage());
    done=true;
  }
catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    _debug(""String_Node_Str"");
  }
  Enumeration eschedule=newSchedule.elements();
  _debug(""String_Node_Str"");
  while (eschedule.hasMoreElements())   _debug(((ComponentEntity)eschedule.nextElement()).toString());
  return newSchedule;
}","/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense. FIXME: This method destroys the firing vector.  This is not nice.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A CircularList of the Actors in the order they should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be  scheduled.
 */
private CircularList _scheduleConnectedActors(CircularList actorList) throws NotSchedulableException {
  CircularList readyToScheduleActorList=new CircularList();
  CircularList newSchedule=new CircularList();
  LLMap waitingTokens=new LLMap();
  CircularList unscheduledActorList=new CircularList();
  unscheduledActorList.appendElements(actorList.elements());
  try {
    Enumeration schedulableEntities=actorList.elements();
    while (schedulableEntities.hasMoreElements()) {
      Actor a=(Actor)schedulableEntities.nextElement();
      Enumeration ainputports=a.inputPorts();
      while (ainputports.hasMoreElements()) {
        IOPort ainputport=(IOPort)ainputports.nextElement();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.putAt(ainputport,tokencount);
      }
    }
    schedulableEntities=actorList.elements();
    while (schedulableEntities.hasMoreElements()) {
      Actor a=(Actor)schedulableEntities.nextElement();
      Enumeration aoutputports=a.outputPorts();
      while (aoutputports.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aoutputports.nextElement();
        int count=_getTokenInitProduction(aOutputPort);
        if (count > 0) {
          _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
        }
      }
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.insertFirst((ComponentEntity)a);
      _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ (new Integer(inputCount)).toString()+ ""String_Node_Str"");
    }
    while (readyToScheduleActorList.size() > 0) {
      _debug(""String_Node_Str"");
      Enumeration ports=waitingTokens.keys();
      while (ports.hasMoreElements()) {
        IOPort port=(IOPort)ports.nextElement();
        _debug(""String_Node_Str"" + port.getFullName());
        int tokencount[]=(int[])waitingTokens.at(port);
        _debug(""String_Node_Str"" + tokencount.length);
        for (int channel=0; channel < tokencount.length; channel++)         _debug(""String_Node_Str"" + channel + ""String_Node_Str""+ tokencount[channel]+ ""String_Node_Str"");
      }
      _debug(""String_Node_Str"");
      Enumeration actorsLeft=readyToScheduleActorList.elements();
      while (actorsLeft.hasMoreElements()) {
        Entity e=(Entity)actorsLeft.nextElement();
        _debug(e.getFullName());
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.at(0);
      readyToScheduleActorList.exclude(currentActor);
      _debug(""String_Node_Str"" + currentActor.getName());
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.insertLast(currentActor);
      Enumeration aOutputPorts=((Actor)currentActor).outputPorts();
      while (aOutputPorts.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.nextElement();
        int count=_getTokenProductionRate(aOutputPort);
        _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=_getFiringCount(currentActor);
      firingsRemaining-=1;
      _setFiringCount(currentActor,firingsRemaining);
      _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          unscheduledActorList.exclude(currentActor);
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1)           readyToScheduleActorList.insertLast(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    _debug(""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    String s=new String(""String_Node_Str"");
    Enumeration actors=unscheduledActorList.elements();
    while (actors.hasMoreElements()) {
      Entity actor=(Entity)actors.nextElement();
      s+=actor.getFullName() + ""String_Node_Str"";
    }
    throw new NotSchedulableException(s);
  }
  Enumeration eschedule=newSchedule.elements();
  _debug(""String_Node_Str"");
  while (eschedule.hasMoreElements())   _debug(((ComponentEntity)eschedule.nextElement()).toString());
  return newSchedule;
}"
76385,"/** 
 * Return the scheduling sequence.  An exception will be thrown if the graph is not schedulable.  This occurs in the following circumstances: <ul> <li>The graph is not a connected graph. <li>No integer solution exists for the balance equations. <li>The graph contains cycles without delays (deadlock). <li>Multiple output ports are connected to the same broadcast relation. (equivalent to a non-deterministic merge) </ul>
 * @return An Enumeration of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If the CompositeActor is notschedulable.
 */
protected Enumeration _schedule() throws NotSchedulableException {
  StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
  CompositeActor ca=(CompositeActor)(dir.getContainer());
  CircularList AllActors=new CircularList();
  Enumeration Entities=ca.deepGetEntities();
  while (Entities.hasMoreElements()) {
    ComponentEntity a=(ComponentEntity)Entities.nextElement();
    if (a instanceof CompositeActor) {
      Director containedDirector=((CompositeActor)a).getDirector();
      if (containedDirector instanceof StaticSchedulingDirector) {
        Scheduler containedScheduler=((StaticSchedulingDirector)containedDirector).getScheduler();
        try {
          containedScheduler.schedule();
        }
 catch (        IllegalActionException e) {
          throw new InternalErrorException(e.getMessage());
        }
      }
    }
    if (a instanceof Actor)     AllActors.insertLast(a);
  }
  LLMap firings=null;
  try {
    firings=_solveBalanceEquations(AllActors.elements());
  }
 catch (  IllegalActionException ex) {
    throw new NotSchedulableException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  firings=_normalizeFirings(firings);
  _setFiringVector(firings);
  _debug(""String_Node_Str"");
  _debug(firings.toString());
  CircularList result=_scheduleConnectedActors(AllActors);
  _setFiringVector(firings);
  _debug(""String_Node_Str"");
  _debug(firings.toString());
  try {
    _setContainerRates();
  }
 catch (  IllegalActionException ex) {
    throw new NotSchedulableException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  setValid(true);
  return result.elements();
}","/** 
 * Return the scheduling sequence.  An exception will be thrown if the graph is not schedulable.  This occurs in the following circumstances: <ul> <li>The graph is not a connected graph. <li>No integer solution exists for the balance equations. <li>The graph contains cycles without delays (deadlock). <li>Multiple output ports are connected to the same broadcast relation. (equivalent to a non-deterministic merge) </ul>
 * @return An Enumeration of the deeply contained opaque entitiesin the firing order.
 * @exception NotScheduleableException If the CompositeActor is notschedulable.
 */
protected Enumeration _schedule() throws NotSchedulableException {
  StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
  CompositeActor ca=(CompositeActor)(dir.getContainer());
  CircularList AllActors=new CircularList();
  Enumeration Entities=ca.deepGetEntities();
  while (Entities.hasMoreElements()) {
    ComponentEntity a=(ComponentEntity)Entities.nextElement();
    if (a instanceof CompositeActor) {
      _debug(""String_Node_Str"");
      Director containedDirector=((CompositeActor)a).getDirector();
      if (containedDirector instanceof StaticSchedulingDirector) {
        Scheduler containedScheduler=((StaticSchedulingDirector)containedDirector).getScheduler();
        try {
          containedScheduler.schedule();
        }
 catch (        IllegalActionException e) {
          throw new InternalErrorException(e.getMessage());
        }
      }
    }
    if (a instanceof Actor)     AllActors.insertLast(a);
  }
  LLMap firings=null;
  try {
    firings=_solveBalanceEquations(AllActors.elements());
  }
 catch (  IllegalActionException ex) {
    throw new NotSchedulableException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  firings=_normalizeFirings(firings);
  _setFiringVector(firings);
  _debug(""String_Node_Str"");
  _debug(firings.toString());
  CircularList result=_scheduleConnectedActors(AllActors);
  _setFiringVector(firings);
  _debug(""String_Node_Str"");
  _debug(firings.toString());
  try {
    _setContainerRates();
  }
 catch (  IllegalActionException ex) {
    throw new NotSchedulableException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  setValid(true);
  return result.elements();
}"
76386,"/** 
 * Simulate the creation of tokens by the given output port when it's actor fires.  If any actors that receive tokens are then ready to fire, given that only actors in the actor list are eing scheduled, then add those actors to the list of actors that are ready to schedule. update the waiting tokens map with the tokens available on each channel of each port.
 */
private void _simulateTokensCreated(IOPort outputPort,CircularList actorList,CircularList readyToScheduleActorList,LLMap waitingTokens) throws IllegalActionException {
  int createdTokens=_getTokenProductionRate(outputPort);
  _debug(""String_Node_Str"" + createdTokens + ""String_Node_Str""+ outputPort.getFullName());
  Enumeration crelations=outputPort.linkedRelations();
  while (crelations.hasMoreElements()) {
    IORelation connectedRelation=(IORelation)crelations.nextElement();
    Enumeration cports=connectedRelation.linkedPorts();
    while (cports.hasMoreElements()) {
      IOPort connectedPort=(IOPort)cports.nextElement();
      ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
      if (!connectedPort.equals(outputPort)) {
        int[] tokens=(int[])waitingTokens.at(connectedPort);
        int startChannel=_startChannel(connectedPort,connectedRelation);
        for (int i=0; i < connectedRelation.getWidth(); i++) {
          tokens[startChannel++]+=createdTokens;
        }
        int ival=_countUnfulfilledInputs((Actor)connectedActor,actorList,waitingTokens);
        int firingsRemaining=_getFiringCount(connectedActor);
        if ((ival <= 0) && (firingsRemaining > 0)) {
          readyToScheduleActorList.insertLast(connectedActor);
        }
      }
    }
  }
}","/** 
 * Simulate the creation of tokens by the given output port when its actor fires.  If any actors that receive tokens are then ready to fire, given that only actors in the actor list are being scheduled, then add those actors to the list of actors that are ready to schedule. update the waiting tokens map with the tokens available on each channel of each port.
 */
private void _simulateTokensCreated(IOPort outputPort,int createdTokens,CircularList actorList,CircularList readyToScheduleActorList,LLMap waitingTokens) throws IllegalActionException {
  _debug(""String_Node_Str"" + createdTokens + ""String_Node_Str""+ outputPort.getFullName());
  Receiver[][] creceivers=outputPort.getRemoteReceivers();
  _debug(""String_Node_Str"" + creceivers.length);
  int sourcechannel;
  for (sourcechannel=0; sourcechannel < creceivers.length; sourcechannel++) {
    _debug(""String_Node_Str"" + creceivers[sourcechannel].length);
    int destinationreceiver;
    for (destinationreceiver=0; destinationreceiver < creceivers[sourcechannel].length; destinationreceiver++) {
      IOPort connectedPort=(IOPort)creceivers[sourcechannel][destinationreceiver].getContainer();
      ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
      if (actorList.includes(connectedActor)) {
        int destinationchannel=_getChannel(connectedPort,creceivers[sourcechannel][destinationreceiver]);
        int[] tokens=(int[])waitingTokens.at(connectedPort);
        tokens[destinationchannel]+=createdTokens;
        _debug(""String_Node_Str"" + destinationchannel + ""String_Node_Str""+ connectedPort.getName());
        int ival=_countUnfulfilledInputs((Actor)connectedActor,actorList,waitingTokens);
        int firingsRemaining=_getFiringCount(connectedActor);
        if ((ival <= 0) && (firingsRemaining > 0)) {
          readyToScheduleActorList.insertLast(connectedActor);
        }
      }
    }
  }
}"
76387,"/** 
 * In addition to creating the buttons provided by the base class, if the number of iterations has not been specified, then create a dialog box for that number to be entered.  The panel containing the buttons and the entry box is returned.
 * @param numbuttons The number of buttons to create.
 */
protected Panel _createRunControls(int numbuttons){
  Panel controlPanel=super._createRunControls(numbuttons);
  if (numbuttons > 2) {
    Button layout=new Button(""String_Node_Str"");
    controlPanel.add(layout);
    layout.addActionListener(new LayoutListener());
  }
  return controlPanel;
}","/** 
 * In addition to creating the buttons provided by the base class, if the number of iterations has not been specified, then create a dialog box for that number to be entered.  The panel containing the buttons and the entry box is returned.
 * @param numButtons The number of buttons to create.
 */
protected Panel _createRunControls(int numButtons){
  Panel controlPanel=super._createRunControls(numButtons);
  if (numButtons > 2) {
    Button layout=new Button(""String_Node_Str"");
    controlPanel.add(layout);
    layout.addActionListener(new LayoutListener());
  }
  return controlPanel;
}"
76388,"/** 
 * Construct the graph representing the topology. This is sort of bogus because it's totally hird-wired, but it will do for now...
 */
public GraphModel constructDivaGraph(){
  GraphModel model=new GraphModel();
  Node n1=model.createNode(_contentionActor);
  Node n2=model.createNode(_alarmActor);
  Node n3=model.createNode(_memoryActor);
  Node n4=model.createNode(_processActor1);
  Node n5=model.createNode(_processActor2);
  Node n6=model.createNode(_processActor3);
  model.addNode(n1);
  model.addNode(n2);
  model.addNode(n3);
  model.addNode(n4);
  model.addNode(n5);
  model.addNode(n6);
  _nodeMap.put(_contentionActor,n1);
  _nodeMap.put(_alarmActor,n2);
  _nodeMap.put(_memoryActor,n3);
  _nodeMap.put(_processActor1,n4);
  _nodeMap.put(_processActor2,n5);
  _nodeMap.put(_processActor3,n6);
  model.createEdge(n1,n2);
  model.createEdge(n1,n4);
  model.createEdge(n1,n5);
  model.createEdge(n1,n6);
  model.createEdge(n3,n4);
  model.createEdge(n3,n5);
  model.createEdge(n3,n6);
  return model;
}","/** 
 * Construct the graph representing the topology. This is sort of bogus because it's totally hard-wired, but it will do for now...
 */
public GraphModel constructDivaGraph(){
  GraphModel model=new GraphModel();
  Node n1=model.createNode(_contentionActor);
  Node n2=model.createNode(_alarmActor);
  Node n3=model.createNode(_memoryActor);
  Node n4=model.createNode(_processActor1);
  Node n5=model.createNode(_processActor2);
  Node n6=model.createNode(_processActor3);
  model.addNode(n1);
  model.addNode(n2);
  model.addNode(n3);
  model.addNode(n4);
  model.addNode(n5);
  model.addNode(n6);
  _nodeMap.put(_contentionActor,n1);
  _nodeMap.put(_alarmActor,n2);
  _nodeMap.put(_memoryActor,n3);
  _nodeMap.put(_processActor1,n4);
  _nodeMap.put(_processActor2,n5);
  _nodeMap.put(_processActor3,n6);
  model.createEdge(n1,n2);
  model.createEdge(n1,n4);
  model.createEdge(n1,n5);
  model.createEdge(n1,n6);
  model.createEdge(n3,n4);
  model.createEdge(n3,n5);
  model.createEdge(n3,n6);
  return model;
}"
76389,"/** 
 * Construct the graph widget with the default constructor (giving it an empty graph). 
 */
public void displayGraph(JGraph g,GraphModel model){
  _divaPanel.add(g,BorderLayout.NORTH);
  g.setPreferredSize(new Dimension(600,400));
  final GraphPane gp=(GraphPane)g.getCanvasPane();
  final GraphView gv=gp.getGraphView();
  gv.setNodeRenderer(new ThreadRenderer());
  gv.setEdgeRenderer(new LocalEdgeRenderer());
  gv.setLayoutPercentage(0.6);
  g.setGraphModel(model);
  gp.repaint();
  final GraphModel m=model;
  try {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        LevelLayout staticLayout=new LevelLayout();
        staticLayout.setOrientation(LevelLayout.HORIZONTAL);
        staticLayout.layout(gv,m.getGraph());
        gp.repaint();
      }
    }
);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new RuntimeException(e.toString());
  }
}","/** 
 * Construct the graph widget with the default constructor (giving it an empty graph).
 */
public void displayGraph(JGraph g,GraphModel model){
  _divaPanel.add(g,BorderLayout.NORTH);
  g.setPreferredSize(new Dimension(600,400));
  final GraphPane gp=(GraphPane)g.getCanvasPane();
  final GraphView gv=gp.getGraphView();
  gv.setNodeRenderer(new ThreadRenderer());
  gv.setEdgeRenderer(new LocalEdgeRenderer());
  gv.setLayoutPercentage(0.6);
  g.setGraphModel(model);
  gp.repaint();
  final GraphModel m=model;
  try {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        LevelLayout staticLayout=new LevelLayout();
        staticLayout.setOrientation(LevelLayout.HORIZONTAL);
        staticLayout.layout(gv,m.getGraph());
        gp.repaint();
      }
    }
);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new RuntimeException(e.toString());
  }
}"
76390,"private void _constructDirectedGraph(){
  LinkedList portList=new LinkedList();
  _dag=new DirectedAcyclicGraph();
  CompositeActor container=((CompositeActor)getContainer());
  if (container != null) {
    Enumeration allactors=container.deepGetEntities();
    while (allactors.hasMoreElements()) {
      Actor actor=(Actor)allactors.nextElement();
      Enumeration allports=actor.inputPorts();
      while (allports.hasMoreElements()) {
        IOPort port=(IOPort)allports.nextElement();
        _dag.add(port);
        portList.insertLast(port);
      }
    }
  }
  Enumeration copiedPorts=portList.elements();
  while (copiedPorts.hasMoreElements()) {
    IOPort ioPort=(IOPort)copiedPorts.nextElement();
    if (ioPort instanceof DEIOPort) {
      DEIOPort p=(DEIOPort)ioPort;
      Enumeration befores=p.beforePorts();
      while (befores.hasMoreElements()) {
        IOPort after=(IOPort)befores.nextElement();
        if (_dag.contains(after)) {
          _dag.addEdge(p,after);
        }
 else {
          throw new InternalErrorException(""String_Node_Str"");
        }
      }
      Enumeration triggers=p.triggersPorts();
      while (triggers.hasMoreElements()) {
        IOPort outPort=(IOPort)triggers.nextElement();
        Enumeration inPortEnum=outPort.deepConnectedInPorts();
        while (inPortEnum.hasMoreElements()) {
          IOPort pp=(IOPort)inPortEnum.nextElement();
          if (_dag.contains(pp)) {
            _dag.addEdge(p,pp);
          }
 else {
            throw new InternalErrorException(""String_Node_Str"");
          }
        }
      }
    }
 else {
      Enumeration triggers=((Actor)ioPort.getContainer()).outputPorts();
      while (triggers.hasMoreElements()) {
        IOPort outPort=(IOPort)triggers.nextElement();
        Enumeration inPortEnum=outPort.deepConnectedInPorts();
        while (inPortEnum.hasMoreElements()) {
          IOPort pp=(IOPort)inPortEnum.nextElement();
          if (_dag.contains(pp)) {
            _dag.addEdge(ioPort,pp);
          }
 else {
            throw new InternalErrorException(""String_Node_Str"");
          }
        }
      }
    }
  }
}","private DirectedAcyclicGraph _constructDirectedGraph() throws IllegalActionException {
  LinkedList portList=new LinkedList();
  DirectedAcyclicGraph dag=new DirectedAcyclicGraph();
  CompositeActor container=((CompositeActor)getContainer());
  if (container != null) {
    Enumeration allactors=container.deepGetEntities();
    while (allactors.hasMoreElements()) {
      Actor actor=(Actor)allactors.nextElement();
      Enumeration allports=actor.inputPorts();
      while (allports.hasMoreElements()) {
        IOPort port=(IOPort)allports.nextElement();
        dag.add(port);
        portList.insertLast(port);
      }
    }
  }
  Enumeration copiedPorts=portList.elements();
  while (copiedPorts.hasMoreElements()) {
    IOPort ioPort=(IOPort)copiedPorts.nextElement();
    if (ioPort instanceof DEIOPort) {
      DEIOPort p=(DEIOPort)ioPort;
      Enumeration befores=p.beforePorts();
      while (befores.hasMoreElements()) {
        IOPort after=(IOPort)befores.nextElement();
        if (dag.contains(after)) {
          dag.addEdge(p,after);
        }
 else {
          throw new InternalErrorException(""String_Node_Str"");
        }
      }
      Enumeration triggers=p.triggersPorts();
      while (triggers.hasMoreElements()) {
        IOPort outPort=(IOPort)triggers.nextElement();
        Enumeration inPortEnum=outPort.deepConnectedInPorts();
        while (inPortEnum.hasMoreElements()) {
          IOPort pp=(IOPort)inPortEnum.nextElement();
          if (dag.contains(pp)) {
            dag.addEdge(p,pp);
          }
 else {
            throw new InternalErrorException(""String_Node_Str"");
          }
        }
      }
    }
 else {
      Enumeration triggers=((Actor)ioPort.getContainer()).outputPorts();
      while (triggers.hasMoreElements()) {
        IOPort outPort=(IOPort)triggers.nextElement();
        Enumeration inPortEnum=outPort.deepConnectedInPorts();
        while (inPortEnum.hasMoreElements()) {
          IOPort pp=(IOPort)inPortEnum.nextElement();
          if (dag.contains(pp)) {
            dag.addEdge(ioPort,pp);
          }
 else {
            throw new InternalErrorException(""String_Node_Str"");
          }
        }
      }
    }
    if (!dag.isAcyclic()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ioPort.getFullName());
    }
  }
  return dag;
}"
76391,"/** 
 * If the topological sort is not valid, then compute it.
 * @return True.
 * @exception IllegalActionException If the graph has a zerodelay loop.
 */
public boolean prefire() throws IllegalActionException {
  if (!_sortValid) {
    _constructDirectedGraph();
    if (!_dag.isAcyclic()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  return super.prefire();
}","/** 
 * If the topological sort is not valid, then compute it.
 * @return True.
 * @exception IllegalActionException If the graph has a zerodelay loop.
 */
public boolean prefire() throws IllegalActionException {
  if (!_sortValid) {
    _computeDepth();
  }
  return super.prefire();
}"
76392,"/** 
 * Set current time to zero, calculate priorities for simultaneous events, and invoke the initialize() methods of all actors deeply contained by the container.  To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their initialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If there is a delay-free loop, orif the initialize() method of the container or one of the deeply contained actors throws it.
 */
public void initialize() throws IllegalActionException {
  _eventQueue.clear();
  _dag=new DirectedAcyclicGraph();
  _deadActors=null;
  _currentTime=0.0;
  _noMoreActorsToFire=false;
  _startTime=Double.MAX_VALUE;
  _isInitialized=false;
  super.initialize();
  _isInitialized=true;
  _computeDepth();
  if (_isEmbedded() && !_eventQueue.isEmpty()) {
    _requestFiring();
  }
}","/** 
 * Set current time to zero, calculate priorities for simultaneous events, and invoke the initialize() methods of all actors deeply contained by the container.  To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their initialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If there is a delay-free loop, orif the initialize() method of the container or one of the deeply contained actors throws it.
 */
public void initialize() throws IllegalActionException {
  _eventQueue.clear();
  _deadActors=null;
  _currentTime=0.0;
  _noMoreActorsToFire=false;
  _startTime=Double.MAX_VALUE;
  _isInitialized=false;
  super.initialize();
  _isInitialized=true;
  _computeDepth();
  if (_isEmbedded() && !_eventQueue.isEmpty()) {
    _requestFiring();
  }
}"
76393,"private void _computeDepth(){
  Object[] sort=(Object[])_dag.topologicalSort();
  if (DEBUG) {
    System.out.println(""String_Node_Str"");
  }
  for (int i=sort.length - 1; i >= 0; i--) {
    IOPort p=(IOPort)sort[i];
    if (DEBUG) {
      System.out.println(p.description(FULLNAME) + ""String_Node_Str"" + i);
    }
    Receiver[][] r;
    try {
      r=p.getReceivers();
    }
 catch (    IllegalActionException e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (r == null) {
      continue;
    }
    for (int j=r.length - 1; j >= 0; j--) {
      for (int k=r[j].length - 1; k >= 0; k--) {
        DEReceiver der=(DEReceiver)r[j][k];
        der._setDepth(i);
      }
    }
  }
}","private void _computeDepth() throws IllegalActionException {
  DirectedAcyclicGraph dag=_constructDirectedGraph();
  Object[] sort=(Object[])dag.topologicalSort();
  _debug(""String_Node_Str"");
  for (int i=sort.length - 1; i >= 0; i--) {
    IOPort p=(IOPort)sort[i];
    _debug(p.getFullName() + ""String_Node_Str"" + i);
    Receiver[][] r;
    try {
      r=p.getReceivers();
    }
 catch (    IllegalActionException e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (r == null) {
      continue;
    }
    for (int j=r.length - 1; j >= 0; j--) {
      for (int k=r[j].length - 1; k >= 0; k--) {
        DEReceiver der=(DEReceiver)r[j][k];
        der._setDepth(i);
      }
    }
  }
}"
76394,"/** 
 */
public boolean postfire() throws IllegalActionException {
  generateEvents(new ExecEvent(this,2));
  try {
    Thread.sleep(100);
  }
 catch (  InterruptedException e) {
    throw new InternalErrorException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  return super.postfire();
}","/** 
 */
public boolean postfire() throws IllegalActionException {
  generateEvents(new ExecEvent(this,2));
  try {
    Thread.sleep(100);
  }
 catch (  InterruptedException e) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return super.postfire();
}"
76395,"/** 
 */
public boolean prefire() throws IllegalActionException {
  generateEvents(new ExecEvent(this,1));
  try {
    Thread.sleep(100);
  }
 catch (  InterruptedException e) {
    throw new InternalErrorException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  return super.prefire();
}","/** 
 */
public boolean prefire() throws IllegalActionException {
  generateEvents(new ExecEvent(this,1));
  try {
    Thread.sleep(100);
  }
 catch (  InterruptedException e) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return super.prefire();
}"
76396,"/** 
 */
public boolean postfire() throws IllegalActionException {
  generateEvents(new ExecEvent(this,2));
  try {
    Thread.sleep(100);
  }
 catch (  InterruptedException e) {
    throw new InternalErrorException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  return super.postfire();
}","/** 
 */
public boolean postfire() throws IllegalActionException {
  generateEvents(new ExecEvent(this,2));
  try {
    Thread.sleep(100);
  }
 catch (  InterruptedException e) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return super.postfire();
}"
76397,"/** 
 */
public boolean prefire() throws IllegalActionException {
  generateEvents(new ExecEvent(this,1));
  try {
    Thread.sleep(100);
  }
 catch (  InterruptedException e) {
    throw new InternalErrorException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  return super.prefire();
}","/** 
 */
public boolean prefire() throws IllegalActionException {
  generateEvents(new ExecEvent(this,1));
  try {
    Thread.sleep(100);
  }
 catch (  InterruptedException e) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return super.prefire();
}"
76398,"public void run(){
  LevelLayout staticLayout=new LevelLayout();
  staticLayout.setOrientation(LevelLayout.HORIZONTAL);
  staticLayout.layout(gv,m.getGraph());
  gp.repaint();
}","public void run(){
switch (state) {
case 1:
    figure.setFillPaint(Color.yellow);
  break;
case 2:
figure.setFillPaint(Color.green);
break;
case 3:
figure.setFillPaint(Color.red);
break;
default :
System.out.println(""String_Node_Str"" + state);
}
}"
76399,"/** 
 * Respond to a state changed event.
 */
public void stateChanged(ExecEvent event){
}","/** 
 * Respond to a state changed event.
 */
public void stateChanged(ExecEvent event){
  final int state=event.getCurrentState();
  Actor actor=event.getActor();
  String name=((Nameable)actor).getName();
  Node node=(Node)_nodeMap.get(actor);
  LabelWrapper wrapper=(LabelWrapper)_graphPane.getGraphView().getNodeFigure(node);
  final BasicFigure figure=(BasicFigure)wrapper.getChild();
  try {
    SwingUtilities.invokeAndWait(new Runnable(){
      public void run(){
switch (state) {
case 1:
          figure.setFillPaint(Color.yellow);
        break;
case 2:
      figure.setFillPaint(Color.green);
    break;
case 3:
  figure.setFillPaint(Color.red);
break;
default :
System.out.println(""String_Node_Str"" + state);
}
}
}
);
}
 catch (Exception e) {
e.printStackTrace();
}
}"
76400,"/** 
 * Initialize the applet. After calling the base class init() method, this method creates a director which is accessible to derived  classes via a protected member. If the applet ""stopTime"" parameter  is given, then set the director stop time to its value. If this  parameter is not given, then create an entry box on screen to query  the user for the stop time.
 */
public void init(){
  super.init();
  try {
    _director=new DDEDirector(_toplevel,""String_Node_Str"");
    String stopSpec=getParameter(""String_Node_Str"");
    if (stopSpec != null) {
      double stopTime=(new Double(stopSpec)).doubleValue();
      _stopTimeGiven=true;
      Parameter dirStopTime=(Parameter)_director.getAttribute(""String_Node_Str"");
      dirStopTime.setToken(new DoubleToken(stopTime));
    }
  }
 catch (  IllegalActionException ex) {
    report(""String_Node_Str"",ex);
  }
catch (  Exception ex) {
    report(""String_Node_Str"" + ""String_Node_Str"",ex);
  }
}","/** 
 * Initialize the applet. After calling the base class init() method, this method creates a director which is accessible to derived  classes via a protected member. If the applet ""stopTime"" parameter  is given, then set the director stop time to its value. If this  parameter is not given, then create an entry box on screen to query  the user for the stop time.
 */
public void init(){
  super.init();
  try {
    _director=new DDEDirector(_toplevel,""String_Node_Str"");
    String stopSpec=getSingleParameter(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + stopSpec);
    if (stopSpec != null) {
      double stopTime=(new Double(stopSpec)).doubleValue();
      _stopTimeGiven=true;
      Parameter dirStopTime=(Parameter)_director.getAttribute(""String_Node_Str"");
      dirStopTime.setToken(new DoubleToken(stopTime));
    }
  }
 catch (  IllegalActionException ex) {
    report(""String_Node_Str"",ex);
  }
catch (  Exception ex) {
    report(""String_Node_Str"" + ""String_Node_Str"",ex);
  }
}"
76401,"/** 
 * In addition to creating the buttons provided by the base  class, if the stop time has not been specified by the  applet parameter ""stopTime,"" then create an entry box for  that number to be entered. If the ""showStopTime"" parameter  is set to true, then display a text entry box for specifying  the stop time of the model. The panel containing the buttons  and the entry box is returned.
 * @param numbuttons The number of buttons to create.
 * @param showStopTime A flag indicating whether stop timeselection box should be displayed.
 * @return The panel containing the controls.
 */
protected Panel _createRunControls(int numbuttons,boolean showStopTime){
  Panel panel=_createRunControls(numbuttons);
  if (showStopTime) {
    Panel stopTimePanel=new Panel();
    stopTimePanel.add(new Label(""String_Node_Str""));
    String defaultStopSpec=getParameter(""String_Node_Str"");
    if (defaultStopSpec == null) {
      defaultStopSpec=""String_Node_Str"";
    }
    _stopTimeBox=new TextField(defaultStopSpec,10);
    _stopTimeBox.addActionListener(new StopTimeBoxListener());
    stopTimePanel.add(_stopTimeBox);
    panel.add(stopTimePanel);
  }
  return panel;
}","/** 
 * In addition to creating the buttons provided by the base  class, if the stop time has not been specified by the  applet parameter ""stopTime,"" then create an entry box for  that number to be entered. If the ""showStopTime"" parameter  is set to true, then display a text entry box for specifying  the stop time of the model. The panel containing the buttons  and the entry box is returned.
 * @param numbuttons The number of buttons to create.
 * @param showStopTime A flag indicating whether stop timeselection box should be displayed.
 * @return The panel containing the controls.
 */
protected Panel _createRunControls(int numbuttons){
  Panel panel=super._createRunControls(numbuttons);
  if (!_stopTimeGiven) {
    Panel stopTimePanel=new Panel();
    stopTimePanel.add(new Label(""String_Node_Str""));
    String defaultStopSpec=getSingleParameter(""String_Node_Str"");
    if (defaultStopSpec == null) {
      defaultStopSpec=""String_Node_Str"";
    }
    _stopTimeBox=new TextField(defaultStopSpec,10);
    _stopTimeBox.addActionListener(new StopTimeBoxListener());
    stopTimePanel.add(_stopTimeBox);
    panel.add(stopTimePanel);
  }
  return panel;
}"
76402,"/** 
 * Describe the applet parameters.
 * @return An array describing the applet parameters.
 */
public String[][] getParameterInfo(){
  String newinfo[][]={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  return _concatStringArrays(super.getParameterInfo(),newinfo);
}","/** 
 * Describe the applet parameters.
 * @return An array describing the applet parameters.
 */
public String[][] getParameterInfo(){
  if (_params == null) {
    String newinfo[][]={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
    _params=_concatStringArrays(super.getParameterInfo(),newinfo);
  }
  return _params;
}"
76403,"/** 
 * Reset local flags. The local flag of this receiver indicates whether this receiver is scheduled for termination. Resetting the termination flag will make sure that this receiver is not scheduled for termination.
 */
public void reset(){
  _terminate=false;
}","/** 
 * Reset local flags. The local flag of this receiver indicates whether this receiver is scheduled for termination. Resetting the termination flag will make sure that this receiver is not scheduled for termination. FIXME
 */
public void reset(){
  _terminate=false;
  _readPending=false;
  _writePending=false;
  _ignoreNotSeen=true;
  clearRcvr();
  Director director=((Actor)getContainer().getContainer()).getDirector();
  String name=((Nameable)getContainer().getContainer()).getName();
  System.out.println(name + ""String_Node_Str"");
  setRcvrTime(0.0);
}"
76404,"/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense. FIXME: This method destroys the firing vector.  This is not nice.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A CircularList of the Actors in the order they should fire.
 * @exception InvalidStateException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state.
 */
private CircularList _scheduleConnectedActors(CircularList actorList){
  CircularList readyToScheduleActorList=new CircularList();
  CircularList newSchedule=new CircularList();
  boolean done=false;
  LLMap waitingTokens=new LLMap();
  CircularList unscheduledActorList=new CircularList();
  unscheduledActorList.appendElements(actorList.elements());
  Enumeration schedulableEntities=actorList.elements();
  try {
    while (schedulableEntities.hasMoreElements()) {
      Actor a=(Actor)schedulableEntities.nextElement();
      Enumeration ainputports=a.inputPorts();
      while (ainputports.hasMoreElements()) {
        IOPort ainputport=(IOPort)ainputports.nextElement();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.putAt(ainputport,tokencount);
        Enumeration crelations=ainputport.linkedRelations();
        int channelNumber=0;
        while (crelations.hasMoreElements()) {
          IORelation crelation=(IORelation)crelations.nextElement();
          Enumeration cports=crelation.linkedSourcePorts();
          IOPort cport=(IOPort)cports.nextElement();
          if (cports.hasMoreElements())           throw new IllegalActionException(crelation,cport,""String_Node_Str"" + ""String_Node_Str"");
          ComponentEntity cactor=(ComponentEntity)cport.getContainer();
          int rate=_getTokenInitProduction(cport);
          if (rate > 0) {
            for (int j=0; j < crelation.getWidth(); j++)             tokencount[channelNumber++]+=_getTokenProductionRate(cport);
          }
        }
      }
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.insertFirst((ComponentEntity)a);
      _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ (new Integer(inputCount)).toString()+ ""String_Node_Str"");
    }
    while (!done) {
      _debug(""String_Node_Str"");
      _debug(waitingTokens.toString());
      _debug(""String_Node_Str"");
      Enumeration actorsLeft=readyToScheduleActorList.elements();
      while (actorsLeft.hasMoreElements()) {
        Entity e=(Entity)actorsLeft.nextElement();
        _debug(e.getFullName());
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.at(0);
      readyToScheduleActorList.removeAt(0);
      _debug(""String_Node_Str"" + currentActor.getName());
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.insertLast(currentActor);
      Enumeration aOutputPorts=((Actor)currentActor).outputPorts();
      while (aOutputPorts.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.nextElement();
        Integer createdTokens=new Integer(_getTokenProductionRate(aOutputPort));
        _simulateTokensCreated(aOutputPort,actorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=_getFiringCount(currentActor);
      firingsRemaining-=1;
      _setFiringCount(currentActor,firingsRemaining);
      _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          unscheduledActorList.removeOneOf(currentActor);
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1)           readyToScheduleActorList.insertLast(currentActor);
        }
      }
    }
  }
 catch (  NoSuchElementException e) {
    _debug(""String_Node_Str"");
    _debug(e.getMessage());
    done=true;
  }
catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    _debug(""String_Node_Str"");
  }
  Enumeration eschedule=newSchedule.elements();
  _debug(""String_Node_Str"");
  while (eschedule.hasMoreElements())   _debug(((ComponentEntity)eschedule.nextElement()).toString());
  return newSchedule;
}","/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense. FIXME: This method destroys the firing vector.  This is not nice.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A CircularList of the Actors in the order they should fire.
 * @exception InvalidStateException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state.
 */
private CircularList _scheduleConnectedActors(CircularList actorList){
  CircularList readyToScheduleActorList=new CircularList();
  CircularList newSchedule=new CircularList();
  boolean done=false;
  LLMap waitingTokens=new LLMap();
  CircularList unscheduledActorList=new CircularList();
  unscheduledActorList.appendElements(actorList.elements());
  Enumeration schedulableEntities=actorList.elements();
  try {
    while (schedulableEntities.hasMoreElements()) {
      Actor a=(Actor)schedulableEntities.nextElement();
      Enumeration ainputports=a.inputPorts();
      while (ainputports.hasMoreElements()) {
        IOPort ainputport=(IOPort)ainputports.nextElement();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.putAt(ainputport,tokencount);
        Enumeration crelations=ainputport.linkedRelations();
        int channelNumber=0;
        while (crelations.hasMoreElements()) {
          IORelation crelation=(IORelation)crelations.nextElement();
          Enumeration cports=crelation.linkedSourcePorts();
          IOPort cport=(IOPort)cports.nextElement();
          if (cports.hasMoreElements())           throw new IllegalActionException(crelation,cport,""String_Node_Str"" + ""String_Node_Str"");
          ComponentEntity cactor=(ComponentEntity)cport.getContainer();
          int rate=_getTokenInitProduction(cport);
          if (rate > 0) {
            for (int j=0; j < crelation.getWidth(); j++)             tokencount[channelNumber++]+=_getTokenProductionRate(cport);
          }
        }
      }
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.insertFirst((ComponentEntity)a);
      _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ (new Integer(inputCount)).toString()+ ""String_Node_Str"");
    }
    while (!done) {
      _debug(""String_Node_Str"");
      _debug(waitingTokens.toString());
      _debug(""String_Node_Str"");
      Enumeration actorsLeft=readyToScheduleActorList.elements();
      while (actorsLeft.hasMoreElements()) {
        Entity e=(Entity)actorsLeft.nextElement();
        _debug(e.getFullName());
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.at(0);
      readyToScheduleActorList.exclude(currentActor);
      _debug(""String_Node_Str"" + currentActor.getName());
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.insertLast(currentActor);
      Enumeration aOutputPorts=((Actor)currentActor).outputPorts();
      while (aOutputPorts.hasMoreElements()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.nextElement();
        Integer createdTokens=new Integer(_getTokenProductionRate(aOutputPort));
        _simulateTokensCreated(aOutputPort,actorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=_getFiringCount(currentActor);
      firingsRemaining-=1;
      _setFiringCount(currentActor,firingsRemaining);
      _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          unscheduledActorList.removeOneOf(currentActor);
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1)           readyToScheduleActorList.insertLast(currentActor);
        }
      }
    }
  }
 catch (  NoSuchElementException e) {
    _debug(""String_Node_Str"");
    _debug(e.getMessage());
    done=true;
  }
catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    _debug(""String_Node_Str"");
  }
  Enumeration eschedule=newSchedule.elements();
  _debug(""String_Node_Str"");
  while (eschedule.hasMoreElements())   _debug(((ComponentEntity)eschedule.nextElement()).toString());
  return newSchedule;
}"
76405,"public Delay(TypedCompositeActor container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  try {
    TypedIOPort input=(TypedIOPort)newPort(""String_Node_Str"");
    input.setInput(true);
    setTokenConsumptionRate(input,1);
    input.setTypeEquals(Token.class);
    TypedIOPort output=(TypedIOPort)newPort(""String_Node_Str"");
    output.setOutput(true);
    setTokenProductionRate(output,1);
    output.setTypeEquals(Token.class);
    setTokenInitProduction(output,1);
  }
 catch (  IllegalActionException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
}","public Delay(TypedCompositeActor container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  try {
    input=(TypedIOPort)newPort(""String_Node_Str"");
    input.setInput(true);
    setTokenConsumptionRate(input,1);
    input.setTypeEquals(Token.class);
    output=(TypedIOPort)newPort(""String_Node_Str"");
    output.setOutput(true);
    setTokenProductionRate(output,1);
    output.setTypeEquals(Token.class);
    setTokenInitProduction(output,1);
  }
 catch (  IllegalActionException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
    throw e1;
  }
}"
76406,"/** 
 * Construct the graph representing the PN topology. This is sort of bogus because it's totally hird-wired, but it will do for now...
 */
public GraphModel constructThreadGraph(){
  GraphModel model=new GraphModel();
  Node n1=model.createNode(a1);
  Node n2=model.createNode(a2);
  Node n3=model.createNode(a3);
  Node n4=model.createNode(a4);
  Node n5=model.createNode(a5);
  Node n6=model.createNode(a6);
  Node n7=model.createNode(a7);
  Node n8=model.createNode(a8);
  model.addNode(n1);
  model.addNode(n2);
  model.addNode(n3);
  model.addNode(n4);
  model.addNode(n5);
  model.addNode(n6);
  model.addNode(n7);
  model.addNode(n8);
  nodeMap.put(a1,n1);
  nodeMap.put(a2,n2);
  nodeMap.put(a3,n3);
  nodeMap.put(a4,n4);
  nodeMap.put(a5,n5);
  nodeMap.put(a6,n6);
  nodeMap.put(a7,n7);
  nodeMap.put(a8,n8);
  model.createEdge(n1,n2);
  model.createEdge(n2,n3);
  model.createEdge(n3,n4);
  model.createEdge(n4,n5);
  model.createEdge(n5,n6);
  model.createEdge(n1,n7);
  model.createEdge(n5,n8);
  return model;
}","/** 
 * Construct the graph representing the PN topology. This is sort of bogus because it's totally hird-wired, but it will do for now...
 */
public GraphModel constructThreadGraph(){
  GraphModel model=new GraphModel();
  Node n1=model.createNode(a1);
  Node n2=model.createNode(a2);
  Node n3=model.createNode(a3);
  Node n4=model.createNode(a4);
  Node n5=model.createNode(a5);
  Node n6=model.createNode(a6);
  Node n7=model.createNode(a7);
  Node n8=model.createNode(a8);
  model.addNode(n1);
  model.addNode(n2);
  model.addNode(n3);
  model.addNode(n4);
  model.addNode(n5);
  model.addNode(n6);
  model.addNode(n7);
  model.addNode(n8);
  _nodeMap.put(a1,n1);
  _nodeMap.put(a2,n2);
  _nodeMap.put(a3,n3);
  _nodeMap.put(a4,n4);
  _nodeMap.put(a5,n5);
  _nodeMap.put(a6,n6);
  _nodeMap.put(a7,n7);
  _nodeMap.put(a8,n8);
  model.createEdge(n1,n2);
  model.createEdge(n2,n3);
  model.createEdge(n3,n4);
  model.createEdge(n4,n5);
  model.createEdge(n5,n6);
  model.createEdge(n1,n7);
  model.createEdge(n5,n8);
  return model;
}"
76407,"/** 
 * Construct the trace display.
 */
public void displayTrace(TraceModel traceModel){
  traceWindow=new TutorialWindow(""String_Node_Str"");
  tracePane=new TracePane();
  JCanvas traceWidget=new JCanvas(tracePane);
  TraceView traceView=tracePane.getTraceView();
  traceView.setTimeScale(0.02);
  traceView.setLayout(10,10,500,30,5);
  traceView.setTraceModel(traceModel);
  traceWindow.getContentPane().add(""String_Node_Str"",traceWidget);
  traceWindow.setSize(800,300);
  traceWindow.setLocation(300,300);
  traceWindow.setVisible(true);
}","/** 
 * Construct the trace display.
 */
public void displayTrace(TraceModel traceModel){
  _traceWindow=new TutorialWindow(""String_Node_Str"");
  _tracePan=new TracePane();
  JCanvas traceWidget=new JCanvas(_tracePan);
  TraceView traceView=_tracePan.getTraceView();
  traceView.setTimeScale(0.02);
  traceView.setLayout(10,10,500,30,5);
  traceView.setTraceModel(traceModel);
  _traceWindow.getContentPane().add(""String_Node_Str"",traceWidget);
  _traceWindow.setSize(800,300);
  _traceWindow.setLocation(300,300);
  _traceWindow.setVisible(true);
}"
76408,"/** 
 * Respond to a state changed event.
 */
public void processStateChanged(PNProcessEvent event){
  final int state=event.getCurrentState();
  Actor actor=event.getActor();
  Node node=(Node)nodeMap.get(actor);
  LabelWrapper wrapper=(LabelWrapper)_graphPane.getGraphView().getNodeFigure(node);
  final BasicFigure figure=(BasicFigure)wrapper.getChild();
  try {
    SwingUtilities.invokeAndWait(new Runnable(){
      public void run(){
switch (state) {
case PNProcessEvent.PROCESS_BLOCKED:
          figure.setFillPaint(Color.red);
        break;
case PNProcessEvent.PROCESS_FINISHED:
      figure.setFillPaint(Color.black);
    break;
case PNProcessEvent.PROCESS_PAUSED:
  figure.setFillPaint(Color.yellow);
break;
case PNProcessEvent.PROCESS_RUNNING:
figure.setFillPaint(Color.green);
break;
default :
System.out.println(""String_Node_Str"" + state);
}
}
}
);
}
 catch (Exception e) {
}
ComponentEntity ce=(ComponentEntity)actor;
String name=ce.getName();
TraceModel model=tracePane.getTraceView().getTraceModel();
TraceModel.Trace trace=model.getTrace(name);
int id=trace.getID();
int colorState=3;
switch (state) {
case PNProcessEvent.PROCESS_BLOCKED:
colorState=0;
break;
case PNProcessEvent.PROCESS_FINISHED:
colorState=7;
break;
case PNProcessEvent.PROCESS_PAUSED:
colorState=2;
break;
case PNProcessEvent.PROCESS_RUNNING:
colorState=3;
break;
}
double currentTime=(double)(System.currentTimeMillis() - _start);
final TraceModel.Element element=new TraceModel.Element(currentTime,currentTime + 1,colorState);
element.closure=TraceModel.Element.OPEN_END;
trace.add(element);
final TraceModel.Element current=_currentElement[id];
current.closure=0;
final int msize=model.size();
final TraceModel.Element temp[]=new TraceModel.Element[msize];
for (int i=0; i < msize; i++) {
_currentElement[i].stopTime=currentTime;
temp[i]=_currentElement[i];
}
try {
SwingUtilities.invokeAndWait(new Runnable(){
public void run(){
TraceView v=tracePane.getTraceView();
for (int i=0; i < msize; i++) {
v.updateTraceElement(temp[i]);
}
v.drawTraceElement(element);
}
}
);
}
 catch (Exception e) {
System.out.println(e);
}
_currentElement[id]=element;
}","/** 
 * Respond to a state changed event.
 */
public void processStateChanged(PNProcessEvent event){
  final int state=event.getCurrentState();
  Actor actor=event.getActor();
  Node node=(Node)_nodeMap.get(actor);
  LabelWrapper wrapper=(LabelWrapper)_graphPane.getGraphView().getNodeFigure(node);
  final BasicFigure figure=(BasicFigure)wrapper.getChild();
  try {
    SwingUtilities.invokeAndWait(new Runnable(){
      public void run(){
switch (state) {
case PNProcessEvent.PROCESS_BLOCKED:
          figure.setFillPaint(Color.red);
        break;
case PNProcessEvent.PROCESS_FINISHED:
      figure.setFillPaint(Color.black);
    break;
case PNProcessEvent.PROCESS_PAUSED:
  figure.setFillPaint(Color.yellow);
break;
case PNProcessEvent.PROCESS_RUNNING:
figure.setFillPaint(Color.green);
break;
default :
System.out.println(""String_Node_Str"" + state);
}
}
}
);
}
 catch (Exception e) {
}
ComponentEntity ce=(ComponentEntity)actor;
String name=ce.getName();
TraceModel model=_tracePan.getTraceView().getTraceModel();
TraceModel.Trace trace=model.getTrace(name);
int id=trace.getID();
int colorState=3;
switch (state) {
case PNProcessEvent.PROCESS_BLOCKED:
colorState=0;
break;
case PNProcessEvent.PROCESS_FINISHED:
colorState=7;
break;
case PNProcessEvent.PROCESS_PAUSED:
colorState=2;
break;
case PNProcessEvent.PROCESS_RUNNING:
colorState=3;
break;
}
double currentTime=(double)(System.currentTimeMillis() - _start);
final TraceModel.Element element=new TraceModel.Element(currentTime,currentTime + 1,colorState);
element.closure=TraceModel.Element.OPEN_END;
trace.add(element);
final TraceModel.Element current=_currentElement[id];
current.closure=0;
final int msize=model.size();
final TraceModel.Element temp[]=new TraceModel.Element[msize];
for (int i=0; i < msize; i++) {
_currentElement[i].stopTime=currentTime;
temp[i]=_currentElement[i];
}
try {
SwingUtilities.invokeAndWait(new Runnable(){
public void run(){
TraceView v=_tracePan.getTraceView();
for (int i=0; i < msize; i++) {
v.updateTraceElement(temp[i]);
}
v.drawTraceElement(element);
}
}
);
}
 catch (Exception e) {
System.out.println(e);
}
_currentElement[id]=element;
}"
76409,"public StateListener(GraphPane pane){
  _graphPane=pane;
  _start=System.currentTimeMillis();
  TraceModel model=tracePane.getTraceModel();
  _currentElement=new TraceModel.Element[model.size()];
  for (int i=0; i < model.size(); i++) {
    TraceModel.Trace trace=model.getTrace(i);
    final TraceModel.Element element=new TraceModel.Element(0,1,3);
    element.closure=TraceModel.Element.OPEN_END;
    trace.add(element);
    _currentElement[i]=element;
    try {
      SwingUtilities.invokeAndWait(new Runnable(){
        public void run(){
          tracePane.getTraceView().drawTraceElement(element);
        }
      }
);
    }
 catch (    Exception e) {
      System.out.println(e);
    }
  }
}","public StateListener(GraphPane pane){
  _graphPane=pane;
  _start=System.currentTimeMillis();
  TraceModel model=_tracePan.getTraceModel();
  _currentElement=new TraceModel.Element[model.size()];
  for (int i=0; i < model.size(); i++) {
    TraceModel.Trace trace=model.getTrace(i);
    final TraceModel.Element element=new TraceModel.Element(0,1,3);
    element.closure=TraceModel.Element.OPEN_END;
    trace.add(element);
    _currentElement[i]=element;
    try {
      SwingUtilities.invokeAndWait(new Runnable(){
        public void run(){
          _tracePan.getTraceView().drawTraceElement(element);
        }
      }
);
    }
 catch (    Exception e) {
      System.out.println(e);
    }
  }
}"
76410,"public void run(){
  TraceView v=tracePane.getTraceView();
  for (int i=0; i < msize; i++) {
    v.updateTraceElement(temp[i]);
  }
  v.drawTraceElement(element);
}","public void run(){
  TraceView v=_tracePan.getTraceView();
  for (int i=0; i < msize; i++) {
    v.updateTraceElement(temp[i]);
  }
  v.drawTraceElement(element);
}"
76411,"/** 
 * Construct the graph widget with the default constructor (giving it an empty graph), and then set the model once the window is showing.
 */
public void displayGraph(JGraph g,GraphModel model){
  window=new TutorialWindow(""String_Node_Str"");
  window.getContentPane().add(""String_Node_Str"",g);
  window.setSize(800,300);
  window.setLocation(20,20);
  window.setVisible(true);
  GraphPane gp=(GraphPane)g.getCanvasPane();
  GraphView gv=gp.getGraphView();
  gv.setNodeRenderer(new ThreadRenderer());
  g.setGraphModel(model);
  LevelLayout staticLayout=new LevelLayout();
  staticLayout.setOrientation(LevelLayout.HORIZONTAL);
  staticLayout.layout(gv,model.getGraph());
  gp.repaint();
}","/** 
 * Construct the graph widget with the default constructor (giving it an empty graph), and then set the model once the window is showing.
 */
public void displayGraph(JGraph g,GraphModel model){
  _window=new TutorialWindow(""String_Node_Str"");
  _window.getContentPane().add(""String_Node_Str"",g);
  _window.setSize(800,300);
  _window.setLocation(20,20);
  _window.setVisible(true);
  GraphPane gp=(GraphPane)g.getCanvasPane();
  GraphView gv=gp.getGraphView();
  gv.setNodeRenderer(new ThreadRenderer());
  g.setGraphModel(model);
  LevelLayout staticLayout=new LevelLayout();
  staticLayout.setOrientation(LevelLayout.HORIZONTAL);
  staticLayout.layout(gv,model.getGraph());
  gp.repaint();
}"
76412,"synchronized void _zoomBox(int x,int y){
  Graphics graphics=getGraphics();
  if (y > _lry)   y=_lry;
  if (y < _uly)   y=_uly;
  if (x > _lrx)   x=_lrx;
  if (x < _ulx)   x=_ulx;
  if ((_zoomx != -1 || _zoomy != -1)) {
    if (_zoomin == false && _zoomout == false) {
      if (y < _zoomy) {
        _zoomout=true;
        graphics.drawRect(_zoomx - 15,_zoomy - 15,30,30);
      }
 else       if (y > _zoomy) {
        _zoomin=true;
      }
    }
    if (_zoomin == true) {
      graphics.setXORMode(_background);
      if ((_zoomxn != -1 || _zoomyn != -1) && (_drawn == true)) {
        int minx=Math.min(_zoomx,_zoomxn);
        int maxx=Math.max(_zoomx,_zoomxn);
        int miny=Math.min(_zoomy,_zoomyn);
        int maxy=Math.max(_zoomy,_zoomyn);
        graphics.drawRect(minx,miny,maxx - minx,maxy - miny);
      }
      if (y > _zoomy) {
        _zoomxn=x;
        _zoomyn=y;
        int minx=Math.min(_zoomx,_zoomxn);
        int maxx=Math.max(_zoomx,_zoomxn);
        int miny=Math.min(_zoomy,_zoomyn);
        int maxy=Math.max(_zoomy,_zoomyn);
        graphics.drawRect(minx,miny,maxx - minx,maxy - miny);
        graphics.setPaintMode();
        _drawn=true;
        return;
      }
 else       _drawn=false;
    }
 else     if (_zoomout == true) {
      graphics.setXORMode(_background);
      if ((_zoomxn != -1 || _zoomyn != -1) && (_drawn == true)) {
        int x_diff=Math.abs(_zoomx - _zoomxn);
        int y_diff=Math.abs(_zoomy - _zoomyn);
        graphics.drawRect(_zoomx - 15 - x_diff,_zoomy - 15 - y_diff,30 + x_diff * 2,30 + y_diff * 2);
      }
      if (y < _zoomy) {
        _zoomxn=x;
        _zoomyn=y;
        int x_diff=Math.abs(_zoomx - _zoomxn);
        int y_diff=Math.abs(_zoomy - _zoomyn);
        graphics.drawRect(_zoomx - 15 - x_diff,_zoomy - 15 - y_diff,30 + x_diff * 2,30 + y_diff * 2);
        graphics.setPaintMode();
        _drawn=true;
        return;
      }
 else       _drawn=false;
    }
  }
  graphics.setPaintMode();
}","synchronized void _zoomBox(int x,int y){
  Graphics graphics=getGraphics();
  if (y > _lry)   y=_lry;
  if (y < _uly)   y=_uly;
  if (x > _lrx)   x=_lrx;
  if (x < _ulx)   x=_ulx;
  if ((_zoomx != -1 || _zoomy != -1)) {
    if (_zoomin == false && _zoomout == false) {
      if (y < _zoomy) {
        _zoomout=true;
        graphics.setXORMode(_boxColor);
        graphics.drawRect(_zoomx - 15,_zoomy - 15,30,30);
      }
 else       if (y > _zoomy) {
        _zoomin=true;
      }
    }
    if (_zoomin == true) {
      if ((_zoomxn != -1 || _zoomyn != -1) && (_drawn == true)) {
        int minx=Math.min(_zoomx,_zoomxn);
        int maxx=Math.max(_zoomx,_zoomxn);
        int miny=Math.min(_zoomy,_zoomyn);
        int maxy=Math.max(_zoomy,_zoomyn);
        graphics.setXORMode(_boxColor);
        graphics.drawRect(minx,miny,maxx - minx,maxy - miny);
      }
      if (y > _zoomy) {
        _zoomxn=x;
        _zoomyn=y;
        int minx=Math.min(_zoomx,_zoomxn);
        int maxx=Math.max(_zoomx,_zoomxn);
        int miny=Math.min(_zoomy,_zoomyn);
        int maxy=Math.max(_zoomy,_zoomyn);
        graphics.setXORMode(_boxColor);
        graphics.drawRect(minx,miny,maxx - minx,maxy - miny);
        _drawn=true;
        return;
      }
 else       _drawn=false;
    }
 else     if (_zoomout == true) {
      if ((_zoomxn != -1 || _zoomyn != -1) && (_drawn == true)) {
        int x_diff=Math.abs(_zoomx - _zoomxn);
        int y_diff=Math.abs(_zoomy - _zoomyn);
        graphics.setXORMode(_boxColor);
        graphics.drawRect(_zoomx - 15 - x_diff,_zoomy - 15 - y_diff,30 + x_diff * 2,30 + y_diff * 2);
      }
      if (y < _zoomy) {
        _zoomxn=x;
        _zoomyn=y;
        int x_diff=Math.abs(_zoomx - _zoomxn);
        int y_diff=Math.abs(_zoomy - _zoomyn);
        graphics.setXORMode(_boxColor);
        graphics.drawRect(_zoomx - 15 - x_diff,_zoomy - 15 - y_diff,30 + x_diff * 2,30 + y_diff * 2);
        _drawn=true;
        return;
      }
 else       _drawn=false;
    }
  }
  graphics.setPaintMode();
}"
76413,"synchronized void _zoom(int x,int y){
  Graphics graphics=getGraphics();
  boolean handled=false;
  if ((_zoomin == true) && (_drawn == true)) {
    if (_zoomxn != -1 || _zoomyn != -1) {
      int minx=Math.min(_zoomx,_zoomxn);
      int maxx=Math.max(_zoomx,_zoomxn);
      int miny=Math.min(_zoomy,_zoomyn);
      int maxy=Math.max(_zoomy,_zoomyn);
      graphics.setXORMode(_background);
      graphics.drawRect(minx,miny,maxx - minx,maxy - miny);
      graphics.setPaintMode();
      if (y > _lry)       y=_lry;
      if (y < _uly)       y=_uly;
      if (x > _lrx)       x=_lrx;
      if (x < _ulx)       x=_ulx;
      if ((Math.abs(_zoomx - x) > 5) && (Math.abs(_zoomy - y) > 5)) {
        double a=_xMin + (_zoomx - _ulx) / _xscale;
        double b=_xMin + (x - _ulx) / _xscale;
        if (a < b)         _setXRange(a,b);
 else         _setXRange(b,a);
        a=_yMax - (_zoomy - _uly) / _yscale;
        b=_yMax - (y - _uly) / _yscale;
        if (a < b)         _setYRange(a,b);
 else         _setYRange(b,a);
      }
      repaint();
      handled=true;
    }
  }
 else   if ((_zoomout == true) && (_drawn == true)) {
    graphics.setXORMode(_background);
    int x_diff=Math.abs(_zoomx - _zoomxn);
    int y_diff=Math.abs(_zoomy - _zoomyn);
    graphics.drawRect(_zoomx - 15 - x_diff,_zoomy - 15 - y_diff,30 + x_diff * 2,30 + y_diff * 2);
    graphics.setPaintMode();
    double a=(double)(Math.abs(_zoomx - x)) / 30.0;
    double b=(double)(Math.abs(_zoomy - y)) / 30.0;
    double newx1=_xMax + (_xMax - _xMin) * a;
    double newx2=_xMin - (_xMax - _xMin) * a;
    double newy1=_yMax + (_yMax - _yMin) * b;
    double newy2=_yMin - (_yMax - _yMin) * b;
    zoom(newx2,newy2,newx1,newy1);
    handled=true;
  }
 else   if (_drawn == false) {
    repaint();
    handled=true;
  }
  _drawn=false;
  _zoomin=_zoomout=false;
  _zoomxn=_zoomyn=_zoomx=_zoomy=-1;
}","synchronized void _zoom(int x,int y){
  Graphics graphics=getGraphics();
  boolean handled=false;
  if ((_zoomin == true) && (_drawn == true)) {
    if (_zoomxn != -1 || _zoomyn != -1) {
      int minx=Math.min(_zoomx,_zoomxn);
      int maxx=Math.max(_zoomx,_zoomxn);
      int miny=Math.min(_zoomy,_zoomyn);
      int maxy=Math.max(_zoomy,_zoomyn);
      graphics.setXORMode(_boxColor);
      graphics.drawRect(minx,miny,maxx - minx,maxy - miny);
      graphics.setPaintMode();
      if (y > _lry)       y=_lry;
      if (y < _uly)       y=_uly;
      if (x > _lrx)       x=_lrx;
      if (x < _ulx)       x=_ulx;
      if ((Math.abs(_zoomx - x) > 5) && (Math.abs(_zoomy - y) > 5)) {
        double a=_xMin + (_zoomx - _ulx) / _xscale;
        double b=_xMin + (x - _ulx) / _xscale;
        if (a < b)         setXRange(a,b);
 else         setXRange(b,a);
        a=_yMax - (_zoomy - _uly) / _yscale;
        b=_yMax - (y - _uly) / _yscale;
        if (a < b)         setYRange(a,b);
 else         setYRange(b,a);
      }
      repaint();
      handled=true;
    }
  }
 else   if ((_zoomout == true) && (_drawn == true)) {
    graphics.setXORMode(_boxColor);
    int x_diff=Math.abs(_zoomx - _zoomxn);
    int y_diff=Math.abs(_zoomy - _zoomyn);
    graphics.drawRect(_zoomx - 15 - x_diff,_zoomy - 15 - y_diff,30 + x_diff * 2,30 + y_diff * 2);
    graphics.setPaintMode();
    double a=(double)(Math.abs(_zoomx - x)) / 30.0;
    double b=(double)(Math.abs(_zoomy - y)) / 30.0;
    double newx1=_xMax + (_xMax - _xMin) * a;
    double newx2=_xMin - (_xMax - _xMin) * a;
    double newy1=_yMax + (_yMax - _yMin) * b;
    double newy2=_yMin - (_yMax - _yMin) * b;
    zoom(newx2,newy2,newx1,newy1);
    handled=true;
  }
 else   if (_drawn == false) {
    repaint();
    handled=true;
  }
  _drawn=false;
  _zoomin=_zoomout=false;
  _zoomxn=_zoomyn=_zoomx=_zoomy=-1;
}"
76414,"/** 
 * Given two array's of probabilities, calculate the relative entropy  aka Kullback Leibler distance, D(p || q), (in bits) between the  two probability mass functions. The result will be POSITIVE_INFINITY if q has a zero probabability for a symbol for which p has a non-zero probability. The function computed is : <p> D(p||q) = - sum (p[x] * log<sup>2</sup>(p[x]/q[x])) </p>  Throw an IllegalArgumentException if either array has length 0. If the two arrays do not have the same length, throw an  IllegalArgumentException.
 * @param p An array of doubles representing the first pmf, p.
 * @param q An array of doubles representing the second pmf, q.
 * @return A double representing the relative entropy of therandom variable.
 */
public static final double relativeEntropy(double[] p,double[] q){
  int length=_commonLength(p,q,""String_Node_Str"");
  double d=0.0;
  for (int i=0; i < length; i++) {
    if ((p[i] < 0.0) || (q[i] < 0.0)) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (p[i] == 0.0) {
    }
 else     if (q[i] == 0.0) {
      return Double.POSITIVE_INFINITY;
    }
 else {
      d+=p[i] * ExtendedMath.log2(p[i] / q[i]);
    }
  }
  return d;
}","/** 
 * Given two array's of probabilities, calculate the relative entropy  aka Kullback Leibler distance, D(p || q), (in bits) between the  two probability mass functions. The result will be POSITIVE_INFINITY if q has a zero probabability for a symbol for which p has a non-zero probability. The function computed is : <p> D(p||q) = - sum (p[x] * log<sup>2</sup>(p[x]/q[x])) </p>  Throw an IllegalArgumentException if either array has length 0. If the two arrays do not have the same length, throw an  IllegalArgumentException.
 * @param p An array of doubles representing the first pmf, p.
 * @param q An array of doubles representing the second pmf, q.
 * @return A double representing the relative entropy of therandom variable.
 */
public static final double relativeEntropy(double[] p,double[] q){
  _nonZeroLength(p,""String_Node_Str"");
  int length=_commonLength(p,q,""String_Node_Str"");
  double d=0.0;
  for (int i=0; i < length; i++) {
    if ((p[i] < 0.0) || (q[i] < 0.0)) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (p[i] == 0.0) {
    }
 else     if (q[i] == 0.0) {
      return Double.POSITIVE_INFINITY;
    }
 else {
      d+=p[i] * ExtendedMath.log2(p[i] / q[i]);
    }
  }
  return d;
}"
76415,"/** 
 * Return a new array of Gaussian distributed doubles with a given mean and standard deviation. The number of elements to allocate  is given by N. This algorithm is from [1]. Note this takes an random, unbounded amount of time!
 */
public static final double[] randomGaussian(double mean,double standardDeviation,int N){
  double t;
  double x, v1, v2, r;
  Random random=new Random();
  double[] retval=new double[N];
  for (int i=0; i < N; i+=2) {
    do {
      v1=2.0 * random.nextDouble() - 1.0;
      v2=2.0 * random.nextDouble() - 1.0;
      r=v1 * v1 + v2 * v2;
    }
 while ((r >= 1.0) && (r == 0.0));
    r=Math.sqrt((-2.0 * Math.log(r)) / r);
    retval[i]=mean + v1 * r * standardDeviation;
    if ((i + 1) < N) {
      retval[i + 1]=mean + v2 * r * standardDeviation;
    }
  }
  return retval;
}","/** 
 * Return a new array of Gaussian distributed doubles with a given mean and standard deviation. The number of elements to allocate  is given by N. This algorithm is from [1]. 
 */
public static final double[] randomGaussian(double mean,double standardDeviation,int N){
  double t;
  double x, v1, v2, r;
  Random random=new Random();
  double[] retval=new double[N];
  for (int i=0; i < N; i+=2) {
    do {
      v1=2.0 * random.nextDouble() - 1.0;
      v2=2.0 * random.nextDouble() - 1.0;
      r=v1 * v1 + v2 * v2;
    }
 while ((r >= 1.0) && (r == 0.0));
    r=Math.sqrt((-2.0 * Math.log(r)) / r);
    retval[i]=mean + v1 * r * standardDeviation;
    if ((i + 1) < N) {
      retval[i + 1]=mean + v2 * r * standardDeviation;
    }
  }
  return retval;
}"
76416,"/** 
 * Return the variance of the elements in the array. The variance is computed as follows : <p> <pre> variance = (sum(X<sup>2</sup>) - (sum(X) / N)<sup>2</sup>) / N </pre> <p> The sample variance is computed as follows : <p> <pre> variance<sub>sample</sub> = (sum(X<sup>2</sup>) - (sum(X) / N)<sup>2</sup>) / (N - 1) </pre> <p> Throw an exception if the array is of length 0, or if the sample variance is taken on an array of length less than 2.
 */
public static double variance(double[] array,boolean sample){
  if (array.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (sample && (array.length < 2)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  int length=array.length;
  double ex2=0.0;
  double sum=0.0;
  for (int i=0; i < length; i++) {
    ex2+=array[i] * array[i];
    sum+=array[i];
  }
  double norm=sample ? (length - 1) : length;
  double sumSquaredOverLength=sum * sum / length;
  return (ex2 - sumSquaredOverLength) / norm;
}","/** 
 * Return the variance of the elements in the array. The variance is computed as follows : <p> <pre> variance = (sum(X<sup>2</sup>) - (sum(X) / N)<sup>2</sup>) / N </pre> <p> The sample variance is computed as follows : <p> <pre> variance<sub>sample</sub> = (sum(X<sup>2</sup>) - (sum(X) / N)<sup>2</sup>) / (N - 1) </pre> <p> Throw an exception if the array is of length 0, or if the sample variance is taken on an array of length less than 2.
 */
public static double variance(double[] array,boolean sample){
  int length=_nonZeroLength(array,""String_Node_Str"");
  if (sample && (array.length < 2)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  double ex2=0.0;
  double sum=0.0;
  for (int i=0; i < length; i++) {
    ex2+=array[i] * array[i];
    sum+=array[i];
  }
  double norm=sample ? (length - 1) : length;
  double sumSquaredOverLength=sum * sum / length;
  return (ex2 - sumSquaredOverLength) / norm;
}"
76417,"/** 
 * Return a new array that is filled with samples of a window of a specified length and type. Throw an IllegalArgumentException if the length is less than 1 or the window type is unknown.
 * @param length The length of the window to be generated.
 * @param windowType The type of window to generate.
 * @return A new array of doubles.
 */
public static final double[] generateWindow(int length,int windowType){
  if (length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  int M=length - 1;
  int n;
  double[] window=new double[length];
switch (windowType) {
case WINDOW_TYPE_RECTANGULAR:
{
      for (n=0; n < length; n++) {
        window[n]=1.0;
      }
    }
  break;
case WINDOW_TYPE_BARTLETT:
{
  int halfM=length / 2;
  double twoOverM=2.0 / (double)M;
  for (n=0; n <= halfM; n++) {
    window[n]=twoOverM;
  }
  for (n=halfM + 1; n < length; n++) {
    window[n]=2.0 - twoOverM;
  }
}
break;
case WINDOW_TYPE_HANNING:
{
double twoPiOverM=2.0 * Math.PI / (double)M;
for (n=0; n < length; n++) {
window[n]=0.5 - 0.5 * Math.cos(twoPiOverM * n);
}
}
break;
case WINDOW_TYPE_HAMMING:
{
double twoPiOverM=2.0 * Math.PI / (double)M;
for (n=0; n < length; n++) {
window[n]=0.54 - 0.46 * Math.cos(twoPiOverM * n);
}
}
break;
case WINDOW_TYPE_BLACKMAN:
{
double twoPiOverM=2.0 * Math.PI / (double)M;
double fourPiOverM=2.0 * twoPiOverM;
for (n=0; n < length; n++) {
window[n]=0.42 - 0.5 * Math.cos(twoPiOverM * n) + 0.08 * Math.cos(fourPiOverM * n);
}
}
break;
case WINDOW_TYPE_BLACKMAN_HARRIS:
{
double twoPiOverM=2.0 * Math.PI / (double)M;
double fourPiOverM=2.0 * twoPiOverM;
double sixPiOverM=3.0 * twoPiOverM;
for (n=0; n < length; n++) {
window[n]=0.35875 - 0.48829 * Math.cos(twoPiOverM * n) + 0.14128 * Math.cos(fourPiOverM * n) - 0.01168 * Math.cos(sixPiOverM * n);
}
}
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + windowType + ""String_Node_Str"");
}
return window;
}","/** 
 * Return a new array that is filled with samples of a window of a specified length and type. Throw an IllegalArgumentException if the length is less than 1 or the window type is unknown.
 * @param length The length of the window to be generated.
 * @param windowType The type of window to generate.
 * @return A new array of doubles.
 */
public static final double[] generateWindow(int length,int windowType){
  if (length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  int M=length - 1;
  int n;
  double[] window=new double[length];
switch (windowType) {
case WINDOW_TYPE_RECTANGULAR:
{
      for (n=0; n < length; n++) {
        window[n]=1.0;
      }
    }
  break;
case WINDOW_TYPE_BARTLETT:
{
  int halfM=M / 2;
  double twoOverM=2.0 / (double)M;
  for (n=0; n <= halfM; n++) {
    window[n]=n * twoOverM;
  }
  for (n=halfM + 1; n < length; n++) {
    window[n]=2.0 - n * twoOverM;
  }
}
break;
case WINDOW_TYPE_HANNING:
{
double twoPiOverM=2.0 * Math.PI / (double)M;
for (n=0; n < length; n++) {
window[n]=0.5 - 0.5 * Math.cos(twoPiOverM * n);
}
}
break;
case WINDOW_TYPE_HAMMING:
{
double twoPiOverM=2.0 * Math.PI / (double)M;
for (n=0; n < length; n++) {
window[n]=0.54 - 0.46 * Math.cos(twoPiOverM * n);
}
}
break;
case WINDOW_TYPE_BLACKMAN:
{
double twoPiOverM=2.0 * Math.PI / (double)M;
double fourPiOverM=2.0 * twoPiOverM;
for (n=0; n < length; n++) {
window[n]=0.42 - 0.5 * Math.cos(twoPiOverM * n) + 0.08 * Math.cos(fourPiOverM * n);
}
}
break;
case WINDOW_TYPE_BLACKMAN_HARRIS:
{
double twoPiOverM=2.0 * Math.PI / (double)M;
double fourPiOverM=2.0 * twoPiOverM;
double sixPiOverM=3.0 * twoPiOverM;
for (n=0; n < length; n++) {
window[n]=0.35875 - 0.48829 * Math.cos(twoPiOverM * n) + 0.14128 * Math.cos(fourPiOverM * n) - 0.01168 * Math.cos(sixPiOverM * n);
}
}
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + windowType + ""String_Node_Str"");
}
return window;
}"
76418,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Expression(TypedCompositeActor container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  expression=new Parameter(this,""String_Node_Str"");
  _time=new Variable(this,""String_Node_Str"",new DoubleToken(0.0));
  _firing=new Variable(this,""String_Node_Str"",new IntToken(1));
  _expression=new Variable(this,""String_Node_Str"",new IntToken(1));
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Expression(TypedCompositeActor container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  expression=new Parameter(this,""String_Node_Str"");
  _time=new Variable(this,""String_Node_Str"",new DoubleToken(0.0));
  _firing=new Variable(this,""String_Node_Str"",new IntToken(1));
}"
76419,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 */
public Object clone(Workspace ws){
  try {
    Expression newobj=(Expression)super.clone(ws);
    newobj._firingCount=1;
    newobj.output=(TypedIOPort)newobj.getPort(""String_Node_Str"");
    expression=(Parameter)newobj.getAttribute(""String_Node_Str"");
    newobj._time=(Variable)newobj.getAttribute(""String_Node_Str"");
    newobj._firing=(Variable)newobj.getAttribute(""String_Node_Str"");
    newobj._expression=(Variable)newobj.getAttribute(""String_Node_Str"");
    return newobj;
  }
 catch (  CloneNotSupportedException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 */
public Object clone(Workspace ws){
  try {
    Expression newobj=(Expression)super.clone(ws);
    newobj._firingCount=1;
    newobj.output=(TypedIOPort)newobj.getPort(""String_Node_Str"");
    newobj.expression=(Parameter)newobj.getAttribute(""String_Node_Str"");
    newobj._time=(Variable)newobj.getAttribute(""String_Node_Str"");
    newobj._firing=(Variable)newobj.getAttribute(""String_Node_Str"");
    return newobj;
  }
 catch (  CloneNotSupportedException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}"
76420,"/** 
 * Evaluate the expression and broadcast its result to the output.
 * @exception IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  String expr=expression.getExpression();
  _expression.setExpression(expr);
  Director dir=getDirector();
  if (dir == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _time.setToken(new DoubleToken(dir.getCurrentTime()));
  Enumeration inputPorts=inputPorts();
  while (inputPorts.hasMoreElements()) {
    IOPort port=(IOPort)(inputPorts.nextElement());
    if (port.hasToken(0)) {
      Token inputToken=port.get(0);
      Variable var=(Variable)(getAttribute(port.getName()));
      var.setToken(inputToken);
    }
  }
  Token result=_expression.getToken();
  if (result == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + _expression.getExpression());
  }
  output.broadcast(result);
}","/** 
 * Evaluate the expression and broadcast its result to the output.
 * @exception IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  Director dir=getDirector();
  if (dir == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _time.setToken(new DoubleToken(dir.getCurrentTime()));
  Enumeration inputPorts=inputPorts();
  while (inputPorts.hasMoreElements()) {
    IOPort port=(IOPort)(inputPorts.nextElement());
    if (port.hasToken(0)) {
      Token inputToken=port.get(0);
      Variable var=(Variable)(getAttribute(port.getName()));
      var.setToken(inputToken);
    }
  }
  Token result=expression.getToken();
  if (result == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + expression.getExpression());
  }
  output.broadcast(result);
}"
76421,"/** 
 * Initialize the firing count to 1.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _firingCount=1;
}","/** 
 * Initialize the firing count to 1.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _firingCount=1;
  _firing.setToken(new IntToken(_firingCount));
}"
76422,"/** 
 * Return true if this receiver has a NullToken at the front  of the queue; return false otherwise.
 * @return True if this receiver contains a NullToken in theoldest queue position; return false otherwise.
 */
synchronized boolean hasNullToken(){
  if (_queue.size() <= 0) {
    return false;
  }
  if (_queue.get(0) instanceof NullToken) {
    return true;
  }
  return false;
}","/** 
 * Return true if this receiver has a NullToken at the front  of the queue; return false otherwise.
 * @return True if this receiver contains a NullToken in theoldest queue position; return false otherwise.
 */
synchronized boolean hasNullToken(){
  String name=((Nameable)getContainer().getContainer()).getName();
  if (_queue.size() > 0) {
    Event event=(Event)_queue.get(0);
    if (event.getToken() instanceof NullToken) {
      return true;
    }
  }
  return false;
}"
76423,"/** 
 * Put a token on the queue with the specified time stamp and set the last time value to be equal to this time stamp. If the  queue is empty immediately prior to putting the token on the queue, then set the receiver time value to be equal to the last time value. If the queue is full, throw a NoRoomException.
 * @param token The token to put on the queue.
 * @param time The time stamp of the token.
 * @exception NoRoomException If the queue is full.
 */
public void put(Token token,double time) throws NoRoomException {
  if (time < _lastTime && time != INACTIVE && time != IGNORE) {
    IOPort port=(IOPort)getContainer();
    NamedObj actor=(NamedObj)port.getContainer();
    throw new IllegalArgumentException(actor.getName() + ""String_Node_Str"");
  }
  Event event;
synchronized (this) {
    _lastTime=time;
    event=new Event(token,_lastTime);
    if (_queue.size() == 0) {
      _rcvrTime=_lastTime;
    }
    if (!_queue.put(event)) {
      throw new NoRoomException(getContainer(),""String_Node_Str"");
    }
  }
}","/** 
 * Put a token on the queue with the specified time stamp and set the last time value to be equal to this time stamp. If the  queue is empty immediately prior to putting the token on the queue, then set the receiver time value to be equal to the last time value. If the queue is full, throw a NoRoomException.
 * @param token The token to put on the queue.
 * @param time The time stamp of the token.
 * @exception NoRoomException If the queue is full.
 */
public void put(Token token,double time) throws NoRoomException {
  if (time < _lastTime && time != INACTIVE && time != IGNORE) {
    IOPort port=(IOPort)getContainer();
    NamedObj actor=(NamedObj)port.getContainer();
    throw new IllegalArgumentException(actor.getName() + ""String_Node_Str"");
  }
  Event event;
synchronized (this) {
    String name=((Nameable)getContainer().getContainer()).getName();
    if (token instanceof NullToken) {
      System.out.println(name + ""String_Node_Str"" + name+ ""String_Node_Str""+ time);
    }
 else     if (token instanceof Token) {
      System.out.println(name + ""String_Node_Str"" + name+ ""String_Node_Str""+ time);
    }
    _lastTime=time;
    event=new Event(token,_lastTime);
    if (_queue.size() == 0) {
      _rcvrTime=_lastTime;
    }
    if (!_queue.put(event)) {
      throw new NoRoomException(getContainer(),""String_Node_Str"");
    }
  }
}"
76424,"protected ptolemy.data.Token _resolveNode(){
  int nChildren=jjtGetNumChildren();
  int i;
  ptolemy.data.Token tok=null;
  Class mtype=_elementType();
  try {
    if (_form == 1) {
      if (mtype == BooleanToken.class) {
        boolean[][] val=new boolean[_nRows][_nColumns];
        for (i=0; i < nChildren; ++i) {
          tok=BooleanToken.convert(childTokens[i]);
          val[i / _nColumns][i % _nColumns]=((BooleanToken)tok).booleanValue();
        }
        _ptToken=new BooleanMatrixToken(val);
      }
 else       if (mtype == IntToken.class) {
        int[][] val=new int[_nRows][_nColumns];
        for (i=0; i < nChildren; ++i) {
          tok=IntToken.convert(childTokens[i]);
          val[i / _nColumns][i % _nColumns]=((IntToken)tok).intValue();
        }
        _ptToken=new IntMatrixToken(val);
      }
 else       if (mtype == LongToken.class) {
        long[][] val=new long[_nRows][_nColumns];
        for (i=0; i < nChildren; ++i) {
          tok=LongToken.convert(childTokens[i]);
          val[i / _nColumns][i % _nColumns]=((LongToken)tok).longValue();
        }
        _ptToken=new LongMatrixToken(val);
      }
 else       if (mtype == DoubleToken.class) {
        double[][] val=new double[_nRows][_nColumns];
        for (i=0; i < nChildren; ++i) {
          tok=DoubleToken.convert(childTokens[i]);
          val[i % _nColumns][i / _nColumns]=((DoubleToken)tok).doubleValue();
        }
        _ptToken=new DoubleMatrixToken(val);
      }
 else       if (mtype == ComplexToken.class) {
        Complex[][] val=new Complex[_nRows][_nColumns];
        for (i=0; i < nChildren; ++i) {
          tok=ComplexToken.convert(childTokens[i]);
          val[i / _nColumns][i % _nColumns]=((ComplexToken)tok).complexValue();
        }
        _ptToken=new ComplexMatrixToken(val);
      }
 else {
        throw new IllegalExpressionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
 else     if (_form == 2) {
      if (mtype == IntToken.class) {
        _nColumns=_numIntColumns(childTokens[0],childTokens[1],childTokens[2]);
        for (i=1; i < _nRows; ++i) {
          if (_nColumns != _numIntColumns(childTokens[3 * i],childTokens[3 * i + 1],childTokens[3 * i + 2])) {
            throw new IllegalExpressionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        int[][] val=new int[_nRows][];
        for (i=0; i < _nRows; ++i) {
          val[i]=_createIntRow(childTokens[3 * i],childTokens[3 * i + 1]);
        }
        _ptToken=new IntMatrixToken(val);
      }
 else       if (mtype == LongToken.class) {
        _nColumns=_numLongColumns(childTokens[0],childTokens[1],childTokens[2]);
        for (i=1; i < _nRows; ++i) {
          if (_nColumns != _numLongColumns(childTokens[3 * i],childTokens[3 * i + 1],childTokens[3 * i + 2])) {
            throw new IllegalExpressionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        long[][] val=new long[_nRows][];
        for (i=0; i < _nRows; ++i) {
          val[i]=_createLongRow(childTokens[3 * i],childTokens[3 * i + 1]);
        }
        _ptToken=new LongMatrixToken(val);
      }
 else       if (mtype == DoubleToken.class) {
        _nColumns=_numDoubleColumns(childTokens[0],childTokens[1],childTokens[2]);
        for (i=1; i < _nRows; ++i) {
          if (_nColumns != _numDoubleColumns(childTokens[3 * i],childTokens[3 * i + 1],childTokens[3 * i + 2])) {
            throw new IllegalExpressionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        double[][] val=new double[_nRows][];
        for (i=0; i < _nRows; ++i) {
          val[i]=_createDoubleRow(childTokens[3 * i],childTokens[3 * i + 1]);
        }
        _ptToken=new DoubleMatrixToken(val);
      }
 else {
        throw new IllegalExpressionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ mtype);
      }
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
  }
  return _ptToken;
}","protected ptolemy.data.Token _resolveNode(){
  int nChildren=jjtGetNumChildren();
  int i;
  ptolemy.data.Token tok=null;
  Class mtype=_elementType();
  try {
    if (_form == 1) {
      if (mtype == BooleanToken.class) {
        boolean[][] val=new boolean[_nRows][_nColumns];
        for (i=0; i < nChildren; ++i) {
          tok=BooleanToken.convert(childTokens[i]);
          val[i / _nColumns][i % _nColumns]=((BooleanToken)tok).booleanValue();
        }
        _ptToken=new BooleanMatrixToken(val);
      }
 else       if (mtype == IntToken.class) {
        int[][] val=new int[_nRows][_nColumns];
        for (i=0; i < nChildren; ++i) {
          tok=IntToken.convert(childTokens[i]);
          val[i / _nColumns][i % _nColumns]=((IntToken)tok).intValue();
        }
        _ptToken=new IntMatrixToken(val);
      }
 else       if (mtype == LongToken.class) {
        long[][] val=new long[_nRows][_nColumns];
        for (i=0; i < nChildren; ++i) {
          tok=LongToken.convert(childTokens[i]);
          val[i / _nColumns][i % _nColumns]=((LongToken)tok).longValue();
        }
        _ptToken=new LongMatrixToken(val);
      }
 else       if (mtype == DoubleToken.class) {
        double[][] val=new double[_nRows][_nColumns];
        for (i=0; i < nChildren; ++i) {
          tok=DoubleToken.convert(childTokens[i]);
          val[i / _nColumns][i % _nColumns]=((DoubleToken)tok).doubleValue();
        }
        _ptToken=new DoubleMatrixToken(val);
      }
 else       if (mtype == ComplexToken.class) {
        Complex[][] val=new Complex[_nRows][_nColumns];
        for (i=0; i < nChildren; ++i) {
          tok=ComplexToken.convert(childTokens[i]);
          val[i / _nColumns][i % _nColumns]=((ComplexToken)tok).complexValue();
        }
        _ptToken=new ComplexMatrixToken(val);
      }
 else {
        throw new IllegalExpressionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
 else     if (_form == 2) {
      if (mtype == IntToken.class) {
        _nColumns=_numIntColumns(childTokens[0],childTokens[1],childTokens[2]);
        for (i=1; i < _nRows; ++i) {
          if (_nColumns != _numIntColumns(childTokens[3 * i],childTokens[3 * i + 1],childTokens[3 * i + 2])) {
            throw new IllegalExpressionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        int[][] val=new int[_nRows][];
        for (i=0; i < _nRows; ++i) {
          val[i]=_createIntRow(childTokens[3 * i],childTokens[3 * i + 1]);
        }
        _ptToken=new IntMatrixToken(val);
      }
 else       if (mtype == LongToken.class) {
        _nColumns=_numLongColumns(childTokens[0],childTokens[1],childTokens[2]);
        for (i=1; i < _nRows; ++i) {
          if (_nColumns != _numLongColumns(childTokens[3 * i],childTokens[3 * i + 1],childTokens[3 * i + 2])) {
            throw new IllegalExpressionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        long[][] val=new long[_nRows][];
        for (i=0; i < _nRows; ++i) {
          val[i]=_createLongRow(childTokens[3 * i],childTokens[3 * i + 1]);
        }
        _ptToken=new LongMatrixToken(val);
      }
 else       if (mtype == DoubleToken.class) {
        _nColumns=_numDoubleColumns(childTokens[0],childTokens[1],childTokens[2]);
        for (i=1; i < _nRows; ++i) {
          if (_nColumns != _numDoubleColumns(childTokens[3 * i],childTokens[3 * i + 1],childTokens[3 * i + 2])) {
            throw new IllegalExpressionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        double[][] val=new double[_nRows][];
        for (i=0; i < _nRows; ++i) {
          val[i]=_createDoubleRow(childTokens[3 * i],childTokens[3 * i + 1]);
        }
        _ptToken=new DoubleMatrixToken(val);
      }
 else {
        throw new IllegalExpressionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ mtype);
      }
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
  }
  return _ptToken;
}"
76425,"/** 
 * Invoke one iteration of the model.  An iteration consists of first performing changes queued with requestChange() and type resolution, if necessary, and then invoking prefire(), fire(), and postfire(), in that order. If prefire() returns false, then fire() and postfire() are not invoked, and true is returned. Otherwise, fire() will be called once, followed by postfire(). The return value of postfire() is returned. Note that this method ignores finish and pause requests. If you wish to use finish() or pause() to control the execution, then you should execute the model using execute(), run(), or startRun(). This method is read synchronized on the workspace.
 * @return True if postfire() returns true.
 * @exception KernelException If the model throws it, or if thereis no container, or if one of the requested changes fails.
 */
public boolean iterate() throws KernelException {
  if (_container == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  boolean result=true;
  try {
    workspace().getReadAccess();
    _processChangeRequests();
    if (!_typesResolved) {
      resolveTypes();
      _typesResolved=true;
    }
    _iterationCount++;
    _setState(ITERATING);
    if (!_needWriteAccess()) {
      workspace().setReadOnly(true);
    }
    if (_container.prefire()) {
      _container.fire();
      result=_container.postfire();
    }
  }
  finally {
    workspace().doneReading();
    workspace().setReadOnly(false);
  }
  return result;
}","/** 
 * Invoke one iteration of the model.  An iteration consists of first performing changes queued with requestChange() and type resolution, if necessary, and then invoking prefire(), fire(), and postfire(), in that order. If prefire() returns false, then fire() and postfire() are not invoked, and true is returned. Otherwise, fire() will be called once, followed by postfire(). The return value of postfire() is returned. Note that this method ignores finish and pause requests. If you wish to use finish() or pause() to control the execution, then you should execute the model using execute(), run(), or startRun(). This method is read synchronized on the workspace.
 * @return True if postfire() returns true.
 * @exception KernelException If the model throws it, or if thereis no container, or if one of the requested changes fails.
 */
public boolean iterate() throws KernelException {
  if (_container == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  boolean result=true;
  try {
    workspace().getReadAccess();
    _processChangeRequests();
    if (!_typesResolved) {
      resolveTypes();
      _typesResolved=true;
    }
    _iterationCount++;
    _setState(ITERATING);
    if (!_needWriteAccess()) {
      workspace().setReadOnly(true);
    }
    if (_container.prefire()) {
      _container.fire();
      result=_container.postfire();
    }
  }
  finally {
    workspace().setReadOnly(false);
    workspace().doneReading();
  }
  return result;
}"
76426,"/** 
 * Wrap up the model.
 * @exception KernelException If the model throws it.
 * @exception IllegalActionException If the model is idle or alreadywrapping up, or if there is no container.
 */
public synchronized void wrapup() throws KernelException, IllegalActionException {
  if (_state == IDLE || _state == WRAPPING_UP) {
    throw new IllegalActionException(this,""String_Node_Str"" + _state.getDescription());
  }
  if (_container == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _setState(WRAPPING_UP);
  _container.wrapup();
  _setState(IDLE);
}","/** 
 * Wrap up the model.
 * @exception KernelException If the model throws it.
 * @exception IllegalActionException If the model is idle or alreadywrapping up, or if there is no container.
 */
public synchronized void wrapup() throws KernelException, IllegalActionException {
  if (_state == IDLE || _state == WRAPPING_UP) {
    throw new IllegalActionException(this,""String_Node_Str"" + _state.getDescription());
  }
  if (_container == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _setState(WRAPPING_UP);
  _container.wrapup();
  _setState(IDLE);
  workspace().doneReading();
}"
76427,"/** 
 * Set the local director for execution of this CompositeActor. Calling this method with a non-null argument makes this entity opaque. Calling it with a null argument makes it transparent. The container of the specified director is set to this composite actor, and if there was previously a local director, its container is set to null. This method is write-synchronized on the workspace.
 * @param director The Director responsible for execution.
 * @exception IllegalActionException If the director is not inthe same workspace as this actor.  It may also be throw in derived classed if the director is not compatible.
 */
public void setDirector(Director director) throws IllegalActionException {
  if (director != null && workspace() != director.workspace()) {
    throw new IllegalActionException(this,director,""String_Node_Str"");
  }
  try {
    workspace().getWriteAccess();
    if (_director != null)     _director._makeDirectorOf(null);
    if (director != null) {
      director._makeDirectorOf(this);
    }
    _director=director;
  }
  finally {
    workspace().doneWriting();
  }
}","/** 
 * Set the local director for execution of this CompositeActor. Calling this method with a non-null argument makes this entity opaque. Calling it with a null argument makes it transparent. The container of the specified director is set to this composite actor, and if there was previously a local director, its container is set to null. This method is write-synchronized on the workspace.
 * @param director The Director responsible for execution.
 * @exception IllegalActionException If the director is not inthe same workspace as this actor. It may also be thrown in derived classes if the director is not compatible.
 */
public void setDirector(Director director) throws IllegalActionException {
  if (director != null && workspace() != director.workspace()) {
    throw new IllegalActionException(this,director,""String_Node_Str"");
  }
  try {
    workspace().getWriteAccess();
    if (_director != null)     _director._makeDirectorOf(null);
    if (director != null) {
      director._makeDirectorOf(this);
    }
    _director=director;
  }
  finally {
    workspace().doneWriting();
  }
}"
76428,"/** 
 * Add an actor to this container with minimal error checking. This overrides the base-class method to make sure the argument implements the Actor interface and to invalidate the schedule and type resolution. This method does not alter the actor in any way. It is <i>not</i> synchronized on the workspace, so the caller should be.
 * @param entity Actor to contain.
 * @exception IllegalActionException If the actor has no name, or theaction would result in a recursive containment structure, or the argument does not implement the Actor interface.
 * @exception NameDuplicationException If the name collides with a namealready on the actor contents list.
 */
protected void _addEntity(ComponentEntity entity) throws IllegalActionException, NameDuplicationException {
  if (!(entity instanceof Actor)) {
    throw new IllegalActionException(this,entity,""String_Node_Str"" + ""String_Node_Str"");
  }
  super._addEntity(entity);
  _director.invalidateSchedule();
  _director.invalidateResolvedTypes();
}","/** 
 * Add an actor to this container with minimal error checking. This overrides the base-class method to make sure the argument implements the Actor interface and to invalidate the schedule and type resolution. This method does not alter the actor in any way. It is <i>not</i> synchronized on the workspace, so the caller should be.
 * @param entity Actor to contain.
 * @exception IllegalActionException If the actor has no name, or theaction would result in a recursive containment structure, or the argument does not implement the Actor interface.
 * @exception NameDuplicationException If the name collides with a namealready on the actor contents list.
 */
protected void _addEntity(ComponentEntity entity) throws IllegalActionException, NameDuplicationException {
  if (!(entity instanceof Actor)) {
    throw new IllegalActionException(this,entity,""String_Node_Str"" + ""String_Node_Str"");
  }
  super._addEntity(entity);
  if (_director != null) {
    _director.invalidateSchedule();
    _director.invalidateResolvedTypes();
  }
}"
76429,"/** 
 * Return the maximum value in the array. Throw an exception if the length of the array is 0.
 * @param array An array of doubles.
 * @return A double.
 */
public static final double max(double[] array){
  int length=_nonZeroLength(array,""String_Node_Str"");
  double maxElement=array[0];
  for (int i=1; i < length; i++) {
    maxElement=Math.max(array[i],maxElement);
  }
  return maxElement;
}","/** 
 * Return the maximum value in the array. Throw an exception if the length of the array is 0.
 */
public static final double max(double[] array){
  int length=_nonZeroLength(array,""String_Node_Str"");
  double maxElement=array[0];
  for (int i=1; i < length; i++) {
    maxElement=Math.max(array[i],maxElement);
  }
  return maxElement;
}"
76430,"/** 
 * Return a new array of Poisson random variables (as doubles) with  a given mean. The number of elements to allocate is given by N. This algorithm is from [1].
 * @param mean A double.
 * @param N An int indicating how many elements to generate.
 * @return A new array of doubles.
 */
public static final double[] randomPoisson(double mean,int N){
  Random random=new Random();
  double[] retval=new double[N];
  for (int i=0; i < N; i++) {
    double j;
    double u, p, f;
    j=0.0;
    f=p=Math.exp(-mean);
    u=random.nextDouble();
    while (f <= u) {
      p*=(mean / (j + 1.0));
      f+=p;
      j+=1.0;
    }
    retval[i]=j;
  }
  return retval;
}","/** 
 * Return a new array of Poisson random variables (as doubles) with  a given mean. The number of elements to allocate is given by N. This algorithm is from [1].
 */
public static final double[] randomPoisson(double mean,int N){
  Random random=new Random();
  double[] retval=new double[N];
  for (int i=0; i < N; i++) {
    double j;
    double u, p, f;
    j=0.0;
    f=p=Math.exp(-mean);
    u=random.nextDouble();
    while (f <= u) {
      p*=(mean / (j + 1.0));
      f+=p;
      j+=1.0;
    }
    retval[i]=j;
  }
  return retval;
}"
76431,"/** 
 * Return the sum of all of the elements in the array. Return 0.0 of the length of the array is 0.
 * @param array An array of doubles.
 * @return A double.
 */
public static final double sumOfElements(double[] array){
  double sum=0.0;
  for (int i=0; i < array.length; i++) {
    sum+=array[i];
  }
  return sum;
}","/** 
 * Return the sum of all of the elements in the array. Return 0.0 of the length of the array is 0.
 */
public static final double sumOfElements(double[] array){
  double sum=0.0;
  for (int i=0; i < array.length; i++) {
    sum+=array[i];
  }
  return sum;
}"
76432,"/** 
 * Given two array's of probabilities, calculate the relative entropy  aka Kullback Leibler distance, D(p || q), (in bits) between the  two probability mass functions. The result will be POSITIVE_INFINITY if q has a zero probabability for a symbol for which p has a non-zero probability. The function computed is : <p> D(p||q) = - sum (p[x] * log<sup>2</sup>(p[x]/q[x])) </p>  Throw an IllegalArgumentException if either array has length 0. If the two arrays do not have the same length, throw an  IllegalArgumentException.
 * @param p An array of doubles representing the first pmf.
 * @param q An array of doubles representing the second pmf.
 * @return A double representing the relative entropy of therandom variable.
 */
public static final double relativeEntropy(double[] p,double[] q){
  int length=_commonLength(p,q,""String_Node_Str"");
  double d=0.0;
  for (int i=0; i < length; i++) {
    if ((p[i] < 0.0) || (q[i] < 0.0)) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (p[i] == 0.0) {
    }
 else     if (q[i] == 0.0) {
      return Double.POSITIVE_INFINITY;
    }
 else {
      d+=p[i] * ExtendedMath.log2(p[i] / q[i]);
    }
  }
  return d;
}","/** 
 * Given two array's of probabilities, calculate the relative entropy  aka Kullback Leibler distance, D(p || q), (in bits) between the  two probability mass functions. The result will be POSITIVE_INFINITY if q has a zero probabability for a symbol for which p has a non-zero probability. The function computed is : <p> D(p||q) = - sum (p[x] * log<sup>2</sup>(p[x]/q[x])) </p>  Throw an IllegalArgumentException if either array has length 0. If the two arrays do not have the same length, throw an  IllegalArgumentException.
 * @param p An array of doubles representing the first pmf, p.
 * @param q An array of doubles representing the second pmf, q.
 * @return A double representing the relative entropy of therandom variable.
 */
public static final double relativeEntropy(double[] p,double[] q){
  int length=_commonLength(p,q,""String_Node_Str"");
  double d=0.0;
  for (int i=0; i < length; i++) {
    if ((p[i] < 0.0) || (q[i] < 0.0)) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (p[i] == 0.0) {
    }
 else     if (q[i] == 0.0) {
      return Double.POSITIVE_INFINITY;
    }
 else {
      d+=p[i] * ExtendedMath.log2(p[i] / q[i]);
    }
  }
  return d;
}"
76433,"/** 
 * Return the sum of the squares of all of the elements in the array. Return 0.0 if the length of the array is 0.
 * @param array An array of doubles.
 * @return A double.
 */
public static final double sumOfSquares(double[] array){
  double sum=0.0;
  for (int i=0; i < array.length; i++) {
    sum+=(array[i] * array[i]);
  }
  return sum;
}","/** 
 * Return the sum of the squares of all of the elements in the array. Return 0.0 if the length of the array is 0.
 */
public static final double sumOfSquares(double[] array){
  double sum=0.0;
  for (int i=0; i < array.length; i++) {
    sum+=(array[i] * array[i]);
  }
  return sum;
}"
76434,"/** 
 * Return the minimum value in the array. Throw an exception if the length of the array is 0.
 * @param array An array of doubles.
 * @param array An array of doubles.
 * @return A double.
 */
public static final double min(double[] array){
  int length=_nonZeroLength(array,""String_Node_Str"");
  double minElement=array[0];
  for (int i=1; i < length; i++) {
    minElement=Math.min(array[i],minElement);
  }
  return minElement;
}","/** 
 * Return the minimum value in the array. Throw an exception if the length of the array is 0.
 */
public static final double min(double[] array){
  int length=_nonZeroLength(array,""String_Node_Str"");
  double minElement=array[0];
  for (int i=1; i < length; i++) {
    minElement=Math.min(array[i],minElement);
  }
  return minElement;
}"
76435,"/** 
 * Given an array of probabilities, treated as a probability mass  function (pmf), calculate the entropy (in bits). The pmf is a discrete function that gives the probability of each element. The sum of the elements in the pmf should be 1, and each element should be between 0 and 1. This method does not check to see if the pmf is valid, except for checking that each entry is non-negative. The function computed is : <p> H(p) = - sum (p[x] * log<sup>2</sup>(p[x])) </p>  The entropy is always non-negative. Throw an IllegalArgumentException if the length of the array is 0, or a negative probability is encountered.
 * @param p An array of doubles representing the pmf.
 * @return A double.
 */
public static final double entropy(double[] p){
  int length=_nonZeroLength(p,""String_Node_Str"");
  double h=0.0;
  for (int i=0; i < length; i++) {
    if (p[i] < 0.0) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (p[i] == 0.0) {
    }
 else {
      h-=p[i] * ExtendedMath.log2(p[i]);
    }
  }
  return h;
}","/** 
 * Given an array of probabilities, treated as a probability mass  function (pmf), calculate the entropy (in bits). The pmf is a discrete function that gives the probability of each element. The sum of the elements in the pmf should be 1, and each element should be between 0 and 1. This method does not check to see if the pmf is valid, except for checking that each entry is non-negative. The function computed is : <p> H(p) = - sum (p[x] * log<sup>2</sup>(p[x])) </p>  The entropy is always non-negative. Throw an IllegalArgumentException if the length of the array is 0, or a negative probability is encountered.
 */
public static final double entropy(double[] p){
  int length=_nonZeroLength(p,""String_Node_Str"");
  double h=0.0;
  for (int i=0; i < length; i++) {
    if (p[i] < 0.0) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (p[i] == 0.0) {
    }
 else {
      h-=p[i] * ExtendedMath.log2(p[i]);
    }
  }
  return h;
}"
76436,"/** 
 * Return the variance of the elements in the array. The variance is computed as follows : <p> <pre> variance = (sum(X<sup>2</sup>) - sum(X)<sup>2</sup>) / N </pre> <p> The sample variance is computed as follows : <p> <pre> variance<sub>sample</sub> = (sum(X<sup>2</sup>) - sum(X)<sup>2</sup>) / (N - 1) </pre> <p> where E[X] denotes the expectation of X : Return 0.0 if the length of the array is 0.
 * @param array An array of doubles.
 * @return A double.
 */
public static double variance(double[] array,boolean sample){
  int length=array.length;
  double ex2=0.0;
  double sum=0.0;
  for (int i=0; i < length; i++) {
    ex2+=array[i] * array[i];
    sum+=array[i];
  }
  double retval=ex2 - (sum * sum);
  double norm=sample ? (length - 1) : length;
  return retval / (double)norm;
}","/** 
 * Return the variance of the elements in the array. The variance is computed as follows : <p> <pre> variance = (sum(X<sup>2</sup>) - (sum(X) / N)<sup>2</sup>) / N </pre> <p> The sample variance is computed as follows : <p> <pre> variance<sub>sample</sub> = (sum(X<sup>2</sup>) - (sum(X) / N)<sup>2</sup>) / (N - 1) </pre> <p> Throw an exception if the array is of length 0, or if the sample variance is taken on an array of length less than 2.
 */
public static double variance(double[] array,boolean sample){
  if (array.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (sample && (array.length < 2)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  int length=array.length;
  double ex2=0.0;
  double sum=0.0;
  for (int i=0; i < length; i++) {
    ex2+=array[i] * array[i];
    sum+=array[i];
  }
  double norm=sample ? (length - 1) : length;
  double sumSquaredOverLength=sum * sum / length;
  return (ex2 - sumSquaredOverLength) / norm;
}"
76437,"/** 
 * Return the arithmetic mean of the elements in the array.
 * @param array An array of doubles.
 * @return A double.
 */
public static final double mean(double[] array){
  _nonZeroLength(array,""String_Node_Str"");
  return sumOfElements(array) / (double)array.length;
}","/** 
 * Return the arithmetic mean of the elements in the array.
 */
public static final double mean(double[] array){
  _nonZeroLength(array,""String_Node_Str"");
  return sumOfElements(array) / (double)array.length;
}"
76438,"/** 
 * Return the product of all of the elements in the array. Return 1.0 if the length of the array is 0.
 * @param array An array of doubles.
 * @return A double.
 */
public static final double productOfElements(double[] array){
  double product=1.0;
  for (int i=0; i < array.length; i++) {
    product*=array[i];
  }
  return product;
}","/** 
 * Return the product of all of the elements in the array. Return 1.0 if the length of the array is 0.
 */
public static final double productOfElements(double[] array){
  double product=1.0;
  for (int i=0; i < array.length; i++) {
    product*=array[i];
  }
  return product;
}"
76439,"/** 
 * Return the standard deviation of the elements in the array. The standard deviation is computed as follows : <p> <pre> stdDev = sqrt(variance) </pre> <p> The sample standard deviation is computed as follows <p> <pre> stdDev = sqrt(variance<sub>sample</sub>) </pre> <p> Return 0.0 if the length of the array is 0.
 * @param array An array of doubles.
 * @param sample
 * @return A double.
 */
public static double standardDeviation(double[] array,boolean sample){
  return Math.sqrt(variance(array,sample));
}","/** 
 * Return the standard deviation of the elements in the array. The standard deviation is computed as follows : <p> <pre> stdDev = sqrt(variance) </pre> <p> The sample standard deviation is computed as follows <p> <pre> stdDev = sqrt(variance<sub>sample</sub>) </pre> <p> Throw an exception if the array is of length 0, or if the sample standard deviation is taken on an array of length less than 2.
 * @param array An array of doubles.
 * @param sample True if the sample standard devation is desired.
 * @return A double.
 */
public static double standardDeviation(double[] array,boolean sample){
  return Math.sqrt(variance(array,sample));
}"
76440,"/** 
 * Return a new array of doubles that is the inverse DCT of the  input array of doubles. See the DCT_TYPE_XXX constants for documentation of the exact formula, which depends on the type.
 * @param x An array of doubles.
 * @param order The base-2 logarithm of the size of the transform.
 * @param type An integer specifying which type of IDCT.
 * @retval A new array of doubles.
 */
public static double[] IDCT(double[] x,int order,int type){
  if (type >= DCT_TYPES) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  int size=1 << order;
  int twoSize=2 << order;
  if (_IDCTfactors[type][order] == null) {
    _IDCTfactors[type][order]=new Complex[twoSize];
    double oneOverTwoSize=1.0 / (double)twoSize;
    double factor=1.0;
    double oneOverE0=2.0;
switch (type) {
case DCT_TYPE_NORMALIZED:
      factor=2.0;
    oneOverE0=_ROOT2;
  break;
case DCT_TYPE_ORTHONORMAL:
factor=Math.sqrt(16.0 * oneOverTwoSize);
oneOverE0=_ROOT2;
break;
case DCT_TYPE_UNNORMALIZED:
factor=2.0;
oneOverE0=1.0;
break;
}
_IDCTfactors[type][order][0]=new Complex(oneOverE0 * factor,0.0);
for (int k=1; k < twoSize; k++) {
Complex c=new Complex(0,k * Math.PI * oneOverTwoSize);
_IDCTfactors[type][order][k]=c.exp().scale(factor);
}
}
Complex[] evenX=new Complex[twoSize];
Complex[] myFactors=_IDCTfactors[type][order];
evenX[0]=myFactors[0].scale(x[0]);
for (int k=1; k < size; k++) {
evenX[k]=myFactors[k].scale(x[k]);
evenX[twoSize - k]=myFactors[twoSize - k].scale(-x[k]);
}
evenX[size]=new Complex(0.0,0.0);
double[] longOutput=IFFTRealOut(evenX,order + 1);
return DoubleArrayMath.resize(longOutput,size);
}","/** 
 * Return a new array of doubles that is the inverse DCT of the  input array of doubles. See the DCT_TYPE_XXX constants for documentation of the exact formula, which depends on the type.
 * @param x An array of doubles.
 * @param order The base-2 logarithm of the size of the transform.
 * @param type An integer specifying which type of IDCT.
 * @retval A new array of doubles.
 */
public static double[] IDCT(double[] x,int order,int type){
  if (type >= DCT_TYPES) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  int size=1 << order;
  int twoSize=2 << order;
  if (_IDCTfactors[type][order] == null) {
    _IDCTfactors[type][order]=new Complex[twoSize];
    double oneOverTwoSize=1.0 / (double)twoSize;
    double factor=1.0;
    double oneOverE0=2.0;
switch (type) {
case DCT_TYPE_NORMALIZED:
      factor=2.0;
    oneOverE0=_ROOT2;
  break;
case DCT_TYPE_ORTHONORMAL:
factor=Math.sqrt((double)twoSize);
oneOverE0=_ROOT2;
break;
case DCT_TYPE_UNNORMALIZED:
factor=2.0;
oneOverE0=1.0;
break;
}
_IDCTfactors[type][order][0]=new Complex(oneOverE0 * factor,0.0);
for (int k=1; k < twoSize; k++) {
Complex c=new Complex(0,k * Math.PI * oneOverTwoSize);
_IDCTfactors[type][order][k]=c.exp().scale(factor);
}
}
Complex[] evenX=new Complex[twoSize];
Complex[] myFactors=_IDCTfactors[type][order];
evenX[0]=myFactors[0].scale(x[0]);
for (int k=1; k < size; k++) {
evenX[k]=myFactors[k].scale(x[k]);
evenX[twoSize - k]=myFactors[twoSize - k].scale(-x[k]);
}
evenX[size]=new Complex(0.0,0.0);
double[] longOutput=IFFTRealOut(evenX,order + 1);
return DoubleArrayMath.resize(longOutput,size);
}"
76441,"/** 
 * Return a new array of Complex's which is the forward FFT of a real input array of doubles. This method is half as expensive as computing the FFT of a Complex array.
 * @param x An array of doubles.
 * @param order The base-2 logarithm of the size of the transform.
 * @retval A new array of Complex's.
 */
public static Complex[] FFTComplexOut(double[] x,int order){
  double[] realPart=FFTRealOut(x,order);
  double[] imagPart=FFTImagOut(x,order);
  return ComplexArrayMath.formArray(realPart,imagPart);
}","/** 
 * Return a new array of Complex's which is the forward FFT of a real input array of doubles. This method is half as expensive as computing the FFT of a Complex array.
 * @param x An array of doubles.
 * @param order The base-2 logarithm of the size of the transform.
 * @retval A new array of Complex's.
 */
public static Complex[] FFTComplexOut(double[] x,int order){
  double[] realPart=FFTRealOut(x,order);
  double[] imagPart=FFTImagOut(x,order);
  return ComplexArrayMath.formComplexArray(realPart,imagPart);
}"
76442,"/** 
 * Return a new array that is a copy of the argument except that the elements are limited to lie within the specified range. If any value is infinite or NaN (not a number), then it is replaced by either the top or the bottom, depending on its sign.  To leave either the bottom or the top unconstrained, specify Double.MIN_VALUE or Double.MAX_VALUE. If the size of the array is 0, return a new array of size 0.
 * @param array An array of doubles.
 * @param bottom The bottom limit.
 * @param top The top limit.
 * @return A new array with values in the range [bottom, top].
 */
public final static double[] limit(double[] array,double bottom,double top){
  double[] result=new double[array.length];
  for (int i=0; i < array.length; i++) {
    if (array[i] > top || array[i] == Double.NaN || array[i] == Double.POSITIVE_INFINITY) {
      result[i]=top;
    }
 else     if (array[i] < bottom || array[i] == -Double.NaN || array[i] == Double.NEGATIVE_INFINITY) {
      result[i]=bottom;
    }
 else {
      result[i]=array[i];
    }
  }
  return result;
}","/** 
 * Return a new array that is a copy of the argument except that the elements are limited to lie within the specified range. If any value is infinite or NaN (not a number), then it is replaced by either the top or the bottom, depending on its sign.  To leave either the bottom or the top unconstrained, specify Double.NEGATIVE_INFINITY or Double.POSITIVE_INFINITY. If the size of the array is 0, return a new array of size 0.
 * @param array An array of doubles.
 * @param bottom The bottom limit.
 * @param top The top limit.
 * @return A new array with values in the range [bottom, top].
 */
public final static double[] limit(double[] array,double bottom,double top){
  double[] result=new double[array.length];
  for (int i=0; i < array.length; i++) {
    if ((array[i] > top) || (array[i] == Double.NaN) || (array[i] == Double.POSITIVE_INFINITY)) {
      result[i]=top;
    }
 else     if ((array[i] < bottom) || (array[i] == -Double.NaN) || (array[i] == Double.NEGATIVE_INFINITY)) {
      result[i]=bottom;
    }
 else {
      result[i]=array[i];
    }
  }
  return result;
}"
76443,"/** 
 * Return the next power of two larger than the argument.
 * @param x A positive real number.
 * @exception IllegalArgumentException If the argument is less thanor equal to zero. This is a runtime exception, so it need not be declared by the caller.
 */
public static int powerOfTwo(double x){
  if (x <= 0.0) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + x);
  }
  double m=Math.log(x) * _LOG2SCALE;
  int exp=(int)Math.ceil(m);
  return 1 << exp;
}","/** 
 * Return the next power of two larger than the argument.
 * @param x A positive real number.
 * @exception IllegalArgumentException If the argument is less thanor equal to zero.      
 */
public static int powerOfTwo(double x){
  if (x <= 0.0) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + x);
  }
  double m=Math.log(x) * _LOG2SCALE;
  int exp=(int)Math.ceil(m);
  return 1 << exp;
}"
76444,"private static double[] _DCT(double[] x,int size,int order){
  double[] retval;
  if (size == 2) {
    retval=new double[2];
    retval[0]=x[0] + x[1];
    retval[1]=_ONEOVERROOT2 * (x[0] - x[1]);
    return retval;
  }
  int halfN=size >> 1;
  double[] x4=new double[size];
  for (int n=0; n < halfN; n++) {
    int twoN=n << 1;
    x4[n]=x[twoN];
    x4[size - n - 1]=x[twoN + 1];
  }
  double[] cosDFTarray=_cosDFT(x4,size,order);
  double[] sinDFTarray=_sinDFT(x4,size,order);
  double[] p1tab=_P1Table[order];
  double[] p2tab=_P2Table[order];
  double[] ctab=_CTable[order];
  retval=new double[size];
  retval[0]=cosDFTarray[0];
  for (int k=1; k < halfN; k++) {
    double m1=(cosDFTarray[k] + sinDFTarray[k]) * ctab[k];
    double m2=sinDFTarray[k] * p1tab[k];
    double m3=cosDFTarray[k] * p2tab[k];
    retval[k]=m1 - m2;
    retval[size - k]=m1 + m3;
  }
  retval[halfN]=_ONEOVERROOT2 * cosDFTarray[halfN];
  return retval;
}","private static double[] _DCT(double[] x,int size,int order){
  double[] retval;
  if (size == 1) {
    retval=new double[1];
    retval[0]=x[0];
    return retval;
  }
  if (size == 2) {
    retval=new double[2];
    retval[0]=x[0] + x[1];
    retval[1]=_ONEOVERROOT2 * (x[0] - x[1]);
    return retval;
  }
  int halfN=size >> 1;
  double[] x4=new double[size];
  for (int n=0; n < halfN; n++) {
    int twoN=n << 1;
    x4[n]=x[twoN];
    x4[size - n - 1]=x[twoN + 1];
  }
  double[] cosDFTarray=_cosDFT(x4,size,order);
  double[] sinDFTarray=_sinDFT(x4,size,order);
  double[] p1tab=_P1Table[order];
  double[] p2tab=_P2Table[order];
  double[] ctab=_CTable[order];
  retval=new double[size];
  retval[0]=cosDFTarray[0];
  for (int k=1; k < halfN; k++) {
    double m1=(cosDFTarray[k] + sinDFTarray[k]) * ctab[k];
    double m2=sinDFTarray[k] * p1tab[k];
    double m3=cosDFTarray[k] * p2tab[k];
    retval[k]=m1 - m2;
    retval[size - k]=m1 + m3;
  }
  retval[halfN]=_ONEOVERROOT2 * cosDFTarray[halfN];
  return retval;
}"
76445,"/** 
 * Return the ""order"" of a transform size, i.e. the base-2 logarithm of the size. The order will be rounded up to the nearest integer.
 * @param size The size of the transform.
 * @retval The order of the transform.
 */
public static int order(int size){
  double m=Math.log(size) * _LOG2SCALE;
  double exp=Math.ceil(m);
  return (int)exp;
}","/** 
 * Return the ""order"" of a transform size, i.e. the base-2 logarithm of the size. The order will be rounded up to the nearest integer. If the size is zero or negative, throw an IllegalArgumentException.
 * @param size The size of the transform.
 * @retval The order of the transform.
 */
public static int order(int size){
  if (size <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  double m=Math.log(size) * _LOG2SCALE;
  double exp=Math.ceil(m);
  return (int)exp;
}"
76446,"private static Complex[] _checkTransformArgs(Complex[] x,int order){
  _checkTransformInput(x);
  _checkTransformOrder(order);
  int size=1 << order;
  if (x.length < size) {
    x=ComplexArrayMath.resize(x,size);
  }
  return x;
}","private static Complex[] _checkTransformArgs(Complex[] x,int order){
  _checkTransformOrder(order);
  int size=1 << order;
  if (x.length < size) {
    x=ComplexArrayMath.resize(x,size);
  }
  return x;
}"
76447,"private static void _checkTransformOrder(int order){
  if (order < 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (order > 31) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","private static void _checkTransformOrder(int order){
  if (order < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (order > 31) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
76448,"/** 
 * Return a new array of doubles that is the forward DCT of the  input array of doubles. See the DCT_TYPE_XXX constants for documentation of the exact formula, which depends on the type.
 * @param x An array of doubles.
 * @param order The base-2 logarithm of the size of the transform.
 * @param type An integer specifying which type of DCT.
 * @retval A new array of doubles.
 */
public static double[] DCT(double[] x,int order,int type){
  if (type >= DCT_TYPES) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  int size=1 << order;
  if (order > _FFCTGenLimit)   _FFCTTableGen(order);
  double[] retval=_DCT(x,size,order);
switch (type) {
case DCT_TYPE_ORTHONORMAL:
    double factor=Math.sqrt(2.0 / size);
  retval=DoubleArrayMath.scale(retval,factor);
case DCT_TYPE_NORMALIZED:
retval[0]*=_ONEOVERROOT2;
break;
}
return retval;
}","/** 
 * Return a new array of doubles that is the forward DCT of the  input array of doubles. See the DCT_TYPE_XXX constants for documentation of the exact formula, which depends on the type.
 * @param x An array of doubles.
 * @param order The base-2 logarithm of the size of the transform.
 * @param type An integer specifying which type of DCT.
 * @retval A new array of doubles.
 */
public static double[] DCT(double[] x,int order,int type){
  _checkTransformArgs(x,order);
  if (type >= DCT_TYPES) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  int size=1 << order;
  if (order > _FFCTGenLimit)   _FFCTTableGen(order);
  double[] retval=_DCT(x,size,order);
switch (type) {
case DCT_TYPE_ORTHONORMAL:
    double factor=Math.sqrt(2.0 / size);
  retval=DoubleArrayMath.scale(retval,factor);
case DCT_TYPE_NORMALIZED:
retval[0]*=_ONEOVERROOT2;
break;
}
return retval;
}"
76449,"private Object _leastElementNodeId(int[] ids){
  LinkedList incompList=new LinkedList();
  int candidate=-1;
  for (int i=0; i < ids.length; i++) {
    boolean listEmpty=incompList.size() == 0;
    if (candidate == -1 && listEmpty) {
      candidate=ids[i];
    }
 else     if (candidate != -1 && listEmpty) {
      int result=_compareNodeId(ids[i],candidate);
      if (result == LOWER) {
        candidate=ids[i];
      }
 else       if (result == INCOMPARABLE) {
        incompList.insertLast(new Integer(candidate));
        incompList.insertLast(new Integer(ids[i]));
        candidate=-1;
      }
    }
 else     if (candidate == -1 && !listEmpty) {
      boolean discard=false;
      LinkedList newList=new LinkedList();
      for (Enumeration e=incompList.elements(); e.hasMoreElements(); ) {
        Integer node=(Integer)e.nextElement();
        int listValue=node.intValue();
        int result=_compareNodeId(ids[i],listValue);
        if (result == LOWER) {
        }
 else         if (result == HIGHER) {
          discard=true;
          newList.insertLast(node);
          break;
        }
 else {
          newList.insertLast(node);
        }
      }
      incompList=newList;
      if (incompList.size() == 0) {
        candidate=ids[i];
      }
 else       if (!discard) {
        incompList.insertLast(_getNodeObject(ids[i]));
      }
    }
 else {
      throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (candidate == -1) {
    return null;
  }
 else {
    return _getNodeObject(candidate);
  }
}","private Object _leastElementNodeId(int[] ids){
  LinkedList incompList=new LinkedList();
  int candidate=-1;
  for (int i=0; i < ids.length; i++) {
    boolean listEmpty=incompList.size() == 0;
    if (candidate == -1 && listEmpty) {
      candidate=ids[i];
    }
 else     if (candidate != -1 && listEmpty) {
      int result=_compareNodeId(ids[i],candidate);
      if (result == LOWER) {
        candidate=ids[i];
      }
 else       if (result == INCOMPARABLE) {
        incompList.insertLast(new Integer(candidate));
        incompList.insertLast(new Integer(ids[i]));
        candidate=-1;
      }
    }
 else     if (candidate == -1 && !listEmpty) {
      boolean discard=false;
      LinkedList newList=new LinkedList();
      for (Enumeration e=incompList.elements(); e.hasMoreElements(); ) {
        Integer node=(Integer)e.nextElement();
        int listValue=node.intValue();
        int result=_compareNodeId(ids[i],listValue);
        if (result == LOWER) {
        }
 else         if (result == HIGHER) {
          discard=true;
          newList.insertLast(node);
          break;
        }
 else {
          newList.insertLast(node);
        }
      }
      incompList=newList;
      if (incompList.size() == 0) {
        candidate=ids[i];
      }
 else       if (!discard) {
        incompList.insertLast(new Integer(ids[i]));
      }
    }
 else {
      throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (candidate == -1) {
    return null;
  }
 else {
    return _getNodeObject(candidate);
  }
}"
76450,"private Object _leastElementNodeId(int[] ids){
  LinkedList incompList=new LinkedList();
  int candidate=-1;
  for (int i=0; i < ids.length; i++) {
    boolean listEmpty=incompList.size() == 0;
    if (candidate == -1 && listEmpty) {
      candidate=ids[i];
    }
 else     if (candidate != -1 && listEmpty) {
      int result=_compareNodeId(ids[i],candidate);
      if (result == LOWER) {
        candidate=ids[i];
      }
 else       if (result == INCOMPARABLE) {
        incompList.insertLast(new Integer(candidate));
        incompList.insertLast(new Integer(ids[i]));
        candidate=-1;
      }
    }
 else     if (candidate == -1 && !listEmpty) {
      boolean discard=false;
      LinkedList newList=new LinkedList();
      for (Enumeration e=incompList.elements(); e.hasMoreElements(); ) {
        Integer node=(Integer)e.nextElement();
        int listValue=node.intValue();
        int result=_compareNodeId(ids[i],listValue);
        if (result == LOWER) {
        }
 else         if (result == HIGHER) {
          discard=true;
          newList.insertLast(node);
          break;
        }
 else {
          newList.insertLast(node);
        }
      }
      incompList=newList;
      if (incompList.size() == 0) {
        candidate=ids[i];
      }
 else       if (!discard) {
        incompList.insertLast(new Integer(ids[i]));
      }
    }
 else {
      throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (candidate == -1) {
    return null;
  }
 else {
    return _getNodeObject(candidate);
  }
}","private Object _leastElementNodeId(int[] ids){
  LinkedList incompList=new LinkedList();
  int candidate=-1;
  for (int i=0; i < ids.length; i++) {
    boolean listEmpty=incompList.size() == 0;
    if (candidate == -1 && listEmpty) {
      candidate=ids[i];
    }
 else     if (candidate != -1 && listEmpty) {
      int result=_compareNodeId(ids[i],candidate);
      if (result == LOWER) {
        candidate=ids[i];
      }
 else       if (result == INCOMPARABLE) {
        incompList.insertLast(new Integer(candidate));
        incompList.insertLast(new Integer(ids[i]));
        candidate=-1;
      }
    }
 else     if (candidate == -1 && !listEmpty) {
      boolean discard=false;
      LinkedList newList=new LinkedList();
      for (Enumeration e=incompList.elements(); e.hasMoreElements(); ) {
        Integer node=(Integer)e.nextElement();
        int listValue=node.intValue();
        int result=_compareNodeId(ids[i],listValue);
        if (result == LOWER) {
        }
 else         if (result == HIGHER || result == SAME) {
          discard=true;
          newList=incompList;
          break;
        }
 else {
          newList.insertLast(node);
        }
      }
      incompList=newList;
      if (incompList.size() == 0) {
        candidate=ids[i];
      }
 else       if (!discard) {
        incompList.insertLast(new Integer(ids[i]));
      }
    }
 else {
      throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (candidate == -1) {
    return null;
  }
 else {
    return _getNodeObject(candidate);
  }
}"
76451,"private static double[] _cosDFT(double[] x,int size,int order){
  if (size == 4) {
    double[] retval=new double[3];
    retval[0]=x[0] + x[1] + x[2]+ x[3];
    retval[1]=x[0] - x[2];
    retval[2]=x[0] - x[1] + x[2] - x[3];
    return retval;
  }
  int halfN=size >> 1;
  int quarterN=size >> 2;
  double[] x1=new double[halfN];
  for (int k=0; k < halfN; k++) {
    x1[k]=x[k << 1];
  }
  double[] x2=new double[quarterN];
  for (int k=0; k < quarterN; k++) {
    int twoIp=(k << 1) + 1;
    x2[k]=x[twoIp] + x[size - twoIp];
  }
  double[] halfCosDFT=_cosDFT(x1,halfN,order - 1);
  double[] quarterDCT=_DCT(x2,quarterN,order - 2);
  double[] retval=new double[halfN + 1];
  for (int k=0; k < quarterN; k++) {
    retval[k]=halfCosDFT[k] + quarterDCT[k];
  }
  retval[quarterN]=halfCosDFT[quarterN];
  for (int k=quarterN + 1; k <= halfN; k++) {
    int idx=halfN - k;
    retval[k]=halfCosDFT[idx] - quarterDCT[idx];
  }
  return retval;
}","private static double[] _cosDFT(double[] x,int size,int order){
switch (size) {
case 0:
    return new double[0];
case 1:
{
    double[] retval=new double[1];
    retval[0]=x[0];
    return retval;
  }
case 2:
{
  double[] retval=new double[2];
  retval[0]=x[0] + x[1];
  retval[1]=x[0] - x[1];
  return retval;
}
case 4:
{
double[] retval=new double[3];
retval[0]=x[0] + x[1] + x[2]+ x[3];
retval[1]=x[0] - x[2];
retval[2]=x[0] - x[1] + x[2] - x[3];
return retval;
}
}
int halfN=size >> 1;
int quarterN=size >> 2;
double[] x1=new double[halfN];
for (int k=0; k < halfN; k++) {
x1[k]=x[k << 1];
}
double[] x2=new double[quarterN];
for (int k=0; k < quarterN; k++) {
int twoIp=(k << 1) + 1;
x2[k]=x[twoIp] + x[size - twoIp];
}
double[] halfCosDFT=_cosDFT(x1,halfN,order - 1);
double[] quarterDCT=_DCT(x2,quarterN,order - 2);
double[] retval=new double[halfN + 1];
for (int k=0; k < quarterN; k++) {
retval[k]=halfCosDFT[k] + quarterDCT[k];
}
retval[quarterN]=halfCosDFT[quarterN];
for (int k=quarterN + 1; k <= halfN; k++) {
int idx=halfN - k;
retval[k]=halfCosDFT[idx] - quarterDCT[idx];
}
return retval;
}"
76452,"private static double[] _sinDFT(double[] x,int size,int order){
  if (size == 4) {
    double[] retval=new double[2];
    retval[1]=x[1] - x[3];
    return retval;
  }
  int halfN=size >> 1;
  int quarterN=size >> 2;
  double[] x1=new double[halfN];
  for (int k=0; k < halfN; k++) {
    x1[k]=x[k << 1];
  }
  double[] x3=new double[quarterN];
  for (int k=0; k < quarterN; k++) {
    int twoIp=(k << 1) + 1;
    x3[k]=((k & 1) == 1) ? (x[size - twoIp] - x[twoIp]) : (x[twoIp] - x[size - twoIp]);
  }
  double[] halfSinDFT=_sinDFT(x1,halfN,order - 1);
  double[] quarterDCT=_DCT(x3,quarterN,order - 2);
  double[] retval=new double[halfN];
  for (int k=1; k < quarterN; k++) {
    retval[k]=halfSinDFT[k] + quarterDCT[quarterN - k];
  }
  retval[quarterN]=quarterDCT[0];
  for (int k=quarterN + 1; k < halfN; k++) {
    retval[k]=quarterDCT[k - quarterN] - halfSinDFT[halfN - k];
  }
  return retval;
}","private static double[] _sinDFT(double[] x,int size,int order){
switch (size) {
case 0:
case 1:
case 2:
    return null;
case 4:
{
    double[] retval=new double[2];
    retval[1]=x[1] - x[3];
  }
}
int halfN=size >> 1;
int quarterN=size >> 2;
double[] x1=new double[halfN];
for (int k=0; k < halfN; k++) {
x1[k]=x[k << 1];
}
double[] x3=new double[quarterN];
for (int k=0; k < quarterN; k++) {
int twoIp=(k << 1) + 1;
x3[k]=((k & 1) == 1) ? (x[size - twoIp] - x[twoIp]) : (x[twoIp] - x[size - twoIp]);
}
double[] halfSinDFT=_sinDFT(x1,halfN,order - 1);
double[] quarterDCT=_DCT(x3,quarterN,order - 2);
double[] retval=new double[halfN];
for (int k=1; k < quarterN; k++) {
retval[k]=halfSinDFT[k] + quarterDCT[quarterN - k];
}
retval[quarterN]=quarterDCT[0];
for (int k=quarterN + 1; k < halfN; k++) {
retval[k]=quarterDCT[k - quarterN] - halfSinDFT[halfN - k];
}
return retval;
}"
76453,"/** 
 * Set the Manager for execution of this CompositeActor. This can only be done for a composite actor that has no container. For others, the Manager is inherited from the container. This method is write-synchronized on the workspace.
 * @param manager The Manager
 * @exception IllegalActionException If this actor has a container.
 * @see getManager
 */
public void setManager(Manager manager) throws IllegalActionException {
  try {
    workspace().getWriteAccess();
    if (getContainer() != null && manager != null) {
      throw new IllegalActionException(this,manager,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_manager != null)     _manager._makeManagerOf(null);
    if (manager != null) {
      manager._makeManagerOf(this);
    }
    _manager=manager;
    return;
  }
  finally {
    workspace().doneWriting();
  }
}","/** 
 * Set the Manager for execution of this CompositeActor. This can only be done for a composite actor that has no container. For others, the Manager is inherited from the container. This method is write-synchronized on the workspace.
 * @param manager The Manager
 * @exception IllegalActionException If this actor already has a container, or the manager is not in the same workspace as this  actor.
 * @see getManager
 */
public void setManager(Manager manager) throws IllegalActionException {
  if (manager != null && workspace() != manager.workspace()) {
    throw new IllegalActionException(this,manager,""String_Node_Str"");
  }
  try {
    workspace().getWriteAccess();
    if (getContainer() != null && manager != null) {
      throw new IllegalActionException(this,manager,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_manager != null)     _manager._makeManagerOf(null);
    if (manager != null) {
      manager._makeManagerOf(this);
    }
    _manager=manager;
    return;
  }
  finally {
    workspace().doneWriting();
  }
}"
76454,"/** 
 * Set the local director for execution of this CompositeActor. Calling this method with a non-null argument makes this entity opaque. Calling it with a null argument makes it transparent. The container of the specified director is set to this composite actor, and if there was previously a local director, its container is set to null. This method is write-synchronized on the workspace.
 * @param director The Director responsible for execution.
 * @exception IllegalActionException Not thrown in this base class,but derived classes may throw it if the director is not compatible.
 */
public void setDirector(Director director) throws IllegalActionException {
  try {
    workspace().getWriteAccess();
    if (_director != null)     _director._makeDirectorOf(null);
    if (director != null) {
      director._makeDirectorOf(this);
    }
    _director=director;
  }
  finally {
    workspace().doneWriting();
  }
}","/** 
 * Set the local director for execution of this CompositeActor. Calling this method with a non-null argument makes this entity opaque. Calling it with a null argument makes it transparent. The container of the specified director is set to this composite actor, and if there was previously a local director, its container is set to null. This method is write-synchronized on the workspace.
 * @param director The Director responsible for execution.
 * @exception IllegalActionException If the director is not inthe same workspace as this actor.  It may also be throw in derived classed if the director is not compatible.
 */
public void setDirector(Director director) throws IllegalActionException {
  if (director != null && workspace() != director.workspace()) {
    throw new IllegalActionException(this,director,""String_Node_Str"");
  }
  try {
    workspace().getWriteAccess();
    if (_director != null)     _director._makeDirectorOf(null);
    if (director != null) {
      director._makeDirectorOf(this);
    }
    _director=director;
  }
  finally {
    workspace().doneWriting();
  }
}"
76455,"/** 
 * Make this director the local director of the specified composite actor.  This method should not be called directly.  Instead, call setDirector of the CompositeActor class (or a derived class).
 */
protected void _makeDirectorOf(CompositeActor cast){
  _container=cast;
  if (cast != null) {
    workspace().remove(this);
  }
}","/** 
 * Make this director the local director of the specified composite actor.  If the CompositeActor is not null, then remove the Actor from the workspace directory. If the CompositeActor is null, then  the director is not added back into the directory of the Workspace,  which could result in it being garbage collected. This method should not be called directly.  Instead, call setDirector of the CompositeActor class (or a derived class).
 */
protected void _makeDirectorOf(CompositeActor cast){
  _container=cast;
  if (cast != null) {
    workspace().remove(this);
  }
}"
76456,"/** 
 * Make this Manager the Manager of the specified composite actor.  This method should not be called directly.  Instead, call setManager of the CompositeActor class (or a derived class). If the argument is not the toplevel CompositeActor, then we throw an InvalidStateException.
 */
protected void _makeManagerOf(CompositeActor ca){
  if (ca != null) {
    if (ca.getContainer() != null)     throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
    workspace().remove(this);
  }
  _toplevel=ca;
}","/** 
 * Make this Manager the Manager of the specified composite actor. If the CompositeActor is not null, then the Manager is  removed from the directory of the workspace.  If the CompositeActor is null, then the MAnager is *not* returned to the directory of the workspace, which may result in it being garbage collected. This method should not be called directly.  Instead, call setManager of the CompositeActor class (or a derived class).
 */
protected void _makeManagerOf(CompositeActor ca){
  if (ca != null) {
    workspace().remove(this);
  }
  _toplevel=ca;
}"
76457,"/** 
 * Set the scheduler for this StaticSchedulingDirector. The container of the specified scheduler is set to this director. If there was a previous scheduler, the container of that scheduler is set to null. This method is write-synchronized on the workspace. If the scheduler is not compatible with the director, an IllegalActionException is thrown.
 * @param director The Director responsible for execution.
 * @exception IllegalActionException Not thrown in this base class,but derived classes may throw it if the scheduler is not compatible.
 */
public void setScheduler(Scheduler scheduler) throws IllegalActionException {
  try {
    workspace().getWriteAccess();
    if (_scheduler != null)     _scheduler._makeSchedulerOf(null);
    if (scheduler != null) {
      scheduler._makeSchedulerOf(this);
    }
    _scheduler=scheduler;
  }
  finally {
    workspace().doneWriting();
  }
}","/** 
 * Set the scheduler for this StaticSchedulingDirector. The container of the specified scheduler is set to this director. If there was a previous scheduler, the container of that scheduler is set to null. This method is write-synchronized on the workspace. If the scheduler is not compatible with the director, an IllegalActionException is thrown.
 * @param director The Director responsible for execution.
 * @exception IllegalActionException Not thrown in this base class,but derived classes may throw it if the scheduler is not compatible.
 */
public void setScheduler(Scheduler scheduler) throws IllegalActionException {
  if (scheduler != null && workspace() != scheduler.workspace()) {
    throw new IllegalActionException(this,scheduler,""String_Node_Str"");
  }
  try {
    workspace().getWriteAccess();
    if (_scheduler != null)     _scheduler._makeSchedulerOf(null);
    if (scheduler != null) {
      scheduler._makeSchedulerOf(this);
    }
    _scheduler=scheduler;
  }
  finally {
    workspace().doneWriting();
  }
}"
76458,"/** 
 * Ends the execution of the model under the control of this director. A flag is set in all the receivers which causes  each process to terminate at the earliest communication point. <P> This method is not synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException if an error occurs whileaccessing the receivers of all actors under the contol of this director.
 */
public void finish() throws IllegalActionException {
  CompositeActor cont=(CompositeActor)getContainer();
  Enumeration allMyActors=cont.deepGetEntities();
  Enumeration actorPorts;
  ProcessReceiver nextRec;
  LinkedList recs=new LinkedList();
  while (allMyActors.hasMoreElements()) {
    Actor actor=(Actor)allMyActors.nextElement();
    actorPorts=actor.inputPorts();
    while (actorPorts.hasMoreElements()) {
      IOPort port=(IOPort)actorPorts.nextElement();
      Receiver[][] receivers=port.getReceivers();
      for (int i=0; i < receivers.length; i++) {
        for (int j=0; j < receivers[i].length; j++) {
          nextRec=(ProcessReceiver)receivers[i][j];
          nextRec.setFinish();
          recs.insertFirst(nextRec);
        }
      }
    }
    actorPorts=cont.outputPorts();
    while (actorPorts.hasMoreElements()) {
      IOPort port=(IOPort)actorPorts.nextElement();
      Receiver[][] receivers=port.getReceivers();
      for (int i=0; i < receivers.length; i++) {
        for (int j=0; j < receivers[i].length; j++) {
          nextRec=(ProcessReceiver)receivers[i][j];
          nextRec.setFinish();
          recs.insertFirst(nextRec);
        }
      }
    }
    (new NotifyThread(recs)).start();
  }
  return;
}","/** 
 * End the execution of the model under the control of this director. A flag is set in all the receivers which causes  each process to terminate at the earliest communication point. <P> This method is not synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException if an error occurs whileaccessing the receivers of all actors under the contol of this director.
 */
public void finish() throws IllegalActionException {
  CompositeActor cont=(CompositeActor)getContainer();
  Enumeration allMyActors=cont.deepGetEntities();
  Enumeration actorPorts;
  ProcessReceiver nextRec;
  LinkedList recs=new LinkedList();
  while (allMyActors.hasMoreElements()) {
    Actor actor=(Actor)allMyActors.nextElement();
    actorPorts=actor.inputPorts();
    while (actorPorts.hasMoreElements()) {
      IOPort port=(IOPort)actorPorts.nextElement();
      Receiver[][] receivers=port.getReceivers();
      for (int i=0; i < receivers.length; i++) {
        for (int j=0; j < receivers[i].length; j++) {
          nextRec=(ProcessReceiver)receivers[i][j];
          nextRec.setFinish();
          recs.insertFirst(nextRec);
        }
      }
    }
    actorPorts=cont.outputPorts();
    while (actorPorts.hasMoreElements()) {
      IOPort port=(IOPort)actorPorts.nextElement();
      Receiver[][] receivers=port.getReceivers();
      for (int i=0; i < receivers.length; i++) {
        for (int j=0; j < receivers[i].length; j++) {
          nextRec=(ProcessReceiver)receivers[i][j];
          nextRec.setFinish();
          recs.insertFirst(nextRec);
        }
      }
    }
    (new NotifyThread(recs)).start();
  }
  return;
}"
76459,"/** 
 * Put an array of objects in the queue and return true if this will not cause the capacity to be exceeded. Otherwise, do not put any of the object in the queue and return false.
 * @param element An array of objects to be put in the queue.
 * @return A boolean indicating success.
 */
public boolean putArray(Object element[]){
  if (_queuearray.length - _queuesize >= element.length) {
    int i;
    if (element.length <= (_queuearray.length - _queuefront)) {
      System.arraycopy(element,0,_queuearray,_queuefront,element.length);
      _queuefront+=element.length;
      if (_queuefront >= _queuearray.length)       _queuefront=_queuefront % _queuearray.length;
      _queuesize+=element.length;
    }
 else {
      System.arraycopy(element,0,_queuearray,_queuefront,_queuearray.length - _queuefront);
      System.arraycopy(element,_queuearray.length - _queuefront,_queuearray,0,element.length - (_queuearray.length - _queuefront));
      _queuefront+=element.length;
      if (_queuefront >= _queuearray.length)       _queuefront=_queuefront % _queuearray.length;
      _queuesize+=element.length;
    }
    return true;
  }
 else {
    if (_queuemaxcapacity == INFINITE_CAPACITY) {
      try {
        _resizeArray(_queuearray.length * 2);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      return put(element);
    }
 else     return false;
  }
}","/** 
 * Put an array of objects in the queue and return true if this will not cause the capacity to be exceeded. Otherwise, do not put any of the object in the queue and return false.
 * @param element An array of objects to be put in the queue.
 * @return A boolean indicating success.
 */
public boolean putArray(Object element[]){
  if (_queuearray.length - _queuesize >= element.length) {
    int i;
    if (element.length <= (_queuearray.length - _queuefront)) {
      System.arraycopy(element,0,_queuearray,_queuefront,element.length);
      _queuefront+=element.length;
      if (_queuefront >= _queuearray.length)       _queuefront=_queuefront % _queuearray.length;
      _queuesize+=element.length;
    }
 else {
      System.arraycopy(element,0,_queuearray,_queuefront,_queuearray.length - _queuefront);
      System.arraycopy(element,_queuearray.length - _queuefront,_queuearray,0,element.length - (_queuearray.length - _queuefront));
      _queuefront+=element.length;
      if (_queuefront >= _queuearray.length)       _queuefront=_queuefront % _queuearray.length;
      _queuesize+=element.length;
    }
    return true;
  }
 else {
    if (_queuemaxcapacity == INFINITE_CAPACITY) {
      try {
        _resizeArray(_queuearray.length * 2);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      return putArray(element);
    }
 else     return false;
  }
}"
76460,"/** 
 * Return true always. Set this input to last input.
 */
public boolean postfire() throws IllegalActionException {
  super.postfire();
  _lastInput=_thisInput;
  return true;
}","/** 
 * Return true always. Set this input to last input.
 */
public boolean postfire() throws IllegalActionException {
  super.postfire();
  _lastInput=_thisInput;
  _first=false;
  return true;
}"
76461,"/** 
 * consume this input.
 */
public void fire() throws IllegalActionException {
  _thisInput=((DoubleToken)input.get(0)).doubleValue();
  _success=true;
}","/** 
 * consume this input.
 */
public void fire() throws IllegalActionException {
  System.out.println(""String_Node_Str"" + getFullName() + ""String_Node_Str"");
  _thisInput=((DoubleToken)input.get(0)).doubleValue();
}"
76462,"/** 
 * Return true if this step did not cross the threshold.
 */
public boolean isThisStepSuccessful(){
  if (!_first) {
    _first=false;
    if (((_lastInput > _upperBound) && (_thisInput < _lowerBound)) || ((_lastInput < _lowerBound) && (_thisInput < _upperBound))) {
      _success=false;
      return false;
    }
  }
  return true;
}","/** 
 * Return true if this step did not cross the threshold.
 */
public boolean isThisStepSuccessful(){
  if (!_first) {
    if (((_lastInput >= _upperBound) && (_thisInput <= _lowerBound)) || ((_lastInput <= _lowerBound) && (_thisInput >= _upperBound))) {
      _success=false;
      return false;
    }
  }
  _success=true;
  return true;
}"
76463,"/** 
 * Read the input receiver, if there is an event, remember the value.
 * @return true Always.
 * @exception IllegalActionException Never thrown.
 */
public boolean postfire() throws IllegalActionException {
  if (input.hasToken(0)) {
    _lasteventvalue=((DoubleToken)input.get(0)).doubleValue();
    if (DEBUG) {
      CTDirector dir=(CTDirector)getDirector();
      System.out.println(""String_Node_Str"" + dir.getCurrentTime());
      System.out.println(""String_Node_Str"" + _lasteventvalue);
    }
  }
  return true;
}","/** 
 * Read the input receiver, if there is an event, remember the value.
 * @return true Always.
 * @exception IllegalActionException Never thrown.
 */
public boolean postfire() throws IllegalActionException {
  return true;
}"
76464,"public void initialize() throws IllegalActionException {
  InputStream source=null;
  Parameter p;
  p=(Parameter)getAttribute(""String_Node_Str"");
  _xframesize=((IntToken)p.getToken()).intValue();
  p=(Parameter)getAttribute(""String_Node_Str"");
  _yframesize=((IntToken)p.getToken()).intValue();
  p=(Parameter)getAttribute(""String_Node_Str"");
  _xpartsize=((IntToken)p.getToken()).intValue();
  p=(Parameter)getAttribute(""String_Node_Str"");
  _ypartsize=((IntToken)p.getToken()).intValue();
  _codewords=new IntToken[_yframesize * _xframesize / _ypartsize / _xpartsize];
  _part=new int[_ypartsize * _xpartsize];
  _partitions=new IntMatrixToken[_yframesize * _xframesize / _ypartsize / _xpartsize];
  p=(Parameter)getAttribute(""String_Node_Str"");
  String filename=((StringToken)p.getToken()).stringValue();
  try {
    if (filename != null) {
      if (_baseurl != null) {
        try {
          URL dataurl=new URL(_baseurl,filename);
          System.out.println(""String_Node_Str"" + dataurl);
          source=dataurl.openStream();
        }
 catch (        MalformedURLException e) {
          System.err.println(e.toString());
        }
catch (        FileNotFoundException e) {
          System.err.println(""String_Node_Str"" + ""String_Node_Str"" + e);
        }
catch (        IOException e) {
          System.err.println(""String_Node_Str"" + ""String_Node_Str"" + e);
        }
      }
 else {
        File sourcefile=new File(filename);
        if (!sourcefile.exists() || !sourcefile.isFile())         throw new IllegalActionException(""String_Node_Str"" + filename + ""String_Node_Str"");
        if (!sourcefile.canRead())         throw new IllegalActionException(""String_Node_Str"" + filename + ""String_Node_Str"");
        source=new FileInputStream(sourcefile);
      }
    }
    int i, j, y, x, size=1;
    byte temp[];
    for (i=0; i < 5; i++) {
      size=size * 2;
      temp=new byte[size];
      for (j=0; j < 256; j++) {
        _codebook[i][j]=new int[size];
        if (_fullread(source,temp) != size)         throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        for (x=0; x < size; x++)         _codebook[i][j][x]=temp[x] & 255;
      }
      source.skip(65536);
    }
  }
 catch (  Exception e) {
    throw new IllegalActionException(e.getMessage());
  }
 finally {
    if (source != null) {
      try {
        source.close();
      }
 catch (      IOException e) {
      }
    }
  }
}","public void initialize() throws IllegalActionException {
  InputStream source=null;
  Parameter p;
  p=(Parameter)getAttribute(""String_Node_Str"");
  _xframesize=((IntToken)p.getToken()).intValue();
  p=(Parameter)getAttribute(""String_Node_Str"");
  _yframesize=((IntToken)p.getToken()).intValue();
  p=(Parameter)getAttribute(""String_Node_Str"");
  _xpartsize=((IntToken)p.getToken()).intValue();
  p=(Parameter)getAttribute(""String_Node_Str"");
  _ypartsize=((IntToken)p.getToken()).intValue();
  _codewords=new IntToken[_yframesize * _xframesize / _ypartsize / _xpartsize];
  _part=new int[_ypartsize * _xpartsize];
  _partitions=new IntMatrixToken[_yframesize * _xframesize / _ypartsize / _xpartsize];
  p=(Parameter)getAttribute(""String_Node_Str"");
  String filename=((StringToken)p.getToken()).stringValue();
  try {
    if (filename != null) {
      if (_baseurl != null) {
        try {
          URL dataurl=new URL(_baseurl,filename);
          System.out.println(""String_Node_Str"" + dataurl);
          source=dataurl.openStream();
        }
 catch (        MalformedURLException e) {
          System.err.println(e.toString());
        }
catch (        FileNotFoundException e) {
          System.err.println(""String_Node_Str"" + ""String_Node_Str"" + e);
        }
catch (        IOException e) {
          System.err.println(""String_Node_Str"" + ""String_Node_Str"" + e);
        }
      }
 else {
        File sourcefile=new File(filename);
        if (!sourcefile.exists() || !sourcefile.isFile())         throw new IllegalActionException(""String_Node_Str"" + filename + ""String_Node_Str"");
        if (!sourcefile.canRead())         throw new IllegalActionException(""String_Node_Str"" + filename + ""String_Node_Str"");
        source=new FileInputStream(sourcefile);
      }
    }
    int i, j, y, x, size=1;
    byte temp[];
    for (i=0; i < 5; i++) {
      size=size * 2;
      temp=new byte[size];
      for (j=0; j < 256; j++) {
        _codebook[i][j]=new int[size];
        if (_fullread(source,temp) != size)         throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        for (x=0; x < size; x++)         _codebook[i][j][x]=temp[x] & 255;
      }
      temp=new byte[65536];
      if (_fullread(source,temp) != 65536)       throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    throw new IllegalActionException(e.getMessage());
  }
 finally {
    if (source != null) {
      try {
        source.close();
      }
 catch (      IOException e) {
      }
    }
  }
}"
76465,"/** 
 * Transfer data from an input port of the container to the ports it is connected to on the inside.  The port argument must be an opaque input port.  If any channel of the input port has no data, then that channel is ignored.
 * @exception IllegalActionException If the port is not an opaqueinput port.
 */
public void transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"");
  }
  Entity refine=(Entity)_controller.currentRefinement();
  IOPort p;
  Receiver rec;
  if (port.hasToken(0)) {
    try {
      Token t=port.get(0);
      p=(IOPort)_controller.getPort(port.getName());
      if (p != null) {
        rec=(p.getReceivers())[0][0];
        if (rec.hasToken()) {
          rec.get();
        }
        rec.put(t);
      }
      p=(IOPort)refine.getPort(port.getName());
      if (p != null) {
        rec=(p.getReceivers())[0][0];
        if (rec.hasToken()) {
          rec.get();
        }
        rec.put(t);
      }
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
    }
  }
}","/** 
 * Transfer data from an input port of the container to the ports it is connected to on the inside.  The port argument must be an opaque input port.  If any channel of the input port has no data, then that channel is ignored.
 * @exception IllegalActionException If the port is not an opaqueinput port.
 */
public void transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"");
  }
  Entity refine=(Entity)_controller.currentRefinement();
  IOPort p;
  Receiver rec;
  if (port.hasToken(0)) {
    try {
      Token t=port.get(0);
      p=(IOPort)_controller.getPort(port.getName());
      System.out.println(""String_Node_Str"" + ((ComponentEntity)_controller).getFullName());
      if (p != null) {
        rec=(p.getReceivers())[0][0];
        if (rec.hasToken()) {
          rec.get();
        }
        rec.put(t);
      }
      p=(IOPort)refine.getPort(port.getName());
      if (p != null) {
        rec=(p.getReceivers())[0][0];
        if (rec.hasToken()) {
          rec.get();
        }
        rec.put(t);
      }
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
    }
  }
}"
76466,"/** 
 * Create receivers and then invoke the initialize() methods of all its deeply contained actors.   <p> This method should be invoked once per execution, before any iteration. It may produce output data. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the initialize() method of thecontainer or one of the deeply contained actors throws it.
 */
public void initialize() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  if (container != null) {
    Enumeration allactors=container.deepGetEntities();
    while (allactors.hasMoreElements()) {
      Actor actor=(Actor)allactors.nextElement();
      actor.createReceivers();
      actor.initialize();
    }
  }
  System.out.println(""String_Node_Str"" + this.getFullName());
}","/** 
 * Create receivers and then invoke the initialize() methods of all its deeply contained actors.   <p> This method should be invoked once per execution, before any iteration. It may produce output data. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the initialize() method of thecontainer or one of the deeply contained actors throws it.
 */
public void initialize() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  if (container != null) {
    Enumeration allactors=container.deepGetEntities();
    while (allactors.hasMoreElements()) {
      Actor actor=(Actor)allactors.nextElement();
      if (actor == _controller) {
        continue;
      }
 else {
        actor.createReceivers();
        actor.initialize();
      }
    }
    _controller.createReceivers();
    _controller.initialize();
  }
  System.out.println(""String_Node_Str"" + this.getFullName());
}"
76467,"/** 
 * return True, indicating that the Director is ready to fire.    Domain Directors will probably want to override this method.   Note that this is called by the container of this Director to see if the Director is ready to execute, and  should *NOT*, in general, just take the logical AND of calling prefire on all the contained actors.
 * @return True if the Director wishes to be scheduled for anotheriteration
 * @exception IllegalActionException *Deprecate* If the postfire() method of the container or one of the deeply contained actors  throws it.
 */
public boolean prefire() throws IllegalActionException {
}","/** 
 * return True, indicating that the Director is ready to fire.    Domain Directors will probably want to override this method.   Note that this is called by the container of this Director to see if the Director is ready to execute, and  should *NOT*, in general, just take the logical AND of calling prefire on all the contained actors.
 * @return True if the Director wishes to be scheduled for anotheriteration
 * @exception IllegalActionException *Deprecate* If the postfire() method of the container or one of the deeply contained actors  throws it.
 */
public boolean prefire() throws IllegalActionException {
  Actor refine=_controller.currentRefinement();
  System.out.println(""String_Node_Str"");
  boolean result=true;
  if (refine != null) {
    result=refine.prefire();
  }
  return result;
}"
76468,"public void initialize() throws IllegalActionException {
  try {
    setupScope();
  }
 catch (  NameDuplicationException ex) {
    throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
  }
  if (_localVariables != null) {
    Enumeration localVars=_localVariables.getVariables();
    Variable var=null;
    while (localVars.hasMoreElements()) {
      var=(Variable)localVars.nextElement();
      var.reset();
    }
  }
  _setInputVars();
  _takenTransition=null;
  if (_initTrans != null) {
    Enumeration trs=_initTrans.elements();
    SCTransition trans;
    while (trs.hasMoreElements()) {
      trans=(SCTransition)trs.nextElement();
      if (trans.isEnabled()) {
        if (_takenTransition != null) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"");
        }
 else {
          _takenTransition=trans;
        }
      }
    }
  }
  if (_takenTransition != null) {
    _outputTriggerActions(_takenTransition.getTriggerActions());
    _updateLocalVariables(_takenTransition.getLocalVariableUpdates());
    _currentState=_takenTransition.destinationState();
  }
 else {
    _currentState=_initialState;
  }
  if (_currentState == null) {
    System.out.println(""String_Node_Str"");
  }
  if (currentRefinement() != null) {
    currentRefinement().createReceivers();
    currentRefinement().initialize();
    System.out.println(""String_Node_Str"" + ((ComponentEntity)currentRefinement()).getFullName());
  }
}","public void initialize() throws IllegalActionException {
  try {
    setupScope();
  }
 catch (  NameDuplicationException ex) {
    throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
  }
  if (_localVariables != null) {
    Enumeration localVars=_localVariables.getVariables();
    Variable var=null;
    while (localVars.hasMoreElements()) {
      var=(Variable)localVars.nextElement();
      var.reset();
    }
  }
  _setInputVars();
  _takenTransition=null;
  if (_initTrans != null) {
    Enumeration trs=_initTrans.elements();
    SCTransition trans;
    while (trs.hasMoreElements()) {
      trans=(SCTransition)trs.nextElement();
      if (trans.isEnabled()) {
        if (_takenTransition != null) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"");
        }
 else {
          _takenTransition=trans;
        }
      }
    }
  }
  if (_takenTransition != null) {
    _outputTriggerActions(_takenTransition.getTriggerActions());
    _updateLocalVariables(_takenTransition.getLocalVariableUpdates());
    _currentState=_takenTransition.destinationState();
  }
 else {
    _currentState=_initialState;
  }
  if (_currentState == null) {
    System.out.println(""String_Node_Str"");
  }
  if (currentRefinement() != null) {
    System.out.println(""String_Node_Str"" + ((ComponentEntity)currentRefinement()).getFullName());
  }
}"
76469,"/** 
 * return an Enumeration of the detail schedules. The first element in the Enumeration is the stateschedule, then transitionschedule, then output schedule, and then event generating schedule. Each schedule is an Enumeration of actors in their topological order. Each schedule can also be accessed by individual getXXSchedule method.
 * @return an Enumeration of sub-schedules.
 * @exception NotSchedulableException either the system constructionis wrong or arithmetic loop exists.
 */
protected Enumeration _schedule() throws NotSchedulableException {
  CTDirector dir=(CTDirector)getContainer();
  if (dir == null) {
    return null;
  }
  CompositeActor ca=(CompositeActor)(dir.getContainer());
  if (ca == null) {
    return null;
  }
  _stateschedule=new LinkedList();
  _transitionschedule=new LinkedList();
  _outputschedule=new LinkedList();
  _statessc=new LinkedList();
  _outputssc=new LinkedList();
  LinkedList _scheList=new LinkedList();
  DirectedAcyclicGraph g=_toGraph(ca.deepGetEntities());
  if (!g.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"");
  }
  _classifyActors();
  int numofdyn=_dynam.size();
  if (numofdyn > 0) {
    Object[] dynactors=new Object[numofdyn];
    Enumeration enumdynactors=_dynam.elements();
    int count=0;
    while (enumdynactors.hasMoreElements()) {
      dynactors[count++]=enumdynactors.nextElement();
    }
    Object[] xsort=g.topologicalSort(dynactors);
    for (int i=0; i < xsort.length; i++) {
      Actor a=(Actor)xsort[i];
      _stateschedule.insertFirst(a);
      if (a instanceof CTStepSizeControlActor) {
        _statessc.insertFirst(a);
      }
    }
    _scheList.insertLast(_stateschedule);
    Object[] fx=g.backwardReachableNodes(dynactors);
    Object[] fxsort=g.topologicalSort(fx);
    for (int i=0; i < fxsort.length; i++) {
      Actor a=(Actor)fxsort[i];
      _transitionschedule.insertLast(a);
      if (a instanceof CTStepSizeControlActor) {
        _statessc.insertFirst(a);
      }
    }
    _scheList.insertLast(_transitionschedule);
  }
  int numofsink=_sink.size();
  if (numofsink > 0) {
    Object[] sinkactors=new Object[numofsink];
    Enumeration enumsinks=_sink.elements();
    int count=0;
    while (enumsinks.hasMoreElements()) {
      sinkactors[count++]=enumsinks.nextElement();
    }
    Object[] gx=g.backwardReachableNodes(sinkactors);
    Object[] gxsort=g.topologicalSort(gx);
    for (int i=0; i < gxsort.length; i++) {
      Actor a=(Actor)gxsort[i];
      _outputschedule.insertLast(a);
      if (a instanceof CTStepSizeControlActor) {
        _outputssc.insertFirst(a);
      }
    }
    _outputschedule.appendElements(_sink.elements());
    _scheList.insertLast(_outputschedule);
  }
  return _scheList.elements();
}","/** 
 * return an Enumeration of the detail schedules. The first element in the Enumeration is the stateschedule, then transitionschedule, then output schedule, and then event generating schedule. Each schedule is an Enumeration of actors in their topological order. Each schedule can also be accessed by individual getXXSchedule method.
 * @return an Enumeration of sub-schedules.
 * @exception NotSchedulableException either the system constructionis wrong or arithmetic loop exists.
 */
protected Enumeration _schedule() throws NotSchedulableException {
  CTDirector dir=(CTDirector)getContainer();
  if (dir == null) {
    return null;
  }
  CompositeActor ca=(CompositeActor)(dir.getContainer());
  if (ca == null) {
    return null;
  }
  _stateschedule=new LinkedList();
  _transitionschedule=new LinkedList();
  _outputschedule=new LinkedList();
  _statessc=new LinkedList();
  _outputssc=new LinkedList();
  LinkedList _scheList=new LinkedList();
  _classifyActors();
  DirectedAcyclicGraph g=_toArithGraph(ca.deepGetEntities());
  DirectedAcyclicGraph gd=_toGraph(dynamicActors());
  if (!g.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"");
  }
  int numofdyn=_dynam.size();
  if (numofdyn > 0) {
    Object[] dynactors=new Object[numofdyn];
    Enumeration enumdynactors=_dynam.elements();
    int count=0;
    while (enumdynactors.hasMoreElements()) {
      dynactors[count++]=enumdynactors.nextElement();
    }
    Object[] xsort=gd.topologicalSort(dynactors);
    for (int i=0; i < xsort.length; i++) {
      Actor a=(Actor)xsort[i];
      _stateschedule.insertFirst(a);
      if (a instanceof CTStepSizeControlActor) {
        _statessc.insertFirst(a);
      }
    }
    _scheList.insertLast(_stateschedule);
    Object[] fx=g.backwardReachableNodes(dynactors);
    Object[] fxsort=g.topologicalSort(fx);
    for (int i=0; i < fxsort.length; i++) {
      Actor a=(Actor)fxsort[i];
      _transitionschedule.insertLast(a);
      if (a instanceof CTStepSizeControlActor) {
        _statessc.insertFirst(a);
      }
    }
    _scheList.insertLast(_transitionschedule);
  }
  int numofsink=_sink.size();
  if (numofsink > 0) {
    Object[] sinkactors=new Object[numofsink];
    Enumeration enumsinks=_sink.elements();
    int count=0;
    while (enumsinks.hasMoreElements()) {
      sinkactors[count++]=enumsinks.nextElement();
    }
    Object[] gx=g.backwardReachableNodes(sinkactors);
    Object[] gxsort=g.topologicalSort(gx);
    for (int i=0; i < gxsort.length; i++) {
      Actor a=(Actor)gxsort[i];
      _outputschedule.insertLast(a);
      if (a instanceof CTStepSizeControlActor) {
        _outputssc.insertFirst(a);
      }
    }
    _outputschedule.appendElements(_sink.elements());
    _scheList.insertLast(_outputschedule);
  }
  return _scheList.elements();
}"
76470,"/** 
 * Convert the given actors to a directed acyclic graph. CTDynamicActors are treated as sinks. Each actor in the given enumeration is a node in the graph,  each link between a pair of actors is a edge between the corresponding nodes unless the source node is a dynamic actor. The presentance of the director and containers is not checked in this method, so the caller should check.
 * @return A graph representation of the actors.
 */
protected DirectedAcyclicGraph _toGraph(Enumeration actors){
  CTDirector dir=(CTDirector)getContainer();
  CompositeActor ca=(CompositeActor)(dir.getContainer());
  DirectedAcyclicGraph g=new DirectedAcyclicGraph();
  LinkedList actorlist=new LinkedList();
  while (actors.hasMoreElements()) {
    AtomicActor a=(AtomicActor)actors.nextElement();
    g.add(a);
    actorlist.insertLast(a);
  }
  Enumeration allactors=actorlist.elements();
  while (allactors.hasMoreElements()) {
    Actor a=(Actor)allactors.nextElement();
    if (!(a instanceof CTDynamicActor)) {
      Enumeration successors=_successors(a);
      while (successors.hasMoreElements()) {
        Actor s=(Actor)successors.nextElement();
        if (actorlist.includes(s)) {
          g.addEdge(a,s);
        }
      }
    }
  }
  return g;
}","/** 
 * Convert the given actors to a directed acyclic graph. CTDynamicActors are NOT treated as sinks. Each actor in the given enumeration is a node in the graph,  each link between a pair of actors is a edge between the corresponding nodes unless the source node is a dynamic actor. The presentance of the director and containers is not checked in this method, so the caller should check.
 * @return A graph representation of the actors.
 */
protected DirectedAcyclicGraph _toGraph(Enumeration actors){
  CTDirector dir=(CTDirector)getContainer();
  CompositeActor ca=(CompositeActor)(dir.getContainer());
  DirectedAcyclicGraph g=new DirectedAcyclicGraph();
  LinkedList actorlist=new LinkedList();
  while (actors.hasMoreElements()) {
    AtomicActor a=(AtomicActor)actors.nextElement();
    g.add(a);
    actorlist.insertLast(a);
  }
  Enumeration allactors=actorlist.elements();
  while (allactors.hasMoreElements()) {
    Actor a=(Actor)allactors.nextElement();
    Enumeration successors=_successors(a);
    while (successors.hasMoreElements()) {
      Actor s=(Actor)successors.nextElement();
      if (actorlist.includes(s)) {
        g.addEdge(a,s);
      }
    }
  }
  return g;
}"
76471,"/** 
 * Initialize the applet.
 */
public void init(){
  Color background=Color.white;
  try {
    String colorspec=getParameter(""String_Node_Str"");
    if (colorspec != null) {
      background=Color.decode(colorspec);
    }
  }
 catch (  Exception ex) {
  }
  setBackground(background);
  Button _goButton=new Button(""String_Node_Str"");
  setLayout(new BorderLayout());
  Panel controlPanel=new Panel();
  add(controlPanel,""String_Node_Str"");
  controlPanel.add(_goButton);
  _goButton.addActionListener(new GoButtonListener());
  Panel displayPanel=new Panel();
  add(displayPanel);
  displayPanel.setLayout(new BorderLayout(15,15));
  displayPanel.setSize(420,200);
  Panel originalPanel=new Panel();
  originalPanel.setSize(200,200);
  displayPanel.add(originalPanel,""String_Node_Str"");
  Panel compressedPanel=new Panel();
  compressedPanel.setSize(200,200);
  displayPanel.add(compressedPanel,""String_Node_Str"");
  validate();
  try {
    _manager=new Manager();
    TypedCompositeActor c=new TypedCompositeActor();
    SDFDirector d=new SDFDirector();
    SDFScheduler s=new SDFScheduler();
    TypedIORelation r;
    c.setDirector(d);
    c.setManager(_manager);
    d.setScheduler(s);
    d.setScheduleValid(false);
    ImageSequence source=new ImageSequence(c,""String_Node_Str"");
    source.setBaseURL(getDocumentBase());
    ImagePartition part=new ImagePartition(c,""String_Node_Str"");
    HTVQEncode encode=new HTVQEncode(c,""String_Node_Str"");
    encode.setBaseURL(getDocumentBase());
    VQDecode decode=new VQDecode(c,""String_Node_Str"");
    encode.setBaseURL(getDocumentBase());
    ImageUnpartition unpart=new ImageUnpartition(c,""String_Node_Str"");
    ImageDisplay consumer=new ImageDisplay(c,""String_Node_Str"");
    ImageDisplay original=new ImageDisplay(c,""String_Node_Str"");
    consumer.setPanel(compressedPanel);
    original.setPanel(originalPanel);
    r=(TypedIORelation)c.connect((TypedIOPort)source.getPort(""String_Node_Str""),(TypedIOPort)part.getPort(""String_Node_Str""),""String_Node_Str"");
    ((TypedIOPort)original.getPort(""String_Node_Str"")).link(r);
    r=(TypedIORelation)c.connect((TypedIOPort)part.getPort(""String_Node_Str""),(TypedIOPort)encode.getPort(""String_Node_Str""),""String_Node_Str"");
    r=(TypedIORelation)c.connect((TypedIOPort)encode.getPort(""String_Node_Str""),(TypedIOPort)decode.getPort(""String_Node_Str""),""String_Node_Str"");
    r=(TypedIORelation)c.connect((TypedIOPort)decode.getPort(""String_Node_Str""),(TypedIOPort)unpart.getPort(""String_Node_Str""),""String_Node_Str"");
    r=(TypedIORelation)c.connect((TypedIOPort)unpart.getPort(""String_Node_Str""),(TypedIOPort)consumer.getPort(""String_Node_Str""),""String_Node_Str"");
    Parameter p=(Parameter)d.getAttribute(""String_Node_Str"");
    p.setToken(new IntToken(60));
  }
 catch (  Exception ex) {
    System.err.println(""String_Node_Str"" + ex.getMessage());
    ex.printStackTrace();
  }
  validate();
}","/** 
 * Initialize the applet.
 */
public void init(){
  Color background=Color.white;
  try {
    String colorspec=getParameter(""String_Node_Str"");
    if (colorspec != null) {
      background=Color.decode(colorspec);
    }
  }
 catch (  Exception ex) {
  }
  setBackground(background);
  Button _goButton=new Button(""String_Node_Str"");
  setLayout(new BorderLayout());
  Panel controlPanel=new Panel();
  add(controlPanel,""String_Node_Str"");
  controlPanel.add(_goButton);
  _goButton.addActionListener(new GoButtonListener());
  Panel displayPanel=new Panel();
  add(displayPanel);
  displayPanel.setLayout(new BorderLayout(15,15));
  displayPanel.setSize(420,200);
  Panel originalPanel=new Panel();
  originalPanel.setSize(200,200);
  displayPanel.add(originalPanel,""String_Node_Str"");
  Panel compressedPanel=new Panel();
  compressedPanel.setSize(200,200);
  displayPanel.add(compressedPanel,""String_Node_Str"");
  validate();
  try {
    _manager=new Manager();
    TypedCompositeActor c=new TypedCompositeActor();
    SDFDirector d=new SDFDirector();
    SDFScheduler s=new SDFScheduler();
    TypedIORelation r;
    c.setDirector(d);
    c.setManager(_manager);
    d.setScheduler(s);
    d.setScheduleValid(false);
    ImageSequence source=new ImageSequence(c,""String_Node_Str"");
    source.setBaseURL(getDocumentBase());
    ImagePartition part=new ImagePartition(c,""String_Node_Str"");
    HTVQEncode encode=new HTVQEncode(c,""String_Node_Str"");
    encode.setBaseURL(getDocumentBase());
    VQDecode decode=new VQDecode(c,""String_Node_Str"");
    decode.setBaseURL(getDocumentBase());
    ImageUnpartition unpart=new ImageUnpartition(c,""String_Node_Str"");
    ImageDisplay consumer=new ImageDisplay(c,""String_Node_Str"");
    ImageDisplay original=new ImageDisplay(c,""String_Node_Str"");
    consumer.setPanel(compressedPanel);
    original.setPanel(originalPanel);
    r=(TypedIORelation)c.connect((TypedIOPort)source.getPort(""String_Node_Str""),(TypedIOPort)part.getPort(""String_Node_Str""),""String_Node_Str"");
    ((TypedIOPort)original.getPort(""String_Node_Str"")).link(r);
    r=(TypedIORelation)c.connect((TypedIOPort)part.getPort(""String_Node_Str""),(TypedIOPort)encode.getPort(""String_Node_Str""),""String_Node_Str"");
    r=(TypedIORelation)c.connect((TypedIOPort)encode.getPort(""String_Node_Str""),(TypedIOPort)decode.getPort(""String_Node_Str""),""String_Node_Str"");
    r=(TypedIORelation)c.connect((TypedIOPort)decode.getPort(""String_Node_Str""),(TypedIOPort)unpart.getPort(""String_Node_Str""),""String_Node_Str"");
    r=(TypedIORelation)c.connect((TypedIOPort)unpart.getPort(""String_Node_Str""),(TypedIOPort)consumer.getPort(""String_Node_Str""),""String_Node_Str"");
    Parameter p=(Parameter)d.getAttribute(""String_Node_Str"");
    p.setToken(new IntToken(60));
  }
 catch (  Exception ex) {
    System.err.println(""String_Node_Str"" + ex.getMessage());
    ex.printStackTrace();
  }
  validate();
  DebugListener debugger=new DebugListener();
  Debug.register(debugger);
  Debug.println(""String_Node_Str"");
}"
76472,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 */
public Object clone(Workspace ws){
  try {
    _firingCount=1;
    Expression newobj=(Expression)super.clone(ws);
    newobj.output=new TypedIOPort(this,""String_Node_Str"",false,true);
    expression=new Parameter(this,""String_Node_Str"",new StringToken(""String_Node_Str""));
    newobj._time=new PassiveVariable(this,""String_Node_Str"",new DoubleToken(0.0));
    newobj._firing=new PassiveVariable(this,""String_Node_Str"",new IntToken(0));
    return newobj;
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
catch (  CloneNotSupportedException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 */
public Object clone(Workspace ws){
  try {
    _firingCount=1;
    Expression newobj=(Expression)super.clone(ws);
    newobj.output=(TypedIOPort)newobj.getPort(""String_Node_Str"");
    expression=(Parameter)newobj.getAttribute(""String_Node_Str"");
    newobj._time=(PassiveVariable)newobj.getAttribute(""String_Node_Str"");
    newobj._firing=(PassiveVariable)newobj.getAttribute(""String_Node_Str"");
    return newobj;
  }
 catch (  CloneNotSupportedException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}"
76473,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 */
public Object clone(Workspace ws){
  try {
    Gaussian newobj=(Gaussian)super.clone(ws);
    newobj.output=new TypedIOPort(this,""String_Node_Str"",false,true);
    newobj.output.setDeclaredType(DoubleToken.class);
    newobj.mean=new Parameter(this,""String_Node_Str"",new DoubleToken(0.0));
    newobj.stddev=new Parameter(this,""String_Node_Str"",new DoubleToken(1.0));
    newobj.seed=new Parameter(this,""String_Node_Str"",new LongToken(0));
    return newobj;
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
catch (  CloneNotSupportedException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 */
public Object clone(Workspace ws){
  try {
    Gaussian newobj=(Gaussian)super.clone(ws);
    newobj.output=(TypedIOPort)newobj.getPort(""String_Node_Str"");
    newobj.output.setDeclaredType(DoubleToken.class);
    newobj.mean=(Parameter)newobj.getAttribute(""String_Node_Str"");
    newobj.stddev=(Parameter)newobj.getAttribute(""String_Node_Str"");
    newobj.seed=(Parameter)newobj.getAttribute(""String_Node_Str"");
    return newobj;
  }
 catch (  CloneNotSupportedException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}"
76474,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 */
public Object clone(Workspace ws){
  try {
    Sin newobj=(Sin)super.clone(ws);
    newobj.input=new TypedIOPort(this,""String_Node_Str"",true,false);
    newobj.input.setDeclaredType(DoubleToken.class);
    newobj.output=new TypedIOPort(this,""String_Node_Str"",false,true);
    newobj.output.setDeclaredType(DoubleToken.class);
    return newobj;
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
catch (  CloneNotSupportedException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 */
public Object clone(Workspace ws){
  try {
    Sin newobj=(Sin)super.clone(ws);
    newobj.input=(TypedIOPort)newobj.getPort(""String_Node_Str"");
    newobj.input.setDeclaredType(DoubleToken.class);
    newobj.output=(TypedIOPort)newobj.getPort(""String_Node_Str"");
    newobj.output.setDeclaredType(DoubleToken.class);
    return newobj;
  }
 catch (  CloneNotSupportedException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}"
76475,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 */
public Object clone(Workspace ws){
  try {
    TimePlot newobj=(TimePlot)super.clone(ws);
    newobj.input=new TypedIOPort(this,""String_Node_Str"",true,false);
    newobj.input.setMultiport(true);
    newobj.input.setDeclaredType(DoubleToken.class);
    newobj.timed=new Parameter(this,""String_Node_Str"",new BooleanToken(true));
    return newobj;
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
catch (  CloneNotSupportedException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 */
public Object clone(Workspace ws){
  try {
    TimePlot newobj=(TimePlot)super.clone(ws);
    newobj.input=(TypedIOPort)newobj.getPort(""String_Node_Str"");
    newobj.input.setMultiport(true);
    newobj.input.setDeclaredType(DoubleToken.class);
    newobj.timed=(Parameter)newobj.getAttribute(""String_Node_Str"");
    return newobj;
  }
 catch (  CloneNotSupportedException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}"
76476,"/** 
 * Put an array of objects in the queue and return true if this will not cause the capacity to be exceeded. Otherwise, do not put the object in the queue and return false.
 * @param element An array of objects to be put in the queue.
 * @return A boolean indicating success.
 */
public boolean put(Object element[]){
  if (_queuecapacity - _queuesize >= element.length) {
    int i;
    if (element.length <= (_queuecapacity - _queuefront)) {
      System.arraycopy(element,0,_queuearray,_queuefront,element.length);
      _queuefront+=element.length;
      if (_queuefront >= _queuecapacity)       _queuefront=_queuefront % _queuecapacity;
      _queuesize+=element.length;
    }
 else {
      System.arraycopy(element,0,_queuearray,_queuefront,_queuecapacity - _queuefront);
      System.arraycopy(element,_queuecapacity - _queuefront,_queuearray,0,element.length - (_queuecapacity - _queuefront));
      _queuefront+=element.length;
      if (_queuefront >= _queuecapacity)       _queuefront=_queuefront % _queuecapacity;
      _queuesize+=element.length;
    }
    return true;
  }
 else {
    Object newqueue[]=new Object[_queuecapacity * 2];
    System.arraycopy(_queuearray,0,newqueue,0,_queuecapacity);
    _queuearray=newqueue;
    _queuecapacity=_queuecapacity * 2;
    return put(element);
  }
}","/** 
 * Put an array of objects in the queue and return true if this will not cause the capacity to be exceeded. Otherwise, do not put the object in the queue and return false.
 * @param element An array of objects to be put in the queue.
 * @return A boolean indicating success.
 */
public boolean put(Object element[]){
  if (_queuecapacity - _queuesize >= element.length) {
    int i;
    if (element.length <= (_queuecapacity - _queuefront)) {
      System.arraycopy(element,0,_queuearray,_queuefront,element.length);
      _queuefront+=element.length;
      if (_queuefront >= _queuecapacity)       _queuefront=_queuefront % _queuecapacity;
      _queuesize+=element.length;
    }
 else {
      System.arraycopy(element,0,_queuearray,_queuefront,_queuecapacity - _queuefront);
      System.arraycopy(element,_queuecapacity - _queuefront,_queuearray,0,element.length - (_queuecapacity - _queuefront));
      _queuefront+=element.length;
      if (_queuefront >= _queuecapacity)       _queuefront=_queuefront % _queuecapacity;
      _queuesize+=element.length;
    }
    return true;
  }
 else {
    try {
      setCapacity(_queuecapacity * 2);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    return put(element);
  }
}"
76477,"/** 
 * Return an object in the queue or history. The object is not removed from the queue or history. If the offset argument is zero, return the oldest object in the queue. If the offset is 1, return the second oldest object, etc. If there is no such object in the queue (the offset is greater than or equal to the current queue size), throw an exception. If the argument is -1, return the most recent object that was put in the history. If the argument is -2, return the second most recent object in the history, etc. If there is no such object in the history (the history capacity is zero or the absolute value of the offset is greater than the current size of the history queue), throw an exception.
 * @param offset The position of the desired object.
 * @return The desired object in the queue or history.
 * @exception NoSuchElementException If the offset is out of range.
 */
public Object get(int offset) throws NoSuchElementException {
  Object obj=null;
  try {
    if (offset >= 0) {
      int loc=_queueback + offset;
      if (loc > _queuefront)       throw new NoSuchElementException(""String_Node_Str"");
 else       if (loc >= _queuecapacity)       loc=loc % _queuecapacity;
      obj=_queuearray[loc];
    }
 else {
      obj=_historylist.at(historySize() + offset);
    }
  }
 catch (  NoSuchElementException ex) {
    String str=""String_Node_Str"";
    if (_container != null) {
      str=""String_Node_Str"" + _container.getFullName();
    }
    throw new NoSuchElementException(""String_Node_Str"" + offset + ""String_Node_Str""+ str);
  }
  return obj;
}","/** 
 * Return an object in the queue or history. The object is not removed from the queue or history. If the offset argument is zero, return the oldest object in the queue. If the offset is 1, return the second oldest object, etc. If there is no such object in the queue (the offset is greater than or equal to the current queue size), throw an exception. If the argument is -1, return the most recent object that was put in the history. If the argument is -2, return the second most recent object in the history, etc. If there is no such object in the history (the history capacity is zero or the absolute value of the offset is greater than the current size of the history queue), throw an exception.
 * @param offset The position of the desired object.
 * @return The desired object in the queue or history.
 * @exception NoSuchElementException If the offset is out of range.
 */
public Object get(int offset) throws NoSuchElementException {
  Object obj=null;
  try {
    if (offset >= 0) {
      int loc=_queueback + offset;
      if (loc >= _queuecapacity)       loc=loc % _queuecapacity;
      if (loc >= _queuefront) {
        String str=""String_Node_Str"";
        if (_container != null) {
          str=""String_Node_Str"" + _container.getFullName();
        }
        throw new NoSuchElementException(""String_Node_Str"" + offset + ""String_Node_Str""+ str);
      }
 else       if (loc >= _queuecapacity)       loc=loc % _queuecapacity;
      obj=_queuearray[loc];
    }
 else {
      obj=_historylist.at(historySize() + offset);
    }
  }
 catch (  NoSuchElementException ex) {
    String str=""String_Node_Str"";
    if (_container != null) {
      str=""String_Node_Str"" + _container.getFullName();
    }
    throw new NoSuchElementException(""String_Node_Str"" + offset + ""String_Node_Str""+ str);
  }
  return obj;
}"
76478,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 */
public Object clone(Workspace ws){
  try {
    Ramp newobj=(Ramp)super.clone(ws);
    newobj.output=new TypedIOPort(this,""String_Node_Str"",false,true);
    newobj.init=new Parameter(this,""String_Node_Str"");
    newobj.step=new Parameter(this,""String_Node_Str"");
    return newobj;
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
catch (  CloneNotSupportedException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 */
public Object clone(Workspace ws){
  try {
    Ramp newobj=(Ramp)super.clone(ws);
    newobj.output=(TypedIOPort)newobj.getPort(""String_Node_Str"");
    newobj.init=(Parameter)newobj.getAttribute(""String_Node_Str"");
    newobj.step=(Parameter)newobj.getAttribute(""String_Node_Str"");
    return newobj;
  }
 catch (  CloneNotSupportedException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}"
76479,"/** 
 * Prepare for firing and return true if firing can proceed. If there is no container, return false immediately.  Otherwise, the first step is to perform any pending mutations, and to initialize any actors that are added by those mutations.  This sequence is repeated until no more mutations are performed.  This way, the initialize() method in actors can perform mutations, and the mutations will be fully executed before proceeding. Then, if this is the local director of its container, invoke the prefire() methods of all its deeply contained actors, and return the logical AND of what they return.  If this is the executive director of its container, then invoke the prefire() method of the container and return what it returns.  Otherwise, return false. <p> This method should be invoked once per iteration, before any invocation of fire() in that iteration. It may produce output data. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @return True if the iteration can proceed.
 * @exception CloneNotSupportedException If the prefire() method of thecontainer or one of the deeply contained actors throws it.
 * @exception IllegalActionException If the prefire() method of thecontainer or one of the deeply contained actors throws it, or a pending mutation throws it.
 */
public boolean prefire() throws IllegalActionException {
}","/** 
 * Prepare for firing and return true if firing can proceed. If there is no container, return false immediately.  Otherwise, the first step is to perform any pending mutations, and to initialize any actors that are added by those mutations.  This sequence is repeated until no more mutations are performed.  This way, the initialize() method in actors can perform mutations, and the mutations will be fully executed before proceeding. Then, if this is the local director of its container, invoke the prefire() methods of all its deeply contained actors, and return the logical AND of what they return.  If this is the executive director of its container, then invoke the prefire() method of the container and return what it returns.  Otherwise, return false. <p> This method should be invoked once per iteration, before any invocation of fire() in that iteration. It may produce output data. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @return True if the iteration can proceed.
 * @exception CloneNotSupportedException If the prefire() method of thecontainer or one of the deeply contained actors throws it.
 * @exception IllegalActionException If the prefire() method of thecontainer or one of the deeply contained actors throws it, or a pending mutation throws it.
 */
public boolean prefire() throws IllegalActionException {
  CompositeActor c=getContainer();
  Director ed=c.getExecutiveDirector();
  boolean iterate;
  if (ed=null) {
    iterate=_advanceTime(_nextFiringTime);
    return true;
  }
 else {
    iterate=_advanceTime(ed.getCurrentTime());
  }
  return iterate;
}"
76480,"/** 
 * Construct an instance and initialize it by reading the specified stream.
 * @param input The input stream.
 * @exception IOException If an error occurs reading the input data(e.g. a premature end of file).
 */
public Audio(DataInputStream input) throws IOException {
  input.read(magic,0,4);
  offset=input.readInt();
  size=input.readInt();
  format=input.readInt();
  sampleRate=input.readInt();
  numChannels=input.readInt();
  info=new byte[offset - 24];
  input.read(info,0,offset - 24);
  if (magic[0] != 0x2E || magic[1] != 0x73 || magic[2] != 0x6E || magic[3] != 0x64) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (format != 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (numChannels != 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  audio=new byte[1][size];
  input.readFully(audio[0]);
}","/** 
 * Construct an instance and initialize it by reading the specified stream.
 * @param input The input stream.
 * @exception IOException If an error occurs reading the input data(e.g. a premature end of file).
 */
public Audio(DataInputStream input) throws IOException {
  input.read(magic,0,4);
  if (magic[0] != 0x2E || magic[1] != 0x73 || magic[2] != 0x6E || magic[3] != 0x64) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  offset=input.readInt();
  size=input.readInt();
  format=input.readInt();
  sampleRate=input.readInt();
  numChannels=input.readInt();
  if (offset < 0 || offset > 10000) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + offset + ""String_Node_Str"");
  }
  info=new byte[offset - 24];
  input.read(info,0,offset - 24);
  if (format != 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (numChannels != 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  audio=new byte[1][size];
  input.readFully(audio[0]);
}"
76481,"/** 
 * Return a description of the object.  The level of detail depends on the argument, which is an or-ing of the static final constants defined in the NamedObj class and in this class. Lines are indented according to to the level argument using the protected method _getIndentPrefix(). Zero, one or two brackets can be specified to surround the returned description.  If one is specified it is the leading bracket. This is used by derived classes that will append to the description. Those derived classes are responsible for the closing bracket. An argument other than 0, 1, or 2 is taken to be equivalent to 0. <p> If the detail argument sets the bit defined by the constant CONFIGURATION, then append to the description a field containing any subset of the words ""input"", ""output"", ""multiport"", and ""opaque"", separated by spaces, plus a subfield of the form ""{width <i>integer</i>}"", where the integer is the width of the port. The field keywork is ""configuration"". <p> If the detail argument sets the bit defined by the constant RECEIVERS, then append to the description a field containing the receivers contained by this port.  The keywork is ""receivers"" and the format is like the Receivers array, an array of groups, with each group receiving from a channel. Each group is a list of receiver descriptions (it may also be empty). If the detail argument sets the bit defined by the constant REMOTERECEIVERS, then also append to the description a field containing the remote receivers connected to this port. This method is read-synchronized on the workspace.
 * @param detail The level of detail.
 * @param indent The amount of indenting.
 * @param bracket The number of surrounding brackets (0, 1, or 2).
 * @return A description of the object.
 */
protected String _description(int detail,int indent,int bracket){
  try {
    workspace().getReadAccess();
    String result;
    if (bracket == 1 || bracket == 2) {
      result=super._description(detail,indent,1);
    }
 else {
      result=super._description(detail,indent,0);
    }
    if ((detail & CONFIGURATION) != 0) {
      if (result.trim().length() > 0) {
        result+=""String_Node_Str"";
      }
      result+=""String_Node_Str"";
      boolean space=false;
      if (isInput()) {
        space=true;
        result+=""String_Node_Str"";
      }
      if (isOutput()) {
        if (space)         result+=""String_Node_Str"";
        space=true;
        result+=""String_Node_Str"";
      }
      if (isMultiport()) {
        if (space)         result+=""String_Node_Str"";
        space=true;
        result+=""String_Node_Str"";
      }
      if (isOpaque()) {
        if (space)         result+=""String_Node_Str"";
        space=true;
        result+=""String_Node_Str"";
      }
      if (space)       result+=""String_Node_Str"";
      result+=""String_Node_Str"" + getWidth() + ""String_Node_Str"";
    }
    if ((detail & RECEIVERS) != 0) {
      if (result.trim().length() > 0) {
        result+=""String_Node_Str"";
      }
      result+=""String_Node_Str"";
      Receiver[][] recvrs=null;
      try {
        recvrs=getReceivers();
      }
 catch (      Exception e) {
        result+=""String_Node_Str"";
      }
      if (recvrs != null) {
        for (int i=0; i < recvrs.length; i++) {
          result+=_getIndentPrefix(indent + 1) + ""String_Node_Str"";
          if (recvrs[i] != null) {
            for (int j=0; j < recvrs[i].length; j++) {
              result+=_getIndentPrefix(indent + 2);
              result+=""String_Node_Str"";
              if (recvrs[i][j] != null) {
                result+=recvrs[i][j].getClass().getName();
              }
              result+=""String_Node_Str"";
            }
          }
          result+=_getIndentPrefix(indent + 1) + ""String_Node_Str"";
        }
      }
      result+=_getIndentPrefix(indent) + ""String_Node_Str"";
    }
    if ((detail & REMOTERECEIVERS) != 0) {
      if (result.trim().length() > 0) {
        result+=""String_Node_Str"";
      }
      result+=""String_Node_Str"";
      Receiver[][] recvrs=null;
      try {
        recvrs=getRemoteReceivers();
        ;
      }
 catch (      Exception e) {
        result+=""String_Node_Str"";
      }
      if (recvrs != null) {
        for (int i=0; i < recvrs.length; i++) {
          result+=_getIndentPrefix(indent + 1) + ""String_Node_Str"";
          if (recvrs[i] != null) {
            for (int j=0; j < recvrs[i].length; j++) {
              result+=_getIndentPrefix(indent + 2);
              result+=""String_Node_Str"";
              if (recvrs[i][j] != null) {
                result+=recvrs[i][j].getClass().getName();
                result+=""String_Node_Str"";
                result+=recvrs[i][j].getContainer().getFullName();
              }
              result+=""String_Node_Str"";
            }
          }
          result+=_getIndentPrefix(indent + 1) + ""String_Node_Str"";
        }
      }
      result+=_getIndentPrefix(indent) + ""String_Node_Str"";
    }
    if (bracket == 2)     result+=""String_Node_Str"";
    return result;
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Return a description of the object.  The level of detail depends on the argument, which is an or-ing of the static final constants defined in the NamedObj class and in this class. Lines are indented according to to the level argument using the protected method _getIndentPrefix(). Zero, one or two brackets can be specified to surround the returned description.  If one is specified it is the leading bracket. This is used by derived classes that will append to the description. Those derived classes are responsible for the closing bracket. An argument other than 0, 1, or 2 is taken to be equivalent to 0. <p> If the detail argument sets the bit defined by the constant CONFIGURATION, then append to the description a field containing any subset of the words ""input"", ""output"", ""multiport"", and ""opaque"", separated by spaces, plus a subfield of the form ""{width <i>integer</i>}"", where the integer is the width of the port. The field keywork is ""configuration"". <p> If the detail argument sets the bit defined by the constant RECEIVERS, then append to the description a field containing the receivers contained by this port.  The keywork is ""receivers"" and the format is like the Receivers array, an array of groups, with each group receiving from a channel. Each group is a list of receiver descriptions (it may also be empty). If the detail argument sets the bit defined by the constant REMOTERECEIVERS, then also append to the description a field containing the remote receivers connected to this port. This method is read-synchronized on the workspace.
 * @param detail The level of detail.
 * @param indent The amount of indenting.
 * @param bracket The number of surrounding brackets (0, 1, or 2).
 * @return A description of the object.
 */
protected String _description(int detail,int indent,int bracket){
  try {
    workspace().getReadAccess();
    String result;
    if (bracket == 1 || bracket == 2) {
      result=super._description(detail,indent,1);
    }
 else {
      result=super._description(detail,indent,0);
    }
    if ((detail & CONFIGURATION) != 0) {
      if (result.trim().length() > 0) {
        result+=""String_Node_Str"";
      }
      result+=""String_Node_Str"";
      boolean space=false;
      if (isInput()) {
        space=true;
        result+=""String_Node_Str"";
      }
      if (isOutput()) {
        if (space)         result+=""String_Node_Str"";
        space=true;
        result+=""String_Node_Str"";
      }
      if (isMultiport()) {
        if (space)         result+=""String_Node_Str"";
        space=true;
        result+=""String_Node_Str"";
      }
      if (isOpaque()) {
        if (space)         result+=""String_Node_Str"";
        space=true;
        result+=""String_Node_Str"";
      }
      if (space)       result+=""String_Node_Str"";
      result+=""String_Node_Str"" + getWidth() + ""String_Node_Str"";
    }
    if ((detail & RECEIVERS) != 0) {
      if (result.trim().length() > 0) {
        result+=""String_Node_Str"";
      }
      result+=""String_Node_Str"";
      try {
        Receiver[][] recvrs=null;
        recvrs=getReceivers();
        if (recvrs != null) {
          for (int i=0; i < recvrs.length; i++) {
            result+=_getIndentPrefix(indent + 1) + ""String_Node_Str"";
            if (recvrs[i] != null) {
              for (int j=0; j < recvrs[i].length; j++) {
                result+=_getIndentPrefix(indent + 2);
                result+=""String_Node_Str"";
                if (recvrs[i][j] != null) {
                  result+=recvrs[i][j].getClass().getName();
                }
                result+=""String_Node_Str"";
              }
            }
            result+=_getIndentPrefix(indent + 1) + ""String_Node_Str"";
          }
        }
      }
 catch (      IllegalActionException ex) {
        result+=_getIndentPrefix(indent + 1) + ex.getMessage() + ""String_Node_Str"";
      }
      result+=_getIndentPrefix(indent) + ""String_Node_Str"";
    }
    if ((detail & REMOTERECEIVERS) != 0) {
      if (result.trim().length() > 0) {
        result+=""String_Node_Str"";
      }
      result+=""String_Node_Str"";
      Receiver[][] recvrs=null;
      recvrs=getRemoteReceivers();
      ;
      if (recvrs != null) {
        for (int i=0; i < recvrs.length; i++) {
          result+=_getIndentPrefix(indent + 1) + ""String_Node_Str"";
          if (recvrs[i] != null) {
            for (int j=0; j < recvrs[i].length; j++) {
              result+=_getIndentPrefix(indent + 2);
              result+=""String_Node_Str"";
              if (recvrs[i][j] != null) {
                result+=recvrs[i][j].getClass().getName();
                result+=""String_Node_Str"";
                result+=recvrs[i][j].getContainer().getFullName();
              }
              result+=""String_Node_Str"";
            }
          }
          result+=_getIndentPrefix(indent + 1) + ""String_Node_Str"";
        }
      }
      result+=_getIndentPrefix(indent) + ""String_Node_Str"";
    }
    if (bracket == 2)     result+=""String_Node_Str"";
    return result;
  }
  finally {
    workspace().doneReading();
  }
}"
76482,"/** 
 * If the port is an input, return the receivers that handle incoming channels from the specified relation. If the port is an opaque output and the relation is inside linked, return the receivers that handle incoming channels from the inside. Otherwise return null. The returned value is an array of arrays of the same form as that returned by getReceivers() with no arguments.  Note that a single relation may represent multiple channels because it may be a bus. <p> This method is read-synchronized on the workspace.
 * @param relation A relation that is linked on the outside or inside.
 * @return The local receivers.
 * @exception IllegalActionException If the relation is not linkedfrom the outside, or if there is no director.
 */
public Receiver[][] getReceivers(IORelation relation) throws IllegalActionException {
  try {
    workspace().getReadAccess();
    boolean insidelink=isInsideLinked(relation);
    if (!isLinked(relation) && !insidelink) {
      throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"");
    }
    boolean opaque=isOpaque();
    if (!isInput() && !(opaque && insidelink && isOutput())) {
      return null;
    }
    int width=relation.getWidth();
    if (width <= 0)     return null;
    Receiver[][] result=null;
    if (opaque) {
      if (_localReceiversTable.containsKey(relation)) {
        result=(Receiver[][])_localReceiversTable.get(relation);
        if (result.length != width) {
          String s=""String_Node_Str"";
          s+=""String_Node_Str"";
          throw new InvalidStateException(this,s);
        }
      }
      return result;
    }
 else {
      Receiver[][] insideRecvrs=getReceivers();
      if (insideRecvrs == null) {
        return null;
      }
      int insideWidth=insideRecvrs.length;
      int index=0;
      result=new Receiver[width][];
      Enumeration outsideRels=linkedRelations();
      while (outsideRels.hasMoreElements()) {
        IORelation r=(IORelation)outsideRels.nextElement();
        if (r == relation) {
          result=new Receiver[width][];
          int rstSize=java.lang.Math.min(width,insideWidth - index);
          for (int i=0; i < rstSize; i++) {
            result[i]=insideRecvrs[index++];
          }
          break;
        }
 else {
          index+=r.getWidth();
          if (index > insideWidth)           break;
        }
      }
      return result;
    }
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * If the port is an input, return the receivers that handle incoming channels from the specified relation. If the port is an opaque output and the relation is inside linked, return the receivers that handle incoming channels from the inside. Otherwise return null. The returned value is an array of arrays of the same form as that returned by getReceivers() with no arguments.  Note that a single relation may represent multiple channels because it may be a bus. If the receivers have not yet been created by createReceivers(), then return null. <p> This method is read-synchronized on the workspace.
 * @param relation A relation that is linked on the outside or inside.
 * @return The local receivers.
 * @exception IllegalActionException If the relation is not linkedfrom the outside, or if there is no director.
 */
public Receiver[][] getReceivers(IORelation relation) throws IllegalActionException {
  try {
    workspace().getReadAccess();
    boolean insidelink=isInsideLinked(relation);
    if (!isLinked(relation) && !insidelink) {
      throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"");
    }
    boolean opaque=isOpaque();
    if (!isInput() && !(opaque && insidelink && isOutput())) {
      return null;
    }
    int width=relation.getWidth();
    if (width <= 0)     return null;
    Receiver[][] result=null;
    if (opaque) {
      if (_localReceiversTable == null)       return null;
      if (_localReceiversTable.containsKey(relation)) {
        result=(Receiver[][])_localReceiversTable.get(relation);
        if (result.length != width) {
          String s=""String_Node_Str"";
          s+=""String_Node_Str"";
          throw new InvalidStateException(this,s);
        }
      }
      return result;
    }
 else {
      Receiver[][] insideRecvrs=getReceivers();
      if (insideRecvrs == null) {
        return null;
      }
      int insideWidth=insideRecvrs.length;
      int index=0;
      result=new Receiver[width][];
      Enumeration outsideRels=linkedRelations();
      while (outsideRels.hasMoreElements()) {
        IORelation r=(IORelation)outsideRels.nextElement();
        if (r == relation) {
          result=new Receiver[width][];
          int rstSize=java.lang.Math.min(width,insideWidth - index);
          for (int i=0; i < rstSize; i++) {
            result[i]=insideRecvrs[index++];
          }
          break;
        }
 else {
          index+=r.getWidth();
          if (index > insideWidth)           break;
        }
      }
      return result;
    }
  }
  finally {
    workspace().doneReading();
  }
}"
76483,"/** 
 * Return a new matrix that is constructed by inverting the input matrix. If the input matrix is singular, null is returned. This method is from [1]
 * @param matrix A matrix of doubles
 * @return A new matrix of doubles, or null if no inverse exists
 */
public static final double[][] inverse(double[][] A){
  _checkSquare(""String_Node_Str"",A);
  int n=_rows(A);
  double[][] Ai=allocCopy(A);
  int[] pivotFlag=new int[n];
  int[] swapCol=new int[n];
  int[] swapRow=new int[n];
  int irow=0, icol=0;
  for (int i=0; i < n; i++) {
    double big=0.0;
    for (int row=0; row < n; row++) {
      if (pivotFlag[row] == 0) {
        for (int col=0; col < n; col++) {
          if (pivotFlag[col] == 0) {
            double absElement=Math.abs(Ai[row][col]);
            if (absElement >= big) {
              big=absElement;
              irow=row;
              icol=col;
            }
          }
        }
      }
    }
    pivotFlag[icol]++;
    if (irow != icol) {
      for (int col=0; col < n; col++) {
        double temp=Ai[irow][icol];
        Ai[irow][col]=Ai[icol][col];
        Ai[icol][col]=temp;
      }
    }
    swapRow[i]=irow;
    swapCol[i]=icol;
    if (Ai[icol][icol] == 0.0) {
      return null;
    }
    double pivotInverse=1.0 / A[icol][icol];
    Ai[icol][icol]=1.0;
    for (int col=0; col < n; col++) {
      Ai[icol][col]*=pivotInverse;
    }
    for (int row=0; row < n; row++) {
      if (row != icol) {
        double temp=Ai[row][icol];
        Ai[row][icol]=0.0;
        for (int col=0; col < n; col++) {
          Ai[row][col]-=Ai[icol][col] * temp;
        }
      }
    }
  }
  for (int swap=n - 1; swap >= 0; swap--) {
    if (swapRow[swap] != swapCol[swap]) {
      for (int row=0; row < n; row++) {
        double temp=Ai[row][swapRow[swap]];
        Ai[row][swapRow[swap]]=Ai[row][swapCol[swap]];
        Ai[row][swapCol[swap]]=temp;
      }
    }
  }
  return Ai;
}","/** 
 * Return a new matrix that is constructed by inverting the input matrix. If the input matrix is singular, null is returned. This method is from [1]
 * @param matrix A matrix of doubles
 * @return A new matrix of doubles, or null if no inverse exists
 */
public static final double[][] inverse(double[][] A){
  _checkSquare(""String_Node_Str"",A);
  int n=_rows(A);
  double[][] Ai=allocCopy(A);
  System.out.println(toString(Ai));
  int[] pivotFlag=new int[n];
  int[] swapCol=new int[n];
  int[] swapRow=new int[n];
  int irow=0, icol=0;
  for (int i=0; i < n; i++) {
    double big=0.0;
    for (int row=0; row < n; row++) {
      if (pivotFlag[row] == 0) {
        for (int col=0; col < n; col++) {
          if (pivotFlag[col] == 0) {
            double absElement=Math.abs(Ai[row][col]);
            if (absElement >= big) {
              big=absElement;
              irow=row;
              icol=col;
            }
          }
        }
      }
    }
    pivotFlag[icol]++;
    if (irow != icol) {
      for (int col=0; col < n; col++) {
        double temp=Ai[irow][col];
        Ai[irow][col]=Ai[icol][col];
        Ai[icol][col]=temp;
      }
    }
    swapRow[i]=irow;
    swapCol[i]=icol;
    if (Ai[icol][icol] == 0.0) {
      return null;
    }
    double pivotInverse=1.0 / Ai[icol][icol];
    Ai[icol][icol]=1.0;
    for (int col=0; col < n; col++) {
      Ai[icol][col]*=pivotInverse;
    }
    for (int row=0; row < n; row++) {
      if (row != icol) {
        double temp=Ai[row][icol];
        Ai[row][icol]=0.0;
        for (int col=0; col < n; col++) {
          Ai[row][col]-=Ai[icol][col] * temp;
        }
      }
    }
  }
  for (int swap=n - 1; swap >= 0; swap--) {
    if (swapRow[swap] != swapCol[swap]) {
      for (int row=0; row < n; row++) {
        double temp=Ai[row][swapRow[swap]];
        Ai[row][swapRow[swap]]=Ai[row][swapCol[swap]];
        Ai[row][swapCol[swap]]=temp;
      }
    }
  }
  return Ai;
}"
76484,"/** 
 */
public void fire() throws IllegalActionException {
  boolean beginning=true;
  StringToken token;
  while (true) {
    token=new StringToken(_strValue);
    ConditionalBranch[] branches=new ConditionalBranch[2];
    branches[0]=new ConditionalReceive(true,_input,0,0);
    branches[1]=new ConditionalSend(true,_output,0,1,token);
    int br=chooseBranch(branches);
    if (br == 0) {
      token=(StringToken)branches[0].getToken();
      _strValue=token.stringValue();
    }
 else     if (br == -1) {
      return;
    }
  }
}","/** 
 */
public void fire() throws IllegalActionException {
  if (_numInChannels == -1) {
    _numInChannels=0;
    Receiver[][] rcvrs=_input.getReceivers();
    for (int i=0; i < rcvrs.length; i++) {
      for (int j=0; j < rcvrs[i].length; j++) {
        _numInChannels++;
      }
    }
  }
  if (_numOutChannels == -1) {
    _numOutChannels=0;
    Receiver[][] rcvrs=_output.getRemoteReceivers();
    for (int i=0; i < rcvrs.length; i++) {
      for (int j=0; j < rcvrs[i].length; j++) {
        _numOutChannels++;
      }
    }
  }
  boolean beginning=true;
  StringToken token;
  while (true) {
    token=new StringToken(_strValue);
    int numBrchs=_numInChannels + _numOutChannels;
    ConditionalBranch[] branches=new ConditionalBranch[numBrchs];
    for (int i=0; i < _numInChannels; i++) {
      branches[i]=new ConditionalReceive(true,_input,i,i);
    }
    for (int i=0; i < _numOutChannels; i++) {
      branches[i + _numInChannels]=new ConditionalSend(true,_output,i,i + _numInChannels,token);
    }
    int br=chooseBranch(branches);
    if (br >= 0 && br < _numInChannels) {
      token=(StringToken)branches[br].getToken();
      _strValue=token.stringValue();
    }
 else     if (br >= _numInChannels && br < numBrchs) {
      _strValue=""String_Node_Str"";
    }
 else     if (br == -1) {
      return;
    }
  }
}"
76485,"/** 
 */
public void fire() throws IllegalActionException {
  while (true) {
    System.out.println(getName() + ""String_Node_Str"");
    _input.get(0);
    System.out.println(getName() + ""String_Node_Str"");
    waitForDeadlock();
    System.out.println(getName() + ""String_Node_Str"");
    _output.send(0,new Token());
  }
}","/** 
 */
public void fire() throws IllegalActionException {
  while (true) {
    System.out.println(""String_Node_Str"" + getName());
    _input.get(0);
    System.out.println(""String_Node_Str"" + getName());
    waitForDeadlock();
    System.out.println(getName() + ""String_Node_Str"");
    _output.send(0,new Token());
  }
}"
76486,"/** 
 */
public void accessMemory(boolean read) throws IllegalActionException {
  double delayTime=java.lang.Math.random() * 10.0;
  System.out.println(getName() + ""String_Node_Str"" + delayTime+ ""String_Node_Str"");
  delay(delayTime);
  IntToken iToken=new IntToken(_code);
  _requestOut.send(0,iToken);
  BooleanToken bToken=(BooleanToken)_requestIn.get(0);
  if (bToken.booleanValue()) {
    if (read) {
      _memoryIn.get(0);
    }
 else {
      StringToken strToken=new StringToken(getName());
      _memoryOut.send(0,strToken);
    }
    return;
  }
  accessMemory(read);
}","/** 
 */
public void accessMemory(boolean read) throws IllegalActionException {
  System.out.println(""String_Node_Str"" + getName());
  double delayTime=java.lang.Math.random() * 10.0;
  System.out.println(getName() + ""String_Node_Str"" + delayTime+ ""String_Node_Str"");
  delay(delayTime);
  System.out.println(getName() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + getName());
  IntToken iToken=new IntToken(_code);
  _requestOut.broadcast(iToken);
  System.out.println(getName() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + getName());
  BooleanToken bToken=(BooleanToken)_requestIn.get(0);
  if (bToken.booleanValue()) {
    System.out.println(getName() + ""String_Node_Str"");
    if (read) {
      _memoryIn.get(0);
    }
 else {
      StringToken strToken=new StringToken(getName());
      _memoryOut.broadcast(strToken);
    }
    return;
  }
  System.out.println(""String_Node_Str"" + getName());
  accessMemory(read);
}"
76487,"/** 
 * Convert mu-255 companded representation of an audio sample into an integer linear representation.  Mu law is the standard used in Sun .au files as well as throughout the telephone network. This implementation is based on the web page by <a href=mailto:donahu@cooper.edu>Billy Donahue</a>: <a href=http://www.cooper.edu/~donahu/auformat/auFormat.html> http://www.cooper.edu/~donahu/auformat/auFormat.html</a>. The resulting integer values are scaled to be in the range -31616 to 31616.  This uses the low order 16 bits of the resulting integer, and thus provides a convenient 16-bit linear encoding. <p> The mu-255 representation is a byte SEEEMMMM where S is the sign bit, EEE is the three-bit exponent, and MMMM is the four-bit mantissa.  The bits are flipped, so that the binary 10000000 is the largest positive number and 00000000 is the largest negative number. <p> If you have called setZeroTrap() with a <i>true</i> argument, then this will not be an exact inverse of lin2mu because the zero code is interpreted as being the largest negative number, -31,616.
 * @param b A mu-255 representation of the sample.
 * @return A linear representation of the sample.
 */
public static int mu2lin(byte b){
  int mu=b ^ 0xFF;
  int sign=(mu & 0x80) >> 7;
  int exponent=(mu & 0x70) >> 4;
  int mantissa=(mu & 0x0F);
  int linear=(mantissa << (exponent + 1)) - 0x20 + (0x20 << exponent);
  linear<<=2;
  return (sign == 1) ? -linear : linear;
}","/** 
 * Convert mu-255 companded representation of an audio sample into an integer linear representation.  Mu law is the standard used in Sun .au files as well as throughout the telephone network. This implementation is based on the web page by <a href=mailto:donahu@cooper.edu>Billy Donahue</a>: <a href=http://www.cooper.edu/~donahu/auformat/auFormat.html> http://www.cooper.edu/~donahu/auformat/auFormat.html</a>. The resulting integer values are scaled to be in the range -31616 to 31616.  This uses the low order 16 bits of the resulting integer, and thus provides a convenient 16-bit linear encoding. <p> The mu-255 representation is a byte SEEEMMMM where S is the sign bit, EEE is the three-bit exponent, and MMMM is the four-bit mantissa.  The bits are flipped, so that the binary 10000000 is the largest positive number and 00000000 is the largest negative number. <p> If you have called setZeroTrap() with a <i>true</i> argument, then this will not be an exact inverse of lin2mu because the zero code is interpreted as being the largest negative number, -31616.
 * @param b A mu-255 representation of the sample.
 * @return A linear representation of the sample.
 */
public static int mu2lin(byte b){
  int mu=b ^ 0xFF;
  int sign=(mu & 0x80) >> 7;
  int exponent=(mu & 0x70) >> 4;
  int mantissa=(mu & 0x0F);
  int linear=(mantissa << (exponent + 1)) - 0x20 + (0x20 << exponent);
  linear<<=2;
  return (sign == 1) ? -linear : linear;
}"
76488,"/** 
 * Display basic information about the application.
 */
protected void _about(){
  Message message=new Message(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  message.setTitle(""String_Node_Str"");
}","/** 
 * Display basic information about the application.
 */
protected void _about(){
  Message message=new Message(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  message.setTitle(""String_Node_Str"");
}"
76489,"/** 
 * Send a token to all connected receivers. The transfer is accomplished by calling the put() method of the destination receivers.  The destination receivers are obtained by calling getRemoteReceivers(). If there are no destination receivers, then nothing is sent. This method is read-synchronized on the workspace.
 * @param token The token to send
 * @exception IllegalActionException If the port is not an output.
 * @exception NoRoomException If a send to one of the channels throwsit.
 */
public void broadcast(Token token) throws IllegalActionException, NoRoomException {
  try {
    workspace().getReadAccess();
    if (!isOutput()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    Receiver farRecs[][]=getRemoteReceivers();
    if (farRecs == null) {
      return;
    }
    for (int j=0; j < farRecs.length; j++) {
      send(j,token);
    }
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Send a token to all connected receivers. The transfer is accomplished by calling getRemoteReceivers() to determine the number of channels with valid receivers and then calling send on the appropriate channels.   It would probably be faster to call put() directly on the receivers. If there are no destination receivers, then nothing is sent. This method is read-synchronized on the workspace.
 * @param token The token to send
 * @exception IllegalActionException If the port is not an output.
 * @exception NoRoomException If a send to one of the channels throwsit.
 */
public void broadcast(Token token) throws IllegalActionException, NoRoomException {
  try {
    workspace().getReadAccess();
    if (!isOutput()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    Receiver farRecs[][]=getRemoteReceivers();
    if (farRecs == null) {
      return;
    }
    for (int j=0; j < farRecs.length; j++) {
      send(j,token);
    }
  }
  finally {
    workspace().doneReading();
  }
}"
76490,"/** 
 * Send the specified token to all receivers connected to the specified channel.  The first receiver gets the actual token, while subsequent ones get a clone.  If there are no receivers, then do nothing. The transfer is accomplished by calling the put() method of the remote receivers. <p> Some of this method is read-synchronized on the workspace. Since it is possible for a thread to block while executing a put, it is important that the thread does not hold read access on the workspace when it is blocked. Thus this method releases read access on the workspace before calling put.
 * @param channelindex The index of the channel, from 0 to width-1
 * @param token The token to send
 * @exception NoRoomException If there is no room in the receiver.
 * @exception IllegalActionException If the port is not an output or ifthe index is out of range.
 */
public void send(int channelindex,Token token) throws IllegalActionException, NoRoomException {
  Receiver[][] farRec;
  try {
    workspace().getReadAccess();
    if (!isOutput()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (channelindex >= getWidth() || channelindex < 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    farRec=getRemoteReceivers();
    if (farRec == null || farRec[channelindex] == null)     return;
  }
  finally {
    workspace().doneReading();
  }
  for (int j=0; j < farRec[channelindex].length; j++) {
    farRec[channelindex][j].put(token);
  }
}","/** 
 * Send the specified token to all receivers connected to the specified channel.  Tokens are in general immutable, so each receiver is given a reference to the same token and no clones are made. If there are no receivers, then do nothing. The transfer is  accomplished by calling the put() method of the remote receivers. <p> Some of this method is read-synchronized on the workspace. Since it is possible for a thread to block while executing a put, it is important that the thread does not hold read access on the workspace when it is blocked. Thus this method releases read access on the workspace before calling put.
 * @param channelindex The index of the channel, from 0 to width-1
 * @param token The token to send
 * @exception NoRoomException If there is no room in the receiver.
 * @exception IllegalActionException If the port is not an output or ifthe index is out of range.
 */
public void send(int channelindex,Token token) throws IllegalActionException, NoRoomException {
  Receiver[][] farRec;
  try {
    workspace().getReadAccess();
    if (!isOutput()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (channelindex >= getWidth() || channelindex < 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    farRec=getRemoteReceivers();
    if (farRec == null || farRec[channelindex] == null)     return;
  }
  finally {
    workspace().doneReading();
  }
  for (int j=0; j < farRec[channelindex].length; j++) {
    farRec[channelindex][j].put(token);
  }
}"
76491,"/** 
 * Return a new receiver of a type compatible with this director.
 * @return A new ODReceiver.
 */
public Receiver newReceiver(){
  ODReceiver rcvr=new ODReceiver();
  if (_completionTime != -1.0) {
    rcvr.setCompletionTime(_completionTime);
  }
  return rcvr;
}","/** 
 * Return a new receiver of a type compatible with this director.
 * @return A new ODReceiver.
 */
public Receiver newReceiver(){
  ODReceiver rcvr=new ODReceiver();
  rcvr.setCompletionTime(_completionTime);
  System.out.println(""String_Node_Str"" + _completionTime);
  return rcvr;
}"
76492,"/** 
 * Do a blocking write to the queue. Block if the queue is full.  Associate the given time stamp with the token. 
 * @param token The token to put on the queue.
 * @param time The time stamp of the token.FIXME: What if receiver is full but we want to put a token with timestamp = -1 inside??
 */
public void put(Token token,double time){
  Workspace workspace=getContainer().workspace();
  ODActor actor=(ODActor)getContainer().getContainer();
  ODDirector director=(ODDirector)actor.getDirector();
synchronized (this) {
    if (time > getCompletionTime()) {
      time=-1.0;
      token=null;
    }
    if (!super.hasRoom()) {
      director.addWriteBlock();
      while (!_terminate && !super.hasRoom()) {
        notifyAll();
        workspace.wait(this);
      }
    }
 else     if (!_terminate) {
      super.put(token,time);
      notifyAll();
      return;
    }
    if (_terminate) {
      director.removeWriteBlock();
      new TerminateProcessException(getContainer(),""String_Node_Str"");
    }
 else {
      director.removeWriteBlock();
      super.put(token,time);
      notifyAll();
      return;
    }
  }
}","/** 
 * Do a blocking write to the queue. Block if the queue is full.  Associate the given time stamp with the token. 
 * @param token The token to put on the queue.
 * @param time The time stamp of the token.FIXME: What if receiver is full but we want to put a token with timestamp = -1 inside??
 */
public void put(Token token,double time){
  Workspace workspace=getContainer().workspace();
  ODActor actor=(ODActor)getContainer().getContainer();
  ODDirector director=(ODDirector)actor.getDirector();
synchronized (this) {
    if (time > getCompletionTime() && getCompletionTime() != -5.0) {
      time=-1.0;
      token=null;
    }
    if (!super.hasRoom()) {
      director.addWriteBlock();
      while (!_terminate && !super.hasRoom()) {
        notifyAll();
        workspace.wait(this);
      }
    }
 else     if (!_terminate) {
      super.put(token,time);
      notifyAll();
      return;
    }
    if (_terminate) {
      director.removeWriteBlock();
      new TerminateProcessException(getContainer(),""String_Node_Str"");
    }
 else {
      director.removeWriteBlock();
      super.put(token,time);
      notifyAll();
      return;
    }
  }
}"
76493,"/** 
 */
public double getLastTime(){
  return _lastTime;
}","/** 
 * Return the lastTime value.
 * @return double The value of the lastTime flag.
 */
public double getLastTime(){
  return _lastTime;
}"
76494,"/** 
 * Return the container. 
 */
public IOPort getContainer(){
  return _container;
}","/** 
 * Return the container. 
 * @return IOPort The containing IOPort.
 */
public IOPort getContainer(){
  return _container;
}"
76495,"/** 
 * Get the completion time of this receiver. 
 */
public synchronized double getCompletionTime(){
  return _completionTime;
}","/** 
 * Get the completion time of this receiver. 
 * @return double The completion time.
 */
public synchronized double getCompletionTime(){
  return _completionTime;
}"
76496,"/** 
 * Take the first token (the oldest one) off the queue and return it. If the queue is empty, throw an exception. If there are other tokens left on the queue, set the rcvr time to equal that of the new leading token.
 * @exception NoTokenException If the queue is empty.
 */
public Token get(){
  ODActor actor=(ODActor)getContainer().getContainer();
  Token token=null;
synchronized (this) {
    Event event=(Event)_queue.take();
    if (event == null) {
      throw new NoTokenException(getContainer(),""String_Node_Str"");
    }
    token=event.getToken();
    if (getSize() > 0) {
      Event nextEvent=(Event)_queue.get(0);
      _rcvrTime=nextEvent.getTime();
    }
    RcvrTimeTriple triple;
    triple=new RcvrTimeTriple(this,_rcvrTime,_priority);
    actor.updateRcvrTable(triple);
  }
  return token;
}","/** 
 * Take the first token (the oldest one) off the queue and return it. If the queue is empty, throw a NoTokenException. If there are other tokens left on the queue, set the rcvr time to equal that of the new leading token.
 * @exception NoTokenException If the queue is empty.
 */
public Token get(){
  ODActor actor=(ODActor)getContainer().getContainer();
  Token token=null;
synchronized (this) {
    Event event=(Event)_queue.take();
    if (event == null) {
      throw new NoTokenException(getContainer(),""String_Node_Str"");
    }
    token=event.getToken();
    if (getSize() > 0) {
      Event nextEvent=(Event)_queue.get(0);
      _rcvrTime=nextEvent.getTime();
    }
    RcvrTimeTriple triple;
    triple=new RcvrTimeTriple(this,_rcvrTime,_priority);
    actor.updateRcvrTable(triple);
  }
  return token;
}"
76497,"/** 
 * Get the priority of this receiver. 
 */
public synchronized int getPriority(){
  return _priority;
}","/** 
 * Return the priority of this receiver. 
 * @return The priority of this receiver.
 */
public synchronized int getPriority(){
  return _priority;
}"
76498,"/** 
 * Get the queue capacity. 
 */
public int getCapacity(){
  return _queue.getCapacity();
}","/** 
 * Get the queue capacity. 
 * @return int The queue capacity.
 */
public int getCapacity(){
  return _queue.getCapacity();
}"
76499,"/** 
 * Override the base class to ensure that the proposed container is a ComponentEntity.
 * @param entity The proposed container.
 * @exception IllegalActionException If the container is not aComponentEntity, or it has no name, or the port and container are not in the same workspace.
 * @exception NameDuplicationException If the container already hasa port with the name of this port.
 */
public void setContainer(Entity container) throws IllegalActionException, NameDuplicationException {
  if (!(container instanceof ComponentEntity)) {
    throw new IllegalActionException(container,this,""String_Node_Str"");
  }
  super.setContainer(container);
}","/** 
 * Override the base class to ensure that the proposed container is a ComponentEntity.
 * @param entity The proposed container.
 * @exception IllegalActionException If the container is not aComponentEntity, or it has no name, or the port and container are not in the same workspace.
 * @exception NameDuplicationException If the container already hasa port with the name of this port.
 */
public void setContainer(Entity container) throws IllegalActionException, NameDuplicationException {
  if (!(container instanceof ComponentEntity) && (container != null)) {
    throw new IllegalActionException(container,this,""String_Node_Str"");
  }
  super.setContainer(container);
}"
76500,"/** 
 * Executes the code in this actor. This actor waits for a  customer to arrive, then delays for a random time,  representing the service times, described by an  exponential distribution. A customer arrival is marked by  the arrival of a message at the input channel of the actor.  It then repeats. This process continues executing until a TerminateProcessException is thrown.
 * @exception IllegalActionException If an error occurs during executing the process.
 */
public void fire() throws IllegalActionException {
  Random rand=new Random();
  double interval=0;
  try {
    while (true) {
      Token t=_input.get(0);
      double rate=1.0;
      interval=Math.exp(-(rand.nextDouble()) * rate);
      interval=(int)(interval * 1000);
      delay(interval / 1000);
      System.out.println(getName() + ""String_Node_Str"" + t.toString());
    }
    System.out.println(""String_Node_Str"" + getName() + ""String_Node_Str"");
    return;
  }
 catch (  NoTokenException ex) {
    throw new IllegalActionException(getName() + ""String_Node_Str"");
  }
}","/** 
 * Executes the code in this actor. This actor waits for a  customer to arrive, then delays for a random time,  representing the service times, described by an  exponential distribution. A customer arrival is marked by  the arrival of a message at the input channel of the actor.  It then repeats. This process continues executing until a TerminateProcessException is thrown.
 * @exception IllegalActionException If an error occurs during executing the process.
 */
public void fire() throws IllegalActionException {
  Random rand=new Random();
  double interval=0;
  try {
    while (true) {
      Token t=_input.get(0);
      double rate=1.0;
      interval=Math.exp(-(rand.nextDouble()) * rate);
      interval=(int)(interval * 1000);
      delay(interval / 1000);
      System.out.println(getName() + ""String_Node_Str"" + t.toString());
    }
  }
 catch (  NoTokenException ex) {
    throw new IllegalActionException(getName() + ""String_Node_Str"");
  }
}"
76501,"/** 
 * Construct a DEProcessor actor with the specified parameters.
 * @param container The composite actor that this actor belongs too.
 * @param name The name of this actor.
 * @param minimumServiceTime The minimum service time.
 * @param interruptServiceTime The interrupt service time.
 * @param lambda The mean interarrival time of the interrupt.adder.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public DEProcessor(TypedCompositeActor container,String name,double minimumServiceTime,double interruptServiceTime,double lambda) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  _minimumServiceTime=new Parameter(this,""String_Node_Str"",new DoubleToken(minimumServiceTime));
  _interruptServiceTime=new Parameter(this,""String_Node_Str"",new DoubleToken(interruptServiceTime));
  _lambda=new Parameter(this,""String_Node_Str"",new DoubleToken(lambda));
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  DECQDirector localDir=new DECQDirector(name + ""String_Node_Str"");
  this.setDirector(localDir);
  DEInterruptibleServer iServer=new DEInterruptibleServer(this,""String_Node_Str"");
  DEPoisson poisson=new DEPoisson(this,""String_Node_Str"");
  this.connect(input,iServer.input);
  this.connect(poisson.output,iServer.interrupt);
  this.connect(iServer.output,output);
  Parameter iServerMST=(Parameter)iServer.getAttribute(""String_Node_Str"");
  Parameter iServerIST=(Parameter)iServer.getAttribute(""String_Node_Str"");
  Parameter poissonLambda=(Parameter)poisson.getAttribute(""String_Node_Str"");
  iServerMST.setExpression(_minimumServiceTime.getName());
  _minimumServiceTime.addParameterListener(iServerMST);
  iServerMST.evaluate();
  iServerIST.setExpression(_interruptServiceTime.getName());
  _interruptServiceTime.addParameterListener(iServerIST);
  iServerIST.evaluate();
  poissonLambda.setExpression(_lambda.getName());
  _lambda.addParameterListener(poissonLambda);
  poissonLambda.evaluate();
}","/** 
 * Construct a DEProcessor actor with the specified parameters.
 * @param container The composite actor that this actor belongs too.
 * @param name The name of this actor.
 * @param minimumServiceTime The minimum service time.
 * @param interruptServiceTime The interrupt service time.
 * @param lambda The mean interarrival time of the interrupt.adder.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public DEProcessor(TypedCompositeActor container,String name,double minimumServiceTime,double interruptServiceTime,double lambda) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  _minimumServiceTime=new Parameter(this,""String_Node_Str"",new DoubleToken(minimumServiceTime));
  _interruptServiceTime=new Parameter(this,""String_Node_Str"",new DoubleToken(interruptServiceTime));
  _lambda=new Parameter(this,""String_Node_Str"",new DoubleToken(lambda));
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  DECQDirector localDir=new DECQDirector(name + ""String_Node_Str"");
  this.setDirector(localDir);
  DEInterruptibleServer iServer=new DEInterruptibleServer(this,""String_Node_Str"");
  DEPoisson poisson=new DEPoisson(this,""String_Node_Str"");
  this.connect(input,iServer.input);
  this.connect(poisson.output,iServer.interrupt);
  this.connect(iServer.output,output);
  Parameter iServerMST=(Parameter)iServer.getAttribute(""String_Node_Str"");
  Parameter iServerIST=(Parameter)iServer.getAttribute(""String_Node_Str"");
  Parameter poissonLambda=(Parameter)poisson.getAttribute(""String_Node_Str"");
  if (iServerMST == null) {
    System.out.println(""String_Node_Str"");
  }
  iServerMST.setExpression(_minimumServiceTime.getName());
  iServerMST.evaluate();
  iServerIST.setExpression(_interruptServiceTime.getName());
  iServerIST.evaluate();
  poissonLambda.setExpression(_lambda.getName());
  poissonLambda.evaluate();
}"
76502,"/** 
 * Construct a DEProcessor actor with the specified parameters.
 * @param container The composite actor that this actor belongs too.
 * @param name The name of this actor.
 * @param minimumServiceTime The minimum service time.
 * @param interruptServiceTime The interrupt service time.
 * @param lambda The mean interarrival time of the interrupt.adder.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public DEProcessor(TypedCompositeActor container,String name,double minimumServiceTime,double interruptServiceTime,double lambda) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  DECQDirector localDir=new DECQDirector(name + ""String_Node_Str"");
  this.setDirector(localDir);
  InterruptibleServer iServer=new InterruptibleServer(this,""String_Node_Str"",minimumServiceTime,interruptServiceTime);
  DEPoisson poisson=new DEPoisson(this,""String_Node_Str"",new Token(),lambda);
  this.connect(input,iServer.input);
  this.connect(poisson.output,iServer.interrupt);
  this.connect(iServer.output,output);
  _minimumServiceTime=(Parameter)iServer.getAttribute(""String_Node_Str"");
  _interruptServiceTime=(Parameter)iServer.getAttribute(""String_Node_Str"");
  _lambda=(Parameter)poisson.getAttribute(""String_Node_Str"");
}","/** 
 * Construct a DEProcessor actor with the specified parameters.
 * @param container The composite actor that this actor belongs too.
 * @param name The name of this actor.
 * @param minimumServiceTime The minimum service time.
 * @param interruptServiceTime The interrupt service time.
 * @param lambda The mean interarrival time of the interrupt.adder.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public DEProcessor(TypedCompositeActor container,String name,double minimumServiceTime,double interruptServiceTime,double lambda) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  _minimumServiceTime=new Parameter(this,""String_Node_Str"",new DoubleToken(minimumServiceTime));
  _interruptServiceTime=new Parameter(this,""String_Node_Str"",new DoubleToken(interruptServiceTime));
  _lambda=new Parameter(this,""String_Node_Str"",new DoubleToken(lambda));
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  DECQDirector localDir=new DECQDirector(name + ""String_Node_Str"");
  this.setDirector(localDir);
  InterruptibleServer iServer=new InterruptibleServer(this,""String_Node_Str"");
  DEPoisson poisson=new DEPoisson(this,""String_Node_Str"");
  this.connect(input,iServer.input);
  this.connect(poisson.output,iServer.interrupt);
  this.connect(iServer.output,output);
  Parameter iServerMST=(Parameter)iServer.getAttribute(""String_Node_Str"");
  Parameter iServerIST=(Parameter)iServer.getAttribute(""String_Node_Str"");
  Parameter poissonLambda=(Parameter)poisson.getAttribute(""String_Node_Str"");
  iServerMST.setExpression(_minimumServiceTime.getName());
  _minimumServiceTime.addParameterListener(iServerMST);
  iServerMST.evaluate();
  iServerIST.setExpression(_interruptServiceTime.getName());
  _interruptServiceTime.addParameterListener(iServerIST);
  iServerIST.evaluate();
  poissonLambda.setExpression(_lambda.getName());
  _lambda.addParameterListener(poissonLambda);
  poissonLambda.evaluate();
}"
76503,"/** 
 * Construct a DESampler actor.
 * @param container The composite actor that this actor belongs too.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public DESampler(TypedCompositeActor container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new DEIOPort(this,""String_Node_Str"",false,true);
  input=new DEIOPort(this,""String_Node_Str"",true,false);
  clock=new DEIOPort(this,""String_Node_Str"",true,false);
  clock.setDeclaredType(Token.class);
  clock.triggers(output);
}","/** 
 * Construct a DESampler actor with the specified initial token.
 * @param container The composite actor that this actor belongs too.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public DESampler(TypedCompositeActor container,String name,Token initToken) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  if (initToken != null) {
    _initToken=new Parameter(this,""String_Node_Str"",initToken);
  }
 else {
    _initToken=null;
  }
  output=new DEIOPort(this,""String_Node_Str"",false,true);
  input=new DEIOPort(this,""String_Node_Str"",true,false);
  clock=new DEIOPort(this,""String_Node_Str"",true,false);
  clock.setDeclaredType(Token.class);
  clock.triggers(output);
}"
76504,"/** 
 * Produce the output event according to whether the server is busy or not.
 * @exception IllegalActionException Not thrown in this class.
 */
public void fire() throws IllegalActionException {
  double interruptServiceTime=((DoubleToken)_interruptServiceTime.getToken()).doubleValue();
  double minimumServiceTime=((DoubleToken)_minimumServiceTime.getToken()).doubleValue();
  double currentTime=getCurrentTime();
  boolean busy=_busyUntil > currentTime;
  if (busy) {
    while (interrupt.hasToken(0)) {
      interrupt.get(0);
      _busyUntil+=interruptServiceTime;
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + currentTime + ""String_Node_Str""+ _busyUntil+ ""String_Node_Str"");
      }
    }
    fireAt(_busyUntil);
  }
 else {
    if (_tokenBeingServed != null) {
      output.broadcast(_tokenBeingServed);
      _tokenBeingServed=null;
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + currentTime + ""String_Node_Str"");
      }
    }
    if (input.hasToken(0)) {
      _tokenBeingServed=input.get(0);
      _busyUntil=currentTime + minimumServiceTime;
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + currentTime + ""String_Node_Str"");
      }
    }
    while (interrupt.hasToken(0)) {
      interrupt.get(0);
      _busyUntil=currentTime + interruptServiceTime;
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + currentTime + ""String_Node_Str""+ _busyUntil+ ""String_Node_Str"");
      }
    }
  }
}","/** 
 * Produce the output event according to whether the server is busy or not.
 * @exception IllegalActionException Not thrown in this class.
 */
public void fire() throws IllegalActionException {
  double interruptServiceTime=((DoubleToken)_interruptServiceTime.getToken()).doubleValue();
  double minimumServiceTime=((DoubleToken)_minimumServiceTime.getToken()).doubleValue();
  double currentTime=getCurrentTime();
  boolean busy=_busyUntil > currentTime;
  if (busy) {
    while (interrupt.hasToken(0)) {
      interrupt.get(0);
      _busyUntil+=interruptServiceTime;
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + currentTime + ""String_Node_Str""+ _busyUntil+ ""String_Node_Str"");
      }
    }
    fireAt(_busyUntil);
  }
 else {
    if (_tokenBeingServed != null) {
      output.broadcast(_tokenBeingServed);
      _tokenBeingServed=null;
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + currentTime + ""String_Node_Str"");
      }
    }
    while (interrupt.hasToken(0)) {
      interrupt.get(0);
      if (_busyUntil > currentTime) {
        _busyUntil+=interruptServiceTime;
      }
 else {
        _busyUntil=currentTime + interruptServiceTime;
      }
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + currentTime + ""String_Node_Str""+ _busyUntil+ ""String_Node_Str"");
      }
    }
    if (input.hasToken(0)) {
      _tokenBeingServed=input.get(0);
      if (_busyUntil > currentTime) {
        _busyUntil+=minimumServiceTime;
      }
 else {
        _busyUntil=currentTime + minimumServiceTime;
      }
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + currentTime + ""String_Node_Str"");
      }
      fireAt(_busyUntil);
    }
  }
}"
76505,"/** 
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  input.allowPendingTokens(true);
  _busyUntil=Double.NEGATIVE_INFINITY;
  _tokenBeingServed=null;
}","/** 
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  input.allowPendingTokens(true);
  while (input.hasToken(0)) {
    input.get(0);
  }
  _busyUntil=Double.NEGATIVE_INFINITY;
  _tokenBeingServed=null;
}"
76506,"/** 
 * Make a token available to the get() method. Normally, only a director should use this method. It uses it when its current time matches the time stamp of the token.
 * @param token The token to make available.
 */
protected void _triggerEvent(Token token){
  _tokens.insertFirst(token);
}","/** 
 * Make a token available to the get() method. Normally, only a director should use this method. It uses it when its current time matches the time stamp of the token.
 * @param token The token to make available.
 */
protected void _triggerEvent(Token token){
  _tokens.insertLast(token);
}"
76507,"/** 
 * Put an event into the event queue with the specified destination receiver, transferred token, time stamp and depth. The depth  is used to prioritize events that have equal time stamps.  A smaller depth corresponds to a higher priority.
 * @param receiver The destination receiver.
 * @param token The token destined for that receiver.
 * @param time The time stamp of the event.
 * @param depth The depth.
 * @exception IllegalActionException If the delay is negative.
 */
protected void _enqueueEvent(DEReceiver receiver,Token token,double time,long depth) throws IllegalActionException {
  if (time < _currentTime) {
    throw new IllegalActionException(getContainer(),""String_Node_Str"");
  }
  DESortKey key=new DESortKey(time,depth);
  DEEvent event=new DEEvent(receiver,token,key);
  if (DEBUG) {
    System.out.print(getFullName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + receiver.getContainer().description(FULLNAME) + ""String_Node_Str""+ ((Entity)event.actor).description(FULLNAME)+ ""String_Node_Str""+ time+ ""String_Node_Str"");
  }
  _cQueue.put(key,event);
}","/** 
 * Put an event into the event queue with the specified destination receiver, transferred token, time stamp and depth. The depth  is used to prioritize events that have equal time stamps.  A smaller depth corresponds to a higher priority.
 * @param receiver The destination receiver.
 * @param token The token destined for that receiver.
 * @param time The time stamp of the event.
 * @param depth The depth.
 * @exception IllegalActionException If the delay is negative.
 */
protected void _enqueueEvent(DEReceiver receiver,Token token,double time,long depth) throws IllegalActionException {
  if (time < _currentTime) {
    throw new IllegalActionException(getContainer(),""String_Node_Str"");
  }
  DESortKey key=new DESortKey(time,depth);
  DEEvent event=new DEEvent(receiver,token,key);
  if (DEBUG) {
    System.out.print(getFullName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + receiver.getContainer().description(FULLNAME) + ""String_Node_Str""+ ((Entity)event.actor).description(FULLNAME)+ ""String_Node_Str""+ time+ ""String_Node_Str""+ depth+ ""String_Node_Str"");
  }
  _cQueue.put(key,event);
}"
76508,"/** 
 * Set current time to zero, calculate priorities for simultaneous events, and invoke the initialize() methods of all actors deeply contained by the container.  To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their initialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If there is a delay-free loop, orif the initialize() method of the container or one of the deeply contained actors throws it.
 */
public void initialize() throws IllegalActionException {
  _cQueue=new CalendarQueue(new DECQComparator());
  _dag=new DirectedAcyclicGraph();
  _currentTime=0.0;
  _startTime=Double.MAX_VALUE;
  _startTimeInitialized=false;
  _constructDirectedGraph();
  if (!_dag.isAcyclic()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  super.initialize();
  _computeDepth();
  if (isEmbedded() && !_cQueue.isEmpty()) {
    _requestFiring();
  }
}","/** 
 * Set current time to zero, calculate priorities for simultaneous events, and invoke the initialize() methods of all actors deeply contained by the container.  To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their initialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If there is a delay-free loop, orif the initialize() method of the container or one of the deeply contained actors throws it.
 */
public void initialize() throws IllegalActionException {
  _cQueue=new CalendarQueue(new DECQComparator());
  _dag=new DirectedAcyclicGraph();
  _currentTime=0.0;
  _startTime=Double.MAX_VALUE;
  _startTimeInitialized=false;
  _constructDirectedGraph();
  if (!_dag.isAcyclic()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  _isInitialized=false;
  super.initialize();
  _isInitialized=true;
  _computeDepth();
  if (isEmbedded() && !_cQueue.isEmpty()) {
    _requestFiring();
  }
}"
76509,"/** 
 * Schedule an actor to be fired after the specified delay. If the delay argument is equal to zero, then the actor will be refired after all actors enabled at current time are fired.
 * @param actor The scheduled actor to fire.
 * @param delay The scheduled time to fire.
 * @exception IllegalActionException If the delay is negative.
 */
public void fireAfterDelay(Actor actor,double delay) throws IllegalActionException {
  if (delay == 0) {
    this._enqueueEvent(actor,getCurrentTime(),Long.MAX_VALUE);
    return;
  }
  long maxdepth=-1;
  Enumeration iports=actor.inputPorts();
  while (iports.hasMoreElements()) {
    IOPort p=(IOPort)iports.nextElement();
    Receiver[][] r=p.getReceivers();
    if (r == null)     continue;
    DEReceiver rr=(DEReceiver)r[0][0];
    if (rr._depth > maxdepth) {
      maxdepth=rr._depth;
    }
  }
  this._enqueueEvent(actor,getCurrentTime() + delay,maxdepth + 1);
}","/** 
 * Schedule an actor to be fired after the specified delay. If the delay argument is equal to zero, then the actor will be refired after all actors enabled at current time are fired.
 * @param actor The scheduled actor to fire.
 * @param delay The scheduled time to fire.
 * @exception IllegalActionException If the delay is negative.
 */
public void fireAfterDelay(Actor actor,double delay) throws IllegalActionException {
  if (delay == 0 && _isInitialized) {
    this._enqueueEvent(actor,getCurrentTime(),Long.MAX_VALUE);
    return;
  }
  long maxdepth=-1;
  Enumeration iports=actor.inputPorts();
  while (iports.hasMoreElements()) {
    IOPort p=(IOPort)iports.nextElement();
    Receiver[][] r=p.getReceivers();
    if (r == null)     continue;
    DEReceiver rr=(DEReceiver)r[0][0];
    if (rr._depth > maxdepth) {
      maxdepth=rr._depth;
    }
  }
  this._enqueueEvent(actor,getCurrentTime() + delay,maxdepth + 1);
}"
76510,"/** 
 * Perform the actions contained by the mutation events in this mutation request. (Note that no events are passed to any listeners.) If any action throws an exception, undo all the actions done so far, and then throw a TopologyFailedException containing the original exception. If any action undo fails, throw a TopologyFailedException containing both the original exception and the exception thrown on undo.
 * @throws TopologyChangeFailedException if the mutation failed
 * @exception IllegalActionException If the change has alreadybeen implemented.
 */
public void performRequest() throws TopologyChangeFailedException, IllegalActionException {
  Enumeration elts=_events.elements();
  LinkedList doneEvents=new LinkedList();
  TopologyChangeFailedException exception;
  while (elts.hasMoreElements()) {
    TopologyEvent event=(TopologyEvent)elts.nextElement();
    try {
      event.doTopologyChange();
    }
 catch (    Exception doException) {
      try {
        event.undoTopologyChange();
      }
 catch (      Exception e) {
      }
      exception=new TopologyChangeFailedException(event,doException);
      elts=doneEvents.elements();
      while (elts.hasMoreElements()) {
        TopologyEvent undoEvent=(TopologyEvent)elts.nextElement();
        try {
          undoEvent.undoTopologyChange();
        }
 catch (        Exception undoException) {
          exception.failedEvent=undoEvent;
          exception.thrownExceptionOnUndo=undoException;
          throw exception;
        }
      }
      throw exception;
    }
    doneEvents.insertFirst(event);
  }
}","/** 
 * Perform the actions contained by the mutation events in this mutation request. (Note that no events are passed to any listeners.) If any action throws an exception, undo all the actions done so far, and then throw a TopologyFailedException containing the original exception. If any action undo fails, throw a TopologyFailedException containing both the original exception and the exception thrown on undo.
 * @exception TopologyChangeFailedException if the mutation failed
 * @exception IllegalActionException If the change has alreadybeen implemented.
 */
public void performRequest() throws TopologyChangeFailedException, IllegalActionException {
  Enumeration elts=_events.elements();
  LinkedList doneEvents=new LinkedList();
  TopologyChangeFailedException exception;
  while (elts.hasMoreElements()) {
    TopologyEvent event=(TopologyEvent)elts.nextElement();
    try {
      event.doTopologyChange();
    }
 catch (    Exception doException) {
      try {
        event.undoTopologyChange();
      }
 catch (      Exception e) {
      }
      exception=new TopologyChangeFailedException(event,doException);
      elts=doneEvents.elements();
      while (elts.hasMoreElements()) {
        TopologyEvent undoEvent=(TopologyEvent)elts.nextElement();
        try {
          undoEvent.undoTopologyChange();
        }
 catch (        Exception undoException) {
          exception.failedEvent=undoEvent;
          exception.thrownExceptionOnUndo=undoException;
          throw exception;
        }
      }
      throw exception;
    }
    doneEvents.insertFirst(event);
  }
}"
76511,"/** 
 * Perform the mutation represented by this object. This is an abstract method, so subclasses must override this method and use it to construct the queue of pending topology events.
 */
public abstract void constructEventQueue() throws Exception ;","/** 
 * Perform the mutation represented by this object. This is an abstract method, so subclasses must override this method and use it to construct the queue of pending topology events.
 * @exception Exception Throw in the derived classes.
 */
public abstract void constructEventQueue() throws Exception ;"
76512,"/** 
 * Undo the topology change represented by this event.
 */
public void undoTopologyChange() throws Exception {
switch (getID()) {
case ENTITY_ADDED:
    _componentEntity.setContainer(null);
  break;
case ENTITY_REMOVED:
_componentEntity.setContainer(_compositeEntity);
break;
case PORT_ADDED:
_port.setContainer(null);
break;
case PORT_REMOVED:
_port.setContainer(_entity);
break;
case PORT_LINKED:
_port.unlink(_relation);
break;
case PORT_UNLINKED:
_port.link(_relation);
break;
case RELATION_ADDED:
_componentRelation.setContainer(null);
break;
case RELATION_REMOVED:
_componentRelation.setContainer(_compositeEntity);
break;
}
}","/** 
 * Undo the topology change represented by this event.
 * @exception Exception Thrown if setting the ComponentEntity containerto null fails.
 */
public void undoTopologyChange() throws Exception {
switch (getID()) {
case ENTITY_ADDED:
    _componentEntity.setContainer(null);
  break;
case ENTITY_REMOVED:
_componentEntity.setContainer(_compositeEntity);
break;
case PORT_ADDED:
_port.setContainer(null);
break;
case PORT_REMOVED:
_port.setContainer(_entity);
break;
case PORT_LINKED:
_port.unlink(_relation);
break;
case PORT_UNLINKED:
_port.link(_relation);
break;
case RELATION_ADDED:
_componentRelation.setContainer(null);
break;
case RELATION_REMOVED:
_componentRelation.setContainer(_compositeEntity);
break;
}
}"
76513,"/** 
 * This method increases the number of paused threads and checks if the entire simulation is paused.
 */
public synchronized void increasePausedCount(){
  _actorsPaused++;
  _checkForPause();
}","/** 
 * This method increases the number of paused threads and checks if the entire model has sucessfuly paused.
 */
public synchronized void increasePausedCount(){
  _actorsPaused++;
  _checkForPause();
}"
76514,"protected boolean _handleDeadlock() throws IllegalActionException {
  Workspace worksp=workspace();
synchronized (this) {
    while (!_deadlock) {
      worksp.wait(this);
    }
  }
  _notdone=false;
  return true;
}","/** 
 * Handles and responds to deadlocks. In this base class it  returns true when deadlock has been detected. Override this  method to obtain domain specific handling of deadlocks.
 * @return true for termination.
 * @exception IllegalActionException If a derived class throws it.
 */
protected boolean _handleDeadlock() throws IllegalActionException {
  Workspace worksp=workspace();
synchronized (this) {
    while (!_deadlock) {
      worksp.wait(this);
    }
  }
  _notdone=false;
  return true;
}"
76515,"/** 
 * This decreases the number of active threads in the compositeActor by 1. It also checks if the simulation has paused if a pause was requested. This method should be called only when an active thread that was registered using increaseActiveCount() is terminated.
 */
public synchronized void decreaseActiveCount(){
  _actorsActive--;
  _checkForDeadlock();
  if (_pauseRequested) {
    _checkForPause();
  }
}","/** 
 * Decrease the number of active processes under the control of  this director by 1. Also checks if the model is now paused if a pause was requested. This method should be called only when an active thread that was registered using increaseActiveCount() is terminated.
 */
public synchronized void decreaseActiveCount(){
  _actorsActive--;
  _checkForDeadlock();
  if (_pauseRequested) {
    _checkForPause();
  }
}"
76516,"/** 
 * This method should be called when a new thread corresponding to an actor is started in a simulation. This method is required for detection of deadlocks. The corresponding method decreaseActiveCount should be called when the thread is terminated.
 */
public synchronized void increaseActiveCount(){
  _actorsActive++;
}","/** 
 * This method should be called when a new thread corresponding to an actor is started in the model under the control of this director. This method is required for detection of deadlocks. The corresponding method decreaseActiveCount should be called when the thread is terminated.
 */
public synchronized void increaseActiveCount(){
  _actorsActive++;
}"
76517,"protected synchronized void _checkForDeadlock(){
  if (_actorsActive == 0) {
    _deadlock=true;
    notifyAll();
  }
  return;
}","/** 
 * Checks for deadlock. In the base class implementation it  returns true only if there are no active processes.
 */
protected synchronized void _checkForDeadlock(){
  if (_actorsActive == 0) {
    _deadlock=true;
    notifyAll();
  }
  return;
}"
76518,"protected synchronized void _checkForPause(){
  System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  return;
}","/** 
 * Checks if all active processes are either blocked or paused. Should be overridden in derived classes.
 */
protected synchronized void _checkForPause(){
  System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  return;
}"
76519,"/** 
 * Clone the director into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new director with no container, no pending mutations, and no mutation listeners. FIXME: not finished.
 * @param ws The workspace for the cloned object.
 * @exception CloneNotSupportedException If one of the attributescannot be cloned.
 * @return The new CSPDirector.
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  ProcessDirector newobj=(ProcessDirector)super.clone(ws);
  newobj._actorsActive=0;
  newobj._pausedReceivers=new LinkedList();
  return newobj;
}","/** 
 * Clone the director into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new director with no container, no pending mutations, and no mutation listeners. The count of active proceses is zero  and it is not paused.
 * @param ws The workspace for the cloned object.
 * @exception CloneNotSupportedException If one of the attributescannot be cloned.
 * @return The new CSPDirector.
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  ProcessDirector newobj=(ProcessDirector)super.clone(ws);
  newobj._actorsActive=0;
  newobj._pausedReceivers=new LinkedList();
  newobj._pauseRequested=false;
  newobj._threadList=new LinkedList();
  return newobj;
}"
76520,"/** 
 * Construct a thread to be used for the execution of the iteration methods of the actor.
 * @param actor The actor that needs to be executed.
 * @param director The director responsible for the execution of thisactor.
 * @param name The name of the thread.
 */
public ProcessThread(Actor actor,ProcessDirector director,String name){
  super(name);
  _actor=actor;
  _director=director;
  _manager=((CompositeActor)actor.getContainer()).getManager();
}","/** 
 * Construct a thread to be used for the execution of the iteration methods of the actor.
 * @param actor The actor that needs to be executed.
 * @param director The director responsible for the execution of thisactor.
 * @param name The name of the thread.
 */
public ProcessThread(Actor actor,ProcessDirector director,String name){
  super(name);
  _actor=actor;
  _director=director;
  _manager=((CompositeActor)((NamedObj)actor).getContainer()).getManager();
}"
76521,"/** 
 * Send a token to the receiver specified by the output port and channel number.
 */
public void send(int channelindex,Token token,double delay) throws InvalidStateException, IllegalActionException {
  if (delay < -1.0) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  ODReceiver[][] farRec;
  try {
    workspace().getReadAccess();
    if (!isOutput()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (channelindex >= getWidth() || channelindex < 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    farRec=(ODReceiver[][])getRemoteReceivers();
    if (farRec == null || farRec[channelindex] == null)     return;
  }
  finally {
    workspace().doneReading();
  }
  for (int j=0; j < farRec[channelindex].length; j++) {
    double currentTime=((ODActor)getContainer()).getCurrentTime();
    farRec[channelindex][j].put(token,currentTime + delay);
  }
}","/** 
 * Send a token to the receiver specified by the output port and channel number.
 */
public void send(int channelindex,Token token,double delay) throws InvalidStateException, IllegalActionException {
  if (delay < -1.0) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  Receiver[][] farRec;
  try {
    workspace().getReadAccess();
    if (!isOutput()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (channelindex >= getWidth() || channelindex < 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    farRec=getRemoteReceivers();
    if (farRec == null || farRec[channelindex] == null) {
      return;
    }
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    for (int j=0; j < farRec[channelindex].length; j++) {
      double currentTime=((ODActor)getContainer()).getCurrentTime();
      ((ODReceiver)farRec[channelindex][j]).put(token,currentTime + delay);
    }
  }
  finally {
    workspace().doneReading();
  }
}"
76522,"/** 
 * Return the receiver with the highest priority given that it has the lowest time stamp.
 */
public RcvrTimeTriple getHighestPriorityTriple(){
  double time=-1.0;
  double firstTime=-1.0;
  int maxPriority=0;
  int cnt=0;
  boolean rcvrNotFound=true;
  RcvrTimeTriple highPriorityTriple=null;
  while (rcvrNotFound) {
    if (cnt > _rcvrTimeTable.size()) {
      return highPriorityTriple;
    }
    RcvrTimeTriple triple=(RcvrTimeTriple)_rcvrTimeTable.at(cnt);
    if (time == -1.0) {
      time=triple.getTime();
      firstTime=time;
      maxPriority=triple.getPriority();
      highPriorityTriple=triple;
    }
 else {
      time=triple.getTime();
    }
    if (time > firstTime) {
      rcvrNotFound=false;
    }
 else {
      if (maxPriority < triple.getPriority()) {
        maxPriority=triple.getPriority();
        highPriorityTriple=triple;
      }
    }
    cnt++;
  }
  return highPriorityTriple;
}","/** 
 * Return the receiver with the highest priority given that it has the lowest time stamp.
 */
public RcvrTimeTriple getHighestPriorityTriple(){
  double time=-1.0;
  double firstTime=-1.0;
  int maxPriority=0;
  int cnt=0;
  boolean rcvrNotFound=true;
  RcvrTimeTriple highPriorityTriple=null;
  while (rcvrNotFound) {
    if (cnt == _rcvrTimeTable.size()) {
      return highPriorityTriple;
    }
    RcvrTimeTriple triple=(RcvrTimeTriple)_rcvrTimeTable.at(cnt);
    if (time == -1.0) {
      time=triple.getTime();
      firstTime=time;
      maxPriority=triple.getPriority();
      highPriorityTriple=triple;
    }
 else {
      time=triple.getTime();
    }
    if (time > firstTime) {
      rcvrNotFound=false;
    }
 else {
      if (maxPriority < triple.getPriority()) {
        maxPriority=triple.getPriority();
        highPriorityTriple=triple;
      }
    }
    cnt++;
  }
  return highPriorityTriple;
}"
76523,"/** 
 * Get the next token which has the minimum rcvrTime and highest priority. The returned token will have the lowest time stamp of  all pending tokens for this actor. If there are multiple tokens  with the lowest time stamp, then the returned token will also  have the highest priority.
 */
public Token getNextToken(){
  RcvrTimeTriple triple=(RcvrTimeTriple)_rcvrTimeTable.first();
  ODReceiver lowestRcvr=(ODReceiver)triple.getReceiver();
  _currentTime=triple.getTime();
  _lastPort=(ODIOPort)triple.getReceiver().getContainer();
  Token token=lowestRcvr.get();
  if (token != null) {
    return token;
  }
 else {
    if (this.hasMinRcvrTime()) {
      return getNextToken();
    }
 else {
      RcvrTimeTriple priorityTriple=getHighestPriorityTriple();
      lowestRcvr=(ODReceiver)priorityTriple.getReceiver();
      lowestRcvr.setSimultaneousIgnore(true);
      token=lowestRcvr.get();
      _lastPort=(ODIOPort)lowestRcvr.getContainer();
      if (token != null) {
        return token;
      }
 else {
        return getNextToken();
      }
    }
  }
}","/** 
 * Get the next token which has the minimum rcvrTime and highest priority. The returned token will have the lowest time stamp of  all pending tokens for this actor. If there are multiple tokens  with the lowest time stamp, then the returned token will also  have the highest priority.
 */
public Token getNextToken(){
  if (_rcvrTimeTable.size() == 0) {
    return null;
  }
  RcvrTimeTriple triple=(RcvrTimeTriple)_rcvrTimeTable.first();
  ODReceiver lowestRcvr=(ODReceiver)triple.getReceiver();
  _currentTime=triple.getTime();
  _lastPort=(ODIOPort)triple.getReceiver().getContainer();
  Token token=lowestRcvr.get();
  if (token != null) {
    System.out.println(""String_Node_Str"");
    return token;
  }
 else {
    if (this.hasMinRcvrTime()) {
      return getNextToken();
    }
 else {
      RcvrTimeTriple priorityTriple=getHighestPriorityTriple();
      lowestRcvr=(ODReceiver)priorityTriple.getReceiver();
      lowestRcvr.setSimultaneousIgnore(true);
      token=lowestRcvr.get();
      _lastPort=(ODIOPort)lowestRcvr.getContainer();
      if (token != null) {
        System.out.println(""String_Node_Str"");
        return token;
      }
 else {
        return getNextToken();
      }
    }
  }
}"
76524,"/** 
 * Add the specified RcvrTimeTriple based on the _Receiver_. This method must be called after _removeRcvrTable() if  the RcvrTimeTriple table already conatains the triple specified in the argument.
 */
private void _addRcvrTriple(RcvrTimeTriple newTriple){
  int cnt=0;
  if (_rcvrTimeTable.size() == 0) {
    _rcvrTimeTable.insertAt(0,newTriple);
    return;
  }
  while (cnt < _rcvrTimeTable.size()) {
    RcvrTimeTriple triple=(RcvrTimeTriple)_rcvrTimeTable.at(cnt);
    if (newTriple.getTime() <= triple.getTime()) {
      _rcvrTimeTable.insertAt(cnt,triple);
      cnt=_rcvrTimeTable.size();
    }
    cnt++;
  }
}","/** 
 * Add the specified RcvrTimeTriple based on the _Receiver_. This method must be called after _removeRcvrTable() if  the RcvrTimeTriple table already conatains the triple specified in the argument.
 */
private void _addRcvrTriple(RcvrTimeTriple newTriple){
  System.out.println(""String_Node_Str"");
  printRcvrTable();
  int cnt=0;
  boolean notAddedYet=true;
  if (_rcvrTimeTable.size() == 0) {
    String portName=newTriple.getReceiver().getContainer().getName();
    System.out.println(portName + ""String_Node_Str"" + cnt);
    _rcvrTimeTable.insertAt(0,newTriple);
    printRcvrTable();
    return;
  }
  System.out.println(""String_Node_Str"" + _rcvrTimeTable.size());
  while (cnt < _rcvrTimeTable.size()) {
    RcvrTimeTriple triple=(RcvrTimeTriple)_rcvrTimeTable.at(cnt);
    String portName1=triple.getReceiver().getContainer().getName();
    System.out.println(portName1 + ""String_Node_Str"");
    String portName2=newTriple.getReceiver().getContainer().getName();
    System.out.println(portName2 + ""String_Node_Str"");
    System.out.println(portName1 + ""String_Node_Str"" + triple.getTime());
    System.out.println(portName2 + ""String_Node_Str"" + newTriple.getTime());
    if (newTriple.getTime() < triple.getTime()) {
      String portName=newTriple.getReceiver().getContainer().getName();
      System.out.println(portName + ""String_Node_Str"" + cnt);
      _rcvrTimeTable.insertAt(cnt,newTriple);
      cnt=_rcvrTimeTable.size();
      notAddedYet=false;
    }
    cnt++;
  }
  if (notAddedYet) {
    _rcvrTimeTable.insertLast(newTriple);
  }
  System.out.println(""String_Node_Str"");
  printRcvrTable();
}"
76525,"/** 
 * Get the next token which has the minimum rcvrTime and highest priority. The returned token will have the lowest time stamp of  all pending tokens for this actor. If there are multiple tokens  with the lowest time stamp, then the returned token will also  have the highest priority.
 */
public Token getNextToken(){
  if (_rcvrTimeTable.size() == 0) {
    return null;
  }
  RcvrTimeTriple triple=(RcvrTimeTriple)_rcvrTimeTable.first();
  ODReceiver lowestRcvr=(ODReceiver)triple.getReceiver();
  _currentTime=triple.getTime();
  _lastPort=(ODIOPort)triple.getReceiver().getContainer();
  Token token=lowestRcvr.get();
  if (token != null) {
    System.out.println(""String_Node_Str"");
    return token;
  }
 else {
    if (this.hasMinRcvrTime()) {
      return getNextToken();
    }
 else {
      RcvrTimeTriple priorityTriple=getHighestPriorityTriple();
      lowestRcvr=(ODReceiver)priorityTriple.getReceiver();
      lowestRcvr.setSimultaneousIgnore(true);
      token=lowestRcvr.get();
      _lastPort=(ODIOPort)lowestRcvr.getContainer();
      if (token != null) {
        System.out.println(""String_Node_Str"");
        return token;
      }
 else {
        return getNextToken();
      }
    }
  }
}","/** 
 * Get the next token which has the minimum rcvrTime and highest priority. The returned token will have the lowest time stamp of  all pending tokens for this actor. If there are multiple tokens  with the lowest time stamp, then the returned token will also  have the highest priority.
 */
public synchronized Token getNextToken(){
  ODDirector director=(ODDirector)getDirector();
  System.out.println(""String_Node_Str"");
  printRcvrTable();
  if (_rcvrTimeTable.size() == 0) {
    System.out.println(""String_Node_Str"");
    return null;
  }
  RcvrTimeTriple triple=(RcvrTimeTriple)_rcvrTimeTable.first();
  System.out.println(""String_Node_Str"");
  ODReceiver lowestRcvr=(ODReceiver)triple.getReceiver();
  _currentTime=triple.getTime();
  _lastPort=(ODIOPort)triple.getReceiver().getContainer();
  System.out.println(""String_Node_Str"" + _lastPort.getName());
  Token token=lowestRcvr.get();
  if (token != null) {
    System.out.println(""String_Node_Str"");
    return token;
  }
 else {
    if (this.hasMinRcvrTime()) {
      System.out.println(""String_Node_Str"");
      return getNextToken();
    }
 else {
      System.out.println(""String_Node_Str"");
      RcvrTimeTriple priorityTriple=getHighestPriorityTriple();
      lowestRcvr=(ODReceiver)priorityTriple.getReceiver();
      lowestRcvr.setSimultaneousIgnore(true);
      token=lowestRcvr.get();
      _lastPort=(ODIOPort)lowestRcvr.getContainer();
      if (token != null) {
        System.out.println(""String_Node_Str"");
        return token;
      }
 else {
        System.out.println(""String_Node_Str"");
        return getNextToken();
      }
    }
  }
}"
76526,"/** 
 * Remove the specified RcvrTimeTriple based on the _Receiver_. 
 */
private void _removeRcvrTable(RcvrTimeTriple triple){
  Receiver oldRcvr=triple.getReceiver();
  for (int cnt=0; cnt < _rcvrTimeTable.size(); cnt++) {
    RcvrTimeTriple newTriple=(RcvrTimeTriple)_rcvrTimeTable.at(cnt);
    Receiver rcvr=newTriple.getReceiver();
    if (rcvr == oldRcvr) {
      _rcvrTimeTable.removeAt(cnt);
      cnt=_rcvrTimeTable.size();
    }
  }
}","/** 
 * Remove the specified RcvrTimeTriple based on the _Receiver_. 
 */
private void _removeRcvrTable(RcvrTimeTriple triple){
  System.out.println(""String_Node_Str"");
  printRcvrTable();
  Receiver rcvrToBeRemoved=triple.getReceiver();
  for (int cnt=0; cnt < _rcvrTimeTable.size(); cnt++) {
    RcvrTimeTriple nextTriple=(RcvrTimeTriple)_rcvrTimeTable.at(cnt);
    Receiver nextRcvr=nextTriple.getReceiver();
    String portName1=nextRcvr.getContainer().getName();
    System.out.println(portName1 + ""String_Node_Str"");
    String portName2=rcvrToBeRemoved.getContainer().getName();
    System.out.println(portName2 + ""String_Node_Str"");
    if (rcvrToBeRemoved == nextRcvr) {
      String portName=nextRcvr.getContainer().getName();
      System.out.println(portName + ""String_Node_Str"" + cnt);
      _rcvrTimeTable.removeAt(cnt);
      cnt=_rcvrTimeTable.size();
    }
  }
  System.out.println(""String_Node_Str"");
  printRcvrTable();
}"
76527,"/** 
 * Increase the count of conditional branches that are blocked. Check if all the conditional branches are blocked, and if so register this actor as being blocked.
 */
protected void _branchBlocked(){
synchronized (_getInternalLock()) {
    _branchesBlocked++;
    if (_branchesBlocked == _branchesStarted) {
      ((CSPDirector)getDirector())._actorBlocked();
    }
  }
}","/** 
 * Increase the count of conditional branches that are blocked. Check if all the conditional branches are blocked, and if so register this actor as being blocked.
 */
protected void _branchBlocked(){
synchronized (_getInternalLock()) {
    _branchesBlocked++;
    if (_branchesBlocked == _branchesStarted) {
      ((CSPDirector)getDirector())._actorBlocked();
      _blocked=true;
    }
  }
}"
76528,"/** 
 * Determine which branch suceeds in rendezvousing. This method is central to nondeterministic rendezvous. It is passed in an array of branches, each element of which represents one of the conditional rendezvous branches. If the guard for the branch is false then the branch is not enabled.  It returns the id of the successful branch, or -1 if none of the branches were enabled. <p> If exactly one branch is enabled, then the communication is perfromed direclt and the id of the enabled branch  is returned. If more than one branch is enabled, a thread  is created and started for each enabled branch. These threads each try to rendezvous until one succeeds. After a thread succeeds the other threads are killed, and the id of the successful branch is returned. <p>
 * @param branches The set of conditional branches involved.
 * @return The ID of the successful branch, or -1 none of thebranches were enabled.
 */
protected int chooseBranch(ConditionalBranch[] branches){
  try {
synchronized (_getInternalLock()) {
      _resetConditionalState();
      _threadList=new LinkedList();
      ConditionalBranch onlyBranch=null;
      for (int i=0; i < branches.length; i++) {
        if (branches[i].getGuard()) {
          Nameable act=(Nameable)branches[i].getParent();
          String name=act.getName() + branches[i].getID();
          Thread t=new Thread((Runnable)branches[i],name);
          _threadList.insertFirst(t);
          onlyBranch=branches[i];
        }
      }
      int num=_threadList.size();
      if (num == 0) {
        return _successfulBranch;
      }
 else       if (num == 1) {
        if (onlyBranch instanceof ConditionalSend) {
          Token t=onlyBranch._token;
          onlyBranch.getReceiver().put(t);
          return onlyBranch.getID();
        }
 else {
          Token tmp=onlyBranch.getReceiver().get();
          onlyBranch._token=tmp;
          return onlyBranch.getID();
        }
      }
 else {
        Enumeration threads=_threadList.elements();
        while (threads.hasMoreElements()) {
          Thread thread=(Thread)threads.nextElement();
          thread.start();
          _branchesActive++;
        }
        _branchesStarted=_branchesActive;
        while ((_successfulBranch == -1) && (_branchesActive > 0)) {
          _getInternalLock().wait();
        }
      }
    }
    LinkedList tmp=new LinkedList();
    for (int i=0; i < branches.length; i++) {
      if ((i != _successfulBranch) && (branches[i].getGuard())) {
        Receiver rec=branches[i].getReceiver();
        tmp.insertFirst(rec);
        branches[i].setAlive(false);
      }
    }
    (new NotifyThread(tmp)).start();
synchronized (_getInternalLock()) {
      while (_branchesActive != 0) {
        _getInternalLock().wait();
      }
      if (_branchesActive != 0) {
        throw new InvalidStateException(getName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException ex) {
    throw new TerminateProcessException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (_successfulBranch == -1) {
    throw new TerminateProcessException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  _threadList=null;
  return _successfulBranch;
}","/** 
 * Determine which branch suceeds in rendezvousing. This method is central to nondeterministic rendezvous. It is passed in an array of branches, each element of which represents one of the conditional rendezvous branches. If the guard for the branch is false then the branch is not enabled.  It returns the id of the successful branch, or -1 if none of the branches were enabled. <p> If exactly one branch is enabled, then the communication is perfromed direclt and the id of the enabled branch  is returned. If more than one branch is enabled, a thread  is created and started for each enabled branch. These threads each try to rendezvous until one succeeds. After a thread succeeds the other threads are killed, and the id of the successful branch is returned. <p>
 * @param branches The set of conditional branches involved.
 * @return The ID of the successful branch, or -1 none of thebranches were enabled.
 */
protected int chooseBranch(ConditionalBranch[] branches){
  try {
synchronized (_getInternalLock()) {
      _resetConditionalState();
      _threadList=new LinkedList();
      ConditionalBranch onlyBranch=null;
      for (int i=0; i < branches.length; i++) {
        if (branches[i].getGuard()) {
          Nameable act=(Nameable)branches[i].getParent();
          String name=act.getName() + branches[i].getID();
          Thread t=new Thread((Runnable)branches[i],name);
          _threadList.insertFirst(t);
          onlyBranch=branches[i];
        }
      }
      int num=_threadList.size();
      if (num == 0) {
        return _successfulBranch;
      }
 else       if (num == 1) {
        if (onlyBranch instanceof ConditionalSend) {
          Token t=onlyBranch._token;
          onlyBranch.getReceiver().put(t);
          return onlyBranch.getID();
        }
 else {
          Token tmp=onlyBranch.getReceiver().get();
          onlyBranch._token=tmp;
          return onlyBranch.getID();
        }
      }
 else {
        Enumeration threads=_threadList.elements();
        while (threads.hasMoreElements()) {
          Thread thread=(Thread)threads.nextElement();
          thread.start();
          _branchesActive++;
        }
        _branchesStarted=_branchesActive;
        while ((_successfulBranch == -1) && (_branchesActive > 0)) {
          _getInternalLock().wait();
        }
      }
    }
    LinkedList tmp=new LinkedList();
    for (int i=0; i < branches.length; i++) {
      if ((i != _successfulBranch) && (branches[i].getGuard())) {
        Receiver rec=branches[i].getReceiver();
        tmp.insertFirst(rec);
        branches[i].setAlive(false);
      }
    }
    (new NotifyThread(tmp)).start();
synchronized (_getInternalLock()) {
      while (_branchesActive != 0) {
        _getInternalLock().wait();
      }
      if (_branchesActive != 0) {
        throw new InvalidStateException(getName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException ex) {
    throw new TerminateProcessException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (_successfulBranch == -1) {
    if (_blocked) {
      ((CSPDirector)getDirector())._actorUnblocked();
    }
    throw new TerminateProcessException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  _threadList=null;
  return _successfulBranch;
}"
76529,"/** 
 * Decrease the count of conditional branches that are blocked. Check if all the conditional branches were previously blocked, and if so register this actor with the director as being unblocked.
 */
protected void _branchUnblocked(){
synchronized (_getInternalLock()) {
    if (_branchesBlocked == _branchesStarted) {
      ((CSPDirector)getDirector())._actorUnblocked();
    }
    _branchesBlocked--;
  }
}","/** 
 * Decrease the count of conditional branches that are blocked. Check if all the conditional branches were previously blocked, and if so register this actor with the director as being unblocked.
 */
protected void _branchUnblocked(){
synchronized (_getInternalLock()) {
    if (_branchesBlocked == _branchesStarted) {
      ((CSPDirector)getDirector())._actorUnblocked();
      _blocked=false;
    }
    _branchesBlocked--;
  }
}"
76530,"private void _resetConditionalState(){
synchronized (_getInternalLock()) {
    _branchesActive=0;
    _branchesBlocked=0;
    _branchesStarted=0;
    _branchTrying=-1;
    _successfulBranch=-1;
  }
}","private void _resetConditionalState(){
synchronized (_getInternalLock()) {
    _blocked=false;
    _branchesActive=0;
    _branchesBlocked=0;
    _branchesStarted=0;
    _branchTrying=-1;
    _successfulBranch=-1;
  }
}"
76531,"/** 
 * Clone this actor into the specified workspace. The new actor is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new actor with the same ports as the original, but no connections and no container.  A container must be set before much can be done with the actor.
 * @param ws The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return A new CSPActor.
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  CSPActor newobj=(CSPActor)super.clone(ws);
  newobj._branchesActive=0;
  newobj._branchesBlocked=0;
  newobj._branchTrying=-1;
  newobj._delayed=false;
  newobj._internalLock=new Object();
  newobj._successfulBranch=-1;
  return newobj;
}","/** 
 * Clone this actor into the specified workspace. The new actor is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new actor with the same ports as the original, but no connections and no container.  A container must be set before much can be done with the actor.
 * @param ws The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return A new CSPActor.
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  CSPActor newobj=(CSPActor)super.clone(ws);
  newobj._blocked=false;
  newobj._branchesActive=0;
  newobj._branchesBlocked=0;
  newobj._branchTrying=-1;
  newobj._delayed=false;
  newobj._internalLock=new Object();
  newobj._successfulBranch=-1;
  return newobj;
}"
76532,"/** 
 * Constructor.
 * @param container The container.
 * @param name The name of this actor.
 * @param value The initial output event value.
 * @param step The step size by which to increase the output event values.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Ramp(TypedCompositeActor container,String name,double value,double step) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  _value=new Parameter(this,""String_Node_Str"",new DoubleToken(value));
  _step=new Parameter(this,""String_Node_Str"",new DoubleToken(step));
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setMultiport(true);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.setDeclaredType(Token.class);
}","/** 
 * Construct a Ramp with the specified container, name, initial value and step size. The initial value and step size are represented by String expressions which will be evaluated by the corresponding Parameters.
 * @param container The container.
 * @param name The name of this actor.
 * @param value The expression for the initial output event value.
 * @param step The expression for the step size by which toincrease the output event values.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Ramp(TypedCompositeActor container,String name,String value,String step) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  _value=new Parameter(this,""String_Node_Str"");
  _value.setExpression(value);
  _step=new Parameter(this,""String_Node_Str"");
  _step.setExpression(step);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setMultiport(true);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.setDeclaredType(Token.class);
}"
76533,"/** 
 * Describe me
 */
public void initialize() throws IllegalActionException {
  Class valueClass=_value.getToken().getClass();
  Class stepClass=_value.getToken().getClass();
  int compare=TypeLattice.compare(valueClass,stepClass);
  if (compare == CPO.INCOMPARABLE) {
    throw new InvalidStateException(""String_Node_Str"");
  }
  if (compare == CPO.LOWER) {
    output.setDeclaredType(stepClass);
  }
 else {
    output.setDeclaredType(valueClass);
  }
  _stateToken=_value.getToken();
}","/** 
 * Describe me
 */
public void initialize() throws IllegalActionException {
  Class valueClass=_value.getToken().getClass();
  Class stepClass=_step.getToken().getClass();
  int compare=TypeLattice.compare(valueClass,stepClass);
  if (compare == CPO.INCOMPARABLE) {
    throw new InvalidStateException(""String_Node_Str"");
  }
  if (compare == CPO.LOWER) {
    output.setDeclaredType(stepClass);
  }
 else {
    output.setDeclaredType(valueClass);
  }
  _stateToken=_value.getToken();
}"
76534,"/** 
 * Check if write access in the workspace will be needed during an iteration. s     *  An iteration is defined to be one invocation of prefire(), fire(), and postfire() methods of the top level composite actor. <p> This method recursively call the needWriteAccess() method of all lower level directors. Intuitively, the workspace will only be made write- protected, if all the directors permit it.
 */
protected boolean _checkIfWriteAccessNeededDuringIteration(){
  CompositeActor toplevel=(CompositeActor)getToplevel();
  if (toplevel == null) {
    throw new InvalidStateException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  return toplevel.getDirector().needWriteAccess();
}","/** 
 * Check if write access in the workspace will be needed during an iteration. An iteration is defined to be one invocation of prefire(), fire(), and postfire() methods of the top level composite actor. <p> This method recursively call the needWriteAccess() method of all lower level directors. Intuitively, the workspace will only be made write- protected, if all the directors permit it.
 */
protected boolean _checkIfWriteAccessNeededDuringIteration(){
  CompositeActor toplevel=(CompositeActor)getToplevel();
  if (toplevel == null) {
    throw new InvalidStateException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  return toplevel.getDirector().needWriteAccess();
}"
76535,"/** 
 * The heart of the director that responds when a deadlock is  detected. It is where nearly all the control for the  simulation at this level in the hierarchy is located. <p> Deadlock occurs if the number of blocked and delayed process  equals the number of active processes. The method looks for  three cases in the following order: are there topology changes  waiting to happen, are there any process delayed, are all the  processses blocked trying to rendezvous.  <p> If there are changes to the topology waiting to happen, they are  performed and the simulation continues. Note that the result of  performing the topology changes may be to remove the deadlock  that had occured. <p> If the number of delayed processes is greater than zero, then  <i> time deadlock</i> has occured. Time is advanced and at least  one of the delayed actors will wake up and continue. Note that  time can be advanced to the current time. This happens if one of the  delayed actors delayed with a delta delay of zero. Otherwise the  simulation time is increased as well as being advanced. Current time is defined as the double value returned by  getCurrentTime plus/minus 10e-10. <p> If all the processes are blocked, then <i>real deadlock</i> has  occured. This method returns true, indicating the end of one  iteration one level up in the hierarchy. If there is no level  above this one, then real deadlock marks the end of the simulation.
 * @return True if real deadlock occured, false otherwise.
 */
protected synchronized boolean _handleDeadlock(){
  try {
    if (_actorsActive == (_actorsBlocked + _actorsDelayed)) {
      if (_topologyChangesPending) {
        System.out.println(""String_Node_Str"");
        _processTopologyRequests();
        LinkedList newThreads=new LinkedList();
        Enumeration newActors=_newActors();
        while (newActors.hasMoreElements()) {
          Actor actor=(Actor)newActors.nextElement();
          System.out.println(""String_Node_Str"" + ((Nameable)actor).getName() + ""String_Node_Str"");
          increaseActiveCount();
          actor.createReceivers();
          actor.initialize();
          String name=((Nameable)actor).getName();
          ProcessThread pnt=new ProcessThread(actor,this,name);
          newThreads.insertFirst(pnt);
        }
        Enumeration allThreads=newThreads.elements();
        while (allThreads.hasMoreElements()) {
          ProcessThread p=(ProcessThread)allThreads.nextElement();
          p.start();
          _threadList.insertFirst(p);
        }
        _topologyChangesPending=false;
        _checkForDeadlock();
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      }
 else       if (_actorsDelayed > 0) {
        System.out.println(""String_Node_Str"");
        double nextTime=_getNextTime();
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + nextTime);
        _currentTime=nextTime;
        boolean done=false;
        while (!done && _delayedActorList.size() > 0) {
          DelayListLink val=(DelayListLink)_delayedActorList.first();
          double tolerance=Math.pow(10,-10);
          if (Math.abs(val._resumeTime - nextTime) < tolerance) {
            _delayedActorList.removeFirst();
            val._actor._continue();
            System.out.println(""String_Node_Str"" + ""String_Node_Str"" + val._resumeTime);
            _actorsDelayed--;
          }
 else {
            done=true;
          }
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        return true;
      }
    }
    System.out.println(""String_Node_Str"");
    this.wait();
    return false;
  }
 catch (  InterruptedException ex) {
    throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
catch (  TopologyChangeFailedException ex) {
    throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
catch (  IllegalActionException ex) {
    throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * The heart of the director that responds when a deadlock is  detected. It is where nearly all the control for the  simulation at this level in the hierarchy is located. <p> Deadlock occurs if the number of blocked and delayed process  equals the number of active processes. The method looks for  three cases in the following order: are there topology changes  waiting to happen, are there any process delayed, are all the  processses blocked trying to rendezvous.  <p> If there are changes to the topology waiting to happen, they are  performed and the simulation continues. Note that the result of  performing the topology changes may be to remove the deadlock  that had occured. <p> If the number of delayed processes is greater than zero, then  <i> time deadlock</i> has occured. Time is advanced and at least  one of the delayed actors will wake up and continue. Note that  time can be advanced to the current time. This happens if one of the  delayed actors delayed with a delta delay of zero. Otherwise the  simulation time is increased as well as being advanced. Current time is defined as the double value returned by  getCurrentTime plus/minus 10e-10. <p> If all the processes are blocked, then <i>real deadlock</i> has  occured. This method returns true, indicating the end of one  iteration one level up in the hierarchy. If there is no level  above this one, then real deadlock marks the end of the simulation.
 * @return True if real deadlock occured, false otherwise.
 */
protected synchronized boolean _handleDeadlock(){
  try {
    if (_actorsActive == (_actorsBlocked + _actorsDelayed)) {
      if (_topologyChangesPending) {
        System.out.println(""String_Node_Str"");
        _processTopologyRequests();
        LinkedList newThreads=new LinkedList();
        Enumeration newActors=_newActors();
        while (newActors.hasMoreElements()) {
          Actor actor=(Actor)newActors.nextElement();
          System.out.println(""String_Node_Str"" + ((Nameable)actor).getName() + ""String_Node_Str"");
          increaseActiveCount();
          actor.createReceivers();
          actor.initialize();
          String name=((Nameable)actor).getName();
          ProcessThread pnt=new ProcessThread(actor,this,name);
          newThreads.insertFirst(pnt);
        }
        Enumeration allThreads=newThreads.elements();
        while (allThreads.hasMoreElements()) {
          ProcessThread p=(ProcessThread)allThreads.nextElement();
          p.start();
          _threadList.insertFirst(p);
        }
        _topologyChangesPending=false;
        return false;
      }
 else       if (_actorsDelayed > 0) {
        System.out.println(""String_Node_Str"");
        double nextTime=_getNextTime();
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + nextTime);
        _currentTime=nextTime;
        boolean done=false;
        while (!done && _delayedActorList.size() > 0) {
          DelayListLink val=(DelayListLink)_delayedActorList.first();
          double tolerance=Math.pow(10,-10);
          if (Math.abs(val._resumeTime - nextTime) < tolerance) {
            _delayedActorList.removeFirst();
            val._actor._continue();
            System.out.println(""String_Node_Str"" + ""String_Node_Str"" + val._resumeTime);
            _actorsDelayed--;
          }
 else {
            done=true;
          }
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        return true;
      }
    }
    System.out.println(""String_Node_Str"");
    this.wait();
    return false;
  }
 catch (  InterruptedException ex) {
    throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
catch (  TopologyChangeFailedException ex) {
    throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
catch (  IllegalActionException ex) {
    throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
}"
76536,"/** 
 * Create a guarded communication with a send communication.
 * @param guard The guard for the guarded communication statementrepresented by this object.
 * @param port The IOPort containing the channel (and thus receiver)that this branch will try to rendezvous with.
 * @param channel The channel in the IOPort that this branch istrying to rendezvous with.
 * @param branch The identification number assigned to this branchupon creation by the CSPActor.
 * @exception IllegalActionException If the channel has morethan one receiver or if the receiver is not of type CSPReceiver.
 */
public ConditionalSend(boolean guard,IOPort port,int channel,int branchID,Token t) throws IllegalActionException {
  super(guard,port,branchID);
  Receiver[][] receivers;
  try {
    port.workspace().getReadAccess();
    if (!port.isOutput()) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (channel >= port.getWidth() || channel < 0) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    receivers=port.getRemoteReceivers();
    if (receivers == null || receivers[channel] == null) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channel].length != 1) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + channel + ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (!(receivers[channel][0] instanceof CSPReceiver)) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + channel + ""String_Node_Str""+ ""String_Node_Str"");
    }
    _receiver=(CSPReceiver)receivers[channel][0];
  }
  finally {
    port.workspace().doneReading();
  }
  _token=t;
}","/** 
 * Create a guarded communication with a send communication.
 * @param guard The guard for the guarded communication statementrepresented by this object.
 * @param port The IOPort containing the channel (and thus receiver)that this branch will try to rendezvous with.
 * @param channel The channel in the IOPort that this branch istrying to rendezvous with.
 * @param branch The identification number assigned to this branchupon creation by the CSPActor.
 * @exception IllegalActionException If the channel has morethan one receiver or if the receiver is not of type CSPReceiver.
 */
public ConditionalSend(boolean guard,IOPort port,int channel,int branchID,Token t) throws IllegalActionException {
  super(guard,port,branchID);
  Receiver[][] receivers;
  try {
    port.workspace().getReadAccess();
    if (!port.isOutput()) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (channel >= port.getWidth() || channel < 0) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    receivers=port.getRemoteReceivers();
    if (receivers == null || receivers[channel] == null) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channel].length != 1) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + channel + ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (!(receivers[channel][0] instanceof CSPReceiver)) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + channel + ""String_Node_Str""+ ""String_Node_Str"");
    }
    _receiver=(CSPReceiver)receivers[channel][0];
  }
 catch (  IllegalActionException ex) {
    _guard=false;
  }
 finally {
    port.workspace().doneReading();
  }
  _token=t;
}"
76537,"/** 
 * Skip all data until we find the specified string. <p>This is especially useful for scanning comments. <p>This is a a little inefficient right now, since it calls tryRead() for every character.
 * @param delim The string delimiter
 * @see #tryRead(String,boolean)
 * @see #readCh
 */
void skipUntil(String delim) throws java.lang.Exception {
  while (!tryRead(delim)) {
    readCh();
  }
}","/** 
 * Skip all data until we find the specified string. <p>This is especially useful for scanning comments. <p>This is a a little inefficient right now, since it calls tryRead() for every character.
 * @param delim The string delimiter
 * @see #tryRead(String,boolean)
 * @see #readCh
 */
void skipUntil(String delim) throws java.lang.Exception {
  while (!tryRead(delim)) {
    char c;
    while (readBufferPos >= readBufferLength) {
switch (sourceType) {
case INPUT_READER:
case INPUT_EXTERNAL:
case INPUT_STREAM:
        readDataChunk();
      while (readBufferLength < 1) {
        popInput();
        if (readBufferLength < 1) {
          readDataChunk();
        }
      }
    break;
default :
  popInput();
break;
}
}
c=readBuffer[readBufferPos++];
if (c == '\n') {
line++;
column=0;
}
 else {
column++;
}
}
}"
76538,"/** 
 * This initializes the actor, and iterates it through the execution  cycle till it terminates.
 */
public void run(){
  try {
    boolean iterate=true;
    while (iterate) {
      if (((Entity)_actor).getContainer() != null && _actor.prefire()) {
        _actor.fire();
        iterate=_actor.postfire();
      }
      iterate=false;
    }
  }
 catch (  TerminateProcessException t) {
  }
catch (  IllegalActionException e) {
    _manager.fireExecutionError(e);
  }
 finally {
    try {
      _actor.wrapup();
    }
 catch (    IllegalActionException e) {
      _manager.fireExecutionError(e);
    }
    _director.decreaseActiveCount();
  }
}","/** 
 * This initializes the actor, and iterates it through the execution  cycle till it terminates.
 */
public void run(){
  try {
    boolean iterate=true;
    while (iterate) {
      iterate=false;
      if (((Entity)_actor).getContainer() != null && _actor.prefire()) {
        _actor.fire();
        iterate=_actor.postfire();
      }
    }
  }
 catch (  TerminateProcessException t) {
  }
catch (  IllegalActionException e) {
    _manager.fireExecutionError(e);
  }
 finally {
    try {
      _actor.wrapup();
    }
 catch (    IllegalActionException e) {
      _manager.fireExecutionError(e);
    }
    _director.decreaseActiveCount();
  }
}"
76539,"/** 
 * This initializes the actor, and iterates it through the execution  cycle till it terminates.
 */
public void run(){
  try {
    boolean iterate=true;
    while (iterate) {
      if (((Entity)_actor).getContainer() != null && _actor.prefire()) {
        _actor.fire();
        iterate=_actor.postfire();
      }
      iterate=false;
    }
  }
 catch (  TerminateProcessException t) {
  }
catch (  IllegalActionException e) {
    _manager.fireExecutionError(e);
  }
 finally {
    try {
      _actor.wrapup();
    }
 catch (    IllegalActionException e) {
      _manager.fireExecutionError(e);
    }
    _director.decreaseActiveCount();
  }
}","/** 
 * This initializes the actor, and iterates it through the execution  cycle till it terminates.
 */
public void run(){
  try {
    boolean iterate=true;
    while (iterate) {
      iterate=false;
      if (((Entity)_actor).getContainer() != null && _actor.prefire()) {
        _actor.fire();
        iterate=_actor.postfire();
      }
    }
  }
 catch (  TerminateProcessException t) {
  }
catch (  IllegalActionException e) {
    _manager.fireExecutionError(e);
  }
 finally {
    try {
      _actor.wrapup();
    }
 catch (    IllegalActionException e) {
      _manager.fireExecutionError(e);
    }
    _director.decreaseActiveCount();
  }
}"
76540,"/** 
 * If running and paused, resume the currently paused simulation by  turning off the paused flag and waking the simulation thread up. This thread is synchronized so that it runs atomically with respect to  the other methods in manager that control the simulation thread.
 */
public synchronized void resume(){
  if (_keepIterating && _isPaused) {
    _isPaused=false;
    if (_simulationThread != null)     _simulationThread.notify();
  }
}","/** 
 * If running and paused, resume the currently paused simulation by  turning off the paused flag and waking the simulation thread up. This thread is synchronized so that it runs atomically with respect to  the other methods in manager that control the simulation thread.
 */
public synchronized void resume(){
  if (_keepIterating && _isPaused) {
    _isPaused=false;
    if (_simulationThread != null) {
synchronized (_simulationThread) {
        _simulationThread.notify();
      }
    }
  }
}"
76541,"/** 
 * Run the sequence of execution. The execution is performed by the current thread. I.e. The execution is performed in 'foreground' and the method returns only after the execution finishes. This is useful for test scripts and batch mode runs. Note that this method is not synchronized since otherwise it would lock the  whole Manager object until it finishes. It is possible for other threads to come in and pause(), resume(), terminate() or finish() the execution of the simulation. <p> To start the simulation in 'background', use the startRun() method. startRun() creates a new thread which executes this run() method and then returns immediately. <p> The execution begins by calling initialize() on the toplevel  composite actor. It then continually calls iterate() based on the variables _keepIterating, and _isPaused.  It finally  calls wrapup() on its container to clean up the execution.
 */
public void run(){
  if (_simulationThread == null) {
    _simulationThread=Thread.currentThread();
  }
 else {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  CompositeActor toplevel=((CompositeActor)getToplevel());
synchronized (this) {
    if (_keepIterating) {
      System.out.println(""String_Node_Str"");
      return;
    }
    _keepIterating=true;
    _isPaused=false;
    _iteration=0;
    _typeResolved=false;
  }
  ExecutionEvent event=new ExecutionEvent(this);
  Enumeration listeners=_ExecutionListeners.elements();
  while (listeners.hasMoreElements()) {
    ExecutionListener l=(ExecutionListener)listeners.nextElement();
    l.executionStarted(event);
  }
  try {
    try {
      toplevel.initialize();
      _needWriteAccessDuringIteration=_checkIfWriteAccessNeededDuringIteration();
      while (_keepIterating && _iterate()) {
        try {
          if (_isPaused) {
            event=new ExecutionEvent(this,_iteration);
            listeners=_ExecutionListeners.elements();
            while (listeners.hasMoreElements()) {
              ExecutionListener l=(ExecutionListener)listeners.nextElement();
              l.executionPaused(event);
            }
            _simulationThread.wait();
            event=new ExecutionEvent(this,_iteration);
            listeners=_ExecutionListeners.elements();
            while (listeners.hasMoreElements()) {
              ExecutionListener l=(ExecutionListener)listeners.nextElement();
              l.executionResumed(event);
            }
          }
        }
 catch (        InterruptedException e) {
        }
      }
    }
  finally {
      _keepIterating=false;
      _isPaused=false;
      toplevel.wrapup();
      event=new ExecutionEvent(this,_iteration);
      listeners=_ExecutionListeners.elements();
      while (listeners.hasMoreElements()) {
        ExecutionListener l=(ExecutionListener)listeners.nextElement();
        l.executionFinished(event);
      }
    }
  }
 catch (  Exception e) {
    fireExecutionError(e);
  }
  _simulationThread=null;
}","/** 
 * Run the sequence of execution. The execution is performed by the current thread. I.e. The execution is performed in 'foreground' and the method returns only after the execution finishes. This is useful for test scripts and batch mode runs. Note that this method is not synchronized since otherwise it would lock the  whole Manager object until it finishes. It is possible for other threads to come in and pause(), resume(), terminate() or finish() the execution of the simulation. <p> To start the simulation in 'background', use the startRun() method. startRun() creates a new thread which executes this run() method and then returns immediately. <p> The execution begins by calling initialize() on the toplevel  composite actor. It then continually calls iterate() based on the variables _keepIterating, and _isPaused.  It finally  calls wrapup() on its container to clean up the execution.
 */
public void run(){
  if (_simulationThread == null) {
    _simulationThread=Thread.currentThread();
  }
 else {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  CompositeActor toplevel=((CompositeActor)getToplevel());
synchronized (this) {
    if (_keepIterating) {
      System.out.println(""String_Node_Str"");
      return;
    }
    _keepIterating=true;
    _isPaused=false;
    _iteration=0;
    _typeResolved=false;
  }
  ExecutionEvent event=new ExecutionEvent(this);
  Enumeration listeners=_ExecutionListeners.elements();
  while (listeners.hasMoreElements()) {
    ExecutionListener l=(ExecutionListener)listeners.nextElement();
    l.executionStarted(event);
  }
  try {
    try {
      toplevel.initialize();
      _needWriteAccessDuringIteration=_checkIfWriteAccessNeededDuringIteration();
      while (_keepIterating && _iterate()) {
        try {
          if (_isPaused) {
            event=new ExecutionEvent(this,_iteration);
            listeners=_ExecutionListeners.elements();
            while (listeners.hasMoreElements()) {
              ExecutionListener l=(ExecutionListener)listeners.nextElement();
              l.executionPaused(event);
            }
synchronized (_simulationThread) {
              _simulationThread.wait();
            }
            event=new ExecutionEvent(this,_iteration);
            listeners=_ExecutionListeners.elements();
            while (listeners.hasMoreElements()) {
              ExecutionListener l=(ExecutionListener)listeners.nextElement();
              l.executionResumed(event);
            }
          }
        }
 catch (        InterruptedException e) {
        }
      }
    }
  finally {
      _keepIterating=false;
      _isPaused=false;
      toplevel.wrapup();
      event=new ExecutionEvent(this,_iteration);
      listeners=_ExecutionListeners.elements();
      while (listeners.hasMoreElements()) {
        ExecutionListener l=(ExecutionListener)listeners.nextElement();
        l.executionFinished(event);
      }
    }
  }
 catch (  Exception e) {
    fireExecutionError(e);
  }
  _simulationThread=null;
}"
76542,"/** 
 * Set a flag to request that the thread in which execution is running  complete by calling wrapup() and then terminating.    This thread is synchronized so that it runs atomically with respect to  other methods in Manager that control the simulation thread. This method is non-blocking.   
 */
public synchronized void finish(){
  _keepIterating=false;
  _isPaused=false;
  if (_simulationThread != null)   _simulationThread.notify();
}","/** 
 * Set a flag to request that the thread in which execution is running  complete by calling wrapup() and then terminating.    This thread is synchronized so that it runs atomically with respect to  other methods in Manager that control the simulation thread. This method is non-blocking.   
 */
public synchronized void finish(){
  _keepIterating=false;
  _isPaused=false;
  if (_simulationThread != null) {
synchronized (_simulationThread) {
      _simulationThread.notify();
    }
  }
}"
76543,"/** 
 * Get the attribute with the given name. This method is read-synchronized on the workspace.
 * @param name The name of the desired attribute.
 * @return The requested attribute if it is found, null otherwise.
 */
public Attribute getAttribute(String name){
  try {
    workspace().getReadAccess();
    return (Attribute)_attributes.get(name);
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Get the attribute with the given name. This method is read-synchronized on the workspace.
 * @param name The name of the desired attribute.
 * @return The requested attribute if it is found, null otherwise.
 */
public Attribute getAttribute(String name){
  try {
    workspace().getReadAccess();
    if (_attributes == null) {
      return null;
    }
 else {
      return (Attribute)_attributes.get(name);
    }
  }
  finally {
    workspace().doneReading();
  }
}"
76544,"/** 
 * Construct a plot actor that uses the specified plot object. This can be used to create applets that plot the results of DE simulations.
 * @exception NameDuplicationException If the parent class throws it.
 * @exception IllegalActionException If the parent class throws it.
 */
public DELogicAnalyzer(TypedCompositeActor container,String name,LogicAnalyzer plot) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.makeMultiport(true);
  _logicAnalyzer=plot;
}","/** 
 * Construct a plot actor that uses the specified plot object. This can be used to create applets that plot the results of DE simulations.
 * @exception NameDuplicationException If the parent class throws it.
 * @exception IllegalActionException If the parent class throws it.
 */
public DELogicAnalyzer(TypedCompositeActor container,String name,LogicAnalyzer plot) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.makeMultiport(true);
  _logicAnalyzer=plot;
  _logicAnalyzer.setButtons(true);
}"
76545,"/** 
 * Add new input data to the plot.
 * @exception IllegalActionException Not thrown in this class.
 */
public void fire() throws IllegalActionException {
  if (!_rangeInitialized) {
    _plot.setXRange(getStartTime(),getStopTime());
    _plot.setYRange(getYMin(),getYMax());
    _plot.init();
    _plot.repaint();
    _rangeInitialized=true;
  }
  int numEmptyChannel=0;
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      double curTime=((DECQDirector)getDirector()).getCurrentTime();
      while (input.hasToken(i)) {
        DoubleToken curToken=null;
        curToken=(DoubleToken)input.get(i);
        double curValue=curToken.doubleValue();
        boolean yRangeChanged=false;
        if (curValue < _yMin) {
          yRangeChanged=true;
          _yMin=curValue;
        }
        if (curValue > _yMax) {
          yRangeChanged=true;
          _yMax=curValue;
        }
        if (yRangeChanged) {
          _plot.setYRange(_yMin,_yMax);
          _plot.repaint();
        }
        _plot.addPoint(i,curTime,curValue,false);
      }
    }
 else {
      numEmptyChannel++;
    }
  }
  if (numEmptyChannel == width) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Add new input data to the plot.
 * @exception IllegalActionException Not thrown in this class.
 */
public void fire() throws IllegalActionException {
  if (!_rangeInitialized) {
    _plot.setXRange(getStartTime(),getStopTime());
    _plot.setYRange(getYMin(),getYMax());
    _plot.init();
    _plot.repaint();
    _rangeInitialized=true;
  }
  int numEmptyChannel=0;
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      double curTime=((DECQDirector)getDirector()).getCurrentTime();
      while (input.hasToken(i)) {
        DoubleToken curToken=null;
        curToken=(DoubleToken)input.get(i);
        double curValue=curToken.doubleValue();
        boolean yRangeChanged=false;
        if (curValue < _yMin) {
          yRangeChanged=true;
          _yMin=curValue;
        }
        if (curValue > _yMax) {
          yRangeChanged=true;
          _yMax=curValue;
        }
        if (yRangeChanged) {
          _plot.setYRange(_yMin,_yMax);
          _plot.repaint();
        }
        if (DEBUG) {
          System.out.print(this.getFullName() + ""String_Node_Str"");
          System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ curTime+ ""String_Node_Str""+ curValue+ ""String_Node_Str"");
        }
        _plot.addPoint(i,curTime,curValue,false);
      }
    }
 else {
      numEmptyChannel++;
    }
  }
  if (numEmptyChannel == width) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
76546,"/** 
 * Insert the given element, keeping the set sorted. If the set <i>contains</i> the given element, then do nothing.  If the type of given element is uncomparable by the comparator, then a ClassCastException  will be thrown.
 * @param obj The element to be inserted.
 */
public void insert(Object obj){
  int count=0;
  Enumeration elements=_set.elements();
  while (elements.hasMoreElements()) {
    Object next=elements.nextElement();
    int com=_comparator.compare(obj,next);
    if (com == 0) {
      break;
    }
    if (com < 0) {
      _set.insertAt(count,obj);
      break;
    }
    count++;
  }
}","/** 
 * Insert the given element, keeping the set sorted. If the set <i>contains</i> the given element, then do nothing.  If the type of given element is uncomparable by the comparator, then a ClassCastException  will be thrown.
 * @param obj The element to be inserted.
 */
public void insert(Object obj){
  int count=0;
  Enumeration elements=_set.elements();
  while (elements.hasMoreElements()) {
    Object next=elements.nextElement();
    int com=_comparator.compare(obj,next);
    if (com == 0) {
      return;
    }
    if (com < 0) {
      _set.insertAt(count,obj);
      return;
    }
    count++;
  }
  _set.insertLast(obj);
}"
76547,"/** 
 * Return the director. Note that the director returned is guaranteed to be non-null.
 * @return An instance of DEDirector.
 * @exception IllegalActionException If there is no container port, orif the port has no container actor, or if the actor has no director, or if the director is not an instance of DEDirector.
 */
public DEDirector getDirector() throws IllegalActionException {
  IOPort port=(IOPort)getContainer();
  if (port != null) {
    if (_directorVersion == port.workspace().getVersion()) {
      return _director;
    }
    Actor actor=(Actor)port.getContainer();
    if (actor != null) {
      Director dir=actor.getExecutiveDirector();
      if (dir != null) {
        if (dir instanceof DEDirector) {
          _director=(DEDirector)dir;
          _directorVersion=port.workspace().getVersion();
          return _director;
        }
      }
    }
  }
  throw new IllegalActionException(getContainer(),""String_Node_Str"");
}","/** 
 * Return the director. Note that the director returned is guaranteed to be non-null.
 * @return An instance of DEDirector.
 * @exception IllegalActionException If there is no container port, orif the port has no container actor, or if the actor has no director, or if the director is not an instance of DEDirector.
 */
public DEDirector getDirector() throws IllegalActionException {
  IOPort port=(IOPort)getContainer();
  if (port != null) {
    if (_directorVersion == port.workspace().getVersion()) {
      return _director;
    }
    Actor actor=(Actor)port.getContainer();
    if (actor != null) {
      Director dir;
      if ((port.isOutput()) && (actor instanceof CompositeActor) && ((CompositeActor)actor).isOpaque()) {
        dir=actor.getDirector();
      }
 else {
        dir=actor.getExecutiveDirector();
      }
      if (dir != null) {
        if (dir instanceof DEDirector) {
          _director=(DEDirector)dir;
          _directorVersion=port.workspace().getVersion();
          return _director;
        }
      }
    }
  }
  throw new IllegalActionException(getContainer(),""String_Node_Str"");
}"
76548,"/** 
 * Put a token with the specified delay into the receiver.  The time stamp of the token is equal to the current time (obtained from the director) plus the delay.  Note that this token does not become immediately available to the get() method. Instead, the token is queued with the director, and the director must put the token back into this receiver using the _triggerEvent() method in order for the token to become available.
 * @param token The token to put.
 * @param delay The delay of the token.
 * @exception IllegalActionException If the delay is negative, or ifthere is no director.
 */
public void put(Token token,double delay) throws NoRoomException, IllegalActionException {
  if (_isOCAOutput()) {
    _tokens.insertFirst(token);
    _tokendelays.insertFirst(new Double(delay));
  }
 else {
    getDirector().enqueueEvent(this,token,delay,_depth);
  }
}","/** 
 * Put a token with the specified delay into the receiver.  The time stamp of the token is equal to the current time (obtained from the director) plus the delay.  Note that this token does not become immediately available to the get() method. Instead, the token is queued with the director, and the director must put the token back into this receiver using the _triggerEvent() method in order for the token to become available.
 * @param token The token to put.
 * @param delay The delay of the token.
 * @exception IllegalActionException If the delay is negative, or ifthere is no director.
 */
public void put(Token token,double delay) throws NoRoomException, IllegalActionException {
  getDirector().enqueueEvent(this,token,delay,_depth);
}"
76549,"/** 
 * Find all the nodes that can be reached from the specified nodes. The reachable nodes do not include the specific ones unless there is a loop from the specified node back to itself. The implementation computes the transitive closure of the graph, if it is not already computed after the last graph change.  So the first call to this method after graph change may be slow, but all the subsequent calls return in constant time.
 * @param o an Object representing a node in this graph.
 * @return an array of Objects representing nodes reachable fromthe specified one.
 * @exception IllegalArgumentException If the specified Object isnot a node in this graph.
 */
public Object[] reachableNodes(Object[] objs){
  _computeTransitiveClosure();
  int N=objs.length;
  int ids[]=new int[N];
  for (int i=0; i < N; i++) {
    ids[i]=_getNodeId(objs[i]);
  }
  Vector nodes=new Vector(_transitiveClosure.length);
  for (int i=0; i < _transitiveClosure.length; i++) {
    boolean orthem=false;
    for (int j=0; j < N; j++) {
      orthem=orthem || _transitiveClosure[j][i];
    }
    if (orthem) {
      nodes.addElement(_getNodeObject(i));
    }
  }
  Object[] arr=new Object[nodes.size()];
  for (int i=0; i < nodes.size(); i++) {
    arr[i]=nodes.elementAt(i);
  }
  return arr;
}","/** 
 * Find all the nodes that can be reached from the specified nodes. The reachable nodes do not include the specific ones unless there is a loop from the specified node back to itself. The implementation computes the transitive closure of the graph, if it is not already computed after the last graph change.  So the first call to this method after graph change may be slow, but all the subsequent calls return in constant time.
 * @param o an Object representing a node in this graph.
 * @return an array of Objects representing nodes reachable fromthe specified one.
 * @exception IllegalArgumentException If the specified Object isnot a node in this graph.
 */
public Object[] reachableNodes(Object[] objs){
  _computeTransitiveClosure();
  int N=objs.length;
  int ids[]=new int[N];
  for (int i=0; i < N; i++) {
    ids[i]=_getNodeId(objs[i]);
  }
  Vector nodes=new Vector(_transitiveClosure.length);
  for (int i=0; i < _transitiveClosure.length; i++) {
    boolean orthem=false;
    for (int j=0; j < N; j++) {
      orthem=orthem || _transitiveClosure[ids[j]][i];
    }
    if (orthem) {
      nodes.addElement(_getNodeObject(i));
    }
  }
  Object[] arr=new Object[nodes.size()];
  for (int i=0; i < nodes.size(); i++) {
    arr[i]=nodes.elementAt(i);
  }
  return arr;
}"
76550,"/** 
 * Find all the nodes that can be reached backward from the specified nodes. The reachable nodes do not include the specific ones unless there is a loop from the specified node back to itself. The implementation computes the transitive closure of the graph, if it is not already computed after the last graph change.  So the first call to this method after graph change may be slow, but all the subsequent calls return in constant time.
 * @param o an Object representing a node in this graph.
 * @return an array of Objects representing nodes reachable fromthe specified one.
 * @exception IllegalArgumentException If the specified Object isnot a node in this graph.
 */
public Object[] backwardReachableNodes(Object[] objs){
  _computeTransitiveClosure();
  int N=objs.length;
  int ids[]=new int[N];
  for (int i=0; i < N; i++) {
    ids[i]=_getNodeId(objs[i]);
  }
  Vector nodes=new Vector(_transitiveClosure.length);
  for (int i=0; i < _transitiveClosure.length; i++) {
    boolean orthem=false;
    for (int j=0; j < N; j++) {
      orthem=orthem || _transitiveClosure[i][j];
    }
    if (orthem) {
      nodes.addElement(_getNodeObject(i));
    }
  }
  Object[] arr=new Object[nodes.size()];
  for (int i=0; i < nodes.size(); i++) {
    arr[i]=nodes.elementAt(i);
  }
  return arr;
}","/** 
 * Find all the nodes that can be reached backward from the specified nodes. The reachable nodes do not include the specific ones unless there is a loop from the specified node back to itself. The implementation computes the transitive closure of the graph, if it is not already computed after the last graph change.  So the first call to this method after graph change may be slow, but all the subsequent calls return in constant time.
 * @param o an Object representing a node in this graph.
 * @return an array of Objects representing nodes reachable fromthe specified one.
 * @exception IllegalArgumentException If the specified Object isnot a node in this graph.
 */
public Object[] backwardReachableNodes(Object[] objs){
  _computeTransitiveClosure();
  int N=objs.length;
  int ids[]=new int[N];
  for (int i=0; i < N; i++) {
    ids[i]=_getNodeId(objs[i]);
  }
  Vector nodes=new Vector(_transitiveClosure.length);
  for (int i=0; i < _transitiveClosure.length; i++) {
    boolean orthem=false;
    for (int j=0; j < N; j++) {
      orthem=orthem || _transitiveClosure[i][ids[j]];
    }
    if (orthem) {
      nodes.addElement(_getNodeObject(i));
    }
  }
  Object[] arr=new Object[nodes.size()];
  for (int i=0; i < nodes.size(); i++) {
    arr[i]=nodes.elementAt(i);
  }
  return arr;
}"
76551,"public void fire(){
  try {
    int count=0;
    int size=0;
    ConditionalBranch[] branches=new ConditionalBranch[2];
    while (true) {
      if (size < _depth) {
        branches[0]=new ConditionalReceive(input,0,0);
      }
      if (size > 0) {
        branches[1]=new ConditionalSend(output,1,1,_buffer[_readFrom]);
      }
      int successfulBranch=chooseBranch(branches);
      if (successfulBranch == 0) {
        size++;
        _buffer[_writeTo]=getToken();
        _writeTo++;
        System.out.println(getName() + ""String_Node_Str"" + getToken().toString()+ ""String_Node_Str""+ _size);
      }
 else {
        _size--;
        _readFrom--;
        System.out.println(getName() + ""String_Node_Str"" + getToken().toString()+ ""String_Node_Str""+ _size);
      }
      count++;
    }
  }
 catch (  IllegalActionException ex) {
    System.out.println(""String_Node_Str"");
  }
catch (  NoTokenException ex) {
    System.out.println(""String_Node_Str"");
  }
 finally {
    _again=false;
  }
}","public void fire(){
  try {
    int count=0;
    ConditionalBranch[] branches=new ConditionalBranch[2];
    while (true) {
      if (_size < _depth) {
        branches[0]=new ConditionalReceive(input,0,0);
      }
 else {
        branches[0]=null;
      }
      if (_size > 0) {
        branches[1]=new ConditionalSend(output,0,1,_buffer[_readFrom]);
      }
 else {
        branches[1]=null;
      }
      int successfulBranch=chooseBranch(branches);
      if (successfulBranch == 0) {
        _size++;
        _buffer[_writeTo]=getToken();
        _writeTo=++_writeTo % _depth;
        System.out.println(getName() + ""String_Node_Str"" + getToken().toString()+ ""String_Node_Str""+ _size);
      }
 else {
        _size--;
        _readFrom=++_readFrom % _depth;
        System.out.println(getName() + ""String_Node_Str"" + getToken().toString()+ ""String_Node_Str""+ _size);
      }
      count++;
    }
  }
 catch (  IllegalActionException ex) {
    System.out.println(""String_Node_Str"" + ex.getMessage());
  }
catch (  NoTokenException ex) {
    System.out.println(""String_Node_Str"");
  }
 finally {
    _again=false;
  }
}"
76552,"/** 
 * Return the Complex value contained by this token.
 * @return The Compelx value contained by this token.
 */
public Complex getValue(){
  return _value;
}","/** 
 * Return the Complex value contained by this token.
 * @return The Compelx value contained by this token.
 */
public Complex getValue(){
  return complexValue();
}"
76553,"/** 
 * Called to report an execution failure
 */
public void executionError(ExecutionEvent event){
  Debug.println(""String_Node_Str"");
}","/** 
 * Called to report an execution failure
 */
public void executionError(ExecutionEvent event){
  Debug.println(""String_Node_Str"");
  Exception e=event.getException();
  e.printStackTrace();
}"
76554,"/** 
 * Erase the point at the given index in the given dataset.  If lines are being drawn, also erase the line to the next points (note: not to the previous point).  The point is not checked to see whether it is in range, so care must be taken by the caller to ensure that it is. The change will be made visible if the plot is visible on the screen.  Otherwise, it will take effect the next time the plot is drawn on the screen.
 * @param dataset The data set index.
 * @param index The index of the point to erase.
 */
public synchronized void erasePoint(int dataset,int index){
  if (isShowing()) {
    _erasePoint(getGraphics(),dataset,index);
  }
  Vector points=(Vector)_points.elementAt(dataset);
  if (points != null) {
    PlotPoint pt=(PlotPoint)points.elementAt(index);
    if (pt != null) {
      if (pt.x == _xBottom || pt.x == _xTop || pt.y == _yBottom || pt.y == _yTop) {
        _xyInvalid=true;
      }
      points.removeElementAt(index);
    }
  }
}","/** 
 * Erase the point at the given index in the given dataset.  If lines are being drawn, also erase the line to the next points (note: not to the previous point).  The point is not checked to see whether it is in range, so care must be taken by the caller to ensure that it is. The change will be made visible if the plot is visible on the screen.  Otherwise, it will take effect the next time the plot is drawn on the screen.
 * @param dataset The data set index.
 * @param index The index of the point to erase.
 */
public synchronized void erasePoint(int dataset,int index){
  _checkDatasetIndex(dataset);
  if (isShowing()) {
    _erasePoint(getGraphics(),dataset,index);
  }
  Vector points=(Vector)_points.elementAt(dataset);
  if (points != null) {
    PlotPoint pt=(PlotPoint)points.elementAt(index);
    if (pt != null) {
      if (pt.x == _xBottom || pt.x == _xTop || pt.y == _yBottom || pt.y == _yTop) {
        _xyInvalid=true;
      }
      points.removeElementAt(index);
    }
  }
}"
76555,"/** 
 * Add a port to this actor. This overrides the base class to throw an exception if the added port is not an instance of IOPort.  This method should not be used directly.  Call the setContainer() method of the port instead. This method does not set the container of the port to point to this actor. It assumes that the port is in the same workspace as this actor, but does not check.  The caller should check. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @param port The port to add to this actor.
 * @exception IllegalActionException If the port class is notacceptable to this actor, or the port has no name.
 * @exception NameDuplicationException If the port name collides with aname already in the actor.
 */
protected void _addPort(Port port) throws IllegalActionException, NameDuplicationException {
  if (!(port instanceof ComponentPort)) {
    throw new IllegalActionException(this,port,""String_Node_Str"");
  }
  super._addPort(port);
}","/** 
 * Add a port to this actor. This overrides the base class to throw an exception if the added port is not an instance of IOPort.  This method should not be used directly.  Call the setContainer() method of the port instead. This method does not set the container of the port to point to this actor. It assumes that the port is in the same workspace as this actor, but does not check.  The caller should check. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @param port The port to add to this actor.
 * @exception IllegalActionException If the port class is notacceptable to this actor, or the port has no name.
 * @exception NameDuplicationException If the port name collides with aname already in the actor.
 */
protected void _addPort(Port port) throws IllegalActionException, NameDuplicationException {
  if (!(port instanceof IOPort)) {
    throw new IllegalActionException(this,port,""String_Node_Str"");
  }
  super._addPort(port);
}"
76556,"/** 
 * Rescale so that the data that is currently plotted just fits. This overrides the base class method to ensure that the protected variables _xBottom, _xTop, _yBottom, and _yTop are valid. This method calls repaint(), which eventually causes the display to be updated.
 */
public synchronized void fillPlot(){
  if (_xyInvalid) {
    _xBottom=Double.MAX_VALUE;
    _xTop=-Double.MIN_VALUE;
    _yBottom=Double.MAX_VALUE;
    _yTop=-Double.MIN_VALUE;
    for (int dataset=0; dataset < _points.size(); dataset++) {
      Vector points=(Vector)_points.elementAt(dataset);
      for (int index=0; index < points.size(); index++) {
        PlotPoint pt=(PlotPoint)points.elementAt(index);
        if (pt.x < _xBottom)         _xBottom=pt.x;
        if (pt.x > _xTop)         _xTop=pt.x;
        if (pt.y < _yBottom)         _yBottom=pt.y;
        if (pt.y > _yTop)         _yTop=pt.y;
      }
    }
  }
  _xyInvalid=false;
  super.fillPlot();
}","/** 
 * Rescale so that the data that is currently plotted just fits. This overrides the base class method to ensure that the protected variables _xBottom, _xTop, _yBottom, and _yTop are valid. This method calls repaint(), which eventually causes the display to be updated.
 */
public synchronized void fillPlot(){
  if (_xyInvalid) {
    _xBottom=Double.MAX_VALUE;
    _xTop=-Double.MIN_VALUE;
    _yBottom=Double.MAX_VALUE;
    _yTop=-Double.MIN_VALUE;
    for (int dataset=0; dataset < _points.size(); dataset++) {
      Vector points=(Vector)_points.elementAt(dataset);
      for (int index=0; index < points.size(); index++) {
        PlotPoint pt=(PlotPoint)points.elementAt(index);
        if (pt.x < _xBottom)         _xBottom=pt.x;
        if (pt.x > _xTop)         _xTop=pt.x;
        if (pt.y < _yBottom)         _yBottom=pt.y;
        if (pt.y > _yTop)         _yTop=pt.y;
      }
    }
  }
  _xyInvalid=false;
  if (_bars) {
    if (_yBottom > 0.0)     _yBottom=0.0;
    if (_yTop < 0.0)     _yTop=0.0;
  }
  super.fillPlot();
}"
76557,"/** 
 * Parse a line that gives plotting information. Return true if the line is recognized.  Lines with syntax errors are ignored.
 * @param line A command line.
 * @return True if the line is recognized.
 */
protected boolean _parseLine(String line){
  boolean connected=false;
  if (_connected)   connected=true;
  if (super._parseLine(line)) {
    _pxgraphBlankLineMode=false;
    return true;
  }
 else {
    String lcLine=new String(line.toLowerCase());
    if (lcLine.startsWith(""String_Node_Str"")) {
      String style=(line.substring(6)).trim();
      setMarksStyle(style);
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",16) >= 0) {
        _reusedatasets=false;
      }
 else {
        _reusedatasets=true;
      }
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"") || (_pxgraphBlankLineMode && lcLine.length() == 0)) {
      if (_reusedatasets && lcLine.length() > 0) {
        String tlegend=(line.substring(8)).trim();
        _currentdataset=-1;
        int i;
        for (i=0; i <= _maxdataset; i++) {
          if (getLegend(i).compareTo(tlegend) == 0) {
            _currentdataset=i;
          }
        }
        if (_currentdataset != -1) {
          return true;
        }
 else {
          _currentdataset=_maxdataset;
        }
      }
      _firstinset=true;
      _sawfirstdataset=true;
      _currentdataset++;
      if (lcLine.length() > 0) {
        String legend=(line.substring(8)).trim();
        if (legend != null && legend.length() > 0) {
          addLegend(_currentdataset,legend);
        }
        _pxgraphBlankLineMode=false;
      }
      _maxdataset=_currentdataset;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",6) >= 0) {
        setConnected(false);
      }
 else {
        setConnected(true);
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",9) >= 0) {
        setImpulses(false);
      }
 else {
        setImpulses(true);
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",5) >= 0) {
        setBars(false);
      }
 else {
        setBars(true);
        if (!_yRangeGiven) {
          _yBottom=0;
        }
        int comma=line.indexOf(""String_Node_Str"",5);
        String barwidth;
        String baroffset=null;
        if (comma > 0) {
          barwidth=(line.substring(5,comma)).trim();
          baroffset=(line.substring(comma + 1)).trim();
        }
 else {
          barwidth=(line.substring(5)).trim();
        }
        try {
          Double bwidth=new Double(barwidth);
          double boffset=_baroffset;
          if (baroffset != null) {
            boffset=(new Double(baroffset)).doubleValue();
          }
          setBars(bwidth.doubleValue(),boffset);
        }
 catch (        NumberFormatException e) {
        }
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      connected=false;
      line=line.substring(5,line.length()).trim();
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      connected=false;
      line=line.substring(4,line.length()).trim();
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=line.substring(5,line.length()).trim();
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=line.substring(4,line.length()).trim();
    }
    line=line.trim();
    int fieldsplit=line.indexOf(""String_Node_Str"");
    if (fieldsplit == -1) {
      fieldsplit=line.indexOf(""String_Node_Str"");
    }
    if (fieldsplit == -1) {
      fieldsplit=line.indexOf(""String_Node_Str"");
    }
    if (fieldsplit > 0) {
      String x=(line.substring(0,fieldsplit)).trim();
      String y=(line.substring(fieldsplit + 1)).trim();
      int fieldsplit2=y.indexOf(""String_Node_Str"");
      if (fieldsplit2 == -1) {
        fieldsplit2=y.indexOf(""String_Node_Str"");
      }
      if (fieldsplit2 == -1) {
        fieldsplit2=y.indexOf(""String_Node_Str"");
      }
      if (fieldsplit2 > 0) {
        line=(y.substring(fieldsplit2 + 1)).trim();
        y=(y.substring(0,fieldsplit2)).trim();
      }
      try {
        Double xpt=new Double(x);
        Double ypt=new Double(y);
        if (fieldsplit2 > 0) {
          int fieldsplit3=line.indexOf(""String_Node_Str"");
          if (fieldsplit3 == -1) {
            fieldsplit3=line.indexOf(""String_Node_Str"");
          }
          if (fieldsplit3 == -1) {
            fieldsplit2=line.indexOf(""String_Node_Str"");
          }
          if (fieldsplit3 > 0) {
            String yl=(line.substring(0,fieldsplit3)).trim();
            String yh=(line.substring(fieldsplit3 + 1)).trim();
            Double yLowEB=new Double(yl);
            Double yHighEB=new Double(yh);
            connected=_addLegendIfNecessary(connected);
            addPointWithErrorBars(_currentdataset,xpt.doubleValue(),ypt.doubleValue(),yLowEB.doubleValue(),yHighEB.doubleValue(),connected);
            return true;
          }
 else {
            connected=_addLegendIfNecessary(connected);
            addPoint(_currentdataset,xpt.doubleValue(),ypt.doubleValue(),connected);
            return true;
          }
        }
 else {
          connected=_addLegendIfNecessary(connected);
          addPoint(_currentdataset,xpt.doubleValue(),ypt.doubleValue(),connected);
          return true;
        }
      }
 catch (      NumberFormatException e) {
      }
    }
  }
  return false;
}","/** 
 * Parse a line that gives plotting information. Return true if the line is recognized.  Lines with syntax errors are ignored.
 * @param line A command line.
 * @return True if the line is recognized.
 */
protected boolean _parseLine(String line){
  boolean connected=false;
  if (_connected)   connected=true;
  if (super._parseLine(line)) {
    _pxgraphBlankLineMode=false;
    return true;
  }
 else {
    String lcLine=new String(line.toLowerCase());
    if (lcLine.startsWith(""String_Node_Str"")) {
      String style=(line.substring(6)).trim();
      setMarksStyle(style);
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",16) >= 0) {
        _reusedatasets=false;
      }
 else {
        _reusedatasets=true;
      }
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"") || (_pxgraphBlankLineMode && lcLine.length() == 0)) {
      if (_reusedatasets && lcLine.length() > 0) {
        String tlegend=(line.substring(8)).trim();
        _currentdataset=-1;
        int i;
        for (i=0; i <= _maxdataset; i++) {
          if (getLegend(i).compareTo(tlegend) == 0) {
            _currentdataset=i;
          }
        }
        if (_currentdataset != -1) {
          return true;
        }
 else {
          _currentdataset=_maxdataset;
        }
      }
      _firstinset=true;
      _sawfirstdataset=true;
      _currentdataset++;
      if (lcLine.length() > 0) {
        String legend=(line.substring(8)).trim();
        if (legend != null && legend.length() > 0) {
          addLegend(_currentdataset,legend);
        }
        _pxgraphBlankLineMode=false;
      }
      _maxdataset=_currentdataset;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",6) >= 0) {
        setConnected(false);
      }
 else {
        setConnected(true);
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",9) >= 0) {
        setImpulses(false);
      }
 else {
        setImpulses(true);
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",5) >= 0) {
        setBars(false);
      }
 else {
        setBars(true);
        int comma=line.indexOf(""String_Node_Str"",5);
        String barwidth;
        String baroffset=null;
        if (comma > 0) {
          barwidth=(line.substring(5,comma)).trim();
          baroffset=(line.substring(comma + 1)).trim();
        }
 else {
          barwidth=(line.substring(5)).trim();
        }
        try {
          Double bwidth=new Double(barwidth);
          double boffset=_baroffset;
          if (baroffset != null) {
            boffset=(new Double(baroffset)).doubleValue();
          }
          setBars(bwidth.doubleValue(),boffset);
        }
 catch (        NumberFormatException e) {
        }
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      connected=false;
      line=line.substring(5,line.length()).trim();
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      connected=false;
      line=line.substring(4,line.length()).trim();
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=line.substring(5,line.length()).trim();
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=line.substring(4,line.length()).trim();
    }
    line=line.trim();
    int fieldsplit=line.indexOf(""String_Node_Str"");
    if (fieldsplit == -1) {
      fieldsplit=line.indexOf(""String_Node_Str"");
    }
    if (fieldsplit == -1) {
      fieldsplit=line.indexOf(""String_Node_Str"");
    }
    if (fieldsplit > 0) {
      String x=(line.substring(0,fieldsplit)).trim();
      String y=(line.substring(fieldsplit + 1)).trim();
      int fieldsplit2=y.indexOf(""String_Node_Str"");
      if (fieldsplit2 == -1) {
        fieldsplit2=y.indexOf(""String_Node_Str"");
      }
      if (fieldsplit2 == -1) {
        fieldsplit2=y.indexOf(""String_Node_Str"");
      }
      if (fieldsplit2 > 0) {
        line=(y.substring(fieldsplit2 + 1)).trim();
        y=(y.substring(0,fieldsplit2)).trim();
      }
      try {
        Double xpt=new Double(x);
        Double ypt=new Double(y);
        if (fieldsplit2 > 0) {
          int fieldsplit3=line.indexOf(""String_Node_Str"");
          if (fieldsplit3 == -1) {
            fieldsplit3=line.indexOf(""String_Node_Str"");
          }
          if (fieldsplit3 == -1) {
            fieldsplit2=line.indexOf(""String_Node_Str"");
          }
          if (fieldsplit3 > 0) {
            String yl=(line.substring(0,fieldsplit3)).trim();
            String yh=(line.substring(fieldsplit3 + 1)).trim();
            Double yLowEB=new Double(yl);
            Double yHighEB=new Double(yh);
            connected=_addLegendIfNecessary(connected);
            addPointWithErrorBars(_currentdataset,xpt.doubleValue(),ypt.doubleValue(),yLowEB.doubleValue(),yHighEB.doubleValue(),connected);
            return true;
          }
 else {
            connected=_addLegendIfNecessary(connected);
            addPoint(_currentdataset,xpt.doubleValue(),ypt.doubleValue(),connected);
            return true;
          }
        }
 else {
          connected=_addLegendIfNecessary(connected);
          addPoint(_currentdataset,xpt.doubleValue(),ypt.doubleValue(),connected);
          return true;
        }
      }
 catch (      NumberFormatException e) {
      }
    }
  }
  return false;
}"
76558,"/** 
 * If paused, resume the currently paused simulation.
 */
public synchronized void resume(){
  _isPaused=false;
  _runningthread.notify();
}","/** 
 * If paused, resume the currently paused simulation.
 */
public synchronized void resume(){
  if (_isRunning && _isPaused) {
    _isPaused=false;
    if (_runningthread != null)     _runningthread.notify();
  }
}"
76559,"/** 
 * Stop any currently executing simulation and cleanup nicely.
 */
public synchronized void wrapup(){
  _isRunning=false;
  _isPaused=false;
  _runningthread.notify();
}","/** 
 * Stop any currently executing simulation and cleanup nicely.
 */
public synchronized void wrapup(){
  _isRunning=false;
  _isPaused=false;
  if (_runningthread != null)   _runningthread.notify();
}"
76560,"/** 
 * Start an execution that will run for no more than a specified number of iterations.   The execution may be terminated early  by calling abort, finish, or returning false in a postfire method.
 */
public synchronized void go(int iterations){
  if (_isRunning)   return;
  _isRunning=true;
  _isPaused=false;
  _iterations=iterations;
  if (_runningthread != null) {
    _runningthread.stop();
    try {
      _runningthread.join();
    }
 catch (    InterruptedException e) {
    }
    _runningthread=null;
  }
  _runningthread=new Thread(this);
  _runningthread.start();
}","/** 
 * Start an execution that will run for no more than a specified number of iterations.   The execution may be terminated early  by calling abort, finish, or returning false in a postfire method. This method starts a new ManagerExecutionThread which will call back to this object in 'blockingGo'.
 */
public synchronized void go(int iterations){
  if (_isRunning)   return;
  _iterations=iterations;
  if (_runningthread != null) {
    _runningthread.stop();
    try {
      _runningthread.join();
    }
 catch (    InterruptedException e) {
    }
    _runningthread=null;
  }
  _runningthread=new ManagerExecutionThread(this,iterations);
  _runningthread.start();
}"
76561,"/** 
 * Terminate any currently executing simulation with extreme prejudice.   Kill the main execution thread and call terminate on the toplevel  container.   This should cause any actors to free up any resources  they have allocated and directors should kill any threads they have  created.   However, a consistant state is not guaraunteed.   The  environment should probably be restarted before attemping any further operations.
 */
public void terminate(){
  _runningthread.stop();
  try {
    _runningthread.join();
  }
 catch (  InterruptedException e) {
  }
  _runningthread=null;
  CompositeActor container=((CompositeActor)getContainer());
  container.terminate();
  ExecutionEvent event=new ExecutionEvent(this);
  Enumeration listeners=_ExecutionListeners.elements();
  while (listeners.hasMoreElements()) {
    ExecutionListener l=(ExecutionListener)listeners.nextElement();
    l.executionTerminated(event);
  }
}","/** 
 * Terminate any currently executing simulation with extreme prejudice.   Kill the main execution thread and call terminate on the toplevel  container.   This should cause any actors to free up any resources  they have allocated and directors should kill any threads they have  created.   However, a consistant state is not guaraunteed.   The  environment should probably be restarted before attemping any further operations.
 */
public void terminate(){
  if (_runningthread != null) {
    _runningthread.stop();
    try {
      _runningthread.join();
    }
 catch (    InterruptedException e) {
    }
    _runningthread=null;
  }
  CompositeActor container=((CompositeActor)getContainer());
  container.terminate();
  ExecutionEvent event=new ExecutionEvent(this);
  Enumeration listeners=_ExecutionListeners.elements();
  while (listeners.hasMoreElements()) {
    ExecutionListener l=(ExecutionListener)listeners.nextElement();
    l.executionTerminated(event);
  }
  _isRunning=false;
  _isPaused=false;
}"
76562,"/** 
 * If not paused, then pause the simulation.
 */
public synchronized void pause(){
  _isPaused=true;
}","/** 
 * If not paused, then pause the simulation.
 */
public synchronized void pause(){
  if (_isRunning)   _isPaused=true;
}"
76563,"/** 
 * Get the ID of this event. The ID may give some additional  information about why the Parameter changed.
 * @return The integer ID.
 */
public int getID(){
  return _id;
}","/** 
 * Get the ID of this event. The ID may give some additional  information about why the Parameter changed.
 * @return The integer ID.
 */
public int getID(){
  return id;
}"
76564,"/** 
 * Get the Parameter associated with this event. 
 * @return The Parameter which changed or was removed.
 */
public int getParameter(){
  return _parameter;
}","/** 
 * Get the Parameter associated with this event. 
 * @return The Parameter which changed or was removed.
 */
public Parameter getParameter(){
  return _parameter;
}"
76565,"/** 
 * This is the thread that is started to actually perform the execution. It begins by calling initialize on its container, which is the toplevel composite actor.   It then continually calls iterate based on the variables _isRunning, _isPaused, and _iterations.  It finally  calls wrapup on its container to clean up after the execution.
 */
public void run(){
  CompositeActor container=((CompositeActor)getContainer());
  int count=0;
  int iterations;
  try {
    try {
      iterations=_iterations;
      container.initialize();
      while (_isRunning && ((iterations < 0) || (count++ < iterations)) && iterate()) {
        try {
          if (_isPaused)           _runningthread.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
  finally {
      container.wrapup();
    }
  }
 catch (  IllegalActionException e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
}","/** 
 * This is the thread that is started to actually perform the execution. It begins by calling initialize on its container, which is the toplevel composite actor.   It then continually calls iterate based on the variables _isRunning, _isPaused, and _iterations.  It finally  calls wrapup on its container to clean up after the execution.
 */
public void run(){
  CompositeActor container=((CompositeActor)getContainer());
  int count=0;
  int iterations;
  try {
    try {
      iterations=_iterations;
      container.initialize();
      while (_isRunning && ((iterations < 0) || (count++ < iterations)) && iterate()) {
        try {
          if (_isPaused)           _runningthread.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
  finally {
      _isRunning=false;
      _isPaused=false;
      container.wrapup();
    }
  }
 catch (  IllegalActionException e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
}"
76566,"/** 
 * If this port is transparent, then deeply enumerate the ports connected on the inside.  Otherwise, enumerate just this port. All ports enumerated are opaque. Note that the returned enumeration could conceivably be empty, for example if this port is transparent but has no inside links. Also, a port may be listed more than once if more than one inside connection to it has been established. This method is read-synchronized on the workspace.
 * @return An enumeration of ComponentPort objects.
 */
public Enumeration deepInsidePorts(){
  try {
    workspace().getReadAccess();
    if (_deeplinkedinportsversion == workspace().getVersion()) {
      return _deeplinkedinports.elements();
    }
    LinkedList result=new LinkedList();
    if (isOpaque()) {
      result.insertLast(this);
    }
 else {
      Enumeration relations=insideRelations();
      while (relations.hasMoreElements()) {
        Relation relation=(Relation)relations.nextElement();
        Enumeration insideports=relation.linkedPorts(this);
        while (insideports.hasMoreElements()) {
          ComponentPort downport=(ComponentPort)insideports.nextElement();
          if (downport._outside(relation.getContainer())) {
            if (downport.isOpaque()) {
              result.insertLast(downport);
            }
 else {
              result.appendElements(downport.deepConnectedPorts());
            }
          }
 else {
            result.appendElements(downport.deepInsidePorts());
          }
        }
      }
    }
    _deeplinkedinports=result;
    _deeplinkedinportsversion=workspace().getVersion();
    return _deeplinkedinports.elements();
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * If this port is transparent, then deeply enumerate the ports connected on the inside.  Otherwise, enumerate just this port. All ports enumerated are opaque. Note that the returned enumeration could conceivably be empty, for example if this port is transparent but has no inside links. Also, a port may be listed more than once if more than one inside connection to it has been established.
 * @return An enumeration of ComponentPort objects.
 */
public Enumeration deepInsidePorts(){
  try {
    workspace().getReadAccess();
    return _deepInsidePorts(null);
  }
  finally {
    workspace().doneReading();
  }
}"
76567,"/** 
 * Deeply enumerate the ports connected to this port on the outside. Begin by enumerating the ports that are connected to this port. If any of those are transparent ports that we are connected to from the inside, then enumerate all the ports deeply connected on the outside to that transparent port.  Note that a port may be listed more than once. This method is read-synchronized on the workspace.
 * @return An enumeration of ComponentPort objects.
 */
public Enumeration deepConnectedPorts(){
  try {
    workspace().getReadAccess();
    if (_deeplinkedportsversion == workspace().getVersion()) {
      return _deeplinkedports.elements();
    }
    Enumeration nearrelations=linkedRelations();
    LinkedList result=new LinkedList();
    while (nearrelations.hasMoreElements()) {
      ComponentRelation relation=(ComponentRelation)nearrelations.nextElement();
      Enumeration connectedports=relation.linkedPorts(this);
      while (connectedports.hasMoreElements()) {
        ComponentPort port=(ComponentPort)connectedports.nextElement();
        if (port._outside(relation.getContainer())) {
          if (port.isOpaque()) {
            result.insertLast(port);
          }
 else {
            result.appendElements(port.deepConnectedPorts());
          }
        }
 else {
          if (port.isOpaque()) {
            result.insertLast(port);
          }
 else {
            result.appendElements(port.deepInsidePorts());
          }
        }
      }
    }
    _deeplinkedports=result;
    _deeplinkedportsversion=workspace().getVersion();
    return _deeplinkedports.elements();
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Deeply enumerate the ports connected to this port on the outside. Begin by enumerating the ports that are connected to this port. If any of those are transparent ports that we are connected to from the inside, then enumerate all the ports deeply connected on the outside to that transparent port.  Note that a port may be listed more than once. This method read synchronized on the workspace.
 * @return An enumeration of ComponentPort objects.
 */
public Enumeration deepConnectedPorts(){
  try {
    workspace().getReadAccess();
    return _deepConnectedPorts(null);
  }
  finally {
    workspace().doneReading();
  }
}"
76568,"/** 
 * Produce an output event at the current time, and then schedule a firing in the future.
 * @exception CloneNotSupportedException If there is more than onedestination and the output token cannot be cloned.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  output.broadcast(_value.getToken());
  refireAtTime(((DoubleToken)_interval.getToken()).doubleValue());
}","/** 
 * Produce an output event at the current time, and then schedule a firing in the future.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  output.broadcast(_value.getToken());
  refireAtTime(((DoubleToken)_interval.getToken()).doubleValue());
}"
76569,"/** 
 * Produce the initializer event that will cause the generation of the first output at time zero. FIXME: What to do if the initial current event is less than zero ?
 * @exception CloneNotSupportedException If the base class throws it.
 * @exception IllegalActionException If there is no director.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  double curTime=getCurrentTime();
  refireAtTime(0.0 - curTime);
}","/** 
 * Produce the initializer event that will cause the generation of the first output at time zero. FIXME: What to do if the initial current event is less than zero ?
 * @exception IllegalActionException If there is no director.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  double curTime=getCurrentTime();
  refireAtTime(0.0 - curTime);
}"
76570,"/** 
 * Transfer the input tokens to the outputs with the specified delay.
 * @exception CloneNotSupportedException If the output has multipledestinations and the token does not support cloning.
 * @exception IllegalActionException Not thrown in this class.
 */
public void fire() throws IllegalActionException {
  for (int i=0; i < input.getWidth(); i++) {
    Token inputToken;
    inputToken=input.get(i);
    output.send(i,inputToken,((DoubleToken)_delay.getToken()).doubleValue());
  }
}","/** 
 * Transfer the input tokens to the outputs with the specified delay.
 * @exception IllegalActionException Not thrown in this class.
 */
public void fire() throws IllegalActionException {
  for (int i=0; i < input.getWidth(); i++) {
    Token inputToken;
    inputToken=input.get(i);
    output.send(i,inputToken,((DoubleToken)_delay.getToken()).doubleValue());
  }
}"
76571,"/** 
 * Rescale the plot so that all the data plotted is visible.
 */
public void wrapup() throws IllegalActionException {
  double binWidth=((DoubleToken)_binWidth.getToken()).doubleValue();
  for (int i=0; i < _dataCount.capacity(); i++) {
    Object d=_dataCount.elementAt(i);
    if (d != null) {
      Integer y=(Integer)d;
      _plot.addPoint(0,i * binWidth + .5 * binWidth,y.doubleValue(),false);
    }
  }
  _plot.fillPlot();
  super.wrapup();
}","/** 
 * Rescale the plot so that all the data plotted is visible.
 * @exception IllegalActionException If the parent class throws it.
 */
public void wrapup() throws IllegalActionException {
  double binWidth=((DoubleToken)_binWidth.getToken()).doubleValue();
  Enumeration keys=_map.keys();
  while (keys.hasMoreElements()) {
    Integer bin=(Integer)keys.nextElement();
    Integer height=(Integer)_map.at(bin);
    double binCenter=bin.intValue() * binWidth + _binZeroOffset;
    _plot.addPoint(0,binCenter,height.intValue(),false);
  }
  _plot.fillPlot();
  super.wrapup();
}"
76572,"/** 
 * Construct a plot actor that uses the specified plot object. This can be used to create applets that plot the results of DE simulations.
 */
public DEHistogram(CompositeActor container,String name,double binWidth,Plot plot) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  input=new IOPort(this,""String_Node_Str"",true,false);
  input.makeMultiport(true);
  _plot=plot;
  _plot.setBars(0.95 * binWidth,0.05 * binWidth);
  _yMin=(double)-1;
  _yMax=(double)1;
  _binWidth=new Parameter(this,""String_Node_Str"",new DoubleToken(binWidth));
}","/** 
 * Construct a plot actor that uses the specified plot object. This can be used to create applets that plot the results of DE simulations.
 * @exception NameDuplicationException If the parent class throws it.
 * @exception IllegalActionException If the parent class throws it.
 */
public DEHistogram(CompositeActor container,String name,double binWidth,Plot plot) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  input=new IOPort(this,""String_Node_Str"",true,false);
  input.makeMultiport(true);
  _plot=plot;
  _plot.setBars((1 - _percentGap) * binWidth,0.25 * _percentGap * binWidth);
  _yMin=(double)-1;
  _yMax=(double)1;
  _binWidth=new Parameter(this,""String_Node_Str"",new DoubleToken(binWidth));
  _binZeroOffset=binWidth / 2.0;
}"
76573,"/** 
 * Add new input data to the plot.
 */
public void fire() throws IllegalActionException {
  while (input.hasToken(0)) {
    double dataIn=((DoubleToken)input.get(0)).doubleValue();
    double width=((DoubleToken)_binWidth.getToken()).doubleValue();
    int binNum=(int)(dataIn / width);
    if (_dataCount.size() < binNum + 1) {
      _dataCount.setSize(binNum + 1);
    }
    Object d=_dataCount.elementAt(binNum);
    if (d == null) {
      _dataCount.setElementAt(new Integer(1),binNum);
    }
 else {
      Integer dd=(Integer)d;
      _dataCount.setElementAt(new Integer(dd.intValue() + 1),binNum);
    }
  }
}","/** 
 * Add new input data to the plot.
 * @exception IllegalActionException If the input port is disconnected.
 */
public void fire() throws IllegalActionException {
  while (input.hasToken(0)) {
    double dataIn=((DoubleToken)input.get(0)).doubleValue();
    int bin=_valueToBin(dataIn);
    if (bin > _maxBin)     _maxBin=bin;
    if (bin < _minBin)     _minBin=bin;
    Integer binObject=new Integer(bin);
    if (_map.includesKey(binObject)) {
      int oldVal=((Integer)_map.at(binObject)).intValue();
      _map.putAt(binObject,new Integer(oldVal + 1));
    }
 else {
      _map.putAt(binObject,new Integer(1));
    }
  }
}"
76574,"/** 
 * Clear the plot window.
 */
public void initialize() throws IllegalActionException {
  _plot.clear(false);
  _dataCount=new Vector();
}","/** 
 * Initialize the plot window by clearing it, and also clear the map collection.
 * @exception IllegalActionException Not thrown in this class.
 */
public void initialize() throws IllegalActionException {
  _plot.clear(false);
  _map.clear();
  _maxBin=Integer.MIN_VALUE;
  _minBin=Integer.MAX_VALUE;
}"
76575,"/** 
 * If there's an event in the ""input"" port, pass it depending on the ""gate"" input; if there's no event in the input port, but only in the ""gate"" input, pass event when the gate reopens.
 * @exception CloneNotSupportedException Error when cloning event.
 * @exception IllegalActionException Not thrown in this class.
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    DoubleToken inputToken=null;
    inputToken=(DoubleToken)(input.get(0));
    if (gate.hasToken(0)) {
      DoubleToken gateToken=null;
      gateToken=(DoubleToken)(gate.get(0));
      if (gateToken.getValue() == 0.0) {
        _gateOpen=false;
      }
 else {
        _gateOpen=true;
      }
    }
    if (_gateOpen) {
      output.broadcast(inputToken);
      return;
    }
 else {
      _lastToken=inputToken;
    }
  }
 else   if (gate.hasToken(0)) {
    DoubleToken gateToken=null;
    gateToken=(DoubleToken)(gate.get(0));
    if (gateToken.getValue() != 0.0 && _gateOpen == false) {
      _gateOpen=true;
      output.broadcast(_lastToken);
      return;
    }
 else     if (gateToken.getValue() == 0 && _gateOpen == true) {
      _gateOpen=false;
      return;
    }
  }
 else {
    throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * If there's an event in the ""input"" port, pass it depending on the ""gate"" input; if there's no event in the input port, but only in the ""gate"" input, pass event when the gate reopens.
 * @exception IllegalActionException Not thrown in this class.
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    DoubleToken inputToken=null;
    inputToken=(DoubleToken)(input.get(0));
    if (gate.hasToken(0)) {
      DoubleToken gateToken=null;
      gateToken=(DoubleToken)(gate.get(0));
      if (gateToken.getValue() == 0.0) {
        _gateOpen=false;
      }
 else {
        _gateOpen=true;
      }
    }
    if (_gateOpen) {
      output.broadcast(inputToken);
      return;
    }
 else {
      _lastToken=inputToken;
    }
  }
 else   if (gate.hasToken(0)) {
    DoubleToken gateToken=null;
    gateToken=(DoubleToken)(gate.get(0));
    if (gateToken.getValue() != 0.0 && _gateOpen == false) {
      _gateOpen=true;
      output.broadcast(_lastToken);
      return;
    }
 else     if (gateToken.getValue() == 0 && _gateOpen == true) {
      _gateOpen=false;
      return;
    }
  }
 else {
    throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
76576,"/** 
 * @exception CloneNotSupportedException Not thrown in this base class.
 * @exception IllegalActionException Thrown if could not create the receivers.
 */
public void initialize() throws IllegalActionException {
  _gateOpen=true;
  _lastToken=null;
}","/** 
 * Initialize gate to be open, and last token equal null.
 * @exception IllegalActionException Thrown if could not create the receivers.
 */
public void initialize() throws IllegalActionException {
  _gateOpen=true;
  _lastToken=null;
}"
76577,"/** 
 * Rescale the plot so that all the data plotted is visible.
 */
public void wrapup() throws IllegalActionException {
  _plot.fillPlot();
  super.wrapup();
}","/** 
 * Rescale the plot so that all the data plotted is visible.
 * @exception IllegalActionException If the parent class throws it.
 */
public void wrapup() throws IllegalActionException {
  _plot.fillPlot();
  super.wrapup();
}"
76578,"/** 
 * Construct a plot actor that uses the specified plot object. This can be used to create applets that plot the results of DE simulations.
 */
public DEPlot(CompositeActor container,String name,Plot plot) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  input=new IOPort(this,""String_Node_Str"",true,false);
  input.makeMultiport(true);
  _plot=plot;
  _plot.setMarksStyle(""String_Node_Str"");
  _plot.setImpulses(true);
  _plot.setConnected(false);
  _yMin=(double)-1;
  _yMax=(double)1;
}","/** 
 * Construct a plot actor that uses the specified plot object. This can be used to create applets that plot the results of DE simulations.
 * @exception NameDuplicationException If the parent class throws it.
 * @exception IllegalActionException If the parent class throws it.
 */
public DEPlot(CompositeActor container,String name,Plot plot) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  input=new IOPort(this,""String_Node_Str"",true,false);
  input.makeMultiport(true);
  _plot=plot;
  _plot.setMarksStyle(""String_Node_Str"");
  _plot.setImpulses(true);
  _plot.setConnected(false);
  _yMin=(double)-1;
  _yMax=(double)1;
}"
76579,"/** 
 * Add new input data to the plot.
 */
public void fire() throws IllegalActionException {
  if (_firstFiring) {
    _plot.setXRange(getStartTime(),getStopTime());
    _plot.setYRange(getYMin(),getYMax());
    _firstFiring=false;
  }
  int numEmptyChannel=0;
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      double curTime=((DECQDirector)getDirector()).getCurrentTime();
      while (input.hasToken(i)) {
        DoubleToken curToken=null;
        curToken=(DoubleToken)input.get(i);
        double curValue=curToken.doubleValue();
        _plot.addPoint(i,curTime,curValue,false);
      }
    }
 else {
      numEmptyChannel++;
    }
  }
  if (numEmptyChannel == width) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Add new input data to the plot.
 * @exception IllegalActionException Not thrown in this class.
 */
public void fire() throws IllegalActionException {
  int numEmptyChannel=0;
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      double curTime=((DECQDirector)getDirector()).getCurrentTime();
      while (input.hasToken(i)) {
        DoubleToken curToken=null;
        curToken=(DoubleToken)input.get(i);
        double curValue=curToken.doubleValue();
        _plot.addPoint(i,curTime,curValue,false);
      }
    }
 else {
      numEmptyChannel++;
    }
  }
  if (numEmptyChannel == width) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
76580,"/** 
 * Clear the plot window.
 */
public void initialize() throws IllegalActionException {
  _plot.clear(false);
}","/** 
 * Clear the plot window.
 * @exception IllegalActionException Not thrown in this class.
 */
public void initialize() throws IllegalActionException {
  _plot.clear(false);
  _plot.setXRange(getStartTime(),getStopTime());
  _plot.setYRange(getYMin(),getYMax());
  _plot.init();
}"
76581,"/** 
 * Return a token on the queue.  If the offset argument is zero, return the most recent token that was put on the queue. If the offset is 1, return the second most recent token, etc. Do not remove the token from the queue. If there is no such token on the queue (the offset is greater than or equal to the size, or is negative), throw an exception.
 * @param offset The offset from the most recent item on the queue.
 * @exception NoSuchItemException The offset is out of range.
 */
public Token get(int offset){
  try {
    return (Token)_queue.get(offset);
  }
 catch (  NoSuchElementException ex) {
    throw new NoTokenException(getContainer(),""String_Node_Str"" + offset + ""String_Node_Str""+ _queue.size());
  }
}","/** 
 * Return a token on the queue.  If the offset argument is zero, return the most recent token that was put on the queue. If the offset is 1, return the second most recent token, etc. Do not remove the token from the queue. If there is no such token on the queue (the offset is greater than or equal to the size, or is negative), throw an exception.
 * @param offset The offset from the most recent item on the queue.
 * @exception NoTokenException The offset is out of range.
 */
public Token get(int offset){
  try {
    return (Token)_queue.get(offset);
  }
 catch (  NoSuchElementException ex) {
    throw new NoTokenException(getContainer(),""String_Node_Str"" + offset + ""String_Node_Str""+ _queue.size());
  }
}"
76582,"/** 
 * Return a new Token whose value is the value of the argument Token subtracted from the value of this Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion.
 * @param rightArg The token to subtract to this Token.
 * @exception IllegalActionException If the passed token isnot of a type that can be subtracted from this Tokens value in a lossless fashion.
 * @return A new Token containing the result.
 */
public Token subtract(Token rightArg) throws IllegalActionException {
  int typeInfo=TypeCPO.compare(this,rightArg);
  try {
    if (typeInfo == CPO.LOWER) {
      return rightArg.addR(this);
    }
 else     if (rightArg instanceof DoubleToken) {
      double result=_value - ((DoubleToken)rightArg).getValue();
      return new DoubleToken(result);
    }
 else     if (typeInfo == CPO.HIGHER) {
      DoubleToken tmp=(DoubleToken)this.convert(rightArg);
      double result=_value - tmp.getValue();
      return new DoubleToken(result);
    }
 else {
      throw new Exception();
    }
  }
 catch (  Exception ex) {
    String str=""String_Node_Str"";
    str=str + this.getClass().getName() + ""String_Node_Str"";
    str=str + rightArg.getClass().getName();
    throw new IllegalActionException(str + ""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Return a new Token whose value is the value of the argument Token subtracted from the value of this Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion.
 * @param rightArg The token to subtract to this Token.
 * @exception IllegalActionException If the passed token isnot of a type that can be subtracted from this Tokens value in a lossless fashion.
 * @return A new Token containing the result.
 */
public Token subtract(Token rightArg) throws IllegalActionException {
  int typeInfo=TypeCPO.compare(this,rightArg);
  try {
    if (typeInfo == CPO.LOWER) {
      return rightArg.subtractR(this);
    }
 else     if (rightArg instanceof DoubleToken) {
      double result=_value - ((DoubleToken)rightArg).getValue();
      return new DoubleToken(result);
    }
 else     if (typeInfo == CPO.HIGHER) {
      DoubleToken tmp=(DoubleToken)this.convert(rightArg);
      double result=_value - tmp.getValue();
      return new DoubleToken(result);
    }
 else {
      throw new Exception();
    }
  }
 catch (  Exception ex) {
    String str=""String_Node_Str"";
    str=str + this.getClass().getName() + ""String_Node_Str"";
    str=str + rightArg.getClass().getName();
    throw new IllegalActionException(str + ""String_Node_Str"" + ex.getMessage());
  }
}"
76583,"/** 
 * Return a new Token whose value is the value of this Token subtracted from the value of the argument Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion.
 * @param leftArg The token to add this Token to.
 * @exception IllegalActionException If the passed tokenis not of a type that can be added to this Tokens value in a lossless fashion.
 * @return A new Token containing the result.
 */
public Token subtractR(Token leftArg) throws IllegalActionException {
  DoubleToken tmp=(DoubleToken)this.convert(leftArg);
  double result=_value - tmp.getValue();
  return new DoubleToken(result);
}","/** 
 * Return a new Token whose value is the value of this Token subtracted from the value of the argument Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion.
 * @param leftArg The token to add this Token to.
 * @exception IllegalActionException If the passed tokenis not of a type that can be added to this Tokens value in a lossless fashion.
 * @return A new Token containing the result.
 */
public Token subtractR(Token leftArg) throws IllegalActionException {
  DoubleToken tmp=(DoubleToken)this.convert(leftArg);
  double result=tmp.getValue() - _value;
  return new DoubleToken(result);
}"
76584,"/** 
 * Return a new Token whose value is the value of the argument Token subtracted from the value of this Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion.
 * @param rightArg The token to subtract to this Token.
 * @exception IllegalActionException If the passed token isnot of a type that can be subtracted from this Tokens value in a lossless fashion.
 * @return A new Token containing the result.
 */
public Token subtract(Token rightArg) throws IllegalActionException {
  int typeInfo=TypeCPO.compare(this,rightArg);
  try {
    if (typeInfo == CPO.LOWER) {
      return rightArg.addR(this);
    }
 else     if (rightArg instanceof IntToken) {
      int result=_value - ((IntToken)rightArg).getValue();
      return new IntToken(result);
    }
 else     if (typeInfo == CPO.HIGHER) {
      IntToken tmp=(IntToken)this.convert(rightArg);
      int result=_value - tmp.getValue();
      return new IntToken(result);
    }
 else {
      throw new Exception();
    }
  }
 catch (  Exception ex) {
    String str=""String_Node_Str"";
    str=str + this.getClass().getName() + ""String_Node_Str"";
    str=str + rightArg.getClass().getName();
    throw new IllegalActionException(str + ""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Return a new Token whose value is the value of the argument Token subtracted from the value of this Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion.
 * @param rightArg The token to subtract to this Token.
 * @exception IllegalActionException If the passed token isnot of a type that can be subtracted from this Tokens value in a lossless fashion.
 * @return A new Token containing the result.
 */
public Token subtract(Token rightArg) throws IllegalActionException {
  int typeInfo=TypeCPO.compare(this,rightArg);
  try {
    if (typeInfo == CPO.LOWER) {
      return rightArg.subtractR(this);
    }
 else     if (rightArg instanceof IntToken) {
      int result=_value - ((IntToken)rightArg).getValue();
      return new IntToken(result);
    }
 else     if (typeInfo == CPO.HIGHER) {
      IntToken tmp=(IntToken)this.convert(rightArg);
      int result=_value - tmp.getValue();
      return new IntToken(result);
    }
 else {
      throw new Exception();
    }
  }
 catch (  Exception ex) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + getClass().getName() + ""String_Node_Str""+ rightArg.getClass().getName()+ ""String_Node_Str""+ ex.getMessage());
  }
}"
76585,"/** 
 * Return a new Token whose value is the value of this Token subtracted from the value of the argument Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion.
 * @param leftArg The token to add this Token to.
 * @exception IllegalActionException If the passed tokenis not of a type that can be added to this Tokens value in a lossless fashion.
 * @return A new Token containing the result.
 */
public Token subtractR(Token leftArg) throws IllegalActionException {
  IntToken tmp=(IntToken)this.convert(leftArg);
  int result=_value - tmp.getValue();
  return new IntToken(result);
}","/** 
 * Return a new Token whose value is the value of this Token subtracted from the value of the argument Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion.
 * @param leftArg The token to add this Token to.
 * @exception IllegalActionException If the passed tokenis not of a type that can be added to this Tokens value in a lossless fashion.
 * @return A new Token containing the result.
 */
public Token subtractR(Token leftArg) throws IllegalActionException {
  IntToken tmp=(IntToken)this.convert(leftArg);
  int result=tmp.getValue() - _value;
  return new IntToken(result);
}"
76586,"/** 
 * Return a new Token whose value is the value of the argument Token subtracted from the value of this Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion.
 * @param rightArg The token to subtract to this Token.
 * @exception IllegalActionException If the passed token isnot of a type that can be subtracted from this Tokens value in a lossless fashion.
 * @return A new Token containing the result.
 */
public Token subtract(Token rightArg) throws IllegalActionException {
  long typeInfo=TypeCPO.compare(this,rightArg);
  try {
    if (typeInfo == CPO.LOWER) {
      return rightArg.addR(this);
    }
 else     if (rightArg instanceof LongToken) {
      long result=_value - ((LongToken)rightArg).getValue();
      return new LongToken(result);
    }
 else     if (typeInfo == CPO.HIGHER) {
      LongToken tmp=(LongToken)this.convert(rightArg);
      long result=_value - tmp.getValue();
      return new LongToken(result);
    }
 else {
      throw new Exception();
    }
  }
 catch (  Exception ex) {
    String str=""String_Node_Str"";
    str=str + this.getClass().getName() + ""String_Node_Str"";
    str=str + rightArg.getClass().getName();
    throw new IllegalActionException(str + ""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Return a new Token whose value is the value of the argument Token subtracted from the value of this Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion.
 * @param rightArg The token to subtract to this Token.
 * @exception IllegalActionException If the passed token isnot of a type that can be subtracted from this Tokens value in a lossless fashion.
 * @return A new Token containing the result.
 */
public Token subtract(Token rightArg) throws IllegalActionException {
  long typeInfo=TypeCPO.compare(this,rightArg);
  try {
    if (typeInfo == CPO.LOWER) {
      return rightArg.subtractR(this);
    }
 else     if (rightArg instanceof LongToken) {
      long result=_value - ((LongToken)rightArg).getValue();
      return new LongToken(result);
    }
 else     if (typeInfo == CPO.HIGHER) {
      LongToken tmp=(LongToken)this.convert(rightArg);
      long result=_value - tmp.getValue();
      return new LongToken(result);
    }
 else {
      throw new Exception();
    }
  }
 catch (  Exception ex) {
    String str=""String_Node_Str"";
    str=str + this.getClass().getName() + ""String_Node_Str"";
    str=str + rightArg.getClass().getName();
    throw new IllegalActionException(str + ""String_Node_Str"" + ex.getMessage());
  }
}"
76587,"/** 
 * Return a new Token whose value is the value of this Token subtracted from the value of the argument Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion.
 * @param leftArg The token to add this Token to.
 * @exception IllegalActionException If the passed tokenis not of a type that can be added to this Tokens value in a lossless fashion.
 * @return A new Token containing the result.
 */
public Token subtractR(Token leftArg) throws IllegalActionException {
  LongToken tmp=(LongToken)this.convert(leftArg);
  long result=_value - tmp.getValue();
  return new LongToken(result);
}","/** 
 * Return a new Token whose value is the value of this Token subtracted from the value of the argument Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion.
 * @param leftArg The token to add this Token to.
 * @exception IllegalActionException If the passed tokenis not of a type that can be added to this Tokens value in a lossless fashion.
 * @return A new Token containing the result.
 */
public Token subtractR(Token leftArg) throws IllegalActionException {
  LongToken tmp=(LongToken)this.convert(leftArg);
  long result=tmp.getValue() - _value;
  return new LongToken(result);
}"
76588,"/** 
 * Invoke the base class prefire() method, and if it returns true, dequeue the next event from the event queue, advance time to its time stamp, and mark its destination actor for firing. If there are multiple events on the queue with the same time stamp that are destined for the same actor, dequeue all of them, making them available in the input ports of the destination actor. If the time stamp is greater than the stop time, or there are no events on the event queue, then return false, which will have the effect of stopping the simulation.
 * @return True if there is an actor to fire.
 * @exception CloneNotSupportedException If the base class throws it.
 * @exception IllegalActionException If the base class throws it.
 * @exception NameDuplicationException If the base class throws it.
 */
public boolean prefire() throws IllegalActionException, NameDuplicationException {
  _actorToFire=null;
  _filledReceivers.clear();
  if (super.prefire()) {
    DEEvent currentEvent=null;
    FIFOQueue fifo=new FIFOQueue();
    while (true) {
      try {
        currentEvent=(DEEvent)_cQueue.take();
      }
 catch (      IllegalAccessException ex) {
        break;
      }
      if (_actorToFire == null) {
        _actorToFire=currentEvent.actor;
        _currentTime=currentEvent.key.timeStamp();
        if (_currentTime < _startTime) {
          if (_startTimeInitialized) {
            throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          _startTime=_currentTime;
          _startTimeInitialized=true;
        }
        if (_currentTime > _stopTime) {
          return false;
        }
        DEReceiver rec=currentEvent.receiver;
        if (rec != null) {
          if (!_filledReceivers.includes(rec)) {
            _filledReceivers.insertFirst(rec);
          }
          rec._triggerEvent(currentEvent.token);
        }
      }
 else {
        if (currentEvent.key.timeStamp() < _currentTime) {
          throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
        if (currentEvent.key.timeStamp() > _currentTime) {
          fifo.put(currentEvent);
          break;
        }
 else {
          if (currentEvent.actor == _actorToFire) {
            DEReceiver rec=currentEvent.receiver;
            if (rec != null) {
              if (!_filledReceivers.includes(rec)) {
                _filledReceivers.insertFirst(rec);
              }
              rec._triggerEvent(currentEvent.token);
            }
          }
 else {
            fifo.put(currentEvent);
          }
        }
      }
    }
    while (fifo.size() > 0) {
      DEEvent event=(DEEvent)fifo.take();
      _cQueue.put(event.key,event);
    }
  }
  return _actorToFire != null;
}","/** 
 * Invoke the base class prefire() method, and if it returns true, dequeue the next event from the event queue, advance time to its time stamp, and mark its destination actor for firing. If there are multiple events on the queue with the same time stamp that are destined for the same actor, dequeue all of them, making them available in the input ports of the destination actor. If the time stamp is greater than the stop time, or there are no events on the event queue, then return false, which will have the effect of stopping the simulation.
 * @return True if there is an actor to fire.
 * @exception IllegalActionException If the base class throws it.
 * @exception NameDuplicationException If the base class throws it.
 */
public boolean prefire() throws IllegalActionException, NameDuplicationException {
  _actorToFire=null;
  _filledReceivers.clear();
  if (super.prefire()) {
    DEEvent currentEvent=null;
    FIFOQueue fifo=new FIFOQueue();
    while (true) {
      try {
        currentEvent=(DEEvent)_cQueue.take();
      }
 catch (      IllegalAccessException ex) {
        break;
      }
      if (_actorToFire == null) {
        _actorToFire=currentEvent.actor;
        _currentTime=currentEvent.key.timeStamp();
        if (_currentTime < _startTime) {
          if (_startTimeInitialized) {
            throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          _startTime=_currentTime;
          _startTimeInitialized=true;
        }
        if (_currentTime > _stopTime) {
          return false;
        }
        DEReceiver rec=currentEvent.receiver;
        if (rec != null) {
          if (!_filledReceivers.includes(rec)) {
            _filledReceivers.insertFirst(rec);
          }
          rec._triggerEvent(currentEvent.token);
        }
      }
 else {
        if (currentEvent.key.timeStamp() < _currentTime) {
          throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
        if (currentEvent.key.timeStamp() > _currentTime) {
          fifo.put(currentEvent);
          break;
        }
 else {
          if (currentEvent.actor == _actorToFire) {
            DEReceiver rec=currentEvent.receiver;
            if (rec != null) {
              if (!_filledReceivers.includes(rec)) {
                _filledReceivers.insertFirst(rec);
              }
              rec._triggerEvent(currentEvent.token);
            }
          }
 else {
            fifo.put(currentEvent);
          }
        }
      }
    }
    while (fifo.size() > 0) {
      DEEvent event=(DEEvent)fifo.take();
      _cQueue.put(event.key,event);
    }
  }
  return _actorToFire != null;
}"
76589,"/** 
 * Set current time to zero, calculate priorities for simultaneous events, and invoke the initialize() methods of all actors deeply contained by the container.  To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their initialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception CloneNotSupportedException If the initialize() method of thecontainer or one of the deeply contained actors throws it.
 * @exception IllegalActionException If there is a delay-free loop, orif the initialize() method of the container or one of the deeply contained actors throws it.
 */
public void initialize() throws IllegalActionException {
  _cQueue=new CalendarQueue(new DECQComparator());
  _dag=new DirectedAcyclicGraph();
  _currentTime=0.0;
  _startTime=Double.MAX_VALUE;
  _startTimeInitialized=false;
  _constructDirectedGraph();
  if (!_dag.isAcyclic()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  super.initialize();
  _computeDepth();
}","/** 
 * Set current time to zero, calculate priorities for simultaneous events, and invoke the initialize() methods of all actors deeply contained by the container.  To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their initialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If there is a delay-free loop, orif the initialize() method of the container or one of the deeply contained actors throws it.
 */
public void initialize() throws IllegalActionException {
  _cQueue=new CalendarQueue(new DECQComparator());
  _dag=new DirectedAcyclicGraph();
  _currentTime=0.0;
  _startTime=Double.MAX_VALUE;
  _startTimeInitialized=false;
  _constructDirectedGraph();
  if (!_dag.isAcyclic()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  super.initialize();
  _computeDepth();
}"
76590,"private void _computeDepth(){
  Object[] sort=(Object[])_dag.topologicalSort();
  for (int i=sort.length - 1; i >= 0; i--) {
    IOPort p=(IOPort)sort[i];
    System.out.println(p.description(FULLNAME) + ""String_Node_Str"" + i);
    Receiver[][] r;
    try {
      r=p.getReceivers();
    }
 catch (    IllegalActionException e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (r == null) {
      continue;
    }
    for (int j=r.length - 1; j >= 0; j--) {
      for (int k=r[j].length - 1; k >= 0; k--) {
        DEReceiver der=(DEReceiver)r[j][k];
        der.setDepth(i);
      }
    }
  }
}","private void _computeDepth(){
  Object[] sort=(Object[])_dag.topologicalSort();
  System.out.println(""String_Node_Str"");
  for (int i=sort.length - 1; i >= 0; i--) {
    IOPort p=(IOPort)sort[i];
    System.out.println(p.description(FULLNAME) + ""String_Node_Str"" + i);
    Receiver[][] r;
    try {
      r=p.getReceivers();
    }
 catch (    IllegalActionException e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (r == null) {
      continue;
    }
    for (int j=r.length - 1; j >= 0; j--) {
      for (int k=r[j].length - 1; k >= 0; k--) {
        DEReceiver der=(DEReceiver)r[j][k];
        der.setDepth(i);
      }
    }
  }
}"
76591,"/** 
 * Fire the one actor identified by the prefire() method as ready to fire. If there are multiple simultaneous events destined to this actor, then they have all been dequeued from the global queue and put into the corresponding receivers. <p> NOTE: Currently, this means that there may be multiple simultaneous events in a given receiver.  Since many actors may be written in such a way that they do not expect this, this may change in the future. I.e., these events may be made visible over multiple firings rather than all at once.
 */
public void fire() throws IllegalActionException {
  super.fire();
}","/** 
 * Fire the one actor identified by the prefire() method as ready to fire. If there are multiple simultaneous events destined to this actor, then they have all been dequeued from the global queue and put into the corresponding receivers. <p> NOTE: Currently, this means that there may be multiple simultaneous events in a given receiver.  Since many actors may be written in such a way that they do not expect this, this may change in the future. I.e., these events may be made visible over multiple firings rather than all at once.
 * @exception IllegalActionException If the parent class throws it.
 */
public void fire() throws IllegalActionException {
  super.fire();
}"
76592,"/** 
 * Broadcast a token to all receivers connected to this output port with the specified time delay.  The time stamp of of the token is equal to current time plus the specified delay.
 * @param token The token to send.
 * @param delay The time stamp of the token being broadcast.
 * @exception CloneNotSupportedException If there is more than onedestination and the token cannot be cloned.
 * @exception IllegalActionException If the port is not an output.
 */
public void broadcast(Token token,double delay) throws IllegalActionException {
  try {
    workspace().getReadAccess();
    if (!isOutput()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    Receiver fr[][]=getRemoteReceivers();
    if (fr == null) {
      return;
    }
    for (int j=0; j < fr.length; j++) {
      send(j,token,delay);
    }
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Broadcast a token to all receivers connected to this output port with the specified time delay.  The time stamp of of the token is equal to current time plus the specified delay.
 * @param token The token to send.
 * @param delay The time stamp of the token being broadcast.
 * @exception IllegalActionException If the port is not an output.
 */
public void broadcast(Token token,double delay) throws IllegalActionException {
  try {
    workspace().getReadAccess();
    if (!isOutput()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    Receiver fr[][]=getRemoteReceivers();
    if (fr == null) {
      return;
    }
    for (int j=0; j < fr.length; j++) {
      send(j,token,delay);
    }
  }
  finally {
    workspace().doneReading();
  }
}"
76593,"/** 
 * Send a token with the specified time delay to the receivers connected on the specified channel.  The time stamp of of the token is equal to current time plus the specified delay.
 * @param channelindex The index of the channel, from 0 to width-1.
 * @param token The token to send.
 * @param delay The time delay of the token being sent.
 * @exception CloneNotSupportedException If the token cannot be clonedand there is more than one destination.
 * @exception IllegalActionException If the port is not an output,or if the index is out of range.
 */
public void send(int channelindex,Token token,double delay) throws IllegalActionException {
  try {
    workspace().getReadAccess();
    if (!isOutput()) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    if (channelindex >= getWidth() || channelindex < 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    Receiver[][] fr=getRemoteReceivers();
    if (fr == null || fr[channelindex] == null)     return;
    for (int j=0; j < fr[channelindex].length; j++) {
      try {
        ((DEReceiver)fr[channelindex][j]).put(token,delay);
      }
 catch (      ClassCastException e) {
        throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Send a token with the specified time delay to the receivers connected on the specified channel.  The time stamp of of the token is equal to current time plus the specified delay.
 * @param channelindex The index of the channel, from 0 to width-1.
 * @param token The token to send.
 * @param delay The time delay of the token being sent.
 * @exception IllegalActionException If the port is not an output,or if the index is out of range.
 */
public void send(int channelindex,Token token,double delay) throws IllegalActionException {
  try {
    workspace().getReadAccess();
    if (!isOutput()) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    if (channelindex >= getWidth() || channelindex < 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    Receiver[][] fr=getRemoteReceivers();
    if (fr == null || fr[channelindex] == null)     return;
    for (int j=0; j < fr[channelindex].length; j++) {
      try {
        ((DEReceiver)fr[channelindex][j]).put(token,delay);
      }
 catch (      ClassCastException e) {
        throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  finally {
    workspace().doneReading();
  }
}"
76594,"/** 
 * Get a token from the receiver.  The token returned is one that was put in the receiver with a time stamp equal to or earlier than the current time.  If there is no such token, throw an exception.
 * @return A token.
 * @exception NoSuchItemException If there are no more tokens.
 */
public Token get() throws NoTokenException {
  if (_tokens.isEmpty()) {
    throw new NoTokenException(getContainer(),""String_Node_Str"");
  }
  return (Token)_tokens.take();
}","/** 
 * Get a token from the receiver.  The token returned is one that was put in the receiver with a time stamp equal to or earlier than the current time.  If there is no such token, throw an exception.
 * @return A token.
 * @exception NoTokenException If there are no more tokens.
 */
public Token get() throws NoTokenException {
  if (_tokens.isEmpty()) {
    throw new NoTokenException(getContainer(),""String_Node_Str"");
  }
  return (Token)_tokens.take();
}"
76595,"/** 
 * Make a token available to the get() method. Normally, only a director should use this method. It uses it when its current time matches the time stamp of the token.
 * @param token The token to make available.
 */
protected void _triggerEvent(Token token) throws IllegalActionException {
  _tokens.insertFirst(token);
}","/** 
 * Make a token available to the get() method. Normally, only a director should use this method. It uses it when its current time matches the time stamp of the token.
 * @param token The token to make available.
 */
protected void _triggerEvent(Token token){
  _tokens.insertFirst(token);
}"
76596,"/** 
 * Return the container.
 * @return An instance of IOPort.
 */
public Nameable getContainer(){
  return _container;
}","/** 
 * Return the container.
 * @return An instance of IOPort.
 */
public IOPort getContainer(){
  return _container;
}"
76597,"/** 
 * Create receivers for each input port.
 * @exception IllegalActionException If any port throws it.
 */
public void createReceivers() throws IllegalActionException {
  Enumeration inputPorts=inputPorts();
  while (inputPorts.hasMoreElements()) {
    IOPort inport=(IOPort)inputPorts.nextElement();
    inport.createReceivers();
  }
}","/** 
 * Create receivers for each input port.
 * @exception IllegalActionException If any port throws it.
 */
public void createReceivers() throws IllegalActionException {
  Enumeration ports=getPorts();
  while (ports.hasMoreElements()) {
    IOPort oneport=(IOPort)ports.nextElement();
    oneport.createReceivers();
  }
}"
76598,"/** 
 * Create receivers for this port. This method should only be  called on input ports. It should also normally only be called  during the initialize and prefire methods of the director. If this port already has the correct number of receivers, then no new receivers are created. However if new receivers are created,  then any receivers this port previously had will be overwritten. It is <i>not</i> write-synchronized on the workspace, so the caller should be. 
 * @exception IllegalActionException Thrown if this port is not an opaque input port or if there is no director.
 */
public void createReceivers() throws IllegalActionException {
  if (!(isInput() && isOpaque())) {
    String message=""String_Node_Str"";
    message+=""String_Node_Str"";
    throw new IllegalActionException(this,message);
  }
  int portWidth=getWidth();
  if (portWidth <= 0)   return;
  if (_localReceiversTable == null) {
    _localReceiversTable=new Hashtable();
  }
  Enumeration relations=linkedRelations();
  while (relations.hasMoreElements()) {
    IORelation relation=(IORelation)relations.nextElement();
    boolean insideLink=isInsideLinked(relation);
    int width=relation.getWidth();
    Receiver[][] result=null;
    if (_localReceiversTable.containsKey(relation)) {
      result=(Receiver[][])_localReceiversTable.get(relation);
    }
    if ((result == null) || (result.length != width)) {
      result=new Receiver[width][1];
      if (insideLink) {
        for (int i=0; i < width; i++) {
          result[i][0]=_newInsideReceiver();
        }
      }
 else {
        for (int i=0; i < width; i++) {
          result[i][0]=_newReceiver();
        }
      }
      _localReceiversTable.put(relation,result);
    }
  }
}","/** 
 * Create receivers for this port. This method should only be  called on input ports. It should also normally only be called  during the initialize and prefire methods of the director. If this port already has the correct number of receivers, then no new receivers are created. However if new receivers are created,  then any receivers this port previously had will be overwritten. <p> Receivers are created if neccessary for each relation connected  to the port. There are two cases where receivers need to be  created: First whenever a port is an input port, and second  whenever the port is an output, opaque port and the relation connects to it from the inside. If neither of these cases apply to a relation, no receivers are created. It is <i>not</i> write-synchronized on the workspace, so the caller should be. 
 * @exception IllegalActionException Thrown if this port is not an opaque input port or if there is no director.
 */
public void createReceivers() throws IllegalActionException {
  if (!isOpaque()) {
    String message=""String_Node_Str"";
    message+=""String_Node_Str"";
    throw new IllegalActionException(this,message);
  }
  int portWidth=getWidth();
  if (portWidth <= 0)   return;
  if (_localReceiversTable == null) {
    _localReceiversTable=new Hashtable();
  }
  boolean input=isInput();
  boolean output=isOutput();
  Enumeration outsideRelations=linkedRelations();
  Enumeration insideRelations=insideRelations();
  if (input) {
    while (outsideRelations.hasMoreElements()) {
      IORelation relation=(IORelation)outsideRelations.nextElement();
      int width=relation.getWidth();
      Receiver[][] result=null;
      if (_localReceiversTable.containsKey(relation)) {
        result=(Receiver[][])_localReceiversTable.get(relation);
      }
      if ((result == null) || (result.length != width)) {
        result=new Receiver[width][1];
        for (int i=0; i < width; i++) {
          result[i][0]=_newReceiver();
        }
      }
      _localReceiversTable.put(relation,result);
    }
  }
 else   if (output) {
    while (insideRelations.hasMoreElements()) {
      IORelation relation=(IORelation)insideRelations.nextElement();
      int width=relation.getWidth();
      Receiver[][] result=null;
      if (_localReceiversTable.containsKey(relation)) {
        result=(Receiver[][])_localReceiversTable.get(relation);
      }
      if ((result == null) || (result.length != width)) {
        result=new Receiver[width][1];
        for (int i=0; i < width; i++) {
          result[i][0]=_newInsideReceiver();
        }
      }
      _localReceiversTable.put(relation,result);
    }
  }
}"
76599,"/** 
 * If the port is an input, return the receivers that handle incoming channels from the specified relation. If the port is an opaque output and the relation is inside linked, return the receivers that handle incoming channels from the inside. Otherwise return null. The returned value is an array of arrays of the same form as that returned by getReceivers() with no arguments.  Note that a single relation may represent multiple channels because it may be a bus. <p> This method is read-synchronized on the workspace.
 * @param relation A relation that is linked on the outside or inside.
 * @return The local receivers.
 * @exception IllegalActionException If the relation is not linkedfrom the outside, or if there is no director.
 */
public Receiver[][] getReceivers(IORelation relation) throws IllegalActionException {
  try {
    workspace().getReadAccess();
    boolean insidelink=isInsideLinked(relation);
    if (!isLinked(relation) && !insidelink) {
      throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"");
    }
    boolean opaque=isOpaque();
    if (!isInput() && !(opaque && insidelink && isOutput())) {
      return null;
    }
    int width=relation.getWidth();
    if (width <= 0)     return null;
    Receiver[][] result;
    if (opaque) {
      result=(Receiver[][])_localReceiversTable.get(relation);
      if ((result == null) || (result.length != width)) {
        String s=""String_Node_Str"";
        s+=""String_Node_Str"";
        throw new InvalidStateException(this,s);
      }
      return result;
    }
 else {
      Receiver[][] insideRecvrs=getReceivers();
      if (insideRecvrs == null) {
        return null;
      }
      int insideWidth=insideRecvrs.length;
      int index=0;
      result=new Receiver[width][];
      Enumeration outsideRels=linkedRelations();
      while (outsideRels.hasMoreElements()) {
        IORelation r=(IORelation)outsideRels.nextElement();
        if (r == relation) {
          result=new Receiver[width][];
          int rstSize=java.lang.Math.min(width,insideWidth - index);
          for (int i=0; i < rstSize; i++) {
            result[i]=insideRecvrs[index++];
          }
          break;
        }
 else {
          index+=r.getWidth();
          if (index > insideWidth)           break;
        }
      }
      return result;
    }
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * If the port is an input, return the receivers that handle incoming channels from the specified relation. If the port is an opaque output and the relation is inside linked, return the receivers that handle incoming channels from the inside. Otherwise return null. The returned value is an array of arrays of the same form as that returned by getReceivers() with no arguments.  Note that a single relation may represent multiple channels because it may be a bus. <p> This method is read-synchronized on the workspace.
 * @param relation A relation that is linked on the outside or inside.
 * @return The local receivers.
 * @exception IllegalActionException If the relation is not linkedfrom the outside, or if there is no director.
 */
public Receiver[][] getReceivers(IORelation relation) throws IllegalActionException {
  try {
    workspace().getReadAccess();
    boolean insidelink=isInsideLinked(relation);
    if (!isLinked(relation) && !insidelink) {
      throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"");
    }
    boolean opaque=isOpaque();
    if (!isInput() && !(opaque && insidelink && isOutput())) {
      return null;
    }
    int width=relation.getWidth();
    if (width <= 0)     return null;
    Receiver[][] result=null;
    if (opaque) {
      if (_localReceiversTable.containsKey(relation)) {
        result=(Receiver[][])_localReceiversTable.get(relation);
        if (result.length != width) {
          String s=""String_Node_Str"";
          s+=""String_Node_Str"";
          throw new InvalidStateException(this,s);
        }
      }
      return result;
    }
 else {
      Receiver[][] insideRecvrs=getReceivers();
      if (insideRecvrs == null) {
        return null;
      }
      int insideWidth=insideRecvrs.length;
      int index=0;
      result=new Receiver[width][];
      Enumeration outsideRels=linkedRelations();
      while (outsideRels.hasMoreElements()) {
        IORelation r=(IORelation)outsideRels.nextElement();
        if (r == relation) {
          result=new Receiver[width][];
          int rstSize=java.lang.Math.min(width,insideWidth - index);
          for (int i=0; i < rstSize; i++) {
            result[i]=insideRecvrs[index++];
          }
          break;
        }
 else {
          index+=r.getWidth();
          if (index > insideWidth)           break;
        }
      }
      return result;
    }
  }
  finally {
    workspace().doneReading();
  }
}"
76600,"/** 
 * Produce an output event at the current time, and then schedule a firing in the future.
 * @exception CloneNotSupportedException If there is more than onedestination and the output token cannot be cloned.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws CloneNotSupportedException, IllegalActionException {
  DECQDirector dir=(DECQDirector)getDirector();
  output.broadcast(new DoubleToken(_value));
  dir.enqueueEvent(this,_interval,0);
}","/** 
 * Produce an output event at the current time, and then schedule a firing in the future.
 * @exception CloneNotSupportedException If there is more than onedestination and the output token cannot be cloned.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws CloneNotSupportedException, IllegalActionException {
  output.broadcast(new DoubleToken(_value));
  refireAtTime(_interval);
}"
76601,"/** 
 * Produce the initializer event that will cause the generation of the first output at time zero.
 * @exception CloneNotSupportedException If the base class throws it.
 * @exception IllegalActionException If there is no director.
 */
public void initialize() throws CloneNotSupportedException, IllegalActionException {
  super.initialize();
  DECQDirector dir=(DECQDirector)getDirector();
  dir.enqueueEvent(this,0.0,0);
}","/** 
 * Produce the initializer event that will cause the generation of the first output at time zero.
 * @exception CloneNotSupportedException If the base class throws it.
 * @exception IllegalActionException If there is no director.
 */
public void initialize() throws CloneNotSupportedException, IllegalActionException {
  super.initialize();
  refireAtTime(0.0);
}"
76602,"/** 
 * Rescale the plot so that all the data plotted is visible.
 */
public void wrapup(){
  _plot.fillPlot();
}","/** 
 * Rescale the plot so that all the data plotted is visible.
 */
public void wrapup() throws IllegalActionException {
  _plot.fillPlot();
  super.wrapup();
}"
76603,"/** 
 * Add new input data to the plot.
 */
public void fire() throws CloneNotSupportedException, IllegalActionException {
  if (_firstFiring) {
    DECQDirector dir=((DECQDirector)getDirector());
    if (dir == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    _plot.setXRange(dir.getStartTime(),dir.getStopTime());
    _plot.setYRange(getYMin(),getYMax());
    _firstFiring=false;
  }
  int numEmptyChannel=0;
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      double curTime=((DECQDirector)getDirector()).getCurrentTime();
      while (input.hasToken(i)) {
        DoubleToken curToken=null;
        try {
          curToken=(DoubleToken)input.get(i);
        }
 catch (        NoSuchItemException e) {
        }
        double curValue=curToken.doubleValue();
        _plot.addPoint(i,curTime,curValue,false);
      }
    }
 else {
      numEmptyChannel++;
    }
  }
  if (numEmptyChannel == width) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Add new input data to the plot.
 */
public void fire() throws CloneNotSupportedException, IllegalActionException {
  if (_firstFiring) {
    _plot.setXRange(getStartTime(),getStopTime());
    _plot.setYRange(getYMin(),getYMax());
    _firstFiring=false;
  }
  int numEmptyChannel=0;
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      double curTime=((DECQDirector)getDirector()).getCurrentTime();
      while (input.hasToken(i)) {
        DoubleToken curToken=null;
        try {
          curToken=(DoubleToken)input.get(i);
        }
 catch (        NoSuchItemException e) {
        }
        double curValue=curToken.doubleValue();
        _plot.addPoint(i,curTime,curValue,false);
      }
    }
 else {
      numEmptyChannel++;
    }
  }
  if (numEmptyChannel == width) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
76604,"/** 
 * Produce an output event at the current time, and then schedule a firing in the future.
 * @exception CloneNotSupportedException If there is more than onedestination and the output token cannot be cloned.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws CloneNotSupportedException, IllegalActionException {
  DECQDirector dir=(DECQDirector)getDirector();
  output.broadcast(new DoubleToken(_value));
  double exp=-Math.log((1 - Math.random())) * _lambda;
  dir.enqueueEvent(this,exp,0);
}","/** 
 * Produce an output event at the current time, and then schedule a firing in the future.
 * @exception CloneNotSupportedException If there is more than onedestination and the output token cannot be cloned.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws CloneNotSupportedException, IllegalActionException {
  output.broadcast(new DoubleToken(_value));
  double exp=-Math.log((1 - Math.random())) * _lambda;
  refireAtTime(exp);
}"
76605,"/** 
 * Produce the initializer event that will cause the generation of the first event at time zero.
 * @exception CloneNotSupportedException If the base class throws it.
 * @exception IllegalActionException If there is no director.
 */
public void initialize() throws CloneNotSupportedException, IllegalActionException {
  super.initialize();
  DECQDirector dir=(DECQDirector)getDirector();
  dir.enqueueEvent(this,0.0,0);
}","/** 
 * Produce the initializer event that will cause the generation of the first event at time zero.
 * @exception CloneNotSupportedException If the base class throws it.
 * @exception IllegalActionException If there is no director.
 */
public void initialize() throws CloneNotSupportedException, IllegalActionException {
  super.initialize();
  refireAtTime(0.0);
}"
76606,"/** 
 * Create receivers for this port. This method should only be  called on input ports. It should also normally only be called  in the prefire method. It is <i>not</i> synchronized on the workspace, so the caller should be. This is because obaining write access  increases the version number of the workspace, which  invalidates any previous cached information in the workspace.
 * @exception IllegalActionException Thrown if this port is not an opaque input port or if there is no director. FIXME: perhaps we need to use writeAccess?
 */
public void createReceivers() throws IllegalActionException {
  if (!(isInput() && isOpaque())) {
    String message=""String_Node_Str"";
    message+=""String_Node_Str"";
    throw new IllegalActionException(this,message);
  }
  int portWidth=getWidth();
  if (portWidth <= 0)   return;
  boolean changed=false;
  if (_localReceiversTable == null) {
    _localReceiversTable=new Hashtable();
  }
  Enumeration relations=linkedRelations();
  while (relations.hasMoreElements()) {
    IORelation relation=(IORelation)relations.nextElement();
    boolean insideLink=isInsideLinked(relation);
    int width=relation.getWidth();
    Receiver[][] result=(Receiver[][])_localReceiversTable.get(relation);
    if (result.length != width) {
      changed=true;
      if (insideLink) {
        for (int i=0; i < width; i++) {
          result[i][0]=_newInsideReceiver();
        }
      }
 else {
        for (int i=0; i < width; i++) {
          result[i][0]=_newReceiver();
        }
      }
      _localReceiversTable.put(relation,result);
    }
  }
}","/** 
 * Create receivers for this port. This method should only be  called on input ports. It should also normally only be called  in the prefire method. It is <i>not</i> synchronized on the workspace, so the caller should be. This is because obaining write access  increases the version number of the workspace, which  invalidates any previous cached information in the workspace.
 * @exception IllegalActionException Thrown if this port is not an opaque input port or if there is no director. FIXME: perhaps we need to use writeAccess?
 */
public void createReceivers() throws IllegalActionException {
  if (!(isInput() && isOpaque())) {
    String message=""String_Node_Str"";
    message+=""String_Node_Str"";
    throw new IllegalActionException(this,message);
  }
  System.out.println(""String_Node_Str"");
  int portWidth=getWidth();
  if (portWidth <= 0)   return;
  boolean changed=false;
  if (_localReceiversTable == null) {
    _localReceiversTable=new Hashtable();
  }
  Enumeration relations=linkedRelations();
  while (relations.hasMoreElements()) {
    IORelation relation=(IORelation)relations.nextElement();
    boolean insideLink=isInsideLinked(relation);
    int width=relation.getWidth();
    Receiver[][] result=null;
    if (_localReceiversTable.containsKey(relation)) {
      result=(Receiver[][])_localReceiversTable.get(relation);
    }
    if ((result == null) || (result.length != width)) {
      changed=true;
      result=new Receiver[width][1];
      if (insideLink) {
        for (int i=0; i < width; i++) {
          result[i][0]=_newInsideReceiver();
        }
      }
 else {
        for (int i=0; i < width; i++) {
          System.out.println(""String_Node_Str"");
          result[i][0]=_newReceiver();
        }
      }
      _localReceiversTable.put(relation,result);
    }
  }
}"
76607,"/** 
 * Set current time to zero, calculate priorities for simultaneous events, and invoke the initialize() methods of all actors deeply contained by the container.  To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their initialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception CloneNotSupportedException If the initialize() method of thecontainer or one of the deeply contained actors throws it.
 * @exception IllegalActionException If there is a delay-free loop, orif the initialize() method of the container or one of the deeply contained actors throws it.
 */
public void initialize() throws CloneNotSupportedException, IllegalActionException {
  _currentTime=0.0;
  _startTime=Double.MAX_VALUE;
  _constructDirectedGraph();
  if (!_dag.isAcyclic()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  _computeDepth();
  super.initialize();
}","/** 
 * Set current time to zero, calculate priorities for simultaneous events, and invoke the initialize() methods of all actors deeply contained by the container.  To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their initialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception CloneNotSupportedException If the initialize() method of thecontainer or one of the deeply contained actors throws it.
 * @exception IllegalActionException If there is a delay-free loop, orif the initialize() method of the container or one of the deeply contained actors throws it.
 */
public void initialize() throws CloneNotSupportedException, IllegalActionException {
  _currentTime=0.0;
  _startTime=Double.MAX_VALUE;
  _startTimeInitialized=false;
  _constructDirectedGraph();
  if (!_dag.isAcyclic()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  _computeDepth();
  super.initialize();
}"
76608,"/** 
 * Invoke the base class prefire() method, and if it returns true, dequeue the next event from the event queue, advance time to its time stamp, and mark its destination actor for firing. If there are multiple events on the queue with the same time stamp that are destined for the same actor, dequeue all of them, making them available in the input ports of the destination actor. If the time stamp is greater than the stop time, or there are no events on the event queue, then return false, which will have the effect of stopping the simulation.
 * @return True if there is an actor to fire.
 * @exception CloneNotSupportedException If the base class throws it.
 * @exception IllegalActionException If the base class throws it.
 * @exception NameDuplicationException If the base class throws it.
 */
public boolean prefire() throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  _actorToFire=null;
  if (super.prefire()) {
    DEEvent currentEvent=null;
    FIFOQueue fifo=new FIFOQueue();
    while (true) {
      try {
        currentEvent=(DEEvent)_cQueue.take();
      }
 catch (      IllegalAccessException ex) {
        break;
      }
      if (_actorToFire == null) {
        _actorToFire=currentEvent.actor;
        _currentTime=currentEvent.key.timeStamp();
        if (_currentTime < _startTime) {
          if (_startTimeInitialized) {
            throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          _startTime=_currentTime;
          _startTimeInitialized=true;
        }
        if (_currentTime > _stopTime) {
          return false;
        }
        DEReceiver rec=currentEvent.receiver;
        if (rec != null) {
          rec._triggerEvent(currentEvent.token);
        }
      }
 else {
        if (currentEvent.key.timeStamp() != _currentTime) {
          fifo.put(currentEvent);
          break;
        }
 else {
          if (currentEvent.actor == _actorToFire) {
            DEReceiver rec=currentEvent.receiver;
            if (rec != null) {
              rec._triggerEvent(currentEvent.token);
            }
 else {
              throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
            }
          }
 else {
            fifo.put(currentEvent);
          }
        }
      }
    }
    while (fifo.size() > 0) {
      DEEvent event=(DEEvent)fifo.take();
      _cQueue.put(event.key,event);
    }
  }
  return _actorToFire != null;
}","/** 
 * Invoke the base class prefire() method, and if it returns true, dequeue the next event from the event queue, advance time to its time stamp, and mark its destination actor for firing. If there are multiple events on the queue with the same time stamp that are destined for the same actor, dequeue all of them, making them available in the input ports of the destination actor. If the time stamp is greater than the stop time, or there are no events on the event queue, then return false, which will have the effect of stopping the simulation.
 * @return True if there is an actor to fire.
 * @exception CloneNotSupportedException If the base class throws it.
 * @exception IllegalActionException If the base class throws it.
 * @exception NameDuplicationException If the base class throws it.
 */
public boolean prefire() throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  _actorToFire=null;
  if (super.prefire()) {
    DEEvent currentEvent=null;
    FIFOQueue fifo=new FIFOQueue();
    while (true) {
      try {
        currentEvent=(DEEvent)_cQueue.take();
      }
 catch (      IllegalAccessException ex) {
        break;
      }
      if (_actorToFire == null) {
        _actorToFire=currentEvent.actor;
        _currentTime=currentEvent.key.timeStamp();
        if (_currentTime < _startTime) {
          if (_startTimeInitialized) {
            throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          _startTime=_currentTime;
          _startTimeInitialized=true;
        }
        if (_currentTime > _stopTime) {
          return false;
        }
        DEReceiver rec=currentEvent.receiver;
        if (rec != null) {
          rec._triggerEvent(currentEvent.token);
        }
      }
 else {
        if (currentEvent.key.timeStamp() != _currentTime) {
          fifo.put(currentEvent);
          break;
        }
 else {
          if (currentEvent.actor == _actorToFire) {
            DEReceiver rec=currentEvent.receiver;
            if (rec != null) {
              rec._triggerEvent(currentEvent.token);
            }
 else {
              System.out.println(""String_Node_Str"" + ((Entity)currentEvent.actor).description(FULLNAME));
            }
          }
 else {
            fifo.put(currentEvent);
          }
        }
      }
    }
    while (fifo.size() > 0) {
      DEEvent event=(DEEvent)fifo.take();
      _cQueue.put(event.key,event);
    }
  }
  return _actorToFire != null;
}"
76609,"/** 
 * Set current time to zero, calculate priorities for simultaneous events, and invoke the initialize() methods of all actors deeply contained by the container.  To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their initialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception CloneNotSupportedException If the initialize() method of thecontainer or one of the deeply contained actors throws it.
 * @exception IllegalActionException If there is a delay-free loop, orif the initialize() method of the container or one of the deeply contained actors throws it.
 */
public void initialize() throws CloneNotSupportedException, IllegalActionException {
  _currentTime=0.0;
  _startTime=Double.MAX_VALUE;
  _startTimeInitialized=false;
  _constructDirectedGraph();
  if (!_dag.isAcyclic()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  _computeDepth();
  super.initialize();
}","/** 
 * Set current time to zero, calculate priorities for simultaneous events, and invoke the initialize() methods of all actors deeply contained by the container.  To be able to calculate the priorities, it is essential that the graph not have a delay-free loop.  If it does, then this can be corrected by inserting a DEDelay actor with a zero-valued delay.  This has the effect of breaking the loop for the purposes of calculating priorities, without introducing a time delay. <p> This method should be invoked once per execution, before any iteration. Actors may produce output data in their initialize() methods, or more commonly, they may schedule pure events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception CloneNotSupportedException If the initialize() method of thecontainer or one of the deeply contained actors throws it.
 * @exception IllegalActionException If there is a delay-free loop, orif the initialize() method of the container or one of the deeply contained actors throws it.
 */
public void initialize() throws CloneNotSupportedException, IllegalActionException {
  _cQueue=new CalendarQueue(new DECQComparator());
  _dag=new DirectedGraph();
  _currentTime=0.0;
  _startTime=Double.MAX_VALUE;
  _startTimeInitialized=false;
  _constructDirectedGraph();
  if (!_dag.isAcyclic()) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  _computeDepth();
  super.initialize();
}"
76610,"/** 
 * Invoke the base class prefire() method, and if it returns true, dequeue the next event from the event queue, advance time to its time stamp, and mark its destination actor for firing. If there are multiple events on the queue with the same time stamp that are destined for the same actor, dequeue all of them, making them available in the input ports of the destination actor. If the time stamp is greater than the stop time, or there are no events on the event queue, then return false, which will have the effect of stopping the simulation.
 * @return True if there is an actor to fire.
 * @exception CloneNotSupportedException If the base class throws it.
 * @exception IllegalActionException If the base class throws it.
 * @exception NameDuplicationException If the base class throws it.
 */
public boolean prefire() throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  _actorToFire=null;
  if (super.prefire()) {
    DEEvent currentEvent=null;
    FIFOQueue fifo=new FIFOQueue();
    while (true) {
      try {
        currentEvent=(DEEvent)_cQueue.take();
      }
 catch (      IllegalAccessException ex) {
        break;
      }
      if (_actorToFire == null) {
        _actorToFire=currentEvent.actor;
        _currentTime=currentEvent.key.timeStamp();
        if (_currentTime < _startTime)         _startTime=_currentTime;
        if (_currentTime > _stopTime)         return false;
        DEReceiver rec=currentEvent.receiver;
        if (rec != null) {
          rec._triggerEvent(currentEvent.token);
        }
      }
 else {
        if (currentEvent.key.timeStamp() != _currentTime) {
          fifo.put(currentEvent);
          break;
        }
 else {
          if (currentEvent.actor == _actorToFire) {
            DEReceiver rec=currentEvent.receiver;
            if (rec != null) {
              rec._triggerEvent(currentEvent.token);
            }
          }
 else {
            fifo.put(currentEvent);
          }
        }
      }
    }
    while (fifo.size() > 0) {
      DEEvent event=(DEEvent)fifo.take();
      _cQueue.put(event.key,event);
    }
  }
  return _actorToFire != null;
}","/** 
 * Invoke the base class prefire() method, and if it returns true, dequeue the next event from the event queue, advance time to its time stamp, and mark its destination actor for firing. If there are multiple events on the queue with the same time stamp that are destined for the same actor, dequeue all of them, making them available in the input ports of the destination actor. If the time stamp is greater than the stop time, or there are no events on the event queue, then return false, which will have the effect of stopping the simulation.
 * @return True if there is an actor to fire.
 * @exception CloneNotSupportedException If the base class throws it.
 * @exception IllegalActionException If the base class throws it.
 * @exception NameDuplicationException If the base class throws it.
 */
public boolean prefire() throws CloneNotSupportedException, IllegalActionException, NameDuplicationException {
  _actorToFire=null;
  if (super.prefire()) {
    DEEvent currentEvent=null;
    FIFOQueue fifo=new FIFOQueue();
    while (true) {
      try {
        currentEvent=(DEEvent)_cQueue.take();
      }
 catch (      IllegalAccessException ex) {
        break;
      }
      if (_actorToFire == null) {
        _actorToFire=currentEvent.actor;
        _currentTime=currentEvent.key.timeStamp();
        if (_currentTime < _startTime) {
          if (_startTimeInitialized) {
            throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
          _startTime=_currentTime;
          _startTimeInitialized=true;
        }
        if (_currentTime > _stopTime) {
          return false;
        }
        DEReceiver rec=currentEvent.receiver;
        if (rec != null) {
          rec._triggerEvent(currentEvent.token);
        }
      }
 else {
        if (currentEvent.key.timeStamp() != _currentTime) {
          fifo.put(currentEvent);
          break;
        }
 else {
          if (currentEvent.actor == _actorToFire) {
            DEReceiver rec=currentEvent.receiver;
            if (rec != null) {
              rec._triggerEvent(currentEvent.token);
            }
 else {
              throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
            }
          }
 else {
            fifo.put(currentEvent);
          }
        }
      }
    }
    while (fifo.size() > 0) {
      DEEvent event=(DEEvent)fifo.take();
      _cQueue.put(event.key,event);
    }
  }
  return _actorToFire != null;
}"
76611,"private void _computeDepth(){
  Object[] sort=(Object[])_dag.topSort();
  for (int i=sort.length - 1; i >= 0; i--) {
    IOPort p=(IOPort)sort[i];
    Receiver[][] r;
    try {
      r=p.getReceivers();
    }
 catch (    IllegalActionException e) {
      throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (r == null) {
      continue;
    }
    for (int j=r.length - 1; j >= 0; j--) {
      for (int k=r[j].length - 1; k >= 0; k--) {
        DEReceiver der=(DEReceiver)r[j][k];
        der.setDepth(i);
      }
    }
  }
}","private void _computeDepth(){
  Object[] sort=(Object[])_dag.topSort();
  for (int i=sort.length - 1; i >= 0; i--) {
    IOPort p=(IOPort)sort[i];
    System.out.println(p.description(FULLNAME) + ""String_Node_Str"" + i);
    Receiver[][] r;
    try {
      r=p.getReceivers();
    }
 catch (    IllegalActionException e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (r == null) {
      continue;
    }
    for (int j=r.length - 1; j >= 0; j--) {
      for (int k=r[j].length - 1; k >= 0; k--) {
        DEReceiver der=(DEReceiver)r[j][k];
        der.setDepth(i);
      }
    }
  }
}"
76612,"/** 
 * Add new input data to the plot.
 */
public void fire() throws CloneNotSupportedException, IllegalActionException {
  if (_firstFiring) {
    DECQDirector dir=((DECQDirector)getDirector());
    if (dir == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    _plot.setXRange(dir.getStartTime(),dir.getStopTime());
    _plot.setYRange(getYMin(),getYMax());
    _firstFiring=false;
  }
  int numEmptyChannel=0;
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    try {
      DoubleToken curToken=(DoubleToken)input.get(i);
      double curValue=curToken.doubleValue();
      double curTime=((DECQDirector)getDirector()).getCurrentTime();
      _plot.addPoint(i,curTime,curValue,false);
    }
 catch (    NoSuchItemException e) {
      numEmptyChannel++;
    }
  }
  if (numEmptyChannel == width) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Add new input data to the plot.
 */
public void fire() throws CloneNotSupportedException, IllegalActionException {
  if (_firstFiring) {
    DECQDirector dir=((DECQDirector)getDirector());
    if (dir == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    _plot.setXRange(dir.getStartTime(),dir.getStopTime());
    _plot.setYRange(getYMin(),getYMax());
    _firstFiring=false;
  }
  int numEmptyChannel=0;
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      double curTime=((DECQDirector)getDirector()).getCurrentTime();
      while (input.hasToken(i)) {
        DoubleToken curToken=null;
        try {
          curToken=(DoubleToken)input.get(i);
        }
 catch (        NoSuchItemException e) {
        }
        double curValue=curToken.doubleValue();
        _plot.addPoint(i,curTime,curValue,false);
      }
    }
 else {
      numEmptyChannel++;
    }
  }
  if (numEmptyChannel == width) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
76613,"/** 
 * Constructor.
 * @param container The composite actor that this actor belongs too.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public DEWaitingTime(CompositeActor container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new DEIOPort(this,""String_Node_Str"",false,true);
  waiter=new DEIOPort(this,""String_Node_Str"",true,false);
  waitee=new DEIOPort(this,""String_Node_Str"",true,false);
}","/** 
 * Constructor.
 * @param container The composite actor that this actor belongs too.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public DEWaitingTime(CompositeActor container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new DEIOPort(this,""String_Node_Str"",false,true);
  waiter=new DEIOPort(this,""String_Node_Str"",true,false);
  waitee=new DEIOPort(this,""String_Node_Str"",true,false);
  waiter.before(waitee);
  waitee.triggers(output);
}"
76614,"/** 
 * Return an element from the history.  If the offset argument is zero, return the most recent token in the history, which is token most recently taken from the queue. If the offset is 1, return the second most recent token, etc. If there is no such token in the history (the offset is greater than or equal to the number of objects in the history, or is negative), throw an exception.
 * @exception NoSuchItemException The offset is out of range.
 */
public Token previous(int offset) throws NoSuchItemException {
  try {
    return (Token)_queue.previous(offset);
  }
 catch (  NoSuchElementException ex) {
    throw new NoSuchItemException(getContainer(),""String_Node_Str"" + offset + ""String_Node_Str""+ ""String_Node_Str""+ historySize());
  }
}","/** 
 * Return an element from the history.  If the offset argument is zero, return the most recent token in the history, which is the token most recently taken from the queue. If the offset is 1, return the second most recent token, etc. If there is no such token in the history (the offset is greater than or equal to the number of objects in the history, or is negative), throw an exception.
 * @exception NoSuchItemException The offset is out of range.
 */
public Token previous(int offset) throws NoSuchItemException {
  try {
    return (Token)_queue.previous(offset);
  }
 catch (  NoSuchElementException ex) {
    throw new NoSuchItemException(getContainer(),""String_Node_Str"" + offset + ""String_Node_Str""+ ""String_Node_Str""+ historySize());
  }
}"
76615,"/** 
 * Return a token on the queue.  If the offset argument is zero, return the most recent token that was put on the queue. If the offset is 1, return second most recent the token, etc. Do not remove the token from the queue. If there is no such token on the queue (the offset is greater than or equal to the size, or is negative), throw an exception.
 * @param offset The offset from the most recent item on the queue.
 * @exception NoSuchItemException The offset is out of range.
 */
public Token get(int offset) throws NoSuchItemException {
  try {
    return (Token)_queue.get(offset);
  }
 catch (  NoSuchElementException ex) {
    throw new NoSuchItemException(getContainer(),""String_Node_Str"" + offset + ""String_Node_Str""+ _queue.size());
  }
}","/** 
 * Return a token on the queue.  If the offset argument is zero, return the most recent token that was put on the queue. If the offset is 1, return the second most recent token, etc. Do not remove the token from the queue. If there is no such token on the queue (the offset is greater than or equal to the size, or is negative), throw an exception.
 * @param offset The offset from the most recent item on the queue.
 * @exception NoSuchItemException The offset is out of range.
 */
public Token get(int offset) throws NoSuchItemException {
  try {
    return (Token)_queue.get(offset);
  }
 catch (  NoSuchElementException ex) {
    throw new NoSuchItemException(getContainer(),""String_Node_Str"" + offset + ""String_Node_Str""+ _queue.size());
  }
}"
76616,"/** 
 * Solves the set of inequalities and updates the variables. If the set of inequalities is satisfiable, this method returns <code>true</code> and the variables are set to the least or greatest solution depending on the <code>least</code> parameter; if the set of inequalities is definite (see class document), and the set of inequalities is not satisfiable, this method returns <code>false</code>; if the set of inequalities is not definite, a <code>false</code> return value doesn't guarantee the set of inequalities is not satisfiable.  In the case this method returns <code>false</code>, the variable values are random.
 * @param least if <code>true</code>, this method will try tofind the least solution; otherwise, this method will try to find the greatest solution.
 * @return <code>true</code> if the set of inequalities issatisfiable; <code>false</code> if not satisfiable, or the set of inequalities is not definite.
 * @exception InvalidStateException the CPO over which theinequalities are defined is not a lattice.
 */
public boolean solve(boolean least){
  Object init=least ? _cpo.bottom() : _cpo.top();
  if (init == null) {
    throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
  for (Enumeration e=_Clist.keys(); e.hasMoreElements(); ) {
    InequalityTerm variable=(InequalityTerm)e.nextElement();
    try {
      variable.set(init);
    }
 catch (    IllegalActionException ex) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
    }
  }
  LinkedList _NS=new LinkedList();
  for (int i=0; i < _Ilist.size(); i++) {
    Info info=(Info)_Ilist.elementAt(i);
    info._inCvar=least ? info._ineq.greaterTerm().settable() : info._ineq.lesserTerm().settable();
    if (info._inCvar) {
      if (info._ineq.satisfied(_cpo)) {
        info._inserted=false;
      }
 else {
        _NS.insertLast(new Integer(i));
        info._inserted=true;
      }
    }
  }
  while (_NS.size() > 0) {
    int index=((Integer)(_NS.first())).intValue();
    _NS.removeFirst();
    Info info=(Info)(_Ilist.elementAt(index));
    info._inserted=false;
    Object value=null;
    InequalityTerm updateTerm=null;
    if (least) {
      updateTerm=info._ineq.greaterTerm();
      value=_cpo.lub(info._ineq.lesserTerm().value(),updateTerm.value());
    }
 else {
      updateTerm=info._ineq.lesserTerm();
      value=_cpo.glb(updateTerm.value(),info._ineq.greaterTerm().value());
    }
    if (value == null) {
      throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
    try {
      updateTerm.set(value);
    }
 catch (    IllegalActionException ex) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
    }
    Vector affected=(Vector)_Clist.get(updateTerm);
    for (int i=0; i < affected.size(); i++) {
      Integer index1Wrap=(Integer)(affected.elementAt(i));
      int index1=index1Wrap.intValue();
      Info affectedInfo=(Info)_Ilist.elementAt(index1);
      if (index1 != index && affectedInfo._inCvar) {
        if (info._ineq.satisfied(_cpo)) {
          if (info._inserted) {
            _NS.removeOneOf(index1Wrap);
          }
        }
 else {
          if (!info._inserted) {
            _NS.insertFirst(index1Wrap);
          }
        }
      }
    }
  }
  for (int i=0; i < _Ilist.size(); i++) {
    Info info=(Info)_Ilist.elementAt(i);
    if (!info._inCvar) {
      if (!info._ineq.satisfied(_cpo)) {
        return false;
      }
    }
  }
  return true;
}","/** 
 * Solves the set of inequalities and updates the variables. If the set of inequalities is satisfiable, this method returns <code>true</code> and the variables are set to the least or greatest solution depending on the <code>least</code> parameter; if the set of inequalities is definite (see class document), and the set of inequalities is not satisfiable, this method returns <code>false</code>; if the set of inequalities is not definite, a <code>false</code> return value doesn't guarantee the set of inequalities is not satisfiable.  In the case this method returns <code>false</code>, the variable values are random.
 * @param least if <code>true</code>, this method will try tofind the least solution; otherwise, this method will try to find the greatest solution.
 * @return <code>true</code> if the set of inequalities issatisfiable; <code>false</code> if not satisfiable, or the set of inequalities is not definite.
 * @exception InvalidStateException the CPO over which theinequalities are defined is not a lattice.
 */
public boolean solve(boolean least){
  Object init=least ? _cpo.bottom() : _cpo.top();
  if (init == null) {
    throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
  for (Enumeration e=_Clist.keys(); e.hasMoreElements(); ) {
    InequalityTerm variable=(InequalityTerm)e.nextElement();
    try {
      variable.set(init);
    }
 catch (    IllegalActionException ex) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
    }
  }
  LinkedList _NS=new LinkedList();
  for (int i=0; i < _Ilist.size(); i++) {
    Info info=(Info)_Ilist.elementAt(i);
    info._inCvar=least ? info._ineq.greaterTerm().settable() : info._ineq.lesserTerm().settable();
    if (info._inCvar) {
      if (info._ineq.satisfied(_cpo)) {
        info._inserted=false;
      }
 else {
        _NS.insertLast(new Integer(i));
        info._inserted=true;
      }
    }
  }
  while (_NS.size() > 0) {
    int index=((Integer)(_NS.first())).intValue();
    _NS.removeFirst();
    Info info=(Info)(_Ilist.elementAt(index));
    info._inserted=false;
    Object value=null;
    InequalityTerm updateTerm=null;
    if (least) {
      updateTerm=info._ineq.greaterTerm();
      value=_cpo.lub(info._ineq.lesserTerm().value(),updateTerm.value());
    }
 else {
      updateTerm=info._ineq.lesserTerm();
      value=_cpo.glb(updateTerm.value(),info._ineq.greaterTerm().value());
    }
    if (value == null) {
      throw new InvalidStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
    try {
      updateTerm.set(value);
    }
 catch (    IllegalActionException ex) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
    }
    Vector affected=(Vector)_Clist.get(updateTerm);
    for (int i=0; i < affected.size(); i++) {
      Integer index1Wrap=(Integer)(affected.elementAt(i));
      int index1=index1Wrap.intValue();
      Info affectedInfo=(Info)_Ilist.elementAt(index1);
      if (index1 != index && affectedInfo._inCvar) {
        if (affectedInfo._ineq.satisfied(_cpo)) {
          if (affectedInfo._inserted) {
            _NS.removeOneOf(index1Wrap);
          }
        }
 else {
          if (!affectedInfo._inserted) {
            _NS.insertFirst(index1Wrap);
          }
        }
      }
    }
  }
  for (int i=0; i < _Ilist.size(); i++) {
    Info info=(Info)_Ilist.elementAt(i);
    if (!info._inCvar) {
      if (!info._ineq.satisfied(_cpo)) {
        return false;
      }
    }
  }
  return true;
}"
76617,"/** 
 * Constructs an Exception with a detail message that includes the names of the first two arguments plus the third argument string.
 * @param obj1 The first object.
 * @param obj2 The second object.
 * @param detail The message.
 */
public InvalidStateException(Nameable obj1,Nameable obj2,String detail){
  String obj1string=_getFullName(obj1);
  String obj2string=_getFullName(obj2);
  String prefix;
  if (obj1string != ""String_Node_Str"") {
    if (obj2string != ""String_Node_Str"") {
      prefix=new String(obj1string + ""String_Node_Str"" + obj2string);
    }
 else {
      prefix=obj1string;
    }
  }
 else {
    prefix=obj2string;
  }
  _setMessage(prefix);
  if (detail != null) {
    if (!detail.equals(""String_Node_Str"")) {
      if (!prefix.equals(""String_Node_Str"")) {
        _setMessage(new String(prefix + ""String_Node_Str"" + detail));
      }
 else {
        _setMessage(detail);
      }
    }
  }
}","/** 
 * Constructs an Exception with a detail message that includes the names of the first two arguments plus the third argument string.
 * @param obj1 The first object.
 * @param obj2 The second object.
 * @param detail The message.
 */
public InvalidStateException(Nameable obj1,Nameable obj2,String detail){
  String obj1string=_getFullName(obj1);
  String obj2string=_getFullName(obj2);
  String prefix;
  if (!obj1string.equals(""String_Node_Str"")) {
    if (!obj2string.equals(""String_Node_Str"")) {
      prefix=new String(obj1string + ""String_Node_Str"" + obj2string);
    }
 else {
      prefix=obj1string;
    }
  }
 else {
    prefix=obj2string;
  }
  _setMessage(prefix);
  if (detail != null) {
    if (!detail.equals(""String_Node_Str"")) {
      if (!prefix.equals(""String_Node_Str"")) {
        _setMessage(new String(prefix + ""String_Node_Str"" + detail));
      }
 else {
        _setMessage(detail);
      }
    }
  }
}"
76618,"public void incr(){
  _count++;
}","private void incr(){
  _count++;
}"
76619,"/** 
 * Indicate that the calling thread is finished writing. This wakes up any threads that are suspended on access to this workspace so that they may contend for permissions. It also increments the version number of the workspace.
 */
public synchronized void doneWriting(){
  _writeReq--;
  _writer=null;
  incrVersion();
  notifyAll();
}","/** 
 * Indicate that the calling thread is finished writing. This wakes up any threads that are suspended on access to this workspace so that they may contend for permissions. It also increments the version number of the workspace.
 */
public synchronized void doneWriting(){
  _writeReq--;
  _writeDepth--;
  if (_writeDepth == 0) {
    _writer=null;
    incrVersion();
    notifyAll();
  }
 else   if (_writeDepth < 0) {
    throw new InvalidStateException(this,""String_Node_Str"");
  }
}"
76620,"public boolean zero(){
  return _count <= 0;
}","private boolean zero(){
  return _count <= 0;
}"
76621,"/** 
 * Obtain permission to write to objects in the workspace. Permission is granted if there are no other threads that currently have read or write permission.  In particular, it <i>is</i> granted if this thread already has write permission, or if it is the only thread with read permission. This method suspends the calling thread until such permission has been obtained.  It is essential that doneWriting() be called after this, or read or write permission may never again be granted in this workspace.
 */
public synchronized void write(){
  _writeReq++;
  while (true) {
    Thread current=Thread.currentThread();
    if (current == _writer) {
      return;
    }
    if (_writer == null) {
      if (_readers.isEmpty()) {
        _writer=Thread.currentThread();
        return;
      }
      if (_readers.size() == 1 && _readers.get(current) != null) {
        _writer=Thread.currentThread();
        return;
      }
    }
    try {
      wait();
    }
 catch (    InterruptedException ex) {
    }
  }
}","/** 
 * Obtain permission to write to objects in the workspace. Permission is granted if there are no other threads that currently have read or write permission.  In particular, it <i>is</i> granted if this thread already has write permission, or if it is the only thread with read permission. This method suspends the calling thread until such permission has been obtained.  It is essential that doneWriting() be called after this, or read or write permission may never again be granted in this workspace.
 */
public synchronized void write(){
  _writeReq++;
  while (true) {
    Thread current=Thread.currentThread();
    if (current == _writer) {
      _writeDepth++;
      return;
    }
    if (_writer == null) {
      if (_readers.isEmpty()) {
        _writer=Thread.currentThread();
        _writeDepth=1;
        return;
      }
      if (_readers.size() == 1 && _readers.get(current) != null) {
        _writer=Thread.currentThread();
        _writeDepth=1;
        return;
      }
    }
    try {
      wait();
    }
 catch (    InterruptedException ex) {
    }
  }
}"
76622,"public ReadCount(){
}","private ReadCount(){
}"
76623,"public void decr(){
  _count--;
}","private void decr(){
  _count--;
}"
76624,"public void wrapup(){
  _terminateAll();
  return;
}","/** 
 * This terminates all the actors in the corresponding CompositeActor
 */
public void wrapup(){
  _terminateAll();
  return;
}"
76625,"public void startNewActors(){
synchronized (workspace()) {
    workspace().notifyAll();
    return;
  }
}","/** 
 * This should go. Currently this notifies the director to process new actors
 */
public void startNewActors(){
synchronized (workspace()) {
    workspace().notifyAll();
    return;
  }
}"
76626,"/** 
 * Decreases the number of queues blocked on a read
 */
public void readUnblock(Receptionist recep){
synchronized (workspace()) {
    _readBlockCount--;
    _readblockedQs.removeOneOf(recep);
    return;
  }
}","/** 
 * Decreases the number of queues blocked on a read
 * @param recep is the receptionist/queue being unblocked on a read
 */
public void readUnblock(Receptionist recep){
synchronized (workspace()) {
    _readBlockCount--;
    _readblockedQs.removeOneOf(recep);
    return;
  }
}"
76627,"public void postfire(){
  return;
}","/** 
 * Does nothing for PN 
 */
public void postfire(){
  return;
}"
76628,"/** 
 * Increments the no of queues blocked on read. Also checks for deadlocks 
 */
public void readBlock(Receptionist recep){
synchronized (workspace()) {
    _readBlockCount++;
    _readblockedQs.insertFirst(recep);
    _checkForDeadlock(0);
    return;
  }
}","/** 
 * Increments the no of queues blocked on read. Also checks for deadlocks 
 * @param recep is the receptionist/queue that is blocking on a read
 */
public void readBlock(Receptionist recep){
synchronized (workspace()) {
    _readBlockCount++;
    _readblockedQs.insertFirst(recep);
    _checkForDeadlock(0);
    return;
  }
}"
76629,"public ThreadGroup getProcessGroup(){
  return _processGroup;
}","/** 
 * returns the threadGroup in which all the threads corresponding to  PN actors are started.
 */
public ThreadGroup getProcessGroup(){
  return _processGroup;
}"
76630,"/** 
 * Increments the capacity, if it can be incremented. Else increments the number of stars blocked while writing and checks for deadlocks.
 * @param latest input port that blocked the corresponding output staron a write.
 */
public void writeBlock(Receptionist recep) throws IllegalActionException {
synchronized (workspace()) {
    _writeBlockCount++;
    _writeblockedQs.insertFirst(recep);
    _checkForDeadlock(0);
    return;
  }
}","/** 
 * Increments the capacity, if it can be incremented. Else increments the number of stars blocked while writing and checks for deadlocks.
 * @param latest input port that blocked the corresponding output staron a write.
 */
public void writeBlock(Receptionist recep){
synchronized (workspace()) {
    _writeBlockCount++;
    _writeblockedQs.insertFirst(recep);
    _checkForDeadlock(0);
    return;
  }
}"
76631,"/** 
 * If the stars can be blocked on a write, then unblock it and  decrement the number of stars blocked on write.
 */
public void writeUnblock(Receptionist recep){
synchronized (workspace()) {
    _writeBlockCount--;
    _writeblockedQs.removeOneOf(recep);
    return;
  }
}","/** 
 * If the stars can be blocked on a write, then unblock it and  decrement the number of stars blocked on write.
 * @param recep is the receptionist/queue being unblocked
 */
public void writeUnblock(Receptionist recep){
synchronized (workspace()) {
    _writeBlockCount--;
    _writeblockedQs.removeOneOf(recep);
    return;
  }
}"
76632,"/** 
 * Creates a thread for each PN star and handles deadlocks and terminates
 * @exception IllegalActionException is thrown by submethods 
 */
public boolean prefire(){
synchronized (workspace()) {
    if (_debug > 5)     System.out.println(""String_Node_Str"");
    Enumeration allMyStars=getNewActors();
    clearNewActors();
    while (allMyStars.hasMoreElements()) {
      PNActor star=(PNActor)allMyStars.nextElement();
      Thread temp=new Thread(_processGroup,star);
      star.setThread(temp);
      star.initialize();
      temp.start();
    }
    _mutate=false;
    if (_debug > 5)     System.out.println(""String_Node_Str"");
    return true;
  }
}","/** 
 * Creates a thread for each new PN actor, initializes the actors and starts the threads corresponding to each new actor.
 * @returns true
 */
public boolean prefire(){
synchronized (workspace()) {
    if (_debug > 5)     System.out.println(""String_Node_Str"");
    Enumeration allMyStars=getNewActors();
    clearNewActors();
    while (allMyStars.hasMoreElements()) {
      PNActor star=(PNActor)allMyStars.nextElement();
      Thread temp=new Thread(_processGroup,star);
      star.setThread(temp);
      star.initialize();
      temp.start();
    }
    _mutate=false;
    if (_debug > 5)     System.out.println(""String_Node_Str"");
    return true;
  }
}"
76633,"public void fire() throws IllegalActionException {
  setComplete(_handleDeadlock());
  if (_debug > 5)   System.out.println(""String_Node_Str"");
  return;
}","/** 
 * This handles deadlocks in the PN systems and sets the complete flag to true or false depending on whether it detected a real deadlock or a mutation respectively
 * @exception IllegalActionException should not be thrown.
 */
public void fire() throws IllegalActionException {
  setComplete(_handleDeadlock());
  if (_debug > 5)   System.out.println(""String_Node_Str"");
  return;
}"
76634,"/** 
 * This is obsolete. Should go. Please donot use it anymore. 
 */
public void setMutate(boolean mutate){
synchronized (workspace()) {
    _mutate=mutate;
    workspace().notifyAll();
  }
}","/** 
 * This is obsolete. Should go. Please donot use it anymore. 
 * @param mutate true to indicate mutation
 */
public void setMutate(boolean mutate){
synchronized (workspace()) {
    _mutate=mutate;
    workspace().notifyAll();
  }
}"
76635,"/** 
 * Return a description of the object specified by verbosity. If versobity = RECEIVERS(7), then returns a String containing the receivers of this port. The returned String has the same  format as the Receivers array, ie. each row corresponding to  a channel, and all the elements in a row are receiving the  clone of the same token. Each element in the receivers array  has the form: container's_full_name.receiver_type,  e.g. e0.p0.Mailbox. Every null element in the array is  is a string ""null"" in the returned String.  If versobity = REMOTE_RECEIVERS(7), then returns a String  containing the remote receivers of this port. The returned String has the same  format as the remoteReceivers array, ie. each row corresponding to  a channel, and all the elements in a row are the destination  receiving the  clone of the same token. Each element in the receivers array  has the form: container's_full_name.receiver_type,  e.g. e0.p0.Mailbox.  FIXME: The information of getReceivers(IORelation) and  getRemoteReceivers(IORelation) is not included.
 * @param verbosity The level of verbosity.
 */
public String description(int verbosity){
  String results=new String();
  Receiver[][] recvrs;
switch (verbosity) {
case RECEIVERS:
    recvrs=getReceivers();
  break;
case REMOTE_RECEIVERS:
recvrs=getRemoteReceivers();
break;
default :
return super.description(verbosity);
}
if (recvrs == null) {
return ""String_Node_Str"";
}
for (int i=0; i < recvrs.length; i++) {
if (recvrs[i] == null) {
results+=""String_Node_Str"";
}
 else {
for (int j=0; j < recvrs[i].length; j++) {
results=results.concat((recvrs[i][j].getContainer()).getFullName() + ""String_Node_Str"" + (recvrs[i][j].getClass()).getName()+ ""String_Node_Str"");
}
}
results+=""String_Node_Str"";
}
return results;
}","/** 
 * Return a description of the object specified by verbosity. If verbosity = RECEIVERS(7), then returns a String containing the receivers of this port. The returned String has the same  format as the Receivers array, ie. each row corresponding to  a channel, and all the elements in a row are receiving the  clone of the same token. Each element in the receivers array  has the form: container's_full_name.receiver_type,  e.g. e0.p0.pt.actors.Mailbox. Every null element in the array is  is a string ""null"" in the returned String.  If verbosity = REMOTE_RECEIVERS(8), then returns a String  containing the remote receivers of this port. The returned String has the same  format as the remoteReceivers array, ie. each row corresponding to  a channel, and all the elements in a row are the destination  receiving the  clone of the same token. Each element in the receivers array  has the form: container's_full_name.receiver_type,  e.g. e0.p0.pt.acotrs.Mailbox.  NOTE: The information of getReceivers(IORelation) and  getRemoteReceivers(IORelation) is not included.
 * @param verbosity The level of verbosity.
 */
public String description(int verbosity){
  String results=new String();
  Receiver[][] recvrs;
switch (verbosity) {
case RECEIVERS:
    recvrs=getReceivers();
  break;
case REMOTE_RECEIVERS:
recvrs=getRemoteReceivers();
break;
default :
return super.description(verbosity);
}
if (recvrs == null) {
return ""String_Node_Str"";
}
for (int i=0; i < recvrs.length; i++) {
if (recvrs[i] == null) {
results+=""String_Node_Str"";
}
 else {
for (int j=0; j < recvrs[i].length; j++) {
results=results.concat((recvrs[i][j].getContainer()).getFullName() + ""String_Node_Str"" + (recvrs[i][j].getClass()).getName()+ ""String_Node_Str"");
}
}
results+=""String_Node_Str"";
}
return results;
}"
76636,"/** 
 * Override parent method to ensure validity of the width of the port. If the given relation is already linked to this port or the argument is null, do nothing. Otherwise, create a new link or throw an exception if the link is invalid.  If this port is not a multiport, then the width of the relation is required to be specified at exactly one. To prohibit links across levels of the hierarchy, use link(). This method is synchronized on the workspace and increments its version.
 * @exception IllegalActionException If the port already linked to arelation and is not a multiport; or if the relation has width not exactly one and the port is not a multiport; or if the  relation is incompatible with this port; or if the port has no container; or the port is not in the same workspace as the relation.
 */
public void liberalLink(Relation relation) throws IllegalActionException {
synchronized (workspace()) {
    _checkRelation(relation);
    IORelation rel=(IORelation)relation;
    if (!isLinked(rel)) {
      boolean insidelink=_outside(relation.getContainer());
      if (!isMultiport()) {
        if ((insidelink && numInsideLinks() >= 1) || (!insidelink && numLinks() >= 1)) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if ((rel.getWidth() != 1) || !rel.widthFixed()) {
        if (!isMultiport()) {
          throw new IllegalActionException(this,rel,""String_Node_Str"");
        }
        if (insidelink) {
          try {
            _getInsideWidth(null);
          }
 catch (          InvalidStateException ex) {
            throw new IllegalActionException(this,rel,""String_Node_Str"" + ""String_Node_Str"");
          }
        }
      }
      super.liberalLink(rel);
    }
  }
}","/** 
 * Override parent method to ensure validity of the width of the port. If the given relation is already linked to this port from the  inside or the outside, or the argument is null, do nothing. Otherwise, create a new link or throw an exception if the link is invalid.  If this port is not a multiport, then the width of the relation is required to be specified at exactly one. To prohibit links across levels of the hierarchy, use link(). This method is synchronized on the workspace and increments its version.
 * @exception IllegalActionException If the port already linked to arelation and is not a multiport; or if the relation has width not exactly one and the port is not a multiport; or if the  relation is incompatible with this port; or if the port has no container; or the port is not in the same workspace as the relation.
 */
public void liberalLink(Relation relation) throws IllegalActionException {
synchronized (workspace()) {
    _checkRelation(relation);
    IORelation rel=(IORelation)relation;
    if (!isLinked(rel) && !isInsideLinked(rel)) {
      boolean insidelink=_outside(relation.getContainer());
      if (!isMultiport()) {
        if ((insidelink && numInsideLinks() >= 1) || (!insidelink && numLinks() >= 1)) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if ((rel.getWidth() != 1) || !rel.widthFixed()) {
        if (!isMultiport()) {
          throw new IllegalActionException(this,rel,""String_Node_Str"");
        }
        if (insidelink) {
          try {
            _getInsideWidth(null);
          }
 catch (          InvalidStateException ex) {
            throw new IllegalActionException(this,rel,""String_Node_Str"" + ""String_Node_Str"");
          }
        }
 else {
          Enumeration relations=linkedRelations();
          while (relations.hasMoreElements()) {
            IORelation r=(IORelation)relations.nextElement();
            if (!r.widthFixed()) {
              throw new IllegalActionException(this,rel,""String_Node_Str"" + ""String_Node_Str"");
            }
          }
        }
      }
      super.liberalLink(rel);
    }
  }
}"
76637,"/** 
 * Add the value of the argument Token to this Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion. FIXME: what do do about long in the next six methods?
 * @param a The token to add to this Token
 * @exception Thrown if the passed token is not of a type that can be added to this Tokens value in a lossless fashion.
 */
public Token add(pt.data.Token a) throws IllegalActionException {
  if (a instanceof StringToken) {
    String result=toString() + a.toString();
    return new StringToken(result);
  }
 else   if (a instanceof ScalarToken) {
    _value=_value + ((ScalarToken)a).doubleValue();
    return new DoubleToken(_value);
  }
 else {
    String str=""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str"";
    str=str + a.getClass().getName();
    throw new IllegalActionException(""String_Node_Str"" + str);
  }
}","/** 
 * Add the value of the argument Token to this Token. Type resolution also occurs here, with the returned Token type chosen to achieve a lossless conversion. FIXME: what do do about long in the next six methods?
 * @param a The token to add to this Token
 * @exception Thrown if the passed token is not of a type that can be added to this Tokens value in a lossless fashion.
 */
public Token add(pt.data.Token a) throws IllegalActionException {
  if (a instanceof StringToken) {
    String result=toString() + a.toString();
    return new StringToken(result);
  }
 else   if (a instanceof ScalarToken) {
    double tmp=_value + ((ScalarToken)a).doubleValue();
    return new DoubleToken(tmp);
  }
 else {
    String str=""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str"";
    str=str + a.getClass().getName();
    throw new IllegalActionException(""String_Node_Str"" + str);
  }
}"
76638,"/** 
 * Subtract the value of the argument Token from this Token. Type  resolution also occurs here, with the returned Token type chosen to  achieve a lossless conversion. 
 * @param a The token to subtract to this Token
 * @exception Thrown if the passed token is not of a type that can be subtracted from this Tokens value in a lossless fashion.
 */
public Token subtract(Token a) throws IllegalActionException {
  if (a instanceof ScalarToken) {
    _value=_value - ((ScalarToken)a).doubleValue();
    return new DoubleToken(_value);
  }
 else {
    String str=""String_Node_Str"" + this.getClass().getName();
    str=str + ""String_Node_Str"" + a.getClass().getName();
    throw new IllegalActionException(""String_Node_Str"" + str);
  }
}","/** 
 * Subtract the value of the argument Token from this Token. Type  resolution also occurs here, with the returned Token type chosen to  achieve a lossless conversion. 
 * @param a The token to subtract to this Token
 * @exception Thrown if the passed token is not of a type that can be subtracted from this Tokens value in a lossless fashion.
 */
public Token subtract(Token a) throws IllegalActionException {
  if (a instanceof ScalarToken) {
    double tmp=_value - ((ScalarToken)a).doubleValue();
    return new DoubleToken(tmp);
  }
 else {
    String str=""String_Node_Str"" + this.getClass().getName();
    str=str + ""String_Node_Str"" + a.getClass().getName();
    throw new IllegalActionException(""String_Node_Str"" + str);
  }
}"
76639,"/** 
 * Set the value of the token to be the specified value.
 */
public void setValue(double value){
  _value=value;
}","/** 
 * Set the value in the token 
 * @param d The new value for the token
 */
public void setValue(double d){
  _value=d;
}"
76640,"/** 
 * Divide the value of this Token with the value of the argument Token. Type resolution also occurs here, with the returned Token type  chosen to achieve a lossless conversion. 
 * @param a The token to divide this Token by
 * @exception Thrown if the passed token is not of a type that can be divide this Tokens value by in a lossless fashion.
 */
public Token divide(Token a) throws IllegalActionException {
  if (a instanceof ScalarToken) {
    _value=_value / ((ScalarToken)a).doubleValue();
    return new DoubleToken(_value);
  }
 else {
    String str=""String_Node_Str"" + this.getClass().getName();
    str=str + ""String_Node_Str"" + a.getClass().getName();
    throw new IllegalActionException(""String_Node_Str"" + str);
  }
}","/** 
 * Divide the value of this Token with the value of the argument Token. Type resolution also occurs here, with the returned Token type  chosen to achieve a lossless conversion. 
 * @param a The token to divide this Token by
 * @exception Thrown if the passed token is not of a type that can be divide this Tokens value by in a lossless fashion.
 */
public Token divide(Token a) throws IllegalActionException {
  if (a instanceof ScalarToken) {
    double tmp=_value / ((ScalarToken)a).doubleValue();
    return new DoubleToken(tmp);
  }
 else {
    String str=""String_Node_Str"" + this.getClass().getName();
    str=str + ""String_Node_Str"" + a.getClass().getName();
    throw new IllegalActionException(""String_Node_Str"" + str);
  }
}"
76641,"/** 
 * Set the value in the token 
 * @param d The new value for the token public void setValue(double d) { _value = d; } /** Create a string representation of the value in the token.
 */
public String toString(){
  return Double.toString(_value);
}","/** 
 * Create a string representation of the value in the token.
 */
public String toString(){
  return Double.toString(_value);
}"
76642,"/** 
 * Multiply the value of this Token with the value of the argument Token. Type resolution also occurs here, with the returned Token type  chosen to achieve a lossless conversion. 
 * @param a The token to multiply this Token by
 * @exception Thrown if the passed token is not of a type that can be multiplied by this Tokens value in a lossless fashion.
 */
public Token multiply(Token a) throws IllegalActionException {
  if (a instanceof ScalarToken) {
    _value=_value * ((ScalarToken)a).doubleValue();
    return new DoubleToken(_value);
  }
 else {
    String str=""String_Node_Str"" + this.getClass().getName();
    str=str + ""String_Node_Str"" + a.getClass().getName();
    throw new IllegalActionException(""String_Node_Str"" + str);
  }
}","/** 
 * Multiply the value of this Token with the value of the argument Token. Type resolution also occurs here, with the returned Token type  chosen to achieve a lossless conversion. 
 * @param a The token to multiply this Token by
 * @exception Thrown if the passed token is not of a type that can be multiplied by this Tokens value in a lossless fashion.
 */
public Token multiply(Token a) throws IllegalActionException {
  if (a instanceof ScalarToken) {
    double tmp=_value * ((ScalarToken)a).doubleValue();
    return new DoubleToken(tmp);
  }
 else {
    String str=""String_Node_Str"" + this.getClass().getName();
    str=str + ""String_Node_Str"" + a.getClass().getName();
    throw new IllegalActionException(""String_Node_Str"" + str);
  }
}"
76643,"/** 
 * Divide the value of this Token with the value of the argument Token. Type resolution also occurs here, with the returned Token type  chosen to achieve a lossless conversion. 
 * @param a The token to divide this Token by
 * @exception Thrown if the passed token is not of a type that can be divide this Tokens value by in a lossless fashion.
 */
public Token modulo(Token a) throws IllegalActionException {
  if (a instanceof ScalarToken) {
    _value=_value % ((ScalarToken)a).doubleValue();
    return new DoubleToken(_value);
  }
 else {
    String str=""String_Node_Str"" + this.getClass().getName();
    str=str + ""String_Node_Str"" + a.getClass().getName();
    throw new IllegalActionException(""String_Node_Str"" + str);
  }
}","/** 
 * Divide the value of this Token with the value of the argument Token. Type resolution also occurs here, with the returned Token type  chosen to achieve a lossless conversion. 
 * @param a The token to divide this Token by
 * @exception Thrown if the passed token is not of a type that can be divide this Tokens value by in a lossless fashion.
 */
public Token modulo(Token a) throws IllegalActionException {
  if (a instanceof ScalarToken) {
    double tmp=_value % ((ScalarToken)a).doubleValue();
    return new DoubleToken(tmp);
  }
 else {
    String str=""String_Node_Str"" + this.getClass().getName();
    str=str + ""String_Node_Str"" + a.getClass().getName();
    throw new IllegalActionException(""String_Node_Str"" + str);
  }
}"
76644,"/** 
 * Add a Param. this causes the version number of the workspace to be incremented.
 * @param The param to be added
 */
public void addParam(Param p) throws NameDuplicationException, IllegalActionException {
  if (((NamedObj)p.getContainer()) != this) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  try {
    _params.append(p);
  }
 catch (  IllegalActionException ex) {
  }
  workspace().incrVersion();
}","/** 
 * Add a Param. this causes the version number of the workspace to be incremented.
 * @param The param to be added
 */
public void addParam(Param p) throws NameDuplicationException, IllegalActionException {
  if (((NamedObj)p.getContainer()) != this) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  try {
    if (_params == null) {
      _params=new NamedList();
    }
    _params.append(p);
  }
 catch (  IllegalActionException ex) {
  }
  workspace().incrVersion();
}"
76645,"/** 
 * Parse a line that gives plotting information. Return true if the line is recognized.  Lines with syntax errors are ignored.
 */
protected boolean _parseLine(String line){
  boolean connected=false;
  if (_debug > 8)   System.out.println(""String_Node_Str"" + line);
  if (_connected)   connected=true;
  if (super._parseLine(line)) {
    _pxgraphBlankLineMode=false;
    return true;
  }
 else {
    String lcLine=new String(line.toLowerCase());
    if (lcLine.startsWith(""String_Node_Str"")) {
      String style=(line.substring(6)).trim();
      setMarksStyle(style);
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      String num=(line.substring(8)).trim();
      try {
        setNumSets(Integer.parseInt(num));
      }
 catch (      NumberFormatException e) {
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"") || (_pxgraphBlankLineMode && lcLine.length() == 0)) {
      _firstinset=true;
      _sawfirstdataset=true;
      if (!_datasetoverflow)       _currentdataset++;
      if (_currentdataset >= _numsets || _datasetoverflow) {
        _datasetoverflow=true;
        _currentdataset=-1;
      }
      if (lcLine.length() > 0) {
        String legend=(line.substring(8)).trim();
        addLegend(_currentdataset,legend);
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",6) >= 0) {
        setConnected(false);
      }
 else {
        setConnected(true);
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",9) >= 0) {
        setImpulses(false);
      }
 else {
        setImpulses(true);
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",5) >= 0) {
        setBars(false);
      }
 else {
        setBars(true);
        if (!_yRangeGiven) {
          _yBottom=0;
        }
        int comma=line.indexOf(""String_Node_Str"",5);
        String barwidth;
        String baroffset=null;
        if (comma > 0) {
          barwidth=(line.substring(5,comma)).trim();
          baroffset=(line.substring(comma + 1)).trim();
        }
 else {
          barwidth=(line.substring(5)).trim();
        }
        try {
          Double bwidth=new Double(barwidth);
          double boffset=_baroffset;
          if (baroffset != null) {
            boffset=(new Double(baroffset)).doubleValue();
          }
          setBars(bwidth.doubleValue(),boffset);
        }
 catch (        NumberFormatException e) {
        }
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      connected=false;
      line=line.substring(5,line.length()).trim();
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      connected=false;
      line=line.substring(4,line.length()).trim();
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=line.substring(5,line.length()).trim();
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=line.substring(4,line.length()).trim();
    }
    line=line.trim();
    int fieldsplit=line.indexOf(""String_Node_Str"");
    if (fieldsplit == -1) {
      fieldsplit=line.indexOf(""String_Node_Str"");
    }
    if (fieldsplit == -1) {
      fieldsplit=line.indexOf(""String_Node_Str"");
    }
    if (fieldsplit > 0) {
      String x=(line.substring(0,fieldsplit)).trim();
      String y=(line.substring(fieldsplit + 1)).trim();
      int fieldsplit2=y.indexOf(""String_Node_Str"");
      if (fieldsplit2 == -1) {
        fieldsplit2=y.indexOf(""String_Node_Str"");
      }
      if (fieldsplit2 == -1) {
        fieldsplit2=y.indexOf(""String_Node_Str"");
      }
      if (fieldsplit2 > 0) {
        line=(y.substring(fieldsplit2 + 1)).trim();
        y=(y.substring(0,fieldsplit2)).trim();
      }
      try {
        Double xpt=new Double(x);
        Double ypt=new Double(y);
        if (fieldsplit2 > 0) {
          int fieldsplit3=line.indexOf(""String_Node_Str"");
          if (fieldsplit3 == -1) {
            fieldsplit3=line.indexOf(""String_Node_Str"");
          }
          if (fieldsplit3 == -1) {
            fieldsplit2=line.indexOf(""String_Node_Str"");
          }
          if (fieldsplit3 > 0) {
            String yl=(line.substring(0,fieldsplit3)).trim();
            String yh=(line.substring(fieldsplit3 + 1)).trim();
            Double yLowEB=new Double(yl);
            Double yHighEB=new Double(yh);
            connected=_addLegendIfNecessary(connected);
            addPointWithErrorBars(_currentdataset,xpt.doubleValue(),ypt.doubleValue(),yLowEB.doubleValue(),yHighEB.doubleValue(),connected);
            return true;
          }
 else {
            connected=_addLegendIfNecessary(connected);
            addPoint(_currentdataset,xpt.doubleValue(),ypt.doubleValue(),connected);
            return true;
          }
        }
 else {
          connected=_addLegendIfNecessary(connected);
          addPoint(_currentdataset,xpt.doubleValue(),ypt.doubleValue(),connected);
          return true;
        }
      }
 catch (      NumberFormatException e) {
      }
    }
  }
  return false;
}","/** 
 * Parse a line that gives plotting information. Return true if the line is recognized.  Lines with syntax errors are ignored.
 */
protected boolean _parseLine(String line){
  boolean connected=false;
  if (_debug > 8)   System.out.println(""String_Node_Str"" + line);
  if (_connected)   connected=true;
  if (super._parseLine(line)) {
    _pxgraphBlankLineMode=false;
    return true;
  }
 else {
    String lcLine=new String(line.toLowerCase());
    if (lcLine.startsWith(""String_Node_Str"")) {
      String style=(line.substring(6)).trim();
      setMarksStyle(style);
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      String num=(line.substring(8)).trim();
      try {
        setNumSets(Integer.parseInt(num));
      }
 catch (      NumberFormatException e) {
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"") || (_pxgraphBlankLineMode && lcLine.length() == 0)) {
      _firstinset=true;
      _sawfirstdataset=true;
      if (!_datasetoverflow)       _currentdataset++;
      if (_currentdataset >= _numsets || _datasetoverflow) {
        _datasetoverflow=true;
        _currentdataset=-1;
      }
      if (lcLine.length() > 0) {
        String legend=(line.substring(8)).trim();
        addLegend(_currentdataset,legend);
        _pxgraphBlankLineMode=false;
      }
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",6) >= 0) {
        setConnected(false);
      }
 else {
        setConnected(true);
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",9) >= 0) {
        setImpulses(false);
      }
 else {
        setImpulses(true);
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (lcLine.startsWith(""String_Node_Str"")) {
      if (lcLine.indexOf(""String_Node_Str"",5) >= 0) {
        setBars(false);
      }
 else {
        setBars(true);
        if (!_yRangeGiven) {
          _yBottom=0;
        }
        int comma=line.indexOf(""String_Node_Str"",5);
        String barwidth;
        String baroffset=null;
        if (comma > 0) {
          barwidth=(line.substring(5,comma)).trim();
          baroffset=(line.substring(comma + 1)).trim();
        }
 else {
          barwidth=(line.substring(5)).trim();
        }
        try {
          Double bwidth=new Double(barwidth);
          double boffset=_baroffset;
          if (baroffset != null) {
            boffset=(new Double(baroffset)).doubleValue();
          }
          setBars(bwidth.doubleValue(),boffset);
        }
 catch (        NumberFormatException e) {
        }
      }
      _pxgraphBlankLineMode=false;
      return true;
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      connected=false;
      line=line.substring(5,line.length()).trim();
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      connected=false;
      line=line.substring(4,line.length()).trim();
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=line.substring(5,line.length()).trim();
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=line.substring(4,line.length()).trim();
    }
    line=line.trim();
    int fieldsplit=line.indexOf(""String_Node_Str"");
    if (fieldsplit == -1) {
      fieldsplit=line.indexOf(""String_Node_Str"");
    }
    if (fieldsplit == -1) {
      fieldsplit=line.indexOf(""String_Node_Str"");
    }
    if (fieldsplit > 0) {
      String x=(line.substring(0,fieldsplit)).trim();
      String y=(line.substring(fieldsplit + 1)).trim();
      int fieldsplit2=y.indexOf(""String_Node_Str"");
      if (fieldsplit2 == -1) {
        fieldsplit2=y.indexOf(""String_Node_Str"");
      }
      if (fieldsplit2 == -1) {
        fieldsplit2=y.indexOf(""String_Node_Str"");
      }
      if (fieldsplit2 > 0) {
        line=(y.substring(fieldsplit2 + 1)).trim();
        y=(y.substring(0,fieldsplit2)).trim();
      }
      try {
        Double xpt=new Double(x);
        Double ypt=new Double(y);
        if (fieldsplit2 > 0) {
          int fieldsplit3=line.indexOf(""String_Node_Str"");
          if (fieldsplit3 == -1) {
            fieldsplit3=line.indexOf(""String_Node_Str"");
          }
          if (fieldsplit3 == -1) {
            fieldsplit2=line.indexOf(""String_Node_Str"");
          }
          if (fieldsplit3 > 0) {
            String yl=(line.substring(0,fieldsplit3)).trim();
            String yh=(line.substring(fieldsplit3 + 1)).trim();
            Double yLowEB=new Double(yl);
            Double yHighEB=new Double(yh);
            connected=_addLegendIfNecessary(connected);
            addPointWithErrorBars(_currentdataset,xpt.doubleValue(),ypt.doubleValue(),yLowEB.doubleValue(),yHighEB.doubleValue(),connected);
            return true;
          }
 else {
            connected=_addLegendIfNecessary(connected);
            addPoint(_currentdataset,xpt.doubleValue(),ypt.doubleValue(),connected);
            return true;
          }
        }
 else {
          connected=_addLegendIfNecessary(connected);
          addPoint(_currentdataset,xpt.doubleValue(),ypt.doubleValue(),connected);
          return true;
        }
      }
 catch (      NumberFormatException e) {
      }
    }
  }
  return false;
}"
76646,"/** 
 * @param exceptPort Do not return this port in the enumeration. 
 */
public PortEnumeration(Port exceptPort){
  _XRefEnum=_portList.elements();
  _exceptPort=exceptPort;
  _skip=true;
}","/** 
 * @param exceptPort Do not return this port in the enumeration. 
 */
public PortEnumeration(Port exceptPort){
  if (exceptPort != null) {
    CrossRefList censored=new CrossRefList(this);
    censored.duplicate(_portList);
    censored.dissociate(exceptPort);
    _XRefEnum=censored.elements();
  }
 else {
    _XRefEnum=_portList.elements();
  }
}"
76647,"/** 
 * Return the next element in the enumeration. 
 */
public Object nextElement(){
  if (!_skip)   return (Port)_XRefEnum.nextElement();
 else {
    Port nextPort=(Port)_XRefEnum.nextElement();
    if (_exceptPort == null)     return nextPort;
    if (nextPort == _exceptPort) {
      nextPort=(Port)_XRefEnum.nextElement();
    }
    return nextPort;
  }
}","/** 
 * Return the next element in the enumeration. 
 */
public Object nextElement(){
  return (Port)_XRefEnum.nextElement();
}"
76648,"/** 
 * Draw the axes using the current range, label, and title information. If the argument is true, clear the display before redrawing.
 */
public synchronized void drawPlot(Graphics graphics,boolean clearfirst){
  if (_debug > 7)   System.out.println(""String_Node_Str"" + graphics + ""String_Node_Str""+ clearfirst);
  if (graphics == null) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  Rectangle drawRect=bounds();
  graphics.setPaintMode();
  if (clearfirst) {
    graphics.clearRect(0,0,drawRect.width,drawRect.height);
  }
  if (_debug > 8) {
    System.out.println(""String_Node_Str"" + drawRect.width + ""String_Node_Str""+ drawRect.height+ ""String_Node_Str""+ drawRect.x+ ""String_Node_Str""+ drawRect.y);
    graphics.drawRect(0,0,drawRect.width,drawRect.height);
  }
  if (_errorMsg != null) {
    int fheight=_labelFontMetrics.getHeight() + 2;
    int msgy=fheight;
    graphics.setColor(Color.black);
    for (int i=0; i < _errorMsg.length; i++) {
      graphics.drawString(_errorMsg[i],10,msgy);
      msgy+=fheight;
    }
    return;
  }
  if (!_xRangeGiven) {
    if (_xBottom > _xTop) {
      _setXRange(0,0);
    }
 else {
      _setXRange(_xBottom,_xTop);
    }
  }
  if (!_yRangeGiven) {
    if (_yBottom > _yTop) {
      _setYRange(0,0);
    }
 else {
      _setYRange(_yBottom,_yTop);
    }
  }
  int titley=0;
  int titlefontheight=_titleFontMetrics.getHeight();
  if (_title != null || _yExp != 0) {
    titley=titlefontheight + _topPadding;
  }
  graphics.setFont(_labelfont);
  int labelheight=_labelFontMetrics.getHeight();
  int halflabelheight=labelheight / 2;
  int ySPos=drawRect.height - 5;
  if (_xExp != 0 && _xticks == null) {
    int xSPos=drawRect.width - _rightPadding;
    String superscript=Integer.toString(_xExp);
    xSPos-=_superscriptFontMetrics.stringWidth(superscript);
    graphics.setFont(_superscriptfont);
    graphics.drawString(superscript,xSPos,ySPos - halflabelheight);
    xSPos-=_labelFontMetrics.stringWidth(""String_Node_Str"");
    graphics.setFont(_labelfont);
    graphics.drawString(""String_Node_Str"",xSPos,ySPos);
    _bottomPadding=(3 * labelheight) / 2 + 5;
  }
  if (_xlabel != null && _bottomPadding < labelheight + 5) {
    _bottomPadding=titlefontheight + 5;
  }
  _uly=titley + 5;
  _lry=drawRect.height - labelheight - _bottomPadding- 3;
  int height=_lry - _uly;
  _yscale=height / (_yMax - _yMin);
  _ytickscale=height / (_ytickMax - _ytickMin);
  int ny=2 + height / (labelheight + 10);
  double yStep=_roundUp((_ytickMax - _ytickMin) / (double)ny);
  double yStart=yStep * Math.ceil(_ytickMin / yStep);
  int widesty=0;
  String ylabels[]=new String[ny];
  int ylabwidth[]=new int[ny];
  int ind=0;
  if (_yticks == null) {
    int numfracdigits=_numFracDigits(yStep);
    for (double ypos=yStart; ypos <= _ytickMax; ypos+=yStep) {
      if (ind >= ny)       break;
      String yl=_formatNum(ypos,numfracdigits);
      ylabels[ind]=yl;
      int lw=_labelFontMetrics.stringWidth(yl);
      ylabwidth[ind++]=lw;
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
 else {
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      int lw=_labelFontMetrics.stringWidth(label);
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
  if (_ylabel != null) {
    _ulx=widesty + _labelFontMetrics.stringWidth(""String_Node_Str"") + _leftPadding;
  }
 else {
    _ulx=widesty + _leftPadding;
  }
  int legendwidth=_drawLegend(graphics,drawRect.width - _rightPadding,_uly);
  _lrx=drawRect.width - legendwidth - _rightPadding;
  int width=_lrx - _ulx;
  _xscale=width / (_xMax - _xMin);
  _xtickscale=width / (_xtickMax - _xtickMin);
  if (_debug > 8) {
    System.out.println(""String_Node_Str"" + _ulx + ""String_Node_Str""+ _uly+ ""String_Node_Str""+ _lrx+ ""String_Node_Str""+ _lry+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height);
  }
  graphics.setColor(_background);
  graphics.fillRect(_ulx,_uly,width,height);
  graphics.setColor(_foreground);
  graphics.drawRect(_ulx,_uly,width,height);
  int tickLength=5;
  int xCoord1=_ulx + tickLength;
  int xCoord2=_lrx - tickLength;
  if (_yticks == null) {
    ind=0;
    for (double ypos=yStart; ypos <= _ytickMax; ypos+=yStep) {
      if (ind >= ny)       break;
      int yCoord1=_lry - (int)((ypos - _ytickMin) * _ytickscale);
      int offset=0;
      if (ind > 0)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(ylabels[ind],_ulx - ylabwidth[ind++] - 4,yCoord1 + offset);
    }
    if (_yExp != 0) {
      graphics.drawString(""String_Node_Str"",2,titley);
      graphics.setFont(_superscriptfont);
      graphics.drawString(Integer.toString(_yExp),_labelFontMetrics.stringWidth(""String_Node_Str"") + 2,titley - halflabelheight);
      graphics.setFont(_labelfont);
    }
  }
 else {
    Enumeration nt=_yticks.elements();
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double ypos=((Double)(nt.nextElement())).doubleValue();
      if (ypos > _yMax || ypos < _yMin)       continue;
      int yCoord1=_lry - (int)((ypos - _yMin) * _ytickscale);
      int offset=0;
      if (ypos < _lry - labelheight)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(label,_ulx - _labelFontMetrics.stringWidth(label) - 3,yCoord1 + offset);
    }
  }
  int yCoord1=_uly + tickLength;
  int yCoord2=_lry - tickLength;
  if (_xticks == null) {
    int nx=10;
    double xStep=0.0;
    int numfracdigits=0;
    int charwidth=_labelFontMetrics.stringWidth(""String_Node_Str"");
    int count=0;
    while (count++ <= 10) {
      xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
      numfracdigits=_numFracDigits(xStep);
      int intdigits=_numIntDigits(_xtickMax);
      int inttemp=_numIntDigits(_xtickMin);
      if (intdigits < inttemp) {
        intdigits=inttemp;
      }
      int maxlabelwidth=charwidth * (numfracdigits + 2 + intdigits);
      int savenx=nx;
      nx=2 + width / (maxlabelwidth + 10);
      if (nx - savenx <= 1 || savenx - nx <= 1)       break;
    }
    xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
    numfracdigits=_numFracDigits(xStep);
    double xStart=xStep * Math.ceil(_xtickMin / xStep);
    for (double xpos=xStart; xpos <= _xtickMax; xpos+=xStep) {
      String xticklabel=_formatNum(xpos,numfracdigits);
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - _labelFontMetrics.stringWidth(xticklabel) / 2;
      graphics.drawString(xticklabel,labxpos,_lry + 3 + labelheight);
    }
  }
 else {
    Enumeration nt=_xticks.elements();
    Enumeration nl=_xticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double xpos=((Double)(nt.nextElement())).doubleValue();
      if (xpos > _xMax || xpos < _xMin)       continue;
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - _labelFontMetrics.stringWidth(label) / 2;
      graphics.drawString(label,labxpos,_lry + 3 + labelheight);
    }
  }
  graphics.setColor(_foreground);
  if (_title != null) {
    graphics.setFont(_titlefont);
    int titlex=_ulx + (width - _titleFontMetrics.stringWidth(_title)) / 2;
    graphics.drawString(_title,titlex,titley);
  }
  graphics.setFont(_labelfont);
  if (_xlabel != null) {
    int labelx=_ulx + (width - _labelFontMetrics.stringWidth(_xlabel)) / 2;
    graphics.drawString(_xlabel,labelx,ySPos);
  }
  int charcenter=2 + _labelFontMetrics.stringWidth(""String_Node_Str"") / 2;
  int charheight=labelheight;
  if (_ylabel != null) {
    int yl=_ylabel.length();
    int starty=_uly + (_lry - _uly) / 2 - yl * charheight / 2 + charheight;
    for (int i=0; i < yl; i++) {
      String nchar=_ylabel.substring(i,i + 1);
      int cwidth=_labelFontMetrics.stringWidth(nchar);
      graphics.drawString(nchar,charcenter - cwidth / 2,starty);
      starty+=charheight;
    }
  }
}","/** 
 * Draw the axes using the current range, label, and title information. If the argument is true, clear the display before redrawing.
 */
public synchronized void drawPlot(Graphics graphics,boolean clearfirst){
  if (_debug > 7)   System.out.println(""String_Node_Str"" + graphics + ""String_Node_Str""+ clearfirst);
  if (graphics == null) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  Rectangle drawRect=bounds();
  graphics.setPaintMode();
  if (clearfirst) {
    graphics.clearRect(0,0,drawRect.width,drawRect.height);
  }
  if (_debug > 8) {
    System.out.println(""String_Node_Str"" + drawRect.width + ""String_Node_Str""+ drawRect.height+ ""String_Node_Str""+ drawRect.x+ ""String_Node_Str""+ drawRect.y);
    graphics.drawRect(0,0,drawRect.width,drawRect.height);
  }
  if (_errorMsg != null) {
    int fheight=_labelFontMetrics.getHeight() + 2;
    int msgy=fheight;
    graphics.setColor(Color.black);
    for (int i=0; i < _errorMsg.length; i++) {
      graphics.drawString(_errorMsg[i],10,msgy);
      msgy+=fheight;
    }
    return;
  }
  if (!_xRangeGiven) {
    if (_xBottom > _xTop) {
      _setXRange(0,0);
    }
 else {
      _setXRange(_xBottom,_xTop);
    }
  }
  if (!_yRangeGiven) {
    if (_yBottom > _yTop) {
      _setYRange(0,0);
    }
 else {
      _setYRange(_yBottom,_yTop);
    }
  }
  int titley=0;
  int titlefontheight=_titleFontMetrics.getHeight();
  if (_title != null || _yExp != 0) {
    titley=titlefontheight + _topPadding;
  }
  graphics.setFont(_labelfont);
  int labelheight=_labelFontMetrics.getHeight();
  int halflabelheight=labelheight / 2;
  int ySPos=drawRect.height - 5;
  if (_xExp != 0 && _xticks == null) {
    int xSPos=drawRect.width - _rightPadding;
    String superscript=Integer.toString(_xExp);
    xSPos-=_superscriptFontMetrics.stringWidth(superscript);
    graphics.setFont(_superscriptfont);
    graphics.drawString(superscript,xSPos,ySPos - halflabelheight);
    xSPos-=_labelFontMetrics.stringWidth(""String_Node_Str"");
    graphics.setFont(_labelfont);
    graphics.drawString(""String_Node_Str"",xSPos,ySPos);
    _bottomPadding=(3 * labelheight) / 2 + 5;
  }
  if (_xlabel != null && _bottomPadding < labelheight + 5) {
    _bottomPadding=titlefontheight + 5;
  }
  _uly=titley + 5;
  _lry=drawRect.height - labelheight - _bottomPadding- 3;
  int height=_lry - _uly;
  _yscale=height / (_yMax - _yMin);
  _ytickscale=height / (_ytickMax - _ytickMin);
  int ny=2 + height / (labelheight + 10);
  double yStep=_roundUp((_ytickMax - _ytickMin) / (double)ny);
  double yStart=yStep * Math.ceil(_ytickMin / yStep);
  int widesty=0;
  String ylabels[]=new String[ny];
  int ylabwidth[]=new int[ny];
  int ind=0;
  if (_yticks == null) {
    int numfracdigits=_numFracDigits(yStep);
    for (double ypos=yStart; ypos <= _ytickMax; ypos+=yStep) {
      if (ind >= ny)       break;
      String yl=_formatNum(ypos,numfracdigits);
      ylabels[ind]=yl;
      int lw=_labelFontMetrics.stringWidth(yl);
      ylabwidth[ind++]=lw;
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
 else {
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      int lw=_labelFontMetrics.stringWidth(label);
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
  if (_ylabel != null) {
    _ulx=widesty + _labelFontMetrics.stringWidth(""String_Node_Str"") + _leftPadding;
  }
 else {
    _ulx=widesty + _leftPadding;
  }
  int legendwidth=_drawLegend(graphics,drawRect.width - _rightPadding,_uly);
  _lrx=drawRect.width - legendwidth - _rightPadding;
  int width=_lrx - _ulx;
  _xscale=width / (_xMax - _xMin);
  _xtickscale=width / (_xtickMax - _xtickMin);
  if (_debug > 8) {
    System.out.println(""String_Node_Str"" + _ulx + ""String_Node_Str""+ _uly+ ""String_Node_Str""+ _lrx+ ""String_Node_Str""+ _lry+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height);
  }
  graphics.setColor(_background);
  graphics.fillRect(_ulx,_uly,width,height);
  graphics.setColor(_foreground);
  graphics.drawRect(_ulx,_uly,width,height);
  int tickLength=5;
  int xCoord1=_ulx + tickLength;
  int xCoord2=_lrx - tickLength;
  if (_yticks == null) {
    ind=0;
    for (double ypos=yStart; ypos <= _ytickMax; ypos+=yStep) {
      if (ind >= ny)       break;
      int yCoord1=_lry - (int)((ypos - _ytickMin) * _ytickscale);
      int offset=0;
      if (ind > 0)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(ylabels[ind],_ulx - ylabwidth[ind++] - 4,yCoord1 + offset);
    }
    if (_yExp != 0) {
      graphics.drawString(""String_Node_Str"",2,titley);
      graphics.setFont(_superscriptfont);
      graphics.drawString(Integer.toString(_yExp),_labelFontMetrics.stringWidth(""String_Node_Str"") + 2,titley - halflabelheight);
      graphics.setFont(_labelfont);
    }
  }
 else {
    Enumeration nt=_yticks.elements();
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double ypos=((Double)(nt.nextElement())).doubleValue();
      if (ypos > _yMax || ypos < _yMin)       continue;
      int yCoord1=_lry - (int)((ypos - _yMin) * _yscale);
      int offset=0;
      if (ypos < _lry - labelheight)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(label,_ulx - _labelFontMetrics.stringWidth(label) - 3,yCoord1 + offset);
    }
  }
  int yCoord1=_uly + tickLength;
  int yCoord2=_lry - tickLength;
  if (_xticks == null) {
    int nx=10;
    double xStep=0.0;
    int numfracdigits=0;
    int charwidth=_labelFontMetrics.stringWidth(""String_Node_Str"");
    int count=0;
    while (count++ <= 10) {
      xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
      numfracdigits=_numFracDigits(xStep);
      int intdigits=_numIntDigits(_xtickMax);
      int inttemp=_numIntDigits(_xtickMin);
      if (intdigits < inttemp) {
        intdigits=inttemp;
      }
      int maxlabelwidth=charwidth * (numfracdigits + 2 + intdigits);
      int savenx=nx;
      nx=2 + width / (maxlabelwidth + 10);
      if (nx - savenx <= 1 || savenx - nx <= 1)       break;
    }
    xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
    numfracdigits=_numFracDigits(xStep);
    double xStart=xStep * Math.ceil(_xtickMin / xStep);
    for (double xpos=xStart; xpos <= _xtickMax; xpos+=xStep) {
      String xticklabel=_formatNum(xpos,numfracdigits);
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - _labelFontMetrics.stringWidth(xticklabel) / 2;
      graphics.drawString(xticklabel,labxpos,_lry + 3 + labelheight);
    }
  }
 else {
    Enumeration nt=_xticks.elements();
    Enumeration nl=_xticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double xpos=((Double)(nt.nextElement())).doubleValue();
      if (xpos > _xMax || xpos < _xMin)       continue;
      xCoord1=_ulx + (int)((xpos - _xMin) * _xscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - _labelFontMetrics.stringWidth(label) / 2;
      graphics.drawString(label,labxpos,_lry + 3 + labelheight);
    }
  }
  graphics.setColor(_foreground);
  if (_title != null) {
    graphics.setFont(_titlefont);
    int titlex=_ulx + (width - _titleFontMetrics.stringWidth(_title)) / 2;
    graphics.drawString(_title,titlex,titley);
  }
  graphics.setFont(_labelfont);
  if (_xlabel != null) {
    int labelx=_ulx + (width - _labelFontMetrics.stringWidth(_xlabel)) / 2;
    graphics.drawString(_xlabel,labelx,ySPos);
  }
  int charcenter=2 + _labelFontMetrics.stringWidth(""String_Node_Str"") / 2;
  int charheight=labelheight;
  if (_ylabel != null) {
    int yl=_ylabel.length();
    int starty=_uly + (_lry - _uly) / 2 - yl * charheight / 2 + charheight;
    for (int i=0; i < yl; i++) {
      String nchar=_ylabel.substring(i,i + 1);
      int cwidth=_labelFontMetrics.stringWidth(nchar);
      graphics.drawString(nchar,charcenter - cwidth / 2,starty);
      starty+=charheight;
    }
  }
}"
76649,"/** 
 * Draw the axes using the current range, label, and title information. If the argument is true, clear the display before redrawing.
 */
public synchronized void drawPlot(Graphics graphics,boolean clearfirst){
  if (_debug > 7)   System.out.println(""String_Node_Str"" + graphics);
  if (graphics == null) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  Rectangle drawRect=bounds();
  if (_debug > 15) {
    System.out.println(""String_Node_Str"" + drawRect.width + ""String_Node_Str""+ drawRect.height);
    graphics.drawRect(0,0,drawRect.width,drawRect.height);
  }
  graphics.setPaintMode();
  if (clearfirst) {
    graphics.clearRect(0,0,drawRect.width,drawRect.height);
  }
  if (_errorMsg != null) {
    int fheight=_labelFontMetrics.getHeight() + 2;
    int msgy=fheight;
    graphics.setColor(Color.black);
    for (int i=0; i < _errorMsg.length; i++) {
      graphics.drawString(_errorMsg[i],10,msgy);
      msgy+=fheight;
    }
    return;
  }
  if (!_xRangeGiven) {
    if (_xBottom > _xTop) {
      _setXRange(0,0);
    }
 else {
      _setXRange(_xBottom,_xTop);
    }
  }
  if (!_yRangeGiven) {
    if (_yBottom > _yTop) {
      _setYRange(0,0);
    }
 else {
      _setYRange(_yBottom,_yTop);
    }
  }
  int titley=0;
  int titlefontheight=_titleFontMetrics.getHeight();
  if (_title != null || _yExp != 0) {
    titley=titlefontheight + _topPadding;
  }
  graphics.setFont(_labelfont);
  int labelheight=_labelFontMetrics.getHeight();
  int halflabelheight=labelheight / 2;
  int ySPos=drawRect.height - 5;
  if (_xExp != 0 && _xticks == null) {
    int xSPos=drawRect.x + drawRect.width - _rightPadding;
    String superscript=Integer.toString(_xExp);
    xSPos-=_superscriptFontMetrics.stringWidth(superscript);
    graphics.setFont(_superscriptfont);
    graphics.drawString(superscript,xSPos,ySPos - halflabelheight);
    xSPos-=_labelFontMetrics.stringWidth(""String_Node_Str"");
    graphics.setFont(_labelfont);
    graphics.drawString(""String_Node_Str"",xSPos,ySPos);
    _bottomPadding=(3 * labelheight) / 2 + 5;
  }
  if (_xlabel != null && _bottomPadding < labelheight + 5) {
    _bottomPadding=titlefontheight + 5;
  }
  _uly=drawRect.y + titley + 5;
  _lry=drawRect.height - labelheight - _bottomPadding- 3;
  int height=_lry - _uly;
  _yscale=height / (_yMax - _yMin);
  _ytickscale=height / (_ytickMax - _ytickMin);
  int ny=2 + height / (labelheight + 10);
  double yStep=_roundUp((_ytickMax - _ytickMin) / (double)ny);
  double yStart=yStep * Math.ceil(_ytickMin / yStep);
  int widesty=0;
  String ylabels[]=new String[ny];
  int ylabwidth[]=new int[ny];
  int ind=0;
  if (_yticks == null) {
    int numfracdigits=_numFracDigits(yStep);
    for (double ypos=yStart; ypos <= _ytickMax; ypos+=yStep) {
      if (ind >= ny)       break;
      String yl=_formatNum(ypos,numfracdigits);
      ylabels[ind]=yl;
      int lw=_labelFontMetrics.stringWidth(yl);
      ylabwidth[ind++]=lw;
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
 else {
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      int lw=_labelFontMetrics.stringWidth(label);
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
  if (_ylabel != null) {
    _ulx=drawRect.x + widesty + _labelFontMetrics.stringWidth(""String_Node_Str"")+ _leftPadding;
  }
 else {
    _ulx=drawRect.x + widesty + _leftPadding;
  }
  int legendwidth=_drawLegend(graphics,drawRect.width - _rightPadding,_uly);
  _lrx=drawRect.width - legendwidth - _rightPadding;
  int width=_lrx - _ulx;
  _xscale=width / (_xMax - _xMin);
  _xtickscale=width / (_xtickMax - _xtickMin);
  graphics.setColor(_background);
  graphics.fillRect(_ulx,_uly,width,height);
  graphics.setColor(_foreground);
  graphics.drawRect(_ulx,_uly,width,height);
  int tickLength=5;
  int xCoord1=_ulx + tickLength;
  int xCoord2=_lrx - tickLength;
  if (_yticks == null) {
    ind=0;
    for (double ypos=yStart; ypos <= _ytickMax; ypos+=yStep) {
      if (ind >= ny)       break;
      int yCoord1=_lry - (int)((ypos - _ytickMin) * _ytickscale);
      int offset=0;
      if (ind > 0)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(ylabels[ind],_ulx - ylabwidth[ind++] - 4,yCoord1 + offset);
    }
    if (_yExp != 0) {
      graphics.drawString(""String_Node_Str"",2,titley);
      graphics.setFont(_superscriptfont);
      graphics.drawString(Integer.toString(_yExp),_labelFontMetrics.stringWidth(""String_Node_Str"") + 2,titley - halflabelheight);
      graphics.setFont(_labelfont);
    }
  }
 else {
    Enumeration nt=_yticks.elements();
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double ypos=((Double)(nt.nextElement())).doubleValue();
      if (ypos > _yMax || ypos < _yMin)       continue;
      int yCoord1=_lry - (int)((ypos - _yMin) * _ytickscale);
      int offset=0;
      if (ypos < _lry - labelheight)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(label,_ulx - _labelFontMetrics.stringWidth(label) - 3,yCoord1 + offset);
    }
  }
  int yCoord1=_uly + tickLength;
  int yCoord2=_lry - tickLength;
  if (_xticks == null) {
    int nx=10;
    double xStep=0.0;
    int numfracdigits=0;
    int charwidth=_labelFontMetrics.stringWidth(""String_Node_Str"");
    int count=0;
    while (count++ <= 10) {
      xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
      numfracdigits=_numFracDigits(xStep);
      int intdigits=_numIntDigits(_xtickMax);
      int inttemp=_numIntDigits(_xtickMin);
      if (intdigits < inttemp) {
        intdigits=inttemp;
      }
      int maxlabelwidth=charwidth * (numfracdigits + 2 + intdigits);
      int savenx=nx;
      nx=2 + width / (maxlabelwidth + 10);
      if (nx - savenx <= 1 || savenx - nx <= 1)       break;
    }
    xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
    numfracdigits=_numFracDigits(xStep);
    double xStart=xStep * Math.ceil(_xtickMin / xStep);
    for (double xpos=xStart; xpos <= _xtickMax; xpos+=xStep) {
      String xticklabel=_formatNum(xpos,numfracdigits);
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - _labelFontMetrics.stringWidth(xticklabel) / 2;
      graphics.drawString(xticklabel,labxpos,_lry + 3 + labelheight);
    }
  }
 else {
    Enumeration nt=_xticks.elements();
    Enumeration nl=_xticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double xpos=((Double)(nt.nextElement())).doubleValue();
      if (xpos > _xMax || xpos < _xMin)       continue;
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - _labelFontMetrics.stringWidth(label) / 2;
      graphics.drawString(label,labxpos,_lry + 3 + labelheight);
    }
  }
  graphics.setColor(_foreground);
  if (_title != null) {
    graphics.setFont(_titlefont);
    int titlex=_ulx + (width - _titleFontMetrics.stringWidth(_title)) / 2;
    graphics.drawString(_title,titlex,titley);
  }
  graphics.setFont(_labelfont);
  if (_xlabel != null) {
    int labelx=_ulx + (width - _labelFontMetrics.stringWidth(_xlabel)) / 2;
    graphics.drawString(_xlabel,labelx,ySPos);
  }
  int charcenter=2 + _labelFontMetrics.stringWidth(""String_Node_Str"") / 2;
  int charheight=labelheight;
  if (_ylabel != null) {
    int yl=_ylabel.length();
    int starty=_uly + (_lry - _uly) / 2 - yl * charheight / 2 + charheight;
    for (int i=0; i < yl; i++) {
      String nchar=_ylabel.substring(i,i + 1);
      int cwidth=_labelFontMetrics.stringWidth(nchar);
      graphics.drawString(nchar,charcenter - cwidth / 2,starty);
      starty+=charheight;
    }
  }
}","/** 
 * Draw the axes using the current range, label, and title information. If the argument is true, clear the display before redrawing.
 */
public synchronized void drawPlot(Graphics graphics,boolean clearfirst){
  if (_debug > 7)   System.out.println(""String_Node_Str"" + graphics);
  if (graphics == null) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  Rectangle drawRect=bounds();
  graphics.setPaintMode();
  if (clearfirst) {
    graphics.clearRect(0,0,drawRect.width - 1,drawRect.height - 1);
  }
  if (_debug > 8) {
    System.out.println(""String_Node_Str"" + drawRect.width + ""String_Node_Str""+ drawRect.height+ ""String_Node_Str""+ drawRect.x+ ""String_Node_Str""+ drawRect.y);
    graphics.drawRect(0,0,drawRect.width - 1,drawRect.height - 1);
  }
  if (_errorMsg != null) {
    int fheight=_labelFontMetrics.getHeight() + 2;
    int msgy=fheight;
    graphics.setColor(Color.black);
    for (int i=0; i < _errorMsg.length; i++) {
      graphics.drawString(_errorMsg[i],10,msgy);
      msgy+=fheight;
    }
    return;
  }
  if (!_xRangeGiven) {
    if (_xBottom > _xTop) {
      _setXRange(0,0);
    }
 else {
      _setXRange(_xBottom,_xTop);
    }
  }
  if (!_yRangeGiven) {
    if (_yBottom > _yTop) {
      _setYRange(0,0);
    }
 else {
      _setYRange(_yBottom,_yTop);
    }
  }
  int titley=0;
  int titlefontheight=_titleFontMetrics.getHeight();
  if (_title != null || _yExp != 0) {
    titley=titlefontheight + _topPadding;
  }
  graphics.setFont(_labelfont);
  int labelheight=_labelFontMetrics.getHeight();
  int halflabelheight=labelheight / 2;
  int ySPos=drawRect.height - 5;
  if (_xExp != 0 && _xticks == null) {
    int xSPos=drawRect.width - _rightPadding;
    String superscript=Integer.toString(_xExp);
    xSPos-=_superscriptFontMetrics.stringWidth(superscript);
    graphics.setFont(_superscriptfont);
    graphics.drawString(superscript,xSPos,ySPos - halflabelheight);
    xSPos-=_labelFontMetrics.stringWidth(""String_Node_Str"");
    graphics.setFont(_labelfont);
    graphics.drawString(""String_Node_Str"",xSPos,ySPos);
    _bottomPadding=(3 * labelheight) / 2 + 5;
  }
  if (_xlabel != null && _bottomPadding < labelheight + 5) {
    _bottomPadding=titlefontheight + 5;
  }
  _uly=titley + 5;
  _lry=drawRect.height - labelheight - _bottomPadding- 3;
  int height=_lry - _uly;
  _yscale=height / (_yMax - _yMin);
  _ytickscale=height / (_ytickMax - _ytickMin);
  int ny=2 + height / (labelheight + 10);
  double yStep=_roundUp((_ytickMax - _ytickMin) / (double)ny);
  double yStart=yStep * Math.ceil(_ytickMin / yStep);
  int widesty=0;
  String ylabels[]=new String[ny];
  int ylabwidth[]=new int[ny];
  int ind=0;
  if (_yticks == null) {
    int numfracdigits=_numFracDigits(yStep);
    for (double ypos=yStart; ypos <= _ytickMax; ypos+=yStep) {
      if (ind >= ny)       break;
      String yl=_formatNum(ypos,numfracdigits);
      ylabels[ind]=yl;
      int lw=_labelFontMetrics.stringWidth(yl);
      ylabwidth[ind++]=lw;
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
 else {
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      int lw=_labelFontMetrics.stringWidth(label);
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
  if (_ylabel != null) {
    _ulx=widesty + _labelFontMetrics.stringWidth(""String_Node_Str"") + _leftPadding;
  }
 else {
    _ulx=widesty + _leftPadding;
  }
  int legendwidth=_drawLegend(graphics,drawRect.width - _rightPadding,_uly);
  _lrx=drawRect.width - legendwidth - _rightPadding;
  int width=_lrx - _ulx;
  _xscale=width / (_xMax - _xMin);
  _xtickscale=width / (_xtickMax - _xtickMin);
  if (_debug > 8) {
    System.out.println(""String_Node_Str"" + _ulx + ""String_Node_Str""+ _uly+ ""String_Node_Str""+ _lrx+ ""String_Node_Str""+ _lry+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height);
  }
  graphics.setColor(_background);
  graphics.fillRect(_ulx,_uly,width,height);
  graphics.setColor(_foreground);
  graphics.drawRect(_ulx,_uly,width,height);
  int tickLength=5;
  int xCoord1=_ulx + tickLength;
  int xCoord2=_lrx - tickLength;
  if (_yticks == null) {
    ind=0;
    for (double ypos=yStart; ypos <= _ytickMax; ypos+=yStep) {
      if (ind >= ny)       break;
      int yCoord1=_lry - (int)((ypos - _ytickMin) * _ytickscale);
      int offset=0;
      if (ind > 0)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(ylabels[ind],_ulx - ylabwidth[ind++] - 4,yCoord1 + offset);
    }
    if (_yExp != 0) {
      graphics.drawString(""String_Node_Str"",2,titley);
      graphics.setFont(_superscriptfont);
      graphics.drawString(Integer.toString(_yExp),_labelFontMetrics.stringWidth(""String_Node_Str"") + 2,titley - halflabelheight);
      graphics.setFont(_labelfont);
    }
  }
 else {
    Enumeration nt=_yticks.elements();
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double ypos=((Double)(nt.nextElement())).doubleValue();
      if (ypos > _yMax || ypos < _yMin)       continue;
      int yCoord1=_lry - (int)((ypos - _yMin) * _ytickscale);
      int offset=0;
      if (ypos < _lry - labelheight)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(label,_ulx - _labelFontMetrics.stringWidth(label) - 3,yCoord1 + offset);
    }
  }
  int yCoord1=_uly + tickLength;
  int yCoord2=_lry - tickLength;
  if (_xticks == null) {
    int nx=10;
    double xStep=0.0;
    int numfracdigits=0;
    int charwidth=_labelFontMetrics.stringWidth(""String_Node_Str"");
    int count=0;
    while (count++ <= 10) {
      xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
      numfracdigits=_numFracDigits(xStep);
      int intdigits=_numIntDigits(_xtickMax);
      int inttemp=_numIntDigits(_xtickMin);
      if (intdigits < inttemp) {
        intdigits=inttemp;
      }
      int maxlabelwidth=charwidth * (numfracdigits + 2 + intdigits);
      int savenx=nx;
      nx=2 + width / (maxlabelwidth + 10);
      if (nx - savenx <= 1 || savenx - nx <= 1)       break;
    }
    xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
    numfracdigits=_numFracDigits(xStep);
    double xStart=xStep * Math.ceil(_xtickMin / xStep);
    for (double xpos=xStart; xpos <= _xtickMax; xpos+=xStep) {
      String xticklabel=_formatNum(xpos,numfracdigits);
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - _labelFontMetrics.stringWidth(xticklabel) / 2;
      graphics.drawString(xticklabel,labxpos,_lry + 3 + labelheight);
    }
  }
 else {
    Enumeration nt=_xticks.elements();
    Enumeration nl=_xticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double xpos=((Double)(nt.nextElement())).doubleValue();
      if (xpos > _xMax || xpos < _xMin)       continue;
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - _labelFontMetrics.stringWidth(label) / 2;
      graphics.drawString(label,labxpos,_lry + 3 + labelheight);
    }
  }
  graphics.setColor(_foreground);
  if (_title != null) {
    graphics.setFont(_titlefont);
    int titlex=_ulx + (width - _titleFontMetrics.stringWidth(_title)) / 2;
    graphics.drawString(_title,titlex,titley);
  }
  graphics.setFont(_labelfont);
  if (_xlabel != null) {
    int labelx=_ulx + (width - _labelFontMetrics.stringWidth(_xlabel)) / 2;
    graphics.drawString(_xlabel,labelx,ySPos);
  }
  int charcenter=2 + _labelFontMetrics.stringWidth(""String_Node_Str"") / 2;
  int charheight=labelheight;
  if (_ylabel != null) {
    int yl=_ylabel.length();
    int starty=_uly + (_lry - _uly) / 2 - yl * charheight / 2 + charheight;
    for (int i=0; i < yl; i++) {
      String nchar=_ylabel.substring(i,i + 1);
      int cwidth=_labelFontMetrics.stringWidth(nchar);
      graphics.drawString(nchar,charcenter - cwidth / 2,starty);
      starty+=charheight;
    }
  }
}"
76650,"/** 
 * Open up the input file, which could be stdin, a URL or a file. This code can be called from an application, which means that getDocumentBase() might fail.
 */
public void parseFile(String dataurl,URL documentBase){
  DataInputStream in;
  if (_debug > 2)   System.out.println(""String_Node_Str"" + dataurl + ""String_Node_Str""+ documentBase+ ""String_Node_Str""+ _dataurl+ ""String_Node_Str""+ _documentBase);
  if (dataurl == null || dataurl.length() == 0) {
    in=new DataInputStream(System.in);
  }
 else {
    try {
      URL url;
      if (documentBase == null && _documentBase != null) {
        documentBase=_documentBase;
      }
      if (documentBase == null) {
        url=new URL(_dataurl);
      }
 else {
        try {
          url=new URL(documentBase,dataurl);
        }
 catch (        NullPointerException e) {
          url=new URL(_dataurl);
        }
      }
      in=new DataInputStream(url.openStream());
    }
 catch (    MalformedURLException e) {
      try {
        in=new DataInputStream(new FileInputStream(dataurl));
      }
 catch (      FileNotFoundException me) {
        _errorMsg=new String[2];
        _errorMsg[0]=""String_Node_Str"" + dataurl;
        _errorMsg[1]=e.getMessage();
        return;
      }
catch (      SecurityException me) {
        _errorMsg=new String[2];
        _errorMsg[0]=""String_Node_Str"" + dataurl;
        _errorMsg[1]=e.getMessage();
        return;
      }
    }
catch (    IOException ioe) {
      _errorMsg=new String[2];
      _errorMsg[0]=""String_Node_Str"" + dataurl;
      _errorMsg[1]=ioe.getMessage();
      return;
    }
  }
  _newFile();
  try {
    if (_binary) {
      _parseBinaryStream(in);
    }
 else {
      String line=in.readLine();
      while (line != null) {
        _parseLine(line);
        line=in.readLine();
      }
    }
  }
 catch (  MalformedURLException e) {
    _errorMsg=new String[2];
    _errorMsg[0]=""String_Node_Str"" + dataurl;
    _errorMsg[1]=e.getMessage();
    return;
  }
catch (  IOException e) {
    _errorMsg=new String[2];
    _errorMsg[0]=""String_Node_Str"" + dataurl;
    _errorMsg[1]=e.getMessage();
  }
catch (  PlotDataException e) {
    _errorMsg=new String[2];
    _errorMsg[0]=""String_Node_Str"" + dataurl;
    _errorMsg[1]=e.getMessage();
  }
 finally {
    try {
      in.close();
    }
 catch (    IOException me) {
    }
  }
}","/** 
 * Open up the input file, which could be stdin, a URL or a file. This code can be called from an application, which means that getDocumentBase() might fail.
 */
public void parseFile(String dataurl,URL documentBase){
  DataInputStream in;
  if (_debug > 2)   System.out.println(""String_Node_Str"" + dataurl + ""String_Node_Str""+ documentBase+ ""String_Node_Str""+ _dataurl+ ""String_Node_Str""+ _documentBase);
  if (dataurl == null || dataurl.length() == 0) {
    in=new DataInputStream(System.in);
  }
 else {
    try {
      URL url;
      if (documentBase == null && _documentBase != null) {
        documentBase=_documentBase;
      }
      if (documentBase == null) {
        url=new URL(_dataurl);
      }
 else {
        try {
          url=new URL(documentBase,dataurl);
        }
 catch (        NullPointerException e) {
          url=new URL(_dataurl);
        }
      }
      in=new DataInputStream(url.openStream());
    }
 catch (    MalformedURLException e) {
      try {
        in=new DataInputStream(new FileInputStream(dataurl));
      }
 catch (      FileNotFoundException me) {
        _errorMsg=new String[2];
        _errorMsg[0]=""String_Node_Str"" + dataurl;
        _errorMsg[1]=me.getMessage();
        return;
      }
catch (      SecurityException me) {
        _errorMsg=new String[2];
        _errorMsg[0]=""String_Node_Str"" + dataurl;
        _errorMsg[1]=me.getMessage();
        return;
      }
    }
catch (    IOException ioe) {
      _errorMsg=new String[2];
      _errorMsg[0]=""String_Node_Str"" + dataurl;
      _errorMsg[1]=ioe.getMessage();
      return;
    }
  }
  _newFile();
  try {
    if (_binary) {
      _parseBinaryStream(in);
    }
 else {
      String line=in.readLine();
      while (line != null) {
        _parseLine(line);
        line=in.readLine();
      }
    }
  }
 catch (  MalformedURLException e) {
    _errorMsg=new String[2];
    _errorMsg[0]=""String_Node_Str"" + dataurl;
    _errorMsg[1]=e.getMessage();
    return;
  }
catch (  IOException e) {
    _errorMsg=new String[2];
    _errorMsg[0]=""String_Node_Str"" + dataurl;
    _errorMsg[1]=e.getMessage();
  }
catch (  PlotDataException e) {
    _errorMsg=new String[2];
    _errorMsg[0]=""String_Node_Str"" + dataurl;
    _errorMsg[1]=e.getMessage();
  }
 finally {
    try {
      in.close();
    }
 catch (    IOException me) {
    }
  }
}"
76651,"/** 
 * Draw the axes using the current range, label, and title information. If the argument is true, clear the display before redrawing.
 */
public synchronized void drawPlot(Graphics graphics,boolean clearfirst){
  if (graphics == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  Thread.yield();
  Rectangle drawRect=bounds();
  graphics.setPaintMode();
  if (clearfirst) {
    graphics.clearRect(0,0,drawRect.width,drawRect.height);
  }
  graphics.setFont(_titlefont);
  FontMetrics tfm=graphics.getFontMetrics();
  graphics.setFont(_superscriptfont);
  FontMetrics sfm=graphics.getFontMetrics();
  graphics.setFont(_labelfont);
  FontMetrics lfm=graphics.getFontMetrics();
  if (_errorMsg != null) {
    int fheight=lfm.getHeight() + 2;
    int msgy=fheight;
    graphics.setColor(Color.black);
    for (int i=0; i < _errorMsg.length; i++) {
      graphics.drawString(_errorMsg[i],10,msgy);
      msgy+=fheight;
    }
    return;
  }
  if (!_xRangeGiven) {
    if (_xBottom > _xTop) {
      _setXRange(0,0);
    }
 else {
      _setXRange(_xBottom,_xTop);
    }
  }
  if (!_yRangeGiven) {
    if (_yBottom > _yTop) {
      _setYRange(0,0);
    }
 else {
      _setYRange(_yBottom,_yTop);
    }
  }
  int titley=0;
  int titlefontheight=tfm.getHeight();
  if (_title != null || _yExp != 0) {
    titley=titlefontheight + _topPadding;
  }
  graphics.setFont(_labelfont);
  int labelheight=lfm.getHeight();
  int halflabelheight=labelheight / 2;
  int ySPos=drawRect.height - 5;
  if (_xExp != 0 && _xticks == null) {
    int xSPos=drawRect.x + drawRect.width - _rightPadding;
    String superscript=Integer.toString(_xExp);
    xSPos-=sfm.stringWidth(superscript);
    graphics.setFont(_superscriptfont);
    graphics.drawString(superscript,xSPos,ySPos - halflabelheight);
    xSPos-=lfm.stringWidth(""String_Node_Str"");
    graphics.setFont(_labelfont);
    graphics.drawString(""String_Node_Str"",xSPos,ySPos);
    _bottomPadding=(3 * labelheight) / 2 + 5;
  }
  if (_xlabel != null && _bottomPadding < labelheight + 5) {
    _bottomPadding=titlefontheight + 5;
  }
  _uly=drawRect.y + titley + 5;
  _lry=drawRect.height - labelheight - _bottomPadding- 3;
  int height=_lry - _uly;
  _yscale=height / (_yMax - _yMin);
  _ytickscale=height / (_ytickMax - _ytickMin);
  int ny=2 + height / (labelheight + 10);
  double yStep=_roundUp((_ytickMax - _ytickMin) / (double)ny);
  double yStart=yStep * Math.ceil(_ytickMin / yStep);
  int widesty=0;
  String ylabels[]=new String[ny];
  int ylabwidth[]=new int[ny];
  int ind=0;
  if (_yticks == null) {
    int numfracdigits=_numFracDigits(yStep);
    for (double ypos=yStart; ypos <= _yMax; ypos+=yStep) {
      if (ind >= ny)       break;
      String yl=_formatNum(ypos,numfracdigits);
      ylabels[ind]=yl;
      int lw=lfm.stringWidth(yl);
      ylabwidth[ind++]=lw;
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
 else {
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      int lw=lfm.stringWidth(label);
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
  if (_ylabel != null) {
    _ulx=drawRect.x + widesty + lfm.stringWidth(""String_Node_Str"")+ _leftPadding;
  }
 else {
    _ulx=drawRect.x + widesty + _leftPadding;
  }
  int legendwidth=_drawLegend(graphics,drawRect.width - _rightPadding,_uly);
  _lrx=drawRect.width - legendwidth - _rightPadding;
  int width=_lrx - _ulx;
  _xscale=width / (_xMax - _xMin);
  _xtickscale=width / (_xtickMax - _xtickMin);
  graphics.setColor(_background);
  graphics.fillRect(_ulx,_uly,width,height);
  graphics.setColor(_foreground);
  graphics.drawRect(_ulx,_uly,width,height);
  int tickLength=5;
  int xCoord1=_ulx + tickLength;
  int xCoord2=_lrx - tickLength;
  if (_yticks == null) {
    ind=0;
    for (double ypos=yStart; ypos <= _ytickMax; ypos+=yStep) {
      if (ind >= ny)       break;
      int yCoord1=_lry - (int)((ypos - _ytickMin) * _ytickscale);
      int offset=0;
      if (ind > 0)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(ylabels[ind],_ulx - ylabwidth[ind++] - 4,yCoord1 + offset);
    }
    if (_yExp != 0) {
      graphics.drawString(""String_Node_Str"",2,titley);
      graphics.setFont(_superscriptfont);
      graphics.drawString(Integer.toString(_yExp),lfm.stringWidth(""String_Node_Str"") + 2,titley - halflabelheight);
      graphics.setFont(_labelfont);
    }
  }
 else {
    Enumeration nt=_yticks.elements();
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double ypos=((Double)(nt.nextElement())).doubleValue();
      if (ypos > _yMax || ypos < _yMin)       continue;
      int yCoord1=_lry - (int)((ypos - _yMin) * _ytickscale);
      int offset=0;
      if (ypos < _lry - labelheight)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(label,_ulx - lfm.stringWidth(label) - 3,yCoord1 + offset);
    }
  }
  int yCoord1=_uly + tickLength;
  int yCoord2=_lry - tickLength;
  if (_xticks == null) {
    int nx=10;
    double xStep=0.0;
    int numfracdigits=0;
    int charwidth=lfm.stringWidth(""String_Node_Str"");
    int count=0;
    while (count++ <= 10) {
      xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
      numfracdigits=_numFracDigits(xStep);
      int intdigits=_numIntDigits(_xtickMax);
      int inttemp=_numIntDigits(_xtickMin);
      if (intdigits < inttemp) {
        intdigits=inttemp;
      }
      int maxlabelwidth=charwidth * (numfracdigits + 2 + intdigits);
      int savenx=nx;
      nx=2 + width / (maxlabelwidth + 10);
      if (nx - savenx <= 1 || savenx - nx <= 1)       break;
    }
    xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
    numfracdigits=_numFracDigits(xStep);
    double xStart=xStep * Math.ceil(_xtickMin / xStep);
    for (double xpos=xStart; xpos <= _xtickMax; xpos+=xStep) {
      String xticklabel=_formatNum(xpos,numfracdigits);
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - lfm.stringWidth(xticklabel) / 2;
      graphics.drawString(xticklabel,labxpos,_lry + 3 + labelheight);
    }
  }
 else {
    Enumeration nt=_xticks.elements();
    Enumeration nl=_xticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double xpos=((Double)(nt.nextElement())).doubleValue();
      if (xpos > _xMax || xpos < _xMin)       continue;
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - lfm.stringWidth(label) / 2;
      graphics.drawString(label,labxpos,_lry + 3 + labelheight);
    }
  }
  graphics.setColor(_foreground);
  if (_title != null) {
    graphics.setFont(_titlefont);
    int titlex=_ulx + (width - tfm.stringWidth(_title)) / 2;
    graphics.drawString(_title,titlex,titley);
  }
  graphics.setFont(_labelfont);
  if (_xlabel != null) {
    int labelx=_ulx + (width - lfm.stringWidth(_xlabel)) / 2;
    graphics.drawString(_xlabel,labelx,ySPos);
  }
  int charcenter=2 + lfm.stringWidth(""String_Node_Str"") / 2;
  int charheight=labelheight;
  if (_ylabel != null) {
    int yl=_ylabel.length();
    int starty=_uly + (_lry - _uly) / 2 - yl * charheight / 2 + charheight;
    for (int i=0; i < yl; i++) {
      String nchar=_ylabel.substring(i,i + 1);
      int cwidth=lfm.stringWidth(nchar);
      graphics.drawString(nchar,charcenter - cwidth / 2,starty);
      starty+=charheight;
    }
  }
}","/** 
 * Draw the axes using the current range, label, and title information. If the argument is true, clear the display before redrawing.
 */
public synchronized void drawPlot(Graphics graphics,boolean clearfirst){
  if (graphics == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  Thread.yield();
  Rectangle drawRect=bounds();
  graphics.setPaintMode();
  if (clearfirst) {
    graphics.clearRect(0,0,drawRect.width,drawRect.height);
  }
  graphics.setFont(_titlefont);
  FontMetrics tfm=graphics.getFontMetrics();
  graphics.setFont(_superscriptfont);
  FontMetrics sfm=graphics.getFontMetrics();
  graphics.setFont(_labelfont);
  FontMetrics lfm=graphics.getFontMetrics();
  if (_errorMsg != null) {
    int fheight=lfm.getHeight() + 2;
    int msgy=fheight;
    graphics.setColor(Color.black);
    for (int i=0; i < _errorMsg.length; i++) {
      graphics.drawString(_errorMsg[i],10,msgy);
      msgy+=fheight;
    }
    return;
  }
  if (!_xRangeGiven) {
    if (_xBottom > _xTop) {
      _setXRange(0,0);
    }
 else {
      _setXRange(_xBottom,_xTop);
    }
  }
  if (!_yRangeGiven) {
    if (_yBottom > _yTop) {
      _setYRange(0,0);
    }
 else {
      _setYRange(_yBottom,_yTop);
    }
  }
  int titley=0;
  int titlefontheight=tfm.getHeight();
  if (_title != null || _yExp != 0) {
    titley=titlefontheight + _topPadding;
  }
  graphics.setFont(_labelfont);
  int labelheight=lfm.getHeight();
  int halflabelheight=labelheight / 2;
  int ySPos=drawRect.height - 5;
  if (_xExp != 0 && _xticks == null) {
    int xSPos=drawRect.x + drawRect.width - _rightPadding;
    String superscript=Integer.toString(_xExp);
    xSPos-=sfm.stringWidth(superscript);
    graphics.setFont(_superscriptfont);
    graphics.drawString(superscript,xSPos,ySPos - halflabelheight);
    xSPos-=lfm.stringWidth(""String_Node_Str"");
    graphics.setFont(_labelfont);
    graphics.drawString(""String_Node_Str"",xSPos,ySPos);
    _bottomPadding=(3 * labelheight) / 2 + 5;
  }
  if (_xlabel != null && _bottomPadding < labelheight + 5) {
    _bottomPadding=titlefontheight + 5;
  }
  _uly=drawRect.y + titley + 5;
  _lry=drawRect.height - labelheight - _bottomPadding- 3;
  int height=_lry - _uly;
  _yscale=height / (_yMax - _yMin);
  _ytickscale=height / (_ytickMax - _ytickMin);
  int ny=2 + height / (labelheight + 10);
  double yStep=_roundUp((_ytickMax - _ytickMin) / (double)ny);
  double yStart=yStep * Math.ceil(_ytickMin / yStep);
  int widesty=0;
  String ylabels[]=new String[ny];
  int ylabwidth[]=new int[ny];
  int ind=0;
  if (_yticks == null) {
    int numfracdigits=_numFracDigits(yStep);
    for (double ypos=yStart; ypos <= _ytickMax; ypos+=yStep) {
      if (ind >= ny)       break;
      String yl=_formatNum(ypos,numfracdigits);
      ylabels[ind]=yl;
      int lw=lfm.stringWidth(yl);
      ylabwidth[ind++]=lw;
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
 else {
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      int lw=lfm.stringWidth(label);
      if (lw > widesty) {
        widesty=lw;
      }
    }
  }
  if (_ylabel != null) {
    _ulx=drawRect.x + widesty + lfm.stringWidth(""String_Node_Str"")+ _leftPadding;
  }
 else {
    _ulx=drawRect.x + widesty + _leftPadding;
  }
  int legendwidth=_drawLegend(graphics,drawRect.width - _rightPadding,_uly);
  _lrx=drawRect.width - legendwidth - _rightPadding;
  int width=_lrx - _ulx;
  _xscale=width / (_xMax - _xMin);
  _xtickscale=width / (_xtickMax - _xtickMin);
  graphics.setColor(_background);
  graphics.fillRect(_ulx,_uly,width,height);
  graphics.setColor(_foreground);
  graphics.drawRect(_ulx,_uly,width,height);
  int tickLength=5;
  int xCoord1=_ulx + tickLength;
  int xCoord2=_lrx - tickLength;
  if (_yticks == null) {
    ind=0;
    for (double ypos=yStart; ypos <= _ytickMax; ypos+=yStep) {
      if (ind >= ny)       break;
      int yCoord1=_lry - (int)((ypos - _ytickMin) * _ytickscale);
      int offset=0;
      if (ind > 0)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(ylabels[ind],_ulx - ylabwidth[ind++] - 4,yCoord1 + offset);
    }
    if (_yExp != 0) {
      graphics.drawString(""String_Node_Str"",2,titley);
      graphics.setFont(_superscriptfont);
      graphics.drawString(Integer.toString(_yExp),lfm.stringWidth(""String_Node_Str"") + 2,titley - halflabelheight);
      graphics.setFont(_labelfont);
    }
  }
 else {
    Enumeration nt=_yticks.elements();
    Enumeration nl=_yticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double ypos=((Double)(nt.nextElement())).doubleValue();
      if (ypos > _yMax || ypos < _yMin)       continue;
      int yCoord1=_lry - (int)((ypos - _yMin) * _ytickscale);
      int offset=0;
      if (ypos < _lry - labelheight)       offset=halflabelheight;
      graphics.drawLine(_ulx,yCoord1,xCoord1,yCoord1);
      graphics.drawLine(_lrx,yCoord1,xCoord2,yCoord1);
      if (_grid && yCoord1 != _uly && yCoord1 != _lry) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord2,yCoord1);
        graphics.setColor(_foreground);
      }
      graphics.drawString(label,_ulx - lfm.stringWidth(label) - 3,yCoord1 + offset);
    }
  }
  int yCoord1=_uly + tickLength;
  int yCoord2=_lry - tickLength;
  if (_xticks == null) {
    int nx=10;
    double xStep=0.0;
    int numfracdigits=0;
    int charwidth=lfm.stringWidth(""String_Node_Str"");
    int count=0;
    while (count++ <= 10) {
      xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
      numfracdigits=_numFracDigits(xStep);
      int intdigits=_numIntDigits(_xtickMax);
      int inttemp=_numIntDigits(_xtickMin);
      if (intdigits < inttemp) {
        intdigits=inttemp;
      }
      int maxlabelwidth=charwidth * (numfracdigits + 2 + intdigits);
      int savenx=nx;
      nx=2 + width / (maxlabelwidth + 10);
      if (nx - savenx <= 1 || savenx - nx <= 1)       break;
    }
    xStep=_roundUp((_xtickMax - _xtickMin) / (double)nx);
    numfracdigits=_numFracDigits(xStep);
    double xStart=xStep * Math.ceil(_xtickMin / xStep);
    for (double xpos=xStart; xpos <= _xtickMax; xpos+=xStep) {
      String xticklabel=_formatNum(xpos,numfracdigits);
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - lfm.stringWidth(xticklabel) / 2;
      graphics.drawString(xticklabel,labxpos,_lry + 3 + labelheight);
    }
  }
 else {
    Enumeration nt=_xticks.elements();
    Enumeration nl=_xticklabels.elements();
    while (nl.hasMoreElements()) {
      String label=(String)nl.nextElement();
      double xpos=((Double)(nt.nextElement())).doubleValue();
      if (xpos > _xMax || xpos < _xMin)       continue;
      xCoord1=_ulx + (int)((xpos - _xtickMin) * _xtickscale);
      graphics.drawLine(xCoord1,_uly,xCoord1,yCoord1);
      graphics.drawLine(xCoord1,_lry,xCoord1,yCoord2);
      if (_grid && xCoord1 != _ulx && xCoord1 != _lrx) {
        graphics.setColor(Color.lightGray);
        graphics.drawLine(xCoord1,yCoord1,xCoord1,yCoord2);
        graphics.setColor(_foreground);
      }
      int labxpos=xCoord1 - lfm.stringWidth(label) / 2;
      graphics.drawString(label,labxpos,_lry + 3 + labelheight);
    }
  }
  graphics.setColor(_foreground);
  if (_title != null) {
    graphics.setFont(_titlefont);
    int titlex=_ulx + (width - tfm.stringWidth(_title)) / 2;
    graphics.drawString(_title,titlex,titley);
  }
  graphics.setFont(_labelfont);
  if (_xlabel != null) {
    int labelx=_ulx + (width - lfm.stringWidth(_xlabel)) / 2;
    graphics.drawString(_xlabel,labelx,ySPos);
  }
  int charcenter=2 + lfm.stringWidth(""String_Node_Str"") / 2;
  int charheight=labelheight;
  if (_ylabel != null) {
    int yl=_ylabel.length();
    int starty=_uly + (_lry - _uly) / 2 - yl * charheight / 2 + charheight;
    for (int i=0; i < yl; i++) {
      String nchar=_ylabel.substring(i,i + 1);
      int cwidth=lfm.stringWidth(nchar);
      graphics.drawString(nchar,charcenter - cwidth / 2,starty);
      starty+=charheight;
    }
  }
}"
76652,"/** 
 * Draw an impulse from the specified point to the y axis. If the specified point is below the y axis or outside the x range, do nothing.  If the <i>clip</i> argument is true, then do not draw above the y range.
 */
protected void _drawImpulse(Graphics graphics,long xpos,long ypos,boolean clip){
  if (_debug > 20) {
    System.out.println(""String_Node_Str"" + xpos + ""String_Node_Str""+ ypos+ ""String_Node_Str""+ clip+ ""String_Node_Str"");
  }
  if (clip && ypos < _uly)   ypos=_uly;
  if (ypos <= _lry && xpos <= _lrx && xpos >= _ulx) {
    double zeroypos=_lry - (long)((0 - _yMin) * _yscale);
    graphics.drawLine((int)xpos,(int)ypos,(int)xpos,(int)zeroypos);
  }
}","/** 
 * Draw an impulse from the specified point to the y axis. If the specified point is below the y axis or outside the x range, do nothing.  If the <i>clip</i> argument is true, then do not draw above the y range.
 */
protected void _drawImpulse(Graphics graphics,long xpos,long ypos,boolean clip){
  if (_debug > 20) {
    System.out.println(""String_Node_Str"" + xpos + ""String_Node_Str""+ ypos+ ""String_Node_Str""+ clip+ ""String_Node_Str"");
  }
  if (clip && ypos < _uly)   ypos=_uly;
  if (ypos <= _lry && xpos <= _lrx && xpos >= _ulx) {
    double zeroypos=_lry - (long)((0 - _yMin) * _yscale);
    if (_lry < zeroypos)     zeroypos=_lry;
    if (_uly > zeroypos)     zeroypos=_uly;
    graphics.drawLine((int)xpos,(int)ypos,(int)xpos,(int)zeroypos);
  }
}"
76653,"/** 
 * Set the starting point for an interactive zoom box.
 * @deprecated As of JDK1.1 in java.awt.component but we need to compile under 1.0.2 for netscape3.x compatibility.
 */
public boolean mouseUp(Event evt,int x,int y){
  boolean pointinside=y <= _lry && y >= _uly && x <= _lrx && x >= _ulx;
  boolean handled=false;
  if (_zoomin == true) {
    if (_zoomxn != -1 || _zoomyn != -1) {
      int minx=Math.min(_zoomx,_zoomxn);
      int maxx=Math.max(_zoomx,_zoomxn);
      int miny=Math.min(_zoomy,_zoomyn);
      int maxy=Math.max(_zoomy,_zoomyn);
      graphics.setXORMode(_background);
      graphics.drawRect(minx,miny,maxx - minx,maxy - miny);
      graphics.setPaintMode();
      if (pointinside) {
        double a=_xMin + (_zoomx - _ulx) / _xscale;
        double b=_xMin + (x - _ulx) / _xscale;
        if (a < b)         setXRange(a,b);
 else         setXRange(b,a);
        a=_yMax - (_zoomy - _uly) / _yscale;
        b=_yMax - (y - _uly) / _yscale;
        if (a < b)         setYRange(a,b);
 else         setYRange(b,a);
        drawPlot(true);
      }
      handled=true;
    }
  }
 else   if (_zoomout == true) {
    graphics.setXORMode(_background);
    int x_diff=Math.abs(_zoomx - _zoomxn);
    int y_diff=Math.abs(_zoomy - _zoomyn);
    graphics.drawRect(_zoomx - 15 - x_diff,_zoomy - 15 - y_diff,30 + x_diff * 2,30 + y_diff * 2);
    graphics.setPaintMode();
    if (pointinside) {
      double a=(double)(Math.abs(_zoomx - x)) / 30.0;
      double b=(double)(Math.abs(_zoomy - y)) / 30.0;
      double newx1=_xMax + (_xMax - _xMin) * a;
      double newx2=_xMin - (_xMax - _xMin) * a;
      if (newx1 > _xTop)       newx1=_xTop;
      if (newx2 < _xBottom)       newx2=_xBottom;
      double newy1=_yMax + (_yMax - _yMin) * b;
      double newy2=_yMin - (_yMax - _yMin) * b;
      if (newy1 > _yTop)       newy1=_yTop;
      if (newy2 < _yBottom)       newy2=_yBottom;
      setXRange(newx2,newx1);
      setYRange(newy2,newy1);
      drawPlot(true);
    }
    handled=true;
  }
  _drawn=false;
  _zoomin=_zoomout=false;
  _zoomxn=_zoomyn=_zoomx=_zoomy=-1;
  return handled;
}","/** 
 * Set the starting point for an interactive zoom box.
 * @deprecated As of JDK1.1 in java.awt.component but we need to compile under 1.0.2 for netscape3.x compatibility.
 */
public boolean mouseUp(Event evt,int x,int y){
  boolean pointinside=y <= _lry && y >= _uly && x <= _lrx && x >= _ulx;
  boolean handled=false;
  if ((_zoomin == true) && (_drawn == true)) {
    if (_zoomxn != -1 || _zoomyn != -1) {
      int minx=Math.min(_zoomx,_zoomxn);
      int maxx=Math.max(_zoomx,_zoomxn);
      int miny=Math.min(_zoomy,_zoomyn);
      int maxy=Math.max(_zoomy,_zoomyn);
      graphics.setXORMode(_background);
      graphics.drawRect(minx,miny,maxx - minx,maxy - miny);
      graphics.setPaintMode();
      if ((pointinside) && (Math.abs(_zoomx - x) > 5) && (Math.abs(_zoomy - y) > 5)) {
        double a=_xMin + (_zoomx - _ulx) / _xscale;
        double b=_xMin + (x - _ulx) / _xscale;
        if (a < b)         setXRange(a,b);
 else         setXRange(b,a);
        a=_yMax - (_zoomy - _uly) / _yscale;
        b=_yMax - (y - _uly) / _yscale;
        if (a < b)         setYRange(a,b);
 else         setYRange(b,a);
      }
      drawPlot(true);
      handled=true;
    }
  }
 else   if ((_zoomout == true) && (_drawn == true)) {
    graphics.setXORMode(_background);
    int x_diff=Math.abs(_zoomx - _zoomxn);
    int y_diff=Math.abs(_zoomy - _zoomyn);
    graphics.drawRect(_zoomx - 15 - x_diff,_zoomy - 15 - y_diff,30 + x_diff * 2,30 + y_diff * 2);
    graphics.setPaintMode();
    if (pointinside) {
      double a=(double)(Math.abs(_zoomx - x)) / 30.0;
      double b=(double)(Math.abs(_zoomy - y)) / 30.0;
      double newx1=_xMax + (_xMax - _xMin) * a;
      double newx2=_xMin - (_xMax - _xMin) * a;
      if (newx1 > _xTop)       newx1=_xTop;
      if (newx2 < _xBottom)       newx2=_xBottom;
      double newy1=_yMax + (_yMax - _yMin) * b;
      double newy2=_yMin - (_yMax - _yMin) * b;
      if (newy1 > _yTop)       newy1=_yTop;
      if (newy2 < _yBottom)       newy2=_yBottom;
      setXRange(newx2,newx1);
      setYRange(newy2,newy1);
      drawPlot(true);
    }
    handled=true;
  }
 else   if (_drawn == false) {
    drawPlot(true);
    handled=true;
  }
  _drawn=false;
  _zoomin=_zoomout=false;
  _zoomxn=_zoomyn=_zoomx=_zoomy=-1;
  return handled;
}"
76654,"/** 
 * Process the arguments and plot the data.
 */
public void pxgraph(String args[]){
  _plotApplet=new Plot();
  _makeButtons();
  pack();
  try {
    _parseArgs(args);
    _plotApplet.parseArgs(args);
  }
 catch (  CmdLineArgException e) {
    System.err.println(""String_Node_Str"" + e);
    System.exit(1);
  }
  show();
  _plotApplet.init();
  _plotApplet.start();
}","/** 
 * Process the arguments and plot the data.
 */
public void pxgraph(String args[]){
  _plotApplet=new Plot();
  _makeButtons();
  pack();
  add(_plotApplet);
  try {
    _parseArgs(args);
    _plotApplet.parseArgs(args);
  }
 catch (  CmdLineArgException e) {
    System.err.println(""String_Node_Str"" + e);
    System.exit(1);
  }
  show();
  _plotApplet.init();
  _plotApplet.start();
}"
76655,"/** 
 * Parse the command line arguments, do any preprocessing, then plot. If you have the <code>pxgraph</code> shell script, then  type <code>pxgraph -help</code> for the complete set of arguments.
 */
public static void main(String args[]){
  int argsread=0, i;
  Pxgraph pxgraph=new Pxgraph();
  pxgraph.pxgraph(args);
  if (_test) {
    if (_debug > 4)     System.out.println(""String_Node_Str"");
    try {
      Thread.currentThread().sleep(2000);
    }
 catch (    InterruptedException e) {
    }
    System.exit(0);
  }
}","/** 
 * Parse the command line arguments, do any preprocessing, then plot. If you have the <code>pxgraph</code> shell script, then  type <code>pxgraph -help</code> for the complete set of arguments.
 */
public static void main(String args[]){
  Pxgraph pxgraph=new Pxgraph();
  pxgraph.pxgraph(args);
  if (_test) {
    if (_debug > 4)     System.out.println(""String_Node_Str"");
    try {
      Thread.currentThread().sleep(2000);
    }
 catch (    InterruptedException e) {
    }
    System.exit(0);
  }
}"
76656,"/** 
 * Copy the alias pair values from the static alias pair list.
 */
public void aliasSet(){
  String name=this.getName();
  AliasPair aliasPair=(AliasPair)aliasPairList_.get(name);
  Port innerPort=(Port)aliasPair.getInnerAlias();
  Port outerPort=(Port)aliasPair.getOuterAlias();
}","/** 
 * Copy the alias pair values from the static alias pair list.
 */
public void aliasSet(){
  String name=this.getName();
  AliasPair aliasPair=(AliasPair)aliasPairList_.get(name);
  innerAlias_=(Port)aliasPair.getInnerAlias();
  outerAlias_=(Port)aliasPair.getOuterAlias();
}"
76657,"public Action.ActionResult changeHealthPoints(int n){
  if (healthPointsCurrent <= 0) {
    return Action.ActionResult.FAIL;
  }
  healthPointsCurrent=Math.min(Math.max(healthPointsCurrent + n,0),healthPointsMax);
  return Action.ActionResult.SUCCESS;
}","public void changeHealthPoints(int delta){
  healthPointsCurrent=Math.max(0,Math.min(healthPointsCurrent + delta,healthPointsMax));
}"
76658,"public Action.ActionResult changeActionPoints(int n){
  if (actionPointsCurrent + n < 0) {
    return Action.ActionResult.FAIL;
  }
  actionPointsCurrent=Math.min(actionPointsCurrent + n,actionPointsMax);
  return Action.ActionResult.SUCCESS;
}","public void changeActionPoints(int delta){
  actionPointsCurrent=Math.max(0,Math.min(actionPointsCurrent + delta,actionPointsMax));
}"
76659,"public Action.ActionResult zeroActionPoints(){
  actionPointsCurrent=0;
  return Action.ActionResult.SUCCESS;
}","public void zeroActionPoints(){
  actionPointsCurrent=0;
}"
76660,"/** 
 * Change (increase or decrease) amount of Health Points.
 * @param n Positive or negative delta for changing Health Points
 * @return ActionResult.SUCCESS or ActionResult.FAIL
 */
Action.ActionResult changeHealthPoints(int n);","/** 
 * Change (increase or decrease) amount of Health Points.
 * @param delta Positive or negative delta for changing Health Points
 */
void changeHealthPoints(int delta);"
76661,"/** 
 * Change (increase or decrease) amount of GenericAction Points.
 * @param n Positive or negative delta for changing GenericAction Points
 * @return ActionResult.SUCCESS or ActionResult.FAIL
 */
Action.ActionResult changeActionPoints(int n);","/** 
 * Change (increase or decrease) amount of GenericAction Points.
 * @param delta Positive or negative delta for changing GenericAction Points
 */
void changeActionPoints(int delta);"
76662,"/** 
 * Resets action points to zero. Useful for attacks (just like in Sid Meier's Civilization)
 * @return Action Result
 */
Action.ActionResult zeroActionPoints();","/** 
 * Sets action points to zero. Useful for attacks (just like in Sid Meier's Civilization)
 */
void zeroActionPoints();"
76663,"abstract ActionResult perform(@NotNull IUnit thisUnit,@Nullable IUnit targetUnit,@Nullable GenericItem item);","abstract public ActionResult perform(@NotNull IUnit thisUnit,@Nullable IUnit targetUnit,@Nullable GenericItem item);"
76664,"@Nullable static Action getAction(){
  return null;
}","@Nullable private static Action getAction(){
  return null;
}"
76665,"@Override public final ActionResult perform(@NotNull IUnit thisUnit,@NotNull IUnit targetUnit,@Nullable GenericItem item){
  ActionResult retval=ActionResult.SUCCESS;
  if (thisUnit.getHealthPoints() > 0 && targetUnit.getHealthPoints() > 0) {
    targetUnit.changeHealthPoints(thisUnit.getDamagePoints());
    thisUnit.zeroActionPoints();
    if (!thisUnit.getCanIgnoreCounterAttack() && targetUnit.getHealthPoints() > 0) {
      thisUnit.changeHealthPoints(targetUnit.getDamagePoints());
    }
  }
 else {
    retval=ActionResult.FAIL;
  }
  return retval;
}","@Override public final ActionResult perform(@NotNull IUnit thisUnit,@NotNull IUnit targetUnit,@Nullable GenericItem item){
  ActionResult retval=ActionResult.SUCCESS;
  if (targetUnit.getHealthPoints() > 0) {
    targetUnit.changeHealthPoints(-thisUnit.getDamagePoints());
    thisUnit.zeroActionPoints();
    if (!thisUnit.getCanIgnoreCounterAttack() && targetUnit.getHealthPoints() > 0) {
      thisUnit.changeHealthPoints(-targetUnit.getDamagePoints());
    }
  }
 else {
    retval=ActionResult.FAIL;
  }
  return retval;
}"
76666,"@Override public ActionResult perform(@NotNull IUnit thisUnit,@Nullable IUnit targetUnit,@Nullable GenericItem item){
  return ActionResult.SUCCESS;
}","@Override public ActionResult perform(@NotNull IUnit thisUnit,@Nullable IUnit targetUnit,@Nullable GenericItem item){
  ActionResult retval=ActionResult.SUCCESS;
  thisUnit.changeActionPoints(-1);
  return retval;
}"
76667,"@Override public ActionResult perform(@NotNull IUnit thisUnit,@Nullable IUnit targetUnit,@Nullable GenericItem item){
  return ActionResult.SUCCESS;
}","@Override public ActionResult perform(@NotNull IUnit thisUnit,@Nullable IUnit targetUnit,@Nullable GenericItem item){
  ActionResult retval=ActionResult.SUCCESS;
  thisUnit.changeActionPoints(-1);
  return retval;
}"
76668,"@Override public ActionResult perform(@NotNull IUnit thisUnit,@Nullable IUnit targetUnit,@Nullable GenericItem item){
  return ActionResult.SUCCESS;
}","@Override public ActionResult perform(@NotNull IUnit thisUnit,@Nullable IUnit targetUnit,@Nullable GenericItem item){
  ActionResult retval=ActionResult.SUCCESS;
  thisUnit.changeActionPoints(-1);
  return retval;
}"
76669,"@Override public Action.ActionResult changeHealthPoints(int n){
  return this.decorated.changeHealthPoints(n);
}","@Override public void changeHealthPoints(int delta){
  this.decorated.changeHealthPoints(delta);
}"
76670,"@Override public Action.ActionResult changeActionPoints(int n){
  return this.decorated.changeActionPoints(n);
}","@Override public void changeActionPoints(int delta){
  this.decorated.changeActionPoints(delta);
}"
76671,"@Override public Action.ActionResult zeroActionPoints(){
  return this.decorated.zeroActionPoints();
}","@Override public void zeroActionPoints(){
  this.decorated.zeroActionPoints();
}"
76672,"public View(){
  presenter=new Presenter();
}","public View(){
  controller=new Controller();
}"
76673,"@Override public String getReadyPacket(){
}","@Override public String getReadyPacket(){
  String toSend=""String_Node_Str"" + name + ""String_Node_Str""+ index+ ""String_Node_Str"";
  if (headNode != null) {
    if (headNode instanceof MISNode2D) {
      MISNode2D node2D=(MISNode2D)headNode;
      toSend+=""String_Node_Str"" + node2D.transform.positionX + ""String_Node_Str""+ node2D.transform.positionY+ ""String_Node_Str""+ node2D.transform.rotation+ ""String_Node_Str""+ node2D.transform.scaleX+ ""String_Node_Str""+ node2D.transform.scaleY;
    }
  }
  return toSend;
}"
76674,"/** 
 * Initialize the contents of the frame.
 */
private void initialize(MISScene scene){
  frame=new JFrame();
  frame.setIconImage(Toolkit.getDefaultToolkit().getImage(ApplicationWindow.class.getResource(""String_Node_Str"")));
  frame.setName(""String_Node_Str"" + MISProjectSettings.MIS_VERSION);
  frame.setTitle(""String_Node_Str"" + MISProjectSettings.MIS_VERSION);
  frame.setBounds(100,100,450,300);
  frame.setSize(1200,1000);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
  JMenuBar menuBar=new JMenuBar();
  frame.setJMenuBar(menuBar);
  JMenu mnNewMenu=new JMenu(""String_Node_Str"");
  menuBar.add(mnNewMenu);
  JMenuItem mntmSave=new JMenuItem(""String_Node_Str"");
  mnNewMenu.add(mntmSave);
  JMenuItem mntmLoadScene=new JMenuItem(""String_Node_Str"");
  mnNewMenu.add(mntmLoadScene);
  JMenuItem mntmNewProject=new JMenuItem(""String_Node_Str"");
  mnNewMenu.add(mntmNewProject);
  JMenuItem mntmProjectSettings=new JMenuItem(""String_Node_Str"");
  mnNewMenu.add(mntmProjectSettings);
  JMenuItem mntmBuildSettings=new JMenuItem(""String_Node_Str"");
  mnNewMenu.add(mntmBuildSettings);
  JMenuItem mntmRun=new JMenuItem(""String_Node_Str"");
  mnNewMenu.add(mntmRun);
  JMenuItem mntmBuild=new JMenuItem(""String_Node_Str"");
  mnNewMenu.add(mntmBuild);
  JMenuItem mntmQuit=new JMenuItem(""String_Node_Str"");
  mnNewMenu.add(mntmQuit);
  JMenu mnEdit=new JMenu(""String_Node_Str"");
  menuBar.add(mnEdit);
  JMenuItem mntmUndo=new JMenuItem(""String_Node_Str"");
  mnEdit.add(mntmUndo);
  JMenuItem mntmRedo=new JMenuItem(""String_Node_Str"");
  mnEdit.add(mntmRedo);
  JMenu mnWindow=new JMenu(""String_Node_Str"");
  menuBar.add(mnWindow);
  JMenuItem mntmConsole=new JMenuItem(""String_Node_Str"");
  mnWindow.add(mntmConsole);
  JMenu mnHelp=new JMenu(""String_Node_Str"");
  menuBar.add(mnHelp);
  JMenuItem mntmAbout=new JMenuItem(""String_Node_Str"");
  mnHelp.add(mntmAbout);
  JMenuItem mntmManual=new JMenuItem(""String_Node_Str"");
  mnHelp.add(mntmManual);
  JMenuItem mntmReportABug=new JMenuItem(""String_Node_Str"");
  mnHelp.add(mntmReportABug);
  JMenuItem mntmSuggestAnImprovement=new JMenuItem(""String_Node_Str"");
  mnHelp.add(mntmSuggestAnImprovement);
  JPanel MiddlePanel=new JPanel();
  MiddlePanel.setBorder(new TitledBorder(UIManager.getBorder(""String_Node_Str""),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.ABOVE_TOP,null,new Color(0,0,0)));
  createNodeList(scene);
  nodeList.setBackground(SystemColor.menu);
  rulesList=new JList();
  rulesList.setBorder(new TitledBorder(new TitledBorder(UIManager.getBorder(""String_Node_Str""),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,null,new Color(0,0,0)),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.ABOVE_TOP,null,new Color(0,0,0)));
  rulesList.setBackground(SystemColor.menu);
  JLabel lblNewLabel=new JLabel(""String_Node_Str"");
  lblNewLabel.setFont(new Font(""String_Node_Str"",Font.PLAIN,17));
  JScrollPane scrollPane=new JScrollPane();
  scrollPane.setViewportBorder(new TitledBorder(null,""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,null,null));
  GroupLayout groupLayout=new GroupLayout(frame.getContentPane());
  groupLayout.setHorizontalGroup(groupLayout.createParallelGroup(Alignment.LEADING).addGroup(groupLayout.createSequentialGroup().addContainerGap().addComponent(lblNewLabel).addContainerGap(1110,Short.MAX_VALUE)).addGroup(Alignment.TRAILING,groupLayout.createSequentialGroup().addContainerGap().addGroup(groupLayout.createParallelGroup(Alignment.TRAILING).addComponent(scrollPane,Alignment.LEADING,GroupLayout.DEFAULT_SIZE,1176,Short.MAX_VALUE).addGroup(groupLayout.createSequentialGroup().addComponent(nodeList,GroupLayout.PREFERRED_SIZE,309,GroupLayout.PREFERRED_SIZE).addPreferredGap(ComponentPlacement.RELATED).addComponent(MiddlePanel,GroupLayout.PREFERRED_SIZE,565,Short.MAX_VALUE).addPreferredGap(ComponentPlacement.UNRELATED).addComponent(rulesList,GroupLayout.PREFERRED_SIZE,276,GroupLayout.PREFERRED_SIZE).addPreferredGap(ComponentPlacement.RELATED))).addGap(28)));
  groupLayout.setVerticalGroup(groupLayout.createParallelGroup(Alignment.TRAILING).addGroup(groupLayout.createSequentialGroup().addGroup(groupLayout.createParallelGroup(Alignment.LEADING).addComponent(rulesList,GroupLayout.DEFAULT_SIZE,711,Short.MAX_VALUE).addComponent(nodeList,Alignment.TRAILING,GroupLayout.DEFAULT_SIZE,711,Short.MAX_VALUE).addComponent(MiddlePanel,GroupLayout.DEFAULT_SIZE,711,Short.MAX_VALUE)).addGap(11).addComponent(lblNewLabel).addPreferredGap(ComponentPlacement.RELATED).addComponent(scrollPane,GroupLayout.PREFERRED_SIZE,178,GroupLayout.PREFERRED_SIZE).addContainerGap()));
  JLabel lblNode=new JLabel(""String_Node_Str"");
  lblNode.setFont(new Font(""String_Node_Str"",Font.PLAIN,17));
  lblUserNode=new JLabel(""String_Node_Str"");
  lblUserNode.setFont(new Font(""String_Node_Str"",Font.PLAIN,11));
  JLabel lblScript=new JLabel(""String_Node_Str"");
  lblUserScript=new JLabel(""String_Node_Str"");
  JLabel lblParent=new JLabel(""String_Node_Str"");
  lblParent.setFont(new Font(""String_Node_Str"",Font.PLAIN,17));
  lblUserParent=new JLabel(""String_Node_Str"");
  lblUserParent.setFont(new Font(""String_Node_Str"",Font.PLAIN,11));
  JLabel lblType=new JLabel(""String_Node_Str"");
  lblType.setFont(new Font(""String_Node_Str"",Font.PLAIN,17));
  lblUserType=new JLabel(""String_Node_Str"");
  JLabel lblIndex=new JLabel(""String_Node_Str"");
  lblIndex.setFont(new Font(""String_Node_Str"",Font.PLAIN,17));
  lblUserIndex=new JLabel(""String_Node_Str"");
  lblUserIndex.setFont(new Font(""String_Node_Str"",Font.PLAIN,11));
  GroupLayout gl_MiddlePanel=new GroupLayout(MiddlePanel);
  gl_MiddlePanel.setHorizontalGroup(gl_MiddlePanel.createParallelGroup(Alignment.LEADING).addGroup(gl_MiddlePanel.createSequentialGroup().addContainerGap().addGroup(gl_MiddlePanel.createParallelGroup(Alignment.LEADING).addGroup(gl_MiddlePanel.createSequentialGroup().addGap(10).addComponent(lblScript).addPreferredGap(ComponentPlacement.RELATED).addComponent(lblUserScript,GroupLayout.DEFAULT_SIZE,384,Short.MAX_VALUE)).addGroup(gl_MiddlePanel.createSequentialGroup().addComponent(lblNode).addPreferredGap(ComponentPlacement.RELATED).addComponent(lblUserNode,GroupLayout.PREFERRED_SIZE,139,GroupLayout.PREFERRED_SIZE).addPreferredGap(ComponentPlacement.UNRELATED).addComponent(lblType).addPreferredGap(ComponentPlacement.RELATED).addComponent(lblUserType,GroupLayout.PREFERRED_SIZE,128,GroupLayout.PREFERRED_SIZE).addPreferredGap(ComponentPlacement.UNRELATED).addComponent(lblIndex)).addGroup(gl_MiddlePanel.createSequentialGroup().addComponent(lblParent).addPreferredGap(ComponentPlacement.RELATED).addComponent(lblUserParent,GroupLayout.DEFAULT_SIZE,372,Short.MAX_VALUE))).addGap(112)).addGroup(gl_MiddlePanel.createSequentialGroup().addGap(447).addComponent(lblUserIndex,GroupLayout.PREFERRED_SIZE,79,GroupLayout.PREFERRED_SIZE).addContainerGap(27,Short.MAX_VALUE)));
  gl_MiddlePanel.setVerticalGroup(gl_MiddlePanel.createParallelGroup(Alignment.LEADING).addGroup(gl_MiddlePanel.createSequentialGroup().addContainerGap().addGroup(gl_MiddlePanel.createParallelGroup(Alignment.BASELINE).addComponent(lblNode).addComponent(lblUserNode).addComponent(lblType).addComponent(lblUserType).addComponent(lblIndex).addComponent(lblUserIndex)).addPreferredGap(ComponentPlacement.RELATED,GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE).addGroup(gl_MiddlePanel.createParallelGroup(Alignment.BASELINE).addComponent(lblScript).addComponent(lblUserScript)).addGap(18).addGroup(gl_MiddlePanel.createParallelGroup(Alignment.BASELINE).addComponent(lblParent).addComponent(lblUserParent)).addGap(591)));
  MiddlePanel.setLayout(gl_MiddlePanel);
  textPaneConsole=new JTextPane();
  textPaneConsole.setFont(new Font(""String_Node_Str"",Font.PLAIN,11));
  textPaneConsole.setBackground(SystemColor.menu);
  scrollPane.setViewportView(textPaneConsole);
  frame.getContentPane().setLayout(groupLayout);
}","/** 
 * Initialize the contents of the frame.
 */
private void initialize(MISScene scene){
  frame=new JFrame();
  frame.setIconImage(Toolkit.getDefaultToolkit().getImage(ApplicationWindow.class.getResource(""String_Node_Str"")));
  frame.setName(""String_Node_Str"" + MISProjectSettings.MIS_VERSION);
  frame.setTitle(""String_Node_Str"" + MISProjectSettings.MIS_VERSION);
  frame.setBounds(100,100,450,300);
  frame.setSize(1200,1000);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
  JMenuBar menuBar=new JMenuBar();
  frame.setJMenuBar(menuBar);
  mnFile=new JMenu(""String_Node_Str"");
  menuBar.add(mnFile);
  mntmSave=new JMenuItem(""String_Node_Str"");
  mnFile.add(mntmSave);
  mntmLoadScene=new JMenuItem(""String_Node_Str"");
  mnFile.add(mntmLoadScene);
  mntmNewProject=new JMenuItem(""String_Node_Str"");
  mnFile.add(mntmNewProject);
  mntmProjectSettings=new JMenuItem(""String_Node_Str"");
  mnFile.add(mntmProjectSettings);
  mntmBuildSettings=new JMenuItem(""String_Node_Str"");
  mnFile.add(mntmBuildSettings);
  mntmRun=new JMenuItem(""String_Node_Str"");
  mnFile.add(mntmRun);
  mntmBuild=new JMenuItem(""String_Node_Str"");
  mnFile.add(mntmBuild);
  mntmQuit=new JMenuItem(""String_Node_Str"");
  mnFile.add(mntmQuit);
  mnEdit=new JMenu(""String_Node_Str"");
  menuBar.add(mnEdit);
  mntmUndo=new JMenuItem(""String_Node_Str"");
  mnEdit.add(mntmUndo);
  mntmRedo=new JMenuItem(""String_Node_Str"");
  mnEdit.add(mntmRedo);
  mnWindow=new JMenu(""String_Node_Str"");
  menuBar.add(mnWindow);
  mntmConsole=new JMenuItem(""String_Node_Str"");
  mnWindow.add(mntmConsole);
  mnHelp=new JMenu(""String_Node_Str"");
  menuBar.add(mnHelp);
  mntmAbout=new JMenuItem(""String_Node_Str"");
  mnHelp.add(mntmAbout);
  mntmManual=new JMenuItem(""String_Node_Str"");
  mnHelp.add(mntmManual);
  mntmReportABug=new JMenuItem(""String_Node_Str"");
  mnHelp.add(mntmReportABug);
  mntmSuggestAnImprovement=new JMenuItem(""String_Node_Str"");
  mnHelp.add(mntmSuggestAnImprovement);
  JPanel MiddlePanel=new JPanel();
  MiddlePanel.setBorder(new TitledBorder(UIManager.getBorder(""String_Node_Str""),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.ABOVE_TOP,null,new Color(0,0,0)));
  createNodeList(scene);
  nodeList.setBackground(SystemColor.menu);
  rulesList=new JList();
  rulesList.setBorder(new TitledBorder(new TitledBorder(UIManager.getBorder(""String_Node_Str""),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,null,new Color(0,0,0)),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.ABOVE_TOP,null,new Color(0,0,0)));
  rulesList.setBackground(SystemColor.menu);
  JLabel lblNewLabel=new JLabel(""String_Node_Str"");
  lblNewLabel.setFont(new Font(""String_Node_Str"",Font.PLAIN,17));
  JScrollPane scrollPane=new JScrollPane();
  scrollPane.setViewportBorder(new TitledBorder(null,""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,null,null));
  GroupLayout groupLayout=new GroupLayout(frame.getContentPane());
  groupLayout.setHorizontalGroup(groupLayout.createParallelGroup(Alignment.LEADING).addGroup(groupLayout.createSequentialGroup().addContainerGap().addComponent(lblNewLabel).addContainerGap(1110,Short.MAX_VALUE)).addGroup(Alignment.TRAILING,groupLayout.createSequentialGroup().addContainerGap().addGroup(groupLayout.createParallelGroup(Alignment.TRAILING).addComponent(scrollPane,Alignment.LEADING,GroupLayout.DEFAULT_SIZE,1176,Short.MAX_VALUE).addGroup(groupLayout.createSequentialGroup().addComponent(nodeList,GroupLayout.PREFERRED_SIZE,309,GroupLayout.PREFERRED_SIZE).addPreferredGap(ComponentPlacement.RELATED).addComponent(MiddlePanel,GroupLayout.PREFERRED_SIZE,565,Short.MAX_VALUE).addPreferredGap(ComponentPlacement.UNRELATED).addComponent(rulesList,GroupLayout.PREFERRED_SIZE,276,GroupLayout.PREFERRED_SIZE).addPreferredGap(ComponentPlacement.RELATED))).addGap(28)));
  groupLayout.setVerticalGroup(groupLayout.createParallelGroup(Alignment.TRAILING).addGroup(groupLayout.createSequentialGroup().addGroup(groupLayout.createParallelGroup(Alignment.LEADING).addComponent(rulesList,GroupLayout.DEFAULT_SIZE,711,Short.MAX_VALUE).addComponent(nodeList,Alignment.TRAILING,GroupLayout.DEFAULT_SIZE,711,Short.MAX_VALUE).addComponent(MiddlePanel,GroupLayout.DEFAULT_SIZE,711,Short.MAX_VALUE)).addGap(11).addComponent(lblNewLabel).addPreferredGap(ComponentPlacement.RELATED).addComponent(scrollPane,GroupLayout.PREFERRED_SIZE,178,GroupLayout.PREFERRED_SIZE).addContainerGap()));
  JLabel lblNode=new JLabel(""String_Node_Str"");
  lblNode.setFont(new Font(""String_Node_Str"",Font.PLAIN,17));
  lblUserNode=new JLabel(""String_Node_Str"");
  lblUserNode.setFont(new Font(""String_Node_Str"",Font.PLAIN,11));
  JLabel lblScript=new JLabel(""String_Node_Str"");
  lblUserScript=new JLabel(""String_Node_Str"");
  JLabel lblParent=new JLabel(""String_Node_Str"");
  lblParent.setFont(new Font(""String_Node_Str"",Font.PLAIN,17));
  lblUserParent=new JLabel(""String_Node_Str"");
  lblUserParent.setFont(new Font(""String_Node_Str"",Font.PLAIN,11));
  JLabel lblType=new JLabel(""String_Node_Str"");
  lblType.setFont(new Font(""String_Node_Str"",Font.PLAIN,17));
  lblUserType=new JLabel(""String_Node_Str"");
  JLabel lblIndex=new JLabel(""String_Node_Str"");
  lblIndex.setFont(new Font(""String_Node_Str"",Font.PLAIN,17));
  lblUserIndex=new JLabel(""String_Node_Str"");
  lblUserIndex.setFont(new Font(""String_Node_Str"",Font.PLAIN,11));
  GroupLayout gl_MiddlePanel=new GroupLayout(MiddlePanel);
  gl_MiddlePanel.setHorizontalGroup(gl_MiddlePanel.createParallelGroup(Alignment.LEADING).addGroup(gl_MiddlePanel.createSequentialGroup().addContainerGap().addGroup(gl_MiddlePanel.createParallelGroup(Alignment.LEADING).addGroup(gl_MiddlePanel.createSequentialGroup().addGap(10).addComponent(lblScript).addPreferredGap(ComponentPlacement.RELATED).addComponent(lblUserScript,GroupLayout.DEFAULT_SIZE,384,Short.MAX_VALUE)).addGroup(gl_MiddlePanel.createSequentialGroup().addComponent(lblNode).addPreferredGap(ComponentPlacement.RELATED).addComponent(lblUserNode,GroupLayout.PREFERRED_SIZE,139,GroupLayout.PREFERRED_SIZE).addPreferredGap(ComponentPlacement.UNRELATED).addComponent(lblType).addPreferredGap(ComponentPlacement.RELATED).addComponent(lblUserType,GroupLayout.PREFERRED_SIZE,128,GroupLayout.PREFERRED_SIZE).addPreferredGap(ComponentPlacement.UNRELATED).addComponent(lblIndex)).addGroup(gl_MiddlePanel.createSequentialGroup().addComponent(lblParent).addPreferredGap(ComponentPlacement.RELATED).addComponent(lblUserParent,GroupLayout.DEFAULT_SIZE,372,Short.MAX_VALUE))).addGap(112)).addGroup(gl_MiddlePanel.createSequentialGroup().addGap(447).addComponent(lblUserIndex,GroupLayout.PREFERRED_SIZE,79,GroupLayout.PREFERRED_SIZE).addContainerGap(27,Short.MAX_VALUE)));
  gl_MiddlePanel.setVerticalGroup(gl_MiddlePanel.createParallelGroup(Alignment.LEADING).addGroup(gl_MiddlePanel.createSequentialGroup().addContainerGap().addGroup(gl_MiddlePanel.createParallelGroup(Alignment.BASELINE).addComponent(lblNode).addComponent(lblUserNode).addComponent(lblType).addComponent(lblUserType).addComponent(lblIndex).addComponent(lblUserIndex)).addPreferredGap(ComponentPlacement.RELATED,GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE).addGroup(gl_MiddlePanel.createParallelGroup(Alignment.BASELINE).addComponent(lblScript).addComponent(lblUserScript)).addGap(18).addGroup(gl_MiddlePanel.createParallelGroup(Alignment.BASELINE).addComponent(lblParent).addComponent(lblUserParent)).addGap(591)));
  MiddlePanel.setLayout(gl_MiddlePanel);
  textPaneConsole=new JTextPane();
  textPaneConsole.setFont(new Font(""String_Node_Str"",Font.PLAIN,11));
  textPaneConsole.setBackground(SystemColor.menu);
  scrollPane.setViewportView(textPaneConsole);
  frame.getContentPane().setLayout(groupLayout);
}"
76675,"private void handleEvents(){
  nodeList.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent arg0){
      if (SwingUtilities.isRightMouseButton(arg0)) {
        nodeList.setSelectedIndex(nodeList.locationToIndex(arg0.getPoint()));
        JPopupMenu menu=new JPopupMenu();
        JMenuItem show=new JMenuItem(""String_Node_Str"");
        show.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            showNode(nodeList.getSelectedValue());
            addTextToConsole(""String_Node_Str"" + nodeList.getSelectedIndex());
          }
        }
);
        JMenuItem remove=new JMenuItem(""String_Node_Str"");
        remove.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            addTextToConsole(""String_Node_Str"" + nodeList.getSelectedIndex());
          }
        }
);
        JMenuItem addRule=new JMenuItem(""String_Node_Str"");
        addRule.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            addTextToConsole(""String_Node_Str"" + nodeList.getSelectedIndex());
          }
        }
);
        menu.add(show);
        menu.add(remove);
        menu.show(nodeList,arg0.getPoint().x,arg0.getPoint().y);
      }
 else       if (SwingUtilities.isLeftMouseButton(arg0)) {
        showNode(nodeList.getSelectedValue());
        addTextToConsole(""String_Node_Str"" + nodeList.getSelectedIndex());
      }
    }
  }
);
  rulesList.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent arg0){
      if (SwingUtilities.isRightMouseButton(arg0)) {
        rulesList.setSelectedIndex(rulesList.locationToIndex(arg0.getPoint()));
        JPopupMenu menu=new JPopupMenu();
        JMenuItem show=new JMenuItem(""String_Node_Str"");
        show.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            addTextToConsole(""String_Node_Str"" + rulesList.getSelectedIndex());
          }
        }
);
        JMenuItem remove=new JMenuItem(""String_Node_Str"");
        remove.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            addTextToConsole(""String_Node_Str"" + rulesList.getSelectedIndex());
          }
        }
);
        menu.add(show);
        menu.add(remove);
        menu.show(rulesList,arg0.getPoint().x,arg0.getPoint().y);
      }
    }
  }
);
}","private void handleEvents(){
  nodeList.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent arg0){
      if (SwingUtilities.isRightMouseButton(arg0)) {
        nodeList.setSelectedIndex(nodeList.locationToIndex(arg0.getPoint()));
        JPopupMenu menu=new JPopupMenu();
        JMenuItem show=new JMenuItem(""String_Node_Str"");
        show.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            showNode(nodeList.getSelectedValue());
            addTextToConsole(""String_Node_Str"" + nodeList.getSelectedIndex());
          }
        }
);
        JMenuItem remove=new JMenuItem(""String_Node_Str"");
        remove.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            addTextToConsole(""String_Node_Str"" + nodeList.getSelectedIndex());
          }
        }
);
        JMenuItem addRule=new JMenuItem(""String_Node_Str"");
        addRule.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            addTextToConsole(""String_Node_Str"" + nodeList.getSelectedIndex());
          }
        }
);
        menu.add(show);
        menu.add(remove);
        menu.show(nodeList,arg0.getPoint().x,arg0.getPoint().y);
      }
 else       if (SwingUtilities.isLeftMouseButton(arg0)) {
        showNode(nodeList.getSelectedValue());
        addTextToConsole(""String_Node_Str"" + nodeList.getSelectedIndex());
      }
    }
  }
);
  rulesList.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent arg0){
      if (SwingUtilities.isRightMouseButton(arg0)) {
        rulesList.setSelectedIndex(rulesList.locationToIndex(arg0.getPoint()));
        JPopupMenu menu=new JPopupMenu();
        JMenuItem show=new JMenuItem(""String_Node_Str"");
        show.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            addTextToConsole(""String_Node_Str"" + rulesList.getSelectedIndex());
          }
        }
);
        JMenuItem remove=new JMenuItem(""String_Node_Str"");
        remove.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            addTextToConsole(""String_Node_Str"" + rulesList.getSelectedIndex());
          }
        }
);
        menu.add(show);
        menu.add(remove);
        menu.show(rulesList,arg0.getPoint().x,arg0.getPoint().y);
      }
    }
  }
);
  mntmSave.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent arg0){
      if (wasChanged) {
        MISProject.saveProject();
        mntmSave.setEnabled(false);
        wasChanged=false;
        mnFile.getPopupMenu().setVisible(false);
      }
    }
  }
);
  mntmLoadScene.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      String[] possiblities=new String[MISProject.project.scenes.size()];
      for (int i=0; i < possiblities.length; i++) {
        possiblities[i]=MISProject.project.scenes.get(i).name;
      }
      if (possiblities.length > 0) {
        String s=(String)JOptionPane.showInputDialog(frame,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,possiblities,possiblities[0]);
        if ((s != null) && (s.length() > 0)) {
          MISScene scene=null;
          for (int i=0; i < possiblities.length; i++) {
            if (possiblities[i].equals(s)) {
              scene=MISProject.project.scenes.get(i);
              break;
            }
          }
          if (scene != null) {
            createNodeList(scene);
          }
        }
      }
    }
  }
);
  mntmNewProject.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      MISProject.saveProject();
      mntmSave.setEnabled(false);
      wasChanged=false;
      mnFile.getPopupMenu().setVisible(false);
      frame.dispose();
      String[] args={};
      ApplicationWindow.main(args);
    }
  }
);
  mntmProjectSettings.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      mnFile.getPopupMenu().setVisible(false);
    }
  }
);
  mntmBuildSettings.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      mnFile.getPopupMenu().setVisible(false);
    }
  }
);
  mntmRun.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      mnFile.getPopupMenu().setVisible(false);
    }
  }
);
  mntmBuild.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      mnFile.getPopupMenu().setVisible(false);
    }
  }
);
  mntmQuit.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      MISProject.saveProject();
      mntmSave.setEnabled(false);
      wasChanged=false;
      mnFile.getPopupMenu().setVisible(false);
      int dialogResult=JOptionPane.showConfirmDialog(null,""String_Node_Str"");
      if (dialogResult == JOptionPane.YES_OPTION) {
        frame.dispose();
      }
    }
  }
);
  mntmUndo.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      mnEdit.getPopupMenu().setVisible(false);
    }
  }
);
  mntmRedo.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      mnEdit.getPopupMenu().setVisible(false);
    }
  }
);
  mntmConsole.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      mnWindow.getPopupMenu().setVisible(false);
    }
  }
);
  mntmAbout.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      mnHelp.getPopupMenu().setVisible(false);
    }
  }
);
  mntmManual.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      mnHelp.getPopupMenu().setVisible(false);
    }
  }
);
  mntmReportABug.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      mnHelp.getPopupMenu().setVisible(false);
    }
  }
);
  mntmSuggestAnImprovement.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      mnHelp.getPopupMenu().setVisible(false);
    }
  }
);
}"
76676,"/** 
 * Creates a TextView that represents a list item
 * @param pMarkdownList MarkdownList used to determine the kind of list
 * @param pText Content of the list item
 * @param pIndex Index of the item in the list
 * @return Returns a TextView
 */
private TextView getTextView(final MarkdownList pMarkdownList,final CharSequence pText,final int pIndex){
  final TextView textView=new TextView(mContext,null,R.attr.MarkdownListStyle);
  textView.setMovementMethod(LinkMovementMethod.getInstance());
  if (pMarkdownList.isOrdered()) {
    textView.setText(String.format(Locale.getDefault(),""String_Node_Str"",pIndex + 1,pText));
  }
 else {
    Drawable bullet=mContext.getResources().getDrawable(getDrawable(pMarkdownList.getNestedLevel()));
    TopCompoundDrawable gravityDrawable=new TopCompoundDrawable(bullet,textView.getLineHeight());
    bullet.setBounds(0,0,bullet.getIntrinsicWidth(),bullet.getIntrinsicHeight());
    gravityDrawable.setBounds(0,0,bullet.getIntrinsicWidth(),bullet.getIntrinsicHeight());
    textView.setCompoundDrawables(gravityDrawable,null,null,null);
    textView.setCompoundDrawablePadding(mIndicatorSpacingPixels);
    textView.setText(pText);
  }
  return textView;
}","/** 
 * Creates a TextView that represents a list item
 * @param pMarkDownList MarkDownList used to determine the kind of list
 * @param pText Content of the list item
 * @param pIndex Index of the item in the list
 * @return Returns a TextView
 */
private TextView getTextView(final MarkdownList pMarkDownList,final CharSequence pText,final int pIndex){
  final TextView textView=new TextView(mContext,null,R.attr.MarkdownListStyle);
  textView.setMovementMethod(LinkMovementMethod.getInstance());
  if (pMarkDownList.isOrdered()) {
    SpannableString string=new SpannableString(pText);
    string.setSpan(new NumberSpan(mListMargin,pIndex + 1),0,string.length(),Spanned.SPAN_INCLUSIVE_INCLUSIVE);
    textView.setText(string);
  }
 else {
    final Drawable drawable=mContext.getResources().getDrawable(getDrawable(pMarkDownList.getNestedLevel()));
    SpannableString string=new SpannableString(pText);
    string.setSpan(new BulletSpan(mListMargin,drawable),0,string.length(),Spanned.SPAN_INCLUSIVE_INCLUSIVE);
    textView.setText(string);
  }
  return textView;
}"
76677,"@Override public View create(final MarkdownList pMarkdownItem,final InlineConverter<Spanned> pInlineConverter){
  return createLayout(pMarkdownItem,pInlineConverter);
}","@Override public View create(final MarkdownList pMarkDownItem,final InlineConverter<Spanned> pInlineConverter){
  return createLayout(pMarkDownItem,pInlineConverter);
}"
76678,"private LinearLayout createLayout(final MarkdownList pMarkdownItem,final InlineConverter<Spanned> pInlineConverter){
  LinearLayout layout=new LinearLayout(mContext);
  layout.setLayoutParams(new LayoutParams(MATCH_PARENT,WRAP_CONTENT));
  layout.setOrientation(LinearLayout.VERTICAL);
  final List<ListItem> items=pMarkdownItem.getListItems();
  for (int i=0; i < items.size(); i++) {
    final ListItem item=items.get(i);
    final View view=getTextView(pMarkdownItem,pInlineConverter.convert(item.getText()),i);
    layout.addView(view);
    if (item.hasChild()) {
      for (      MarkdownList list : item.getChild()) {
        final LinearLayout nestedLayout=createLayout(list,pInlineConverter);
        LayoutParams params=new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT);
        params.setMargins(mIndentationSpacingPixels,0,0,0);
        nestedLayout.setLayoutParams(params);
        layout.addView(nestedLayout);
      }
    }
  }
  return layout;
}","private LinearLayout createLayout(final MarkdownList pMarkDownItem,final InlineConverter<Spanned> pInlineConverter){
  LinearLayout layout=new LinearLayout(mContext);
  layout.setLayoutParams(new LayoutParams(MATCH_PARENT,WRAP_CONTENT));
  layout.setOrientation(LinearLayout.VERTICAL);
  final List<ListItem> items=pMarkDownItem.getListItems();
  for (int i=0; i < items.size(); i++) {
    final ListItem item=items.get(i);
    final View view=getTextView(pMarkDownItem,pInlineConverter.convert(item.getText()),i);
    layout.addView(view);
    if (item.hasChild()) {
      for (      MarkdownList list : item.getChild()) {
        final LinearLayout nestedLayout=createLayout(list,pInlineConverter);
        nestedLayout.setPadding(mListMargin,0,0,0);
        layout.addView(nestedLayout);
      }
    }
  }
  return layout;
}"
76679,"public ListDisplayItem(final Context pContext,@DimenRes final int pIndentationSpacing,@DimenRes final int pBulletSpacing,@DrawableRes final int[] pBulletDrawables){
  mContext=pContext;
  mIndicatorSpacingPixels=mContext.getResources().getDimensionPixelSize(pBulletSpacing);
  mIndentationSpacingPixels=mContext.getResources().getDimensionPixelSize(pIndentationSpacing);
  mBulletDrawables=pBulletDrawables;
}","public ListDisplayItem(final Context pContext,@DimenRes final int pListMargin,@DrawableRes final int[] pBulletDrawables){
  mContext=pContext;
  mListMargin=mContext.getResources().getDimensionPixelSize(pListMargin);
  mBulletDrawables=pBulletDrawables;
}"
76680,"/** 
 * Creates a TextView that represents a list item
 * @param pMarkdownList MarkdownList used to determine the kind of list
 * @param pText Content of the list item
 * @param pIndex Index of the item in the list
 * @return Returns a TextView
 */
private TextView getTextView(final MarkdownList pMarkdownList,final CharSequence pText,final int pIndex){
  final TextView textView=new TextView(mContext,null,R.attr.MarkdownListStyle);
  textView.setMovementMethod(LinkMovementMethod.getInstance());
  if (pMarkdownList.isOrdered()) {
    textView.setText(String.format(Locale.getDefault(),""String_Node_Str"",pIndex + 1,pText));
  }
 else {
    Drawable bullet=mContext.getResources().getDrawable(getDrawable(pMarkdownList.getNestedLevel()));
    TopCompoundDrawable gravityDrawable=new TopCompoundDrawable(bullet,textView.getLineHeight());
    bullet.setBounds(0,0,bullet.getIntrinsicWidth(),bullet.getIntrinsicHeight());
    gravityDrawable.setBounds(0,0,bullet.getIntrinsicWidth(),bullet.getIntrinsicHeight());
    textView.setCompoundDrawables(gravityDrawable,null,null,null);
    textView.setCompoundDrawablePadding(mIndicatorSpacingPixels);
    textView.setText(pText);
  }
  return textView;
}","/** 
 * Creates a TextView that represents a list item
 * @param pMarkDownList MarkDownList used to determine the kind of list
 * @param pText Content of the list item
 * @param pIndex Index of the item in the list
 * @return Returns a TextView
 */
private TextView getTextView(final MarkdownList pMarkDownList,final CharSequence pText,final int pIndex){
  final TextView textView=new TextView(mContext,null,R.attr.MarkdownListStyle);
  textView.setMovementMethod(LinkMovementMethod.getInstance());
  if (pMarkDownList.isOrdered()) {
    SpannableString string=new SpannableString(pText);
    string.setSpan(new NumberSpan(mListMargin,pIndex + 1),0,string.length(),Spanned.SPAN_INCLUSIVE_INCLUSIVE);
    textView.setText(string);
  }
 else {
    final Drawable drawable=mContext.getResources().getDrawable(getDrawable(pMarkDownList.getNestedLevel()));
    SpannableString string=new SpannableString(pText);
    string.setSpan(new BulletSpan(mListMargin,drawable),0,string.length(),Spanned.SPAN_INCLUSIVE_INCLUSIVE);
    textView.setText(string);
  }
  return textView;
}"
76681,"@Override public View create(final MarkdownList pMarkdownItem,final InlineConverter<Spanned> pInlineConverter){
  return createLayout(pMarkdownItem,pInlineConverter);
}","@Override public View create(final MarkdownList pMarkDownItem,final InlineConverter<Spanned> pInlineConverter){
  return createLayout(pMarkDownItem,pInlineConverter);
}"
76682,"private LinearLayout createLayout(final MarkdownList pMarkdownItem,final InlineConverter<Spanned> pInlineConverter){
  LinearLayout layout=new LinearLayout(mContext);
  layout.setLayoutParams(new LayoutParams(MATCH_PARENT,WRAP_CONTENT));
  layout.setOrientation(LinearLayout.VERTICAL);
  final List<ListItem> items=pMarkdownItem.getListItems();
  for (int i=0; i < items.size(); i++) {
    final ListItem item=items.get(i);
    final View view=getTextView(pMarkdownItem,pInlineConverter.convert(item.getText()),i);
    layout.addView(view);
    if (item.hasChild()) {
      for (      MarkdownList list : item.getChild()) {
        final LinearLayout nestedLayout=createLayout(list,pInlineConverter);
        LayoutParams params=new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT);
        params.setMargins(mIndentationSpacingPixels,0,0,0);
        nestedLayout.setLayoutParams(params);
        layout.addView(nestedLayout);
      }
    }
  }
  return layout;
}","private LinearLayout createLayout(final MarkdownList pMarkDownItem,final InlineConverter<Spanned> pInlineConverter){
  LinearLayout layout=new LinearLayout(mContext);
  layout.setLayoutParams(new LayoutParams(MATCH_PARENT,WRAP_CONTENT));
  layout.setOrientation(LinearLayout.VERTICAL);
  final List<ListItem> items=pMarkDownItem.getListItems();
  for (int i=0; i < items.size(); i++) {
    final ListItem item=items.get(i);
    final View view=getTextView(pMarkDownItem,pInlineConverter.convert(item.getText()),i);
    layout.addView(view);
    if (item.hasChild()) {
      for (      MarkdownList list : item.getChild()) {
        final LinearLayout nestedLayout=createLayout(list,pInlineConverter);
        nestedLayout.setPadding(mListMargin,0,0,0);
        layout.addView(nestedLayout);
      }
    }
  }
  return layout;
}"
76683,"public ListDisplayItem(final Context pContext,@DimenRes final int pIndentationSpacing,@DimenRes final int pBulletSpacing,@DrawableRes final int[] pBulletDrawables){
  mContext=pContext;
  mIndicatorSpacingPixels=mContext.getResources().getDimensionPixelSize(pBulletSpacing);
  mIndentationSpacingPixels=mContext.getResources().getDimensionPixelSize(pIndentationSpacing);
  mBulletDrawables=pBulletDrawables;
}","public ListDisplayItem(final Context pContext,@DimenRes final int pListMargin,@DrawableRes final int[] pBulletDrawables){
  mContext=pContext;
  mListMargin=mContext.getResources().getDimensionPixelSize(pListMargin);
  mBulletDrawables=pBulletDrawables;
}"
76684,"/** 
 * Creates a MarkyMark instance that converts the rules provided by the flavor into MarkyMarkAndroid Views
 * @param pContext            Context used to create Views
 * @param pFlavor             Flavor that provides the markdown parsing rules
 * @param pDisplayItems       Extra DisplayItems (replaces DisplayItems that render the same MarkdownItem}
 * @param pInlineDisplayItems Extra InlineDisplayItems (replaces InlineDisplayItems that render the same MarkdownItem}
 * @param imageLoader         The ImageLoader that should be used to load images
 * @return MarkMark instance that renders MarkyMarkAndroid Views from Markdown
 */
public static MarkyMark<View> getMarkyMark(final Context pContext,final Flavor pFlavor,@Nullable final List<DisplayItem> pDisplayItems,@Nullable final List<InlineDisplayItem> pInlineDisplayItems,@NonNull ImageLoader imageLoader){
  Converter<View> viewConverter=new Converter<>();
  InlineConverter<Spanned> inlineConverter=new InlineConverter<>();
  inlineConverter.addMapping(new BoldInlineDisplayItem());
  inlineConverter.addMapping(new StringInlineDisplayItem());
  inlineConverter.addMapping(new TextDisplayItem());
  inlineConverter.addMapping(new StrikeInlineDisplayItem());
  inlineConverter.addMapping(new ItalicInlineDisplayItem());
  inlineConverter.addMapping(new LinkInlineDisplayItem());
  inlineConverter.addMapping(new CodeInlineDisplayItem());
  final ThemedContext context=new ThemedContext(pContext);
  viewConverter.addMapping(new HeaderDisplayItem(context));
  viewConverter.addMapping(new ParagraphDisplayItem(context));
  viewConverter.addMapping(new HorizontalRuleDisplayItem(context));
  viewConverter.addMapping(new ListDisplayItem(context,R.dimen.list_indentation_spacing,R.dimen.list_indicator_spacing,new int[]{R.drawable.bullet_filled,R.drawable.bullet,R.drawable.dash,R.drawable.square}));
  viewConverter.addMapping(new QuoteDisplayItem(context));
  viewConverter.addMapping(new CodeBlockDisplayItem(context));
  viewConverter.addMapping(new ImageDisplayItem(context,imageLoader));
  if (pInlineDisplayItems != null) {
    for (    InlineDisplayItem item : pInlineDisplayItems) {
      inlineConverter.addMapping(item);
    }
  }
  if (pDisplayItems != null) {
    for (    DisplayItem item : pDisplayItems) {
      viewConverter.addMapping(item);
    }
  }
  return new MarkyMark.Builder<View>().addFlavor(pFlavor).setConverter(viewConverter).setInlineConverter(inlineConverter).build();
}","/** 
 * Creates a MarkyMark instance that converts the rules provided by the flavor into MarkyMarkAndroid Views
 * @param pContext            Context used to create Views
 * @param pFlavor             Flavor that provides the markdown parsing rules
 * @param pDisplayItems       Extra DisplayItems (replaces DisplayItems that render the same MarkdownItem}
 * @param pInlineDisplayItems Extra InlineDisplayItems (replaces InlineDisplayItems that render the same MarkdownItem}
 * @param imageLoader         The ImageLoader that should be used to load images
 * @return MarkMark instance that renders MarkyMarkAndroid Views from Markdown
 */
public static MarkyMark<View> getMarkyMark(final Context pContext,final Flavor pFlavor,@Nullable final List<DisplayItem> pDisplayItems,@Nullable final List<InlineDisplayItem> pInlineDisplayItems,@NonNull ImageLoader imageLoader){
  Converter<View> viewConverter=new Converter<>();
  InlineConverter<Spanned> inlineConverter=new InlineConverter<>();
  inlineConverter.addMapping(new BoldInlineDisplayItem());
  inlineConverter.addMapping(new StringInlineDisplayItem());
  inlineConverter.addMapping(new TextDisplayItem());
  inlineConverter.addMapping(new StrikeInlineDisplayItem());
  inlineConverter.addMapping(new ItalicInlineDisplayItem());
  inlineConverter.addMapping(new LinkInlineDisplayItem());
  inlineConverter.addMapping(new CodeInlineDisplayItem());
  final ThemedContext context=new ThemedContext(pContext);
  viewConverter.addMapping(new HeaderDisplayItem(context));
  viewConverter.addMapping(new ParagraphDisplayItem(context));
  viewConverter.addMapping(new HorizontalRuleDisplayItem(context));
  viewConverter.addMapping(new ListDisplayItem(context,R.dimen.list_margin,new int[]{R.drawable.bullet_filled,R.drawable.bullet,R.drawable.dash,R.drawable.square}));
  viewConverter.addMapping(new QuoteDisplayItem(context));
  viewConverter.addMapping(new CodeBlockDisplayItem(context));
  viewConverter.addMapping(new ImageDisplayItem(context,imageLoader));
  if (pInlineDisplayItems != null) {
    for (    InlineDisplayItem item : pInlineDisplayItems) {
      inlineConverter.addMapping(item);
    }
  }
  if (pDisplayItems != null) {
    for (    DisplayItem item : pDisplayItems) {
      viewConverter.addMapping(item);
    }
  }
  return new MarkyMark.Builder<View>().addFlavor(pFlavor).setConverter(viewConverter).setInlineConverter(inlineConverter).build();
}"
76685,"/** 
 * Creates a TextView that represents a list item
 * @param pMarkDownList MarkDownList used to determine the kind of list
 * @param pText Content of the list item
 * @param pIndex Index of the item in the list
 * @return Returns a TextView
 */
private TextView getTextView(final MarkDownList pMarkDownList,final CharSequence pText,final int pIndex){
  final TextView textView=new TextView(mContext,null,R.attr.MarkDownListStyle);
  textView.setMovementMethod(LinkMovementMethod.getInstance());
  if (pMarkDownList.isOrdered()) {
    textView.setText(String.format(Locale.getDefault(),""String_Node_Str"",pIndex + 1,pText));
  }
 else {
    Drawable bullet=mContext.getResources().getDrawable(getDrawable(pMarkDownList.getNestedLevel()));
    TopCompoundDrawable gravityDrawable=new TopCompoundDrawable(bullet,textView.getLineHeight());
    bullet.setBounds(0,0,bullet.getIntrinsicWidth(),bullet.getIntrinsicHeight());
    gravityDrawable.setBounds(0,0,bullet.getIntrinsicWidth(),0);
    textView.setCompoundDrawables(gravityDrawable,null,null,null);
    textView.setCompoundDrawablePadding(mIndicatorSpacingPixels);
    textView.setText(pText);
  }
  return textView;
}","/** 
 * Creates a TextView that represents a list item
 * @param pMarkDownList MarkDownList used to determine the kind of list
 * @param pText Content of the list item
 * @param pIndex Index of the item in the list
 * @return Returns a TextView
 */
private TextView getTextView(final MarkDownList pMarkDownList,final CharSequence pText,final int pIndex){
  final TextView textView=new TextView(mContext,null,R.attr.MarkDownListStyle);
  textView.setMovementMethod(LinkMovementMethod.getInstance());
  if (pMarkDownList.isOrdered()) {
    textView.setText(String.format(Locale.getDefault(),""String_Node_Str"",pIndex + 1,pText));
  }
 else {
    Drawable bullet=mContext.getResources().getDrawable(getDrawable(pMarkDownList.getNestedLevel()));
    TopCompoundDrawable gravityDrawable=new TopCompoundDrawable(bullet,textView.getLineHeight());
    bullet.setBounds(0,0,bullet.getIntrinsicWidth(),bullet.getIntrinsicHeight());
    gravityDrawable.setBounds(0,0,bullet.getIntrinsicWidth(),bullet.getIntrinsicHeight());
    textView.setCompoundDrawables(gravityDrawable,null,null,null);
    textView.setCompoundDrawablePadding(mIndicatorSpacingPixels);
    textView.setText(pText);
  }
  return textView;
}"
76686,"/** 
 * Creates a TextView that represents a list item
 * @param pMarkDownList MarkDownList used to determine the kind of list
 * @param pText Content of the list item
 * @param pIndex Index of the item in the list
 * @return Returns a TextView
 */
private TextView getTextView(final MarkDownList pMarkDownList,final CharSequence pText,final int pIndex){
  final TextView textView=new TextView(mContext,null,R.attr.MarkDownListStyle);
  textView.setMovementMethod(LinkMovementMethod.getInstance());
  if (pMarkDownList.isOrdered()) {
    textView.setText(String.format(Locale.getDefault(),""String_Node_Str"",pIndex + 1,pText));
  }
 else {
    Drawable bullet=mContext.getResources().getDrawable(getDrawable(pMarkDownList.getNestedLevel()));
    TopCompoundDrawable gravityDrawable=new TopCompoundDrawable(bullet,textView.getLineHeight());
    bullet.setBounds(0,0,bullet.getIntrinsicWidth(),bullet.getIntrinsicHeight());
    gravityDrawable.setBounds(0,0,bullet.getIntrinsicWidth(),0);
    textView.setCompoundDrawables(gravityDrawable,null,null,null);
    textView.setCompoundDrawablePadding(mIndicatorSpacingPixels);
    textView.setText(pText);
  }
  return textView;
}","/** 
 * Creates a TextView that represents a list item
 * @param pMarkDownList MarkDownList used to determine the kind of list
 * @param pText Content of the list item
 * @param pIndex Index of the item in the list
 * @return Returns a TextView
 */
private TextView getTextView(final MarkDownList pMarkDownList,final CharSequence pText,final int pIndex){
  final TextView textView=new TextView(mContext,null,R.attr.MarkDownListStyle);
  textView.setMovementMethod(LinkMovementMethod.getInstance());
  if (pMarkDownList.isOrdered()) {
    textView.setText(String.format(Locale.getDefault(),""String_Node_Str"",pIndex + 1,pText));
  }
 else {
    Drawable bullet=mContext.getResources().getDrawable(getDrawable(pMarkDownList.getNestedLevel()));
    TopCompoundDrawable gravityDrawable=new TopCompoundDrawable(bullet,textView.getLineHeight());
    bullet.setBounds(0,0,bullet.getIntrinsicWidth(),bullet.getIntrinsicHeight());
    gravityDrawable.setBounds(0,0,bullet.getIntrinsicWidth(),bullet.getIntrinsicHeight());
    textView.setCompoundDrawables(gravityDrawable,null,null,null);
    textView.setCompoundDrawablePadding(mIndicatorSpacingPixels);
    textView.setText(pText);
  }
  return textView;
}"
76687,"/** 
 * Creates a TextView that represents a list item
 * @param pMarkDownList MarkDownList used to determine the kind of list
 * @param pText Content of the list item
 * @param pIndex Index of the item in the list
 * @return Returns a TextView
 */
private TextView getTextView(final MarkdownList pMarkDownList,final CharSequence pText,final int pIndex){
  final TextView textView=new TextView(mContext,null,R.attr.MarkdownListStyle);
  textView.setMovementMethod(LinkMovementMethod.getInstance());
  if (pMarkDownList.isOrdered()) {
    SpannableString string=new SpannableString(pText);
    string.setSpan(new NumberSpan(mListMargin,pIndex + 1),0,string.length(),Spanned.SPAN_INCLUSIVE_INCLUSIVE);
    textView.setText(string);
  }
 else {
    final Drawable drawable=mContext.getResources().getDrawable(getDrawable(pMarkDownList.getNestedLevel()));
    SpannableString string=new SpannableString(pText);
    string.setSpan(new BulletSpan(mListMargin,drawable),0,string.length(),Spanned.SPAN_INCLUSIVE_INCLUSIVE);
    textView.setText(string);
  }
  return textView;
}","/** 
 * Creates a TextView that represents a list item
 * @param pMarkdownList MarkdownList used to determine the kind of list
 * @param pText Content of the list item
 * @param pIndex Index of the item in the list
 * @return Returns a TextView
 */
private TextView getTextView(final MarkdownList pMarkdownList,final CharSequence pText,final int pIndex){
  final TextView textView=new TextView(mContext,null,R.attr.MarkdownListStyle);
  textView.setMovementMethod(LinkMovementMethod.getInstance());
  if (pMarkdownList.isOrdered()) {
    textView.setText(String.format(Locale.getDefault(),""String_Node_Str"",pIndex + 1,pText));
  }
 else {
    Drawable bullet=mContext.getResources().getDrawable(getDrawable(pMarkdownList.getNestedLevel()));
    TopCompoundDrawable gravityDrawable=new TopCompoundDrawable(bullet,textView.getLineHeight());
    bullet.setBounds(0,0,bullet.getIntrinsicWidth(),bullet.getIntrinsicHeight());
    gravityDrawable.setBounds(0,0,bullet.getIntrinsicWidth(),bullet.getIntrinsicHeight());
    textView.setCompoundDrawables(gravityDrawable,null,null,null);
    textView.setCompoundDrawablePadding(mIndicatorSpacingPixels);
    textView.setText(pText);
  }
  return textView;
}"
76688,"@Override public View create(final MarkdownList pMarkDownItem,final InlineConverter<Spanned> pInlineConverter){
  return createLayout(pMarkDownItem,pInlineConverter);
}","@Override public View create(final MarkdownList pMarkdownItem,final InlineConverter<Spanned> pInlineConverter){
  return createLayout(pMarkdownItem,pInlineConverter);
}"
76689,"private LinearLayout createLayout(final MarkdownList pMarkDownItem,final InlineConverter<Spanned> pInlineConverter){
  LinearLayout layout=new LinearLayout(mContext);
  layout.setLayoutParams(new LayoutParams(MATCH_PARENT,WRAP_CONTENT));
  layout.setOrientation(LinearLayout.VERTICAL);
  final List<ListItem> items=pMarkDownItem.getListItems();
  for (int i=0; i < items.size(); i++) {
    final ListItem item=items.get(i);
    final View view=getTextView(pMarkDownItem,pInlineConverter.convert(item.getText()),i);
    layout.addView(view);
    if (item.hasChild()) {
      for (      MarkdownList list : item.getChild()) {
        final LinearLayout nestedLayout=createLayout(list,pInlineConverter);
        nestedLayout.setPadding(mListMargin,0,0,0);
        layout.addView(nestedLayout);
      }
    }
  }
  return layout;
}","private LinearLayout createLayout(final MarkdownList pMarkdownItem,final InlineConverter<Spanned> pInlineConverter){
  LinearLayout layout=new LinearLayout(mContext);
  layout.setLayoutParams(new LayoutParams(MATCH_PARENT,WRAP_CONTENT));
  layout.setOrientation(LinearLayout.VERTICAL);
  final List<ListItem> items=pMarkdownItem.getListItems();
  for (int i=0; i < items.size(); i++) {
    final ListItem item=items.get(i);
    final View view=getTextView(pMarkdownItem,pInlineConverter.convert(item.getText()),i);
    layout.addView(view);
    if (item.hasChild()) {
      for (      MarkdownList list : item.getChild()) {
        final LinearLayout nestedLayout=createLayout(list,pInlineConverter);
        LayoutParams params=new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT);
        params.setMargins(mIndentationSpacingPixels,0,0,0);
        nestedLayout.setLayoutParams(params);
        layout.addView(nestedLayout);
      }
    }
  }
  return layout;
}"
76690,"public ListDisplayItem(final Context pContext,@DimenRes final int pListMargin,@DrawableRes final int[] pBulletDrawables){
  mContext=pContext;
  mListMargin=mContext.getResources().getDimensionPixelSize(pListMargin);
  mBulletDrawables=pBulletDrawables;
}","public ListDisplayItem(final Context pContext,@DimenRes final int pIndentationSpacing,@DimenRes final int pBulletSpacing,@DrawableRes final int[] pBulletDrawables){
  mContext=pContext;
  mIndicatorSpacingPixels=mContext.getResources().getDimensionPixelSize(pBulletSpacing);
  mIndentationSpacingPixels=mContext.getResources().getDimensionPixelSize(pIndentationSpacing);
  mBulletDrawables=pBulletDrawables;
}"
76691,"/** 
 * Adds a user to the users table in the database.
 * @param provider The provider used to access the database.
 * @param userName The user name which will be used to create the new user.
 * @return The user.
 * @throws CouldntSaveDataException if the user could not be saved to the database.
 */
public static IUser addUser(final SQLProvider provider,final String userName) throws CouldntSaveDataException {
  Preconditions.checkNotNull(provider,""String_Node_Str"");
  Preconditions.checkNotNull(userName,""String_Node_Str"");
  final Connection connection=provider.getConnection().getConnection();
  final String query=""String_Node_Str"" + CTableNames.USER_TABLE + ""String_Node_Str"";
  CUser user=null;
  try (PreparedStatement statement=connection.prepareStatement(query);ResultSet resultSet=statement.executeQuery()){
    statement.setString(1,userName);
    while (resultSet.next()) {
      user=new CUser(resultSet.getInt(1),userName);
    }
  }
 catch (  final SQLException exception) {
    throw new CouldntSaveDataException(exception);
  }
  return user;
}","/** 
 * Adds a user to the users table in the database.
 * @param provider The provider used to access the database.
 * @param userName The user name which will be used to create the new user.
 * @return The user.
 * @throws CouldntSaveDataException if the user could not be saved to the database.
 */
public static IUser addUser(final SQLProvider provider,final String userName) throws CouldntSaveDataException {
  Preconditions.checkNotNull(provider,""String_Node_Str"");
  Preconditions.checkNotNull(userName,""String_Node_Str"");
  final Connection connection=provider.getConnection().getConnection();
  final String query=""String_Node_Str"" + CTableNames.USER_TABLE + ""String_Node_Str"";
  CUser user=null;
  try (PreparedStatement statement=connection.prepareStatement(query)){
    statement.setString(1,userName);
    ResultSet resultSet=statement.executeQuery();
    while (resultSet.next()) {
      user=new CUser(resultSet.getInt(1),userName);
    }
  }
 catch (  final SQLException exception) {
    throw new CouldntSaveDataException(exception);
  }
  return user;
}"
76692,"/** 
 * Creates a new debugger template in the database.
 * @param provider SQL provider of the new debugger template.
 * @param name Name of the new debugger template. This argument must be non-empty.
 * @param host Host of the new debugger template. This argument must be non-empty.
 * @param port Port of the new debugger template. This argument must be a valid port number.
 * @return The new debugger template.
 * @throws CouldntSaveDataException Thrown if the new debugger template could not be written tothe database.
 */
public static DebuggerTemplate createDebuggerTemplate(final AbstractSQLProvider provider,final String name,final String host,final int port) throws CouldntSaveDataException {
  Preconditions.checkNotNull(name,""String_Node_Str"");
  Preconditions.checkArgument(!name.isEmpty(),""String_Node_Str"");
  Preconditions.checkNotNull(host,""String_Node_Str"");
  Preconditions.checkArgument(!host.isEmpty(),""String_Node_Str"");
  Preconditions.checkArgument((port > 0) && (port <= 65535),""String_Node_Str"");
  NaviLogger.info(""String_Node_Str"",name,host,port);
  final CConnection connection=provider.getConnection();
  final String query=""String_Node_Str"" + CTableNames.DEBUGGERS_TABLE + ""String_Node_Str"";
  try (PreparedStatement statement=connection.getConnection().prepareStatement(query);ResultSet resultSet=statement.executeQuery()){
    statement.setString(1,name);
    statement.setString(2,host);
    statement.setInt(3,port);
    int id=-1;
    while (resultSet.next()) {
      id=resultSet.getInt(""String_Node_Str"");
    }
    return new DebuggerTemplate(id,name,host,port,provider);
  }
 catch (  final SQLException e) {
    throw new CouldntSaveDataException(e);
  }
}","/** 
 * Creates a new debugger template in the database.
 * @param provider SQL provider of the new debugger template.
 * @param name Name of the new debugger template. This argument must be non-empty.
 * @param host Host of the new debugger template. This argument must be non-empty.
 * @param port Port of the new debugger template. This argument must be a valid port number.
 * @return The new debugger template.
 * @throws CouldntSaveDataException Thrown if the new debugger template could not be written tothe database.
 */
public static DebuggerTemplate createDebuggerTemplate(final AbstractSQLProvider provider,final String name,final String host,final int port) throws CouldntSaveDataException {
  Preconditions.checkNotNull(name,""String_Node_Str"");
  Preconditions.checkArgument(!name.isEmpty(),""String_Node_Str"");
  Preconditions.checkNotNull(host,""String_Node_Str"");
  Preconditions.checkArgument(!host.isEmpty(),""String_Node_Str"");
  Preconditions.checkArgument((port > 0) && (port <= 65535),""String_Node_Str"");
  NaviLogger.info(""String_Node_Str"",name,host,port);
  final CConnection connection=provider.getConnection();
  final String query=""String_Node_Str"" + CTableNames.DEBUGGERS_TABLE + ""String_Node_Str"";
  try (PreparedStatement statement=connection.getConnection().prepareStatement(query)){
    statement.setString(1,name);
    statement.setString(2,host);
    statement.setInt(3,port);
    int id=-1;
    try (ResultSet resultSet=statement.executeQuery()){
      while (resultSet.next()) {
        id=resultSet.getInt(""String_Node_Str"");
      }
    }
     return new DebuggerTemplate(id,name,host,port,provider);
  }
 catch (  final SQLException e) {
    throw new CouldntSaveDataException(e);
  }
}"
76693,"/** 
 * Returns the derived views of the given view.
 * @param provider Provides the connection to the database.
 * @param view The view whose derived views are returned.
 * @return The derived views.
 * @throws CouldntLoadDataException Thrown if the derived views could not be determined.
 */
public static List<INaviView> getDerivedViews(final AbstractSQLProvider provider,final INaviView view) throws CouldntLoadDataException {
  checkArguments(provider,view);
  final List<INaviView> views=new ArrayList<INaviView>();
  if (view.getConfiguration().getModule() == null) {
    return views;
  }
  final String query=""String_Node_Str"";
  try (PreparedStatement statement=provider.getConnection().getConnection().prepareStatement(query);ResultSet resultSet=statement.executeQuery()){
    final List<INaviView> moduleViews=view.getConfiguration().getModule().getContent().getViewContainer().getViews();
    statement.setInt(1,view.getConfiguration().getId());
    if (resultSet == null) {
      return views;
    }
    while (resultSet.next()) {
      final int viewId=resultSet.getInt(1);
      if (viewId != view.getConfiguration().getId()) {
        for (        final INaviView moduleView : moduleViews) {
          if (moduleView.getConfiguration().getId() == viewId) {
            views.add(moduleView);
            break;
          }
        }
      }
    }
    return views;
  }
 catch (  final SQLException e) {
    throw new CouldntLoadDataException(e);
  }
}","/** 
 * Returns the derived views of the given view.
 * @param provider Provides the connection to the database.
 * @param view The view whose derived views are returned.
 * @return The derived views.
 * @throws CouldntLoadDataException Thrown if the derived views could not be determined.
 */
public static List<INaviView> getDerivedViews(final AbstractSQLProvider provider,final INaviView view) throws CouldntLoadDataException {
  checkArguments(provider,view);
  final List<INaviView> views=new ArrayList<INaviView>();
  if (view.getConfiguration().getModule() == null) {
    return views;
  }
  final String query=""String_Node_Str"";
  try (PreparedStatement statement=provider.getConnection().getConnection().prepareStatement(query)){
    final List<INaviView> moduleViews=view.getConfiguration().getModule().getContent().getViewContainer().getViews();
    statement.setInt(1,view.getConfiguration().getId());
    final ResultSet resultSet=statement.executeQuery();
    if (resultSet == null) {
      return views;
    }
    while (resultSet.next()) {
      final int viewId=resultSet.getInt(1);
      if (viewId != view.getConfiguration().getId()) {
        for (        final INaviView moduleView : moduleViews) {
          if (moduleView.getConfiguration().getId() == viewId) {
            views.add(moduleView);
            break;
          }
        }
      }
    }
    return views;
  }
 catch (  final SQLException e) {
    throw new CouldntLoadDataException(e);
  }
}"
76694,"/** 
 * Creates a new tag in the database.
 * @param provider The connection to the database.
 * @param parent The parent tag of the tag.
 * @param name The name of the new tag.
 * @param description The description of the new tag.
 * @param type The type of the new tag.
 * @return The new tag.
 * @throws CouldntSaveDataException Thrown if creating the tag failed.
 */
public static CTag createTag(final AbstractSQLProvider provider,final CTag parent,final String name,final String description,final TagType type) throws CouldntSaveDataException {
  checkArguments(provider,parent,type);
  Preconditions.checkNotNull(name,""String_Node_Str"");
  Preconditions.checkNotNull(description,""String_Node_Str"");
  final CConnection connection=provider.getConnection();
  final String query=""String_Node_Str"" + CTableNames.TAGS_TABLE + ""String_Node_Str"";
  try (PreparedStatement statement=connection.getConnection().prepareStatement(query,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);ResultSet resultSet=statement.executeQuery()){
    if (parent.getId() == 0) {
      statement.setNull(1,Types.INTEGER);
    }
 else {
      statement.setInt(1,parent.getId());
    }
    statement.setString(2,name);
    statement.setString(3,description);
    statement.setString(4,tagToString(type));
    Integer id=null;
    while (resultSet.next()) {
      if (resultSet.isFirst()) {
        id=resultSet.getInt(1);
      }
    }
    if (id != null) {
      return new CTag(id,name,description,type,provider);
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 catch (  final SQLException e) {
    throw new CouldntSaveDataException(e);
  }
}","/** 
 * Creates a new tag in the database.
 * @param provider The connection to the database.
 * @param parent The parent tag of the tag.
 * @param name The name of the new tag.
 * @param description The description of the new tag.
 * @param type The type of the new tag.
 * @return The new tag.
 * @throws CouldntSaveDataException Thrown if creating the tag failed.
 */
public static CTag createTag(final AbstractSQLProvider provider,final CTag parent,final String name,final String description,final TagType type) throws CouldntSaveDataException {
  checkArguments(provider,parent,type);
  Preconditions.checkNotNull(name,""String_Node_Str"");
  Preconditions.checkNotNull(description,""String_Node_Str"");
  final CConnection connection=provider.getConnection();
  final String query=""String_Node_Str"" + CTableNames.TAGS_TABLE + ""String_Node_Str"";
  try (PreparedStatement statement=connection.getConnection().prepareStatement(query,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY)){
    if (parent.getId() == 0) {
      statement.setNull(1,Types.INTEGER);
    }
 else {
      statement.setInt(1,parent.getId());
    }
    statement.setString(2,name);
    statement.setString(3,description);
    statement.setString(4,tagToString(type));
    Integer id=null;
    try (ResultSet resultSet=statement.executeQuery()){
      while (resultSet.next()) {
        if (resultSet.isFirst()) {
          id=resultSet.getInt(1);
        }
      }
    }
     if (id != null) {
      return new CTag(id,name,description,type,provider);
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 catch (  final SQLException e) {
    throw new CouldntSaveDataException(e);
  }
}"
76695,"public void batchInsert(List<CoreDict> list){
  dictDao.insertBatch(list);
}","/** 
 * 参考：dict_mapping.xml
 * @param list
 * @return
 */
public void batchInsert(List<DictExcelImportData> list){
  int dataStartRow=3;
  final Map<Integer,DictExcelImportData> map=new HashMap<>();
  list.forEach((item) -> map.put(item.getExcelId(),item));
  for (  DictExcelImportData item : list) {
    CoreDict dict=new CoreDict();
    dict.setName(item.getName());
    dict.setRemark(item.getRemark());
    dict.setType(item.getType());
    dict.setTypeName(item.getTypeName());
    dict.setValue(item.getValue());
    CoreDict template=new CoreDict();
    template.setType(dict.getType());
    template.setValue(dict.getValue());
    CoreDict dbDict=dictDao.templateOne(template);
    if (dbDict != null) {
      int row=item.getExcelId() + dataStartRow;
      throwImporError(row,0,""String_Node_Str"");
    }
    if (item.getParentExcelId() != 0) {
      DictExcelImportData parentItem=map.get(item.getParentExcelId());
      if (parentItem == null) {
        int row=item.getExcelId() + dataStartRow;
        throwImporError(row,6,""String_Node_Str"");
      }
      if (parentItem.getId() == null) {
        int row=item.getExcelId() + dataStartRow;
        throwImporError(row,6,""String_Node_Str"");
      }
      dict.setParent(parentItem.getId());
    }
    dict.setCreateTime(new Date());
    dictDao.insert(dict);
    item.setId(dict.getId());
  }
}"
76696,"public List<UserExcelData> queryExcel(PageQuery<CoreUser> query){
  PageQuery<CoreUser> ret=userDao.queryByCondtion(query);
  List<CoreUser> list=ret.getList();
  OrgItem orgRoot=platformService.buildOrg();
  List<UserExcelData> items=new ArrayList<>();
  for (  CoreUser user : list) {
    UserExcelData userItem=new UserExcelData();
    userItem.setCode(user.getCode());
    userItem.setId(user.getId());
    userItem.setName(user.getName());
    CoreDict dict=dictService.findCoreDict(CoreDictType.USER_STATE,user.getState());
    userItem.setStateText(dict.getName());
    if (StringUtils.isNotEmpty(user.getJobType1())) {
      dict=dictService.findCoreDict(""String_Node_Str"",user.getJobType1());
      userItem.setJobType1Text(dict.getName());
    }
    String orgName=orgRoot.findChild(user.getOrgId()).getName();
    userItem.setOrgText(orgName);
    items.add(userItem);
  }
  return items;
}","public List<UserExcelExportData> queryExcel(PageQuery<CoreUser> query){
  PageQuery<CoreUser> ret=userDao.queryByCondtion(query);
  List<CoreUser> list=ret.getList();
  OrgItem orgRoot=platformService.buildOrg();
  List<UserExcelExportData> items=new ArrayList<>();
  for (  CoreUser user : list) {
    UserExcelExportData userItem=new UserExcelExportData();
    userItem.setCode(user.getCode());
    userItem.setId(user.getId());
    userItem.setName(user.getName());
    CoreDict dict=dictService.findCoreDict(CoreDictType.USER_STATE,user.getState());
    userItem.setStateText(dict.getName());
    if (StringUtils.isNotEmpty(user.getJobType1())) {
      dict=dictService.findCoreDict(""String_Node_Str"",user.getJobType1());
      userItem.setJobType1Text(dict.getName());
    }
    String orgName=orgRoot.findChild(user.getOrgId()).getName();
    userItem.setOrgText(orgName);
    items.add(userItem);
  }
  return items;
}"
76697,"@PostMapping(MODEL + ""String_Node_Str"") @Function(""String_Node_Str"") @ResponseBody public JsonResult importExcel(@RequestParam(""String_Node_Str"") MultipartFile file) throws Exception {
  if (file.isEmpty()) {
    return JsonResult.fail();
  }
  String fileName=file.getOriginalFilename();
  InputStream ins=file.getInputStream();
  InputStream inputXML=Thread.currentThread().getContextClassLoader().getResourceAsStream(""String_Node_Str"");
  XLSReader mainReader=ReaderBuilder.buildFromXML(inputXML);
  InputStream inputXLS=ins;
  List<CoreDict> dicts=new ArrayList<CoreDict>();
  Map beans=new HashMap();
  beans.put(""String_Node_Str"",dicts);
  XLSReadStatus readStatus=mainReader.read(inputXLS,beans);
  System.out.println(dicts);
  return JsonResult.success();
}","@PostMapping(MODEL + ""String_Node_Str"") @Function(""String_Node_Str"") @ResponseBody public JsonResult importExcel(@RequestParam(""String_Node_Str"") MultipartFile file) throws Exception {
  if (file.isEmpty()) {
    return JsonResult.fail();
  }
  String fileName=file.getOriginalFilename();
  InputStream ins=file.getInputStream();
  InputStream inputXML=Thread.currentThread().getContextClassLoader().getResourceAsStream(""String_Node_Str"");
  XLSReader mainReader=ReaderBuilder.buildFromXML(inputXML);
  InputStream inputXLS=ins;
  List<DictExcelImportData> dicts=new ArrayList<DictExcelImportData>();
  Map beans=new HashMap();
  beans.put(""String_Node_Str"",dicts);
  XLSReadStatus readStatus=mainReader.read(inputXLS,beans);
  try {
    this.dictService.batchInsert(dicts);
    return JsonResult.success();
  }
 catch (  Exception ex) {
    return JsonResult.failMessage(ex.getMessage());
  }
}"
76698,"@PostMapping(MODEL + ""String_Node_Str"") @Function(""String_Node_Str"") @ResponseBody public JsonResult<String> export(HttpServletResponse response,UserQuery condtion){
  String excelTemplate=""String_Node_Str"";
  PageQuery<CoreUser> page=condtion.getPageQuery();
  page.setPageSize(Integer.MAX_VALUE);
  page.setPageNumber(1);
  page.setTotalRow(Integer.MAX_VALUE);
  List<UserExcelData> users=userConsoleService.queryExcel(page);
  try (InputStream is=Thread.currentThread().getContextClassLoader().getResourceAsStream(excelTemplate)){
    if (is == null) {
      throw new PlatformException(""String_Node_Str"" + excelTemplate);
    }
    FileItem item=fileService.createFileTemp(""String_Node_Str"");
    OutputStream os=item.openOutpuStream();
    Context context=new Context();
    context.putVar(""String_Node_Str"",users);
    JxlsHelper.getInstance().processTemplate(is,os,context);
    return JsonResult.success(item.getId());
  }
 catch (  IOException e) {
    throw new PlatformException(e.getMessage());
  }
}","@PostMapping(MODEL + ""String_Node_Str"") @Function(""String_Node_Str"") @ResponseBody public JsonResult<String> export(HttpServletResponse response,UserQuery condtion){
  String excelTemplate=""String_Node_Str"";
  PageQuery<CoreUser> page=condtion.getPageQuery();
  page.setPageSize(Integer.MAX_VALUE);
  page.setPageNumber(1);
  page.setTotalRow(Integer.MAX_VALUE);
  List<UserExcelExportData> users=userConsoleService.queryExcel(page);
  try (InputStream is=Thread.currentThread().getContextClassLoader().getResourceAsStream(excelTemplate)){
    if (is == null) {
      throw new PlatformException(""String_Node_Str"" + excelTemplate);
    }
    FileItem item=fileService.createFileTemp(""String_Node_Str"");
    OutputStream os=item.openOutpuStream();
    Context context=new Context();
    context.putVar(""String_Node_Str"",users);
    JxlsHelper.getInstance().processTemplate(is,os,context);
    return JsonResult.success(item.getId());
  }
 catch (  IOException e) {
    throw new PlatformException(e.getMessage());
  }
}"
76699,public void batchDelCoreDictByIds(List<String> ids);,public void batchDelCoreDictByIds(List<Long> ids);
76700,"public void batchDelCoreDict(List<String> ids){
  try {
    dictDao.batchDelCoreDictByIds(ids);
  }
 catch (  Exception e) {
    throw new PlatformException(""String_Node_Str"",e);
  }
}","public void batchDelCoreDict(List<Long> ids){
  try {
    dictDao.batchDelCoreDictByIds(ids);
  }
 catch (  Exception e) {
    throw new PlatformException(""String_Node_Str"",e);
  }
}"
76701,"public List<UserExcelData> queryExcel(PageQuery<CoreUser> query){
  PageQuery<CoreUser> ret=userDao.queryByCondtion(query);
  List<CoreUser> list=ret.getList();
  OrgItem orgRoot=platformService.buildOrg();
  List<UserExcelData> items=new ArrayList<>();
  for (  CoreUser user : list) {
    UserExcelData userItem=new UserExcelData();
    userItem.setCode(user.getCode());
    userItem.setId(user.getId());
    userItem.setName(user.getName());
    CoreDict dict=dictService.findCoreDict(user.getState());
    userItem.setStateText(dict.getName());
    if (StringUtils.isNotEmpty(user.getJobType1())) {
      dict=dictService.findCoreDict(user.getJobType1());
      userItem.setJobType1Text(dict.getName());
    }
    String orgName=orgRoot.findChild(user.getOrgId()).getName();
    userItem.setOrgText(orgName);
    items.add(userItem);
  }
  return items;
}","public List<UserExcelData> queryExcel(PageQuery<CoreUser> query){
  PageQuery<CoreUser> ret=userDao.queryByCondtion(query);
  List<CoreUser> list=ret.getList();
  OrgItem orgRoot=platformService.buildOrg();
  List<UserExcelData> items=new ArrayList<>();
  for (  CoreUser user : list) {
    UserExcelData userItem=new UserExcelData();
    userItem.setCode(user.getCode());
    userItem.setId(user.getId());
    userItem.setName(user.getName());
    CoreDict dict=dictService.findCoreDict(CoreDictType.USER_STATE,user.getState());
    userItem.setStateText(dict.getName());
    if (StringUtils.isNotEmpty(user.getJobType1())) {
      dict=dictService.findCoreDict(""String_Node_Str"",user.getJobType1());
      userItem.setJobType1Text(dict.getName());
    }
    String orgName=orgRoot.findChild(user.getOrgId()).getName();
    userItem.setOrgText(orgName);
    items.add(userItem);
  }
  return items;
}"
76702,"@GetMapping(MODEL + ""String_Node_Str"") @Function(""String_Node_Str"") public ModelAndView edit(String id){
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  CoreDict dict=dictService.queryById(id);
  view.addObject(""String_Node_Str"",dict);
  return view;
}","@GetMapping(MODEL + ""String_Node_Str"") @Function(""String_Node_Str"") public ModelAndView edit(Long id){
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  CoreDict dict=dictService.queryById(id);
  view.addObject(""String_Node_Str"",dict);
  return view;
}"
76703,"@PostMapping(MODEL + ""String_Node_Str"") @Function(""String_Node_Str"") @ResponseBody public JsonResult delete(String ids){
  if (ids.endsWith(""String_Node_Str"")) {
    ids=StringUtils.substringBeforeLast(ids,""String_Node_Str"");
  }
  List<String> idList=Arrays.asList(ids.split(""String_Node_Str""));
  dictService.batchDelCoreDict(idList);
  return new JsonResult().success();
}","@PostMapping(MODEL + ""String_Node_Str"") @Function(""String_Node_Str"") @ResponseBody public JsonResult delete(String ids){
  List<Long> dels=ConvertUtil.str2longs(ids);
  dictService.batchDelCoreDict(dels);
  return new JsonResult().success();
}"
76704,"@Override public void createWorld(String id,WorldGenerator generator){
  World world=new SimpleGeneratedWorld(id,worldLoader.getDataSource(id),generator);
  worldMap.put(id,world);
}","@Override public void createWorld(String id,WorldGenerator generator){
  World world;
  try {
    world=new SimpleGeneratedWorld(id,worldLoader.getDataSource(id),generator);
    worldMap.put(id,world);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
}"
76705,"public PaletteBlockStateStorage(ByteBuf in) throws IOException {
  this.bitsPerEntry=in.readUnsignedByte();
  int stateCount=ByteBufUtils.readVarInt(in);
  for (int i=0; i < stateCount; i++) {
    this.palette.add(BlockState.of(ByteBufUtils.readVarInt(in)));
  }
  int dataAmount=ByteBufUtils.readVarInt(in);
  long[] data=new long[dataAmount];
  for (int i=0; i < dataAmount; dataAmount++) {
    data[i]=in.readLong();
  }
  this.baseStorage=new EntrySizeBasedStorage(this.bitsPerEntry,data);
}","public PaletteBlockStateStorage(ByteBuf in) throws IOException {
  this.bitsPerEntry=in.readUnsignedByte();
  int stateCount=ByteBufUtils.readVarInt(in);
  for (int i=0; i < stateCount; i++) {
    this.palette.add(BlockState.of(ByteBufUtils.readVarInt(in)));
  }
  int dataAmount=ByteBufUtils.readVarInt(in);
  long[] data=new long[dataAmount];
  for (int i=0; i < dataAmount; i++) {
    data[i]=in.readLong();
  }
  this.baseStorage=new EntrySizeBasedStorage(this.bitsPerEntry,data);
}"
76706,"public void finishLogin(Connection connection,UUID uuid,String accountName,UserProperty[] properties){
  if (connectionLoginDataMap.remove(connection) == null || connection.isClosed())   return;
  Collection<UserProperty> userProperties=new ArrayList<>(Arrays.asList(properties));
  AsyncLoginEvent event=CleanstoneServer.publishEvent(new AsyncLoginEvent(connection,uuid,accountName,userProperties));
  if (event.isCancelled()) {
    stopLogin(connection,event.getKickReason());
    return;
  }
  SetCompressionPacket setCompressionPacket=new SetCompressionPacket(0);
  LoginSuccessPacket loginSuccessPacket=new LoginSuccessPacket(uuid,accountName);
  connection.sendPacket(loginSuccessPacket);
  logger.info(""String_Node_Str"" + accountName + ""String_Node_Str""+ uuid.toString()+ ""String_Node_Str"");
  connection.setProtocolState(VanillaProtocolState.PLAY);
  CleanstoneServer.publishEvent(new AsyncLoginSuccessEvent(connection,uuid,accountName,userProperties));
}","public void finishLogin(Connection connection,UUID uuid,String accountName,UserProperty[] properties){
  if (connectionLoginDataMap.remove(connection) == null || connection.isClosed())   return;
  if (properties == null) {
    properties=new UserProperty[0];
  }
  Collection<UserProperty> userProperties=new ArrayList<>(Arrays.asList(properties));
  AsyncLoginEvent event=CleanstoneServer.publishEvent(new AsyncLoginEvent(connection,uuid,accountName,userProperties));
  if (event.isCancelled()) {
    stopLogin(connection,event.getKickReason());
    return;
  }
  SetCompressionPacket setCompressionPacket=new SetCompressionPacket(0);
  LoginSuccessPacket loginSuccessPacket=new LoginSuccessPacket(uuid,accountName);
  connection.sendPacket(loginSuccessPacket);
  logger.info(""String_Node_Str"" + accountName + ""String_Node_Str""+ uuid.toString()+ ""String_Node_Str"");
  connection.setProtocolState(VanillaProtocolState.PLAY);
  CleanstoneServer.publishEvent(new AsyncLoginSuccessEvent(connection,uuid,accountName,userProperties));
}"
76707,"@Nullable @Override public Chunk loadExistingChunk(int x,int y){
  ByteBuf blocksKey=ChunkDataKeyFactory.create(x,y,StandardChunkDataType.BLOCKS);
  BlockDataStorage blockDataStorage;
  try {
    blockDataStorage=new BlockDataStorage(get(blocksKey),hasSkyLight);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ worldID+ ""String_Node_Str"",e);
    return null;
  }
  return new SimpleChunk(blockDataStorage.constructTable(),blockDataStorage,Collections.emptyList(),x,y);
}","@Nullable @Override public Chunk loadExistingChunk(int x,int y){
  ByteBuf blocksKey=ChunkDataKeyFactory.create(x,y,StandardChunkDataType.BLOCKS);
  BlockDataStorage blockDataStorage;
  try {
    blockDataStorage=new BlockDataStorage(get(blocksKey),hasSkyLight);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ worldID+ ""String_Node_Str"",e);
    return null;
  }
catch (  NullPointerException e) {
    return null;
  }
  return new SimpleChunk(blockDataStorage.constructTable(),blockDataStorage,Collections.emptyList(),x,y);
}"
76708,"@Override public ListenableFuture<Chunk> getChunk(int x,int y){
  if (isChunkLoaded(x,y)) {
    return new AsyncResult<>(getLoadedChunk(x,y));
  }
  ListenableFuture<Chunk> chunkFuture=world.getChunkProvider().getChunk(x,y);
  chunkFuture.addCallback((chunk) -> chunks[x][y]=chunk,(error) -> logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y,error));
  return chunkFuture;
}","@Override public ListenableFuture<Chunk> getChunk(int x,int y){
  if (isChunkLoaded(x,y)) {
    return new AsyncResult<>(getLoadedChunk(x,y));
  }
  ListenableFuture<Chunk> chunkFuture=chunkProvider.getChunk(x,y);
  chunkFuture.addCallback((chunk) -> chunks[x][y]=chunk,(error) -> logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y,error));
  return chunkFuture;
}"
76709,"public SimpleRegion(int x,int y,RegionWorker regionWorker,World world){
  this(x,y,new SimpleChunk[Region.CHUNK_COUNT_ROOT][Region.CHUNK_COUNT_ROOT],regionWorker,world);
}","public SimpleRegion(int x,int y,RegionWorker regionWorker,ChunkProvider chunkProvider){
  this(x,y,new SimpleChunk[Region.CHUNK_COUNT_ROOT][Region.CHUNK_COUNT_ROOT],regionWorker,chunkProvider);
}"
76710,"@Override public ListenableFuture<Region> getRegion(int x,int y){
  return null;
}","@Override public ListenableFuture<Region> getRegion(int x,int y){
  final Pair coordPair=Pair.of(x,y);
  if (regions.containsKey(coordPair)) {
    return new AsyncResult<>(regions.get(coordPair));
  }
  return loadRegion(x,y);
}"
76711,"@Override public void unloadRegion(int x,int y){
}","@Override public void unloadRegion(int x,int y){
  regions.remove(Pair.of(x,y));
}"
76712,"@Override public Collection<Region> getLoadedRegions(){
  return null;
}","@Override public Collection<Region> getLoadedRegions(){
  return regions.values();
}"
76713,"@Override public ListenableFuture<Region> loadRegion(int x,int y){
  return null;
}","@Override public ListenableFuture<Region> loadRegion(int x,int y){
  Region region=new SimpleRegion(x,y,new LocalRegionWorker(),chunkProvider);
  regions.put(Pair.of(x,y),region);
  return new AsyncResult<>(region);
}"
76714,"public SimpleRegionManager(AsyncListenableTaskExecutor localWorkerExecutor){
  regions=new HashMap<>();
}","public SimpleRegionManager(ChunkProvider chunkProvider){
  this.chunkProvider=chunkProvider;
  regions=new HashMap<>();
}"
76715,"@Override public ListenableFuture<Chunk> getChunk(int x,int y){
  return executor.submitListenable(() -> {
    Chunk chunk=dataSource.loadExistingChunk(x,y);
    if (chunk == null) {
      chunk=generator.generateChunk(x,y);
    }
    return chunk;
  }
);
}","@Override public ListenableFuture<Chunk> getChunk(int x,int y){
  return executor.submitListenable(() -> {
    Chunk chunk=dataSource.loadExistingChunk(x,y);
    if (chunk == null) {
      chunk=generator.generateChunk(x,y);
      dataSource.saveChunk(chunk);
    }
    return chunk;
  }
);
}"
76716,"protected void sendChunkLoad(Player player,int x,int y){
  BlockDataStorage storage=flatWorldGenerator.generateChunk(x,y).getBlockDataStorage();
  ChunkDataPacket chunkDataPacket=new ChunkDataPacket(x,y,true,storage,new NamedBinaryTag[]{});
  player.sendPacket(chunkDataPacket);
}","protected void sendChunkLoad(Player player,int x,int y){
  World world=player.getEntity().getLocation().getPosition().getWorld();
  world.getChunkProvider().getChunk(x,y).addCallback(chunk -> {
    if (chunk == null) {
      logger.error(""String_Node_Str"",x,y);
      return;
    }
    ChunkDataPacket chunkDataPacket=new ChunkDataPacket(x,y,true,chunk.getBlockDataStorage(),new NamedBinaryTag[]{});
    player.sendPacket(chunkDataPacket);
  }
,throwable -> {
    logger.error(""String_Node_Str"",throwable);
  }
);
}"
76717,"private int getUnoccupiedEntityID(){
  ThreadLocalRandom current=ThreadLocalRandom.current();
  int random=current.nextInt();
  while (entityMap.containsKey(random)) {
    random=current.nextInt();
  }
  return random;
}","private int getUnoccupiedEntityID(){
  int random=current.nextInt();
  while (entityMap.containsKey(random)) {
    random=current.nextInt();
  }
  return random;
}"
76718,"/** 
 * This sends the Player Spawn Packet for every Player to the Joined User
 */
private void sendToJoined(Player player){
  playerManager.getOnlinePlayers().forEach(onlinePlayer -> {
    if (onlinePlayer == player) {
      return;
    }
    Entity entity=player.getEntity();
    Location location=entity.getLocation();
    SpawnPlayerPacket spawnPlayerPacket=new SpawnPlayerPacket(entity.getEntityID(),onlinePlayer.getId().getUUID(),location.getPosition().getX(),location.getPosition().getY(),location.getPosition().getZ(),location.getRotation().getYaw(),location.getRotation().getPitch(),null);
    player.sendPacket(spawnPlayerPacket);
  }
);
}","/** 
 * This sends the Player Spawn Packet for every Player to the Joined User
 */
private void sendToJoined(Player player){
  playerManager.getOnlinePlayers().forEach(onlinePlayer -> {
    if (onlinePlayer == player) {
      return;
    }
    Entity entity=onlinePlayer.getEntity();
    Location location=entity.getLocation();
    SpawnPlayerPacket spawnPlayerPacket=new SpawnPlayerPacket(entity.getEntityID(),onlinePlayer.getId().getUUID(),location.getPosition().getX(),location.getPosition().getY(),location.getPosition().getZ(),location.getRotation().getYaw(),location.getRotation().getPitch(),null);
    player.sendPacket(spawnPlayerPacket);
  }
);
}"
76719,"@Async(value=""String_Node_Str"") @EventListener public void onPlayerPositionAndLookPacket(PlayerInboundPacketEvent event){
  if (!(event.getPacket() instanceof InPlayerPositionAndLookPacket)) {
    return;
  }
  InPlayerPositionAndLookPacket playerPositionAndLookPacket=(InPlayerPositionAndLookPacket)event.getPacket();
  Entity entity=event.getPlayer().getEntity();
  if (entity == null) {
    return;
  }
  Position oldPosition=entity.getLocation().getPosition();
  Rotation oldRotation=entity.getLocation().getRotation();
  Position newPosition=new Position(oldPosition);
  Rotation newRotation=new Rotation(oldRotation);
  newPosition.setX(playerPositionAndLookPacket.getX());
  newPosition.setY(playerPositionAndLookPacket.getY());
  newPosition.setZ(playerPositionAndLookPacket.getZ());
  newRotation.setPitch(playerPositionAndLookPacket.getPitch());
  newRotation.setYaw(playerPositionAndLookPacket.getYaw());
  entity.getLocation().setPosition(newPosition);
  entity.getLocation().setRotation(newRotation);
  CleanstoneServer.publishEvent(new PlayerMoveEvent(event.getPlayer(),oldPosition,oldRotation,newPosition,newRotation));
}","@Async(value=""String_Node_Str"") @EventListener public void onPlayerPositionAndLookPacket(PlayerInboundPacketEvent event){
  if (!(event.getPacket() instanceof InPlayerPositionAndLookPacket)) {
    return;
  }
  InPlayerPositionAndLookPacket playerPositionAndLookPacket=(InPlayerPositionAndLookPacket)event.getPacket();
  Entity entity=event.getPlayer().getEntity();
  if (entity == null) {
    return;
  }
  Position oldPosition=entity.getLocation().getPosition();
  Rotation oldRotation=entity.getLocation().getRotation();
  Position newPosition=new Position(oldPosition);
  Rotation newRotation=new Rotation(oldRotation);
  newPosition.setX(playerPositionAndLookPacket.getX());
  newPosition.setY(playerPositionAndLookPacket.getY());
  newPosition.setZ(playerPositionAndLookPacket.getZ());
  newRotation.setPitch(playerPositionAndLookPacket.getPitch());
  newRotation.setYaw(playerPositionAndLookPacket.getYaw());
  entity.setLocation(new Location(newPosition,newRotation));
  CleanstoneServer.publishEvent(new PlayerMoveEvent(event.getPlayer(),oldPosition,oldRotation,newPosition,newRotation));
}"
76720,"@Async(value=""String_Node_Str"") @EventListener public void onPlayerPositionPacket(PlayerInboundPacketEvent event){
  if (!(event.getPacket() instanceof PlayerPositionPacket)) {
    return;
  }
  PlayerPositionPacket playerPositionPacket=(PlayerPositionPacket)event.getPacket();
  Human entity=event.getPlayer().getEntity();
  if (entity == null) {
    return;
  }
  Position oldPosition=entity.getLocation().getPosition();
  Rotation oldRotation=entity.getLocation().getRotation();
  Position newPosition=new Position(oldPosition);
  newPosition.setX(playerPositionPacket.getX());
  newPosition.setY(playerPositionPacket.getFeetY());
  newPosition.setZ(playerPositionPacket.getZ());
  entity.getLocation().setPosition(newPosition);
  CleanstoneServer.publishEvent(new PlayerMoveEvent(event.getPlayer(),oldPosition,oldRotation,newPosition,oldRotation));
}","@Async(value=""String_Node_Str"") @EventListener public void onPlayerPositionPacket(PlayerInboundPacketEvent event){
  if (!(event.getPacket() instanceof PlayerPositionPacket)) {
    return;
  }
  PlayerPositionPacket playerPositionPacket=(PlayerPositionPacket)event.getPacket();
  Human entity=event.getPlayer().getEntity();
  if (entity == null) {
    return;
  }
  Position oldPosition=entity.getLocation().getPosition();
  Rotation oldRotation=entity.getLocation().getRotation();
  Position newPosition=new Position(oldPosition);
  newPosition.setX(playerPositionPacket.getX());
  newPosition.setY(playerPositionPacket.getFeetY());
  newPosition.setZ(playerPositionPacket.getZ());
  entity.setLocation(new Location(newPosition,oldRotation));
  CleanstoneServer.publishEvent(new PlayerMoveEvent(event.getPlayer(),oldPosition,oldRotation,newPosition,oldRotation));
}"
76721,"@Async(value=""String_Node_Str"") @EventListener public void onPlayerLookPacket(PlayerInboundPacketEvent event){
  if (!(event.getPacket() instanceof PlayerLookPacket)) {
    return;
  }
  PlayerLookPacket playerLookPacket=(PlayerLookPacket)event.getPacket();
  Entity entity=event.getPlayer().getEntity();
  if (entity == null) {
    return;
  }
  Position oldPosition=entity.getLocation().getPosition();
  Rotation oldRotation=entity.getLocation().getRotation();
  Rotation newRotation=new Rotation(oldRotation);
  newRotation.setPitch(playerLookPacket.getPitch());
  newRotation.setYaw(playerLookPacket.getYaw());
  entity.getLocation().setRotation(newRotation);
  CleanstoneServer.publishEvent(new PlayerMoveEvent(event.getPlayer(),oldPosition,oldRotation,oldPosition,newRotation));
}","@Async(value=""String_Node_Str"") @EventListener public void onPlayerLookPacket(PlayerInboundPacketEvent event){
  if (!(event.getPacket() instanceof PlayerLookPacket)) {
    return;
  }
  PlayerLookPacket playerLookPacket=(PlayerLookPacket)event.getPacket();
  Entity entity=event.getPlayer().getEntity();
  if (entity == null) {
    return;
  }
  Position oldPosition=entity.getLocation().getPosition();
  Rotation oldRotation=entity.getLocation().getRotation();
  Rotation newRotation=new Rotation(oldRotation);
  newRotation.setPitch(playerLookPacket.getPitch());
  newRotation.setYaw(playerLookPacket.getYaw());
  entity.setLocation(new Location(oldPosition,newRotation));
  CleanstoneServer.publishEvent(new PlayerMoveEvent(event.getPlayer(),oldPosition,oldRotation,oldPosition,newRotation));
}"
76722,"@Override public Packet decode(ByteBuf byteBuf){
  String locale;
  try {
    locale=ByteBufUtils.readUTF8(byteBuf);
  }
 catch (  IOException e) {
    e.printStackTrace();
    locale=""String_Node_Str"";
  }
  final byte viewDistance=byteBuf.readByte();
  ChatMode chatMode;
  try {
    chatMode=ChatMode.fromModeID(ByteBufUtils.readVarInt(byteBuf));
  }
 catch (  IOException e) {
    e.printStackTrace();
    chatMode=ChatMode.ENABLED;
  }
  final boolean chatColors=byteBuf.readBoolean();
  final DisplayedSkinParts[] displayedSkinParts=DisplayedSkinParts.fromBitMask(byteBuf.readByte());
  MainHand mainHand;
  try {
    mainHand=MainHand.fromHandID(ByteBufUtils.readVarInt(byteBuf));
  }
 catch (  IOException e) {
    e.printStackTrace();
    mainHand=MainHand.RIGHT;
  }
  return new ClientSettingsPacket(locale,viewDistance,chatMode,chatColors,displayedSkinParts,mainHand);
}","@Override public Packet decode(ByteBuf byteBuf){
  String locale;
  try {
    locale=ByteBufUtils.readUTF8(byteBuf);
  }
 catch (  IOException e) {
    logger.error(e.getMessage());
    locale=""String_Node_Str"";
  }
  final byte viewDistance=byteBuf.readByte();
  ChatMode chatMode;
  try {
    chatMode=ChatMode.fromModeID(ByteBufUtils.readVarInt(byteBuf));
  }
 catch (  IOException e) {
    logger.error(e.getMessage());
    chatMode=ChatMode.ENABLED;
  }
  final boolean chatColors=byteBuf.readBoolean();
  final DisplayedSkinParts[] displayedSkinParts=DisplayedSkinParts.fromBitMask(byteBuf.readByte());
  MainHand mainHand;
  try {
    mainHand=MainHand.fromHandID(ByteBufUtils.readVarInt(byteBuf));
  }
 catch (  IOException e) {
    logger.error(e.getMessage());
    mainHand=MainHand.RIGHT;
  }
  return new ClientSettingsPacket(locale,viewDistance,chatMode,chatColors,displayedSkinParts,mainHand);
}"
76723,"@Nullable public InetAddress convert(String address){
  try {
    return InetAddress.getByName(address);
  }
 catch (  UnknownHostException e) {
    e.printStackTrace();
    return null;
  }
}","@Nullable public InetAddress convert(@NotNull String address){
  try {
    return InetAddress.getByName(address);
  }
 catch (  UnknownHostException e) {
    logger.error(e.getMessage());
    return null;
  }
}"
76724,"public void init(){
  System.out.println(""String_Node_Str"");
}","public void init(){
}"
76725,"public void destroy(){
  System.out.println(""String_Node_Str"");
}","public void destroy(){
}"
76726,"public void run(){
  System.out.println(""String_Node_Str"");
  cleanstoneNetworking.start();
  minecraftNetworking.start();
}","public void run(){
}"
76727,"public void run(){
  System.out.println(""String_Node_Str"");
  cleanstoneNetworking.start();
}","public void run(){
}"
76728,"@Override protected void initChannel(Channel channel){
  channel.pipeline().addLast(new IdentificationHandler(nettyNetworking,nettyNetworking.getClientAddressBlacklist()),new EncryptionDecoder(),new ByteStreamDecoder(),new CompressionDecoder(),new PacketDataDecoder(nettyNetworking.getProtocol()),new InboundPacketHandler(nettyNetworking));
  channel.pipeline().addFirst(new OutboundPacketHandler(nettyNetworking),new PacketEncoder(nettyNetworking.getProtocol()),new CompressionEncoder(),new ByteStreamEncoder(),new EncryptionEncoder());
}","@Override protected void initChannel(Channel channel){
  channel.pipeline().addLast(""String_Node_Str"",new IdentificationHandler(nettyNetworking));
  channel.pipeline().addLast(""String_Node_Str"",new ChannelInboundHandlerAdapter());
  channel.pipeline().addLast(""String_Node_Str"",new ByteStreamDecoder());
  channel.pipeline().addLast(""String_Node_Str"",new ChannelInboundHandlerAdapter());
  channel.pipeline().addLast(""String_Node_Str"",new PacketDataDecoder(nettyNetworking.getProtocol()));
  channel.pipeline().addLast(""String_Node_Str"",new InboundPacketHandler(nettyNetworking));
  channel.pipeline().addFirst(""String_Node_Str"",new OutboundPacketHandler(nettyNetworking));
  channel.pipeline().addFirst(""String_Node_Str"",new PacketEncoder(nettyNetworking.getProtocol()));
  channel.pipeline().addFirst(""String_Node_Str"",new ChannelOutboundHandlerAdapter());
  channel.pipeline().addFirst(""String_Node_Str"",new ByteStreamEncoder());
  channel.pipeline().addFirst(""String_Node_Str"",new ChannelOutboundHandlerAdapter());
}"
76729,"@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause){
  cause.printStackTrace();
  ctx.close();
}","@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause){
  cause.printStackTrace();
  logger.error(""String_Node_Str"");
  ctx.close();
}"
76730,"@Override protected void decode(ChannelHandlerContext ctx,ByteBuf in,List<Object> out) throws IOException {
  Connection connection=ctx.channel().attr(AttributeKey.<Connection>valueOf(""String_Node_Str"")).get();
  in.markReaderIndex();
  int remainingPacketLength;
  try {
    remainingPacketLength=ByteBufUtils.readVarInt(in);
    if (in.readableBytes() < remainingPacketLength)     throw new NotEnoughReadableBytesException();
  }
 catch (  NotEnoughReadableBytesException e) {
    in.resetReaderIndex();
    return;
  }
  if (!connection.isCompressionEnabled()) {
    out.add(in);
  }
 else {
    int uncompressedDataLength=ByteBufUtils.readVarInt(in);
    ctx.channel().attr(AttributeKey.<Integer>valueOf(""String_Node_Str"")).set(uncompressedDataLength);
    out.add(in);
  }
}","@Override protected void decode(ChannelHandlerContext ctx,ByteBuf in,List<Object> out) throws IOException {
  Connection connection=ctx.channel().attr(AttributeKey.<Connection>valueOf(""String_Node_Str"")).get();
  logger.info(""String_Node_Str"");
  in.markReaderIndex();
  int remainingPacketLength;
  try {
    remainingPacketLength=ByteBufUtils.readVarInt(in);
    if (in.readableBytes() < remainingPacketLength)     throw new NotEnoughReadableBytesException();
  }
 catch (  NotEnoughReadableBytesException e) {
    in.resetReaderIndex();
    return;
  }
  if (!connection.isCompressionEnabled()) {
    out.add(in);
  }
 else {
    int uncompressedDataLength=ByteBufUtils.readVarInt(in);
    ctx.channel().attr(AttributeKey.<Integer>valueOf(""String_Node_Str"")).set(uncompressedDataLength);
    out.add(in);
  }
}"
76731,"@Override protected void decode(ChannelHandlerContext ctx,ByteBuf in,List<Object> out) throws Exception {
  Connection connection=ctx.channel().attr(AttributeKey.<Connection>valueOf(""String_Node_Str"")).get();
  int uncompressedDataLength=ctx.channel().attr(AttributeKey.<Integer>valueOf(""String_Node_Str"")).get();
  if (connection.isCompressionEnabled() && uncompressedDataLength != 0)   super.decode(ctx,in,out);
 else   out.add(in);
}","@Override protected void decode(ChannelHandlerContext ctx,ByteBuf in,List<Object> out) throws Exception {
  super.decode(ctx,in,out);
}"
76732,"@Override protected void decode(ChannelHandlerContext ctx,ByteBuf in,List<Object> out) throws Exception {
  Connection connection=ctx.channel().attr(AttributeKey.<Connection>valueOf(""String_Node_Str"")).get();
  if (!connection.isEncryptionEnabled()) {
    out.add(in);
  }
 else {
    try {
      SecretKey sharedSecret=connection.getSharedSecret();
      Cipher cipher=Cipher.getInstance(""String_Node_Str"");
      cipher.init(Cipher.DECRYPT_MODE,sharedSecret,new IvParameterSpec(sharedSecret.getEncoded()));
      ByteBuffer outNioBuf=ByteBuffer.allocate(in.readableBytes());
      try {
        cipher.update(in.nioBuffer(),outNioBuf);
      }
 catch (      ShortBufferException e) {
        throw new DecoderException(""String_Node_Str"",e);
      }
      outNioBuf.flip();
      out.add(Unpooled.wrappedBuffer(outNioBuf));
    }
  finally {
      ReferenceCountUtil.release(in);
    }
  }
}","@Override protected void decode(ChannelHandlerContext ctx,ByteBuf in,List<Object> out) throws Exception {
  Connection connection=ctx.channel().attr(AttributeKey.<Connection>valueOf(""String_Node_Str"")).get();
  try {
    SecretKey sharedSecret=connection.getSharedSecret();
    Cipher cipher=Cipher.getInstance(""String_Node_Str"");
    cipher.init(Cipher.DECRYPT_MODE,sharedSecret,new IvParameterSpec(sharedSecret.getEncoded()));
    ByteBuffer outNioBuf=ByteBuffer.allocate(in.readableBytes());
    try {
      cipher.update(in.nioBuffer(),outNioBuf);
    }
 catch (    ShortBufferException e) {
      throw new DecoderException(""String_Node_Str"",e);
    }
    outNioBuf.flip();
    out.add(Unpooled.wrappedBuffer(outNioBuf));
  }
  finally {
    ReferenceCountUtil.release(in);
  }
}"
76733,"public IdentificationHandler(Networking networking,Collection<String> addressBlacklist){
  this.networking=networking;
  this.addressBlacklist=addressBlacklist;
}","public IdentificationHandler(Networking networking){
  this.networking=networking;
  this.addressBlacklist=networking.getClientAddressBlacklist();
}"
76734,"@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  InetSocketAddress socketAddress=(InetSocketAddress)ctx.channel().remoteAddress();
  InetAddress inetaddress=socketAddress.getAddress();
  String ipAddress=inetaddress.getHostAddress();
  if (addressBlacklist.contains(ipAddress))   ctx.close();
  Attribute<Connection> connectionKey=ctx.channel().attr(AttributeKey.valueOf(""String_Node_Str""));
  if (connectionKey.get() == null) {
    Connection connection=new NettyConnection(ctx.channel(),inetaddress,networking.getProtocol().getDefaultClientLayer(),networking.getProtocol().getDefaultState());
    connectionKey.set(connection);
    if (CleanstoneServer.publishEvent(new ConnectionOpenEvent(connection,networking)).isCancelled()) {
      ctx.close();
    }
    ctx.channel().closeFuture().addListener((a) -> CleanstoneServer.publishEvent(new ConnectionClosedEvent(connection,networking)));
  }
  ctx.fireChannelRead(msg);
}","@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  InetSocketAddress socketAddress=(InetSocketAddress)ctx.channel().remoteAddress();
  InetAddress inetaddress=socketAddress.getAddress();
  String ipAddress=inetaddress.getHostAddress();
  logger.info(""String_Node_Str"" + ipAddress);
  if (addressBlacklist.contains(ipAddress))   ctx.close();
  Attribute<Connection> connectionKey=ctx.channel().attr(AttributeKey.valueOf(""String_Node_Str""));
  if (connectionKey.get() == null) {
    logger.info(""String_Node_Str"");
    Connection connection=new NettyConnection(ctx.channel(),inetaddress,networking.getProtocol().getDefaultClientLayer(),networking.getProtocol().getDefaultState());
    connectionKey.set(connection);
    if (CleanstoneServer.publishEvent(new ConnectionOpenEvent(connection,networking)).isCancelled()) {
      ctx.close();
    }
    ctx.channel().closeFuture().addListener((a) -> CleanstoneServer.publishEvent(new ConnectionClosedEvent(connection,networking)));
  }
  ctx.fireChannelRead(msg);
}"
76735,"@Override public int creatorId(){
  return 318585602;
}","@Override public int creatorId(){
  return 1234567890;
}"
76736,"private void recieveData(){
  byte buf[]=new byte[1024];
  int len=0;
  try {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    Log.d(""String_Node_Str"",serverSocket.getLocalSocketAddress().toString());
    Log.d(""String_Node_Str"",String.valueOf(serverSocket.getLocalPort()));
    client=serverSocket.accept();
    Log.d(""String_Node_Str"",""String_Node_Str"");
    if (isCancelled())     return;
    InputStream inputStream=client.getInputStream();
    ObjectInputStream objectInputStream=new ObjectInputStream(inputStream);
    int sizeOfItems=objectInputStream.readInt();
    ArrayList<String> fileNames=(ArrayList<String>)objectInputStream.readObject();
    ArrayList<Long> fileSizes=(ArrayList<Long>)objectInputStream.readObject();
    for (int i=0; i < sizeOfItems; i++) {
      String fileName=fileNames.get(i);
      fileSize=fileSizes.get(i);
      fileSizeOriginal=fileSizes.get(i);
      file=new File(Environment.getExternalStorageDirectory() + ""String_Node_Str"" + context.getApplicationContext().getPackageName()+ ""String_Node_Str""+ fileName);
      Log.d(""String_Node_Str"",file.getPath());
      File dir=file.getParentFile();
      if (!dir.exists())       dir.mkdirs();
      if (file.exists())       file.delete();
      if (file.createNewFile()) {
        Log.d(""String_Node_Str"",""String_Node_Str"");
      }
 else       Log.d(""String_Node_Str"",""String_Node_Str"");
      OutputStream outputStream=new FileOutputStream(file);
      CustomObject progress=new CustomObject();
      progress.name=fileName;
      progress.dataIncrement=0;
      progress.totalProgress=0;
      try {
        while (fileSize > 0 && (len=inputStream.read(buf,0,(int)Math.min(buf.length,fileSize))) != -1) {
          outputStream.write(buf,0,len);
          fileSize-=len;
          progress.dataIncrement=(long)len;
          if (((int)(progress.totalProgress * 100 / fileSizeOriginal)) == ((int)((progress.totalProgress + progress.dataIncrement) * 100 / fileSizeOriginal))) {
            progress.totalProgress+=progress.dataIncrement;
            continue;
          }
          progress.totalProgress+=progress.dataIncrement;
          publishProgress(progress);
          if (this.isCancelled())           return;
        }
        Log.d(""String_Node_Str"",""String_Node_Str"" + len);
      }
 catch (      Exception e) {
        Log.d(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
      outputStream.flush();
      outputStream.close();
    }
    inputStream.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","private void recieveData(){
  byte buf[]=new byte[1024];
  int len=0;
  try {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    Log.d(""String_Node_Str"",serverSocket.getLocalSocketAddress().toString());
    Log.d(""String_Node_Str"",String.valueOf(serverSocket.getLocalPort()));
    client=serverSocket.accept();
    Log.d(""String_Node_Str"",""String_Node_Str"");
    if (isCancelled())     return;
    InputStream inputStream=client.getInputStream();
    ObjectInputStream objectInputStream=new ObjectInputStream(inputStream);
    int sizeOfItems=objectInputStream.readInt();
    ArrayList<String> fileNames=(ArrayList<String>)objectInputStream.readObject();
    ArrayList<Long> fileSizes=(ArrayList<Long>)objectInputStream.readObject();
    for (int i=0; i < sizeOfItems; i++) {
      String fileName=fileNames.get(i);
      fileSize=fileSizes.get(i);
      fileSizeOriginal=fileSizes.get(i);
      file=new File(Environment.getExternalStorageDirectory() + ""String_Node_Str"" + context.getApplicationContext().getPackageName()+ ""String_Node_Str""+ fileName);
      Log.d(""String_Node_Str"",file.getPath());
      File dir=file.getParentFile();
      if (!dir.exists())       dir.mkdirs();
      if (file.exists())       file.delete();
      if (file.createNewFile()) {
        Log.d(""String_Node_Str"",""String_Node_Str"");
      }
 else       Log.d(""String_Node_Str"",""String_Node_Str"");
      OutputStream outputStream=new FileOutputStream(file);
      CustomObject progress=new CustomObject();
      progress.name=fileName;
      progress.dataIncrement=0;
      progress.totalProgress=0;
      try {
        while (fileSize > 0 && (len=objectInputStream.read(buf,0,(int)Math.min(buf.length,fileSize))) != -1) {
          outputStream.write(buf,0,len);
          fileSize-=len;
          progress.dataIncrement=(long)len;
          if (((int)(progress.totalProgress * 100 / fileSizeOriginal)) == ((int)((progress.totalProgress + progress.dataIncrement) * 100 / fileSizeOriginal))) {
            progress.totalProgress+=progress.dataIncrement;
            continue;
          }
          progress.totalProgress+=progress.dataIncrement;
          publishProgress(progress);
          if (this.isCancelled())           return;
        }
        Log.d(""String_Node_Str"",""String_Node_Str"" + len);
      }
 catch (      Exception e) {
        Log.d(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
      outputStream.flush();
      outputStream.close();
    }
    objectInputStream.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
76737,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_send_file);
  rvSendingFilesList=findViewById(R.id.rvSendingFilesList);
  LinearLayoutManager filesListLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvSendingFilesList.setLayoutManager(filesListLayoutManager);
  sendFilesAdapter=new FilesSendAdapter();
  rvSendingFilesList.setAdapter(sendFilesAdapter);
  rvReceivingFilesList=findViewById(R.id.rvReceivingFilesList);
  LinearLayoutManager receiveFilesListLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvReceivingFilesList.setLayoutManager(receiveFilesListLayoutManager);
  FilesAdapter receiveFilesAdapter=new FilesAdapter(SendFileActivity.this);
  rvReceivingFilesList.setAdapter(receiveFilesAdapter);
  this.initNav();
  this.initSockets();
  callbackReInitServers=() -> SendFileActivity.this.initServers(receiveFilesAdapter);
  peerListListener=peers -> {
    peerList.clear();
    peerList.addAll(peers.getDeviceList());
    peersAdapter.updateList(peerList);
    peersAdapter.notifyDataSetChanged();
  }
;
  callbackSendThisDeviceName=() -> {
    TransferNameDevice transferNameDevice=new TransferNameDevice(serverAddress);
    transferNameDevice.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
  }
;
  infoListener=info -> {
    serverAddress=info.groupOwnerAddress;
    if (serverAddress == null)     return;
    SendFileActivity.this.callbackSendThisDeviceName.call();
    ChooseFile.fileChooser(SendFileActivity.this);
  }
;
  p2pManager=(WifiP2pManager)getSystemService(WIFI_P2P_SERVICE);
  channel=p2pManager.initialize(this,getMainLooper(),null);
  peersAdapter=new PeersAdapter(peerList,this,p2pManager,channel,this,infoListener);
  this.initServers(receiveFilesAdapter);
  try {
    Class<?> wifiManager=Class.forName(""String_Node_Str"");
    Method method=wifiManager.getMethod(""String_Node_Str"",WifiP2pManager.Channel.class);
    method.invoke(p2pManager,channel);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  p2pManager.removeGroup(channel,null);
  myBroadcastReciever=new MyBroadcastReciever(p2pManager,channel,this,infoListener);
  myBroadcastReciever.setPeerListListener(peerListListener);
  intentFilter=new IntentFilter();
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
  registerReceiver(myBroadcastReciever,intentFilter);
  rvDevicesList=findViewById(R.id.rvDevicesList);
  rvDevicesList.setAdapter(peersAdapter);
  RecyclerView.LayoutManager mLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvDevicesList.setLayoutManager(mLayoutManager);
  p2pManager.discoverPeers(channel,null);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_send_file);
  rvSendingFilesList=findViewById(R.id.rvSendingFilesList);
  LinearLayoutManager filesListLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvSendingFilesList.setLayoutManager(filesListLayoutManager);
  sendFilesAdapter=new FilesSendAdapter();
  rvSendingFilesList.setAdapter(sendFilesAdapter);
  rvReceivingFilesList=findViewById(R.id.rvReceivingFilesList);
  LinearLayoutManager receiveFilesListLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvReceivingFilesList.setLayoutManager(receiveFilesListLayoutManager);
  FilesAdapter receiveFilesAdapter=new FilesAdapter(SendFileActivity.this);
  rvReceivingFilesList.setAdapter(receiveFilesAdapter);
  this.initNav();
  this.initSockets();
  callbackReInitFileServer=() -> SendFileActivity.this.initFileServer(receiveFilesAdapter);
  callbackReInitDeviceServer=SendFileActivity.this::initDeviceInfoServers;
  peerListListener=peers -> {
    peerList.clear();
    peerList.addAll(peers.getDeviceList());
    peersAdapter.updateList(peerList);
    peersAdapter.notifyDataSetChanged();
  }
;
  callbackSendThisDeviceName=() -> {
    TransferNameDevice transferNameDevice=new TransferNameDevice(serverAddress);
    transferNameDevice.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
  }
;
  infoListener=info -> {
    serverAddress=info.groupOwnerAddress;
    if (serverAddress == null)     return;
    SendFileActivity.this.callbackSendThisDeviceName.call();
    ChooseFile.fileChooser(SendFileActivity.this);
  }
;
  p2pManager=(WifiP2pManager)getSystemService(WIFI_P2P_SERVICE);
  channel=p2pManager.initialize(this,getMainLooper(),null);
  peersAdapter=new PeersAdapter(peerList,this,p2pManager,channel,this,infoListener);
  this.initFileServer(receiveFilesAdapter);
  this.initDeviceInfoServers();
  try {
    Class<?> wifiManager=Class.forName(""String_Node_Str"");
    Method method=wifiManager.getMethod(""String_Node_Str"",WifiP2pManager.Channel.class);
    method.invoke(p2pManager,channel);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  p2pManager.removeGroup(channel,null);
  myBroadcastReciever=new MyBroadcastReciever(p2pManager,channel,this,infoListener);
  myBroadcastReciever.setPeerListListener(peerListListener);
  intentFilter=new IntentFilter();
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
  registerReceiver(myBroadcastReciever,intentFilter);
  rvDevicesList=findViewById(R.id.rvDevicesList);
  rvDevicesList.setAdapter(peersAdapter);
  RecyclerView.LayoutManager mLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvDevicesList.setLayoutManager(mLayoutManager);
  p2pManager.discoverPeers(channel,null);
}"
76738,"@Override public void onBindViewHolder(final FilesViewHolder holder,int position){
  holder.bind(new FileModel(receivedFiles[position]));
  filesViewHolders.add(holder);
}","@Override public void onBindViewHolder(final FilesViewHolder holder,int position){
  filesViewHolders.add(holder);
  holder.bind(new FileModel(receivedFiles[position]));
}"
76739,"FilesViewHolder(View itemView,Context context){
  super(itemView);
  this.view=itemView;
  this.context=context;
  tvItemTitle=itemView.findViewById(R.id.tvItemTitle);
  ivItemType=itemView.findViewById(R.id.ivItemType);
}","FilesViewHolder(View itemView,Context context){
  super(itemView);
  this.view=itemView;
  this.context=context;
  tvItemTitle=itemView.findViewById(R.id.tvItemTitle);
  ivItemType=itemView.findViewById(R.id.ivItemType);
  progressBar=itemView.findViewById(R.id.progressBar);
}"
76740,"public PeersAdapter(List<WifiP2pDevice> peersList,final Context context,final WifiP2pManager manager,final WifiP2pManager.Channel channel,final Activity activity,final WifiP2pManager.ConnectionInfoListener infoListener){
  this.peersList=peersList;
  this.context=context;
  this.manager=manager;
  this.channel=channel;
  this.activity=activity;
  this.infoListener=infoListener;
  listener=new WifiP2pManager.ActionListener(){
    @Override public void onSuccess(){
      Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_LONG).show();
      manager.requestConnectionInfo(channel,infoListener);
      Log.d(""String_Node_Str"",""String_Node_Str"");
      tempHolder.statePeer.setImageResource(R.drawable.d_icon_done);
    }
    @Override public void onFailure(    int reason){
      Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_LONG).show();
      Log.d(""String_Node_Str"",""String_Node_Str"");
    }
  }
;
}","public PeersAdapter(List<WifiP2pDevice> peersList,final Context context,final WifiP2pManager manager,final WifiP2pManager.Channel channel,final Activity activity,final WifiP2pManager.ConnectionInfoListener infoListener){
  this.peersList=peersList;
  this.context=context;
  this.manager=manager;
  this.channel=channel;
  this.activity=activity;
  this.infoListener=infoListener;
  listener=new WifiP2pManager.ActionListener(){
    @Override public void onSuccess(){
      Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_LONG).show();
      tempHolder.statePeer.setImageResource(R.drawable.d_icon_done);
      tempHolder.itemSyncing.setVisibility(View.INVISIBLE);
      manager.requestConnectionInfo(channel,infoListener);
      Log.d(""String_Node_Str"",""String_Node_Str"");
    }
    @Override public void onFailure(    int reason){
      Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_LONG).show();
      Log.d(""String_Node_Str"",""String_Node_Str"");
    }
  }
;
}"
76741,"@Override public void onSuccess(){
  Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_LONG).show();
  manager.requestConnectionInfo(channel,infoListener);
  Log.d(""String_Node_Str"",""String_Node_Str"");
  tempHolder.statePeer.setImageResource(R.drawable.d_icon_done);
}","@Override public void onSuccess(){
  Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_LONG).show();
  tempHolder.statePeer.setImageResource(R.drawable.d_icon_done);
  tempHolder.itemSyncing.setVisibility(View.INVISIBLE);
  manager.requestConnectionInfo(channel,infoListener);
  Log.d(""String_Node_Str"",""String_Node_Str"");
}"
76742,"@Override public void onBindViewHolder(PeersViewHolder holder,int position){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  holder.setPeer(peersList.get(position));
  try {
    final String deviceAddress=holder.device.deviceAddress;
    holder.peerView.setOnClickListener(v -> {
      Log.d(""String_Node_Str"",""String_Node_Str"");
      ConnectPeer.connect(deviceAddress,manager,channel,context,listener);
      holder.statePeer.setImageResource(R.drawable.d_icon_refresh);
      tempHolder=holder;
    }
);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Override public void onBindViewHolder(PeersViewHolder holder,int position){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  holder.setPeer(peersList.get(position));
  try {
    final String deviceAddress=holder.device.deviceAddress;
    holder.peerView.setOnClickListener(v -> {
      Log.d(""String_Node_Str"",""String_Node_Str"");
      ConnectPeer.connect(deviceAddress,manager,channel,context,listener);
      holder.statePeer.setImageResource(R.drawable.d_icon_refresh);
      holder.statePeer.setVisibility(View.VISIBLE);
      holder.itemSyncing.setVisibility(View.VISIBLE);
      tempHolder=holder;
    }
);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
76743,"public PeersViewHolder(View itemView){
  super(itemView);
  peerName=itemView.findViewById(R.id.tvItemTitle);
  statePeer=itemView.findViewById(R.id.imgState);
  peerView=itemView;
}","public PeersViewHolder(View itemView){
  super(itemView);
  peerName=itemView.findViewById(R.id.tvItemTitle);
  statePeer=itemView.findViewById(R.id.ivItemSyncStatus);
  itemSyncing=itemView.findViewById(R.id.tvItemSyncing);
  peerView=itemView;
}"
76744,"@Override protected void onProgressUpdate(CustomObject... values){
  super.onProgressUpdate(values);
  for (int i=0; i < this.fileList.receivedFiles.length; i++) {
    if (this.fileList.receivedFiles[i].getName().equals(values[0].name)) {
      FilesViewHolder holder=this.fileList.filesViewHolders.get(i);
      if (holder.progressBar.getVisibility() != View.VISIBLE) {
        holder.progressBar.setVisibility(View.VISIBLE);
      }
      holder.progressBar.setProgress((int)((values[0].totalProgress * 100) / fileSizeOriginal));
    }
 else {
      this.fileList.notifyAdapter();
    }
  }
}","@Override protected void onProgressUpdate(CustomObject... values){
  super.onProgressUpdate(values);
  boolean isNotContain=true;
  for (int i=0; i < this.fileList.receivedFiles.length; i++) {
    if (this.fileList.receivedFiles[i].getName().equals(values[0].name)) {
      isNotContain=false;
      if (this.fileList.filesViewHolders.size() != this.fileList.receivedFiles.length) {
        break;
      }
      FilesViewHolder holder=this.fileList.filesViewHolders.get(i);
      if (holder.progressBar.getVisibility() != View.VISIBLE) {
        holder.progressBar.setVisibility(View.VISIBLE);
      }
      holder.progressBar.setProgress((int)((values[0].totalProgress * 100) / fileSizeOriginal));
    }
  }
  if (isNotContain) {
    this.fileList.notifyAdapter();
  }
}"
76745,"@Override protected void onPostExecute(Void aVoid){
  super.onPostExecute(aVoid);
  fileList.notifyAdapter();
  Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_LONG).show();
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Log.d(""String_Node_Str"",file.length() + ""String_Node_Str"");
  try {
    serverSocket.close();
    client.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Override protected void onPostExecute(Void aVoid){
  super.onPostExecute(aVoid);
  this.fileList.filesViewHolders.get(fileList.receivedFiles.length - 1).progressBar.setVisibility(View.INVISIBLE);
  this.fileList.notifyAdapter();
  Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_LONG).show();
  Log.d(""String_Node_Str"",""String_Node_Str"");
  try {
    serverSocket.close();
    client.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
76746,"public TransferData(Context context,ArrayList<Uri> uris,ArrayList<String> fileNames,ArrayList<Long> filesLength,InetAddress serverAddress){
  this.context=context;
  this.uris=uris;
  this.fileNames=fileNames;
  this.filesLength=filesLength;
  this.serverAddress=serverAddress;
  Log.d(""String_Node_Str"",serverAddress.getHostAddress());
  Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}","public TransferData(Context context,ArrayList<Uri> uris,ArrayList<String> fileNames,ArrayList<Long> filesLength,InetAddress serverAddress,final WifiP2pManager manager,final WifiP2pManager.Channel channel){
  this.context=context;
  this.channel=channel;
  this.manager=manager;
  this.uris=uris;
  this.fileNames=fileNames;
  this.filesLength=filesLength;
  this.serverAddress=serverAddress;
  Log.d(""String_Node_Str"",serverAddress.getHostAddress());
  Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}"
76747,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_send_file);
  rvSendingFilesList=findViewById(R.id.rvSendingFilesList);
  LinearLayoutManager filesListLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvSendingFilesList.setLayoutManager(filesListLayoutManager);
  FilesAdapter filesAdapter=new FilesAdapter(SendFileActivity.this);
  rvSendingFilesList.setAdapter(filesAdapter);
  Log.d(""String_Node_Str"",""String_Node_Str"" + (serverSocket == null));
  rvReceivingFilesList=findViewById(R.id.rvReceivingFilesList);
  initNav();
  try {
    serverSocket=new ServerSocket(8888);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  Log.d(""String_Node_Str"",""String_Node_Str"");
  fileServerAsyncTask=new FileServerAsyncTask((SendFileActivity.this),(serverSocket),(filesAdapter));
  fileServerAsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
  Log.d(""String_Node_Str"",""String_Node_Str"");
  peerListListener=peers -> {
    peerList.clear();
    peerList.addAll(peers.getDeviceList());
    peersAdapter.updateList(peerList);
    peersAdapter.notifyDataSetChanged();
  }
;
  infoListener=info -> {
    serverAddress=info.groupOwnerAddress;
    if (serverAddress == null)     return;
    Toast.makeText(getApplicationContext(),""String_Node_Str"" + String.valueOf(info.isGroupOwner),Toast.LENGTH_LONG).show();
    Toast.makeText(SendFileActivity.this,""String_Node_Str"" + serverAddress.toString(),Toast.LENGTH_LONG).show();
    Log.d(""String_Node_Str"",info.toString());
    Toast.makeText(getApplicationContext(),""String_Node_Str"" + info.groupFormed,Toast.LENGTH_LONG).show();
    ChooseFile.fileChooser(SendFileActivity.this);
  }
;
  p2pManager=(WifiP2pManager)getSystemService(WIFI_P2P_SERVICE);
  channel=p2pManager.initialize(this,getMainLooper(),null);
  try {
    Class<?> wifiManager=Class.forName(""String_Node_Str"");
    Method method=wifiManager.getMethod(""String_Node_Str"",WifiP2pManager.Channel.class);
    method.invoke(p2pManager,channel);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  p2pManager.removeGroup(channel,new WifiP2pManager.ActionListener(){
    @Override public void onSuccess(){
      Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
    }
    @Override public void onFailure(    int reason){
      Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      Log.d(""String_Node_Str"",reason + ""String_Node_Str"");
    }
  }
);
  myBroadcastReciever=new MyBroadcastReciever(p2pManager,channel,this,infoListener);
  myBroadcastReciever.setPeerListListener(peerListListener);
  intentFilter=new IntentFilter();
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
  registerReceiver(myBroadcastReciever,intentFilter);
  peersAdapter=new PeersAdapter(peerList,this,p2pManager,channel,this,infoListener);
  rvDevicesList=findViewById(R.id.rvDevicesList);
  rvDevicesList.setAdapter(peersAdapter);
  RecyclerView.LayoutManager mLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvDevicesList.setLayoutManager(mLayoutManager);
  p2pManager.discoverPeers(channel,new WifiP2pManager.ActionListener(){
    @Override public void onSuccess(){
      Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
    }
    @Override public void onFailure(    int reason){
      Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_send_file);
  rvSendingFilesList=findViewById(R.id.rvSendingFilesList);
  LinearLayoutManager filesListLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvSendingFilesList.setLayoutManager(filesListLayoutManager);
  rvReceivingFilesList=findViewById(R.id.rvReceivingFilesList);
  LinearLayoutManager receiveFilesListLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvReceivingFilesList.setLayoutManager(receiveFilesListLayoutManager);
  FilesAdapter receiveFilesAdapter=new FilesAdapter(SendFileActivity.this);
  rvReceivingFilesList.setAdapter(receiveFilesAdapter);
  initNav();
  try {
    serverSocket=new ServerSocket(8888);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  fileServerAsyncTask=new FileServerAsyncTask((SendFileActivity.this),(serverSocket),(receiveFilesAdapter));
  fileServerAsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
  peerListListener=peers -> {
    peerList.clear();
    peerList.addAll(peers.getDeviceList());
    peersAdapter.updateList(peerList);
    peersAdapter.notifyDataSetChanged();
  }
;
  infoListener=info -> {
    serverAddress=info.groupOwnerAddress;
    if (serverAddress == null)     return;
    Toast.makeText(getApplicationContext(),""String_Node_Str"" + String.valueOf(info.isGroupOwner),Toast.LENGTH_LONG).show();
    Toast.makeText(SendFileActivity.this,""String_Node_Str"" + serverAddress.toString(),Toast.LENGTH_LONG).show();
    Log.d(""String_Node_Str"",info.toString());
    Toast.makeText(getApplicationContext(),""String_Node_Str"" + info.groupFormed,Toast.LENGTH_LONG).show();
    ChooseFile.fileChooser(SendFileActivity.this);
  }
;
  p2pManager=(WifiP2pManager)getSystemService(WIFI_P2P_SERVICE);
  channel=p2pManager.initialize(this,getMainLooper(),null);
  try {
    Class<?> wifiManager=Class.forName(""String_Node_Str"");
    Method method=wifiManager.getMethod(""String_Node_Str"",WifiP2pManager.Channel.class);
    method.invoke(p2pManager,channel);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  p2pManager.removeGroup(channel,null);
  myBroadcastReciever=new MyBroadcastReciever(p2pManager,channel,this,infoListener);
  myBroadcastReciever.setPeerListListener(peerListListener);
  intentFilter=new IntentFilter();
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
  registerReceiver(myBroadcastReciever,intentFilter);
  peersAdapter=new PeersAdapter(peerList,this,p2pManager,channel,this,infoListener);
  rvDevicesList=findViewById(R.id.rvDevicesList);
  rvDevicesList.setAdapter(peersAdapter);
  RecyclerView.LayoutManager mLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvDevicesList.setLayoutManager(mLayoutManager);
  p2pManager.discoverPeers(channel,null);
}"
76748,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
switch (requestCode) {
case ChooseFile.FILE_TRANSFER_CODE:
    if (data == null)     return;
  ArrayList<Uri> uris=new ArrayList<>();
ArrayList<Long> filesLength=new ArrayList<>();
ArrayList<String> fileNames=new ArrayList<>();
try {
ClipData clipData=data.getClipData();
if (clipData != null) {
for (int i=0; i < clipData.getItemCount(); i++) {
  uris.add(clipData.getItemAt(i).getUri());
  String fileName=PathUtil.getPath(getApplicationContext(),clipData.getItemAt(i).getUri());
  filesLength.add(new File(fileName).length());
  fileName=FilesUtil.getFileName(fileName);
  fileNames.add(fileName);
  Log.d(""String_Node_Str"",clipData.getItemAt(i).getUri().toString());
  Log.d(""String_Node_Str"",fileName);
}
}
 else {
Uri uri=data.getData();
uris.add(uri);
String fileName=PathUtil.getPath(getApplicationContext(),uri);
filesLength.add(new File(fileName).length());
fileName=FilesUtil.getFileName(fileName);
fileNames.add(fileName);
}
TransferData transferData=new TransferData(SendFileActivity.this,uris,fileNames,filesLength,serverAddress);
transferData.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
 catch (Exception e) {
e.printStackTrace();
}
}
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
switch (requestCode) {
case ChooseFile.FILE_TRANSFER_CODE:
    if (data == null)     return;
  ArrayList<Uri> uris=new ArrayList<>();
ArrayList<Long> filesLength=new ArrayList<>();
ArrayList<String> fileNames=new ArrayList<>();
try {
ClipData clipData=data.getClipData();
if (clipData != null) {
for (int i=0; i < clipData.getItemCount(); i++) {
  uris.add(clipData.getItemAt(i).getUri());
  String fileName=PathUtil.getPath(getApplicationContext(),clipData.getItemAt(i).getUri());
  filesLength.add(new File(fileName).length());
  fileName=FilesUtil.getFileName(fileName);
  fileNames.add(fileName);
  Log.d(""String_Node_Str"",clipData.getItemAt(i).getUri().toString());
  Log.d(""String_Node_Str"",fileName);
}
}
 else {
Uri uri=data.getData();
uris.add(uri);
String fileName=PathUtil.getPath(getApplicationContext(),uri);
filesLength.add(new File(fileName).length());
fileName=FilesUtil.getFileName(fileName);
fileNames.add(fileName);
}
TransferData transferData=new TransferData(SendFileActivity.this,uris,fileNames,filesLength,serverAddress,p2pManager,channel);
transferData.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
 catch (Exception e) {
e.printStackTrace();
}
}
}"
76749,"private void sendData(Context context,ArrayList<Uri> uris){
  int len=0;
  byte buf[]=new byte[1024];
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Socket socket=new Socket();
  try {
    socket.bind(null);
    Log.d(""String_Node_Str"",socket.getLocalSocketAddress().toString());
    socket.connect(new InetSocketAddress(serverAddress,8888));
    Log.d(""String_Node_Str"",""String_Node_Str"");
    OutputStream outputStream=socket.getOutputStream();
    ObjectOutputStream objectOutputStream=new ObjectOutputStream(outputStream);
    ContentResolver cr=context.getContentResolver();
    objectOutputStream.writeInt(uris.size());
    objectOutputStream.writeObject(fileNames);
    objectOutputStream.flush();
    objectOutputStream.writeObject(filesLength);
    objectOutputStream.flush();
    for (int i=0; i < uris.size(); i++) {
      InputStream inputStream=cr.openInputStream(uris.get(i));
      while ((len=inputStream.read(buf)) != -1) {
        objectOutputStream.write(buf,0,len);
        objectOutputStream.flush();
      }
      inputStream.close();
      publishProgress(i);
      if (this.isCancelled())       return;
      Log.d(""String_Node_Str"",""String_Node_Str"" + len);
    }
    objectOutputStream.close();
    socket.close();
  }
 catch (  Exception e) {
    Log.d(""String_Node_Str"",e.toString());
    e.printStackTrace();
  }
 finally {
    if (socket.isConnected()) {
      try {
        socket.close();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
}","private void sendData(Context context,ArrayList<Uri> uris){
  int len=0;
  byte buf[]=new byte[1024];
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Socket socket=new Socket();
  try {
    socket.bind(null);
    Log.d(""String_Node_Str"",socket.getLocalSocketAddress().toString());
    socket.connect(new InetSocketAddress(serverAddress,8888));
    Log.d(""String_Node_Str"",""String_Node_Str"");
    OutputStream outputStream=socket.getOutputStream();
    ObjectOutputStream objectOutputStream=new ObjectOutputStream(outputStream);
    ContentResolver cr=context.getContentResolver();
    objectOutputStream.writeInt(uris.size());
    objectOutputStream.writeObject(fileNames);
    objectOutputStream.flush();
    objectOutputStream.writeObject(filesLength);
    objectOutputStream.flush();
    for (int i=0; i < uris.size(); i++) {
      InputStream inputStream=cr.openInputStream(uris.get(i));
      while ((len=inputStream.read(buf)) != -1) {
        objectOutputStream.write(buf,0,len);
      }
      inputStream.close();
      publishProgress(fileNames.get(i));
      Log.d(""String_Node_Str"",""String_Node_Str"" + len);
    }
    objectOutputStream.close();
    socket.close();
  }
 catch (  Exception e) {
    Log.d(""String_Node_Str"",e.toString());
    e.printStackTrace();
  }
 finally {
    if (socket.isConnected()) {
      try {
        socket.close();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
}"
76750,"@Override protected void onProgressUpdate(Integer... values){
  super.onProgressUpdate(values);
  Log.d(""String_Node_Str"",this.sendFilesAdapter.filesViewHolders.toString());
  this.sendFilesAdapter.filesViewHolders.get(values[0]).stateFile.setImageResource(R.drawable.d_icon_done);
}","@Override protected void onProgressUpdate(String... values){
  super.onProgressUpdate(values);
  Log.d(""String_Node_Str"",this.sendFilesAdapter.filesViewHolders.toString());
  for (int i=0; i < this.sendFilesAdapter.filesViewHolders.size(); i++) {
    if (this.sendFilesAdapter.filesViewHolders.get(i).fileModel.getFileName().equals(values[0])) {
      this.sendFilesAdapter.filesViewHolders.get(i).stateFile.setImageResource(R.drawable.d_icon_done);
    }
  }
}"
76751,"public TransferData(Context context,FilesSendAdapter referenceSendFilesAdapter,InetAddress serverAddress,final WifiP2pManager manager,final WifiP2pManager.Channel channel){
  this.context=context;
  this.channel=channel;
  this.manager=manager;
  this.sendFilesAdapter=referenceSendFilesAdapter;
  this.uris=referenceSendFilesAdapter.uris;
  this.fileNames=referenceSendFilesAdapter.fileNames;
  this.filesLength=referenceSendFilesAdapter.filesLength;
  this.serverAddress=serverAddress;
  Log.d(""String_Node_Str"",serverAddress.getHostAddress());
  Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}","public TransferData(Context context,ArrayList<Uri> uris,ArrayList<Long> filesLength,ArrayList<String> fileNames,FilesSendAdapter referenceSendFilesAdapter,InetAddress serverAddress,final WifiP2pManager manager,final WifiP2pManager.Channel channel){
  this.context=context;
  this.channel=channel;
  this.manager=manager;
  this.sendFilesAdapter=referenceSendFilesAdapter;
  this.uris=uris;
  this.fileNames=fileNames;
  this.filesLength=filesLength;
  this.serverAddress=serverAddress;
  Log.d(""String_Node_Str"",serverAddress.getHostAddress());
  Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}"
76752,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
switch (requestCode) {
case ChooseFile.FILE_TRANSFER_CODE:
    if (data == null)     return;
  ArrayList<Uri> uris=new ArrayList<>();
ArrayList<Long> filesLength=new ArrayList<>();
ArrayList<String> fileNames=new ArrayList<>();
try {
ClipData clipData=data.getClipData();
if (clipData != null) {
for (int i=0; i < clipData.getItemCount(); i++) {
  uris.add(clipData.getItemAt(i).getUri());
  String fileName=PathUtil.getPath(getApplicationContext(),clipData.getItemAt(i).getUri());
  filesLength.add(new File(fileName).length());
  fileName=FilesUtil.getFileName(fileName);
  fileNames.add(fileName);
  Log.d(""String_Node_Str"",clipData.getItemAt(i).getUri().toString());
  Log.d(""String_Node_Str"",fileName);
}
}
 else {
Uri uri=data.getData();
uris.add(uri);
String fileName=PathUtil.getPath(getApplicationContext(),uri);
filesLength.add(new File(fileName).length());
fileName=FilesUtil.getFileName(fileName);
fileNames.add(fileName);
}
sendFilesAdapter.notifyAdapter(uris,filesLength,fileNames);
TransferData transferData=new TransferData(SendFileActivity.this,(sendFilesAdapter),serverAddress,p2pManager,channel);
transferData.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
 catch (Exception e) {
e.printStackTrace();
}
}
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
switch (requestCode) {
case ChooseFile.FILE_TRANSFER_CODE:
    if (data == null)     return;
  ArrayList<Uri> uris=new ArrayList<>();
ArrayList<Long> filesLength=new ArrayList<>();
ArrayList<String> fileNames=new ArrayList<>();
try {
ClipData clipData=data.getClipData();
if (clipData != null) {
for (int i=0; i < clipData.getItemCount(); i++) {
  uris.add(clipData.getItemAt(i).getUri());
  String fileName=PathUtil.getPath(getApplicationContext(),clipData.getItemAt(i).getUri());
  filesLength.add(new File(fileName).length());
  fileName=FilesUtil.getFileName(fileName);
  fileNames.add(fileName);
  Log.d(""String_Node_Str"",clipData.getItemAt(i).getUri().toString());
  Log.d(""String_Node_Str"",fileName);
}
}
 else {
Uri uri=data.getData();
uris.add(uri);
String fileName=PathUtil.getPath(getApplicationContext(),uri);
filesLength.add(new File(fileName).length());
fileName=FilesUtil.getFileName(fileName);
fileNames.add(fileName);
}
sendFilesAdapter.notifyAdapter(uris,filesLength,fileNames);
TransferData transferData=new TransferData(SendFileActivity.this,uris,filesLength,fileNames,(sendFilesAdapter),serverAddress,p2pManager,channel);
transferData.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
 catch (Exception e) {
e.printStackTrace();
}
}
}"
76753,"public static void connect(String deviceAddress,final WifiP2pManager manager,final WifiP2pManager.Channel channel,final Context context,WifiP2pManager.ActionListener listener){
  final WifiP2pConfig config=new WifiP2pConfig();
  config.deviceAddress=deviceAddress;
  Log.d(""String_Node_Str"",""String_Node_Str"");
  manager.connect(channel,config,listener);
}","public static void connect(String deviceAddress,final WifiP2pManager manager,final WifiP2pManager.Channel channel,final Context context,WifiP2pManager.ActionListener listener){
  final WifiP2pConfig config=new WifiP2pConfig();
  config.deviceAddress=deviceAddress;
  config.groupOwnerIntent=0;
  Log.d(""String_Node_Str"",""String_Node_Str"");
  manager.connect(channel,config,listener);
}"
76754,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_send_file);
  rvSendingFilesList=findViewById(R.id.rvSendingFilesList);
  LinearLayoutManager filesListLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvSendingFilesList.setLayoutManager(filesListLayoutManager);
  sendFilesAdapter=new FilesSendAdapter();
  rvSendingFilesList.setAdapter(sendFilesAdapter);
  rvReceivingFilesList=findViewById(R.id.rvReceivingFilesList);
  LinearLayoutManager receiveFilesListLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvReceivingFilesList.setLayoutManager(receiveFilesListLayoutManager);
  FilesAdapter receiveFilesAdapter=new FilesAdapter(SendFileActivity.this);
  rvReceivingFilesList.setAdapter(receiveFilesAdapter);
  this.initNav();
  this.initSockets();
  callbackReInitFileServer=() -> SendFileActivity.this.initFileServer(receiveFilesAdapter);
  callbackReInitDeviceServer=SendFileActivity.this::initDeviceInfoServers;
  peerListListener=peers -> {
    peerList.clear();
    peerList.addAll(peers.getDeviceList());
    peersAdapter.updateList(peerList);
    peersAdapter.notifyDataSetChanged();
  }
;
  callbackSendThisDeviceName=() -> {
    TransferNameDevice transferNameDevice=new TransferNameDevice(serverAddress);
    transferNameDevice.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
  }
;
  infoListener=info -> {
    serverAddress=info.groupOwnerAddress;
    if (serverAddress == null)     return;
    SendFileActivity.this.callbackSendThisDeviceName.call();
    ChooseFile.fileChooser(SendFileActivity.this);
  }
;
  p2pManager=(WifiP2pManager)getSystemService(WIFI_P2P_SERVICE);
  channel=p2pManager.initialize(this,getMainLooper(),null);
  peersAdapter=new PeersAdapter(peerList,this,p2pManager,channel,this,infoListener);
  this.initFileServer(receiveFilesAdapter);
  this.initDeviceInfoServers();
  try {
    Class<?> wifiManager=Class.forName(""String_Node_Str"");
    Method method=wifiManager.getMethod(""String_Node_Str"",WifiP2pManager.Channel.class);
    method.invoke(p2pManager,channel);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  p2pManager.removeGroup(channel,null);
  myBroadcastReciever=new MyBroadcastReciever(p2pManager,channel,this,infoListener);
  myBroadcastReciever.setPeerListListener(peerListListener);
  intentFilter=new IntentFilter();
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
  registerReceiver(myBroadcastReciever,intentFilter);
  rvDevicesList=findViewById(R.id.rvDevicesList);
  rvDevicesList.setAdapter(peersAdapter);
  RecyclerView.LayoutManager mLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvDevicesList.setLayoutManager(mLayoutManager);
  p2pManager.discoverPeers(channel,null);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_send_file);
  rvSendingFilesList=findViewById(R.id.rvSendingFilesList);
  LinearLayoutManager filesListLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvSendingFilesList.setLayoutManager(filesListLayoutManager);
  sendFilesAdapter=new FilesSendAdapter();
  rvSendingFilesList.setAdapter(sendFilesAdapter);
  rvReceivingFilesList=findViewById(R.id.rvReceivingFilesList);
  LinearLayoutManager receiveFilesListLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvReceivingFilesList.setLayoutManager(receiveFilesListLayoutManager);
  FilesAdapter receiveFilesAdapter=new FilesAdapter(SendFileActivity.this);
  rvReceivingFilesList.setAdapter(receiveFilesAdapter);
  this.initNav();
  this.initSockets();
  callbackReInitFileServer=() -> SendFileActivity.this.initFileServer(receiveFilesAdapter);
  callbackReInitDeviceServer=SendFileActivity.this::initDeviceInfoServers;
  peerListListener=peers -> {
    peerList.clear();
    peerList.addAll(peers.getDeviceList());
    peersAdapter.updateList(peerList);
    peersAdapter.notifyDataSetChanged();
  }
;
  callbackSendThisDeviceName=() -> {
    TransferNameDevice transferNameDevice=new TransferNameDevice(serverAddress);
    transferNameDevice.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
  }
;
  infoListener=info -> {
    serverAddress=info.groupOwnerAddress;
    if (serverAddress == null)     return;
    SendFileActivity.this.callbackSendThisDeviceName.call();
    ChooseFile.fileChooser(SendFileActivity.this);
  }
;
  p2pManager=(WifiP2pManager)getSystemService(WIFI_P2P_SERVICE);
  channel=p2pManager.initialize(this,getMainLooper(),null);
  this.initFileServer(receiveFilesAdapter);
  try {
    Class<?> wifiManager=Class.forName(""String_Node_Str"");
    Method method=wifiManager.getMethod(""String_Node_Str"",WifiP2pManager.Channel.class);
    method.invoke(p2pManager,channel);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  p2pManager.removeGroup(channel,null);
  myBroadcastReciever=new MyBroadcastReciever(p2pManager,channel,this,infoListener);
  myBroadcastReciever.setPeerListListener(peerListListener);
  intentFilter=new IntentFilter();
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
  intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
  registerReceiver(myBroadcastReciever,intentFilter);
  peersAdapter=new PeersAdapter(peerList,this,p2pManager,channel,this,infoListener);
  this.initDeviceInfoServers();
  rvDevicesList=findViewById(R.id.rvDevicesList);
  rvDevicesList.setAdapter(peersAdapter);
  RecyclerView.LayoutManager mLayoutManager=new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false);
  rvDevicesList.setLayoutManager(mLayoutManager);
  p2pManager.discoverPeers(channel,null);
}"
76755,"private void check(CompileCodeTestCase testCase){
  System.out.println(testCase);
  NMethod nMethod=testCase.deoptimizeAndCompile();
  if (nMethod == null) {
    throw new Error(testCase + ""String_Node_Str"");
  }
  InstalledCode installedCode=testCase.toInstalledCode();
  String str=CompilerToVMHelper.disassembleCodeBlob(installedCode);
  if (str != null) {
    Asserts.assertGT(str.length(),0,testCase + ""String_Node_Str"");
  }
  String str2=CompilerToVMHelper.disassembleCodeBlob(installedCode);
  Asserts.assertEQ(str,str2,testCase + ""String_Node_Str"");
}","private void check(CompileCodeTestCase testCase){
  System.out.println(testCase);
  NMethod nMethod=testCase.deoptimizeAndCompile();
  if (nMethod == null) {
    throw new Error(testCase + ""String_Node_Str"");
  }
  InstalledCode installedCode=testCase.toInstalledCode();
  String str1=CompilerToVMHelper.disassembleCodeBlob(installedCode);
  if (str1 != null) {
    Asserts.assertGT(str1.length(),0,testCase + ""String_Node_Str"");
  }
  String str2=CompilerToVMHelper.disassembleCodeBlob(installedCode);
  String str3=CompilerToVMHelper.disassembleCodeBlob(installedCode);
  Asserts.assertEQ(str2,str3,testCase + ""String_Node_Str"");
}"
76756,"@Override public boolean finishOptionSettings(){
  if (!validateOptions()) {
    return false;
  }
  if (!getSpecifiedTypeElements().isEmpty()) {
    Map<String,PackageElement> map=new HashMap<>();
    PackageElement pkg;
    for (    TypeElement aClass : getIncludedTypeElements()) {
      pkg=utils.containingPackage(aClass);
      if (!map.containsKey(utils.getPackageName(pkg))) {
        map.put(utils.getPackageName(pkg),pkg);
      }
    }
  }
  docPaths=new DocPaths(utils,useModuleDirectories);
  setCreateOverview();
  setTopFile(docEnv);
  workArounds.initDocLint(doclintOpts.values(),tagletManager.getCustomTagNames(),Utils.toLowerCase(htmlVersion.name()));
  return true;
}","@Override public boolean finishOptionSettings(){
  if (!validateOptions()) {
    return false;
  }
  if (!getSpecifiedTypeElements().isEmpty()) {
    Map<String,PackageElement> map=new HashMap<>();
    PackageElement pkg;
    for (    TypeElement aClass : getIncludedTypeElements()) {
      pkg=utils.containingPackage(aClass);
      if (!map.containsKey(utils.getPackageName(pkg))) {
        map.put(utils.getPackageName(pkg),pkg);
      }
    }
  }
  docPaths=new DocPaths(utils,useModuleDirectories);
  setCreateOverview();
  setTopFile(docEnv);
  workArounds.initDocLint(doclintOpts.values(),tagletManager.getAllTagletNames(),Utils.toLowerCase(htmlVersion.name()));
  return true;
}"
76757,"/** 
 * Check whether there are any tags for Serialization Overview section to be printed.
 * @param field the VariableElement object to check for tags.
 * @return true if there are tags to be printed else return false.
 */
protected boolean hasSerializationOverviewTags(VariableElement field){
  Content output=new ContentBuilder();
  TagletWriter.genTagOutput(configuration.tagletManager,field,configuration.tagletManager.getCustomTaglets(field),getTagletWriterInstance(false),output);
  return !output.isEmpty();
}","/** 
 * Check whether there are any tags for Serialization Overview section to be printed.
 * @param field the VariableElement object to check for tags.
 * @return true if there are tags to be printed else return false.
 */
protected boolean hasSerializationOverviewTags(VariableElement field){
  Content output=new ContentBuilder();
  TagletWriter.genTagOutput(configuration.tagletManager,field,configuration.tagletManager.getBlockTaglets(field),getTagletWriterInstance(false),output);
  return !output.isEmpty();
}"
76758,"/** 
 * Adds the tags information.
 * @param e the Element for which the tags will be generated
 * @param htmltree the documentation tree to which the tags will be added
 */
protected void addTagsInfo(Element e,Content htmltree){
  if (configuration.nocomment) {
    return;
  }
  Content dl=new HtmlTree(HtmlTag.DL);
  if (utils.isExecutableElement(e) && !utils.isConstructor(e)) {
    addMethodInfo((ExecutableElement)e,dl);
  }
  Content output=new ContentBuilder();
  TagletWriter.genTagOutput(configuration.tagletManager,e,configuration.tagletManager.getCustomTaglets(e),getTagletWriterInstance(false),output);
  dl.addContent(output);
  htmltree.addContent(dl);
}","/** 
 * Adds the tags information.
 * @param e the Element for which the tags will be generated
 * @param htmltree the documentation tree to which the tags will be added
 */
protected void addTagsInfo(Element e,Content htmltree){
  if (configuration.nocomment) {
    return;
  }
  Content dl=new HtmlTree(HtmlTag.DL);
  if (utils.isExecutableElement(e) && !utils.isConstructor(e)) {
    addMethodInfo((ExecutableElement)e,dl);
  }
  Content output=new ContentBuilder();
  TagletWriter.genTagOutput(configuration.tagletManager,e,configuration.tagletManager.getBlockTaglets(e),getTagletWriterInstance(false),output);
  dl.addContent(output);
  htmltree.addContent(dl);
}"
76759,"/** 
 * Converts inline tags and text to text strings, expanding the inline tags along the way.  Called wherever text can contain an inline tag, such as in comments or in free-form text arguments to non-inline tags.
 * @param holderTag    specific tag where comment resides
 * @param element    specific element where comment resides
 * @param tags   array of text tags and inline tags (often alternating)present in the text of interest for this element
 * @param isFirstSentence  true if text is first sentence
 * @return a Content object
 */
public Content commentTagsToContent(DocTree holderTag,Element element,List<? extends DocTree> tags,boolean isFirstSentence){
  final Content result=new ContentBuilder(){
    @Override public void addContent(    CharSequence text){
      super.addContent(utils.normalizeNewlines(text));
    }
  }
;
  CommentHelper ch=utils.getCommentHelper(element);
  configuration.tagletManager.checkTags(utils,element,tags,true);
  commentRemoved=false;
  for (ListIterator<? extends DocTree> iterator=tags.listIterator(); iterator.hasNext(); ) {
    boolean isFirstNode=!iterator.hasPrevious();
    DocTree tag=iterator.next();
    boolean isLastNode=!iterator.hasNext();
    if (isFirstSentence) {
      if (ignoreNonInlineTag(tag))       continue;
      if ((isLastNode || commentRemoved) && tag.getKind() == TEXT && isAllWhiteSpace(ch.getText(tag)))       continue;
      if ((isFirstNode || commentRemoved) && tag.getKind() == COMMENT) {
        commentRemoved=true;
        continue;
      }
    }
    boolean allDone=new SimpleDocTreeVisitor<Boolean,Content>(){
      private boolean inAnAtag(){
        if (utils.isStartElement(tag)) {
          StartElementTree st=(StartElementTree)tag;
          Name name=st.getName();
          if (name != null) {
            com.sun.tools.doclint.HtmlTag htag=com.sun.tools.doclint.HtmlTag.get(name);
            return htag != null && htag.equals(com.sun.tools.doclint.HtmlTag.A);
          }
        }
        return false;
      }
      @Override public Boolean visitAttribute(      AttributeTree node,      Content c){
        StringBuilder sb=new StringBuilder(SPACER).append(node.getName());
        if (node.getValueKind() == ValueKind.EMPTY) {
          result.addContent(sb);
          return false;
        }
        sb.append(""String_Node_Str"");
        String quote;
switch (node.getValueKind()) {
case DOUBLE:
          quote=""String_Node_Str"";
        break;
case SINGLE:
      quote=""String_Node_Str"";
    break;
default :
  quote=""String_Node_Str"";
break;
}
sb.append(quote);
result.addContent(sb);
Content docRootContent=new ContentBuilder();
boolean isHRef=inAnAtag() && node.getName().toString().equalsIgnoreCase(""String_Node_Str"");
for (DocTree dt : node.getValue()) {
if (utils.isText(dt) && isHRef) {
String text=((TextTree)dt).getBody();
if (text.startsWith(""String_Node_Str"") && !configuration.docrootparent.isEmpty()) {
  result.addContent(configuration.docrootparent);
  docRootContent=new ContentBuilder();
  result.addContent(textCleanup(text.substring(3),isLastNode));
}
 else {
  if (!docRootContent.isEmpty()) {
    docRootContent=copyDocRootContent(docRootContent);
  }
 else {
    text=redirectRelativeLinks(element,(TextTree)dt);
  }
  result.addContent(textCleanup(text,isLastNode));
}
}
 else {
docRootContent=copyDocRootContent(docRootContent);
dt.accept(this,docRootContent);
}
}
copyDocRootContent(docRootContent);
result.addContent(quote);
return false;
}
@Override public Boolean visitComment(CommentTree node,Content c){
result.addContent(new RawHtml(node.getBody()));
return false;
}
private Content copyDocRootContent(Content content){
if (!content.isEmpty()) {
result.addContent(content);
return new ContentBuilder();
}
return content;
}
@Override public Boolean visitDocRoot(DocRootTree node,Content c){
Content docRootContent=TagletWriter.getInlineTagOutput(element,configuration.tagletManager,holderTag,node,getTagletWriterInstance(isFirstSentence));
if (c != null) {
c.addContent(docRootContent);
}
 else {
result.addContent(docRootContent);
}
return false;
}
@Override public Boolean visitEndElement(EndElementTree node,Content c){
RawHtml rawHtml=new RawHtml(""String_Node_Str"" + node.getName() + ""String_Node_Str"");
result.addContent(rawHtml);
return false;
}
@Override public Boolean visitEntity(EntityTree node,Content c){
result.addContent(new RawHtml(node.toString()));
return false;
}
@Override public Boolean visitErroneous(ErroneousTree node,Content c){
messages.warning(ch.getDocTreePath(node),""String_Node_Str"",node);
result.addContent(new RawHtml(node.toString()));
return false;
}
@Override public Boolean visitInheritDoc(InheritDocTree node,Content c){
Content output=TagletWriter.getInlineTagOutput(element,configuration.tagletManager,holderTag,tag,getTagletWriterInstance(isFirstSentence));
result.addContent(output);
return (isFirstSentence && !output.isEmpty());
}
@Override public Boolean visitIndex(IndexTree node,Content p){
Content output=TagletWriter.getInlineTagOutput(element,configuration.tagletManager,holderTag,tag,getTagletWriterInstance(isFirstSentence));
if (output != null) {
result.addContent(output);
}
return false;
}
@Override public Boolean visitLink(LinkTree node,Content c){
result.addContent(seeTagToContent(element,tag));
return false;
}
@Override public Boolean visitLiteral(LiteralTree node,Content c){
String s=node.getBody().getBody();
Content content=new StringContent(utils.normalizeNewlines(s));
if (node.getKind() == CODE) content=HtmlTree.CODE(content);
result.addContent(content);
return false;
}
@Override public Boolean visitSee(SeeTree node,Content c){
result.addContent(seeTagToContent(element,tag));
return false;
}
@Override public Boolean visitStartElement(StartElementTree node,Content c){
String text=""String_Node_Str"" + node.getName();
RawHtml rawHtml=new RawHtml(utils.normalizeNewlines(text));
result.addContent(rawHtml);
for (DocTree dt : node.getAttributes()) {
dt.accept(this,null);
}
result.addContent(new RawHtml(node.isSelfClosing() ? ""String_Node_Str"" : ""String_Node_Str""));
return false;
}
@Override public Boolean visitSummary(SummaryTree node,Content c){
Content output=TagletWriter.getInlineTagOutput(element,configuration.tagletManager,holderTag,tag,getTagletWriterInstance(isFirstSentence));
result.addContent(output);
return false;
}
private CharSequence textCleanup(String text,boolean isLast){
return textCleanup(text,isLast,false);
}
private CharSequence textCleanup(String text,boolean isLast,boolean trimLeader){
if (trimLeader) {
text=removeLeadingWhitespace(text);
}
if (isFirstSentence && isLast) {
text=removeTrailingWhitespace(text);
}
text=utils.replaceTabs(text);
return utils.normalizeNewlines(text);
}
@Override public Boolean visitText(TextTree node,Content c){
String text=node.getBody();
result.addContent(new RawHtml(textCleanup(text,isLastNode,commentRemoved)));
return false;
}
@Override protected Boolean defaultAction(DocTree node,Content c){
Content output=TagletWriter.getInlineTagOutput(element,configuration.tagletManager,holderTag,tag,getTagletWriterInstance(isFirstSentence));
if (output != null) {
result.addContent(output);
}
return false;
}
}
.visit(tag,null);
commentRemoved=false;
if (allDone) break;
}
return result;
}","/** 
 * Converts inline tags and text to text strings, expanding the inline tags along the way.  Called wherever text can contain an inline tag, such as in comments or in free-form text arguments to non-inline tags.
 * @param holderTag    specific tag where comment resides
 * @param element    specific element where comment resides
 * @param tags   array of text tags and inline tags (often alternating)present in the text of interest for this element
 * @param isFirstSentence  true if text is first sentence
 * @return a Content object
 */
public Content commentTagsToContent(DocTree holderTag,Element element,List<? extends DocTree> tags,boolean isFirstSentence){
  final Content result=new ContentBuilder(){
    @Override public void addContent(    CharSequence text){
      super.addContent(utils.normalizeNewlines(text));
    }
  }
;
  CommentHelper ch=utils.getCommentHelper(element);
  configuration.tagletManager.checkTags(element,tags,true);
  commentRemoved=false;
  for (ListIterator<? extends DocTree> iterator=tags.listIterator(); iterator.hasNext(); ) {
    boolean isFirstNode=!iterator.hasPrevious();
    DocTree tag=iterator.next();
    boolean isLastNode=!iterator.hasNext();
    if (isFirstSentence) {
      if (ignoreNonInlineTag(tag))       continue;
      if ((isLastNode || commentRemoved) && tag.getKind() == TEXT && isAllWhiteSpace(ch.getText(tag)))       continue;
      if ((isFirstNode || commentRemoved) && tag.getKind() == COMMENT) {
        commentRemoved=true;
        continue;
      }
    }
    boolean allDone=new SimpleDocTreeVisitor<Boolean,Content>(){
      private boolean inAnAtag(){
        if (utils.isStartElement(tag)) {
          StartElementTree st=(StartElementTree)tag;
          Name name=st.getName();
          if (name != null) {
            com.sun.tools.doclint.HtmlTag htag=com.sun.tools.doclint.HtmlTag.get(name);
            return htag != null && htag.equals(com.sun.tools.doclint.HtmlTag.A);
          }
        }
        return false;
      }
      @Override public Boolean visitAttribute(      AttributeTree node,      Content c){
        StringBuilder sb=new StringBuilder(SPACER).append(node.getName());
        if (node.getValueKind() == ValueKind.EMPTY) {
          result.addContent(sb);
          return false;
        }
        sb.append(""String_Node_Str"");
        String quote;
switch (node.getValueKind()) {
case DOUBLE:
          quote=""String_Node_Str"";
        break;
case SINGLE:
      quote=""String_Node_Str"";
    break;
default :
  quote=""String_Node_Str"";
break;
}
sb.append(quote);
result.addContent(sb);
Content docRootContent=new ContentBuilder();
boolean isHRef=inAnAtag() && node.getName().toString().equalsIgnoreCase(""String_Node_Str"");
for (DocTree dt : node.getValue()) {
if (utils.isText(dt) && isHRef) {
String text=((TextTree)dt).getBody();
if (text.startsWith(""String_Node_Str"") && !configuration.docrootparent.isEmpty()) {
  result.addContent(configuration.docrootparent);
  docRootContent=new ContentBuilder();
  result.addContent(textCleanup(text.substring(3),isLastNode));
}
 else {
  if (!docRootContent.isEmpty()) {
    docRootContent=copyDocRootContent(docRootContent);
  }
 else {
    text=redirectRelativeLinks(element,(TextTree)dt);
  }
  result.addContent(textCleanup(text,isLastNode));
}
}
 else {
docRootContent=copyDocRootContent(docRootContent);
dt.accept(this,docRootContent);
}
}
copyDocRootContent(docRootContent);
result.addContent(quote);
return false;
}
@Override public Boolean visitComment(CommentTree node,Content c){
result.addContent(new RawHtml(node.getBody()));
return false;
}
private Content copyDocRootContent(Content content){
if (!content.isEmpty()) {
result.addContent(content);
return new ContentBuilder();
}
return content;
}
@Override public Boolean visitDocRoot(DocRootTree node,Content c){
Content docRootContent=TagletWriter.getInlineTagOutput(element,configuration.tagletManager,holderTag,node,getTagletWriterInstance(isFirstSentence));
if (c != null) {
c.addContent(docRootContent);
}
 else {
result.addContent(docRootContent);
}
return false;
}
@Override public Boolean visitEndElement(EndElementTree node,Content c){
RawHtml rawHtml=new RawHtml(""String_Node_Str"" + node.getName() + ""String_Node_Str"");
result.addContent(rawHtml);
return false;
}
@Override public Boolean visitEntity(EntityTree node,Content c){
result.addContent(new RawHtml(node.toString()));
return false;
}
@Override public Boolean visitErroneous(ErroneousTree node,Content c){
messages.warning(ch.getDocTreePath(node),""String_Node_Str"",node);
result.addContent(new RawHtml(node.toString()));
return false;
}
@Override public Boolean visitInheritDoc(InheritDocTree node,Content c){
Content output=TagletWriter.getInlineTagOutput(element,configuration.tagletManager,holderTag,tag,getTagletWriterInstance(isFirstSentence));
result.addContent(output);
return (isFirstSentence && !output.isEmpty());
}
@Override public Boolean visitIndex(IndexTree node,Content p){
Content output=TagletWriter.getInlineTagOutput(element,configuration.tagletManager,holderTag,tag,getTagletWriterInstance(isFirstSentence));
if (output != null) {
result.addContent(output);
}
return false;
}
@Override public Boolean visitLink(LinkTree node,Content c){
result.addContent(seeTagToContent(element,tag));
return false;
}
@Override public Boolean visitLiteral(LiteralTree node,Content c){
String s=node.getBody().getBody();
Content content=new StringContent(utils.normalizeNewlines(s));
if (node.getKind() == CODE) content=HtmlTree.CODE(content);
result.addContent(content);
return false;
}
@Override public Boolean visitSee(SeeTree node,Content c){
result.addContent(seeTagToContent(element,tag));
return false;
}
@Override public Boolean visitStartElement(StartElementTree node,Content c){
String text=""String_Node_Str"" + node.getName();
RawHtml rawHtml=new RawHtml(utils.normalizeNewlines(text));
result.addContent(rawHtml);
for (DocTree dt : node.getAttributes()) {
dt.accept(this,null);
}
result.addContent(new RawHtml(node.isSelfClosing() ? ""String_Node_Str"" : ""String_Node_Str""));
return false;
}
@Override public Boolean visitSummary(SummaryTree node,Content c){
Content output=TagletWriter.getInlineTagOutput(element,configuration.tagletManager,holderTag,tag,getTagletWriterInstance(isFirstSentence));
result.addContent(output);
return false;
}
private CharSequence textCleanup(String text,boolean isLast){
return textCleanup(text,isLast,false);
}
private CharSequence textCleanup(String text,boolean isLast,boolean trimLeader){
if (trimLeader) {
text=removeLeadingWhitespace(text);
}
if (isFirstSentence && isLast) {
text=removeTrailingWhitespace(text);
}
text=utils.replaceTabs(text);
return utils.normalizeNewlines(text);
}
@Override public Boolean visitText(TextTree node,Content c){
String text=node.getBody();
result.addContent(new RawHtml(textCleanup(text,isLastNode,commentRemoved)));
return false;
}
@Override protected Boolean defaultAction(DocTree node,Content c){
Content output=TagletWriter.getInlineTagOutput(element,configuration.tagletManager,holderTag,tag,getTagletWriterInstance(isFirstSentence));
if (output != null) {
result.addContent(output);
}
return false;
}
}
.visit(tag,null);
commentRemoved=false;
if (allDone) break;
}
return result;
}"
76760,"/** 
 * Add the tag information for this member.
 * @param field the field to document.
 * @param contentTree the tree to which the member tags info will be added
 */
public void addMemberTags(VariableElement field,Content contentTree){
  Content tagContent=new ContentBuilder();
  TagletWriter.genTagOutput(configuration.tagletManager,field,configuration.tagletManager.getCustomTaglets(field),writer.getTagletWriterInstance(false),tagContent);
  Content dlTags=new HtmlTree(HtmlTag.DL);
  dlTags.addContent(tagContent);
  contentTree.addContent(dlTags);
}","/** 
 * Add the tag information for this member.
 * @param field the field to document.
 * @param contentTree the tree to which the member tags info will be added
 */
public void addMemberTags(VariableElement field,Content contentTree){
  Content tagContent=new ContentBuilder();
  TagletWriter.genTagOutput(configuration.tagletManager,field,configuration.tagletManager.getBlockTaglets(field),writer.getTagletWriterInstance(false),tagContent);
  Content dlTags=new HtmlTree(HtmlTag.DL);
  dlTags.addContent(tagContent);
  contentTree.addContent(dlTags);
}"
76761,"/** 
 * Initialize the taglet manager.  The strings to initialize the simple custom tags should be in the following format:  ""[tag name]:[location str]:[heading]"".
 * @param customTagStrs the set two dimensional arrays of strings.  These arrays containeither -tag or -taglet arguments.
 */
private void initTagletManager(Set<List<String>> customTagStrs){
  tagletManager=tagletManager == null ? new TagletManager(nosince,showversion,showauthor,javafx,this) : tagletManager;
  for (  List<String> args : customTagStrs) {
    if (args.get(0).equals(""String_Node_Str"")) {
      tagletManager.addCustomTag(args.get(1),getFileManager(),tagletpath);
      continue;
    }
    List<String> tokens=tokenize(args.get(1),TagletManager.SIMPLE_TAGLET_OPT_SEPARATOR,3);
    if (tokens.size() == 1) {
      String tagName=args.get(1);
      if (tagletManager.isKnownCustomTag(tagName)) {
        tagletManager.addNewSimpleCustomTag(tagName,null,""String_Node_Str"");
      }
 else {
        StringBuilder heading=new StringBuilder(tagName + ""String_Node_Str"");
        heading.setCharAt(0,Character.toUpperCase(tagName.charAt(0)));
        tagletManager.addNewSimpleCustomTag(tagName,heading.toString(),""String_Node_Str"");
      }
    }
 else     if (tokens.size() == 2) {
      tagletManager.addNewSimpleCustomTag(tokens.get(0),tokens.get(1),""String_Node_Str"");
    }
 else     if (tokens.size() >= 3) {
      tagletManager.addNewSimpleCustomTag(tokens.get(0),tokens.get(2),tokens.get(1));
    }
 else {
      Messages messages=getMessages();
      messages.error(""String_Node_Str"",args.get(1));
    }
  }
}","/** 
 * Initialize the taglet manager.  The strings to initialize the simple custom tags should be in the following format:  ""[tag name]:[location str]:[heading]"".
 * @param customTagStrs the set two dimensional arrays of strings.  These arrays containeither -tag or -taglet arguments.
 */
private void initTagletManager(Set<List<String>> customTagStrs){
  tagletManager=tagletManager == null ? new TagletManager(nosince,showversion,showauthor,javafx,this) : tagletManager;
  for (  List<String> args : customTagStrs) {
    if (args.get(0).equals(""String_Node_Str"")) {
      tagletManager.addCustomTag(args.get(1),getFileManager(),tagletpath);
      continue;
    }
    List<String> tokens=tokenize(args.get(1),TagletManager.SIMPLE_TAGLET_OPT_SEPARATOR,3);
switch (tokens.size()) {
case 1:
      String tagName=args.get(1);
    if (tagletManager.isKnownCustomTag(tagName)) {
      tagletManager.addNewSimpleCustomTag(tagName,null,""String_Node_Str"");
    }
 else {
      StringBuilder heading=new StringBuilder(tagName + ""String_Node_Str"");
      heading.setCharAt(0,Character.toUpperCase(tagName.charAt(0)));
      tagletManager.addNewSimpleCustomTag(tagName,heading.toString(),""String_Node_Str"");
    }
  break;
case 2:
tagletManager.addNewSimpleCustomTag(tokens.get(0),tokens.get(1),""String_Node_Str"");
break;
case 3:
tagletManager.addNewSimpleCustomTag(tokens.get(0),tokens.get(2),tokens.get(1));
break;
default :
Messages messages=getMessages();
messages.error(""String_Node_Str"",args.get(1));
}
}
}"
76762,"public Set<Doclet.Option> getSupportedOptions(){
  Resources resources=getResources();
  Doclet.Option[] options={new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      showauthor=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      destDirName=addTrailingFileSep(args.get(0));
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      docencoding=args.get(0);
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      copydocfilesubdirs=true;
      return true;
    }
  }
,new Hidden(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      encoding=args.get(0);
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      addToSet(excludedDocFileDirs,args.get(0));
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",2){
    @Override public boolean process(    String opt,    List<String> args){
      groupPairs.add(new Pair<>(args.get(0),args.get(1)));
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      javafx=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      keywords=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      linkList.add(args.get(0));
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      linksource=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",2){
    @Override public boolean process(    String opt,    List<String> args){
      linkOfflineList.add(new Pair<>(args.get(0),args.get(1)));
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      nocomment=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      nodeprecated=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      nosince=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      notimestamp=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      addToSet(excludedQualifiers,args.get(0));
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      String o=args.get(0);
switch (o) {
case ""String_Node_Str"":
        summarizeOverriddenMethods=true;
      break;
case ""String_Node_Str"":
    summarizeOverriddenMethods=false;
  break;
default :
reporter.print(ERROR,getText(""String_Node_Str"",o,""String_Node_Str""));
return false;
}
return true;
}
}
,new Hidden(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
quiet=true;
return true;
}
}
,new Option(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
serialwarn=true;
return true;
}
}
,new Option(resources,""String_Node_Str"",1){
@Override public boolean process(String opt,List<String> args){
linksource=true;
try {
setTabWidth(Integer.parseInt(args.get(0)));
}
 catch (NumberFormatException e) {
sourcetab=-1;
}
if (sourcetab <= 0) {
getMessages().warning(""String_Node_Str"");
setTabWidth(DocletConstants.DEFAULT_TAB_STOP_LENGTH);
}
return true;
}
}
,new Option(resources,""String_Node_Str"",1){
@Override public boolean process(String opt,List<String> args){
ArrayList<String> list=new ArrayList<>();
list.add(opt);
list.add(args.get(0));
customTagStrs.add(list);
return true;
}
}
,new Option(resources,""String_Node_Str"",1){
@Override public boolean process(String opt,List<String> args){
ArrayList<String> list=new ArrayList<>();
list.add(opt);
list.add(args.get(0));
customTagStrs.add(list);
return true;
}
}
,new Option(resources,""String_Node_Str"",1){
@Override public boolean process(String opt,List<String> args){
tagletpath=args.get(0);
return true;
}
}
,new Option(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
showversion=true;
return true;
}
}
,new Hidden(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
dumpOnError=true;
return true;
}
}
,new Option(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
allowScriptInComments=true;
return true;
}
}
,new Hidden(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
disableJavaFxStrictChecks=true;
return true;
}
}
};
Set<Doclet.Option> set=new TreeSet<>();
set.addAll(Arrays.asList(options));
return set;
}","public Set<Doclet.Option> getSupportedOptions(){
  Resources resources=getResources();
  Doclet.Option[] options={new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      showauthor=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      destDirName=addTrailingFileSep(args.get(0));
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      docencoding=args.get(0);
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      copydocfilesubdirs=true;
      return true;
    }
  }
,new Hidden(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      encoding=args.get(0);
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      addToSet(excludedDocFileDirs,args.get(0));
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",2){
    @Override public boolean process(    String opt,    List<String> args){
      groupPairs.add(new Pair<>(args.get(0),args.get(1)));
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      javafx=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      keywords=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      linkList.add(args.get(0));
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      linksource=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",2){
    @Override public boolean process(    String opt,    List<String> args){
      linkOfflineList.add(new Pair<>(args.get(0),args.get(1)));
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      nocomment=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      nodeprecated=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      nosince=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str""){
    @Override public boolean process(    String opt,    List<String> args){
      notimestamp=true;
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      addToSet(excludedQualifiers,args.get(0));
      return true;
    }
  }
,new Option(resources,""String_Node_Str"",1){
    @Override public boolean process(    String opt,    List<String> args){
      String o=args.get(0);
switch (o) {
case ""String_Node_Str"":
        summarizeOverriddenMethods=true;
      break;
case ""String_Node_Str"":
    summarizeOverriddenMethods=false;
  break;
default :
reporter.print(ERROR,getText(""String_Node_Str"",o,""String_Node_Str""));
return false;
}
return true;
}
}
,new Hidden(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
quiet=true;
return true;
}
}
,new Option(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
serialwarn=true;
return true;
}
}
,new Option(resources,""String_Node_Str"",1){
@Override public boolean process(String opt,List<String> args){
linksource=true;
try {
setTabWidth(Integer.parseInt(args.get(0)));
}
 catch (NumberFormatException e) {
sourcetab=-1;
}
if (sourcetab <= 0) {
getMessages().warning(""String_Node_Str"");
setTabWidth(DocletConstants.DEFAULT_TAB_STOP_LENGTH);
}
return true;
}
}
,new Option(resources,""String_Node_Str"",1){
@Override public boolean process(String opt,List<String> args){
ArrayList<String> list=new ArrayList<>();
list.add(opt);
list.add(args.get(0));
customTagStrs.add(list);
return true;
}
}
,new Option(resources,""String_Node_Str"",1){
@Override public boolean process(String opt,List<String> args){
ArrayList<String> list=new ArrayList<>();
list.add(opt);
list.add(args.get(0));
customTagStrs.add(list);
return true;
}
}
,new Option(resources,""String_Node_Str"",1){
@Override public boolean process(String opt,List<String> args){
tagletpath=args.get(0);
return true;
}
}
,new Option(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
showversion=true;
return true;
}
}
,new Hidden(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
dumpOnError=true;
return true;
}
}
,new Option(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
allowScriptInComments=true;
return true;
}
}
,new Hidden(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
disableJavaFxStrictChecks=true;
return true;
}
}
,new Hidden(resources,""String_Node_Str""){
@Override public boolean process(String opt,List<String> args){
showTaglets=true;
return true;
}
}
};
Set<Doclet.Option> set=new TreeSet<>();
set.addAll(Arrays.asList(options));
return set;
}"
76763,"@Override public boolean process(String opt,List<String> args){
  disableJavaFxStrictChecks=true;
  return true;
}","@Override public boolean process(String opt,List<String> args){
  showTaglets=true;
  return true;
}"
76764,"public BasePropertyTaglet(){
}","public BasePropertyTaglet(String name){
  super(name,false,EnumSet.of(Site.METHOD));
}"
76765,"public ServerSocket createServerSocket(int port) throws IOException {
  ServerSocket ss=new ServerSocket();
  if (port == 0) {
    ss.setReuseAddress(false);
  }
  ss.bind(new InetSocketAddress(port));
  return ss;
}","public ServerSocket createServerSocket(int port) throws IOException {
  return new ServerSocket(port);
}"
76766,"/** 
 * Produces an adapter method handle which adapts the type of the current method handle to a new type. The resulting method handle is guaranteed to report a type which is equal to the desired new type. <p> If the original type and new type are equal, returns   {@code this}. <p> The new method handle, when invoked, will perform the following steps: <ul> <li>Convert the incoming argument list to match the original method handle's argument list. <li>Invoke the original method handle on the converted argument list. <li>Convert any result returned by the original method handle to the return type of new method handle. </ul> <p> This method provides the crucial behavioral difference between  {@link #invokeExact invokeExact} and plain, inexact {@link #invoke invoke}. The two methods perform the same steps when the caller's type descriptor exactly matches the callee's, but when the types differ, plain   {@link #invoke invoke}also calls   {@code asType} (or some internal equivalent) in orderto match up the caller's and callee's types. <p> If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as {@linkplain #asVarargsCollector described elsewhere}. In every other case, all conversions are applied <em>pairwise</em>, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the the corresponding component types of the old and new method handle types. <p> Let <em>T0</em> and <em>T1</em> be corresponding new and old parameter types, or old and new return types.  Specifically, for some valid index   {@code i}, let <em>T0</em>  {@code =newType.parameterType(i)} and <em>T1</em>{@code =this.type().parameterType(i)}. Or else, going the other way for return values, let <em>T0</em>  {@code =this.type().returnType()} and <em>T1</em>{@code =newType.returnType()}. If the types are the same, the new method handle makes no change to the corresponding argument or return value (if any). Otherwise, one of the following conversions is applied if possible: <ul> <li>If <em>T0</em> and <em>T1</em> are references, then a cast to <em>T1</em> is applied. (The types do not need to be related in any particular way. This is because a dynamic value of null can convert to any reference type.) <li>If <em>T0</em> and <em>T1</em> are primitives, then a Java method invocation conversion (JLS 5.3) is applied, if one exists. (Specifically, <em>T0</em> must convert to <em>T1</em> by a widening primitive conversion.) <li>If <em>T0</em> is a primitive and <em>T1</em> a reference, a Java casting conversion (JLS 5.5) is applied if one exists. (Specifically, the value is boxed from <em>T0</em> to its wrapper class, which is then widened as needed to <em>T1</em>.) <li>If <em>T0</em> is a reference and <em>T1</em> a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value.  (These are the primitive widening conversions.) <em>T0</em> must be a wrapper class or a supertype of one. (In the case where <em>T0</em> is Object, these are the conversions allowed by   {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.) The unboxing conversion must have a possibility of success, which means that if <em>T0</em> is not itself a wrapper class, there must exist at least one wrapper class <em>TW</em> which is a subtype of <em>T0</em> and whose unboxed primitive value can be widened to <em>T1</em>. <li>If the return type <em>T1</em> is marked as void, any returned value is discarded <li>If the return type <em>T0</em> is void and <em>T1</em> a reference, a null value is introduced. <li>If the return type <em>T0</em> is void and <em>T1</em> a primitive, a zero value is introduced. </ul> (<em>Note:</em> Both <em>T0</em> and <em>T1</em> may be regarded as static types, because neither corresponds specifically to the <em>dynamic type</em> of any actual argument or return value.) <p> The method handle conversion cannot be made if any one of the required pairwise conversions cannot be made. <p> At runtime, the conversions applied to reference arguments or return values may require additional runtime checks which can fail. An unboxing operation may fail because the original reference is null, causing a   {@link java.lang.NullPointerException NullPointerException}. An unboxing operation or a reference cast may also fail on a reference to an object of the wrong type, causing a   {@link java.lang.ClassCastException ClassCastException}. Although an unboxing operation may accept several kinds of wrappers, if none are available, a   {@code ClassCastException} will be thrown.
 * @param newType the expected type of the new method handle
 * @return a method handle which delegates to {@code this} after performingany necessary argument conversions, and arranges for any necessary return value conversions
 * @throws NullPointerException if {@code newType} is a null reference
 * @throws WrongMethodTypeException if the conversion cannot be made
 * @see MethodHandles#explicitCastArguments
 */
public MethodHandle asType(MethodType newType){
  if (newType == type) {
    return this;
  }
  MethodHandle atc=asTypeCached(newType);
  if (atc != null) {
    return atc;
  }
  return asTypeUncached(newType);
}","/** 
 * Produces an adapter method handle which adapts the type of the current method handle to a new type. The resulting method handle is guaranteed to report a type which is equal to the desired new type. <p> If the original type and new type are equal, returns   {@code this}. <p> The new method handle, when invoked, will perform the following steps: <ul> <li>Convert the incoming argument list to match the original method handle's argument list. <li>Invoke the original method handle on the converted argument list. <li>Convert any result returned by the original method handle to the return type of new method handle. </ul> <p> This method provides the crucial behavioral difference between  {@link #invokeExact invokeExact} and plain, inexact {@link #invoke invoke}. The two methods perform the same steps when the caller's type descriptor exactly matches the callee's, but when the types differ, plain   {@link #invoke invoke}also calls   {@code asType} (or some internal equivalent) in orderto match up the caller's and callee's types. <p> If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as {@linkplain #asVarargsCollector described elsewhere}. In every other case, all conversions are applied <em>pairwise</em>, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the corresponding component types of the old and new method handle types. <p> Let <em>T0</em> and <em>T1</em> be corresponding new and old parameter types, or old and new return types.  Specifically, for some valid index   {@code i}, let <em>T0</em>  {@code =newType.parameterType(i)} and <em>T1</em>{@code =this.type().parameterType(i)}. Or else, going the other way for return values, let <em>T0</em>  {@code =this.type().returnType()} and <em>T1</em>{@code =newType.returnType()}. If the types are the same, the new method handle makes no change to the corresponding argument or return value (if any). Otherwise, one of the following conversions is applied if possible: <ul> <li>If <em>T0</em> and <em>T1</em> are references, then a cast to <em>T1</em> is applied. (The types do not need to be related in any particular way. This is because a dynamic value of null can convert to any reference type.) <li>If <em>T0</em> and <em>T1</em> are primitives, then a Java method invocation conversion (JLS 5.3) is applied, if one exists. (Specifically, <em>T0</em> must convert to <em>T1</em> by a widening primitive conversion.) <li>If <em>T0</em> is a primitive and <em>T1</em> a reference, a Java casting conversion (JLS 5.5) is applied if one exists. (Specifically, the value is boxed from <em>T0</em> to its wrapper class, which is then widened as needed to <em>T1</em>.) <li>If <em>T0</em> is a reference and <em>T1</em> a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value.  (These are the primitive widening conversions.) <em>T0</em> must be a wrapper class or a supertype of one. (In the case where <em>T0</em> is Object, these are the conversions allowed by   {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.) The unboxing conversion must have a possibility of success, which means that if <em>T0</em> is not itself a wrapper class, there must exist at least one wrapper class <em>TW</em> which is a subtype of <em>T0</em> and whose unboxed primitive value can be widened to <em>T1</em>. <li>If the return type <em>T1</em> is marked as void, any returned value is discarded <li>If the return type <em>T0</em> is void and <em>T1</em> a reference, a null value is introduced. <li>If the return type <em>T0</em> is void and <em>T1</em> a primitive, a zero value is introduced. </ul> (<em>Note:</em> Both <em>T0</em> and <em>T1</em> may be regarded as static types, because neither corresponds specifically to the <em>dynamic type</em> of any actual argument or return value.) <p> The method handle conversion cannot be made if any one of the required pairwise conversions cannot be made. <p> At runtime, the conversions applied to reference arguments or return values may require additional runtime checks which can fail. An unboxing operation may fail because the original reference is null, causing a   {@link java.lang.NullPointerException NullPointerException}. An unboxing operation or a reference cast may also fail on a reference to an object of the wrong type, causing a   {@link java.lang.ClassCastException ClassCastException}. Although an unboxing operation may accept several kinds of wrappers, if none are available, a   {@code ClassCastException} will be thrown.
 * @param newType the expected type of the new method handle
 * @return a method handle which delegates to {@code this} after performingany necessary argument conversions, and arranges for any necessary return value conversions
 * @throws NullPointerException if {@code newType} is a null reference
 * @throws WrongMethodTypeException if the conversion cannot be made
 * @see MethodHandles#explicitCastArguments
 */
public MethodHandle asType(MethodType newType){
  if (newType == type) {
    return this;
  }
  MethodHandle atc=asTypeCached(newType);
  if (atc != null) {
    return atc;
  }
  return asTypeUncached(newType);
}"
76767,"/** 
 * Sets the SO_RCVBUF option to the specified value for this  {@code DatagramSocket}. The SO_RCVBUF option is used by the the network implementation as a hint to size the underlying network I/O buffers. The SO_RCVBUF setting may also be used by the network implementation to determine the maximum size of the packet that can be received on this socket. <p> Because SO_RCVBUF is a hint, applications that want to verify what size the buffers were set to should call  {@link #getReceiveBufferSize()}. <p> Increasing SO_RCVBUF may allow the network implementation to buffer multiple packets when packets arrive faster than are being received using   {@link #receive(DatagramPacket)}. <p> Note: It is implementation specific if a packet larger than SO_RCVBUF can be received.
 * @param size the size to which to set the receive buffersize. This value must be greater than 0.
 * @exception SocketException if there is an error inthe underlying protocol, such as an UDP error.
 * @exception IllegalArgumentException if the value is 0 or isnegative.
 * @see #getReceiveBufferSize()
 */
public synchronized void setReceiveBufferSize(int size) throws SocketException {
  if (size <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (isClosed())   throw new SocketException(""String_Node_Str"");
  getImpl().setOption(SocketOptions.SO_RCVBUF,size);
}","/** 
 * Sets the SO_RCVBUF option to the specified value for this  {@code DatagramSocket}. The SO_RCVBUF option is used by the network implementation as a hint to size the underlying network I/O buffers. The SO_RCVBUF setting may also be used by the network implementation to determine the maximum size of the packet that can be received on this socket. <p> Because SO_RCVBUF is a hint, applications that want to verify what size the buffers were set to should call  {@link #getReceiveBufferSize()}. <p> Increasing SO_RCVBUF may allow the network implementation to buffer multiple packets when packets arrive faster than are being received using   {@link #receive(DatagramPacket)}. <p> Note: It is implementation specific if a packet larger than SO_RCVBUF can be received.
 * @param size the size to which to set the receive buffersize. This value must be greater than 0.
 * @exception SocketException if there is an error inthe underlying protocol, such as an UDP error.
 * @exception IllegalArgumentException if the value is 0 or isnegative.
 * @see #getReceiveBufferSize()
 */
public synchronized void setReceiveBufferSize(int size) throws SocketException {
  if (size <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (isClosed())   throw new SocketException(""String_Node_Str"");
  getImpl().setOption(SocketOptions.SO_RCVBUF,size);
}"
76768,"/** 
 * Sets performance preferences for this socket. <p> Sockets use the TCP/IP protocol by default.  Some implementations may offer alternative protocols which have different performance characteristics than TCP/IP.  This method allows the application to express its own preferences as to how these tradeoffs should be made when the implementation chooses from the available protocols. <p> Performance preferences are described by three integers whose values indicate the relative importance of short connection time, low latency, and high bandwidth.  The absolute values of the integers are irrelevant; in order to choose a protocol the values are simply compared, with larger values indicating stronger preferences. Negative values represent a lower priority than positive values. If the application prefers short connection time over both low latency and high bandwidth, for example, then it could invoke this method with the values  {@code (1, 0, 0)}.  If the application prefers high bandwidth above low latency, and low latency above short connection time, then it could invoke this method with the values   {@code (0, 1, 2)}. By default, this method does nothing, unless it is overridden in a a sub-class.
 * @param connectionTime An  {@code int} expressing the relative importance of a shortconnection time
 * @param latency An  {@code int} expressing the relative importance of lowlatency
 * @param bandwidth An  {@code int} expressing the relative importance of highbandwidth
 * @since 1.5
 */
protected void setPerformancePreferences(int connectionTime,int latency,int bandwidth){
}","/** 
 * Sets performance preferences for this socket. <p> Sockets use the TCP/IP protocol by default.  Some implementations may offer alternative protocols which have different performance characteristics than TCP/IP.  This method allows the application to express its own preferences as to how these tradeoffs should be made when the implementation chooses from the available protocols. <p> Performance preferences are described by three integers whose values indicate the relative importance of short connection time, low latency, and high bandwidth.  The absolute values of the integers are irrelevant; in order to choose a protocol the values are simply compared, with larger values indicating stronger preferences. Negative values represent a lower priority than positive values. If the application prefers short connection time over both low latency and high bandwidth, for example, then it could invoke this method with the values  {@code (1, 0, 0)}.  If the application prefers high bandwidth above low latency, and low latency above short connection time, then it could invoke this method with the values   {@code (0, 1, 2)}. By default, this method does nothing, unless it is overridden in a sub-class.
 * @param connectionTime An  {@code int} expressing the relative importance of a shortconnection time
 * @param latency An  {@code int} expressing the relative importance of lowlatency
 * @param bandwidth An  {@code int} expressing the relative importance of highbandwidth
 * @since 1.5
 */
protected void setPerformancePreferences(int connectionTime,int latency,int bandwidth){
}"
76769,"/** 
 * Sends the Bind request to the SOCKS proxy. In the SOCKS protocol, bind means ""accept incoming connection from"", so the SocketAddress is the the one of the host we do accept connection from.
 * @param saddr   the Socket address of the remote host.
 * @exception IOException  if an I/O error occurs when binding this socket.
 */
protected synchronized void socksBind(InetSocketAddress saddr) throws IOException {
}","/** 
 * Sends the Bind request to the SOCKS proxy. In the SOCKS protocol, bind means ""accept incoming connection from"", so the SocketAddress is the one of the host we do accept connection from.
 * @param saddr   the Socket address of the remote host.
 * @exception IOException  if an I/O error occurs when binding this socket.
 */
protected synchronized void socksBind(InetSocketAddress saddr) throws IOException {
}"
76770,"/** 
 * Returns a permission object representing the permission necessary to make the connection represented by this object. This method returns null if no permission is required to make the connection. By default, this method returns   {@code java.security.AllPermission}. Subclasses should override this method and return the permission that best represents the permission required to make a a connection to the URL. For example, a   {@code URLConnection}representing a   {@code file:} URL would return a{@code java.io.FilePermission} object.<p>The permission returned may dependent upon the state of the connection. For example, the permission before connecting may be different from that after connecting. For example, an HTTP sever, say foo.com, may redirect the connection to a different host, say bar.com. Before connecting the permission returned by the connection will represent the permission needed to connect to foo.com, while the permission returned after connecting will be to bar.com. <p>Permissions are generally used for two purposes: to protect caches of objects obtained through URLConnections, and to check the right of a recipient to learn about a particular URL. In the first case, the permission should be obtained <em>after</em> the object has been obtained. For example, in an HTTP connection, this will represent the permission to connect to the host from which the data was ultimately fetched. In the second case, the permission should be obtained and tested <em>before</em> connecting.
 * @return the permission object representing the permissionnecessary to make the connection represented by this URLConnection.
 * @exception IOException if the computation of the permissionrequires network or file I/O and an exception occurs while computing it.
 */
public Permission getPermission() throws IOException {
  return SecurityConstants.ALL_PERMISSION;
}","/** 
 * Returns a permission object representing the permission necessary to make the connection represented by this object. This method returns null if no permission is required to make the connection. By default, this method returns   {@code java.security.AllPermission}. Subclasses should override this method and return the permission that best represents the permission required to make a connection to the URL. For example, a   {@code URLConnection}representing a   {@code file:} URL would return a{@code java.io.FilePermission} object.<p>The permission returned may dependent upon the state of the connection. For example, the permission before connecting may be different from that after connecting. For example, an HTTP sever, say foo.com, may redirect the connection to a different host, say bar.com. Before connecting the permission returned by the connection will represent the permission needed to connect to foo.com, while the permission returned after connecting will be to bar.com. <p>Permissions are generally used for two purposes: to protect caches of objects obtained through URLConnections, and to check the right of a recipient to learn about a particular URL. In the first case, the permission should be obtained <em>after</em> the object has been obtained. For example, in an HTTP connection, this will represent the permission to connect to the host from which the data was ultimately fetched. In the second case, the permission should be obtained and tested <em>before</em> connecting.
 * @return the permission object representing the permissionnecessary to make the connection represented by this URLConnection.
 * @exception IOException if the computation of the permissionrequires network or file I/O and an exception occurs while computing it.
 */
public Permission getPermission() throws IOException {
  return SecurityConstants.ALL_PERMISSION;
}"
76771,"/** 
 * Obtains an instance of   {@code WeekFields} from the first day-of-week and minimal days.<p> The first day-of-week defines the ISO  {@code DayOfWeek} that is day 1 of the week.The minimal number of days in the first week defines how many days must be present in a month or year, starting from the first day-of-week, before the week is counted as the first week. A value of 1 will count the first day of the month or year as part of the first week, whereas a value of 7 will require the whole seven days to be in the new month or year. <p> WeekFields instances are singletons; for each unique combination of  {@code firstDayOfWeek} and {@code minimalDaysInFirstWeek} thethe same instance will be returned.
 * @param firstDayOfWeek  the first day of the week, not null
 * @param minimalDaysInFirstWeek  the minimal number of days in the first week, from 1 to 7
 * @return the week-definition, not null
 * @throws IllegalArgumentException if the minimal days value is less than oneor greater than 7
 */
public static WeekFields of(DayOfWeek firstDayOfWeek,int minimalDaysInFirstWeek){
  String key=firstDayOfWeek.toString() + minimalDaysInFirstWeek;
  WeekFields rules=CACHE.get(key);
  if (rules == null) {
    rules=new WeekFields(firstDayOfWeek,minimalDaysInFirstWeek);
    CACHE.putIfAbsent(key,rules);
    rules=CACHE.get(key);
  }
  return rules;
}","/** 
 * Obtains an instance of   {@code WeekFields} from the first day-of-week and minimal days.<p> The first day-of-week defines the ISO  {@code DayOfWeek} that is day 1 of the week.The minimal number of days in the first week defines how many days must be present in a month or year, starting from the first day-of-week, before the week is counted as the first week. A value of 1 will count the first day of the month or year as part of the first week, whereas a value of 7 will require the whole seven days to be in the new month or year. <p> WeekFields instances are singletons; for each unique combination of  {@code firstDayOfWeek} and {@code minimalDaysInFirstWeek}the same instance will be returned.
 * @param firstDayOfWeek  the first day of the week, not null
 * @param minimalDaysInFirstWeek  the minimal number of days in the first week, from 1 to 7
 * @return the week-definition, not null
 * @throws IllegalArgumentException if the minimal days value is less than oneor greater than 7
 */
public static WeekFields of(DayOfWeek firstDayOfWeek,int minimalDaysInFirstWeek){
  String key=firstDayOfWeek.toString() + minimalDaysInFirstWeek;
  WeekFields rules=CACHE.get(key);
  if (rules == null) {
    rules=new WeekFields(firstDayOfWeek,minimalDaysInFirstWeek);
    CACHE.putIfAbsent(key,rules);
    rules=CACHE.get(key);
  }
  return rules;
}"
76772,"/** 
 * The object on which the Event initially occurred.
 * @return   The object on which the Event initially occurred.
 */
public Object getSource(){
  return source;
}","/** 
 * The object on which the Event initially occurred.
 * @return the object on which the Event initially occurred
 */
public Object getSource(){
  return source;
}"
76773,"/** 
 * Returns a String representation of this EventObject.
 * @return  A a String representation of this EventObject.
 */
public String toString(){
  return getClass().getName() + ""String_Node_Str"" + source+ ""String_Node_Str"";
}","/** 
 * Returns a String representation of this EventObject.
 * @return a String representation of this EventObject
 */
public String toString(){
  return getClass().getName() + ""String_Node_Str"" + source+ ""String_Node_Str"";
}"
76774,"/** 
 * Constructs a prototypical Event.
 * @param source    The object on which the Event initially occurred.
 * @exception IllegalArgumentException  if source is null.
 */
public EventObject(Object source){
  if (source == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.source=source;
}","/** 
 * Constructs a prototypical Event.
 * @param source the object on which the Event initially occurred
 * @throws IllegalArgumentException if source is null
 */
public EventObject(Object source){
  if (source == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.source=source;
}"
76775,"/** 
 * Returns a <code>List</code> of <code>Locale</code>s as candidate locales for <code>baseName</code> and <code>locale</code>. This method is called by the <code>ResourceBundle.getBundle</code> factory method each time the factory method tries finding a resource bundle for a target <code>Locale</code>. <p>The sequence of the candidate locales also corresponds to the runtime resource lookup path (also known as the <I>parent chain</I>), if the corresponding resource bundles for the candidate locales exist and their parents are not defined by loaded resource bundles themselves.  The last element of the list must be a   {@linkplain Locale#ROOT root locale} if it is desired tohave the base bundle as the terminal of the parent chain. <p>If the given locale is equal to <code>Locale.ROOT</code> (the root locale), a <code>List</code> containing only the root <code>Locale</code> must be returned. In this case, the <code>ResourceBundle.getBundle</code> factory method loads only the base bundle as the resulting resource bundle. <p>It is not a requirement to return an immutable (unmodifiable) <code>List</code>. However, the returned <code>List</code> must not be mutated after it has been returned by <code>getCandidateLocales</code>. <p>The default implementation returns a <code>List</code> containing <code>Locale</code>s using the rules described below.  In the description below, <em>L</em>, <em>S</em>, <em>C</em> and <em>V</em> respectively represent non-empty language, script, country, and variant.  For example, [<em>L</em>, <em>C</em>] represents a <code>Locale</code> that has non-empty values only for language and country.  The form <em>L</em>(""xx"") represents the (non-empty) language value is ""xx"".  For all cases, <code>Locale</code>s whose final component values are empty strings are omitted. <ol><li>For an input <code>Locale</code> with an empty script value, append candidate <code>Locale</code>s by omitting the final component one by one as below: <ul> <li> [<em>L</em>, <em>C</em>, <em>V</em>] </li> <li> [<em>L</em>, <em>C</em>] </li> <li> [<em>L</em>] </li> <li> <code>Locale.ROOT</code> </li> </ul></li> <li>For an input <code>Locale</code> with a non-empty script value, append candidate <code>Locale</code>s by omitting the final component up to language, then append candidates generated from the <code>Locale</code> with country and variant restored: <ul> <li> [<em>L</em>, <em>S</em>, <em>C</em>, <em>V</em>]</li> <li> [<em>L</em>, <em>S</em>, <em>C</em>]</li> <li> [<em>L</em>, <em>S</em>]</li> <li> [<em>L</em>, <em>C</em>, <em>V</em>]</li> <li> [<em>L</em>, <em>C</em>]</li> <li> [<em>L</em>]</li> <li> <code>Locale.ROOT</code></li> </ul></li> <li>For an input <code>Locale</code> with a variant value consisting of multiple subtags separated by underscore, generate candidate <code>Locale</code>s by omitting the variant subtags one by one, then insert them after every occurrence of <code> Locale</code>s with the full variant value in the original list.  For example, if the the variant consists of two subtags <em>V1</em> and <em>V2</em>: <ul> <li> [<em>L</em>, <em>S</em>, <em>C</em>, <em>V1</em>, <em>V2</em>]</li> <li> [<em>L</em>, <em>S</em>, <em>C</em>, <em>V1</em>]</li> <li> [<em>L</em>, <em>S</em>, <em>C</em>]</li> <li> [<em>L</em>, <em>S</em>]</li> <li> [<em>L</em>, <em>C</em>, <em>V1</em>, <em>V2</em>]</li> <li> [<em>L</em>, <em>C</em>, <em>V1</em>]</li> <li> [<em>L</em>, <em>C</em>]</li> <li> [<em>L</em>]</li> <li> <code>Locale.ROOT</code></li> </ul></li> <li>Special cases for Chinese.  When an input <code>Locale</code> has the language ""zh"" (Chinese) and an empty script value, either ""Hans"" (Simplified) or ""Hant"" (Traditional) might be supplied, depending on the country. When the country is ""CN"" (China) or ""SG"" (Singapore), ""Hans"" is supplied. When the country is ""HK"" (Hong Kong SAR China), ""MO"" (Macau SAR China), or ""TW"" (Taiwan), ""Hant"" is supplied.  For all other countries or when the country is empty, no script is supplied.  For example, for <code>Locale(""zh"", ""CN"") </code>, the candidate list will be: <ul> <li> [<em>L</em>(""zh""), <em>S</em>(""Hans""), <em>C</em>(""CN"")]</li> <li> [<em>L</em>(""zh""), <em>S</em>(""Hans"")]</li> <li> [<em>L</em>(""zh""), <em>C</em>(""CN"")]</li> <li> [<em>L</em>(""zh"")]</li> <li> <code>Locale.ROOT</code></li> </ul> For <code>Locale(""zh"", ""TW"")</code>, the candidate list will be: <ul> <li> [<em>L</em>(""zh""), <em>S</em>(""Hant""), <em>C</em>(""TW"")]</li> <li> [<em>L</em>(""zh""), <em>S</em>(""Hant"")]</li> <li> [<em>L</em>(""zh""), <em>C</em>(""TW"")]</li> <li> [<em>L</em>(""zh"")]</li> <li> <code>Locale.ROOT</code></li> </ul></li> <li>Special cases for Norwegian.  Both <code>Locale(""no"", ""NO"", ""NY"")</code> and <code>Locale(""nn"", ""NO"")</code> represent Norwegian Nynorsk.  When a locale's language is ""nn"", the standard candidate list is generated up to [<em>L</em>(""nn"")], and then the following candidates are added: <ul><li> [<em>L</em>(""no""), <em>C</em>(""NO""), <em>V</em>(""NY"")]</li> <li> [<em>L</em>(""no""), <em>C</em>(""NO"")]</li> <li> [<em>L</em>(""no"")]</li> <li> <code>Locale.ROOT</code></li> </ul> If the locale is exactly <code>Locale(""no"", ""NO"", ""NY"")</code>, it is first converted to <code>Locale(""nn"", ""NO"")</code> and then the above procedure is followed. <p>Also, Java treats the language ""no"" as a synonym of Norwegian Bokm&#xE5;l ""nb"".  Except for the single case <code>Locale(""no"", ""NO"", ""NY"")</code> (handled above), when an input <code>Locale</code> has language ""no"" or ""nb"", candidate <code>Locale</code>s with language code ""no"" and ""nb"" are interleaved, first using the requested language, then using its synonym. For example, <code>Locale(""nb"", ""NO"", ""POSIX"")</code> generates the following candidate list: <ul> <li> [<em>L</em>(""nb""), <em>C</em>(""NO""), <em>V</em>(""POSIX"")]</li> <li> [<em>L</em>(""no""), <em>C</em>(""NO""), <em>V</em>(""POSIX"")]</li> <li> [<em>L</em>(""nb""), <em>C</em>(""NO"")]</li> <li> [<em>L</em>(""no""), <em>C</em>(""NO"")]</li> <li> [<em>L</em>(""nb"")]</li> <li> [<em>L</em>(""no"")]</li> <li> <code>Locale.ROOT</code></li> </ul> <code>Locale(""no"", ""NO"", ""POSIX"")</code> would generate the same list except that locales with ""no"" would appear before the corresponding locales with ""nb"".</li> </ol> <p>The default implementation uses an  {@link ArrayList} thatoverriding implementations may modify before returning it to the caller. However, a subclass must not modify it after it has been returned by <code>getCandidateLocales</code>. <p>For example, if the given <code>baseName</code> is ""Messages"" and the given <code>locale</code> is <code>Locale(""ja"",&nbsp;"""",&nbsp;""XX"")</code>, then a <code>List</code> of <code>Locale</code>s: <pre> Locale(""ja"", """", ""XX"") Locale(""ja"") Locale.ROOT </pre> is returned. And if the resource bundles for the ""ja"" and """" <code>Locale</code>s are found, then the runtime resource lookup path (parent chain) is: <pre> {@code Messages_ja -> Messages}</pre>
 * @param baseName the base name of the resource bundle, a fully qualified class name
 * @param locale the locale for which a resource bundle is desired
 * @return a <code>List</code> of candidate<code>Locale</code>s for the given <code>locale</code>
 * @exception NullPointerException if <code>baseName</code> or <code>locale</code> is <code>null</code>
 */
public List<Locale> getCandidateLocales(String baseName,Locale locale){
  if (baseName == null) {
    throw new NullPointerException();
  }
  return new ArrayList<>(CANDIDATES_CACHE.get(locale.getBaseLocale()));
}","/** 
 * Returns a <code>List</code> of <code>Locale</code>s as candidate locales for <code>baseName</code> and <code>locale</code>. This method is called by the <code>ResourceBundle.getBundle</code> factory method each time the factory method tries finding a resource bundle for a target <code>Locale</code>. <p>The sequence of the candidate locales also corresponds to the runtime resource lookup path (also known as the <I>parent chain</I>), if the corresponding resource bundles for the candidate locales exist and their parents are not defined by loaded resource bundles themselves.  The last element of the list must be a   {@linkplain Locale#ROOT root locale} if it is desired tohave the base bundle as the terminal of the parent chain. <p>If the given locale is equal to <code>Locale.ROOT</code> (the root locale), a <code>List</code> containing only the root <code>Locale</code> must be returned. In this case, the <code>ResourceBundle.getBundle</code> factory method loads only the base bundle as the resulting resource bundle. <p>It is not a requirement to return an immutable (unmodifiable) <code>List</code>. However, the returned <code>List</code> must not be mutated after it has been returned by <code>getCandidateLocales</code>. <p>The default implementation returns a <code>List</code> containing <code>Locale</code>s using the rules described below.  In the description below, <em>L</em>, <em>S</em>, <em>C</em> and <em>V</em> respectively represent non-empty language, script, country, and variant.  For example, [<em>L</em>, <em>C</em>] represents a <code>Locale</code> that has non-empty values only for language and country.  The form <em>L</em>(""xx"") represents the (non-empty) language value is ""xx"".  For all cases, <code>Locale</code>s whose final component values are empty strings are omitted. <ol><li>For an input <code>Locale</code> with an empty script value, append candidate <code>Locale</code>s by omitting the final component one by one as below: <ul> <li> [<em>L</em>, <em>C</em>, <em>V</em>] </li> <li> [<em>L</em>, <em>C</em>] </li> <li> [<em>L</em>] </li> <li> <code>Locale.ROOT</code> </li> </ul></li> <li>For an input <code>Locale</code> with a non-empty script value, append candidate <code>Locale</code>s by omitting the final component up to language, then append candidates generated from the <code>Locale</code> with country and variant restored: <ul> <li> [<em>L</em>, <em>S</em>, <em>C</em>, <em>V</em>]</li> <li> [<em>L</em>, <em>S</em>, <em>C</em>]</li> <li> [<em>L</em>, <em>S</em>]</li> <li> [<em>L</em>, <em>C</em>, <em>V</em>]</li> <li> [<em>L</em>, <em>C</em>]</li> <li> [<em>L</em>]</li> <li> <code>Locale.ROOT</code></li> </ul></li> <li>For an input <code>Locale</code> with a variant value consisting of multiple subtags separated by underscore, generate candidate <code>Locale</code>s by omitting the variant subtags one by one, then insert them after every occurrence of <code> Locale</code>s with the full variant value in the original list.  For example, if the variant consists of two subtags <em>V1</em> and <em>V2</em>: <ul> <li> [<em>L</em>, <em>S</em>, <em>C</em>, <em>V1</em>, <em>V2</em>]</li> <li> [<em>L</em>, <em>S</em>, <em>C</em>, <em>V1</em>]</li> <li> [<em>L</em>, <em>S</em>, <em>C</em>]</li> <li> [<em>L</em>, <em>S</em>]</li> <li> [<em>L</em>, <em>C</em>, <em>V1</em>, <em>V2</em>]</li> <li> [<em>L</em>, <em>C</em>, <em>V1</em>]</li> <li> [<em>L</em>, <em>C</em>]</li> <li> [<em>L</em>]</li> <li> <code>Locale.ROOT</code></li> </ul></li> <li>Special cases for Chinese.  When an input <code>Locale</code> has the language ""zh"" (Chinese) and an empty script value, either ""Hans"" (Simplified) or ""Hant"" (Traditional) might be supplied, depending on the country. When the country is ""CN"" (China) or ""SG"" (Singapore), ""Hans"" is supplied. When the country is ""HK"" (Hong Kong SAR China), ""MO"" (Macau SAR China), or ""TW"" (Taiwan), ""Hant"" is supplied.  For all other countries or when the country is empty, no script is supplied.  For example, for <code>Locale(""zh"", ""CN"") </code>, the candidate list will be: <ul> <li> [<em>L</em>(""zh""), <em>S</em>(""Hans""), <em>C</em>(""CN"")]</li> <li> [<em>L</em>(""zh""), <em>S</em>(""Hans"")]</li> <li> [<em>L</em>(""zh""), <em>C</em>(""CN"")]</li> <li> [<em>L</em>(""zh"")]</li> <li> <code>Locale.ROOT</code></li> </ul> For <code>Locale(""zh"", ""TW"")</code>, the candidate list will be: <ul> <li> [<em>L</em>(""zh""), <em>S</em>(""Hant""), <em>C</em>(""TW"")]</li> <li> [<em>L</em>(""zh""), <em>S</em>(""Hant"")]</li> <li> [<em>L</em>(""zh""), <em>C</em>(""TW"")]</li> <li> [<em>L</em>(""zh"")]</li> <li> <code>Locale.ROOT</code></li> </ul></li> <li>Special cases for Norwegian.  Both <code>Locale(""no"", ""NO"", ""NY"")</code> and <code>Locale(""nn"", ""NO"")</code> represent Norwegian Nynorsk.  When a locale's language is ""nn"", the standard candidate list is generated up to [<em>L</em>(""nn"")], and then the following candidates are added: <ul><li> [<em>L</em>(""no""), <em>C</em>(""NO""), <em>V</em>(""NY"")]</li> <li> [<em>L</em>(""no""), <em>C</em>(""NO"")]</li> <li> [<em>L</em>(""no"")]</li> <li> <code>Locale.ROOT</code></li> </ul> If the locale is exactly <code>Locale(""no"", ""NO"", ""NY"")</code>, it is first converted to <code>Locale(""nn"", ""NO"")</code> and then the above procedure is followed. <p>Also, Java treats the language ""no"" as a synonym of Norwegian Bokm&#xE5;l ""nb"".  Except for the single case <code>Locale(""no"", ""NO"", ""NY"")</code> (handled above), when an input <code>Locale</code> has language ""no"" or ""nb"", candidate <code>Locale</code>s with language code ""no"" and ""nb"" are interleaved, first using the requested language, then using its synonym. For example, <code>Locale(""nb"", ""NO"", ""POSIX"")</code> generates the following candidate list: <ul> <li> [<em>L</em>(""nb""), <em>C</em>(""NO""), <em>V</em>(""POSIX"")]</li> <li> [<em>L</em>(""no""), <em>C</em>(""NO""), <em>V</em>(""POSIX"")]</li> <li> [<em>L</em>(""nb""), <em>C</em>(""NO"")]</li> <li> [<em>L</em>(""no""), <em>C</em>(""NO"")]</li> <li> [<em>L</em>(""nb"")]</li> <li> [<em>L</em>(""no"")]</li> <li> <code>Locale.ROOT</code></li> </ul> <code>Locale(""no"", ""NO"", ""POSIX"")</code> would generate the same list except that locales with ""no"" would appear before the corresponding locales with ""nb"".</li> </ol> <p>The default implementation uses an  {@link ArrayList} thatoverriding implementations may modify before returning it to the caller. However, a subclass must not modify it after it has been returned by <code>getCandidateLocales</code>. <p>For example, if the given <code>baseName</code> is ""Messages"" and the given <code>locale</code> is <code>Locale(""ja"",&nbsp;"""",&nbsp;""XX"")</code>, then a <code>List</code> of <code>Locale</code>s: <pre> Locale(""ja"", """", ""XX"") Locale(""ja"") Locale.ROOT </pre> is returned. And if the resource bundles for the ""ja"" and """" <code>Locale</code>s are found, then the runtime resource lookup path (parent chain) is: <pre> {@code Messages_ja -> Messages}</pre>
 * @param baseName the base name of the resource bundle, a fully qualified class name
 * @param locale the locale for which a resource bundle is desired
 * @return a <code>List</code> of candidate<code>Locale</code>s for the given <code>locale</code>
 * @exception NullPointerException if <code>baseName</code> or <code>locale</code> is <code>null</code>
 */
public List<Locale> getCandidateLocales(String baseName,Locale locale){
  if (baseName == null) {
    throw new NullPointerException();
  }
  return new ArrayList<>(CANDIDATES_CACHE.get(locale.getBaseLocale()));
}"
76776,"/** 
 * Static factory. Given a (generic) class, actual type arguments and an owner type, creates a parameterized type. This class can be instantiated with a a raw type that does not represent a generic type, provided the list of actual type arguments is empty. If the ownerType argument is null, the declaring class of the raw type is used as the owner type. <p> This method throws a MalformedParameterizedTypeException under the following circumstances: If the number of actual type arguments (i.e., the size of the array   {@code typeArgs}) does not correspond to the number of formal type arguments. If any of the actual type arguments is not an instance of the bounds on the corresponding formal.
 * @param rawType the Class representing the generic type declaration beinginstantiated
 * @param actualTypeArguments a (possibly empty) array of typesrepresenting the actual type arguments to the parameterized type
 * @param ownerType the enclosing type, if known.
 * @return An instance of {@code ParameterizedType}
 * @throws MalformedParameterizedTypeException if the instantiationis invalid
 */
public static ParameterizedTypeImpl make(Class<?> rawType,Type[] actualTypeArguments,Type ownerType){
  return new ParameterizedTypeImpl(rawType,actualTypeArguments,ownerType);
}","/** 
 * Static factory. Given a (generic) class, actual type arguments and an owner type, creates a parameterized type. This class can be instantiated with a raw type that does not represent a generic type, provided the list of actual type arguments is empty. If the ownerType argument is null, the declaring class of the raw type is used as the owner type. <p> This method throws a MalformedParameterizedTypeException under the following circumstances: If the number of actual type arguments (i.e., the size of the array   {@code typeArgs}) does not correspond to the number of formal type arguments. If any of the actual type arguments is not an instance of the bounds on the corresponding formal.
 * @param rawType the Class representing the generic type declaration beinginstantiated
 * @param actualTypeArguments a (possibly empty) array of typesrepresenting the actual type arguments to the parameterized type
 * @param ownerType the enclosing type, if known.
 * @return An instance of {@code ParameterizedType}
 * @throws MalformedParameterizedTypeException if the instantiationis invalid
 */
public static ParameterizedTypeImpl make(Class<?> rawType,Type[] actualTypeArguments,Type ownerType){
  return new ParameterizedTypeImpl(rawType,actualTypeArguments,ownerType);
}"
76777,"/** 
 * Returns true if this <code>SubjectCodeSource</code> object ""implies"" the specified <code>CodeSource</code>. More specifically, this method makes the following checks. If any fail, it returns false.  If they all succeed, it returns true. <p> <ol> <li> The provided codesource must not be <code>null</code>. <li> codesource must be an instance of <code>SubjectCodeSource</code>. <li> super.implies(codesource) must return true. <li> for each principal in this codesource's principal list: <ol> <li>     if the principal is an instanceof <code>Principal</code>, then the principal must imply the provided codesource's <code>Subject</code>. <li>     if the principal is not an instanceof <code>Principal</code>, then the provided codesource's <code>Subject</code> must have an associated <code>Principal</code>, <i>P</i>, where P.getClass().getName equals principal.principalClass, and P.getName() equals principal.principalName. </ol> </ol> <p>
 * @param codesource the <code>CodeSource</code> to compare against.
 * @return true if this <code>SubjectCodeSource</code> implies thethe specified <code>CodeSource</code>.
 */
public boolean implies(CodeSource codesource){
  LinkedList<PrincipalEntry> subjectList=null;
  if (codesource == null || !(codesource instanceof SubjectCodeSource) || !(super.implies(codesource))) {
    if (debug != null)     debug.println(""String_Node_Str"");
    return false;
  }
  SubjectCodeSource that=(SubjectCodeSource)codesource;
  if (this.principals == null) {
    if (debug != null)     debug.println(""String_Node_Str"");
    return true;
  }
  if (that.getSubject() == null || that.getSubject().getPrincipals().size() == 0) {
    if (debug != null)     debug.println(""String_Node_Str"");
    return false;
  }
  ListIterator<PrincipalEntry> li=this.principals.listIterator(0);
  while (li.hasNext()) {
    PrincipalEntry pppe=li.next();
    try {
      Class<?> pClass=Class.forName(pppe.principalClass,true,sysClassLoader);
      if (!Principal.class.isAssignableFrom(pClass)) {
        throw new ClassCastException(pppe.principalClass + ""String_Node_Str"");
      }
      Constructor<?> c=pClass.getConstructor(PARAMS);
      Principal p=(Principal)c.newInstance(new Object[]{pppe.principalName});
      if (!p.implies(that.getSubject())) {
        if (debug != null)         debug.println(""String_Node_Str"");
        return false;
      }
 else {
        if (debug != null)         debug.println(""String_Node_Str"");
        return true;
      }
    }
 catch (    Exception e) {
      if (subjectList == null) {
        if (that.getSubject() == null) {
          if (debug != null)           debug.println(""String_Node_Str"" + ""String_Node_Str"");
          return false;
        }
        Iterator<Principal> i=that.getSubject().getPrincipals().iterator();
        subjectList=new LinkedList<PrincipalEntry>();
        while (i.hasNext()) {
          Principal p=i.next();
          PrincipalEntry spppe=new PrincipalEntry(p.getClass().getName(),p.getName());
          subjectList.add(spppe);
        }
      }
      if (!subjectListImpliesPrincipalEntry(subjectList,pppe)) {
        if (debug != null)         debug.println(""String_Node_Str"");
        return false;
      }
    }
  }
  if (debug != null)   debug.println(""String_Node_Str"");
  return true;
}","/** 
 * Returns true if this <code>SubjectCodeSource</code> object ""implies"" the specified <code>CodeSource</code>. More specifically, this method makes the following checks. If any fail, it returns false.  If they all succeed, it returns true. <p> <ol> <li> The provided codesource must not be <code>null</code>. <li> codesource must be an instance of <code>SubjectCodeSource</code>. <li> super.implies(codesource) must return true. <li> for each principal in this codesource's principal list: <ol> <li>     if the principal is an instanceof <code>Principal</code>, then the principal must imply the provided codesource's <code>Subject</code>. <li>     if the principal is not an instanceof <code>Principal</code>, then the provided codesource's <code>Subject</code> must have an associated <code>Principal</code>, <i>P</i>, where P.getClass().getName equals principal.principalClass, and P.getName() equals principal.principalName. </ol> </ol> <p>
 * @param codesource the <code>CodeSource</code> to compare against.
 * @return true if this <code>SubjectCodeSource</code> impliesthe specified <code>CodeSource</code>.
 */
public boolean implies(CodeSource codesource){
  LinkedList<PrincipalEntry> subjectList=null;
  if (codesource == null || !(codesource instanceof SubjectCodeSource) || !(super.implies(codesource))) {
    if (debug != null)     debug.println(""String_Node_Str"");
    return false;
  }
  SubjectCodeSource that=(SubjectCodeSource)codesource;
  if (this.principals == null) {
    if (debug != null)     debug.println(""String_Node_Str"");
    return true;
  }
  if (that.getSubject() == null || that.getSubject().getPrincipals().size() == 0) {
    if (debug != null)     debug.println(""String_Node_Str"");
    return false;
  }
  ListIterator<PrincipalEntry> li=this.principals.listIterator(0);
  while (li.hasNext()) {
    PrincipalEntry pppe=li.next();
    try {
      Class<?> pClass=Class.forName(pppe.principalClass,true,sysClassLoader);
      if (!Principal.class.isAssignableFrom(pClass)) {
        throw new ClassCastException(pppe.principalClass + ""String_Node_Str"");
      }
      Constructor<?> c=pClass.getConstructor(PARAMS);
      Principal p=(Principal)c.newInstance(new Object[]{pppe.principalName});
      if (!p.implies(that.getSubject())) {
        if (debug != null)         debug.println(""String_Node_Str"");
        return false;
      }
 else {
        if (debug != null)         debug.println(""String_Node_Str"");
        return true;
      }
    }
 catch (    Exception e) {
      if (subjectList == null) {
        if (that.getSubject() == null) {
          if (debug != null)           debug.println(""String_Node_Str"" + ""String_Node_Str"");
          return false;
        }
        Iterator<Principal> i=that.getSubject().getPrincipals().iterator();
        subjectList=new LinkedList<PrincipalEntry>();
        while (i.hasNext()) {
          Principal p=i.next();
          PrincipalEntry spppe=new PrincipalEntry(p.getClass().getName(),p.getName());
          subjectList.add(spppe);
        }
      }
      if (!subjectListImpliesPrincipalEntry(subjectList,pppe)) {
        if (debug != null)         debug.println(""String_Node_Str"");
        return false;
      }
    }
  }
  if (debug != null)   debug.println(""String_Node_Str"");
  return true;
}"
76778,"/** 
 * Get the certificate constraints path length from the the critical BasicConstraints extension, (oid = 2.5.29.19).
 * @return the length of the constraint.
 */
public int getBasicConstraints(){
  try {
    String extAlias=OIDMap.getName(PKIXExtensions.BasicConstraints_Id);
    if (extAlias == null)     return -1;
    BasicConstraintsExtension certExt=(BasicConstraintsExtension)this.get(extAlias);
    if (certExt == null)     return -1;
    if (((Boolean)certExt.get(BasicConstraintsExtension.IS_CA)).booleanValue() == true)     return ((Integer)certExt.get(BasicConstraintsExtension.PATH_LEN)).intValue();
 else     return -1;
  }
 catch (  Exception e) {
    return -1;
  }
}","/** 
 * Get the certificate constraints path length from the critical BasicConstraints extension, (oid = 2.5.29.19).
 * @return the length of the constraint.
 */
public int getBasicConstraints(){
  try {
    String extAlias=OIDMap.getName(PKIXExtensions.BasicConstraints_Id);
    if (extAlias == null)     return -1;
    BasicConstraintsExtension certExt=(BasicConstraintsExtension)this.get(extAlias);
    if (certExt == null)     return -1;
    if (((Boolean)certExt.get(BasicConstraintsExtension.IS_CA)).booleanValue() == true)     return ((Integer)certExt.get(BasicConstraintsExtension.PATH_LEN)).intValue();
 else     return -1;
  }
 catch (  Exception e) {
    return -1;
  }
}"
76779,"/** 
 * Get the particular property in the underlying implementation of  {@code Marshaller}.  This method can only be used to get one of the standard JAXB defined properties above or a provider specific property.  Attempting to get an undefined property will result in a PropertyException being thrown.  See <a href=""#supportedProps""> Supported Properties</a>.
 * @param name the name of the property to retrieve
 * @return the value of the requested property
 * @throws PropertyException when there is an error retrieving the given property or value property name
 * @throws IllegalArgumentException If the name parameter is null
 */
public Object getProperty(String name) throws PropertyException ;","/** 
 * Get the particular property in the underlying implementation of  {@code Marshaller}.  This method can only be used to get one of the standard JAXB defined properties above or a provider specific property.  Attempting to get an undefined property will result in a PropertyException being thrown.  See <a href=""  {@docRoot}/javax/xml/bind/Marshaller.html#supportedProps""> Supported Properties</a>.
 * @param name the name of the property to retrieve
 * @return the value of the requested property
 * @throws PropertyException when there is an error retrieving the given property or value property name
 * @throws IllegalArgumentException If the name parameter is null
 */
public Object getProperty(String name) throws PropertyException ;"
76780,"/** 
 * Marshal the content tree rooted at   {@code jaxbElement} into a{@link javax.xml.stream.XMLEventWriter}.
 * @param jaxbElement The content tree rooted at jaxbElement to be marshalled.
 * @param writer XML will be sent to this writer.
 * @throws JAXBException If any unexpected problem occurs during the marshalling.
 * @throws MarshalException If the  {@link ValidationEventHandler ValidationEventHandler}returns false from its   {@code handleEvent} method or the{@code Marshaller} is unable to marshal {@code jaxbElement} (or anyobject reachable from  {@code jaxbElement}).  See <a href=""#elementMarshalling""> Marshalling a JAXB element</a>.
 * @throws IllegalArgumentException If any of the method parameters are null
 * @since 1.6, JAXB 2.0
 */
public void marshal(Object jaxbElement,javax.xml.stream.XMLEventWriter writer) throws JAXBException ;","/** 
 * Marshal the content tree rooted at   {@code jaxbElement} into a{@link javax.xml.stream.XMLEventWriter}.
 * @param jaxbElement The content tree rooted at jaxbElement to be marshalled.
 * @param writer XML will be sent to this writer.
 * @throws JAXBException If any unexpected problem occurs during the marshalling.
 * @throws MarshalException If the  {@link ValidationEventHandler ValidationEventHandler}returns false from its   {@code handleEvent} method or the{@code Marshaller} is unable to marshal {@code jaxbElement} (or anyobject reachable from  {@code jaxbElement}).  See <a href=""  {@docRoot}/javax/xml/bind/Marshaller.html#elementMarshalling""> Marshalling a JAXB element</a>.
 * @throws IllegalArgumentException If any of the method parameters are null
 * @since 1.6, JAXB 2.0
 */
public void marshal(Object jaxbElement,javax.xml.stream.XMLEventWriter writer) throws JAXBException ;"
76781,"/** 
 * Set the particular property in the underlying implementation of  {@code Marshaller}.  This method can only be used to set one of the standard JAXB defined properties above or a provider specific property.  Attempting to set an undefined property will result in a PropertyException being thrown.  See <a href=""#supportedProps""> Supported Properties</a>.
 * @param name the name of the property to be set. This value can eitherbe specified using one of the constant fields or a user supplied string.
 * @param value the value of the property to be set
 * @throws PropertyException when there is an error processing the givenproperty or value
 * @throws IllegalArgumentException If the name parameter is null
 */
public void setProperty(String name,Object value) throws PropertyException ;","/** 
 * Set the particular property in the underlying implementation of  {@code Marshaller}.  This method can only be used to set one of the standard JAXB defined properties above or a provider specific property.  Attempting to set an undefined property will result in a PropertyException being thrown.  See <a href=""  {@docRoot}/javax/xml/bind/Marshaller.html#supportedProps""> Supported Properties</a>.
 * @param name the name of the property to be set. This value can eitherbe specified using one of the constant fields or a user supplied string.
 * @param value the value of the property to be set
 * @throws PropertyException when there is an error processing the givenproperty or value
 * @throws IllegalArgumentException If the name parameter is null
 */
public void setProperty(String name,Object value) throws PropertyException ;"
76782,"/** 
 * Returns a   {@code LockInfo} object represented by thegiven  {@code CompositeData}. The given   {@code CompositeData} must contain the following attributes:<blockquote> <table border=""1""> <caption style=""display:none"">The attributes and the types the given CompositeData contains</caption> <tr> <th style=""text-align:left"">Attribute Name</th> <th style=""text-align:left"">Type</th> </tr> <tr> <td>className</td> <td> {@code java.lang.String}</td> </tr> <tr> <td>identityHashCode</td> <td>  {@code java.lang.Integer}</td> </tr> </table> </blockquote>
 * @param cd {@code CompositeData} representing a {@code LockInfo}
 * @throws IllegalArgumentException if {@code cd} does notrepresent a  {@code LockInfo} with the attributes describedabove.
 * @return a {@code LockInfo} object representedby  {@code cd} if {@code cd} is not {@code null};  {@code null} otherwise.
 * @since 1.8
 */
public static LockInfo from(CompositeData cd){
  if (cd == null) {
    return null;
  }
  if (cd instanceof LockInfoCompositeData) {
    return ((LockInfoCompositeData)cd).getLockInfo();
  }
 else {
    return LockInfoCompositeData.toLockInfo(cd);
  }
}","/** 
 * Returns a   {@code LockInfo} object represented by thegiven  {@code CompositeData}. The given   {@code CompositeData} must contain the following attributes:<table class=""striped"" style=""margin-left:2em;""> <caption style=""display:none"">The attributes and the types the given CompositeData contains</caption> <thead style=""text-align:left""> <tr> <th scope=""col"">Attribute Name</th> <th scope=""col"">Type</th> </tr> </thead> <tbody style=""text-align:left""> <tr> <th scope=""row"">className</th> <td> {@code java.lang.String}</td> </tr> <tr> <th scope=""row"">identityHashCode</th> <td>  {@code java.lang.Integer}</td> </tr> </tbody> </table>
 * @param cd {@code CompositeData} representing a {@code LockInfo}
 * @throws IllegalArgumentException if {@code cd} does notrepresent a  {@code LockInfo} with the attributes describedabove.
 * @return a {@code LockInfo} object representedby  {@code cd} if {@code cd} is not {@code null};  {@code null} otherwise.
 * @since 1.8
 */
public static LockInfo from(CompositeData cd){
  if (cd == null) {
    return null;
  }
  if (cd instanceof LockInfoCompositeData) {
    return ((LockInfoCompositeData)cd).getLockInfo();
  }
 else {
    return LockInfoCompositeData.toLockInfo(cd);
  }
}"
76783,"/** 
 * Returns a   {@code MemoryNotificationInfo} object represented by thegiven  {@code CompositeData}. The given   {@code CompositeData} must containthe following attributes: <blockquote> <table border=""1""> <caption style=""display:none"">The attributes and the types the given CompositeData contains</caption> <tr> <th style=""text-align:left"">Attribute Name</th> <th style=""text-align:left"">Type</th> </tr> <tr> <td>poolName</td> <td> {@code java.lang.String}</td> </tr> <tr> <td>usage</td> <td>  {@code javax.management.openmbean.CompositeData}</td> </tr> <tr> <td>count</td> <td>  {@code java.lang.Long}</td> </tr> </table> </blockquote>
 * @param cd {@code CompositeData} representing a{@code MemoryNotificationInfo}
 * @throws IllegalArgumentException if {@code cd} does notrepresent a  {@code MemoryNotificationInfo} object.
 * @return a {@code MemoryNotificationInfo} object representedby  {@code cd} if {@code cd} is not {@code null};  {@code null} otherwise.
 */
public static MemoryNotificationInfo from(CompositeData cd){
  if (cd == null) {
    return null;
  }
  if (cd instanceof MemoryNotifInfoCompositeData) {
    return ((MemoryNotifInfoCompositeData)cd).getMemoryNotifInfo();
  }
 else {
    return new MemoryNotificationInfo(cd);
  }
}","/** 
 * Returns a   {@code MemoryNotificationInfo} object represented by thegiven  {@code CompositeData}. The given   {@code CompositeData} must containthe following attributes: <table class=""striped"" style=""margin-left:2em""> <caption style=""display:none"">The attributes and the types the given CompositeData contains</caption> <thead> <tr> <th scope=""col"">Attribute Name</th> <th scope=""col"">Type</th> </tr> </thead> <tbody style=""text-align:left""> <tr> <th scope=""row"">poolName</th> <td> {@code java.lang.String}</td> </tr> <tr> <th scope=""row"">usage</th> <td>  {@code javax.management.openmbean.CompositeData}</td> </tr> <tr> <th scope=""row"">count</th> <td>  {@code java.lang.Long}</td> </tr> </tbody> </table>
 * @param cd {@code CompositeData} representing a{@code MemoryNotificationInfo}
 * @throws IllegalArgumentException if {@code cd} does notrepresent a  {@code MemoryNotificationInfo} object.
 * @return a {@code MemoryNotificationInfo} object representedby  {@code cd} if {@code cd} is not {@code null};  {@code null} otherwise.
 */
public static MemoryNotificationInfo from(CompositeData cd){
  if (cd == null) {
    return null;
  }
  if (cd instanceof MemoryNotifInfoCompositeData) {
    return ((MemoryNotifInfoCompositeData)cd).getMemoryNotifInfo();
  }
 else {
    return new MemoryNotificationInfo(cd);
  }
}"
76784,"/** 
 * Returns a   {@code MemoryUsage} object represented by thegiven  {@code CompositeData}. The given   {@code CompositeData}must contain the following attributes: <blockquote> <table border=""1""> <caption style=""display:none"">The attributes and the types the given CompositeData contains</caption> <tr> <th style=""text-align:left"">Attribute Name</th> <th style=""text-align:left"">Type</th> </tr> <tr> <td>init</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>used</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>committed</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>max</td> <td>  {@code java.lang.Long}</td> </tr> </table> </blockquote>
 * @param cd {@code CompositeData} representing a {@code MemoryUsage}
 * @throws IllegalArgumentException if {@code cd} does notrepresent a  {@code MemoryUsage} with the attributes describedabove.
 * @return a {@code MemoryUsage} object represented by {@code cd}if   {@code cd} is not {@code null};  {@code null} otherwise.
 */
public static MemoryUsage from(CompositeData cd){
  if (cd == null) {
    return null;
  }
  if (cd instanceof MemoryUsageCompositeData) {
    return ((MemoryUsageCompositeData)cd).getMemoryUsage();
  }
 else {
    return new MemoryUsage(cd);
  }
}","/** 
 * Returns a   {@code MemoryUsage} object represented by thegiven  {@code CompositeData}. The given   {@code CompositeData}must contain the following attributes: <table class=""striped"" style=""margin-left:2em;""> <caption style=""display:none"">The attributes and the types the given CompositeData contains</caption> <thead> <tr> <th scope=""col"">Attribute Name</th> <th scope=""col"">Type</th> </tr> </thead> <tbody style=""text-align:left""> <tr> <th scope=""row"">init</th> <td>  {@code java.lang.Long}</td> </tr> <tr> <th scope=""row"">used</th> <td>  {@code java.lang.Long}</td> </tr> <tr> <th scope=""row"">committed</th> <td>  {@code java.lang.Long}</td> </tr> <tr> <th scope=""row"">max</th> <td>  {@code java.lang.Long}</td> </tr> </tbody> </table>
 * @param cd {@code CompositeData} representing a {@code MemoryUsage}
 * @throws IllegalArgumentException if {@code cd} does notrepresent a  {@code MemoryUsage} with the attributes describedabove.
 * @return a {@code MemoryUsage} object represented by {@code cd}if   {@code cd} is not {@code null};  {@code null} otherwise.
 */
public static MemoryUsage from(CompositeData cd){
  if (cd == null) {
    return null;
  }
  if (cd instanceof MemoryUsageCompositeData) {
    return ((MemoryUsageCompositeData)cd).getMemoryUsage();
  }
 else {
    return new MemoryUsage(cd);
  }
}"
76785,"/** 
 * Returns a   {@code MonitorInfo} object represented by thegiven  {@code CompositeData}. The given   {@code CompositeData} must contain the following attributesas well as the attributes specified in the <a href=""LockInfo.html#MappedType""> mapped type</a> for the  {@link LockInfo} class:<blockquote> <table border=""1""> <caption style=""display:none"">The attributes and their types the given CompositeData contains</caption> <tr> <th style=""text-align:left"">Attribute Name</th> <th style=""text-align:left"">Type</th> </tr> <tr> <td>lockedStackFrame</td> <td><code>CompositeData as specified in the <a href=""ThreadInfo.html#StackTrace"">stackTrace</a> attribute defined in the  {@link ThreadInfo#from ThreadInfo.from} method.</code></td> </tr> <tr> <td>lockedStackDepth</td> <td> {@code java.lang.Integer}</td> </tr> </table> </blockquote>
 * @param cd {@code CompositeData} representing a {@code MonitorInfo}
 * @throws IllegalArgumentException if {@code cd} does notrepresent a  {@code MonitorInfo} with the attributes describedabove.
 * @return a {@code MonitorInfo} object representedby  {@code cd} if {@code cd} is not {@code null};  {@code null} otherwise.
 */
public static MonitorInfo from(CompositeData cd){
  if (cd == null) {
    return null;
  }
  if (cd instanceof MonitorInfoCompositeData) {
    return ((MonitorInfoCompositeData)cd).getMonitorInfo();
  }
 else {
    MonitorInfoCompositeData.validateCompositeData(cd);
    String className=MonitorInfoCompositeData.getClassName(cd);
    int identityHashCode=MonitorInfoCompositeData.getIdentityHashCode(cd);
    int stackDepth=MonitorInfoCompositeData.getLockedStackDepth(cd);
    StackTraceElement stackFrame=MonitorInfoCompositeData.getLockedStackFrame(cd);
    return new MonitorInfo(className,identityHashCode,stackDepth,stackFrame);
  }
}","/** 
 * Returns a   {@code MonitorInfo} object represented by thegiven  {@code CompositeData}. The given   {@code CompositeData} must contain the following attributesas well as the attributes specified in the <a href=""LockInfo.html#MappedType""> mapped type</a> for the  {@link LockInfo} class:<table class=""striped"" style=""margin-left:2em""> <caption style=""display:none"">The attributes and their types the given CompositeData contains</caption> <thead> <tr> <th scope=""col"">Attribute Name</th> <th scope=""col"">Type</th> </tr> </thead> <tbody style=""text-align:left""> <tr> <th scope=""row"">lockedStackFrame</th> <td><code>CompositeData as specified in the <a href=""ThreadInfo.html#StackTrace"">stackTrace</a> attribute defined in the  {@link ThreadInfo#from ThreadInfo.from} method.</code></td> </tr> <tr> <th scope=""row"">lockedStackDepth</th> <td> {@code java.lang.Integer}</td> </tr> </tbody> </table>
 * @param cd {@code CompositeData} representing a {@code MonitorInfo}
 * @throws IllegalArgumentException if {@code cd} does notrepresent a  {@code MonitorInfo} with the attributes describedabove.
 * @return a {@code MonitorInfo} object representedby  {@code cd} if {@code cd} is not {@code null};  {@code null} otherwise.
 */
public static MonitorInfo from(CompositeData cd){
  if (cd == null) {
    return null;
  }
  if (cd instanceof MonitorInfoCompositeData) {
    return ((MonitorInfoCompositeData)cd).getMonitorInfo();
  }
 else {
    MonitorInfoCompositeData.validateCompositeData(cd);
    String className=MonitorInfoCompositeData.getClassName(cd);
    int identityHashCode=MonitorInfoCompositeData.getIdentityHashCode(cd);
    int stackDepth=MonitorInfoCompositeData.getLockedStackDepth(cd);
    StackTraceElement stackFrame=MonitorInfoCompositeData.getLockedStackFrame(cd);
    return new MonitorInfo(className,identityHashCode,stackDepth,stackFrame);
  }
}"
76786,"/** 
 * Gets the DER-encoded OCTET string for the extension value (<em>extnValue</em>) identified by the passed-in   {@code oid}String. The   {@code oid} string isrepresented by a set of nonnegative whole numbers separated by periods. <p>For example:<br> <table class=""plain""> <caption style=""display:none"">Examples of OIDs and extension names</caption> <thead> <tr> <th>OID <em>(Object Identifier)</em></th> <th>Extension Name</th></tr> </thead> <tbody> <tr><td>2.5.29.14</td> <td>SubjectKeyIdentifier</td></tr> <tr><td>2.5.29.15</td> <td>KeyUsage</td></tr> <tr><td>2.5.29.16</td> <td>PrivateKeyUsage</td></tr> <tr><td>2.5.29.17</td> <td>SubjectAlternativeName</td></tr> <tr><td>2.5.29.18</td> <td>IssuerAlternativeName</td></tr> <tr><td>2.5.29.19</td> <td>BasicConstraints</td></tr> <tr><td>2.5.29.30</td> <td>NameConstraints</td></tr> <tr><td>2.5.29.33</td> <td>PolicyMappings</td></tr> <tr><td>2.5.29.35</td> <td>AuthorityKeyIdentifier</td></tr> <tr><td>2.5.29.36</td> <td>PolicyConstraints</td></tr> </tbody> </table>
 * @param oid the Object Identifier value for the extension.
 * @return the DER-encoded octet string of the extension value ornull if it is not present.
 */
public byte[] getExtensionValue(String oid);","/** 
 * Gets the DER-encoded OCTET string for the extension value (<em>extnValue</em>) identified by the passed-in   {@code oid}String. The   {@code oid} string isrepresented by a set of nonnegative whole numbers separated by periods. <p>For example:<br> <table class=""striped""> <caption style=""display:none"">Examples of OIDs and extension names</caption> <thead> <tr> <th scope=""col"">OID <em>(Object Identifier)</em></th> <th scope=""col"">Extension Name</th></tr> </thead> <tbody style=""text-align:left""> <tr><th scope=""row"">2.5.29.14</th> <td>SubjectKeyIdentifier</td></tr> <tr><th scope=""row"">2.5.29.15</th> <td>KeyUsage</td></tr> <tr><th scope=""row"">2.5.29.16</th> <td>PrivateKeyUsage</td></tr> <tr><th scope=""row"">2.5.29.17</th> <td>SubjectAlternativeName</td></tr> <tr><th scope=""row"">2.5.29.18</th> <td>IssuerAlternativeName</td></tr> <tr><th scope=""row"">2.5.29.19</th> <td>BasicConstraints</td></tr> <tr><th scope=""row"">2.5.29.30</th> <td>NameConstraints</td></tr> <tr><th scope=""row"">2.5.29.33</th> <td>PolicyMappings</td></tr> <tr><th scope=""row"">2.5.29.35</th> <td>AuthorityKeyIdentifier</td></tr> <tr><th scope=""row"">2.5.29.36</th> <td>PolicyConstraints</td></tr> </tbody> </table>
 * @param oid the Object Identifier value for the extension.
 * @return the DER-encoded octet string of the extension value ornull if it is not present.
 */
public byte[] getExtensionValue(String oid);"
76787,"/** 
 * Updates the logging configuration. <p> For each configuration key in the   {@linkplain #getProperty(java.lang.String) existing configuration} andthe given input stream configuration, the given  {@code mapper} functionis invoked to map from the configuration key to a function, <i>f(o,n)</i>, that takes the old value and new value and returns the resulting value to be applied in the resulting configuration, as specified in the table below. <p>Let <i>k</i> be a configuration key in the old or new configuration, <i>o</i> be the old value (i.e. the value associated with <i>k</i> in the old configuration), <i>n</i> be the new value (i.e. the value associated with <i>k</i> in the new configuration), and <i>f</i> be the function returned by  {@code mapper.apply(}<i>k</i>  {@code )}: then <i>v = f(o,n)</i> is the resulting value. If <i>v</i> is not   {@code null}, then a property <i>k</i> with value <i>v</i> will be added to the resulting configuration. Otherwise, it will be omitted. <br>A   {@code null} value may be passed to function<i>f</i> to indicate that the corresponding configuration has no configuration key <i>k</i>. The function <i>f</i> may return  {@code null} to indicate thatthere will be no value associated with <i>k</i> in the resulting configuration. <p> If  {@code mapper} is {@code null}, then <i>v</i> will be set to <i>n</i>. <p> LogManager   {@linkplain #getProperty(java.lang.String) properties} areupdated with the resulting value in the resulting configuration. <p> The registered  {@linkplain #addConfigurationListener configurationlisteners} will be invoked after the configuration is successfully updated.<br><br> <table><caption style=""display:none"">Updating configuration properties</caption> <tr> <th>Property</th> <th>Resulting Behavior</th> </tr> <tr> <td valign=""top""> {@code <logger>.level}</td> <td> <ul> <li>If the resulting configuration defines a level for a logger and if the resulting level is different than the level specified in the the old configuration, or not specified in the old configuration, then if the logger exists or if children for that logger exist, the level for that logger will be updated, and the change propagated to any existing logger children. This may cause the logger to be created, if necessary. </li> <li>If the old configuration defined a level for a logger, and the resulting configuration doesn't, then this change will not be propagated to existing loggers, if any. To completely replace a configuration - the caller should therefore call   {@link #reset() reset} to empty the current configuration,before calling  {@code updateConfiguration}. </li> </ul> </td> <tr> <td valign=""top"">  {@code <logger>.useParentHandlers}</td> <td> <ul> <li>If either the resulting or the old value for the useParentHandlers property is not null, then if the logger exists or if children for that logger exist, that logger will be updated to the resulting value. The value of the useParentHandlers property is the value specified in the configuration; if not specified, the default is true. </li> </ul> </td> </tr> <tr> <td valign=""top"">  {@code <logger>.handlers}</td> <td> <ul> <li>If the resulting configuration defines a list of handlers for a logger, and if the resulting list is different than the list specified in the old configuration for that logger (that could be empty), then if the logger exists or its children exist, the handlers associated with that logger are closed and removed and the new handlers will be created per the resulting configuration and added to that logger, creating that logger if necessary. </li> <li>If the old configuration defined some handlers for a logger, and the resulting configuration doesn't, if that logger exists, its handlers will be removed and closed. </li> <li>Changing the list of handlers on an existing logger will cause all its previous handlers to be removed and closed, regardless of whether they had been created from the configuration or programmatically. The old handlers will be replaced by new handlers, if any. </li> </ul> </td> </tr> <tr> <td valign=""top"">  {@code <handler-name>.*}</td> <td> <ul> <li>Properties configured/changed on handler classes will only affect newly created handlers. If a node is configured with the same list of handlers in the old and the resulting configuration, then these handlers will remain unchanged. </li> </ul> </td> </tr> <tr> <td valign=""top"">  {@code config} and any other property</td><td> <ul> <li>The resulting value for these property will be stored in the LogManager properties, but  {@code updateConfiguration} will not parseor process their values. </li> </ul> </td> </tr> </table> <p> <em>Example mapper functions:</em> <br><br> <ul> <li>Replace all logging properties with the new configuration: <br><br> {@code     (k) -> ((o, n) -> n)}: <br><br>this is equivalent to passing a null   {@code mapper} parameter.</li> <li>Merge the new configuration and old configuration and use the new value if <i>k</i> exists in the new configuration: <br><br> {@code     (k) -> ((o, n) -> n == null ? o : n)}: <br><br>as if merging two collections as follows:  {@code result.putAll(oldc); result.putAll(newc)}.<br></li> <li>Merge the new configuration and old configuration and use the old value if <i>k</i> exists in the old configuration: <br><br>  {@code     (k) -> ((o, n) -> o == null ? n : o)}: <br><br>as if merging two collections as follows:  {@code result.putAll(newc); result.putAll(oldc)}.<br></li> <li>Replace all properties with the new configuration except the handler property to configure Logger's handler that is not root logger: <br> <pre>  {@code (k) -> k.endsWith("".handlers"")}{@code     ? ((o, n) -> (o == null ? n : o))}{@code     : ((o, n) -> n)}</pre> </li> </ul> <p> To completely reinitialize a configuration, an application can first call  {@link #reset() reset} to fully remove the old configuration, followed by{@code updateConfiguration} to initialize the new configuration.
 * @param ins    a stream to read properties from
 * @param mapper a functional interface that takes a configurationkey <i>k</i> and returns a function <i>f(o,n)</i> whose returned value will be applied to the resulting configuration. The function <i>f</i> may return  {@code null} to indicate that the property<i>k</i> will not be added to the resulting configuration. <br> If  {@code mapper} is {@code null} then {@code (k) -> ((o, n) -> n)} isassumed. <br> For each <i>k</i>, the mapped function <i>f</i> will be invoked with the value associated with <i>k</i> in the old configuration (i.e <i>o</i>) and the value associated with <i>k</i> in the new configuration (i.e. <i>n</i>). <br>A  {@code null} value for <i>o</i> or <i>n</i> indicates that novalue was present for <i>k</i> in the corresponding configuration.
 * @throws SecurityException if a security manager exists and ifthe caller does not have LoggingPermission(""control""), or does not have the permissions required to set up the configuration (e.g. open files specified for FileHandlers)
 * @throws NullPointerException if {@code ins} is null or if{@code mapper} returns a null function when invoked.
 * @throws IOException if there are problems reading from the stream,or the given stream is not in the {@linkplain java.util.Properties properties file} format.
 * @since 9
 */
public void updateConfiguration(InputStream ins,Function<String,BiFunction<String,String,String>> mapper) throws IOException {
  checkPermission();
  ensureLogManagerInitialized();
  drainLoggerRefQueueBounded();
  final Properties previous;
  final Set<String> updatePropertyNames;
  List<LoggerContext> cxs=Collections.emptyList();
  final VisitedLoggers visited=new VisitedLoggers();
  final Properties next=new Properties();
  try {
    next.load(ins);
  }
 catch (  IllegalArgumentException x) {
    throw new IOException(x.getMessage(),x);
  }
  if (globalHandlersState == STATE_SHUTDOWN)   return;
  configurationLock.lock();
  try {
    if (globalHandlersState == STATE_SHUTDOWN)     return;
    previous=props;
    updatePropertyNames=Stream.concat(previous.stringPropertyNames().stream(),next.stringPropertyNames().stream()).collect(Collectors.toCollection(TreeSet::new));
    if (mapper != null) {
      updatePropertyNames.stream().forEachOrdered(k -> ConfigProperty.merge(k,previous,next,Objects.requireNonNull(mapper.apply(k))));
    }
    props=next;
    final Stream<String> allKeys=updatePropertyNames.stream().filter(ConfigProperty::matches).filter(k -> ConfigProperty.needsUpdating(k,previous,next));
    final Map<String,TreeSet<String>> loggerConfigs=allKeys.collect(Collectors.groupingBy(ConfigProperty::getLoggerName,TreeMap::new,Collectors.toCollection(TreeSet::new)));
    if (!loggerConfigs.isEmpty()) {
      cxs=contexts();
    }
    final List<Logger> loggers=cxs.isEmpty() ? Collections.emptyList() : new ArrayList<>(cxs.size());
    for (    Map.Entry<String,TreeSet<String>> e : loggerConfigs.entrySet()) {
      final String name=e.getKey();
      final Set<String> properties=e.getValue();
      loggers.clear();
      for (      LoggerContext cx : cxs) {
        Logger l=cx.findLogger(name);
        if (l != null && !visited.test(l)) {
          loggers.add(l);
        }
      }
      if (loggers.isEmpty())       continue;
      for (      String pk : properties) {
        ConfigProperty cp=ConfigProperty.find(pk).get();
        String p=previous.getProperty(pk,null);
        String n=next.getProperty(pk,null);
        ModType mod=ModType.of(p,n);
        if (mod == ModType.SAME)         continue;
switch (cp) {
case LEVEL:
          if (mod == ModType.REMOVED)           continue;
        Level level=Level.findLevel(trim(n));
      if (level != null) {
        if (name.isEmpty()) {
          rootLogger.setLevel(level);
        }
        for (        Logger l : loggers) {
          if (!name.isEmpty() || l != rootLogger) {
            l.setLevel(level);
          }
        }
      }
    break;
case USEPARENT:
  if (!name.isEmpty()) {
    boolean useParent=getBooleanProperty(pk,true);
    if (n != null || p != null) {
      for (      Logger l : loggers) {
        l.setUseParentHandlers(useParent);
      }
    }
  }
break;
case HANDLERS:
List<Handler> hdls=null;
if (name.isEmpty()) {
globalHandlersState=STATE_READING_CONFIG;
try {
closeHandlers(rootLogger);
globalHandlersState=STATE_UNINITIALIZED;
}
 catch (Throwable t) {
globalHandlersState=STATE_INITIALIZED;
throw t;
}
}
for (Logger l : loggers) {
if (l == rootLogger) continue;
closeHandlers(l);
if (mod == ModType.REMOVED) {
closeOnResetLoggers.removeIf(c -> c.logger == l);
continue;
}
if (hdls == null) {
hdls=name.isEmpty() ? Arrays.asList(rootLogger.getHandlers()) : createLoggerHandlers(name,pk);
}
setLoggerHandlers(l,name,pk,hdls);
}
break;
default :
break;
}
}
}
}
  finally {
configurationLock.unlock();
visited.clear();
}
drainLoggerRefQueueBounded();
for (LoggerContext cx : cxs) {
for (Enumeration<String> names=cx.getLoggerNames(); names.hasMoreElements(); ) {
String name=names.nextElement();
if (name.isEmpty()) continue;
Logger l=cx.findLogger(name);
if (l != null && !visited.test(l)) {
cx.processParentHandlers(l,name,visited);
}
}
}
invokeConfigurationListeners();
}","/** 
 * Updates the logging configuration. <p> For each configuration key in the   {@linkplain #getProperty(java.lang.String) existing configuration} andthe given input stream configuration, the given  {@code mapper} functionis invoked to map from the configuration key to a function, <i>f(o,n)</i>, that takes the old value and new value and returns the resulting value to be applied in the resulting configuration, as specified in the table below. <p>Let <i>k</i> be a configuration key in the old or new configuration, <i>o</i> be the old value (i.e. the value associated with <i>k</i> in the old configuration), <i>n</i> be the new value (i.e. the value associated with <i>k</i> in the new configuration), and <i>f</i> be the function returned by  {@code mapper.apply(}<i>k</i>  {@code )}: then <i>v = f(o,n)</i> is the resulting value. If <i>v</i> is not   {@code null}, then a property <i>k</i> with value <i>v</i> will be added to the resulting configuration. Otherwise, it will be omitted. <br>A   {@code null} value may be passed to function<i>f</i> to indicate that the corresponding configuration has no configuration key <i>k</i>. The function <i>f</i> may return  {@code null} to indicate thatthere will be no value associated with <i>k</i> in the resulting configuration. <p> If  {@code mapper} is {@code null}, then <i>v</i> will be set to <i>n</i>. <p> LogManager   {@linkplain #getProperty(java.lang.String) properties} areupdated with the resulting value in the resulting configuration. <p> The registered  {@linkplain #addConfigurationListener configurationlisteners} will be invoked after the configuration is successfully updated.<br><br> <table class=""striped""> <caption style=""display:none"">Updating configuration properties</caption> <thead> <tr> <th scope=""col"">Property</th> <th scope=""col"">Resulting Behavior</th> </tr> </thead> <tbody> <tr> <th scope=""row"" valign=""top""> {@code <logger>.level}</th> <td> <ul> <li>If the resulting configuration defines a level for a logger and if the resulting level is different than the level specified in the the old configuration, or not specified in the old configuration, then if the logger exists or if children for that logger exist, the level for that logger will be updated, and the change propagated to any existing logger children. This may cause the logger to be created, if necessary. </li> <li>If the old configuration defined a level for a logger, and the resulting configuration doesn't, then this change will not be propagated to existing loggers, if any. To completely replace a configuration - the caller should therefore call   {@link #reset() reset} to empty the current configuration,before calling  {@code updateConfiguration}. </li> </ul> </td> <tr> <th scope=""row"" valign=""top"">  {@code <logger>.useParentHandlers}</th> <td> <ul> <li>If either the resulting or the old value for the useParentHandlers property is not null, then if the logger exists or if children for that logger exist, that logger will be updated to the resulting value. The value of the useParentHandlers property is the value specified in the configuration; if not specified, the default is true. </li> </ul> </td> </tr> <tr> <th scope=""row"" valign=""top"">  {@code <logger>.handlers}</th> <td> <ul> <li>If the resulting configuration defines a list of handlers for a logger, and if the resulting list is different than the list specified in the old configuration for that logger (that could be empty), then if the logger exists or its children exist, the handlers associated with that logger are closed and removed and the new handlers will be created per the resulting configuration and added to that logger, creating that logger if necessary. </li> <li>If the old configuration defined some handlers for a logger, and the resulting configuration doesn't, if that logger exists, its handlers will be removed and closed. </li> <li>Changing the list of handlers on an existing logger will cause all its previous handlers to be removed and closed, regardless of whether they had been created from the configuration or programmatically. The old handlers will be replaced by new handlers, if any. </li> </ul> </td> </tr> <tr> <th scope=""row"" valign=""top"">  {@code <handler-name>.*}</th> <td> <ul> <li>Properties configured/changed on handler classes will only affect newly created handlers. If a node is configured with the same list of handlers in the old and the resulting configuration, then these handlers will remain unchanged. </li> </ul> </td> </tr> <tr> <th scope=""row"" valign=""top"">  {@code config} and any other property</th><td> <ul> <li>The resulting value for these property will be stored in the LogManager properties, but  {@code updateConfiguration} will not parseor process their values. </li> </ul> </td> </tr> </tbody> </table> <p> <em>Example mapper functions:</em> <br><br> <ul> <li>Replace all logging properties with the new configuration: <br><br> {@code     (k) -> ((o, n) -> n)}: <br><br>this is equivalent to passing a null   {@code mapper} parameter.</li> <li>Merge the new configuration and old configuration and use the new value if <i>k</i> exists in the new configuration: <br><br> {@code     (k) -> ((o, n) -> n == null ? o : n)}: <br><br>as if merging two collections as follows:  {@code result.putAll(oldc); result.putAll(newc)}.<br></li> <li>Merge the new configuration and old configuration and use the old value if <i>k</i> exists in the old configuration: <br><br>  {@code     (k) -> ((o, n) -> o == null ? n : o)}: <br><br>as if merging two collections as follows:  {@code result.putAll(newc); result.putAll(oldc)}.<br></li> <li>Replace all properties with the new configuration except the handler property to configure Logger's handler that is not root logger: <br> <pre>  {@code (k) -> k.endsWith("".handlers"")}{@code     ? ((o, n) -> (o == null ? n : o))}{@code     : ((o, n) -> n)}</pre> </li> </ul> <p> To completely reinitialize a configuration, an application can first call  {@link #reset() reset} to fully remove the old configuration, followed by{@code updateConfiguration} to initialize the new configuration.
 * @param ins    a stream to read properties from
 * @param mapper a functional interface that takes a configurationkey <i>k</i> and returns a function <i>f(o,n)</i> whose returned value will be applied to the resulting configuration. The function <i>f</i> may return  {@code null} to indicate that the property<i>k</i> will not be added to the resulting configuration. <br> If  {@code mapper} is {@code null} then {@code (k) -> ((o, n) -> n)} isassumed. <br> For each <i>k</i>, the mapped function <i>f</i> will be invoked with the value associated with <i>k</i> in the old configuration (i.e <i>o</i>) and the value associated with <i>k</i> in the new configuration (i.e. <i>n</i>). <br>A  {@code null} value for <i>o</i> or <i>n</i> indicates that novalue was present for <i>k</i> in the corresponding configuration.
 * @throws SecurityException if a security manager exists and ifthe caller does not have LoggingPermission(""control""), or does not have the permissions required to set up the configuration (e.g. open files specified for FileHandlers)
 * @throws NullPointerException if {@code ins} is null or if{@code mapper} returns a null function when invoked.
 * @throws IOException if there are problems reading from the stream,or the given stream is not in the {@linkplain java.util.Properties properties file} format.
 * @since 9
 */
public void updateConfiguration(InputStream ins,Function<String,BiFunction<String,String,String>> mapper) throws IOException {
  checkPermission();
  ensureLogManagerInitialized();
  drainLoggerRefQueueBounded();
  final Properties previous;
  final Set<String> updatePropertyNames;
  List<LoggerContext> cxs=Collections.emptyList();
  final VisitedLoggers visited=new VisitedLoggers();
  final Properties next=new Properties();
  try {
    next.load(ins);
  }
 catch (  IllegalArgumentException x) {
    throw new IOException(x.getMessage(),x);
  }
  if (globalHandlersState == STATE_SHUTDOWN)   return;
  configurationLock.lock();
  try {
    if (globalHandlersState == STATE_SHUTDOWN)     return;
    previous=props;
    updatePropertyNames=Stream.concat(previous.stringPropertyNames().stream(),next.stringPropertyNames().stream()).collect(Collectors.toCollection(TreeSet::new));
    if (mapper != null) {
      updatePropertyNames.stream().forEachOrdered(k -> ConfigProperty.merge(k,previous,next,Objects.requireNonNull(mapper.apply(k))));
    }
    props=next;
    final Stream<String> allKeys=updatePropertyNames.stream().filter(ConfigProperty::matches).filter(k -> ConfigProperty.needsUpdating(k,previous,next));
    final Map<String,TreeSet<String>> loggerConfigs=allKeys.collect(Collectors.groupingBy(ConfigProperty::getLoggerName,TreeMap::new,Collectors.toCollection(TreeSet::new)));
    if (!loggerConfigs.isEmpty()) {
      cxs=contexts();
    }
    final List<Logger> loggers=cxs.isEmpty() ? Collections.emptyList() : new ArrayList<>(cxs.size());
    for (    Map.Entry<String,TreeSet<String>> e : loggerConfigs.entrySet()) {
      final String name=e.getKey();
      final Set<String> properties=e.getValue();
      loggers.clear();
      for (      LoggerContext cx : cxs) {
        Logger l=cx.findLogger(name);
        if (l != null && !visited.test(l)) {
          loggers.add(l);
        }
      }
      if (loggers.isEmpty())       continue;
      for (      String pk : properties) {
        ConfigProperty cp=ConfigProperty.find(pk).get();
        String p=previous.getProperty(pk,null);
        String n=next.getProperty(pk,null);
        ModType mod=ModType.of(p,n);
        if (mod == ModType.SAME)         continue;
switch (cp) {
case LEVEL:
          if (mod == ModType.REMOVED)           continue;
        Level level=Level.findLevel(trim(n));
      if (level != null) {
        if (name.isEmpty()) {
          rootLogger.setLevel(level);
        }
        for (        Logger l : loggers) {
          if (!name.isEmpty() || l != rootLogger) {
            l.setLevel(level);
          }
        }
      }
    break;
case USEPARENT:
  if (!name.isEmpty()) {
    boolean useParent=getBooleanProperty(pk,true);
    if (n != null || p != null) {
      for (      Logger l : loggers) {
        l.setUseParentHandlers(useParent);
      }
    }
  }
break;
case HANDLERS:
List<Handler> hdls=null;
if (name.isEmpty()) {
globalHandlersState=STATE_READING_CONFIG;
try {
closeHandlers(rootLogger);
globalHandlersState=STATE_UNINITIALIZED;
}
 catch (Throwable t) {
globalHandlersState=STATE_INITIALIZED;
throw t;
}
}
for (Logger l : loggers) {
if (l == rootLogger) continue;
closeHandlers(l);
if (mod == ModType.REMOVED) {
closeOnResetLoggers.removeIf(c -> c.logger == l);
continue;
}
if (hdls == null) {
hdls=name.isEmpty() ? Arrays.asList(rootLogger.getHandlers()) : createLoggerHandlers(name,pk);
}
setLoggerHandlers(l,name,pk,hdls);
}
break;
default :
break;
}
}
}
}
  finally {
configurationLock.unlock();
visited.clear();
}
drainLoggerRefQueueBounded();
for (LoggerContext cx : cxs) {
for (Enumeration<String> names=cx.getLoggerNames(); names.hasMoreElements(); ) {
String name=names.nextElement();
if (name.isEmpty()) continue;
Logger l=cx.findLogger(name);
if (l != null && !visited.test(l)) {
cx.processParentHandlers(l,name,visited);
}
}
}
invokeConfigurationListeners();
}"
76788,"/** 
 * Log a message, specifying source class, method, and resource bundle, with associated Throwable information. <p> If the logger is currently enabled for the given message  {@code level} then the given arguments are stored in a {@code LogRecord}which is forwarded to all registered output handlers. <p> The   {@code msg} string is localized using the given resource bundle.If the resource bundle is  {@code null}, then the   {@code msg} string is notlocalized. <p> Note that the  {@code thrown} argument is stored in the {@code LogRecord}{@code thrown} property, rather than the {@code LogRecord}{@code parameters} property.  Thus it isprocessed specially by output  {@code Formatter} objects and is not treatedas a formatting parameter to the  {@code LogRecord} {@code message}property. <p>
 * @param level   One of the message level identifiers, e.g., {@code SEVERE}
 * @param bundle  Resource bundle to localize {@code msg}; can be   {@code null}.
 * @param msg     The string message (or a key in the message catalog)
 * @param thrown  Throwable associated with the log message.
 * @since 9
 */
public void logrb(Level level,ResourceBundle bundle,String msg,Throwable thrown){
  if (!isLoggable(level)) {
    return;
  }
  LogRecord lr=new LogRecord(level,msg);
  lr.setThrown(thrown);
  doLog(lr,bundle);
}","/** 
 * Log a message, specifying source class, method, and resource bundle, with associated Throwable information. <p> If the logger is currently enabled for the given message  {@code level} then the given arguments are stored in a {@code LogRecord}which is forwarded to all registered output handlers. <p> The   {@code msg} string is localized using the given resource bundle.If the resource bundle is  {@code null}, then the   {@code msg} string is notlocalized. <p> Note that the  {@code thrown} argument is stored in the {@code LogRecord}{@code thrown} property, rather than the {@code LogRecord}{@code parameters} property.  Thus it isprocessed specially by output  {@code Formatter} objects and is not treatedas a formatting parameter to the  {@code LogRecord} {@code message}property.
 * @param level   One of the message level identifiers, e.g., {@code SEVERE}
 * @param bundle  Resource bundle to localize {@code msg}; can be   {@code null}.
 * @param msg     The string message (or a key in the message catalog)
 * @param thrown  Throwable associated with the log message.
 * @since 9
 */
public void logrb(Level level,ResourceBundle bundle,String msg,Throwable thrown){
  if (!isLoggable(level)) {
    return;
  }
  LogRecord lr=new LogRecord(level,msg);
  lr.setThrown(thrown);
  doLog(lr,bundle);
}"
76789,"/** 
 * Determines if the specified character is ISO-LATIN-1 white space. This method returns   {@code true} for the following fivecharacters only: <table class=""borderless""> <caption style=""display:none"">truechars</caption> <tbody> <tr><td> {@code '\t'}</td>            <td>  {@code U+0009}</td> <td>  {@code HORIZONTAL TABULATION}</td></tr> <tr><td>  {@code '\n'}</td>            <td>  {@code U+000A}</td> <td>  {@code NEW LINE}</td></tr> <tr><td>  {@code '\f'}</td>            <td>  {@code U+000C}</td> <td>  {@code FORM FEED}</td></tr> <tr><td>  {@code '\r'}</td>            <td>  {@code U+000D}</td> <td>  {@code CARRIAGE RETURN}</td></tr> <tr><td>  {@code ' '}</td>  <td>  {@code U+0020}</td> <td>  {@code SPACE}</td></tr> </tbody> </table>
 * @param ch   the character to be tested.
 * @return     {@code true} if the character is ISO-LATIN-1 whitespace;  {@code false} otherwise.
 * @see Character#isSpaceChar(char)
 * @see Character#isWhitespace(char)
 * @deprecated Replaced by isWhitespace(char).
 */
@Deprecated(since=""String_Node_Str"") public static boolean isSpace(char ch){
  return (ch <= 0x0020) && (((((1L << 0x0009) | (1L << 0x000A) | (1L << 0x000C)| (1L << 0x000D)| (1L << 0x0020)) >> ch) & 1L) != 0);
}","/** 
 * Determines if the specified character is ISO-LATIN-1 white space. This method returns   {@code true} for the following fivecharacters only: <table class=""striped""> <caption style=""display:none"">truechars</caption> <thead> <tr><th scope=""col"">Character <th scope=""col"">Code <th scope=""col"">Name </thead> <tbody> <tr><th scope=""row""> {@code '\t'}</th>            <td>  {@code U+0009}</td> <td>  {@code HORIZONTAL TABULATION}</td></tr> <tr><th scope=""row"">  {@code '\n'}</th>            <td>  {@code U+000A}</td> <td>  {@code NEW LINE}</td></tr> <tr><th scope=""row"">  {@code '\f'}</th>            <td>  {@code U+000C}</td> <td>  {@code FORM FEED}</td></tr> <tr><th scope=""row"">  {@code '\r'}</th>            <td>  {@code U+000D}</td> <td>  {@code CARRIAGE RETURN}</td></tr> <tr><th scope=""row"">  {@code ' '}</th>  <td>  {@code U+0020}</td> <td>  {@code SPACE}</td></tr> </tbody> </table>
 * @param ch   the character to be tested.
 * @return     {@code true} if the character is ISO-LATIN-1 whitespace;  {@code false} otherwise.
 * @see Character#isSpaceChar(char)
 * @see Character#isWhitespace(char)
 * @deprecated Replaced by isWhitespace(char).
 */
@Deprecated(since=""String_Node_Str"") public static boolean isSpace(char ch){
  return (ch <= 0x0020) && (((((1L << 0x0009) | (1L << 0x000A) | (1L << 0x000C)| (1L << 0x000D)| (1L << 0x0020)) >> ch) & 1L) != 0);
}"
76790,"/** 
 * Returns a hexadecimal string representation of the  {@code double} argument. All characters mentioned beloware ASCII characters. <ul> <li>If the argument is NaN, the result is the string "" {@code NaN}"". <li>Otherwise, the result is a string that represents the sign and magnitude of the argument. If the sign is negative, the first character of the result is '  {@code -}' (  {@code '\u005Cu002D'}); if the sign is positive, no sign character appears in the result. As for the magnitude <i>m</i>: <ul> <li>If <i>m</i> is infinity, it is represented by the string  {@code ""Infinity""}; thus, positive infinity produces the result   {@code ""Infinity""} and negative infinity producesthe result  {@code ""-Infinity""}. <li>If <i>m</i> is zero, it is represented by the string  {@code ""0x0.0p0""}; thus, negative zero produces the result  {@code ""-0x0.0p0""} and positive zero produces the result{@code ""0x0.0p0""}. <li>If <i>m</i> is a   {@code double} value with anormalized representation, substrings are used to represent the significand and exponent fields.  The significand is represented by the characters  {@code ""0x1.""}followed by a lowercase hexadecimal representation of the rest of the significand as a fraction.  Trailing zeros in the hexadecimal representation are removed unless all the digits are zero, in which case a single zero is used. Next, the exponent is represented by   {@code ""p""} followedby a decimal string of the unbiased exponent as if produced by a call to  {@link Integer#toString(int) Integer.toString} on theexponent value. <li>If <i>m</i> is a  {@code double} value with a subnormalrepresentation, the significand is represented by the characters  {@code ""0x0.""} followed by ahexadecimal representation of the rest of the significand as a fraction.  Trailing zeros in the hexadecimal representation are removed. Next, the exponent is represented by {@code ""p-1022""}.  Note that there must be at least one nonzero digit in a subnormal significand. </ul> </ul> <table class=""plain""> <caption>Examples</caption> <thead> <tr><th>Floating-point Value</th><th>Hexadecimal String</th> </thead> <tbody> <tr><td>  {@code 1.0}</td> <td>  {@code 0x1.0p0}</td> <tr><td>  {@code -1.0}</td>        <td>  {@code -0x1.0p0}</td> <tr><td>  {@code 2.0}</td> <td>  {@code 0x1.0p1}</td> <tr><td>  {@code 3.0}</td> <td>  {@code 0x1.8p1}</td> <tr><td>  {@code 0.5}</td> <td>  {@code 0x1.0p-1}</td> <tr><td>  {@code 0.25}</td>        <td>  {@code 0x1.0p-2}</td> <tr><td>  {@code Double.MAX_VALUE}</td> <td>  {@code 0x1.fffffffffffffp1023}</td> <tr><td>  {@code Minimum Normal Value}</td> <td>  {@code 0x1.0p-1022}</td> <tr><td>  {@code Maximum Subnormal Value}</td> <td>  {@code 0x0.fffffffffffffp-1022}</td> <tr><td>  {@code Double.MIN_VALUE}</td> <td>  {@code 0x0.0000000000001p-1022}</td> </tbody> </table>
 * @param d   the {@code double} to be converted.
 * @return a hex string representation of the argument.
 * @since 1.5
 * @author Joseph D. Darcy
 */
public static String toHexString(double d){
  if (!isFinite(d))   return Double.toString(d);
 else {
    StringBuilder answer=new StringBuilder(24);
    if (Math.copySign(1.0,d) == -1.0)     answer.append(""String_Node_Str"");
    answer.append(""String_Node_Str"");
    d=Math.abs(d);
    if (d == 0.0) {
      answer.append(""String_Node_Str"");
    }
 else {
      boolean subnormal=(d < Double.MIN_NORMAL);
      long signifBits=(Double.doubleToLongBits(d) & DoubleConsts.SIGNIF_BIT_MASK) | 0x1000000000000000L;
      answer.append(subnormal ? ""String_Node_Str"" : ""String_Node_Str"");
      String signif=Long.toHexString(signifBits).substring(3,16);
      answer.append(signif.equals(""String_Node_Str"") ? ""String_Node_Str"" : signif.replaceFirst(""String_Node_Str"",""String_Node_Str""));
      answer.append('p');
      answer.append(subnormal ? Double.MIN_EXPONENT : Math.getExponent(d));
    }
    return answer.toString();
  }
}","/** 
 * Returns a hexadecimal string representation of the  {@code double} argument. All characters mentioned beloware ASCII characters. <ul> <li>If the argument is NaN, the result is the string "" {@code NaN}"". <li>Otherwise, the result is a string that represents the sign and magnitude of the argument. If the sign is negative, the first character of the result is '  {@code -}' (  {@code '\u005Cu002D'}); if the sign is positive, no sign character appears in the result. As for the magnitude <i>m</i>: <ul> <li>If <i>m</i> is infinity, it is represented by the string  {@code ""Infinity""}; thus, positive infinity produces the result   {@code ""Infinity""} and negative infinity producesthe result  {@code ""-Infinity""}. <li>If <i>m</i> is zero, it is represented by the string  {@code ""0x0.0p0""}; thus, negative zero produces the result  {@code ""-0x0.0p0""} and positive zero produces the result{@code ""0x0.0p0""}. <li>If <i>m</i> is a   {@code double} value with anormalized representation, substrings are used to represent the significand and exponent fields.  The significand is represented by the characters  {@code ""0x1.""}followed by a lowercase hexadecimal representation of the rest of the significand as a fraction.  Trailing zeros in the hexadecimal representation are removed unless all the digits are zero, in which case a single zero is used. Next, the exponent is represented by   {@code ""p""} followedby a decimal string of the unbiased exponent as if produced by a call to  {@link Integer#toString(int) Integer.toString} on theexponent value. <li>If <i>m</i> is a  {@code double} value with a subnormalrepresentation, the significand is represented by the characters  {@code ""0x0.""} followed by ahexadecimal representation of the rest of the significand as a fraction.  Trailing zeros in the hexadecimal representation are removed. Next, the exponent is represented by {@code ""p-1022""}.  Note that there must be at least one nonzero digit in a subnormal significand. </ul> </ul> <table class=""striped""> <caption>Examples</caption> <thead> <tr><th scope=""col"">Floating-point Value</th><th scope=""col"">Hexadecimal String</th> </thead> <tbody style=""text-align:right""> <tr><th scope=""row"">  {@code 1.0}</th> <td>  {@code 0x1.0p0}</td> <tr><th scope=""row"">  {@code -1.0}</th>        <td>  {@code -0x1.0p0}</td> <tr><th scope=""row"">  {@code 2.0}</th> <td>  {@code 0x1.0p1}</td> <tr><th scope=""row"">  {@code 3.0}</th> <td>  {@code 0x1.8p1}</td> <tr><th scope=""row"">  {@code 0.5}</th> <td>  {@code 0x1.0p-1}</td> <tr><th scope=""row"">  {@code 0.25}</th>        <td>  {@code 0x1.0p-2}</td> <tr><th scope=""row"">  {@code Double.MAX_VALUE}</th> <td>  {@code 0x1.fffffffffffffp1023}</td> <tr><th scope=""row"">  {@code Minimum Normal Value}</th> <td>  {@code 0x1.0p-1022}</td> <tr><th scope=""row"">  {@code Maximum Subnormal Value}</th> <td>  {@code 0x0.fffffffffffffp-1022}</td> <tr><th scope=""row"">  {@code Double.MIN_VALUE}</th> <td>  {@code 0x0.0000000000001p-1022}</td> </tbody> </table>
 * @param d   the {@code double} to be converted.
 * @return a hex string representation of the argument.
 * @since 1.5
 * @author Joseph D. Darcy
 */
public static String toHexString(double d){
  if (!isFinite(d))   return Double.toString(d);
 else {
    StringBuilder answer=new StringBuilder(24);
    if (Math.copySign(1.0,d) == -1.0)     answer.append(""String_Node_Str"");
    answer.append(""String_Node_Str"");
    d=Math.abs(d);
    if (d == 0.0) {
      answer.append(""String_Node_Str"");
    }
 else {
      boolean subnormal=(d < Double.MIN_NORMAL);
      long signifBits=(Double.doubleToLongBits(d) & DoubleConsts.SIGNIF_BIT_MASK) | 0x1000000000000000L;
      answer.append(subnormal ? ""String_Node_Str"" : ""String_Node_Str"");
      String signif=Long.toHexString(signifBits).substring(3,16);
      answer.append(signif.equals(""String_Node_Str"") ? ""String_Node_Str"" : signif.replaceFirst(""String_Node_Str"",""String_Node_Str""));
      answer.append('p');
      answer.append(subnormal ? Double.MIN_EXPONENT : Math.getExponent(d));
    }
    return answer.toString();
  }
}"
76791,"/** 
 * Returns a hexadecimal string representation of the  {@code float} argument. All characters mentioned below areASCII characters. <ul> <li>If the argument is NaN, the result is the string "" {@code NaN}"". <li>Otherwise, the result is a string that represents the sign and magnitude (absolute value) of the argument. If the sign is negative, the first character of the result is '  {@code -}' (  {@code '\u005Cu002D'}); if the sign is positive, no sign character appears in the result. As for the magnitude <i>m</i>: <ul> <li>If <i>m</i> is infinity, it is represented by the string  {@code ""Infinity""}; thus, positive infinity produces the result   {@code ""Infinity""} and negative infinity producesthe result  {@code ""-Infinity""}. <li>If <i>m</i> is zero, it is represented by the string  {@code ""0x0.0p0""}; thus, negative zero produces the result  {@code ""-0x0.0p0""} and positive zero produces the result{@code ""0x0.0p0""}. <li>If <i>m</i> is a   {@code float} value with anormalized representation, substrings are used to represent the significand and exponent fields.  The significand is represented by the characters  {@code ""0x1.""}followed by a lowercase hexadecimal representation of the rest of the significand as a fraction.  Trailing zeros in the hexadecimal representation are removed unless all the digits are zero, in which case a single zero is used. Next, the exponent is represented by   {@code ""p""} followedby a decimal string of the unbiased exponent as if produced by a call to  {@link Integer#toString(int) Integer.toString} on theexponent value. <li>If <i>m</i> is a  {@code float} value with a subnormalrepresentation, the significand is represented by the characters  {@code ""0x0.""} followed by ahexadecimal representation of the rest of the significand as a fraction.  Trailing zeros in the hexadecimal representation are removed. Next, the exponent is represented by {@code ""p-126""}.  Note that there must be at least one nonzero digit in a subnormal significand. </ul> </ul> <table class=""plain""> <caption>Examples</caption> <thead> <tr><th>Floating-point Value</th><th>Hexadecimal String</th> </thead> <tbody> <tr><td>  {@code 1.0}</td> <td>  {@code 0x1.0p0}</td> <tr><td>  {@code -1.0}</td>        <td>  {@code -0x1.0p0}</td> <tr><td>  {@code 2.0}</td> <td>  {@code 0x1.0p1}</td> <tr><td>  {@code 3.0}</td> <td>  {@code 0x1.8p1}</td> <tr><td>  {@code 0.5}</td> <td>  {@code 0x1.0p-1}</td> <tr><td>  {@code 0.25}</td>        <td>  {@code 0x1.0p-2}</td> <tr><td>  {@code Float.MAX_VALUE}</td> <td>  {@code 0x1.fffffep127}</td> <tr><td>  {@code Minimum Normal Value}</td> <td>  {@code 0x1.0p-126}</td> <tr><td>  {@code Maximum Subnormal Value}</td> <td>  {@code 0x0.fffffep-126}</td> <tr><td>  {@code Float.MIN_VALUE}</td> <td>  {@code 0x0.000002p-126}</td> </tbody> </table>
 * @param f   the {@code float} to be converted.
 * @return a hex string representation of the argument.
 * @since 1.5
 * @author Joseph D. Darcy
 */
public static String toHexString(float f){
  if (Math.abs(f) < Float.MIN_NORMAL && f != 0.0f) {
    String s=Double.toHexString(Math.scalb((double)f,Double.MIN_EXPONENT - Float.MIN_EXPONENT));
    return s.replaceFirst(""String_Node_Str"",""String_Node_Str"");
  }
 else   return Double.toHexString(f);
}","/** 
 * Returns a hexadecimal string representation of the  {@code float} argument. All characters mentioned below areASCII characters. <ul> <li>If the argument is NaN, the result is the string "" {@code NaN}"". <li>Otherwise, the result is a string that represents the sign and magnitude (absolute value) of the argument. If the sign is negative, the first character of the result is '  {@code -}' (  {@code '\u005Cu002D'}); if the sign is positive, no sign character appears in the result. As for the magnitude <i>m</i>: <ul> <li>If <i>m</i> is infinity, it is represented by the string  {@code ""Infinity""}; thus, positive infinity produces the result   {@code ""Infinity""} and negative infinity producesthe result  {@code ""-Infinity""}. <li>If <i>m</i> is zero, it is represented by the string  {@code ""0x0.0p0""}; thus, negative zero produces the result  {@code ""-0x0.0p0""} and positive zero produces the result{@code ""0x0.0p0""}. <li>If <i>m</i> is a   {@code float} value with anormalized representation, substrings are used to represent the significand and exponent fields.  The significand is represented by the characters  {@code ""0x1.""}followed by a lowercase hexadecimal representation of the rest of the significand as a fraction.  Trailing zeros in the hexadecimal representation are removed unless all the digits are zero, in which case a single zero is used. Next, the exponent is represented by   {@code ""p""} followedby a decimal string of the unbiased exponent as if produced by a call to  {@link Integer#toString(int) Integer.toString} on theexponent value. <li>If <i>m</i> is a  {@code float} value with a subnormalrepresentation, the significand is represented by the characters  {@code ""0x0.""} followed by ahexadecimal representation of the rest of the significand as a fraction.  Trailing zeros in the hexadecimal representation are removed. Next, the exponent is represented by {@code ""p-126""}.  Note that there must be at least one nonzero digit in a subnormal significand. </ul> </ul> <table class=""striped""> <caption>Examples</caption> <thead> <tr><th scope=""col"">Floating-point Value</th><th scope=""col"">Hexadecimal String</th> </thead> <tbody> <tr><th scope=""row"">  {@code 1.0}</th> <td>  {@code 0x1.0p0}</td> <tr><th scope=""row"">  {@code -1.0}</th>        <td>  {@code -0x1.0p0}</td> <tr><th scope=""row"">  {@code 2.0}</th> <td>  {@code 0x1.0p1}</td> <tr><th scope=""row"">  {@code 3.0}</th> <td>  {@code 0x1.8p1}</td> <tr><th scope=""row"">  {@code 0.5}</th> <td>  {@code 0x1.0p-1}</td> <tr><th scope=""row"">  {@code 0.25}</th>        <td>  {@code 0x1.0p-2}</td> <tr><th scope=""row"">  {@code Float.MAX_VALUE}</th> <td>  {@code 0x1.fffffep127}</td> <tr><th scope=""row"">  {@code Minimum Normal Value}</th> <td>  {@code 0x1.0p-126}</td> <tr><th scope=""row"">  {@code Maximum Subnormal Value}</th> <td>  {@code 0x0.fffffep-126}</td> <tr><th scope=""row"">  {@code Float.MIN_VALUE}</th> <td>  {@code 0x0.000002p-126}</td> </tbody> </table>
 * @param f   the {@code float} to be converted.
 * @return a hex string representation of the argument.
 * @since 1.5
 * @author Joseph D. Darcy
 */
public static String toHexString(float f){
  if (Math.abs(f) < Float.MIN_NORMAL && f != 0.0f) {
    String s=Double.toHexString(Math.scalb((double)f,Double.MIN_EXPONENT - Float.MIN_EXPONENT));
    return s.replaceFirst(""String_Node_Str"",""String_Node_Str"");
  }
 else   return Double.toHexString(f);
}"
76792,"/** 
 * Splits this string around matches of the given <a href=""../util/regex/Pattern.html#sum"">regular expression</a>. <p> This method works as if by invoking the two-argument   {@link #split(String,int) split} method with the given expression and a limitargument of zero.  Trailing empty strings are therefore not included in the resulting array. <p> The string  {@code ""boo:and:foo""}, for example, yields the following results with these expressions: <blockquote><table class=""plain""> <caption style=""display:none"">Split examples showing regex and result</caption> <thead> <tr> <th>Regex</th> <th>Result</th> </tr> </thead> <tbody> <tr><td style=""text-align:center"">:</td> <td>  {@code} ""boo"", ""and"", ""foo"" }}</td></tr> <tr><td style=""text-align:center"">o</td> <td> {@code} ""b"", """", "":and:f"" }}</td></tr> </tbody> </table></blockquote>
 * @param regex the delimiting regular expression
 * @return  the array of strings computed by splitting this stringaround matches of the given regular expression
 * @throws PatternSyntaxException if the regular expression's syntax is invalid
 * @see java.util.regex.Pattern
 * @since 1.4
 * @spec JSR-51
 */
public String[] split(String regex){
  return split(regex,0);
}","/** 
 * Splits this string around matches of the given <a href=""../util/regex/Pattern.html#sum"">regular expression</a>. <p> This method works as if by invoking the two-argument   {@link #split(String,int) split} method with the given expression and a limitargument of zero.  Trailing empty strings are therefore not included in the resulting array. <p> The string  {@code ""boo:and:foo""}, for example, yields the following results with these expressions: <blockquote><table class=""plain""> <caption style=""display:none"">Split examples showing regex and result</caption> <thead> <tr> <th scope=""col"">Regex</th> <th scope=""col"">Result</th> </tr> </thead> <tbody> <tr><th scope=""row"" style=""text-weight:normal"">:</th> <td>  {@code} ""boo"", ""and"", ""foo"" }}</td></tr> <tr><th scope=""row"" style=""text-weight:normal"">o</th> <td> {@code} ""b"", """", "":and:f"" }}</td></tr> </tbody> </table></blockquote>
 * @param regex the delimiting regular expression
 * @return  the array of strings computed by splitting this stringaround matches of the given regular expression
 * @throws PatternSyntaxException if the regular expression's syntax is invalid
 * @see java.util.regex.Pattern
 * @since 1.4
 * @spec JSR-51
 */
public String[] split(String regex){
  return split(regex,0);
}"
76793,"/** 
 * Determines the current system properties. <p> First, if there is a security manager, its <code>checkPropertiesAccess</code> method is called with no arguments. This may result in a security exception. <p> The current set of system properties for use by the  {@link #getProperty(String)} method is returned as a<code>Properties</code> object. If there is no current set of system properties, a set of system properties is first created and initialized. This set of system properties always includes values for the following keys: <table class=""striped""> <caption style=""display:none"">Shows property keys and associated values</caption> <thead> <tr><th scope=""col"">Key</th> <th scope=""col"">Description of Associated Value</th></tr> </thead> <tbody> <tr><th scope=""row""><code>java.version</code></th> <td>Java Runtime Environment version which may be interpreted as a  {@link Runtime.Version}</td></tr> <tr><th scope=""row""><code>java.vendor</code></th> <td>Java Runtime Environment vendor</td></tr> <tr><th scope=""row""><code>java.vendor.url</code></th> <td>Java vendor URL</td></tr> <tr><th scope=""row""><code>java.home</code></th> <td>Java installation directory</td></tr> <tr><th scope=""row""><code>java.vm.specification.version</code></th> <td>Java Virtual Machine specification version which may be interpreted as a   {@link Runtime.Version}</td></tr> <tr><th scope=""row""><code>java.vm.specification.vendor</code></th> <td>Java Virtual Machine specification vendor</td></tr> <tr><th scope=""row""><code>java.vm.specification.name</code></th> <td>Java Virtual Machine specification name</td></tr> <tr><th scope=""row""><code>java.vm.version</code></th> <td>Java Virtual Machine implementation version which may be interpreted as a   {@link Runtime.Version}</td></tr> <tr><th scope=""row""><code>java.vm.vendor</code></th> <td>Java Virtual Machine implementation vendor</td></tr> <tr><th scope=""row""><code>java.vm.name</code></th> <td>Java Virtual Machine implementation name</td></tr> <tr><th scope=""row""><code>java.specification.version</code></th> <td>Java Runtime Environment specification version which may be interpreted as a   {@link Runtime.Version}</td></tr> <tr><th scope=""row""><code>java.specification.vendor</code></th> <td>Java Runtime Environment specification  vendor</td></tr> <tr><th scope=""row""><code>java.specification.name</code></th> <td>Java Runtime Environment specification  name</td></tr> <tr><th scope=""row""><code>java.class.version</code></th> <td>Java class format version number</td></tr> <tr><th scope=""row""><code>java.class.path</code></th> <td>Java class path</td></tr> <tr><th scope=""row""><code>java.library.path</code></th> <td>List of paths to search when loading libraries</td></tr> <tr><th scope=""row""><code>java.io.tmpdir</code></th> <td>Default temp file path</td></tr> <tr><th scope=""row""><code>java.compiler</code></th> <td>Name of JIT compiler to use</td></tr> <tr><th scope=""row""><code>os.name</code></th> <td>Operating system name</td></tr> <tr><th scope=""row""><code>os.arch</code></th> <td>Operating system architecture</td></tr> <tr><th scope=""row""><code>os.version</code></th> <td>Operating system version</td></tr> <tr><th scope=""row""><code>file.separator</code></th> <td>File separator (""/"" on UNIX)</td></tr> <tr><th scope=""row""><code>path.separator</code></th> <td>Path separator ("":"" on UNIX)</td></tr> <tr><th scope=""row""><code>line.separator</code></th> <td>Line separator (""\n"" on UNIX)</td></tr> <tr><th scope=""row""><code>user.name</code></th> <td>User's account name</td></tr> <tr><th scope=""row""><code>user.home</code></th> <td>User's home directory</td></tr> <tr><th scope=""row""><code>user.dir</code></th> <td>User's current working directory</td></tr> </tbody> </table> <p> Multiple paths in a system property value are separated by the path separator character of the platform. <p> Note that even if the security manager does not permit the <code>getProperties</code> operation, it may choose to permit the  {@link #getProperty(String)} operation.
 * @implNote In addition to the standard system properties, the systemproperties may include the following keys: <table class=""striped""> <caption style=""display:none"">Shows property keys and associated values</caption> <thead> <tr><th scope=""col"">Key</th> <th scope=""col"">Description of Associated Value</th></tr> </thead> <tbody> <tr><th scope=""row""> {@code jdk.module.path}</th> <td>The application module path</td></tr> <tr><th scope=""row"">  {@code jdk.module.upgrade.path}</th> <td>The upgrade module path</td></tr> <tr><th scope=""row"">  {@code jdk.module.main}</th> <td>The module name of the initial/main module</td></tr> <tr><th scope=""row"">  {@code jdk.module.main.class}</th> <td>The main class name of the initial module</td></tr> </tbody> </table>
 * @return     the system properties
 * @exception SecurityException  if a security manager exists and its<code>checkPropertiesAccess</code> method doesn't allow access to the system properties.
 * @see #setProperties
 * @see java.lang.SecurityException
 * @see java.lang.SecurityManager#checkPropertiesAccess()
 * @see java.util.Properties
 */
public static Properties getProperties(){
  SecurityManager sm=getSecurityManager();
  if (sm != null) {
    sm.checkPropertiesAccess();
  }
  return props;
}","/** 
 * Determines the current system properties. <p> First, if there is a security manager, its <code>checkPropertiesAccess</code> method is called with no arguments. This may result in a security exception. <p> The current set of system properties for use by the  {@link #getProperty(String)} method is returned as a<code>Properties</code> object. If there is no current set of system properties, a set of system properties is first created and initialized. This set of system properties always includes values for the following keys: <table class=""striped"" style=""text-align:left""> <caption style=""display:none"">Shows property keys and associated values</caption> <thead> <tr><th scope=""col"">Key</th> <th scope=""col"">Description of Associated Value</th></tr> </thead> <tbody> <tr><th scope=""row""><code>java.version</code></th> <td>Java Runtime Environment version which may be interpreted as a  {@link Runtime.Version}</td></tr> <tr><th scope=""row""><code>java.vendor</code></th> <td>Java Runtime Environment vendor</td></tr> <tr><th scope=""row""><code>java.vendor.url</code></th> <td>Java vendor URL</td></tr> <tr><th scope=""row""><code>java.home</code></th> <td>Java installation directory</td></tr> <tr><th scope=""row""><code>java.vm.specification.version</code></th> <td>Java Virtual Machine specification version which may be interpreted as a   {@link Runtime.Version}</td></tr> <tr><th scope=""row""><code>java.vm.specification.vendor</code></th> <td>Java Virtual Machine specification vendor</td></tr> <tr><th scope=""row""><code>java.vm.specification.name</code></th> <td>Java Virtual Machine specification name</td></tr> <tr><th scope=""row""><code>java.vm.version</code></th> <td>Java Virtual Machine implementation version which may be interpreted as a   {@link Runtime.Version}</td></tr> <tr><th scope=""row""><code>java.vm.vendor</code></th> <td>Java Virtual Machine implementation vendor</td></tr> <tr><th scope=""row""><code>java.vm.name</code></th> <td>Java Virtual Machine implementation name</td></tr> <tr><th scope=""row""><code>java.specification.version</code></th> <td>Java Runtime Environment specification version which may be interpreted as a   {@link Runtime.Version}</td></tr> <tr><th scope=""row""><code>java.specification.vendor</code></th> <td>Java Runtime Environment specification  vendor</td></tr> <tr><th scope=""row""><code>java.specification.name</code></th> <td>Java Runtime Environment specification  name</td></tr> <tr><th scope=""row""><code>java.class.version</code></th> <td>Java class format version number</td></tr> <tr><th scope=""row""><code>java.class.path</code></th> <td>Java class path</td></tr> <tr><th scope=""row""><code>java.library.path</code></th> <td>List of paths to search when loading libraries</td></tr> <tr><th scope=""row""><code>java.io.tmpdir</code></th> <td>Default temp file path</td></tr> <tr><th scope=""row""><code>java.compiler</code></th> <td>Name of JIT compiler to use</td></tr> <tr><th scope=""row""><code>os.name</code></th> <td>Operating system name</td></tr> <tr><th scope=""row""><code>os.arch</code></th> <td>Operating system architecture</td></tr> <tr><th scope=""row""><code>os.version</code></th> <td>Operating system version</td></tr> <tr><th scope=""row""><code>file.separator</code></th> <td>File separator (""/"" on UNIX)</td></tr> <tr><th scope=""row""><code>path.separator</code></th> <td>Path separator ("":"" on UNIX)</td></tr> <tr><th scope=""row""><code>line.separator</code></th> <td>Line separator (""\n"" on UNIX)</td></tr> <tr><th scope=""row""><code>user.name</code></th> <td>User's account name</td></tr> <tr><th scope=""row""><code>user.home</code></th> <td>User's home directory</td></tr> <tr><th scope=""row""><code>user.dir</code></th> <td>User's current working directory</td></tr> </tbody> </table> <p> Multiple paths in a system property value are separated by the path separator character of the platform. <p> Note that even if the security manager does not permit the <code>getProperties</code> operation, it may choose to permit the  {@link #getProperty(String)} operation.
 * @implNote In addition to the standard system properties, the systemproperties may include the following keys: <table class=""striped""> <caption style=""display:none"">Shows property keys and associated values</caption> <thead> <tr><th scope=""col"">Key</th> <th scope=""col"">Description of Associated Value</th></tr> </thead> <tbody> <tr><th scope=""row""> {@code jdk.module.path}</th> <td>The application module path</td></tr> <tr><th scope=""row"">  {@code jdk.module.upgrade.path}</th> <td>The upgrade module path</td></tr> <tr><th scope=""row"">  {@code jdk.module.main}</th> <td>The module name of the initial/main module</td></tr> <tr><th scope=""row"">  {@code jdk.module.main.class}</th> <td>The main class name of the initial module</td></tr> </tbody> </table>
 * @return     the system properties
 * @exception SecurityException  if a security manager exists and its<code>checkPropertiesAccess</code> method doesn't allow access to the system properties.
 * @see #setProperties
 * @see java.lang.SecurityException
 * @see java.lang.SecurityManager#checkPropertiesAccess()
 * @see java.util.Properties
 */
public static Properties getProperties(){
  SecurityManager sm=getSecurityManager();
  if (sm != null) {
    sm.checkPropertiesAccess();
  }
  return props;
}"
76794,"/** 
 * Indicates that the caller is momentarily unable to progress, until the occurrence of one or more actions on the part of other activities. By invoking this method within each iteration of a spin-wait loop construct, the calling thread indicates to the runtime that it is busy-waiting. The runtime may take action to improve the performance of invoking spin-wait loop constructions. <p>
 * @apiNote As an example consider a method in a class that spins in a loop until some flag is set outside of that method. A call to the  {@code onSpinWait}method should be placed inside the spin loop. <pre>  {@code}class EventHandler  volatile boolean eventNotificationNotReceived; void waitForEventAndHandleIt() { while ( eventNotificationNotReceived ) { java.lang.Thread.onSpinWait(); } readAndProcessEvent(); } void readAndProcessEvent() { // Read event from some source and process it . . . } } }</pre> <p> The code above would remain correct even if the   {@code onSpinWait}method was not called at all. However on some architectures the Java Virtual Machine may issue the processor instructions to address such code patterns in a more beneficial way. <p>
 * @since 9
 */
@HotSpotIntrinsicCandidate public static void onSpinWait(){
}","/** 
 * Indicates that the caller is momentarily unable to progress, until the occurrence of one or more actions on the part of other activities. By invoking this method within each iteration of a spin-wait loop construct, the calling thread indicates to the runtime that it is busy-waiting. The runtime may take action to improve the performance of invoking spin-wait loop constructions.
 * @apiNote As an example consider a method in a class that spins in a loop until some flag is set outside of that method. A call to the  {@code onSpinWait}method should be placed inside the spin loop. <pre>  {@code}class EventHandler  volatile boolean eventNotificationNotReceived; void waitForEventAndHandleIt() { while ( eventNotificationNotReceived ) { java.lang.Thread.onSpinWait(); } readAndProcessEvent(); } void readAndProcessEvent() { // Read event from some source and process it . . . } } }</pre> <p> The code above would remain correct even if the   {@code onSpinWait}method was not called at all. However on some architectures the Java Virtual Machine may issue the processor instructions to address such code patterns in a more beneficial way.
 * @since 9
 */
@HotSpotIntrinsicCandidate public static void onSpinWait(){
}"
76795,"/** 
 * Create and return the default parameter map for this  {@code ExecutionControlProvider}. The map can optionally be modified; Modified or unmodified it can be passed to  {@link #generate(jdk.jshell.spi.ExecutionEnv,java.util.Map) }. <table> <caption>Parameters</caption> <tr> <th>Parameter</th> <th>Description</th> <th>Constant Field</th> </tr> <tr> <td>remoteAgent</td> <td>the remote agent to launch</td> <td>  {@link #PARAM_REMOTE_AGENT}</td> </tr> <tr> <td>timeout</td> <td>milliseconds before connect timeout</td> <td>  {@link #PARAM_TIMEOUT}</td> </tr> <tr> <td>launch</td> <td>""true"" for JDI controlled launch</td> <td>  {@link #PARAM_LAUNCH}</td> </tr> <tr> <td>hostname</td> <td>connect to the named of the local host ("""" for discovered)</td> <td>  {@link #PARAM_HOST_NAME}</td> </tr> </table>
 * @return the default parameter map
 */
@Override public Map<String,String> defaultParameters(){
  Map<String,String> dp=new HashMap<>();
  dp.put(PARAM_REMOTE_AGENT,RemoteExecutionControl.class.getName());
  dp.put(PARAM_TIMEOUT,""String_Node_Str"" + DEFAULT_TIMEOUT);
  dp.put(PARAM_HOST_NAME,""String_Node_Str"");
  dp.put(PARAM_LAUNCH,""String_Node_Str"");
  return dp;
}","/** 
 * Create and return the default parameter map for this  {@code ExecutionControlProvider}. The map can optionally be modified; Modified or unmodified it can be passed to  {@link #generate(jdk.jshell.spi.ExecutionEnv,java.util.Map) }. <table class=""striped""> <caption>Parameters</caption> <thead> <tr> <th scope=""col"">Parameter</th> <th scope=""col"">Description</th> <th scope=""col"">Constant Field</th> </tr> </thead> <tbody> <tr> <th scope=""row"">remoteAgent</th> <td>the remote agent to launch</td> <td>  {@link #PARAM_REMOTE_AGENT}</td> </tr> <tr> <th scope=""row"">timeout</th> <td>milliseconds before connect timeout</td> <td>  {@link #PARAM_TIMEOUT}</td> </tr> <tr> <th scope=""row"">launch</th> <td>""true"" for JDI controlled launch</td> <td>  {@link #PARAM_LAUNCH}</td> </tr> <tr> <th scope=""row"">hostname</th> <td>connect to the named of the local host ("""" for discovered)</td> <td>  {@link #PARAM_HOST_NAME}</td> </tr> </tbody> </table>
 * @return the default parameter map
 */
@Override public Map<String,String> defaultParameters(){
  Map<String,String> dp=new HashMap<>();
  dp.put(PARAM_REMOTE_AGENT,RemoteExecutionControl.class.getName());
  dp.put(PARAM_TIMEOUT,""String_Node_Str"" + DEFAULT_TIMEOUT);
  dp.put(PARAM_HOST_NAME,""String_Node_Str"");
  dp.put(PARAM_LAUNCH,""String_Node_Str"");
  return dp;
}"
76796,"/** 
 * Updates the logging configuration. <p> For each configuration key in the   {@linkplain #getProperty(java.lang.String) existing configuration} andthe given input stream configuration, the given  {@code mapper} functionis invoked to map from the configuration key to a function, <i>f(o,n)</i>, that takes the old value and new value and returns the resulting value to be applied in the resulting configuration, as specified in the table below. <p>Let <i>k</i> be a configuration key in the old or new configuration, <i>o</i> be the old value (i.e. the value associated with <i>k</i> in the old configuration), <i>n</i> be the new value (i.e. the value associated with <i>k</i> in the new configuration), and <i>f</i> be the function returned by  {@code mapper.apply(}<i>k</i>  {@code )}: then <i>v = f(o,n)</i> is the resulting value. If <i>v</i> is not   {@code null}, then a property <i>k</i> with value <i>v</i> will be added to the resulting configuration. Otherwise, it will be omitted. <br>A   {@code null} value may be passed to function<i>f</i> to indicate that the corresponding configuration has no configuration key <i>k</i>. The function <i>f</i> may return  {@code null} to indicate thatthere will be no value associated with <i>k</i> in the resulting configuration. <p> If  {@code mapper} is {@code null}, then <i>v</i> will be set to <i>n</i>. <p> LogManager   {@linkplain #getProperty(java.lang.String) properties} areupdated with the resulting value in the resulting configuration. <p> The registered  {@linkplain #addConfigurationListener configurationlisteners} will be invoked after the configuration is successfully updated.<br><br> <table summary=""Updating configuration properties""> <tr> <th>Property</th> <th>Resulting Behavior</th> </tr> <tr> <td valign=""top""> {@code <logger>.level}</td> <td> <ul> <li>If the resulting configuration defines a level for a logger and if the resulting level is different than the level specified in the the old configuration, or not specified in the old configuration, then if the logger exists or if children for that logger exist, the level for that logger will be updated, and the change propagated to any existing logger children. This may cause the logger to be created, if necessary. </li> <li>If the old configuration defined a level for a logger, and the resulting configuration doesn't, then this change will not be propagated to existing loggers, if any. To completely replace a configuration - the caller should therefore call   {@link #reset() reset} to empty the current configuration,before calling  {@code updateConfiguration}. </li> </ul> </td> <tr> <td valign=""top"">  {@code <logger>.useParentHandlers}</td> <td> <ul> <li>If either the resulting or the old value for the useParentHandlers property is not null, then if the logger exists or if children for that logger exist, that logger will be updated to the resulting value. The value of the useParentHandlers property is the value specified in the configuration; if not specified, the default is true. </li> </ul> </td> </tr> <tr> <td valign=""top"">  {@code <logger>.handlers}</td> <td> <ul> <li>If the resulting configuration defines a list of handlers for a logger, and if the resulting list is different than the list specified in the old configuration for that logger (that could be empty), then if the logger exists or its children exist, the handlers associated with that logger are closed and removed and the new handlers will be created per the resulting configuration and added to that logger, creating that logger if necessary. </li> <li>If the old configuration defined some handlers for a logger, and the resulting configuration doesn't, if that logger exists, its handlers will be removed and closed. </li> <li>Changing the list of handlers on an existing logger will cause all its previous handlers to be removed and closed, regardless of whether they had been created from the configuration or programmatically. The old handlers will be replaced by new handlers, if any. </li> </ul> </td> </tr> <tr> <td valign=""top"">  {@code <handler-name>.*}</td> <td> <ul> <li>Properties configured/changed on handler classes will only affect newly created handlers. If a node is configured with the same list of handlers in the old and the resulting configuration, then these handlers will remain unchanged. </li> </ul> </td> </tr> <tr> <td valign=""top"">  {@code config} and any other property</td><td> <ul> <li>The resulting value for these property will be stored in the LogManager properties, but  {@code updateConfiguration} will not parseor process their values. </li> </ul> </td> </tr> </table> <p> <em>Example mapper functions:</em> <br><br> <ul> <li>Replace all logging properties with the new configuration: <br><br> {@code     (k) -> ((o, n) -> n)}: <br><br>this is equivalent to passing a null   {@code mapper} parameter.</li> <li>Merge the new configuration and old configuration and use the new value if <i>k</i> exists in the new configuration: <br><br> {@code     (k) -> ((o, n) -> n == null ? o : n)}: <br><br>as if merging two collections as follows:  {@code result.putAll(oldc); result.putAll(newc)}.<br></li> <li>Merge the new configuration and old configuration and use the old value if <i>k</i> exists in the old configuration: <br><br>  {@code     (k) -> ((o, n) -> o == null ? n : o)}: <br><br>as if merging two collections as follows:  {@code result.putAll(newc); result.putAll(oldc)}.<br></li> <li>Replace all properties with the new configuration except the handler property to configure Logger's handler that is not root logger: <br> <pre>  {@code (k) -> k.endsWith("".handlers"")}{@code     ? ((o, n) -> (o == null ? n : o))}{@code     : ((o, n) -> n)}</pre> </li> </ul> <p> To completely reinitialize a configuration, an application can first call  {@link #reset() reset} to fully remove the old configuration, followed by{@code updateConfiguration} to initialize the new configuration.
 * @param ins    a stream to read properties from
 * @param mapper a functional interface that takes a configurationkey <i>k</i> and returns a function <i>f(o,n)</i> whose returned value will be applied to the resulting configuration. The function <i>f</i> may return  {@code null} to indicate that the property<i>k</i> will not be added to the resulting configuration. <br> If  {@code mapper} is {@code null} then {@code (k) -> ((o, n) -> n)} isassumed. <br> For each <i>k</i>, the mapped function <i>f</i> will be invoked with the value associated with <i>k</i> in the old configuration (i.e <i>o</i>) and the value associated with <i>k</i> in the new configuration (i.e. <i>n</i>). <br>A  {@code null} value for <i>o</i> or <i>n</i> indicates that novalue was present for <i>k</i> in the corresponding configuration.
 * @throws SecurityException if a security manager exists and ifthe caller does not have LoggingPermission(""control""), or does not have the permissions required to set up the configuration (e.g. open files specified for FileHandlers)
 * @throws NullPointerException if {@code ins} is null or if{@code mapper} returns a null function when invoked.
 * @throws IOException if there are problems reading from the stream,or the given stream is not in the {@linkplain java.util.Properties properties file} format.
 * @since 9
 */
public void updateConfiguration(InputStream ins,Function<String,BiFunction<String,String,String>> mapper) throws IOException {
  checkPermission();
  ensureLogManagerInitialized();
  drainLoggerRefQueueBounded();
  final Properties previous;
  final Set<String> updatePropertyNames;
  List<LoggerContext> cxs=Collections.emptyList();
  final VisitedLoggers visited=new VisitedLoggers();
  final Properties next=new Properties();
  try {
    next.load(ins);
  }
 catch (  IllegalArgumentException x) {
    throw new IOException(x.getMessage(),x);
  }
  if (globalHandlersState == STATE_SHUTDOWN)   return;
  configurationLock.lock();
  try {
    if (globalHandlersState == STATE_SHUTDOWN)     return;
    previous=props;
    updatePropertyNames=Stream.concat(previous.stringPropertyNames().stream(),next.stringPropertyNames().stream()).collect(Collectors.toCollection(TreeSet::new));
    if (mapper != null) {
      updatePropertyNames.stream().forEachOrdered(k -> ConfigProperty.merge(k,previous,next,Objects.requireNonNull(mapper.apply(k))));
    }
    props=next;
    final Stream<String> allKeys=updatePropertyNames.stream().filter(ConfigProperty::matches).filter(k -> ConfigProperty.needsUpdating(k,previous,next));
    final Map<String,TreeSet<String>> loggerConfigs=allKeys.collect(Collectors.groupingBy(ConfigProperty::getLoggerName,TreeMap::new,Collectors.toCollection(TreeSet::new)));
    if (!loggerConfigs.isEmpty()) {
      cxs=contexts();
    }
    final List<Logger> loggers=cxs.isEmpty() ? Collections.emptyList() : new ArrayList<>(cxs.size());
    for (    Map.Entry<String,TreeSet<String>> e : loggerConfigs.entrySet()) {
      final String name=e.getKey();
      final Set<String> properties=e.getValue();
      loggers.clear();
      for (      LoggerContext cx : cxs) {
        Logger l=cx.findLogger(name);
        if (l != null && !visited.test(l)) {
          loggers.add(l);
        }
      }
      if (loggers.isEmpty())       continue;
      for (      String pk : properties) {
        ConfigProperty cp=ConfigProperty.find(pk).get();
        String p=previous.getProperty(pk,null);
        String n=next.getProperty(pk,null);
        ModType mod=ModType.of(p,n);
        if (mod == ModType.SAME)         continue;
switch (cp) {
case LEVEL:
          if (mod == ModType.REMOVED)           continue;
        Level level=Level.findLevel(trim(n));
      if (level != null) {
        if (name.isEmpty()) {
          rootLogger.setLevel(level);
        }
        for (        Logger l : loggers) {
          if (!name.isEmpty() || l != rootLogger) {
            l.setLevel(level);
          }
        }
      }
    break;
case USEPARENT:
  if (!name.isEmpty()) {
    boolean useParent=getBooleanProperty(pk,true);
    if (n != null || p != null) {
      for (      Logger l : loggers) {
        l.setUseParentHandlers(useParent);
      }
    }
  }
break;
case HANDLERS:
List<Handler> hdls=null;
if (name.isEmpty()) {
globalHandlersState=STATE_READING_CONFIG;
try {
closeHandlers(rootLogger);
globalHandlersState=STATE_UNINITIALIZED;
}
 catch (Throwable t) {
globalHandlersState=STATE_INITIALIZED;
throw t;
}
}
for (Logger l : loggers) {
if (l == rootLogger) continue;
closeHandlers(l);
if (mod == ModType.REMOVED) {
closeOnResetLoggers.removeIf(c -> c.logger == l);
continue;
}
if (hdls == null) {
hdls=name.isEmpty() ? Arrays.asList(rootLogger.getHandlers()) : createLoggerHandlers(name,pk);
}
setLoggerHandlers(l,name,pk,hdls);
}
break;
default :
break;
}
}
}
}
  finally {
configurationLock.unlock();
visited.clear();
}
drainLoggerRefQueueBounded();
for (LoggerContext cx : cxs) {
for (Enumeration<String> names=cx.getLoggerNames(); names.hasMoreElements(); ) {
String name=names.nextElement();
if (name.isEmpty()) continue;
Logger l=cx.findLogger(name);
if (l != null && !visited.test(l)) {
cx.processParentHandlers(l,name,visited);
}
}
}
invokeConfigurationListeners();
}","/** 
 * Updates the logging configuration. <p> For each configuration key in the   {@linkplain #getProperty(java.lang.String) existing configuration} andthe given input stream configuration, the given  {@code mapper} functionis invoked to map from the configuration key to a function, <i>f(o,n)</i>, that takes the old value and new value and returns the resulting value to be applied in the resulting configuration, as specified in the table below. <p>Let <i>k</i> be a configuration key in the old or new configuration, <i>o</i> be the old value (i.e. the value associated with <i>k</i> in the old configuration), <i>n</i> be the new value (i.e. the value associated with <i>k</i> in the new configuration), and <i>f</i> be the function returned by  {@code mapper.apply(}<i>k</i>  {@code )}: then <i>v = f(o,n)</i> is the resulting value. If <i>v</i> is not   {@code null}, then a property <i>k</i> with value <i>v</i> will be added to the resulting configuration. Otherwise, it will be omitted. <br>A   {@code null} value may be passed to function<i>f</i> to indicate that the corresponding configuration has no configuration key <i>k</i>. The function <i>f</i> may return  {@code null} to indicate thatthere will be no value associated with <i>k</i> in the resulting configuration. <p> If  {@code mapper} is {@code null}, then <i>v</i> will be set to <i>n</i>. <p> LogManager   {@linkplain #getProperty(java.lang.String) properties} areupdated with the resulting value in the resulting configuration. <p> The registered  {@linkplain #addConfigurationListener configurationlisteners} will be invoked after the configuration is successfully updated.<br><br> <table><caption style=""display:none"">Updating configuration properties</caption> <tr> <th>Property</th> <th>Resulting Behavior</th> </tr> <tr> <td valign=""top""> {@code <logger>.level}</td> <td> <ul> <li>If the resulting configuration defines a level for a logger and if the resulting level is different than the level specified in the the old configuration, or not specified in the old configuration, then if the logger exists or if children for that logger exist, the level for that logger will be updated, and the change propagated to any existing logger children. This may cause the logger to be created, if necessary. </li> <li>If the old configuration defined a level for a logger, and the resulting configuration doesn't, then this change will not be propagated to existing loggers, if any. To completely replace a configuration - the caller should therefore call   {@link #reset() reset} to empty the current configuration,before calling  {@code updateConfiguration}. </li> </ul> </td> <tr> <td valign=""top"">  {@code <logger>.useParentHandlers}</td> <td> <ul> <li>If either the resulting or the old value for the useParentHandlers property is not null, then if the logger exists or if children for that logger exist, that logger will be updated to the resulting value. The value of the useParentHandlers property is the value specified in the configuration; if not specified, the default is true. </li> </ul> </td> </tr> <tr> <td valign=""top"">  {@code <logger>.handlers}</td> <td> <ul> <li>If the resulting configuration defines a list of handlers for a logger, and if the resulting list is different than the list specified in the old configuration for that logger (that could be empty), then if the logger exists or its children exist, the handlers associated with that logger are closed and removed and the new handlers will be created per the resulting configuration and added to that logger, creating that logger if necessary. </li> <li>If the old configuration defined some handlers for a logger, and the resulting configuration doesn't, if that logger exists, its handlers will be removed and closed. </li> <li>Changing the list of handlers on an existing logger will cause all its previous handlers to be removed and closed, regardless of whether they had been created from the configuration or programmatically. The old handlers will be replaced by new handlers, if any. </li> </ul> </td> </tr> <tr> <td valign=""top"">  {@code <handler-name>.*}</td> <td> <ul> <li>Properties configured/changed on handler classes will only affect newly created handlers. If a node is configured with the same list of handlers in the old and the resulting configuration, then these handlers will remain unchanged. </li> </ul> </td> </tr> <tr> <td valign=""top"">  {@code config} and any other property</td><td> <ul> <li>The resulting value for these property will be stored in the LogManager properties, but  {@code updateConfiguration} will not parseor process their values. </li> </ul> </td> </tr> </table> <p> <em>Example mapper functions:</em> <br><br> <ul> <li>Replace all logging properties with the new configuration: <br><br> {@code     (k) -> ((o, n) -> n)}: <br><br>this is equivalent to passing a null   {@code mapper} parameter.</li> <li>Merge the new configuration and old configuration and use the new value if <i>k</i> exists in the new configuration: <br><br> {@code     (k) -> ((o, n) -> n == null ? o : n)}: <br><br>as if merging two collections as follows:  {@code result.putAll(oldc); result.putAll(newc)}.<br></li> <li>Merge the new configuration and old configuration and use the old value if <i>k</i> exists in the old configuration: <br><br>  {@code     (k) -> ((o, n) -> o == null ? n : o)}: <br><br>as if merging two collections as follows:  {@code result.putAll(newc); result.putAll(oldc)}.<br></li> <li>Replace all properties with the new configuration except the handler property to configure Logger's handler that is not root logger: <br> <pre>  {@code (k) -> k.endsWith("".handlers"")}{@code     ? ((o, n) -> (o == null ? n : o))}{@code     : ((o, n) -> n)}</pre> </li> </ul> <p> To completely reinitialize a configuration, an application can first call  {@link #reset() reset} to fully remove the old configuration, followed by{@code updateConfiguration} to initialize the new configuration.
 * @param ins    a stream to read properties from
 * @param mapper a functional interface that takes a configurationkey <i>k</i> and returns a function <i>f(o,n)</i> whose returned value will be applied to the resulting configuration. The function <i>f</i> may return  {@code null} to indicate that the property<i>k</i> will not be added to the resulting configuration. <br> If  {@code mapper} is {@code null} then {@code (k) -> ((o, n) -> n)} isassumed. <br> For each <i>k</i>, the mapped function <i>f</i> will be invoked with the value associated with <i>k</i> in the old configuration (i.e <i>o</i>) and the value associated with <i>k</i> in the new configuration (i.e. <i>n</i>). <br>A  {@code null} value for <i>o</i> or <i>n</i> indicates that novalue was present for <i>k</i> in the corresponding configuration.
 * @throws SecurityException if a security manager exists and ifthe caller does not have LoggingPermission(""control""), or does not have the permissions required to set up the configuration (e.g. open files specified for FileHandlers)
 * @throws NullPointerException if {@code ins} is null or if{@code mapper} returns a null function when invoked.
 * @throws IOException if there are problems reading from the stream,or the given stream is not in the {@linkplain java.util.Properties properties file} format.
 * @since 9
 */
public void updateConfiguration(InputStream ins,Function<String,BiFunction<String,String,String>> mapper) throws IOException {
  checkPermission();
  ensureLogManagerInitialized();
  drainLoggerRefQueueBounded();
  final Properties previous;
  final Set<String> updatePropertyNames;
  List<LoggerContext> cxs=Collections.emptyList();
  final VisitedLoggers visited=new VisitedLoggers();
  final Properties next=new Properties();
  try {
    next.load(ins);
  }
 catch (  IllegalArgumentException x) {
    throw new IOException(x.getMessage(),x);
  }
  if (globalHandlersState == STATE_SHUTDOWN)   return;
  configurationLock.lock();
  try {
    if (globalHandlersState == STATE_SHUTDOWN)     return;
    previous=props;
    updatePropertyNames=Stream.concat(previous.stringPropertyNames().stream(),next.stringPropertyNames().stream()).collect(Collectors.toCollection(TreeSet::new));
    if (mapper != null) {
      updatePropertyNames.stream().forEachOrdered(k -> ConfigProperty.merge(k,previous,next,Objects.requireNonNull(mapper.apply(k))));
    }
    props=next;
    final Stream<String> allKeys=updatePropertyNames.stream().filter(ConfigProperty::matches).filter(k -> ConfigProperty.needsUpdating(k,previous,next));
    final Map<String,TreeSet<String>> loggerConfigs=allKeys.collect(Collectors.groupingBy(ConfigProperty::getLoggerName,TreeMap::new,Collectors.toCollection(TreeSet::new)));
    if (!loggerConfigs.isEmpty()) {
      cxs=contexts();
    }
    final List<Logger> loggers=cxs.isEmpty() ? Collections.emptyList() : new ArrayList<>(cxs.size());
    for (    Map.Entry<String,TreeSet<String>> e : loggerConfigs.entrySet()) {
      final String name=e.getKey();
      final Set<String> properties=e.getValue();
      loggers.clear();
      for (      LoggerContext cx : cxs) {
        Logger l=cx.findLogger(name);
        if (l != null && !visited.test(l)) {
          loggers.add(l);
        }
      }
      if (loggers.isEmpty())       continue;
      for (      String pk : properties) {
        ConfigProperty cp=ConfigProperty.find(pk).get();
        String p=previous.getProperty(pk,null);
        String n=next.getProperty(pk,null);
        ModType mod=ModType.of(p,n);
        if (mod == ModType.SAME)         continue;
switch (cp) {
case LEVEL:
          if (mod == ModType.REMOVED)           continue;
        Level level=Level.findLevel(trim(n));
      if (level != null) {
        if (name.isEmpty()) {
          rootLogger.setLevel(level);
        }
        for (        Logger l : loggers) {
          if (!name.isEmpty() || l != rootLogger) {
            l.setLevel(level);
          }
        }
      }
    break;
case USEPARENT:
  if (!name.isEmpty()) {
    boolean useParent=getBooleanProperty(pk,true);
    if (n != null || p != null) {
      for (      Logger l : loggers) {
        l.setUseParentHandlers(useParent);
      }
    }
  }
break;
case HANDLERS:
List<Handler> hdls=null;
if (name.isEmpty()) {
globalHandlersState=STATE_READING_CONFIG;
try {
closeHandlers(rootLogger);
globalHandlersState=STATE_UNINITIALIZED;
}
 catch (Throwable t) {
globalHandlersState=STATE_INITIALIZED;
throw t;
}
}
for (Logger l : loggers) {
if (l == rootLogger) continue;
closeHandlers(l);
if (mod == ModType.REMOVED) {
closeOnResetLoggers.removeIf(c -> c.logger == l);
continue;
}
if (hdls == null) {
hdls=name.isEmpty() ? Arrays.asList(rootLogger.getHandlers()) : createLoggerHandlers(name,pk);
}
setLoggerHandlers(l,name,pk,hdls);
}
break;
default :
break;
}
}
}
}
  finally {
configurationLock.unlock();
visited.clear();
}
drainLoggerRefQueueBounded();
for (LoggerContext cx : cxs) {
for (Enumeration<String> names=cx.getLoggerNames(); names.hasMoreElements(); ) {
String name=names.nextElement();
if (name.isEmpty()) continue;
Logger l=cx.findLogger(name);
if (l != null && !visited.test(l)) {
cx.processParentHandlers(l,name,visited);
}
}
}
invokeConfigurationListeners();
}"
76797,"/** 
 * Returns a   {@code ThreadInfo} object represented by thegiven  {@code CompositeData}. The given   {@code CompositeData} must contain the following attributesunless otherwise specified below: <blockquote> <table border=""1""> <caption style=""display:none"">The attributes and their types the given CompositeData contains</caption> <tr> <th style=""text-align:left"">Attribute Name</th> <th style=""text-align:left"">Type</th> </tr> <tr> <td>threadId</td> <td> {@code java.lang.Long}</td> </tr> <tr> <td>threadName</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td>threadState</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td>suspended</td> <td>  {@code java.lang.Boolean}</td> </tr> <tr> <td>inNative</td> <td>  {@code java.lang.Boolean}</td> </tr> <tr> <td>blockedCount</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>blockedTime</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>waitedCount</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>waitedTime</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>lockInfo</td> <td>  {@code javax.management.openmbean.CompositeData}- the mapped type for   {@link LockInfo} as specified in the{@link LockInfo#from} method.<p> If  {@code cd} does not contain this attribute,the  {@code LockInfo} object will be constructed fromthe value of the  {@code lockName} attribute. </td></tr> <tr> <td>lockName</td> <td> {@code java.lang.String}</td> </tr> <tr> <td>lockOwnerId</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>lockOwnerName</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td><a id=""StackTrace"">stackTrace</a></td> <td>  {@code javax.management.openmbean.CompositeData[]}<p> Each element is a   {@code CompositeData} representingStackTraceElement containing the following attributes: <blockquote> <table cellspacing=1 cellpadding=0> <caption style=""display:none"">The attributes and their types the given CompositeData contains</caption> <tr> <th style=""text-align:left"">Attribute Name</th> <th style=""text-align:left"">Type</th> </tr> <tr> <td>moduleName</td> <td> {@code java.lang.String}</td> </tr> <tr> <td>moduleVersion</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td>className</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td>methodName</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td>fileName</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td>lineNumber</td> <td>  {@code java.lang.Integer}</td> </tr> <tr> <td>nativeMethod</td> <td>  {@code java.lang.Boolean}</td> </tr> </table> </blockquote> </td> </tr> <tr> <td>lockedMonitors</td> <td>  {@code javax.management.openmbean.CompositeData[]}whose element type is the mapped type for  {@link MonitorInfo} as specified in the{@link MonitorInfo#from Monitor.from} method.<p> If  {@code cd} does not contain this attribute,this attribute will be set to an empty array. </td> </tr> <tr> <td>lockedSynchronizers</td> <td> {@code javax.management.openmbean.CompositeData[]}whose element type is the mapped type for  {@link LockInfo} as specified in the {@link LockInfo#from} method.<p> If  {@code cd} does not contain this attribute,this attribute will be set to an empty array. </td> </tr> <tr> <td>daemon</td> <td> {@code java.lang.Boolean}</td> </tr> <tr> <td>priority</td> <td>  {@code java.lang.Integer}</td> </tr> </table> </blockquote>
 * @param cd {@code CompositeData} representing a {@code ThreadInfo}
 * @throws IllegalArgumentException if {@code cd} does notrepresent a  {@code ThreadInfo} with the attributes describedabove.
 * @return a {@code ThreadInfo} object representedby  {@code cd} if {@code cd} is not {@code null};  {@code null} otherwise.
 * @revised 9
 * @spec JPMS
 */
public static ThreadInfo from(CompositeData cd){
  if (cd == null) {
    return null;
  }
  if (cd instanceof ThreadInfoCompositeData) {
    return ((ThreadInfoCompositeData)cd).getThreadInfo();
  }
 else {
    return new ThreadInfo(cd);
  }
}","/** 
 * Returns a   {@code ThreadInfo} object represented by thegiven  {@code CompositeData}. The given   {@code CompositeData} must contain the following attributesunless otherwise specified below: <blockquote> <table class=""plain""> <caption style=""display:none"">The attributes and their types the given CompositeData contains</caption> <tr> <th style=""text-align:left"">Attribute Name</th> <th style=""text-align:left"">Type</th> </tr> <tr> <td>threadId</td> <td> {@code java.lang.Long}</td> </tr> <tr> <td>threadName</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td>threadState</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td>suspended</td> <td>  {@code java.lang.Boolean}</td> </tr> <tr> <td>inNative</td> <td>  {@code java.lang.Boolean}</td> </tr> <tr> <td>blockedCount</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>blockedTime</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>waitedCount</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>waitedTime</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>lockInfo</td> <td>  {@code javax.management.openmbean.CompositeData}- the mapped type for   {@link LockInfo} as specified in the{@link LockInfo#from} method.<p> If  {@code cd} does not contain this attribute,the  {@code LockInfo} object will be constructed fromthe value of the  {@code lockName} attribute. </td></tr> <tr> <td>lockName</td> <td> {@code java.lang.String}</td> </tr> <tr> <td>lockOwnerId</td> <td>  {@code java.lang.Long}</td> </tr> <tr> <td>lockOwnerName</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td><a id=""StackTrace"">stackTrace</a></td> <td>  {@code javax.management.openmbean.CompositeData[]}<p> Each element is a   {@code CompositeData} representingStackTraceElement containing the following attributes: <blockquote> <table class=""borderless""> <caption style=""display:none"">The attributes and their types the given CompositeData contains</caption> <tr> <th style=""text-align:left"">Attribute Name</th> <th style=""text-align:left"">Type</th> </tr> <tr> <td>moduleName</td> <td> {@code java.lang.String}</td> </tr> <tr> <td>moduleVersion</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td>className</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td>methodName</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td>fileName</td> <td>  {@code java.lang.String}</td> </tr> <tr> <td>lineNumber</td> <td>  {@code java.lang.Integer}</td> </tr> <tr> <td>nativeMethod</td> <td>  {@code java.lang.Boolean}</td> </tr> </table> </blockquote> </td> </tr> <tr> <td>lockedMonitors</td> <td>  {@code javax.management.openmbean.CompositeData[]}whose element type is the mapped type for  {@link MonitorInfo} as specified in the{@link MonitorInfo#from Monitor.from} method.<p> If  {@code cd} does not contain this attribute,this attribute will be set to an empty array. </td> </tr> <tr> <td>lockedSynchronizers</td> <td> {@code javax.management.openmbean.CompositeData[]}whose element type is the mapped type for  {@link LockInfo} as specified in the {@link LockInfo#from} method.<p> If  {@code cd} does not contain this attribute,this attribute will be set to an empty array. </td> </tr> <tr> <td>daemon</td> <td> {@code java.lang.Boolean}</td> </tr> <tr> <td>priority</td> <td>  {@code java.lang.Integer}</td> </tr> </table> </blockquote>
 * @param cd {@code CompositeData} representing a {@code ThreadInfo}
 * @throws IllegalArgumentException if {@code cd} does notrepresent a  {@code ThreadInfo} with the attributes describedabove.
 * @return a {@code ThreadInfo} object representedby  {@code cd} if {@code cd} is not {@code null};  {@code null} otherwise.
 * @revised 9
 * @spec JPMS
 */
public static ThreadInfo from(CompositeData cd){
  if (cd == null) {
    return null;
  }
  if (cd instanceof ThreadInfoCompositeData) {
    return ((ThreadInfoCompositeData)cd).getThreadInfo();
  }
 else {
    return new ThreadInfo(cd);
  }
}"
76798,"/** 
 * <p>Returns the ModelMBean's descriptor which contains MBean wide policies.  This descriptor contains metadata about the MBean and default policies for persistence and caching.</p> <P id=""descriptor""> The fields in the descriptor are defined, but not limited to, the following.  Note that when the Type in this table is Number, a String that is the decimal representation of a Long can also be used.</P> <table border=""1"" cellpadding=""5""> <caption style=""display:none"">ModelMBean Fields</caption> <tr><th>Name</th><th>Type</th><th>Meaning</th></tr> <tr><td>name</td><td>String</td> <td>MBean name.</td></tr> <tr><td>descriptorType</td><td>String</td> <td>Must be ""mbean"".</td></tr> <tr><td>displayName</td><td>String</td> <td>Name of MBean to be used in displays.</td></tr> <tr><td>persistPolicy</td><td>String</td> <td>One of: OnUpdate|OnTimer|NoMoreOftenThan|OnUnregister|Always|Never. See the section ""MBean Descriptor Fields"" in the JMX specification document.</td></tr> <tr><td>persistLocation</td><td>String</td> <td>The fully qualified directory name where the MBean should be persisted (if appropriate).</td></tr> <tr><td>persistFile</td><td>String</td> <td>File name into which the MBean should be persisted.</td></tr> <tr><td>persistPeriod</td><td>Number</td> <td>Frequency of persist cycle in seconds, for OnTime and NoMoreOftenThan PersistPolicy</td></tr> <tr><td>currencyTimeLimit</td><td>Number</td> <td>How long cached value is valid: &lt;0 never, =0 always, &gt;0 seconds.</td></tr> <tr><td>log</td><td>String</td> <td>t: log all notifications, f: log no notifications.</td></tr> <tr><td>logfile</td><td>String</td> <td>Fully qualified filename to log events to.</td></tr> <tr><td>visibility</td><td>Number</td> <td>1-4 where 1: always visible 4: rarely visible.</td></tr> <tr><td>export</td><td>String</td> <td>Name to be used to export/expose this MBean so that it is findable by other JMX Agents.</td></tr> <tr><td>presentationString</td><td>String</td> <td>XML formatted string to allow presentation of data to be associated with the MBean.</td></tr> </table> <P> The default descriptor is: name=className,descriptorType=""mbean"", displayName=className, persistPolicy=""never"",log=""F"",visibility=""1"" If the descriptor does not contain all these fields, they will be added with these default values. <p><b>Note:</b> because of inconsistencies in previous versions of this specification, it is recommended not to use negative or zero values for <code>currencyTimeLimit</code>.  To indicate that a cached value is never valid, omit the <code>currencyTimeLimit</code> field.  To indicate that it is always valid, use a very large number for this field.</p>
 * @return the MBean descriptor.
 * @exception MBeanException Wraps a distributed communicationException.
 * @exception RuntimeOperationsException a {@link RuntimeException} occurred while getting the descriptor.
 * @see #setMBeanDescriptor
 */
public Descriptor getMBeanDescriptor() throws MBeanException, RuntimeOperationsException ;","/** 
 * <p>Returns the ModelMBean's descriptor which contains MBean wide policies.  This descriptor contains metadata about the MBean and default policies for persistence and caching.</p> <P id=""descriptor""> The fields in the descriptor are defined, but not limited to, the following.  Note that when the Type in this table is Number, a String that is the decimal representation of a Long can also be used.</P> <table class=""striped""> <caption style=""display:none"">ModelMBean Fields</caption> <tr><th>Name</th><th>Type</th><th>Meaning</th></tr> <tr><td>name</td><td>String</td> <td>MBean name.</td></tr> <tr><td>descriptorType</td><td>String</td> <td>Must be ""mbean"".</td></tr> <tr><td>displayName</td><td>String</td> <td>Name of MBean to be used in displays.</td></tr> <tr><td>persistPolicy</td><td>String</td> <td>One of: OnUpdate|OnTimer|NoMoreOftenThan|OnUnregister|Always|Never. See the section ""MBean Descriptor Fields"" in the JMX specification document.</td></tr> <tr><td>persistLocation</td><td>String</td> <td>The fully qualified directory name where the MBean should be persisted (if appropriate).</td></tr> <tr><td>persistFile</td><td>String</td> <td>File name into which the MBean should be persisted.</td></tr> <tr><td>persistPeriod</td><td>Number</td> <td>Frequency of persist cycle in seconds, for OnTime and NoMoreOftenThan PersistPolicy</td></tr> <tr><td>currencyTimeLimit</td><td>Number</td> <td>How long cached value is valid: &lt;0 never, =0 always, &gt;0 seconds.</td></tr> <tr><td>log</td><td>String</td> <td>t: log all notifications, f: log no notifications.</td></tr> <tr><td>logfile</td><td>String</td> <td>Fully qualified filename to log events to.</td></tr> <tr><td>visibility</td><td>Number</td> <td>1-4 where 1: always visible 4: rarely visible.</td></tr> <tr><td>export</td><td>String</td> <td>Name to be used to export/expose this MBean so that it is findable by other JMX Agents.</td></tr> <tr><td>presentationString</td><td>String</td> <td>XML formatted string to allow presentation of data to be associated with the MBean.</td></tr> </table> <P> The default descriptor is: name=className,descriptorType=""mbean"", displayName=className, persistPolicy=""never"",log=""F"",visibility=""1"" If the descriptor does not contain all these fields, they will be added with these default values. <p><b>Note:</b> because of inconsistencies in previous versions of this specification, it is recommended not to use negative or zero values for <code>currencyTimeLimit</code>.  To indicate that a cached value is never valid, omit the <code>currencyTimeLimit</code> field.  To indicate that it is always valid, use a very large number for this field.</p>
 * @return the MBean descriptor.
 * @exception MBeanException Wraps a distributed communicationException.
 * @exception RuntimeOperationsException a {@link RuntimeException} occurred while getting the descriptor.
 * @see #setMBeanDescriptor
 */
public Descriptor getMBeanDescriptor() throws MBeanException, RuntimeOperationsException ;"
76799,"@Override public void connect() throws IOException, InterruptedException {
  delegate.connect();
  HttpRequestImpl req=new HttpRequestImpl(""String_Node_Str"",client,address);
  Exchange<?> connectExchange=new Exchange<>(req,null);
  Response r=connectExchange.responseImpl(delegate);
  if (r.statusCode() != 200) {
    throw new IOException(""String_Node_Str"");
  }
  connected=true;
}","@Override public void connect() throws IOException, InterruptedException {
  delegate.connect();
  HttpRequestImpl req=new HttpRequestImpl(""String_Node_Str"",client,address);
  MultiExchange<Void,Void> mul=new MultiExchange<>(req,client,BodyHandler.<Void>discard(null));
  Exchange<Void> connectExchange=new Exchange<>(req,mul);
  Response r=connectExchange.responseImpl(delegate);
  if (r.statusCode() != 200) {
    throw new IOException(""String_Node_Str"");
  }
  connected=true;
}"
76800,"/** 
 * Sends a whole Text message with characters from the given   {@code CharSequence}. <p> This is a convenience method. For the general case, use   {@link #sendText(CharSequence,boolean)}. <p> Returns a   {@code CompletableFuture<WebSocket>} which completesnormally when the message has been sent or completes exceptionally if an error occurs. <p> The  {@code CharSequence} must not be modified until the returned{@code CompletableFuture} completes (either normally or exceptionally).<p> The returned  {@code CompletableFuture} can complete exceptionallywith: <ul> <li>  {@link IllegalArgumentException} -if  {@code message} is a malformed UTF-16 sequence<li>  {@link IllegalStateException} -if the  {@code WebSocket} is closed;or if a Close message has been sent; or if there is an outstanding send operation; or if a previous Binary message was sent with  {@code isLast == false}<li>   {@link IOException} -if an I/O error occurs during this operation; or if the  {@code WebSocket} has been closed due to an error;</ul>
 * @param message the message
 * @return a {@code CompletableFuture} with this {@code WebSocket}
 */
default CompletableFuture<WebSocket> sendText(CharSequence message){
  return sendText(message,true);
}","/** 
 * Sends a Text message with characters from the given   {@code CharSequence}. <p> Returns a   {@code CompletableFuture<WebSocket>} which completesnormally when the message has been sent or completes exceptionally if an error occurs. <p> The  {@code CharSequence} must not be modified until the returned{@code CompletableFuture} completes (either normally or exceptionally).<p> The returned  {@code CompletableFuture} can complete exceptionallywith: <ul> <li>  {@link IllegalArgumentException} -if  {@code message} is a malformed UTF-16 sequence<li>  {@link IllegalStateException} -if the  {@code WebSocket} is closed;or if a Close message has been sent; or if there is an outstanding send operation; or if a previous Binary message was sent with  {@code isLast == false}<li>   {@link IOException} -if an I/O error occurs during this operation; or if the  {@code WebSocket} has been closed due to an error;</ul>
 * @implNote This implementation does not accept partial UTF-16 sequences.In case such a sequence is passed, a returned  {@code CompletableFuture}completes exceptionally with   {@code IOException}.
 * @param message the message
 * @param isLast {@code true} if this is the last part of the message,{@code false} otherwise
 * @return a {@code CompletableFuture} with this {@code WebSocket}
 */
CompletableFuture<WebSocket> sendText(CharSequence message,boolean isLast);"
76801,"/** 
 * Receives a Close message. <p> A Close message consists of a status code and a reason for closing. The status code is an integer in the range   {@code 1000 <=code <= 65535}. The   {@code reason} is a short string that has anUTF-8 representation not longer than  {@code 123} bytes. For moredetails on Close message, status codes and reason see RFC 6455 sections <a href=""https://tools.ietf.org/html/rfc6455#section-5.5.1"">5.5.1. Close</a> and <a href=""https://tools.ietf.org/html/rfc6455#section-7.4"">7.4. Status Codes</a>. <p> After the returned  {@code CompletionStage} has completed(normally or exceptionally), the  {@code WebSocket} completes theclosing handshake by replying with an appropriate Close message. <p> This implementation replies with a Close message that has the same code this message has and an empty reason. <p>  {@code onClose} is the last invocation on the {@code Listener}. It is invoked at most once, but after   {@code onOpen}. If an exception is thrown from this method, it is ignored. <p> The   {@code WebSocket} will close at the earliest of completion ofthe returned  {@code CompletionStage} or sending a Close message. Inparticular, if a Close message has been  {@link WebSocket#sendClose() sent} before, then this invocation completes the closing handshakeand by the time this method is invoked, the  {@code WebSocket} willhave been closed.
 * @implSpec The default implementation of this method behaves as if:<pre> {@code return null;}</pre>
 * @param webSocket the WebSocket
 * @param statusCode the status code
 * @param reason the reason
 * @return a {@code CompletionStage} which completes when the {@code WebSocket} can be closed; or {@code null} if it can be closed immediately
 * @see #NORMAL_CLOSURE
 */
default CompletionStage<?> onClose(WebSocket webSocket,int statusCode,String reason){
  return null;
}","/** 
 * Receives a Close message. <p> A Close message consists of a status code and a reason for closing. The status code is an integer in the range   {@code 1000 <=code <= 65535}. The   {@code reason} is a short string that has anUTF-8 representation not longer than  {@code 123} bytes. For moredetails on Close message, status codes and reason see RFC 6455 sections <a href=""https://tools.ietf.org/html/rfc6455#section-5.5.1"">5.5.1. Close</a> and <a href=""https://tools.ietf.org/html/rfc6455#section-7.4"">7.4. Status Codes</a>. <p> After the returned  {@code CompletionStage} has completed(normally or exceptionally), the  {@code WebSocket} completes theclosing handshake by replying with an appropriate Close message. <p> This implementation replies with a Close message that has the same code this message has and an empty reason. <p>  {@code onClose} is the last invocation on the {@code Listener}. It is invoked at most once, but after   {@code onOpen}. If an exception is thrown from this method, it is ignored. <p> The   {@code WebSocket} will close at the earliest of completion ofthe returned  {@code CompletionStage} or sending a Close message. Inparticular, if a Close message has been  {@linkplain WebSocket#sendClose sent} before, then this invocation completes the closing handshakeand by the time this method is invoked, the  {@code WebSocket} willhave been closed.
 * @implSpec The default implementation of this method behaves as if:<pre> {@code return null;}</pre>
 * @param webSocket the WebSocket
 * @param statusCode the status code
 * @param reason the reason
 * @return a {@code CompletionStage} which completes when the {@code WebSocket} can be closed; or {@code null} if it can be closed immediately
 * @see #NORMAL_CLOSURE
 */
default CompletionStage<?> onClose(WebSocket webSocket,int statusCode,String reason){
  return null;
}"
76802,"/** 
 * Closes the   {@code WebSocket} abruptly.<p> This method may be invoked at any time. This method closes the underlying TCP connection and puts the  {@code WebSocket} into a closedstate. <p> As the result  {@link Listener#onClose(WebSocket,int,String) Listener.onClose} will be invoked with the status code {@link #CLOSED_ABNORMALLY} unless either {@code onClose} or {@link Listener#onError(WebSocket,Throwable) onError} has been invoked before.In which case no additional invocation will happen. <p> If the  {@code WebSocket} is already closed then invoking this methodhas no effect.
 * @throws IOException if an I/O error occurs
 */
void abort() throws IOException ;","/** 
 * Closes the   {@code WebSocket} abruptly.<p> This method may be invoked at any time. This method closes the underlying TCP connection and puts the  {@code WebSocket} into a closedstate. <p> As the result  {@link Listener#onClose(WebSocket,int,String) Listener.onClose} will be invoked unless either {@code onClose} or {@link Listener#onError(WebSocket,Throwable) onError} has been invoked before.In which case no additional invocation will happen. <p> If the  {@code WebSocket} is already closed then invoking this methodhas no effect.
 * @throws IOException if an I/O error occurs
 */
void abort() throws IOException ;"
76803,"/** 
 * Sends an empty Close message. <p> When this method has been invoked, no further messages can be sent. <p> For more details on Close message see RFC 6455 section <a href=""https://tools.ietf.org/html/rfc6455#section-5.5.1"">5.5.1. Close</a> <p> The method returns a   {@code CompletableFuture<WebSocket>} whichcompletes normally when the message has been sent or completes exceptionally if an error occurs. <p> The returned  {@code CompletableFuture} can complete exceptionallywith: <ul> <li>  {@link IOException} -if an I/O error occurs during this operation; or the  {@code WebSocket} has been closed due to an error</ul> <p> If this method has already been invoked or the  {@code WebSocket} isclosed, then subsequent invocations of this method have no effect and the returned  {@code CompletableFuture} completes normally.<p> If a Close message has been  {@linkplain Listener#onClose(WebSocket,int,String) received} before, then this invocation completes the closinghandshake and by the time the returned  {@code CompletableFuture}completes, the   {@code WebSocket} will have been closed.
 * @return a {@code CompletableFuture} with this {@code WebSocket}
 * @see #sendClose(int,String)
 */
CompletableFuture<WebSocket> sendClose();","/** 
 * Sends a Close message with the given status code and the reason. <p> When this method has been invoked, no further messages can be sent. <p> The   {@code statusCode} is an integer in the range {@code 1000 <= code<= 4999}. However, not all status codes may be legal in some implementations. Regardless of an implementation, <code>  {@value jdk.incubator.http.WebSocket#NORMAL_CLOSURE}</code> is always legal and   {@code 1002},   {@code 1003},   {@code 1005},   {@code 1006},   {@code 1007},   {@code 1009},   {@code 1010},   {@code 1012},   {@code 1013} and {@code 1015} are always illegal codes.<p> The  {@code reason} is a short string that must have an UTF-8representation not longer than  {@code 123} bytes. For more details onClose message, status codes and reason see RFC 6455 sections <a href=""https://tools.ietf.org/html/rfc6455#section-5.5.1"">5.5.1. Close</a> and <a href=""https://tools.ietf.org/html/rfc6455#section-7.4"">7.4. Status Codes</a>. <p> The method returns a  {@code CompletableFuture<WebSocket>} whichcompletes normally when the message has been sent or completes exceptionally if an error occurs. <p> The returned  {@code CompletableFuture} can complete exceptionallywith: <ul> <li>  {@link IllegalArgumentException} -if the  {@code statusCode} has an illegal value;or if  {@code reason} doesn't have an UTF-8 representation oflength  {@code <= 123}<li>   {@link IOException} -if an I/O error occurs during this operation; or the  {@code WebSocket} has been closed due to an error</ul> <p> If this method has already been invoked or the  {@code WebSocket} isclosed, then subsequent invocations of this method have no effect and the returned  {@code CompletableFuture} completes normally.<p> If a Close message has been  {@linkplain Listener#onClose(WebSocket,int,String) received} before, then this invocation completes the closinghandshake and by the time the returned  {@code CompletableFuture}completes, the   {@code WebSocket} will have been closed.
 * @param statusCode the status code
 * @param reason the reason
 * @return a {@code CompletableFuture} with this {@code WebSocket}
 */
CompletableFuture<WebSocket> sendClose(int statusCode,String reason);"
76804,"List<Pair<String,String>> getHeaders(){
  return headers;
}","Collection<Pair<String,String>> getHeaders(){
  return headers;
}"
76805,"@Override public Builder subprotocols(String mostPreferred,String... lesserPreferred){
  requireNonNull(mostPreferred,""String_Node_Str"");
  requireNonNull(lesserPreferred,""String_Node_Str"");
  List<String> subprotocols=new LinkedList<>();
  for (int i=0; i < lesserPreferred.length; i++) {
    String p=lesserPreferred[i];
    requireNonNull(p,""String_Node_Str"" + i + ""String_Node_Str"");
    subprotocols.add(p);
  }
  subprotocols.add(0,mostPreferred);
  this.subprotocols.clear();
  this.subprotocols.addAll(subprotocols);
  return this;
}","@Override public Builder subprotocols(String mostPreferred,String... lesserPreferred){
  requireNonNull(mostPreferred,""String_Node_Str"");
  requireNonNull(lesserPreferred,""String_Node_Str"");
  List<String> subprotocols=new LinkedList<>();
  subprotocols.add(mostPreferred);
  for (int i=0; i < lesserPreferred.length; i++) {
    String p=lesserPreferred[i];
    requireNonNull(p,""String_Node_Str"" + i + ""String_Node_Str"");
    subprotocols.add(p);
  }
  this.subprotocols.clear();
  this.subprotocols.addAll(subprotocols);
  return this;
}"
76806,"/** 
 * Return the serialField tags in this FieldDoc item.
 * @return an array of <tt>SerialFieldTag</tt> objects containingall  {@code @serialField} tags.
 */
SerialFieldTag[] serialFieldTags();","/** 
 * Return the serialField tags in this FieldDoc item.
 * @return an array of {@code SerialFieldTag} objects containingall  {@code @serialField} tags.
 */
SerialFieldTag[] serialFieldTags();"
76807,"/** 
 * Tests whether this method overrides another. The overridden method may be one declared in a superclass or a superinterface (unlike   {@link #overriddenMethod()}). <p> When a non-abstract method overrides an abstract one, it is also said to <i>implement</i> the other.
 * @param meth  the other method to examine
 * @return <tt>true</tt> if this method overrides the other
 * @since 1.5
 */
boolean overrides(MethodDoc meth);","/** 
 * Tests whether this method overrides another. The overridden method may be one declared in a superclass or a superinterface (unlike   {@link #overriddenMethod()}). <p> When a non-abstract method overrides an abstract one, it is also said to <i>implement</i> the other.
 * @param meth  the other method to examine
 * @return {@code true} if this method overrides the other
 * @since 1.5
 */
boolean overrides(MethodDoc meth);"
76808,"/** 
 * Return the kind of this tag. For most tags,  {@code kind() == name()}; the following table lists those cases where there is more than one tag of a given kind: <table border=""1"" cellpadding=""4"" cellspacing=""0"" summary=""related tags""> <tr><th>  {@code kind()  }</th>  <th>  {@code name()      }</th></tr> <tr><td>  {@code @throws }</td>  <td>  {@code @throws     }</td></tr> <tr><td>  {@code @throws }</td>  <td>  {@code @exception  }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @see        }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @link       }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @linkplain  }</td></tr> <tr><td>  {@code @serial }</td>  <td>  {@code @serial     }</td></tr> <tr><td>  {@code @serial }</td>  <td>  {@code @serialData }</td></tr> </table>
 * @return the kind of this tag.
 */
String kind();","/** 
 * Return the kind of this tag. For most tags,  {@code kind() == name()}; the following table lists those cases where there is more than one tag of a given kind: <table border=""1""> <caption>Related Tags</caption> <tr><th>  {@code kind()  }</th>  <th>  {@code name()      }</th></tr> <tr><td>  {@code @throws }</td>  <td>  {@code @throws     }</td></tr> <tr><td>  {@code @throws }</td>  <td>  {@code @exception  }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @see        }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @link       }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @linkplain  }</td></tr> <tr><td>  {@code @serial }</td>  <td>  {@code @serial     }</td></tr> <tr><td>  {@code @serial }</td>  <td>  {@code @serialData }</td></tr> </table>
 * @return the kind of this tag.
 */
String kind();"
76809,"/** 
 * Create and return the default parameter map for this  {@code ExecutionControlProvider}. The map can optionally be modified; Modified or unmodified it can be passed to  {@link #generate(jdk.jshell.spi.ExecutionEnv,java.util.Map) }. <table summary=""Parameters""> <tr> <th>Parameter</th> <th>Description</th> <th>Constant Field</th> </tr> <tr> <td>remoteAgent</td> <td>the remote agent to launch</td> <td>  {@link #PARAM_REMOTE_AGENT}</td> </tr> <tr> <td>timeout</td> <td>milliseconds before connect timeout</td> <td>  {@link #PARAM_TIMEOUT}</td> </tr> <tr> <td>launch</td> <td>""true"" for JDI controlled launch</td> <td>  {@link #PARAM_LAUNCH}</td> </tr> <tr> <td>hostname</td> <td>connect to the named of the local host ("""" for discovered)</td> <td>  {@link #PARAM_HOST_NAME}</td> </tr> </table>
 * @return the default parameter map
 */
@Override public Map<String,String> defaultParameters(){
  Map<String,String> dp=new HashMap<>();
  dp.put(PARAM_REMOTE_AGENT,RemoteExecutionControl.class.getName());
  dp.put(PARAM_TIMEOUT,""String_Node_Str"" + DEFAULT_TIMEOUT);
  dp.put(PARAM_HOST_NAME,""String_Node_Str"");
  dp.put(PARAM_LAUNCH,""String_Node_Str"");
  return dp;
}","/** 
 * Create and return the default parameter map for this  {@code ExecutionControlProvider}. The map can optionally be modified; Modified or unmodified it can be passed to  {@link #generate(jdk.jshell.spi.ExecutionEnv,java.util.Map) }. <table> <caption>Parameters</caption> <tr> <th>Parameter</th> <th>Description</th> <th>Constant Field</th> </tr> <tr> <td>remoteAgent</td> <td>the remote agent to launch</td> <td>  {@link #PARAM_REMOTE_AGENT}</td> </tr> <tr> <td>timeout</td> <td>milliseconds before connect timeout</td> <td>  {@link #PARAM_TIMEOUT}</td> </tr> <tr> <td>launch</td> <td>""true"" for JDI controlled launch</td> <td>  {@link #PARAM_LAUNCH}</td> </tr> <tr> <td>hostname</td> <td>connect to the named of the local host ("""" for discovered)</td> <td>  {@link #PARAM_HOST_NAME}</td> </tr> </table>
 * @return the default parameter map
 */
@Override public Map<String,String> defaultParameters(){
  Map<String,String> dp=new HashMap<>();
  dp.put(PARAM_REMOTE_AGENT,RemoteExecutionControl.class.getName());
  dp.put(PARAM_TIMEOUT,""String_Node_Str"" + DEFAULT_TIMEOUT);
  dp.put(PARAM_HOST_NAME,""String_Node_Str"");
  dp.put(PARAM_LAUNCH,""String_Node_Str"");
  return dp;
}"
76810,"/** 
 * Returns a guarded type conversion that receives a value of the specified source type and returns a value converted to the specified target type. Value types can be either primitives or reference types, including interfaces, so you can even provide converters for converting your language's objects to Java interfaces and classes by generating adapters for them. <p> The type of the invocation is <tt>(sourceType)&rarr;targetType</tt>, while the type of the guard is <tt>(sourceType)&rarr;boolean</tt>. You are allowed to return unconditional invocations (with no guard) if the source type is specific to your runtime and your runtime only. <p>Note that this method will never be invoked for  {@link TypeUtilities#isMethodInvocationConvertible(Class,Class) methodinvocation conversions} as those can be automatically applied by{@link java.lang.invoke.MethodHandle#asType(MethodType)}. An implementation can assume it is never requested to produce a converter for those conversions. If a language runtime needs to customize method invocation conversions, it should  {@link jdk.dynalink.DynamicLinkerFactory#setAutoConversionStrategy(MethodTypeConversionStrategy) set an autoconversion strategy in the dynamic linker factory} instead.<p>Dynalink is at liberty to either cache some of the returned converters or to repeatedly request the converter factory to create the same conversion.
 * @param sourceType source type
 * @param targetType the target type.
 * @param lookupSupplier a supplier for retrieving the lookup of the classon whose behalf a type converter is requested. When a converter is requested as part of linking an  {@code invokedynamic} instruction thesupplier will return the lookup passed to the bootstrap method, otherwise if the method is invoked from within a {@link LinkerServices#getWithLookup(Supplier,jdk.dynalink.SecureLookupSupplier)}it will delegate to the secure lookup supplier. In any other case, it will return the public lookup. A typical case where the lookup might be needed is when the converter creates a Java adapter class on the fly (e.g. to convert some object from the dynamic language into a Java interface for interoperability). Invoking the   {@link Supplier#get()}method on the passed supplier will be subject to the same security checks as   {@link SecureLookupSupplier#getLookup()}. An implementation should avoid retrieving the lookup if it is not needed so as to avoid the expense of  {@code AccessController.doPrivileged} call.
 * @return a guarded invocation that can take an object (if it passes guard)and return another object that is its representation coerced into the target type. In case the factory is certain it is unable to handle a conversion, it can return null. In case the factory is certain that it can always handle the conversion, it can return an unconditional invocation (one whose guard is null).
 * @throws Exception if there was an error during creation of the converter
 * @see LinkerServices#getWithLookup(Supplier,SecureLookupSupplier)
 */
public GuardedInvocation convertToType(Class<?> sourceType,Class<?> targetType,Supplier<MethodHandles.Lookup> lookupSupplier) throws Exception ;","/** 
 * Returns a guarded type conversion that receives a value of the specified source type and returns a value converted to the specified target type. Value types can be either primitives or reference types, including interfaces, so you can even provide converters for converting your language's objects to Java interfaces and classes by generating adapters for them. <p> The type of the invocation is <code>(sourceType)&rarr;targetType</code>, while the type of the guard is <code>(sourceType)&rarr;boolean</code>. You are allowed to return unconditional invocations (with no guard) if the source type is specific to your runtime and your runtime only. <p>Note that this method will never be invoked for  {@link TypeUtilities#isMethodInvocationConvertible(Class,Class) methodinvocation conversions} as those can be automatically applied by{@link java.lang.invoke.MethodHandle#asType(MethodType)}. An implementation can assume it is never requested to produce a converter for those conversions. If a language runtime needs to customize method invocation conversions, it should  {@link jdk.dynalink.DynamicLinkerFactory#setAutoConversionStrategy(MethodTypeConversionStrategy) set an autoconversion strategy in the dynamic linker factory} instead.<p>Dynalink is at liberty to either cache some of the returned converters or to repeatedly request the converter factory to create the same conversion.
 * @param sourceType source type
 * @param targetType the target type.
 * @param lookupSupplier a supplier for retrieving the lookup of the classon whose behalf a type converter is requested. When a converter is requested as part of linking an  {@code invokedynamic} instruction thesupplier will return the lookup passed to the bootstrap method, otherwise if the method is invoked from within a {@link LinkerServices#getWithLookup(Supplier,jdk.dynalink.SecureLookupSupplier)}it will delegate to the secure lookup supplier. In any other case, it will return the public lookup. A typical case where the lookup might be needed is when the converter creates a Java adapter class on the fly (e.g. to convert some object from the dynamic language into a Java interface for interoperability). Invoking the   {@link Supplier#get()}method on the passed supplier will be subject to the same security checks as   {@link SecureLookupSupplier#getLookup()}. An implementation should avoid retrieving the lookup if it is not needed so as to avoid the expense of  {@code AccessController.doPrivileged} call.
 * @return a guarded invocation that can take an object (if it passes guard)and return another object that is its representation coerced into the target type. In case the factory is certain it is unable to handle a conversion, it can return null. In case the factory is certain that it can always handle the conversion, it can return an unconditional invocation (one whose guard is null).
 * @throws Exception if there was an error during creation of the converter
 * @see LinkerServices#getWithLookup(Supplier,SecureLookupSupplier)
 */
public GuardedInvocation convertToType(Class<?> sourceType,Class<?> targetType,Supplier<MethodHandles.Lookup> lookupSupplier) throws Exception ;"
76811,"/** 
 * Returns the fields, methods, constructors, and member types that are directly declared in this class or interface. This includes any   {@linkplain Elements.Origin#MANDATED mandated} elements such as the (implicit) default constructorand the implicit  {@code values} and {@code valueOf} methods ofan enum type.
 * @apiNote As a particular instance of the {@linkplain javax.lang.model.element general accuracy requirements} and theordering behavior required of this interface, the list of enclosed elements will be returned in the natural order for the originating source of information about the type.  For example, if the information about the type is originating from a source file, the elements will be returned in source code order. (However, in that case the the ordering of elements, such as a default constructor, is not specified.)
 * @return the enclosed elements in proper order, or an empty list if none
 * @jls 8.8.9 Default Constructor
 * @jls 8.9.3 Enum Members
 */
@Override List<? extends Element> getEnclosedElements();","/** 
 * Returns the fields, methods, constructors, and member types that are directly declared in this class or interface. This includes any   {@linkplain Elements.Origin#MANDATED mandated} elements such as the (implicit) default constructorand the implicit  {@code values} and {@code valueOf} methods ofan enum type.
 * @apiNote As a particular instance of the {@linkplain javax.lang.model.element general accuracy requirements} and theordering behavior required of this interface, the list of enclosed elements will be returned in the natural order for the originating source of information about the type.  For example, if the information about the type is originating from a source file, the elements will be returned in source code order. (However, in that case the the ordering of  {@linkplain Elements.Origin#MANDATED implicitly declared} elements, such asdefault constructors, is not specified.)
 * @return the enclosed elements in proper order, or an empty list if none
 * @jls 8.8.9 Default Constructor
 * @jls 8.9.3 Enum Members
 */
@Override List<? extends Element> getEnclosedElements();"
76812,"/** 
 * If the processor class is annotated with   {@link SupportedAnnotationTypes}, return an unmodifiable set with the same set of strings as the annotation.  If the class is not so annotated, an empty set is returned. If the   {@link ProcessingEvironment#getSourceVersion sourceversion} does not support modules, in other words if it is lessthan or equal to  {@link SourceVersion#RELEASE_8 RELEASE_8}, then any leading   {@link Processor#getSupportedAnnotationTypes module prefixes} are stripped from the names.
 * @return the names of the annotation types supported by thisprocessor, or an empty set if none
 */
public Set<String> getSupportedAnnotationTypes(){
  SupportedAnnotationTypes sat=this.getClass().getAnnotation(SupportedAnnotationTypes.class);
  boolean initialized=isInitialized();
  if (sat == null) {
    if (initialized)     processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,""String_Node_Str"" + ""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str"");
    return Collections.emptySet();
  }
 else {
    boolean stripModulePrefixes=initialized && processingEnv.getSourceVersion().compareTo(SourceVersion.RELEASE_8) <= 0;
    return arrayToSet(sat.value(),stripModulePrefixes);
  }
}","/** 
 * If the processor class is annotated with   {@link SupportedAnnotationTypes}, return an unmodifiable set with the same set of strings as the annotation.  If the class is not so annotated, an empty set is returned. If the   {@link ProcessingEnvironment#getSourceVersion sourceversion} does not support modules, in other words if it is lessthan or equal to  {@link SourceVersion#RELEASE_8 RELEASE_8}, then any leading   {@link Processor#getSupportedAnnotationTypes module prefixes} are stripped from the names.
 * @return the names of the annotation types supported by thisprocessor, or an empty set if none
 */
public Set<String> getSupportedAnnotationTypes(){
  SupportedAnnotationTypes sat=this.getClass().getAnnotation(SupportedAnnotationTypes.class);
  boolean initialized=isInitialized();
  if (sat == null) {
    if (initialized)     processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,""String_Node_Str"" + ""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str"");
    return Collections.emptySet();
  }
 else {
    boolean stripModulePrefixes=initialized && processingEnv.getSourceVersion().compareTo(SourceVersion.RELEASE_8) <= 0;
    return arrayToSet(sat.value(),stripModulePrefixes);
  }
}"
76813,"/** 
 * Returns the names of the annotation types supported by this processor.  An element of the result may be the canonical (fully qualified) name of a supported annotation type. Alternately it may be of the form &quot;<code><i>name</i>.*</code>&quot; representing the set of all annotation types with canonical names beginning with &quot;<code><i>name.</i></code>&quot;. In either of those cases, the name of the annotation type can be optionally preceded by a module name followed by a   {@code ""/""} character. For example, if a processor supports {@code ""a.B""}, this can include multiple annotation types named   {@code a.B} which reside in different modules. To only support {@code a.B} in the {@code Foo} module, instead use {@code ""Foo/a.B""}. If a module name is included, only an annotation in that module is matched. In particular, if a module name is given in an environment where modules are not supported, such as an annotation processing environment configured for a   {@linkplain javax.annotation.processing.ProcessingEnvironment#getSourceVersion source version} without modules, then the annotation types witha module name do <em>not</em> match. Finally,  {@code ""*""} by itself represents the set of allannotation types, including the empty set.  Note that a processor should not claim  {@code ""*""} unless it is actuallyprocessing all files; claiming unnecessary annotations may cause a performance slowdown in some environments. <p>Each string returned in the set must be accepted by the following grammar: <blockquote> <dl> <dt><i>SupportedAnnotationTypeString:</i> <dd><i>ModulePrefix</i><sub><i>opt</i></sub> <i>TypeName</i> <i>DotStar</i><sub><i>opt</i></sub> <dd><code>*</code> <dt><i>ModulePrefix:</i> <dd><i>TypeName</i> <code>/</code> <dt><i>DotStar:</i> <dd><code>.</code> <code>*</code> </dl> </blockquote> where <i>TypeName</i> is as defined in <cite>The Java&trade; Language Specification</cite>.
 * @apiNote When running in an environment which supports modules,processors are encouraged to include the module prefix when describing their supported annotation types. The method  {@link AbstractProcessor.getSupportedAnnotationTypes AbstractProcessor.getSupportedAnnotationTypes} provides supportfor stripping off the module prefix when running in an environment without modules.
 * @return the names of the annotation types supported by this processor
 * @see javax.annotation.processing.SupportedAnnotationTypes
 * @jls 3.8 Identifiers
 * @jls 6.5.5 Meaning of Type Names
 */
Set<String> getSupportedAnnotationTypes();","/** 
 * Returns the names of the annotation types supported by this processor.  An element of the result may be the canonical (fully qualified) name of a supported annotation type. Alternately it may be of the form &quot;<code><i>name</i>.*</code>&quot; representing the set of all annotation types with canonical names beginning with &quot;<code><i>name.</i></code>&quot;. In either of those cases, the name of the annotation type can be optionally preceded by a module name followed by a   {@code ""/""} character. For example, if a processor supports {@code ""a.B""}, this can include multiple annotation types named   {@code a.B} which reside in different modules. To only support {@code a.B} in the {@code Foo} module, instead use {@code ""Foo/a.B""}. If a module name is included, only an annotation in that module is matched. In particular, if a module name is given in an environment where modules are not supported, such as an annotation processing environment configured for a   {@linkplain javax.annotation.processing.ProcessingEnvironment#getSourceVersion source version} without modules, then the annotation types witha module name do <em>not</em> match. Finally,  {@code ""*""} by itself represents the set of allannotation types, including the empty set.  Note that a processor should not claim  {@code ""*""} unless it is actuallyprocessing all files; claiming unnecessary annotations may cause a performance slowdown in some environments. <p>Each string returned in the set must be accepted by the following grammar: <blockquote> <dl> <dt><i>SupportedAnnotationTypeString:</i> <dd><i>ModulePrefix</i><sub><i>opt</i></sub> <i>TypeName</i> <i>DotStar</i><sub><i>opt</i></sub> <dd><code>*</code> <dt><i>ModulePrefix:</i> <dd><i>TypeName</i> <code>/</code> <dt><i>DotStar:</i> <dd><code>.</code> <code>*</code> </dl> </blockquote> where <i>TypeName</i> is as defined in <cite>The Java&trade; Language Specification</cite>.
 * @apiNote When running in an environment which supports modules,processors are encouraged to include the module prefix when describing their supported annotation types. The method  {@link AbstractProcessor#getSupportedAnnotationTypes AbstractProcessor.getSupportedAnnotationTypes} provides supportfor stripping off the module prefix when running in an environment without modules.
 * @return the names of the annotation types supported by this processor
 * @see javax.annotation.processing.SupportedAnnotationTypes
 * @jls 3.8 Identifiers
 * @jls 6.5.5 Meaning of Type Names
 */
Set<String> getSupportedAnnotationTypes();"
76814,"/** 
 * Returns the module of an element.  The module of a module is itself. If there is no module for the element, null is returned. One situation where there is no module for an element is if the environment does not include modules, such as an annotation processing environment configured for a   {@linkplain ProcessingEnvironment#getSourceVersion source version} without modules.      
 * @param type the element being examined
 * @return the module of an element
 * @since 9
 */
ModuleElement getModuleOf(Element type);","/** 
 * Returns the module of an element.  The module of a module is itself. If there is no module for the element, null is returned. One situation where there is no module for an element is if the environment does not include modules, such as an annotation processing environment configured for a   {@linkplain javax.annotation.processing.ProcessingEnvironment#getSourceVersion source version} without modules.
 * @param type the element being examined
 * @return the module of an element
 * @since 9
 */
ModuleElement getModuleOf(Element type);"
76815,"/** 
 * Returns a module element given its fully qualified name. If the named module cannot be found, null is returned. One situation where a module cannot be found is if the environment does not include modules, such as an annotation processing environment configured for a   {@linkplain ProcessingEnvironment#getSourceVersion source version} without modules.      
 * @param name  the name
 * @return the named module element, or {@code null} if it cannot be found
 * @since 9
 */
ModuleElement getModuleElement(CharSequence name);","/** 
 * Returns a module element given its fully qualified name. If the named module cannot be found, null is returned. One situation where a module cannot be found is if the environment does not include modules, such as an annotation processing environment configured for a   {@linkplain javax.annotation.processing.ProcessingEnvironment#getSourceVersion source version} without modules.
 * @param name  the name
 * @return the named module element, or {@code null} if it cannot be found
 * @since 9
 */
ModuleElement getModuleElement(CharSequence name);"
76816,"@Override public void visitRequires(JCRequires tree){
  if (tree.directive != null) {
    chk.checkDeprecated(tree.moduleName.pos(),msym,tree.directive.module);
    msym.directives=msym.directives.prepend(tree.directive);
  }
}","@Override public void visitRequires(JCRequires tree){
  if (tree.directive != null && allModules().contains(tree.directive.module)) {
    chk.checkDeprecated(tree.moduleName.pos(),msym,tree.directive.module);
    msym.directives=msym.directives.prepend(tree.directive);
  }
}"
76817,"private void completeModule(ModuleSymbol msym){
  if (inInitModules) {
    msym.completer=sym -> completeModule(msym);
    return;
  }
  if ((msym.flags_field & Flags.AUTOMATIC_MODULE) != 0) {
    completeAutomaticModule(msym);
  }
  Assert.checkNonNull(msym.requires);
  initAddReads();
  msym.requires=msym.requires.appendList(List.from(addReads.getOrDefault(msym,Collections.emptySet())));
  List<RequiresDirective> requires=msym.requires;
  List<RequiresDirective> previous=null;
  while (requires.nonEmpty()) {
    if (!allModules().contains(requires.head.module)) {
      Env<AttrContext> env=typeEnvs.get(msym);
      if (env != null) {
        JavaFileObject origSource=log.useSource(env.toplevel.sourcefile);
        try {
          log.error(env.tree,Errors.ModuleNotFound(requires.head.module));
        }
  finally {
          log.useSource(origSource);
        }
      }
 else {
        Assert.check((msym.flags() & Flags.AUTOMATIC_MODULE) == 0);
      }
      if (previous != null) {
        previous.tail=requires.tail;
      }
 else {
        msym.requires.tail=requires.tail;
      }
    }
 else {
      previous=requires;
    }
    requires=requires.tail;
  }
  Set<ModuleSymbol> readable=new LinkedHashSet<>();
  Set<ModuleSymbol> requiresTransitive=new HashSet<>();
  for (  RequiresDirective d : msym.requires) {
    d.module.complete();
    readable.add(d.module);
    Set<ModuleSymbol> s=retrieveRequiresTransitive(d.module);
    Assert.checkNonNull(s,() -> ""String_Node_Str"" + d.module);
    readable.addAll(s);
    if (d.flags.contains(RequiresFlag.TRANSITIVE)) {
      requiresTransitive.add(d.module);
      requiresTransitive.addAll(s);
    }
  }
  requiresTransitiveCache.put(msym,requiresTransitive);
  initVisiblePackages(msym,readable);
  for (  ExportsDirective d : msym.exports) {
    if (d.packge != null) {
      d.packge.modle=msym;
    }
  }
}","private void completeModule(ModuleSymbol msym){
  if (inInitModules) {
    msym.completer=sym -> completeModule(msym);
    return;
  }
  if ((msym.flags_field & Flags.AUTOMATIC_MODULE) != 0) {
    completeAutomaticModule(msym);
  }
  Assert.checkNonNull(msym.requires);
  initAddReads();
  msym.requires=msym.requires.appendList(List.from(addReads.getOrDefault(msym,Collections.emptySet())));
  List<RequiresDirective> requires=msym.requires;
  while (requires.nonEmpty()) {
    if (!allModules().contains(requires.head.module)) {
      Env<AttrContext> env=typeEnvs.get(msym);
      if (env != null) {
        JavaFileObject origSource=log.useSource(env.toplevel.sourcefile);
        try {
          log.error(env.tree,Errors.ModuleNotFound(requires.head.module));
        }
  finally {
          log.useSource(origSource);
        }
      }
 else {
        Assert.check((msym.flags() & Flags.AUTOMATIC_MODULE) == 0);
      }
      msym.requires=List.filter(msym.requires,requires.head);
    }
    requires=requires.tail;
  }
  Set<ModuleSymbol> readable=new LinkedHashSet<>();
  Set<ModuleSymbol> requiresTransitive=new HashSet<>();
  for (  RequiresDirective d : msym.requires) {
    d.module.complete();
    readable.add(d.module);
    Set<ModuleSymbol> s=retrieveRequiresTransitive(d.module);
    Assert.checkNonNull(s,() -> ""String_Node_Str"" + d.module);
    readable.addAll(s);
    if (d.flags.contains(RequiresFlag.TRANSITIVE)) {
      requiresTransitive.add(d.module);
      requiresTransitive.addAll(s);
    }
  }
  requiresTransitiveCache.put(msym,requiresTransitive);
  initVisiblePackages(msym,readable);
  for (  ExportsDirective d : msym.exports) {
    if (d.packge != null) {
      d.packge.modle=msym;
    }
  }
}"
76818,"/** 
 * Creates a new layer by defining the modules in the given   {@code Configuration} to the Java virtual machine. Each module is defined toits own  {@link ClassLoader} created by this method. The {@link ClassLoader#getParent() parent} of each class loader is the given parentclass loader. <p> The class loaders created by this method implement <em>direct delegation</em> when loading types from modules. When  {@link ClassLoader#loadClass(String,boolean) loadClass} method is invoked toload a class then it uses the package name of the class to map it to a module. The package may be in the module defined to the class loader. The package may be exported by another module in this layer to the module defined to the class loader. It may be in a package exported by a module in a parent layer. The class loader delegates to the class loader of the module, throwing  {@code ClassNotFoundException} if not found bythat class loader. When  {@code loadClass} is invoked to load classes that do not map to amodule then it delegates to the parent class loader. </p> <p> If there is a security manager then the class loaders created by this method will load classes and resources with privileges that are restricted by the calling context of this method. </p>
 * @param cf The configuration for the layer
 * @param parentLayers The list parent layers in search order
 * @param parentLoader The parent class loader for each of the class loaders created by this method; may be  {@code null} for the bootstrap class loader
 * @return A controller that controls the newly created layer
 * @throws IllegalArgumentException If the parent configurations do not match the configuration of the parent layers, including order
 * @throws LayerInstantiationException If the layer cannot be created because the configuration contains a module named "" {@code java.base}"" or a module with a package name starting with ""  {@code java.}""
 * @throws SecurityException If  {@code RuntimePermission(""createClassLoader"")} or{@code RuntimePermission(""getClassLoader"")} is denied bythe security manager
 * @see #findLoader
 */
public static Controller defineModulesWithManyLoaders(Configuration cf,List<Layer> parentLayers,ClassLoader parentLoader){
  List<Layer> parents=new ArrayList<>(parentLayers);
  checkConfiguration(cf,parents);
  checkCreateClassLoaderPermission();
  checkGetClassLoaderPermission();
  LoaderPool pool=new LoaderPool(cf,parents,parentLoader);
  try {
    Layer layer=new Layer(cf,parents,pool::loaderFor);
    return new Controller(layer);
  }
 catch (  IllegalArgumentException e) {
    throw new LayerInstantiationException(e.getMessage());
  }
}","/** 
 * Creates a new layer by defining the modules in the given   {@code Configuration} to the Java virtual machine. Each module is defined toits own  {@link ClassLoader} created by this method. The {@link ClassLoader#getParent() parent} of each class loader is the given parentclass loader. <p> The class loaders created by this method implement <em>direct delegation</em> when loading types from modules. When  {@link ClassLoader#loadClass(String,boolean) loadClass} method is invoked toload a class then it uses the package name of the class to map it to a module. The package may be in the module defined to the class loader. The package may be exported by another module in this layer to the module defined to the class loader. It may be in a package exported by a module in a parent layer. The class loader delegates to the class loader of the module, throwing  {@code ClassNotFoundException} if not found bythat class loader. When  {@code loadClass} is invoked to load classes that do not map to amodule then it delegates to the parent class loader. </p> <p> If there is a security manager then the class loaders created by this method will load classes and resources with privileges that are restricted by the calling context of this method. </p>
 * @param cf The configuration for the layer
 * @param parentLayers The list parent layers in search order
 * @param parentLoader The parent class loader for each of the class loaders created by this method; may be  {@code null} for the bootstrap class loader
 * @return A controller that controls the newly created layer
 * @throws IllegalArgumentException If the parent configurations do not match the configuration of the parent layers, including order
 * @throws LayerInstantiationException If the layer cannot be created because the configuration contains a module named "" {@code java.base}"" or a module with a package name starting with ""  {@code java.}""
 * @throws SecurityException If  {@code RuntimePermission(""createClassLoader"")} or{@code RuntimePermission(""getClassLoader"")} is denied bythe security manager
 * @see #findLoader
 */
public static Controller defineModulesWithManyLoaders(Configuration cf,List<Layer> parentLayers,ClassLoader parentLoader){
  List<Layer> parents=new ArrayList<>(parentLayers);
  checkConfiguration(cf,parents);
  checkCreateClassLoaderPermission();
  checkGetClassLoaderPermission();
  LoaderPool pool=new LoaderPool(cf,parents,parentLoader);
  try {
    Layer layer=new Layer(cf,parents,pool::loaderFor);
    return new Controller(layer);
  }
 catch (  IllegalArgumentException|IllegalStateException e) {
    throw new LayerInstantiationException(e.getMessage());
  }
}"
76819,"/** 
 * Creates a new layer by defining the modules in the given   {@code Configuration} to the Java virtual machine. This method creates oneclass loader and defines all modules to that class loader. <p> The class loader created by this method implements <em>direct delegation</em> when loading types from modules. When its  {@link ClassLoader#loadClass(String,boolean) loadClass} method is invoked toload a class then it uses the package name of the class to map it to a module. This may be a module in this layer and hence defined to the same class loader. It may be a package in a module in a parent layer that is exported to one or more of the modules in this layer. The class loader delegates to the class loader of the module, throwing  {@code ClassNotFoundException} if not found by that class loader.When  {@code loadClass} is invoked to load classes that do not map to amodule then it delegates to the parent class loader. </p> <p> Attempting to create a layer with all modules defined to the same class loader can fail for the following reasons: <ul> <li><p> <em>Overlapping packages</em>: Two or more modules in the configuration have the same package. </p></li> <li><p> <em>Split delegation</em>: The resulting class loader would need to delegate to more than one class loader in order to load types in a specific package. </p></li> </ul> <p> If there is a security manager then the class loader created by this method will load classes and resources with privileges that are restricted by the calling context of this method. </p>
 * @param cf The configuration for the layer
 * @param parentLayers The list parent layers in search order
 * @param parentLoader The parent class loader for the class loader created by this method; may be  {@code null} for the bootstrap class loader
 * @return A controller that controls the newly created layer
 * @throws IllegalArgumentException If the parent configurations do not match the configuration of the parent layers, including order
 * @throws LayerInstantiationException If all modules cannot be defined to the same class loader for any of the reasons listed above or the layer cannot be created because the configuration contains a module named "" {@code java.base}"" or a module with a package name starting with ""  {@code java.}""
 * @throws SecurityException If  {@code RuntimePermission(""createClassLoader"")} or{@code RuntimePermission(""getClassLoader"")} is denied bythe security manager
 * @see #findLoader
 */
public static Controller defineModulesWithOneLoader(Configuration cf,List<Layer> parentLayers,ClassLoader parentLoader){
  List<Layer> parents=new ArrayList<>(parentLayers);
  checkConfiguration(cf,parents);
  checkCreateClassLoaderPermission();
  checkGetClassLoaderPermission();
  try {
    Loader loader=new Loader(cf.modules(),parentLoader);
    loader.initRemotePackageMap(cf,parents);
    Layer layer=new Layer(cf,parents,mn -> loader);
    return new Controller(layer);
  }
 catch (  IllegalArgumentException e) {
    throw new LayerInstantiationException(e.getMessage());
  }
}","/** 
 * Creates a new layer by defining the modules in the given   {@code Configuration} to the Java virtual machine. This method creates oneclass loader and defines all modules to that class loader. <p> The class loader created by this method implements <em>direct delegation</em> when loading types from modules. When its  {@link ClassLoader#loadClass(String,boolean) loadClass} method is invoked toload a class then it uses the package name of the class to map it to a module. This may be a module in this layer and hence defined to the same class loader. It may be a package in a module in a parent layer that is exported to one or more of the modules in this layer. The class loader delegates to the class loader of the module, throwing  {@code ClassNotFoundException} if not found by that class loader.When  {@code loadClass} is invoked to load classes that do not map to amodule then it delegates to the parent class loader. </p> <p> Attempting to create a layer with all modules defined to the same class loader can fail for the following reasons: <ul> <li><p> <em>Overlapping packages</em>: Two or more modules in the configuration have the same package. </p></li> <li><p> <em>Split delegation</em>: The resulting class loader would need to delegate to more than one class loader in order to load types in a specific package. </p></li> </ul> <p> If there is a security manager then the class loader created by this method will load classes and resources with privileges that are restricted by the calling context of this method. </p>
 * @param cf The configuration for the layer
 * @param parentLayers The list parent layers in search order
 * @param parentLoader The parent class loader for the class loader created by this method; may be  {@code null} for the bootstrap class loader
 * @return A controller that controls the newly created layer
 * @throws IllegalArgumentException If the parent configurations do not match the configuration of the parent layers, including order
 * @throws LayerInstantiationException If all modules cannot be defined to the same class loader for any of the reasons listed above or the layer cannot be created because the configuration contains a module named "" {@code java.base}"" or a module with a package name starting with ""  {@code java.}""
 * @throws SecurityException If  {@code RuntimePermission(""createClassLoader"")} or{@code RuntimePermission(""getClassLoader"")} is denied bythe security manager
 * @see #findLoader
 */
public static Controller defineModulesWithOneLoader(Configuration cf,List<Layer> parentLayers,ClassLoader parentLoader){
  List<Layer> parents=new ArrayList<>(parentLayers);
  checkConfiguration(cf,parents);
  checkCreateClassLoaderPermission();
  checkGetClassLoaderPermission();
  try {
    Loader loader=new Loader(cf.modules(),parentLoader);
    loader.initRemotePackageMap(cf,parents);
    Layer layer=new Layer(cf,parents,mn -> loader);
    return new Controller(layer);
  }
 catch (  IllegalArgumentException|IllegalStateException e) {
    throw new LayerInstantiationException(e.getMessage());
  }
}"
76820,"/** 
 * Creates a new layer by defining the modules in the given   {@code Configuration} to the Java virtual machine.Each module is mapped, by name, to its class loader by means of the given function. The class loader delegation implemented by these class loaders must respect module readability. The class loaders should be {@link ClassLoader#registerAsParallelCapable parallel-capable} so as toavoid deadlocks during class loading. In addition, the entity creating a new layer with this method should arrange that the class loaders are ready to load from these modules before there are any attempts to load classes or resources. <p> Creating a  {@code Layer} can fail for the following reasons: </p><ul> <li><p> Two or more modules with the same package are mapped to the same class loader. </p></li> <li><p> A module is mapped to a class loader that already has a module of the same name defined to it. </p></li> <li><p> A module is mapped to a class loader that has already defined types in any of the packages in the module. </p></li> </ul> <p> If the function to map a module name to class loader throws an error or runtime exception then it is propagated to the caller of this method. </p>
 * @apiNote It is implementation specific as to whether creating a Layerwith this method is an atomic operation or not. Consequentially it is possible for this method to fail with some modules, but not all, defined to Java virtual machine.
 * @param cf The configuration for the layer
 * @param parentLayers The list parent layers in search order
 * @param clf The function to map a module name to a class loader
 * @return A controller that controls the newly created layer
 * @throws IllegalArgumentException If the parent configurations do not match the configuration of the parent layers, including order
 * @throws LayerInstantiationException If creating the  {@code Layer} fails for any of the reasonslisted above, the layer cannot be created because the configuration contains a module named "" {@code java.base}"", a module with a package name starting with ""  {@code java.}"" is mapped to a class loader other than the   {@link ClassLoader#getPlatformClassLoader() platform class loader}, or the function to map a module name to a class loader returns  {@code null}
 * @throws SecurityException If  {@code RuntimePermission(""getClassLoader"")} is denied bythe security manager
 */
public static Controller defineModules(Configuration cf,List<Layer> parentLayers,Function<String,ClassLoader> clf){
  List<Layer> parents=new ArrayList<>(parentLayers);
  checkConfiguration(cf,parents);
  Objects.requireNonNull(clf);
  checkGetClassLoaderPermission();
  if (boot() != null) {
    checkForDuplicatePkgs(cf,clf);
  }
  try {
    Layer layer=new Layer(cf,parents,clf);
    return new Controller(layer);
  }
 catch (  IllegalArgumentException iae) {
    throw new LayerInstantiationException(iae.getMessage());
  }
}","/** 
 * Creates a new layer by defining the modules in the given   {@code Configuration} to the Java virtual machine.Each module is mapped, by name, to its class loader by means of the given function. The class loader delegation implemented by these class loaders must respect module readability. The class loaders should be {@link ClassLoader#registerAsParallelCapable parallel-capable} so as toavoid deadlocks during class loading. In addition, the entity creating a new layer with this method should arrange that the class loaders are ready to load from these modules before there are any attempts to load classes or resources. <p> Creating a  {@code Layer} can fail for the following reasons: </p><ul> <li><p> Two or more modules with the same package are mapped to the same class loader. </p></li> <li><p> A module is mapped to a class loader that already has a module of the same name defined to it. </p></li> <li><p> A module is mapped to a class loader that has already defined types in any of the packages in the module. </p></li> </ul> <p> If the function to map a module name to class loader throws an error or runtime exception then it is propagated to the caller of this method. </p>
 * @apiNote It is implementation specific as to whether creating a Layerwith this method is an atomic operation or not. Consequentially it is possible for this method to fail with some modules, but not all, defined to Java virtual machine.
 * @param cf The configuration for the layer
 * @param parentLayers The list parent layers in search order
 * @param clf The function to map a module name to a class loader
 * @return A controller that controls the newly created layer
 * @throws IllegalArgumentException If the parent configurations do not match the configuration of the parent layers, including order
 * @throws LayerInstantiationException If creating the  {@code Layer} fails for any of the reasonslisted above, the layer cannot be created because the configuration contains a module named "" {@code java.base}"", a module with a package name starting with ""  {@code java.}"" is mapped to a class loader other than the   {@link ClassLoader#getPlatformClassLoader() platform class loader}, or the function to map a module name to a class loader returns  {@code null}
 * @throws SecurityException If  {@code RuntimePermission(""getClassLoader"")} is denied bythe security manager
 */
public static Controller defineModules(Configuration cf,List<Layer> parentLayers,Function<String,ClassLoader> clf){
  List<Layer> parents=new ArrayList<>(parentLayers);
  checkConfiguration(cf,parents);
  Objects.requireNonNull(clf);
  checkGetClassLoaderPermission();
  if (boot() != null) {
    checkForDuplicatePkgs(cf,clf);
  }
  try {
    Layer layer=new Layer(cf,parents,clf);
    return new Controller(layer);
  }
 catch (  IllegalArgumentException|IllegalStateException e) {
    throw new LayerInstantiationException(e.getMessage());
  }
}"
76821,"/** 
 * Returns a   {@code Method} object that reflects the specified publicmember method of the class or interface represented by this {@code Class} object. The {@code name} parameter is a{@code String} specifying the simple name of the desired method. The{@code parameterTypes} parameter is an array of {@code Class}objects that identify the method's formal parameter types, in declared order. If   {@code parameterTypes} is {@code null}, it is treated as if it were an empty array. <p> If the   {@code name} is ""{@code <init>}"" or ""  {@code <clinit>}"" a  {@code NoSuchMethodException} is raised. Otherwise, the method tobe reflected is determined by the algorithm that follows.  Let C be the class or interface represented by this object: <OL> <LI> C is searched for a <I>matching method</I>, as defined below. If a matching method is found, it is reflected.</LI> <LI> If no matching method is found by step 1 then: <OL TYPE=""a""> <LI> If C is a class other than  {@code Object}, then this algorithm is invoked recursively on the superclass of C.</LI> <LI> If C is the class   {@code Object}, or if C is an interface, then the superinterfaces of C (if any) are searched for a matching method. If any such method is found, it is reflected.</LI> </OL></LI> </OL> <p> To find a matching method in a class or interface C:&nbsp; If C declares exactly one public method with the specified name and exactly the same formal parameter types, that is the method reflected. If more than one such method is found in C, and one of these methods has a return type that is more specific than any of the others, that method is reflected; otherwise one of the methods is chosen arbitrarily. <p>Note that there may be more than one matching method in a class because while the Java language forbids a class to declare multiple methods with the same signature but different return types, the Java virtual machine does not.  This increased flexibility in the virtual machine can be used to implement various language features.  For example, covariant returns can be implemented with   {@linkplain java.lang.reflect.Method#isBridge bridge methods}; the bridge method and the method being overridden would have the same signature but different return types. <p> If this   {@code Class} object represents an array type, then thismethod does not find the  {@code clone()} method.<p> Static methods declared in superinterfaces of the class or interface represented by this  {@code Class} object are not considered members ofthe class or interface.
 * @param name the name of the method
 * @param parameterTypes the list of parameters
 * @return the {@code Method} object that matches the specified{@code name} and {@code parameterTypes}
 * @throws NoSuchMethodException if a matching method is not foundor if the name is ""&lt;init&gt;""or ""&lt;clinit&gt;"".
 * @throws NullPointerException if {@code name} is {@code null}
 * @throws SecurityException If a security manager, <i>s</i>, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of  {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class.
 * @jls 8.2 Class Members
 * @jls 8.4 Method Declarations
 * @since 1.1
 */
@CallerSensitive public Method getMethod(String name,Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException {
  checkMemberAccess(Member.PUBLIC,Reflection.getCallerClass(),true);
  Method method=getMethod0(name,parameterTypes,true);
  if (method == null) {
    throw new NoSuchMethodException(getName() + ""String_Node_Str"" + name+ argumentTypesToString(parameterTypes));
  }
  return method;
}","/** 
 * Returns a   {@code Method} object that reflects the specified publicmember method of the class or interface represented by this {@code Class} object. The {@code name} parameter is a{@code String} specifying the simple name of the desired method. The{@code parameterTypes} parameter is an array of {@code Class}objects that identify the method's formal parameter types, in declared order. If   {@code parameterTypes} is {@code null}, it is treated as if it were an empty array. <p> If this   {@code Class} object represents an array type, then thismethod finds any public method inherited by the array type from {@code Object} except method {@code clone()}. <p> If this   {@code Class} object represents an interface then thismethod does not find any implicitly declared method from {@code Object}. Therefore, if no methods are explicitly declared in this interface or any of its superinterfaces, then this method does not find any method. <p> This method does not find any method with name ""  {@code <init>}"" or ""  {@code <clinit>}"". <p> Generally, the method to be reflected is determined by the 4 step algorithm that follows. Let C be the class or interface represented by this   {@code Class} object:<ol> <li> A union of methods is composed of: <ol type=""a""> <li> C's declared public instance and static methods as returned by {@link #getDeclaredMethods()} and filtered to include only publicmethods that match given  {@code name} and {@code parameterTypes}</li> <li> If C is a class other than   {@code Object}, then include the result of invoking this algorithm recursively on the superclass of C.</li> <li> Include the results of invoking this algorithm recursively on all direct superinterfaces of C, but include only instance methods.</li> </ol></li> <li> This union is partitioned into subsets of methods with same return type (the selection of methods from step 1 also guarantees that they have the same method name and parameter types).</li> <li> Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same VM signature (return type, name, parameter types). M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if: <ol type=""a""> <li> N is declared by a class and M is declared by an interface; or</li> <li> N and M are both declared by classes or both by interfaces and N's declaring type is the same as or a subtype of M's declaring type (clearly, if M's and N's declaring types are the same type, then M and N are the same method).</li> </ol></li> <li> The result of this algorithm is chosen arbitrarily from the methods with most specific return type among all selected methods from step 3. Let R be a return type of a method M from the set of all selected methods from step 3. M is a method with most specific return type if there is no such method N != M from the same set, having return type S != R, such that S is a subtype of R as determined by R.class.  {@link #isAssignableFrom}(S.class). </ol>
 * @apiNote There may be more than one method with matching name andparameter types in a class because while the Java language forbids a class to declare multiple methods with the same signature but different return types, the Java virtual machine does not.  This increased flexibility in the virtual machine can be used to implement various language features.  For example, covariant returns can be implemented with  {@linkplain java.lang.reflect.Method#isBridge bridge methods}; the bridge method and the overriding method would have the same signature but different return types. This method would return the overriding method as it would have a more specific return type.
 * @param name the name of the method
 * @param parameterTypes the list of parameters
 * @return the {@code Method} object that matches the specified{@code name} and {@code parameterTypes}
 * @throws NoSuchMethodException if a matching method is not foundor if the name is ""&lt;init&gt;""or ""&lt;clinit&gt;"".
 * @throws NullPointerException if {@code name} is {@code null}
 * @throws SecurityException If a security manager, <i>s</i>, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of  {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class.
 * @jls 8.2 Class Members
 * @jls 8.4 Method Declarations
 * @since 1.1
 */
@CallerSensitive public Method getMethod(String name,Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException {
  Objects.requireNonNull(name);
  checkMemberAccess(Member.PUBLIC,Reflection.getCallerClass(),true);
  Method method=getMethod0(name,parameterTypes);
  if (method == null) {
    throw new NoSuchMethodException(getName() + ""String_Node_Str"" + name+ argumentTypesToString(parameterTypes));
  }
  return getReflectionFactory().copyMethod(method);
}"
76822,"private Constructor<T> getConstructor0(Class<?>[] parameterTypes,int which) throws NoSuchMethodException {
  Constructor<T>[] constructors=privateGetDeclaredConstructors((which == Member.PUBLIC));
  for (  Constructor<T> constructor : constructors) {
    if (arrayContentsEq(parameterTypes,constructor.getParameterTypes())) {
      return getReflectionFactory().copyConstructor(constructor);
    }
  }
  throw new NoSuchMethodException(getName() + ""String_Node_Str"" + argumentTypesToString(parameterTypes));
}","private Constructor<T> getConstructor0(Class<?>[] parameterTypes,int which) throws NoSuchMethodException {
  ReflectionFactory fact=getReflectionFactory();
  Constructor<T>[] constructors=privateGetDeclaredConstructors((which == Member.PUBLIC));
  for (  Constructor<T> constructor : constructors) {
    if (arrayContentsEq(parameterTypes,fact.getExecutableSharedParameterTypes(constructor))) {
      return constructor;
    }
  }
  throw new NoSuchMethodException(getName() + ""String_Node_Str"" + argumentTypesToString(parameterTypes));
}"
76823,"/** 
 * Returns a   {@code Field} object that reflects the specified public memberfield of the class or interface represented by this  {@code Class}object. The   {@code name} parameter is a {@code String} specifying thesimple name of the desired field. <p> The field to be reflected is determined by the algorithm that follows.  Let C be the class or interface represented by this object: <OL> <LI> If C declares a public field with the name specified, that is the field to be reflected.</LI> <LI> If no field was found in step 1 above, this algorithm is applied recursively to each direct superinterface of C. The direct superinterfaces are searched in the order they were declared.</LI> <LI> If no field was found in steps 1 and 2 above, and C has a superclass S, then this algorithm is invoked recursively upon S. If C has no superclass, then a  {@code NoSuchFieldException}is thrown.</LI> </OL> <p> If this   {@code Class} object represents an array type, then thismethod does not find the  {@code length} field of the array type.
 * @param name the field name
 * @return the {@code Field} object of this class specified by{@code name}
 * @throws NoSuchFieldException if a field with the specified name isnot found.
 * @throws NullPointerException if {@code name} is {@code null}
 * @throws SecurityException If a security manager, <i>s</i>, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of  {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class.
 * @since 1.1
 * @jls 8.2 Class Members
 * @jls 8.3 Field Declarations
 */
@CallerSensitive public Field getField(String name) throws NoSuchFieldException, SecurityException {
  checkMemberAccess(Member.PUBLIC,Reflection.getCallerClass(),true);
  Field field=getField0(name);
  if (field == null) {
    throw new NoSuchFieldException(name);
  }
  return field;
}","/** 
 * Returns a   {@code Field} object that reflects the specified public memberfield of the class or interface represented by this  {@code Class}object. The   {@code name} parameter is a {@code String} specifying thesimple name of the desired field. <p> The field to be reflected is determined by the algorithm that follows.  Let C be the class or interface represented by this object: <OL> <LI> If C declares a public field with the name specified, that is the field to be reflected.</LI> <LI> If no field was found in step 1 above, this algorithm is applied recursively to each direct superinterface of C. The direct superinterfaces are searched in the order they were declared.</LI> <LI> If no field was found in steps 1 and 2 above, and C has a superclass S, then this algorithm is invoked recursively upon S. If C has no superclass, then a  {@code NoSuchFieldException}is thrown.</LI> </OL> <p> If this   {@code Class} object represents an array type, then thismethod does not find the  {@code length} field of the array type.
 * @param name the field name
 * @return the {@code Field} object of this class specified by{@code name}
 * @throws NoSuchFieldException if a field with the specified name isnot found.
 * @throws NullPointerException if {@code name} is {@code null}
 * @throws SecurityException If a security manager, <i>s</i>, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of  {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class.
 * @since 1.1
 * @jls 8.2 Class Members
 * @jls 8.3 Field Declarations
 */
@CallerSensitive public Field getField(String name) throws NoSuchFieldException, SecurityException {
  Objects.requireNonNull(name);
  checkMemberAccess(Member.PUBLIC,Reflection.getCallerClass(),true);
  Field field=getField0(name);
  if (field == null) {
    throw new NoSuchFieldException(name);
  }
  return getReflectionFactory().copyField(field);
}"
76824,"private Method[] privateGetPublicMethods(){
  Method[] res;
  ReflectionData<T> rd=reflectionData();
  if (rd != null) {
    res=rd.publicMethods;
    if (res != null)     return res;
  }
  MethodArray methods=new MethodArray();
{
    Method[] tmp=privateGetDeclaredMethods(true);
    methods.addAll(tmp);
  }
  MethodArray inheritedMethods=new MethodArray();
  for (  Class<?> i : getInterfaces()) {
    inheritedMethods.addInterfaceMethods(i.privateGetPublicMethods());
  }
  if (!isInterface()) {
    Class<?> c=getSuperclass();
    if (c != null) {
      MethodArray supers=new MethodArray();
      supers.addAll(c.privateGetPublicMethods());
      for (int i=0; i < supers.length(); i++) {
        Method m=supers.get(i);
        if (m != null && !Modifier.isAbstract(m.getModifiers()) && !m.isDefault()) {
          inheritedMethods.removeByNameAndDescriptor(m);
        }
      }
      supers.addAll(inheritedMethods);
      inheritedMethods=supers;
    }
  }
  for (int i=0; i < methods.length(); i++) {
    Method m=methods.get(i);
    inheritedMethods.removeByNameAndDescriptor(m);
  }
  methods.addAllIfNotPresent(inheritedMethods);
  methods.removeLessSpecifics();
  methods.compactAndTrim();
  res=methods.getArray();
  if (rd != null) {
    rd.publicMethods=res;
  }
  return res;
}","private Method[] privateGetPublicMethods(){
  Method[] res;
  ReflectionData<T> rd=reflectionData();
  if (rd != null) {
    res=rd.publicMethods;
    if (res != null)     return res;
  }
  PublicMethods pms=new PublicMethods();
  for (  Method m : privateGetDeclaredMethods(true)) {
    pms.merge(m);
  }
  Class<?> sc=getSuperclass();
  if (sc != null) {
    for (    Method m : sc.privateGetPublicMethods()) {
      pms.merge(m);
    }
  }
  for (  Class<?> intf : getInterfaces(false)) {
    for (    Method m : intf.privateGetPublicMethods()) {
      if (!Modifier.isStatic(m.getModifiers())) {
        pms.merge(m);
      }
    }
  }
  res=pms.toArray();
  if (rd != null) {
    rd.publicMethods=res;
  }
  return res;
}"
76825,"/** 
 * Returns a   {@code Constructor} object that reflects the specifiedconstructor of the class or interface represented by this {@code Class} object.  The {@code parameterTypes} parameter isan array of  {@code Class} objects that identify the constructor'sformal parameter types, in declared order. If this  {@code Class} object represents an inner classdeclared in a non-static context, the formal parameter types include the explicit enclosing instance as the first parameter.
 * @param parameterTypes the parameter array
 * @return  The {@code Constructor} object for the constructor with thespecified parameter list
 * @throws NoSuchMethodException if a matching method is not found.
 * @throws SecurityException If a security manager, <i>s</i>, is present and any of the following conditions is met: <ul> <li> the caller's class loader is not the same as the class loader of this class and invocation of {@link SecurityManager#checkPermission s.checkPermission} method with{@code RuntimePermission(""accessDeclaredMembers"")}denies access to the declared constructor <li> the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of   {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class </ul>
 * @since 1.1
 */
@CallerSensitive public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException {
  checkMemberAccess(Member.DECLARED,Reflection.getCallerClass(),true);
  return getConstructor0(parameterTypes,Member.DECLARED);
}","/** 
 * Returns a   {@code Constructor} object that reflects the specifiedconstructor of the class or interface represented by this {@code Class} object.  The {@code parameterTypes} parameter isan array of  {@code Class} objects that identify the constructor'sformal parameter types, in declared order. If this  {@code Class} object represents an inner classdeclared in a non-static context, the formal parameter types include the explicit enclosing instance as the first parameter.
 * @param parameterTypes the parameter array
 * @return  The {@code Constructor} object for the constructor with thespecified parameter list
 * @throws NoSuchMethodException if a matching method is not found.
 * @throws SecurityException If a security manager, <i>s</i>, is present and any of the following conditions is met: <ul> <li> the caller's class loader is not the same as the class loader of this class and invocation of {@link SecurityManager#checkPermission s.checkPermission} method with{@code RuntimePermission(""accessDeclaredMembers"")}denies access to the declared constructor <li> the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of   {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class </ul>
 * @since 1.1
 */
@CallerSensitive public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException {
  checkMemberAccess(Member.DECLARED,Reflection.getCallerClass(),true);
  return getReflectionFactory().copyConstructor(getConstructor0(parameterTypes,Member.DECLARED));
}"
76826,"/** 
 * Returns a   {@code Method} object that reflects the specified publicmember method of the class or interface represented by this {@code Class} object.
 * @param name the name of the method
 * @param parameterTypes the list of parameters
 * @return the {@code Method} object that matches the specified{@code name} and {@code parameterTypes};   {@code null}if the method is not found or the name is ""&lt;init&gt;""or ""&lt;clinit&gt;"".
 */
Method getMethodOrNull(String name,Class<?>... parameterTypes){
  return getMethod0(name,parameterTypes,true);
}","/** 
 * Returns a   {@code Method} object that reflects the specified publicmember method of the class or interface represented by this {@code Class} object.
 * @param name the name of the method
 * @param parameterTypes the list of parameters
 * @return the {@code Method} object that matches the specified{@code name} and {@code parameterTypes};   {@code null}if the method is not found or the name is ""&lt;init&gt;""or ""&lt;clinit&gt;"".
 */
Method getMethodOrNull(String name,Class<?>... parameterTypes){
  Objects.requireNonNull(name);
  Method method=getMethod0(name,parameterTypes);
  return method == null ? null : getReflectionFactory().copyMethod(method);
}"
76827,"private Field getField0(String name) throws NoSuchFieldException {
  Field res;
  if ((res=searchFields(privateGetDeclaredFields(true),name)) != null) {
    return res;
  }
  Class<?>[] interfaces=getInterfaces();
  for (  Class<?> c : interfaces) {
    if ((res=c.getField0(name)) != null) {
      return res;
    }
  }
  if (!isInterface()) {
    Class<?> c=getSuperclass();
    if (c != null) {
      if ((res=c.getField0(name)) != null) {
        return res;
      }
    }
  }
  return null;
}","private Field getField0(String name){
  Field res;
  if ((res=searchFields(privateGetDeclaredFields(true),name)) != null) {
    return res;
  }
  Class<?>[] interfaces=getInterfaces(false);
  for (  Class<?> c : interfaces) {
    if ((res=c.getField0(name)) != null) {
      return res;
    }
  }
  if (!isInterface()) {
    Class<?> c=getSuperclass();
    if (c != null) {
      if ((res=c.getField0(name)) != null) {
        return res;
      }
    }
  }
  return null;
}"
76828,"void addAll(MethodArray ma){
  for (int i=0; i < ma.length(); i++) {
    add(ma.get(i));
  }
}","private static void addAll(Collection<Field> c,Field[] o){
  for (  Field f : o) {
    c.add(f);
  }
}"
76829,"private static Method searchMethods(Method[] methods,String name,Class<?>[] parameterTypes){
  Method res=null;
  String internedName=name.intern();
  for (  Method m : methods) {
    if (m.getName() == internedName && arrayContentsEq(parameterTypes,m.getParameterTypes()) && (res == null || res.getReturnType().isAssignableFrom(m.getReturnType())))     res=m;
  }
  return (res == null ? res : getReflectionFactory().copyMethod(res));
}","private static Method searchMethods(Method[] methods,String name,Class<?>[] parameterTypes){
  ReflectionFactory fact=getReflectionFactory();
  Method res=null;
  for (  Method m : methods) {
    if (m.getName().equals(name) && arrayContentsEq(parameterTypes,fact.getExecutableSharedParameterTypes(m)) && (res == null || (res.getReturnType() != m.getReturnType() && res.getReturnType().isAssignableFrom(m.getReturnType()))))     res=m;
  }
  return res;
}"
76830,"/** 
 * Returns the interfaces directly implemented by the class or interface represented by this object. <p>If this object represents a class, the return value is an array containing objects representing all interfaces directly implemented by the class.  The order of the interface objects in the array corresponds to the order of the interface names in the   {@code implements} clause ofthe declaration of the class represented by this object.  For example, given the declaration: <blockquote> {@code} class Shimmer implements FloorWax, DessertTopping ... }} </blockquote> suppose the value of  {@code s} is an instance of{@code Shimmer}; the value of the expression: <blockquote>  {@code s.getClass().getInterfaces()[0]}</blockquote> is the   {@code Class} object that represents interface{@code FloorWax}; and the value of: <blockquote>  {@code s.getClass().getInterfaces()[1]}</blockquote> is the   {@code Class} object that represents interface{@code DessertTopping}. <p>If this object represents an interface, the array contains objects representing all interfaces directly extended by the interface.  The order of the interface objects in the array corresponds to the order of the interface names in the   {@code extends} clause of the declaration ofthe interface represented by this object. <p>If this object represents a class or interface that implements no interfaces, the method returns an array of length 0. <p>If this object represents a primitive type or void, the method returns an array of length 0. <p>If this  {@code Class} object represents an array type, theinterfaces  {@code Cloneable} and {@code java.io.Serializable} arereturned in that order.
 * @return an array of interfaces directly implemented by this class
 */
public Class<?>[] getInterfaces(){
  ReflectionData<T> rd=reflectionData();
  if (rd == null) {
    return getInterfaces0();
  }
 else {
    Class<?>[] interfaces=rd.interfaces;
    if (interfaces == null) {
      interfaces=getInterfaces0();
      rd.interfaces=interfaces;
    }
    return interfaces.clone();
  }
}","private Class<?>[] getInterfaces(boolean cloneArray){
  ReflectionData<T> rd=reflectionData();
  if (rd == null) {
    return getInterfaces0();
  }
 else {
    Class<?>[] interfaces=rd.interfaces;
    if (interfaces == null) {
      interfaces=getInterfaces0();
      rd.interfaces=interfaces;
    }
    return cloneArray ? interfaces.clone() : interfaces;
  }
}"
76831,"/** 
 * Creates a new instance of the class represented by this   {@code Class}object.  The class is instantiated as if by a   {@code new}expression with an empty argument list.  The class is initialized if it has not already been initialized.
 * @deprecated This method propagates any exception thrown by thenullary constructor, including a checked exception.  Use of this method effectively bypasses the compile-time exception checking that would otherwise be performed by the compiler. The  {@link java.lang.reflect.Constructor#newInstance(java.lang.Object) Constructor.newInstance} method avoids this problem by wrappingany exception thrown by the constructor in a (checked)  {@link java.lang.reflect.InvocationTargetException}. <p>The call <pre>  {@code clazz.newInstance()}</pre> can be replaced by <pre>  {@code clazz.getDeclaredConstructor().newInstance()}</pre> The latter sequence of calls is inferred to be able to throw the additional exception types   {@link InvocationTargetException} and {@link NoSuchMethodException}. Both of these exception types are subclasses of   {@link ReflectiveOperationException}.
 * @return  a newly allocated instance of the class represented by thisobject.
 * @throws IllegalAccessException  if the class or its nullaryconstructor is not accessible.
 * @throws InstantiationException if this  {@code Class} represents an abstract class,an interface, an array class, a primitive type, or void; or if the class has no nullary constructor; or if the instantiation fails for some other reason.
 * @throws ExceptionInInitializerError if the initializationprovoked by this method fails.
 * @throws SecurityException If a security manager, <i>s</i>, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of  {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class.
 */
@CallerSensitive @Deprecated(since=""String_Node_Str"") public T newInstance() throws InstantiationException, IllegalAccessException {
  if (System.getSecurityManager() != null) {
    checkMemberAccess(Member.PUBLIC,Reflection.getCallerClass(),false);
  }
  if (cachedConstructor == null) {
    if (this == Class.class) {
      throw new IllegalAccessException(""String_Node_Str"");
    }
    try {
      Class<?>[] empty={};
      final Constructor<T> c=getConstructor0(empty,Member.DECLARED);
      java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<>(){
        public Void run(){
          c.setAccessible(true);
          return null;
        }
      }
);
      cachedConstructor=c;
    }
 catch (    NoSuchMethodException e) {
      throw (InstantiationException)new InstantiationException(getName()).initCause(e);
    }
  }
  Constructor<T> tmpConstructor=cachedConstructor;
  Class<?> caller=Reflection.getCallerClass();
  if (newInstanceCallerCache != caller) {
    int modifiers=tmpConstructor.getModifiers();
    Reflection.ensureMemberAccess(caller,this,this,modifiers);
    newInstanceCallerCache=caller;
  }
  try {
    return tmpConstructor.newInstance((Object[])null);
  }
 catch (  InvocationTargetException e) {
    Unsafe.getUnsafe().throwException(e.getTargetException());
    return null;
  }
}","/** 
 * Creates a new instance of the class represented by this   {@code Class}object.  The class is instantiated as if by a   {@code new}expression with an empty argument list.  The class is initialized if it has not already been initialized.
 * @deprecated This method propagates any exception thrown by thenullary constructor, including a checked exception.  Use of this method effectively bypasses the compile-time exception checking that would otherwise be performed by the compiler. The  {@link java.lang.reflect.Constructor#newInstance(java.lang.Object) Constructor.newInstance} method avoids this problem by wrappingany exception thrown by the constructor in a (checked)  {@link java.lang.reflect.InvocationTargetException}. <p>The call <pre>  {@code clazz.newInstance()}</pre> can be replaced by <pre>  {@code clazz.getDeclaredConstructor().newInstance()}</pre> The latter sequence of calls is inferred to be able to throw the additional exception types   {@link InvocationTargetException} and {@link NoSuchMethodException}. Both of these exception types are subclasses of   {@link ReflectiveOperationException}.
 * @return  a newly allocated instance of the class represented by thisobject.
 * @throws IllegalAccessException  if the class or its nullaryconstructor is not accessible.
 * @throws InstantiationException if this  {@code Class} represents an abstract class,an interface, an array class, a primitive type, or void; or if the class has no nullary constructor; or if the instantiation fails for some other reason.
 * @throws ExceptionInInitializerError if the initializationprovoked by this method fails.
 * @throws SecurityException If a security manager, <i>s</i>, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of  {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class.
 */
@CallerSensitive @Deprecated(since=""String_Node_Str"") public T newInstance() throws InstantiationException, IllegalAccessException {
  if (System.getSecurityManager() != null) {
    checkMemberAccess(Member.PUBLIC,Reflection.getCallerClass(),false);
  }
  if (cachedConstructor == null) {
    if (this == Class.class) {
      throw new IllegalAccessException(""String_Node_Str"");
    }
    try {
      Class<?>[] empty={};
      final Constructor<T> c=getReflectionFactory().copyConstructor(getConstructor0(empty,Member.DECLARED));
      java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<>(){
        public Void run(){
          c.setAccessible(true);
          return null;
        }
      }
);
      cachedConstructor=c;
    }
 catch (    NoSuchMethodException e) {
      throw (InstantiationException)new InstantiationException(getName()).initCause(e);
    }
  }
  Constructor<T> tmpConstructor=cachedConstructor;
  Class<?> caller=Reflection.getCallerClass();
  if (newInstanceCallerCache != caller) {
    int modifiers=tmpConstructor.getModifiers();
    Reflection.ensureMemberAccess(caller,this,this,modifiers);
    newInstanceCallerCache=caller;
  }
  try {
    return tmpConstructor.newInstance((Object[])null);
  }
 catch (  InvocationTargetException e) {
    Unsafe.getUnsafe().throwException(e.getTargetException());
    return null;
  }
}"
76832,"/** 
 * Returns an array containing   {@code Method} objects reflecting all thepublic methods of the class or interface represented by this  {@code Class} object, including those declared by the class or interface andthose inherited from superclasses and superinterfaces. <p> If this  {@code Class} object represents a type that has multiplepublic methods with the same name and parameter types, but different return types, then the returned array has a  {@code Method} object foreach such method. <p> If this  {@code Class} object represents a type with a classinitialization method  {@code <clinit>}, then the returned array does <em>not</em> have a corresponding   {@code Method} object.<p> If this  {@code Class} object represents an array type, then thereturned array has a  {@code Method} object for each of the publicmethods inherited by the array type from  {@code Object}. It does not contain a   {@code Method} object for {@code clone()}. <p> If this   {@code Class} object represents an interface then thereturned array does not contain any implicitly declared methods from {@code Object}. Therefore, if no methods are explicitly declared in this interface or any of its superinterfaces then the returned array has length 0. (Note that a   {@code Class} object which represents a classalways has public methods, inherited from  {@code Object}.) <p> If this   {@code Class} object represents a primitive type or void,then the returned array has length 0. <p> Static methods declared in superinterfaces of the class or interface represented by this  {@code Class} object are not considered members ofthe class or interface. <p> The elements in the returned array are not sorted and are not in any particular order.
 * @return the array of {@code Method} objects representing thepublic methods of this class
 * @throws SecurityException If a security manager, <i>s</i>, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of  {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class.
 * @jls 8.2 Class Members
 * @jls 8.4 Method Declarations
 * @since 1.1
 */
@CallerSensitive public Method[] getMethods() throws SecurityException {
  checkMemberAccess(Member.PUBLIC,Reflection.getCallerClass(),true);
  return copyMethods(privateGetPublicMethods());
}","/** 
 * Returns an array containing   {@code Method} objects reflecting all thepublic methods of the class or interface represented by this  {@code Class} object, including those declared by the class or interface andthose inherited from superclasses and superinterfaces. <p> If this  {@code Class} object represents an array type, then thereturned array has a  {@code Method} object for each of the publicmethods inherited by the array type from  {@code Object}. It does not contain a   {@code Method} object for {@code clone()}. <p> If this   {@code Class} object represents an interface then thereturned array does not contain any implicitly declared methods from {@code Object}. Therefore, if no methods are explicitly declared in this interface or any of its superinterfaces then the returned array has length 0. (Note that a   {@code Class} object which represents a classalways has public methods, inherited from  {@code Object}.) <p> The returned array never contains methods with names ""  {@code <init>}"" or ""  {@code <clinit>}"". <p> The elements in the returned array are not sorted and are not in any particular order. <p> Generally, the result is computed as with the following 4 step algorithm. Let C be the class or interface represented by this   {@code Class} object:<ol> <li> A union of methods is composed of: <ol type=""a""> <li> C's declared public instance and static methods as returned by {@link #getDeclaredMethods()} and filtered to include only publicmethods.</li> <li> If C is a class other than  {@code Object}, then include the result of invoking this algorithm recursively on the superclass of C.</li> <li> Include the results of invoking this algorithm recursively on all direct superinterfaces of C, but include only instance methods.</li> </ol></li> <li> Union from step 1 is partitioned into subsets of methods with same signature (name, parameter types) and return type.</li> <li> Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same signature and return type. M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if: <ol type=""a""> <li> N is declared by a class and M is declared by an interface; or</li> <li> N and M are both declared by classes or both by interfaces and N's declaring type is the same as or a subtype of M's declaring type (clearly, if M's and N's declaring types are the same type, then M and N are the same method).</li> </ol></li> <li> The result of this algorithm is the union of all selected methods from step 3.</li> </ol>
 * @apiNote There may be more than one method with a particular nameand parameter types in a class because while the Java language forbids a class to declare multiple methods with the same signature but different return types, the Java virtual machine does not.  This increased flexibility in the virtual machine can be used to implement various language features.  For example, covariant returns can be implemented with  {@linkplain java.lang.reflect.Method#isBridge bridge methods}; the bridge method and the overriding method would have the same signature but different return types.
 * @return the array of {@code Method} objects representing thepublic methods of this class
 * @throws SecurityException If a security manager, <i>s</i>, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of  {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class.
 * @jls 8.2 Class Members
 * @jls 8.4 Method Declarations
 * @since 1.1
 */
@CallerSensitive public Method[] getMethods() throws SecurityException {
  checkMemberAccess(Member.PUBLIC,Reflection.getCallerClass(),true);
  return copyMethods(privateGetPublicMethods());
}"
76833,"private static Field searchFields(Field[] fields,String name){
  String internedName=name.intern();
  for (  Field field : fields) {
    if (field.getName() == internedName) {
      return getReflectionFactory().copyField(field);
    }
  }
  return null;
}","private static Field searchFields(Field[] fields,String name){
  for (  Field field : fields) {
    if (field.getName().equals(name)) {
      return field;
    }
  }
  return null;
}"
76834,"/** 
 * Returns a   {@code Field} object that reflects the specified declaredfield of the class or interface represented by this  {@code Class}object. The   {@code name} parameter is a {@code String} that specifiesthe simple name of the desired field. <p> If this  {@code Class} object represents an array type, then thismethod does not find the  {@code length} field of the array type.
 * @param name the name of the field
 * @return  the {@code Field} object for the specified field in thisclass
 * @throws NoSuchFieldException if a field with the specified name isnot found.
 * @throws NullPointerException if {@code name} is {@code null}
 * @throws SecurityException If a security manager, <i>s</i>, is present and any of the following conditions is met: <ul> <li> the caller's class loader is not the same as the class loader of this class and invocation of {@link SecurityManager#checkPermission s.checkPermission} method with{@code RuntimePermission(""accessDeclaredMembers"")}denies access to the declared field <li> the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of   {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class </ul>
 * @since 1.1
 * @jls 8.2 Class Members
 * @jls 8.3 Field Declarations
 */
@CallerSensitive public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException {
  checkMemberAccess(Member.DECLARED,Reflection.getCallerClass(),true);
  Field field=searchFields(privateGetDeclaredFields(false),name);
  if (field == null) {
    throw new NoSuchFieldException(name);
  }
  return field;
}","/** 
 * Returns a   {@code Field} object that reflects the specified declaredfield of the class or interface represented by this  {@code Class}object. The   {@code name} parameter is a {@code String} that specifiesthe simple name of the desired field. <p> If this  {@code Class} object represents an array type, then thismethod does not find the  {@code length} field of the array type.
 * @param name the name of the field
 * @return  the {@code Field} object for the specified field in thisclass
 * @throws NoSuchFieldException if a field with the specified name isnot found.
 * @throws NullPointerException if {@code name} is {@code null}
 * @throws SecurityException If a security manager, <i>s</i>, is present and any of the following conditions is met: <ul> <li> the caller's class loader is not the same as the class loader of this class and invocation of {@link SecurityManager#checkPermission s.checkPermission} method with{@code RuntimePermission(""accessDeclaredMembers"")}denies access to the declared field <li> the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of   {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class </ul>
 * @since 1.1
 * @jls 8.2 Class Members
 * @jls 8.3 Field Declarations
 */
@CallerSensitive public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException {
  Objects.requireNonNull(name);
  checkMemberAccess(Member.DECLARED,Reflection.getCallerClass(),true);
  Field field=searchFields(privateGetDeclaredFields(false),name);
  if (field == null) {
    throw new NoSuchFieldException(name);
  }
  return getReflectionFactory().copyField(field);
}"
76835,"/** 
 * Returns a   {@code Method} object that reflects the specifieddeclared method of the class or interface represented by this {@code Class} object. The {@code name} parameter is a{@code String} that specifies the simple name of the desiredmethod, and the  {@code parameterTypes} parameter is an array of{@code Class} objects that identify the method's formal parametertypes, in declared order.  If more than one method with the same parameter types is declared in a class, and one of these methods has a return type that is more specific than any of the others, that method is returned; otherwise one of the methods is chosen arbitrarily.  If the name is ""&lt;init&gt;""or ""&lt;clinit&gt;"" a  {@code NoSuchMethodException}is raised. <p> If this   {@code Class} object represents an array type, then thismethod does not find the  {@code clone()} method.
 * @param name the name of the method
 * @param parameterTypes the parameter array
 * @return  the {@code Method} object for the method of this classmatching the specified name and parameters
 * @throws NoSuchMethodException if a matching method is not found.
 * @throws NullPointerException if {@code name} is {@code null}
 * @throws SecurityException If a security manager, <i>s</i>, is present and any of the following conditions is met: <ul> <li> the caller's class loader is not the same as the class loader of this class and invocation of {@link SecurityManager#checkPermission s.checkPermission} method with{@code RuntimePermission(""accessDeclaredMembers"")}denies access to the declared method <li> the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of   {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class </ul>
 * @jls 8.2 Class Members
 * @jls 8.4 Method Declarations
 * @since 1.1
 */
@CallerSensitive public Method getDeclaredMethod(String name,Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException {
  checkMemberAccess(Member.DECLARED,Reflection.getCallerClass(),true);
  Method method=searchMethods(privateGetDeclaredMethods(false),name,parameterTypes);
  if (method == null) {
    throw new NoSuchMethodException(getName() + ""String_Node_Str"" + name+ argumentTypesToString(parameterTypes));
  }
  return method;
}","/** 
 * Returns a   {@code Method} object that reflects the specifieddeclared method of the class or interface represented by this {@code Class} object. The {@code name} parameter is a{@code String} that specifies the simple name of the desiredmethod, and the  {@code parameterTypes} parameter is an array of{@code Class} objects that identify the method's formal parametertypes, in declared order.  If more than one method with the same parameter types is declared in a class, and one of these methods has a return type that is more specific than any of the others, that method is returned; otherwise one of the methods is chosen arbitrarily.  If the name is ""&lt;init&gt;""or ""&lt;clinit&gt;"" a  {@code NoSuchMethodException}is raised. <p> If this   {@code Class} object represents an array type, then thismethod does not find the  {@code clone()} method.
 * @param name the name of the method
 * @param parameterTypes the parameter array
 * @return  the {@code Method} object for the method of this classmatching the specified name and parameters
 * @throws NoSuchMethodException if a matching method is not found.
 * @throws NullPointerException if {@code name} is {@code null}
 * @throws SecurityException If a security manager, <i>s</i>, is present and any of the following conditions is met: <ul> <li> the caller's class loader is not the same as the class loader of this class and invocation of {@link SecurityManager#checkPermission s.checkPermission} method with{@code RuntimePermission(""accessDeclaredMembers"")}denies access to the declared method <li> the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of   {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class </ul>
 * @jls 8.2 Class Members
 * @jls 8.4 Method Declarations
 * @since 1.1
 */
@CallerSensitive public Method getDeclaredMethod(String name,Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException {
  Objects.requireNonNull(name);
  checkMemberAccess(Member.DECLARED,Reflection.getCallerClass(),true);
  Method method=searchMethods(privateGetDeclaredMethods(false),name,parameterTypes);
  if (method == null) {
    throw new NoSuchMethodException(getName() + ""String_Node_Str"" + name+ argumentTypesToString(parameterTypes));
  }
  return getReflectionFactory().copyMethod(method);
}"
76836,"/** 
 * Returns a   {@code Constructor} object that reflects the specifiedpublic constructor of the class represented by this  {@code Class}object. The   {@code parameterTypes} parameter is an array of{@code Class} objects that identify the constructor's formalparameter types, in declared order. If this  {@code Class} object represents an inner classdeclared in a non-static context, the formal parameter types include the explicit enclosing instance as the first parameter. <p> The constructor to reflect is the public constructor of the class represented by this  {@code Class} object whose formal parametertypes match those specified by  {@code parameterTypes}.
 * @param parameterTypes the parameter array
 * @return the {@code Constructor} object of the public constructor thatmatches the specified  {@code parameterTypes}
 * @throws NoSuchMethodException if a matching method is not found.
 * @throws SecurityException If a security manager, <i>s</i>, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of  {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class.
 * @since 1.1
 */
@CallerSensitive public Constructor<T> getConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException {
  checkMemberAccess(Member.PUBLIC,Reflection.getCallerClass(),true);
  return getConstructor0(parameterTypes,Member.PUBLIC);
}","/** 
 * Returns a   {@code Constructor} object that reflects the specifiedpublic constructor of the class represented by this  {@code Class}object. The   {@code parameterTypes} parameter is an array of{@code Class} objects that identify the constructor's formalparameter types, in declared order. If this  {@code Class} object represents an inner classdeclared in a non-static context, the formal parameter types include the explicit enclosing instance as the first parameter. <p> The constructor to reflect is the public constructor of the class represented by this  {@code Class} object whose formal parametertypes match those specified by  {@code parameterTypes}.
 * @param parameterTypes the parameter array
 * @return the {@code Constructor} object of the public constructor thatmatches the specified  {@code parameterTypes}
 * @throws NoSuchMethodException if a matching method is not found.
 * @throws SecurityException If a security manager, <i>s</i>, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of  {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the packageof this class.
 * @since 1.1
 */
@CallerSensitive public Constructor<T> getConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException {
  checkMemberAccess(Member.PUBLIC,Reflection.getCallerClass(),true);
  return getReflectionFactory().copyConstructor(getConstructor0(parameterTypes,Member.PUBLIC));
}"
76837,"private Method getMethod0(String name,Class<?>[] parameterTypes,boolean includeStaticMethods){
  MethodArray interfaceCandidates=new MethodArray(2);
  Method res=privateGetMethodRecursive(name,parameterTypes,includeStaticMethods,interfaceCandidates);
  if (res != null)   return res;
  interfaceCandidates.removeLessSpecifics();
  return interfaceCandidates.getFirst();
}","private Method getMethod0(String name,Class<?>[] parameterTypes){
  PublicMethods.MethodList res=getMethodsRecursive(name,parameterTypes == null ? EMPTY_CLASS_ARRAY : parameterTypes,true);
  return res == null ? null : res.getMostSpecific();
}"
76838,"public static void main(String[] args){
  Class[] l1={D1.class};
  test(A1.class.getMethods(),new ArrayList(Arrays.asList(l1)));
  Class[] l2={A2.class};
  test(A2.class.getMethods(),new ArrayList(Arrays.asList(l2)));
  Class[] l3={B3.class,C3.class};
  test(A3.class.getMethods(),new ArrayList(Arrays.asList(l3)));
  Class[] l4={B4.class,D4.class};
  test(A4.class.getMethods(),new ArrayList(Arrays.asList(l4)));
}","public static void main(String[] args){
  Class[] l1={D1.class};
  test(A1.class.getMethods(),new ArrayList(Arrays.asList(l1)));
  Class[] l2={A2.class};
  test(A2.class.getMethods(),new ArrayList(Arrays.asList(l2)));
  Class[] l3={B3.class,C3.class};
  test(A3.class.getMethods(),new ArrayList(Arrays.asList(l3)));
  Class[] l4={B4.class};
  test(A4.class.getMethods(),new ArrayList(Arrays.asList(l4)));
}"
76839,"void setContentBounds(WindowDimensions dims){
  XToolkit.awtLock();
  try {
    Rectangle newBounds=dims.getBounds();
    Insets in=dims.getInsets();
    if (in != null) {
      newBounds.setLocation(-in.left,-in.top);
    }
    if (insLog.isLoggable(PlatformLogger.Level.FINE)) {
      insLog.fine(""String_Node_Str"",newBounds,getBounds());
    }
    boolean needHandleResize=!(newBounds.equals(getBounds()));
    reshape(newBounds);
    if (needHandleResize) {
      insLog.fine(""String_Node_Str"");
      handleResize(newBounds);
    }
  }
  finally {
    XToolkit.awtUnlock();
  }
  validateSurface();
}","void setContentBounds(WindowDimensions dims){
  XToolkit.awtLock();
  try {
    Rectangle newBounds=dims.getBounds();
    Insets in=dims.getInsets();
    if (in != null) {
      newBounds.setLocation(-in.left,-in.top);
    }
    if (insLog.isLoggable(PlatformLogger.Level.FINE)) {
      insLog.fine(""String_Node_Str"",newBounds,getBounds());
    }
    boolean needHandleResize=!(newBounds.equals(getBounds()));
    boolean needPaint=width <= 0 || height <= 0;
    reshape(newBounds);
    if (needHandleResize) {
      insLog.fine(""String_Node_Str"");
      handleResize(newBounds);
    }
    if (needPaint) {
      postPaintEvent(target,0,0,newBounds.width,newBounds.height);
    }
  }
  finally {
    XToolkit.awtUnlock();
  }
}"
76840,"CaInfo scan(String s){
  try {
    Scanner scanner=scannerFactory.newScanner(s,false);
    Matched in=new Matched(scanner);
    Parser parser=new Parser(in,proc,s);
    Completeness stat=parser.parseUnit();
    int endPos=stat == Completeness.UNKNOWN ? s.length() : in.prevCT.endPos;
    return new CaInfo(stat,endPos);
  }
 catch (  SyntaxException ex) {
    return new CaInfo(error(),s.length());
  }
}","CaInfo scan(String s){
  try {
    Parser parser=new Parser(() -> new Matched(scannerFactory.newScanner(s,false)),() -> proc.taskFactory.new ParseTask(s));
    Completeness stat=parser.parseUnit();
    int endPos=stat == Completeness.UNKNOWN ? s.length() : parser.endPos();
    return new CaInfo(stat,endPos);
  }
 catch (  SyntaxException ex) {
    return new CaInfo(error(),s.length());
  }
}"
76841,"/** 
 * @return the next scanner token
 */
private CT nextCT(){
  TK prevTK=currentCT.kind;
  while (true) {
    db(""String_Node_Str"");
    CT ct;
switch (current.kind) {
case EOF:
      db(""String_Node_Str"");
    if (stack.isEmpty()) {
      ct=new CT(EOF,current);
    }
 else {
      TokenKind unmatched=stack.pop().kind;
      stack.clear();
      ct=new CT(UNMATCHED,current,""String_Node_Str"" + unmatched);
    }
  break;
case LPAREN:
case LBRACE:
case LBRACKET:
stack.push(advance());
prevTK=SEMI;
continue;
case RPAREN:
ct=match(PARENS,TokenKind.LPAREN);
break;
case RBRACE:
ct=match(BRACES,TokenKind.LBRACE);
break;
case RBRACKET:
ct=match(BRACKETS,TokenKind.LBRACKET);
break;
default :
ct=new CT(TK.tokenKindToTK(current.kind),advance());
break;
}
if (ct.kind.isStart() && !prevTK.isOkToTerminate()) {
return new CT(ERROR,current,""String_Node_Str"" + prevTK + ""String_Node_Str""+ ct.kind+ ""String_Node_Str"");
}
if (stack.isEmpty() || ct.kind.isError()) {
return ct;
}
prevTK=ct.kind;
}
}","/** 
 * @return the next scanner token
 */
private CT nextCT(){
  TK prevTK=currentCT.kind;
  while (true) {
    db(""String_Node_Str"");
    CT ct;
switch (current.kind) {
case EOF:
      db(""String_Node_Str"");
    if (stack.isEmpty()) {
      ct=new CT(EOF,current);
    }
 else {
      TokenKind unmatched=stack.pop().kind;
      stack.clear();
      ct=new CT(UNMATCHED,current,""String_Node_Str"" + unmatched);
    }
  break;
case LPAREN:
case LBRACE:
case LBRACKET:
stack.push(advance());
prevTK=SEMI;
continue;
case RPAREN:
ct=match(PARENS,TokenKind.LPAREN);
break;
case RBRACE:
ct=match(BRACES,TokenKind.LBRACE);
break;
case RBRACKET:
ct=match(BRACKETS,TokenKind.LBRACKET);
break;
default :
ct=new CT(TK.tokenKindToTK(prevTK,current.kind),advance());
break;
}
if (ct.kind.isStart() && !prevTK.isOkToTerminate()) {
return new CT(ERROR,current,""String_Node_Str"" + prevTK + ""String_Node_Str""+ ct.kind+ ""String_Node_Str"");
}
if (stack.isEmpty() || ct.kind.isError()) {
return ct;
}
prevTK=ct.kind;
}
}"
76842,"private static TK tokenKindToTK(TokenKind kind){
  TK tk=tokenKindToTKMap.get(kind);
  if (tk == null) {
    System.err.printf(""String_Node_Str"",TK.class.getCanonicalName(),TokenKind.class.getCanonicalName(),kind);
    throw new InternalError(""String_Node_Str"" + kind);
  }
  return tk;
}","private static TK tokenKindToTK(TK prev,TokenKind kind){
  TK tk=tokenKindToTKMap.get(kind);
  if (tk == null) {
    System.err.printf(""String_Node_Str"",TK.class.getCanonicalName(),TokenKind.class.getCanonicalName(),kind);
    throw new InternalError(""String_Node_Str"" + kind);
  }
  return tk.mapping != null ? tk.mapping.apply(prev) : tk;
}"
76843,"public Completeness disambiguateDeclarationVsExpression(){
  ParseTask pt=proc.taskFactory.new ParseTask(scannedInput);
  List<? extends Tree> units=pt.units();
  if (units.isEmpty()) {
    return error();
  }
  Tree unitTree=units.get(0);
switch (unitTree.getKind()) {
case EXPRESSION_STATEMENT:
    return parseExpressionOptionalSemi();
case LABELED_STATEMENT:
  if (shouldAbort(IDENTIFIER))   return checkResult;
if (shouldAbort(COLON)) return checkResult;
return parseStatement();
case VARIABLE:
case IMPORT:
case CLASS:
case ENUM:
case ANNOTATION_TYPE:
case INTERFACE:
case METHOD:
return parseDeclaration();
default :
return error();
}
}","public Completeness disambiguateDeclarationVsExpression(){
  ParseTask pt=parseFactory.get();
  List<? extends Tree> units=pt.units();
  if (units.isEmpty()) {
    return error();
  }
  Tree unitTree=units.get(0);
switch (unitTree.getKind()) {
case EXPRESSION_STATEMENT:
    return parseExpressionOptionalSemi();
case LABELED_STATEMENT:
  if (shouldAbort(IDENTIFIER))   return checkResult;
if (shouldAbort(COLON)) return checkResult;
return parseStatement();
case VARIABLE:
case IMPORT:
case CLASS:
case ENUM:
case ANNOTATION_TYPE:
case INTERFACE:
case METHOD:
return parseDeclaration();
default :
return error();
}
}"
76844,"public Completeness parseDeclaration(){
  boolean isImport=token.kind == IMPORT;
  while (token.kind.isDeclaration()) {
    nextToken();
  }
switch (token.kind) {
case EQ:
    nextToken();
  if (token.kind == BRACES) {
    nextToken();
    return lastly(SEMI);
  }
return parseExpressionStatement();
case BRACES:
case SEMI:
nextToken();
return Completeness.COMPLETE;
case UNMATCHED:
nextToken();
return Completeness.DEFINITELY_INCOMPLETE;
case EOF:
switch (in.prevCT.kind) {
case BRACES:
case SEMI:
return Completeness.COMPLETE;
case IDENTIFIER:
case BRACKETS:
return Completeness.COMPLETE_WITH_SEMI;
case STAR:
if (isImport) {
return Completeness.COMPLETE_WITH_SEMI;
}
 else {
return Completeness.DEFINITELY_INCOMPLETE;
}
default :
return Completeness.DEFINITELY_INCOMPLETE;
}
default :
return error();
}
}","public Completeness parseDeclaration(){
  boolean isImport=token.kind == IMPORT;
  while (token.kind.isDeclaration()) {
    nextToken();
  }
switch (token.kind) {
case EQ:
    nextToken();
  if (token.kind == BRACES) {
    nextToken();
    return lastly(SEMI);
  }
return parseExpressionStatement();
case BRACES:
case SEMI:
nextToken();
return Completeness.COMPLETE;
case UNMATCHED:
nextToken();
return Completeness.DEFINITELY_INCOMPLETE;
case EOF:
switch (in.prevCT.kind) {
case BRACES:
case SEMI:
return Completeness.COMPLETE;
case IDENTIFIER:
case BRACKETS:
return Completeness.COMPLETE_WITH_SEMI;
case DOTSTAR:
if (isImport) {
return Completeness.COMPLETE_WITH_SEMI;
}
 else {
return Completeness.UNKNOWN;
}
default :
return Completeness.DEFINITELY_INCOMPLETE;
}
default :
return error();
}
}"
76845,"Parser(Matched in,JShell proc,String scannedInput){
  this.in=in;
  nextToken();
  this.proc=proc;
  this.scannedInput=scannedInput;
}","Parser(Supplier<Matched> matchedFactory,Supplier<ParseTask> parseFactory){
  this.matchedFactory=matchedFactory;
  this.parseFactory=parseFactory;
  resetInput();
}"
76846,"void TK(TokenKind tokenKind,int b){
  this.tokenKind=tokenKind;
  this.belongs=b;
}","void TK(TokenKind tokenKind,int b){
  this.tokenKind=tokenKind;
  this.belongs=b;
  this.mapping=null;
}"
76847,"/** 
 * Utility routine to check if the InetAddress in a wildcard address.
 * @return a {@code boolean} indicating if the Inetaddress isa wildcard address.
 * @since 1.4
 */
public boolean isAnyLocalAddress(){
  return holder().getAddress() == 0;
}","/** 
 * Utility routine to check if the InetAddress is a wildcard address.
 * @return a {@code boolean} indicating if the Inetaddress isa wildcard address.
 * @since 1.4
 */
public boolean isAnyLocalAddress(){
  return holder().getAddress() == 0;
}"
76848,"/** 
 * Utility routine to check if the InetAddress in a wildcard address.
 * @return a {@code boolean} indicating if the Inetaddress isa wildcard address.
 * @since 1.4
 */
@Override public boolean isAnyLocalAddress(){
  return holder6.isAnyLocalAddress();
}","/** 
 * Utility routine to check if the InetAddress is a wildcard address.
 * @return a {@code boolean} indicating if the Inetaddress isa wildcard address.
 * @since 1.4
 */
@Override public boolean isAnyLocalAddress(){
  return holder6.isAnyLocalAddress();
}"
76849,"/** 
 * Utility routine to check if the InetAddress in a wildcard address.
 * @return a {@code boolean} indicating if the Inetaddress isa wildcard address.
 * @since 1.4
 */
public boolean isAnyLocalAddress(){
  return false;
}","/** 
 * Utility routine to check if the InetAddress is a wildcard address.
 * @return a {@code boolean} indicating if the Inetaddress isa wildcard address.
 * @since 1.4
 */
public boolean isAnyLocalAddress(){
  return false;
}"
76850,"/** 
 * Returns an input stream for this socket. <p> If this socket has an associated channel then the resulting input stream delegates all of its operations to the channel.  If the channel is in non-blocking mode then the input stream's   {@code read} operationswill throw an  {@link java.nio.channels.IllegalBlockingModeException}. <p>Under abnormal conditions the underlying connection may be broken by the remote host or the network software (for example a connection reset in the case of TCP connections). When a broken connection is detected by the network software the following applies to the returned input stream :- <ul> <li><p>The network software may discard bytes that are buffered by the socket. Bytes that aren't discarded by the network software can be read using   {@link java.io.InputStream#read read}. <li><p>If there are no bytes buffered on the socket, or all buffered bytes have been consumed by  {@link java.io.InputStream#read read}, then all subsequent calls to   {@link java.io.InputStream#read read} will throw an{@link java.io.IOException IOException}. <li><p>If there are no bytes buffered on the socket, and the socket has not been closed using   {@link #close close}, then  {@link java.io.InputStream#available available} willreturn  {@code 0}. </ul> <p> Closing the returned   {@link java.io.InputStream InputStream}will close the associated socket.
 * @return     an input stream for reading bytes from this socket.
 * @exception IOException  if an I/O error occurs when creating theinput stream, the socket is closed, the socket is not connected, or the socket input has been shutdown using  {@link #shutdownInput()}
 * @revised 1.4
 * @spec JSR-51
 */
public InputStream getInputStream() throws IOException {
  if (isClosed())   throw new SocketException(""String_Node_Str"");
  if (!isConnected())   throw new SocketException(""String_Node_Str"");
  if (isInputShutdown())   throw new SocketException(""String_Node_Str"");
  final Socket s=this;
  InputStream is=null;
  try {
    is=AccessController.doPrivileged(new PrivilegedExceptionAction<>(){
      public InputStream run() throws IOException {
        return impl.getInputStream();
      }
    }
);
  }
 catch (  java.security.PrivilegedActionException e) {
    throw (IOException)e.getException();
  }
  return is;
}","/** 
 * Returns an input stream for this socket. <p> If this socket has an associated channel then the resulting input stream delegates all of its operations to the channel.  If the channel is in non-blocking mode then the input stream's   {@code read} operationswill throw an  {@link java.nio.channels.IllegalBlockingModeException}. <p>Under abnormal conditions the underlying connection may be broken by the remote host or the network software (for example a connection reset in the case of TCP connections). When a broken connection is detected by the network software the following applies to the returned input stream :- <ul> <li><p>The network software may discard bytes that are buffered by the socket. Bytes that aren't discarded by the network software can be read using   {@link java.io.InputStream#read read}. <li><p>If there are no bytes buffered on the socket, or all buffered bytes have been consumed by  {@link java.io.InputStream#read read}, then all subsequent calls to   {@link java.io.InputStream#read read} will throw an{@link java.io.IOException IOException}. <li><p>If there are no bytes buffered on the socket, and the socket has not been closed using   {@link #close close}, then  {@link java.io.InputStream#available available} willreturn  {@code 0}. </ul> <p> Closing the returned   {@link java.io.InputStream InputStream}will close the associated socket.
 * @return     an input stream for reading bytes from this socket.
 * @exception IOException  if an I/O error occurs when creating theinput stream, the socket is closed, the socket is not connected, or the socket input has been shutdown using  {@link #shutdownInput()}
 * @revised 1.4
 * @spec JSR-51
 */
public InputStream getInputStream() throws IOException {
  if (isClosed())   throw new SocketException(""String_Node_Str"");
  if (!isConnected())   throw new SocketException(""String_Node_Str"");
  if (isInputShutdown())   throw new SocketException(""String_Node_Str"");
  InputStream is=null;
  try {
    is=AccessController.doPrivileged(new PrivilegedExceptionAction<>(){
      public InputStream run() throws IOException {
        return impl.getInputStream();
      }
    }
);
  }
 catch (  java.security.PrivilegedActionException e) {
    throw (IOException)e.getException();
  }
  return is;
}"
76851,"/** 
 * Returns an output stream for this socket. <p> If this socket has an associated channel then the resulting output stream delegates all of its operations to the channel.  If the channel is in non-blocking mode then the output stream's   {@code write}operations will throw an   {@link java.nio.channels.IllegalBlockingModeException}. <p> Closing the returned   {@link java.io.OutputStream OutputStream}will close the associated socket.
 * @return     an output stream for writing bytes to this socket.
 * @exception IOException  if an I/O error occurs when creating theoutput stream or if the socket is not connected.
 * @revised 1.4
 * @spec JSR-51
 */
public OutputStream getOutputStream() throws IOException {
  if (isClosed())   throw new SocketException(""String_Node_Str"");
  if (!isConnected())   throw new SocketException(""String_Node_Str"");
  if (isOutputShutdown())   throw new SocketException(""String_Node_Str"");
  final Socket s=this;
  OutputStream os=null;
  try {
    os=AccessController.doPrivileged(new PrivilegedExceptionAction<>(){
      public OutputStream run() throws IOException {
        return impl.getOutputStream();
      }
    }
);
  }
 catch (  java.security.PrivilegedActionException e) {
    throw (IOException)e.getException();
  }
  return os;
}","/** 
 * Returns an output stream for this socket. <p> If this socket has an associated channel then the resulting output stream delegates all of its operations to the channel.  If the channel is in non-blocking mode then the output stream's   {@code write}operations will throw an   {@link java.nio.channels.IllegalBlockingModeException}. <p> Closing the returned   {@link java.io.OutputStream OutputStream}will close the associated socket.
 * @return     an output stream for writing bytes to this socket.
 * @exception IOException  if an I/O error occurs when creating theoutput stream or if the socket is not connected.
 * @revised 1.4
 * @spec JSR-51
 */
public OutputStream getOutputStream() throws IOException {
  if (isClosed())   throw new SocketException(""String_Node_Str"");
  if (!isConnected())   throw new SocketException(""String_Node_Str"");
  if (isOutputShutdown())   throw new SocketException(""String_Node_Str"");
  OutputStream os=null;
  try {
    os=AccessController.doPrivileged(new PrivilegedExceptionAction<>(){
      public OutputStream run() throws IOException {
        return impl.getOutputStream();
      }
    }
);
  }
 catch (  java.security.PrivilegedActionException e) {
    throw (IOException)e.getException();
  }
  return os;
}"
76852,"/** 
 * extract the root name from a versioned entry name given inode for META-INF/versions/9/foo/bar.class and prefix META-INF/versions/9/ returns foo/bar.class
 */
private byte[] getRootName(IndexNode prefix,IndexNode inode){
  int offset=prefix.name.length;
  byte[] fullName=inode.name;
  return Arrays.copyOfRange(fullName,offset,fullName.length);
}","/** 
 * extract the root name from a versioned entry name given inode for META-INF/versions/9/foo/bar.class and prefix META-INF/versions/9/ returns foo/bar.class
 */
private byte[] getRootName(IndexNode prefix,IndexNode inode){
  int offset=prefix.name.length - 1;
  byte[] fullName=inode.name;
  return Arrays.copyOfRange(fullName,offset,fullName.length);
}"
76853,"public int method(){
  return e.method;
}",public int method();
76854,"public long compressedSize(){
  return e.csize;
}",public long compressedSize();
76855,"public long crc(){
  return e.crc;
}",public long crc();
76856,"public byte[] extra(){
  if (e.extra != null)   return Arrays.copyOf(e.extra,e.extra.length);
  return null;
}",public byte[] extra();
76857,"public byte[] comment(){
  if (e.comment != null)   return Arrays.copyOf(e.comment,e.comment.length);
  return null;
}",public byte[] comment();
76858,"public String toString(){
  StringBuilder sb=new StringBuilder(1024);
  Formatter fm=new Formatter(sb);
  if (creationTime() != null)   fm.format(""String_Node_Str"",creationTime().toMillis());
 else   fm.format(""String_Node_Str"");
  if (lastAccessTime() != null)   fm.format(""String_Node_Str"",lastAccessTime().toMillis());
 else   fm.format(""String_Node_Str"");
  fm.format(""String_Node_Str"",lastModifiedTime().toMillis());
  fm.format(""String_Node_Str"",isRegularFile());
  fm.format(""String_Node_Str"",isDirectory());
  fm.format(""String_Node_Str"",isSymbolicLink());
  fm.format(""String_Node_Str"",isOther());
  fm.format(""String_Node_Str"",fileKey());
  fm.format(""String_Node_Str"",size());
  fm.format(""String_Node_Str"",compressedSize());
  fm.format(""String_Node_Str"",crc());
  fm.format(""String_Node_Str"",method());
  fm.close();
  return sb.toString();
}",public String toString();
76859,"@Override <V extends Number,A>Future<V> implRead(boolean isScatteringRead,ByteBuffer dst,ByteBuffer[] dsts,long timeout,TimeUnit unit,A attachment,CompletionHandler<V,? super A> handler){
  PendingFuture<V,A> result=new PendingFuture<V,A>(this,handler,attachment);
  ByteBuffer[] bufs;
  if (isScatteringRead) {
    bufs=dsts;
  }
 else {
    bufs=new ByteBuffer[1];
    bufs[0]=dst;
  }
  final ReadTask<V,A> readTask=new ReadTask<V,A>(bufs,isScatteringRead,result);
  result.setContext(readTask);
  if (timeout > 0L) {
    Future<?> timeoutTask=iocp.schedule(new Runnable(){
      public void run(){
        readTask.timeout();
      }
    }
,timeout,unit);
    result.setTimeoutTask(timeoutTask);
  }
  if (Iocp.supportsThreadAgnosticIo()) {
    readTask.run();
  }
 else {
    Invoker.invokeOnThreadInThreadPool(this,readTask);
  }
  return result;
}","@Override <V extends Number,A>Future<V> implRead(boolean isScatteringRead,ByteBuffer dst,ByteBuffer[] dsts,long timeout,TimeUnit unit,A attachment,CompletionHandler<V,? super A> handler){
  PendingFuture<V,A> result=new PendingFuture<V,A>(this,handler,attachment);
  ByteBuffer[] bufs;
  if (isScatteringRead) {
    bufs=dsts;
  }
 else {
    bufs=new ByteBuffer[1];
    bufs[0]=dst;
  }
  final ReadTask<V,A> readTask=new ReadTask<V,A>(bufs,isScatteringRead,result);
  result.setContext(readTask);
  if (timeout > 0L) {
    Future<?> timeoutTask=iocp.schedule(new Runnable(){
      public void run(){
        readTask.timeout();
      }
    }
,timeout,unit);
    result.setTimeoutTask(timeoutTask);
  }
  readTask.run();
  return result;
}"
76860,"@Override <V extends Number,A>Future<V> implWrite(boolean gatheringWrite,ByteBuffer src,ByteBuffer[] srcs,long timeout,TimeUnit unit,A attachment,CompletionHandler<V,? super A> handler){
  PendingFuture<V,A> result=new PendingFuture<V,A>(this,handler,attachment);
  ByteBuffer[] bufs;
  if (gatheringWrite) {
    bufs=srcs;
  }
 else {
    bufs=new ByteBuffer[1];
    bufs[0]=src;
  }
  final WriteTask<V,A> writeTask=new WriteTask<V,A>(bufs,gatheringWrite,result);
  result.setContext(writeTask);
  if (timeout > 0L) {
    Future<?> timeoutTask=iocp.schedule(new Runnable(){
      public void run(){
        writeTask.timeout();
      }
    }
,timeout,unit);
    result.setTimeoutTask(timeoutTask);
  }
  if (Iocp.supportsThreadAgnosticIo()) {
    writeTask.run();
  }
 else {
    Invoker.invokeOnThreadInThreadPool(this,writeTask);
  }
  return result;
}","@Override <V extends Number,A>Future<V> implWrite(boolean gatheringWrite,ByteBuffer src,ByteBuffer[] srcs,long timeout,TimeUnit unit,A attachment,CompletionHandler<V,? super A> handler){
  PendingFuture<V,A> result=new PendingFuture<V,A>(this,handler,attachment);
  ByteBuffer[] bufs;
  if (gatheringWrite) {
    bufs=srcs;
  }
 else {
    bufs=new ByteBuffer[1];
    bufs[0]=src;
  }
  final WriteTask<V,A> writeTask=new WriteTask<V,A>(bufs,gatheringWrite,result);
  result.setContext(writeTask);
  if (timeout > 0L) {
    Future<?> timeoutTask=iocp.schedule(new Runnable(){
      public void run(){
        writeTask.timeout();
      }
    }
,timeout,unit);
    result.setTimeoutTask(timeoutTask);
  }
  writeTask.run();
  return result;
}"
76861,"/** 
 * Constructs an instance with the given file descriptor.
 */
PlainSocketImpl(FileDescriptor fd){
  if (useDualStackImpl) {
    impl=new DualStackPlainSocketImpl(fd,exclusiveBind);
  }
 else {
    impl=new TwoStacksPlainSocketImpl(fd,exclusiveBind);
  }
}","/** 
 * Constructs an instance with the given file descriptor.
 */
PlainSocketImpl(FileDescriptor fd){
  if (!preferIPv4Stack) {
    impl=new DualStackPlainSocketImpl(fd,exclusiveBind);
  }
 else {
    impl=new TwoStacksPlainSocketImpl(fd,exclusiveBind);
  }
}"
76862,"@Override public Type add(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    method.visitInsn(IADD);
  }
 else {
    method.visitInvokeDynamicInsn(""String_Node_Str"",""String_Node_Str"",MATHBOOTSTRAP,programPoint);
  }
  return INT;
}","@Override public Type add(final MethodVisitor method,final int programPoint){
  return Type.INT.add(method,programPoint);
}"
76863,"@Override public Type add(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    method.visitInsn(IADD);
  }
 else {
    method.visitInvokeDynamicInsn(""String_Node_Str"",""String_Node_Str"",MATHBOOTSTRAP,programPoint);
  }
  return INT;
}","@Override public Type add(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    method.visitInsn(IADD);
  }
 else {
    ldc(method,programPoint);
    JSType.ADD_EXACT.invoke(method);
  }
  return INT;
}"
76864,"@Override public Type sub(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    method.visitInsn(ISUB);
  }
 else {
    method.visitInvokeDynamicInsn(""String_Node_Str"",""String_Node_Str"",MATHBOOTSTRAP,programPoint);
  }
  return INT;
}","@Override public Type sub(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    method.visitInsn(ISUB);
  }
 else {
    ldc(method,programPoint);
    JSType.SUB_EXACT.invoke(method);
  }
  return INT;
}"
76865,"@Override public Type mul(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    method.visitInsn(IMUL);
  }
 else {
    method.visitInvokeDynamicInsn(""String_Node_Str"",""String_Node_Str"",MATHBOOTSTRAP,programPoint);
  }
  return INT;
}","@Override public Type mul(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    method.visitInsn(IMUL);
  }
 else {
    ldc(method,programPoint);
    JSType.MUL_EXACT.invoke(method);
  }
  return INT;
}"
76866,"@Override public Type div(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    JSType.DIV_ZERO.invoke(method);
  }
 else {
    method.visitInvokeDynamicInsn(""String_Node_Str"",""String_Node_Str"",MATHBOOTSTRAP,programPoint);
  }
  return INT;
}","@Override public Type div(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    JSType.DIV_ZERO.invoke(method);
  }
 else {
    ldc(method,programPoint);
    JSType.DIV_EXACT.invoke(method);
  }
  return INT;
}"
76867,"@Override public Type neg(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    method.visitInsn(INEG);
  }
 else {
    method.visitInvokeDynamicInsn(""String_Node_Str"",""String_Node_Str"",MATHBOOTSTRAP,programPoint);
  }
  return INT;
}","@Override public Type neg(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    method.visitInsn(INEG);
  }
 else {
    ldc(method,programPoint);
    JSType.NEGATE_EXACT.invoke(method);
  }
  return INT;
}"
76868,"@Override public Type rem(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    JSType.REM_ZERO.invoke(method);
  }
 else {
    method.visitInvokeDynamicInsn(""String_Node_Str"",""String_Node_Str"",MATHBOOTSTRAP,programPoint);
  }
  return INT;
}","@Override public Type rem(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    JSType.REM_ZERO.invoke(method);
  }
 else {
    ldc(method,programPoint);
    JSType.REM_EXACT.invoke(method);
  }
  return INT;
}"
76869,"@Override public Type add(final MethodVisitor method,final int programPoint){
  if (programPoint == INVALID_PROGRAM_POINT) {
    method.visitInsn(LADD);
  }
 else {
    method.visitInvokeDynamicInsn(""String_Node_Str"",""String_Node_Str"",MATHBOOTSTRAP,programPoint);
  }
  return LONG;
}","@Override public Type add(final MethodVisitor method,final int programPoint){
  throw new UnsupportedOperationException(""String_Node_Str"");
}"
76870,"/** 
 * Get the next XMLEvent
 * @see XMLEvent
 * @throws XMLStreamException if there is an error with the underlying XML.
 * @throws NoSuchElementException iteration has no more elements.
 */
public XMLEvent nextEvent() throws XMLStreamException ;","/** 
 * Get the next XMLEvent
 * @see XMLEvent
 * @throws XMLStreamException if there is an error with the underlying XML.
 * @throws java.util.NoSuchElementException iteration has no more elements.
 */
public XMLEvent nextEvent() throws XMLStreamException ;"
76871,"/** 
 * This method will write the XMLEvent as per the XML 1.0 specification as Unicode characters. No indentation or whitespace should be outputted. Any user defined event type SHALL have this method called when being written to on an output stream. Built in Event types MUST implement this method, but implementations MAY choose not call these methods for optimizations reasons when writing out built in Events to an output stream. The output generated MUST be equivalent in terms of the infoset expressed.
 * @param writer The writer that will output the data
 * @throws XMLStreamException if there is a fatal error writing the event
 */
public void writeAsEncodedUnicode(Writer writer) throws javax.xml.stream.XMLStreamException ;","/** 
 * This method will write the XMLEvent as per the XML 1.0 specification as Unicode characters. No indentation or whitespace should be outputted. Any user defined event type SHALL have this method called when being written to on an output stream. Built in Event types MUST implement this method, but implementations MAY choose not call these methods for optimizations reasons when writing out built in Events to an output stream. The output generated MUST be equivalent in terms of the infoset expressed.
 * @param writer The writer that will output the data
 * @throws javax.xml.stream.XMLStreamException if there is a fatal error writing the event
 */
public void writeAsEncodedUnicode(Writer writer) throws javax.xml.stream.XMLStreamException ;"
76872,"/** 
 * Transmits a control command to the terminal device. <p>This can be used to, for example, control terminal functions like a built-in PIN pad or biometrics.
 * @param controlCode the control code of the command
 * @param command the command data
 * @throws SecurityException if a SecurityManager exists and thecaller does not have the required {@linkplain CardPermission permission}
 * @throws NullPointerException if command is null
 * @throws CardException if the card operation failed
 * @throws IllegalStateException if this card object has been disposed ofvia the  {@linkplain #disconnect disconnect()} method
 */
public abstract byte[] transmitControlCommand(int controlCode,byte[] command) throws CardException ;","/** 
 * Transmits a control command to the terminal device. <p>This can be used to, for example, control terminal functions like a built-in PIN pad or biometrics.
 * @param controlCode the control code of the command
 * @param command the command data
 * @return the response from the terminal device
 * @throws SecurityException if a SecurityManager exists and thecaller does not have the required {@linkplain CardPermission permission}
 * @throws NullPointerException if command is null
 * @throws CardException if the card operation failed
 * @throws IllegalStateException if this card object has been disposed ofvia the  {@linkplain #disconnect disconnect()} method
 */
public abstract byte[] transmitControlCommand(int controlCode,byte[] command) throws CardException ;"
76873,"/** 
 * Returns the CardChannel for the basic logical channel. The basic logical channel has a channel number of 0.
 * @throws SecurityException if a SecurityManager exists and thecaller does not have the required {@linkplain CardPermission permission}
 * @throws IllegalStateException if this card object has been disposed ofvia the  {@linkplain #disconnect disconnect()} method
 */
public abstract CardChannel getBasicChannel();","/** 
 * Returns the CardChannel for the basic logical channel. The basic logical channel has a channel number of 0.
 * @return the CardChannel for the basic logical channel
 * @throws SecurityException if a SecurityManager exists and thecaller does not have the required {@linkplain CardPermission permission}
 * @throws IllegalStateException if this card object has been disposed ofvia the  {@linkplain #disconnect disconnect()} method
 */
public abstract CardChannel getBasicChannel();"
76874,"/** 
 * Opens a new logical channel to the card and returns it. The channel is opened by issuing a <code>MANAGE CHANNEL</code> command that should use the format <code>[00 70 00 00 01]</code>.
 * @throws SecurityException if a SecurityManager exists and thecaller does not have the required {@linkplain CardPermission permission}
 * @throws CardException is a new logical channel could not be opened
 * @throws IllegalStateException if this card object has been disposed ofvia the  {@linkplain #disconnect disconnect()} method
 */
public abstract CardChannel openLogicalChannel() throws CardException ;","/** 
 * Opens a new logical channel to the card and returns it. The channel is opened by issuing a <code>MANAGE CHANNEL</code> command that should use the format <code>[00 70 00 00 01]</code>.
 * @return the logical channel which has been opened
 * @throws SecurityException if a SecurityManager exists and thecaller does not have the required {@linkplain CardPermission permission}
 * @throws CardException is a new logical channel could not be opened
 * @throws IllegalStateException if this card object has been disposed ofvia the  {@linkplain #disconnect disconnect()} method
 */
public abstract CardChannel openLogicalChannel() throws CardException ;"
76875,"/** 
 * Establishes a connection to the card. If a connection has previously established using the specified protocol, this method returns the same Card object as the previous call.
 * @param protocol the protocol to use (""T=0"", ""T=1"", or ""T=CL""), or ""*"" toconnect using any available protocol.
 * @throws NullPointerException if protocol is null
 * @throws IllegalArgumentException if protocol is an invalid protocolspecification
 * @throws CardNotPresentException if no card is present in this terminal
 * @throws CardException if a connection could not be establishedusing the specified protocol or if a connection has previously been established using a different protocol
 * @throws SecurityException if a SecurityManager exists and thecaller does not have the required {@linkplain CardPermission permission}
 */
public abstract Card connect(String protocol) throws CardException ;","/** 
 * Establishes a connection to the card. If a connection has previously established using the specified protocol, this method returns the same Card object as the previous call.
 * @param protocol the protocol to use (""T=0"", ""T=1"", or ""T=CL""), or ""*"" toconnect using any available protocol.
 * @throws NullPointerException if protocol is null
 * @throws IllegalArgumentException if protocol is an invalid protocolspecification
 * @throws CardNotPresentException if no card is present in this terminal
 * @throws CardException if a connection could not be establishedusing the specified protocol or if a connection has previously been established using a different protocol
 * @throws SecurityException if a SecurityManager exists and thecaller does not have the required {@linkplain CardPermission permission}
 * @return the card the connection has been established with
 */
public abstract Card connect(String protocol) throws CardException ;"
76876,"/** 
 * Returns the terminal with the specified name or null if no such terminal exists.
 * @return the terminal with the specified name or null if no suchterminal exists.
 * @throws NullPointerException if name is null
 */
public CardTerminal getTerminal(String name){
  if (name == null) {
    throw new NullPointerException();
  }
  try {
    for (    CardTerminal terminal : list()) {
      if (terminal.getName().equals(name)) {
        return terminal;
      }
    }
    return null;
  }
 catch (  CardException e) {
    return null;
  }
}","/** 
 * Returns the terminal with the specified name or null if no such terminal exists.
 * @param name the terminal name
 * @return the terminal with the specified name or null if no suchterminal exists.
 * @throws NullPointerException if name is null
 */
public CardTerminal getTerminal(String name){
  if (name == null) {
    throw new NullPointerException();
  }
  try {
    for (    CardTerminal terminal : list()) {
      if (terminal.getName().equals(name)) {
        return terminal;
      }
    }
    return null;
  }
 catch (  CardException e) {
    return null;
  }
}"
76877,"/** 
 * displays a dialog box describing an error which occurred.
 */
void displayErrorDialog(Window w,Throwable t){
  if (t instanceof NoDisplayException) {
    return;
  }
  displayErrorDialog(w,t.toString());
}","/** 
 * displays a dialog box describing an error which occurred.
 */
void displayErrorDialog(Window w,Throwable t){
  if (t instanceof NoDisplayException) {
    return;
  }
  if (t.getClass() == Exception.class) {
    displayErrorDialog(w,t.getLocalizedMessage());
  }
 else {
    displayErrorDialog(w,t.toString());
  }
}"
76878,"/** 
 * Returns an array of all the objects currently registered as <code><em>Foo</em>Listener</code>s upon this model. <code><em>Foo</em>Listener</code>s are registered using the <code>add<em>Foo</em>Listener</code> method. <p> You can specify the <code>listenerType</code> argument with a class literal, such as <code><em>Foo</em>Listener.class</code>. For example, you can query a list model <code>m</code> for its list data listeners with the following code: <pre>ListDataListener[] ldls = (ListDataListener[])(m.getListeners(ListDataListener.class));</pre> If no such listeners exist, this method returns an empty array.
 * @param listenerType  the type of listeners requested;this parameter should specify an interface that descends from <code>java.util.EventListener</code>
 * @return an array of all objects registered as<code><em>Foo</em>Listener</code>s on this model, or an empty array if no such listeners have been added
 * @exception ClassCastException if <code>listenerType</code> doesn'tspecify a class or interface that implements <code>java.util.EventListener</code>
 * @see #getListDataListeners
 * @since 1.3
 */
public <T extends EventListener>T[] getListeners(Class<T> listenerType){
  return listenerList.getListeners(listenerType);
}","/** 
 * Returns an array of all the objects currently registered as <code><em>Foo</em>Listener</code>s upon this model. <code><em>Foo</em>Listener</code>s are registered using the <code>add<em>Foo</em>Listener</code> method. <p> You can specify the <code>listenerType</code> argument with a class literal, such as <code><em>Foo</em>Listener.class</code>. For example, you can query a list model <code>m</code> for its list data listeners with the following code: <pre>ListDataListener[] ldls = (ListDataListener[])(m.getListeners(ListDataListener.class));</pre> If no such listeners exist, this method returns an empty array.
 * @param < T > the type of {@code EventListener} class being requested
 * @param listenerType  the type of listeners requested;this parameter should specify an interface that descends from <code>java.util.EventListener</code>
 * @return an array of all objects registered as<code><em>Foo</em>Listener</code>s on this model, or an empty array if no such listeners have been added
 * @exception ClassCastException if <code>listenerType</code> doesn'tspecify a class or interface that implements <code>java.util.EventListener</code>
 * @see #getListDataListeners
 * @since 1.3
 */
public <T extends EventListener>T[] getListeners(Class<T> listenerType){
  return listenerList.getListeners(listenerType);
}"
76879,"/** 
 * Returns true to indicate that editing has begun.
 * @param anEvent          the event
 */
public boolean startCellEditing(EventObject anEvent){
  return true;
}","/** 
 * Returns true to indicate that editing has begun.
 * @param anEvent          the event
 * @return true to indicate editing has begun
 */
public boolean startCellEditing(EventObject anEvent){
  return true;
}"
76880,"/** 
 * Sets that the component has been iconized and the bounds of the <code>desktopIcon</code> are valid.
 */
protected void setWasIcon(JInternalFrame f,Boolean value){
  if (value != null) {
    f.putClientProperty(HAS_BEEN_ICONIFIED_PROPERTY,value);
  }
}","/** 
 * Sets that the component has been iconized and the bounds of the <code>desktopIcon</code> are valid.
 * @param f     the {@code JInternalFrame} of interest
 * @param value a {@code Boolean} signifying if component has been iconized
 */
protected void setWasIcon(JInternalFrame f,Boolean value){
  if (value != null) {
    f.putClientProperty(HAS_BEEN_ICONIFIED_PROPERTY,value);
  }
}"
76881,"/** 
 * Convenience method to remove the desktopIcon of <b>f</b> is necessary. 
 */
protected void removeIconFor(JInternalFrame f){
  JInternalFrame.JDesktopIcon di=f.getDesktopIcon();
  Container c=di.getParent();
  if (c != null) {
    c.remove(di);
    c.repaint(di.getX(),di.getY(),di.getWidth(),di.getHeight());
  }
}","/** 
 * Convenience method to remove the desktopIcon of <b>f</b> is necessary.
 * @param f the {@code JInternalFrame} for which to remove the{@code desktopIcon}
 */
protected void removeIconFor(JInternalFrame f){
  JInternalFrame.JDesktopIcon di=f.getDesktopIcon();
  Container c=di.getParent();
  if (c != null) {
    c.remove(di);
    c.repaint(di.getX(),di.getY(),di.getWidth(),di.getHeight());
  }
}"
76882,"/** 
 * The iconifyFrame() code calls this to determine the proper bounds for the desktopIcon.
 */
protected Rectangle getBoundsForIconOf(JInternalFrame f){
  JInternalFrame.JDesktopIcon icon=f.getDesktopIcon();
  Dimension prefSize=icon.getPreferredSize();
  Container c=f.getParent();
  if (c == null) {
    c=f.getDesktopIcon().getParent();
  }
  if (c == null) {
    return new Rectangle(0,0,prefSize.width,prefSize.height);
  }
  Rectangle parentBounds=c.getBounds();
  Component[] components=c.getComponents();
  Rectangle availableRectangle=null;
  JInternalFrame.JDesktopIcon currentIcon=null;
  int x=0;
  int y=parentBounds.height - prefSize.height;
  int w=prefSize.width;
  int h=prefSize.height;
  boolean found=false;
  while (!found) {
    availableRectangle=new Rectangle(x,y,w,h);
    found=true;
    for (int i=0; i < components.length; i++) {
      if (components[i] instanceof JInternalFrame) {
        currentIcon=((JInternalFrame)components[i]).getDesktopIcon();
      }
 else       if (components[i] instanceof JInternalFrame.JDesktopIcon) {
        currentIcon=(JInternalFrame.JDesktopIcon)components[i];
      }
 else       continue;
      if (!currentIcon.equals(icon)) {
        if (availableRectangle.intersects(currentIcon.getBounds())) {
          found=false;
          break;
        }
      }
    }
    if (currentIcon == null)     return availableRectangle;
    x+=currentIcon.getBounds().width;
    if (x + w > parentBounds.width) {
      x=0;
      y-=h;
    }
  }
  return (availableRectangle);
}","/** 
 * The   {@code iconifyFrame()} code calls this to determine the proper boundsfor the desktopIcon.
 * @param f the {@code JInternalFrame} of interest
 * @return a {@code Rectangle} containing bounds for the {@code desktopIcon}
 */
protected Rectangle getBoundsForIconOf(JInternalFrame f){
  JInternalFrame.JDesktopIcon icon=f.getDesktopIcon();
  Dimension prefSize=icon.getPreferredSize();
  Container c=f.getParent();
  if (c == null) {
    c=f.getDesktopIcon().getParent();
  }
  if (c == null) {
    return new Rectangle(0,0,prefSize.width,prefSize.height);
  }
  Rectangle parentBounds=c.getBounds();
  Component[] components=c.getComponents();
  Rectangle availableRectangle=null;
  JInternalFrame.JDesktopIcon currentIcon=null;
  int x=0;
  int y=parentBounds.height - prefSize.height;
  int w=prefSize.width;
  int h=prefSize.height;
  boolean found=false;
  while (!found) {
    availableRectangle=new Rectangle(x,y,w,h);
    found=true;
    for (int i=0; i < components.length; i++) {
      if (components[i] instanceof JInternalFrame) {
        currentIcon=((JInternalFrame)components[i]).getDesktopIcon();
      }
 else       if (components[i] instanceof JInternalFrame.JDesktopIcon) {
        currentIcon=(JInternalFrame.JDesktopIcon)components[i];
      }
 else       continue;
      if (!currentIcon.equals(icon)) {
        if (availableRectangle.intersects(currentIcon.getBounds())) {
          found=false;
          break;
        }
      }
    }
    if (currentIcon == null)     return availableRectangle;
    x+=currentIcon.getBounds().width;
    if (x + w > parentBounds.width) {
      x=0;
      y-=h;
    }
  }
  return (availableRectangle);
}"
76883,"/** 
 * Returns the element at the specified position in this list. <p> Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is out of range (<code>index &lt; 0 || index &gt;= size()</code>).
 * @param index index of element to return
 */
public E get(int index){
  return delegate.elementAt(index);
}","/** 
 * Returns the element at the specified position in this list. <p> Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is out of range (<code>index &lt; 0 || index &gt;= size()</code>).
 * @param index index of element to return
 * @return the element at the specified position in this list
 */
public E get(int index){
  return delegate.elementAt(index);
}"
76884,"/** 
 * Returns an array of all the objects currently registered as <code><em>Foo</em>Listener</code>s upon this model. <code><em>Foo</em>Listener</code>s are registered using the <code>add<em>Foo</em>Listener</code> method. <p> You can specify the <code>listenerType</code> argument with a class literal, such as <code><em>Foo</em>Listener.class</code>. For example, you can query a <code>DefaultListSelectionModel</code> instance <code>m</code> for its list selection listeners with the following code: <pre>ListSelectionListener[] lsls = (ListSelectionListener[])(m.getListeners(ListSelectionListener.class));</pre> If no such listeners exist, this method returns an empty array.
 * @param listenerType  the type of listeners requested;this parameter should specify an interface that descends from <code>java.util.EventListener</code>
 * @return an array of all objects registered as<code><em>Foo</em>Listener</code>s on this model, or an empty array if no such listeners have been added
 * @exception ClassCastException if <code>listenerType</code> doesn'tspecify a class or interface that implements <code>java.util.EventListener</code>
 * @see #getListSelectionListeners
 * @since 1.3
 */
public <T extends EventListener>T[] getListeners(Class<T> listenerType){
  return listenerList.getListeners(listenerType);
}","/** 
 * Returns an array of all the objects currently registered as <code><em>Foo</em>Listener</code>s upon this model. <code><em>Foo</em>Listener</code>s are registered using the <code>add<em>Foo</em>Listener</code> method. <p> You can specify the <code>listenerType</code> argument with a class literal, such as <code><em>Foo</em>Listener.class</code>. For example, you can query a <code>DefaultListSelectionModel</code> instance <code>m</code> for its list selection listeners with the following code: <pre>ListSelectionListener[] lsls = (ListSelectionListener[])(m.getListeners(ListSelectionListener.class));</pre> If no such listeners exist, this method returns an empty array.
 * @param < T > the type of {@code EventListener} class being requested
 * @param listenerType  the type of listeners requested;this parameter should specify an interface that descends from <code>java.util.EventListener</code>
 * @return an array of all objects registered as<code><em>Foo</em>Listener</code>s on this model, or an empty array if no such listeners have been added
 * @exception ClassCastException if <code>listenerType</code> doesn'tspecify a class or interface that implements <code>java.util.EventListener</code>
 * @see #getListSelectionListeners
 * @since 1.3
 */
public <T extends EventListener>T[] getListeners(Class<T> listenerType){
  return listenerList.getListeners(listenerType);
}"
76885,"/** 
 * Sets the value of the leadAnchorNotificationEnabled flag.
 * @see #isLeadAnchorNotificationEnabled()
 */
public void setLeadAnchorNotificationEnabled(boolean flag){
  leadAnchorNotificationEnabled=flag;
}","/** 
 * Sets the value of the leadAnchorNotificationEnabled flag.
 * @param flag boolean value for {@code leadAnchorNotificationEnabled}
 * @see #isLeadAnchorNotificationEnabled()
 */
public void setLeadAnchorNotificationEnabled(boolean flag){
  leadAnchorNotificationEnabled=flag;
}"
76886,"/** 
 * Returns whether or not to convert the value to a string before doing comparisons when sorting.  If true <code>ModelWrapper.getStringValueAt</code> will be used, otherwise <code>ModelWrapper.getValueAt</code> will be used.  It is up to subclasses, such as <code>TableRowSorter</code>, to honor this value in their <code>ModelWrapper</code> implementation.
 * @param column the index of the column to test, in terms of theunderlying model
 * @throws IndexOutOfBoundsException if <code>column</code> is not valid
 */
protected boolean useToString(int column){
  return (getComparator(column) == null);
}","/** 
 * Returns whether or not to convert the value to a string before doing comparisons when sorting.  If true <code>ModelWrapper.getStringValueAt</code> will be used, otherwise <code>ModelWrapper.getValueAt</code> will be used.  It is up to subclasses, such as <code>TableRowSorter</code>, to honor this value in their <code>ModelWrapper</code> implementation.
 * @param column the index of the column to test, in terms of theunderlying model
 * @return true if values are to be converted to strings before doingcomparisons when sorting
 * @throws IndexOutOfBoundsException if <code>column</code> is not valid
 */
protected boolean useToString(int column){
  return (getComparator(column) == null);
}"
76887,"/** 
 * Gets this <code>InputMap</code>'s parent.
 * @return map  the <code>InputMap</code> that is the parent of this one,or null if this <code>InputMap</code> has no parent
 */
public InputMap getParent(){
  return parent;
}","/** 
 * Gets this   {@code InputMap}'s parent.
 * @return map the {@code InputMap} that is the parent of this one,or null if this  {@code InputMap} has no parent
 */
public InputMap getParent(){
  return parent;
}"
76888,"/** 
 * Returns the number of <code>KeyStroke</code> bindings.
 */
public int size(){
  if (arrayTable == null) {
    return 0;
  }
  return arrayTable.size();
}","/** 
 * Returns the number of   {@code KeyStroke} bindings.
 * @return the number of {@code KeyStroke} bindings
 */
public int size(){
  if (arrayTable == null) {
    return 0;
  }
  return arrayTable.size();
}"
76889,"/** 
 * Returns the <code>KeyStroke</code>s that are bound in this <code>InputMap</code>.
 */
public KeyStroke[] keys(){
  if (arrayTable == null) {
    return null;
  }
  KeyStroke[] keys=new KeyStroke[arrayTable.size()];
  arrayTable.getKeys(keys);
  return keys;
}","/** 
 * Returns the   {@code KeyStroke}s that are bound in this   {@code InputMap}.
 * @return an array of the {@code KeyStroke}s that are bound in this  {@code InputMap}
 */
public KeyStroke[] keys(){
  if (arrayTable == null) {
    return null;
  }
  KeyStroke[] keys=new KeyStroke[arrayTable.size()];
  arrayTable.getKeys(keys);
  return keys;
}"
76890,"/** 
 * Returns the binding for <code>keyStroke</code>, messaging the parent <code>InputMap</code> if the binding is not locally defined.
 */
public Object get(KeyStroke keyStroke){
  if (arrayTable == null) {
    InputMap parent=getParent();
    if (parent != null) {
      return parent.get(keyStroke);
    }
    return null;
  }
  Object value=arrayTable.get(keyStroke);
  if (value == null) {
    InputMap parent=getParent();
    if (parent != null) {
      return parent.get(keyStroke);
    }
  }
  return value;
}","/** 
 * Returns the binding for   {@code keyStroke}, messaging the parent   {@code InputMap} if the binding is not locally defined.
 * @param keyStroke the {@code KeyStroke} for which to get the binding
 * @return the binding for {@code keyStroke}
 */
public Object get(KeyStroke keyStroke){
  if (arrayTable == null) {
    InputMap parent=getParent();
    if (parent != null) {
      return parent.get(keyStroke);
    }
    return null;
  }
  Object value=arrayTable.get(keyStroke);
  if (value == null) {
    InputMap parent=getParent();
    if (parent != null) {
      return parent.get(keyStroke);
    }
  }
  return value;
}"
76891,"/** 
 * Removes all the mappings from this <code>InputMap</code>.
 */
public void clear(){
  if (arrayTable != null) {
    arrayTable.clear();
  }
}","/** 
 * Removes all the mappings from this   {@code InputMap}.
 */
public void clear(){
  if (arrayTable != null) {
    arrayTable.clear();
  }
}"
76892,"/** 
 * Returns an array of the <code>KeyStroke</code>s defined in this <code>InputMap</code> and its parent. This differs from <code>keys()</code> in that this method includes the keys defined in the parent.
 */
public KeyStroke[] allKeys(){
  int count=size();
  InputMap parent=getParent();
  if (count == 0) {
    if (parent != null) {
      return parent.allKeys();
    }
    return keys();
  }
  if (parent == null) {
    return keys();
  }
  KeyStroke[] keys=keys();
  KeyStroke[] pKeys=parent.allKeys();
  if (pKeys == null) {
    return keys;
  }
  if (keys == null) {
    return pKeys;
  }
  HashMap<KeyStroke,KeyStroke> keyMap=new HashMap<KeyStroke,KeyStroke>();
  int counter;
  for (counter=keys.length - 1; counter >= 0; counter--) {
    keyMap.put(keys[counter],keys[counter]);
  }
  for (counter=pKeys.length - 1; counter >= 0; counter--) {
    keyMap.put(pKeys[counter],pKeys[counter]);
  }
  KeyStroke[] allKeys=new KeyStroke[keyMap.size()];
  return keyMap.keySet().toArray(allKeys);
}","/** 
 * Returns an array of the   {@code KeyStroke}s defined in this  {@code InputMap} and its parent. This differs from {@code keys()}in that this method includes the keys defined in the parent.
 * @return an array of the {@code KeyStroke}s defined in this  {@code InputMap} and its parent
 */
public KeyStroke[] allKeys(){
  int count=size();
  InputMap parent=getParent();
  if (count == 0) {
    if (parent != null) {
      return parent.allKeys();
    }
    return keys();
  }
  if (parent == null) {
    return keys();
  }
  KeyStroke[] keys=keys();
  KeyStroke[] pKeys=parent.allKeys();
  if (pKeys == null) {
    return keys;
  }
  if (keys == null) {
    return pKeys;
  }
  HashMap<KeyStroke,KeyStroke> keyMap=new HashMap<KeyStroke,KeyStroke>();
  int counter;
  for (counter=keys.length - 1; counter >= 0; counter--) {
    keyMap.put(keys[counter],keys[counter]);
  }
  for (counter=pKeys.length - 1; counter >= 0; counter--) {
    keyMap.put(pKeys[counter],pKeys[counter]);
  }
  KeyStroke[] allKeys=new KeyStroke[keyMap.size()];
  return keyMap.keySet().toArray(allKeys);
}"
76893,"/** 
 * Creates an <code>InputMap</code> with no parent and no mappings.
 */
public InputMap(){
}","/** 
 * Creates an   {@code InputMap} with no parent and no mappings.
 */
public InputMap(){
}"
76894,"/** 
 * Sets this <code>InputMap</code>'s parent.
 * @param map  the <code>InputMap</code> that is the parent of this one
 */
public void setParent(InputMap map){
  this.parent=map;
}","/** 
 * Sets this   {@code InputMap}'s parent.
 * @param map the {@code InputMap} that is the parent of this one
 */
public void setParent(InputMap map){
  this.parent=map;
}"
76895,"/** 
 * Adds a binding for <code>keyStroke</code> to <code>actionMapKey</code>. If <code>actionMapKey</code> is null, this removes the current binding for <code>keyStroke</code>.
 */
public void put(KeyStroke keyStroke,Object actionMapKey){
  if (keyStroke == null) {
    return;
  }
  if (actionMapKey == null) {
    remove(keyStroke);
  }
 else {
    if (arrayTable == null) {
      arrayTable=new ArrayTable();
    }
    arrayTable.put(keyStroke,actionMapKey);
  }
}","/** 
 * Adds a binding for   {@code keyStroke} to {@code actionMapKey}. If   {@code actionMapKey} is null, this removes the current bindingfor  {@code keyStroke}.
 * @param keyStroke a {@code KeyStroke}
 * @param actionMapKey an action map key
 */
public void put(KeyStroke keyStroke,Object actionMapKey){
  if (keyStroke == null) {
    return;
  }
  if (actionMapKey == null) {
    remove(keyStroke);
  }
 else {
    if (arrayTable == null) {
      arrayTable=new ArrayTable();
    }
    arrayTable.put(keyStroke,actionMapKey);
  }
}"
76896,"/** 
 * Removes the binding for <code>key</code> from this <code>InputMap</code>.
 */
public void remove(KeyStroke key){
  if (arrayTable != null) {
    arrayTable.remove(key);
  }
}","/** 
 * Removes the binding for   {@code key} from this {@code InputMap}.
 * @param key the {@code KeyStroke} for which to remove the binding
 */
public void remove(KeyStroke key){
  if (arrayTable != null) {
    arrayTable.remove(key);
  }
}"
76897,"/** 
 * Returns the currently registered <code>EditorKit</code> class name for the type <code>type</code>.
 * @param type  the non-<code>null</code> content type
 * @since 1.3
 */
public static String getEditorKitClassNameForContentType(String type){
  return getKitTypeRegistry().get(type);
}","/** 
 * Returns the currently registered   {@code EditorKit} class name for thetype  {@code type}.
 * @param type  the non-{@code null} content type
 * @return a {@code String} containing the {@code EditorKit} class namefor  {@code type}
 * @since 1.3
 */
public static String getEditorKitClassNameForContentType(String type){
  return getKitTypeRegistry().get(type);
}"
76898,"/** 
 * Supports reporting bound property changes.  This method can be called when a bound property has changed and it will send the appropriate <code>PropertyChangeEvent</code> to any registered <code>PropertyChangeListeners</code>.
 */
protected void firePropertyChange(String propertyName,Object oldValue,Object newValue){
  if (changeSupport == null || (oldValue != null && newValue != null && oldValue.equals(newValue))) {
    return;
  }
  changeSupport.firePropertyChange(propertyName,oldValue,newValue);
}","/** 
 * Supports reporting bound property changes.  This method can be called when a bound property has changed and it will send the appropriate <code>PropertyChangeEvent</code> to any registered <code>PropertyChangeListeners</code>.
 * @param propertyName  the name of the property that has changed
 * @param oldValue  the old value of the property
 * @param newValue  the new value of the property
 */
protected void firePropertyChange(String propertyName,Object oldValue,Object newValue){
  if (changeSupport == null || (oldValue != null && newValue != null && oldValue.equals(newValue))) {
    return;
  }
  changeSupport.firePropertyChange(propertyName,oldValue,newValue);
}"
76899,"/** 
 * Calls this.paintComponent() with the rectangles x,y,width,height fields.
 */
public void paintComponent(Graphics g,Component c,Container p,Rectangle r){
  paintComponent(g,c,p,r.x,r.y,r.width,r.height);
}","/** 
 * Calls this.paintComponent() with the rectangles x,y,width,height fields.
 * @param g  the {@code Graphics} object to draw on
 * @param c  the {@code Component} to draw
 * @param p  the {@code Container} component actually drawn on
 * @param r  the {@code Rectangle} to draw in
 */
public void paintComponent(Graphics g,Component c,Container p,Rectangle r){
  paintComponent(g,c,p,r.x,r.y,r.width,r.height);
}"
76900,"/** 
 * Sets the number of times that drawing operations will flash.
 */
public static void setFlashCount(int flashCount){
  info().flashCount=flashCount;
}","/** 
 * Sets the number of times that drawing operations will flash.
 * @param flashCount number of times that drawing operations will flash
 */
public static void setFlashCount(int flashCount){
  info().flashCount=flashCount;
}"
76901,"/** 
 * Returns the stream to which the DebugGraphics logs drawing operations.
 * @see #setLogStream
 */
public static java.io.PrintStream logStream(){
  return info().stream;
}","/** 
 * Returns the stream to which the DebugGraphics logs drawing operations.
 * @return the stream to which the DebugGraphics logs drawing operations
 * @see #setLogStream
 */
public static java.io.PrintStream logStream(){
  return info().stream;
}"
76902,"/** 
 * Sets the stream to which the DebugGraphics logs drawing operations.
 */
public static void setLogStream(java.io.PrintStream stream){
  info().stream=stream;
}","/** 
 * Sets the stream to which the DebugGraphics logs drawing operations.
 * @param stream the stream to which the DebugGraphics logs drawing operations
 */
public static void setLogStream(java.io.PrintStream stream){
  info().stream=stream;
}"
76903,"/** 
 * Returns the time delay of drawing operation flashing.
 * @see #setFlashTime
 */
public static int flashTime(){
  return info().flashTime;
}","/** 
 * Returns the time delay of drawing operation flashing.
 * @return the time delay of drawing operation flashing
 * @see #setFlashTime
 */
public static int flashTime(){
  return info().flashTime;
}"
76904,"/** 
 * Returns the number of times that drawing operations will flash.
 * @see #setFlashCount
 */
public static int flashCount(){
  return info().flashCount;
}","/** 
 * Returns the number of times that drawing operations will flash.
 * @return the number of times that drawing operations will flash
 * @see #setFlashCount
 */
public static int flashCount(){
  return info().flashCount;
}"
76905,"/** 
 * Sets the time delay of drawing operation flashing.
 */
public static void setFlashTime(int flashTime){
  info().flashTime=flashTime;
}","/** 
 * Sets the time delay of drawing operation flashing.
 * @param flashTime the time delay of drawing operation flashing
 */
public static void setFlashTime(int flashTime){
  info().flashTime=flashTime;
}"
76906,"/** 
 * Returns the Color used to flash drawing operations.
 * @see #setFlashColor
 */
public static Color flashColor(){
  return info().flashColor;
}","/** 
 * Returns the Color used to flash drawing operations.
 * @return the Color used to flash drawing operations
 * @see #setFlashColor
 */
public static Color flashColor(){
  return info().flashColor;
}"
76907,"/** 
 * Sets the Color used to flash drawing operations.
 */
public static void setFlashColor(Color flashColor){
  info().flashColor=flashColor;
}","/** 
 * Sets the Color used to flash drawing operations.
 * @param flashColor the Color used to flash drawing operations
 */
public static void setFlashColor(Color flashColor){
  info().flashColor=flashColor;
}"
76908,"/** 
 * Returns an array of all the objects currently registered as <code><em>Foo</em>Listener</code>s upon this model. <code><em>Foo</em>Listener</code>s are registered using the <code>add<em>Foo</em>Listener</code> method. <p> You can specify the <code>listenerType</code> argument with a class literal, such as <code><em>Foo</em>Listener.class</code>. For example, you can query a <code>DefaultBoundedRangeModel</code> instance <code>m</code> for its change listeners with the following code: <pre>ChangeListener[] cls = (ChangeListener[])(m.getListeners(ChangeListener.class));</pre> If no such listeners exist, this method returns an empty array.
 * @param listenerType  the type of listeners requested;this parameter should specify an interface that descends from <code>java.util.EventListener</code>
 * @return an array of all objects registered as<code><em>Foo</em>Listener</code>s on this model, or an empty array if no such listeners have been added
 * @exception ClassCastException if <code>listenerType</code> doesn'tspecify a class or interface that implements <code>java.util.EventListener</code>
 * @see #getChangeListeners
 * @since 1.3
 */
public <T extends EventListener>T[] getListeners(Class<T> listenerType){
  return listenerList.getListeners(listenerType);
}","/** 
 * Returns an array of all the objects currently registered as <code><em>Foo</em>Listener</code>s upon this model. <code><em>Foo</em>Listener</code>s are registered using the <code>add<em>Foo</em>Listener</code> method. <p> You can specify the <code>listenerType</code> argument with a class literal, such as <code><em>Foo</em>Listener.class</code>. For example, you can query a <code>DefaultBoundedRangeModel</code> instance <code>m</code> for its change listeners with the following code: <pre>ChangeListener[] cls = (ChangeListener[])(m.getListeners(ChangeListener.class));</pre> If no such listeners exist, this method returns an empty array.
 * @param < T > the type of {@code EventListener} class being requested
 * @param listenerType  the type of listeners requested;this parameter should specify an interface that descends from <code>java.util.EventListener</code>
 * @return an array of all objects registered as<code><em>Foo</em>Listener</code>s on this model, or an empty array if no such listeners have been added
 * @exception ClassCastException if <code>listenerType</code> doesn'tspecify a class or interface that implements <code>java.util.EventListener</code>
 * @see #getChangeListeners
 * @since 1.3
 */
public <T extends EventListener>T[] getListeners(Class<T> listenerType){
  return listenerList.getListeners(listenerType);
}"
76909,"/** 
 * Initializes value, extent, minimum and maximum. Adjusting is false. Throws an <code>IllegalArgumentException</code> if the following constraints aren't satisfied: <pre> min &lt;= value &lt;= value+extent &lt;= max </pre>
 */
public DefaultBoundedRangeModel(int value,int extent,int min,int max){
  if ((max >= min) && (value >= min) && ((value + extent) >= value)&& ((value + extent) <= max)) {
    this.value=value;
    this.extent=extent;
    this.min=min;
    this.max=max;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Initializes value, extent, minimum and maximum. Adjusting is false. Throws an <code>IllegalArgumentException</code> if the following constraints aren't satisfied: <pre> min &lt;= value &lt;= value+extent &lt;= max </pre>
 * @param value  an int giving the current value
 * @param extent the length of the inner range that begins at the model's value
 * @param min    an int giving the minimum value
 * @param max    an int giving the maximum value
 */
public DefaultBoundedRangeModel(int value,int extent,int min,int max){
  if ((max >= min) && (value >= min) && ((value + extent) >= value)&& ((value + extent) <= max)) {
    this.value=value;
    this.extent=extent;
    this.min=min;
    this.max=max;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}"
76910,"/** 
 * Normally this method will not be called. If it is, it try to determine the appropriate parent from the desktopIcon of the frame. Will remove the desktopIcon from its parent if it successfully adds the frame.
 */
public void openFrame(JInternalFrame f){
  if (f.getDesktopIcon().getParent() != null) {
    f.getDesktopIcon().getParent().add(f);
    removeIconFor(f);
  }
}","/** 
 * Normally this method will not be called. If it is, it tries to determine the appropriate parent from the desktopIcon of the frame. Will remove the desktopIcon from its parent if it successfully adds the frame.
 */
public void openFrame(JInternalFrame f){
  if (f.getDesktopIcon().getParent() != null) {
    f.getDesktopIcon().getParent().add(f);
    removeIconFor(f);
  }
}"
76911,"/** 
 * Returns an array of all the objects currently registered as <code><em>Foo</em>Listener</code>s upon this model. <code><em>Foo</em>Listener</code>s are registered using the <code>add<em>Foo</em>Listener</code> method. <p> You can specify the <code>listenerType</code> argument with a class literal, such as <code><em>Foo</em>Listener.class</code>. For example, you can query a <code>DefaultSingleSelectionModel</code> instance <code>m</code> for its change listeners with the following code: <pre>ChangeListener[] cls = (ChangeListener[])(m.getListeners(ChangeListener.class));</pre> If no such listeners exist, this method returns an empty array.
 * @param listenerType  the type of listeners requested;this parameter should specify an interface that descends from <code>java.util.EventListener</code>
 * @return an array of all objects registered as<code><em>Foo</em>Listener</code>s on this model, or an empty array if no such listeners have been added
 * @exception ClassCastException if <code>listenerType</code> doesn'tspecify a class or interface that implements <code>java.util.EventListener</code>
 * @see #getChangeListeners
 * @since 1.3
 */
public <T extends EventListener>T[] getListeners(Class<T> listenerType){
  return listenerList.getListeners(listenerType);
}","/** 
 * Returns an array of all the objects currently registered as <code><em>Foo</em>Listener</code>s upon this model. <code><em>Foo</em>Listener</code>s are registered using the <code>add<em>Foo</em>Listener</code> method. <p> You can specify the <code>listenerType</code> argument with a class literal, such as <code><em>Foo</em>Listener.class</code>. For example, you can query a <code>DefaultSingleSelectionModel</code> instance <code>m</code> for its change listeners with the following code: <pre>ChangeListener[] cls = (ChangeListener[])(m.getListeners(ChangeListener.class));</pre> If no such listeners exist, this method returns an empty array.
 * @param < T >  the type of {@code EventListener} class being requested
 * @param listenerType  the type of listeners requested;this parameter should specify an interface that descends from <code>java.util.EventListener</code>
 * @return an array of all objects registered as<code><em>Foo</em>Listener</code>s on this model, or an empty array if no such listeners have been added
 * @exception ClassCastException if <code>listenerType</code> doesn'tspecify a class or interface that implements <code>java.util.EventListener</code>
 * @see #getChangeListeners
 * @since 1.3
 */
public <T extends EventListener>T[] getListeners(Class<T> listenerType){
  return listenerList.getListeners(listenerType);
}"
76912,"/** 
 * Generally, remove this frame from it's parent and add an iconic representation. 
 */
void iconifyFrame(JInternalFrame f);","/** 
 * Generally, remove this frame from its parent and add an iconic representation.
 * @param f  the {@code JInternalFrame} to be iconified
 */
void iconifyFrame(JInternalFrame f);"
76913,"/** 
 * Generally, this indicates that the frame should be restored to it's size and position prior to a maximizeFrame() call.
 */
void minimizeFrame(JInternalFrame f);","/** 
 * Generally, this indicates that the frame should be restored to its size and position prior to a maximizeFrame() call.
 * @param f  the {@code JInternalFrame} to be restored
 */
void minimizeFrame(JInternalFrame f);"
76914,"/** 
 * Generally, this call should remove the frame from it's parent. 
 */
void closeFrame(JInternalFrame f);","/** 
 * Generally, this call should remove the frame from its parent.
 * @param f  the {@code JInternalFrame} to be removed
 */
void closeFrame(JInternalFrame f);"
76915,"/** 
 * Generally, remove any iconic representation that is present and restore the frame to it's original size and location.
 */
void deiconifyFrame(JInternalFrame f);","/** 
 * Generally, remove any iconic representation that is present and restore the frame to it's original size and location.
 * @param f  the {@code JInternalFrame} to be de-iconified
 */
void deiconifyFrame(JInternalFrame f);"
76916,"/** 
 * Generally, indicate that this frame has focus. This is usually called after the JInternalFrame's IS_SELECTED_PROPERTY has been set to true.
 */
void activateFrame(JInternalFrame f);","/** 
 * Generally, indicate that this frame has focus. This is usually called after the JInternalFrame's IS_SELECTED_PROPERTY has been set to true.
 * @param f  the {@code JInternalFrame} to be activated
 */
void activateFrame(JInternalFrame f);"
76917,"/** 
 * This methods is normally called when the user has indicated that they will begin resizing the frame. This method should be called prior to any resizeFrame() calls to allow the DesktopManager to prepare any necessary state.  Normally <b>f</b> will be a JInternalFrame.
 */
void beginResizingFrame(JComponent f,int direction);","/** 
 * This method is normally called when the user has indicated that they will begin resizing the frame. This method should be called prior to any resizeFrame() calls to allow the DesktopManager to prepare any necessary state.  Normally <b>f</b> will be a JInternalFrame.
 * @param f  the {@code JComponent} being resized
 */
void beginResizingFrame(JComponent f,int direction);"
76918,"/** 
 * The user has moved the frame. Calls to this method will be preceded by calls to beginDraggingFrame(). Normally <b>f</b> will be a JInternalFrame.
 */
void dragFrame(JComponent f,int newX,int newY);","/** 
 * The user has moved the frame. Calls to this method will be preceded by calls to beginDraggingFrame(). Normally <b>f</b> will be a JInternalFrame.
 * @param f  the {@code JComponent} being dragged
 * @param newX  the new x-coordinate
 * @param newY  the new y-coordinate
 */
void dragFrame(JComponent f,int newX,int newY);"
76919,"/** 
 * If possible, display this frame in an appropriate location. Normally, this is not called, as the creator of the JInternalFrame will add the frame to the appropriate parent.
 */
void openFrame(JInternalFrame f);","/** 
 * If possible, display this frame in an appropriate location. Normally, this is not called, as the creator of the JInternalFrame will add the frame to the appropriate parent.
 * @param f  the {@code JInternalFrame} to be displayed
 */
void openFrame(JInternalFrame f);"
76920,"/** 
 * Generally, the frame should be resized to match it's parents bounds. 
 */
void maximizeFrame(JInternalFrame f);","/** 
 * Generally, the frame should be resized to match its parents bounds.
 * @param f  the {@code JInternalFrame} to be resized
 */
void maximizeFrame(JInternalFrame f);"
76921,"/** 
 * This method is normally called when the user has indicated that they will begin dragging a component around. This method should be called prior to any dragFrame() calls to allow the DesktopManager to prepare any necessary state. Normally <b>f</b> will be a JInternalFrame.
 */
void beginDraggingFrame(JComponent f);","/** 
 * This method is normally called when the user has indicated that they will begin dragging a component around. This method should be called prior to any dragFrame() calls to allow the DesktopManager to prepare any necessary state. Normally <b>f</b> will be a JInternalFrame.
 * @param f  the {@code JComponent} being dragged
 */
void beginDraggingFrame(JComponent f);"
76922,"/** 
 * Generally, indicate that this frame has lost focus. This is usually called after the JInternalFrame's IS_SELECTED_PROPERTY has been set to false.
 */
void deactivateFrame(JInternalFrame f);","/** 
 * Generally, indicate that this frame has lost focus. This is usually called after the JInternalFrame's IS_SELECTED_PROPERTY has been set to false.
 * @param f  the {@code JInternalFrame} to be deactivated
 */
void deactivateFrame(JInternalFrame f);"
76923,"/** 
 * The user has resized the component. Calls to this method will be preceded by calls to beginResizingFrame(). Normally <b>f</b> will be a JInternalFrame.
 */
void resizeFrame(JComponent f,int newX,int newY,int newWidth,int newHeight);","/** 
 * The user has resized the component. Calls to this method will be preceded by calls to beginResizingFrame(). Normally <b>f</b> will be a JInternalFrame.
 * @param f  the {@code JComponent} being resized
 * @param newX  the new x-coordinate
 * @param newY  the new y-coordinate
 * @param newWidth  the new width
 * @param newHeight  the new height
 */
void resizeFrame(JComponent f,int newX,int newY,int newWidth,int newHeight);"
76924,"/** 
 * This method signals the end of the resize session. Any state maintained by the DesktopManager can be removed here.  Normally <b>f</b> will be a JInternalFrame.
 */
void endResizingFrame(JComponent f);","/** 
 * This method signals the end of the resize session. Any state maintained by the DesktopManager can be removed here.  Normally <b>f</b> will be a JInternalFrame.
 * @param f  the {@code JComponent} being resized
 */
void endResizingFrame(JComponent f);"
76925,"/** 
 * This method signals the end of the dragging session. Any state maintained by the DesktopManager can be removed here.  Normally <b>f</b> will be a JInternalFrame.
 */
void endDraggingFrame(JComponent f);","/** 
 * This method signals the end of the dragging session. Any state maintained by the DesktopManager can be removed here.  Normally <b>f</b> will be a JInternalFrame.
 * @param f  the {@code JComponent} being dragged
 */
void endDraggingFrame(JComponent f);"
76926,"/** 
 * This is a primitive reshape method.
 */
void setBoundsForFrame(JComponent f,int newX,int newY,int newWidth,int newHeight);","/** 
 * This is a primitive reshape method.
 * @param f  the {@code JComponent} being moved or resized
 * @param newX  the new x-coordinate
 * @param newY  the new y-coordinate
 * @param newWidth  the new width
 * @param newHeight  the new height
 */
void setBoundsForFrame(JComponent f,int newX,int newY,int newWidth,int newHeight);"
76927,"/** 
 * Returns the ancestor that the event actually occurred on.
 */
public Container getAncestor(){
  return ancestor;
}","/** 
 * Returns the ancestor that the event actually occurred on.
 * @return the {@code Container} object specifying the ancestor component
 */
public Container getAncestor(){
  return ancestor;
}"
76928,"/** 
 * Returns the parent of the ancestor the event actually occurred on. This is most interesting in an ANCESTOR_REMOVED event, as the ancestor may no longer be in the component hierarchy.
 */
public Container getAncestorParent(){
  return ancestorParent;
}","/** 
 * Returns the parent of the ancestor the event actually occurred on. This is most interesting in an ANCESTOR_REMOVED event, as the ancestor may no longer be in the component hierarchy.
 * @return the {@code Container} object specifying the ancestor's parent
 */
public Container getAncestorParent(){
  return ancestorParent;
}"
76929,"/** 
 * Returns the component that the listener was added to.
 */
public JComponent getComponent(){
  return (JComponent)getSource();
}","/** 
 * Returns the component that the listener was added to.
 * @return the {@code JComponent} on which the event occurred
 */
public JComponent getComponent(){
  return (JComponent)getSource();
}"
76930,"/** 
 * Called when the source or one of its ancestors is made visible either by setVisible(true) being called or by its being added to the component hierarchy.  The method is only called if the source has actually become visible.  For this to be true all its parents must be visible and it must be in a hierarchy rooted at a Window
 */
public void ancestorAdded(AncestorEvent event);","/** 
 * Called when the source or one of its ancestors is made visible either by setVisible(true) being called or by its being added to the component hierarchy.  The method is only called if the source has actually become visible.  For this to be true all its parents must be visible and it must be in a hierarchy rooted at a Window
 * @param event an {@code AncestorEvent} signifying a change in anancestor-component's display-status
 */
public void ancestorAdded(AncestorEvent event);"
76931,"/** 
 * Called when either the source or one of its ancestors is moved.
 */
public void ancestorMoved(AncestorEvent event);","/** 
 * Called when either the source or one of its ancestors is moved.
 * @param event an {@code AncestorEvent} signifying a change in anancestor-component's display-status
 */
public void ancestorMoved(AncestorEvent event);"
76932,"/** 
 * Called when the source or one of its ancestors is made invisible either by setVisible(false) being called or by its being remove from the component hierarchy.  The method is only called if the source has actually become invisible.  For this to be true at least one of its parents must by invisible or it is not in a hierarchy rooted at a Window
 */
public void ancestorRemoved(AncestorEvent event);","/** 
 * Called when the source or one of its ancestors is made invisible either by setVisible(false) being called or by its being remove from the component hierarchy.  The method is only called if the source has actually become invisible.  For this to be true at least one of its parents must by invisible or it is not in a hierarchy rooted at a Window
 * @param event an {@code AncestorEvent} signifying a change in anancestor-component's display-status
 */
public void ancestorRemoved(AncestorEvent event);"
76933,"/** 
 * This tells the listeners the editor has ended editing 
 */
public void editingStopped(ChangeEvent e);","/** 
 * This tells the listeners the editor has ended editing
 * @param e the {@code ChangeEvent} containing the source of the event
 */
public void editingStopped(ChangeEvent e);"
76934,"/** 
 * This tells the listeners the editor has canceled editing 
 */
public void editingCanceled(ChangeEvent e);","/** 
 * This tells the listeners the editor has canceled editing
 * @param e the {@code ChangeEvent} containing the source of the event
 */
public void editingCanceled(ChangeEvent e);"
76935,"/** 
 * Return an array of all the listeners of the given type.
 * @return all of the listeners of the specified type.
 * @exception ClassCastException if the supplied classis not assignable to EventListener
 * @since 1.3
 */
public <T extends EventListener>T[] getListeners(Class<T> t){
  Object[] lList=listenerList;
  int n=getListenerCount(lList,t);
  T[] result=(T[])Array.newInstance(t,n);
  int j=0;
  for (int i=lList.length - 2; i >= 0; i-=2) {
    if (lList[i] == t) {
      result[j++]=(T)lList[i + 1];
    }
  }
  return result;
}","/** 
 * Return an array of all the listeners of the given type.
 * @param < T > the type of {@code EventListener} to search for
 * @param t the type of {@code EventListener} classes to be returned
 * @return all of the listeners of the specified type.
 * @exception ClassCastException if the supplied classis not assignable to EventListener
 * @since 1.3
 */
public <T extends EventListener>T[] getListeners(Class<T> t){
  Object[] lList=listenerList;
  int n=getListenerCount(lList,t);
  T[] result=(T[])Array.newInstance(t,n);
  int j=0;
  for (int i=lList.length - 2; i >= 0; i-=2) {
    if (lList[i] == t) {
      result[j++]=(T)lList[i + 1];
    }
  }
  return result;
}"
76936,"/** 
 * Adds the listener as a listener of the specified type.
 * @param t the type of the listener to be added
 * @param l the listener to be added
 */
public synchronized <T extends EventListener>void add(Class<T> t,T l){
  if (l == null) {
    return;
  }
  if (!t.isInstance(l)) {
    throw new IllegalArgumentException(""String_Node_Str"" + l + ""String_Node_Str""+ t);
  }
  if (listenerList == NULL_ARRAY) {
    listenerList=new Object[]{t,l};
  }
 else {
    int i=listenerList.length;
    Object[] tmp=new Object[i + 2];
    System.arraycopy(listenerList,0,tmp,0,i);
    tmp[i]=t;
    tmp[i + 1]=l;
    listenerList=tmp;
  }
}","/** 
 * Adds the listener as a listener of the specified type.
 * @param < T > the type of {@code EventListener} to add
 * @param t the type of the {@code EventListener} class to add
 * @param l the listener to be added
 */
public synchronized <T extends EventListener>void add(Class<T> t,T l){
  if (l == null) {
    return;
  }
  if (!t.isInstance(l)) {
    throw new IllegalArgumentException(""String_Node_Str"" + l + ""String_Node_Str""+ t);
  }
  if (listenerList == NULL_ARRAY) {
    listenerList=new Object[]{t,l};
  }
 else {
    int i=listenerList.length;
    Object[] tmp=new Object[i + 2];
    System.arraycopy(listenerList,0,tmp,0,i);
    tmp[i]=t;
    tmp[i + 1]=l;
    listenerList=tmp;
  }
}"
76937,"/** 
 * Passes back the event listener list as an array of ListenerType-listener pairs.  Note that for performance reasons, this implementation passes back the actual data structure in which the listener data is stored internally! This method is guaranteed to pass back a non-null array, so that no null-checking is required in fire methods.  A zero-length array of Object should be returned if there are currently no listeners. WARNING!!! Absolutely NO modification of the data contained in this array should be made -- if any such manipulation is necessary, it should be done on a copy of the array returned rather than the array itself.
 */
public Object[] getListenerList(){
  return listenerList;
}","/** 
 * Passes back the event listener list as an array of ListenerType-listener pairs.  Note that for performance reasons, this implementation passes back the actual data structure in which the listener data is stored internally! This method is guaranteed to pass back a non-null array, so that no null-checking is required in fire methods.  A zero-length array of Object should be returned if there are currently no listeners. WARNING!!! Absolutely NO modification of the data contained in this array should be made -- if any such manipulation is necessary, it should be done on a copy of the array returned rather than the array itself.
 * @return array of ListenerType-listener pairs
 */
public Object[] getListenerList(){
  return listenerList;
}"
76938,"/** 
 * Removes the listener as a listener of the specified type.
 * @param t the type of the listener to be removed
 * @param l the listener to be removed
 */
public synchronized <T extends EventListener>void remove(Class<T> t,T l){
  if (l == null) {
    return;
  }
  if (!t.isInstance(l)) {
    throw new IllegalArgumentException(""String_Node_Str"" + l + ""String_Node_Str""+ t);
  }
  int index=-1;
  for (int i=listenerList.length - 2; i >= 0; i-=2) {
    if ((listenerList[i] == t) && (listenerList[i + 1].equals(l) == true)) {
      index=i;
      break;
    }
  }
  if (index != -1) {
    Object[] tmp=new Object[listenerList.length - 2];
    System.arraycopy(listenerList,0,tmp,0,index);
    if (index < tmp.length)     System.arraycopy(listenerList,index + 2,tmp,index,tmp.length - index);
    listenerList=(tmp.length == 0) ? NULL_ARRAY : tmp;
  }
}","/** 
 * Removes the listener as a listener of the specified type.
 * @param < T > the type of {@code EventListener}
 * @param t the type of the listener to be removed
 * @param l the listener to be removed
 */
public synchronized <T extends EventListener>void remove(Class<T> t,T l){
  if (l == null) {
    return;
  }
  if (!t.isInstance(l)) {
    throw new IllegalArgumentException(""String_Node_Str"" + l + ""String_Node_Str""+ t);
  }
  int index=-1;
  for (int i=listenerList.length - 2; i >= 0; i-=2) {
    if ((listenerList[i] == t) && (listenerList[i + 1].equals(l) == true)) {
      index=i;
      break;
    }
  }
  if (index != -1) {
    Object[] tmp=new Object[listenerList.length - 2];
    System.arraycopy(listenerList,0,tmp,0,index);
    if (index < tmp.length)     System.arraycopy(listenerList,index + 2,tmp,index,tmp.length - index);
    listenerList=(tmp.length == 0) ? NULL_ARRAY : tmp;
  }
}"
76939,"/** 
 * Get the description of the link as a string. This may be useful if a URL can't be formed from the description, in which case the associated URL would be null.
 */
public String getDescription(){
  return desc;
}","/** 
 * Get the description of the link as a string. This may be useful if a URL can't be formed from the description, in which case the associated URL would be null.
 * @return the description of this link as a {@code String}
 */
public String getDescription(){
  return desc;
}"
76940,"/** 
 * Invoked when a internal frame has been opened.
 * @see javax.swing.JInternalFrame#show
 */
public void internalFrameOpened(InternalFrameEvent e);","/** 
 * Invoked when a internal frame has been opened.
 * @param e an {@code InternalFrameEvent} with information about the{@code JInteralFrame} that originated the event
 * @see javax.swing.JInternalFrame#show
 */
public void internalFrameOpened(InternalFrameEvent e);"
76941,"/** 
 * Invoked when an internal frame is activated.
 * @see javax.swing.JInternalFrame#setSelected
 */
public void internalFrameActivated(InternalFrameEvent e);","/** 
 * Invoked when an internal frame is activated.
 * @param e an {@code InternalFrameEvent} with information about the{@code JInteralFrame} that originated the event
 * @see javax.swing.JInternalFrame#setSelected
 */
public void internalFrameActivated(InternalFrameEvent e);"
76942,"/** 
 * Invoked when an internal frame is de-activated.
 * @see javax.swing.JInternalFrame#setSelected
 */
public void internalFrameDeactivated(InternalFrameEvent e);","/** 
 * Invoked when an internal frame is de-activated.
 * @param e an {@code InternalFrameEvent} with information about the{@code JInteralFrame} that originated the event
 * @see javax.swing.JInternalFrame#setSelected
 */
public void internalFrameDeactivated(InternalFrameEvent e);"
76943,"/** 
 * Invoked when an internal frame has been closed.
 * @see javax.swing.JInternalFrame#setClosed
 */
public void internalFrameClosed(InternalFrameEvent e);","/** 
 * Invoked when an internal frame has been closed.
 * @param e an {@code InternalFrameEvent} with information about the{@code JInteralFrame} that originated the event
 * @see javax.swing.JInternalFrame#setClosed
 */
public void internalFrameClosed(InternalFrameEvent e);"
76944,"/** 
 * Invoked when an internal frame is iconified.
 * @see javax.swing.JInternalFrame#setIcon
 */
public void internalFrameIconified(InternalFrameEvent e);","/** 
 * Invoked when an internal frame is iconified.
 * @param e an {@code InternalFrameEvent} with information about the{@code JInteralFrame} that originated the event
 * @see javax.swing.JInternalFrame#setIcon
 */
public void internalFrameIconified(InternalFrameEvent e);"
76945,"/** 
 * Invoked when an internal frame is de-iconified.
 * @see javax.swing.JInternalFrame#setIcon
 */
public void internalFrameDeiconified(InternalFrameEvent e);","/** 
 * Invoked when an internal frame is de-iconified.
 * @param e an {@code InternalFrameEvent} with information about the{@code JInteralFrame} that originated the event
 * @see javax.swing.JInternalFrame#setIcon
 */
public void internalFrameDeiconified(InternalFrameEvent e);"
76946,"/** 
 * Invoked when an internal frame is in the process of being closed. The close operation can be overridden at this point.
 * @see javax.swing.JInternalFrame#setDefaultCloseOperation
 */
public void internalFrameClosing(InternalFrameEvent e);","/** 
 * Invoked when an internal frame is in the process of being closed. The close operation can be overridden at this point.
 * @param e an {@code InternalFrameEvent} with information about the{@code JInteralFrame} that originated the event
 * @see javax.swing.JInternalFrame#setDefaultCloseOperation
 */
public void internalFrameClosing(InternalFrameEvent e);"
76947,"/** 
 * Represents a change in selection status between   {@code firstIndex} and{@code lastIndex}, inclusive.   {@code firstIndex} is less than or equal to{@code lastIndex}. The selection of at least one index within the range will have changed.
 * @param firstIndex the first index in the range, &lt;= lastIndex
 * @param lastIndex the last index in the range, &gt;= firstIndex
 * @param isAdjusting whether or not this is one in a series ofmultiple events, where changes are still being made
 */
public ListSelectionEvent(Object source,int firstIndex,int lastIndex,boolean isAdjusting){
  super(source);
  this.firstIndex=firstIndex;
  this.lastIndex=lastIndex;
  this.isAdjusting=isAdjusting;
}","/** 
 * Represents a change in selection status between   {@code firstIndex} and{@code lastIndex}, inclusive.   {@code firstIndex} is less than or equal to{@code lastIndex}. The selection of at least one index within the range will have changed.
 * @param source the {@code Object} on which the event initially occurred
 * @param firstIndex the first index in the range, &lt;= lastIndex
 * @param lastIndex the last index in the range, &gt;= firstIndex
 * @param isAdjusting whether or not this is one in a series ofmultiple events, where changes are still being made
 */
public ListSelectionEvent(Object source,int firstIndex,int lastIndex,boolean isAdjusting){
  super(source);
  this.firstIndex=firstIndex;
  this.lastIndex=lastIndex;
  this.isAdjusting=isAdjusting;
}"
76948,"/** 
 * Invoked when a key has been released.
 */
void menuKeyReleased(MenuKeyEvent e);","/** 
 * Invoked when a key has been released.
 * @param e a {@code MenuKeyEvent}
 */
void menuKeyReleased(MenuKeyEvent e);"
76949,"/** 
 * Invoked when a key has been typed. This event occurs when a key press is followed by a key release.
 */
void menuKeyTyped(MenuKeyEvent e);","/** 
 * Invoked when a key has been typed. This event occurs when a key press is followed by a key release.
 * @param e a {@code MenuKeyEvent}
 */
void menuKeyTyped(MenuKeyEvent e);"
76950,"/** 
 * Invoked when a key has been pressed.
 */
void menuKeyPressed(MenuKeyEvent e);","/** 
 * Invoked when a key has been pressed.
 * @param e a {@code MenuKeyEvent}
 */
void menuKeyPressed(MenuKeyEvent e);"
76951,"/** 
 * This method is called before the popup menu becomes visible
 */
void popupMenuWillBecomeVisible(PopupMenuEvent e);","/** 
 * This method is called before the popup menu becomes visible
 * @param e a {@code PopupMenuEvent} containing the source of the event
 */
void popupMenuWillBecomeVisible(PopupMenuEvent e);"
76952,"/** 
 * This method is called when the popup menu is canceled
 */
void popupMenuCanceled(PopupMenuEvent e);","/** 
 * This method is called when the popup menu is canceled
 * @param e a {@code PopupMenuEvent} containing the source of the event
 */
void popupMenuCanceled(PopupMenuEvent e);"
76953,"/** 
 * This method is called before the popup menu becomes invisible Note that a JPopupMenu can become invisible any time
 */
void popupMenuWillBecomeInvisible(PopupMenuEvent e);","/** 
 * This method is called before the popup menu becomes invisible Note that a JPopupMenu can become invisible any time
 * @param e a {@code PopupMenuEvent} containing the source of the event
 */
void popupMenuWillBecomeInvisible(PopupMenuEvent e);"
76954,"/** 
 * Returns the fromIndex.  Valid for removed or moved events 
 */
public int getFromIndex(){
  return fromIndex;
}","/** 
 * Returns the fromIndex.  Valid for removed or moved events
 * @return int value for index from which the column was moved or removed
 */
public int getFromIndex(){
  return fromIndex;
}"
76955,"/** 
 * Returns the toIndex.  Valid for add and moved events 
 */
public int getToIndex(){
  return toIndex;
}","/** 
 * Returns the toIndex.  Valid for add and moved events
 * @return int value of column's new index
 */
public int getToIndex(){
  return toIndex;
}"
76956,"/** 
 * Tells listeners that a column was repositioned. 
 */
public void columnMoved(TableColumnModelEvent e);","/** 
 * Tells listeners that a column was repositioned.
 * @param e a {@code TableColumnModelEvent}
 */
public void columnMoved(TableColumnModelEvent e);"
76957,"/** 
 * Tells listeners that the selection model of the TableColumnModel changed.
 */
public void columnSelectionChanged(ListSelectionEvent e);","/** 
 * Tells listeners that the selection model of the TableColumnModel changed.
 * @param e a {@code ListSelectionEvent}
 */
public void columnSelectionChanged(ListSelectionEvent e);"
76958,"/** 
 * Tells listeners that a column was removed from the model. 
 */
public void columnRemoved(TableColumnModelEvent e);","/** 
 * Tells listeners that a column was removed from the model.
 * @param e a {@code TableColumnModelEvent}
 */
public void columnRemoved(TableColumnModelEvent e);"
76959,"/** 
 * Tells listeners that a column was moved due to a margin change. 
 */
public void columnMarginChanged(ChangeEvent e);","/** 
 * Tells listeners that a column was moved due to a margin change.
 * @param e a {@code ChangeEvent}
 */
public void columnMarginChanged(ChangeEvent e);"
76960,"/** 
 * Tells listeners that a column was added to the model. 
 */
public void columnAdded(TableColumnModelEvent e);","/** 
 * Tells listeners that a column was added to the model.
 * @param e a {@code TableColumnModelEvent}
 */
public void columnAdded(TableColumnModelEvent e);"
76961,"/** 
 * Return an array of all the listeners of the given type that were added to this model.  For example to find all of the ChangeListeners added to this model: <pre> myAbstractSpinnerModel.getListeners(ChangeListener.class); </pre>
 * @param listenerType the type of listeners to return, e.g. ChangeListener.class
 * @return all of the objects receiving <em>listenerType</em> notificationsfrom this model
 */
public <T extends EventListener>T[] getListeners(Class<T> listenerType){
  return listenerList.getListeners(listenerType);
}","/** 
 * Return an array of all the listeners of the given type that were added to this model.  For example to find all of the ChangeListeners added to this model: <pre> myAbstractSpinnerModel.getListeners(ChangeListener.class); </pre>
 * @param < T > the type of requested listeners
 * @param listenerType the type of listeners to return, e.g. ChangeListener.class
 * @return all of the objects receiving <em>listenerType</em> notificationsfrom this model
 */
public <T extends EventListener>T[] getListeners(Class<T> listenerType){
  return listenerList.getListeners(listenerType);
}"
76962,"/** 
 * Returns the <code>Action</code> names that are bound in this <code>ActionMap</code>.
 */
public Object[] keys(){
  if (arrayTable == null) {
    return null;
  }
  return arrayTable.getKeys(null);
}","/** 
 * Returns the <code>Action</code> names that are bound in this <code>ActionMap</code>.
 * @return an array of the keys
 */
public Object[] keys(){
  if (arrayTable == null) {
    return null;
  }
  return arrayTable.getKeys(null);
}"
76963,"/** 
 * Returns the binding for <code>key</code>, messaging the parent <code>ActionMap</code> if the binding is not locally defined.
 */
public Action get(Object key){
  Action value=(arrayTable == null) ? null : (Action)arrayTable.get(key);
  if (value == null) {
    ActionMap parent=getParent();
    if (parent != null) {
      return parent.get(key);
    }
  }
  return value;
}","/** 
 * Returns the binding for <code>key</code>, messaging the parent <code>ActionMap</code> if the binding is not locally defined.
 * @param key a key
 * @return the binding for {@code key}
 */
public Action get(Object key){
  Action value=(arrayTable == null) ? null : (Action)arrayTable.get(key);
  if (value == null) {
    ActionMap parent=getParent();
    if (parent != null) {
      return parent.get(key);
    }
  }
  return value;
}"
76964,"/** 
 * Returns an array of the keys defined in this <code>ActionMap</code> and its parent. This method differs from <code>keys()</code> in that this method includes the keys defined in the parent.
 */
public Object[] allKeys(){
  int count=size();
  ActionMap parent=getParent();
  if (count == 0) {
    if (parent != null) {
      return parent.allKeys();
    }
    return keys();
  }
  if (parent == null) {
    return keys();
  }
  Object[] keys=keys();
  Object[] pKeys=parent.allKeys();
  if (pKeys == null) {
    return keys;
  }
  if (keys == null) {
    return pKeys;
  }
  HashMap<Object,Object> keyMap=new HashMap<Object,Object>();
  int counter;
  for (counter=keys.length - 1; counter >= 0; counter--) {
    keyMap.put(keys[counter],keys[counter]);
  }
  for (counter=pKeys.length - 1; counter >= 0; counter--) {
    keyMap.put(pKeys[counter],pKeys[counter]);
  }
  return keyMap.keySet().toArray();
}","/** 
 * Returns an array of the keys defined in this <code>ActionMap</code> and its parent. This method differs from <code>keys()</code> in that this method includes the keys defined in the parent.
 * @return an array of the keys
 */
public Object[] allKeys(){
  int count=size();
  ActionMap parent=getParent();
  if (count == 0) {
    if (parent != null) {
      return parent.allKeys();
    }
    return keys();
  }
  if (parent == null) {
    return keys();
  }
  Object[] keys=keys();
  Object[] pKeys=parent.allKeys();
  if (pKeys == null) {
    return keys;
  }
  if (keys == null) {
    return pKeys;
  }
  HashMap<Object,Object> keyMap=new HashMap<Object,Object>();
  int counter;
  for (counter=keys.length - 1; counter >= 0; counter--) {
    keyMap.put(keys[counter],keys[counter]);
  }
  for (counter=pKeys.length - 1; counter >= 0; counter--) {
    keyMap.put(pKeys[counter],pKeys[counter]);
  }
  return keyMap.keySet().toArray();
}"
76965,"/** 
 * Adds a binding for <code>key</code> to <code>action</code>. If <code>action</code> is null, this removes the current binding for <code>key</code>. <p>In most instances, <code>key</code> will be <code>action.getValue(NAME)</code>.
 */
public void put(Object key,Action action){
  if (key == null) {
    return;
  }
  if (action == null) {
    remove(key);
  }
 else {
    if (arrayTable == null) {
      arrayTable=new ArrayTable();
    }
    arrayTable.put(key,action);
  }
}","/** 
 * Adds a binding for <code>key</code> to <code>action</code>. If <code>action</code> is null, this removes the current binding for <code>key</code>. <p>In most instances, <code>key</code> will be <code>action.getValue(NAME)</code>.
 * @param key a key
 * @param action a binding for {@code key}
 */
public void put(Object key,Action action){
  if (key == null) {
    return;
  }
  if (action == null) {
    remove(key);
  }
 else {
    if (arrayTable == null) {
      arrayTable=new ArrayTable();
    }
    arrayTable.put(key,action);
  }
}"
76966,"/** 
 * Removes the binding for <code>key</code> from this <code>ActionMap</code>.
 */
public void remove(Object key){
  if (arrayTable != null) {
    arrayTable.remove(key);
  }
}","/** 
 * Removes the binding for <code>key</code> from this <code>ActionMap</code>.
 * @param key a key
 */
public void remove(Object key){
  if (arrayTable != null) {
    arrayTable.remove(key);
  }
}"
76967,"/** 
 * Returns whether a <code>ButtonModel</code> is selected.
 * @return <code>true</code> if the button is selected,otherwise returns <code>false</code>
 */
public boolean isSelected(ButtonModel m){
  return (m == selection);
}","/** 
 * Returns whether a   {@code ButtonModel} is selected.
 * @param m an isntance of {@code ButtonModel}
 * @return {@code true} if the button is selected,otherwise returns  {@code false}
 */
public boolean isSelected(ButtonModel m){
  return (m == selection);
}"
76968,"/** 
 * Ask the editor to start editing and to select everything 
 */
public void selectAll();","/** 
 * Ask the editor to start editing and to select everything
 */
public void selectAll();"
76969,"/** 
 * Remove an ActionListener 
 */
public void removeActionListener(ActionListener l);","/** 
 * Remove an ActionListener
 * @param l an {@code ActionListener}
 */
public void removeActionListener(ActionListener l);"
76970,"/** 
 * Add an ActionListener. An action event is generated when the edited item changes 
 */
public void addActionListener(ActionListener l);","/** 
 * Add an ActionListener. An action event is generated when the edited item changes
 * @param l an {@code ActionListener}
 */
public void addActionListener(ActionListener l);"
76971,"/** 
 * Return the edited item 
 */
public Object getItem();","/** 
 * Returns the edited item
 * @return the edited item
 */
public Object getItem();"
76972,"/** 
 * Return the component that should be added to the tree hierarchy for this editor
 */
public Component getEditorComponent();","/** 
 * Returns the component that should be added to the tree hierarchy for this editor
 * @return the component
 */
public Component getEditorComponent();"
76973,"/** 
 * Set the item that should be edited. Cancel any editing if necessary 
 */
public void setItem(Object anObject);","/** 
 * Set the item that should be edited. Cancel any editing if necessary
 * @param anObject an item
 */
public void setItem(Object anObject);"
76974,"/** 
 * Returns the component the <code>InputMap</code> was created for.
 */
public JComponent getComponent(){
  return component;
}","/** 
 * Returns the component the   {@code InputMap} was created for.
 * @return the component the {@code InputMap} was created for.
 */
public JComponent getComponent(){
  return component;
}"
76975,"/** 
 * Returns an array of all the objects currently registered as <code><em>Foo</em>Listener</code>s upon this model. <code><em>Foo</em>Listener</code>s are registered using the <code>add<em>Foo</em>Listener</code> method. <p> You can specify the <code>listenerType</code> argument with a class literal, such as <code><em>Foo</em>Listener.class</code>. For example, you can query a <code>DefaultButtonModel</code> instance <code>m</code> for its action listeners with the following code: <pre>ActionListener[] als = (ActionListener[])(m.getListeners(ActionListener.class));</pre> If no such listeners exist, this method returns an empty array.
 * @param listenerType  the type of listeners requested;this parameter should specify an interface that descends from <code>java.util.EventListener</code>
 * @return an array of all objects registered as<code><em>Foo</em>Listener</code>s on this model, or an empty array if no such listeners have been added
 * @exception ClassCastException if <code>listenerType</code> doesn'tspecify a class or interface that implements <code>java.util.EventListener</code>
 * @see #getActionListeners
 * @see #getChangeListeners
 * @see #getItemListeners
 * @since 1.3
 */
public <T extends EventListener>T[] getListeners(Class<T> listenerType){
  return listenerList.getListeners(listenerType);
}","/** 
 * Returns an array of all the objects currently registered as <code><em>Foo</em>Listener</code>s upon this model. <code><em>Foo</em>Listener</code>s are registered using the <code>add<em>Foo</em>Listener</code> method. <p> You can specify the <code>listenerType</code> argument with a class literal, such as <code><em>Foo</em>Listener.class</code>. For example, you can query a <code>DefaultButtonModel</code> instance <code>m</code> for its action listeners with the following code: <pre>ActionListener[] als = (ActionListener[])(m.getListeners(ActionListener.class));</pre> If no such listeners exist, this method returns an empty array.
 * @param < T > the type of requested listeners
 * @param listenerType  the type of listeners requested;this parameter should specify an interface that descends from <code>java.util.EventListener</code>
 * @return an array of all objects registered as<code><em>Foo</em>Listener</code>s on this model, or an empty array if no such listeners have been added
 * @exception ClassCastException if <code>listenerType</code> doesn'tspecify a class or interface that implements <code>java.util.EventListener</code>
 * @see #getActionListeners
 * @see #getChangeListeners
 * @see #getItemListeners
 * @since 1.3
 */
public <T extends EventListener>T[] getListeners(Class<T> listenerType){
  return listenerList.getListeners(listenerType);
}"
76976,"/** 
 * Creates and returns a   {@code ParallelGroup} that aligns it'selements along the baseline.
 * @param resizable whether the group is resizable
 * @param anchorBaselineToTop whether the baseline is anchored tothe top or bottom of the group
 * @see #createBaselineGroup
 * @see ParallelGroup
 */
public ParallelGroup createBaselineGroup(boolean resizable,boolean anchorBaselineToTop){
  return new BaselineGroup(resizable,anchorBaselineToTop);
}","/** 
 * Creates and returns a   {@code ParallelGroup} that aligns it'selements along the baseline.
 * @param resizable whether the group is resizable
 * @param anchorBaselineToTop whether the baseline is anchored tothe top or bottom of the group
 * @return the {@code ParallelGroup}
 * @see #createBaselineGroup
 * @see ParallelGroup
 */
public ParallelGroup createBaselineGroup(boolean resizable,boolean anchorBaselineToTop){
  return new BaselineGroup(resizable,anchorBaselineToTop);
}"
76977,"/** 
 * Sets the <code>wantsInput</code> property. If <code>newValue</code> is true, an input component (such as a text field or combo box) whose parent is <code>parentComponent</code> is provided to allow the user to input a value. If <code>getSelectionValues</code> returns a non-<code>null</code> array, the input value is one of the objects in that array. Otherwise the input value is whatever the user inputs. <p> This is a bound property.
 * @see #setSelectionValues
 * @see #setInputValue
 * @beaninfo preferred: true bound: true description: Flag which allows the user to input a value.
 */
public void setWantsInput(boolean newValue){
  boolean oldValue=wantsInput;
  wantsInput=newValue;
  firePropertyChange(WANTS_INPUT_PROPERTY,oldValue,newValue);
}","/** 
 * Sets the <code>wantsInput</code> property. If <code>newValue</code> is true, an input component (such as a text field or combo box) whose parent is <code>parentComponent</code> is provided to allow the user to input a value. If <code>getSelectionValues</code> returns a non-<code>null</code> array, the input value is one of the objects in that array. Otherwise the input value is whatever the user inputs. <p> This is a bound property.
 * @param newValue if true, an input component whose parent is {@code parentComponent}is provided to allow the user to input a value.
 * @see #setSelectionValues
 * @see #setInputValue
 * @beaninfo preferred: true bound: true description: Flag which allows the user to input a value.
 */
public void setWantsInput(boolean newValue){
  boolean oldValue=wantsInput;
  wantsInput=newValue;
  firePropertyChange(WANTS_INPUT_PROPERTY,oldValue,newValue);
}"
76978,"/** 
 * Creates a radio button menu item that has the specified text, image, and selection state.  All other constructors defer to this one.
 * @param text  the string displayed on the radio button
 * @param icon  the image that the button should display
 */
public JRadioButtonMenuItem(String text,Icon icon,boolean selected){
  super(text,icon);
  setModel(new JToggleButton.ToggleButtonModel());
  setSelected(selected);
  setFocusable(false);
}","/** 
 * Creates a radio button menu item that has the specified text, image, and selection state.  All other constructors defer to this one.
 * @param text  the string displayed on the radio button
 * @param icon  the image that the button should display
 * @param selected if {@code true}, the button is initially selected, otherwise, the button is initially unselected
 */
public JRadioButtonMenuItem(String text,Icon icon,boolean selected){
  super(text,icon);
  setModel(new JToggleButton.ToggleButtonModel());
  setSelected(selected);
  setFocusable(false);
}"
76979,"/** 
 * Sets the four BoundedRangeModel properties after forcing the arguments to obey the usual constraints: <pre> minimum &le; value &le; value+extent &le; maximum </pre>
 * @see BoundedRangeModel#setRangeProperties
 * @see #setValue
 * @see #setVisibleAmount
 * @see #setMinimum
 * @see #setMaximum
 */
public void setValues(int newValue,int newExtent,int newMin,int newMax){
  BoundedRangeModel m=getModel();
  int oldValue=m.getValue();
  m.setRangeProperties(newValue,newExtent,newMin,newMax,m.getValueIsAdjusting());
  if (accessibleContext != null) {
    accessibleContext.firePropertyChange(AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,Integer.valueOf(oldValue),Integer.valueOf(m.getValue()));
  }
}","/** 
 * Sets the four BoundedRangeModel properties after forcing the arguments to obey the usual constraints: <pre> minimum &le; value &le; value+extent &le; maximum </pre>
 * @param newValue an int giving the current value
 * @param newExtent an int giving the amount by which the value can ""jump""
 * @param newMin an int giving the minimum value
 * @param newMax an int giving the maximum value
 * @see BoundedRangeModel#setRangeProperties
 * @see #setValue
 * @see #setVisibleAmount
 * @see #setMinimum
 * @see #setMaximum
 */
public void setValues(int newValue,int newExtent,int newMin,int newMax){
  BoundedRangeModel m=getModel();
  int oldValue=m.getValue();
  m.setRangeProperties(newValue,newExtent,newMin,newMax,m.getValueIsAdjusting());
  if (accessibleContext != null) {
    accessibleContext.firePropertyChange(AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,Integer.valueOf(oldValue),Integer.valueOf(m.getValue()));
  }
}"
76980,"/** 
 * Set the scrollbar's orientation to either VERTICAL or HORIZONTAL.
 * @exception IllegalArgumentException if orientation is not one of VERTICAL, HORIZONTAL
 * @see #getOrientation
 * @beaninfo preferred: true bound: true attribute: visualUpdate true description: The scrollbar's orientation. enum: VERTICAL JScrollBar.VERTICAL HORIZONTAL JScrollBar.HORIZONTAL
 */
public void setOrientation(int orientation){
  checkOrientation(orientation);
  int oldValue=this.orientation;
  this.orientation=orientation;
  firePropertyChange(""String_Node_Str"",oldValue,orientation);
  if ((oldValue != orientation) && (accessibleContext != null)) {
    accessibleContext.firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,((oldValue == VERTICAL) ? AccessibleState.VERTICAL : AccessibleState.HORIZONTAL),((orientation == VERTICAL) ? AccessibleState.VERTICAL : AccessibleState.HORIZONTAL));
  }
  if (orientation != oldValue) {
    revalidate();
  }
}","/** 
 * Set the scrollbar's orientation to either VERTICAL or HORIZONTAL.
 * @param orientation an orientation of the {@code JScrollBar}
 * @exception IllegalArgumentException if orientation is not one of VERTICAL, HORIZONTAL
 * @see #getOrientation
 * @beaninfo preferred: true bound: true attribute: visualUpdate true description: The scrollbar's orientation. enum: VERTICAL JScrollBar.VERTICAL HORIZONTAL JScrollBar.HORIZONTAL
 */
public void setOrientation(int orientation){
  checkOrientation(orientation);
  int oldValue=this.orientation;
  this.orientation=orientation;
  firePropertyChange(""String_Node_Str"",oldValue,orientation);
  if ((oldValue != orientation) && (accessibleContext != null)) {
    accessibleContext.firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,((oldValue == VERTICAL) ? AccessibleState.VERTICAL : AccessibleState.HORIZONTAL),((orientation == VERTICAL) ? AccessibleState.VERTICAL : AccessibleState.HORIZONTAL));
  }
  if (orientation != oldValue) {
    revalidate();
  }
}"
76981,"/** 
 * Returns data model that handles the scrollbar's four fundamental properties: minimum, maximum, value, extent.
 * @see #setModel
 */
public BoundedRangeModel getModel(){
  return model;
}","/** 
 * Returns data model that handles the scrollbar's four fundamental properties: minimum, maximum, value, extent.
 * @return the data model
 * @see #setModel
 */
public BoundedRangeModel getModel(){
  return model;
}"
76982,"/** 
 * Returns the delegate that implements the look and feel for this component.
 * @see JComponent#setUI
 */
public ScrollBarUI getUI(){
  return (ScrollBarUI)ui;
}","/** 
 * Returns the delegate that implements the look and feel for this component.
 * @return the scroll bar's current UI.
 * @see JComponent#setUI
 */
public ScrollBarUI getUI(){
  return (ScrollBarUI)ui;
}"
76983,"/** 
 * Sets the model's valueIsAdjusting property.  Scrollbar look and feel implementations should set this property to true when a knob drag begins, and to false when the drag ends.  The scrollbar model will not generate ChangeEvents while valueIsAdjusting is true.
 * @see #getValueIsAdjusting
 * @see BoundedRangeModel#setValueIsAdjusting
 * @beaninfo expert: true description: True if the scrollbar thumb is being dragged.
 */
public void setValueIsAdjusting(boolean b){
  BoundedRangeModel m=getModel();
  boolean oldValue=m.getValueIsAdjusting();
  m.setValueIsAdjusting(b);
  if ((oldValue != b) && (accessibleContext != null)) {
    accessibleContext.firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,((oldValue) ? AccessibleState.BUSY : null),((b) ? AccessibleState.BUSY : null));
  }
}","/** 
 * Sets the model's valueIsAdjusting property.  Scrollbar look and feel implementations should set this property to true when a knob drag begins, and to false when the drag ends.  The scrollbar model will not generate ChangeEvents while valueIsAdjusting is true.
 * @param b {@code true} if the upcoming changes to the value property are part of a series
 * @see #getValueIsAdjusting
 * @see BoundedRangeModel#setValueIsAdjusting
 * @beaninfo expert: true description: True if the scrollbar thumb is being dragged.
 */
public void setValueIsAdjusting(boolean b){
  BoundedRangeModel m=getModel();
  boolean oldValue=m.getValueIsAdjusting();
  m.setValueIsAdjusting(b);
  if ((oldValue != b) && (accessibleContext != null)) {
    accessibleContext.firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,((oldValue) ? AccessibleState.BUSY : null),((b) ? AccessibleState.BUSY : null));
  }
}"
76984,"/** 
 * Sets the model that handles the scrollbar's four fundamental properties: minimum, maximum, value, extent.
 * @see #getModel
 * @beaninfo bound: true expert: true description: The scrollbar's BoundedRangeModel.
 */
public void setModel(BoundedRangeModel newModel){
  Integer oldValue=null;
  BoundedRangeModel oldModel=model;
  if (model != null) {
    model.removeChangeListener(fwdAdjustmentEvents);
    oldValue=Integer.valueOf(model.getValue());
  }
  model=newModel;
  if (model != null) {
    model.addChangeListener(fwdAdjustmentEvents);
  }
  firePropertyChange(""String_Node_Str"",oldModel,model);
  if (accessibleContext != null) {
    accessibleContext.firePropertyChange(AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,oldValue,new Integer(model.getValue()));
  }
}","/** 
 * Sets the model that handles the scrollbar's four fundamental properties: minimum, maximum, value, extent.
 * @param newModel a new model
 * @see #getModel
 * @beaninfo bound: true expert: true description: The scrollbar's BoundedRangeModel.
 */
public void setModel(BoundedRangeModel newModel){
  Integer oldValue=null;
  BoundedRangeModel oldModel=model;
  if (model != null) {
    model.removeChangeListener(fwdAdjustmentEvents);
    oldValue=Integer.valueOf(model.getValue());
  }
  model=newModel;
  if (model != null) {
    model.addChangeListener(fwdAdjustmentEvents);
  }
  firePropertyChange(""String_Node_Str"",oldModel,model);
  if (accessibleContext != null) {
    accessibleContext.firePropertyChange(AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,oldValue,new Integer(model.getValue()));
  }
}"
76985,"public AccessibleJToggleButton(){
  super();
  JToggleButton.this.addItemListener(this);
}","/** 
 * Constructs   {@code AccessibleJToggleButton}
 */
public AccessibleJToggleButton(){
  super();
  JToggleButton.this.addItemListener(this);
}"
76986,"protected void init(String text,Icon icon){
  if (text != null) {
    setText(text);
  }
  if (icon != null) {
    setIcon(icon);
  }
  updateUI();
  setAlignmentX(LEFT_ALIGNMENT);
  setAlignmentY(CENTER_ALIGNMENT);
}","/** 
 * Initialization of the   {@code AbstractButton}.
 * @param text  the text of the button
 * @param icon  the Icon image to display on the button
 */
protected void init(String text,Icon icon){
  if (text != null) {
    setText(text);
  }
  if (icon != null) {
    setIcon(icon);
  }
  updateUI();
  setAlignmentX(LEFT_ALIGNMENT);
  setAlignmentY(CENTER_ALIGNMENT);
}"
76987,"protected ItemListener createItemListener(){
  return getHandler();
}","/** 
 * Returns   {@code ItemListener} that is added to model.
 * @return the {@code ItemListener}
 */
protected ItemListener createItemListener(){
  return getHandler();
}"
76988,"/** 
 * If both the icon and text properties are set, this property defines the space between them. <p> The default value of this property is 4 pixels. <p> This is a JavaBeans bound property.
 * @since 1.4
 * @see #getIconTextGap
 * @beaninfo bound: true attribute: visualUpdate true description: If both the icon and text properties are set, this property defines the space between them.
 */
public void setIconTextGap(int iconTextGap){
  int oldValue=this.iconTextGap;
  this.iconTextGap=iconTextGap;
  iconTextGapSet=true;
  firePropertyChange(""String_Node_Str"",oldValue,iconTextGap);
  if (iconTextGap != oldValue) {
    revalidate();
    repaint();
  }
}","/** 
 * If both the icon and text properties are set, this property defines the space between them. <p> The default value of this property is 4 pixels. <p> This is a JavaBeans bound property.
 * @param iconTextGap the space between icon and text if these properties are set.
 * @since 1.4
 * @see #getIconTextGap
 * @beaninfo bound: true attribute: visualUpdate true description: If both the icon and text properties are set, this property defines the space between them.
 */
public void setIconTextGap(int iconTextGap){
  int oldValue=this.iconTextGap;
  this.iconTextGap=iconTextGap;
  iconTextGapSet=true;
  firePropertyChange(""String_Node_Str"",oldValue,iconTextGap);
  if (iconTextGap != oldValue) {
    revalidate();
    repaint();
  }
}"
76989,"/** 
 * Creates and returns a <code>PropertyChangeListener</code> that is responsible for listening for changes from the specified <code>Action</code> and updating the appropriate properties. <p> <b>Warning:</b> If you subclass this do not create an anonymous inner class.  If you do the lifetime of the button will be tied to that of the <code>Action</code>.
 * @param a the button's action
 * @since 1.3
 * @see Action
 * @see #setAction
 */
protected PropertyChangeListener createActionPropertyChangeListener(Action a){
  return createActionPropertyChangeListener0(a);
}","/** 
 * Creates and returns a <code>PropertyChangeListener</code> that is responsible for listening for changes from the specified <code>Action</code> and updating the appropriate properties. <p> <b>Warning:</b> If you subclass this do not create an anonymous inner class.  If you do the lifetime of the button will be tied to that of the <code>Action</code>.
 * @param a the button's action
 * @return the {@code PropertyChangeListener}
 * @since 1.3
 * @see Action
 * @see #setAction
 */
protected PropertyChangeListener createActionPropertyChangeListener(Action a){
  return createActionPropertyChangeListener0(a);
}"
76990,"protected ActionListener createActionListener(){
  return getHandler();
}","/** 
 * Returns   {@code ActionListener} that is added to model.
 * @return the {@code ActionListener}
 */
protected ActionListener createActionListener(){
  return getHandler();
}"
76991,"/** 
 * Gets one of this object's properties using the associated key.
 * @see #putValue
 */
public Object getValue(String key);","/** 
 * Gets one of this object's properties using the associated key.
 * @param key a {@code String} containing the key
 * @return the {@code Object} value
 * @see #putValue
 */
public Object getValue(String key);"
76992,"/** 
 * Returns whether the application has invoked <code>disableSwingFocusManager()</code>.
 * @see #disableSwingFocusManager
 * @deprecated As of 1.4, replaced by<code>KeyboardFocusManager.getDefaultFocusTraversalPolicy()</code>
 */
@Deprecated public static boolean isFocusManagerEnabled(){
  return enabled;
}","/** 
 * Returns whether the application has invoked <code>disableSwingFocusManager()</code>.
 * @return {@code true} if focus manager is enabled.
 * @see #disableSwingFocusManager
 * @deprecated As of 1.4, replaced by<code>KeyboardFocusManager.getDefaultFocusTraversalPolicy()</code>
 */
@Deprecated public static boolean isFocusManagerEnabled(){
  return enabled;
}"
76993,"/** 
 * Selects the list item that corresponds to the specified keyboard character and returns true, if there is an item corresponding to that character.  Otherwise, returns false.
 * @param keyChar a char, typically this is a keyboard keytyped by the user
 */
public boolean selectWithKeyChar(char keyChar){
  int index;
  if (keySelectionManager == null)   keySelectionManager=createDefaultKeySelectionManager();
  index=keySelectionManager.selectionForKey(keyChar,getModel());
  if (index != -1) {
    setSelectedIndex(index);
    return true;
  }
 else   return false;
}","/** 
 * Selects the list item that corresponds to the specified keyboard character and returns true, if there is an item corresponding to that character.  Otherwise, returns false.
 * @param keyChar a char, typically this is a keyboard keytyped by the user
 * @return {@code true} if there is an item corresponding to that character.Otherwise, returns  {@code false}.
 */
public boolean selectWithKeyChar(char keyChar){
  int index;
  if (keySelectionManager == null)   keySelectionManager=createDefaultKeySelectionManager();
  index=keySelectionManager.selectionForKey(keyChar,getModel());
  if (index != -1) {
    setSelectedIndex(index);
    return true;
  }
 else   return false;
}"
76994,"protected void installAncestorListener(){
  addAncestorListener(new AncestorListener(){
    public void ancestorAdded(    AncestorEvent event){
      hidePopup();
    }
    public void ancestorRemoved(    AncestorEvent event){
      hidePopup();
    }
    public void ancestorMoved(    AncestorEvent event){
      if (event.getSource() != JComboBox.this)       hidePopup();
    }
  }
);
}","/** 
 * Registers ancestor listener so that it will receive  {@code AncestorEvents} when it or any of its ancestorsmove or are made visible or invisible. Events are also sent when the component or its ancestors are added or removed from the containment hierarchy.
 */
protected void installAncestorListener(){
  addAncestorListener(new AncestorListener(){
    public void ancestorAdded(    AncestorEvent event){
      hidePopup();
    }
    public void ancestorRemoved(    AncestorEvent event){
      hidePopup();
    }
    public void ancestorMoved(    AncestorEvent event){
      if (event.getSource() != JComboBox.this)       hidePopup();
    }
  }
);
}"
76995,"/** 
 * Creates and returns a <code>PropertyChangeListener</code> that is responsible for listening for changes from the specified <code>Action</code> and updating the appropriate properties. <p> <b>Warning:</b> If you subclass this do not create an anonymous inner class.  If you do the lifetime of the combobox will be tied to that of the <code>Action</code>.
 * @param a the combobox's action
 * @since 1.3
 * @see Action
 * @see #setAction
 */
protected PropertyChangeListener createActionPropertyChangeListener(Action a){
  return new ComboBoxActionPropertyChangeListener(this,a);
}","/** 
 * Creates and returns a <code>PropertyChangeListener</code> that is responsible for listening for changes from the specified <code>Action</code> and updating the appropriate properties. <p> <b>Warning:</b> If you subclass this do not create an anonymous inner class.  If you do the lifetime of the combobox will be tied to that of the <code>Action</code>.
 * @param a the combobox's action
 * @return the {@code PropertyChangeListener}
 * @since 1.3
 * @see Action
 * @see #setAction
 */
protected PropertyChangeListener createActionPropertyChangeListener(Action a){
  return new ComboBoxActionPropertyChangeListener(this,a);
}"
76996,"/** 
 * Sets the object that translates a keyboard character into a list selection. Typically, the first selection with a matching first character becomes the selected item.
 * @beaninfo expert: true description: The objects that changes the selection when a key is pressed.
 */
public void setKeySelectionManager(KeySelectionManager aManager){
  keySelectionManager=aManager;
}","/** 
 * Sets the object that translates a keyboard character into a list selection. Typically, the first selection with a matching first character becomes the selected item.
 * @param aManager a key selection manager
 * @beaninfo expert: true description: The objects that changes the selection when a key is pressed.
 */
public void setKeySelectionManager(KeySelectionManager aManager){
  keySelectionManager=aManager;
}"
76997,"/** 
 * Sets the visibility of the popup.
 */
public void setPopupVisible(boolean v){
  getUI().setPopupVisible(this,v);
}","/** 
 * Sets the visibility of the popup.
 * @param v if {@code true} shows the popup, otherwise, hides the popup.
 */
public void setPopupVisible(boolean v){
  getUI().setPopupVisible(this,v);
}"
76998,"/** 
 * Subclasses that want to handle change events from the model differently can override this to return an instance of a custom <code>ChangeListener</code> implementation. The default   {@code ChangeListener} simply calls the{@code fireStateChanged} method to forward {@code ChangeEvent}s to the   {@code ChangeListener}s that have been added directly to the progress bar.
 * @see #changeListener
 * @see #fireStateChanged
 * @see javax.swing.event.ChangeListener
 * @see javax.swing.BoundedRangeModel
 */
protected ChangeListener createChangeListener(){
  return new ModelListener();
}","/** 
 * Subclasses that want to handle change events from the model differently can override this to return an instance of a custom <code>ChangeListener</code> implementation. The default   {@code ChangeListener} simply calls the{@code fireStateChanged} method to forward {@code ChangeEvent}s to the   {@code ChangeListener}s that have been added directly to the progress bar.
 * @return the instance of a custom {@code ChangeListener} implementation.
 * @see #changeListener
 * @see #fireStateChanged
 * @see javax.swing.event.ChangeListener
 * @see javax.swing.BoundedRangeModel
 */
protected ChangeListener createChangeListener(){
  return new ModelListener();
}"
76999,"/** 
 * Creates a radio button that has the specified text, image, and selection state.
 * @param text  the string displayed on the radio button
 * @param icon  the image that the button should display
 */
public JRadioButton(String text,Icon icon,boolean selected){
  super(text,icon,selected);
  setBorderPainted(false);
  setHorizontalAlignment(LEADING);
}","/** 
 * Creates a radio button that has the specified text, image, and selection state.
 * @param text  the string displayed on the radio button
 * @param icon  the image that the button should display
 * @param selected if {@code true}, the button is initially selected otherwise, the button is initially unselected
 */
public JRadioButton(String text,Icon icon,boolean selected){
  super(text,icon,selected);
  setBorderPainted(false);
  setHorizontalAlignment(LEADING);
}"
77000,"/** 
 * Returns a properly configured <code>PropertyChangeListener</code> which updates the control as changes to the <code>Action</code> occur, or <code>null</code> if the default property change listener for the control is desired.
 * @return <code>null</code>
 */
protected PropertyChangeListener createActionChangeListener(JButton b){
  return null;
}","/** 
 * Returns a properly configured <code>PropertyChangeListener</code> which updates the control as changes to the <code>Action</code> occur, or <code>null</code> if the default property change listener for the control is desired.
 * @param b a {@code JButton}
 * @return {@code null}
 */
protected PropertyChangeListener createActionChangeListener(JButton b){
  return null;
}"
