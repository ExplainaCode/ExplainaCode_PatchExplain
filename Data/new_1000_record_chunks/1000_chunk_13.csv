record_number,buggy_code,fixed_code
12001,"@Around(value=""String_Node_Str"") public void aroundAddIgnoreTagPointcut(ProceedingJoinPoint pjp,Formatter formatter,Reporter reporter,Runtime runtime) throws Throwable {
  logger.debug(""String_Node_Str"");
  CucumberScenario scen=(CucumberScenario)pjp.getThis();
  Scenario scenario=(Scenario)scen.getGherkinModel();
  Class<?> sc=scen.getClass();
  Method tt=sc.getSuperclass().getDeclaredMethod(""String_Node_Str"");
  tt.setAccessible(true);
  Set<Tag> tags=(Set<Tag>)tt.invoke(scen);
  Boolean ignore=false;
  for (  Tag tag : tags) {
    if (""String_Node_Str"".equals(tag.getName())) {
      ignore=true;
    }
  }
  if (ignore) {
    runtime.buildBackendWorlds(reporter,tags,scenario.getName());
    formatter.startOfScenarioLifeCycle(scenario);
    formatter.endOfScenarioLifeCycle(scenario);
    runtime.disposeBackendWorlds();
  }
 else {
    pjp.proceed();
  }
}","/** 
 * @param pjp
 * @param formatter
 * @param reporter
 * @param runtime
 * @throws Throwable
 */
@Around(value=""String_Node_Str"") public void aroundAddIgnoreTagPointcut(ProceedingJoinPoint pjp,Formatter formatter,Reporter reporter,Runtime runtime) throws Throwable {
  logger.debug(""String_Node_Str"");
  CucumberScenario scen=(CucumberScenario)pjp.getThis();
  Scenario scenario=(Scenario)scen.getGherkinModel();
  Class<?> sc=scen.getClass();
  Method tt=sc.getSuperclass().getDeclaredMethod(""String_Node_Str"");
  tt.setAccessible(true);
  Set<Tag> tags=(Set<Tag>)tt.invoke(scen);
  Boolean ignore=false;
  for (  Tag tag : tags) {
    if (""String_Node_Str"".equals(tag.getName())) {
      ignore=true;
    }
  }
  if (ignore) {
    runtime.buildBackendWorlds(reporter,tags,scenario.getName());
    formatter.startOfScenarioLifeCycle(scenario);
    formatter.endOfScenarioLifeCycle(scenario);
    runtime.disposeBackendWorlds();
  }
 else {
    pjp.proceed();
  }
}"
12002,"private File adjustLastCapture(Integer newTrailingImageHeight,List<File> capture) throws IOException {
  Integer finalHeight=0;
  Integer finalWidth=0;
  File trailingImage=capture.get(capture.size() - 1);
  capture.remove(capture.size() - 1);
  BufferedImage oldTrailingImage=ImageIO.read(trailingImage);
  BufferedImage newTrailingImage=new BufferedImage(oldTrailingImage.getWidth(),oldTrailingImage.getHeight() - newTrailingImageHeight,BufferedImage.TYPE_INT_RGB);
  newTrailingImage.createGraphics().drawImage(oldTrailingImage,0,0 - newTrailingImageHeight,null);
  File newTrailingImageF=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  newTrailingImageF.deleteOnExit();
  ImageIO.write(newTrailingImage,""String_Node_Str"",newTrailingImageF);
  capture.add(newTrailingImageF);
  finalWidth=ImageIO.read(capture.get(0)).getWidth();
  for (  File cap : capture) {
    finalHeight+=ImageIO.read(cap).getHeight();
  }
  BufferedImage img=new BufferedImage(finalWidth,finalHeight,BufferedImage.TYPE_INT_RGB);
  Integer y=0;
  BufferedImage tmpImg=null;
  for (  File cap : capture) {
    tmpImg=ImageIO.read(cap);
    img.createGraphics().drawImage(tmpImg,0,y,null);
    y+=tmpImg.getHeight();
  }
  long ts=System.currentTimeMillis() / 1000L;
  File temp;
  temp=File.createTempFile(""String_Node_Str"" + String.valueOf(ts),""String_Node_Str"");
  temp.deleteOnExit();
  ImageIO.write(img,""String_Node_Str"",temp);
  return temp;
}","private File adjustLastCapture(Integer newTrailingImageHeight,List<File> capture) throws IOException {
  Integer finalHeight=0;
  Integer finalWidth=0;
  File trailingImage=capture.get(capture.size() - 1);
  capture.remove(capture.size() - 1);
  BufferedImage oldTrailingImage=ImageIO.read(trailingImage);
  BufferedImage newTrailingImage=new BufferedImage(oldTrailingImage.getWidth(),oldTrailingImage.getHeight() - newTrailingImageHeight,BufferedImage.TYPE_INT_RGB);
  newTrailingImage.createGraphics().drawImage(oldTrailingImage,0,0 - newTrailingImageHeight,null);
  File newTrailingImageF=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  newTrailingImageF.deleteOnExit();
  ImageIO.write(newTrailingImage,""String_Node_Str"",newTrailingImageF);
  capture.add(newTrailingImageF);
  finalWidth=ImageIO.read(capture.get(0)).getWidth();
  for (  File cap : capture) {
    finalHeight+=ImageIO.read(cap).getHeight();
  }
  BufferedImage img=new BufferedImage(finalWidth,finalHeight,BufferedImage.TYPE_INT_RGB);
  Integer y=0;
  BufferedImage tmpImg=null;
  for (  File cap : capture) {
    tmpImg=ImageIO.read(cap);
    img.createGraphics().drawImage(tmpImg,0,y,null);
    y+=tmpImg.getHeight();
  }
  long ts=System.currentTimeMillis() / DEFAULT_CURRENT_TIME;
  File temp;
  temp=File.createTempFile(""String_Node_Str"" + Long.toString(ts),""String_Node_Str"");
  temp.deleteOnExit();
  ImageIO.write(img,""String_Node_Str"",temp);
  return temp;
}"
12003,"private File chromeFullScreenCapture(WebDriver driver) throws IOException, InterruptedException {
  driver.switchTo().defaultContent();
  ArrayList<File> capture=new ArrayList<File>();
  Boolean atBottom=false;
  Integer windowSize=((Long)((JavascriptExecutor)driver).executeScript(""String_Node_Str"")).intValue();
  Integer accuScroll=0;
  Integer newTrailingImageHeight=0;
  while (!atBottom) {
    Thread.sleep(1500);
    capture.add(((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE));
    ((JavascriptExecutor)driver).executeScript(""String_Node_Str"" + ""String_Node_Str"" + windowSize + ""String_Node_Str"");
    accuScroll+=windowSize;
    if (getDocumentHeight(driver) <= accuScroll) {
      atBottom=true;
    }
  }
  newTrailingImageHeight=accuScroll - getDocumentHeight(driver);
  return adjustLastCapture(newTrailingImageHeight,capture);
}","private File chromeFullScreenCapture(WebDriver driver) throws IOException, InterruptedException {
  driver.switchTo().defaultContent();
  ArrayList<File> capture=new ArrayList<File>();
  Boolean atBottom=false;
  Integer windowSize=((Long)((JavascriptExecutor)driver).executeScript(""String_Node_Str"")).intValue();
  Integer accuScroll=0;
  Integer newTrailingImageHeight=0;
  while (!atBottom) {
    Thread.sleep(DEFAULT_SLEEP_TIME);
    capture.add(((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE));
    ((JavascriptExecutor)driver).executeScript(""String_Node_Str"" + ""String_Node_Str"" + windowSize + ""String_Node_Str"");
    accuScroll+=windowSize;
    if (getDocumentHeight(driver) <= accuScroll) {
      atBottom=true;
    }
  }
  newTrailingImageHeight=accuScroll - getDocumentHeight(driver);
  return adjustLastCapture(newTrailingImageHeight,capture);
}"
12004,"@Around(value=""String_Node_Str"") public Object aroundExceptionCalls(ProceedingJoinPoint pjp) throws Throwable {
  Object retVal=null;
  try {
    retVal=pjp.proceed();
    return retVal;
  }
 catch (  Throwable ex) {
    WebDriver driver=null;
    if (ex instanceof WebDriverException) {
      logger.info(""String_Node_Str"");
      if (!(pjp.getThis() instanceof WebDriver)) {
        throw ex;
      }
      driver=(WebDriver)pjp.getThis();
    }
 else     if ((pjp.getTarget() instanceof SeleniumAssert) && (ex instanceof AssertionError)) {
      logger.info(""String_Node_Str"");
      SeleniumAssert as=(SeleniumAssert)pjp.getTarget();
      Class<?> c=as.getClass().getSuperclass();
      Field actual=c.getDeclaredField(""String_Node_Str"");
      actual.setAccessible(true);
      Object realActual=actual.get(as);
      if (realActual instanceof WebDriver) {
        driver=(WebDriver)actual.get(as);
      }
 else       if (realActual instanceof RemoteWebElement) {
        driver=((RemoteWebElement)actual.get(as)).getWrappedDriver();
      }
    }
    if (driver != null) {
      captureEvidence(driver,""String_Node_Str"");
      captureEvidence(driver,""String_Node_Str"");
      captureEvidence(driver,""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"");
    }
    throw ex;
  }
}","/** 
 * @param pjp
 * @return
 * @throws Throwable
 */
@Around(value=""String_Node_Str"") public Object aroundExceptionCalls(ProceedingJoinPoint pjp) throws Throwable {
  Object retVal=null;
  try {
    retVal=pjp.proceed();
    return retVal;
  }
 catch (  Throwable ex) {
    WebDriver driver=null;
    if (ex instanceof WebDriverException) {
      logger.info(""String_Node_Str"");
      if (!(pjp.getThis() instanceof WebDriver)) {
        throw ex;
      }
      driver=(WebDriver)pjp.getThis();
    }
 else     if ((pjp.getTarget() instanceof SeleniumAssert) && (ex instanceof AssertionError)) {
      logger.info(""String_Node_Str"");
      SeleniumAssert as=(SeleniumAssert)pjp.getTarget();
      Class<?> c=as.getClass().getSuperclass();
      Field actual=c.getDeclaredField(""String_Node_Str"");
      actual.setAccessible(true);
      Object realActual=actual.get(as);
      if (realActual instanceof WebDriver) {
        driver=(WebDriver)actual.get(as);
      }
 else       if (realActual instanceof RemoteWebElement) {
        driver=((RemoteWebElement)actual.get(as)).getWrappedDriver();
      }
    }
    if (driver != null) {
      captureEvidence(driver,""String_Node_Str"");
      captureEvidence(driver,""String_Node_Str"");
      captureEvidence(driver,""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"");
    }
    throw ex;
  }
}"
12005,"@Override Attachment.EmptyAttachment parseAttachment(JSONObject attachmentData) throws NxtException.NotValidException {
  return Attachment.AT_PAYMENT;
}","@Override AbstractAttachment parseAttachment(JSONObject attachmentData) throws NxtException.NotValidException {
  return new Attachment.AutomatedTransactionsPayment(attachmentData);
}"
12006,"protected static Long findTransaction(int startHeight,Long atID,int numOfTx,long minAmount){
  try (Connection con=Db.getConnection();PreparedStatement pstmt=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"")){
    pstmt.setInt(1,startHeight);
    pstmt.setInt(2,Nxt.getBlockchain().getHeight());
    pstmt.setLong(3,atID);
    pstmt.setInt(4,numOfTx);
    pstmt.setLong(5,minAmount);
    ResultSet rs=pstmt.executeQuery();
    Long transactionId=0L;
    if (rs.next()) {
      transactionId=rs.getLong(""String_Node_Str"");
    }
    rs.close();
    return transactionId;
  }
 catch (  SQLException e) {
    throw new RuntimeException(e.toString(),e);
  }
}","protected static Long findTransaction(int startHeight,Long atID,int numOfTx,long minAmount){
  try (Connection con=Db.getConnection();PreparedStatement pstmt=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"")){
    pstmt.setInt(1,startHeight);
    pstmt.setInt(2,Nxt.getBlockchain().getHeight());
    pstmt.setLong(3,atID);
    pstmt.setLong(4,minAmount);
    pstmt.setInt(5,numOfTx);
    ResultSet rs=pstmt.executeQuery();
    Long transactionId=0L;
    if (rs.next()) {
      transactionId=rs.getLong(""String_Node_Str"");
    }
    rs.close();
    return transactionId;
  }
 catch (  SQLException e) {
    throw new RuntimeException(e.toString(),e);
  }
}"
12007,"@Override public long get_Type_for_Tx_in_A(AT_Machine_State state){
  long txid=AT_API_Helper.getLong(state.get_A1());
  Transaction tx=Nxt.getBlockchain().getTransaction(txid);
  if (tx != null) {
    if (tx.getType().getType() == 1) {
      return 1;
    }
 else {
      return 0;
    }
  }
  return -1;
}","@Override public long get_Type_for_Tx_in_A(AT_Machine_State state){
  long txid=AT_API_Helper.getLong(state.get_A1());
  Transaction tx=Nxt.getBlockchain().getTransaction(txid);
  if (tx != null) {
    if (tx.getMessage() != null) {
      return 1;
    }
 else {
      return 0;
    }
  }
  return -1;
}"
12008,"public LinkedList<AT_Transaction> getTransactions(){
  return transactions;
}","public Collection<AT_Transaction> getTransactions(){
  return transactions.values();
}"
12009,"public AT_Machine_State(byte[] atId,byte[] creator,byte[] creationBytes,int height){
  this.version=AT_Constants.getInstance().AT_VERSION(height);
  this.atID=atId;
  this.creator=creator;
  ByteBuffer b=ByteBuffer.allocate(creationBytes.length);
  b.order(ByteOrder.LITTLE_ENDIAN);
  b.put(creationBytes);
  b.clear();
  this.version=b.getShort();
  b.getShort();
  int pageSize=(int)AT_Constants.getInstance().PAGE_SIZE(height);
  short codePages=b.getShort();
  short dataPages=b.getShort();
  short callStackPages=b.getShort();
  short userStackPages=b.getShort();
  this.csize=codePages * pageSize;
  this.dsize=dataPages * pageSize;
  this.c_call_stack_bytes=callStackPages * pageSize;
  this.c_user_stack_bytes=userStackPages * pageSize;
  int codeLen=0;
  if (codePages * pageSize < pageSize + 1) {
    codeLen=b.get();
    if (codeLen < 0)     codeLen+=(Byte.MAX_VALUE + 1) * 2;
  }
 else   if (codePages * pageSize < Short.MAX_VALUE + 1) {
    codeLen=b.getShort();
    if (codeLen < 0)     codeLen+=(Short.MAX_VALUE + 1) * 2;
  }
 else {
    codeLen=b.getInt();
  }
  byte[] code=new byte[codeLen];
  b.get(code,0,codeLen);
  this.ap_code=ByteBuffer.allocate(csize);
  this.ap_code.order(ByteOrder.LITTLE_ENDIAN);
  this.ap_code.put(code);
  this.ap_code.clear();
  int dataLen=0;
  if (dataPages * pageSize < 257) {
    dataLen=b.get();
    if (dataLen < 0)     dataLen+=(Byte.MAX_VALUE + 1) * 2;
  }
 else   if (dataPages * pageSize < Short.MAX_VALUE + 1) {
    dataLen=b.getShort();
    if (dataLen < 0)     dataLen+=(Short.MAX_VALUE + 1) * 2;
  }
 else {
    dataLen=b.getInt();
  }
  byte[] data=new byte[dataLen];
  b.get(data,0,dataLen);
  this.ap_data=ByteBuffer.allocate(this.dsize + this.c_call_stack_bytes + this.c_user_stack_bytes);
  this.ap_data.order(ByteOrder.LITTLE_ENDIAN);
  this.ap_data.put(data);
  this.ap_data.clear();
  this.creationBlockHeight=height;
  this.minimumFee=(codePages + dataPages + callStackPages+ userStackPages) * AT_Constants.getInstance().COST_PER_PAGE(height);
  this.waitForNumberOfBlocks=0;
  this.sleepBetween=0;
  this.freezeWhenSameBalance=false;
  this.minActivationAmount=1L;
  this.transactions=new LinkedList<>();
  this.g_balance=0;
  this.p_balance=0;
  this.machineState=new Machine_State();
}","public AT_Machine_State(byte[] atId,byte[] creator,byte[] creationBytes,int height){
  this.version=AT_Constants.getInstance().AT_VERSION(height);
  this.atID=atId;
  this.creator=creator;
  ByteBuffer b=ByteBuffer.allocate(creationBytes.length);
  b.order(ByteOrder.LITTLE_ENDIAN);
  b.put(creationBytes);
  b.clear();
  this.version=b.getShort();
  b.getShort();
  int pageSize=(int)AT_Constants.getInstance().PAGE_SIZE(height);
  short codePages=b.getShort();
  short dataPages=b.getShort();
  short callStackPages=b.getShort();
  short userStackPages=b.getShort();
  this.csize=codePages * pageSize;
  this.dsize=dataPages * pageSize;
  this.c_call_stack_bytes=callStackPages * pageSize;
  this.c_user_stack_bytes=userStackPages * pageSize;
  int codeLen=0;
  if (codePages * pageSize < pageSize + 1) {
    codeLen=b.get();
    if (codeLen < 0)     codeLen+=(Byte.MAX_VALUE + 1) * 2;
  }
 else   if (codePages * pageSize < Short.MAX_VALUE + 1) {
    codeLen=b.getShort();
    if (codeLen < 0)     codeLen+=(Short.MAX_VALUE + 1) * 2;
  }
 else {
    codeLen=b.getInt();
  }
  byte[] code=new byte[codeLen];
  b.get(code,0,codeLen);
  this.ap_code=ByteBuffer.allocate(csize);
  this.ap_code.order(ByteOrder.LITTLE_ENDIAN);
  this.ap_code.put(code);
  this.ap_code.clear();
  int dataLen=0;
  if (dataPages * pageSize < 257) {
    dataLen=b.get();
    if (dataLen < 0)     dataLen+=(Byte.MAX_VALUE + 1) * 2;
  }
 else   if (dataPages * pageSize < Short.MAX_VALUE + 1) {
    dataLen=b.getShort();
    if (dataLen < 0)     dataLen+=(Short.MAX_VALUE + 1) * 2;
  }
 else {
    dataLen=b.getInt();
  }
  byte[] data=new byte[dataLen];
  b.get(data,0,dataLen);
  this.ap_data=ByteBuffer.allocate(this.dsize + this.c_call_stack_bytes + this.c_user_stack_bytes);
  this.ap_data.order(ByteOrder.LITTLE_ENDIAN);
  this.ap_data.put(data);
  this.ap_data.clear();
  this.creationBlockHeight=height;
  this.minimumFee=(codePages + dataPages + callStackPages+ userStackPages) * AT_Constants.getInstance().COST_PER_PAGE(height);
  this.waitForNumberOfBlocks=0;
  this.sleepBetween=0;
  this.freezeWhenSameBalance=false;
  this.minActivationAmount=1L;
  this.transactions=new LinkedHashMap<>();
  this.g_balance=0;
  this.p_balance=0;
  this.machineState=new Machine_State();
}"
12010,"public byte[] getTransactionBytes(){
  ByteBuffer b=ByteBuffer.allocate((creator.length + 8) * transactions.size());
  b.order(ByteOrder.LITTLE_ENDIAN);
  for (  AT_Transaction tx : transactions) {
    b.put(tx.getRecipientId());
    b.putLong(tx.getAmount());
  }
  return b.array();
}","public byte[] getTransactionBytes(){
  ByteBuffer b=ByteBuffer.allocate((creator.length + 8) * transactions.size());
  b.order(ByteOrder.LITTLE_ENDIAN);
  for (  AT_Transaction tx : transactions.values()) {
    b.put(tx.getRecipientId());
    b.putLong(tx.getAmount());
  }
  return b.array();
}"
12011,"protected void addTransaction(AT_Transaction tx){
  transactions.add(tx);
}","protected void addTransaction(AT_Transaction tx){
  ByteBuffer recipId=ByteBuffer.wrap(tx.getRecipientId());
  AT_Transaction oldTx=transactions.get(recipId);
  if (oldTx == null) {
    transactions.put(recipId,tx);
  }
 else {
    AT_Transaction newTx=new AT_Transaction(tx.getSenderId(),tx.getRecipientId(),oldTx.getAmount() + tx.getAmount(),tx.getMessage() != null ? tx.getMessage() : oldTx.getMessage());
    transactions.put(recipId,newTx);
  }
}"
12012,"static void saveTransactions(Connection con,AT at,Block block){
  try {
    for (    AT_Transaction transaction : at.getTransactions()) {
      try (PreparedStatement pstmt=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"")){
        int i=0;
        byte[] signature=new byte[64];
        byte[] hash;
        Account senderAccount=Account.getAccount(AT_API_Helper.getLong(at.getId()));
        Account recipientAccount=Account.getAccount(AT_API_Helper.getLong(transaction.getRecipientId()));
        Long totalAmount=transaction.getAmount();
        if (!(senderAccount.getUnconfirmedBalanceNQT() < totalAmount)) {
          senderAccount.addToUnconfirmedBalanceNQT(-totalAmount);
          senderAccount.addToBalanceNQT(-totalAmount);
          recipientAccount.addToBalanceAndUnconfirmedBalanceNQT(totalAmount);
          ByteBuffer b=ByteBuffer.allocate((8 + 8));
          b.order(ByteOrder.LITTLE_ENDIAN);
          b.put(transaction.getRecipientId());
          b.putLong(transaction.getAmount());
          byte[] data=at.getBytes();
          byte[] signatureHash=Crypto.sha256().digest(signature);
          MessageDigest digest=Crypto.sha256();
          digest.update(data);
          digest.update(b.array());
          digest.update(block.getBlockSignature());
          hash=digest.digest(signatureHash);
          BigInteger bigInteger=new BigInteger(1,new byte[]{hash[7],hash[6],hash[5],hash[4],hash[3],hash[2],hash[1],hash[0]});
          Long id=bigInteger.longValue();
          String fullHash=Convert.toHexString(hash);
          pstmt.setLong(++i,id);
          pstmt.setShort(++i,(short)1440);
          pstmt.setBytes(++i,new byte[32]);
          if (transaction.getRecipientId() != null) {
            pstmt.setLong(++i,AT_API_Helper.getLong(transaction.getRecipientId()));
          }
 else {
            pstmt.setNull(++i,Types.BIGINT);
          }
          pstmt.setLong(++i,transaction.getAmount());
          pstmt.setLong(++i,0L);
          pstmt.setNull(++i,Types.BINARY);
          pstmt.setInt(++i,block.getHeight());
          pstmt.setLong(++i,block.getId());
          pstmt.setBytes(++i,new byte[64]);
          pstmt.setInt(++i,block.getTimestamp());
          pstmt.setByte(++i,(byte)5);
          pstmt.setByte(++i,(byte)1);
          pstmt.setLong(++i,AT_API_Helper.getLong(at.getId()));
          int bytesLength=0;
          Attachment appendage=Attachment.AT_PAYMENT;
          bytesLength+=appendage.getSize();
          if (bytesLength == 0) {
            pstmt.setNull(++i,Types.VARBINARY);
          }
 else {
            ByteBuffer buffer=ByteBuffer.allocate(bytesLength);
            buffer.order(ByteOrder.LITTLE_ENDIAN);
            appendage.putBytes(buffer);
            pstmt.setBytes(++i,buffer.array());
          }
          pstmt.setInt(++i,block.getTimestamp());
          pstmt.setBytes(++i,Convert.parseHexString(fullHash));
          pstmt.setByte(++i,(byte)1);
          pstmt.setBoolean(++i,false);
          pstmt.setBoolean(++i,false);
          pstmt.setBoolean(++i,false);
          pstmt.setBoolean(++i,false);
          Block ecBlock=EconomicClustering.getECBlockId(block.getTimestamp());
          pstmt.setInt(++i,ecBlock.getHeight());
          if (block.getId() != null) {
            pstmt.setLong(++i,block.getId());
          }
 else {
            pstmt.setNull(++i,Types.BIGINT);
          }
          pstmt.executeUpdate();
        }
      }
     }
  }
 catch (  SQLException e) {
    throw new RuntimeException(e.toString(),e);
  }
}","static void saveTransactions(Connection con,AT at,Block block){
  try {
    for (    AT_Transaction transaction : at.getTransactions()) {
      try (PreparedStatement pstmt=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"")){
        int i=0;
        byte[] signature=new byte[64];
        byte[] hash;
        Account senderAccount=Account.getAccount(AT_API_Helper.getLong(at.getId()));
        Account recipientAccount=Account.getAccount(AT_API_Helper.getLong(transaction.getRecipientId()));
        Long totalAmount=transaction.getAmount();
        if (!(senderAccount.getUnconfirmedBalanceNQT() < totalAmount)) {
          senderAccount.addToUnconfirmedBalanceNQT(-totalAmount);
          senderAccount.addToBalanceNQT(-totalAmount);
          recipientAccount.addToBalanceAndUnconfirmedBalanceNQT(totalAmount);
          ByteBuffer b=ByteBuffer.allocate((8 + 8));
          b.order(ByteOrder.LITTLE_ENDIAN);
          b.put(transaction.getRecipientId());
          b.putLong(transaction.getAmount());
          byte[] data=at.getBytes();
          byte[] signatureHash=Crypto.sha256().digest(signature);
          MessageDigest digest=Crypto.sha256();
          digest.update(data);
          digest.update(b.array());
          digest.update(block.getBlockSignature());
          hash=digest.digest(signatureHash);
          BigInteger bigInteger=new BigInteger(1,new byte[]{hash[7],hash[6],hash[5],hash[4],hash[3],hash[2],hash[1],hash[0]});
          Long id=bigInteger.longValue();
          String fullHash=Convert.toHexString(hash);
          pstmt.setLong(++i,id);
          pstmt.setShort(++i,(short)1440);
          pstmt.setBytes(++i,new byte[32]);
          if (transaction.getRecipientId() != null) {
            pstmt.setLong(++i,AT_API_Helper.getLong(transaction.getRecipientId()));
          }
 else {
            pstmt.setNull(++i,Types.BIGINT);
          }
          pstmt.setLong(++i,transaction.getAmount());
          pstmt.setLong(++i,0L);
          pstmt.setNull(++i,Types.BINARY);
          pstmt.setInt(++i,block.getHeight());
          pstmt.setLong(++i,block.getId());
          pstmt.setBytes(++i,new byte[64]);
          pstmt.setInt(++i,block.getTimestamp());
          pstmt.setByte(++i,(byte)5);
          pstmt.setByte(++i,(byte)1);
          pstmt.setLong(++i,AT_API_Helper.getLong(at.getId()));
          int bytesLength=0;
          Attachment appendage=Attachment.AT_PAYMENT;
          bytesLength+=appendage.getSize();
          if (bytesLength == 0) {
            pstmt.setNull(++i,Types.VARBINARY);
          }
 else {
            ByteBuffer buffer=ByteBuffer.allocate(bytesLength);
            buffer.order(ByteOrder.LITTLE_ENDIAN);
            appendage.putBytes(buffer);
            pstmt.setBytes(++i,buffer.array());
          }
          pstmt.setInt(++i,block.getTimestamp());
          pstmt.setBytes(++i,Convert.parseHexString(fullHash));
          pstmt.setByte(++i,(byte)1);
          pstmt.setBoolean(++i,false);
          pstmt.setBoolean(++i,false);
          pstmt.setBoolean(++i,false);
          pstmt.setBoolean(++i,false);
          Block ecBlock=EconomicClustering.getECBlock(block.getTimestamp());
          pstmt.setInt(++i,ecBlock.getHeight());
          if (block.getId() != 0L) {
            pstmt.setLong(++i,ecBlock.getId());
          }
 else {
            pstmt.setNull(++i,Types.BIGINT);
          }
          pstmt.executeUpdate();
        }
      }
     }
  }
 catch (  SQLException e) {
    throw new RuntimeException(e.toString(),e);
  }
}"
12013,"public static AT getAT(Long id){
  try (PreparedStatement pstmt=Db.getConnection().prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"")){
    int i=0;
    pstmt.setLong(++i,id);
    ResultSet result=pstmt.executeQuery();
    List<AT> ats=createATs(result);
    if (ats.size() > 0) {
      return ats.get(0);
    }
    return null;
  }
 catch (  SQLException e) {
    throw new RuntimeException(e.toString(),e);
  }
}","public static AT getAT(Long id){
  try (Connection con=Db.getConnection();PreparedStatement pstmt=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"")){
    int i=0;
    pstmt.setLong(++i,id);
    ResultSet result=pstmt.executeQuery();
    List<AT> ats=createATs(result);
    if (ats.size() > 0) {
      return ats.get(0);
    }
    return null;
  }
 catch (  SQLException e) {
    throw new RuntimeException(e.toString(),e);
  }
}"
12014,"public static List<AT> getATsIssuedBy(Long accountId){
  try (PreparedStatement pstmt=Db.getConnection().prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"")){
    pstmt.setLong(1,accountId);
    ResultSet result=pstmt.executeQuery();
    return createATs(result);
  }
 catch (  SQLException e) {
    throw new RuntimeException(e.toString(),e);
  }
}","public static List<Long> getATsIssuedBy(Long accountId){
  try (Connection con=Db.getConnection();PreparedStatement pstmt=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"")){
    pstmt.setLong(1,accountId);
    ResultSet result=pstmt.executeQuery();
    List<Long> resultList=new ArrayList<>();
    while (result.next()) {
      resultList.add(result.getLong(1));
    }
    return resultList;
  }
 catch (  SQLException e) {
    throw new RuntimeException(e.toString(),e);
  }
}"
12015,"public static List<Long> getOrderedATs(){
  List<Long> orderedATs=new ArrayList<>();
  try (PreparedStatement pstmt=Db.getConnection().prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"")){
    pstmt.setInt(1,Nxt.getBlockchain().getHeight());
    pstmt.setLong(2,AT_Constants.getInstance().STEP_FEE(Nxt.getBlockchain().getHeight()));
    ResultSet result=pstmt.executeQuery();
    while (result.next()) {
      Long id=result.getLong(1);
      orderedATs.add(id);
    }
  }
 catch (  SQLException e) {
    throw new RuntimeException(e.toString(),e);
  }
  return orderedATs;
}","public static List<Long> getOrderedATs(){
  List<Long> orderedATs=new ArrayList<>();
  try (Connection con=Db.getConnection();PreparedStatement pstmt=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"")){
    pstmt.setInt(1,Nxt.getBlockchain().getHeight());
    pstmt.setLong(2,AT_Constants.getInstance().STEP_FEE(Nxt.getBlockchain().getHeight()));
    ResultSet result=pstmt.executeQuery();
    while (result.next()) {
      Long id=result.getLong(1);
      orderedATs.add(id);
    }
  }
 catch (  SQLException e) {
    throw new RuntimeException(e.toString(),e);
  }
  return orderedATs;
}"
12016,"byte[] getBytes(){
  ByteBuffer buffer=ByteBuffer.allocate(4 + 4 + 8+ 4+ (version < 3 ? (4 + 4) : (8 + 8))+ 4+ 32+ 32+ (32 + 32)+ 8+ (blockATs != null ? blockATs.length : 0)+ 64);
  buffer.order(ByteOrder.LITTLE_ENDIAN);
  buffer.putInt(version);
  buffer.putInt(timestamp);
  buffer.putLong(previousBlockId);
  buffer.putInt(getTransactions().size());
  if (version < 3) {
    buffer.putInt((int)(totalAmountNQT / Constants.ONE_NXT));
    buffer.putInt((int)(totalFeeNQT / Constants.ONE_NXT));
  }
 else {
    buffer.putLong(totalAmountNQT);
    buffer.putLong(totalFeeNQT);
  }
  buffer.putInt(payloadLength);
  buffer.put(payloadHash);
  buffer.put(generatorPublicKey);
  buffer.put(generationSignature);
  if (version > 1) {
    buffer.put(previousBlockHash);
  }
  buffer.putLong(nonce);
  buffer.put(blockATs);
  buffer.put(blockSignature);
  return buffer.array();
}","byte[] getBytes(){
  ByteBuffer buffer=ByteBuffer.allocate(4 + 4 + 8+ 4+ (version < 3 ? (4 + 4) : (8 + 8))+ 4+ 32+ 32+ (32 + 32)+ 8+ (blockATs != null ? blockATs.length : 0)+ 64);
  buffer.order(ByteOrder.LITTLE_ENDIAN);
  buffer.putInt(version);
  buffer.putInt(timestamp);
  buffer.putLong(previousBlockId);
  buffer.putInt(getTransactions().size());
  if (version < 3) {
    buffer.putInt((int)(totalAmountNQT / Constants.ONE_NXT));
    buffer.putInt((int)(totalFeeNQT / Constants.ONE_NXT));
  }
 else {
    buffer.putLong(totalAmountNQT);
    buffer.putLong(totalFeeNQT);
  }
  buffer.putInt(payloadLength);
  buffer.put(payloadHash);
  buffer.put(generatorPublicKey);
  buffer.put(generationSignature);
  if (version > 1) {
    buffer.put(previousBlockHash);
  }
  buffer.putLong(nonce);
  if (blockATs != null)   buffer.put(blockATs);
  buffer.put(blockSignature);
  return buffer.array();
}"
12017,"public static AT_Block validateATs(byte[] blockATs,int blockHeight) throws NoSuchAlgorithmException, AT_Exception {
  LinkedHashMap<byte[],byte[]> ats=getATsFromBlock(blockATs);
  List<AT> processedATs=new ArrayList<>();
  boolean validated=true;
  long totalSteps=0;
  MessageDigest digest=MessageDigest.getInstance(""String_Node_Str"");
  byte[] md5=null;
  for (  byte[] atId : ats.keySet()) {
    AT at=AT.getAT(atId);
    try {
      at.clearTransactions();
      at.setWaitForNumberOfBlocks(at.getSleepBetween());
      long atAccountBalance=getATAccountBalance(AT_API_Helper.getLong(atId));
      if (atAccountBalance < AT_Constants.getInstance().STEP_FEE(blockHeight)) {
        throw new AT_Exception(""String_Node_Str"");
      }
      if (at.freezeOnSameBalance() && atAccountBalance == at.getG_balance()) {
        throw new AT_Exception(""String_Node_Str"");
      }
      at.setG_balance(atAccountBalance);
      listCode(at,true,true);
      runSteps(at);
      totalSteps+=at.getMachineState().steps;
      AT.addPendingFee(atId,at.getMachineState().steps * AT_Constants.getInstance().STEP_FEE(blockHeight));
      at.setP_balance(at.getG_balance());
      processedATs.add(at);
      md5=digest.digest(at.getBytes());
      if (!Arrays.equals(md5,ats.get(atId))) {
        throw new AT_Exception(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      throw new AT_Exception(""String_Node_Str"");
    }
  }
  long totalAmount=0;
  for (  AT at : processedATs) {
    at.saveState();
    totalAmount=makeTransactions(at);
  }
  AT_Block atBlock=new AT_Block(totalSteps * AT_Constants.getInstance().STEP_FEE(blockHeight),totalAmount,new byte[1],validated);
  return atBlock;
}","public static AT_Block validateATs(byte[] blockATs,int blockHeight) throws NoSuchAlgorithmException, AT_Exception {
  if (blockATs == null) {
    return new AT_Block(0,0,null,true);
  }
  LinkedHashMap<byte[],byte[]> ats=getATsFromBlock(blockATs);
  List<AT> processedATs=new ArrayList<>();
  boolean validated=true;
  long totalSteps=0;
  MessageDigest digest=MessageDigest.getInstance(""String_Node_Str"");
  byte[] md5=null;
  for (  byte[] atId : ats.keySet()) {
    AT at=AT.getAT(atId);
    try {
      at.clearTransactions();
      at.setWaitForNumberOfBlocks(at.getSleepBetween());
      long atAccountBalance=getATAccountBalance(AT_API_Helper.getLong(atId));
      if (atAccountBalance < AT_Constants.getInstance().STEP_FEE(blockHeight)) {
        throw new AT_Exception(""String_Node_Str"");
      }
      if (at.freezeOnSameBalance() && atAccountBalance == at.getG_balance()) {
        throw new AT_Exception(""String_Node_Str"");
      }
      at.setG_balance(atAccountBalance);
      listCode(at,true,true);
      runSteps(at);
      totalSteps+=at.getMachineState().steps;
      AT.addPendingFee(atId,at.getMachineState().steps * AT_Constants.getInstance().STEP_FEE(blockHeight));
      at.setP_balance(at.getG_balance());
      processedATs.add(at);
      md5=digest.digest(at.getBytes());
      if (!Arrays.equals(md5,ats.get(atId))) {
        throw new AT_Exception(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      throw new AT_Exception(""String_Node_Str"");
    }
  }
  long totalAmount=0;
  for (  AT at : processedATs) {
    at.saveState();
    totalAmount=makeTransactions(at);
  }
  AT_Block atBlock=new AT_Block(totalSteps * AT_Constants.getInstance().STEP_FEE(blockHeight),totalAmount,new byte[1],validated);
  return atBlock;
}"
12018,"private static void saveResultTransaction(Long blockId,int blockHeight,int blockTime,Long escrowId,Long recipientId,Long amountNQT,DecisionType decision){
  Attachment.AbstractAttachment attachment=new Attachment.AdvancedPaymentEscrowResult(escrowId,decision);
  TransactionImpl.BuilderImpl builder=new TransactionImpl.BuilderImpl((byte)1,Genesis.CREATOR_PUBLIC_KEY,amountNQT,0L,blockTime,(short)1440,attachment);
  builder.recipientId(recipientId).referencedTransactionFullHash((String)null).signature(null).blockId(blockId).height(blockHeight).id(null).senderId(null).blockTimestamp(blockTime).fullHash((String)null).ecBlockHeight(0).ecBlockId(null);
  List<TransactionImpl> transactionList=new ArrayList<>();
  try {
    TransactionImpl transaction=builder.build();
    transactionList.add(transaction);
  }
 catch (  NxtException.NotValidException e) {
    throw new RuntimeException(e.toString(),e);
  }
  try (Connection con=Db.getConnection()){
    TransactionDb.saveTransactions(con,transactionList);
  }
 catch (  SQLException e) {
    throw new RuntimeException(e.toString(),e);
  }
}","private static void saveResultTransaction(Long blockId,int blockHeight,int blockTime,Long escrowId,Long recipientId,Long amountNQT,DecisionType decision){
  Attachment.AbstractAttachment attachment=new Attachment.AdvancedPaymentEscrowResult(escrowId,decision);
  TransactionImpl.BuilderImpl builder=new TransactionImpl.BuilderImpl((byte)1,Genesis.CREATOR_PUBLIC_KEY,amountNQT,0L,blockTime,(short)1440,attachment);
  builder.senderId(0L).recipientId(recipientId).referencedTransactionFullHash((String)null).signature(null).blockId(blockId).height(blockHeight).id(null).senderId(null).blockTimestamp(blockTime).fullHash((String)null).ecBlockHeight(0).ecBlockId(0L);
  List<TransactionImpl> transactionList=new ArrayList<>();
  try {
    TransactionImpl transaction=builder.build();
    transactionList.add(transaction);
  }
 catch (  NxtException.NotValidException e) {
    throw new RuntimeException(e.toString(),e);
  }
  try (Connection con=Db.getConnection()){
    TransactionDb.saveTransactions(con,transactionList);
    con.commit();
  }
 catch (  SQLException e) {
    throw new RuntimeException(e.toString(),e);
  }
}"
12019,"private synchronized boolean process(Long blockId,int blockHeight,int blockTime,boolean apply,boolean scanning) throws NotValidException {
  if (blockTime < timeNext) {
    return true;
  }
  Account sender=Account.getAccount(senderId);
  Account recipient=Account.getAccount(recipientId);
  long totalAmountNQT=Convert.safeAdd(amountNQT,Convert.safeDivide(Constants.ONE_NXT,10L));
  if (sender.getBalanceNQT() < totalAmountNQT) {
    return false;
  }
  if (apply) {
    sender.addToBalanceAndUnconfirmedBalanceNQT(-totalAmountNQT);
    recipient.addToBalanceAndUnconfirmedBalanceNQT(amountNQT);
    timeLast=timeNext;
    timeNext+=frequency;
    if (!scanning) {
      Attachment.AbstractAttachment attachment=new Attachment.AdvancedPaymentSubscriptionPayment(id);
      TransactionImpl.BuilderImpl builder=new TransactionImpl.BuilderImpl((byte)1,sender.getPublicKey(),amountNQT,Convert.safeDivide(Constants.ONE_NXT,10L),timeLast,(short)1440,attachment);
      builder.referencedTransactionFullHash((String)null).signature(null).blockId(blockId).height(blockHeight).id(null).senderId(null).blockTimestamp(blockTime).fullHash((String)null).ecBlockHeight(0).ecBlockId(null);
      TransactionImpl transaction=builder.build();
      paymentTransactions.add(transaction);
    }
  }
  return true;
}","private synchronized boolean process(Long blockId,int blockHeight,int blockTime,boolean apply,boolean scanning) throws NotValidException {
  if (blockTime < timeNext) {
    return true;
  }
  Account sender=Account.getAccount(senderId);
  Account recipient=Account.getAccount(recipientId);
  long totalAmountNQT=Convert.safeAdd(amountNQT,Convert.safeDivide(Constants.ONE_NXT,10L));
  if (sender.getBalanceNQT() < totalAmountNQT) {
    return false;
  }
  if (apply) {
    sender.addToBalanceAndUnconfirmedBalanceNQT(-totalAmountNQT);
    recipient.addToBalanceAndUnconfirmedBalanceNQT(amountNQT);
    timeLast=timeNext;
    timeNext+=frequency;
    if (!scanning) {
      Attachment.AbstractAttachment attachment=new Attachment.AdvancedPaymentSubscriptionPayment(id);
      TransactionImpl.BuilderImpl builder=new TransactionImpl.BuilderImpl((byte)1,sender.getPublicKey(),amountNQT,Convert.safeDivide(Constants.ONE_NXT,10L),timeLast,(short)1440,attachment);
      builder.senderId(senderId).recipientId(recipientId).referencedTransactionFullHash((String)null).signature(null).blockId(blockId).height(blockHeight).id(null).senderId(null).blockTimestamp(blockTime).fullHash((String)null).ecBlockHeight(0).ecBlockId(0L);
      TransactionImpl transaction=builder.build();
      paymentTransactions.add(transaction);
    }
  }
  return true;
}"
12020,"public static void saveTransactions(){
  if (paymentTransactions.size() > 0) {
    try (Connection con=Db.getConnection()){
      TransactionDb.saveTransactions(con,paymentTransactions);
    }
 catch (    SQLException e) {
      throw new RuntimeException(e.toString(),e);
    }
    paymentTransactions.clear();
  }
}","public static void saveTransactions(){
  if (paymentTransactions.size() > 0) {
    try (Connection con=Db.getConnection()){
      TransactionDb.saveTransactions(con,paymentTransactions);
      con.commit();
    }
 catch (    SQLException e) {
      throw new RuntimeException(e.toString(),e);
    }
    paymentTransactions.clear();
  }
}"
12021,"static JSONObject subscription(Subscription subscription){
  JSONObject json=new JSONObject();
  json.put(""String_Node_Str"",subscription.getId());
  putAccount(json,""String_Node_Str"",subscription.getSenderId());
  putAccount(json,""String_Node_Str"",subscription.getRecipientId());
  json.put(""String_Node_Str"",subscription.getAmountNQT());
  json.put(""String_Node_Str"",subscription.getFrequency());
  json.put(""String_Node_Str"",subscription.getTimeStart());
  json.put(""String_Node_Str"",subscription.getTimeLast());
  json.put(""String_Node_Str"",subscription.getTimeNext());
  return json;
}","static JSONObject subscription(Subscription subscription){
  JSONObject json=new JSONObject();
  json.put(""String_Node_Str"",Convert.toUnsignedLong(subscription.getId()));
  putAccount(json,""String_Node_Str"",subscription.getSenderId());
  putAccount(json,""String_Node_Str"",subscription.getRecipientId());
  json.put(""String_Node_Str"",Convert.toUnsignedLong(subscription.getAmountNQT()));
  json.put(""String_Node_Str"",subscription.getFrequency());
  json.put(""String_Node_Str"",subscription.getTimeStart());
  json.put(""String_Node_Str"",subscription.getTimeLast());
  json.put(""String_Node_Str"",subscription.getTimeNext());
  return json;
}"
12022,"public ExtractMethodFragmentRefactoring(){
  this.tryStatementsToBeRemoved=new LinkedHashSet<TryStatement>();
  this.tryStatementsToBeCopied=new LinkedHashSet<TryStatement>();
  this.tryStatementBodyRewriteMap=new LinkedHashMap<TryStatement,ListRewrite>();
  this.doLoopNodes=new ArrayList<CFGBranchDoLoopNode>();
}","public ExtractMethodFragmentRefactoring(){
  this.tryStatementsToBeRemoved=new LinkedHashSet<TryStatement>();
  this.tryStatementsToBeCopied=new LinkedHashSet<TryStatement>();
  this.tryStatementBodyRewriteMap=new LinkedHashMap<TryStatement,ListRewrite>();
  this.doLoopNodes=new ArrayList<CFGBranchDoLoopNode>();
  this.labeledStatementsToBeRemoved=new LinkedHashSet<LabeledStatement>();
}"
12023,"protected Statement processPredicateNode(PDGControlPredicateNode predicateNode,AST ast,ASTRewrite sourceRewriter,List<PDGNode> sliceNodes){
  Statement oldPredicateStatement=predicateNode.getASTStatement();
  sliceNodes.remove(predicateNode);
  Statement newPredicateStatement=null;
  if (oldPredicateStatement instanceof IfStatement) {
    IfStatement oldIfStatement=(IfStatement)oldPredicateStatement;
    IfStatement newIfStatement=ast.newIfStatement();
    newPredicateStatement=newIfStatement;
    sourceRewriter.set(newIfStatement,IfStatement.EXPRESSION_PROPERTY,oldIfStatement.getExpression(),null);
    Iterator<GraphEdge> outgoingDependenceIterator=predicateNode.getOutgoingDependenceIterator();
    List<PDGNode> trueControlDependentChildren=new ArrayList<PDGNode>();
    List<PDGNode> falseControlDependentChildren=new ArrayList<PDGNode>();
    while (outgoingDependenceIterator.hasNext()) {
      PDGDependence dependence=(PDGDependence)outgoingDependenceIterator.next();
      if (dependence instanceof PDGControlDependence) {
        PDGControlDependence controlDependence=(PDGControlDependence)dependence;
        PDGNode dstPDGNode=(PDGNode)controlDependence.getDst();
        if (sliceNodes.contains(dstPDGNode)) {
          if (controlDependence.isTrueControlDependence()) {
            trueControlDependentChildren.add(dstPDGNode);
          }
 else           if (controlDependence.isFalseControlDependence()) {
            falseControlDependentChildren.add(dstPDGNode);
          }
        }
      }
    }
    if (oldIfStatement.getThenStatement() instanceof Block || trueControlDependentChildren.size() > 1) {
      Block thenBlock=ast.newBlock();
      ListRewrite thenBodyRewrite=sourceRewriter.getListRewrite(thenBlock,Block.STATEMENTS_PROPERTY);
      for (      PDGNode dstPDGNode : trueControlDependentChildren) {
        ListRewrite listRewrite=thenBodyRewrite;
        listRewrite=createTryStatementIfNeeded(sourceRewriter,ast,listRewrite,dstPDGNode);
        if (dstPDGNode instanceof PDGControlPredicateNode) {
          PDGControlPredicateNode dstPredicateNode=(PDGControlPredicateNode)dstPDGNode;
          listRewrite.insertLast(processPredicateNode(dstPredicateNode,ast,sourceRewriter,sliceNodes),null);
        }
 else {
          processStatementNode(listRewrite,dstPDGNode,ast,sourceRewriter);
          sliceNodes.remove(dstPDGNode);
        }
      }
      sourceRewriter.set(newIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,thenBlock,null);
    }
 else     if (trueControlDependentChildren.size() == 1) {
      PDGNode dstPDGNode=trueControlDependentChildren.get(0);
      if (dstPDGNode instanceof PDGControlPredicateNode) {
        PDGControlPredicateNode dstPredicateNode=(PDGControlPredicateNode)dstPDGNode;
        sourceRewriter.set(newIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,processPredicateNode(dstPredicateNode,ast,sourceRewriter,sliceNodes),null);
      }
 else {
        sourceRewriter.set(newIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,dstPDGNode.getASTStatement(),null);
        sliceNodes.remove(dstPDGNode);
      }
    }
    if (oldIfStatement.getElseStatement() instanceof Block || falseControlDependentChildren.size() > 1) {
      Block elseBlock=ast.newBlock();
      ListRewrite elseBodyRewrite=sourceRewriter.getListRewrite(elseBlock,Block.STATEMENTS_PROPERTY);
      for (      PDGNode dstPDGNode : falseControlDependentChildren) {
        ListRewrite listRewrite=elseBodyRewrite;
        listRewrite=createTryStatementIfNeeded(sourceRewriter,ast,listRewrite,dstPDGNode);
        if (dstPDGNode instanceof PDGControlPredicateNode) {
          PDGControlPredicateNode dstPredicateNode=(PDGControlPredicateNode)dstPDGNode;
          listRewrite.insertLast(processPredicateNode(dstPredicateNode,ast,sourceRewriter,sliceNodes),null);
        }
 else {
          processStatementNode(listRewrite,dstPDGNode,ast,sourceRewriter);
          sliceNodes.remove(dstPDGNode);
        }
      }
      sourceRewriter.set(newIfStatement,IfStatement.ELSE_STATEMENT_PROPERTY,elseBlock,null);
    }
 else     if (falseControlDependentChildren.size() == 1) {
      PDGNode dstPDGNode=falseControlDependentChildren.get(0);
      if (dstPDGNode instanceof PDGControlPredicateNode) {
        PDGControlPredicateNode dstPredicateNode=(PDGControlPredicateNode)dstPDGNode;
        sourceRewriter.set(newIfStatement,IfStatement.ELSE_STATEMENT_PROPERTY,processPredicateNode(dstPredicateNode,ast,sourceRewriter,sliceNodes),null);
      }
 else {
        sourceRewriter.set(newIfStatement,IfStatement.ELSE_STATEMENT_PROPERTY,dstPDGNode.getASTStatement(),null);
        sliceNodes.remove(dstPDGNode);
      }
    }
  }
 else   if (oldPredicateStatement instanceof SwitchStatement) {
    SwitchStatement oldSwitchStatement=(SwitchStatement)oldPredicateStatement;
    SwitchStatement newSwitchStatement=ast.newSwitchStatement();
    newPredicateStatement=newSwitchStatement;
    sourceRewriter.set(newSwitchStatement,SwitchStatement.EXPRESSION_PROPERTY,oldSwitchStatement.getExpression(),null);
    ListRewrite switchStatementsRewrite=sourceRewriter.getListRewrite(newSwitchStatement,SwitchStatement.STATEMENTS_PROPERTY);
    Iterator<GraphEdge> outgoingDependenceIterator=predicateNode.getOutgoingDependenceIterator();
    while (outgoingDependenceIterator.hasNext()) {
      ListRewrite bodyRewrite=switchStatementsRewrite;
      PDGDependence dependence=(PDGDependence)outgoingDependenceIterator.next();
      if (dependence instanceof PDGControlDependence) {
        PDGControlDependence controlDependence=(PDGControlDependence)dependence;
        PDGNode dstPDGNode=(PDGNode)controlDependence.getDst();
        if (sliceNodes.contains(dstPDGNode)) {
          bodyRewrite=createTryStatementIfNeeded(sourceRewriter,ast,bodyRewrite,dstPDGNode);
          if (dstPDGNode instanceof PDGControlPredicateNode) {
            PDGControlPredicateNode dstPredicateNode=(PDGControlPredicateNode)dstPDGNode;
            bodyRewrite.insertLast(processPredicateNode(dstPredicateNode,ast,sourceRewriter,sliceNodes),null);
          }
 else {
            processStatementNode(bodyRewrite,dstPDGNode,ast,sourceRewriter);
            sliceNodes.remove(dstPDGNode);
          }
        }
      }
    }
  }
 else {
    Block loopBlock=ast.newBlock();
    ListRewrite loopBodyRewrite=sourceRewriter.getListRewrite(loopBlock,Block.STATEMENTS_PROPERTY);
    Iterator<GraphEdge> outgoingDependenceIterator=predicateNode.getOutgoingDependenceIterator();
    while (outgoingDependenceIterator.hasNext()) {
      ListRewrite bodyRewrite=loopBodyRewrite;
      PDGDependence dependence=(PDGDependence)outgoingDependenceIterator.next();
      if (dependence instanceof PDGControlDependence) {
        PDGControlDependence controlDependence=(PDGControlDependence)dependence;
        PDGNode dstPDGNode=(PDGNode)controlDependence.getDst();
        if (sliceNodes.contains(dstPDGNode)) {
          bodyRewrite=createTryStatementIfNeeded(sourceRewriter,ast,bodyRewrite,dstPDGNode);
          if (dstPDGNode instanceof PDGControlPredicateNode) {
            PDGControlPredicateNode dstPredicateNode=(PDGControlPredicateNode)dstPDGNode;
            bodyRewrite.insertLast(processPredicateNode(dstPredicateNode,ast,sourceRewriter,sliceNodes),null);
          }
 else {
            processStatementNode(bodyRewrite,dstPDGNode,ast,sourceRewriter);
            sliceNodes.remove(dstPDGNode);
          }
        }
      }
    }
    if (oldPredicateStatement instanceof WhileStatement) {
      WhileStatement oldWhileStatement=(WhileStatement)oldPredicateStatement;
      WhileStatement newWhileStatement=ast.newWhileStatement();
      newPredicateStatement=newWhileStatement;
      sourceRewriter.set(newWhileStatement,WhileStatement.EXPRESSION_PROPERTY,oldWhileStatement.getExpression(),null);
      sourceRewriter.set(newWhileStatement,WhileStatement.BODY_PROPERTY,loopBlock,null);
    }
 else     if (oldPredicateStatement instanceof ForStatement) {
      ForStatement oldForStatement=(ForStatement)oldPredicateStatement;
      ForStatement newForStatement=ast.newForStatement();
      newPredicateStatement=newForStatement;
      sourceRewriter.set(newForStatement,ForStatement.EXPRESSION_PROPERTY,oldForStatement.getExpression(),null);
      ListRewrite initializerRewrite=sourceRewriter.getListRewrite(newForStatement,ForStatement.INITIALIZERS_PROPERTY);
      List<Expression> initializers=oldForStatement.initializers();
      for (      Expression expression : initializers)       initializerRewrite.insertLast(expression,null);
      ListRewrite updaterRewrite=sourceRewriter.getListRewrite(newForStatement,ForStatement.UPDATERS_PROPERTY);
      List<Expression> updaters=oldForStatement.updaters();
      for (      Expression expression : updaters)       updaterRewrite.insertLast(expression,null);
      sourceRewriter.set(newForStatement,ForStatement.BODY_PROPERTY,loopBlock,null);
    }
 else     if (oldPredicateStatement instanceof EnhancedForStatement) {
      EnhancedForStatement oldEnhancedForStatement=(EnhancedForStatement)oldPredicateStatement;
      EnhancedForStatement newEnhancedForStatement=ast.newEnhancedForStatement();
      newPredicateStatement=newEnhancedForStatement;
      sourceRewriter.set(newEnhancedForStatement,EnhancedForStatement.PARAMETER_PROPERTY,oldEnhancedForStatement.getParameter(),null);
      sourceRewriter.set(newEnhancedForStatement,EnhancedForStatement.EXPRESSION_PROPERTY,oldEnhancedForStatement.getExpression(),null);
      sourceRewriter.set(newEnhancedForStatement,EnhancedForStatement.BODY_PROPERTY,loopBlock,null);
    }
 else     if (oldPredicateStatement instanceof DoStatement) {
      DoStatement oldDoStatement=(DoStatement)oldPredicateStatement;
      DoStatement newDoStatement=ast.newDoStatement();
      newPredicateStatement=newDoStatement;
      sourceRewriter.set(newDoStatement,DoStatement.EXPRESSION_PROPERTY,oldDoStatement.getExpression(),null);
      sourceRewriter.set(newDoStatement,DoStatement.BODY_PROPERTY,loopBlock,null);
    }
  }
  return newPredicateStatement;
}","protected Statement processPredicateNode(PDGControlPredicateNode predicateNode,AST ast,ASTRewrite sourceRewriter,List<PDGNode> sliceNodes){
  Statement oldPredicateStatement=predicateNode.getASTStatement();
  sliceNodes.remove(predicateNode);
  Statement newPredicateStatement=null;
  if (oldPredicateStatement instanceof IfStatement) {
    IfStatement oldIfStatement=(IfStatement)oldPredicateStatement;
    IfStatement newIfStatement=ast.newIfStatement();
    newPredicateStatement=newIfStatement;
    sourceRewriter.set(newIfStatement,IfStatement.EXPRESSION_PROPERTY,oldIfStatement.getExpression(),null);
    Iterator<GraphEdge> outgoingDependenceIterator=predicateNode.getOutgoingDependenceIterator();
    List<PDGNode> trueControlDependentChildren=new ArrayList<PDGNode>();
    List<PDGNode> falseControlDependentChildren=new ArrayList<PDGNode>();
    while (outgoingDependenceIterator.hasNext()) {
      PDGDependence dependence=(PDGDependence)outgoingDependenceIterator.next();
      if (dependence instanceof PDGControlDependence) {
        PDGControlDependence controlDependence=(PDGControlDependence)dependence;
        PDGNode dstPDGNode=(PDGNode)controlDependence.getDst();
        if (sliceNodes.contains(dstPDGNode)) {
          if (controlDependence.isTrueControlDependence()) {
            trueControlDependentChildren.add(dstPDGNode);
          }
 else           if (controlDependence.isFalseControlDependence()) {
            falseControlDependentChildren.add(dstPDGNode);
          }
        }
      }
    }
    if (oldIfStatement.getThenStatement() instanceof Block || trueControlDependentChildren.size() > 1) {
      Block thenBlock=ast.newBlock();
      ListRewrite thenBodyRewrite=sourceRewriter.getListRewrite(thenBlock,Block.STATEMENTS_PROPERTY);
      for (      PDGNode dstPDGNode : trueControlDependentChildren) {
        ListRewrite listRewrite=thenBodyRewrite;
        listRewrite=createTryStatementIfNeeded(sourceRewriter,ast,listRewrite,dstPDGNode);
        if (dstPDGNode instanceof PDGControlPredicateNode) {
          PDGControlPredicateNode dstPredicateNode=(PDGControlPredicateNode)dstPDGNode;
          listRewrite.insertLast(processPredicateNode(dstPredicateNode,ast,sourceRewriter,sliceNodes),null);
        }
 else {
          processStatementNode(listRewrite,dstPDGNode,ast,sourceRewriter);
          sliceNodes.remove(dstPDGNode);
        }
      }
      sourceRewriter.set(newIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,thenBlock,null);
    }
 else     if (trueControlDependentChildren.size() == 1) {
      PDGNode dstPDGNode=trueControlDependentChildren.get(0);
      if (dstPDGNode instanceof PDGControlPredicateNode) {
        PDGControlPredicateNode dstPredicateNode=(PDGControlPredicateNode)dstPDGNode;
        sourceRewriter.set(newIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,processPredicateNode(dstPredicateNode,ast,sourceRewriter,sliceNodes),null);
      }
 else {
        sourceRewriter.set(newIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,dstPDGNode.getASTStatement(),null);
        sliceNodes.remove(dstPDGNode);
      }
    }
    if (oldIfStatement.getElseStatement() instanceof Block || falseControlDependentChildren.size() > 1) {
      Block elseBlock=ast.newBlock();
      ListRewrite elseBodyRewrite=sourceRewriter.getListRewrite(elseBlock,Block.STATEMENTS_PROPERTY);
      for (      PDGNode dstPDGNode : falseControlDependentChildren) {
        ListRewrite listRewrite=elseBodyRewrite;
        listRewrite=createTryStatementIfNeeded(sourceRewriter,ast,listRewrite,dstPDGNode);
        if (dstPDGNode instanceof PDGControlPredicateNode) {
          PDGControlPredicateNode dstPredicateNode=(PDGControlPredicateNode)dstPDGNode;
          listRewrite.insertLast(processPredicateNode(dstPredicateNode,ast,sourceRewriter,sliceNodes),null);
        }
 else {
          processStatementNode(listRewrite,dstPDGNode,ast,sourceRewriter);
          sliceNodes.remove(dstPDGNode);
        }
      }
      sourceRewriter.set(newIfStatement,IfStatement.ELSE_STATEMENT_PROPERTY,elseBlock,null);
    }
 else     if (falseControlDependentChildren.size() == 1) {
      PDGNode dstPDGNode=falseControlDependentChildren.get(0);
      if (dstPDGNode instanceof PDGControlPredicateNode) {
        PDGControlPredicateNode dstPredicateNode=(PDGControlPredicateNode)dstPDGNode;
        sourceRewriter.set(newIfStatement,IfStatement.ELSE_STATEMENT_PROPERTY,processPredicateNode(dstPredicateNode,ast,sourceRewriter,sliceNodes),null);
      }
 else {
        sourceRewriter.set(newIfStatement,IfStatement.ELSE_STATEMENT_PROPERTY,dstPDGNode.getASTStatement(),null);
        sliceNodes.remove(dstPDGNode);
      }
    }
  }
 else   if (oldPredicateStatement instanceof SwitchStatement) {
    SwitchStatement oldSwitchStatement=(SwitchStatement)oldPredicateStatement;
    SwitchStatement newSwitchStatement=ast.newSwitchStatement();
    newPredicateStatement=newSwitchStatement;
    sourceRewriter.set(newSwitchStatement,SwitchStatement.EXPRESSION_PROPERTY,oldSwitchStatement.getExpression(),null);
    ListRewrite switchStatementsRewrite=sourceRewriter.getListRewrite(newSwitchStatement,SwitchStatement.STATEMENTS_PROPERTY);
    Iterator<GraphEdge> outgoingDependenceIterator=predicateNode.getOutgoingDependenceIterator();
    while (outgoingDependenceIterator.hasNext()) {
      ListRewrite bodyRewrite=switchStatementsRewrite;
      PDGDependence dependence=(PDGDependence)outgoingDependenceIterator.next();
      if (dependence instanceof PDGControlDependence) {
        PDGControlDependence controlDependence=(PDGControlDependence)dependence;
        PDGNode dstPDGNode=(PDGNode)controlDependence.getDst();
        if (sliceNodes.contains(dstPDGNode)) {
          bodyRewrite=createTryStatementIfNeeded(sourceRewriter,ast,bodyRewrite,dstPDGNode);
          if (dstPDGNode instanceof PDGControlPredicateNode) {
            PDGControlPredicateNode dstPredicateNode=(PDGControlPredicateNode)dstPDGNode;
            bodyRewrite.insertLast(processPredicateNode(dstPredicateNode,ast,sourceRewriter,sliceNodes),null);
          }
 else {
            processStatementNode(bodyRewrite,dstPDGNode,ast,sourceRewriter);
            sliceNodes.remove(dstPDGNode);
          }
        }
      }
    }
  }
 else {
    Block loopBlock=ast.newBlock();
    ListRewrite loopBodyRewrite=sourceRewriter.getListRewrite(loopBlock,Block.STATEMENTS_PROPERTY);
    Iterator<GraphEdge> outgoingDependenceIterator=predicateNode.getOutgoingDependenceIterator();
    while (outgoingDependenceIterator.hasNext()) {
      ListRewrite bodyRewrite=loopBodyRewrite;
      PDGDependence dependence=(PDGDependence)outgoingDependenceIterator.next();
      if (dependence instanceof PDGControlDependence) {
        PDGControlDependence controlDependence=(PDGControlDependence)dependence;
        PDGNode dstPDGNode=(PDGNode)controlDependence.getDst();
        if (sliceNodes.contains(dstPDGNode)) {
          bodyRewrite=createTryStatementIfNeeded(sourceRewriter,ast,bodyRewrite,dstPDGNode);
          if (dstPDGNode instanceof PDGControlPredicateNode) {
            PDGControlPredicateNode dstPredicateNode=(PDGControlPredicateNode)dstPDGNode;
            bodyRewrite.insertLast(processPredicateNode(dstPredicateNode,ast,sourceRewriter,sliceNodes),null);
          }
 else {
            processStatementNode(bodyRewrite,dstPDGNode,ast,sourceRewriter);
            sliceNodes.remove(dstPDGNode);
          }
        }
      }
    }
    if (oldPredicateStatement instanceof WhileStatement) {
      WhileStatement oldWhileStatement=(WhileStatement)oldPredicateStatement;
      WhileStatement newWhileStatement=ast.newWhileStatement();
      newPredicateStatement=newWhileStatement;
      sourceRewriter.set(newWhileStatement,WhileStatement.EXPRESSION_PROPERTY,oldWhileStatement.getExpression(),null);
      sourceRewriter.set(newWhileStatement,WhileStatement.BODY_PROPERTY,loopBlock,null);
    }
 else     if (oldPredicateStatement instanceof ForStatement) {
      ForStatement oldForStatement=(ForStatement)oldPredicateStatement;
      ForStatement newForStatement=ast.newForStatement();
      newPredicateStatement=newForStatement;
      sourceRewriter.set(newForStatement,ForStatement.EXPRESSION_PROPERTY,oldForStatement.getExpression(),null);
      ListRewrite initializerRewrite=sourceRewriter.getListRewrite(newForStatement,ForStatement.INITIALIZERS_PROPERTY);
      List<Expression> initializers=oldForStatement.initializers();
      for (      Expression expression : initializers)       initializerRewrite.insertLast(expression,null);
      ListRewrite updaterRewrite=sourceRewriter.getListRewrite(newForStatement,ForStatement.UPDATERS_PROPERTY);
      List<Expression> updaters=oldForStatement.updaters();
      for (      Expression expression : updaters)       updaterRewrite.insertLast(expression,null);
      sourceRewriter.set(newForStatement,ForStatement.BODY_PROPERTY,loopBlock,null);
    }
 else     if (oldPredicateStatement instanceof EnhancedForStatement) {
      EnhancedForStatement oldEnhancedForStatement=(EnhancedForStatement)oldPredicateStatement;
      EnhancedForStatement newEnhancedForStatement=ast.newEnhancedForStatement();
      newPredicateStatement=newEnhancedForStatement;
      sourceRewriter.set(newEnhancedForStatement,EnhancedForStatement.PARAMETER_PROPERTY,oldEnhancedForStatement.getParameter(),null);
      sourceRewriter.set(newEnhancedForStatement,EnhancedForStatement.EXPRESSION_PROPERTY,oldEnhancedForStatement.getExpression(),null);
      sourceRewriter.set(newEnhancedForStatement,EnhancedForStatement.BODY_PROPERTY,loopBlock,null);
    }
 else     if (oldPredicateStatement instanceof DoStatement) {
      DoStatement oldDoStatement=(DoStatement)oldPredicateStatement;
      DoStatement newDoStatement=ast.newDoStatement();
      newPredicateStatement=newDoStatement;
      sourceRewriter.set(newDoStatement,DoStatement.EXPRESSION_PROPERTY,oldDoStatement.getExpression(),null);
      sourceRewriter.set(newDoStatement,DoStatement.BODY_PROPERTY,loopBlock,null);
    }
  }
  LabeledStatement labeled=belongsToLabeledStatement(predicateNode);
  if (labeled != null) {
    labeledStatementsToBeRemoved.add(labeled);
    LabeledStatement newLabeledStatement=ast.newLabeledStatement();
    sourceRewriter.set(newLabeledStatement,LabeledStatement.LABEL_PROPERTY,labeled.getLabel(),null);
    sourceRewriter.set(newLabeledStatement,LabeledStatement.BODY_PROPERTY,newPredicateStatement,null);
    newPredicateStatement=newLabeledStatement;
  }
  return newPredicateStatement;
}"
12024,"private void modifySourceMethod(MultiTextEdit root){
  ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
  AST ast=sourceMethodDeclaration.getAST();
  MethodInvocation extractedMethodInvocation=ast.newMethodInvocation();
  sourceRewriter.set(extractedMethodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(slice.getExtractedMethodName()),null);
  ListRewrite argumentRewrite=sourceRewriter.getListRewrite(extractedMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  VariableDeclaration variableDeclaration : slice.getPassedParameters()) {
    if (!variableDeclaration.resolveBinding().isField())     argumentRewrite.insertLast(variableDeclaration.getName(),null);
  }
  Statement extractedMethodInvocationInsertionStatement=slice.getExtractedMethodInvocationInsertionStatement();
  ASTNode statementParent=extractedMethodInvocationInsertionStatement.getParent();
  if (statementParent != null && statementParent instanceof Block)   statementParent=statementParent.getParent();
  if (statementParent != null && statementParent instanceof TryStatement) {
    TryStatement tryStatementParent=(TryStatement)statementParent;
    if (tryStatementsToBeRemoved.contains(tryStatementParent))     extractedMethodInvocationInsertionStatement=tryStatementParent;
  }
  VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion();
  if (slice.declarationOfVariableCriterionBelongsToSliceNodes() && slice.declarationOfVariableCriterionBelongsToRemovableNodes()) {
    VariableDeclarationFragment initializationFragment=ast.newVariableDeclarationFragment();
    sourceRewriter.set(initializationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariableDeclaration.getName(),null);
    sourceRewriter.set(initializationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractedMethodInvocation,null);
    VariableDeclarationStatement initializationVariableDeclarationStatement=ast.newVariableDeclarationStatement(initializationFragment);
    ITypeBinding returnedVariableTypeBinding=extractTypeBinding(returnedVariableDeclaration);
    Type returnedVariableType=RefactoringUtility.generateTypeFromTypeBinding(returnedVariableTypeBinding,ast,sourceRewriter);
    sourceRewriter.set(initializationVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedVariableType,null);
    ListRewrite blockRewrite=getBlockRewrite(extractedMethodInvocationInsertionStatement,sourceRewriter);
    blockRewrite.insertBefore(initializationVariableDeclarationStatement,extractedMethodInvocationInsertionStatement,null);
  }
 else   if (slice.declarationOfVariableCriterionBelongsToSliceNodes() && !slice.declarationOfVariableCriterionBelongsToRemovableNodes()) {
    if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment oldInitializationFragment=(VariableDeclarationFragment)returnedVariableDeclaration;
      VariableDeclarationFragment newInitializationFragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(newInitializationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariableDeclaration.getName(),null);
      sourceRewriter.set(newInitializationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractedMethodInvocation,null);
      if (oldInitializationFragment.getParent() instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement oldVariableDeclarationStatement=(VariableDeclarationStatement)oldInitializationFragment.getParent();
        List<VariableDeclarationFragment> oldFragments=oldVariableDeclarationStatement.fragments();
        ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(oldVariableDeclarationStatement,VariableDeclarationStatement.FRAGMENTS_PROPERTY);
        for (int i=0; i < oldFragments.size(); i++) {
          if (oldInitializationFragment.equals(oldFragments.get(i)))           fragmentRewrite.replace(oldFragments.get(i),newInitializationFragment,null);
        }
      }
 else       if (oldInitializationFragment.getParent() instanceof VariableDeclarationExpression) {
        VariableDeclarationExpression oldVariableDeclarationExpression=(VariableDeclarationExpression)oldInitializationFragment.getParent();
        List<VariableDeclarationFragment> oldFragments=oldVariableDeclarationExpression.fragments();
        ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(oldVariableDeclarationExpression,VariableDeclarationExpression.FRAGMENTS_PROPERTY);
        for (int i=0; i < oldFragments.size(); i++) {
          if (oldInitializationFragment.equals(oldFragments.get(i)))           fragmentRewrite.replace(oldFragments.get(i),newInitializationFragment,null);
        }
      }
    }
  }
 else {
    if (!slice.isObjectSlice()) {
      Assignment assignment=ast.newAssignment();
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariableDeclaration.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,extractedMethodInvocation,null);
      ExpressionStatement expressionStatement=ast.newExpressionStatement(assignment);
      ListRewrite blockRewrite=getBlockRewrite(extractedMethodInvocationInsertionStatement,sourceRewriter);
      blockRewrite.insertBefore(expressionStatement,extractedMethodInvocationInsertionStatement,null);
    }
 else {
      ExpressionStatement expressionStatement=ast.newExpressionStatement(extractedMethodInvocation);
      ListRewrite blockRewrite=getBlockRewrite(extractedMethodInvocationInsertionStatement,sourceRewriter);
      blockRewrite.insertBefore(expressionStatement,extractedMethodInvocationInsertionStatement,null);
    }
  }
  for (  Statement removableStatement : slice.getRemovableStatements()) {
    sourceRewriter.remove(removableStatement,null);
  }
  for (  TryStatement tryStatement : tryStatementsToBeRemoved) {
    sourceRewriter.remove(tryStatement,null);
  }
  try {
    TextEdit sourceEdit=sourceRewriter.rewriteAST();
    root.addChild(sourceEdit);
    compilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
}","private void modifySourceMethod(MultiTextEdit root){
  ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
  AST ast=sourceMethodDeclaration.getAST();
  MethodInvocation extractedMethodInvocation=ast.newMethodInvocation();
  sourceRewriter.set(extractedMethodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(slice.getExtractedMethodName()),null);
  ListRewrite argumentRewrite=sourceRewriter.getListRewrite(extractedMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  VariableDeclaration variableDeclaration : slice.getPassedParameters()) {
    if (!variableDeclaration.resolveBinding().isField())     argumentRewrite.insertLast(variableDeclaration.getName(),null);
  }
  Statement extractedMethodInvocationInsertionStatement=slice.getExtractedMethodInvocationInsertionStatement();
  if (extractedMethodInvocationInsertionStatement.getParent() instanceof LabeledStatement) {
    extractedMethodInvocationInsertionStatement=(LabeledStatement)extractedMethodInvocationInsertionStatement.getParent();
  }
  ASTNode statementParent=extractedMethodInvocationInsertionStatement.getParent();
  if (statementParent != null && statementParent instanceof Block)   statementParent=statementParent.getParent();
  if (statementParent != null && statementParent instanceof TryStatement) {
    TryStatement tryStatementParent=(TryStatement)statementParent;
    if (tryStatementsToBeRemoved.contains(tryStatementParent))     extractedMethodInvocationInsertionStatement=tryStatementParent;
  }
  VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion();
  if (slice.declarationOfVariableCriterionBelongsToSliceNodes() && slice.declarationOfVariableCriterionBelongsToRemovableNodes()) {
    VariableDeclarationFragment initializationFragment=ast.newVariableDeclarationFragment();
    sourceRewriter.set(initializationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariableDeclaration.getName(),null);
    sourceRewriter.set(initializationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractedMethodInvocation,null);
    VariableDeclarationStatement initializationVariableDeclarationStatement=ast.newVariableDeclarationStatement(initializationFragment);
    ITypeBinding returnedVariableTypeBinding=extractTypeBinding(returnedVariableDeclaration);
    Type returnedVariableType=RefactoringUtility.generateTypeFromTypeBinding(returnedVariableTypeBinding,ast,sourceRewriter);
    sourceRewriter.set(initializationVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedVariableType,null);
    ListRewrite blockRewrite=getBlockRewrite(extractedMethodInvocationInsertionStatement,sourceRewriter);
    blockRewrite.insertBefore(initializationVariableDeclarationStatement,extractedMethodInvocationInsertionStatement,null);
  }
 else   if (slice.declarationOfVariableCriterionBelongsToSliceNodes() && !slice.declarationOfVariableCriterionBelongsToRemovableNodes()) {
    if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment oldInitializationFragment=(VariableDeclarationFragment)returnedVariableDeclaration;
      VariableDeclarationFragment newInitializationFragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(newInitializationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariableDeclaration.getName(),null);
      sourceRewriter.set(newInitializationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractedMethodInvocation,null);
      if (oldInitializationFragment.getParent() instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement oldVariableDeclarationStatement=(VariableDeclarationStatement)oldInitializationFragment.getParent();
        List<VariableDeclarationFragment> oldFragments=oldVariableDeclarationStatement.fragments();
        ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(oldVariableDeclarationStatement,VariableDeclarationStatement.FRAGMENTS_PROPERTY);
        for (int i=0; i < oldFragments.size(); i++) {
          if (oldInitializationFragment.equals(oldFragments.get(i)))           fragmentRewrite.replace(oldFragments.get(i),newInitializationFragment,null);
        }
      }
 else       if (oldInitializationFragment.getParent() instanceof VariableDeclarationExpression) {
        VariableDeclarationExpression oldVariableDeclarationExpression=(VariableDeclarationExpression)oldInitializationFragment.getParent();
        List<VariableDeclarationFragment> oldFragments=oldVariableDeclarationExpression.fragments();
        ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(oldVariableDeclarationExpression,VariableDeclarationExpression.FRAGMENTS_PROPERTY);
        for (int i=0; i < oldFragments.size(); i++) {
          if (oldInitializationFragment.equals(oldFragments.get(i)))           fragmentRewrite.replace(oldFragments.get(i),newInitializationFragment,null);
        }
      }
    }
  }
 else {
    if (!slice.isObjectSlice()) {
      Assignment assignment=ast.newAssignment();
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariableDeclaration.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,extractedMethodInvocation,null);
      ExpressionStatement expressionStatement=ast.newExpressionStatement(assignment);
      ListRewrite blockRewrite=getBlockRewrite(extractedMethodInvocationInsertionStatement,sourceRewriter);
      blockRewrite.insertBefore(expressionStatement,extractedMethodInvocationInsertionStatement,null);
    }
 else {
      ExpressionStatement expressionStatement=ast.newExpressionStatement(extractedMethodInvocation);
      ListRewrite blockRewrite=getBlockRewrite(extractedMethodInvocationInsertionStatement,sourceRewriter);
      blockRewrite.insertBefore(expressionStatement,extractedMethodInvocationInsertionStatement,null);
    }
  }
  for (  Statement removableStatement : slice.getRemovableStatements()) {
    sourceRewriter.remove(removableStatement,null);
  }
  for (  TryStatement tryStatement : tryStatementsToBeRemoved) {
    sourceRewriter.remove(tryStatement,null);
  }
  for (  LabeledStatement labeledStatement : labeledStatementsToBeRemoved) {
    sourceRewriter.remove(labeledStatement,null);
  }
  try {
    TextEdit sourceEdit=sourceRewriter.rewriteAST();
    root.addChild(sourceEdit);
    compilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
}"
12025,"public PDGObjectSliceUnion(PDG pdg,BasicBlock boundaryBlock,Set<PDGNode> allNodeCriteria,PlainVariable objectReference){
  this.pdg=pdg;
  this.subgraph=new PDGSlice(pdg,boundaryBlock);
  this.sliceNodes=new TreeSet<PDGNode>();
  for (  PDGNode nodeCriterion : allNodeCriteria) {
    sliceNodes.addAll(subgraph.computeSlice(nodeCriterion));
  }
  this.method=pdg.getMethod();
  this.iFile=pdg.getIFile();
  this.methodSize=pdg.getTotalNumberOfStatements();
  this.boundaryBlock=boundaryBlock;
  this.allNodeCriteria=allNodeCriteria;
  this.objectReference=objectReference;
  Set<PDGNode> nodesToBeAddedToSliceDueToDependenceOnObjectStateSlices=new TreeSet<PDGNode>();
  Set<PlainVariable> alreadyExaminedObjectReferences=new LinkedHashSet<PlainVariable>();
  for (  PDGNode sliceNode : sliceNodes) {
    Set<AbstractVariable> usedVariables=sliceNode.usedVariables;
    for (    AbstractVariable usedVariable : usedVariables) {
      if (usedVariable instanceof PlainVariable) {
        PlainVariable plainVariable=(PlainVariable)usedVariable;
        if (!alreadyExaminedObjectReferences.contains(plainVariable) && !objectReference.equals(plainVariable)) {
          Map<CompositeVariable,LinkedHashSet<PDGNode>> definedAttributeNodeCriteriaMap=pdg.getDefinedAttributesOfReference(plainVariable);
          if (!definedAttributeNodeCriteriaMap.isEmpty()) {
            TreeSet<PDGNode> objectSlice=new TreeSet<PDGNode>();
            for (            CompositeVariable compositeVariable : definedAttributeNodeCriteriaMap.keySet()) {
              Set<PDGNode> nodeCriteria2=definedAttributeNodeCriteriaMap.get(compositeVariable);
              for (              PDGNode nodeCriterion : nodeCriteria2) {
                if (subgraph.nodeBelongsToBlockBasedRegion(nodeCriterion))                 objectSlice.addAll(subgraph.computeSlice(nodeCriterion));
              }
            }
            nodesToBeAddedToSliceDueToDependenceOnObjectStateSlices.addAll(objectSlice);
          }
          alreadyExaminedObjectReferences.add(plainVariable);
        }
      }
    }
  }
  sliceNodes.addAll(nodesToBeAddedToSliceDueToDependenceOnObjectStateSlices);
  Set<PDGNode> throwStatementNodes=getThrowStatementNodesWithinRegion();
  Set<PDGNode> nodesToBeAddedToSliceDueToThrowStatementNodes=new TreeSet<PDGNode>();
  for (  PDGNode throwNode : throwStatementNodes) {
    for (    PDGNode sliceNode : sliceNodes) {
      if (sliceNode instanceof PDGControlPredicateNode && isNestedInside(throwNode,sliceNode)) {
        Set<PDGNode> throwNodeSlice=subgraph.computeSlice(throwNode);
        nodesToBeAddedToSliceDueToThrowStatementNodes.addAll(throwNodeSlice);
        break;
      }
    }
  }
  sliceNodes.addAll(nodesToBeAddedToSliceDueToThrowStatementNodes);
  Set<PDGNode> remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.add(pdg.getEntryNode());
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!sliceNodes.contains(pdgNode))     remainingNodes.add(pdgNode);
  }
  Set<PDGNode> throwStatementNodesToBeAddedToDuplicatedNodesDueToRemainingNodes=new TreeSet<PDGNode>();
  for (  PDGNode throwNode : throwStatementNodes) {
    for (    PDGNode remainingNode : remainingNodes) {
      if (remainingNode.getId() != 0 && isNestedInside(throwNode,remainingNode)) {
        throwStatementNodesToBeAddedToDuplicatedNodesDueToRemainingNodes.add(throwNode);
        break;
      }
    }
  }
  this.passedParameters=new LinkedHashSet<AbstractVariable>();
  Set<PDGNode> nCD=new LinkedHashSet<PDGNode>();
  Set<PDGNode> nDD=new LinkedHashSet<PDGNode>();
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    PDGNode srcPDGNode=(PDGNode)dependence.src;
    PDGNode dstPDGNode=(PDGNode)dependence.dst;
    if (dependence instanceof PDGDataDependence) {
      PDGDataDependence dataDependence=(PDGDataDependence)dependence;
      if (remainingNodes.contains(srcPDGNode) && sliceNodes.contains(dstPDGNode))       passedParameters.add(dataDependence.getData());
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode) && !dataDependence.getData().equals(objectReference))       nDD.add(srcPDGNode);
    }
 else     if (dependence instanceof PDGControlDependence) {
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode))       nCD.add(srcPDGNode);
    }
  }
  Set<PDGNode> controlIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nCD) {
    for (    AbstractVariable usedVariable : p.usedVariables) {
      Set<PDGNode> pSliceNodes=subgraph.computeSlice(p,usedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
    if (p.usedVariables.isEmpty()) {
      Set<PDGNode> pSliceNodes=subgraph.computeSlice(p);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
  }
  Set<PDGNode> dataIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nDD) {
    for (    AbstractVariable definedVariable : p.definedVariables) {
      Set<PDGNode> pSliceNodes=subgraph.computeSlice(p,definedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q))         dataIndispensableNodes.add(q);
      }
    }
  }
  this.indispensableNodes=new TreeSet<PDGNode>();
  indispensableNodes.addAll(controlIndispensableNodes);
  indispensableNodes.addAll(dataIndispensableNodes);
  Set<PDGNode> throwStatementNodesToBeAddedToDuplicatedNodesDueToIndispensableNodes=new TreeSet<PDGNode>();
  for (  PDGNode throwNode : throwStatementNodes) {
    for (    PDGNode indispensableNode : indispensableNodes) {
      if (isNestedInside(throwNode,indispensableNode)) {
        throwStatementNodesToBeAddedToDuplicatedNodesDueToIndispensableNodes.add(throwNode);
        break;
      }
    }
  }
  for (  PDGNode throwNode : throwStatementNodesToBeAddedToDuplicatedNodesDueToRemainingNodes) {
    indispensableNodes.addAll(subgraph.computeSlice(throwNode));
  }
  for (  PDGNode throwNode : throwStatementNodesToBeAddedToDuplicatedNodesDueToIndispensableNodes) {
    indispensableNodes.addAll(subgraph.computeSlice(throwNode));
  }
  this.removableNodes=new LinkedHashSet<PDGNode>();
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!remainingNodes.contains(pdgNode) && !indispensableNodes.contains(pdgNode))     removableNodes.add(pdgNode);
  }
  for (  PDGNode node : sliceNodes) {
    if (!(node instanceof PDGTryNode)) {
      if (node.declaresLocalVariable(objectReference) || ((objectReference.isField() || objectReference.isParameter()) && node.instantiatesLocalVariable(objectReference) && node.definesLocalVariable(objectReference))) {
        removableNodes.add(node);
        indispensableNodes.remove(node);
        break;
      }
    }
  }
}","public PDGObjectSliceUnion(PDG pdg,BasicBlock boundaryBlock,Set<PDGNode> allNodeCriteria,PlainVariable objectReference){
  this.pdg=pdg;
  this.subgraph=new PDGSlice(pdg,boundaryBlock);
  this.sliceNodes=new TreeSet<PDGNode>();
  for (  PDGNode nodeCriterion : allNodeCriteria) {
    sliceNodes.addAll(subgraph.computeSlice(nodeCriterion));
  }
  this.method=pdg.getMethod();
  this.iFile=pdg.getIFile();
  this.methodSize=pdg.getTotalNumberOfStatements();
  this.boundaryBlock=boundaryBlock;
  this.allNodeCriteria=allNodeCriteria;
  this.objectReference=objectReference;
  Set<PDGNode> nodesToBeAddedToSliceDueToDependenceOnObjectStateSlices=new TreeSet<PDGNode>();
  Set<PlainVariable> alreadyExaminedObjectReferences=new LinkedHashSet<PlainVariable>();
  for (  PDGNode sliceNode : sliceNodes) {
    Set<AbstractVariable> usedVariables=sliceNode.usedVariables;
    for (    AbstractVariable usedVariable : usedVariables) {
      if (usedVariable instanceof PlainVariable) {
        PlainVariable plainVariable=(PlainVariable)usedVariable;
        if (!alreadyExaminedObjectReferences.contains(plainVariable) && !objectReference.equals(plainVariable)) {
          Map<CompositeVariable,LinkedHashSet<PDGNode>> definedAttributeNodeCriteriaMap=pdg.getDefinedAttributesOfReference(plainVariable);
          if (!definedAttributeNodeCriteriaMap.isEmpty()) {
            TreeSet<PDGNode> objectSlice=new TreeSet<PDGNode>();
            for (            CompositeVariable compositeVariable : definedAttributeNodeCriteriaMap.keySet()) {
              Set<PDGNode> nodeCriteria2=definedAttributeNodeCriteriaMap.get(compositeVariable);
              for (              PDGNode nodeCriterion : nodeCriteria2) {
                if (subgraph.nodeBelongsToBlockBasedRegion(nodeCriterion))                 objectSlice.addAll(subgraph.computeSlice(nodeCriterion));
              }
            }
            nodesToBeAddedToSliceDueToDependenceOnObjectStateSlices.addAll(objectSlice);
          }
          alreadyExaminedObjectReferences.add(plainVariable);
        }
      }
    }
  }
  sliceNodes.addAll(nodesToBeAddedToSliceDueToDependenceOnObjectStateSlices);
  Set<PDGNode> throwStatementNodes=getThrowStatementNodesWithinRegion();
  Set<PDGNode> nodesToBeAddedToSliceDueToThrowStatementNodes=new TreeSet<PDGNode>();
  for (  PDGNode throwNode : throwStatementNodes) {
    for (    PDGNode sliceNode : sliceNodes) {
      if (sliceNode instanceof PDGControlPredicateNode && isNestedInside(throwNode,sliceNode)) {
        Set<PDGNode> throwNodeSlice=subgraph.computeSlice(throwNode);
        nodesToBeAddedToSliceDueToThrowStatementNodes.addAll(throwNodeSlice);
        break;
      }
    }
  }
  sliceNodes.addAll(nodesToBeAddedToSliceDueToThrowStatementNodes);
  Set<PDGNode> remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.add(pdg.getEntryNode());
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!sliceNodes.contains(pdgNode))     remainingNodes.add(pdgNode);
  }
  Set<PDGNode> throwStatementNodesToBeAddedToDuplicatedNodesDueToRemainingNodes=new TreeSet<PDGNode>();
  for (  PDGNode throwNode : throwStatementNodes) {
    for (    PDGNode remainingNode : remainingNodes) {
      if (remainingNode.getId() != 0 && isNestedInside(throwNode,remainingNode)) {
        throwStatementNodesToBeAddedToDuplicatedNodesDueToRemainingNodes.add(throwNode);
        break;
      }
    }
  }
  this.passedParameters=new LinkedHashSet<AbstractVariable>();
  Set<PDGNode> nCD=new LinkedHashSet<PDGNode>();
  Set<PDGNode> nDD=new LinkedHashSet<PDGNode>();
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    PDGNode srcPDGNode=(PDGNode)dependence.src;
    PDGNode dstPDGNode=(PDGNode)dependence.dst;
    if (dependence instanceof PDGDataDependence) {
      PDGDataDependence dataDependence=(PDGDataDependence)dependence;
      if (remainingNodes.contains(srcPDGNode) && sliceNodes.contains(dstPDGNode))       passedParameters.add(dataDependence.getData());
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode) && !dataDependence.getData().equals(objectReference)&& !dataDependence.getData().isField())       nDD.add(srcPDGNode);
    }
 else     if (dependence instanceof PDGControlDependence) {
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode))       nCD.add(srcPDGNode);
    }
  }
  Set<PDGNode> controlIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nCD) {
    for (    AbstractVariable usedVariable : p.usedVariables) {
      Set<PDGNode> pSliceNodes=subgraph.computeSlice(p,usedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
    if (p.usedVariables.isEmpty()) {
      Set<PDGNode> pSliceNodes=subgraph.computeSlice(p);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
  }
  Set<PDGNode> dataIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nDD) {
    for (    AbstractVariable definedVariable : p.definedVariables) {
      Set<PDGNode> pSliceNodes=subgraph.computeSlice(p,definedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q))         dataIndispensableNodes.add(q);
      }
    }
  }
  this.indispensableNodes=new TreeSet<PDGNode>();
  indispensableNodes.addAll(controlIndispensableNodes);
  indispensableNodes.addAll(dataIndispensableNodes);
  Set<PDGNode> throwStatementNodesToBeAddedToDuplicatedNodesDueToIndispensableNodes=new TreeSet<PDGNode>();
  for (  PDGNode throwNode : throwStatementNodes) {
    for (    PDGNode indispensableNode : indispensableNodes) {
      if (isNestedInside(throwNode,indispensableNode)) {
        throwStatementNodesToBeAddedToDuplicatedNodesDueToIndispensableNodes.add(throwNode);
        break;
      }
    }
  }
  for (  PDGNode throwNode : throwStatementNodesToBeAddedToDuplicatedNodesDueToRemainingNodes) {
    indispensableNodes.addAll(subgraph.computeSlice(throwNode));
  }
  for (  PDGNode throwNode : throwStatementNodesToBeAddedToDuplicatedNodesDueToIndispensableNodes) {
    indispensableNodes.addAll(subgraph.computeSlice(throwNode));
  }
  this.removableNodes=new LinkedHashSet<PDGNode>();
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!remainingNodes.contains(pdgNode) && !indispensableNodes.contains(pdgNode))     removableNodes.add(pdgNode);
  }
  for (  PDGNode node : sliceNodes) {
    if (!(node instanceof PDGTryNode)) {
      if (node.declaresLocalVariable(objectReference) || ((objectReference.isField() || objectReference.isParameter()) && node.instantiatesLocalVariable(objectReference) && node.definesLocalVariable(objectReference))) {
        removableNodes.add(node);
        indispensableNodes.remove(node);
        break;
      }
    }
  }
}"
12026,"public PDGSlice(PDG pdg,BasicBlock boundaryBlock,PDGNode nodeCriterion,AbstractVariable localVariableCriterion){
  this(pdg,boundaryBlock);
  this.nodeCriterion=nodeCriterion;
  this.localVariableCriterion=localVariableCriterion;
  this.sliceNodes=new TreeSet<PDGNode>();
  sliceNodes.addAll(computeSlice(nodeCriterion,localVariableCriterion));
  this.remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.add(pdg.getEntryNode());
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!sliceNodes.contains(pdgNode))     remainingNodes.add(pdgNode);
  }
  this.passedParameters=new LinkedHashSet<AbstractVariable>();
  Set<PDGNode> nCD=new LinkedHashSet<PDGNode>();
  Set<PDGNode> nDD=new LinkedHashSet<PDGNode>();
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    PDGNode srcPDGNode=(PDGNode)dependence.src;
    PDGNode dstPDGNode=(PDGNode)dependence.dst;
    if (dependence instanceof PDGDataDependence) {
      PDGDataDependence dataDependence=(PDGDataDependence)dependence;
      if (remainingNodes.contains(srcPDGNode) && sliceNodes.contains(dstPDGNode))       passedParameters.add(dataDependence.getData());
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode) && !dataDependence.getData().equals(localVariableCriterion))       nDD.add(srcPDGNode);
    }
 else     if (dependence instanceof PDGControlDependence) {
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode))       nCD.add(srcPDGNode);
    }
  }
  Set<PDGNode> controlIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nCD) {
    for (    AbstractVariable usedVariable : p.usedVariables) {
      Set<PDGNode> pSliceNodes=computeSlice(p,usedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
  }
  Set<PDGNode> dataIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nDD) {
    for (    AbstractVariable definedVariable : p.definedVariables) {
      Set<PDGNode> pSliceNodes=computeSlice(p,definedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q))         dataIndispensableNodes.add(q);
      }
    }
  }
  this.indispensableNodes=new TreeSet<PDGNode>();
  indispensableNodes.addAll(controlIndispensableNodes);
  indispensableNodes.addAll(dataIndispensableNodes);
  this.removableNodes=new LinkedHashSet<PDGNode>();
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!remainingNodes.contains(pdgNode) && !indispensableNodes.contains(pdgNode))     removableNodes.add(pdgNode);
  }
}","public PDGSlice(PDG pdg,BasicBlock boundaryBlock,PDGNode nodeCriterion,AbstractVariable localVariableCriterion){
  this(pdg,boundaryBlock);
  this.nodeCriterion=nodeCriterion;
  this.localVariableCriterion=localVariableCriterion;
  this.sliceNodes=new TreeSet<PDGNode>();
  sliceNodes.addAll(computeSlice(nodeCriterion,localVariableCriterion));
  this.remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.add(pdg.getEntryNode());
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!sliceNodes.contains(pdgNode))     remainingNodes.add(pdgNode);
  }
  this.passedParameters=new LinkedHashSet<AbstractVariable>();
  Set<PDGNode> nCD=new LinkedHashSet<PDGNode>();
  Set<PDGNode> nDD=new LinkedHashSet<PDGNode>();
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    PDGNode srcPDGNode=(PDGNode)dependence.src;
    PDGNode dstPDGNode=(PDGNode)dependence.dst;
    if (dependence instanceof PDGDataDependence) {
      PDGDataDependence dataDependence=(PDGDataDependence)dependence;
      if (remainingNodes.contains(srcPDGNode) && sliceNodes.contains(dstPDGNode))       passedParameters.add(dataDependence.getData());
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode) && !dataDependence.getData().equals(localVariableCriterion)&& !dataDependence.getData().isField())       nDD.add(srcPDGNode);
    }
 else     if (dependence instanceof PDGControlDependence) {
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode))       nCD.add(srcPDGNode);
    }
  }
  Set<PDGNode> controlIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nCD) {
    for (    AbstractVariable usedVariable : p.usedVariables) {
      Set<PDGNode> pSliceNodes=computeSlice(p,usedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
  }
  Set<PDGNode> dataIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nDD) {
    for (    AbstractVariable definedVariable : p.definedVariables) {
      Set<PDGNode> pSliceNodes=computeSlice(p,definedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q))         dataIndispensableNodes.add(q);
      }
    }
  }
  this.indispensableNodes=new TreeSet<PDGNode>();
  indispensableNodes.addAll(controlIndispensableNodes);
  indispensableNodes.addAll(dataIndispensableNodes);
  this.removableNodes=new LinkedHashSet<PDGNode>();
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!remainingNodes.contains(pdgNode) && !indispensableNodes.contains(pdgNode))     removableNodes.add(pdgNode);
  }
}"
12027,"public PDGSliceUnion(PDG pdg,BasicBlock boundaryBlock,Set<PDGNode> nodeCriteria,PlainVariable localVariableCriterion){
  this.pdg=pdg;
  this.subgraph=new PDGSlice(pdg,boundaryBlock);
  this.sliceNodes=new TreeSet<PDGNode>();
  for (  PDGNode nodeCriterion : nodeCriteria) {
    sliceNodes.addAll(subgraph.computeSlice(nodeCriterion));
  }
  this.method=pdg.getMethod();
  this.iFile=pdg.getIFile();
  this.methodSize=pdg.getTotalNumberOfStatements();
  this.boundaryBlock=boundaryBlock;
  this.nodeCriteria=nodeCriteria;
  this.localVariableCriterion=localVariableCriterion;
  Set<PDGNode> nodesToBeAddedToSliceDueToDependenceOnObjectStateSlices=new TreeSet<PDGNode>();
  Set<PlainVariable> alreadyExaminedObjectReferences=new LinkedHashSet<PlainVariable>();
  for (  PDGNode sliceNode : sliceNodes) {
    Set<AbstractVariable> usedVariables=sliceNode.usedVariables;
    for (    AbstractVariable usedVariable : usedVariables) {
      if (usedVariable instanceof PlainVariable) {
        PlainVariable plainVariable=(PlainVariable)usedVariable;
        if (!alreadyExaminedObjectReferences.contains(plainVariable) && !localVariableCriterion.getInitialVariable().equals(plainVariable)) {
          Map<CompositeVariable,LinkedHashSet<PDGNode>> definedAttributeNodeCriteriaMap=pdg.getDefinedAttributesOfReference(plainVariable);
          if (!definedAttributeNodeCriteriaMap.isEmpty()) {
            TreeSet<PDGNode> objectSlice=new TreeSet<PDGNode>();
            for (            CompositeVariable compositeVariable : definedAttributeNodeCriteriaMap.keySet()) {
              Set<PDGNode> nodeCriteria2=definedAttributeNodeCriteriaMap.get(compositeVariable);
              for (              PDGNode nodeCriterion : nodeCriteria2) {
                if (subgraph.nodeBelongsToBlockBasedRegion(nodeCriterion))                 objectSlice.addAll(subgraph.computeSlice(nodeCriterion));
              }
            }
            nodesToBeAddedToSliceDueToDependenceOnObjectStateSlices.addAll(objectSlice);
          }
          alreadyExaminedObjectReferences.add(plainVariable);
        }
      }
    }
  }
  sliceNodes.addAll(nodesToBeAddedToSliceDueToDependenceOnObjectStateSlices);
  Set<PDGNode> throwStatementNodes=getThrowStatementNodesWithinRegion();
  Set<PDGNode> nodesToBeAddedToSliceDueToThrowStatementNodes=new TreeSet<PDGNode>();
  for (  PDGNode throwNode : throwStatementNodes) {
    for (    PDGNode sliceNode : sliceNodes) {
      if (sliceNode instanceof PDGControlPredicateNode && isNestedInside(throwNode,sliceNode)) {
        Set<PDGNode> throwNodeSlice=subgraph.computeSlice(throwNode);
        nodesToBeAddedToSliceDueToThrowStatementNodes.addAll(throwNodeSlice);
        break;
      }
    }
  }
  sliceNodes.addAll(nodesToBeAddedToSliceDueToThrowStatementNodes);
  Set<PDGNode> remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.add(pdg.getEntryNode());
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!sliceNodes.contains(pdgNode))     remainingNodes.add(pdgNode);
  }
  Set<PDGNode> throwStatementNodesToBeAddedToDuplicatedNodesDueToRemainingNodes=new TreeSet<PDGNode>();
  for (  PDGNode throwNode : throwStatementNodes) {
    for (    PDGNode remainingNode : remainingNodes) {
      if (remainingNode.getId() != 0 && isNestedInside(throwNode,remainingNode)) {
        throwStatementNodesToBeAddedToDuplicatedNodesDueToRemainingNodes.add(throwNode);
        break;
      }
    }
  }
  this.passedParameters=new LinkedHashSet<AbstractVariable>();
  Set<PDGNode> nCD=new LinkedHashSet<PDGNode>();
  Set<PDGNode> nDD=new LinkedHashSet<PDGNode>();
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    PDGNode srcPDGNode=(PDGNode)dependence.src;
    PDGNode dstPDGNode=(PDGNode)dependence.dst;
    if (dependence instanceof PDGDataDependence) {
      PDGDataDependence dataDependence=(PDGDataDependence)dependence;
      if (remainingNodes.contains(srcPDGNode) && sliceNodes.contains(dstPDGNode))       passedParameters.add(dataDependence.getData());
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode) && !dataDependence.getData().equals(localVariableCriterion))       nDD.add(srcPDGNode);
    }
 else     if (dependence instanceof PDGControlDependence) {
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode))       nCD.add(srcPDGNode);
    }
  }
  Set<PDGNode> controlIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nCD) {
    for (    AbstractVariable usedVariable : p.usedVariables) {
      Set<PDGNode> pSliceNodes=subgraph.computeSlice(p,usedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
    if (p.usedVariables.isEmpty()) {
      Set<PDGNode> pSliceNodes=subgraph.computeSlice(p);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
  }
  Set<PDGNode> dataIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nDD) {
    for (    AbstractVariable definedVariable : p.definedVariables) {
      Set<PDGNode> pSliceNodes=subgraph.computeSlice(p,definedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q))         dataIndispensableNodes.add(q);
      }
    }
  }
  this.indispensableNodes=new TreeSet<PDGNode>();
  indispensableNodes.addAll(controlIndispensableNodes);
  indispensableNodes.addAll(dataIndispensableNodes);
  Set<PDGNode> throwStatementNodesToBeAddedToDuplicatedNodesDueToIndispensableNodes=new TreeSet<PDGNode>();
  for (  PDGNode throwNode : throwStatementNodes) {
    for (    PDGNode indispensableNode : indispensableNodes) {
      if (isNestedInside(throwNode,indispensableNode)) {
        throwStatementNodesToBeAddedToDuplicatedNodesDueToIndispensableNodes.add(throwNode);
        break;
      }
    }
  }
  for (  PDGNode throwNode : throwStatementNodesToBeAddedToDuplicatedNodesDueToRemainingNodes) {
    indispensableNodes.addAll(subgraph.computeSlice(throwNode));
  }
  for (  PDGNode throwNode : throwStatementNodesToBeAddedToDuplicatedNodesDueToIndispensableNodes) {
    indispensableNodes.addAll(subgraph.computeSlice(throwNode));
  }
  this.removableNodes=new LinkedHashSet<PDGNode>();
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!remainingNodes.contains(pdgNode) && !indispensableNodes.contains(pdgNode))     removableNodes.add(pdgNode);
  }
}","public PDGSliceUnion(PDG pdg,BasicBlock boundaryBlock,Set<PDGNode> nodeCriteria,PlainVariable localVariableCriterion){
  this.pdg=pdg;
  this.subgraph=new PDGSlice(pdg,boundaryBlock);
  this.sliceNodes=new TreeSet<PDGNode>();
  for (  PDGNode nodeCriterion : nodeCriteria) {
    sliceNodes.addAll(subgraph.computeSlice(nodeCriterion));
  }
  this.method=pdg.getMethod();
  this.iFile=pdg.getIFile();
  this.methodSize=pdg.getTotalNumberOfStatements();
  this.boundaryBlock=boundaryBlock;
  this.nodeCriteria=nodeCriteria;
  this.localVariableCriterion=localVariableCriterion;
  Set<PDGNode> nodesToBeAddedToSliceDueToDependenceOnObjectStateSlices=new TreeSet<PDGNode>();
  Set<PlainVariable> alreadyExaminedObjectReferences=new LinkedHashSet<PlainVariable>();
  for (  PDGNode sliceNode : sliceNodes) {
    Set<AbstractVariable> usedVariables=sliceNode.usedVariables;
    for (    AbstractVariable usedVariable : usedVariables) {
      if (usedVariable instanceof PlainVariable) {
        PlainVariable plainVariable=(PlainVariable)usedVariable;
        if (!alreadyExaminedObjectReferences.contains(plainVariable) && !localVariableCriterion.getInitialVariable().equals(plainVariable)) {
          Map<CompositeVariable,LinkedHashSet<PDGNode>> definedAttributeNodeCriteriaMap=pdg.getDefinedAttributesOfReference(plainVariable);
          if (!definedAttributeNodeCriteriaMap.isEmpty()) {
            TreeSet<PDGNode> objectSlice=new TreeSet<PDGNode>();
            for (            CompositeVariable compositeVariable : definedAttributeNodeCriteriaMap.keySet()) {
              Set<PDGNode> nodeCriteria2=definedAttributeNodeCriteriaMap.get(compositeVariable);
              for (              PDGNode nodeCriterion : nodeCriteria2) {
                if (subgraph.nodeBelongsToBlockBasedRegion(nodeCriterion))                 objectSlice.addAll(subgraph.computeSlice(nodeCriterion));
              }
            }
            nodesToBeAddedToSliceDueToDependenceOnObjectStateSlices.addAll(objectSlice);
          }
          alreadyExaminedObjectReferences.add(plainVariable);
        }
      }
    }
  }
  sliceNodes.addAll(nodesToBeAddedToSliceDueToDependenceOnObjectStateSlices);
  Set<PDGNode> throwStatementNodes=getThrowStatementNodesWithinRegion();
  Set<PDGNode> nodesToBeAddedToSliceDueToThrowStatementNodes=new TreeSet<PDGNode>();
  for (  PDGNode throwNode : throwStatementNodes) {
    for (    PDGNode sliceNode : sliceNodes) {
      if (sliceNode instanceof PDGControlPredicateNode && isNestedInside(throwNode,sliceNode)) {
        Set<PDGNode> throwNodeSlice=subgraph.computeSlice(throwNode);
        nodesToBeAddedToSliceDueToThrowStatementNodes.addAll(throwNodeSlice);
        break;
      }
    }
  }
  sliceNodes.addAll(nodesToBeAddedToSliceDueToThrowStatementNodes);
  Set<PDGNode> remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.add(pdg.getEntryNode());
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!sliceNodes.contains(pdgNode))     remainingNodes.add(pdgNode);
  }
  Set<PDGNode> throwStatementNodesToBeAddedToDuplicatedNodesDueToRemainingNodes=new TreeSet<PDGNode>();
  for (  PDGNode throwNode : throwStatementNodes) {
    for (    PDGNode remainingNode : remainingNodes) {
      if (remainingNode.getId() != 0 && isNestedInside(throwNode,remainingNode)) {
        throwStatementNodesToBeAddedToDuplicatedNodesDueToRemainingNodes.add(throwNode);
        break;
      }
    }
  }
  this.passedParameters=new LinkedHashSet<AbstractVariable>();
  Set<PDGNode> nCD=new LinkedHashSet<PDGNode>();
  Set<PDGNode> nDD=new LinkedHashSet<PDGNode>();
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    PDGNode srcPDGNode=(PDGNode)dependence.src;
    PDGNode dstPDGNode=(PDGNode)dependence.dst;
    if (dependence instanceof PDGDataDependence) {
      PDGDataDependence dataDependence=(PDGDataDependence)dependence;
      if (remainingNodes.contains(srcPDGNode) && sliceNodes.contains(dstPDGNode))       passedParameters.add(dataDependence.getData());
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode) && !dataDependence.getData().equals(localVariableCriterion)&& !dataDependence.getData().isField())       nDD.add(srcPDGNode);
    }
 else     if (dependence instanceof PDGControlDependence) {
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode))       nCD.add(srcPDGNode);
    }
  }
  Set<PDGNode> controlIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nCD) {
    for (    AbstractVariable usedVariable : p.usedVariables) {
      Set<PDGNode> pSliceNodes=subgraph.computeSlice(p,usedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
    if (p.usedVariables.isEmpty()) {
      Set<PDGNode> pSliceNodes=subgraph.computeSlice(p);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
  }
  Set<PDGNode> dataIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nDD) {
    for (    AbstractVariable definedVariable : p.definedVariables) {
      Set<PDGNode> pSliceNodes=subgraph.computeSlice(p,definedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q))         dataIndispensableNodes.add(q);
      }
    }
  }
  this.indispensableNodes=new TreeSet<PDGNode>();
  indispensableNodes.addAll(controlIndispensableNodes);
  indispensableNodes.addAll(dataIndispensableNodes);
  Set<PDGNode> throwStatementNodesToBeAddedToDuplicatedNodesDueToIndispensableNodes=new TreeSet<PDGNode>();
  for (  PDGNode throwNode : throwStatementNodes) {
    for (    PDGNode indispensableNode : indispensableNodes) {
      if (isNestedInside(throwNode,indispensableNode)) {
        throwStatementNodesToBeAddedToDuplicatedNodesDueToIndispensableNodes.add(throwNode);
        break;
      }
    }
  }
  for (  PDGNode throwNode : throwStatementNodesToBeAddedToDuplicatedNodesDueToRemainingNodes) {
    indispensableNodes.addAll(subgraph.computeSlice(throwNode));
  }
  for (  PDGNode throwNode : throwStatementNodesToBeAddedToDuplicatedNodesDueToIndispensableNodes) {
    indispensableNodes.addAll(subgraph.computeSlice(throwNode));
  }
  this.removableNodes=new LinkedHashSet<PDGNode>();
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!remainingNodes.contains(pdgNode) && !indispensableNodes.contains(pdgNode))     removableNodes.add(pdgNode);
  }
}"
12028,"protected Set<ITypeBinding> getThrownExceptionTypes(Statement statement){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> methodInvocations=new ArrayList<Expression>();
  List<Expression> classInstanceCreations=new ArrayList<Expression>();
  if (statement instanceof IfStatement) {
    IfStatement ifStatement=(IfStatement)statement;
    Expression ifExpression=ifStatement.getExpression();
    methodInvocations.addAll(expressionExtractor.getMethodInvocations(ifExpression));
    classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(ifExpression));
  }
 else   if (statement instanceof WhileStatement) {
    WhileStatement whileStatement=(WhileStatement)statement;
    Expression whileExpression=whileStatement.getExpression();
    methodInvocations.addAll(expressionExtractor.getMethodInvocations(whileExpression));
    classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(whileExpression));
  }
 else   if (statement instanceof ForStatement) {
    ForStatement forStatement=(ForStatement)statement;
    List<Expression> initializers=forStatement.initializers();
    for (    Expression expression : initializers) {
      methodInvocations.addAll(expressionExtractor.getMethodInvocations(expression));
      classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(expression));
    }
    Expression forExpression=forStatement.getExpression();
    if (forExpression != null) {
      methodInvocations.addAll(expressionExtractor.getMethodInvocations(forExpression));
      classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(forExpression));
    }
    List<Expression> updaters=forStatement.updaters();
    for (    Expression expression : updaters) {
      methodInvocations.addAll(expressionExtractor.getMethodInvocations(expression));
      classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(expression));
    }
  }
 else   if (statement instanceof EnhancedForStatement) {
    EnhancedForStatement enhancedForStatement=(EnhancedForStatement)statement;
    Expression expression=enhancedForStatement.getExpression();
    methodInvocations.addAll(expressionExtractor.getMethodInvocations(expression));
    classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(expression));
  }
 else   if (statement instanceof DoStatement) {
    DoStatement doStatement=(DoStatement)statement;
    Expression doExpression=doStatement.getExpression();
    methodInvocations.addAll(expressionExtractor.getMethodInvocations(doExpression));
    classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(doExpression));
  }
 else   if (statement instanceof SwitchStatement) {
    SwitchStatement switchStatement=(SwitchStatement)statement;
    Expression switchExpression=switchStatement.getExpression();
    methodInvocations.addAll(expressionExtractor.getMethodInvocations(switchExpression));
    classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(switchExpression));
  }
 else   if (statement instanceof TryStatement) {
  }
 else {
    methodInvocations.addAll(expressionExtractor.getMethodInvocations(statement));
    classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(statement));
  }
  Set<ITypeBinding> thrownExceptionTypes=new LinkedHashSet<ITypeBinding>();
  for (  Expression expression : methodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      IMethodBinding methodInvocationBinding=methodInvocation.resolveMethodBinding();
      ITypeBinding[] exceptionTypes=methodInvocationBinding.getExceptionTypes();
      for (      ITypeBinding typeBinding : exceptionTypes)       thrownExceptionTypes.add(typeBinding);
    }
 else     if (expression instanceof SuperMethodInvocation) {
      SuperMethodInvocation superMethodInvocation=(SuperMethodInvocation)expression;
      IMethodBinding methodInvocationBinding=superMethodInvocation.resolveMethodBinding();
      ITypeBinding[] exceptionTypes=methodInvocationBinding.getExceptionTypes();
      for (      ITypeBinding typeBinding : exceptionTypes)       thrownExceptionTypes.add(typeBinding);
    }
  }
  for (  Expression expression : classInstanceCreations) {
    ClassInstanceCreation classInstanceCreation=(ClassInstanceCreation)expression;
    IMethodBinding constructorBinding=classInstanceCreation.resolveConstructorBinding();
    ITypeBinding[] exceptionTypes=constructorBinding.getExceptionTypes();
    for (    ITypeBinding typeBinding : exceptionTypes)     thrownExceptionTypes.add(typeBinding);
  }
  if (statement instanceof ThrowStatement) {
    ThrowStatement throwStatement=(ThrowStatement)statement;
    TypeVisitor typeVisitor=new TypeVisitor();
    throwStatement.accept(typeVisitor);
    thrownExceptionTypes.addAll(typeVisitor.getTypeBindings());
  }
  return thrownExceptionTypes;
}","protected Set<ITypeBinding> getThrownExceptionTypes(Statement statement){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> methodInvocations=new ArrayList<Expression>();
  List<Expression> classInstanceCreations=new ArrayList<Expression>();
  if (statement instanceof IfStatement) {
    IfStatement ifStatement=(IfStatement)statement;
    Expression ifExpression=ifStatement.getExpression();
    methodInvocations.addAll(expressionExtractor.getMethodInvocations(ifExpression));
    classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(ifExpression));
  }
 else   if (statement instanceof WhileStatement) {
    WhileStatement whileStatement=(WhileStatement)statement;
    Expression whileExpression=whileStatement.getExpression();
    methodInvocations.addAll(expressionExtractor.getMethodInvocations(whileExpression));
    classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(whileExpression));
  }
 else   if (statement instanceof ForStatement) {
    ForStatement forStatement=(ForStatement)statement;
    List<Expression> initializers=forStatement.initializers();
    for (    Expression expression : initializers) {
      methodInvocations.addAll(expressionExtractor.getMethodInvocations(expression));
      classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(expression));
    }
    Expression forExpression=forStatement.getExpression();
    if (forExpression != null) {
      methodInvocations.addAll(expressionExtractor.getMethodInvocations(forExpression));
      classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(forExpression));
    }
    List<Expression> updaters=forStatement.updaters();
    for (    Expression expression : updaters) {
      methodInvocations.addAll(expressionExtractor.getMethodInvocations(expression));
      classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(expression));
    }
  }
 else   if (statement instanceof EnhancedForStatement) {
    EnhancedForStatement enhancedForStatement=(EnhancedForStatement)statement;
    Expression expression=enhancedForStatement.getExpression();
    methodInvocations.addAll(expressionExtractor.getMethodInvocations(expression));
    classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(expression));
  }
 else   if (statement instanceof DoStatement) {
    DoStatement doStatement=(DoStatement)statement;
    Expression doExpression=doStatement.getExpression();
    methodInvocations.addAll(expressionExtractor.getMethodInvocations(doExpression));
    classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(doExpression));
  }
 else   if (statement instanceof SwitchStatement) {
    SwitchStatement switchStatement=(SwitchStatement)statement;
    Expression switchExpression=switchStatement.getExpression();
    methodInvocations.addAll(expressionExtractor.getMethodInvocations(switchExpression));
    classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(switchExpression));
  }
 else   if (statement instanceof TryStatement) {
  }
 else {
    methodInvocations.addAll(expressionExtractor.getMethodInvocations(statement));
    classInstanceCreations.addAll(expressionExtractor.getClassInstanceCreations(statement));
  }
  Set<ITypeBinding> thrownExceptionTypes=new LinkedHashSet<ITypeBinding>();
  for (  Expression expression : methodInvocations) {
    TryStatement surroundingTryBlock=surroundingTryBlock(expression);
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      IMethodBinding methodInvocationBinding=methodInvocation.resolveMethodBinding();
      ITypeBinding[] exceptionTypes=methodInvocationBinding.getExceptionTypes();
      for (      ITypeBinding typeBinding : exceptionTypes) {
        if (surroundingTryBlock == null || (surroundingTryBlock != null && !isNestedUnderAnonymousClassDeclaration(surroundingTryBlock))) {
          thrownExceptionTypes.add(typeBinding);
        }
      }
    }
 else     if (expression instanceof SuperMethodInvocation) {
      SuperMethodInvocation superMethodInvocation=(SuperMethodInvocation)expression;
      IMethodBinding methodInvocationBinding=superMethodInvocation.resolveMethodBinding();
      ITypeBinding[] exceptionTypes=methodInvocationBinding.getExceptionTypes();
      for (      ITypeBinding typeBinding : exceptionTypes) {
        if (surroundingTryBlock == null || (surroundingTryBlock != null && !isNestedUnderAnonymousClassDeclaration(surroundingTryBlock))) {
          thrownExceptionTypes.add(typeBinding);
        }
      }
    }
  }
  for (  Expression expression : classInstanceCreations) {
    TryStatement surroundingTryBlock=surroundingTryBlock(expression);
    ClassInstanceCreation classInstanceCreation=(ClassInstanceCreation)expression;
    IMethodBinding constructorBinding=classInstanceCreation.resolveConstructorBinding();
    ITypeBinding[] exceptionTypes=constructorBinding.getExceptionTypes();
    for (    ITypeBinding typeBinding : exceptionTypes) {
      if (surroundingTryBlock == null || (surroundingTryBlock != null && !isNestedUnderAnonymousClassDeclaration(surroundingTryBlock))) {
        thrownExceptionTypes.add(typeBinding);
      }
    }
  }
  if (statement instanceof ThrowStatement) {
    TryStatement surroundingTryBlock=surroundingTryBlock(statement);
    ThrowStatement throwStatement=(ThrowStatement)statement;
    TypeVisitor typeVisitor=new TypeVisitor();
    throwStatement.accept(typeVisitor);
    if (surroundingTryBlock == null || (surroundingTryBlock != null && !isNestedUnderAnonymousClassDeclaration(surroundingTryBlock))) {
      thrownExceptionTypes.addAll(typeVisitor.getTypeBindings());
    }
  }
  return thrownExceptionTypes;
}"
12029,"protected TryStatement surroundingTryBlock(Statement statement){
  ASTNode parent=statement.getParent();
  while (!(parent instanceof MethodDeclaration)) {
    if (parent instanceof TryStatement)     return (TryStatement)parent;
    parent=parent.getParent();
  }
  return null;
}","protected TryStatement surroundingTryBlock(ASTNode statement){
  ASTNode parent=statement.getParent();
  while (!(parent instanceof MethodDeclaration)) {
    if (parent instanceof TryStatement)     return (TryStatement)parent;
    parent=parent.getParent();
  }
  return null;
}"
12030,"private void extractMethod(MultiTextEdit root){
  ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
  AST ast=sourceTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion();
  SimpleName returnedVariableSimpleName=returnedVariableDeclaration.getName();
  ITypeBinding returnedVariableTypeBinding=extractTypeBinding(returnedVariableDeclaration);
  Type returnedVariableType=RefactoringUtility.generateTypeFromTypeBinding(returnedVariableTypeBinding,ast,sourceRewriter);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(slice.getExtractedMethodName()),null);
  IVariableBinding returnedVariableBinding=returnedVariableDeclaration.resolveBinding();
  if (slice.isObjectSlice() && (returnedVariableBinding.isField() || returnedVariableBinding.isParameter() || !slice.declarationOfVariableCriterionBelongsToSliceNodes()))   sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
 else   sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnedVariableType,null);
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
  modifierRewrite.insertLast(accessModifier,null);
  if ((sourceMethodDeclaration.getModifiers() & Modifier.STATIC) != 0) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  VariableDeclaration variableDeclaration : slice.getPassedParameters()) {
    ITypeBinding variableTypeBinding=extractTypeBinding(variableDeclaration);
    Type variableType=RefactoringUtility.generateTypeFromTypeBinding(variableTypeBinding,ast,sourceRewriter);
    if (!variableDeclaration.resolveBinding().isField()) {
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration.getName(),null);
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding thrownExceptionType : exceptionTypesThatShouldBeThrownByExtractedMethod) {
    thrownExceptionRewrite.insertLast(ast.newName(thrownExceptionType.getQualifiedName()),null);
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  List<PDGNode> sliceNodes=new ArrayList<PDGNode>(slice.getSliceNodes());
  while (!sliceNodes.isEmpty()) {
    ListRewrite bodyRewrite=methodBodyRewrite;
    PDGNode node=sliceNodes.get(0);
    PDGControlPredicateNode doLoopPredicateNode=isInsideDoLoop(node);
    if (doLoopPredicateNode != null) {
      bodyRewrite=createTryStatementIfNeeded(sourceRewriter,ast,bodyRewrite,doLoopPredicateNode);
      if (sliceNodes.contains(doLoopPredicateNode)) {
        bodyRewrite.insertLast(processPredicateNode(doLoopPredicateNode,ast,sourceRewriter,sliceNodes),null);
      }
    }
 else {
      bodyRewrite=createTryStatementIfNeeded(sourceRewriter,ast,bodyRewrite,node);
      if (node instanceof PDGControlPredicateNode) {
        PDGControlPredicateNode predicateNode=(PDGControlPredicateNode)node;
        bodyRewrite.insertLast(processPredicateNode(predicateNode,ast,sourceRewriter,sliceNodes),null);
      }
 else       if (node instanceof PDGTryNode) {
        sliceNodes.remove(node);
      }
 else {
        bodyRewrite.insertLast(node.getASTStatement(),null);
        sliceNodes.remove(node);
      }
    }
  }
  if (!slice.isObjectSlice() || (!returnedVariableBinding.isField() && !returnedVariableBinding.isParameter() && slice.declarationOfVariableCriterionBelongsToSliceNodes())) {
    ReturnStatement returnStatement=newMethodBody.getAST().newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariableSimpleName,null);
    methodBodyRewrite.insertLast(returnStatement,null);
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  ListRewrite methodDeclarationRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertAfter(newMethodDeclaration,sourceMethodDeclaration,null);
  try {
    TextEdit sourceEdit=sourceRewriter.rewriteAST();
    root.addChild(sourceEdit);
    compilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
}","private void extractMethod(MultiTextEdit root){
  ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
  AST ast=sourceTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion();
  SimpleName returnedVariableSimpleName=returnedVariableDeclaration.getName();
  ITypeBinding returnedVariableTypeBinding=extractTypeBinding(returnedVariableDeclaration);
  Type returnedVariableType=RefactoringUtility.generateTypeFromTypeBinding(returnedVariableTypeBinding,ast,sourceRewriter);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(slice.getExtractedMethodName()),null);
  IVariableBinding returnedVariableBinding=returnedVariableDeclaration.resolveBinding();
  if (slice.isObjectSlice() && (returnedVariableBinding.isField() || returnedVariableBinding.isParameter() || !slice.declarationOfVariableCriterionBelongsToSliceNodes()))   sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
 else   sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnedVariableType,null);
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
  modifierRewrite.insertLast(accessModifier,null);
  if ((sourceMethodDeclaration.getModifiers() & Modifier.STATIC) != 0) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  Set<ITypeBinding> requiredTypeParameterBindings=new LinkedHashSet<ITypeBinding>();
  for (  VariableDeclaration variableDeclaration : slice.getPassedParameters()) {
    ITypeBinding variableTypeBinding=extractTypeBinding(variableDeclaration);
    TypeVisitor typeVisitor=new TypeVisitor();
    variableDeclaration.accept(typeVisitor);
    Set<ITypeBinding> typeBindings=typeVisitor.getTypeBindings();
    for (    ITypeBinding typeBinding : typeBindings) {
      if (typeBinding.isTypeVariable()) {
        requiredTypeParameterBindings.add(typeBinding);
      }
    }
    Type variableType=RefactoringUtility.generateTypeFromTypeBinding(variableTypeBinding,ast,sourceRewriter);
    if (!variableDeclaration.resolveBinding().isField()) {
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration.getName(),null);
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
      if ((variableDeclaration.resolveBinding().getModifiers() & Modifier.FINAL) != 0) {
        Modifier finalModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.FINAL_KEYWORD);
        ListRewrite parameterModifierRewrite=sourceRewriter.getListRewrite(parameter,SingleVariableDeclaration.MODIFIERS2_PROPERTY);
        parameterModifierRewrite.insertLast(finalModifier,null);
      }
      parameterRewrite.insertLast(parameter,null);
    }
  }
  ListRewrite typeParameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.TYPE_PARAMETERS_PROPERTY);
  for (  ITypeBinding typeParameterBinding : requiredTypeParameterBindings) {
    TypeParameter typeParameter=ast.newTypeParameter();
    sourceRewriter.set(typeParameter,TypeParameter.NAME_PROPERTY,ast.newSimpleName(typeParameterBinding.getName()),null);
    ITypeBinding[] typeBounds=typeParameterBinding.getTypeBounds();
    if (typeBounds.length > 0) {
      ListRewrite typeBoundsRewrite=sourceRewriter.getListRewrite(typeParameter,TypeParameter.TYPE_BOUNDS_PROPERTY);
      for (      ITypeBinding typeBoundBinding : typeBounds) {
        Type typeBound=RefactoringUtility.generateTypeFromTypeBinding(typeBoundBinding,ast,sourceRewriter);
        typeBoundsRewrite.insertLast(typeBound,null);
      }
    }
    typeParameterRewrite.insertLast(typeParameter,null);
  }
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding thrownExceptionType : exceptionTypesThatShouldBeThrownByExtractedMethod) {
    thrownExceptionRewrite.insertLast(ast.newName(thrownExceptionType.getQualifiedName()),null);
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  List<PDGNode> sliceNodes=new ArrayList<PDGNode>(slice.getSliceNodes());
  while (!sliceNodes.isEmpty()) {
    ListRewrite bodyRewrite=methodBodyRewrite;
    PDGNode node=sliceNodes.get(0);
    PDGControlPredicateNode doLoopPredicateNode=isInsideDoLoop(node);
    if (doLoopPredicateNode != null) {
      bodyRewrite=createTryStatementIfNeeded(sourceRewriter,ast,bodyRewrite,doLoopPredicateNode);
      if (sliceNodes.contains(doLoopPredicateNode)) {
        bodyRewrite.insertLast(processPredicateNode(doLoopPredicateNode,ast,sourceRewriter,sliceNodes),null);
      }
    }
 else {
      bodyRewrite=createTryStatementIfNeeded(sourceRewriter,ast,bodyRewrite,node);
      if (node instanceof PDGControlPredicateNode) {
        PDGControlPredicateNode predicateNode=(PDGControlPredicateNode)node;
        bodyRewrite.insertLast(processPredicateNode(predicateNode,ast,sourceRewriter,sliceNodes),null);
      }
 else       if (node instanceof PDGTryNode) {
        sliceNodes.remove(node);
      }
 else {
        bodyRewrite.insertLast(node.getASTStatement(),null);
        sliceNodes.remove(node);
      }
    }
  }
  if (!slice.isObjectSlice() || (!returnedVariableBinding.isField() && !returnedVariableBinding.isParameter() && slice.declarationOfVariableCriterionBelongsToSliceNodes())) {
    ReturnStatement returnStatement=newMethodBody.getAST().newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariableSimpleName,null);
    methodBodyRewrite.insertLast(returnStatement,null);
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  ListRewrite methodDeclarationRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertAfter(newMethodDeclaration,sourceMethodDeclaration,null);
  try {
    TextEdit sourceEdit=sourceRewriter.rewriteAST();
    root.addChild(sourceEdit);
    compilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
}"
12031,"private void extractClone(){
  this.cloneInfo=new CloneInformation();
  Set<ITypeBinding> requiredImportTypeBindings=new LinkedHashSet<ITypeBinding>();
  ITypeBinding commonSuperTypeOfSourceTypeDeclarations=null;
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding()) && sourceTypeDeclarations.get(0).resolveBinding().getQualifiedName().equals(sourceTypeDeclarations.get(1).resolveBinding().getQualifiedName())) {
    cloneInfo.sourceCompilationUnit=sourceCompilationUnits.get(0);
    cloneInfo.sourceICompilationUnit=(ICompilationUnit)cloneInfo.sourceCompilationUnit.getJavaElement();
    cloneInfo.sourceTypeDeclaration=sourceTypeDeclarations.get(0);
    cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
    cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
  }
 else {
    ITypeBinding typeBinding1=sourceTypeDeclarations.get(0).resolveBinding();
    ITypeBinding typeBinding2=sourceTypeDeclarations.get(1).resolveBinding();
    commonSuperTypeOfSourceTypeDeclarations=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
    if (commonSuperTypeOfSourceTypeDeclarations != null) {
      if (mapper.getCloneRefactoringType().equals(CloneRefactoringType.PULL_UP_TO_EXISTING_SUPERCLASS)) {
        IJavaElement javaElement=commonSuperTypeOfSourceTypeDeclarations.getJavaElement();
        javaElementsToOpenInEditor.add(javaElement);
        ICompilationUnit iCompilationUnit=(ICompilationUnit)javaElement.getParent();
        ASTParser parser=ASTParser.newParser(ASTReader.JLS);
        parser.setKind(ASTParser.K_COMPILATION_UNIT);
        parser.setSource(iCompilationUnit);
        parser.setResolveBindings(true);
        CompilationUnit compilationUnit=(CompilationUnit)parser.createAST(null);
        List<AbstractTypeDeclaration> typeDeclarations=compilationUnit.types();
        for (        AbstractTypeDeclaration abstractTypeDeclaration : typeDeclarations) {
          if (abstractTypeDeclaration instanceof TypeDeclaration) {
            TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
            if (typeDeclaration.resolveBinding().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)) {
              cloneInfo.sourceCompilationUnit=compilationUnit;
              cloneInfo.sourceICompilationUnit=iCompilationUnit;
              cloneInfo.sourceTypeDeclaration=typeDeclaration;
              cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
              cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
              cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses=!superclassDirectlyInheritedFromRefactoredSubclasses(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2);
              break;
            }
          }
        }
        MultiTextEdit multiTextEdit=new MultiTextEdit();
        CompilationUnitChange compilationUnitChange=new CompilationUnitChange(""String_Node_Str"",iCompilationUnit);
        compilationUnitChange.setEdit(multiTextEdit);
        compilationUnitChanges.put(iCompilationUnit,compilationUnitChange);
      }
 else {
        if (mapper.getCloneRefactoringType().equals(CloneRefactoringType.EXTRACT_STATIC_METHOD_TO_NEW_UTILITY_CLASS)) {
          cloneInfo.extractUtilityClass=true;
        }
        if (cloneInfo.extractUtilityClass) {
          cloneInfo.intermediateClassName=""String_Node_Str"";
        }
 else {
          cloneInfo.intermediateClassName=""String_Node_Str"" + commonSuperTypeOfSourceTypeDeclarations.getName();
        }
        ClassObject commonSuperType=ASTReader.getSystemObject().getClassObject(commonSuperTypeOfSourceTypeDeclarations.getQualifiedName());
        CompilationUnit compilationUnit=null;
        if (commonSuperType != null) {
          compilationUnit=findCompilationUnit(commonSuperType.getAbstractTypeDeclaration());
        }
 else {
          compilationUnit=sourceCompilationUnits.get(0);
        }
        if (compilationUnit.getPackage() != null) {
          cloneInfo.intermediateClassPackageBinding=compilationUnit.getPackage().resolveBinding();
        }
        ICompilationUnit iCompilationUnit=(ICompilationUnit)compilationUnit.getJavaElement();
        IContainer container=(IContainer)iCompilationUnit.getResource().getParent();
        if (container instanceof IProject) {
          IProject contextProject=(IProject)container;
          cloneInfo.file=contextProject.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
 else         if (container instanceof IFolder) {
          IFolder contextFolder=(IFolder)container;
          cloneInfo.file=contextFolder.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
        boolean intermediateAlreadyExists=false;
        ICompilationUnit intermediateICompilationUnit=JavaCore.createCompilationUnitFrom(cloneInfo.file);
        javaElementsToOpenInEditor.add(intermediateICompilationUnit);
        ASTParser intermediateParser=ASTParser.newParser(ASTReader.JLS);
        intermediateParser.setKind(ASTParser.K_COMPILATION_UNIT);
        if (cloneInfo.file.exists()) {
          intermediateAlreadyExists=true;
          intermediateParser.setSource(intermediateICompilationUnit);
          intermediateParser.setResolveBindings(true);
        }
 else {
          cloneInfo.document=new Document();
          intermediateParser.setSource(cloneInfo.document.get().toCharArray());
        }
        CompilationUnit intermediateCompilationUnit=(CompilationUnit)intermediateParser.createAST(null);
        AST intermediateAST=intermediateCompilationUnit.getAST();
        ASTRewrite intermediateRewriter=ASTRewrite.create(intermediateAST);
        ListRewrite intermediateTypesRewrite=intermediateRewriter.getListRewrite(intermediateCompilationUnit,CompilationUnit.TYPES_PROPERTY);
        TypeDeclaration intermediateTypeDeclaration=null;
        if (intermediateAlreadyExists) {
          List<AbstractTypeDeclaration> abstractTypeDeclarations=intermediateCompilationUnit.types();
          for (          AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
            if (abstractTypeDeclaration instanceof TypeDeclaration) {
              TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
              if (typeDeclaration.getName().getIdentifier().equals(cloneInfo.intermediateClassName)) {
                intermediateTypeDeclaration=typeDeclaration;
                int intermediateModifiers=intermediateTypeDeclaration.getModifiers();
                if ((intermediateModifiers & Modifier.ABSTRACT) == 0 && !cloneInfo.extractUtilityClass) {
                  ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
                  intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
                }
                break;
              }
            }
          }
          MultiTextEdit intermediateMultiTextEdit=new MultiTextEdit();
          CompilationUnitChange intermediateCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",intermediateICompilationUnit);
          intermediateCompilationUnitChange.setEdit(intermediateMultiTextEdit);
          compilationUnitChanges.put(intermediateICompilationUnit,intermediateCompilationUnitChange);
        }
 else {
          if (compilationUnit.getPackage() != null) {
            intermediateRewriter.set(intermediateCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,compilationUnit.getPackage(),null);
          }
          intermediateTypeDeclaration=intermediateAST.newTypeDeclaration();
          SimpleName intermediateName=intermediateAST.newSimpleName(cloneInfo.intermediateClassName);
          intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.NAME_PROPERTY,intermediateName,null);
          ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
          intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
          if (!cloneInfo.extractUtilityClass) {
            intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
            Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
            if (commonSuperTypeOfSourceTypeDeclarations.isClass()) {
              intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,intermediateAST.newSimpleType(intermediateAST.newSimpleName(commonSuperTypeOfSourceTypeDeclarations.getName())),null);
              typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
            }
            ListRewrite interfaceRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.SUPER_INTERFACE_TYPES_PROPERTY);
            if (commonSuperTypeOfSourceTypeDeclarations.isInterface()) {
              ITypeBinding[] superInterfaces=commonSuperTypeOfSourceTypeDeclarations.getInterfaces();
              int taggingSuperInterfaceCount=0;
              for (              ITypeBinding superInterface : superInterfaces) {
                if (ASTNodeMatcher.isTaggingInterface(superInterface)) {
                  taggingSuperInterfaceCount++;
                }
              }
              boolean allSuperInterfacesAreTaggingInterfaces=superInterfaces.length > 0 && taggingSuperInterfaceCount == superInterfaces.length;
              boolean bothSubClassesImplementCommonSuperType=ASTNodeMatcher.implementsInterface(typeBinding1,commonSuperTypeOfSourceTypeDeclarations) && ASTNodeMatcher.implementsInterface(typeBinding2,commonSuperTypeOfSourceTypeDeclarations);
              if (!allSuperInterfacesAreTaggingInterfaces && !bothSubClassesImplementCommonSuperType) {
                Type interfaceType=RefactoringUtility.generateTypeFromTypeBinding(commonSuperTypeOfSourceTypeDeclarations,intermediateAST,intermediateRewriter);
                interfaceRewrite.insertLast(interfaceType,null);
                typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
              }
            }
            List<Type> superInterfaceTypes1=sourceTypeDeclarations.get(0).superInterfaceTypes();
            List<Type> superInterfaceTypes2=sourceTypeDeclarations.get(1).superInterfaceTypes();
            for (            Type interfaceType1 : superInterfaceTypes1) {
              ITypeBinding interfaceTypeBinding1=interfaceType1.resolveBinding();
              for (              Type interfaceType2 : superInterfaceTypes2) {
                ITypeBinding interfaceTypeBinding2=interfaceType2.resolveBinding();
                if (interfaceTypeBinding1.isEqualTo(interfaceTypeBinding2) && interfaceTypeBinding1.getQualifiedName().equals(interfaceTypeBinding2.getQualifiedName()) && checkIfThisReferenceIsPassedAsArgumentToMethodInvocation(interfaceTypeBinding1)) {
                  interfaceRewrite.insertLast(interfaceType1,null);
                  typeBindings.add(interfaceTypeBinding1);
                  break;
                }
              }
            }
            ListRewrite bodyDeclarationsRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
            Set<String> processedSuperConstructorBindingKeys=new LinkedHashSet<String>();
            for (            MethodDeclaration methodDeclaration1 : sourceTypeDeclarations.get(0).getMethods()) {
              if (methodDeclaration1.isConstructor()) {
                boolean matchingSuperConstructorCallFound=false;
                SuperConstructorInvocation superConstructorInvocation1=firstStatementIsSuperConstructorInvocation(methodDeclaration1);
                String superConstructorBindingKey1=superConstructorInvocation1 != null ? superConstructorInvocation1.resolveConstructorBinding().getKey() : null;
                for (                MethodDeclaration methodDeclaration2 : sourceTypeDeclarations.get(1).getMethods()) {
                  if (methodDeclaration2.isConstructor()) {
                    SuperConstructorInvocation superConstructorInvocation2=firstStatementIsSuperConstructorInvocation(methodDeclaration2);
                    if (superConstructorInvocation1 != null && superConstructorInvocation2 != null) {
                      List<Expression> superConstructorArguments1=superConstructorInvocation1.arguments();
                      List<Expression> superConstructorArguments2=superConstructorInvocation2.arguments();
                      if (matchingArgumentTypes(superConstructorArguments1,superConstructorArguments2) || superConstructorInvocation1.resolveConstructorBinding().isEqualTo(superConstructorInvocation2.resolveConstructorBinding())) {
                        matchingSuperConstructorCallFound=true;
                        if (!processedSuperConstructorBindingKeys.contains(superConstructorBindingKey1)) {
                          processedSuperConstructorBindingKeys.add(superConstructorBindingKey1);
                          if (compareStatements(sourceCompilationUnits.get(0).getTypeRoot(),sourceCompilationUnits.get(1).getTypeRoot(),superConstructorInvocation1,superConstructorInvocation2)) {
                            MethodDeclaration constructor=copyConstructor(methodDeclaration1,intermediateAST,intermediateRewriter,intermediateName,requiredImportTypeBindings);
                            bodyDeclarationsRewrite.insertLast(constructor,null);
                          }
 else {
                            MethodDeclaration constructor=intermediateAST.newMethodDeclaration();
                            intermediateRewriter.set(constructor,MethodDeclaration.NAME_PROPERTY,intermediateName,null);
                            intermediateRewriter.set(constructor,MethodDeclaration.CONSTRUCTOR_PROPERTY,true,null);
                            ListRewrite constructorModifierRewriter=intermediateRewriter.getListRewrite(constructor,MethodDeclaration.MODIFIERS2_PROPERTY);
                            List<IExtendedModifier> modifiers=methodDeclaration1.modifiers();
                            for (                            IExtendedModifier modifier : modifiers) {
                              if (modifier instanceof Modifier) {
                                constructorModifierRewriter.insertLast((Modifier)modifier,null);
                              }
                            }
                            ListRewrite parameterRewriter=intermediateRewriter.getListRewrite(constructor,MethodDeclaration.PARAMETERS_PROPERTY);
                            SuperConstructorInvocation superConstructorInvocation=intermediateAST.newSuperConstructorInvocation();
                            ListRewrite argumentRewriter=intermediateRewriter.getListRewrite(superConstructorInvocation,SuperConstructorInvocation.ARGUMENTS_PROPERTY);
                            Map<String,Integer> parameterTypeCounterMap=new LinkedHashMap<String,Integer>();
                            for (                            ITypeBinding argumentTypeBinding : superConstructorInvocation1.resolveConstructorBinding().getParameterTypes()) {
                              SingleVariableDeclaration parameter=intermediateAST.newSingleVariableDeclaration();
                              typeBindings.add(argumentTypeBinding);
                              Type parameterType=RefactoringUtility.generateTypeFromTypeBinding(argumentTypeBinding,intermediateAST,intermediateRewriter);
                              intermediateRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
                              String typeName=argumentTypeBinding.getName();
                              String parameterName=typeName.replaceFirst(Character.toString(typeName.charAt(0)),Character.toString(Character.toLowerCase(typeName.charAt(0))));
                              if (parameterTypeCounterMap.containsKey(argumentTypeBinding.getKey())) {
                                int previousCounter=parameterTypeCounterMap.get(argumentTypeBinding.getKey());
                                parameterName+=previousCounter;
                                int currentCounter=previousCounter + 1;
                                parameterTypeCounterMap.put(argumentTypeBinding.getKey(),currentCounter);
                              }
 else {
                                parameterTypeCounterMap.put(argumentTypeBinding.getKey(),1);
                              }
                              SimpleName parameterSimpleName=intermediateAST.newSimpleName(parameterName);
                              intermediateRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,parameterSimpleName,null);
                              parameterRewriter.insertLast(parameter,null);
                              argumentRewriter.insertLast(parameterSimpleName,null);
                            }
                            Block constructorBody=intermediateAST.newBlock();
                            ListRewrite constructorBodyRewriter=intermediateRewriter.getListRewrite(constructorBody,Block.STATEMENTS_PROPERTY);
                            constructorBodyRewriter.insertLast(superConstructorInvocation,null);
                            intermediateRewriter.set(constructor,MethodDeclaration.BODY_PROPERTY,constructorBody,null);
                            bodyDeclarationsRewrite.insertLast(constructor,null);
                          }
                        }
                      }
                    }
                  }
                }
                if (!matchingSuperConstructorCallFound && superConstructorInvocation1 != null) {
                  if (!processedSuperConstructorBindingKeys.contains(superConstructorBindingKey1)) {
                    processedSuperConstructorBindingKeys.add(superConstructorBindingKey1);
                    MethodDeclaration constructor=copyConstructor(methodDeclaration1,intermediateAST,intermediateRewriter,intermediateName,requiredImportTypeBindings);
                    bodyDeclarationsRewrite.insertLast(constructor,null);
                    constructorsToBeCopiedInSubclasses.get(1).add(methodDeclaration1);
                  }
                }
              }
            }
            for (            MethodDeclaration methodDeclaration2 : sourceTypeDeclarations.get(1).getMethods()) {
              if (methodDeclaration2.isConstructor()) {
                boolean matchingSuperConstructorCallFound=false;
                SuperConstructorInvocation superConstructorInvocation2=firstStatementIsSuperConstructorInvocation(methodDeclaration2);
                String superConstructorBindingKey2=superConstructorInvocation2 != null ? superConstructorInvocation2.resolveConstructorBinding().getKey() : null;
                for (                MethodDeclaration methodDeclaration1 : sourceTypeDeclarations.get(0).getMethods()) {
                  if (methodDeclaration1.isConstructor()) {
                    SuperConstructorInvocation superConstructorInvocation1=firstStatementIsSuperConstructorInvocation(methodDeclaration1);
                    if (superConstructorInvocation1 != null && superConstructorInvocation2 != null) {
                      List<Expression> superConstructorArguments1=superConstructorInvocation1.arguments();
                      List<Expression> superConstructorArguments2=superConstructorInvocation2.arguments();
                      if (matchingArgumentTypes(superConstructorArguments1,superConstructorArguments2) || superConstructorInvocation1.resolveConstructorBinding().isEqualTo(superConstructorInvocation2.resolveConstructorBinding())) {
                        matchingSuperConstructorCallFound=true;
                      }
                    }
                  }
                }
                if (!matchingSuperConstructorCallFound && superConstructorInvocation2 != null) {
                  if (!processedSuperConstructorBindingKeys.contains(superConstructorBindingKey2)) {
                    processedSuperConstructorBindingKeys.add(superConstructorBindingKey2);
                    MethodDeclaration constructor=copyConstructor(methodDeclaration2,intermediateAST,intermediateRewriter,intermediateName,requiredImportTypeBindings);
                    bodyDeclarationsRewrite.insertLast(constructor,null);
                    constructorsToBeCopiedInSubclasses.get(0).add(methodDeclaration2);
                  }
                }
              }
            }
            if ((noneOfTheConstructorsContainsSuperConstructorCall(sourceTypeDeclarations.get(0)) && !containsConstructorCallingSuperConstructorWithoutArguments(sourceTypeDeclarations.get(1))) || (noneOfTheConstructorsContainsSuperConstructorCall(sourceTypeDeclarations.get(1)) && !containsConstructorCallingSuperConstructorWithoutArguments(sourceTypeDeclarations.get(0)))) {
              boolean commonSuperTypeDeclaresConstructorWithoutParameters=false;
              for (              IMethodBinding methodBinding : commonSuperTypeOfSourceTypeDeclarations.getDeclaredMethods()) {
                if (methodBinding.isConstructor() && methodBinding.getParameterTypes().length == 0) {
                  commonSuperTypeDeclaresConstructorWithoutParameters=true;
                  break;
                }
              }
              if (commonSuperTypeDeclaresConstructorWithoutParameters) {
                MethodDeclaration constructor=createDefaultConstructor(intermediateAST,intermediateRewriter,intermediateName);
                bodyDeclarationsRewrite.insertLast(constructor,null);
              }
            }
            RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
          }
          intermediateTypesRewrite.insertLast(intermediateTypeDeclaration,null);
        }
        cloneInfo.sourceCompilationUnit=intermediateCompilationUnit;
        cloneInfo.sourceICompilationUnit=intermediateICompilationUnit;
        cloneInfo.sourceTypeDeclaration=intermediateTypeDeclaration;
        cloneInfo.sourceRewriter=intermediateRewriter;
        cloneInfo.ast=intermediateAST;
      }
    }
  }
  ASTRewrite sourceRewriter=cloneInfo.sourceRewriter;
  AST ast=cloneInfo.ast;
  TypeDeclaration sourceTypeDeclaration=cloneInfo.sourceTypeDeclaration;
  MethodDeclaration sourceMethodDeclaration=sourceMethodDeclarations.get(0);
  ListRewrite bodyDeclarationsRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  if (commonSuperTypeOfSourceTypeDeclarations != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
    RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  Set<VariableDeclaration> accessedLocalFieldsG1=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
  Set<VariableDeclaration> accessedLocalFieldsG2=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
  Set<VariableDeclaration> modifiedLocalFieldsG1=getLocallyAccessedFields(mapper.getDirectlyModifiedLocalFieldsG1(),sourceTypeDeclarations.get(0));
  Set<VariableDeclaration> modifiedLocalFieldsG2=getLocallyAccessedFields(mapper.getDirectlyModifiedLocalFieldsG2(),sourceTypeDeclarations.get(1));
  if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding()) || !sourceTypeDeclarations.get(0).resolveBinding().getQualifiedName().equals(sourceTypeDeclarations.get(1).resolveBinding().getQualifiedName())) {
    pullUpLocallyAccessedFields(accessedLocalFieldsG1,accessedLocalFieldsG2,modifiedLocalFieldsG1,modifiedLocalFieldsG2,bodyDeclarationsRewrite,requiredImportTypeBindings);
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG1=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG2=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    Set<VariableDeclaration> indirectlyModifiedLocalFieldsG1=getLocallyAccessedFields(mapper.getIndirectlyModifiedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> indirectlyModifiedLocalFieldsG2=getLocallyAccessedFields(mapper.getIndirectlyModifiedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    Set<MethodObject> accessedLocalMethodsG1=mapper.getAccessedLocalMethodsG1();
    Set<MethodObject> accessedLocalMethodsG2=mapper.getAccessedLocalMethodsG2();
    for (    MethodObject localMethodG1 : accessedLocalMethodsG1) {
      MethodDeclaration methodDeclaration1=localMethodG1.getMethodDeclaration();
      for (      MethodObject localMethodG2 : accessedLocalMethodsG2) {
        MethodDeclaration methodDeclaration2=localMethodG2.getMethodDeclaration();
        ITypeBinding returnTypesCommonSuperType=ASTNodeMatcher.commonSuperType(localMethodG1.getMethodDeclaration().getReturnType2().resolveBinding(),localMethodG2.getMethodDeclaration().getReturnType2().resolveBinding());
        if (localMethodG1.getName().equals(localMethodG2.getName()) && (localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) || ASTNodeMatcher.validCommonSuperType(returnTypesCommonSuperType)) && (localMethodG1.getParameterTypeList().equals(localMethodG2.getParameterTypeList()) || (MethodCallAnalyzer.equalSignatureIgnoringSubclassTypeDifferences(methodDeclaration1.resolveBinding(),methodDeclaration2.resolveBinding()) && mapper.getDirectlyAccessedLocalMethodsG1().contains(localMethodG1) && mapper.getDirectlyAccessedLocalMethodsG2().contains(localMethodG2)))) {
          Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
          boolean clones=type2Clones(methodDeclaration1,methodDeclaration2);
          Type returnType=methodDeclaration1.getReturnType2();
          TypeDeclaration typeDeclaration1=findTypeDeclaration(methodDeclaration1);
          TypeDeclaration typeDeclaration2=findTypeDeclaration(methodDeclaration2);
          Set<VariableDeclaration> fieldsAccessedInMethod1=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG1,methodDeclaration1);
          Set<VariableDeclaration> fieldsAccessedInMethod2=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG2,methodDeclaration2);
          Set<VariableDeclaration> fieldsModifiedInMethod1=getFieldsAccessedInMethod(indirectlyModifiedLocalFieldsG1,methodDeclaration1);
          Set<VariableDeclaration> fieldsModifiedInMethod2=getFieldsAccessedInMethod(indirectlyModifiedLocalFieldsG2,methodDeclaration2);
          if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !methodDeclaration1.resolveBinding().getDeclaringClass().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)&& !methodDeclaration2.resolveBinding().getDeclaringClass().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)&& !commonSuperTypeDeclaresMethodWithIdenticalSignature(methodDeclaration1)&& !commonSuperTypeDeclaresMethodWithIdenticalSignature(methodDeclaration2)&& !commonSuperTypeInheritsMethodWithIdenticalSignature(methodDeclaration1.resolveBinding(),cloneInfo.sourceTypeDeclaration.resolveBinding())&& !commonSuperTypeInheritsMethodWithIdenticalSignature(methodDeclaration2.resolveBinding(),cloneInfo.sourceTypeDeclaration.resolveBinding())) {
            boolean avoidPullUpDueToSerialization1=avoidPullUpMethodDueToSerialization(sourceTypeDeclarations.get(0),fieldsAccessedInMethod1);
            boolean avoidPullUpDueToSerialization2=avoidPullUpMethodDueToSerialization(sourceTypeDeclarations.get(1),fieldsAccessedInMethod2);
            if (clones && !avoidPullUpDueToSerialization1 && !avoidPullUpDueToSerialization2) {
              MethodDeclaration copiedMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,methodDeclaration1);
              ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(copiedMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
              List<IExtendedModifier> originalModifiers=copiedMethodDeclaration.modifiers();
              for (              IExtendedModifier extendedModifier : originalModifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.isPrivate()) {
                    modifiersRewrite.replace(modifier,ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                  }
                }
              }
              if (!localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) && ASTNodeMatcher.validCommonSuperType(returnTypesCommonSuperType)) {
                Type newReturnType=RefactoringUtility.generateTypeFromTypeBinding(returnTypesCommonSuperType,ast,sourceRewriter);
                sourceRewriter.set(copiedMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,newReturnType,null);
                typeBindings.add(returnTypesCommonSuperType);
              }
              if (!localMethodG1.isStatic() && localMethodG2.isStatic()) {
                modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD),null);
              }
              bodyDeclarationsRewrite.insertLast(copiedMethodDeclaration,null);
              TypeVisitor typeVisitor=new TypeVisitor();
              methodDeclaration1.accept(typeVisitor);
              typeBindings.addAll(typeVisitor.getTypeBindings());
              fieldsAccessedInMethod1.removeAll(accessedLocalFieldsG1);
              fieldsAccessedInMethod2.removeAll(accessedLocalFieldsG2);
              pullUpLocallyAccessedFields(fieldsAccessedInMethod1,fieldsAccessedInMethod2,fieldsModifiedInMethod1,fieldsModifiedInMethod2,bodyDeclarationsRewrite,requiredImportTypeBindings);
              if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
                methodDeclarationsToBePulledUp.get(0).add(methodDeclaration1);
              }
              if (!typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
                methodDeclarationsToBePulledUp.get(1).add(methodDeclaration2);
              }
            }
 else {
              if (mapper.getCloneRefactoringType().equals(CloneRefactoringType.EXTRACT_STATIC_METHOD_TO_NEW_UTILITY_CLASS)) {
                createDifferencesForStaticMethodCalls(methodDeclaration1.resolveBinding(),methodDeclaration2.resolveBinding());
              }
 else               if (!containsSuperMethodCall(typeDeclaration1,methodDeclaration1.resolveBinding()) && !containsSuperMethodCall(typeDeclaration2,methodDeclaration2.resolveBinding())) {
                MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
                sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(methodDeclaration1.getName().getIdentifier()),null);
                if (localMethodG1.getReturnType().equals(localMethodG2.getReturnType())) {
                  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
                  typeBindings.add(returnType.resolveBinding());
                }
 else                 if (ASTNodeMatcher.validCommonSuperType(returnTypesCommonSuperType)) {
                  Type newReturnType=RefactoringUtility.generateTypeFromTypeBinding(returnTypesCommonSuperType,ast,sourceRewriter);
                  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,newReturnType,null);
                  typeBindings.add(returnTypesCommonSuperType);
                }
                ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
                List<IExtendedModifier> originalModifiers=methodDeclaration1.modifiers();
                for (                IExtendedModifier extendedModifier : originalModifiers) {
                  if (extendedModifier.isModifier()) {
                    Modifier modifier=(Modifier)extendedModifier;
                    if (modifier.isProtected()) {
                      modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                      if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) == 0) {
                        updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                      }
                    }
 else                     if (modifier.isPublic()) {
                      if ((methodDeclaration2.getModifiers() & Modifier.PUBLIC) != 0) {
                        modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
                      }
 else                       if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) != 0) {
                        modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                      }
                      if ((methodDeclaration2.getModifiers() & Modifier.PUBLIC) == 0) {
                        updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PUBLIC_KEYWORD);
                      }
                    }
 else                     if (modifier.isPrivate()) {
                      modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                      updateAccessModifier(methodDeclaration1,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                      if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) == 0) {
                        updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                      }
                    }
                  }
                }
                if (cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses) {
                  Block methodBody=ast.newBlock();
                  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodBody,null);
                  Expression returnedExpression=generateDefaultValue(sourceRewriter,ast,returnType.resolveBinding());
                  if (returnedExpression != null) {
                    ReturnStatement returnStatement=ast.newReturnStatement();
                    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedExpression,null);
                    ListRewrite statementsRewrite=sourceRewriter.getListRewrite(methodBody,Block.STATEMENTS_PROPERTY);
                    statementsRewrite.insertLast(returnStatement,null);
                  }
                }
 else {
                  modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
                }
                ListRewrite parametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
                List<SingleVariableDeclaration> parameters1=methodDeclaration1.parameters();
                List<SingleVariableDeclaration> parameters2=methodDeclaration2.parameters();
                int parameterIndex=0;
                for (                SingleVariableDeclaration parameter1 : parameters1) {
                  SingleVariableDeclaration parameter2=parameters2.get(parameterIndex);
                  ITypeBinding parameterTypeBinding1=parameter1.getType().resolveBinding();
                  ITypeBinding parameterTypeBinding2=parameter2.getType().resolveBinding();
                  if (parameterTypeBinding1.isEqualTo(parameterTypeBinding2) && parameterTypeBinding1.getQualifiedName().equals(parameterTypeBinding2.getQualifiedName())) {
                    parametersRewrite.insertLast(parameter1,null);
                    typeBindings.add(parameterTypeBinding1);
                  }
 else {
                    ITypeBinding parameterCommonSuperTypeBinding=ASTNodeMatcher.commonSuperType(parameterTypeBinding1,parameterTypeBinding2);
                    Type parameterType=RefactoringUtility.generateTypeFromTypeBinding(parameterCommonSuperTypeBinding,ast,sourceRewriter);
                    SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
                    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
                    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(parameter1.getName().getIdentifier()),null);
                    parametersRewrite.insertLast(parameter,null);
                    typeBindings.add(parameterCommonSuperTypeBinding);
                  }
                  parameterIndex++;
                }
                ListRewrite thrownExceptionsRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
                List<Name> thrownExceptions=methodDeclaration1.thrownExceptions();
                for (                Name thrownException : thrownExceptions) {
                  thrownExceptionsRewrite.insertLast(thrownException,null);
                  typeBindings.add(thrownException.resolveTypeBinding());
                }
                bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
              }
            }
          }
          RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
          break;
        }
      }
    }
  }
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  List<VariableDeclaration> returnedVariables1=this.returnedVariables.get(0);
  List<VariableDeclaration> returnedVariables2=this.returnedVariables.get(1);
  ITypeBinding returnTypeBinding=mapper.getReturnTypeBinding();
  if (returnTypeBinding != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(returnTypeBinding);
    RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
    Type returnType=RefactoringUtility.generateTypeFromTypeBinding(returnTypeBinding,ast,sourceRewriter);
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
  }
 else {
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
  }
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else   if (cloneInfo.extractUtilityClass) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
  if (((sourceMethodDeclarations.get(0).getModifiers() & Modifier.STATIC) != 0 && (sourceMethodDeclarations.get(1).getModifiers() & Modifier.STATIC) != 0) || cloneInfo.extractUtilityClass) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> commonPassedParameters=mapper.getCommonPassedParameters();
  for (  VariableBindingKeyPair parameterName : commonPassedParameters.keySet()) {
    ArrayList<VariableDeclaration> variableDeclarations=commonPassedParameters.get(parameterName);
    VariableDeclaration variableDeclaration1=variableDeclarations.get(0);
    VariableDeclaration variableDeclaration2=variableDeclarations.get(1);
    if (parameterIsUsedByNodesWithoutDifferences(variableDeclaration1,variableDeclaration2)) {
      if (!variableDeclaration1.resolveBinding().isField() && !variableDeclaration2.resolveBinding().isField()) {
        ITypeBinding typeBinding1=extractTypeBinding(variableDeclaration1);
        ITypeBinding typeBinding2=extractTypeBinding(variableDeclaration2);
        ITypeBinding typeBinding=null;
        if (!typeBinding1.isEqualTo(typeBinding2) || !typeBinding1.getQualifiedName().equals(typeBinding2.getQualifiedName())) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
        boolean makeQualifiedType=RefactoringUtility.hasQualifiedType(variableDeclaration1) && RefactoringUtility.hasQualifiedType(variableDeclaration2);
        Type variableType=makeQualifiedType ? RefactoringUtility.generateQualifiedTypeFromTypeBinding(typeBinding,ast,sourceRewriter) : RefactoringUtility.generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(typeBinding);
        RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration1.getName(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
        parameterRewrite.insertLast(parameter,null);
        originalPassedParameters.put(parameterName,variableDeclarations);
      }
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  Set<ITypeBinding> thrownExceptionTypeBindings=new LinkedHashSet<ITypeBinding>();
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode1=pdgNodeMapping.getNodeG1();
    AbstractStatement statement1=pdgNode1.getStatement();
    PDGBlockNode blockNode1=mapper.getPDG1().isNestedWithinBlockNode(pdgNode1);
    if (blockNode1 != null && blockNode1 instanceof PDGTryNode && mapper.getRemovableNodesG1().contains(blockNode1)) {
    }
 else {
      ThrownExceptionVisitor thrownExceptionVisitor=new ThrownExceptionVisitor();
      statement1.getStatement().accept(thrownExceptionVisitor);
      for (      ITypeBinding thrownException : thrownExceptionVisitor.getTypeBindings()) {
        if (pdgNode1.getThrownExceptionTypes().contains(thrownException.getQualifiedName())) {
          addTypeBinding(thrownException,thrownExceptionTypeBindings);
        }
      }
    }
    RefactoringUtility.getSimpleTypeBindings(extractTypeBindings(statement1),requiredImportTypeBindings);
    PDGNode pdgNode2=pdgNodeMapping.getNodeG2();
    AbstractStatement statement2=pdgNode2.getStatement();
    PDGBlockNode blockNode2=mapper.getPDG2().isNestedWithinBlockNode(pdgNode2);
    if (blockNode2 != null && blockNode2 instanceof PDGTryNode && mapper.getRemovableNodesG2().contains(blockNode2)) {
    }
 else {
      ThrownExceptionVisitor thrownExceptionVisitor=new ThrownExceptionVisitor();
      statement2.getStatement().accept(thrownExceptionVisitor);
      for (      ITypeBinding thrownException : thrownExceptionVisitor.getTypeBindings()) {
        if (pdgNode2.getThrownExceptionTypes().contains(thrownException.getQualifiedName())) {
          addTypeBinding(thrownException,thrownExceptionTypeBindings);
        }
      }
    }
    RefactoringUtility.getSimpleTypeBindings(extractTypeBindings(statement2),requiredImportTypeBindings);
  }
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  List<Name> thrownExceptions1=sourceMethodDeclarations.get(0).thrownExceptions();
  List<Name> thrownExceptions2=sourceMethodDeclarations.get(1).thrownExceptions();
  for (  Name thrownException1 : thrownExceptions1) {
    for (    Name thrownException2 : thrownExceptions2) {
      if (thrownException1.resolveTypeBinding().isEqualTo(thrownException2.resolveTypeBinding()) && thrownExceptionTypeBindings.contains(thrownException1.resolveTypeBinding())) {
        thrownExceptionRewrite.insertLast(thrownException1,null);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(thrownException1.resolveTypeBinding());
        RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        thrownExceptionTypeBindings.remove(thrownException1.resolveTypeBinding());
        break;
      }
    }
  }
  for (  ITypeBinding thrownExceptionTypeBinding : thrownExceptionTypeBindings) {
    thrownExceptionRewrite.insertLast(ast.newSimpleName(thrownExceptionTypeBinding.getName()),null);
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(thrownExceptionTypeBinding);
    RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  CloneStructureNode root=mapper.getCloneStructureRoot();
  for (  CloneStructureNode child : root.getChildren()) {
    if (processableNode(child)) {
      Statement statement=processCloneStructureNode(child,ast,sourceRewriter);
      if (processableMappedNode(child) && ((PDGNodeMapping)child.getMapping()).declaresInconsistentlyRenamedVariable(mapper.getRenamedVariableBindings()) && mapper.movableBeforeFirstMappedNode((PDGNodeMapping)child.getMapping())) {
        methodBodyRewrite.insertFirst(statement,null);
      }
 else {
        methodBodyRewrite.insertLast(statement,null);
      }
    }
  }
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1 && !mappedNodesContainStatementReturningVariable(returnedVariables1.get(0),returnedVariables2.get(0))) {
    ReturnStatement returnStatement=ast.newReturnStatement();
    BindingSignaturePair variableBelongingToParameterizedDifferences=variableBelongsToParameterizedDifferences(returnedVariables1.get(0),returnedVariables2.get(0));
    if (variableBelongingToParameterizedDifferences != null) {
      int existingArgValue=findExistingParametersWithArgName();
      int i=0;
      if (existingArgValue > 0) {
        i=existingArgValue + 1;
      }
      for (      BindingSignaturePair pair : parameterizedDifferenceMap.keySet()) {
        if (pair.equals(variableBelongingToParameterizedDifferences)) {
          break;
        }
        i++;
      }
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,ast.newSimpleName(""String_Node_Str"" + i),null);
    }
 else {
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariables1.get(0).getName(),null);
    }
    methodBodyRewrite.insertLast(returnStatement,null);
    if (!mappedNodesContainStatementDeclaringVariable(returnedVariables1.get(0),returnedVariables2.get(0)) && !mappedNodesContainDifferentStatementsDeclaringVariables(returnedVariables1.get(0),returnedVariables2.get(0)) && variableBelongingToParameterizedDifferences == null && !variableIsPassedAsCommonParameter(returnedVariables1.get(0),returnedVariables2.get(0))) {
      ITypeBinding returnedTypeBinding=extractTypeBinding(returnedVariables1.get(0));
      Expression initializer=generateDefaultValue(sourceRewriter,ast,returnedTypeBinding);
      VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(fragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariables1.get(0).getName(),null);
      sourceRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,initializer,null);
      VariableDeclarationStatement declarationStatement=ast.newVariableDeclarationStatement(fragment);
      Type returnedType=RefactoringUtility.generateTypeFromTypeBinding(returnedTypeBinding,ast,sourceRewriter);
      sourceRewriter.set(declarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedType,null);
      methodBodyRewrite.insertFirst(declarationStatement,null);
    }
  }
 else {
    if (returnTypeBinding != null && !root.containsMappedReturnStatementInDirectChildren() && !root.lastIfElseIfChainContainsReturnOrThrowStatements()) {
      ReturnStatement returnStatement=ast.newReturnStatement();
      Expression expression=generateDefaultValue(sourceRewriter,ast,returnTypeBinding);
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,expression,null);
      methodBodyRewrite.insertLast(returnStatement,null);
    }
  }
  int existingArgValue=findExistingParametersWithArgName();
  int i=0;
  if (existingArgValue > 0) {
    i=existingArgValue + 1;
  }
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    AbstractExpression expression1=difference.getExpression1();
    AbstractExpression expression2=difference.getExpression2();
    boolean isReturnedVariable=false;
    if (expression1 != null) {
      isReturnedVariable=isReturnedVariable(expression1.getExpression(),this.returnedVariables.get(0));
    }
 else     if (expression2 != null) {
      isReturnedVariable=isReturnedVariable(expression2.getExpression(),this.returnedVariables.get(1));
    }
    ITypeBinding typeBinding1=expression1 != null ? ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1.getExpression()).resolveTypeBinding() : ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2.getExpression()).resolveTypeBinding();
    ITypeBinding typeBinding2=expression2 != null ? ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2.getExpression()).resolveTypeBinding() : ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1.getExpression()).resolveTypeBinding();
    if (!isReturnedVariable || (returnedVariables1.size() == 1 && returnedVariables2.size() == 1 && variableBelongsToParameterizedDifferences(returnedVariables1.get(0),returnedVariables2.get(0)) != null)) {
      ITypeBinding typeBinding=null;
      if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH) || difference.containsDifferenceType(DifferenceType.METHOD_INVOCATION_NAME_MISMATCH) || differenceContainsSubDifferenceWithSubclassTypeMismatch(difference)) {
        if (!typeBinding1.isEqualTo(typeBinding2) || !typeBinding1.getQualifiedName().equals(typeBinding2.getQualifiedName())) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
      }
 else {
        if (expression1 != null && !typeBinding1.getQualifiedName().equals(""String_Node_Str"")) {
          if (typeBinding1.getErasure().getQualifiedName().equals(""String_Node_Str"") && typeBinding2.getErasure().getQualifiedName().equals(""String_Node_Str"") && (!typeBinding1.isEqualTo(typeBinding2) || !typeBinding1.getQualifiedName().equals(typeBinding2.getQualifiedName()))) {
            typeBinding=typeBinding1.getErasure();
          }
 else {
            typeBinding=typeBinding1;
          }
        }
 else {
          typeBinding=typeBinding2;
        }
      }
      Type type=null;
      if (typeBinding.isPrimitive() && (typeBinding1.getQualifiedName().equals(""String_Node_Str"") || typeBinding2.getQualifiedName().equals(""String_Node_Str""))) {
        type=RefactoringUtility.generateWrapperTypeForPrimitiveTypeBinding(typeBinding,ast);
      }
 else {
        type=RefactoringUtility.generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
      }
      Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
      typeBindings.add(typeBinding);
      RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(""String_Node_Str"" + i),null);
      i++;
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  int j=0;
  List<VariableDeclaration> fieldDeclarationsToBeParameterizedG2=new ArrayList<VariableDeclaration>(fieldDeclarationsToBeParameterized.get(1));
  for (  VariableDeclaration variableDeclaration1 : fieldDeclarationsToBeParameterized.get(0)) {
    if (accessedLocalFieldsG1.contains(variableDeclaration1)) {
      VariableDeclaration variableDeclaration2=fieldDeclarationsToBeParameterizedG2.get(j);
      ITypeBinding typeBinding1=variableDeclaration1.resolveBinding().getType();
      ITypeBinding typeBinding2=variableDeclaration2.resolveBinding().getType();
      ITypeBinding typeBinding=null;
      if (!typeBinding1.isEqualTo(typeBinding2) || !typeBinding1.getQualifiedName().equals(typeBinding2.getQualifiedName())) {
        ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
        if (commonSuperTypeBinding != null) {
          typeBinding=commonSuperTypeBinding;
        }
      }
 else {
        typeBinding=typeBinding1;
      }
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      Type type=RefactoringUtility.generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      String identifier=(variableDeclaration1.resolveBinding().getModifiers() & Modifier.STATIC) != 0 ? variableDeclaration1.getName().getIdentifier() : createNameForParameterizedFieldAccess(variableDeclaration1.getName().getIdentifier());
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(identifier),null);
      parameterRewrite.insertLast(parameter,null);
    }
    j++;
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
  cloneInfo.requiredImportTypeBindings=requiredImportTypeBindings;
  cloneInfo.methodBodyRewrite=methodBodyRewrite;
  cloneInfo.parameterRewrite=parameterRewrite;
}","private void extractClone(){
  this.cloneInfo=new CloneInformation();
  Set<ITypeBinding> requiredImportTypeBindings=new LinkedHashSet<ITypeBinding>();
  ITypeBinding commonSuperTypeOfSourceTypeDeclarations=null;
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding()) && sourceTypeDeclarations.get(0).resolveBinding().getQualifiedName().equals(sourceTypeDeclarations.get(1).resolveBinding().getQualifiedName())) {
    cloneInfo.sourceCompilationUnit=sourceCompilationUnits.get(0);
    cloneInfo.sourceICompilationUnit=(ICompilationUnit)cloneInfo.sourceCompilationUnit.getJavaElement();
    cloneInfo.sourceTypeDeclaration=sourceTypeDeclarations.get(0);
    cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
    cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
  }
 else {
    ITypeBinding typeBinding1=sourceTypeDeclarations.get(0).resolveBinding();
    ITypeBinding typeBinding2=sourceTypeDeclarations.get(1).resolveBinding();
    commonSuperTypeOfSourceTypeDeclarations=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
    if (commonSuperTypeOfSourceTypeDeclarations != null) {
      if (mapper.getCloneRefactoringType().equals(CloneRefactoringType.PULL_UP_TO_EXISTING_SUPERCLASS)) {
        IJavaElement javaElement=commonSuperTypeOfSourceTypeDeclarations.getJavaElement();
        javaElementsToOpenInEditor.add(javaElement);
        ICompilationUnit iCompilationUnit=(ICompilationUnit)javaElement.getParent();
        ASTParser parser=ASTParser.newParser(ASTReader.JLS);
        parser.setKind(ASTParser.K_COMPILATION_UNIT);
        parser.setSource(iCompilationUnit);
        parser.setResolveBindings(true);
        CompilationUnit compilationUnit=(CompilationUnit)parser.createAST(null);
        List<AbstractTypeDeclaration> typeDeclarations=compilationUnit.types();
        for (        AbstractTypeDeclaration abstractTypeDeclaration : typeDeclarations) {
          if (abstractTypeDeclaration instanceof TypeDeclaration) {
            TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
            if (typeDeclaration.resolveBinding().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)) {
              cloneInfo.sourceCompilationUnit=compilationUnit;
              cloneInfo.sourceICompilationUnit=iCompilationUnit;
              cloneInfo.sourceTypeDeclaration=typeDeclaration;
              cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
              cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
              cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses=!superclassDirectlyInheritedFromRefactoredSubclasses(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2);
              break;
            }
          }
        }
        MultiTextEdit multiTextEdit=new MultiTextEdit();
        CompilationUnitChange compilationUnitChange=new CompilationUnitChange(""String_Node_Str"",iCompilationUnit);
        compilationUnitChange.setEdit(multiTextEdit);
        compilationUnitChanges.put(iCompilationUnit,compilationUnitChange);
      }
 else {
        if (mapper.getCloneRefactoringType().equals(CloneRefactoringType.EXTRACT_STATIC_METHOD_TO_NEW_UTILITY_CLASS)) {
          cloneInfo.extractUtilityClass=true;
        }
        if (cloneInfo.extractUtilityClass) {
          cloneInfo.intermediateClassName=""String_Node_Str"";
        }
 else {
          cloneInfo.intermediateClassName=""String_Node_Str"" + commonSuperTypeOfSourceTypeDeclarations.getName();
        }
        ClassObject commonSuperType=ASTReader.getSystemObject().getClassObject(commonSuperTypeOfSourceTypeDeclarations.getQualifiedName());
        CompilationUnit compilationUnit=null;
        if (commonSuperType != null) {
          compilationUnit=findCompilationUnit(commonSuperType.getAbstractTypeDeclaration());
        }
 else {
          compilationUnit=sourceCompilationUnits.get(0);
        }
        if (compilationUnit.getPackage() != null) {
          cloneInfo.intermediateClassPackageBinding=compilationUnit.getPackage().resolveBinding();
        }
        ICompilationUnit iCompilationUnit=(ICompilationUnit)compilationUnit.getJavaElement();
        IContainer container=(IContainer)iCompilationUnit.getResource().getParent();
        if (container instanceof IProject) {
          IProject contextProject=(IProject)container;
          cloneInfo.file=contextProject.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
 else         if (container instanceof IFolder) {
          IFolder contextFolder=(IFolder)container;
          cloneInfo.file=contextFolder.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
        boolean intermediateAlreadyExists=false;
        ICompilationUnit intermediateICompilationUnit=JavaCore.createCompilationUnitFrom(cloneInfo.file);
        javaElementsToOpenInEditor.add(intermediateICompilationUnit);
        ASTParser intermediateParser=ASTParser.newParser(ASTReader.JLS);
        intermediateParser.setKind(ASTParser.K_COMPILATION_UNIT);
        if (cloneInfo.file.exists()) {
          intermediateAlreadyExists=true;
          intermediateParser.setSource(intermediateICompilationUnit);
          intermediateParser.setResolveBindings(true);
        }
 else {
          cloneInfo.document=new Document();
          intermediateParser.setSource(cloneInfo.document.get().toCharArray());
        }
        CompilationUnit intermediateCompilationUnit=(CompilationUnit)intermediateParser.createAST(null);
        AST intermediateAST=intermediateCompilationUnit.getAST();
        ASTRewrite intermediateRewriter=ASTRewrite.create(intermediateAST);
        ListRewrite intermediateTypesRewrite=intermediateRewriter.getListRewrite(intermediateCompilationUnit,CompilationUnit.TYPES_PROPERTY);
        TypeDeclaration intermediateTypeDeclaration=null;
        if (intermediateAlreadyExists) {
          List<AbstractTypeDeclaration> abstractTypeDeclarations=intermediateCompilationUnit.types();
          for (          AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
            if (abstractTypeDeclaration instanceof TypeDeclaration) {
              TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
              if (typeDeclaration.getName().getIdentifier().equals(cloneInfo.intermediateClassName)) {
                intermediateTypeDeclaration=typeDeclaration;
                int intermediateModifiers=intermediateTypeDeclaration.getModifiers();
                if ((intermediateModifiers & Modifier.ABSTRACT) == 0 && !cloneInfo.extractUtilityClass) {
                  ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
                  intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
                }
                break;
              }
            }
          }
          MultiTextEdit intermediateMultiTextEdit=new MultiTextEdit();
          CompilationUnitChange intermediateCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",intermediateICompilationUnit);
          intermediateCompilationUnitChange.setEdit(intermediateMultiTextEdit);
          compilationUnitChanges.put(intermediateICompilationUnit,intermediateCompilationUnitChange);
        }
 else {
          if (compilationUnit.getPackage() != null) {
            intermediateRewriter.set(intermediateCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,compilationUnit.getPackage(),null);
          }
          intermediateTypeDeclaration=intermediateAST.newTypeDeclaration();
          SimpleName intermediateName=intermediateAST.newSimpleName(cloneInfo.intermediateClassName);
          intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.NAME_PROPERTY,intermediateName,null);
          ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
          intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
          if (!cloneInfo.extractUtilityClass) {
            intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
            Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
            if (commonSuperTypeOfSourceTypeDeclarations.isClass()) {
              intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,intermediateAST.newSimpleType(intermediateAST.newSimpleName(commonSuperTypeOfSourceTypeDeclarations.getName())),null);
              typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
            }
            ListRewrite interfaceRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.SUPER_INTERFACE_TYPES_PROPERTY);
            if (commonSuperTypeOfSourceTypeDeclarations.isInterface()) {
              ITypeBinding[] superInterfaces=commonSuperTypeOfSourceTypeDeclarations.getInterfaces();
              int taggingSuperInterfaceCount=0;
              for (              ITypeBinding superInterface : superInterfaces) {
                if (ASTNodeMatcher.isTaggingInterface(superInterface)) {
                  taggingSuperInterfaceCount++;
                }
              }
              boolean allSuperInterfacesAreTaggingInterfaces=superInterfaces.length > 0 && taggingSuperInterfaceCount == superInterfaces.length;
              boolean bothSubClassesImplementCommonSuperType=ASTNodeMatcher.implementsInterface(typeBinding1,commonSuperTypeOfSourceTypeDeclarations) && ASTNodeMatcher.implementsInterface(typeBinding2,commonSuperTypeOfSourceTypeDeclarations);
              if (!allSuperInterfacesAreTaggingInterfaces && !bothSubClassesImplementCommonSuperType) {
                Type interfaceType=RefactoringUtility.generateTypeFromTypeBinding(commonSuperTypeOfSourceTypeDeclarations,intermediateAST,intermediateRewriter);
                interfaceRewrite.insertLast(interfaceType,null);
                typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
              }
            }
            List<Type> superInterfaceTypes1=sourceTypeDeclarations.get(0).superInterfaceTypes();
            List<Type> superInterfaceTypes2=sourceTypeDeclarations.get(1).superInterfaceTypes();
            for (            Type interfaceType1 : superInterfaceTypes1) {
              ITypeBinding interfaceTypeBinding1=interfaceType1.resolveBinding();
              for (              Type interfaceType2 : superInterfaceTypes2) {
                ITypeBinding interfaceTypeBinding2=interfaceType2.resolveBinding();
                if (interfaceTypeBinding1.isEqualTo(interfaceTypeBinding2) && interfaceTypeBinding1.getQualifiedName().equals(interfaceTypeBinding2.getQualifiedName()) && checkIfThisReferenceIsPassedAsArgumentToMethodInvocation(interfaceTypeBinding1)) {
                  interfaceRewrite.insertLast(interfaceType1,null);
                  typeBindings.add(interfaceTypeBinding1);
                  break;
                }
              }
            }
            ListRewrite bodyDeclarationsRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
            Set<String> processedSuperConstructorBindingKeys=new LinkedHashSet<String>();
            for (            MethodDeclaration methodDeclaration1 : sourceTypeDeclarations.get(0).getMethods()) {
              if (methodDeclaration1.isConstructor()) {
                boolean matchingSuperConstructorCallFound=false;
                SuperConstructorInvocation superConstructorInvocation1=firstStatementIsSuperConstructorInvocation(methodDeclaration1);
                String superConstructorBindingKey1=superConstructorInvocation1 != null ? superConstructorInvocation1.resolveConstructorBinding().getKey() : null;
                for (                MethodDeclaration methodDeclaration2 : sourceTypeDeclarations.get(1).getMethods()) {
                  if (methodDeclaration2.isConstructor()) {
                    SuperConstructorInvocation superConstructorInvocation2=firstStatementIsSuperConstructorInvocation(methodDeclaration2);
                    if (superConstructorInvocation1 != null && superConstructorInvocation2 != null) {
                      List<Expression> superConstructorArguments1=superConstructorInvocation1.arguments();
                      List<Expression> superConstructorArguments2=superConstructorInvocation2.arguments();
                      if (matchingArgumentTypes(superConstructorArguments1,superConstructorArguments2) || superConstructorInvocation1.resolveConstructorBinding().isEqualTo(superConstructorInvocation2.resolveConstructorBinding())) {
                        matchingSuperConstructorCallFound=true;
                        if (!processedSuperConstructorBindingKeys.contains(superConstructorBindingKey1)) {
                          processedSuperConstructorBindingKeys.add(superConstructorBindingKey1);
                          if (compareStatements(sourceCompilationUnits.get(0).getTypeRoot(),sourceCompilationUnits.get(1).getTypeRoot(),superConstructorInvocation1,superConstructorInvocation2)) {
                            MethodDeclaration constructor=copyConstructor(methodDeclaration1,intermediateAST,intermediateRewriter,intermediateName,requiredImportTypeBindings);
                            bodyDeclarationsRewrite.insertLast(constructor,null);
                          }
 else {
                            MethodDeclaration constructor=intermediateAST.newMethodDeclaration();
                            intermediateRewriter.set(constructor,MethodDeclaration.NAME_PROPERTY,intermediateName,null);
                            intermediateRewriter.set(constructor,MethodDeclaration.CONSTRUCTOR_PROPERTY,true,null);
                            ListRewrite constructorModifierRewriter=intermediateRewriter.getListRewrite(constructor,MethodDeclaration.MODIFIERS2_PROPERTY);
                            List<IExtendedModifier> modifiers=methodDeclaration1.modifiers();
                            for (                            IExtendedModifier modifier : modifiers) {
                              if (modifier instanceof Modifier) {
                                constructorModifierRewriter.insertLast((Modifier)modifier,null);
                              }
                            }
                            ListRewrite parameterRewriter=intermediateRewriter.getListRewrite(constructor,MethodDeclaration.PARAMETERS_PROPERTY);
                            SuperConstructorInvocation superConstructorInvocation=intermediateAST.newSuperConstructorInvocation();
                            ListRewrite argumentRewriter=intermediateRewriter.getListRewrite(superConstructorInvocation,SuperConstructorInvocation.ARGUMENTS_PROPERTY);
                            Map<String,Integer> parameterTypeCounterMap=new LinkedHashMap<String,Integer>();
                            for (                            ITypeBinding argumentTypeBinding : superConstructorInvocation1.resolveConstructorBinding().getParameterTypes()) {
                              SingleVariableDeclaration parameter=intermediateAST.newSingleVariableDeclaration();
                              typeBindings.add(argumentTypeBinding);
                              Type parameterType=RefactoringUtility.generateTypeFromTypeBinding(argumentTypeBinding,intermediateAST,intermediateRewriter);
                              intermediateRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
                              String typeName=argumentTypeBinding.getName();
                              String parameterName=typeName.replaceFirst(Character.toString(typeName.charAt(0)),Character.toString(Character.toLowerCase(typeName.charAt(0))));
                              if (parameterTypeCounterMap.containsKey(argumentTypeBinding.getKey())) {
                                int previousCounter=parameterTypeCounterMap.get(argumentTypeBinding.getKey());
                                parameterName+=previousCounter;
                                int currentCounter=previousCounter + 1;
                                parameterTypeCounterMap.put(argumentTypeBinding.getKey(),currentCounter);
                              }
 else {
                                parameterTypeCounterMap.put(argumentTypeBinding.getKey(),1);
                              }
                              SimpleName parameterSimpleName=intermediateAST.newSimpleName(parameterName);
                              intermediateRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,parameterSimpleName,null);
                              parameterRewriter.insertLast(parameter,null);
                              argumentRewriter.insertLast(parameterSimpleName,null);
                            }
                            Block constructorBody=intermediateAST.newBlock();
                            ListRewrite constructorBodyRewriter=intermediateRewriter.getListRewrite(constructorBody,Block.STATEMENTS_PROPERTY);
                            constructorBodyRewriter.insertLast(superConstructorInvocation,null);
                            intermediateRewriter.set(constructor,MethodDeclaration.BODY_PROPERTY,constructorBody,null);
                            bodyDeclarationsRewrite.insertLast(constructor,null);
                          }
                        }
                      }
                    }
                  }
                }
                if (!matchingSuperConstructorCallFound && superConstructorInvocation1 != null) {
                  if (!processedSuperConstructorBindingKeys.contains(superConstructorBindingKey1)) {
                    processedSuperConstructorBindingKeys.add(superConstructorBindingKey1);
                    MethodDeclaration constructor=copyConstructor(methodDeclaration1,intermediateAST,intermediateRewriter,intermediateName,requiredImportTypeBindings);
                    bodyDeclarationsRewrite.insertLast(constructor,null);
                    constructorsToBeCopiedInSubclasses.get(1).add(methodDeclaration1);
                  }
                }
              }
            }
            for (            MethodDeclaration methodDeclaration2 : sourceTypeDeclarations.get(1).getMethods()) {
              if (methodDeclaration2.isConstructor()) {
                boolean matchingSuperConstructorCallFound=false;
                SuperConstructorInvocation superConstructorInvocation2=firstStatementIsSuperConstructorInvocation(methodDeclaration2);
                String superConstructorBindingKey2=superConstructorInvocation2 != null ? superConstructorInvocation2.resolveConstructorBinding().getKey() : null;
                for (                MethodDeclaration methodDeclaration1 : sourceTypeDeclarations.get(0).getMethods()) {
                  if (methodDeclaration1.isConstructor()) {
                    SuperConstructorInvocation superConstructorInvocation1=firstStatementIsSuperConstructorInvocation(methodDeclaration1);
                    if (superConstructorInvocation1 != null && superConstructorInvocation2 != null) {
                      List<Expression> superConstructorArguments1=superConstructorInvocation1.arguments();
                      List<Expression> superConstructorArguments2=superConstructorInvocation2.arguments();
                      if (matchingArgumentTypes(superConstructorArguments1,superConstructorArguments2) || superConstructorInvocation1.resolveConstructorBinding().isEqualTo(superConstructorInvocation2.resolveConstructorBinding())) {
                        matchingSuperConstructorCallFound=true;
                      }
                    }
                  }
                }
                if (!matchingSuperConstructorCallFound && superConstructorInvocation2 != null) {
                  if (!processedSuperConstructorBindingKeys.contains(superConstructorBindingKey2)) {
                    processedSuperConstructorBindingKeys.add(superConstructorBindingKey2);
                    MethodDeclaration constructor=copyConstructor(methodDeclaration2,intermediateAST,intermediateRewriter,intermediateName,requiredImportTypeBindings);
                    bodyDeclarationsRewrite.insertLast(constructor,null);
                    constructorsToBeCopiedInSubclasses.get(0).add(methodDeclaration2);
                  }
                }
              }
            }
            if ((noneOfTheConstructorsContainsSuperConstructorCall(sourceTypeDeclarations.get(0)) && !containsConstructorCallingSuperConstructorWithoutArguments(sourceTypeDeclarations.get(1))) || (noneOfTheConstructorsContainsSuperConstructorCall(sourceTypeDeclarations.get(1)) && !containsConstructorCallingSuperConstructorWithoutArguments(sourceTypeDeclarations.get(0)))) {
              boolean commonSuperTypeDeclaresConstructorWithoutParameters=false;
              for (              IMethodBinding methodBinding : commonSuperTypeOfSourceTypeDeclarations.getDeclaredMethods()) {
                if (methodBinding.isConstructor() && methodBinding.getParameterTypes().length == 0) {
                  commonSuperTypeDeclaresConstructorWithoutParameters=true;
                  break;
                }
              }
              if (commonSuperTypeDeclaresConstructorWithoutParameters) {
                MethodDeclaration constructor=createDefaultConstructor(intermediateAST,intermediateRewriter,intermediateName);
                bodyDeclarationsRewrite.insertLast(constructor,null);
              }
            }
            RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
          }
          intermediateTypesRewrite.insertLast(intermediateTypeDeclaration,null);
        }
        cloneInfo.sourceCompilationUnit=intermediateCompilationUnit;
        cloneInfo.sourceICompilationUnit=intermediateICompilationUnit;
        cloneInfo.sourceTypeDeclaration=intermediateTypeDeclaration;
        cloneInfo.sourceRewriter=intermediateRewriter;
        cloneInfo.ast=intermediateAST;
      }
    }
  }
  ASTRewrite sourceRewriter=cloneInfo.sourceRewriter;
  AST ast=cloneInfo.ast;
  TypeDeclaration sourceTypeDeclaration=cloneInfo.sourceTypeDeclaration;
  MethodDeclaration sourceMethodDeclaration=sourceMethodDeclarations.get(0);
  ListRewrite bodyDeclarationsRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  if (commonSuperTypeOfSourceTypeDeclarations != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
    RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  Set<VariableDeclaration> accessedLocalFieldsG1=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
  Set<VariableDeclaration> accessedLocalFieldsG2=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
  Set<VariableDeclaration> modifiedLocalFieldsG1=getLocallyAccessedFields(mapper.getDirectlyModifiedLocalFieldsG1(),sourceTypeDeclarations.get(0));
  Set<VariableDeclaration> modifiedLocalFieldsG2=getLocallyAccessedFields(mapper.getDirectlyModifiedLocalFieldsG2(),sourceTypeDeclarations.get(1));
  if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding()) || !sourceTypeDeclarations.get(0).resolveBinding().getQualifiedName().equals(sourceTypeDeclarations.get(1).resolveBinding().getQualifiedName())) {
    pullUpLocallyAccessedFields(accessedLocalFieldsG1,accessedLocalFieldsG2,modifiedLocalFieldsG1,modifiedLocalFieldsG2,bodyDeclarationsRewrite,requiredImportTypeBindings);
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG1=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG2=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    Set<VariableDeclaration> indirectlyModifiedLocalFieldsG1=getLocallyAccessedFields(mapper.getIndirectlyModifiedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> indirectlyModifiedLocalFieldsG2=getLocallyAccessedFields(mapper.getIndirectlyModifiedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    Set<MethodObject> accessedLocalMethodsG1=mapper.getAccessedLocalMethodsG1();
    Set<MethodObject> accessedLocalMethodsG2=mapper.getAccessedLocalMethodsG2();
    for (    MethodObject localMethodG1 : accessedLocalMethodsG1) {
      MethodDeclaration methodDeclaration1=localMethodG1.getMethodDeclaration();
      for (      MethodObject localMethodG2 : accessedLocalMethodsG2) {
        MethodDeclaration methodDeclaration2=localMethodG2.getMethodDeclaration();
        ITypeBinding returnTypesCommonSuperType=ASTNodeMatcher.commonSuperType(localMethodG1.getMethodDeclaration().getReturnType2().resolveBinding(),localMethodG2.getMethodDeclaration().getReturnType2().resolveBinding());
        if (localMethodG1.getName().equals(localMethodG2.getName()) && (localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) || ASTNodeMatcher.validCommonSuperType(returnTypesCommonSuperType)) && (localMethodG1.getParameterTypeList().equals(localMethodG2.getParameterTypeList()) || (MethodCallAnalyzer.equalSignatureIgnoringSubclassTypeDifferences(methodDeclaration1.resolveBinding(),methodDeclaration2.resolveBinding()) && mapper.getDirectlyAccessedLocalMethodsG1().contains(localMethodG1) && mapper.getDirectlyAccessedLocalMethodsG2().contains(localMethodG2)))) {
          Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
          boolean clones=type2Clones(methodDeclaration1,methodDeclaration2);
          Type returnType=methodDeclaration1.getReturnType2();
          TypeDeclaration typeDeclaration1=findTypeDeclaration(methodDeclaration1);
          TypeDeclaration typeDeclaration2=findTypeDeclaration(methodDeclaration2);
          Set<VariableDeclaration> fieldsAccessedInMethod1=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG1,methodDeclaration1);
          Set<VariableDeclaration> fieldsAccessedInMethod2=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG2,methodDeclaration2);
          Set<VariableDeclaration> fieldsModifiedInMethod1=getFieldsAccessedInMethod(indirectlyModifiedLocalFieldsG1,methodDeclaration1);
          Set<VariableDeclaration> fieldsModifiedInMethod2=getFieldsAccessedInMethod(indirectlyModifiedLocalFieldsG2,methodDeclaration2);
          if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !methodDeclaration1.resolveBinding().getDeclaringClass().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)&& !methodDeclaration2.resolveBinding().getDeclaringClass().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)&& !commonSuperTypeDeclaresOrInheritsMethodWithIdenticalSignature(methodDeclaration1.resolveBinding(),commonSuperTypeOfSourceTypeDeclarations)&& !commonSuperTypeDeclaresOrInheritsMethodWithIdenticalSignature(methodDeclaration2.resolveBinding(),commonSuperTypeOfSourceTypeDeclarations)) {
            boolean avoidPullUpDueToSerialization1=avoidPullUpMethodDueToSerialization(sourceTypeDeclarations.get(0),fieldsAccessedInMethod1);
            boolean avoidPullUpDueToSerialization2=avoidPullUpMethodDueToSerialization(sourceTypeDeclarations.get(1),fieldsAccessedInMethod2);
            if (clones && !avoidPullUpDueToSerialization1 && !avoidPullUpDueToSerialization2) {
              MethodDeclaration copiedMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,methodDeclaration1);
              ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(copiedMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
              List<IExtendedModifier> originalModifiers=copiedMethodDeclaration.modifiers();
              for (              IExtendedModifier extendedModifier : originalModifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.isPrivate()) {
                    modifiersRewrite.replace(modifier,ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                  }
                }
              }
              if (!localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) && ASTNodeMatcher.validCommonSuperType(returnTypesCommonSuperType)) {
                Type newReturnType=RefactoringUtility.generateTypeFromTypeBinding(returnTypesCommonSuperType,ast,sourceRewriter);
                sourceRewriter.set(copiedMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,newReturnType,null);
                typeBindings.add(returnTypesCommonSuperType);
              }
              if (!localMethodG1.isStatic() && localMethodG2.isStatic()) {
                modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD),null);
              }
              bodyDeclarationsRewrite.insertLast(copiedMethodDeclaration,null);
              TypeVisitor typeVisitor=new TypeVisitor();
              methodDeclaration1.accept(typeVisitor);
              typeBindings.addAll(typeVisitor.getTypeBindings());
              fieldsAccessedInMethod1.removeAll(accessedLocalFieldsG1);
              fieldsAccessedInMethod2.removeAll(accessedLocalFieldsG2);
              pullUpLocallyAccessedFields(fieldsAccessedInMethod1,fieldsAccessedInMethod2,fieldsModifiedInMethod1,fieldsModifiedInMethod2,bodyDeclarationsRewrite,requiredImportTypeBindings);
              if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
                methodDeclarationsToBePulledUp.get(0).add(methodDeclaration1);
              }
              if (!typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
                methodDeclarationsToBePulledUp.get(1).add(methodDeclaration2);
              }
            }
 else {
              if (mapper.getCloneRefactoringType().equals(CloneRefactoringType.EXTRACT_STATIC_METHOD_TO_NEW_UTILITY_CLASS)) {
                createDifferencesForStaticMethodCalls(methodDeclaration1.resolveBinding(),methodDeclaration2.resolveBinding());
              }
 else               if (!containsSuperMethodCall(typeDeclaration1,methodDeclaration1.resolveBinding()) && !containsSuperMethodCall(typeDeclaration2,methodDeclaration2.resolveBinding())) {
                MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
                sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(methodDeclaration1.getName().getIdentifier()),null);
                if (localMethodG1.getReturnType().equals(localMethodG2.getReturnType())) {
                  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
                  typeBindings.add(returnType.resolveBinding());
                }
 else                 if (ASTNodeMatcher.validCommonSuperType(returnTypesCommonSuperType)) {
                  Type newReturnType=RefactoringUtility.generateTypeFromTypeBinding(returnTypesCommonSuperType,ast,sourceRewriter);
                  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,newReturnType,null);
                  typeBindings.add(returnTypesCommonSuperType);
                }
                ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
                List<IExtendedModifier> originalModifiers=methodDeclaration1.modifiers();
                for (                IExtendedModifier extendedModifier : originalModifiers) {
                  if (extendedModifier.isModifier()) {
                    Modifier modifier=(Modifier)extendedModifier;
                    if (modifier.isProtected()) {
                      modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                      if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) == 0) {
                        updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                      }
                    }
 else                     if (modifier.isPublic()) {
                      if ((methodDeclaration2.getModifiers() & Modifier.PUBLIC) != 0) {
                        modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
                      }
 else                       if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) != 0) {
                        modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                      }
                      if ((methodDeclaration2.getModifiers() & Modifier.PUBLIC) == 0) {
                        updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PUBLIC_KEYWORD);
                      }
                    }
 else                     if (modifier.isPrivate()) {
                      modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                      updateAccessModifier(methodDeclaration1,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                      if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) == 0) {
                        updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                      }
                    }
                  }
                }
                if (cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses) {
                  Block methodBody=ast.newBlock();
                  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodBody,null);
                  Expression returnedExpression=generateDefaultValue(sourceRewriter,ast,returnType.resolveBinding());
                  if (returnedExpression != null) {
                    ReturnStatement returnStatement=ast.newReturnStatement();
                    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedExpression,null);
                    ListRewrite statementsRewrite=sourceRewriter.getListRewrite(methodBody,Block.STATEMENTS_PROPERTY);
                    statementsRewrite.insertLast(returnStatement,null);
                  }
                }
 else {
                  modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
                }
                ListRewrite parametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
                List<SingleVariableDeclaration> parameters1=methodDeclaration1.parameters();
                List<SingleVariableDeclaration> parameters2=methodDeclaration2.parameters();
                int parameterIndex=0;
                for (                SingleVariableDeclaration parameter1 : parameters1) {
                  SingleVariableDeclaration parameter2=parameters2.get(parameterIndex);
                  ITypeBinding parameterTypeBinding1=parameter1.getType().resolveBinding();
                  ITypeBinding parameterTypeBinding2=parameter2.getType().resolveBinding();
                  if (parameterTypeBinding1.isEqualTo(parameterTypeBinding2) && parameterTypeBinding1.getQualifiedName().equals(parameterTypeBinding2.getQualifiedName())) {
                    parametersRewrite.insertLast(parameter1,null);
                    typeBindings.add(parameterTypeBinding1);
                  }
 else {
                    ITypeBinding parameterCommonSuperTypeBinding=ASTNodeMatcher.commonSuperType(parameterTypeBinding1,parameterTypeBinding2);
                    Type parameterType=RefactoringUtility.generateTypeFromTypeBinding(parameterCommonSuperTypeBinding,ast,sourceRewriter);
                    SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
                    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
                    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(parameter1.getName().getIdentifier()),null);
                    parametersRewrite.insertLast(parameter,null);
                    typeBindings.add(parameterCommonSuperTypeBinding);
                  }
                  parameterIndex++;
                }
                ListRewrite thrownExceptionsRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
                List<Name> thrownExceptions=methodDeclaration1.thrownExceptions();
                for (                Name thrownException : thrownExceptions) {
                  thrownExceptionsRewrite.insertLast(thrownException,null);
                  typeBindings.add(thrownException.resolveTypeBinding());
                }
                bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
              }
            }
          }
          RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
          break;
        }
      }
    }
  }
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  List<VariableDeclaration> returnedVariables1=this.returnedVariables.get(0);
  List<VariableDeclaration> returnedVariables2=this.returnedVariables.get(1);
  ITypeBinding returnTypeBinding=mapper.getReturnTypeBinding();
  if (returnTypeBinding != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(returnTypeBinding);
    RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
    Type returnType=RefactoringUtility.generateTypeFromTypeBinding(returnTypeBinding,ast,sourceRewriter);
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
  }
 else {
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
  }
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else   if (cloneInfo.extractUtilityClass) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
  if (((sourceMethodDeclarations.get(0).getModifiers() & Modifier.STATIC) != 0 && (sourceMethodDeclarations.get(1).getModifiers() & Modifier.STATIC) != 0) || cloneInfo.extractUtilityClass) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> commonPassedParameters=mapper.getCommonPassedParameters();
  for (  VariableBindingKeyPair parameterName : commonPassedParameters.keySet()) {
    ArrayList<VariableDeclaration> variableDeclarations=commonPassedParameters.get(parameterName);
    VariableDeclaration variableDeclaration1=variableDeclarations.get(0);
    VariableDeclaration variableDeclaration2=variableDeclarations.get(1);
    if (parameterIsUsedByNodesWithoutDifferences(variableDeclaration1,variableDeclaration2)) {
      if (!variableDeclaration1.resolveBinding().isField() && !variableDeclaration2.resolveBinding().isField()) {
        ITypeBinding typeBinding1=extractTypeBinding(variableDeclaration1);
        ITypeBinding typeBinding2=extractTypeBinding(variableDeclaration2);
        ITypeBinding typeBinding=null;
        if (!typeBinding1.isEqualTo(typeBinding2) || !typeBinding1.getQualifiedName().equals(typeBinding2.getQualifiedName())) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
        boolean makeQualifiedType=RefactoringUtility.hasQualifiedType(variableDeclaration1) && RefactoringUtility.hasQualifiedType(variableDeclaration2);
        Type variableType=makeQualifiedType ? RefactoringUtility.generateQualifiedTypeFromTypeBinding(typeBinding,ast,sourceRewriter) : RefactoringUtility.generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(typeBinding);
        RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration1.getName(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
        parameterRewrite.insertLast(parameter,null);
        originalPassedParameters.put(parameterName,variableDeclarations);
      }
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  Set<ITypeBinding> thrownExceptionTypeBindings=new LinkedHashSet<ITypeBinding>();
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode1=pdgNodeMapping.getNodeG1();
    AbstractStatement statement1=pdgNode1.getStatement();
    PDGBlockNode blockNode1=mapper.getPDG1().isNestedWithinBlockNode(pdgNode1);
    if (blockNode1 != null && blockNode1 instanceof PDGTryNode && mapper.getRemovableNodesG1().contains(blockNode1)) {
    }
 else {
      ThrownExceptionVisitor thrownExceptionVisitor=new ThrownExceptionVisitor();
      statement1.getStatement().accept(thrownExceptionVisitor);
      for (      ITypeBinding thrownException : thrownExceptionVisitor.getTypeBindings()) {
        if (pdgNode1.getThrownExceptionTypes().contains(thrownException.getQualifiedName())) {
          addTypeBinding(thrownException,thrownExceptionTypeBindings);
        }
      }
    }
    RefactoringUtility.getSimpleTypeBindings(extractTypeBindings(statement1),requiredImportTypeBindings);
    PDGNode pdgNode2=pdgNodeMapping.getNodeG2();
    AbstractStatement statement2=pdgNode2.getStatement();
    PDGBlockNode blockNode2=mapper.getPDG2().isNestedWithinBlockNode(pdgNode2);
    if (blockNode2 != null && blockNode2 instanceof PDGTryNode && mapper.getRemovableNodesG2().contains(blockNode2)) {
    }
 else {
      ThrownExceptionVisitor thrownExceptionVisitor=new ThrownExceptionVisitor();
      statement2.getStatement().accept(thrownExceptionVisitor);
      for (      ITypeBinding thrownException : thrownExceptionVisitor.getTypeBindings()) {
        if (pdgNode2.getThrownExceptionTypes().contains(thrownException.getQualifiedName())) {
          addTypeBinding(thrownException,thrownExceptionTypeBindings);
        }
      }
    }
    RefactoringUtility.getSimpleTypeBindings(extractTypeBindings(statement2),requiredImportTypeBindings);
  }
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  List<Name> thrownExceptions1=sourceMethodDeclarations.get(0).thrownExceptions();
  List<Name> thrownExceptions2=sourceMethodDeclarations.get(1).thrownExceptions();
  for (  Name thrownException1 : thrownExceptions1) {
    for (    Name thrownException2 : thrownExceptions2) {
      if (thrownException1.resolveTypeBinding().isEqualTo(thrownException2.resolveTypeBinding()) && thrownExceptionTypeBindings.contains(thrownException1.resolveTypeBinding())) {
        thrownExceptionRewrite.insertLast(thrownException1,null);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(thrownException1.resolveTypeBinding());
        RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        thrownExceptionTypeBindings.remove(thrownException1.resolveTypeBinding());
        break;
      }
    }
  }
  for (  ITypeBinding thrownExceptionTypeBinding : thrownExceptionTypeBindings) {
    thrownExceptionRewrite.insertLast(ast.newSimpleName(thrownExceptionTypeBinding.getName()),null);
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(thrownExceptionTypeBinding);
    RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  CloneStructureNode root=mapper.getCloneStructureRoot();
  for (  CloneStructureNode child : root.getChildren()) {
    if (processableNode(child)) {
      Statement statement=processCloneStructureNode(child,ast,sourceRewriter);
      if (processableMappedNode(child) && ((PDGNodeMapping)child.getMapping()).declaresInconsistentlyRenamedVariable(mapper.getRenamedVariableBindings()) && mapper.movableBeforeFirstMappedNode((PDGNodeMapping)child.getMapping())) {
        methodBodyRewrite.insertFirst(statement,null);
      }
 else {
        methodBodyRewrite.insertLast(statement,null);
      }
    }
  }
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1 && !mappedNodesContainStatementReturningVariable(returnedVariables1.get(0),returnedVariables2.get(0))) {
    ReturnStatement returnStatement=ast.newReturnStatement();
    BindingSignaturePair variableBelongingToParameterizedDifferences=variableBelongsToParameterizedDifferences(returnedVariables1.get(0),returnedVariables2.get(0));
    if (variableBelongingToParameterizedDifferences != null) {
      int existingArgValue=findExistingParametersWithArgName();
      int i=0;
      if (existingArgValue > 0) {
        i=existingArgValue + 1;
      }
      for (      BindingSignaturePair pair : parameterizedDifferenceMap.keySet()) {
        if (pair.equals(variableBelongingToParameterizedDifferences)) {
          break;
        }
        i++;
      }
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,ast.newSimpleName(""String_Node_Str"" + i),null);
    }
 else {
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariables1.get(0).getName(),null);
    }
    methodBodyRewrite.insertLast(returnStatement,null);
    if (!mappedNodesContainStatementDeclaringVariable(returnedVariables1.get(0),returnedVariables2.get(0)) && !mappedNodesContainDifferentStatementsDeclaringVariables(returnedVariables1.get(0),returnedVariables2.get(0)) && variableBelongingToParameterizedDifferences == null && !variableIsPassedAsCommonParameter(returnedVariables1.get(0),returnedVariables2.get(0))) {
      ITypeBinding returnedTypeBinding=extractTypeBinding(returnedVariables1.get(0));
      Expression initializer=generateDefaultValue(sourceRewriter,ast,returnedTypeBinding);
      VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(fragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariables1.get(0).getName(),null);
      sourceRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,initializer,null);
      VariableDeclarationStatement declarationStatement=ast.newVariableDeclarationStatement(fragment);
      Type returnedType=RefactoringUtility.generateTypeFromTypeBinding(returnedTypeBinding,ast,sourceRewriter);
      sourceRewriter.set(declarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedType,null);
      methodBodyRewrite.insertFirst(declarationStatement,null);
    }
  }
 else {
    if (returnTypeBinding != null && !root.containsMappedReturnStatementInDirectChildren() && !root.lastIfElseIfChainContainsReturnOrThrowStatements()) {
      ReturnStatement returnStatement=ast.newReturnStatement();
      Expression expression=generateDefaultValue(sourceRewriter,ast,returnTypeBinding);
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,expression,null);
      methodBodyRewrite.insertLast(returnStatement,null);
    }
  }
  int existingArgValue=findExistingParametersWithArgName();
  int i=0;
  if (existingArgValue > 0) {
    i=existingArgValue + 1;
  }
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    AbstractExpression expression1=difference.getExpression1();
    AbstractExpression expression2=difference.getExpression2();
    boolean isReturnedVariable=false;
    if (expression1 != null) {
      isReturnedVariable=isReturnedVariable(expression1.getExpression(),this.returnedVariables.get(0));
    }
 else     if (expression2 != null) {
      isReturnedVariable=isReturnedVariable(expression2.getExpression(),this.returnedVariables.get(1));
    }
    ITypeBinding typeBinding1=expression1 != null ? ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1.getExpression()).resolveTypeBinding() : ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2.getExpression()).resolveTypeBinding();
    ITypeBinding typeBinding2=expression2 != null ? ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2.getExpression()).resolveTypeBinding() : ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1.getExpression()).resolveTypeBinding();
    if (!isReturnedVariable || (returnedVariables1.size() == 1 && returnedVariables2.size() == 1 && variableBelongsToParameterizedDifferences(returnedVariables1.get(0),returnedVariables2.get(0)) != null)) {
      ITypeBinding typeBinding=null;
      if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH) || difference.containsDifferenceType(DifferenceType.METHOD_INVOCATION_NAME_MISMATCH) || differenceContainsSubDifferenceWithSubclassTypeMismatch(difference)) {
        if (!typeBinding1.isEqualTo(typeBinding2) || !typeBinding1.getQualifiedName().equals(typeBinding2.getQualifiedName())) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
      }
 else {
        if (expression1 != null && !typeBinding1.getQualifiedName().equals(""String_Node_Str"")) {
          if (typeBinding1.getErasure().getQualifiedName().equals(""String_Node_Str"") && typeBinding2.getErasure().getQualifiedName().equals(""String_Node_Str"") && (!typeBinding1.isEqualTo(typeBinding2) || !typeBinding1.getQualifiedName().equals(typeBinding2.getQualifiedName()))) {
            typeBinding=typeBinding1.getErasure();
          }
 else {
            typeBinding=typeBinding1;
          }
        }
 else {
          typeBinding=typeBinding2;
        }
      }
      Type type=null;
      if (typeBinding.isPrimitive() && (typeBinding1.getQualifiedName().equals(""String_Node_Str"") || typeBinding2.getQualifiedName().equals(""String_Node_Str""))) {
        type=RefactoringUtility.generateWrapperTypeForPrimitiveTypeBinding(typeBinding,ast);
      }
 else {
        type=RefactoringUtility.generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
      }
      Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
      typeBindings.add(typeBinding);
      RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(""String_Node_Str"" + i),null);
      i++;
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  int j=0;
  List<VariableDeclaration> fieldDeclarationsToBeParameterizedG2=new ArrayList<VariableDeclaration>(fieldDeclarationsToBeParameterized.get(1));
  for (  VariableDeclaration variableDeclaration1 : fieldDeclarationsToBeParameterized.get(0)) {
    if (accessedLocalFieldsG1.contains(variableDeclaration1)) {
      VariableDeclaration variableDeclaration2=fieldDeclarationsToBeParameterizedG2.get(j);
      ITypeBinding typeBinding1=variableDeclaration1.resolveBinding().getType();
      ITypeBinding typeBinding2=variableDeclaration2.resolveBinding().getType();
      ITypeBinding typeBinding=null;
      if (!typeBinding1.isEqualTo(typeBinding2) || !typeBinding1.getQualifiedName().equals(typeBinding2.getQualifiedName())) {
        ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
        if (commonSuperTypeBinding != null) {
          typeBinding=commonSuperTypeBinding;
        }
      }
 else {
        typeBinding=typeBinding1;
      }
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      Type type=RefactoringUtility.generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      String identifier=(variableDeclaration1.resolveBinding().getModifiers() & Modifier.STATIC) != 0 ? variableDeclaration1.getName().getIdentifier() : createNameForParameterizedFieldAccess(variableDeclaration1.getName().getIdentifier());
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(identifier),null);
      parameterRewrite.insertLast(parameter,null);
    }
    j++;
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
  cloneInfo.requiredImportTypeBindings=requiredImportTypeBindings;
  cloneInfo.methodBodyRewrite=methodBodyRewrite;
  cloneInfo.parameterRewrite=parameterRewrite;
}"
12032,"public boolean hasResources(){
  return !getExpressions().isEmpty();
}","public boolean hasResources(){
  return !super.getExpressions().isEmpty();
}"
12033,"public ExtractClassRefactoring(IFile sourceFile,CompilationUnit sourceCompilationUnit,TypeDeclaration sourceTypeDeclaration,Set<VariableDeclaration> extractedFieldFragments,Set<MethodDeclaration> extractedMethods,Set<MethodDeclaration> delegateMethods,String extractedTypeName){
  this.sourceFile=sourceFile;
  this.sourceCompilationUnit=sourceCompilationUnit;
  this.sourceTypeDeclaration=sourceTypeDeclaration;
  this.compilationUnitChanges=new LinkedHashMap<ICompilationUnit,CompilationUnitChange>();
  ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
  MultiTextEdit sourceMultiTextEdit=new MultiTextEdit();
  CompilationUnitChange sourceCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",sourceICompilationUnit);
  sourceCompilationUnitChange.setEdit(sourceMultiTextEdit);
  this.compilationUnitChanges.put(sourceICompilationUnit,sourceCompilationUnitChange);
  this.createCompilationUnitChanges=new LinkedHashMap<ICompilationUnit,CreateCompilationUnitChange>();
  this.javaElementsToOpenInEditor=new LinkedHashSet<IJavaElement>();
  this.requiredImportDeclarationsInExtractedClass=new LinkedHashSet<ITypeBinding>();
  this.additionalArgumentsAddedToExtractedMethods=new LinkedHashMap<MethodDeclaration,Set<PlainVariable>>();
  this.additionalParametersAddedToExtractedMethods=new LinkedHashMap<MethodDeclaration,Set<SingleVariableDeclaration>>();
  this.sourceMethodBindingsChangedWithPublicModifier=new LinkedHashSet<String>();
  this.sourceFieldBindingsWithCreatedSetterMethod=new LinkedHashSet<String>();
  this.sourceFieldBindingsWithCreatedGetterMethod=new LinkedHashSet<String>();
  this.fieldDeclarationsChangedWithPublicModifier=new LinkedHashSet<FieldDeclaration>();
  this.memberTypeDeclarationsChangedWithPublicModifier=new LinkedHashSet<TypeDeclaration>();
  this.oldMethodInvocationsWithinExtractedMethods=new LinkedHashMap<MethodDeclaration,Set<MethodInvocation>>();
  this.newMethodInvocationsWithinExtractedMethods=new LinkedHashMap<MethodDeclaration,Set<MethodInvocation>>();
  this.oldToNewExtractedMethodDeclarationMap=new LinkedHashMap<MethodDeclaration,MethodDeclaration>();
  this.extractedFieldFragments=extractedFieldFragments;
  this.extractedMethods=extractedMethods;
  this.delegateMethods=delegateMethods;
  this.extractedTypeName=extractedTypeName;
  this.leaveDelegateForPublicMethods=false;
  this.statementRewriteMap=new LinkedHashMap<Statement,ASTRewrite>();
  this.constructorFinalFieldAssignmentMap=new LinkedHashMap<MethodDeclaration,Map<VariableDeclaration,Assignment>>();
  this.extractedClassConstructorParameterMap=new LinkedHashMap<MethodDeclaration,Set<VariableDeclaration>>();
  this.extractedFieldsWithThisExpressionInTheirInitializer=new LinkedHashSet<VariableDeclaration>();
  for (  MethodDeclaration extractedMethod : extractedMethods) {
    additionalArgumentsAddedToExtractedMethods.put(extractedMethod,new LinkedHashSet<PlainVariable>());
    additionalParametersAddedToExtractedMethods.put(extractedMethod,new LinkedHashSet<SingleVariableDeclaration>());
  }
}","public ExtractClassRefactoring(IFile sourceFile,CompilationUnit sourceCompilationUnit,TypeDeclaration sourceTypeDeclaration,Set<VariableDeclaration> extractedFieldFragments,Set<MethodDeclaration> extractedMethods,Set<MethodDeclaration> delegateMethods,String extractedTypeName){
  this.sourceFile=sourceFile;
  this.sourceCompilationUnit=sourceCompilationUnit;
  this.sourceTypeDeclaration=sourceTypeDeclaration;
  this.compilationUnitChanges=new LinkedHashMap<ICompilationUnit,CompilationUnitChange>();
  ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
  MultiTextEdit sourceMultiTextEdit=new MultiTextEdit();
  CompilationUnitChange sourceCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",sourceICompilationUnit);
  sourceCompilationUnitChange.setEdit(sourceMultiTextEdit);
  this.compilationUnitChanges.put(sourceICompilationUnit,sourceCompilationUnitChange);
  this.createCompilationUnitChanges=new LinkedHashMap<ICompilationUnit,CreateCompilationUnitChange>();
  this.javaElementsToOpenInEditor=new LinkedHashSet<IJavaElement>();
  this.requiredImportDeclarationsInExtractedClass=new LinkedHashSet<ITypeBinding>();
  this.additionalArgumentsAddedToExtractedMethods=new LinkedHashMap<MethodDeclaration,Set<PlainVariable>>();
  this.additionalParametersAddedToExtractedMethods=new LinkedHashMap<MethodDeclaration,Set<SingleVariableDeclaration>>();
  this.sourceMethodBindingsChangedWithPublicModifier=new LinkedHashSet<String>();
  this.sourceFieldBindingsWithCreatedSetterMethod=new LinkedHashSet<String>();
  this.sourceFieldBindingsWithCreatedGetterMethod=new LinkedHashSet<String>();
  this.fieldDeclarationsChangedWithPublicModifier=new LinkedHashSet<FieldDeclaration>();
  this.memberTypeDeclarationsChangedWithPublicModifier=new LinkedHashSet<BodyDeclaration>();
  this.oldMethodInvocationsWithinExtractedMethods=new LinkedHashMap<MethodDeclaration,Set<MethodInvocation>>();
  this.newMethodInvocationsWithinExtractedMethods=new LinkedHashMap<MethodDeclaration,Set<MethodInvocation>>();
  this.oldToNewExtractedMethodDeclarationMap=new LinkedHashMap<MethodDeclaration,MethodDeclaration>();
  this.extractedFieldFragments=extractedFieldFragments;
  this.extractedMethods=extractedMethods;
  this.delegateMethods=delegateMethods;
  this.extractedTypeName=extractedTypeName;
  this.leaveDelegateForPublicMethods=false;
  this.statementRewriteMap=new LinkedHashMap<Statement,ASTRewrite>();
  this.constructorFinalFieldAssignmentMap=new LinkedHashMap<MethodDeclaration,Map<VariableDeclaration,Assignment>>();
  this.extractedClassConstructorParameterMap=new LinkedHashMap<MethodDeclaration,Set<VariableDeclaration>>();
  this.extractedFieldsWithThisExpressionInTheirInitializer=new LinkedHashSet<VariableDeclaration>();
  for (  MethodDeclaration extractedMethod : extractedMethods) {
    additionalArgumentsAddedToExtractedMethods.put(extractedMethod,new LinkedHashSet<PlainVariable>());
    additionalParametersAddedToExtractedMethods.put(extractedMethod,new LinkedHashSet<SingleVariableDeclaration>());
  }
}"
12034,"private void modifySourceStaticFieldInstructionsInTargetClass(MethodDeclaration sourceMethod,MethodDeclaration newMethodDeclaration,ASTRewrite targetRewriter){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceVariableInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newVariableInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceVariableInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding != null && binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
        if (declaredInSourceTypeDeclarationOrSuperclass(variableBinding)) {
          AST ast=newMethodDeclaration.getAST();
          SimpleName qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
          if (simpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
            targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(simpleName.getParent() instanceof QualifiedName)) {
            SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
            QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
            targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
          }
          setPublicModifierToSourceField(variableBinding);
        }
 else {
          AST ast=newMethodDeclaration.getAST();
          SimpleName qualifier=null;
          if ((variableBinding.getModifiers() & Modifier.PUBLIC) != 0) {
            qualifier=ast.newSimpleName(variableBinding.getDeclaringClass().getName());
            Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
            typeBindings.add(variableBinding.getDeclaringClass());
            RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportDeclarationsInExtractedClass);
          }
 else {
            qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
          }
          if (simpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
            targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(simpleName.getParent() instanceof QualifiedName)) {
            SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
            QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
            targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
          }
        }
      }
    }
    i++;
  }
}","private void modifySourceStaticFieldInstructionsInTargetClass(MethodDeclaration sourceMethod,MethodDeclaration newMethodDeclaration,ASTRewrite targetRewriter){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceVariableInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newVariableInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceVariableInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding != null && binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
        if (declaredInSourceTypeDeclarationOrSuperclass(variableBinding)) {
          AST ast=newMethodDeclaration.getAST();
          SimpleName qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
          if (simpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
            targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(simpleName.getParent() instanceof QualifiedName) && !RefactoringUtility.isEnumConstantInSwitchCaseExpression(simpleName)) {
            SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
            QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
            targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
          }
          setPublicModifierToSourceField(variableBinding);
        }
 else {
          AST ast=newMethodDeclaration.getAST();
          SimpleName qualifier=null;
          if ((variableBinding.getModifiers() & Modifier.PUBLIC) != 0) {
            qualifier=ast.newSimpleName(variableBinding.getDeclaringClass().getName());
            Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
            typeBindings.add(variableBinding.getDeclaringClass());
            RefactoringUtility.getSimpleTypeBindings(typeBindings,requiredImportDeclarationsInExtractedClass);
          }
 else {
            qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
          }
          if (simpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
            targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(simpleName.getParent() instanceof QualifiedName) && !RefactoringUtility.isEnumConstantInSwitchCaseExpression(simpleName)) {
            SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
            QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
            targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
          }
          ITypeBinding fieldDeclaringClass=variableBinding.getDeclaringClass();
          if (fieldDeclaringClass != null && fieldDeclaringClass.isEnum() && sourceTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaringClass.getDeclaringClass())) {
            setPublicModifierToSourceMemberType(fieldDeclaringClass);
          }
        }
      }
    }
    i++;
  }
}"
12035,"private void setPublicModifierToSourceMemberType(ITypeBinding typeBinding){
  TypeDeclaration[] memberTypes=sourceTypeDeclaration.getTypes();
  for (  TypeDeclaration memberType : memberTypes) {
    if (typeBinding.isEqualTo(memberType.resolveBinding())) {
      ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
      ListRewrite modifierRewrite=sourceRewriter.getListRewrite(memberType,TypeDeclaration.MODIFIERS2_PROPERTY);
      Modifier publicModifier=memberType.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
      boolean modifierFound=false;
      List<IExtendedModifier> modifiers=memberType.modifiers();
      for (      IExtendedModifier extendedModifier : modifiers) {
        if (extendedModifier.isModifier()) {
          Modifier modifier=(Modifier)extendedModifier;
          if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
            modifierFound=true;
          }
 else           if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD)) {
            if (!memberTypeDeclarationsChangedWithPublicModifier.contains(memberType)) {
              memberTypeDeclarationsChangedWithPublicModifier.add(memberType);
              modifierFound=true;
              modifierRewrite.replace(modifier,publicModifier,null);
              try {
                TextEdit sourceEdit=sourceRewriter.rewriteAST();
                ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
                CompilationUnitChange change=compilationUnitChanges.get(sourceICompilationUnit);
                change.getEdit().addChild(sourceEdit);
                change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
              }
 catch (              JavaModelException e) {
                e.printStackTrace();
              }
            }
          }
 else           if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
            modifierFound=true;
          }
        }
      }
      if (!modifierFound) {
        if (!memberTypeDeclarationsChangedWithPublicModifier.contains(memberType)) {
          memberTypeDeclarationsChangedWithPublicModifier.add(memberType);
          modifierRewrite.insertFirst(publicModifier,null);
          try {
            TextEdit sourceEdit=sourceRewriter.rewriteAST();
            ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
            CompilationUnitChange change=compilationUnitChanges.get(sourceICompilationUnit);
            change.getEdit().addChild(sourceEdit);
            change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
          }
 catch (          JavaModelException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
}","private void setPublicModifierToSourceMemberType(ITypeBinding typeBinding){
  List<BodyDeclaration> bodyDeclarations=sourceTypeDeclaration.bodyDeclarations();
  for (  BodyDeclaration bodyDeclaration : bodyDeclarations) {
    if (bodyDeclaration instanceof TypeDeclaration) {
      TypeDeclaration memberType=(TypeDeclaration)bodyDeclaration;
      ITypeBinding memberTypeBinding=memberType.resolveBinding();
      if (typeBinding.isEqualTo(memberTypeBinding)) {
        updateBodyDeclarationAccessModifier(memberType,TypeDeclaration.MODIFIERS2_PROPERTY);
      }
    }
 else     if (bodyDeclaration instanceof EnumDeclaration) {
      EnumDeclaration memberEnum=(EnumDeclaration)bodyDeclaration;
      ITypeBinding memberTypeBinding=memberEnum.resolveBinding();
      if (typeBinding.isEqualTo(memberTypeBinding)) {
        updateBodyDeclarationAccessModifier(memberEnum,EnumDeclaration.MODIFIERS2_PROPERTY);
      }
    }
  }
}"
12036,"private void modifySourceStaticFieldInstructionsInTargetClass(MethodDeclaration newMethodDeclaration,ASTRewrite targetRewriter){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceVariableInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newVariableInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceVariableInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding != null && binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
        if (sourceTypeDeclaration.resolveBinding().isEqualTo(variableBinding.getDeclaringClass())) {
          AST ast=newMethodDeclaration.getAST();
          SimpleName qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
          if (simpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
            targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(simpleName.getParent() instanceof QualifiedName)) {
            SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
            QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
            targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
          }
          this.additionalTypeBindingsToBeImportedInTargetClass.add(sourceTypeDeclaration.resolveBinding());
          setPublicModifierToSourceField(variableBinding);
        }
 else {
          AST ast=newMethodDeclaration.getAST();
          SimpleName qualifier=null;
          if ((variableBinding.getModifiers() & Modifier.PUBLIC) != 0) {
            qualifier=ast.newSimpleName(variableBinding.getDeclaringClass().getName());
            this.additionalTypeBindingsToBeImportedInTargetClass.add(variableBinding.getDeclaringClass());
          }
 else {
            qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
            this.additionalTypeBindingsToBeImportedInTargetClass.add(sourceTypeDeclaration.resolveBinding());
          }
          if (simpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
            targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(simpleName.getParent() instanceof QualifiedName)) {
            SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
            QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
            targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
          }
        }
      }
    }
    i++;
  }
}","private void modifySourceStaticFieldInstructionsInTargetClass(MethodDeclaration newMethodDeclaration,ASTRewrite targetRewriter){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceVariableInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newVariableInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceVariableInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding != null && binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
        if (sourceTypeDeclaration.resolveBinding().isEqualTo(variableBinding.getDeclaringClass())) {
          AST ast=newMethodDeclaration.getAST();
          SimpleName qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
          if (simpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
            targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(simpleName.getParent() instanceof QualifiedName) && !RefactoringUtility.isEnumConstantInSwitchCaseExpression(simpleName)) {
            SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
            QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
            targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
          }
          this.additionalTypeBindingsToBeImportedInTargetClass.add(sourceTypeDeclaration.resolveBinding());
          setPublicModifierToSourceField(variableBinding);
        }
 else {
          AST ast=newMethodDeclaration.getAST();
          SimpleName qualifier=null;
          if ((variableBinding.getModifiers() & Modifier.PUBLIC) != 0) {
            qualifier=ast.newSimpleName(variableBinding.getDeclaringClass().getName());
            this.additionalTypeBindingsToBeImportedInTargetClass.add(variableBinding.getDeclaringClass());
          }
 else {
            qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
            this.additionalTypeBindingsToBeImportedInTargetClass.add(sourceTypeDeclaration.resolveBinding());
          }
          if (simpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
            targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(simpleName.getParent() instanceof QualifiedName) && !RefactoringUtility.isEnumConstantInSwitchCaseExpression(simpleName)) {
            SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
            QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
            targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
          }
          ITypeBinding fieldDeclaringClass=variableBinding.getDeclaringClass();
          if (fieldDeclaringClass != null && fieldDeclaringClass.isEnum() && sourceTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaringClass.getDeclaringClass())) {
            setPublicModifierToSourceMemberType(fieldDeclaringClass);
          }
        }
      }
    }
    i++;
  }
}"
12037,"public MoveMethodRefactoring(CompilationUnit sourceCompilationUnit,CompilationUnit targetCompilationUnit,TypeDeclaration sourceTypeDeclaration,TypeDeclaration targetTypeDeclaration,MethodDeclaration sourceMethod,Map<MethodInvocation,MethodDeclaration> additionalMethodsToBeMoved,boolean leaveDelegate,String movedMethodName){
  this.sourceCompilationUnit=sourceCompilationUnit;
  this.targetCompilationUnit=targetCompilationUnit;
  this.sourceTypeDeclaration=sourceTypeDeclaration;
  this.targetTypeDeclaration=targetTypeDeclaration;
  this.sourceMethod=sourceMethod;
  this.targetClassVariableName=null;
  this.additionalArgumentsAddedToMovedMethod=new LinkedHashSet<String>();
  this.additionalTypeBindingsToBeImportedInTargetClass=new LinkedHashSet<ITypeBinding>();
  this.additionalMethodsToBeMoved=additionalMethodsToBeMoved;
  this.fieldDeclarationsChangedWithPublicModifier=new LinkedHashSet<FieldDeclaration>();
  this.leaveDelegate=leaveDelegate;
  this.movedMethodName=movedMethodName;
  this.isTargetClassVariableParameter=false;
  this.targetClassVariableParameterIndex=-1;
  this.fChanges=new LinkedHashMap<ICompilationUnit,CompilationUnitChange>();
  ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
  this.sourceMultiTextEdit=new MultiTextEdit();
  this.sourceCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",sourceICompilationUnit);
  sourceCompilationUnitChange.setEdit(sourceMultiTextEdit);
  fChanges.put(sourceICompilationUnit,sourceCompilationUnitChange);
  ICompilationUnit targetICompilationUnit=(ICompilationUnit)targetCompilationUnit.getJavaElement();
  if (sourceICompilationUnit.equals(targetICompilationUnit)) {
    this.targetMultiTextEdit=sourceMultiTextEdit;
    this.targetCompilationUnitChange=sourceCompilationUnitChange;
  }
 else {
    this.targetMultiTextEdit=new MultiTextEdit();
    this.targetCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",targetICompilationUnit);
    targetCompilationUnitChange.setEdit(targetMultiTextEdit);
    fChanges.put(targetICompilationUnit,targetCompilationUnitChange);
  }
}","public MoveMethodRefactoring(CompilationUnit sourceCompilationUnit,CompilationUnit targetCompilationUnit,TypeDeclaration sourceTypeDeclaration,TypeDeclaration targetTypeDeclaration,MethodDeclaration sourceMethod,Map<MethodInvocation,MethodDeclaration> additionalMethodsToBeMoved,boolean leaveDelegate,String movedMethodName){
  this.sourceCompilationUnit=sourceCompilationUnit;
  this.targetCompilationUnit=targetCompilationUnit;
  this.sourceTypeDeclaration=sourceTypeDeclaration;
  this.targetTypeDeclaration=targetTypeDeclaration;
  this.sourceMethod=sourceMethod;
  this.targetClassVariableName=null;
  this.additionalArgumentsAddedToMovedMethod=new LinkedHashSet<String>();
  this.additionalTypeBindingsToBeImportedInTargetClass=new LinkedHashSet<ITypeBinding>();
  this.additionalMethodsToBeMoved=additionalMethodsToBeMoved;
  this.fieldDeclarationsChangedWithPublicModifier=new LinkedHashSet<FieldDeclaration>();
  this.memberTypeDeclarationsChangedWithPublicModifier=new LinkedHashSet<BodyDeclaration>();
  this.leaveDelegate=leaveDelegate;
  this.movedMethodName=movedMethodName;
  this.isTargetClassVariableParameter=false;
  this.targetClassVariableParameterIndex=-1;
  this.fChanges=new LinkedHashMap<ICompilationUnit,CompilationUnitChange>();
  ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
  this.sourceMultiTextEdit=new MultiTextEdit();
  this.sourceCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",sourceICompilationUnit);
  sourceCompilationUnitChange.setEdit(sourceMultiTextEdit);
  fChanges.put(sourceICompilationUnit,sourceCompilationUnitChange);
  ICompilationUnit targetICompilationUnit=(ICompilationUnit)targetCompilationUnit.getJavaElement();
  if (sourceICompilationUnit.equals(targetICompilationUnit)) {
    this.targetMultiTextEdit=sourceMultiTextEdit;
    this.targetCompilationUnitChange=sourceCompilationUnitChange;
  }
 else {
    this.targetMultiTextEdit=new MultiTextEdit();
    this.targetCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",targetICompilationUnit);
    targetCompilationUnitChange.setEdit(targetMultiTextEdit);
    fChanges.put(targetICompilationUnit,targetCompilationUnitChange);
  }
}"
12038,"private MethodInvocationObject recurseDelegations(MethodInvocationObject methodInvocation,SystemObject system){
  MethodInvocationObject delegation;
  if ((delegation=system.containsDelegate(methodInvocation)) != null && system.getClassObject(delegation.getOriginClassName()) != null)   return recurseDelegations(delegation,system);
 else   return methodInvocation;
}","private MethodInvocationObject recurseDelegations(MethodInvocationObject methodInvocation,SystemObject system){
  MethodInvocationObject delegation;
  if ((delegation=system.containsDelegate(methodInvocation)) != null && system.getClassObject(delegation.getOriginClassName()) != null && !delegation.equals(methodInvocation))   return recurseDelegations(delegation,system);
 else   return methodInvocation;
}"
12039,"public int getEndOffset(){
  return this.endOffset;
}","public int getEndOffset(){
  return endOffset;
}"
12040,"public CloneInstanceLocationInfo(String filePath,int startLine,int startColumn,int endLine,int endColumn){
  this(filePath);
  this.startLine=startLine;
  this.startColumn=startColumn;
  this.endLine=endLine;
  this.endColumn=endColumn;
  String fileContents=readFileContents(filePath);
  String[] lines=fileContents.split(LINE_FEED);
  int numberOfCharsForLines=getNumberOfCharsForLines(lines,startLine - 1);
  this.startOffset=numberOfCharsForLines + this.startColumn;
  while (isWhiteSpaceCharacter(fileContents.charAt(startOffset))) {
    this.startOffset++;
  }
  numberOfCharsForLines=getNumberOfCharsForLines(lines,endLine) - 1;
  this.endOffset=numberOfCharsForLines + this.endColumn;
  while (isWhiteSpaceCharacter(fileContents.charAt(this.endOffset))) {
    this.endOffset--;
  }
  this.length=this.endOffset - this.startOffset + 1;
}","public CloneInstanceLocationInfo(String filePath,int startLine,int startColumn,int endLine,int endColumn){
  this.filePath=filePath;
  this.startLine=startLine;
  this.startColumn=startColumn;
  this.endLine=endLine;
  this.endColumn=endColumn;
  String fileContents=readFileContents(filePath);
  String[] lines=fileContents.split(LINE_FEED);
  int numberOfCharsForLines=getNumberOfCharsForLines(lines,startLine - 1);
  this.startOffset=numberOfCharsForLines + this.startColumn;
  while (isWhiteSpaceCharacter(fileContents.charAt(startOffset))) {
    this.startOffset++;
  }
  numberOfCharsForLines=getNumberOfCharsForLines(lines,endLine) - 1;
  this.endOffset=numberOfCharsForLines + this.endColumn;
  while (isWhiteSpaceCharacter(fileContents.charAt(this.endOffset))) {
    this.endOffset--;
  }
  this.length=this.endOffset - this.startOffset + 1;
}"
12041,"@Override public CloneGroupList readInputFile() throws InvalidInputFileException {
  CloneGroupList cloneGroups=new CloneGroupList();
  for (  Integer cloneGroupID : this.allCloneGroupIDs) {
    if (isOperationCanceled())     break;
    String filePath=this.getToolOutputFilePath() + ""String_Node_Str"" + cloneGroupID+ ""String_Node_Str"";
    CloneGroup cloneGroup=new CloneGroup(cloneGroupID);
    String fileContents=readFileContents(filePath);
    Pattern pattern=Pattern.compile(""String_Node_Str"");
    Matcher cloneMatcher=pattern.matcher(fileContents);
    int cloneCount=0;
    while (cloneMatcher.find()) {
      try {
        int cloneLineCount=Integer.parseInt(cloneMatcher.group(2));
        int startLine=Integer.parseInt(cloneMatcher.group(3));
        int endLine=startLine + cloneLineCount - 1;
        String cloneFilePath=cloneMatcher.group(4);
        cloneCount++;
        CloneInstance cloneInstance=getCloneInstance(cloneFilePath,cloneCount,true,startLine,0,endLine,0);
        cloneGroup.addClone(cloneInstance);
      }
 catch (      NullPointerException npex) {
        addExceptionHappenedDuringParsing(npex);
      }
catch (      NumberFormatException nfex) {
        addExceptionHappenedDuringParsing(nfex);
      }
catch (      JavaModelException jme) {
        addExceptionHappenedDuringParsing(jme);
      }
catch (      ICompilationUnitNotFoundException infe) {
        addExceptionHappenedDuringParsing(infe);
      }
    }
    if (cloneGroup.getCloneGroupSize() > 0)     cloneGroups.add(cloneGroup);
 else     throw new InvalidInputFileException();
    progress(cloneGroupID);
  }
  return cloneGroups;
}","@Override public CloneGroupList readInputFile() throws InvalidInputFileException {
  CloneGroupList cloneGroups=new CloneGroupList();
  for (  Integer cloneGroupID : this.allCloneGroupIDs) {
    if (isOperationCanceled())     break;
    String filePath=this.getToolOutputFilePath() + ""String_Node_Str"" + cloneGroupID+ ""String_Node_Str"";
    CloneGroup cloneGroup=new CloneGroup(cloneGroupID);
    String fileContents=readFileContents(filePath);
    Pattern pattern=Pattern.compile(""String_Node_Str"");
    Matcher cloneMatcher=pattern.matcher(fileContents);
    int cloneCount=0;
    while (cloneMatcher.find()) {
      try {
        int cloneLineCount=Integer.parseInt(cloneMatcher.group(2));
        int startLine=Integer.parseInt(cloneMatcher.group(3));
        int endLine=startLine + cloneLineCount - 1;
        String cloneFilePath=cloneMatcher.group(4);
        cloneCount++;
        CloneInstance cloneInstance=getCloneInstance(cloneFilePath,cloneCount,true,startLine,0,endLine,0);
        cloneGroup.addClone(cloneInstance);
      }
 catch (      NullPointerException npex) {
        addExceptionHappenedDuringParsing(npex);
      }
catch (      NumberFormatException nfex) {
        addExceptionHappenedDuringParsing(nfex);
      }
catch (      JavaModelException jme) {
        addExceptionHappenedDuringParsing(jme);
      }
catch (      ICompilationUnitNotFoundException infe) {
        addExceptionHappenedDuringParsing(infe);
      }
    }
    if (cloneGroup.getCloneGroupSize() > 0)     cloneGroups.add(cloneGroup);
    progress(cloneGroupID);
  }
  if (cloneGroups.getCloneGroupsCount() == 0)   throw new InvalidInputFileException();
  return cloneGroups;
}"
12042,"private int getNumberOfCharsForLines(String[] linesBeforeAndIncludingOffset,int line){
  if (line >= linesBeforeAndIncludingOffset.length)   return 0;
  int charsBeforeLine=0;
  for (int i=0; i < line; i++) {
    charsBeforeLine+=linesBeforeAndIncludingOffset[i].length() + LINE_FEED.length();
  }
  return charsBeforeLine;
}","private int getNumberOfCharsForLines(String[] lines,int line){
  if (line >= lines.length)   return 0;
  int charsBeforeLine=0;
  for (int i=0; i < line; i++) {
    charsBeforeLine+=lines[i].length() + LINE_FEED.length();
  }
  return charsBeforeLine;
}"
12043,"public CloneInstanceLocationInfo(String filePath,int startLine,int startColumn,int endLine,int endColumn){
  this(filePath);
  this.startLine=startLine;
  this.startColumn=startColumn;
  this.endLine=endLine;
  this.endColumn=endColumn;
  String[] lines=this.containingFileContents.split(LINE_FEED);
  int numberOfCharsForLines=getNumberOfCharsForLines(lines,startLine - 1);
  this.startOffset=numberOfCharsForLines + this.startColumn;
  numberOfCharsForLines=getNumberOfCharsForLines(lines,endLine - 1);
  int endOffset=numberOfCharsForLines + this.endColumn;
  this.length=endOffset - this.startOffset + 1;
}","public CloneInstanceLocationInfo(String filePath,int startLine,int startColumn,int endLine,int endColumn){
  this(filePath);
  this.startLine=startLine;
  this.startColumn=startColumn;
  this.endLine=endLine;
  this.endColumn=endColumn;
  String[] lines=this.containingFileContents.split(LINE_FEED);
  int numberOfCharsForLines=getNumberOfCharsForLines(lines,startLine - 1);
  this.startOffset=numberOfCharsForLines + this.startColumn;
  numberOfCharsForLines=getNumberOfCharsForLines(lines,endLine) - 1;
  int endOffset=numberOfCharsForLines + this.endColumn;
  this.length=endOffset - this.startOffset + 1;
}"
12044,"private void findPassedParameters(){
  Set<AbstractVariable> passedParametersG1=extractPassedParameters(pdg1,mappedNodesG1);
  Set<AbstractVariable> passedParametersG2=extractPassedParameters(pdg2,mappedNodesG2);
  Set<VariableDeclaration> variableDeclarationsInMethod1=pdg1.getVariableDeclarationsInMethod();
  Set<VariableDeclaration> variableDeclarationsInMethod2=pdg2.getVariableDeclarationsInMethod();
  Set<VariableDeclaration> variableDeclarationsAndFieldAccessedInMethod1=pdg1.getVariableDeclarationsAndAccessedFieldsInMethod();
  Set<VariableDeclaration> variableDeclarationsAndFieldAccessedInMethod2=pdg2.getVariableDeclarationsAndAccessedFieldsInMethod();
  for (  PDGNodeMapping nodeMapping : getMaximumStateWithMinimumDifferences().getSortedNodeMappings()) {
    PDGNode nodeG1=nodeMapping.getNodeG1();
    PDGNode nodeG2=nodeMapping.getNodeG2();
    List<AbstractVariable> nonAnonymousDeclaredVariablesG1=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG1=nodeG1.getDeclaredVariableIterator();
    while (declaredVariableIteratorG1.hasNext()) {
      AbstractVariable declaredVariableG1=declaredVariableIteratorG1.next();
      String key1=declaredVariableG1.getVariableBindingKey();
      for (      VariableDeclaration variableDeclaration : variableDeclarationsInMethod1) {
        IVariableBinding declaredVariableBinding=variableDeclaration.resolveBinding();
        if (declaredVariableBinding.getKey().equals(key1)) {
          if (!declaredVariableBinding.getDeclaringMethod().getDeclaringClass().isAnonymous()) {
            nonAnonymousDeclaredVariablesG1.add(declaredVariableG1);
          }
        }
      }
    }
    List<AbstractVariable> nonAnonymousDeclaredVariablesG2=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG2=nodeG2.getDeclaredVariableIterator();
    while (declaredVariableIteratorG2.hasNext()) {
      AbstractVariable declaredVariableG2=declaredVariableIteratorG2.next();
      String key2=declaredVariableG2.getVariableBindingKey();
      for (      VariableDeclaration variableDeclaration : variableDeclarationsInMethod2) {
        IVariableBinding declaredVariableBinding=variableDeclaration.resolveBinding();
        if (declaredVariableBinding.getKey().equals(key2)) {
          if (!declaredVariableBinding.getDeclaringMethod().getDeclaringClass().isAnonymous()) {
            nonAnonymousDeclaredVariablesG2.add(declaredVariableG2);
          }
        }
      }
    }
    int min=Math.min(nonAnonymousDeclaredVariablesG1.size(),nonAnonymousDeclaredVariablesG2.size());
    for (int i=0; i < min; i++) {
      AbstractVariable declaredVariableG1=nonAnonymousDeclaredVariablesG1.get(i);
      AbstractVariable declaredVariableG2=nonAnonymousDeclaredVariablesG2.get(i);
      ArrayList<AbstractVariable> declaredVariables=new ArrayList<AbstractVariable>();
      declaredVariables.add(declaredVariableG1);
      declaredVariables.add(declaredVariableG2);
      VariableBindingKeyPair keyPair=new VariableBindingKeyPair(declaredVariableG1.getVariableBindingKey(),declaredVariableG2.getVariableBindingKey());
      declaredLocalVariablesInMappedNodes.put(keyPair,declaredVariables);
    }
    Set<AbstractVariable> dataDependences1=nodeG1.incomingDataDependencesFromNodesDeclaringOrDefiningVariables();
    Set<AbstractVariable> dataDependences2=nodeG2.incomingDataDependencesFromNodesDeclaringOrDefiningVariables();
    dataDependences1.retainAll(passedParametersG1);
    dataDependences2.retainAll(passedParametersG2);
    List<AbstractVariable> variables1=new ArrayList<AbstractVariable>(dataDependences1);
    List<AbstractVariable> variables2=new ArrayList<AbstractVariable>(dataDependences2);
    if (dataDependences1.size() == dataDependences2.size()) {
      List<String> variableNames1=new ArrayList<String>();
      List<String> variableNames2=new ArrayList<String>();
      for (int i=0; i < variables1.size(); i++) {
        variableNames1.add(variables1.get(i).getVariableName());
        AbstractVariable variable2=variables2.get(i);
        String renamedVariableName=findRenamedVariableName(variable2);
        if (renamedVariableName != null)         variableNames2.add(renamedVariableName);
 else         variableNames2.add(variable2.getVariableName());
      }
      if (variableNames1.containsAll(variableNames2) && variableNames2.containsAll(variableNames1) && variableNames1.size() > 0 && variableNames2.size() > 0) {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        for (int i=0; i < variables1.size(); i++) {
          AbstractVariable variable1=variables1.get(i);
          IVariableBinding variableBinding1=getVariableBinding(variable1,variableDeclarationsAndFieldAccessedInMethod1);
          sortedVariables1.add(variable1);
          for (int j=0; j < variables2.size(); j++) {
            AbstractVariable variable2=variables2.get(j);
            IVariableBinding variableBinding2=getVariableBinding(variable2,variableDeclarationsAndFieldAccessedInMethod2);
            String renamedVariableName=findRenamedVariableName(variable2);
            if ((variable2.getVariableName().equals(variable1.getVariableName()) || variable1.getVariableName().equals(renamedVariableName)) && (variable2.getVariableType().equals(variable1.getVariableType()) || ASTNodeMatcher.commonSuperType(variableBinding1.getType(),variableBinding2.getType()) != null)) {
              sortedVariables2.add(variable2);
              break;
            }
          }
        }
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
 else {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
    }
 else {
      List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
      List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
      sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
      if (sortedVariables1.size() == sortedVariables2.size()) {
        variables1=sortedVariables1;
        variables2=sortedVariables2;
      }
    }
    for (int i=0; i < variables1.size(); i++) {
      AbstractVariable variable1=variables1.get(i);
      AbstractVariable variable2=variables2.get(i);
      if (passedParametersG1.contains(variable1) && passedParametersG2.contains(variable2)) {
        ArrayList<AbstractVariable> variableDeclarations=new ArrayList<AbstractVariable>();
        variableDeclarations.add(variable1);
        variableDeclarations.add(variable2);
        VariableBindingKeyPair keyPair=new VariableBindingKeyPair(variable1.getVariableBindingKey(),variable2.getVariableBindingKey());
        if (!declaredLocalVariablesInMappedNodes.containsKey(keyPair) && !commonPassedParametersAlreadyContainOneOfTheKeys(keyPair)) {
          commonPassedParameters.put(keyPair,variableDeclarations);
        }
      }
    }
  }
}","private void findPassedParameters(){
  Set<AbstractVariable> passedParametersG1=extractPassedParameters(pdg1,mappedNodesG1);
  Set<AbstractVariable> passedParametersG2=extractPassedParameters(pdg2,mappedNodesG2);
  Set<VariableDeclaration> variableDeclarationsInMethod1=pdg1.getVariableDeclarationsInMethod();
  Set<VariableDeclaration> variableDeclarationsInMethod2=pdg2.getVariableDeclarationsInMethod();
  Set<VariableDeclaration> variableDeclarationsAndFieldAccessedInMethod1=pdg1.getVariableDeclarationsAndAccessedFieldsInMethod();
  Set<VariableDeclaration> variableDeclarationsAndFieldAccessedInMethod2=pdg2.getVariableDeclarationsAndAccessedFieldsInMethod();
  for (  PDGNodeMapping nodeMapping : getMaximumStateWithMinimumDifferences().getSortedNodeMappings()) {
    PDGNode nodeG1=nodeMapping.getNodeG1();
    PDGNode nodeG2=nodeMapping.getNodeG2();
    List<AbstractVariable> nonAnonymousDeclaredVariablesG1=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG1=nodeG1.getDeclaredVariableIterator();
    while (declaredVariableIteratorG1.hasNext()) {
      AbstractVariable declaredVariableG1=declaredVariableIteratorG1.next();
      String key1=declaredVariableG1.getVariableBindingKey();
      for (      VariableDeclaration variableDeclaration : variableDeclarationsInMethod1) {
        IVariableBinding declaredVariableBinding=variableDeclaration.resolveBinding();
        if (declaredVariableBinding.getKey().equals(key1)) {
          if (!declaredVariableBinding.getDeclaringMethod().getDeclaringClass().isAnonymous()) {
            nonAnonymousDeclaredVariablesG1.add(declaredVariableG1);
          }
        }
      }
    }
    List<AbstractVariable> nonAnonymousDeclaredVariablesG2=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG2=nodeG2.getDeclaredVariableIterator();
    while (declaredVariableIteratorG2.hasNext()) {
      AbstractVariable declaredVariableG2=declaredVariableIteratorG2.next();
      String key2=declaredVariableG2.getVariableBindingKey();
      for (      VariableDeclaration variableDeclaration : variableDeclarationsInMethod2) {
        IVariableBinding declaredVariableBinding=variableDeclaration.resolveBinding();
        if (declaredVariableBinding.getKey().equals(key2)) {
          if (!declaredVariableBinding.getDeclaringMethod().getDeclaringClass().isAnonymous()) {
            nonAnonymousDeclaredVariablesG2.add(declaredVariableG2);
          }
        }
      }
    }
    int min=Math.min(nonAnonymousDeclaredVariablesG1.size(),nonAnonymousDeclaredVariablesG2.size());
    for (int i=0; i < min; i++) {
      AbstractVariable declaredVariableG1=nonAnonymousDeclaredVariablesG1.get(i);
      AbstractVariable declaredVariableG2=nonAnonymousDeclaredVariablesG2.get(i);
      ArrayList<AbstractVariable> declaredVariables=new ArrayList<AbstractVariable>();
      declaredVariables.add(declaredVariableG1);
      declaredVariables.add(declaredVariableG2);
      VariableBindingKeyPair keyPair=new VariableBindingKeyPair(declaredVariableG1.getVariableBindingKey(),declaredVariableG2.getVariableBindingKey());
      declaredLocalVariablesInMappedNodes.put(keyPair,declaredVariables);
    }
    Set<AbstractVariable> dataDependences1=nodeG1.incomingDataDependencesFromNodesDeclaringOrDefiningVariables();
    Set<AbstractVariable> dataDependences2=nodeG2.incomingDataDependencesFromNodesDeclaringOrDefiningVariables();
    dataDependences1.retainAll(passedParametersG1);
    dataDependences2.retainAll(passedParametersG2);
    List<AbstractVariable> variables1=new ArrayList<AbstractVariable>(dataDependences1);
    List<AbstractVariable> variables2=new ArrayList<AbstractVariable>(dataDependences2);
    if (dataDependences1.size() == dataDependences2.size()) {
      List<String> variableNames1=new ArrayList<String>();
      List<String> variableNames2=new ArrayList<String>();
      for (int i=0; i < variables1.size(); i++) {
        variableNames1.add(variables1.get(i).getVariableName());
        AbstractVariable variable2=variables2.get(i);
        String renamedVariableName=findRenamedVariableName2(variable2);
        if (renamedVariableName != null)         variableNames2.add(renamedVariableName);
 else         variableNames2.add(variable2.getVariableName());
      }
      if (variableNames1.containsAll(variableNames2) && variableNames2.containsAll(variableNames1) && variableNames1.size() > 0 && variableNames2.size() > 0) {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        for (int i=0; i < variables1.size(); i++) {
          AbstractVariable variable1=variables1.get(i);
          IVariableBinding variableBinding1=getVariableBinding(variable1,variableDeclarationsAndFieldAccessedInMethod1);
          sortedVariables1.add(variable1);
          for (int j=0; j < variables2.size(); j++) {
            AbstractVariable variable2=variables2.get(j);
            IVariableBinding variableBinding2=getVariableBinding(variable2,variableDeclarationsAndFieldAccessedInMethod2);
            String renamedVariableName=findRenamedVariableName2(variable2);
            if ((variable2.getVariableName().equals(variable1.getVariableName()) || variable1.getVariableName().equals(renamedVariableName)) && (variable2.getVariableType().equals(variable1.getVariableType()) || ASTNodeMatcher.commonSuperType(variableBinding1.getType(),variableBinding2.getType()) != null)) {
              sortedVariables2.add(variable2);
              break;
            }
          }
        }
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
 else {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
    }
 else {
      List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
      List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
      sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
      if (sortedVariables1.size() == sortedVariables2.size()) {
        variables1=sortedVariables1;
        variables2=sortedVariables2;
      }
    }
    for (int i=0; i < variables1.size(); i++) {
      AbstractVariable variable1=variables1.get(i);
      AbstractVariable variable2=variables2.get(i);
      if (passedParametersG1.contains(variable1) && passedParametersG2.contains(variable2)) {
        ArrayList<AbstractVariable> variableDeclarations=new ArrayList<AbstractVariable>();
        variableDeclarations.add(variable1);
        variableDeclarations.add(variable2);
        VariableBindingKeyPair keyPair=new VariableBindingKeyPair(variable1.getVariableBindingKey(),variable2.getVariableBindingKey());
        if (!declaredLocalVariablesInMappedNodes.containsKey(keyPair) && !commonPassedParametersAlreadyContainOneOfTheKeys(keyPair)) {
          commonPassedParameters.put(keyPair,variableDeclarations);
        }
      }
    }
  }
}"
12045,"private void sortVariables(List<AbstractVariable> variables1,List<AbstractVariable> variables2,List<AbstractVariable> sortedVariables1,List<AbstractVariable> sortedVariables2){
  boolean requireVariableNameMatch=getRenamedVariables().isEmpty();
  for (int i=0; i < variables1.size(); i++) {
    AbstractVariable variable1=variables1.get(i);
    boolean found=false;
    for (int j=0; j < variables2.size(); j++) {
      AbstractVariable variable2=variables2.get(j);
      if (requireVariableNameMatch) {
        if (variable2.getVariableName().equals(variable1.getVariableName()) && variable2.getVariableType().equals(variable1.getVariableType()) && !sortedVariables2.contains(variable2)) {
          sortedVariables2.add(variable2);
          found=true;
          break;
        }
      }
 else {
        String renamedVariableName=findRenamedVariableName(variable2);
        if (renamedVariableName != null) {
          if (variable2.getVariableType().equals(variable1.getVariableType()) && variable1.getVariableName().equals(renamedVariableName) && !sortedVariables2.contains(variable2)) {
            sortedVariables2.add(variable2);
            found=true;
            break;
          }
        }
 else {
          if (variable2.getVariableType().equals(variable1.getVariableType()) && !sortedVariables2.contains(variable2)) {
            sortedVariables2.add(variable2);
            found=true;
            break;
          }
        }
      }
    }
    if (found) {
      sortedVariables1.add(variable1);
    }
  }
}","private void sortVariables(List<AbstractVariable> variables1,List<AbstractVariable> variables2,List<AbstractVariable> sortedVariables1,List<AbstractVariable> sortedVariables2){
  boolean requireVariableNameMatch=getRenamedVariables().isEmpty();
  for (int i=0; i < variables1.size(); i++) {
    AbstractVariable variable1=variables1.get(i);
    boolean found=false;
    for (int j=0; j < variables2.size(); j++) {
      AbstractVariable variable2=variables2.get(j);
      if (requireVariableNameMatch) {
        if (variable2.getVariableName().equals(variable1.getVariableName()) && variable2.getVariableType().equals(variable1.getVariableType()) && !sortedVariables2.contains(variable2)) {
          sortedVariables2.add(variable2);
          found=true;
          break;
        }
      }
 else {
        String renamedVariableName=findRenamedVariableName2(variable2);
        if (renamedVariableName != null) {
          if (variable2.getVariableType().equals(variable1.getVariableType()) && variable1.getVariableName().equals(renamedVariableName) && !sortedVariables2.contains(variable2)) {
            sortedVariables2.add(variable2);
            found=true;
            break;
          }
        }
 else         if (findRenamedVariableName1(variable1) == null) {
          if (variable2.getVariableType().equals(variable1.getVariableType()) && !sortedVariables2.contains(variable2)) {
            sortedVariables2.add(variable2);
            found=true;
            break;
          }
        }
      }
    }
    if (found) {
      sortedVariables1.add(variable1);
    }
  }
}"
12046,"private void findPassedParameters(){
  Set<AbstractVariable> passedParametersG1=extractPassedParameters(pdg1,mappedNodesG1);
  Set<AbstractVariable> passedParametersG2=extractPassedParameters(pdg2,mappedNodesG2);
  Set<VariableDeclaration> variableDeclarationsInMethod1=pdg1.getVariableDeclarationsInMethod();
  Set<VariableDeclaration> variableDeclarationsInMethod2=pdg2.getVariableDeclarationsInMethod();
  Set<VariableDeclaration> variableDeclarationsAndFieldAccessedInMethod1=pdg1.getVariableDeclarationsAndAccessedFieldsInMethod();
  Set<VariableDeclaration> variableDeclarationsAndFieldAccessedInMethod2=pdg2.getVariableDeclarationsAndAccessedFieldsInMethod();
  for (  PDGNodeMapping nodeMapping : getMaximumStateWithMinimumDifferences().getSortedNodeMappings()) {
    PDGNode nodeG1=nodeMapping.getNodeG1();
    PDGNode nodeG2=nodeMapping.getNodeG2();
    List<AbstractVariable> nonAnonymousDeclaredVariablesG1=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG1=nodeG1.getDeclaredVariableIterator();
    while (declaredVariableIteratorG1.hasNext()) {
      AbstractVariable declaredVariableG1=declaredVariableIteratorG1.next();
      String key1=declaredVariableG1.getVariableBindingKey();
      for (      VariableDeclaration variableDeclaration : variableDeclarationsInMethod1) {
        IVariableBinding declaredVariableBinding=variableDeclaration.resolveBinding();
        if (declaredVariableBinding.getKey().equals(key1)) {
          if (!declaredVariableBinding.getDeclaringMethod().getDeclaringClass().isAnonymous()) {
            nonAnonymousDeclaredVariablesG1.add(declaredVariableG1);
          }
        }
      }
    }
    List<AbstractVariable> nonAnonymousDeclaredVariablesG2=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG2=nodeG2.getDeclaredVariableIterator();
    while (declaredVariableIteratorG2.hasNext()) {
      AbstractVariable declaredVariableG2=declaredVariableIteratorG2.next();
      String key2=declaredVariableG2.getVariableBindingKey();
      for (      VariableDeclaration variableDeclaration : variableDeclarationsInMethod2) {
        IVariableBinding declaredVariableBinding=variableDeclaration.resolveBinding();
        if (declaredVariableBinding.getKey().equals(key2)) {
          if (!declaredVariableBinding.getDeclaringMethod().getDeclaringClass().isAnonymous()) {
            nonAnonymousDeclaredVariablesG2.add(declaredVariableG2);
          }
        }
      }
    }
    int min=Math.min(nonAnonymousDeclaredVariablesG1.size(),nonAnonymousDeclaredVariablesG2.size());
    for (int i=0; i < min; i++) {
      AbstractVariable declaredVariableG1=nonAnonymousDeclaredVariablesG1.get(i);
      AbstractVariable declaredVariableG2=nonAnonymousDeclaredVariablesG2.get(i);
      ArrayList<AbstractVariable> declaredVariables=new ArrayList<AbstractVariable>();
      declaredVariables.add(declaredVariableG1);
      declaredVariables.add(declaredVariableG2);
      VariableBindingKeyPair keyPair=new VariableBindingKeyPair(declaredVariableG1.getVariableBindingKey(),declaredVariableG2.getVariableBindingKey());
      declaredLocalVariablesInMappedNodes.put(keyPair,declaredVariables);
    }
    Set<AbstractVariable> dataDependences1=nodeG1.incomingDataDependencesFromNodesDeclaringOrDefiningVariables();
    Set<AbstractVariable> dataDependences2=nodeG2.incomingDataDependencesFromNodesDeclaringOrDefiningVariables();
    dataDependences1.retainAll(passedParametersG1);
    dataDependences2.retainAll(passedParametersG2);
    List<AbstractVariable> variables1=new ArrayList<AbstractVariable>(dataDependences1);
    List<AbstractVariable> variables2=new ArrayList<AbstractVariable>(dataDependences2);
    if (dataDependences1.size() == dataDependences2.size()) {
      List<String> variableNames1=new ArrayList<String>();
      List<String> variableNames2=new ArrayList<String>();
      for (int i=0; i < variables1.size(); i++) {
        variableNames1.add(variables1.get(i).getVariableName());
        AbstractVariable variable2=variables2.get(i);
        String renamedVariableName=findRenamedVariableName2(variable2);
        if (renamedVariableName != null)         variableNames2.add(renamedVariableName);
 else         variableNames2.add(variable2.getVariableName());
      }
      if (variableNames1.containsAll(variableNames2) && variableNames2.containsAll(variableNames1) && variableNames1.size() > 0 && variableNames2.size() > 0) {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        for (int i=0; i < variables1.size(); i++) {
          AbstractVariable variable1=variables1.get(i);
          IVariableBinding variableBinding1=getVariableBinding(variable1,variableDeclarationsAndFieldAccessedInMethod1);
          sortedVariables1.add(variable1);
          for (int j=0; j < variables2.size(); j++) {
            AbstractVariable variable2=variables2.get(j);
            IVariableBinding variableBinding2=getVariableBinding(variable2,variableDeclarationsAndFieldAccessedInMethod2);
            String renamedVariableName=findRenamedVariableName2(variable2);
            if ((variable2.getVariableName().equals(variable1.getVariableName()) || variable1.getVariableName().equals(renamedVariableName)) && (variable2.getVariableType().equals(variable1.getVariableType()) || ASTNodeMatcher.commonSuperType(variableBinding1.getType(),variableBinding2.getType()) != null)) {
              sortedVariables2.add(variable2);
              break;
            }
          }
        }
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
 else {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
    }
 else {
      List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
      List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
      sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
      if (sortedVariables1.size() == sortedVariables2.size()) {
        variables1=sortedVariables1;
        variables2=sortedVariables2;
      }
    }
    for (int i=0; i < variables1.size(); i++) {
      AbstractVariable variable1=variables1.get(i);
      AbstractVariable variable2=variables2.get(i);
      if (passedParametersG1.contains(variable1) && passedParametersG2.contains(variable2)) {
        ArrayList<AbstractVariable> variableDeclarations=new ArrayList<AbstractVariable>();
        variableDeclarations.add(variable1);
        variableDeclarations.add(variable2);
        VariableBindingKeyPair keyPair=new VariableBindingKeyPair(variable1.getVariableBindingKey(),variable2.getVariableBindingKey());
        if (!declaredLocalVariablesInMappedNodes.containsKey(keyPair) && !commonPassedParametersAlreadyContainOneOfTheKeys(keyPair)) {
          commonPassedParameters.put(keyPair,variableDeclarations);
        }
      }
    }
  }
}","private void findPassedParameters(){
  Set<AbstractVariable> passedParametersG1=extractPassedParameters(pdg1,mappedNodesG1);
  Set<AbstractVariable> passedParametersG2=extractPassedParameters(pdg2,mappedNodesG2);
  Set<VariableDeclaration> variableDeclarationsInMethod1=pdg1.getVariableDeclarationsInMethod();
  Set<VariableDeclaration> variableDeclarationsInMethod2=pdg2.getVariableDeclarationsInMethod();
  Set<VariableDeclaration> variableDeclarationsAndFieldAccessedInMethod1=pdg1.getVariableDeclarationsAndAccessedFieldsInMethod();
  Set<VariableDeclaration> variableDeclarationsAndFieldAccessedInMethod2=pdg2.getVariableDeclarationsAndAccessedFieldsInMethod();
  for (  PDGNodeMapping nodeMapping : getMaximumStateWithMinimumDifferences().getSortedNodeMappings()) {
    PDGNode nodeG1=nodeMapping.getNodeG1();
    PDGNode nodeG2=nodeMapping.getNodeG2();
    List<AbstractVariable> nonAnonymousDeclaredVariablesG1=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG1=nodeG1.getDeclaredVariableIterator();
    while (declaredVariableIteratorG1.hasNext()) {
      AbstractVariable declaredVariableG1=declaredVariableIteratorG1.next();
      String key1=declaredVariableG1.getVariableBindingKey();
      for (      VariableDeclaration variableDeclaration : variableDeclarationsInMethod1) {
        IVariableBinding declaredVariableBinding=variableDeclaration.resolveBinding();
        if (declaredVariableBinding.getKey().equals(key1)) {
          if (!declaredVariableBinding.getDeclaringMethod().getDeclaringClass().isAnonymous()) {
            nonAnonymousDeclaredVariablesG1.add(declaredVariableG1);
          }
        }
      }
    }
    List<AbstractVariable> nonAnonymousDeclaredVariablesG2=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG2=nodeG2.getDeclaredVariableIterator();
    while (declaredVariableIteratorG2.hasNext()) {
      AbstractVariable declaredVariableG2=declaredVariableIteratorG2.next();
      String key2=declaredVariableG2.getVariableBindingKey();
      for (      VariableDeclaration variableDeclaration : variableDeclarationsInMethod2) {
        IVariableBinding declaredVariableBinding=variableDeclaration.resolveBinding();
        if (declaredVariableBinding.getKey().equals(key2)) {
          if (!declaredVariableBinding.getDeclaringMethod().getDeclaringClass().isAnonymous()) {
            nonAnonymousDeclaredVariablesG2.add(declaredVariableG2);
          }
        }
      }
    }
    int min=Math.min(nonAnonymousDeclaredVariablesG1.size(),nonAnonymousDeclaredVariablesG2.size());
    for (int i=0; i < min; i++) {
      AbstractVariable declaredVariableG1=nonAnonymousDeclaredVariablesG1.get(i);
      AbstractVariable declaredVariableG2=nonAnonymousDeclaredVariablesG2.get(i);
      ArrayList<AbstractVariable> declaredVariables=new ArrayList<AbstractVariable>();
      declaredVariables.add(declaredVariableG1);
      declaredVariables.add(declaredVariableG2);
      VariableBindingKeyPair keyPair=new VariableBindingKeyPair(declaredVariableG1.getVariableBindingKey(),declaredVariableG2.getVariableBindingKey());
      declaredLocalVariablesInMappedNodes.put(keyPair,declaredVariables);
    }
    Set<AbstractVariable> dataDependences1=nodeG1.incomingDataDependencesFromNodesDeclaringOrDefiningVariables();
    Set<AbstractVariable> dataDependences2=nodeG2.incomingDataDependencesFromNodesDeclaringOrDefiningVariables();
    dataDependences1.retainAll(passedParametersG1);
    dataDependences2.retainAll(passedParametersG2);
    List<AbstractVariable> variables1=new ArrayList<AbstractVariable>(dataDependences1);
    List<AbstractVariable> variables2=new ArrayList<AbstractVariable>(dataDependences2);
    if (dataDependences1.size() == dataDependences2.size()) {
      List<String> variableNames1=new ArrayList<String>();
      List<String> variableNames2=new ArrayList<String>();
      for (int i=0; i < variables1.size(); i++) {
        variableNames1.add(variables1.get(i).getVariableName());
        AbstractVariable variable2=variables2.get(i);
        String renamedVariableName=findRenamedVariableName2(variable2);
        if (renamedVariableName != null)         variableNames2.add(renamedVariableName);
 else         variableNames2.add(variable2.getVariableName());
      }
      if (variableNames1.containsAll(variableNames2) && variableNames2.containsAll(variableNames1) && variableNames1.size() > 0 && variableNames2.size() > 0) {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        for (int i=0; i < variables1.size(); i++) {
          AbstractVariable variable1=variables1.get(i);
          IVariableBinding variableBinding1=getVariableBinding(variable1,variableDeclarationsAndFieldAccessedInMethod1);
          sortedVariables1.add(variable1);
          for (int j=0; j < variables2.size(); j++) {
            AbstractVariable variable2=variables2.get(j);
            IVariableBinding variableBinding2=getVariableBinding(variable2,variableDeclarationsAndFieldAccessedInMethod2);
            String renamedVariableName=findRenamedVariableName2(variable2);
            if ((variable2.getVariableName().equals(variable1.getVariableName()) || variable1.getVariableName().equals(renamedVariableName)) && (variable2.getVariableType().equals(variable1.getVariableType()) || ASTNodeMatcher.commonSuperType(variableBinding1.getType(),variableBinding2.getType()) != null)) {
              sortedVariables2.add(variable2);
              break;
            }
          }
        }
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
 else {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
    }
 else {
      List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
      List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
      sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
      if (sortedVariables1.size() == sortedVariables2.size()) {
        variables1=sortedVariables1;
        variables2=sortedVariables2;
      }
    }
    for (int i=0; i < variables1.size(); i++) {
      AbstractVariable variable1=variables1.get(i);
      AbstractVariable variable2=variables2.get(i);
      if (passedParametersG1.contains(variable1) && passedParametersG2.contains(variable2)) {
        ArrayList<AbstractVariable> variableDeclarations=new ArrayList<AbstractVariable>();
        variableDeclarations.add(variable1);
        variableDeclarations.add(variable2);
        VariableBindingKeyPair keyPair=new VariableBindingKeyPair(variable1.getVariableBindingKey(),variable2.getVariableBindingKey());
        if (!declaredLocalVariablesInMappedNodes.containsKey(keyPair) && commonPassedParametersAlreadyContainOneOfTheKeys(keyPair) == null) {
          commonPassedParameters.put(keyPair,variableDeclarations);
        }
      }
    }
  }
}"
12047,"private void sortVariables(List<AbstractVariable> variables1,List<AbstractVariable> variables2,List<AbstractVariable> sortedVariables1,List<AbstractVariable> sortedVariables2){
  boolean requireVariableNameMatch=getRenamedVariables().isEmpty();
  for (int i=0; i < variables1.size(); i++) {
    AbstractVariable variable1=variables1.get(i);
    boolean found=false;
    for (int j=0; j < variables2.size(); j++) {
      AbstractVariable variable2=variables2.get(j);
      if (requireVariableNameMatch) {
        if (variable2.getVariableName().equals(variable1.getVariableName()) && variable2.getVariableType().equals(variable1.getVariableType()) && !sortedVariables2.contains(variable2)) {
          sortedVariables2.add(variable2);
          found=true;
          break;
        }
      }
 else {
        String renamedVariableName=findRenamedVariableName2(variable2);
        if (renamedVariableName != null) {
          if (variable2.getVariableType().equals(variable1.getVariableType()) && variable1.getVariableName().equals(renamedVariableName) && !sortedVariables2.contains(variable2)) {
            sortedVariables2.add(variable2);
            found=true;
            break;
          }
        }
 else         if (findRenamedVariableName1(variable1) == null) {
          if (variable2.getVariableType().equals(variable1.getVariableType()) && !sortedVariables2.contains(variable2)) {
            sortedVariables2.add(variable2);
            found=true;
            break;
          }
        }
      }
    }
    if (found) {
      sortedVariables1.add(variable1);
    }
  }
}","private void sortVariables(List<AbstractVariable> variables1,List<AbstractVariable> variables2,List<AbstractVariable> sortedVariables1,List<AbstractVariable> sortedVariables2){
  boolean requireVariableNameMatch=getRenamedVariables().isEmpty();
  for (int i=0; i < variables1.size(); i++) {
    AbstractVariable variable1=variables1.get(i);
    boolean found=false;
    for (int j=0; j < variables2.size(); j++) {
      AbstractVariable variable2=variables2.get(j);
      if (requireVariableNameMatch) {
        if (variable2.getVariableName().equals(variable1.getVariableName()) && variable2.getVariableType().equals(variable1.getVariableType()) && !sortedVariables2.contains(variable2)) {
          sortedVariables2.add(variable2);
          found=true;
          break;
        }
      }
 else {
        String renamedVariableName=findRenamedVariableName2(variable2);
        if (renamedVariableName != null) {
          if (variable2.getVariableType().equals(variable1.getVariableType()) && variable1.getVariableName().equals(renamedVariableName) && !sortedVariables2.contains(variable2)) {
            sortedVariables2.add(variable2);
            found=true;
            break;
          }
        }
 else         if (findRenamedVariableName1(variable1) == null) {
          if (variable2.getVariableType().equals(variable1.getVariableType()) && !sortedVariables2.contains(variable2) && !appearsInMultipleDifferences(variable1)&& !appearsInMultipleDifferences(variable2)) {
            sortedVariables2.add(variable2);
            found=true;
            break;
          }
        }
      }
    }
    if (found) {
      sortedVariables1.add(variable1);
    }
  }
}"
12048,"private boolean commonPassedParametersAlreadyContainOneOfTheKeys(VariableBindingKeyPair keyPair){
  for (  VariableBindingKeyPair key : commonPassedParameters.keySet()) {
    if (key.getKey1().equals(keyPair.getKey1()) || key.getKey2().equals(keyPair.getKey2())) {
      return true;
    }
  }
  return false;
}","private VariableBindingKeyPair commonPassedParametersAlreadyContainOneOfTheKeys(VariableBindingKeyPair keyPair){
  for (  VariableBindingKeyPair key : commonPassedParameters.keySet()) {
    if (key.getKey1().equals(keyPair.getKey1()) || key.getKey2().equals(keyPair.getKey2())) {
      return key;
    }
  }
  return null;
}"
12049,"private void findPassedParameters(){
  Set<AbstractVariable> passedParametersG1=extractPassedParameters(pdg1,mappedNodesG1);
  Set<AbstractVariable> passedParametersG2=extractPassedParameters(pdg2,mappedNodesG2);
  Set<AbstractVariable> parametersToBeRemovedG1=new LinkedHashSet<AbstractVariable>();
  Set<AbstractVariable> parametersToBeRemovedG2=new LinkedHashSet<AbstractVariable>();
  for (  PDGNodeMapping nodeMapping : getMaximumStateWithMinimumDifferences().getNodeMappings()) {
    PDGNode nodeG1=nodeMapping.getNodeG1();
    PDGNode nodeG2=nodeMapping.getNodeG2();
    List<AbstractVariable> nonAnonymousDeclaredVariablesG1=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG1=nodeG1.getDeclaredVariableIterator();
    while (declaredVariableIteratorG1.hasNext()) {
      AbstractVariable declaredVariableG1=declaredVariableIteratorG1.next();
      String key1=declaredVariableG1.getVariableBindingKey();
      String declaringType1=key1.substring(0,key1.indexOf(""String_Node_Str""));
      if (!declaringType1.contains(""String_Node_Str"")) {
        nonAnonymousDeclaredVariablesG1.add(declaredVariableG1);
      }
    }
    List<AbstractVariable> nonAnonymousDeclaredVariablesG2=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG2=nodeG2.getDeclaredVariableIterator();
    while (declaredVariableIteratorG2.hasNext()) {
      AbstractVariable declaredVariableG2=declaredVariableIteratorG2.next();
      String key2=declaredVariableG2.getVariableBindingKey();
      String declaringType2=key2.substring(0,key2.indexOf(""String_Node_Str""));
      if (!declaringType2.contains(""String_Node_Str"")) {
        nonAnonymousDeclaredVariablesG2.add(declaredVariableG2);
      }
    }
    int min=Math.min(nonAnonymousDeclaredVariablesG1.size(),nonAnonymousDeclaredVariablesG2.size());
    for (int i=0; i < min; i++) {
      AbstractVariable declaredVariableG1=nonAnonymousDeclaredVariablesG1.get(i);
      AbstractVariable declaredVariableG2=nonAnonymousDeclaredVariablesG2.get(i);
      ArrayList<AbstractVariable> declaredVariables=new ArrayList<AbstractVariable>();
      declaredVariables.add(declaredVariableG1);
      declaredVariables.add(declaredVariableG2);
      VariableBindingKeyPair keyPair=new VariableBindingKeyPair(declaredVariableG1.getVariableBindingKey(),declaredVariableG2.getVariableBindingKey());
      declaredLocalVariablesInMappedNodes.put(keyPair,declaredVariables);
    }
    Set<AbstractVariable> dataDependences1=nodeG1.incomingDataDependencesFromNodesDeclaringOrDefiningVariables();
    Set<AbstractVariable> dataDependences2=nodeG2.incomingDataDependencesFromNodesDeclaringOrDefiningVariables();
    dataDependences1.retainAll(passedParametersG1);
    dataDependences2.retainAll(passedParametersG2);
    List<AbstractVariable> variables1=new ArrayList<AbstractVariable>(dataDependences1);
    List<AbstractVariable> variables2=new ArrayList<AbstractVariable>(dataDependences2);
    if (dataDependences1.size() == dataDependences2.size()) {
      List<String> variableNames1=new ArrayList<String>();
      List<String> variableNames2=new ArrayList<String>();
      for (int i=0; i < variables1.size(); i++) {
        variableNames1.add(variables1.get(i).getVariableName());
        AbstractVariable variable2=variables2.get(i);
        String renamedVariableName=findRenamedVariableName(variable2);
        if (renamedVariableName != null)         variableNames2.add(renamedVariableName);
 else         variableNames2.add(variable2.getVariableName());
      }
      if (variableNames1.containsAll(variableNames2) && variableNames2.containsAll(variableNames1) && variableNames1.size() > 0 && variableNames2.size() > 0) {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        for (int i=0; i < variables1.size(); i++) {
          AbstractVariable variable1=variables1.get(i);
          sortedVariables1.add(variable1);
          for (int j=0; j < variables2.size(); j++) {
            AbstractVariable variable2=variables2.get(j);
            String renamedVariableName=findRenamedVariableName(variable2);
            if ((variable2.getVariableName().equals(variable1.getVariableName()) || variable1.getVariableName().equals(renamedVariableName)) && variable2.getVariableType().equals(variable1.getVariableType())) {
              sortedVariables2.add(variable2);
              break;
            }
          }
        }
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
 else {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
    }
 else {
      List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
      List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
      sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
      if (sortedVariables1.size() == sortedVariables2.size()) {
        variables1=sortedVariables1;
        variables2=sortedVariables2;
      }
    }
    for (int i=0; i < variables1.size(); i++) {
      AbstractVariable variable1=variables1.get(i);
      AbstractVariable variable2=variables2.get(i);
      if (passedParametersG1.contains(variable1) && passedParametersG2.contains(variable2)) {
        ArrayList<AbstractVariable> variableDeclarations=new ArrayList<AbstractVariable>();
        variableDeclarations.add(variable1);
        variableDeclarations.add(variable2);
        VariableBindingKeyPair keyPair=new VariableBindingKeyPair(variable1.getVariableBindingKey(),variable2.getVariableBindingKey());
        commonPassedParameters.put(keyPair,variableDeclarations);
        parametersToBeRemovedG1.add(variable1);
        parametersToBeRemovedG2.add(variable2);
      }
    }
  }
  passedParametersG1.removeAll(parametersToBeRemovedG1);
  passedParametersG2.removeAll(parametersToBeRemovedG2);
  this.passedParametersG1.addAll(passedParametersG1);
  this.passedParametersG2.addAll(passedParametersG2);
}","private void findPassedParameters(){
  Set<AbstractVariable> passedParametersG1=extractPassedParameters(pdg1,mappedNodesG1);
  Set<AbstractVariable> passedParametersG2=extractPassedParameters(pdg2,mappedNodesG2);
  Set<VariableDeclaration> variableDeclarationsInMethod1=pdg1.getVariableDeclarationsInMethod();
  Set<VariableDeclaration> variableDeclarationsInMethod2=pdg2.getVariableDeclarationsInMethod();
  Set<AbstractVariable> parametersToBeRemovedG1=new LinkedHashSet<AbstractVariable>();
  Set<AbstractVariable> parametersToBeRemovedG2=new LinkedHashSet<AbstractVariable>();
  for (  PDGNodeMapping nodeMapping : getMaximumStateWithMinimumDifferences().getNodeMappings()) {
    PDGNode nodeG1=nodeMapping.getNodeG1();
    PDGNode nodeG2=nodeMapping.getNodeG2();
    List<AbstractVariable> nonAnonymousDeclaredVariablesG1=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG1=nodeG1.getDeclaredVariableIterator();
    while (declaredVariableIteratorG1.hasNext()) {
      AbstractVariable declaredVariableG1=declaredVariableIteratorG1.next();
      String key1=declaredVariableG1.getVariableBindingKey();
      for (      VariableDeclaration variableDeclaration : variableDeclarationsInMethod1) {
        IVariableBinding declaredVariableBinding=variableDeclaration.resolveBinding();
        if (declaredVariableBinding.getKey().equals(key1)) {
          if (!declaredVariableBinding.getDeclaringMethod().getDeclaringClass().isAnonymous()) {
            nonAnonymousDeclaredVariablesG1.add(declaredVariableG1);
          }
        }
      }
    }
    List<AbstractVariable> nonAnonymousDeclaredVariablesG2=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG2=nodeG2.getDeclaredVariableIterator();
    while (declaredVariableIteratorG2.hasNext()) {
      AbstractVariable declaredVariableG2=declaredVariableIteratorG2.next();
      String key2=declaredVariableG2.getVariableBindingKey();
      for (      VariableDeclaration variableDeclaration : variableDeclarationsInMethod2) {
        IVariableBinding declaredVariableBinding=variableDeclaration.resolveBinding();
        if (declaredVariableBinding.getKey().equals(key2)) {
          if (!declaredVariableBinding.getDeclaringMethod().getDeclaringClass().isAnonymous()) {
            nonAnonymousDeclaredVariablesG2.add(declaredVariableG2);
          }
        }
      }
    }
    int min=Math.min(nonAnonymousDeclaredVariablesG1.size(),nonAnonymousDeclaredVariablesG2.size());
    for (int i=0; i < min; i++) {
      AbstractVariable declaredVariableG1=nonAnonymousDeclaredVariablesG1.get(i);
      AbstractVariable declaredVariableG2=nonAnonymousDeclaredVariablesG2.get(i);
      ArrayList<AbstractVariable> declaredVariables=new ArrayList<AbstractVariable>();
      declaredVariables.add(declaredVariableG1);
      declaredVariables.add(declaredVariableG2);
      VariableBindingKeyPair keyPair=new VariableBindingKeyPair(declaredVariableG1.getVariableBindingKey(),declaredVariableG2.getVariableBindingKey());
      declaredLocalVariablesInMappedNodes.put(keyPair,declaredVariables);
    }
    Set<AbstractVariable> dataDependences1=nodeG1.incomingDataDependencesFromNodesDeclaringOrDefiningVariables();
    Set<AbstractVariable> dataDependences2=nodeG2.incomingDataDependencesFromNodesDeclaringOrDefiningVariables();
    dataDependences1.retainAll(passedParametersG1);
    dataDependences2.retainAll(passedParametersG2);
    List<AbstractVariable> variables1=new ArrayList<AbstractVariable>(dataDependences1);
    List<AbstractVariable> variables2=new ArrayList<AbstractVariable>(dataDependences2);
    if (dataDependences1.size() == dataDependences2.size()) {
      List<String> variableNames1=new ArrayList<String>();
      List<String> variableNames2=new ArrayList<String>();
      for (int i=0; i < variables1.size(); i++) {
        variableNames1.add(variables1.get(i).getVariableName());
        AbstractVariable variable2=variables2.get(i);
        String renamedVariableName=findRenamedVariableName(variable2);
        if (renamedVariableName != null)         variableNames2.add(renamedVariableName);
 else         variableNames2.add(variable2.getVariableName());
      }
      if (variableNames1.containsAll(variableNames2) && variableNames2.containsAll(variableNames1) && variableNames1.size() > 0 && variableNames2.size() > 0) {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        for (int i=0; i < variables1.size(); i++) {
          AbstractVariable variable1=variables1.get(i);
          sortedVariables1.add(variable1);
          for (int j=0; j < variables2.size(); j++) {
            AbstractVariable variable2=variables2.get(j);
            String renamedVariableName=findRenamedVariableName(variable2);
            if ((variable2.getVariableName().equals(variable1.getVariableName()) || variable1.getVariableName().equals(renamedVariableName)) && variable2.getVariableType().equals(variable1.getVariableType())) {
              sortedVariables2.add(variable2);
              break;
            }
          }
        }
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
 else {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
    }
 else {
      List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
      List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
      sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
      if (sortedVariables1.size() == sortedVariables2.size()) {
        variables1=sortedVariables1;
        variables2=sortedVariables2;
      }
    }
    for (int i=0; i < variables1.size(); i++) {
      AbstractVariable variable1=variables1.get(i);
      AbstractVariable variable2=variables2.get(i);
      if (passedParametersG1.contains(variable1) && passedParametersG2.contains(variable2)) {
        ArrayList<AbstractVariable> variableDeclarations=new ArrayList<AbstractVariable>();
        variableDeclarations.add(variable1);
        variableDeclarations.add(variable2);
        VariableBindingKeyPair keyPair=new VariableBindingKeyPair(variable1.getVariableBindingKey(),variable2.getVariableBindingKey());
        commonPassedParameters.put(keyPair,variableDeclarations);
        parametersToBeRemovedG1.add(variable1);
        parametersToBeRemovedG2.add(variable2);
      }
    }
  }
  passedParametersG1.removeAll(parametersToBeRemovedG1);
  passedParametersG2.removeAll(parametersToBeRemovedG2);
  this.passedParametersG1.addAll(passedParametersG1);
  this.passedParametersG2.addAll(passedParametersG2);
}"
12050,"public Set<PlainVariable> getVariablesToBeReturnedG1(){
  return preconditionExaminer.getVariablesToBeReturnedG1();
}","public Set<VariableDeclaration> getVariablesToBeReturnedG1(){
  return preconditionExaminer.getVariablesToBeReturnedG1();
}"
12051,"public Set<PlainVariable> getVariablesToBeReturnedG2(){
  return preconditionExaminer.getVariablesToBeReturnedG2();
}","public Set<VariableDeclaration> getVariablesToBeReturnedG2(){
  return preconditionExaminer.getVariablesToBeReturnedG2();
}"
12052,"public PreconditionExaminer(PDG pdg1,PDG pdg2,ICompilationUnit iCompilationUnit1,ICompilationUnit iCompilationUnit2,CloneStructureNode cloneStructureRoot,MappingState finalState,TreeSet<PDGNode> allNodesInSubTreePDG1,TreeSet<PDGNode> allNodesInSubTreePDG2){
  this.pdg1=pdg1;
  this.pdg2=pdg2;
  this.iCompilationUnit1=iCompilationUnit1;
  this.iCompilationUnit2=iCompilationUnit2;
  this.cloneStructureRoot=cloneStructureRoot;
  this.finalState=finalState;
  this.allNodesInSubTreePDG1=allNodesInSubTreePDG1;
  this.allNodesInSubTreePDG2=allNodesInSubTreePDG2;
  this.nonMappedNodesG1=new TreeSet<PDGNode>();
  this.nonMappedNodesG2=new TreeSet<PDGNode>();
  this.commonPassedParameters=new LinkedHashMap<VariableBindingKeyPair,ArrayList<AbstractVariable>>();
  this.declaredLocalVariablesInMappedNodes=new LinkedHashMap<VariableBindingKeyPair,ArrayList<AbstractVariable>>();
  this.passedParametersG1=new LinkedHashSet<AbstractVariable>();
  this.passedParametersG2=new LinkedHashSet<AbstractVariable>();
  this.directlyAccessedLocalFieldsG1=new LinkedHashSet<AbstractVariable>();
  this.directlyAccessedLocalFieldsG2=new LinkedHashSet<AbstractVariable>();
  this.indirectlyAccessedLocalFieldsG1=new LinkedHashSet<AbstractVariable>();
  this.indirectlyAccessedLocalFieldsG2=new LinkedHashSet<AbstractVariable>();
  this.accessedLocalMethodsG1=new LinkedHashSet<MethodObject>();
  this.accessedLocalMethodsG2=new LinkedHashSet<MethodObject>();
  this.declaredVariablesInMappedNodesUsedByNonMappedNodesG1=new LinkedHashSet<AbstractVariable>();
  this.declaredVariablesInMappedNodesUsedByNonMappedNodesG2=new LinkedHashSet<AbstractVariable>();
  this.preconditionViolations=new ArrayList<PreconditionViolation>();
  this.renamedVariables=new LinkedHashSet<BindingSignaturePair>();
  this.renamedFields=new LinkedHashSet<BindingSignaturePair>();
  this.nonMappedPDGNodesG1MovableBefore=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableBeforeAndAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableBefore=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableBeforeAndAfter=new TreeSet<PDGNode>();
  this.mappedNodesG1=new TreeSet<PDGNode>();
  this.mappedNodesG2=new TreeSet<PDGNode>();
  this.additionallyMatchedNodesG1=new TreeSet<PDGNode>();
  this.additionallyMatchedNodesG2=new TreeSet<PDGNode>();
  this.declaredLocalVariablesInAdditionallyMatchedNodesG1=new LinkedHashSet<AbstractVariable>();
  this.declaredLocalVariablesInAdditionallyMatchedNodesG2=new LinkedHashSet<AbstractVariable>();
  if (getMaximumStateWithMinimumDifferences() != null) {
    this.mappedNodesG1=getMaximumStateWithMinimumDifferences().getMappedNodesG1();
    this.mappedNodesG2=getMaximumStateWithMinimumDifferences().getMappedNodesG2();
    findNonMappedNodes(getAllNodesInSubTreePDG1(),mappedNodesG1,nonMappedNodesG1);
    findNonMappedNodes(getAllNodesInSubTreePDG2(),mappedNodesG2,nonMappedNodesG2);
    for (    PDGNode nodeG1 : nonMappedNodesG1) {
      boolean advancedMatch=getCloneStructureRoot().isGapNodeG1InAdditionalMatches(nodeG1);
      List<ASTNodeDifference> differencesForAdvancedMatch=new ArrayList<ASTNodeDifference>();
      if (advancedMatch) {
        additionallyMatchedNodesG1.add(nodeG1);
        for (        ASTNodeDifference difference : getNodeDifferences()) {
          if (isExpressionUnderStatement(difference.getExpression1().getExpression(),nodeG1.getASTStatement())) {
            differencesForAdvancedMatch.add(difference);
          }
        }
        List<AbstractVariable> nonAnonymousDeclaredVariablesG1=new ArrayList<AbstractVariable>();
        Iterator<AbstractVariable> declaredVariableIteratorG1=nodeG1.getDeclaredVariableIterator();
        while (declaredVariableIteratorG1.hasNext()) {
          AbstractVariable declaredVariableG1=declaredVariableIteratorG1.next();
          String key1=declaredVariableG1.getVariableBindingKey();
          String declaringType1=key1.substring(0,key1.indexOf(""String_Node_Str""));
          if (!declaringType1.contains(""String_Node_Str"")) {
            nonAnonymousDeclaredVariablesG1.add(declaredVariableG1);
          }
        }
        declaredLocalVariablesInAdditionallyMatchedNodesG1.addAll(nonAnonymousDeclaredVariablesG1);
      }
      PDGNodeGap nodeGap=new PDGNodeGap(nodeG1,null,advancedMatch,differencesForAdvancedMatch);
      CloneStructureNode node=new CloneStructureNode(nodeGap);
      PDGBlockNode tryNode=pdg1.isDirectlyNestedWithinBlockNode(nodeG1);
      if (tryNode != null) {
        CloneStructureNode cloneStructureTry=getCloneStructureRoot().findNodeG1(tryNode);
        if (cloneStructureTry != null) {
          node.setParent(cloneStructureTry);
        }
      }
 else {
        getCloneStructureRoot().addGapChild(node);
      }
    }
    nonMappedNodesG1.removeAll(additionallyMatchedNodesG1);
    mappedNodesG1.addAll(additionallyMatchedNodesG1);
    for (    PDGNode nodeG2 : nonMappedNodesG2) {
      boolean advancedMatch=getCloneStructureRoot().isGapNodeG2InAdditionalMatches(nodeG2);
      List<ASTNodeDifference> differencesForAdvancedMatch=new ArrayList<ASTNodeDifference>();
      if (advancedMatch) {
        additionallyMatchedNodesG2.add(nodeG2);
        for (        ASTNodeDifference difference : getNodeDifferences()) {
          if (isExpressionUnderStatement(difference.getExpression2().getExpression(),nodeG2.getASTStatement())) {
            differencesForAdvancedMatch.add(difference);
          }
        }
        List<AbstractVariable> nonAnonymousDeclaredVariablesG2=new ArrayList<AbstractVariable>();
        Iterator<AbstractVariable> declaredVariableIteratorG2=nodeG2.getDeclaredVariableIterator();
        while (declaredVariableIteratorG2.hasNext()) {
          AbstractVariable declaredVariableG2=declaredVariableIteratorG2.next();
          String key2=declaredVariableG2.getVariableBindingKey();
          String declaringType2=key2.substring(0,key2.indexOf(""String_Node_Str""));
          if (!declaringType2.contains(""String_Node_Str"")) {
            nonAnonymousDeclaredVariablesG2.add(declaredVariableG2);
          }
        }
        declaredLocalVariablesInAdditionallyMatchedNodesG2.addAll(nonAnonymousDeclaredVariablesG2);
      }
      PDGNodeGap nodeGap=new PDGNodeGap(null,nodeG2,advancedMatch,differencesForAdvancedMatch);
      CloneStructureNode node=new CloneStructureNode(nodeGap);
      PDGBlockNode tryNode=pdg2.isDirectlyNestedWithinBlockNode(nodeG2);
      if (tryNode != null) {
        CloneStructureNode cloneStructureTry=getCloneStructureRoot().findNodeG2(tryNode);
        if (cloneStructureTry != null) {
          node.setParent(cloneStructureTry);
        }
      }
 else {
        getCloneStructureRoot().addGapChild(node);
      }
    }
    nonMappedNodesG2.removeAll(additionallyMatchedNodesG2);
    mappedNodesG2.addAll(additionallyMatchedNodesG2);
    findDeclaredVariablesInMappedNodesUsedByNonMappedNodes(pdg1,mappedNodesG1,nonMappedNodesG1,declaredVariablesInMappedNodesUsedByNonMappedNodesG1);
    findDeclaredVariablesInMappedNodesUsedByNonMappedNodes(pdg2,mappedNodesG2,nonMappedNodesG2,declaredVariablesInMappedNodesUsedByNonMappedNodesG2);
    findRenamedVariables(renamedVariables,renamedFields);
    findPassedParameters();
    List<Expression> expressions1=new ArrayList<Expression>();
    List<Expression> expressions2=new ArrayList<Expression>();
    List<AbstractExpression> fieldAccessReplacedWithGetterExpressions1=new ArrayList<AbstractExpression>();
    List<AbstractExpression> fieldAccessReplacedWithGetterExpressions2=new ArrayList<AbstractExpression>();
    for (    ASTNodeDifference nodeDifference : getNodeDifferences()) {
      if (!nodeDifference.containsDifferenceType(DifferenceType.FIELD_ACCESS_REPLACED_WITH_GETTER)) {
        Expression expression1=nodeDifference.getExpression1().getExpression();
        Expression expr1=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1);
        if (expression1.equals(expr1)) {
          expressions1.add(expression1);
        }
 else {
          expressions1.add(expr1);
        }
        Expression expression2=nodeDifference.getExpression2().getExpression();
        Expression expr2=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2);
        if (expression2.equals(expr2)) {
          expressions2.add(expression2);
        }
 else {
          expressions2.add(expr2);
        }
      }
 else {
        fieldAccessReplacedWithGetterExpressions1.add(nodeDifference.getExpression1());
        fieldAccessReplacedWithGetterExpressions2.add(nodeDifference.getExpression2());
      }
    }
    ITypeBinding commonSuperclass=ASTNodeMatcher.commonSuperType(pdg1.getMethod().getMethodDeclaration().resolveBinding().getDeclaringClass(),pdg2.getMethod().getMethodDeclaration().resolveBinding().getDeclaringClass());
    findLocallyAccessedFields(pdg1,mappedNodesG1,commonSuperclass,directlyAccessedLocalFieldsG1,indirectlyAccessedLocalFieldsG1,accessedLocalMethodsG1,expressions1,fieldAccessReplacedWithGetterExpressions1,this.iCompilationUnit1);
    findLocallyAccessedFields(pdg2,mappedNodesG2,commonSuperclass,directlyAccessedLocalFieldsG2,indirectlyAccessedLocalFieldsG2,accessedLocalMethodsG2,expressions2,fieldAccessReplacedWithGetterExpressions2,this.iCompilationUnit2);
    this.variablesToBeReturnedG1=variablesToBeReturned(pdg1,getRemovableNodesG1());
    this.variablesToBeReturnedG2=variablesToBeReturned(pdg2,getRemovableNodesG2());
    checkCloneStructureNodeForPreconditions(getCloneStructureRoot());
    processNonMappedNodesMovableBeforeAndAfter();
    checkPreconditionsAboutReturnedVariables();
    checkIfAllPossibleExecutionFlowsEndInReturn();
  }
}","public PreconditionExaminer(PDG pdg1,PDG pdg2,ICompilationUnit iCompilationUnit1,ICompilationUnit iCompilationUnit2,CloneStructureNode cloneStructureRoot,MappingState finalState,TreeSet<PDGNode> allNodesInSubTreePDG1,TreeSet<PDGNode> allNodesInSubTreePDG2){
  this.pdg1=pdg1;
  this.pdg2=pdg2;
  this.iCompilationUnit1=iCompilationUnit1;
  this.iCompilationUnit2=iCompilationUnit2;
  this.cloneStructureRoot=cloneStructureRoot;
  this.finalState=finalState;
  this.allNodesInSubTreePDG1=allNodesInSubTreePDG1;
  this.allNodesInSubTreePDG2=allNodesInSubTreePDG2;
  this.nonMappedNodesG1=new TreeSet<PDGNode>();
  this.nonMappedNodesG2=new TreeSet<PDGNode>();
  this.commonPassedParameters=new LinkedHashMap<VariableBindingKeyPair,ArrayList<AbstractVariable>>();
  this.declaredLocalVariablesInMappedNodes=new LinkedHashMap<VariableBindingKeyPair,ArrayList<AbstractVariable>>();
  this.passedParametersG1=new LinkedHashSet<AbstractVariable>();
  this.passedParametersG2=new LinkedHashSet<AbstractVariable>();
  this.directlyAccessedLocalFieldsG1=new LinkedHashSet<AbstractVariable>();
  this.directlyAccessedLocalFieldsG2=new LinkedHashSet<AbstractVariable>();
  this.indirectlyAccessedLocalFieldsG1=new LinkedHashSet<AbstractVariable>();
  this.indirectlyAccessedLocalFieldsG2=new LinkedHashSet<AbstractVariable>();
  this.accessedLocalMethodsG1=new LinkedHashSet<MethodObject>();
  this.accessedLocalMethodsG2=new LinkedHashSet<MethodObject>();
  this.preconditionViolations=new ArrayList<PreconditionViolation>();
  this.renamedVariables=new LinkedHashSet<BindingSignaturePair>();
  this.renamedFields=new LinkedHashSet<BindingSignaturePair>();
  this.nonMappedPDGNodesG1MovableBefore=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableBeforeAndAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableBefore=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableBeforeAndAfter=new TreeSet<PDGNode>();
  this.mappedNodesG1=new TreeSet<PDGNode>();
  this.mappedNodesG2=new TreeSet<PDGNode>();
  this.additionallyMatchedNodesG1=new TreeSet<PDGNode>();
  this.additionallyMatchedNodesG2=new TreeSet<PDGNode>();
  this.declaredLocalVariablesInAdditionallyMatchedNodesG1=new LinkedHashSet<AbstractVariable>();
  this.declaredLocalVariablesInAdditionallyMatchedNodesG2=new LinkedHashSet<AbstractVariable>();
  if (getMaximumStateWithMinimumDifferences() != null) {
    this.mappedNodesG1=getMaximumStateWithMinimumDifferences().getMappedNodesG1();
    this.mappedNodesG2=getMaximumStateWithMinimumDifferences().getMappedNodesG2();
    findNonMappedNodes(getAllNodesInSubTreePDG1(),mappedNodesG1,nonMappedNodesG1);
    findNonMappedNodes(getAllNodesInSubTreePDG2(),mappedNodesG2,nonMappedNodesG2);
    for (    PDGNode nodeG1 : nonMappedNodesG1) {
      boolean advancedMatch=getCloneStructureRoot().isGapNodeG1InAdditionalMatches(nodeG1);
      List<ASTNodeDifference> differencesForAdvancedMatch=new ArrayList<ASTNodeDifference>();
      if (advancedMatch) {
        additionallyMatchedNodesG1.add(nodeG1);
        for (        ASTNodeDifference difference : getNodeDifferences()) {
          if (isExpressionUnderStatement(difference.getExpression1().getExpression(),nodeG1.getASTStatement())) {
            differencesForAdvancedMatch.add(difference);
          }
        }
        List<AbstractVariable> nonAnonymousDeclaredVariablesG1=new ArrayList<AbstractVariable>();
        Iterator<AbstractVariable> declaredVariableIteratorG1=nodeG1.getDeclaredVariableIterator();
        while (declaredVariableIteratorG1.hasNext()) {
          AbstractVariable declaredVariableG1=declaredVariableIteratorG1.next();
          String key1=declaredVariableG1.getVariableBindingKey();
          String declaringType1=key1.substring(0,key1.indexOf(""String_Node_Str""));
          if (!declaringType1.contains(""String_Node_Str"")) {
            nonAnonymousDeclaredVariablesG1.add(declaredVariableG1);
          }
        }
        declaredLocalVariablesInAdditionallyMatchedNodesG1.addAll(nonAnonymousDeclaredVariablesG1);
      }
      PDGNodeGap nodeGap=new PDGNodeGap(nodeG1,null,advancedMatch,differencesForAdvancedMatch);
      CloneStructureNode node=new CloneStructureNode(nodeGap);
      PDGBlockNode tryNode=pdg1.isDirectlyNestedWithinBlockNode(nodeG1);
      if (tryNode != null) {
        CloneStructureNode cloneStructureTry=getCloneStructureRoot().findNodeG1(tryNode);
        if (cloneStructureTry != null) {
          node.setParent(cloneStructureTry);
        }
      }
 else {
        getCloneStructureRoot().addGapChild(node);
      }
    }
    nonMappedNodesG1.removeAll(additionallyMatchedNodesG1);
    mappedNodesG1.addAll(additionallyMatchedNodesG1);
    for (    PDGNode nodeG2 : nonMappedNodesG2) {
      boolean advancedMatch=getCloneStructureRoot().isGapNodeG2InAdditionalMatches(nodeG2);
      List<ASTNodeDifference> differencesForAdvancedMatch=new ArrayList<ASTNodeDifference>();
      if (advancedMatch) {
        additionallyMatchedNodesG2.add(nodeG2);
        for (        ASTNodeDifference difference : getNodeDifferences()) {
          if (isExpressionUnderStatement(difference.getExpression2().getExpression(),nodeG2.getASTStatement())) {
            differencesForAdvancedMatch.add(difference);
          }
        }
        List<AbstractVariable> nonAnonymousDeclaredVariablesG2=new ArrayList<AbstractVariable>();
        Iterator<AbstractVariable> declaredVariableIteratorG2=nodeG2.getDeclaredVariableIterator();
        while (declaredVariableIteratorG2.hasNext()) {
          AbstractVariable declaredVariableG2=declaredVariableIteratorG2.next();
          String key2=declaredVariableG2.getVariableBindingKey();
          String declaringType2=key2.substring(0,key2.indexOf(""String_Node_Str""));
          if (!declaringType2.contains(""String_Node_Str"")) {
            nonAnonymousDeclaredVariablesG2.add(declaredVariableG2);
          }
        }
        declaredLocalVariablesInAdditionallyMatchedNodesG2.addAll(nonAnonymousDeclaredVariablesG2);
      }
      PDGNodeGap nodeGap=new PDGNodeGap(null,nodeG2,advancedMatch,differencesForAdvancedMatch);
      CloneStructureNode node=new CloneStructureNode(nodeGap);
      PDGBlockNode tryNode=pdg2.isDirectlyNestedWithinBlockNode(nodeG2);
      if (tryNode != null) {
        CloneStructureNode cloneStructureTry=getCloneStructureRoot().findNodeG2(tryNode);
        if (cloneStructureTry != null) {
          node.setParent(cloneStructureTry);
        }
      }
 else {
        getCloneStructureRoot().addGapChild(node);
      }
    }
    nonMappedNodesG2.removeAll(additionallyMatchedNodesG2);
    mappedNodesG2.addAll(additionallyMatchedNodesG2);
    findRenamedVariables(renamedVariables,renamedFields);
    findPassedParameters();
    List<Expression> expressions1=new ArrayList<Expression>();
    List<Expression> expressions2=new ArrayList<Expression>();
    List<AbstractExpression> fieldAccessReplacedWithGetterExpressions1=new ArrayList<AbstractExpression>();
    List<AbstractExpression> fieldAccessReplacedWithGetterExpressions2=new ArrayList<AbstractExpression>();
    for (    ASTNodeDifference nodeDifference : getNodeDifferences()) {
      if (!nodeDifference.containsDifferenceType(DifferenceType.FIELD_ACCESS_REPLACED_WITH_GETTER)) {
        Expression expression1=nodeDifference.getExpression1().getExpression();
        Expression expr1=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1);
        if (expression1.equals(expr1)) {
          expressions1.add(expression1);
        }
 else {
          expressions1.add(expr1);
        }
        Expression expression2=nodeDifference.getExpression2().getExpression();
        Expression expr2=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2);
        if (expression2.equals(expr2)) {
          expressions2.add(expression2);
        }
 else {
          expressions2.add(expr2);
        }
      }
 else {
        fieldAccessReplacedWithGetterExpressions1.add(nodeDifference.getExpression1());
        fieldAccessReplacedWithGetterExpressions2.add(nodeDifference.getExpression2());
      }
    }
    ITypeBinding commonSuperclass=ASTNodeMatcher.commonSuperType(pdg1.getMethod().getMethodDeclaration().resolveBinding().getDeclaringClass(),pdg2.getMethod().getMethodDeclaration().resolveBinding().getDeclaringClass());
    findLocallyAccessedFields(pdg1,mappedNodesG1,commonSuperclass,directlyAccessedLocalFieldsG1,indirectlyAccessedLocalFieldsG1,accessedLocalMethodsG1,expressions1,fieldAccessReplacedWithGetterExpressions1,this.iCompilationUnit1);
    findLocallyAccessedFields(pdg2,mappedNodesG2,commonSuperclass,directlyAccessedLocalFieldsG2,indirectlyAccessedLocalFieldsG2,accessedLocalMethodsG2,expressions2,fieldAccessReplacedWithGetterExpressions2,this.iCompilationUnit2);
    this.variablesToBeReturnedG1=variablesToBeReturned(pdg1,getRemovableNodesG1());
    this.variablesToBeReturnedG2=variablesToBeReturned(pdg2,getRemovableNodesG2());
    checkCloneStructureNodeForPreconditions(getCloneStructureRoot());
    processNonMappedNodesMovableBeforeAndAfter();
    checkPreconditionsAboutReturnedVariables();
    checkIfAllPossibleExecutionFlowsEndInReturn();
  }
}"
12053,"public Set<PlainVariable> getVariablesToBeReturnedG1(){
  return variablesToBeReturnedG1;
}","public Set<VariableDeclaration> getVariablesToBeReturnedG1(){
  Set<VariableDeclaration> declaredVariablesG1=new LinkedHashSet<VariableDeclaration>();
  Set<VariableDeclaration> variableDeclarationsInMethod1=pdg1.getVariableDeclarationsInMethod();
  for (  PlainVariable variable1 : this.variablesToBeReturnedG1) {
    for (    VariableDeclaration variableDeclaration : variableDeclarationsInMethod1) {
      if (variableDeclaration.resolveBinding().getKey().equals(variable1.getVariableBindingKey())) {
        declaredVariablesG1.add(variableDeclaration);
        break;
      }
    }
  }
  return declaredVariablesG1;
}"
12054,"public Set<PlainVariable> getVariablesToBeReturnedG2(){
  return variablesToBeReturnedG2;
}","public Set<VariableDeclaration> getVariablesToBeReturnedG2(){
  Set<VariableDeclaration> declaredVariablesG2=new LinkedHashSet<VariableDeclaration>();
  Set<VariableDeclaration> variableDeclarationsInMethod2=pdg2.getVariableDeclarationsInMethod();
  for (  AbstractVariable variable2 : this.variablesToBeReturnedG2) {
    for (    VariableDeclaration variableDeclaration : variableDeclarationsInMethod2) {
      if (variableDeclaration.resolveBinding().getKey().equals(variable2.getVariableBindingKey())) {
        declaredVariablesG2.add(variableDeclaration);
        break;
      }
    }
  }
  return declaredVariablesG2;
}"
12055,"private boolean variableIsPassedAsCommonParameter(VariableDeclaration variableDeclaration1,VariableDeclaration variableDeclaration2){
  for (  VariableBindingKeyPair pair : mapper.getCommonPassedParameters().keySet()) {
    if (pair.getKey1().equals(variableDeclaration1.resolveBinding().getKey()) && pair.getKey2().equals(variableDeclaration2.resolveBinding().getKey())) {
      return true;
    }
  }
  return false;
}","private boolean variableIsPassedAsCommonParameter(VariableDeclaration variableDeclaration){
  for (  VariableBindingKeyPair pair : mapper.getCommonPassedParameters().keySet()) {
    if (pair.getKey1().equals(variableDeclaration.resolveBinding().getKey()) || pair.getKey2().equals(variableDeclaration.resolveBinding().getKey())) {
      return true;
    }
  }
  return false;
}"
12056,"private void modifySourceMethod(CompilationUnit compilationUnit,MethodDeclaration methodDeclaration,TreeSet<PDGNode> removableNodes,TreeSet<PDGNode> remainingNodesMovableBefore,TreeSet<PDGNode> remainingNodesMovableAfter,List<VariableDeclaration> returnedVariables,Set<VariableDeclaration> fieldsToBeParameterized,int index){
  AST ast=methodDeclaration.getAST();
  ASTRewrite methodBodyRewriter=ASTRewrite.create(ast);
  MethodInvocation methodInvocation=ast.newMethodInvocation();
  methodBodyRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  if (cloneInfo.extractUtilityClass) {
    methodBodyRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,ast.newSimpleName(cloneInfo.intermediateClassName),null);
  }
  ListRewrite argumentsRewrite=methodBodyRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  VariableBindingKeyPair parameterName : originalPassedParameters.keySet()) {
    List<VariableDeclaration> variableDeclarations=originalPassedParameters.get(parameterName);
    argumentsRewrite.insertLast(variableDeclarations.get(index).getName(),null);
  }
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    List<Expression> expressions=new ArrayList<Expression>();
    if (difference.getExpression1() != null) {
      Expression expression1=difference.getExpression1().getExpression();
      expression1=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1);
      expressions.add(expression1);
    }
 else {
      expressions.add(null);
    }
    if (difference.getExpression2() != null) {
      Expression expression2=difference.getExpression2().getExpression();
      expression2=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2);
      expressions.add(expression2);
    }
 else {
      expressions.add(null);
    }
    Expression expression=expressions.get(index);
    boolean isReturnedVariable=false;
    if (expression != null)     isReturnedVariable=isReturnedVariable(expression,returnedVariables);
    if (!isReturnedVariable) {
      if (expression != null) {
        if (difference.containsDifferenceType(DifferenceType.IF_ELSE_SYMMETRICAL_MATCH) && index == 1) {
          ParenthesizedExpression parenthesizedExpression=ast.newParenthesizedExpression();
          methodBodyRewriter.set(parenthesizedExpression,ParenthesizedExpression.EXPRESSION_PROPERTY,expression,null);
          PrefixExpression prefixExpression=ast.newPrefixExpression();
          methodBodyRewriter.set(prefixExpression,PrefixExpression.OPERAND_PROPERTY,parenthesizedExpression,null);
          methodBodyRewriter.set(prefixExpression,PrefixExpression.OPERATOR_PROPERTY,PrefixExpression.Operator.NOT,null);
          argumentsRewrite.insertLast(prefixExpression,null);
        }
 else {
          argumentsRewrite.insertLast(expression,null);
        }
      }
 else {
        argumentsRewrite.insertLast(ast.newThisExpression(),null);
      }
    }
  }
  Set<VariableDeclaration> accessedLocalFields=null;
  if (index == 0)   accessedLocalFields=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
 else   accessedLocalFields=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
  for (  VariableDeclaration variableDeclaration : fieldsToBeParameterized) {
    if (accessedLocalFields.contains(variableDeclaration)) {
      argumentsRewrite.insertLast(variableDeclaration.getName(),null);
    }
  }
  cloneInfo.argumentRewriteList.add(index,argumentsRewrite);
  Statement firstStatement=removableNodes.first().getASTStatement();
  Block parentBlock=(Block)firstStatement.getParent();
  ListRewrite blockRewrite=methodBodyRewriter.getListRewrite(parentBlock,Block.STATEMENTS_PROPERTY);
  CloneStructureNode root=mapper.getCloneStructureRoot();
  List<CloneStructureNode> processedCloneStructureGapNodes=new ArrayList<CloneStructureNode>();
  Set<PDGNode> remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.addAll(remainingNodesMovableBefore);
  remainingNodes.addAll(remainingNodesMovableAfter);
  List<Statement> statementsToBeMovedBefore=new ArrayList<Statement>();
  List<Statement> statementsToBeMovedAfter=new ArrayList<Statement>();
  for (  PDGNode remainingNode : remainingNodes) {
    CloneStructureNode remainingCloneStructureNode=null;
    if (index == 0)     remainingCloneStructureNode=root.findNodeG1(remainingNode);
 else     remainingCloneStructureNode=root.findNodeG2(remainingNode);
    if (!processedCloneStructureGapNodes.contains(remainingCloneStructureNode.getParent())) {
      Statement statement=processCloneStructureGapNode(remainingCloneStructureNode,ast,methodBodyRewriter,index);
      if (remainingNodesMovableBefore.contains(remainingNode)) {
        statementsToBeMovedBefore.add(statement);
      }
 else       if (remainingNodesMovableAfter.contains(remainingNode)) {
        statementsToBeMovedAfter.add(statement);
      }
      methodBodyRewriter.remove(remainingNode.getASTStatement(),null);
    }
    processedCloneStructureGapNodes.add(remainingCloneStructureNode);
    for (    CloneStructureNode child : remainingCloneStructureNode.getChildren()) {
      if (child.getMapping() instanceof PDGElseGap)       processedCloneStructureGapNodes.add(child);
    }
  }
  Statement extractedMethodInvocationStatement=null;
  if (returnedVariables.size() == 1) {
    Statement methodInvocationStatement=null;
    VariableDeclaration variableDeclaration=returnedVariables.get(0);
    if (variableDeclaration.resolveBinding().isParameter() || variableDeclaration.resolveBinding().isField() || statementsToBeMovedBefore.contains(variableDeclaration.getParent())) {
      Type variableType=extractType(variableDeclaration);
      Assignment assignment=ast.newAssignment();
      methodBodyRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,variableDeclaration.getName(),null);
      ITypeBinding returnTypeBinding=findReturnTypeBinding();
      if (returnTypeBinding != null && !returnTypeBinding.isEqualTo(variableType.resolveBinding())) {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,variableType,null);
        methodBodyRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,castExpression,null);
      }
 else {
        methodBodyRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,methodInvocation,null);
      }
      ExpressionStatement expressionStatement=ast.newExpressionStatement(assignment);
      methodInvocationStatement=expressionStatement;
      if (statementsToBeMovedBefore.contains(variableDeclaration.getParent()) && variableDeclaration.getInitializer() == null) {
        methodBodyRewriter.set(variableDeclaration,VariableDeclarationFragment.INITIALIZER_PROPERTY,generateDefaultValue(methodBodyRewriter,ast,variableType),null);
      }
    }
 else {
      Type variableType=extractType(variableDeclaration);
      VariableDeclarationFragment newFragment=ast.newVariableDeclarationFragment();
      methodBodyRewriter.set(newFragment,VariableDeclarationFragment.NAME_PROPERTY,variableDeclaration.getName(),null);
      ITypeBinding returnTypeBinding=findReturnTypeBinding();
      if (returnTypeBinding != null && !returnTypeBinding.isEqualTo(variableType.resolveBinding())) {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,variableType,null);
        methodBodyRewriter.set(newFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,castExpression,null);
      }
 else {
        methodBodyRewriter.set(newFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,methodInvocation,null);
      }
      VariableDeclarationStatement newVariableDeclarationStatement=ast.newVariableDeclarationStatement(newFragment);
      methodBodyRewriter.set(newVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,variableType,null);
      methodInvocationStatement=newVariableDeclarationStatement;
    }
    blockRewrite.insertBefore(methodInvocationStatement,firstStatement,null);
    extractedMethodInvocationStatement=methodInvocationStatement;
  }
 else {
    ITypeBinding returnTypeBinding=findReturnTypeBinding();
    Statement methodInvocationStatement=null;
    if (returnTypeBinding != null) {
      ReturnStatement returnStatement=ast.newReturnStatement();
      if (returnTypeBinding.isEqualTo(methodDeclaration.getReturnType2().resolveBinding())) {
        methodBodyRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,methodInvocation,null);
      }
 else {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,methodDeclaration.getReturnType2(),null);
        methodBodyRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,castExpression,null);
      }
      methodInvocationStatement=returnStatement;
    }
 else {
      methodInvocationStatement=ast.newExpressionStatement(methodInvocation);
    }
    blockRewrite.insertBefore(methodInvocationStatement,firstStatement,null);
    extractedMethodInvocationStatement=methodInvocationStatement;
  }
  for (  Statement movedBefore : statementsToBeMovedBefore) {
    blockRewrite.insertBefore(movedBefore,extractedMethodInvocationStatement,null);
  }
  for (int i=statementsToBeMovedAfter.size() - 1; i >= 0; i--) {
    Statement movedAfter=statementsToBeMovedAfter.get(i);
    blockRewrite.insertAfter(movedAfter,extractedMethodInvocationStatement,null);
  }
  for (  PDGNode pdgNode : removableNodes) {
    Statement statement=pdgNode.getASTStatement();
    methodBodyRewriter.remove(statement,null);
  }
  Set<LabeledStatement> labeledStatements=labeledStatementsToBeRemoved.get(index);
  for (  LabeledStatement labeled : labeledStatements) {
    methodBodyRewriter.remove(labeled,null);
  }
  cloneInfo.originalMethodBodyRewriteList.add(index,methodBodyRewriter);
}","private void modifySourceMethod(CompilationUnit compilationUnit,MethodDeclaration methodDeclaration,TreeSet<PDGNode> removableNodes,TreeSet<PDGNode> remainingNodesMovableBefore,TreeSet<PDGNode> remainingNodesMovableAfter,List<VariableDeclaration> returnedVariables,Set<VariableDeclaration> fieldsToBeParameterized,int index){
  AST ast=methodDeclaration.getAST();
  ASTRewrite methodBodyRewriter=ASTRewrite.create(ast);
  MethodInvocation methodInvocation=ast.newMethodInvocation();
  methodBodyRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  if (cloneInfo.extractUtilityClass) {
    methodBodyRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,ast.newSimpleName(cloneInfo.intermediateClassName),null);
  }
  ListRewrite argumentsRewrite=methodBodyRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  VariableBindingKeyPair parameterName : originalPassedParameters.keySet()) {
    List<VariableDeclaration> variableDeclarations=originalPassedParameters.get(parameterName);
    argumentsRewrite.insertLast(variableDeclarations.get(index).getName(),null);
  }
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    List<Expression> expressions=new ArrayList<Expression>();
    if (difference.getExpression1() != null) {
      Expression expression1=difference.getExpression1().getExpression();
      expression1=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1);
      expressions.add(expression1);
    }
 else {
      expressions.add(null);
    }
    if (difference.getExpression2() != null) {
      Expression expression2=difference.getExpression2().getExpression();
      expression2=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2);
      expressions.add(expression2);
    }
 else {
      expressions.add(null);
    }
    Expression expression=expressions.get(index);
    boolean isReturnedVariable=false;
    if (expression != null)     isReturnedVariable=isReturnedVariable(expression,returnedVariables);
    if (!isReturnedVariable) {
      if (expression != null) {
        if (difference.containsDifferenceType(DifferenceType.IF_ELSE_SYMMETRICAL_MATCH) && index == 1) {
          ParenthesizedExpression parenthesizedExpression=ast.newParenthesizedExpression();
          methodBodyRewriter.set(parenthesizedExpression,ParenthesizedExpression.EXPRESSION_PROPERTY,expression,null);
          PrefixExpression prefixExpression=ast.newPrefixExpression();
          methodBodyRewriter.set(prefixExpression,PrefixExpression.OPERAND_PROPERTY,parenthesizedExpression,null);
          methodBodyRewriter.set(prefixExpression,PrefixExpression.OPERATOR_PROPERTY,PrefixExpression.Operator.NOT,null);
          argumentsRewrite.insertLast(prefixExpression,null);
        }
 else {
          argumentsRewrite.insertLast(expression,null);
        }
      }
 else {
        argumentsRewrite.insertLast(ast.newThisExpression(),null);
      }
    }
  }
  Set<VariableDeclaration> accessedLocalFields=null;
  if (index == 0)   accessedLocalFields=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
 else   accessedLocalFields=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
  for (  VariableDeclaration variableDeclaration : fieldsToBeParameterized) {
    if (accessedLocalFields.contains(variableDeclaration)) {
      argumentsRewrite.insertLast(variableDeclaration.getName(),null);
    }
  }
  cloneInfo.argumentRewriteList.add(index,argumentsRewrite);
  Statement firstStatement=removableNodes.first().getASTStatement();
  Block parentBlock=(Block)firstStatement.getParent();
  ListRewrite blockRewrite=methodBodyRewriter.getListRewrite(parentBlock,Block.STATEMENTS_PROPERTY);
  CloneStructureNode root=mapper.getCloneStructureRoot();
  List<CloneStructureNode> processedCloneStructureGapNodes=new ArrayList<CloneStructureNode>();
  Set<PDGNode> remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.addAll(remainingNodesMovableBefore);
  remainingNodes.addAll(remainingNodesMovableAfter);
  List<Statement> statementsToBeMovedBefore=new ArrayList<Statement>();
  List<Statement> statementsToBeMovedAfter=new ArrayList<Statement>();
  for (  PDGNode remainingNode : remainingNodes) {
    CloneStructureNode remainingCloneStructureNode=null;
    if (index == 0)     remainingCloneStructureNode=root.findNodeG1(remainingNode);
 else     remainingCloneStructureNode=root.findNodeG2(remainingNode);
    if (!processedCloneStructureGapNodes.contains(remainingCloneStructureNode.getParent())) {
      Statement statement=processCloneStructureGapNode(remainingCloneStructureNode,ast,methodBodyRewriter,index);
      if (remainingNodesMovableBefore.contains(remainingNode)) {
        statementsToBeMovedBefore.add(statement);
      }
 else       if (remainingNodesMovableAfter.contains(remainingNode)) {
        statementsToBeMovedAfter.add(statement);
      }
      methodBodyRewriter.remove(remainingNode.getASTStatement(),null);
    }
    processedCloneStructureGapNodes.add(remainingCloneStructureNode);
    for (    CloneStructureNode child : remainingCloneStructureNode.getChildren()) {
      if (child.getMapping() instanceof PDGElseGap)       processedCloneStructureGapNodes.add(child);
    }
  }
  Statement extractedMethodInvocationStatement=null;
  if (returnedVariables.size() == 1) {
    Statement methodInvocationStatement=null;
    VariableDeclaration variableDeclaration=returnedVariables.get(0);
    if (variableDeclaration.resolveBinding().isParameter() || variableDeclaration.resolveBinding().isField() || statementsToBeMovedBefore.contains(variableDeclaration.getParent())|| variableIsPassedAsCommonParameter(variableDeclaration)) {
      Type variableType=extractType(variableDeclaration);
      Assignment assignment=ast.newAssignment();
      methodBodyRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,variableDeclaration.getName(),null);
      ITypeBinding returnTypeBinding=findReturnTypeBinding();
      if (returnTypeBinding != null && !returnTypeBinding.isEqualTo(variableType.resolveBinding())) {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,variableType,null);
        methodBodyRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,castExpression,null);
      }
 else {
        methodBodyRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,methodInvocation,null);
      }
      ExpressionStatement expressionStatement=ast.newExpressionStatement(assignment);
      methodInvocationStatement=expressionStatement;
      if (statementsToBeMovedBefore.contains(variableDeclaration.getParent()) && variableDeclaration.getInitializer() == null) {
        methodBodyRewriter.set(variableDeclaration,VariableDeclarationFragment.INITIALIZER_PROPERTY,generateDefaultValue(methodBodyRewriter,ast,variableType),null);
      }
    }
 else {
      Type variableType=extractType(variableDeclaration);
      VariableDeclarationFragment newFragment=ast.newVariableDeclarationFragment();
      methodBodyRewriter.set(newFragment,VariableDeclarationFragment.NAME_PROPERTY,variableDeclaration.getName(),null);
      ITypeBinding returnTypeBinding=findReturnTypeBinding();
      if (returnTypeBinding != null && !returnTypeBinding.isEqualTo(variableType.resolveBinding())) {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,variableType,null);
        methodBodyRewriter.set(newFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,castExpression,null);
      }
 else {
        methodBodyRewriter.set(newFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,methodInvocation,null);
      }
      VariableDeclarationStatement newVariableDeclarationStatement=ast.newVariableDeclarationStatement(newFragment);
      methodBodyRewriter.set(newVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,variableType,null);
      methodInvocationStatement=newVariableDeclarationStatement;
    }
    blockRewrite.insertBefore(methodInvocationStatement,firstStatement,null);
    extractedMethodInvocationStatement=methodInvocationStatement;
  }
 else {
    ITypeBinding returnTypeBinding=findReturnTypeBinding();
    Statement methodInvocationStatement=null;
    if (returnTypeBinding != null) {
      ReturnStatement returnStatement=ast.newReturnStatement();
      if (returnTypeBinding.isEqualTo(methodDeclaration.getReturnType2().resolveBinding())) {
        methodBodyRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,methodInvocation,null);
      }
 else {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,methodDeclaration.getReturnType2(),null);
        methodBodyRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,castExpression,null);
      }
      methodInvocationStatement=returnStatement;
    }
 else {
      methodInvocationStatement=ast.newExpressionStatement(methodInvocation);
    }
    blockRewrite.insertBefore(methodInvocationStatement,firstStatement,null);
    extractedMethodInvocationStatement=methodInvocationStatement;
  }
  for (  Statement movedBefore : statementsToBeMovedBefore) {
    blockRewrite.insertBefore(movedBefore,extractedMethodInvocationStatement,null);
  }
  for (int i=statementsToBeMovedAfter.size() - 1; i >= 0; i--) {
    Statement movedAfter=statementsToBeMovedAfter.get(i);
    blockRewrite.insertAfter(movedAfter,extractedMethodInvocationStatement,null);
  }
  for (  PDGNode pdgNode : removableNodes) {
    Statement statement=pdgNode.getASTStatement();
    methodBodyRewriter.remove(statement,null);
  }
  Set<LabeledStatement> labeledStatements=labeledStatementsToBeRemoved.get(index);
  for (  LabeledStatement labeled : labeledStatements) {
    methodBodyRewriter.remove(labeled,null);
  }
  cloneInfo.originalMethodBodyRewriteList.add(index,methodBodyRewriter);
}"
12057,"private void extractClone(){
  this.cloneInfo=new CloneInformation();
  Set<ITypeBinding> requiredImportTypeBindings=new LinkedHashSet<ITypeBinding>();
  ITypeBinding commonSuperTypeOfSourceTypeDeclarations=null;
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding()) && sourceTypeDeclarations.get(0).resolveBinding().getQualifiedName().equals(sourceTypeDeclarations.get(1).resolveBinding().getQualifiedName())) {
    cloneInfo.sourceCompilationUnit=sourceCompilationUnits.get(0);
    cloneInfo.sourceICompilationUnit=(ICompilationUnit)cloneInfo.sourceCompilationUnit.getJavaElement();
    cloneInfo.sourceTypeDeclaration=sourceTypeDeclarations.get(0);
    cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
    cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
  }
 else {
    ITypeBinding typeBinding1=sourceTypeDeclarations.get(0).resolveBinding();
    ITypeBinding typeBinding2=sourceTypeDeclarations.get(1).resolveBinding();
    commonSuperTypeOfSourceTypeDeclarations=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
    if (commonSuperTypeOfSourceTypeDeclarations != null) {
      if (pullUpToCommonSuperclass(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2)) {
        IJavaElement javaElement=commonSuperTypeOfSourceTypeDeclarations.getJavaElement();
        javaElementsToOpenInEditor.add(javaElement);
        ICompilationUnit iCompilationUnit=(ICompilationUnit)javaElement.getParent();
        ASTParser parser=ASTParser.newParser(AST.JLS4);
        parser.setKind(ASTParser.K_COMPILATION_UNIT);
        parser.setSource(iCompilationUnit);
        parser.setResolveBindings(true);
        CompilationUnit compilationUnit=(CompilationUnit)parser.createAST(null);
        List<AbstractTypeDeclaration> typeDeclarations=compilationUnit.types();
        for (        AbstractTypeDeclaration abstractTypeDeclaration : typeDeclarations) {
          if (abstractTypeDeclaration instanceof TypeDeclaration) {
            TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
            if (typeDeclaration.resolveBinding().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)) {
              cloneInfo.sourceCompilationUnit=compilationUnit;
              cloneInfo.sourceICompilationUnit=iCompilationUnit;
              cloneInfo.sourceTypeDeclaration=typeDeclaration;
              cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
              cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
              cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses=!superclassDirectlyInheritedFromRefactoredSubclasses(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2);
              break;
            }
          }
        }
        MultiTextEdit multiTextEdit=new MultiTextEdit();
        CompilationUnitChange compilationUnitChange=new CompilationUnitChange(""String_Node_Str"",iCompilationUnit);
        compilationUnitChange.setEdit(multiTextEdit);
        compilationUnitChanges.put(iCompilationUnit,compilationUnitChange);
      }
 else {
        if (extractToUtilityClass(commonSuperTypeOfSourceTypeDeclarations)) {
          cloneInfo.extractUtilityClass=true;
        }
        if (cloneInfo.extractUtilityClass) {
          cloneInfo.intermediateClassName=""String_Node_Str"";
        }
 else {
          cloneInfo.intermediateClassName=""String_Node_Str"" + commonSuperTypeOfSourceTypeDeclarations.getName();
        }
        ClassObject commonSuperType=ASTReader.getSystemObject().getClassObject(commonSuperTypeOfSourceTypeDeclarations.getQualifiedName());
        CompilationUnit compilationUnit=null;
        if (commonSuperType != null) {
          compilationUnit=findCompilationUnit(commonSuperType.getAbstractTypeDeclaration());
        }
 else {
          compilationUnit=sourceCompilationUnits.get(0);
        }
        if (compilationUnit.getPackage() != null) {
          cloneInfo.intermediateClassPackageBinding=compilationUnit.getPackage().resolveBinding();
        }
        ICompilationUnit iCompilationUnit=(ICompilationUnit)compilationUnit.getJavaElement();
        IContainer container=(IContainer)iCompilationUnit.getResource().getParent();
        if (container instanceof IProject) {
          IProject contextProject=(IProject)container;
          cloneInfo.file=contextProject.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
 else         if (container instanceof IFolder) {
          IFolder contextFolder=(IFolder)container;
          cloneInfo.file=contextFolder.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
        boolean intermediateAlreadyExists=false;
        ICompilationUnit intermediateICompilationUnit=JavaCore.createCompilationUnitFrom(cloneInfo.file);
        javaElementsToOpenInEditor.add(intermediateICompilationUnit);
        ASTParser intermediateParser=ASTParser.newParser(AST.JLS4);
        intermediateParser.setKind(ASTParser.K_COMPILATION_UNIT);
        if (cloneInfo.file.exists()) {
          intermediateAlreadyExists=true;
          intermediateParser.setSource(intermediateICompilationUnit);
          intermediateParser.setResolveBindings(true);
        }
 else {
          cloneInfo.document=new Document();
          intermediateParser.setSource(cloneInfo.document.get().toCharArray());
        }
        CompilationUnit intermediateCompilationUnit=(CompilationUnit)intermediateParser.createAST(null);
        AST intermediateAST=intermediateCompilationUnit.getAST();
        ASTRewrite intermediateRewriter=ASTRewrite.create(intermediateAST);
        ListRewrite intermediateTypesRewrite=intermediateRewriter.getListRewrite(intermediateCompilationUnit,CompilationUnit.TYPES_PROPERTY);
        TypeDeclaration intermediateTypeDeclaration=null;
        if (intermediateAlreadyExists) {
          List<AbstractTypeDeclaration> abstractTypeDeclarations=intermediateCompilationUnit.types();
          for (          AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
            if (abstractTypeDeclaration instanceof TypeDeclaration) {
              TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
              if (typeDeclaration.getName().getIdentifier().equals(cloneInfo.intermediateClassName)) {
                intermediateTypeDeclaration=typeDeclaration;
                int intermediateModifiers=intermediateTypeDeclaration.getModifiers();
                if ((intermediateModifiers & Modifier.ABSTRACT) == 0 && !cloneInfo.extractUtilityClass) {
                  ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
                  intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
                }
                break;
              }
            }
          }
          MultiTextEdit intermediateMultiTextEdit=new MultiTextEdit();
          CompilationUnitChange intermediateCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",intermediateICompilationUnit);
          intermediateCompilationUnitChange.setEdit(intermediateMultiTextEdit);
          compilationUnitChanges.put(intermediateICompilationUnit,intermediateCompilationUnitChange);
        }
 else {
          if (compilationUnit.getPackage() != null) {
            intermediateRewriter.set(intermediateCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,compilationUnit.getPackage(),null);
          }
          intermediateTypeDeclaration=intermediateAST.newTypeDeclaration();
          SimpleName intermediateName=intermediateAST.newSimpleName(cloneInfo.intermediateClassName);
          intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.NAME_PROPERTY,intermediateName,null);
          ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
          intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
          if (!cloneInfo.extractUtilityClass) {
            intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
            intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,intermediateAST.newSimpleType(intermediateAST.newSimpleName(commonSuperTypeOfSourceTypeDeclarations.getName())),null);
            ListRewrite interfaceRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.SUPER_INTERFACE_TYPES_PROPERTY);
            List<Type> superInterfaceTypes1=sourceTypeDeclarations.get(0).superInterfaceTypes();
            List<Type> superInterfaceTypes2=sourceTypeDeclarations.get(1).superInterfaceTypes();
            for (            Type interfaceType1 : superInterfaceTypes1) {
              for (              Type interfaceType2 : superInterfaceTypes2) {
                if (interfaceType1.resolveBinding().isEqualTo(interfaceType2.resolveBinding())) {
                  interfaceRewrite.insertLast(interfaceType1,null);
                  Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
                  typeBindings.add(interfaceType1.resolveBinding());
                  getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
                  break;
                }
              }
            }
            ListRewrite bodyDeclarationsRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
            for (            MethodDeclaration methodDeclaration1 : sourceTypeDeclarations.get(0).getMethods()) {
              List<SingleVariableDeclaration> parameters1=methodDeclaration1.parameters();
              if (methodDeclaration1.isConstructor()) {
                for (                MethodDeclaration methodDeclaration2 : sourceTypeDeclarations.get(1).getMethods()) {
                  List<SingleVariableDeclaration> parameters2=methodDeclaration2.parameters();
                  if (methodDeclaration2.isConstructor()) {
                    if (matchingParameterTypes(parameters1,parameters2)) {
                      SuperConstructorInvocation superConstructorInvocation1=firstStatementIsSuperConstructorInvocation(methodDeclaration1);
                      SuperConstructorInvocation superConstructorInvocation2=firstStatementIsSuperConstructorInvocation(methodDeclaration2);
                      if (superConstructorInvocation1 != null && superConstructorInvocation2 != null) {
                        if (compareStatements(sourceCompilationUnits.get(0).getTypeRoot(),sourceCompilationUnits.get(1).getTypeRoot(),superConstructorInvocation1,superConstructorInvocation2)) {
                          MethodDeclaration constructor=intermediateAST.newMethodDeclaration();
                          intermediateRewriter.set(constructor,MethodDeclaration.NAME_PROPERTY,intermediateName,null);
                          intermediateRewriter.set(constructor,MethodDeclaration.CONSTRUCTOR_PROPERTY,true,null);
                          ListRewrite constructorModifierRewriter=intermediateRewriter.getListRewrite(constructor,MethodDeclaration.MODIFIERS2_PROPERTY);
                          List<IExtendedModifier> modifiers=methodDeclaration1.modifiers();
                          for (                          IExtendedModifier modifier : modifiers) {
                            if (modifier instanceof Modifier) {
                              constructorModifierRewriter.insertLast((Modifier)modifier,null);
                            }
                          }
                          ListRewrite parameterRewriter=intermediateRewriter.getListRewrite(constructor,MethodDeclaration.PARAMETERS_PROPERTY);
                          for (                          SingleVariableDeclaration parameter : parameters1) {
                            Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
                            typeBindings.add(parameter.getType().resolveBinding());
                            getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
                            parameterRewriter.insertLast(parameter,null);
                          }
                          Block constructorBody=intermediateAST.newBlock();
                          ListRewrite constructorBodyRewriter=intermediateRewriter.getListRewrite(constructorBody,Block.STATEMENTS_PROPERTY);
                          constructorBodyRewriter.insertLast(superConstructorInvocation1,null);
                          intermediateRewriter.set(constructor,MethodDeclaration.BODY_PROPERTY,constructorBody,null);
                          bodyDeclarationsRewrite.insertLast(constructor,null);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          intermediateTypesRewrite.insertLast(intermediateTypeDeclaration,null);
        }
        cloneInfo.sourceCompilationUnit=intermediateCompilationUnit;
        cloneInfo.sourceICompilationUnit=intermediateICompilationUnit;
        cloneInfo.sourceTypeDeclaration=intermediateTypeDeclaration;
        cloneInfo.sourceRewriter=intermediateRewriter;
        cloneInfo.ast=intermediateAST;
      }
    }
  }
  ASTRewrite sourceRewriter=cloneInfo.sourceRewriter;
  AST ast=cloneInfo.ast;
  TypeDeclaration sourceTypeDeclaration=cloneInfo.sourceTypeDeclaration;
  MethodDeclaration sourceMethodDeclaration=sourceMethodDeclarations.get(0);
  ListRewrite bodyDeclarationsRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  if (commonSuperTypeOfSourceTypeDeclarations != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  Set<VariableDeclaration> accessedLocalFieldsG1=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
  Set<VariableDeclaration> accessedLocalFieldsG2=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
  if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding()) || !sourceTypeDeclarations.get(0).resolveBinding().getQualifiedName().equals(sourceTypeDeclarations.get(1).resolveBinding().getQualifiedName())) {
    pullUpLocallyAccessedFields(accessedLocalFieldsG1,accessedLocalFieldsG2,bodyDeclarationsRewrite,requiredImportTypeBindings);
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG1=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG2=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    Set<MethodObject> accessedLocalMethodsG1=mapper.getAccessedLocalMethodsG1();
    Set<MethodObject> accessedLocalMethodsG2=mapper.getAccessedLocalMethodsG2();
    for (    MethodObject localMethodG1 : accessedLocalMethodsG1) {
      for (      MethodObject localMethodG2 : accessedLocalMethodsG2) {
        ITypeBinding returnTypesCommonSuperType=ASTNodeMatcher.commonSuperType(localMethodG1.getMethodDeclaration().getReturnType2().resolveBinding(),localMethodG2.getMethodDeclaration().getReturnType2().resolveBinding());
        if (localMethodG1.getName().equals(localMethodG2.getName()) && (localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) || (returnTypesCommonSuperType != null && !ASTNodeMatcher.isTaggingInterface(returnTypesCommonSuperType))) && localMethodG1.getParameterTypeList().equals(localMethodG2.getParameterTypeList())) {
          MethodDeclaration methodDeclaration1=localMethodG1.getMethodDeclaration();
          MethodDeclaration methodDeclaration2=localMethodG2.getMethodDeclaration();
          Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
          boolean clones=type2Clones(methodDeclaration1,methodDeclaration2);
          Type returnType=methodDeclaration1.getReturnType2();
          TypeDeclaration typeDeclaration1=findTypeDeclaration(methodDeclaration1);
          TypeDeclaration typeDeclaration2=findTypeDeclaration(methodDeclaration2);
          Set<VariableDeclaration> fieldsAccessedInMethod1=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG1,methodDeclaration1);
          Set<VariableDeclaration> fieldsAccessedInMethod2=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG2,methodDeclaration2);
          boolean avoidPullUpDueToSerialization1=avoidPullUpMethodDueToSerialization(sourceTypeDeclarations.get(0),fieldsAccessedInMethod1);
          boolean avoidPullUpDueToSerialization2=avoidPullUpMethodDueToSerialization(sourceTypeDeclarations.get(1),fieldsAccessedInMethod2);
          if (clones && !avoidPullUpDueToSerialization1 && !avoidPullUpDueToSerialization2) {
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              MethodDeclaration copiedMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,methodDeclaration1);
              ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(copiedMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
              List<IExtendedModifier> originalModifiers=copiedMethodDeclaration.modifiers();
              for (              IExtendedModifier extendedModifier : originalModifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.isPrivate()) {
                    modifiersRewrite.replace(modifier,ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                  }
                }
              }
              if (!localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) && returnTypesCommonSuperType != null && !ASTNodeMatcher.isTaggingInterface(returnTypesCommonSuperType)) {
                Type newReturnType=generateTypeFromTypeBinding(returnTypesCommonSuperType,ast,sourceRewriter);
                sourceRewriter.set(copiedMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,newReturnType,null);
                typeBindings.add(returnTypesCommonSuperType);
              }
              if (!localMethodG1.isStatic() && localMethodG2.isStatic()) {
                modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD),null);
              }
              bodyDeclarationsRewrite.insertLast(copiedMethodDeclaration,null);
              TypeVisitor typeVisitor=new TypeVisitor();
              methodDeclaration1.accept(typeVisitor);
              typeBindings.addAll(typeVisitor.getTypeBindings());
              fieldsAccessedInMethod1.removeAll(accessedLocalFieldsG1);
              fieldsAccessedInMethod2.removeAll(accessedLocalFieldsG2);
              pullUpLocallyAccessedFields(fieldsAccessedInMethod1,fieldsAccessedInMethod2,bodyDeclarationsRewrite,requiredImportTypeBindings);
            }
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              methodDeclarationsToBePulledUp.get(0).add(methodDeclaration1);
            }
            if (!typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              methodDeclarationsToBePulledUp.get(1).add(methodDeclaration2);
            }
          }
 else {
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
              sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(methodDeclaration1.getName().getIdentifier()),null);
              if (localMethodG1.getReturnType().equals(localMethodG2.getReturnType())) {
                sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
                typeBindings.add(returnType.resolveBinding());
              }
 else               if (returnTypesCommonSuperType != null && !ASTNodeMatcher.isTaggingInterface(returnTypesCommonSuperType)) {
                Type newReturnType=generateTypeFromTypeBinding(returnTypesCommonSuperType,ast,sourceRewriter);
                sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,newReturnType,null);
                typeBindings.add(returnTypesCommonSuperType);
              }
              ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
              List<IExtendedModifier> originalModifiers=methodDeclaration1.modifiers();
              for (              IExtendedModifier extendedModifier : originalModifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.isProtected()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                    if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) == 0) {
                      updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                    }
                  }
 else                   if (modifier.isPublic()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
                    if ((methodDeclaration2.getModifiers() & Modifier.PUBLIC) == 0) {
                      updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PUBLIC_KEYWORD);
                    }
                  }
 else                   if (modifier.isPrivate()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                    updateAccessModifier(methodDeclaration1,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                    if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) == 0) {
                      updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                    }
                  }
                }
              }
              if (cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses) {
                Block methodBody=ast.newBlock();
                sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodBody,null);
                Expression returnedExpression=generateDefaultValue(sourceRewriter,ast,returnType);
                if (returnedExpression != null) {
                  ReturnStatement returnStatement=ast.newReturnStatement();
                  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedExpression,null);
                  ListRewrite statementsRewrite=sourceRewriter.getListRewrite(methodBody,Block.STATEMENTS_PROPERTY);
                  statementsRewrite.insertLast(returnStatement,null);
                }
              }
 else {
                modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
              }
              ListRewrite parametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
              List<SingleVariableDeclaration> parameters=methodDeclaration1.parameters();
              for (              SingleVariableDeclaration parameter : parameters) {
                parametersRewrite.insertLast(parameter,null);
                typeBindings.add(parameter.getType().resolveBinding());
              }
              ListRewrite thrownExceptionsRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
              List<Name> thrownExceptions=methodDeclaration1.thrownExceptions();
              for (              Name thrownException : thrownExceptions) {
                thrownExceptionsRewrite.insertLast(thrownException,null);
                typeBindings.add(thrownException.resolveTypeBinding());
              }
              bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
            }
          }
          getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
          break;
        }
      }
    }
  }
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  List<VariableDeclaration> returnedVariables1=this.returnedVariables.get(0);
  List<VariableDeclaration> returnedVariables2=this.returnedVariables.get(1);
  ITypeBinding returnTypeBinding=null;
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1) {
    Type returnType1=extractType(returnedVariables1.get(0));
    Type returnType2=extractType(returnedVariables2.get(0));
    if (returnType1.resolveBinding().isEqualTo(returnType2.resolveBinding()))     returnTypeBinding=returnType1.resolveBinding();
 else     returnTypeBinding=ASTNodeMatcher.commonSuperType(returnType1.resolveBinding(),returnType2.resolveBinding());
  }
 else {
    returnTypeBinding=findReturnTypeBinding();
  }
  if (returnTypeBinding != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(returnTypeBinding);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
    Type returnType=generateTypeFromTypeBinding(returnTypeBinding,ast,sourceRewriter);
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
  }
 else {
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
  }
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else   if (cloneInfo.extractUtilityClass) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
  if (((sourceMethodDeclarations.get(0).getModifiers() & Modifier.STATIC) != 0 && (sourceMethodDeclarations.get(1).getModifiers() & Modifier.STATIC) != 0) || cloneInfo.extractUtilityClass) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> commonPassedParameters=mapper.getCommonPassedParameters();
  for (  VariableBindingKeyPair parameterName : commonPassedParameters.keySet()) {
    ArrayList<VariableDeclaration> variableDeclarations=commonPassedParameters.get(parameterName);
    VariableDeclaration variableDeclaration1=variableDeclarations.get(0);
    VariableDeclaration variableDeclaration2=variableDeclarations.get(1);
    if (parameterIsUsedByNodesWithoutDifferences(variableDeclaration1,variableDeclaration2)) {
      if (!variableDeclaration1.resolveBinding().isField() && !variableDeclaration2.resolveBinding().isField()) {
        ITypeBinding typeBinding1=extractType(variableDeclaration1).resolveBinding();
        ITypeBinding typeBinding2=extractType(variableDeclaration2).resolveBinding();
        ITypeBinding typeBinding=null;
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
        Type variableType=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(typeBinding);
        getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration1.getName(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
        parameterRewrite.insertLast(parameter,null);
        originalPassedParameters.put(parameterName,variableDeclarations);
      }
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  Set<ITypeBinding> thrownExceptionTypeBindings=new LinkedHashSet<ITypeBinding>();
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode1=pdgNodeMapping.getNodeG1();
    AbstractStatement statement1=pdgNode1.getStatement();
    PDGBlockNode blockNode1=mapper.getPDG1().isNestedWithinBlockNode(pdgNode1);
    if (blockNode1 != null && blockNode1 instanceof PDGTryNode && mapper.getRemovableNodesG1().contains(blockNode1)) {
    }
 else {
      ThrownExceptionVisitor thrownExceptionVisitor=new ThrownExceptionVisitor();
      statement1.getStatement().accept(thrownExceptionVisitor);
      thrownExceptionTypeBindings.addAll(thrownExceptionVisitor.getTypeBindings());
    }
    getSimpleTypeBindings(extractTypeBindings(statement1),requiredImportTypeBindings);
    PDGNode pdgNode2=pdgNodeMapping.getNodeG2();
    AbstractStatement statement2=pdgNode2.getStatement();
    PDGBlockNode blockNode2=mapper.getPDG2().isNestedWithinBlockNode(pdgNode2);
    if (blockNode2 != null && blockNode2 instanceof PDGTryNode && mapper.getRemovableNodesG2().contains(blockNode2)) {
    }
 else {
      ThrownExceptionVisitor thrownExceptionVisitor=new ThrownExceptionVisitor();
      statement2.getStatement().accept(thrownExceptionVisitor);
      thrownExceptionTypeBindings.addAll(thrownExceptionVisitor.getTypeBindings());
    }
    getSimpleTypeBindings(extractTypeBindings(statement2),requiredImportTypeBindings);
  }
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  List<Name> thrownExceptions1=sourceMethodDeclarations.get(0).thrownExceptions();
  List<Name> thrownExceptions2=sourceMethodDeclarations.get(1).thrownExceptions();
  for (  Name thrownException1 : thrownExceptions1) {
    for (    Name thrownException2 : thrownExceptions2) {
      if (thrownException1.resolveTypeBinding().isEqualTo(thrownException2.resolveTypeBinding()) && thrownExceptionTypeBindings.contains(thrownException1.resolveTypeBinding())) {
        thrownExceptionRewrite.insertLast(thrownException1,null);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(thrownException1.resolveTypeBinding());
        getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        thrownExceptionTypeBindings.remove(thrownException1.resolveTypeBinding());
        break;
      }
    }
  }
  for (  ITypeBinding thrownExceptionTypeBinding : thrownExceptionTypeBindings) {
    thrownExceptionRewrite.insertLast(ast.newSimpleName(thrownExceptionTypeBinding.getName()),null);
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(thrownExceptionTypeBinding);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  CloneStructureNode root=mapper.getCloneStructureRoot();
  for (  CloneStructureNode child : root.getChildren()) {
    if (processableNode(child)) {
      Statement statement=processCloneStructureNode(child,ast,sourceRewriter);
      methodBodyRewrite.insertLast(statement,null);
    }
  }
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1 && !mappedNodesContainStatementReturningVariable(returnedVariables1.get(0),returnedVariables2.get(0))) {
    ReturnStatement returnStatement=ast.newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariables1.get(0).getName(),null);
    methodBodyRewrite.insertLast(returnStatement,null);
    if (!mappedNodesContainStatementDeclaringVariable(returnedVariables1.get(0),returnedVariables2.get(0)) && !variableIsPassedAsCommonParameter(returnedVariables1.get(0),returnedVariables2.get(0))) {
      Type returnedType=extractType(returnedVariables1.get(0));
      Expression initializer=generateDefaultValue(sourceRewriter,ast,returnedType);
      VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(fragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariables1.get(0).getName(),null);
      sourceRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,initializer,null);
      VariableDeclarationStatement declarationStatement=ast.newVariableDeclarationStatement(fragment);
      sourceRewriter.set(declarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedType,null);
      methodBodyRewrite.insertFirst(declarationStatement,null);
    }
  }
  int existingArgValue=findExistingParametersWithArgName();
  int i=0;
  if (existingArgValue > 0) {
    i=existingArgValue + 1;
  }
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    AbstractExpression expression1=difference.getExpression1();
    AbstractExpression expression2=difference.getExpression2();
    boolean isReturnedVariable=false;
    if (expression1 != null) {
      isReturnedVariable=isReturnedVariable(expression1.getExpression(),this.returnedVariables.get(0));
    }
 else     if (expression2 != null) {
      isReturnedVariable=isReturnedVariable(expression2.getExpression(),this.returnedVariables.get(1));
    }
    ITypeBinding typeBinding1=expression1 != null ? expression1.getExpression().resolveTypeBinding() : expression2.getExpression().resolveTypeBinding();
    ITypeBinding typeBinding2=expression2 != null ? expression2.getExpression().resolveTypeBinding() : expression1.getExpression().resolveTypeBinding();
    if (!isReturnedVariable) {
      ITypeBinding typeBinding=null;
      if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH) || differenceContainsSubDifferenceWithSubclassTypeMismatch(difference)) {
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
      }
 else {
        if (expression1 != null && !typeBinding1.getQualifiedName().equals(""String_Node_Str"")) {
          typeBinding=typeBinding1;
        }
 else {
          typeBinding=typeBinding2;
        }
      }
      Type type=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
      Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
      typeBindings.add(typeBinding);
      getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(""String_Node_Str"" + i),null);
      i++;
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  for (  VariableDeclaration variableDeclaration : fieldDeclarationsToBeParameterized.get(0)) {
    if (accessedLocalFieldsG1.contains(variableDeclaration)) {
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      Type type=generateTypeFromTypeBinding(variableDeclaration.resolveBinding().getType(),ast,sourceRewriter);
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration.getName(),null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
  cloneInfo.requiredImportTypeBindings=requiredImportTypeBindings;
  cloneInfo.methodBodyRewrite=methodBodyRewrite;
  cloneInfo.parameterRewrite=parameterRewrite;
}","private void extractClone(){
  this.cloneInfo=new CloneInformation();
  Set<ITypeBinding> requiredImportTypeBindings=new LinkedHashSet<ITypeBinding>();
  ITypeBinding commonSuperTypeOfSourceTypeDeclarations=null;
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding()) && sourceTypeDeclarations.get(0).resolveBinding().getQualifiedName().equals(sourceTypeDeclarations.get(1).resolveBinding().getQualifiedName())) {
    cloneInfo.sourceCompilationUnit=sourceCompilationUnits.get(0);
    cloneInfo.sourceICompilationUnit=(ICompilationUnit)cloneInfo.sourceCompilationUnit.getJavaElement();
    cloneInfo.sourceTypeDeclaration=sourceTypeDeclarations.get(0);
    cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
    cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
  }
 else {
    ITypeBinding typeBinding1=sourceTypeDeclarations.get(0).resolveBinding();
    ITypeBinding typeBinding2=sourceTypeDeclarations.get(1).resolveBinding();
    commonSuperTypeOfSourceTypeDeclarations=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
    if (commonSuperTypeOfSourceTypeDeclarations != null) {
      if (pullUpToCommonSuperclass(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2)) {
        IJavaElement javaElement=commonSuperTypeOfSourceTypeDeclarations.getJavaElement();
        javaElementsToOpenInEditor.add(javaElement);
        ICompilationUnit iCompilationUnit=(ICompilationUnit)javaElement.getParent();
        ASTParser parser=ASTParser.newParser(AST.JLS4);
        parser.setKind(ASTParser.K_COMPILATION_UNIT);
        parser.setSource(iCompilationUnit);
        parser.setResolveBindings(true);
        CompilationUnit compilationUnit=(CompilationUnit)parser.createAST(null);
        List<AbstractTypeDeclaration> typeDeclarations=compilationUnit.types();
        for (        AbstractTypeDeclaration abstractTypeDeclaration : typeDeclarations) {
          if (abstractTypeDeclaration instanceof TypeDeclaration) {
            TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
            if (typeDeclaration.resolveBinding().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)) {
              cloneInfo.sourceCompilationUnit=compilationUnit;
              cloneInfo.sourceICompilationUnit=iCompilationUnit;
              cloneInfo.sourceTypeDeclaration=typeDeclaration;
              cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
              cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
              cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses=!superclassDirectlyInheritedFromRefactoredSubclasses(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2);
              break;
            }
          }
        }
        MultiTextEdit multiTextEdit=new MultiTextEdit();
        CompilationUnitChange compilationUnitChange=new CompilationUnitChange(""String_Node_Str"",iCompilationUnit);
        compilationUnitChange.setEdit(multiTextEdit);
        compilationUnitChanges.put(iCompilationUnit,compilationUnitChange);
      }
 else {
        if (extractToUtilityClass(commonSuperTypeOfSourceTypeDeclarations)) {
          cloneInfo.extractUtilityClass=true;
        }
        if (cloneInfo.extractUtilityClass) {
          cloneInfo.intermediateClassName=""String_Node_Str"";
        }
 else {
          cloneInfo.intermediateClassName=""String_Node_Str"" + commonSuperTypeOfSourceTypeDeclarations.getName();
        }
        ClassObject commonSuperType=ASTReader.getSystemObject().getClassObject(commonSuperTypeOfSourceTypeDeclarations.getQualifiedName());
        CompilationUnit compilationUnit=null;
        if (commonSuperType != null) {
          compilationUnit=findCompilationUnit(commonSuperType.getAbstractTypeDeclaration());
        }
 else {
          compilationUnit=sourceCompilationUnits.get(0);
        }
        if (compilationUnit.getPackage() != null) {
          cloneInfo.intermediateClassPackageBinding=compilationUnit.getPackage().resolveBinding();
        }
        ICompilationUnit iCompilationUnit=(ICompilationUnit)compilationUnit.getJavaElement();
        IContainer container=(IContainer)iCompilationUnit.getResource().getParent();
        if (container instanceof IProject) {
          IProject contextProject=(IProject)container;
          cloneInfo.file=contextProject.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
 else         if (container instanceof IFolder) {
          IFolder contextFolder=(IFolder)container;
          cloneInfo.file=contextFolder.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
        boolean intermediateAlreadyExists=false;
        ICompilationUnit intermediateICompilationUnit=JavaCore.createCompilationUnitFrom(cloneInfo.file);
        javaElementsToOpenInEditor.add(intermediateICompilationUnit);
        ASTParser intermediateParser=ASTParser.newParser(AST.JLS4);
        intermediateParser.setKind(ASTParser.K_COMPILATION_UNIT);
        if (cloneInfo.file.exists()) {
          intermediateAlreadyExists=true;
          intermediateParser.setSource(intermediateICompilationUnit);
          intermediateParser.setResolveBindings(true);
        }
 else {
          cloneInfo.document=new Document();
          intermediateParser.setSource(cloneInfo.document.get().toCharArray());
        }
        CompilationUnit intermediateCompilationUnit=(CompilationUnit)intermediateParser.createAST(null);
        AST intermediateAST=intermediateCompilationUnit.getAST();
        ASTRewrite intermediateRewriter=ASTRewrite.create(intermediateAST);
        ListRewrite intermediateTypesRewrite=intermediateRewriter.getListRewrite(intermediateCompilationUnit,CompilationUnit.TYPES_PROPERTY);
        TypeDeclaration intermediateTypeDeclaration=null;
        if (intermediateAlreadyExists) {
          List<AbstractTypeDeclaration> abstractTypeDeclarations=intermediateCompilationUnit.types();
          for (          AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
            if (abstractTypeDeclaration instanceof TypeDeclaration) {
              TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
              if (typeDeclaration.getName().getIdentifier().equals(cloneInfo.intermediateClassName)) {
                intermediateTypeDeclaration=typeDeclaration;
                int intermediateModifiers=intermediateTypeDeclaration.getModifiers();
                if ((intermediateModifiers & Modifier.ABSTRACT) == 0 && !cloneInfo.extractUtilityClass) {
                  ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
                  intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
                }
                break;
              }
            }
          }
          MultiTextEdit intermediateMultiTextEdit=new MultiTextEdit();
          CompilationUnitChange intermediateCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",intermediateICompilationUnit);
          intermediateCompilationUnitChange.setEdit(intermediateMultiTextEdit);
          compilationUnitChanges.put(intermediateICompilationUnit,intermediateCompilationUnitChange);
        }
 else {
          if (compilationUnit.getPackage() != null) {
            intermediateRewriter.set(intermediateCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,compilationUnit.getPackage(),null);
          }
          intermediateTypeDeclaration=intermediateAST.newTypeDeclaration();
          SimpleName intermediateName=intermediateAST.newSimpleName(cloneInfo.intermediateClassName);
          intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.NAME_PROPERTY,intermediateName,null);
          ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
          intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
          if (!cloneInfo.extractUtilityClass) {
            intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
            intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,intermediateAST.newSimpleType(intermediateAST.newSimpleName(commonSuperTypeOfSourceTypeDeclarations.getName())),null);
            ListRewrite interfaceRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.SUPER_INTERFACE_TYPES_PROPERTY);
            List<Type> superInterfaceTypes1=sourceTypeDeclarations.get(0).superInterfaceTypes();
            List<Type> superInterfaceTypes2=sourceTypeDeclarations.get(1).superInterfaceTypes();
            for (            Type interfaceType1 : superInterfaceTypes1) {
              for (              Type interfaceType2 : superInterfaceTypes2) {
                if (interfaceType1.resolveBinding().isEqualTo(interfaceType2.resolveBinding())) {
                  interfaceRewrite.insertLast(interfaceType1,null);
                  Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
                  typeBindings.add(interfaceType1.resolveBinding());
                  getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
                  break;
                }
              }
            }
            ListRewrite bodyDeclarationsRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
            for (            MethodDeclaration methodDeclaration1 : sourceTypeDeclarations.get(0).getMethods()) {
              List<SingleVariableDeclaration> parameters1=methodDeclaration1.parameters();
              if (methodDeclaration1.isConstructor()) {
                for (                MethodDeclaration methodDeclaration2 : sourceTypeDeclarations.get(1).getMethods()) {
                  List<SingleVariableDeclaration> parameters2=methodDeclaration2.parameters();
                  if (methodDeclaration2.isConstructor()) {
                    if (matchingParameterTypes(parameters1,parameters2)) {
                      SuperConstructorInvocation superConstructorInvocation1=firstStatementIsSuperConstructorInvocation(methodDeclaration1);
                      SuperConstructorInvocation superConstructorInvocation2=firstStatementIsSuperConstructorInvocation(methodDeclaration2);
                      if (superConstructorInvocation1 != null && superConstructorInvocation2 != null) {
                        if (compareStatements(sourceCompilationUnits.get(0).getTypeRoot(),sourceCompilationUnits.get(1).getTypeRoot(),superConstructorInvocation1,superConstructorInvocation2)) {
                          MethodDeclaration constructor=intermediateAST.newMethodDeclaration();
                          intermediateRewriter.set(constructor,MethodDeclaration.NAME_PROPERTY,intermediateName,null);
                          intermediateRewriter.set(constructor,MethodDeclaration.CONSTRUCTOR_PROPERTY,true,null);
                          ListRewrite constructorModifierRewriter=intermediateRewriter.getListRewrite(constructor,MethodDeclaration.MODIFIERS2_PROPERTY);
                          List<IExtendedModifier> modifiers=methodDeclaration1.modifiers();
                          for (                          IExtendedModifier modifier : modifiers) {
                            if (modifier instanceof Modifier) {
                              constructorModifierRewriter.insertLast((Modifier)modifier,null);
                            }
                          }
                          ListRewrite parameterRewriter=intermediateRewriter.getListRewrite(constructor,MethodDeclaration.PARAMETERS_PROPERTY);
                          for (                          SingleVariableDeclaration parameter : parameters1) {
                            Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
                            typeBindings.add(parameter.getType().resolveBinding());
                            getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
                            parameterRewriter.insertLast(parameter,null);
                          }
                          Block constructorBody=intermediateAST.newBlock();
                          ListRewrite constructorBodyRewriter=intermediateRewriter.getListRewrite(constructorBody,Block.STATEMENTS_PROPERTY);
                          constructorBodyRewriter.insertLast(superConstructorInvocation1,null);
                          intermediateRewriter.set(constructor,MethodDeclaration.BODY_PROPERTY,constructorBody,null);
                          bodyDeclarationsRewrite.insertLast(constructor,null);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          intermediateTypesRewrite.insertLast(intermediateTypeDeclaration,null);
        }
        cloneInfo.sourceCompilationUnit=intermediateCompilationUnit;
        cloneInfo.sourceICompilationUnit=intermediateICompilationUnit;
        cloneInfo.sourceTypeDeclaration=intermediateTypeDeclaration;
        cloneInfo.sourceRewriter=intermediateRewriter;
        cloneInfo.ast=intermediateAST;
      }
    }
  }
  ASTRewrite sourceRewriter=cloneInfo.sourceRewriter;
  AST ast=cloneInfo.ast;
  TypeDeclaration sourceTypeDeclaration=cloneInfo.sourceTypeDeclaration;
  MethodDeclaration sourceMethodDeclaration=sourceMethodDeclarations.get(0);
  ListRewrite bodyDeclarationsRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  if (commonSuperTypeOfSourceTypeDeclarations != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  Set<VariableDeclaration> accessedLocalFieldsG1=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
  Set<VariableDeclaration> accessedLocalFieldsG2=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
  if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding()) || !sourceTypeDeclarations.get(0).resolveBinding().getQualifiedName().equals(sourceTypeDeclarations.get(1).resolveBinding().getQualifiedName())) {
    pullUpLocallyAccessedFields(accessedLocalFieldsG1,accessedLocalFieldsG2,bodyDeclarationsRewrite,requiredImportTypeBindings);
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG1=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG2=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    Set<MethodObject> accessedLocalMethodsG1=mapper.getAccessedLocalMethodsG1();
    Set<MethodObject> accessedLocalMethodsG2=mapper.getAccessedLocalMethodsG2();
    for (    MethodObject localMethodG1 : accessedLocalMethodsG1) {
      for (      MethodObject localMethodG2 : accessedLocalMethodsG2) {
        ITypeBinding returnTypesCommonSuperType=ASTNodeMatcher.commonSuperType(localMethodG1.getMethodDeclaration().getReturnType2().resolveBinding(),localMethodG2.getMethodDeclaration().getReturnType2().resolveBinding());
        if (localMethodG1.getName().equals(localMethodG2.getName()) && (localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) || (returnTypesCommonSuperType != null && !ASTNodeMatcher.isTaggingInterface(returnTypesCommonSuperType))) && localMethodG1.getParameterTypeList().equals(localMethodG2.getParameterTypeList())) {
          MethodDeclaration methodDeclaration1=localMethodG1.getMethodDeclaration();
          MethodDeclaration methodDeclaration2=localMethodG2.getMethodDeclaration();
          Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
          boolean clones=type2Clones(methodDeclaration1,methodDeclaration2);
          Type returnType=methodDeclaration1.getReturnType2();
          TypeDeclaration typeDeclaration1=findTypeDeclaration(methodDeclaration1);
          TypeDeclaration typeDeclaration2=findTypeDeclaration(methodDeclaration2);
          Set<VariableDeclaration> fieldsAccessedInMethod1=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG1,methodDeclaration1);
          Set<VariableDeclaration> fieldsAccessedInMethod2=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG2,methodDeclaration2);
          boolean avoidPullUpDueToSerialization1=avoidPullUpMethodDueToSerialization(sourceTypeDeclarations.get(0),fieldsAccessedInMethod1);
          boolean avoidPullUpDueToSerialization2=avoidPullUpMethodDueToSerialization(sourceTypeDeclarations.get(1),fieldsAccessedInMethod2);
          if (clones && !avoidPullUpDueToSerialization1 && !avoidPullUpDueToSerialization2) {
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              MethodDeclaration copiedMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,methodDeclaration1);
              ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(copiedMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
              List<IExtendedModifier> originalModifiers=copiedMethodDeclaration.modifiers();
              for (              IExtendedModifier extendedModifier : originalModifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.isPrivate()) {
                    modifiersRewrite.replace(modifier,ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                  }
                }
              }
              if (!localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) && returnTypesCommonSuperType != null && !ASTNodeMatcher.isTaggingInterface(returnTypesCommonSuperType)) {
                Type newReturnType=generateTypeFromTypeBinding(returnTypesCommonSuperType,ast,sourceRewriter);
                sourceRewriter.set(copiedMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,newReturnType,null);
                typeBindings.add(returnTypesCommonSuperType);
              }
              if (!localMethodG1.isStatic() && localMethodG2.isStatic()) {
                modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD),null);
              }
              bodyDeclarationsRewrite.insertLast(copiedMethodDeclaration,null);
              TypeVisitor typeVisitor=new TypeVisitor();
              methodDeclaration1.accept(typeVisitor);
              typeBindings.addAll(typeVisitor.getTypeBindings());
              fieldsAccessedInMethod1.removeAll(accessedLocalFieldsG1);
              fieldsAccessedInMethod2.removeAll(accessedLocalFieldsG2);
              pullUpLocallyAccessedFields(fieldsAccessedInMethod1,fieldsAccessedInMethod2,bodyDeclarationsRewrite,requiredImportTypeBindings);
            }
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              methodDeclarationsToBePulledUp.get(0).add(methodDeclaration1);
            }
            if (!typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              methodDeclarationsToBePulledUp.get(1).add(methodDeclaration2);
            }
          }
 else {
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
              sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(methodDeclaration1.getName().getIdentifier()),null);
              if (localMethodG1.getReturnType().equals(localMethodG2.getReturnType())) {
                sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
                typeBindings.add(returnType.resolveBinding());
              }
 else               if (returnTypesCommonSuperType != null && !ASTNodeMatcher.isTaggingInterface(returnTypesCommonSuperType)) {
                Type newReturnType=generateTypeFromTypeBinding(returnTypesCommonSuperType,ast,sourceRewriter);
                sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,newReturnType,null);
                typeBindings.add(returnTypesCommonSuperType);
              }
              ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
              List<IExtendedModifier> originalModifiers=methodDeclaration1.modifiers();
              for (              IExtendedModifier extendedModifier : originalModifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.isProtected()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                    if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) == 0) {
                      updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                    }
                  }
 else                   if (modifier.isPublic()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
                    if ((methodDeclaration2.getModifiers() & Modifier.PUBLIC) == 0) {
                      updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PUBLIC_KEYWORD);
                    }
                  }
 else                   if (modifier.isPrivate()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                    updateAccessModifier(methodDeclaration1,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                    if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) == 0) {
                      updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                    }
                  }
                }
              }
              if (cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses) {
                Block methodBody=ast.newBlock();
                sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodBody,null);
                Expression returnedExpression=generateDefaultValue(sourceRewriter,ast,returnType);
                if (returnedExpression != null) {
                  ReturnStatement returnStatement=ast.newReturnStatement();
                  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedExpression,null);
                  ListRewrite statementsRewrite=sourceRewriter.getListRewrite(methodBody,Block.STATEMENTS_PROPERTY);
                  statementsRewrite.insertLast(returnStatement,null);
                }
              }
 else {
                modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
              }
              ListRewrite parametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
              List<SingleVariableDeclaration> parameters=methodDeclaration1.parameters();
              for (              SingleVariableDeclaration parameter : parameters) {
                parametersRewrite.insertLast(parameter,null);
                typeBindings.add(parameter.getType().resolveBinding());
              }
              ListRewrite thrownExceptionsRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
              List<Name> thrownExceptions=methodDeclaration1.thrownExceptions();
              for (              Name thrownException : thrownExceptions) {
                thrownExceptionsRewrite.insertLast(thrownException,null);
                typeBindings.add(thrownException.resolveTypeBinding());
              }
              bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
            }
          }
          getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
          break;
        }
      }
    }
  }
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  List<VariableDeclaration> returnedVariables1=this.returnedVariables.get(0);
  List<VariableDeclaration> returnedVariables2=this.returnedVariables.get(1);
  ITypeBinding returnTypeBinding=null;
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1) {
    Type returnType1=extractType(returnedVariables1.get(0));
    Type returnType2=extractType(returnedVariables2.get(0));
    if (returnType1.resolveBinding().isEqualTo(returnType2.resolveBinding()))     returnTypeBinding=returnType1.resolveBinding();
 else     returnTypeBinding=ASTNodeMatcher.commonSuperType(returnType1.resolveBinding(),returnType2.resolveBinding());
  }
 else {
    returnTypeBinding=findReturnTypeBinding();
  }
  if (returnTypeBinding != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(returnTypeBinding);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
    Type returnType=generateTypeFromTypeBinding(returnTypeBinding,ast,sourceRewriter);
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
  }
 else {
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
  }
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else   if (cloneInfo.extractUtilityClass) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
  if (((sourceMethodDeclarations.get(0).getModifiers() & Modifier.STATIC) != 0 && (sourceMethodDeclarations.get(1).getModifiers() & Modifier.STATIC) != 0) || cloneInfo.extractUtilityClass) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> commonPassedParameters=mapper.getCommonPassedParameters();
  for (  VariableBindingKeyPair parameterName : commonPassedParameters.keySet()) {
    ArrayList<VariableDeclaration> variableDeclarations=commonPassedParameters.get(parameterName);
    VariableDeclaration variableDeclaration1=variableDeclarations.get(0);
    VariableDeclaration variableDeclaration2=variableDeclarations.get(1);
    if (parameterIsUsedByNodesWithoutDifferences(variableDeclaration1,variableDeclaration2)) {
      if (!variableDeclaration1.resolveBinding().isField() && !variableDeclaration2.resolveBinding().isField()) {
        ITypeBinding typeBinding1=extractType(variableDeclaration1).resolveBinding();
        ITypeBinding typeBinding2=extractType(variableDeclaration2).resolveBinding();
        ITypeBinding typeBinding=null;
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
        Type variableType=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(typeBinding);
        getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration1.getName(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
        parameterRewrite.insertLast(parameter,null);
        originalPassedParameters.put(parameterName,variableDeclarations);
      }
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  Set<ITypeBinding> thrownExceptionTypeBindings=new LinkedHashSet<ITypeBinding>();
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode1=pdgNodeMapping.getNodeG1();
    AbstractStatement statement1=pdgNode1.getStatement();
    PDGBlockNode blockNode1=mapper.getPDG1().isNestedWithinBlockNode(pdgNode1);
    if (blockNode1 != null && blockNode1 instanceof PDGTryNode && mapper.getRemovableNodesG1().contains(blockNode1)) {
    }
 else {
      ThrownExceptionVisitor thrownExceptionVisitor=new ThrownExceptionVisitor();
      statement1.getStatement().accept(thrownExceptionVisitor);
      for (      ITypeBinding thrownException : thrownExceptionVisitor.getTypeBindings()) {
        if (pdgNode1.getThrownExceptionTypes().contains(thrownException.getQualifiedName())) {
          thrownExceptionTypeBindings.add(thrownException);
        }
      }
    }
    getSimpleTypeBindings(extractTypeBindings(statement1),requiredImportTypeBindings);
    PDGNode pdgNode2=pdgNodeMapping.getNodeG2();
    AbstractStatement statement2=pdgNode2.getStatement();
    PDGBlockNode blockNode2=mapper.getPDG2().isNestedWithinBlockNode(pdgNode2);
    if (blockNode2 != null && blockNode2 instanceof PDGTryNode && mapper.getRemovableNodesG2().contains(blockNode2)) {
    }
 else {
      ThrownExceptionVisitor thrownExceptionVisitor=new ThrownExceptionVisitor();
      statement2.getStatement().accept(thrownExceptionVisitor);
      for (      ITypeBinding thrownException : thrownExceptionVisitor.getTypeBindings()) {
        if (pdgNode2.getThrownExceptionTypes().contains(thrownException.getQualifiedName())) {
          thrownExceptionTypeBindings.add(thrownException);
        }
      }
    }
    getSimpleTypeBindings(extractTypeBindings(statement2),requiredImportTypeBindings);
  }
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  List<Name> thrownExceptions1=sourceMethodDeclarations.get(0).thrownExceptions();
  List<Name> thrownExceptions2=sourceMethodDeclarations.get(1).thrownExceptions();
  for (  Name thrownException1 : thrownExceptions1) {
    for (    Name thrownException2 : thrownExceptions2) {
      if (thrownException1.resolveTypeBinding().isEqualTo(thrownException2.resolveTypeBinding()) && thrownExceptionTypeBindings.contains(thrownException1.resolveTypeBinding())) {
        thrownExceptionRewrite.insertLast(thrownException1,null);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(thrownException1.resolveTypeBinding());
        getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        thrownExceptionTypeBindings.remove(thrownException1.resolveTypeBinding());
        break;
      }
    }
  }
  for (  ITypeBinding thrownExceptionTypeBinding : thrownExceptionTypeBindings) {
    thrownExceptionRewrite.insertLast(ast.newSimpleName(thrownExceptionTypeBinding.getName()),null);
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(thrownExceptionTypeBinding);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  CloneStructureNode root=mapper.getCloneStructureRoot();
  for (  CloneStructureNode child : root.getChildren()) {
    if (processableNode(child)) {
      Statement statement=processCloneStructureNode(child,ast,sourceRewriter);
      methodBodyRewrite.insertLast(statement,null);
    }
  }
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1 && !mappedNodesContainStatementReturningVariable(returnedVariables1.get(0),returnedVariables2.get(0))) {
    ReturnStatement returnStatement=ast.newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariables1.get(0).getName(),null);
    methodBodyRewrite.insertLast(returnStatement,null);
    if (!mappedNodesContainStatementDeclaringVariable(returnedVariables1.get(0),returnedVariables2.get(0)) && !variableIsPassedAsCommonParameter(returnedVariables1.get(0),returnedVariables2.get(0))) {
      Type returnedType=extractType(returnedVariables1.get(0));
      Expression initializer=generateDefaultValue(sourceRewriter,ast,returnedType);
      VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(fragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariables1.get(0).getName(),null);
      sourceRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,initializer,null);
      VariableDeclarationStatement declarationStatement=ast.newVariableDeclarationStatement(fragment);
      sourceRewriter.set(declarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedType,null);
      methodBodyRewrite.insertFirst(declarationStatement,null);
    }
  }
  int existingArgValue=findExistingParametersWithArgName();
  int i=0;
  if (existingArgValue > 0) {
    i=existingArgValue + 1;
  }
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    AbstractExpression expression1=difference.getExpression1();
    AbstractExpression expression2=difference.getExpression2();
    boolean isReturnedVariable=false;
    if (expression1 != null) {
      isReturnedVariable=isReturnedVariable(expression1.getExpression(),this.returnedVariables.get(0));
    }
 else     if (expression2 != null) {
      isReturnedVariable=isReturnedVariable(expression2.getExpression(),this.returnedVariables.get(1));
    }
    ITypeBinding typeBinding1=expression1 != null ? expression1.getExpression().resolveTypeBinding() : expression2.getExpression().resolveTypeBinding();
    ITypeBinding typeBinding2=expression2 != null ? expression2.getExpression().resolveTypeBinding() : expression1.getExpression().resolveTypeBinding();
    if (!isReturnedVariable) {
      ITypeBinding typeBinding=null;
      if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH) || differenceContainsSubDifferenceWithSubclassTypeMismatch(difference)) {
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
      }
 else {
        if (expression1 != null && !typeBinding1.getQualifiedName().equals(""String_Node_Str"")) {
          typeBinding=typeBinding1;
        }
 else {
          typeBinding=typeBinding2;
        }
      }
      Type type=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
      Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
      typeBindings.add(typeBinding);
      getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(""String_Node_Str"" + i),null);
      i++;
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  for (  VariableDeclaration variableDeclaration : fieldDeclarationsToBeParameterized.get(0)) {
    if (accessedLocalFieldsG1.contains(variableDeclaration)) {
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      Type type=generateTypeFromTypeBinding(variableDeclaration.resolveBinding().getType(),ast,sourceRewriter);
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration.getName(),null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
  cloneInfo.requiredImportTypeBindings=requiredImportTypeBindings;
  cloneInfo.methodBodyRewrite=methodBodyRewrite;
  cloneInfo.parameterRewrite=parameterRewrite;
}"
12058,"private void initialize(){
  AbstractMethodDeclaration methodObject1=this.mapper.getPDG1().getMethod();
  AbstractMethodDeclaration methodObject2=this.mapper.getPDG2().getMethod();
  MethodDeclaration methodDeclaration1=methodObject1.getMethodDeclaration();
  MethodDeclaration methodDeclaration2=methodObject2.getMethodDeclaration();
  this.sourceCompilationUnits=new ArrayList<CompilationUnit>();
  this.sourceTypeDeclarations=new ArrayList<TypeDeclaration>();
  this.sourceMethodDeclarations=new ArrayList<MethodDeclaration>();
  this.removableStatements=new ArrayList<TreeSet<PDGNode>>();
  removableStatements.add(this.mapper.getRemovableNodesG1());
  removableStatements.add(this.mapper.getRemovableNodesG2());
  this.remainingStatementsMovableBefore=new ArrayList<TreeSet<PDGNode>>();
  remainingStatementsMovableBefore.add(this.mapper.getNonMappedPDGNodesG1MovableBefore());
  remainingStatementsMovableBefore.add(this.mapper.getNonMappedPDGNodesG2MovableBefore());
  this.remainingStatementsMovableAfter=new ArrayList<TreeSet<PDGNode>>();
  remainingStatementsMovableAfter.add(this.mapper.getNonMappedPDGNodesG1MovableAfter());
  remainingStatementsMovableAfter.add(this.mapper.getNonMappedPDGNodesG2MovableAfter());
  this.returnedVariables=new ArrayList<ArrayList<VariableDeclaration>>();
  returnedVariables.add(new ArrayList<VariableDeclaration>(this.mapper.getDeclaredVariablesInMappedNodesUsedByNonMappedNodesG1()));
  returnedVariables.add(new ArrayList<VariableDeclaration>(this.mapper.getDeclaredVariablesInMappedNodesUsedByNonMappedNodesG2()));
  this.fieldDeclarationsToBePulledUp=new ArrayList<Set<VariableDeclaration>>();
  this.fieldDeclarationsToBeParameterized=new ArrayList<Set<VariableDeclaration>>();
  this.methodDeclarationsToBePulledUp=new ArrayList<Set<MethodDeclaration>>();
  this.labeledStatementsToBeRemoved=new ArrayList<Set<LabeledStatement>>();
  for (int i=0; i < 2; i++) {
    fieldDeclarationsToBePulledUp.add(new LinkedHashSet<VariableDeclaration>());
    fieldDeclarationsToBeParameterized.add(new LinkedHashSet<VariableDeclaration>());
    methodDeclarationsToBePulledUp.add(new LinkedHashSet<MethodDeclaration>());
    labeledStatementsToBeRemoved.add(new LinkedHashSet<LabeledStatement>());
  }
  this.compilationUnitChanges=new LinkedHashMap<ICompilationUnit,CompilationUnitChange>();
  this.createCompilationUnitChanges=new LinkedHashMap<ICompilationUnit,CreateCompilationUnitChange>();
  this.javaElementsToOpenInEditor=new LinkedHashSet<IJavaElement>();
  this.sourceMethodDeclarations.add(methodDeclaration1);
  this.sourceMethodDeclarations.add(methodDeclaration2);
  this.sourceTypeDeclarations.add((TypeDeclaration)methodDeclaration1.getParent());
  this.sourceTypeDeclarations.add((TypeDeclaration)methodDeclaration2.getParent());
  this.sourceCompilationUnits.add((CompilationUnit)methodDeclaration1.getRoot());
  this.sourceCompilationUnits.add((CompilationUnit)methodDeclaration2.getRoot());
  this.originalPassedParameters=new LinkedHashMap<VariableBindingKeyPair,ArrayList<VariableDeclaration>>();
  this.parameterizedDifferenceMap=new LinkedHashMap<BindingSignaturePair,ASTNodeDifference>();
  this.sortedNodeMappings=new TreeSet<PDGNodeMapping>(this.mapper.getMaximumStateWithMinimumDifferences().getNodeMappings());
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode=pdgNodeMapping.getNodeG1();
    CFGNode cfgNode=pdgNode.getCFGNode();
    if (cfgNode instanceof CFGBranchDoLoopNode) {
      CFGBranchDoLoopNode cfgDoLoopNode=(CFGBranchDoLoopNode)cfgNode;
      doLoopNodes.add(cfgDoLoopNode);
    }
  }
  for (  CompilationUnit sourceCompilationUnit : sourceCompilationUnits) {
    ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
    MultiTextEdit sourceMultiTextEdit=new MultiTextEdit();
    CompilationUnitChange sourceCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",sourceICompilationUnit);
    sourceCompilationUnitChange.setEdit(sourceMultiTextEdit);
    compilationUnitChanges.put(sourceICompilationUnit,sourceCompilationUnitChange);
  }
  this.cloneInfo=null;
}","private void initialize(){
  AbstractMethodDeclaration methodObject1=this.mapper.getPDG1().getMethod();
  AbstractMethodDeclaration methodObject2=this.mapper.getPDG2().getMethod();
  MethodDeclaration methodDeclaration1=methodObject1.getMethodDeclaration();
  MethodDeclaration methodDeclaration2=methodObject2.getMethodDeclaration();
  this.sourceCompilationUnits=new ArrayList<CompilationUnit>();
  this.sourceTypeDeclarations=new ArrayList<TypeDeclaration>();
  this.sourceMethodDeclarations=new ArrayList<MethodDeclaration>();
  this.removableStatements=new ArrayList<TreeSet<PDGNode>>();
  removableStatements.add(this.mapper.getRemovableNodesG1());
  removableStatements.add(this.mapper.getRemovableNodesG2());
  this.remainingStatementsMovableBefore=new ArrayList<TreeSet<PDGNode>>();
  remainingStatementsMovableBefore.add(this.mapper.getNonMappedPDGNodesG1MovableBefore());
  remainingStatementsMovableBefore.add(this.mapper.getNonMappedPDGNodesG2MovableBefore());
  this.remainingStatementsMovableAfter=new ArrayList<TreeSet<PDGNode>>();
  remainingStatementsMovableAfter.add(this.mapper.getNonMappedPDGNodesG1MovableAfter());
  remainingStatementsMovableAfter.add(this.mapper.getNonMappedPDGNodesG2MovableAfter());
  this.returnedVariables=new ArrayList<ArrayList<VariableDeclaration>>();
  returnedVariables.add(new ArrayList<VariableDeclaration>(this.mapper.getVariablesToBeReturnedG1()));
  returnedVariables.add(new ArrayList<VariableDeclaration>(this.mapper.getVariablesToBeReturnedG2()));
  this.fieldDeclarationsToBePulledUp=new ArrayList<Set<VariableDeclaration>>();
  this.fieldDeclarationsToBeParameterized=new ArrayList<Set<VariableDeclaration>>();
  this.methodDeclarationsToBePulledUp=new ArrayList<Set<MethodDeclaration>>();
  this.labeledStatementsToBeRemoved=new ArrayList<Set<LabeledStatement>>();
  for (int i=0; i < 2; i++) {
    fieldDeclarationsToBePulledUp.add(new LinkedHashSet<VariableDeclaration>());
    fieldDeclarationsToBeParameterized.add(new LinkedHashSet<VariableDeclaration>());
    methodDeclarationsToBePulledUp.add(new LinkedHashSet<MethodDeclaration>());
    labeledStatementsToBeRemoved.add(new LinkedHashSet<LabeledStatement>());
  }
  this.compilationUnitChanges=new LinkedHashMap<ICompilationUnit,CompilationUnitChange>();
  this.createCompilationUnitChanges=new LinkedHashMap<ICompilationUnit,CreateCompilationUnitChange>();
  this.javaElementsToOpenInEditor=new LinkedHashSet<IJavaElement>();
  this.sourceMethodDeclarations.add(methodDeclaration1);
  this.sourceMethodDeclarations.add(methodDeclaration2);
  this.sourceTypeDeclarations.add((TypeDeclaration)methodDeclaration1.getParent());
  this.sourceTypeDeclarations.add((TypeDeclaration)methodDeclaration2.getParent());
  this.sourceCompilationUnits.add((CompilationUnit)methodDeclaration1.getRoot());
  this.sourceCompilationUnits.add((CompilationUnit)methodDeclaration2.getRoot());
  this.originalPassedParameters=new LinkedHashMap<VariableBindingKeyPair,ArrayList<VariableDeclaration>>();
  this.parameterizedDifferenceMap=new LinkedHashMap<BindingSignaturePair,ASTNodeDifference>();
  this.sortedNodeMappings=new TreeSet<PDGNodeMapping>(this.mapper.getMaximumStateWithMinimumDifferences().getNodeMappings());
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode=pdgNodeMapping.getNodeG1();
    CFGNode cfgNode=pdgNode.getCFGNode();
    if (cfgNode instanceof CFGBranchDoLoopNode) {
      CFGBranchDoLoopNode cfgDoLoopNode=(CFGBranchDoLoopNode)cfgNode;
      doLoopNodes.add(cfgDoLoopNode);
    }
  }
  for (  CompilationUnit sourceCompilationUnit : sourceCompilationUnits) {
    ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
    MultiTextEdit sourceMultiTextEdit=new MultiTextEdit();
    CompilationUnitChange sourceCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",sourceICompilationUnit);
    sourceCompilationUnitChange.setEdit(sourceMultiTextEdit);
    compilationUnitChanges.put(sourceICompilationUnit,sourceCompilationUnitChange);
  }
  this.cloneInfo=null;
}"
12059,"private void processCFGNode(PDGNode previousNode,CFGNode cfgNode,boolean controlType){
  if (cfgNode instanceof CFGBranchNode) {
    PDGControlPredicateNode predicateNode=new PDGControlPredicateNode(cfgNode,variableDeclarationsInMethod,fieldsAccessedInMethod);
    nodes.add(predicateNode);
    if (monitor != null)     monitor.worked(1);
    PDGControlDependence controlDependence=new PDGControlDependence(previousNode,predicateNode,controlType);
    edges.add(controlDependence);
    processControlPredicate(predicateNode);
  }
 else {
    PDGNode pdgNode=null;
    if (cfgNode instanceof CFGExitNode)     pdgNode=new PDGExitNode(cfgNode,variableDeclarationsInMethod,fieldsAccessedInMethod);
 else     pdgNode=new PDGStatementNode(cfgNode,variableDeclarationsInMethod,fieldsAccessedInMethod);
    nodes.add(pdgNode);
    if (monitor != null)     monitor.worked(1);
    PDGControlDependence controlDependence=new PDGControlDependence(previousNode,pdgNode,controlType);
    edges.add(controlDependence);
  }
}","private void processCFGNode(PDGNode previousNode,CFGNode cfgNode,boolean controlType){
  if (cfgNode instanceof CFGBranchNode) {
    PDGControlPredicateNode predicateNode=new PDGControlPredicateNode(cfgNode,variableDeclarationsInMethod,fieldsAccessedInMethod);
    nodes.add(predicateNode);
    if (monitor != null)     monitor.worked(1);
    PDGControlDependence controlDependence=new PDGControlDependence(previousNode,predicateNode,controlType);
    edges.add(controlDependence);
    processControlPredicate(predicateNode);
  }
 else {
    PDGNode pdgNode=null;
    if (cfgNode instanceof CFGExitNode)     pdgNode=new PDGExitNode(cfgNode,variableDeclarationsInMethod,fieldsAccessedInMethod);
 else     if (cfgNode instanceof CFGTryNode)     pdgNode=new PDGTryNode((CFGTryNode)cfgNode,variableDeclarationsInMethod,fieldsAccessedInMethod);
 else     if (cfgNode instanceof CFGSynchronizedNode)     pdgNode=new PDGSynchronizedNode((CFGSynchronizedNode)cfgNode,variableDeclarationsInMethod,fieldsAccessedInMethod);
 else     pdgNode=new PDGStatementNode(cfgNode,variableDeclarationsInMethod,fieldsAccessedInMethod);
    nodes.add(pdgNode);
    if (monitor != null)     monitor.worked(1);
    PDGControlDependence controlDependence=new PDGControlDependence(previousNode,pdgNode,controlType);
    edges.add(controlDependence);
  }
}"
12060,"private void createControlDependenciesFromEntryNode(){
  for (  GraphNode node : cfg.nodes) {
    CFGNode cfgNode=(CFGNode)node;
    if (!isNested(cfgNode)) {
      processCFGNode(entryNode,cfgNode,true);
    }
  }
  Map<CFGBlockNode,List<CFGNode>> directlyNestedNodesInBlocks=cfg.getDirectlyNestedNodesInBlocks();
  for (  CFGBlockNode blockNode : directlyNestedNodesInBlocks.keySet()) {
    PDGBlockNode pdgBlockNode=null;
    if (blockNode instanceof CFGTryNode) {
      CFGTryNode tryNode=(CFGTryNode)blockNode;
      pdgBlockNode=new PDGTryNode(tryNode,variableDeclarationsInMethod,fieldsAccessedInMethod);
    }
 else     if (blockNode instanceof CFGSynchronizedNode) {
      CFGSynchronizedNode synchronizedNode=(CFGSynchronizedNode)blockNode;
      pdgBlockNode=new PDGSynchronizedNode(synchronizedNode,variableDeclarationsInMethod,fieldsAccessedInMethod);
    }
    nodes.add(pdgBlockNode);
  }
}","private void createControlDependenciesFromEntryNode(){
  for (  GraphNode node : cfg.nodes) {
    CFGNode cfgNode=(CFGNode)node;
    if (!isNested(cfgNode)) {
      processCFGNode(entryNode,cfgNode,true);
    }
  }
  Map<CFGBlockNode,List<CFGNode>> directlyNestedNodesInBlocks=cfg.getDirectlyNestedNodesInBlocks();
  for (  CFGBlockNode blockNode : directlyNestedNodesInBlocks.keySet()) {
    if (!containsNodeWithID(blockNode.getId())) {
      PDGBlockNode pdgBlockNode=null;
      if (blockNode instanceof CFGTryNode) {
        CFGTryNode tryNode=(CFGTryNode)blockNode;
        pdgBlockNode=new PDGTryNode(tryNode,variableDeclarationsInMethod,fieldsAccessedInMethod);
      }
 else       if (blockNode instanceof CFGSynchronizedNode) {
        CFGSynchronizedNode synchronizedNode=(CFGSynchronizedNode)blockNode;
        pdgBlockNode=new PDGSynchronizedNode(synchronizedNode,variableDeclarationsInMethod,fieldsAccessedInMethod);
      }
      if (pdgBlockNode != null) {
        nodes.add(pdgBlockNode);
      }
    }
  }
}"
12061,"private void modifySourceMethod(CompilationUnit compilationUnit,MethodDeclaration methodDeclaration,TreeSet<PDGNode> removableNodes,TreeSet<PDGNode> remainingNodesMovableBefore,TreeSet<PDGNode> remainingNodesMovableAfter,List<VariableDeclaration> returnedVariables,Set<VariableDeclaration> fieldsToBeParamterized,int index){
  AST ast=methodDeclaration.getAST();
  ASTRewrite methodBodyRewriter=ASTRewrite.create(ast);
  MethodInvocation methodInvocation=ast.newMethodInvocation();
  methodBodyRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  if (cloneInfo.extractUtilityClass) {
    methodBodyRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,ast.newSimpleName(cloneInfo.intermediateClassName),null);
  }
  ListRewrite argumentsRewrite=methodBodyRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  VariableBindingKeyPair parameterName : originalPassedParameters.keySet()) {
    List<VariableDeclaration> variableDeclarations=originalPassedParameters.get(parameterName);
    argumentsRewrite.insertLast(variableDeclarations.get(index).getName(),null);
  }
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    List<Expression> expressions=new ArrayList<Expression>();
    if (difference.getExpression1() != null) {
      Expression expression1=difference.getExpression1().getExpression();
      expression1=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1);
      expressions.add(expression1);
    }
 else {
      expressions.add(null);
    }
    if (difference.getExpression2() != null) {
      Expression expression2=difference.getExpression2().getExpression();
      expression2=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2);
      expressions.add(expression2);
    }
 else {
      expressions.add(null);
    }
    Expression expression=expressions.get(index);
    boolean isReturnedVariable=false;
    if (expression != null)     isReturnedVariable=isReturnedVariable(expression,returnedVariables);
    if (!isReturnedVariable) {
      if (expression != null) {
        if (difference.containsDifferenceType(DifferenceType.IF_ELSE_SYMMETRICAL_MATCH) && index == 1) {
          ParenthesizedExpression parenthesizedExpression=ast.newParenthesizedExpression();
          methodBodyRewriter.set(parenthesizedExpression,ParenthesizedExpression.EXPRESSION_PROPERTY,expression,null);
          PrefixExpression prefixExpression=ast.newPrefixExpression();
          methodBodyRewriter.set(prefixExpression,PrefixExpression.OPERAND_PROPERTY,parenthesizedExpression,null);
          methodBodyRewriter.set(prefixExpression,PrefixExpression.OPERATOR_PROPERTY,PrefixExpression.Operator.NOT,null);
          argumentsRewrite.insertLast(prefixExpression,null);
        }
 else {
          argumentsRewrite.insertLast(expression,null);
        }
      }
 else {
        argumentsRewrite.insertLast(ast.newThisExpression(),null);
      }
    }
  }
  for (  VariableDeclaration variableDeclaration : fieldsToBeParamterized) {
    argumentsRewrite.insertLast(variableDeclaration.getName(),null);
  }
  cloneInfo.argumentRewriteList.add(index,argumentsRewrite);
  Statement firstStatement=removableNodes.first().getASTStatement();
  Block parentBlock=(Block)firstStatement.getParent();
  ListRewrite blockRewrite=methodBodyRewriter.getListRewrite(parentBlock,Block.STATEMENTS_PROPERTY);
  CloneStructureNode root=mapper.getCloneStructureRoot();
  List<CloneStructureNode> processedCloneStructureGapNodes=new ArrayList<CloneStructureNode>();
  Set<PDGNode> remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.addAll(remainingNodesMovableBefore);
  remainingNodes.addAll(remainingNodesMovableAfter);
  List<Statement> statementsToBeMovedBefore=new ArrayList<Statement>();
  List<Statement> statementsToBeMovedAfter=new ArrayList<Statement>();
  for (  PDGNode remainingNode : remainingNodes) {
    CloneStructureNode remainingCloneStructureNode=null;
    if (index == 0)     remainingCloneStructureNode=root.findNodeG1(remainingNode);
 else     remainingCloneStructureNode=root.findNodeG2(remainingNode);
    if (!processedCloneStructureGapNodes.contains(remainingCloneStructureNode.getParent())) {
      Statement statement=processCloneStructureGapNode(remainingCloneStructureNode,ast,methodBodyRewriter,index);
      if (remainingNodesMovableBefore.contains(remainingNode)) {
        statementsToBeMovedBefore.add(statement);
      }
 else       if (remainingNodesMovableAfter.contains(remainingNode)) {
        statementsToBeMovedAfter.add(statement);
      }
      methodBodyRewriter.remove(remainingNode.getASTStatement(),null);
    }
    processedCloneStructureGapNodes.add(remainingCloneStructureNode);
    for (    CloneStructureNode child : remainingCloneStructureNode.getChildren()) {
      if (child.getMapping() instanceof PDGElseGap)       processedCloneStructureGapNodes.add(child);
    }
  }
  Statement extractedMethodInvocationStatement=null;
  if (returnedVariables.size() == 1) {
    Statement methodInvocationStatement=null;
    VariableDeclaration variableDeclaration=returnedVariables.get(0);
    if (variableDeclaration.resolveBinding().isParameter() || variableDeclaration.resolveBinding().isField() || statementsToBeMovedBefore.contains(variableDeclaration.getParent())) {
      Type variableType=extractType(variableDeclaration);
      Assignment assignment=ast.newAssignment();
      methodBodyRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,variableDeclaration.getName(),null);
      ITypeBinding returnTypeBinding=findReturnTypeBinding();
      if (returnTypeBinding != null && !returnTypeBinding.isEqualTo(variableType.resolveBinding())) {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,variableType,null);
        methodBodyRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,castExpression,null);
      }
 else {
        methodBodyRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,methodInvocation,null);
      }
      ExpressionStatement expressionStatement=ast.newExpressionStatement(assignment);
      methodInvocationStatement=expressionStatement;
      if (statementsToBeMovedBefore.contains(variableDeclaration.getParent()) && variableDeclaration.getInitializer() == null) {
        methodBodyRewriter.set(variableDeclaration,VariableDeclarationFragment.INITIALIZER_PROPERTY,generateDefaultValue(methodBodyRewriter,ast,variableType),null);
      }
    }
 else {
      Type variableType=extractType(variableDeclaration);
      VariableDeclarationFragment newFragment=ast.newVariableDeclarationFragment();
      methodBodyRewriter.set(newFragment,VariableDeclarationFragment.NAME_PROPERTY,variableDeclaration.getName(),null);
      ITypeBinding returnTypeBinding=findReturnTypeBinding();
      if (returnTypeBinding != null && !returnTypeBinding.isEqualTo(variableType.resolveBinding())) {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,variableType,null);
        methodBodyRewriter.set(newFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,castExpression,null);
      }
 else {
        methodBodyRewriter.set(newFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,methodInvocation,null);
      }
      VariableDeclarationStatement newVariableDeclarationStatement=ast.newVariableDeclarationStatement(newFragment);
      methodBodyRewriter.set(newVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,variableType,null);
      methodInvocationStatement=newVariableDeclarationStatement;
    }
    blockRewrite.insertBefore(methodInvocationStatement,firstStatement,null);
    extractedMethodInvocationStatement=methodInvocationStatement;
  }
 else {
    ITypeBinding returnTypeBinding=findReturnTypeBinding();
    Statement methodInvocationStatement=null;
    if (returnTypeBinding != null) {
      ReturnStatement returnStatement=ast.newReturnStatement();
      if (returnTypeBinding.isEqualTo(methodDeclaration.getReturnType2().resolveBinding())) {
        methodBodyRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,methodInvocation,null);
      }
 else {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,methodDeclaration.getReturnType2(),null);
        methodBodyRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,castExpression,null);
      }
      methodInvocationStatement=returnStatement;
    }
 else {
      methodInvocationStatement=ast.newExpressionStatement(methodInvocation);
    }
    blockRewrite.insertBefore(methodInvocationStatement,firstStatement,null);
    extractedMethodInvocationStatement=methodInvocationStatement;
  }
  for (  Statement movedBefore : statementsToBeMovedBefore) {
    blockRewrite.insertBefore(movedBefore,extractedMethodInvocationStatement,null);
  }
  for (int i=statementsToBeMovedAfter.size() - 1; i >= 0; i--) {
    Statement movedAfter=statementsToBeMovedAfter.get(i);
    blockRewrite.insertAfter(movedAfter,extractedMethodInvocationStatement,null);
  }
  for (  PDGNode pdgNode : removableNodes) {
    Statement statement=pdgNode.getASTStatement();
    methodBodyRewriter.remove(statement,null);
  }
  Set<LabeledStatement> labeledStatements=labeledStatementsToBeRemoved.get(index);
  for (  LabeledStatement labeled : labeledStatements) {
    methodBodyRewriter.remove(labeled,null);
  }
  cloneInfo.originalMethodBodyRewriteList.add(index,methodBodyRewriter);
}","private void modifySourceMethod(CompilationUnit compilationUnit,MethodDeclaration methodDeclaration,TreeSet<PDGNode> removableNodes,TreeSet<PDGNode> remainingNodesMovableBefore,TreeSet<PDGNode> remainingNodesMovableAfter,List<VariableDeclaration> returnedVariables,Set<VariableDeclaration> fieldsToBeParameterized,int index){
  AST ast=methodDeclaration.getAST();
  ASTRewrite methodBodyRewriter=ASTRewrite.create(ast);
  MethodInvocation methodInvocation=ast.newMethodInvocation();
  methodBodyRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  if (cloneInfo.extractUtilityClass) {
    methodBodyRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,ast.newSimpleName(cloneInfo.intermediateClassName),null);
  }
  ListRewrite argumentsRewrite=methodBodyRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  VariableBindingKeyPair parameterName : originalPassedParameters.keySet()) {
    List<VariableDeclaration> variableDeclarations=originalPassedParameters.get(parameterName);
    argumentsRewrite.insertLast(variableDeclarations.get(index).getName(),null);
  }
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    List<Expression> expressions=new ArrayList<Expression>();
    if (difference.getExpression1() != null) {
      Expression expression1=difference.getExpression1().getExpression();
      expression1=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1);
      expressions.add(expression1);
    }
 else {
      expressions.add(null);
    }
    if (difference.getExpression2() != null) {
      Expression expression2=difference.getExpression2().getExpression();
      expression2=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2);
      expressions.add(expression2);
    }
 else {
      expressions.add(null);
    }
    Expression expression=expressions.get(index);
    boolean isReturnedVariable=false;
    if (expression != null)     isReturnedVariable=isReturnedVariable(expression,returnedVariables);
    if (!isReturnedVariable) {
      if (expression != null) {
        if (difference.containsDifferenceType(DifferenceType.IF_ELSE_SYMMETRICAL_MATCH) && index == 1) {
          ParenthesizedExpression parenthesizedExpression=ast.newParenthesizedExpression();
          methodBodyRewriter.set(parenthesizedExpression,ParenthesizedExpression.EXPRESSION_PROPERTY,expression,null);
          PrefixExpression prefixExpression=ast.newPrefixExpression();
          methodBodyRewriter.set(prefixExpression,PrefixExpression.OPERAND_PROPERTY,parenthesizedExpression,null);
          methodBodyRewriter.set(prefixExpression,PrefixExpression.OPERATOR_PROPERTY,PrefixExpression.Operator.NOT,null);
          argumentsRewrite.insertLast(prefixExpression,null);
        }
 else {
          argumentsRewrite.insertLast(expression,null);
        }
      }
 else {
        argumentsRewrite.insertLast(ast.newThisExpression(),null);
      }
    }
  }
  Set<VariableDeclaration> accessedLocalFields=null;
  if (index == 0)   accessedLocalFields=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
 else   accessedLocalFields=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
  for (  VariableDeclaration variableDeclaration : fieldsToBeParameterized) {
    if (accessedLocalFields.contains(variableDeclaration)) {
      argumentsRewrite.insertLast(variableDeclaration.getName(),null);
    }
  }
  cloneInfo.argumentRewriteList.add(index,argumentsRewrite);
  Statement firstStatement=removableNodes.first().getASTStatement();
  Block parentBlock=(Block)firstStatement.getParent();
  ListRewrite blockRewrite=methodBodyRewriter.getListRewrite(parentBlock,Block.STATEMENTS_PROPERTY);
  CloneStructureNode root=mapper.getCloneStructureRoot();
  List<CloneStructureNode> processedCloneStructureGapNodes=new ArrayList<CloneStructureNode>();
  Set<PDGNode> remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.addAll(remainingNodesMovableBefore);
  remainingNodes.addAll(remainingNodesMovableAfter);
  List<Statement> statementsToBeMovedBefore=new ArrayList<Statement>();
  List<Statement> statementsToBeMovedAfter=new ArrayList<Statement>();
  for (  PDGNode remainingNode : remainingNodes) {
    CloneStructureNode remainingCloneStructureNode=null;
    if (index == 0)     remainingCloneStructureNode=root.findNodeG1(remainingNode);
 else     remainingCloneStructureNode=root.findNodeG2(remainingNode);
    if (!processedCloneStructureGapNodes.contains(remainingCloneStructureNode.getParent())) {
      Statement statement=processCloneStructureGapNode(remainingCloneStructureNode,ast,methodBodyRewriter,index);
      if (remainingNodesMovableBefore.contains(remainingNode)) {
        statementsToBeMovedBefore.add(statement);
      }
 else       if (remainingNodesMovableAfter.contains(remainingNode)) {
        statementsToBeMovedAfter.add(statement);
      }
      methodBodyRewriter.remove(remainingNode.getASTStatement(),null);
    }
    processedCloneStructureGapNodes.add(remainingCloneStructureNode);
    for (    CloneStructureNode child : remainingCloneStructureNode.getChildren()) {
      if (child.getMapping() instanceof PDGElseGap)       processedCloneStructureGapNodes.add(child);
    }
  }
  Statement extractedMethodInvocationStatement=null;
  if (returnedVariables.size() == 1) {
    Statement methodInvocationStatement=null;
    VariableDeclaration variableDeclaration=returnedVariables.get(0);
    if (variableDeclaration.resolveBinding().isParameter() || variableDeclaration.resolveBinding().isField() || statementsToBeMovedBefore.contains(variableDeclaration.getParent())) {
      Type variableType=extractType(variableDeclaration);
      Assignment assignment=ast.newAssignment();
      methodBodyRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,variableDeclaration.getName(),null);
      ITypeBinding returnTypeBinding=findReturnTypeBinding();
      if (returnTypeBinding != null && !returnTypeBinding.isEqualTo(variableType.resolveBinding())) {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,variableType,null);
        methodBodyRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,castExpression,null);
      }
 else {
        methodBodyRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,methodInvocation,null);
      }
      ExpressionStatement expressionStatement=ast.newExpressionStatement(assignment);
      methodInvocationStatement=expressionStatement;
      if (statementsToBeMovedBefore.contains(variableDeclaration.getParent()) && variableDeclaration.getInitializer() == null) {
        methodBodyRewriter.set(variableDeclaration,VariableDeclarationFragment.INITIALIZER_PROPERTY,generateDefaultValue(methodBodyRewriter,ast,variableType),null);
      }
    }
 else {
      Type variableType=extractType(variableDeclaration);
      VariableDeclarationFragment newFragment=ast.newVariableDeclarationFragment();
      methodBodyRewriter.set(newFragment,VariableDeclarationFragment.NAME_PROPERTY,variableDeclaration.getName(),null);
      ITypeBinding returnTypeBinding=findReturnTypeBinding();
      if (returnTypeBinding != null && !returnTypeBinding.isEqualTo(variableType.resolveBinding())) {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,variableType,null);
        methodBodyRewriter.set(newFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,castExpression,null);
      }
 else {
        methodBodyRewriter.set(newFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,methodInvocation,null);
      }
      VariableDeclarationStatement newVariableDeclarationStatement=ast.newVariableDeclarationStatement(newFragment);
      methodBodyRewriter.set(newVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,variableType,null);
      methodInvocationStatement=newVariableDeclarationStatement;
    }
    blockRewrite.insertBefore(methodInvocationStatement,firstStatement,null);
    extractedMethodInvocationStatement=methodInvocationStatement;
  }
 else {
    ITypeBinding returnTypeBinding=findReturnTypeBinding();
    Statement methodInvocationStatement=null;
    if (returnTypeBinding != null) {
      ReturnStatement returnStatement=ast.newReturnStatement();
      if (returnTypeBinding.isEqualTo(methodDeclaration.getReturnType2().resolveBinding())) {
        methodBodyRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,methodInvocation,null);
      }
 else {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,methodDeclaration.getReturnType2(),null);
        methodBodyRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,castExpression,null);
      }
      methodInvocationStatement=returnStatement;
    }
 else {
      methodInvocationStatement=ast.newExpressionStatement(methodInvocation);
    }
    blockRewrite.insertBefore(methodInvocationStatement,firstStatement,null);
    extractedMethodInvocationStatement=methodInvocationStatement;
  }
  for (  Statement movedBefore : statementsToBeMovedBefore) {
    blockRewrite.insertBefore(movedBefore,extractedMethodInvocationStatement,null);
  }
  for (int i=statementsToBeMovedAfter.size() - 1; i >= 0; i--) {
    Statement movedAfter=statementsToBeMovedAfter.get(i);
    blockRewrite.insertAfter(movedAfter,extractedMethodInvocationStatement,null);
  }
  for (  PDGNode pdgNode : removableNodes) {
    Statement statement=pdgNode.getASTStatement();
    methodBodyRewriter.remove(statement,null);
  }
  Set<LabeledStatement> labeledStatements=labeledStatementsToBeRemoved.get(index);
  for (  LabeledStatement labeled : labeledStatements) {
    methodBodyRewriter.remove(labeled,null);
  }
  cloneInfo.originalMethodBodyRewriteList.add(index,methodBodyRewriter);
}"
12062,"private void pullUpLocallyAccessedFields(Set<VariableDeclaration> accessedLocalFieldsG1,Set<VariableDeclaration> accessedLocalFieldsG2,ListRewrite bodyDeclarationsRewrite,Set<ITypeBinding> requiredImportTypeBindings){
  ASTRewrite sourceRewriter=cloneInfo.sourceRewriter;
  AST ast=cloneInfo.ast;
  TypeDeclaration sourceTypeDeclaration=cloneInfo.sourceTypeDeclaration;
  for (  VariableDeclaration localFieldG1 : accessedLocalFieldsG1) {
    FieldDeclaration originalFieldDeclarationG1=(FieldDeclaration)localFieldG1.getParent();
    for (    VariableDeclaration localFieldG2 : accessedLocalFieldsG2) {
      FieldDeclaration originalFieldDeclarationG2=(FieldDeclaration)localFieldG2.getParent();
      if (localFieldG1.getName().getIdentifier().equals(localFieldG2.getName().getIdentifier())) {
        if (originalFieldDeclarationG1.getType().resolveBinding().isEqualTo(originalFieldDeclarationG2.getType().resolveBinding())) {
          boolean avoidPullUpDueToSerialization1=implementsSerializableInterface(sourceTypeDeclarations.get(0).resolveBinding()) && (localFieldG1.resolveBinding().getModifiers() & Modifier.TRANSIENT) == 0;
          boolean avoidPullUpDueToSerialization2=implementsSerializableInterface(sourceTypeDeclarations.get(1).resolveBinding()) && (localFieldG2.resolveBinding().getModifiers() & Modifier.TRANSIENT) == 0;
          if (!avoidPullUpDueToSerialization1 && !avoidPullUpDueToSerialization2) {
            if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              fieldDeclarationsToBePulledUp.get(0).add(localFieldG1);
            }
            if (!sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              fieldDeclarationsToBePulledUp.get(1).add(localFieldG2);
            }
            if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
              typeBindings.add(localFieldG1.resolveBinding().getType());
              getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
              VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
              sourceRewriter.set(fragment,VariableDeclarationFragment.NAME_PROPERTY,ast.newSimpleName(localFieldG1.getName().getIdentifier()),null);
              if (localFieldG1.getInitializer() != null && localFieldG2.getInitializer() != null) {
                Expression initializer1=localFieldG1.getInitializer();
                Expression initializer2=localFieldG2.getInitializer();
                if (initializer1.subtreeMatch(new ASTMatcher(),initializer2)) {
                  sourceRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,ASTNode.copySubtree(ast,initializer1),null);
                }
              }
              FieldDeclaration newFieldDeclaration=ast.newFieldDeclaration(fragment);
              sourceRewriter.set(newFieldDeclaration,FieldDeclaration.TYPE_PROPERTY,originalFieldDeclarationG1.getType(),null);
              if (originalFieldDeclarationG1.getJavadoc() != null) {
                sourceRewriter.set(newFieldDeclaration,FieldDeclaration.JAVADOC_PROPERTY,originalFieldDeclarationG1.getJavadoc(),null);
              }
              ListRewrite newFieldDeclarationModifiersRewrite=sourceRewriter.getListRewrite(newFieldDeclaration,FieldDeclaration.MODIFIERS2_PROPERTY);
              newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
              List<IExtendedModifier> originalModifiers=originalFieldDeclarationG1.modifiers();
              for (              IExtendedModifier extendedModifier : originalModifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.isFinal()) {
                    newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.FINAL_KEYWORD),null);
                  }
 else                   if (modifier.isStatic()) {
                    newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD),null);
                  }
 else                   if (modifier.isTransient()) {
                    newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.TRANSIENT_KEYWORD),null);
                  }
 else                   if (modifier.isVolatile()) {
                    newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.VOLATILE_KEYWORD),null);
                  }
                }
              }
              bodyDeclarationsRewrite.insertLast(newFieldDeclaration,null);
            }
          }
 else {
            fieldDeclarationsToBeParameterized.get(0).add(localFieldG1);
            fieldDeclarationsToBeParameterized.get(1).add(localFieldG2);
          }
          break;
        }
      }
    }
  }
}","private void pullUpLocallyAccessedFields(Set<VariableDeclaration> accessedLocalFieldsG1,Set<VariableDeclaration> accessedLocalFieldsG2,ListRewrite bodyDeclarationsRewrite,Set<ITypeBinding> requiredImportTypeBindings){
  ASTRewrite sourceRewriter=cloneInfo.sourceRewriter;
  AST ast=cloneInfo.ast;
  TypeDeclaration sourceTypeDeclaration=cloneInfo.sourceTypeDeclaration;
  for (  VariableDeclaration localFieldG1 : accessedLocalFieldsG1) {
    FieldDeclaration originalFieldDeclarationG1=(FieldDeclaration)localFieldG1.getParent();
    for (    VariableDeclaration localFieldG2 : accessedLocalFieldsG2) {
      FieldDeclaration originalFieldDeclarationG2=(FieldDeclaration)localFieldG2.getParent();
      if (localFieldG1.getName().getIdentifier().equals(localFieldG2.getName().getIdentifier())) {
        if (originalFieldDeclarationG1.getType().resolveBinding().isEqualTo(originalFieldDeclarationG2.getType().resolveBinding())) {
          boolean avoidPullUpDueToSerialization1=avoidPullUpFieldDueToSerialization(sourceTypeDeclarations.get(0),localFieldG1);
          boolean avoidPullUpDueToSerialization2=avoidPullUpFieldDueToSerialization(sourceTypeDeclarations.get(1),localFieldG2);
          if (!avoidPullUpDueToSerialization1 && !avoidPullUpDueToSerialization2) {
            if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              fieldDeclarationsToBePulledUp.get(0).add(localFieldG1);
            }
            if (!sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              fieldDeclarationsToBePulledUp.get(1).add(localFieldG2);
            }
            if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
              typeBindings.add(localFieldG1.resolveBinding().getType());
              getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
              VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
              sourceRewriter.set(fragment,VariableDeclarationFragment.NAME_PROPERTY,ast.newSimpleName(localFieldG1.getName().getIdentifier()),null);
              if (localFieldG1.getInitializer() != null && localFieldG2.getInitializer() != null) {
                Expression initializer1=localFieldG1.getInitializer();
                Expression initializer2=localFieldG2.getInitializer();
                if (initializer1.subtreeMatch(new ASTMatcher(),initializer2)) {
                  sourceRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,ASTNode.copySubtree(ast,initializer1),null);
                }
              }
              FieldDeclaration newFieldDeclaration=ast.newFieldDeclaration(fragment);
              sourceRewriter.set(newFieldDeclaration,FieldDeclaration.TYPE_PROPERTY,originalFieldDeclarationG1.getType(),null);
              if (originalFieldDeclarationG1.getJavadoc() != null) {
                sourceRewriter.set(newFieldDeclaration,FieldDeclaration.JAVADOC_PROPERTY,originalFieldDeclarationG1.getJavadoc(),null);
              }
              ListRewrite newFieldDeclarationModifiersRewrite=sourceRewriter.getListRewrite(newFieldDeclaration,FieldDeclaration.MODIFIERS2_PROPERTY);
              newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
              List<IExtendedModifier> originalModifiers=originalFieldDeclarationG1.modifiers();
              for (              IExtendedModifier extendedModifier : originalModifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.isFinal()) {
                    newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.FINAL_KEYWORD),null);
                  }
 else                   if (modifier.isStatic()) {
                    newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD),null);
                  }
 else                   if (modifier.isTransient()) {
                    newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.TRANSIENT_KEYWORD),null);
                  }
 else                   if (modifier.isVolatile()) {
                    newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.VOLATILE_KEYWORD),null);
                  }
                }
              }
              bodyDeclarationsRewrite.insertLast(newFieldDeclaration,null);
            }
          }
 else {
            fieldDeclarationsToBeParameterized.get(0).add(localFieldG1);
            fieldDeclarationsToBeParameterized.get(1).add(localFieldG2);
            Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
            typeBindings.add(localFieldG1.resolveBinding().getType());
            getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
          }
          break;
        }
      }
    }
  }
}"
12063,"private void extractClone(){
  this.cloneInfo=new CloneInformation();
  ITypeBinding commonSuperTypeOfSourceTypeDeclarations=null;
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding())) {
    cloneInfo.sourceCompilationUnit=sourceCompilationUnits.get(0);
    cloneInfo.sourceICompilationUnit=(ICompilationUnit)cloneInfo.sourceCompilationUnit.getJavaElement();
    cloneInfo.sourceTypeDeclaration=sourceTypeDeclarations.get(0);
    cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
    cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
  }
 else {
    ITypeBinding typeBinding1=sourceTypeDeclarations.get(0).resolveBinding();
    ITypeBinding typeBinding2=sourceTypeDeclarations.get(1).resolveBinding();
    commonSuperTypeOfSourceTypeDeclarations=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
    if (commonSuperTypeOfSourceTypeDeclarations != null) {
      if (pullUpToCommonSuperclass(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2)) {
        IJavaElement javaElement=commonSuperTypeOfSourceTypeDeclarations.getJavaElement();
        javaElementsToOpenInEditor.add(javaElement);
        ICompilationUnit iCompilationUnit=(ICompilationUnit)javaElement.getParent();
        ASTParser parser=ASTParser.newParser(AST.JLS4);
        parser.setKind(ASTParser.K_COMPILATION_UNIT);
        parser.setSource(iCompilationUnit);
        parser.setResolveBindings(true);
        CompilationUnit compilationUnit=(CompilationUnit)parser.createAST(null);
        List<AbstractTypeDeclaration> typeDeclarations=compilationUnit.types();
        for (        AbstractTypeDeclaration abstractTypeDeclaration : typeDeclarations) {
          if (abstractTypeDeclaration instanceof TypeDeclaration) {
            TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
            if (typeDeclaration.resolveBinding().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)) {
              cloneInfo.sourceCompilationUnit=compilationUnit;
              cloneInfo.sourceICompilationUnit=iCompilationUnit;
              cloneInfo.sourceTypeDeclaration=typeDeclaration;
              cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
              cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
              cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses=!superclassDirectlyInheritedFromRefactoredSubclasses(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2);
              break;
            }
          }
        }
        MultiTextEdit multiTextEdit=new MultiTextEdit();
        CompilationUnitChange compilationUnitChange=new CompilationUnitChange(""String_Node_Str"",iCompilationUnit);
        compilationUnitChange.setEdit(multiTextEdit);
        compilationUnitChanges.put(iCompilationUnit,compilationUnitChange);
      }
 else {
        if (extractToUtilityClass(commonSuperTypeOfSourceTypeDeclarations)) {
          cloneInfo.extractUtilityClass=true;
        }
        if (cloneInfo.extractUtilityClass) {
          cloneInfo.intermediateClassName=""String_Node_Str"";
        }
 else {
          cloneInfo.intermediateClassName=""String_Node_Str"" + commonSuperTypeOfSourceTypeDeclarations.getName();
        }
        ClassObject commonSuperType=ASTReader.getSystemObject().getClassObject(commonSuperTypeOfSourceTypeDeclarations.getQualifiedName());
        CompilationUnit compilationUnit=null;
        if (commonSuperType != null) {
          compilationUnit=findCompilationUnit(commonSuperType.getAbstractTypeDeclaration());
        }
 else {
          compilationUnit=sourceCompilationUnits.get(0);
        }
        if (compilationUnit.getPackage() != null) {
          cloneInfo.intermediateClassPackageBinding=compilationUnit.getPackage().resolveBinding();
        }
        ICompilationUnit iCompilationUnit=(ICompilationUnit)compilationUnit.getJavaElement();
        IContainer container=(IContainer)iCompilationUnit.getResource().getParent();
        if (container instanceof IProject) {
          IProject contextProject=(IProject)container;
          cloneInfo.file=contextProject.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
 else         if (container instanceof IFolder) {
          IFolder contextFolder=(IFolder)container;
          cloneInfo.file=contextFolder.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
        boolean intermediateAlreadyExists=false;
        ICompilationUnit intermediateICompilationUnit=JavaCore.createCompilationUnitFrom(cloneInfo.file);
        javaElementsToOpenInEditor.add(intermediateICompilationUnit);
        ASTParser intermediateParser=ASTParser.newParser(AST.JLS4);
        intermediateParser.setKind(ASTParser.K_COMPILATION_UNIT);
        if (cloneInfo.file.exists()) {
          intermediateAlreadyExists=true;
          intermediateParser.setSource(intermediateICompilationUnit);
          intermediateParser.setResolveBindings(true);
        }
 else {
          cloneInfo.document=new Document();
          intermediateParser.setSource(cloneInfo.document.get().toCharArray());
        }
        CompilationUnit intermediateCompilationUnit=(CompilationUnit)intermediateParser.createAST(null);
        AST intermediateAST=intermediateCompilationUnit.getAST();
        ASTRewrite intermediateRewriter=ASTRewrite.create(intermediateAST);
        ListRewrite intermediateTypesRewrite=intermediateRewriter.getListRewrite(intermediateCompilationUnit,CompilationUnit.TYPES_PROPERTY);
        TypeDeclaration intermediateTypeDeclaration=null;
        if (intermediateAlreadyExists) {
          List<AbstractTypeDeclaration> abstractTypeDeclarations=intermediateCompilationUnit.types();
          for (          AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
            if (abstractTypeDeclaration instanceof TypeDeclaration) {
              TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
              if (typeDeclaration.getName().getIdentifier().equals(cloneInfo.intermediateClassName)) {
                intermediateTypeDeclaration=typeDeclaration;
                int intermediateModifiers=intermediateTypeDeclaration.getModifiers();
                if ((intermediateModifiers & Modifier.ABSTRACT) == 0 && !cloneInfo.extractUtilityClass) {
                  ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
                  intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
                }
                break;
              }
            }
          }
          MultiTextEdit intermediateMultiTextEdit=new MultiTextEdit();
          CompilationUnitChange intermediateCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",intermediateICompilationUnit);
          intermediateCompilationUnitChange.setEdit(intermediateMultiTextEdit);
          compilationUnitChanges.put(intermediateICompilationUnit,intermediateCompilationUnitChange);
        }
 else {
          if (compilationUnit.getPackage() != null) {
            intermediateRewriter.set(intermediateCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,compilationUnit.getPackage(),null);
          }
          intermediateTypeDeclaration=intermediateAST.newTypeDeclaration();
          SimpleName intermediateName=intermediateAST.newSimpleName(cloneInfo.intermediateClassName);
          intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.NAME_PROPERTY,intermediateName,null);
          ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
          intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
          if (!cloneInfo.extractUtilityClass) {
            intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
            intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,intermediateAST.newSimpleType(intermediateAST.newSimpleName(commonSuperTypeOfSourceTypeDeclarations.getName())),null);
          }
          intermediateTypesRewrite.insertLast(intermediateTypeDeclaration,null);
        }
        cloneInfo.sourceCompilationUnit=intermediateCompilationUnit;
        cloneInfo.sourceICompilationUnit=intermediateICompilationUnit;
        cloneInfo.sourceTypeDeclaration=intermediateTypeDeclaration;
        cloneInfo.sourceRewriter=intermediateRewriter;
        cloneInfo.ast=intermediateAST;
      }
    }
  }
  ASTRewrite sourceRewriter=cloneInfo.sourceRewriter;
  AST ast=cloneInfo.ast;
  TypeDeclaration sourceTypeDeclaration=cloneInfo.sourceTypeDeclaration;
  MethodDeclaration sourceMethodDeclaration=sourceMethodDeclarations.get(0);
  Set<ITypeBinding> requiredImportTypeBindings=new LinkedHashSet<ITypeBinding>();
  ListRewrite bodyDeclarationsRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  if (commonSuperTypeOfSourceTypeDeclarations != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding())) {
    Set<VariableDeclaration> accessedLocalFieldsG1=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> accessedLocalFieldsG2=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    pullUpLocallyAccessedFields(accessedLocalFieldsG1,accessedLocalFieldsG2,bodyDeclarationsRewrite,requiredImportTypeBindings);
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG1=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG2=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    Set<MethodObject> accessedLocalMethodsG1=mapper.getAccessedLocalMethodsG1();
    Set<MethodObject> accessedLocalMethodsG2=mapper.getAccessedLocalMethodsG2();
    for (    MethodObject localMethodG1 : accessedLocalMethodsG1) {
      for (      MethodObject localMethodG2 : accessedLocalMethodsG2) {
        if (localMethodG1.getName().equals(localMethodG2.getName()) && localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) && localMethodG1.getParameterTypeList().equals(localMethodG2.getParameterTypeList())) {
          MethodDeclaration methodDeclaration1=localMethodG1.getMethodDeclaration();
          MethodDeclaration methodDeclaration2=localMethodG2.getMethodDeclaration();
          Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
          boolean clones=type2Clones(methodDeclaration1,methodDeclaration2);
          Type returnType=methodDeclaration1.getReturnType2();
          TypeDeclaration typeDeclaration1=findTypeDeclaration(methodDeclaration1);
          TypeDeclaration typeDeclaration2=findTypeDeclaration(methodDeclaration2);
          if (clones) {
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              bodyDeclarationsRewrite.insertLast(methodDeclaration1,null);
              TypeVisitor typeVisitor=new TypeVisitor();
              methodDeclaration1.accept(typeVisitor);
              typeBindings.addAll(typeVisitor.getTypeBindings());
              Set<VariableDeclaration> fieldsAccessedInMethod1=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG1,methodDeclaration1);
              fieldsAccessedInMethod1.removeAll(accessedLocalFieldsG1);
              Set<VariableDeclaration> fieldsAccessedInMethod2=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG2,methodDeclaration2);
              fieldsAccessedInMethod2.removeAll(accessedLocalFieldsG2);
              pullUpLocallyAccessedFields(fieldsAccessedInMethod1,fieldsAccessedInMethod2,bodyDeclarationsRewrite,requiredImportTypeBindings);
            }
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              methodDeclarationsToBePulledUp.get(0).add(methodDeclaration1);
            }
            if (!typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              methodDeclarationsToBePulledUp.get(1).add(methodDeclaration2);
            }
          }
 else {
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
              sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(methodDeclaration1.getName().getIdentifier()),null);
              sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
              typeBindings.add(returnType.resolveBinding());
              ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
              List<IExtendedModifier> originalModifiers=methodDeclaration1.modifiers();
              for (              IExtendedModifier extendedModifier : originalModifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.isProtected()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                    if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) == 0) {
                      updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                    }
                  }
 else                   if (modifier.isPublic()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
                    if ((methodDeclaration2.getModifiers() & Modifier.PUBLIC) == 0) {
                      updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PUBLIC_KEYWORD);
                    }
                  }
                }
              }
              if (cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses) {
                Block methodBody=ast.newBlock();
                sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodBody,null);
                Expression returnedExpression=generateDefaultValue(sourceRewriter,ast,returnType);
                if (returnedExpression != null) {
                  ReturnStatement returnStatement=ast.newReturnStatement();
                  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedExpression,null);
                  ListRewrite statementsRewrite=sourceRewriter.getListRewrite(methodBody,Block.STATEMENTS_PROPERTY);
                  statementsRewrite.insertLast(returnStatement,null);
                }
              }
 else {
                modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
              }
              ListRewrite parametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
              List<SingleVariableDeclaration> parameters=methodDeclaration1.parameters();
              for (              SingleVariableDeclaration parameter : parameters) {
                parametersRewrite.insertLast(parameter,null);
                typeBindings.add(parameter.getType().resolveBinding());
              }
              ListRewrite thrownExceptionsRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
              List<Name> thrownExceptions=methodDeclaration1.thrownExceptions();
              for (              Name thrownException : thrownExceptions) {
                thrownExceptionsRewrite.insertLast(thrownException,null);
                typeBindings.add(thrownException.resolveTypeBinding());
              }
              bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
            }
          }
          getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
          break;
        }
      }
    }
  }
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  List<VariableDeclaration> returnedVariables1=this.returnedVariables.get(0);
  List<VariableDeclaration> returnedVariables2=this.returnedVariables.get(1);
  ITypeBinding returnTypeBinding=null;
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1) {
    Type returnType1=extractType(returnedVariables1.get(0));
    Type returnType2=extractType(returnedVariables2.get(0));
    if (returnType1.resolveBinding().isEqualTo(returnType2.resolveBinding()))     returnTypeBinding=returnType1.resolveBinding();
 else     returnTypeBinding=ASTNodeMatcher.commonSuperType(returnType1.resolveBinding(),returnType2.resolveBinding());
  }
 else {
    returnTypeBinding=findReturnTypeBinding();
  }
  if (returnTypeBinding != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(returnTypeBinding);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
    Type returnType=generateTypeFromTypeBinding(returnTypeBinding,ast,sourceRewriter);
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
  }
 else {
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
  }
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else   if (cloneInfo.extractUtilityClass) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
  if (((sourceMethodDeclarations.get(0).getModifiers() & Modifier.STATIC) != 0 && (sourceMethodDeclarations.get(1).getModifiers() & Modifier.STATIC) != 0) || cloneInfo.extractUtilityClass) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  List<Name> thrownExceptions1=sourceMethodDeclarations.get(0).thrownExceptions();
  List<Name> thrownExceptions2=sourceMethodDeclarations.get(1).thrownExceptions();
  for (  Name thrownException1 : thrownExceptions1) {
    for (    Name thrownException2 : thrownExceptions2) {
      if (thrownException1.resolveTypeBinding().isEqualTo(thrownException2.resolveTypeBinding())) {
        thrownExceptionRewrite.insertLast(thrownException1,null);
        break;
      }
    }
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> commonPassedParameters=mapper.getCommonPassedParameters();
  for (  VariableBindingKeyPair parameterName : commonPassedParameters.keySet()) {
    ArrayList<VariableDeclaration> variableDeclarations=commonPassedParameters.get(parameterName);
    VariableDeclaration variableDeclaration1=variableDeclarations.get(0);
    VariableDeclaration variableDeclaration2=variableDeclarations.get(1);
    if (parameterIsUsedByNodesWithoutDifferences(variableDeclaration1,variableDeclaration2)) {
      if (!variableDeclaration1.resolveBinding().isField() && !variableDeclaration2.resolveBinding().isField()) {
        ITypeBinding typeBinding1=extractType(variableDeclaration1).resolveBinding();
        ITypeBinding typeBinding2=extractType(variableDeclaration2).resolveBinding();
        ITypeBinding typeBinding=null;
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
        Type variableType=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(typeBinding);
        getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration1.getName(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
        parameterRewrite.insertLast(parameter,null);
        originalPassedParameters.put(parameterName,variableDeclarations);
      }
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode1=pdgNodeMapping.getNodeG1();
    Statement statement1=pdgNode1.getASTStatement();
    TypeVisitor typeVisitor1=new TypeVisitor();
    statement1.accept(typeVisitor1);
    getSimpleTypeBindings(typeVisitor1.getTypeBindings(),requiredImportTypeBindings);
    PDGNode pdgNode2=pdgNodeMapping.getNodeG2();
    Statement statement2=pdgNode2.getASTStatement();
    TypeVisitor typeVisitor2=new TypeVisitor();
    statement2.accept(typeVisitor2);
    getSimpleTypeBindings(typeVisitor2.getTypeBindings(),requiredImportTypeBindings);
  }
  CloneStructureNode root=mapper.getCloneStructureRoot();
  for (  CloneStructureNode child : root.getChildren()) {
    if (child.getMapping() instanceof PDGNodeMapping) {
      Statement statement=processCloneStructureNode(child,ast,sourceRewriter);
      methodBodyRewrite.insertLast(statement,null);
    }
  }
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1 && !mappedNodesContainStatementReturningVariable(returnedVariables1.get(0),returnedVariables2.get(0))) {
    ReturnStatement returnStatement=ast.newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariables1.get(0).getName(),null);
    methodBodyRewrite.insertLast(returnStatement,null);
    if (!mappedNodesContainStatementDeclaringVariable(returnedVariables1.get(0),returnedVariables2.get(0)) && !variableIsPassedAsCommonParameter(returnedVariables1.get(0),returnedVariables2.get(0))) {
      Type returnedType=extractType(returnedVariables1.get(0));
      Expression initializer=generateDefaultValue(sourceRewriter,ast,returnedType);
      VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(fragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariables1.get(0).getName(),null);
      sourceRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,initializer,null);
      VariableDeclarationStatement declarationStatement=ast.newVariableDeclarationStatement(fragment);
      sourceRewriter.set(declarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedType,null);
      methodBodyRewrite.insertFirst(declarationStatement,null);
    }
  }
  int i=0;
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    AbstractExpression expression1=difference.getExpression1();
    AbstractExpression expression2=difference.getExpression2();
    boolean isReturnedVariable=false;
    if (expression1 != null) {
      isReturnedVariable=isReturnedVariable(expression1.getExpression(),this.returnedVariables.get(0));
    }
 else     if (expression2 != null) {
      isReturnedVariable=isReturnedVariable(expression2.getExpression(),this.returnedVariables.get(1));
    }
    ITypeBinding typeBinding1=expression1 != null ? expression1.getExpression().resolveTypeBinding() : expression2.getExpression().resolveTypeBinding();
    ITypeBinding typeBinding2=expression2 != null ? expression2.getExpression().resolveTypeBinding() : expression1.getExpression().resolveTypeBinding();
    if (!isReturnedVariable) {
      ITypeBinding typeBinding=null;
      if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH) || differenceContainsSubDifferenceWithSubclassTypeMismatch(difference)) {
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
      }
 else {
        if (expression1 != null && !typeBinding1.getQualifiedName().equals(""String_Node_Str"")) {
          typeBinding=typeBinding1;
        }
 else {
          typeBinding=typeBinding2;
        }
      }
      Type type=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
      Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
      typeBindings.add(typeBinding);
      getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(""String_Node_Str"" + i),null);
      i++;
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  for (  VariableDeclaration variableDeclaration : fieldDeclarationsToBeParameterized.get(0)) {
    SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
    Type type=generateTypeFromTypeBinding(variableDeclaration.resolveBinding().getType(),ast,sourceRewriter);
    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration.getName(),null);
    parameterRewrite.insertLast(parameter,null);
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
  cloneInfo.requiredImportTypeBindings=requiredImportTypeBindings;
  cloneInfo.methodBodyRewrite=methodBodyRewrite;
  cloneInfo.parameterRewrite=parameterRewrite;
}","private void extractClone(){
  this.cloneInfo=new CloneInformation();
  ITypeBinding commonSuperTypeOfSourceTypeDeclarations=null;
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding())) {
    cloneInfo.sourceCompilationUnit=sourceCompilationUnits.get(0);
    cloneInfo.sourceICompilationUnit=(ICompilationUnit)cloneInfo.sourceCompilationUnit.getJavaElement();
    cloneInfo.sourceTypeDeclaration=sourceTypeDeclarations.get(0);
    cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
    cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
  }
 else {
    ITypeBinding typeBinding1=sourceTypeDeclarations.get(0).resolveBinding();
    ITypeBinding typeBinding2=sourceTypeDeclarations.get(1).resolveBinding();
    commonSuperTypeOfSourceTypeDeclarations=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
    if (commonSuperTypeOfSourceTypeDeclarations != null) {
      if (pullUpToCommonSuperclass(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2)) {
        IJavaElement javaElement=commonSuperTypeOfSourceTypeDeclarations.getJavaElement();
        javaElementsToOpenInEditor.add(javaElement);
        ICompilationUnit iCompilationUnit=(ICompilationUnit)javaElement.getParent();
        ASTParser parser=ASTParser.newParser(AST.JLS4);
        parser.setKind(ASTParser.K_COMPILATION_UNIT);
        parser.setSource(iCompilationUnit);
        parser.setResolveBindings(true);
        CompilationUnit compilationUnit=(CompilationUnit)parser.createAST(null);
        List<AbstractTypeDeclaration> typeDeclarations=compilationUnit.types();
        for (        AbstractTypeDeclaration abstractTypeDeclaration : typeDeclarations) {
          if (abstractTypeDeclaration instanceof TypeDeclaration) {
            TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
            if (typeDeclaration.resolveBinding().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)) {
              cloneInfo.sourceCompilationUnit=compilationUnit;
              cloneInfo.sourceICompilationUnit=iCompilationUnit;
              cloneInfo.sourceTypeDeclaration=typeDeclaration;
              cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
              cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
              cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses=!superclassDirectlyInheritedFromRefactoredSubclasses(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2);
              break;
            }
          }
        }
        MultiTextEdit multiTextEdit=new MultiTextEdit();
        CompilationUnitChange compilationUnitChange=new CompilationUnitChange(""String_Node_Str"",iCompilationUnit);
        compilationUnitChange.setEdit(multiTextEdit);
        compilationUnitChanges.put(iCompilationUnit,compilationUnitChange);
      }
 else {
        if (extractToUtilityClass(commonSuperTypeOfSourceTypeDeclarations)) {
          cloneInfo.extractUtilityClass=true;
        }
        if (cloneInfo.extractUtilityClass) {
          cloneInfo.intermediateClassName=""String_Node_Str"";
        }
 else {
          cloneInfo.intermediateClassName=""String_Node_Str"" + commonSuperTypeOfSourceTypeDeclarations.getName();
        }
        ClassObject commonSuperType=ASTReader.getSystemObject().getClassObject(commonSuperTypeOfSourceTypeDeclarations.getQualifiedName());
        CompilationUnit compilationUnit=null;
        if (commonSuperType != null) {
          compilationUnit=findCompilationUnit(commonSuperType.getAbstractTypeDeclaration());
        }
 else {
          compilationUnit=sourceCompilationUnits.get(0);
        }
        if (compilationUnit.getPackage() != null) {
          cloneInfo.intermediateClassPackageBinding=compilationUnit.getPackage().resolveBinding();
        }
        ICompilationUnit iCompilationUnit=(ICompilationUnit)compilationUnit.getJavaElement();
        IContainer container=(IContainer)iCompilationUnit.getResource().getParent();
        if (container instanceof IProject) {
          IProject contextProject=(IProject)container;
          cloneInfo.file=contextProject.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
 else         if (container instanceof IFolder) {
          IFolder contextFolder=(IFolder)container;
          cloneInfo.file=contextFolder.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
        boolean intermediateAlreadyExists=false;
        ICompilationUnit intermediateICompilationUnit=JavaCore.createCompilationUnitFrom(cloneInfo.file);
        javaElementsToOpenInEditor.add(intermediateICompilationUnit);
        ASTParser intermediateParser=ASTParser.newParser(AST.JLS4);
        intermediateParser.setKind(ASTParser.K_COMPILATION_UNIT);
        if (cloneInfo.file.exists()) {
          intermediateAlreadyExists=true;
          intermediateParser.setSource(intermediateICompilationUnit);
          intermediateParser.setResolveBindings(true);
        }
 else {
          cloneInfo.document=new Document();
          intermediateParser.setSource(cloneInfo.document.get().toCharArray());
        }
        CompilationUnit intermediateCompilationUnit=(CompilationUnit)intermediateParser.createAST(null);
        AST intermediateAST=intermediateCompilationUnit.getAST();
        ASTRewrite intermediateRewriter=ASTRewrite.create(intermediateAST);
        ListRewrite intermediateTypesRewrite=intermediateRewriter.getListRewrite(intermediateCompilationUnit,CompilationUnit.TYPES_PROPERTY);
        TypeDeclaration intermediateTypeDeclaration=null;
        if (intermediateAlreadyExists) {
          List<AbstractTypeDeclaration> abstractTypeDeclarations=intermediateCompilationUnit.types();
          for (          AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
            if (abstractTypeDeclaration instanceof TypeDeclaration) {
              TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
              if (typeDeclaration.getName().getIdentifier().equals(cloneInfo.intermediateClassName)) {
                intermediateTypeDeclaration=typeDeclaration;
                int intermediateModifiers=intermediateTypeDeclaration.getModifiers();
                if ((intermediateModifiers & Modifier.ABSTRACT) == 0 && !cloneInfo.extractUtilityClass) {
                  ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
                  intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
                }
                break;
              }
            }
          }
          MultiTextEdit intermediateMultiTextEdit=new MultiTextEdit();
          CompilationUnitChange intermediateCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",intermediateICompilationUnit);
          intermediateCompilationUnitChange.setEdit(intermediateMultiTextEdit);
          compilationUnitChanges.put(intermediateICompilationUnit,intermediateCompilationUnitChange);
        }
 else {
          if (compilationUnit.getPackage() != null) {
            intermediateRewriter.set(intermediateCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,compilationUnit.getPackage(),null);
          }
          intermediateTypeDeclaration=intermediateAST.newTypeDeclaration();
          SimpleName intermediateName=intermediateAST.newSimpleName(cloneInfo.intermediateClassName);
          intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.NAME_PROPERTY,intermediateName,null);
          ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
          intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
          if (!cloneInfo.extractUtilityClass) {
            intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
            intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,intermediateAST.newSimpleType(intermediateAST.newSimpleName(commonSuperTypeOfSourceTypeDeclarations.getName())),null);
          }
          intermediateTypesRewrite.insertLast(intermediateTypeDeclaration,null);
        }
        cloneInfo.sourceCompilationUnit=intermediateCompilationUnit;
        cloneInfo.sourceICompilationUnit=intermediateICompilationUnit;
        cloneInfo.sourceTypeDeclaration=intermediateTypeDeclaration;
        cloneInfo.sourceRewriter=intermediateRewriter;
        cloneInfo.ast=intermediateAST;
      }
    }
  }
  ASTRewrite sourceRewriter=cloneInfo.sourceRewriter;
  AST ast=cloneInfo.ast;
  TypeDeclaration sourceTypeDeclaration=cloneInfo.sourceTypeDeclaration;
  MethodDeclaration sourceMethodDeclaration=sourceMethodDeclarations.get(0);
  Set<ITypeBinding> requiredImportTypeBindings=new LinkedHashSet<ITypeBinding>();
  ListRewrite bodyDeclarationsRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  if (commonSuperTypeOfSourceTypeDeclarations != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  Set<VariableDeclaration> accessedLocalFieldsG1=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
  Set<VariableDeclaration> accessedLocalFieldsG2=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
  if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding())) {
    pullUpLocallyAccessedFields(accessedLocalFieldsG1,accessedLocalFieldsG2,bodyDeclarationsRewrite,requiredImportTypeBindings);
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG1=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG2=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    Set<MethodObject> accessedLocalMethodsG1=mapper.getAccessedLocalMethodsG1();
    Set<MethodObject> accessedLocalMethodsG2=mapper.getAccessedLocalMethodsG2();
    for (    MethodObject localMethodG1 : accessedLocalMethodsG1) {
      for (      MethodObject localMethodG2 : accessedLocalMethodsG2) {
        if (localMethodG1.getName().equals(localMethodG2.getName()) && localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) && localMethodG1.getParameterTypeList().equals(localMethodG2.getParameterTypeList())) {
          MethodDeclaration methodDeclaration1=localMethodG1.getMethodDeclaration();
          MethodDeclaration methodDeclaration2=localMethodG2.getMethodDeclaration();
          Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
          boolean clones=type2Clones(methodDeclaration1,methodDeclaration2);
          Type returnType=methodDeclaration1.getReturnType2();
          TypeDeclaration typeDeclaration1=findTypeDeclaration(methodDeclaration1);
          TypeDeclaration typeDeclaration2=findTypeDeclaration(methodDeclaration2);
          Set<VariableDeclaration> fieldsAccessedInMethod1=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG1,methodDeclaration1);
          Set<VariableDeclaration> fieldsAccessedInMethod2=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG2,methodDeclaration2);
          boolean avoidPullUpDueToSerialization1=avoidPullUpMethodDueToSerialization(sourceTypeDeclarations.get(0),fieldsAccessedInMethod1);
          boolean avoidPullUpDueToSerialization2=avoidPullUpMethodDueToSerialization(sourceTypeDeclarations.get(1),fieldsAccessedInMethod2);
          if (clones && !avoidPullUpDueToSerialization1 && !avoidPullUpDueToSerialization2) {
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              bodyDeclarationsRewrite.insertLast(methodDeclaration1,null);
              TypeVisitor typeVisitor=new TypeVisitor();
              methodDeclaration1.accept(typeVisitor);
              typeBindings.addAll(typeVisitor.getTypeBindings());
              fieldsAccessedInMethod1.removeAll(accessedLocalFieldsG1);
              fieldsAccessedInMethod2.removeAll(accessedLocalFieldsG2);
              pullUpLocallyAccessedFields(fieldsAccessedInMethod1,fieldsAccessedInMethod2,bodyDeclarationsRewrite,requiredImportTypeBindings);
            }
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              methodDeclarationsToBePulledUp.get(0).add(methodDeclaration1);
            }
            if (!typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              methodDeclarationsToBePulledUp.get(1).add(methodDeclaration2);
            }
          }
 else {
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
              sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(methodDeclaration1.getName().getIdentifier()),null);
              sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
              typeBindings.add(returnType.resolveBinding());
              ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
              List<IExtendedModifier> originalModifiers=methodDeclaration1.modifiers();
              for (              IExtendedModifier extendedModifier : originalModifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.isProtected()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                    if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) == 0) {
                      updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                    }
                  }
 else                   if (modifier.isPublic()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
                    if ((methodDeclaration2.getModifiers() & Modifier.PUBLIC) == 0) {
                      updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PUBLIC_KEYWORD);
                    }
                  }
                }
              }
              if (cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses) {
                Block methodBody=ast.newBlock();
                sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodBody,null);
                Expression returnedExpression=generateDefaultValue(sourceRewriter,ast,returnType);
                if (returnedExpression != null) {
                  ReturnStatement returnStatement=ast.newReturnStatement();
                  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedExpression,null);
                  ListRewrite statementsRewrite=sourceRewriter.getListRewrite(methodBody,Block.STATEMENTS_PROPERTY);
                  statementsRewrite.insertLast(returnStatement,null);
                }
              }
 else {
                modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
              }
              ListRewrite parametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
              List<SingleVariableDeclaration> parameters=methodDeclaration1.parameters();
              for (              SingleVariableDeclaration parameter : parameters) {
                parametersRewrite.insertLast(parameter,null);
                typeBindings.add(parameter.getType().resolveBinding());
              }
              ListRewrite thrownExceptionsRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
              List<Name> thrownExceptions=methodDeclaration1.thrownExceptions();
              for (              Name thrownException : thrownExceptions) {
                thrownExceptionsRewrite.insertLast(thrownException,null);
                typeBindings.add(thrownException.resolveTypeBinding());
              }
              bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
            }
          }
          getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
          break;
        }
      }
    }
  }
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  List<VariableDeclaration> returnedVariables1=this.returnedVariables.get(0);
  List<VariableDeclaration> returnedVariables2=this.returnedVariables.get(1);
  ITypeBinding returnTypeBinding=null;
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1) {
    Type returnType1=extractType(returnedVariables1.get(0));
    Type returnType2=extractType(returnedVariables2.get(0));
    if (returnType1.resolveBinding().isEqualTo(returnType2.resolveBinding()))     returnTypeBinding=returnType1.resolveBinding();
 else     returnTypeBinding=ASTNodeMatcher.commonSuperType(returnType1.resolveBinding(),returnType2.resolveBinding());
  }
 else {
    returnTypeBinding=findReturnTypeBinding();
  }
  if (returnTypeBinding != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(returnTypeBinding);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
    Type returnType=generateTypeFromTypeBinding(returnTypeBinding,ast,sourceRewriter);
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
  }
 else {
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
  }
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else   if (cloneInfo.extractUtilityClass) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
  if (((sourceMethodDeclarations.get(0).getModifiers() & Modifier.STATIC) != 0 && (sourceMethodDeclarations.get(1).getModifiers() & Modifier.STATIC) != 0) || cloneInfo.extractUtilityClass) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  List<Name> thrownExceptions1=sourceMethodDeclarations.get(0).thrownExceptions();
  List<Name> thrownExceptions2=sourceMethodDeclarations.get(1).thrownExceptions();
  for (  Name thrownException1 : thrownExceptions1) {
    for (    Name thrownException2 : thrownExceptions2) {
      if (thrownException1.resolveTypeBinding().isEqualTo(thrownException2.resolveTypeBinding())) {
        thrownExceptionRewrite.insertLast(thrownException1,null);
        break;
      }
    }
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> commonPassedParameters=mapper.getCommonPassedParameters();
  for (  VariableBindingKeyPair parameterName : commonPassedParameters.keySet()) {
    ArrayList<VariableDeclaration> variableDeclarations=commonPassedParameters.get(parameterName);
    VariableDeclaration variableDeclaration1=variableDeclarations.get(0);
    VariableDeclaration variableDeclaration2=variableDeclarations.get(1);
    if (parameterIsUsedByNodesWithoutDifferences(variableDeclaration1,variableDeclaration2)) {
      if (!variableDeclaration1.resolveBinding().isField() && !variableDeclaration2.resolveBinding().isField()) {
        ITypeBinding typeBinding1=extractType(variableDeclaration1).resolveBinding();
        ITypeBinding typeBinding2=extractType(variableDeclaration2).resolveBinding();
        ITypeBinding typeBinding=null;
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
        Type variableType=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(typeBinding);
        getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration1.getName(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
        parameterRewrite.insertLast(parameter,null);
        originalPassedParameters.put(parameterName,variableDeclarations);
      }
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode1=pdgNodeMapping.getNodeG1();
    Statement statement1=pdgNode1.getASTStatement();
    TypeVisitor typeVisitor1=new TypeVisitor();
    statement1.accept(typeVisitor1);
    getSimpleTypeBindings(typeVisitor1.getTypeBindings(),requiredImportTypeBindings);
    PDGNode pdgNode2=pdgNodeMapping.getNodeG2();
    Statement statement2=pdgNode2.getASTStatement();
    TypeVisitor typeVisitor2=new TypeVisitor();
    statement2.accept(typeVisitor2);
    getSimpleTypeBindings(typeVisitor2.getTypeBindings(),requiredImportTypeBindings);
  }
  CloneStructureNode root=mapper.getCloneStructureRoot();
  for (  CloneStructureNode child : root.getChildren()) {
    if (child.getMapping() instanceof PDGNodeMapping) {
      Statement statement=processCloneStructureNode(child,ast,sourceRewriter);
      methodBodyRewrite.insertLast(statement,null);
    }
  }
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1 && !mappedNodesContainStatementReturningVariable(returnedVariables1.get(0),returnedVariables2.get(0))) {
    ReturnStatement returnStatement=ast.newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariables1.get(0).getName(),null);
    methodBodyRewrite.insertLast(returnStatement,null);
    if (!mappedNodesContainStatementDeclaringVariable(returnedVariables1.get(0),returnedVariables2.get(0)) && !variableIsPassedAsCommonParameter(returnedVariables1.get(0),returnedVariables2.get(0))) {
      Type returnedType=extractType(returnedVariables1.get(0));
      Expression initializer=generateDefaultValue(sourceRewriter,ast,returnedType);
      VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(fragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariables1.get(0).getName(),null);
      sourceRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,initializer,null);
      VariableDeclarationStatement declarationStatement=ast.newVariableDeclarationStatement(fragment);
      sourceRewriter.set(declarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedType,null);
      methodBodyRewrite.insertFirst(declarationStatement,null);
    }
  }
  int i=0;
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    AbstractExpression expression1=difference.getExpression1();
    AbstractExpression expression2=difference.getExpression2();
    boolean isReturnedVariable=false;
    if (expression1 != null) {
      isReturnedVariable=isReturnedVariable(expression1.getExpression(),this.returnedVariables.get(0));
    }
 else     if (expression2 != null) {
      isReturnedVariable=isReturnedVariable(expression2.getExpression(),this.returnedVariables.get(1));
    }
    ITypeBinding typeBinding1=expression1 != null ? expression1.getExpression().resolveTypeBinding() : expression2.getExpression().resolveTypeBinding();
    ITypeBinding typeBinding2=expression2 != null ? expression2.getExpression().resolveTypeBinding() : expression1.getExpression().resolveTypeBinding();
    if (!isReturnedVariable) {
      ITypeBinding typeBinding=null;
      if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH) || differenceContainsSubDifferenceWithSubclassTypeMismatch(difference)) {
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
      }
 else {
        if (expression1 != null && !typeBinding1.getQualifiedName().equals(""String_Node_Str"")) {
          typeBinding=typeBinding1;
        }
 else {
          typeBinding=typeBinding2;
        }
      }
      Type type=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
      Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
      typeBindings.add(typeBinding);
      getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(""String_Node_Str"" + i),null);
      i++;
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  for (  VariableDeclaration variableDeclaration : fieldDeclarationsToBeParameterized.get(0)) {
    if (accessedLocalFieldsG1.contains(variableDeclaration)) {
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      Type type=generateTypeFromTypeBinding(variableDeclaration.resolveBinding().getType(),ast,sourceRewriter);
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration.getName(),null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
  cloneInfo.requiredImportTypeBindings=requiredImportTypeBindings;
  cloneInfo.methodBodyRewrite=methodBodyRewrite;
  cloneInfo.parameterRewrite=parameterRewrite;
}"
12064,"public Set<IType> getSubTypes(IType superType){
  if (subTypeMap.containsKey(superType)) {
    Set<IType> subTypes=subTypeMap.get(superType);
    LinkedHashSet<IType> subTypesOfAbstractSubTypes=new LinkedHashSet<IType>();
    try {
      for (      IType subType : subTypes) {
        if (Flags.isAbstract(subType.getFlags()) && !subType.equals(superType)) {
          subTypesOfAbstractSubTypes.addAll(getSubTypes(subType));
        }
      }
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
    }
    LinkedHashSet<IType> finalSubTypes=new LinkedHashSet<IType>();
    finalSubTypes.addAll(subTypes);
    finalSubTypes.addAll(subTypesOfAbstractSubTypes);
    return finalSubTypes;
  }
 else {
    IPackageFragment packageFragment=superType.getPackageFragment();
    final LinkedHashSet<IType> subTypes=new LinkedHashSet<IType>();
    final LinkedHashSet<IType> subTypesOfAbstractSubTypes=new LinkedHashSet<IType>();
    try {
      SearchPattern searchPattern=SearchPattern.createPattern(superType,IJavaSearchConstants.IMPLEMENTORS);
      SearchEngine searchEngine=new SearchEngine();
      IJavaSearchScope scope=null;
      if (packageFragment.getElementName().equals(""String_Node_Str"") || packageFragment.getElementName().equals(""String_Node_Str"") || packageFragment.getElementName().equals(""String_Node_Str"")|| packageFragment.getElementName().equals(""String_Node_Str""))       scope=SearchEngine.createJavaSearchScope(new IJavaElement[]{packageFragment},false);
 else       scope=SearchEngine.createHierarchyScope(superType);
      SearchRequestor requestor=new TypeSearchRequestor(subTypes);
      searchEngine.search(searchPattern,new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},scope,requestor,null);
      subTypeMap.put(superType,subTypes);
      for (      IType subType : subTypes) {
        if (Flags.isAbstract(subType.getFlags()) && !subType.equals(superType)) {
          subTypesOfAbstractSubTypes.addAll(getSubTypes(subType));
        }
      }
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
    }
catch (    CoreException e) {
      e.printStackTrace();
    }
    LinkedHashSet<IType> finalSubTypes=new LinkedHashSet<IType>();
    finalSubTypes.addAll(subTypes);
    finalSubTypes.addAll(subTypesOfAbstractSubTypes);
    return finalSubTypes;
  }
}","public Set<IType> getSubTypes(IType superType){
  if (subTypeMap.containsKey(superType)) {
    Set<IType> subTypes=subTypeMap.get(superType);
    LinkedHashSet<IType> subTypesOfAbstractSubTypes=new LinkedHashSet<IType>();
    try {
      for (      IType subType : subTypes) {
        if (Flags.isAbstract(subType.getFlags()) && !subType.equals(superType)) {
          subTypesOfAbstractSubTypes.addAll(getSubTypes(subType));
        }
      }
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
    }
    LinkedHashSet<IType> finalSubTypes=new LinkedHashSet<IType>();
    finalSubTypes.addAll(subTypes);
    finalSubTypes.addAll(subTypesOfAbstractSubTypes);
    return finalSubTypes;
  }
 else {
    IPackageFragment packageFragment=superType.getPackageFragment();
    final LinkedHashSet<IType> subTypes=new LinkedHashSet<IType>();
    final LinkedHashSet<IType> subTypesOfAbstractSubTypes=new LinkedHashSet<IType>();
    try {
      SearchPattern searchPattern=SearchPattern.createPattern(superType,IJavaSearchConstants.IMPLEMENTORS);
      SearchEngine searchEngine=new SearchEngine();
      IJavaSearchScope scope=null;
      String packageFragmentName=packageFragment.getElementName();
      if (packageFragmentName.equals(""String_Node_Str"") || packageFragmentName.equals(""String_Node_Str"") || packageFragmentName.equals(""String_Node_Str"")|| packageFragmentName.equals(""String_Node_Str"")|| packageFragmentName.equals(""String_Node_Str""))       scope=SearchEngine.createJavaSearchScope(new IJavaElement[]{packageFragment},false);
 else       scope=SearchEngine.createHierarchyScope(superType);
      SearchRequestor requestor=new TypeSearchRequestor(subTypes);
      searchEngine.search(searchPattern,new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},scope,requestor,null);
      subTypeMap.put(superType,subTypes);
      for (      IType subType : subTypes) {
        if (Flags.isAbstract(subType.getFlags()) && !subType.equals(superType)) {
          subTypesOfAbstractSubTypes.addAll(getSubTypes(subType));
        }
      }
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
    }
catch (    CoreException e) {
      e.printStackTrace();
    }
    LinkedHashSet<IType> finalSubTypes=new LinkedHashSet<IType>();
    finalSubTypes.addAll(subTypes);
    finalSubTypes.addAll(subTypesOfAbstractSubTypes);
    return finalSubTypes;
  }
}"
12065,"public PDGSubTreeMapper(PDG pdg1,PDG pdg2,ICompilationUnit iCompilationUnit1,ICompilationUnit iCompilationUnit2,ControlDependenceTreeNode controlDependenceSubTreePDG1,ControlDependenceTreeNode controlDependenceSubTreePDG2,boolean fullTreeMatch,IProgressMonitor monitor){
  super(pdg1,pdg2,iCompilationUnit1,iCompilationUnit2,controlDependenceSubTreePDG1,controlDependenceSubTreePDG2,fullTreeMatch,monitor);
  this.pdg1=pdg1;
  this.pdg2=pdg2;
  this.iCompilationUnit1=iCompilationUnit1;
  this.iCompilationUnit2=iCompilationUnit2;
  this.nonMappedNodesG1=new TreeSet<PDGNode>();
  this.nonMappedNodesG2=new TreeSet<PDGNode>();
  this.commonPassedParameters=new LinkedHashMap<VariableBindingKeyPair,ArrayList<AbstractVariable>>();
  this.declaredLocalVariablesInMappedNodes=new LinkedHashMap<VariableBindingKeyPair,ArrayList<AbstractVariable>>();
  this.passedParametersG1=new LinkedHashSet<AbstractVariable>();
  this.passedParametersG2=new LinkedHashSet<AbstractVariable>();
  this.directlyAccessedLocalFieldsG1=new LinkedHashSet<AbstractVariable>();
  this.directlyAccessedLocalFieldsG2=new LinkedHashSet<AbstractVariable>();
  this.indirectlyAccessedLocalFieldsG1=new LinkedHashSet<AbstractVariable>();
  this.indirectlyAccessedLocalFieldsG2=new LinkedHashSet<AbstractVariable>();
  this.accessedLocalMethodsG1=new LinkedHashSet<MethodObject>();
  this.accessedLocalMethodsG2=new LinkedHashSet<MethodObject>();
  this.declaredVariablesInMappedNodesUsedByNonMappedNodesG1=new LinkedHashSet<AbstractVariable>();
  this.declaredVariablesInMappedNodesUsedByNonMappedNodesG2=new LinkedHashSet<AbstractVariable>();
  this.preconditionViolations=new ArrayList<PreconditionViolation>();
  this.renamedVariables=new LinkedHashSet<BindingSignaturePair>();
  this.nonMappedPDGNodesG1MovableBefore=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableBeforeAndAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableBefore=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableBeforeAndAfter=new TreeSet<PDGNode>();
  matchBasedOnControlDependenceTreeStructure();
  if (getMaximumStateWithMinimumDifferences() != null) {
    this.mappedNodesG1=getMaximumStateWithMinimumDifferences().getMappedNodesG1();
    this.mappedNodesG2=getMaximumStateWithMinimumDifferences().getMappedNodesG2();
    findNonMappedNodes(pdg1,getAllNodesInSubTreePDG1(),mappedNodesG1,nonMappedNodesG1);
    findNonMappedNodes(pdg2,getAllNodesInSubTreePDG2(),mappedNodesG2,nonMappedNodesG2);
    Set<PDGNode> additionallyMatchedNodesG1=new LinkedHashSet<PDGNode>();
    for (    PDGNode nodeG1 : nonMappedNodesG1) {
      boolean advancedMatch=getCloneStructureRoot().isGapNodeG1InAdditionalMatches(nodeG1);
      if (advancedMatch) {
        additionallyMatchedNodesG1.add(nodeG1);
      }
      PDGNodeGap nodeGap=new PDGNodeGap(nodeG1,null,advancedMatch);
      CloneStructureNode node=new CloneStructureNode(nodeGap);
      PDGBlockNode tryNode=pdg1.isDirectlyNestedWithinBlockNode(nodeG1);
      if (tryNode != null) {
        CloneStructureNode cloneStructureTry=getCloneStructureRoot().findNodeG1(tryNode);
        if (cloneStructureTry != null) {
          node.setParent(cloneStructureTry);
        }
      }
 else {
        getCloneStructureRoot().addGapChild(node);
      }
    }
    nonMappedNodesG1.removeAll(additionallyMatchedNodesG1);
    Set<PDGNode> additionallyMatchedNodesG2=new LinkedHashSet<PDGNode>();
    for (    PDGNode nodeG2 : nonMappedNodesG2) {
      boolean advancedMatch=getCloneStructureRoot().isGapNodeG2InAdditionalMatches(nodeG2);
      if (advancedMatch) {
        additionallyMatchedNodesG2.add(nodeG2);
      }
      PDGNodeGap nodeGap=new PDGNodeGap(null,nodeG2,advancedMatch);
      CloneStructureNode node=new CloneStructureNode(nodeGap);
      PDGBlockNode tryNode=pdg2.isDirectlyNestedWithinBlockNode(nodeG2);
      if (tryNode != null) {
        CloneStructureNode cloneStructureTry=getCloneStructureRoot().findNodeG2(tryNode);
        if (cloneStructureTry != null) {
          node.setParent(cloneStructureTry);
        }
      }
 else {
        getCloneStructureRoot().addGapChild(node);
      }
    }
    nonMappedNodesG2.removeAll(additionallyMatchedNodesG2);
    findDeclaredVariablesInMappedNodesUsedByNonMappedNodes(pdg1,mappedNodesG1,nonMappedNodesG1,declaredVariablesInMappedNodesUsedByNonMappedNodesG1);
    findDeclaredVariablesInMappedNodesUsedByNonMappedNodes(pdg2,mappedNodesG2,nonMappedNodesG2,declaredVariablesInMappedNodesUsedByNonMappedNodesG2);
    this.renamedVariables=findRenamedVariables();
    findPassedParameters();
    List<AbstractExpression> expressions1=new ArrayList<AbstractExpression>();
    List<AbstractExpression> expressions2=new ArrayList<AbstractExpression>();
    List<AbstractExpression> fieldAccessReplacedWithGetterExpressions1=new ArrayList<AbstractExpression>();
    List<AbstractExpression> fieldAccessReplacedWithGetterExpressions2=new ArrayList<AbstractExpression>();
    for (    ASTNodeDifference nodeDifference : getNodeDifferences()) {
      if (!nodeDifference.containsDifferenceType(DifferenceType.FIELD_ACCESS_REPLACED_WITH_GETTER)) {
        expressions1.add(nodeDifference.getExpression1());
        expressions2.add(nodeDifference.getExpression2());
      }
 else {
        fieldAccessReplacedWithGetterExpressions1.add(nodeDifference.getExpression1());
        fieldAccessReplacedWithGetterExpressions2.add(nodeDifference.getExpression2());
      }
    }
    ITypeBinding commonSuperclass=ASTNodeMatcher.commonSuperType(pdg1.getMethod().getMethodDeclaration().resolveBinding().getDeclaringClass(),pdg2.getMethod().getMethodDeclaration().resolveBinding().getDeclaringClass());
    findLocallyAccessedFields(pdg1,mappedNodesG1,commonSuperclass,directlyAccessedLocalFieldsG1,indirectlyAccessedLocalFieldsG1,accessedLocalMethodsG1,expressions1,fieldAccessReplacedWithGetterExpressions1);
    findLocallyAccessedFields(pdg2,mappedNodesG2,commonSuperclass,directlyAccessedLocalFieldsG2,indirectlyAccessedLocalFieldsG2,accessedLocalMethodsG2,expressions2,fieldAccessReplacedWithGetterExpressions2);
    this.variablesToBeReturnedG1=variablesToBeReturned(pdg1,getRemovableNodesG1());
    this.variablesToBeReturnedG2=variablesToBeReturned(pdg2,getRemovableNodesG2());
    checkCloneStructureNodeForPreconditions(getCloneStructureRoot());
    processNonMappedNodesMovableBeforeAndAfter();
    checkPreconditionsAboutReturnedVariables();
    checkIfAllPossibleExecutionFlowsEndInReturn();
  }
}","public PDGSubTreeMapper(PDG pdg1,PDG pdg2,ICompilationUnit iCompilationUnit1,ICompilationUnit iCompilationUnit2,ControlDependenceTreeNode controlDependenceSubTreePDG1,ControlDependenceTreeNode controlDependenceSubTreePDG2,boolean fullTreeMatch,IProgressMonitor monitor){
  super(pdg1,pdg2,iCompilationUnit1,iCompilationUnit2,controlDependenceSubTreePDG1,controlDependenceSubTreePDG2,fullTreeMatch,monitor);
  this.pdg1=pdg1;
  this.pdg2=pdg2;
  this.iCompilationUnit1=iCompilationUnit1;
  this.iCompilationUnit2=iCompilationUnit2;
  this.nonMappedNodesG1=new TreeSet<PDGNode>();
  this.nonMappedNodesG2=new TreeSet<PDGNode>();
  this.commonPassedParameters=new LinkedHashMap<VariableBindingKeyPair,ArrayList<AbstractVariable>>();
  this.declaredLocalVariablesInMappedNodes=new LinkedHashMap<VariableBindingKeyPair,ArrayList<AbstractVariable>>();
  this.passedParametersG1=new LinkedHashSet<AbstractVariable>();
  this.passedParametersG2=new LinkedHashSet<AbstractVariable>();
  this.directlyAccessedLocalFieldsG1=new LinkedHashSet<AbstractVariable>();
  this.directlyAccessedLocalFieldsG2=new LinkedHashSet<AbstractVariable>();
  this.indirectlyAccessedLocalFieldsG1=new LinkedHashSet<AbstractVariable>();
  this.indirectlyAccessedLocalFieldsG2=new LinkedHashSet<AbstractVariable>();
  this.accessedLocalMethodsG1=new LinkedHashSet<MethodObject>();
  this.accessedLocalMethodsG2=new LinkedHashSet<MethodObject>();
  this.declaredVariablesInMappedNodesUsedByNonMappedNodesG1=new LinkedHashSet<AbstractVariable>();
  this.declaredVariablesInMappedNodesUsedByNonMappedNodesG2=new LinkedHashSet<AbstractVariable>();
  this.preconditionViolations=new ArrayList<PreconditionViolation>();
  this.renamedVariables=new LinkedHashSet<BindingSignaturePair>();
  this.nonMappedPDGNodesG1MovableBefore=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableBeforeAndAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableBefore=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableBeforeAndAfter=new TreeSet<PDGNode>();
  matchBasedOnControlDependenceTreeStructure();
  if (getMaximumStateWithMinimumDifferences() != null) {
    this.mappedNodesG1=getMaximumStateWithMinimumDifferences().getMappedNodesG1();
    this.mappedNodesG2=getMaximumStateWithMinimumDifferences().getMappedNodesG2();
    findNonMappedNodes(pdg1,getAllNodesInSubTreePDG1(),mappedNodesG1,nonMappedNodesG1);
    findNonMappedNodes(pdg2,getAllNodesInSubTreePDG2(),mappedNodesG2,nonMappedNodesG2);
    Set<PDGNode> additionallyMatchedNodesG1=new LinkedHashSet<PDGNode>();
    for (    PDGNode nodeG1 : nonMappedNodesG1) {
      boolean advancedMatch=getCloneStructureRoot().isGapNodeG1InAdditionalMatches(nodeG1);
      if (advancedMatch) {
        additionallyMatchedNodesG1.add(nodeG1);
      }
      PDGNodeGap nodeGap=new PDGNodeGap(nodeG1,null,advancedMatch);
      CloneStructureNode node=new CloneStructureNode(nodeGap);
      PDGBlockNode tryNode=pdg1.isDirectlyNestedWithinBlockNode(nodeG1);
      if (tryNode != null) {
        CloneStructureNode cloneStructureTry=getCloneStructureRoot().findNodeG1(tryNode);
        if (cloneStructureTry != null) {
          node.setParent(cloneStructureTry);
        }
      }
 else {
        getCloneStructureRoot().addGapChild(node);
      }
    }
    nonMappedNodesG1.removeAll(additionallyMatchedNodesG1);
    Set<PDGNode> additionallyMatchedNodesG2=new LinkedHashSet<PDGNode>();
    for (    PDGNode nodeG2 : nonMappedNodesG2) {
      boolean advancedMatch=getCloneStructureRoot().isGapNodeG2InAdditionalMatches(nodeG2);
      if (advancedMatch) {
        additionallyMatchedNodesG2.add(nodeG2);
      }
      PDGNodeGap nodeGap=new PDGNodeGap(null,nodeG2,advancedMatch);
      CloneStructureNode node=new CloneStructureNode(nodeGap);
      PDGBlockNode tryNode=pdg2.isDirectlyNestedWithinBlockNode(nodeG2);
      if (tryNode != null) {
        CloneStructureNode cloneStructureTry=getCloneStructureRoot().findNodeG2(tryNode);
        if (cloneStructureTry != null) {
          node.setParent(cloneStructureTry);
        }
      }
 else {
        getCloneStructureRoot().addGapChild(node);
      }
    }
    nonMappedNodesG2.removeAll(additionallyMatchedNodesG2);
    findDeclaredVariablesInMappedNodesUsedByNonMappedNodes(pdg1,mappedNodesG1,nonMappedNodesG1,declaredVariablesInMappedNodesUsedByNonMappedNodesG1);
    findDeclaredVariablesInMappedNodesUsedByNonMappedNodes(pdg2,mappedNodesG2,nonMappedNodesG2,declaredVariablesInMappedNodesUsedByNonMappedNodesG2);
    this.renamedVariables=findRenamedVariables();
    findPassedParameters();
    List<Expression> expressions1=new ArrayList<Expression>();
    List<Expression> expressions2=new ArrayList<Expression>();
    List<AbstractExpression> fieldAccessReplacedWithGetterExpressions1=new ArrayList<AbstractExpression>();
    List<AbstractExpression> fieldAccessReplacedWithGetterExpressions2=new ArrayList<AbstractExpression>();
    for (    ASTNodeDifference nodeDifference : getNodeDifferences()) {
      if (!nodeDifference.containsDifferenceType(DifferenceType.FIELD_ACCESS_REPLACED_WITH_GETTER)) {
        Expression expression1=nodeDifference.getExpression1().getExpression();
        Expression expr1=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1);
        if (expression1.equals(expr1)) {
          expressions1.add(expression1);
        }
 else {
          expressions1.add(expr1);
        }
        Expression expression2=nodeDifference.getExpression2().getExpression();
        Expression expr2=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2);
        if (expression2.equals(expr2)) {
          expressions2.add(expression2);
        }
 else {
          expressions2.add(expr2);
        }
      }
 else {
        fieldAccessReplacedWithGetterExpressions1.add(nodeDifference.getExpression1());
        fieldAccessReplacedWithGetterExpressions2.add(nodeDifference.getExpression2());
      }
    }
    ITypeBinding commonSuperclass=ASTNodeMatcher.commonSuperType(pdg1.getMethod().getMethodDeclaration().resolveBinding().getDeclaringClass(),pdg2.getMethod().getMethodDeclaration().resolveBinding().getDeclaringClass());
    findLocallyAccessedFields(pdg1,mappedNodesG1,commonSuperclass,directlyAccessedLocalFieldsG1,indirectlyAccessedLocalFieldsG1,accessedLocalMethodsG1,expressions1,fieldAccessReplacedWithGetterExpressions1);
    findLocallyAccessedFields(pdg2,mappedNodesG2,commonSuperclass,directlyAccessedLocalFieldsG2,indirectlyAccessedLocalFieldsG2,accessedLocalMethodsG2,expressions2,fieldAccessReplacedWithGetterExpressions2);
    this.variablesToBeReturnedG1=variablesToBeReturned(pdg1,getRemovableNodesG1());
    this.variablesToBeReturnedG2=variablesToBeReturned(pdg2,getRemovableNodesG2());
    checkCloneStructureNodeForPreconditions(getCloneStructureRoot());
    processNonMappedNodesMovableBeforeAndAfter();
    checkPreconditionsAboutReturnedVariables();
    checkIfAllPossibleExecutionFlowsEndInReturn();
  }
}"
12066,"private void findLocallyAccessedFields(PDG pdg,Set<PDGNode> mappedNodes,ITypeBinding commonSuperclass,Set<AbstractVariable> directlyAccessedFields,Set<AbstractVariable> indirectlyAccessedFields,Set<MethodObject> accessedMethods,List<AbstractExpression> expressionsInDifferences,List<AbstractExpression> fieldAccessReplacedWithGetterExpressions){
  Set<MethodInvocationObject> methodInvocationsToBeExcluded=new LinkedHashSet<MethodInvocationObject>();
  for (  AbstractExpression expression : expressionsInDifferences) {
    methodInvocationsToBeExcluded.addAll(expression.getInvokedMethodsThroughThisReference());
    methodInvocationsToBeExcluded.addAll(expression.getInvokedStaticMethods());
  }
  Set<AbstractVariable> fieldsWithGetterToBeIncluded=new LinkedHashSet<AbstractVariable>();
  for (  AbstractExpression expression : fieldAccessReplacedWithGetterExpressions) {
    fieldsWithGetterToBeIncluded.addAll(expression.getUsedFieldsThroughThisReference());
  }
  Set<PlainVariable> usedLocalFields=new LinkedHashSet<PlainVariable>();
  Set<MethodInvocationObject> accessedLocalMethods=new LinkedHashSet<MethodInvocationObject>();
  for (  PDGNode pdgNode : mappedNodes) {
    AbstractStatement abstractStatement=pdgNode.getStatement();
    if (abstractStatement instanceof StatementObject) {
      StatementObject statement=(StatementObject)abstractStatement;
      usedLocalFields.addAll(statement.getUsedFieldsThroughThisReference());
      accessedLocalMethods.addAll(statement.getInvokedMethodsThroughThisReference());
      accessedLocalMethods.addAll(statement.getInvokedStaticMethods());
    }
 else     if (abstractStatement instanceof CompositeStatementObject) {
      CompositeStatementObject composite=(CompositeStatementObject)abstractStatement;
      usedLocalFields.addAll(composite.getUsedFieldsThroughThisReferenceInExpressions());
      accessedLocalMethods.addAll(composite.getInvokedMethodsThroughThisReferenceInExpressions());
      accessedLocalMethods.addAll(composite.getInvokedStaticMethodsInExpressions());
      if (composite instanceof TryStatementObject) {
        TryStatementObject tryStatement=(TryStatementObject)composite;
        List<CatchClauseObject> catchClauses=tryStatement.getCatchClauses();
        for (        CatchClauseObject catchClause : catchClauses) {
          usedLocalFields.addAll(catchClause.getBody().getUsedFieldsThroughThisReference());
          accessedLocalMethods.addAll(catchClause.getBody().getInvokedMethodsThroughThisReference());
          accessedLocalMethods.addAll(catchClause.getBody().getInvokedStaticMethods());
        }
        if (tryStatement.getFinallyClause() != null) {
          usedLocalFields.addAll(tryStatement.getFinallyClause().getUsedFieldsThroughThisReference());
          accessedLocalMethods.addAll(tryStatement.getFinallyClause().getInvokedMethodsThroughThisReference());
          accessedLocalMethods.addAll(tryStatement.getFinallyClause().getInvokedStaticMethods());
        }
      }
    }
  }
  ITypeBinding declaringClassTypeBinding=pdg.getMethod().getMethodDeclaration().resolveBinding().getDeclaringClass();
  Set<VariableDeclaration> fieldsAccessedInMethod=pdg.getFieldsAccessedInMethod();
  for (  PlainVariable variable : usedLocalFields) {
    for (    VariableDeclaration fieldDeclaration : fieldsAccessedInMethod) {
      if (variable.getVariableBindingKey().equals(fieldDeclaration.resolveBinding().getKey())) {
        ITypeBinding fieldDeclaringClassTypeBinding=fieldDeclaration.resolveBinding().getDeclaringClass();
        Set<ITypeBinding> superTypes=getAllSuperTypesUpToCommonSuperclass(declaringClassTypeBinding,commonSuperclass);
        boolean fieldFoundInSuperType=false;
        for (        ITypeBinding typeBinding : superTypes) {
          if (typeBinding.isEqualTo(fieldDeclaringClassTypeBinding)) {
            fieldFoundInSuperType=true;
            break;
          }
        }
        if (fieldDeclaringClassTypeBinding.isEqualTo(declaringClassTypeBinding) || fieldFoundInSuperType) {
          directlyAccessedFields.add(variable);
          if (fieldsWithGetterToBeIncluded.contains(variable)) {
            SystemObject system=ASTReader.getSystemObject();
            ClassObject accessedClass=system.getClassObject(fieldDeclaringClassTypeBinding.getQualifiedName());
            if (accessedClass != null) {
              ListIterator<MethodObject> it=accessedClass.getMethodIterator();
              while (it.hasNext()) {
                MethodObject method=it.next();
                FieldInstructionObject getterFieldInstruction=method.isGetter();
                if (getterFieldInstruction != null) {
                  if (variable.getVariableBindingKey().equals(getterFieldInstruction.getSimpleName().resolveBinding().getKey())) {
                    accessedMethods.add(method);
                    break;
                  }
                }
              }
            }
          }
          break;
        }
      }
    }
  }
  for (  MethodInvocationObject invocation : accessedLocalMethods) {
    ITypeBinding invokedMethodDeclaringClassTypeBinding=invocation.getMethodInvocation().resolveMethodBinding().getDeclaringClass();
    Set<ITypeBinding> superTypes=getAllSuperTypesUpToCommonSuperclass(declaringClassTypeBinding,commonSuperclass);
    boolean invokedMethodFoundInSuperType=false;
    for (    ITypeBinding typeBinding : superTypes) {
      if (typeBinding.isEqualTo(invokedMethodDeclaringClassTypeBinding)) {
        invokedMethodFoundInSuperType=true;
        break;
      }
    }
    if ((invokedMethodDeclaringClassTypeBinding.isEqualTo(declaringClassTypeBinding) || invokedMethodFoundInSuperType) && !methodInvocationsToBeExcluded.contains(invocation)) {
      if (!pdg.getMethod().getMethodDeclaration().resolveBinding().isEqualTo(invocation.getMethodInvocation().resolveMethodBinding())) {
        SystemObject system=ASTReader.getSystemObject();
        MethodObject calledMethod=system.getMethod(invocation);
        if (calledMethod != null) {
          accessedMethods.add(calledMethod);
          FieldInstructionObject getterFieldInstruction=calledMethod.isGetter();
          if (getterFieldInstruction != null) {
            Set<PlainVariable> usedFields=calledMethod.getUsedFieldsThroughThisReference();
            for (            PlainVariable plainVariable : usedFields) {
              if (plainVariable.getVariableBindingKey().equals(getterFieldInstruction.getSimpleName().resolveBinding().getKey())) {
                directlyAccessedFields.add(plainVariable);
                break;
              }
            }
          }
          ClassObject calledClass=system.getClassObject(calledMethod.getClassName());
          getAdditionalLocallyAccessedFieldsAndMethods(calledMethod,calledClass,indirectlyAccessedFields,accessedMethods);
        }
      }
    }
  }
}","private void findLocallyAccessedFields(PDG pdg,Set<PDGNode> mappedNodes,ITypeBinding commonSuperclass,Set<AbstractVariable> directlyAccessedFields,Set<AbstractVariable> indirectlyAccessedFields,Set<MethodObject> accessedMethods,List<Expression> expressionsInDifferences,List<AbstractExpression> fieldAccessReplacedWithGetterExpressions){
  Set<MethodInvocation> methodInvocationsToBeExcluded=new LinkedHashSet<MethodInvocation>();
  for (  Expression expression : expressionsInDifferences) {
    if (expression instanceof MethodInvocation) {
      methodInvocationsToBeExcluded.add((MethodInvocation)expression);
    }
  }
  Set<AbstractVariable> fieldsWithGetterToBeIncluded=new LinkedHashSet<AbstractVariable>();
  for (  AbstractExpression expression : fieldAccessReplacedWithGetterExpressions) {
    fieldsWithGetterToBeIncluded.addAll(expression.getUsedFieldsThroughThisReference());
  }
  Set<PlainVariable> usedLocalFields=new LinkedHashSet<PlainVariable>();
  Set<MethodInvocationObject> accessedLocalMethods=new LinkedHashSet<MethodInvocationObject>();
  for (  PDGNode pdgNode : mappedNodes) {
    AbstractStatement abstractStatement=pdgNode.getStatement();
    if (abstractStatement instanceof StatementObject) {
      StatementObject statement=(StatementObject)abstractStatement;
      usedLocalFields.addAll(statement.getUsedFieldsThroughThisReference());
      accessedLocalMethods.addAll(statement.getInvokedMethodsThroughThisReference());
      accessedLocalMethods.addAll(statement.getInvokedStaticMethods());
    }
 else     if (abstractStatement instanceof CompositeStatementObject) {
      CompositeStatementObject composite=(CompositeStatementObject)abstractStatement;
      usedLocalFields.addAll(composite.getUsedFieldsThroughThisReferenceInExpressions());
      accessedLocalMethods.addAll(composite.getInvokedMethodsThroughThisReferenceInExpressions());
      accessedLocalMethods.addAll(composite.getInvokedStaticMethodsInExpressions());
      if (composite instanceof TryStatementObject) {
        TryStatementObject tryStatement=(TryStatementObject)composite;
        List<CatchClauseObject> catchClauses=tryStatement.getCatchClauses();
        for (        CatchClauseObject catchClause : catchClauses) {
          usedLocalFields.addAll(catchClause.getBody().getUsedFieldsThroughThisReference());
          accessedLocalMethods.addAll(catchClause.getBody().getInvokedMethodsThroughThisReference());
          accessedLocalMethods.addAll(catchClause.getBody().getInvokedStaticMethods());
        }
        if (tryStatement.getFinallyClause() != null) {
          usedLocalFields.addAll(tryStatement.getFinallyClause().getUsedFieldsThroughThisReference());
          accessedLocalMethods.addAll(tryStatement.getFinallyClause().getInvokedMethodsThroughThisReference());
          accessedLocalMethods.addAll(tryStatement.getFinallyClause().getInvokedStaticMethods());
        }
      }
    }
  }
  ITypeBinding declaringClassTypeBinding=pdg.getMethod().getMethodDeclaration().resolveBinding().getDeclaringClass();
  Set<VariableDeclaration> fieldsAccessedInMethod=pdg.getFieldsAccessedInMethod();
  for (  PlainVariable variable : usedLocalFields) {
    for (    VariableDeclaration fieldDeclaration : fieldsAccessedInMethod) {
      if (variable.getVariableBindingKey().equals(fieldDeclaration.resolveBinding().getKey())) {
        ITypeBinding fieldDeclaringClassTypeBinding=fieldDeclaration.resolveBinding().getDeclaringClass();
        Set<ITypeBinding> superTypes=getAllSuperTypesUpToCommonSuperclass(declaringClassTypeBinding,commonSuperclass);
        boolean fieldFoundInSuperType=false;
        for (        ITypeBinding typeBinding : superTypes) {
          if (typeBinding.isEqualTo(fieldDeclaringClassTypeBinding)) {
            fieldFoundInSuperType=true;
            break;
          }
        }
        if (fieldDeclaringClassTypeBinding.isEqualTo(declaringClassTypeBinding) || fieldFoundInSuperType) {
          directlyAccessedFields.add(variable);
          if (fieldsWithGetterToBeIncluded.contains(variable)) {
            SystemObject system=ASTReader.getSystemObject();
            ClassObject accessedClass=system.getClassObject(fieldDeclaringClassTypeBinding.getQualifiedName());
            if (accessedClass != null) {
              ListIterator<MethodObject> it=accessedClass.getMethodIterator();
              while (it.hasNext()) {
                MethodObject method=it.next();
                FieldInstructionObject getterFieldInstruction=method.isGetter();
                if (getterFieldInstruction != null) {
                  if (variable.getVariableBindingKey().equals(getterFieldInstruction.getSimpleName().resolveBinding().getKey())) {
                    accessedMethods.add(method);
                    break;
                  }
                }
              }
            }
          }
          break;
        }
      }
    }
  }
  for (  MethodInvocationObject invocation : accessedLocalMethods) {
    ITypeBinding invokedMethodDeclaringClassTypeBinding=invocation.getMethodInvocation().resolveMethodBinding().getDeclaringClass();
    Set<ITypeBinding> superTypes=getAllSuperTypesUpToCommonSuperclass(declaringClassTypeBinding,commonSuperclass);
    boolean invokedMethodFoundInSuperType=false;
    for (    ITypeBinding typeBinding : superTypes) {
      if (typeBinding.isEqualTo(invokedMethodDeclaringClassTypeBinding)) {
        invokedMethodFoundInSuperType=true;
        break;
      }
    }
    if ((invokedMethodDeclaringClassTypeBinding.isEqualTo(declaringClassTypeBinding) || invokedMethodFoundInSuperType) && !methodInvocationsToBeExcluded.contains(invocation.getMethodInvocation())) {
      if (!pdg.getMethod().getMethodDeclaration().resolveBinding().isEqualTo(invocation.getMethodInvocation().resolveMethodBinding())) {
        SystemObject system=ASTReader.getSystemObject();
        MethodObject calledMethod=system.getMethod(invocation);
        if (calledMethod != null) {
          accessedMethods.add(calledMethod);
          FieldInstructionObject getterFieldInstruction=calledMethod.isGetter();
          if (getterFieldInstruction != null) {
            Set<PlainVariable> usedFields=calledMethod.getUsedFieldsThroughThisReference();
            for (            PlainVariable plainVariable : usedFields) {
              if (plainVariable.getVariableBindingKey().equals(getterFieldInstruction.getSimpleName().resolveBinding().getKey())) {
                directlyAccessedFields.add(plainVariable);
                break;
              }
            }
          }
          ClassObject calledClass=system.getClassObject(calledMethod.getClassName());
          getAdditionalLocallyAccessedFieldsAndMethods(calledMethod,calledClass,indirectlyAccessedFields,accessedMethods);
        }
      }
    }
  }
}"
12067,"private void findPassedParameters(){
  Set<AbstractVariable> passedParametersG1=extractPassedParameters(pdg1,mappedNodesG1);
  Set<AbstractVariable> passedParametersG2=extractPassedParameters(pdg2,mappedNodesG2);
  Set<AbstractVariable> parametersToBeRemovedG1=new LinkedHashSet<AbstractVariable>();
  Set<AbstractVariable> parametersToBeRemovedG2=new LinkedHashSet<AbstractVariable>();
  for (  PDGNodeMapping nodeMapping : getMaximumStateWithMinimumDifferences().getNodeMappings()) {
    PDGNode nodeG1=nodeMapping.getNodeG1();
    PDGNode nodeG2=nodeMapping.getNodeG2();
    List<AbstractVariable> nonAnonymousDeclaredVariablesG1=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG1=nodeG1.getDeclaredVariableIterator();
    while (declaredVariableIteratorG1.hasNext()) {
      AbstractVariable declaredVariableG1=declaredVariableIteratorG1.next();
      String key1=declaredVariableG1.getVariableBindingKey();
      String declaringType1=key1.substring(0,key1.indexOf(""String_Node_Str""));
      if (!declaringType1.contains(""String_Node_Str"")) {
        nonAnonymousDeclaredVariablesG1.add(declaredVariableG1);
      }
    }
    List<AbstractVariable> nonAnonymousDeclaredVariablesG2=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG2=nodeG2.getDeclaredVariableIterator();
    while (declaredVariableIteratorG2.hasNext()) {
      AbstractVariable declaredVariableG2=declaredVariableIteratorG2.next();
      String key2=declaredVariableG2.getVariableBindingKey();
      String declaringType2=key2.substring(0,key2.indexOf(""String_Node_Str""));
      if (!declaringType2.contains(""String_Node_Str"")) {
        nonAnonymousDeclaredVariablesG2.add(declaredVariableG2);
      }
    }
    int min=Math.min(nonAnonymousDeclaredVariablesG1.size(),nonAnonymousDeclaredVariablesG2.size());
    for (int i=0; i < min; i++) {
      AbstractVariable declaredVariableG1=nonAnonymousDeclaredVariablesG1.get(i);
      AbstractVariable declaredVariableG2=nonAnonymousDeclaredVariablesG2.get(i);
      ArrayList<AbstractVariable> declaredVariables=new ArrayList<AbstractVariable>();
      declaredVariables.add(declaredVariableG1);
      declaredVariables.add(declaredVariableG2);
      VariableBindingKeyPair keyPair=new VariableBindingKeyPair(declaredVariableG1.getVariableBindingKey(),declaredVariableG2.getVariableBindingKey());
      declaredLocalVariablesInMappedNodes.put(keyPair,declaredVariables);
    }
    Set<AbstractVariable> dataDependences1=nodeG1.incomingDataDependencesFromNodesDeclaringVariables();
    Set<AbstractVariable> dataDependences2=nodeG2.incomingDataDependencesFromNodesDeclaringVariables();
    dataDependences1.retainAll(passedParametersG1);
    dataDependences2.retainAll(passedParametersG2);
    if (dataDependences1.size() == dataDependences2.size()) {
      List<AbstractVariable> variables1=new ArrayList<AbstractVariable>(dataDependences1);
      List<AbstractVariable> variables2=new ArrayList<AbstractVariable>(dataDependences2);
      List<String> variableNames1=new ArrayList<String>();
      List<String> variableNames2=new ArrayList<String>();
      for (int i=0; i < variables1.size(); i++) {
        variableNames1.add(variables1.get(i).getVariableName());
        AbstractVariable variable2=variables2.get(i);
        String renamedVariableName=findRenamedVariableName(variable2);
        if (renamedVariableName != null)         variableNames2.add(renamedVariableName);
 else         variableNames2.add(variable2.getVariableName());
      }
      if (variableNames1.containsAll(variableNames2) && variableNames2.containsAll(variableNames1) && variableNames1.size() > 0 && variableNames2.size() > 0) {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        for (int i=0; i < variables1.size(); i++) {
          AbstractVariable variable1=variables1.get(i);
          sortedVariables1.add(variable1);
          for (int j=0; j < variables2.size(); j++) {
            AbstractVariable variable2=variables2.get(j);
            String renamedVariableName=findRenamedVariableName(variable2);
            if ((variable2.getVariableName().equals(variable1.getVariableName()) || variable1.getVariableName().equals(renamedVariableName)) && variable2.getVariableType().equals(variable1.getVariableType())) {
              sortedVariables2.add(variable2);
              break;
            }
          }
        }
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
 else {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        boolean requireVariableNameMatch=getRenamedVariables().isEmpty();
        for (int i=0; i < variables1.size(); i++) {
          AbstractVariable variable1=variables1.get(i);
          boolean found=false;
          for (int j=0; j < variables2.size(); j++) {
            AbstractVariable variable2=variables2.get(j);
            if (requireVariableNameMatch) {
              if (variable2.getVariableName().equals(variable1.getVariableName()) && variable2.getVariableType().equals(variable1.getVariableType()) && !sortedVariables2.contains(variable2)) {
                sortedVariables2.add(variable2);
                found=true;
                break;
              }
            }
 else {
              String renamedVariableName=findRenamedVariableName(variable2);
              if (renamedVariableName != null) {
                if (variable2.getVariableType().equals(variable1.getVariableType()) && variable1.getVariableName().equals(renamedVariableName) && !sortedVariables2.contains(variable2)) {
                  sortedVariables2.add(variable2);
                  found=true;
                  break;
                }
              }
 else {
                if (variable2.getVariableType().equals(variable1.getVariableType()) && !sortedVariables2.contains(variable2)) {
                  sortedVariables2.add(variable2);
                  found=true;
                  break;
                }
              }
            }
          }
          if (found) {
            sortedVariables1.add(variable1);
          }
        }
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
      for (int i=0; i < variables1.size(); i++) {
        AbstractVariable variable1=variables1.get(i);
        AbstractVariable variable2=variables2.get(i);
        if (passedParametersG1.contains(variable1) && passedParametersG2.contains(variable2)) {
          ArrayList<AbstractVariable> variableDeclarations=new ArrayList<AbstractVariable>();
          variableDeclarations.add(variable1);
          variableDeclarations.add(variable2);
          VariableBindingKeyPair keyPair=new VariableBindingKeyPair(variable1.getVariableBindingKey(),variable2.getVariableBindingKey());
          commonPassedParameters.put(keyPair,variableDeclarations);
          parametersToBeRemovedG1.add(variable1);
          parametersToBeRemovedG2.add(variable2);
        }
      }
    }
  }
  passedParametersG1.removeAll(parametersToBeRemovedG1);
  passedParametersG2.removeAll(parametersToBeRemovedG2);
  this.passedParametersG1.addAll(passedParametersG1);
  this.passedParametersG2.addAll(passedParametersG2);
}","private void findPassedParameters(){
  Set<AbstractVariable> passedParametersG1=extractPassedParameters(pdg1,mappedNodesG1);
  Set<AbstractVariable> passedParametersG2=extractPassedParameters(pdg2,mappedNodesG2);
  Set<AbstractVariable> parametersToBeRemovedG1=new LinkedHashSet<AbstractVariable>();
  Set<AbstractVariable> parametersToBeRemovedG2=new LinkedHashSet<AbstractVariable>();
  for (  PDGNodeMapping nodeMapping : getMaximumStateWithMinimumDifferences().getNodeMappings()) {
    PDGNode nodeG1=nodeMapping.getNodeG1();
    PDGNode nodeG2=nodeMapping.getNodeG2();
    List<AbstractVariable> nonAnonymousDeclaredVariablesG1=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG1=nodeG1.getDeclaredVariableIterator();
    while (declaredVariableIteratorG1.hasNext()) {
      AbstractVariable declaredVariableG1=declaredVariableIteratorG1.next();
      String key1=declaredVariableG1.getVariableBindingKey();
      String declaringType1=key1.substring(0,key1.indexOf(""String_Node_Str""));
      if (!declaringType1.contains(""String_Node_Str"")) {
        nonAnonymousDeclaredVariablesG1.add(declaredVariableG1);
      }
    }
    List<AbstractVariable> nonAnonymousDeclaredVariablesG2=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG2=nodeG2.getDeclaredVariableIterator();
    while (declaredVariableIteratorG2.hasNext()) {
      AbstractVariable declaredVariableG2=declaredVariableIteratorG2.next();
      String key2=declaredVariableG2.getVariableBindingKey();
      String declaringType2=key2.substring(0,key2.indexOf(""String_Node_Str""));
      if (!declaringType2.contains(""String_Node_Str"")) {
        nonAnonymousDeclaredVariablesG2.add(declaredVariableG2);
      }
    }
    int min=Math.min(nonAnonymousDeclaredVariablesG1.size(),nonAnonymousDeclaredVariablesG2.size());
    for (int i=0; i < min; i++) {
      AbstractVariable declaredVariableG1=nonAnonymousDeclaredVariablesG1.get(i);
      AbstractVariable declaredVariableG2=nonAnonymousDeclaredVariablesG2.get(i);
      ArrayList<AbstractVariable> declaredVariables=new ArrayList<AbstractVariable>();
      declaredVariables.add(declaredVariableG1);
      declaredVariables.add(declaredVariableG2);
      VariableBindingKeyPair keyPair=new VariableBindingKeyPair(declaredVariableG1.getVariableBindingKey(),declaredVariableG2.getVariableBindingKey());
      declaredLocalVariablesInMappedNodes.put(keyPair,declaredVariables);
    }
    Set<AbstractVariable> dataDependences1=nodeG1.incomingDataDependencesFromNodesDeclaringVariables();
    Set<AbstractVariable> dataDependences2=nodeG2.incomingDataDependencesFromNodesDeclaringVariables();
    dataDependences1.retainAll(passedParametersG1);
    dataDependences2.retainAll(passedParametersG2);
    List<AbstractVariable> variables1=new ArrayList<AbstractVariable>(dataDependences1);
    List<AbstractVariable> variables2=new ArrayList<AbstractVariable>(dataDependences2);
    if (dataDependences1.size() == dataDependences2.size()) {
      List<String> variableNames1=new ArrayList<String>();
      List<String> variableNames2=new ArrayList<String>();
      for (int i=0; i < variables1.size(); i++) {
        variableNames1.add(variables1.get(i).getVariableName());
        AbstractVariable variable2=variables2.get(i);
        String renamedVariableName=findRenamedVariableName(variable2);
        if (renamedVariableName != null)         variableNames2.add(renamedVariableName);
 else         variableNames2.add(variable2.getVariableName());
      }
      if (variableNames1.containsAll(variableNames2) && variableNames2.containsAll(variableNames1) && variableNames1.size() > 0 && variableNames2.size() > 0) {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        for (int i=0; i < variables1.size(); i++) {
          AbstractVariable variable1=variables1.get(i);
          sortedVariables1.add(variable1);
          for (int j=0; j < variables2.size(); j++) {
            AbstractVariable variable2=variables2.get(j);
            String renamedVariableName=findRenamedVariableName(variable2);
            if ((variable2.getVariableName().equals(variable1.getVariableName()) || variable1.getVariableName().equals(renamedVariableName)) && variable2.getVariableType().equals(variable1.getVariableType())) {
              sortedVariables2.add(variable2);
              break;
            }
          }
        }
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
 else {
        List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
        List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
        sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
        if (sortedVariables1.size() == sortedVariables2.size()) {
          variables1=sortedVariables1;
          variables2=sortedVariables2;
        }
      }
    }
 else {
      List<AbstractVariable> sortedVariables1=new ArrayList<AbstractVariable>();
      List<AbstractVariable> sortedVariables2=new ArrayList<AbstractVariable>();
      sortVariables(variables1,variables2,sortedVariables1,sortedVariables2);
      if (sortedVariables1.size() == sortedVariables2.size()) {
        variables1=sortedVariables1;
        variables2=sortedVariables2;
      }
    }
    for (int i=0; i < variables1.size(); i++) {
      AbstractVariable variable1=variables1.get(i);
      AbstractVariable variable2=variables2.get(i);
      if (passedParametersG1.contains(variable1) && passedParametersG2.contains(variable2)) {
        ArrayList<AbstractVariable> variableDeclarations=new ArrayList<AbstractVariable>();
        variableDeclarations.add(variable1);
        variableDeclarations.add(variable2);
        VariableBindingKeyPair keyPair=new VariableBindingKeyPair(variable1.getVariableBindingKey(),variable2.getVariableBindingKey());
        commonPassedParameters.put(keyPair,variableDeclarations);
        parametersToBeRemovedG1.add(variable1);
        parametersToBeRemovedG2.add(variable2);
      }
    }
  }
  passedParametersG1.removeAll(parametersToBeRemovedG1);
  passedParametersG2.removeAll(parametersToBeRemovedG2);
  this.passedParametersG1.addAll(passedParametersG1);
  this.passedParametersG2.addAll(passedParametersG2);
}"
12068,"private void extractClone(){
  this.cloneInfo=new CloneInformation();
  ITypeBinding commonSuperTypeOfSourceTypeDeclarations=null;
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding())) {
    cloneInfo.sourceCompilationUnit=sourceCompilationUnits.get(0);
    cloneInfo.sourceICompilationUnit=(ICompilationUnit)cloneInfo.sourceCompilationUnit.getJavaElement();
    cloneInfo.sourceTypeDeclaration=sourceTypeDeclarations.get(0);
    cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
    cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
  }
 else {
    ITypeBinding typeBinding1=sourceTypeDeclarations.get(0).resolveBinding();
    ITypeBinding typeBinding2=sourceTypeDeclarations.get(1).resolveBinding();
    commonSuperTypeOfSourceTypeDeclarations=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
    if (commonSuperTypeOfSourceTypeDeclarations != null) {
      if (pullUpToCommonSuperclass(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2)) {
        IJavaElement javaElement=commonSuperTypeOfSourceTypeDeclarations.getJavaElement();
        javaElementsToOpenInEditor.add(javaElement);
        ICompilationUnit iCompilationUnit=(ICompilationUnit)javaElement.getParent();
        ASTParser parser=ASTParser.newParser(AST.JLS4);
        parser.setKind(ASTParser.K_COMPILATION_UNIT);
        parser.setSource(iCompilationUnit);
        parser.setResolveBindings(true);
        CompilationUnit compilationUnit=(CompilationUnit)parser.createAST(null);
        List<AbstractTypeDeclaration> typeDeclarations=compilationUnit.types();
        for (        AbstractTypeDeclaration abstractTypeDeclaration : typeDeclarations) {
          if (abstractTypeDeclaration instanceof TypeDeclaration) {
            TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
            if (typeDeclaration.resolveBinding().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)) {
              cloneInfo.sourceCompilationUnit=compilationUnit;
              cloneInfo.sourceICompilationUnit=iCompilationUnit;
              cloneInfo.sourceTypeDeclaration=typeDeclaration;
              cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
              cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
              cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses=!superclassDirectlyInheritedFromRefactoredSubclasses(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2);
              break;
            }
          }
        }
        MultiTextEdit multiTextEdit=new MultiTextEdit();
        CompilationUnitChange compilationUnitChange=new CompilationUnitChange(""String_Node_Str"",iCompilationUnit);
        compilationUnitChange.setEdit(multiTextEdit);
        compilationUnitChanges.put(iCompilationUnit,compilationUnitChange);
      }
 else {
        if (extractToUtilityClass(commonSuperTypeOfSourceTypeDeclarations)) {
          cloneInfo.extractUtilityClass=true;
        }
        if (cloneInfo.extractUtilityClass) {
          cloneInfo.intermediateClassName=""String_Node_Str"";
        }
 else {
          cloneInfo.intermediateClassName=""String_Node_Str"" + commonSuperTypeOfSourceTypeDeclarations.getName();
        }
        ClassObject commonSuperType=ASTReader.getSystemObject().getClassObject(commonSuperTypeOfSourceTypeDeclarations.getQualifiedName());
        CompilationUnit compilationUnit=null;
        if (commonSuperType != null) {
          compilationUnit=findCompilationUnit(commonSuperType.getAbstractTypeDeclaration());
        }
 else {
          compilationUnit=sourceCompilationUnits.get(0);
        }
        cloneInfo.intermediateClassPackageBinding=compilationUnit.getPackage().resolveBinding();
        ICompilationUnit iCompilationUnit=(ICompilationUnit)compilationUnit.getJavaElement();
        IContainer container=(IContainer)iCompilationUnit.getResource().getParent();
        if (container instanceof IProject) {
          IProject contextProject=(IProject)container;
          cloneInfo.file=contextProject.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
 else         if (container instanceof IFolder) {
          IFolder contextFolder=(IFolder)container;
          cloneInfo.file=contextFolder.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
        boolean intermediateAlreadyExists=false;
        ICompilationUnit intermediateICompilationUnit=JavaCore.createCompilationUnitFrom(cloneInfo.file);
        javaElementsToOpenInEditor.add(intermediateICompilationUnit);
        ASTParser intermediateParser=ASTParser.newParser(AST.JLS4);
        intermediateParser.setKind(ASTParser.K_COMPILATION_UNIT);
        if (cloneInfo.file.exists()) {
          intermediateAlreadyExists=true;
          intermediateParser.setSource(intermediateICompilationUnit);
          intermediateParser.setResolveBindings(true);
        }
 else {
          cloneInfo.document=new Document();
          intermediateParser.setSource(cloneInfo.document.get().toCharArray());
        }
        CompilationUnit intermediateCompilationUnit=(CompilationUnit)intermediateParser.createAST(null);
        AST intermediateAST=intermediateCompilationUnit.getAST();
        ASTRewrite intermediateRewriter=ASTRewrite.create(intermediateAST);
        ListRewrite intermediateTypesRewrite=intermediateRewriter.getListRewrite(intermediateCompilationUnit,CompilationUnit.TYPES_PROPERTY);
        TypeDeclaration intermediateTypeDeclaration=null;
        if (intermediateAlreadyExists) {
          List<AbstractTypeDeclaration> abstractTypeDeclarations=intermediateCompilationUnit.types();
          for (          AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
            if (abstractTypeDeclaration instanceof TypeDeclaration) {
              TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
              if (typeDeclaration.getName().getIdentifier().equals(cloneInfo.intermediateClassName)) {
                intermediateTypeDeclaration=typeDeclaration;
                int intermediateModifiers=intermediateTypeDeclaration.getModifiers();
                if ((intermediateModifiers & Modifier.ABSTRACT) == 0 && !cloneInfo.extractUtilityClass) {
                  ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
                  intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
                }
                break;
              }
            }
          }
          MultiTextEdit intermediateMultiTextEdit=new MultiTextEdit();
          CompilationUnitChange intermediateCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",intermediateICompilationUnit);
          intermediateCompilationUnitChange.setEdit(intermediateMultiTextEdit);
          compilationUnitChanges.put(intermediateICompilationUnit,intermediateCompilationUnitChange);
        }
 else {
          if (compilationUnit.getPackage() != null) {
            intermediateRewriter.set(intermediateCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,compilationUnit.getPackage(),null);
          }
          intermediateTypeDeclaration=intermediateAST.newTypeDeclaration();
          SimpleName intermediateName=intermediateAST.newSimpleName(cloneInfo.intermediateClassName);
          intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.NAME_PROPERTY,intermediateName,null);
          ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
          intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
          if (!cloneInfo.extractUtilityClass) {
            intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
            intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,intermediateAST.newSimpleType(intermediateAST.newSimpleName(commonSuperTypeOfSourceTypeDeclarations.getName())),null);
          }
          intermediateTypesRewrite.insertLast(intermediateTypeDeclaration,null);
        }
        cloneInfo.sourceCompilationUnit=intermediateCompilationUnit;
        cloneInfo.sourceICompilationUnit=intermediateICompilationUnit;
        cloneInfo.sourceTypeDeclaration=intermediateTypeDeclaration;
        cloneInfo.sourceRewriter=intermediateRewriter;
        cloneInfo.ast=intermediateAST;
      }
    }
  }
  ASTRewrite sourceRewriter=cloneInfo.sourceRewriter;
  AST ast=cloneInfo.ast;
  TypeDeclaration sourceTypeDeclaration=cloneInfo.sourceTypeDeclaration;
  MethodDeclaration sourceMethodDeclaration=sourceMethodDeclarations.get(0);
  Set<ITypeBinding> requiredImportTypeBindings=new LinkedHashSet<ITypeBinding>();
  ListRewrite bodyDeclarationsRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  if (commonSuperTypeOfSourceTypeDeclarations != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding())) {
    Set<VariableDeclaration> accessedLocalFieldsG1=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> accessedLocalFieldsG2=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    pullUpLocallyAccessedFields(accessedLocalFieldsG1,accessedLocalFieldsG2,bodyDeclarationsRewrite,requiredImportTypeBindings);
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG1=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG2=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    Set<MethodObject> accessedLocalMethodsG1=mapper.getAccessedLocalMethodsG1();
    Set<MethodObject> accessedLocalMethodsG2=mapper.getAccessedLocalMethodsG2();
    for (    MethodObject localMethodG1 : accessedLocalMethodsG1) {
      for (      MethodObject localMethodG2 : accessedLocalMethodsG2) {
        if (localMethodG1.getName().equals(localMethodG2.getName()) && localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) && localMethodG1.getParameterTypeList().equals(localMethodG2.getParameterTypeList())) {
          MethodDeclaration methodDeclaration1=localMethodG1.getMethodDeclaration();
          MethodDeclaration methodDeclaration2=localMethodG2.getMethodDeclaration();
          Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
          boolean clones=type2Clones(methodDeclaration1,methodDeclaration2);
          Type returnType=methodDeclaration1.getReturnType2();
          TypeDeclaration typeDeclaration1=findTypeDeclaration(methodDeclaration1);
          TypeDeclaration typeDeclaration2=findTypeDeclaration(methodDeclaration2);
          if (clones) {
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              bodyDeclarationsRewrite.insertLast(methodDeclaration1,null);
              typeBindings.add(returnType.resolveBinding());
              List<SingleVariableDeclaration> parameters=methodDeclaration1.parameters();
              for (              SingleVariableDeclaration parameter : parameters) {
                typeBindings.add(parameter.getType().resolveBinding());
              }
              List<Name> thrownExceptions=methodDeclaration1.thrownExceptions();
              for (              Name thrownException : thrownExceptions) {
                typeBindings.add(thrownException.resolveTypeBinding());
              }
              Set<VariableDeclaration> fieldsAccessedInMethod1=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG1,methodDeclaration1);
              fieldsAccessedInMethod1.removeAll(accessedLocalFieldsG1);
              Set<VariableDeclaration> fieldsAccessedInMethod2=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG2,methodDeclaration2);
              fieldsAccessedInMethod2.removeAll(accessedLocalFieldsG2);
              pullUpLocallyAccessedFields(fieldsAccessedInMethod1,fieldsAccessedInMethod2,bodyDeclarationsRewrite,requiredImportTypeBindings);
            }
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              methodDeclarationsToBePulledUp.get(0).add(methodDeclaration1);
            }
            if (!typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              methodDeclarationsToBePulledUp.get(1).add(methodDeclaration2);
            }
          }
 else {
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
              sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(methodDeclaration1.getName().getIdentifier()),null);
              sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
              typeBindings.add(returnType.resolveBinding());
              ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
              List<IExtendedModifier> originalModifiers=methodDeclaration1.modifiers();
              for (              IExtendedModifier extendedModifier : originalModifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.isProtected()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                    updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                  }
 else                   if (modifier.isPublic()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
                    updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PUBLIC_KEYWORD);
                  }
                }
              }
              if (cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses) {
                Block methodBody=ast.newBlock();
                sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodBody,null);
                Expression returnedExpression=generateDefaultValue(sourceRewriter,ast,returnType);
                if (returnedExpression != null) {
                  ReturnStatement returnStatement=ast.newReturnStatement();
                  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedExpression,null);
                  ListRewrite statementsRewrite=sourceRewriter.getListRewrite(methodBody,Block.STATEMENTS_PROPERTY);
                  statementsRewrite.insertLast(returnStatement,null);
                }
              }
 else {
                modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
              }
              ListRewrite parametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
              List<SingleVariableDeclaration> parameters=methodDeclaration1.parameters();
              for (              SingleVariableDeclaration parameter : parameters) {
                parametersRewrite.insertLast(parameter,null);
                typeBindings.add(parameter.getType().resolveBinding());
              }
              ListRewrite thrownExceptionsRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
              List<Name> thrownExceptions=methodDeclaration1.thrownExceptions();
              for (              Name thrownException : thrownExceptions) {
                thrownExceptionsRewrite.insertLast(thrownException,null);
                typeBindings.add(thrownException.resolveTypeBinding());
              }
              bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
            }
          }
          getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
          break;
        }
      }
    }
  }
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  List<VariableDeclaration> returnedVariables1=this.returnedVariables.get(0);
  List<VariableDeclaration> returnedVariables2=this.returnedVariables.get(1);
  ITypeBinding returnTypeBinding=null;
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1) {
    Type returnType1=extractType(returnedVariables1.get(0));
    Type returnType2=extractType(returnedVariables2.get(0));
    if (returnType1.resolveBinding().isEqualTo(returnType2.resolveBinding()))     returnTypeBinding=returnType1.resolveBinding();
 else     returnTypeBinding=ASTNodeMatcher.commonSuperType(returnType1.resolveBinding(),returnType2.resolveBinding());
  }
 else {
    returnTypeBinding=findReturnTypeBinding();
  }
  if (returnTypeBinding != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(returnTypeBinding);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
    Type returnType=generateTypeFromTypeBinding(returnTypeBinding,ast,sourceRewriter);
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
  }
 else {
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
  }
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else   if (cloneInfo.extractUtilityClass) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
  if (((sourceMethodDeclarations.get(0).getModifiers() & Modifier.STATIC) != 0 && (sourceMethodDeclarations.get(1).getModifiers() & Modifier.STATIC) != 0) || cloneInfo.extractUtilityClass) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  List<Name> thrownExceptions1=sourceMethodDeclarations.get(0).thrownExceptions();
  List<Name> thrownExceptions2=sourceMethodDeclarations.get(1).thrownExceptions();
  for (  Name thrownException1 : thrownExceptions1) {
    for (    Name thrownException2 : thrownExceptions2) {
      if (thrownException1.resolveTypeBinding().isEqualTo(thrownException2.resolveTypeBinding())) {
        thrownExceptionRewrite.insertLast(thrownException1,null);
        break;
      }
    }
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> commonPassedParameters=mapper.getCommonPassedParameters();
  for (  VariableBindingKeyPair parameterName : commonPassedParameters.keySet()) {
    ArrayList<VariableDeclaration> variableDeclarations=commonPassedParameters.get(parameterName);
    VariableDeclaration variableDeclaration1=variableDeclarations.get(0);
    VariableDeclaration variableDeclaration2=variableDeclarations.get(1);
    if (parameterIsUsedByNodesWithoutDifferences(variableDeclaration1,variableDeclaration2)) {
      if (!variableDeclaration1.resolveBinding().isField() && !variableDeclaration2.resolveBinding().isField()) {
        ITypeBinding typeBinding1=extractType(variableDeclaration1).resolveBinding();
        ITypeBinding typeBinding2=extractType(variableDeclaration2).resolveBinding();
        ITypeBinding typeBinding=null;
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
        Type variableType=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(typeBinding);
        getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration1.getName(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
        parameterRewrite.insertLast(parameter,null);
        originalPassedParameters.put(parameterName,variableDeclarations);
      }
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode1=pdgNodeMapping.getNodeG1();
    Statement statement1=pdgNode1.getASTStatement();
    TypeVisitor typeVisitor1=new TypeVisitor();
    statement1.accept(typeVisitor1);
    getSimpleTypeBindings(typeVisitor1.getTypeBindings(),requiredImportTypeBindings);
    PDGNode pdgNode2=pdgNodeMapping.getNodeG2();
    Statement statement2=pdgNode2.getASTStatement();
    TypeVisitor typeVisitor2=new TypeVisitor();
    statement2.accept(typeVisitor2);
    getSimpleTypeBindings(typeVisitor2.getTypeBindings(),requiredImportTypeBindings);
  }
  CloneStructureNode root=mapper.getCloneStructureRoot();
  for (  CloneStructureNode child : root.getChildren()) {
    if (child.getMapping() instanceof PDGNodeMapping) {
      Statement statement=processCloneStructureNode(child,ast,sourceRewriter);
      methodBodyRewrite.insertLast(statement,null);
    }
  }
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1 && !mappedNodesContainStatementReturningVariable(returnedVariables1.get(0),returnedVariables2.get(0))) {
    ReturnStatement returnStatement=ast.newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariables1.get(0).getName(),null);
    methodBodyRewrite.insertLast(returnStatement,null);
    if (!mappedNodesContainStatementDeclaringVariable(returnedVariables1.get(0),returnedVariables2.get(0)) && !variableIsPassedAsCommonParameter(returnedVariables1.get(0),returnedVariables2.get(0))) {
      Type returnedType=extractType(returnedVariables1.get(0));
      Expression initializer=generateDefaultValue(sourceRewriter,ast,returnedType);
      VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(fragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariables1.get(0).getName(),null);
      sourceRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,initializer,null);
      VariableDeclarationStatement declarationStatement=ast.newVariableDeclarationStatement(fragment);
      sourceRewriter.set(declarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedType,null);
      methodBodyRewrite.insertFirst(declarationStatement,null);
    }
  }
  int i=0;
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    AbstractExpression expression1=difference.getExpression1();
    AbstractExpression expression2=difference.getExpression2();
    boolean isReturnedVariable=false;
    if (expression1 != null) {
      isReturnedVariable=isReturnedVariable(expression1.getExpression(),this.returnedVariables.get(0));
    }
 else     if (expression2 != null) {
      isReturnedVariable=isReturnedVariable(expression2.getExpression(),this.returnedVariables.get(1));
    }
    if (!isReturnedVariable) {
      ITypeBinding typeBinding=null;
      if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH) || differenceContainsSubDifferenceWithSubclassTypeMismatch(difference)) {
        ITypeBinding typeBinding1=expression1 != null ? expression1.getExpression().resolveTypeBinding() : expression2.getExpression().resolveTypeBinding();
        ITypeBinding typeBinding2=expression2 != null ? expression2.getExpression().resolveTypeBinding() : expression1.getExpression().resolveTypeBinding();
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
      }
 else {
        typeBinding=expression1 != null ? expression1.getExpression().resolveTypeBinding() : expression2.getExpression().resolveTypeBinding();
      }
      Type type=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
      Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
      typeBindings.add(typeBinding);
      getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(""String_Node_Str"" + i),null);
      i++;
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
  cloneInfo.requiredImportTypeBindings=requiredImportTypeBindings;
  cloneInfo.methodBodyRewrite=methodBodyRewrite;
  cloneInfo.parameterRewrite=parameterRewrite;
}","private void extractClone(){
  this.cloneInfo=new CloneInformation();
  ITypeBinding commonSuperTypeOfSourceTypeDeclarations=null;
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding())) {
    cloneInfo.sourceCompilationUnit=sourceCompilationUnits.get(0);
    cloneInfo.sourceICompilationUnit=(ICompilationUnit)cloneInfo.sourceCompilationUnit.getJavaElement();
    cloneInfo.sourceTypeDeclaration=sourceTypeDeclarations.get(0);
    cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
    cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
  }
 else {
    ITypeBinding typeBinding1=sourceTypeDeclarations.get(0).resolveBinding();
    ITypeBinding typeBinding2=sourceTypeDeclarations.get(1).resolveBinding();
    commonSuperTypeOfSourceTypeDeclarations=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
    if (commonSuperTypeOfSourceTypeDeclarations != null) {
      if (pullUpToCommonSuperclass(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2)) {
        IJavaElement javaElement=commonSuperTypeOfSourceTypeDeclarations.getJavaElement();
        javaElementsToOpenInEditor.add(javaElement);
        ICompilationUnit iCompilationUnit=(ICompilationUnit)javaElement.getParent();
        ASTParser parser=ASTParser.newParser(AST.JLS4);
        parser.setKind(ASTParser.K_COMPILATION_UNIT);
        parser.setSource(iCompilationUnit);
        parser.setResolveBindings(true);
        CompilationUnit compilationUnit=(CompilationUnit)parser.createAST(null);
        List<AbstractTypeDeclaration> typeDeclarations=compilationUnit.types();
        for (        AbstractTypeDeclaration abstractTypeDeclaration : typeDeclarations) {
          if (abstractTypeDeclaration instanceof TypeDeclaration) {
            TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
            if (typeDeclaration.resolveBinding().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)) {
              cloneInfo.sourceCompilationUnit=compilationUnit;
              cloneInfo.sourceICompilationUnit=iCompilationUnit;
              cloneInfo.sourceTypeDeclaration=typeDeclaration;
              cloneInfo.sourceRewriter=ASTRewrite.create(cloneInfo.sourceTypeDeclaration.getAST());
              cloneInfo.ast=cloneInfo.sourceTypeDeclaration.getAST();
              cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses=!superclassDirectlyInheritedFromRefactoredSubclasses(commonSuperTypeOfSourceTypeDeclarations,typeBinding1,typeBinding2);
              break;
            }
          }
        }
        MultiTextEdit multiTextEdit=new MultiTextEdit();
        CompilationUnitChange compilationUnitChange=new CompilationUnitChange(""String_Node_Str"",iCompilationUnit);
        compilationUnitChange.setEdit(multiTextEdit);
        compilationUnitChanges.put(iCompilationUnit,compilationUnitChange);
      }
 else {
        if (extractToUtilityClass(commonSuperTypeOfSourceTypeDeclarations)) {
          cloneInfo.extractUtilityClass=true;
        }
        if (cloneInfo.extractUtilityClass) {
          cloneInfo.intermediateClassName=""String_Node_Str"";
        }
 else {
          cloneInfo.intermediateClassName=""String_Node_Str"" + commonSuperTypeOfSourceTypeDeclarations.getName();
        }
        ClassObject commonSuperType=ASTReader.getSystemObject().getClassObject(commonSuperTypeOfSourceTypeDeclarations.getQualifiedName());
        CompilationUnit compilationUnit=null;
        if (commonSuperType != null) {
          compilationUnit=findCompilationUnit(commonSuperType.getAbstractTypeDeclaration());
        }
 else {
          compilationUnit=sourceCompilationUnits.get(0);
        }
        cloneInfo.intermediateClassPackageBinding=compilationUnit.getPackage().resolveBinding();
        ICompilationUnit iCompilationUnit=(ICompilationUnit)compilationUnit.getJavaElement();
        IContainer container=(IContainer)iCompilationUnit.getResource().getParent();
        if (container instanceof IProject) {
          IProject contextProject=(IProject)container;
          cloneInfo.file=contextProject.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
 else         if (container instanceof IFolder) {
          IFolder contextFolder=(IFolder)container;
          cloneInfo.file=contextFolder.getFile(cloneInfo.intermediateClassName + ""String_Node_Str"");
        }
        boolean intermediateAlreadyExists=false;
        ICompilationUnit intermediateICompilationUnit=JavaCore.createCompilationUnitFrom(cloneInfo.file);
        javaElementsToOpenInEditor.add(intermediateICompilationUnit);
        ASTParser intermediateParser=ASTParser.newParser(AST.JLS4);
        intermediateParser.setKind(ASTParser.K_COMPILATION_UNIT);
        if (cloneInfo.file.exists()) {
          intermediateAlreadyExists=true;
          intermediateParser.setSource(intermediateICompilationUnit);
          intermediateParser.setResolveBindings(true);
        }
 else {
          cloneInfo.document=new Document();
          intermediateParser.setSource(cloneInfo.document.get().toCharArray());
        }
        CompilationUnit intermediateCompilationUnit=(CompilationUnit)intermediateParser.createAST(null);
        AST intermediateAST=intermediateCompilationUnit.getAST();
        ASTRewrite intermediateRewriter=ASTRewrite.create(intermediateAST);
        ListRewrite intermediateTypesRewrite=intermediateRewriter.getListRewrite(intermediateCompilationUnit,CompilationUnit.TYPES_PROPERTY);
        TypeDeclaration intermediateTypeDeclaration=null;
        if (intermediateAlreadyExists) {
          List<AbstractTypeDeclaration> abstractTypeDeclarations=intermediateCompilationUnit.types();
          for (          AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
            if (abstractTypeDeclaration instanceof TypeDeclaration) {
              TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
              if (typeDeclaration.getName().getIdentifier().equals(cloneInfo.intermediateClassName)) {
                intermediateTypeDeclaration=typeDeclaration;
                int intermediateModifiers=intermediateTypeDeclaration.getModifiers();
                if ((intermediateModifiers & Modifier.ABSTRACT) == 0 && !cloneInfo.extractUtilityClass) {
                  ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
                  intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
                }
                break;
              }
            }
          }
          MultiTextEdit intermediateMultiTextEdit=new MultiTextEdit();
          CompilationUnitChange intermediateCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",intermediateICompilationUnit);
          intermediateCompilationUnitChange.setEdit(intermediateMultiTextEdit);
          compilationUnitChanges.put(intermediateICompilationUnit,intermediateCompilationUnitChange);
        }
 else {
          if (compilationUnit.getPackage() != null) {
            intermediateRewriter.set(intermediateCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,compilationUnit.getPackage(),null);
          }
          intermediateTypeDeclaration=intermediateAST.newTypeDeclaration();
          SimpleName intermediateName=intermediateAST.newSimpleName(cloneInfo.intermediateClassName);
          intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.NAME_PROPERTY,intermediateName,null);
          ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
          intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
          if (!cloneInfo.extractUtilityClass) {
            intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
            intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,intermediateAST.newSimpleType(intermediateAST.newSimpleName(commonSuperTypeOfSourceTypeDeclarations.getName())),null);
          }
          intermediateTypesRewrite.insertLast(intermediateTypeDeclaration,null);
        }
        cloneInfo.sourceCompilationUnit=intermediateCompilationUnit;
        cloneInfo.sourceICompilationUnit=intermediateICompilationUnit;
        cloneInfo.sourceTypeDeclaration=intermediateTypeDeclaration;
        cloneInfo.sourceRewriter=intermediateRewriter;
        cloneInfo.ast=intermediateAST;
      }
    }
  }
  ASTRewrite sourceRewriter=cloneInfo.sourceRewriter;
  AST ast=cloneInfo.ast;
  TypeDeclaration sourceTypeDeclaration=cloneInfo.sourceTypeDeclaration;
  MethodDeclaration sourceMethodDeclaration=sourceMethodDeclarations.get(0);
  Set<ITypeBinding> requiredImportTypeBindings=new LinkedHashSet<ITypeBinding>();
  ListRewrite bodyDeclarationsRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  if (commonSuperTypeOfSourceTypeDeclarations != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding())) {
    Set<VariableDeclaration> accessedLocalFieldsG1=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> accessedLocalFieldsG2=getLocallyAccessedFields(mapper.getDirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    pullUpLocallyAccessedFields(accessedLocalFieldsG1,accessedLocalFieldsG2,bodyDeclarationsRewrite,requiredImportTypeBindings);
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG1=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG1(),sourceTypeDeclarations.get(0));
    Set<VariableDeclaration> indirectlyAccessedLocalFieldsG2=getLocallyAccessedFields(mapper.getIndirectlyAccessedLocalFieldsG2(),sourceTypeDeclarations.get(1));
    Set<MethodObject> accessedLocalMethodsG1=mapper.getAccessedLocalMethodsG1();
    Set<MethodObject> accessedLocalMethodsG2=mapper.getAccessedLocalMethodsG2();
    for (    MethodObject localMethodG1 : accessedLocalMethodsG1) {
      for (      MethodObject localMethodG2 : accessedLocalMethodsG2) {
        if (localMethodG1.getName().equals(localMethodG2.getName()) && localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) && localMethodG1.getParameterTypeList().equals(localMethodG2.getParameterTypeList())) {
          MethodDeclaration methodDeclaration1=localMethodG1.getMethodDeclaration();
          MethodDeclaration methodDeclaration2=localMethodG2.getMethodDeclaration();
          Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
          boolean clones=type2Clones(methodDeclaration1,methodDeclaration2);
          Type returnType=methodDeclaration1.getReturnType2();
          TypeDeclaration typeDeclaration1=findTypeDeclaration(methodDeclaration1);
          TypeDeclaration typeDeclaration2=findTypeDeclaration(methodDeclaration2);
          if (clones) {
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              bodyDeclarationsRewrite.insertLast(methodDeclaration1,null);
              TypeVisitor typeVisitor=new TypeVisitor();
              methodDeclaration1.accept(typeVisitor);
              typeBindings.addAll(typeVisitor.getTypeBindings());
              Set<VariableDeclaration> fieldsAccessedInMethod1=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG1,methodDeclaration1);
              fieldsAccessedInMethod1.removeAll(accessedLocalFieldsG1);
              Set<VariableDeclaration> fieldsAccessedInMethod2=getFieldsAccessedInMethod(indirectlyAccessedLocalFieldsG2,methodDeclaration2);
              fieldsAccessedInMethod2.removeAll(accessedLocalFieldsG2);
              pullUpLocallyAccessedFields(fieldsAccessedInMethod1,fieldsAccessedInMethod2,bodyDeclarationsRewrite,requiredImportTypeBindings);
            }
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              methodDeclarationsToBePulledUp.get(0).add(methodDeclaration1);
            }
            if (!typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              methodDeclarationsToBePulledUp.get(1).add(methodDeclaration2);
            }
          }
 else {
            if (!typeDeclaration1.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && !typeDeclaration2.resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
              sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(methodDeclaration1.getName().getIdentifier()),null);
              sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
              typeBindings.add(returnType.resolveBinding());
              ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
              List<IExtendedModifier> originalModifiers=methodDeclaration1.modifiers();
              for (              IExtendedModifier extendedModifier : originalModifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.isProtected()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                    if ((methodDeclaration2.getModifiers() & Modifier.PROTECTED) == 0) {
                      updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PROTECTED_KEYWORD);
                    }
                  }
 else                   if (modifier.isPublic()) {
                    modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
                    if ((methodDeclaration2.getModifiers() & Modifier.PUBLIC) == 0) {
                      updateAccessModifier(methodDeclaration2,Modifier.ModifierKeyword.PUBLIC_KEYWORD);
                    }
                  }
                }
              }
              if (cloneInfo.superclassNotDirectlyInheritedFromRefactoredSubclasses) {
                Block methodBody=ast.newBlock();
                sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodBody,null);
                Expression returnedExpression=generateDefaultValue(sourceRewriter,ast,returnType);
                if (returnedExpression != null) {
                  ReturnStatement returnStatement=ast.newReturnStatement();
                  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedExpression,null);
                  ListRewrite statementsRewrite=sourceRewriter.getListRewrite(methodBody,Block.STATEMENTS_PROPERTY);
                  statementsRewrite.insertLast(returnStatement,null);
                }
              }
 else {
                modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
              }
              ListRewrite parametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
              List<SingleVariableDeclaration> parameters=methodDeclaration1.parameters();
              for (              SingleVariableDeclaration parameter : parameters) {
                parametersRewrite.insertLast(parameter,null);
                typeBindings.add(parameter.getType().resolveBinding());
              }
              ListRewrite thrownExceptionsRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
              List<Name> thrownExceptions=methodDeclaration1.thrownExceptions();
              for (              Name thrownException : thrownExceptions) {
                thrownExceptionsRewrite.insertLast(thrownException,null);
                typeBindings.add(thrownException.resolveTypeBinding());
              }
              bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
            }
          }
          getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
          break;
        }
      }
    }
  }
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  List<VariableDeclaration> returnedVariables1=this.returnedVariables.get(0);
  List<VariableDeclaration> returnedVariables2=this.returnedVariables.get(1);
  ITypeBinding returnTypeBinding=null;
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1) {
    Type returnType1=extractType(returnedVariables1.get(0));
    Type returnType2=extractType(returnedVariables2.get(0));
    if (returnType1.resolveBinding().isEqualTo(returnType2.resolveBinding()))     returnTypeBinding=returnType1.resolveBinding();
 else     returnTypeBinding=ASTNodeMatcher.commonSuperType(returnType1.resolveBinding(),returnType2.resolveBinding());
  }
 else {
    returnTypeBinding=findReturnTypeBinding();
  }
  if (returnTypeBinding != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(returnTypeBinding);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
    Type returnType=generateTypeFromTypeBinding(returnTypeBinding,ast,sourceRewriter);
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
  }
 else {
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
  }
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else   if (cloneInfo.extractUtilityClass) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
  if (((sourceMethodDeclarations.get(0).getModifiers() & Modifier.STATIC) != 0 && (sourceMethodDeclarations.get(1).getModifiers() & Modifier.STATIC) != 0) || cloneInfo.extractUtilityClass) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  List<Name> thrownExceptions1=sourceMethodDeclarations.get(0).thrownExceptions();
  List<Name> thrownExceptions2=sourceMethodDeclarations.get(1).thrownExceptions();
  for (  Name thrownException1 : thrownExceptions1) {
    for (    Name thrownException2 : thrownExceptions2) {
      if (thrownException1.resolveTypeBinding().isEqualTo(thrownException2.resolveTypeBinding())) {
        thrownExceptionRewrite.insertLast(thrownException1,null);
        break;
      }
    }
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> commonPassedParameters=mapper.getCommonPassedParameters();
  for (  VariableBindingKeyPair parameterName : commonPassedParameters.keySet()) {
    ArrayList<VariableDeclaration> variableDeclarations=commonPassedParameters.get(parameterName);
    VariableDeclaration variableDeclaration1=variableDeclarations.get(0);
    VariableDeclaration variableDeclaration2=variableDeclarations.get(1);
    if (parameterIsUsedByNodesWithoutDifferences(variableDeclaration1,variableDeclaration2)) {
      if (!variableDeclaration1.resolveBinding().isField() && !variableDeclaration2.resolveBinding().isField()) {
        ITypeBinding typeBinding1=extractType(variableDeclaration1).resolveBinding();
        ITypeBinding typeBinding2=extractType(variableDeclaration2).resolveBinding();
        ITypeBinding typeBinding=null;
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
        Type variableType=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(typeBinding);
        getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration1.getName(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
        parameterRewrite.insertLast(parameter,null);
        originalPassedParameters.put(parameterName,variableDeclarations);
      }
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode1=pdgNodeMapping.getNodeG1();
    Statement statement1=pdgNode1.getASTStatement();
    TypeVisitor typeVisitor1=new TypeVisitor();
    statement1.accept(typeVisitor1);
    getSimpleTypeBindings(typeVisitor1.getTypeBindings(),requiredImportTypeBindings);
    PDGNode pdgNode2=pdgNodeMapping.getNodeG2();
    Statement statement2=pdgNode2.getASTStatement();
    TypeVisitor typeVisitor2=new TypeVisitor();
    statement2.accept(typeVisitor2);
    getSimpleTypeBindings(typeVisitor2.getTypeBindings(),requiredImportTypeBindings);
  }
  CloneStructureNode root=mapper.getCloneStructureRoot();
  for (  CloneStructureNode child : root.getChildren()) {
    if (child.getMapping() instanceof PDGNodeMapping) {
      Statement statement=processCloneStructureNode(child,ast,sourceRewriter);
      methodBodyRewrite.insertLast(statement,null);
    }
  }
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1 && !mappedNodesContainStatementReturningVariable(returnedVariables1.get(0),returnedVariables2.get(0))) {
    ReturnStatement returnStatement=ast.newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariables1.get(0).getName(),null);
    methodBodyRewrite.insertLast(returnStatement,null);
    if (!mappedNodesContainStatementDeclaringVariable(returnedVariables1.get(0),returnedVariables2.get(0)) && !variableIsPassedAsCommonParameter(returnedVariables1.get(0),returnedVariables2.get(0))) {
      Type returnedType=extractType(returnedVariables1.get(0));
      Expression initializer=generateDefaultValue(sourceRewriter,ast,returnedType);
      VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(fragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariables1.get(0).getName(),null);
      sourceRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,initializer,null);
      VariableDeclarationStatement declarationStatement=ast.newVariableDeclarationStatement(fragment);
      sourceRewriter.set(declarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedType,null);
      methodBodyRewrite.insertFirst(declarationStatement,null);
    }
  }
  int i=0;
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    AbstractExpression expression1=difference.getExpression1();
    AbstractExpression expression2=difference.getExpression2();
    boolean isReturnedVariable=false;
    if (expression1 != null) {
      isReturnedVariable=isReturnedVariable(expression1.getExpression(),this.returnedVariables.get(0));
    }
 else     if (expression2 != null) {
      isReturnedVariable=isReturnedVariable(expression2.getExpression(),this.returnedVariables.get(1));
    }
    ITypeBinding typeBinding1=expression1 != null ? expression1.getExpression().resolveTypeBinding() : expression2.getExpression().resolveTypeBinding();
    ITypeBinding typeBinding2=expression2 != null ? expression2.getExpression().resolveTypeBinding() : expression1.getExpression().resolveTypeBinding();
    if (!isReturnedVariable) {
      ITypeBinding typeBinding=null;
      if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH) || differenceContainsSubDifferenceWithSubclassTypeMismatch(difference)) {
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
      }
 else {
        if (expression1 != null && !typeBinding1.getQualifiedName().equals(""String_Node_Str"")) {
          typeBinding=typeBinding1;
        }
 else {
          typeBinding=typeBinding2;
        }
      }
      Type type=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
      Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
      typeBindings.add(typeBinding);
      getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(""String_Node_Str"" + i),null);
      i++;
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
  cloneInfo.requiredImportTypeBindings=requiredImportTypeBindings;
  cloneInfo.methodBodyRewrite=methodBodyRewrite;
  cloneInfo.parameterRewrite=parameterRewrite;
}"
12069,"public PDGSubTreeMapper(PDG pdg1,PDG pdg2,ICompilationUnit iCompilationUnit1,ICompilationUnit iCompilationUnit2,ControlDependenceTreeNode controlDependenceSubTreePDG1,ControlDependenceTreeNode controlDependenceSubTreePDG2,boolean fullTreeMatch,IProgressMonitor monitor){
  this.pdg1=pdg1;
  this.pdg2=pdg2;
  this.iCompilationUnit1=iCompilationUnit1;
  this.iCompilationUnit2=iCompilationUnit2;
  this.fullTreeMatch=fullTreeMatch;
  this.nonMappedNodesG1=new TreeSet<PDGNode>();
  this.nonMappedNodesG2=new TreeSet<PDGNode>();
  this.commonPassedParameters=new LinkedHashMap<String,ArrayList<AbstractVariable>>();
  this.declaredLocalVariablesInMappedNodes=new LinkedHashMap<String,ArrayList<AbstractVariable>>();
  this.passedParametersG1=new LinkedHashSet<AbstractVariable>();
  this.passedParametersG2=new LinkedHashSet<AbstractVariable>();
  this.accessedLocalFieldsG1=new LinkedHashSet<AbstractVariable>();
  this.accessedLocalFieldsG2=new LinkedHashSet<AbstractVariable>();
  this.accessedLocalMethodsG1=new LinkedHashSet<MethodInvocationObject>();
  this.accessedLocalMethodsG2=new LinkedHashSet<MethodInvocationObject>();
  this.declaredVariablesInMappedNodesUsedByNonMappedNodesG1=new LinkedHashSet<AbstractVariable>();
  this.declaredVariablesInMappedNodesUsedByNonMappedNodesG2=new LinkedHashSet<AbstractVariable>();
  this.monitor=monitor;
  this.allNodesInSubTreePDG1=new TreeSet<PDGNode>();
  this.allNodesInSubTreePDG2=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableBefore=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableBeforeAndAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableBefore=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableBeforeAndAfter=new TreeSet<PDGNode>();
  matchBasedOnControlDependenceTreeStructure(controlDependenceSubTreePDG1,controlDependenceSubTreePDG2);
  if (maximumStateWithMinimumDifferences != null) {
    this.mappedNodesG1=maximumStateWithMinimumDifferences.getMappedNodesG1();
    this.mappedNodesG2=maximumStateWithMinimumDifferences.getMappedNodesG2();
    findNonMappedNodes(pdg1,allNodesInSubTreePDG1,mappedNodesG1,nonMappedNodesG1);
    findNonMappedNodes(pdg2,allNodesInSubTreePDG2,mappedNodesG2,nonMappedNodesG2);
    Set<PDGNode> additionallyMatchedNodesG1=new LinkedHashSet<PDGNode>();
    for (    PDGNode nodeG1 : nonMappedNodesG1) {
      boolean advancedMatch=cloneStructureRoot.isGapNodeG1InAdditionalMatches(nodeG1);
      if (advancedMatch) {
        additionallyMatchedNodesG1.add(nodeG1);
      }
      PDGNodeGap nodeGap=new PDGNodeGap(nodeG1,null,advancedMatch);
      CloneStructureNode node=new CloneStructureNode(nodeGap);
      PDGBlockNode tryNode=pdg1.isDirectlyNestedWithinBlockNode(nodeG1);
      if (tryNode != null) {
        CloneStructureNode cloneStructureTry=cloneStructureRoot.findNodeG1(tryNode);
        if (cloneStructureTry != null) {
          node.setParent(cloneStructureTry);
        }
      }
 else {
        cloneStructureRoot.addGapChild(node);
      }
    }
    nonMappedNodesG1.removeAll(additionallyMatchedNodesG1);
    Set<PDGNode> additionallyMatchedNodesG2=new LinkedHashSet<PDGNode>();
    for (    PDGNode nodeG2 : nonMappedNodesG2) {
      boolean advancedMatch=cloneStructureRoot.isGapNodeG2InAdditionalMatches(nodeG2);
      if (advancedMatch) {
        additionallyMatchedNodesG2.add(nodeG2);
      }
      PDGNodeGap nodeGap=new PDGNodeGap(null,nodeG2,advancedMatch);
      CloneStructureNode node=new CloneStructureNode(nodeGap);
      PDGBlockNode tryNode=pdg2.isDirectlyNestedWithinBlockNode(nodeG2);
      if (tryNode != null) {
        CloneStructureNode cloneStructureTry=cloneStructureRoot.findNodeG2(tryNode);
        if (cloneStructureTry != null) {
          node.setParent(cloneStructureTry);
        }
      }
 else {
        cloneStructureRoot.addGapChild(node);
      }
    }
    nonMappedNodesG2.removeAll(additionallyMatchedNodesG2);
    findDeclaredVariablesInMappedNodesUsedByNonMappedNodes(pdg1,mappedNodesG1,declaredVariablesInMappedNodesUsedByNonMappedNodesG1);
    findDeclaredVariablesInMappedNodesUsedByNonMappedNodes(pdg2,mappedNodesG2,declaredVariablesInMappedNodesUsedByNonMappedNodesG2);
    findPassedParameters();
    findLocallyAccessedFields(pdg1,mappedNodesG1,accessedLocalFieldsG1,accessedLocalMethodsG1);
    findLocallyAccessedFields(pdg2,mappedNodesG2,accessedLocalFieldsG2,accessedLocalMethodsG2);
    this.preconditionViolations=new ArrayList<PreconditionViolation>();
    this.variablesToBeReturnedG1=variablesToBeReturned(pdg1,getRemovableNodesG1());
    this.variablesToBeReturnedG2=variablesToBeReturned(pdg2,getRemovableNodesG2());
    checkCloneStructureNodeForPreconditions(cloneStructureRoot);
    processNonMappedNodesMovableBeforeAndAfter();
    checkPreconditionsAboutReturnedVariables();
  }
}","public PDGSubTreeMapper(PDG pdg1,PDG pdg2,ICompilationUnit iCompilationUnit1,ICompilationUnit iCompilationUnit2,ControlDependenceTreeNode controlDependenceSubTreePDG1,ControlDependenceTreeNode controlDependenceSubTreePDG2,boolean fullTreeMatch,IProgressMonitor monitor){
  this.pdg1=pdg1;
  this.pdg2=pdg2;
  this.iCompilationUnit1=iCompilationUnit1;
  this.iCompilationUnit2=iCompilationUnit2;
  this.fullTreeMatch=fullTreeMatch;
  this.nonMappedNodesG1=new TreeSet<PDGNode>();
  this.nonMappedNodesG2=new TreeSet<PDGNode>();
  this.commonPassedParameters=new LinkedHashMap<VariableBindingKeyPair,ArrayList<AbstractVariable>>();
  this.declaredLocalVariablesInMappedNodes=new LinkedHashMap<VariableBindingKeyPair,ArrayList<AbstractVariable>>();
  this.passedParametersG1=new LinkedHashSet<AbstractVariable>();
  this.passedParametersG2=new LinkedHashSet<AbstractVariable>();
  this.accessedLocalFieldsG1=new LinkedHashSet<AbstractVariable>();
  this.accessedLocalFieldsG2=new LinkedHashSet<AbstractVariable>();
  this.accessedLocalMethodsG1=new LinkedHashSet<MethodInvocationObject>();
  this.accessedLocalMethodsG2=new LinkedHashSet<MethodInvocationObject>();
  this.declaredVariablesInMappedNodesUsedByNonMappedNodesG1=new LinkedHashSet<AbstractVariable>();
  this.declaredVariablesInMappedNodesUsedByNonMappedNodesG2=new LinkedHashSet<AbstractVariable>();
  this.monitor=monitor;
  this.allNodesInSubTreePDG1=new TreeSet<PDGNode>();
  this.allNodesInSubTreePDG2=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableBefore=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG1MovableBeforeAndAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableBefore=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableAfter=new TreeSet<PDGNode>();
  this.nonMappedPDGNodesG2MovableBeforeAndAfter=new TreeSet<PDGNode>();
  matchBasedOnControlDependenceTreeStructure(controlDependenceSubTreePDG1,controlDependenceSubTreePDG2);
  if (maximumStateWithMinimumDifferences != null) {
    this.mappedNodesG1=maximumStateWithMinimumDifferences.getMappedNodesG1();
    this.mappedNodesG2=maximumStateWithMinimumDifferences.getMappedNodesG2();
    findNonMappedNodes(pdg1,allNodesInSubTreePDG1,mappedNodesG1,nonMappedNodesG1);
    findNonMappedNodes(pdg2,allNodesInSubTreePDG2,mappedNodesG2,nonMappedNodesG2);
    Set<PDGNode> additionallyMatchedNodesG1=new LinkedHashSet<PDGNode>();
    for (    PDGNode nodeG1 : nonMappedNodesG1) {
      boolean advancedMatch=cloneStructureRoot.isGapNodeG1InAdditionalMatches(nodeG1);
      if (advancedMatch) {
        additionallyMatchedNodesG1.add(nodeG1);
      }
      PDGNodeGap nodeGap=new PDGNodeGap(nodeG1,null,advancedMatch);
      CloneStructureNode node=new CloneStructureNode(nodeGap);
      PDGBlockNode tryNode=pdg1.isDirectlyNestedWithinBlockNode(nodeG1);
      if (tryNode != null) {
        CloneStructureNode cloneStructureTry=cloneStructureRoot.findNodeG1(tryNode);
        if (cloneStructureTry != null) {
          node.setParent(cloneStructureTry);
        }
      }
 else {
        cloneStructureRoot.addGapChild(node);
      }
    }
    nonMappedNodesG1.removeAll(additionallyMatchedNodesG1);
    Set<PDGNode> additionallyMatchedNodesG2=new LinkedHashSet<PDGNode>();
    for (    PDGNode nodeG2 : nonMappedNodesG2) {
      boolean advancedMatch=cloneStructureRoot.isGapNodeG2InAdditionalMatches(nodeG2);
      if (advancedMatch) {
        additionallyMatchedNodesG2.add(nodeG2);
      }
      PDGNodeGap nodeGap=new PDGNodeGap(null,nodeG2,advancedMatch);
      CloneStructureNode node=new CloneStructureNode(nodeGap);
      PDGBlockNode tryNode=pdg2.isDirectlyNestedWithinBlockNode(nodeG2);
      if (tryNode != null) {
        CloneStructureNode cloneStructureTry=cloneStructureRoot.findNodeG2(tryNode);
        if (cloneStructureTry != null) {
          node.setParent(cloneStructureTry);
        }
      }
 else {
        cloneStructureRoot.addGapChild(node);
      }
    }
    nonMappedNodesG2.removeAll(additionallyMatchedNodesG2);
    findDeclaredVariablesInMappedNodesUsedByNonMappedNodes(pdg1,mappedNodesG1,declaredVariablesInMappedNodesUsedByNonMappedNodesG1);
    findDeclaredVariablesInMappedNodesUsedByNonMappedNodes(pdg2,mappedNodesG2,declaredVariablesInMappedNodesUsedByNonMappedNodesG2);
    findPassedParameters();
    findLocallyAccessedFields(pdg1,mappedNodesG1,accessedLocalFieldsG1,accessedLocalMethodsG1);
    findLocallyAccessedFields(pdg2,mappedNodesG2,accessedLocalFieldsG2,accessedLocalMethodsG2);
    this.preconditionViolations=new ArrayList<PreconditionViolation>();
    this.variablesToBeReturnedG1=variablesToBeReturned(pdg1,getRemovableNodesG1());
    this.variablesToBeReturnedG2=variablesToBeReturned(pdg2,getRemovableNodesG2());
    checkCloneStructureNodeForPreconditions(cloneStructureRoot);
    processNonMappedNodesMovableBeforeAndAfter();
    checkPreconditionsAboutReturnedVariables();
  }
}"
12070,"public Map<String,ArrayList<VariableDeclaration>> getCommonPassedParameters(){
  Map<String,ArrayList<VariableDeclaration>> commonPassedParameters=new LinkedHashMap<String,ArrayList<VariableDeclaration>>();
  Set<VariableDeclaration> variableDeclarationsAndAccessedFieldsInMethod1=pdg1.getVariableDeclarationsAndAccessedFieldsInMethod();
  Set<VariableDeclaration> variableDeclarationsAndAccessedFieldsInMethod2=pdg2.getVariableDeclarationsAndAccessedFieldsInMethod();
  for (  String key : this.commonPassedParameters.keySet()) {
    ArrayList<AbstractVariable> value=this.commonPassedParameters.get(key);
    AbstractVariable variableDeclaration1=value.get(0);
    AbstractVariable variableDeclaration2=value.get(1);
    ArrayList<VariableDeclaration> variableDeclarations=new ArrayList<VariableDeclaration>();
    for (    VariableDeclaration variableDeclaration : variableDeclarationsAndAccessedFieldsInMethod1) {
      if (variableDeclaration.resolveBinding().getKey().equals(variableDeclaration1.getVariableBindingKey())) {
        variableDeclarations.add(variableDeclaration);
        break;
      }
    }
    for (    VariableDeclaration variableDeclaration : variableDeclarationsAndAccessedFieldsInMethod2) {
      if (variableDeclaration.resolveBinding().getKey().equals(variableDeclaration2.getVariableBindingKey())) {
        variableDeclarations.add(variableDeclaration);
        break;
      }
    }
    commonPassedParameters.put(key,variableDeclarations);
  }
  return commonPassedParameters;
}","public Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> getCommonPassedParameters(){
  Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> commonPassedParameters=new LinkedHashMap<VariableBindingKeyPair,ArrayList<VariableDeclaration>>();
  Set<VariableDeclaration> variableDeclarationsAndAccessedFieldsInMethod1=pdg1.getVariableDeclarationsAndAccessedFieldsInMethod();
  Set<VariableDeclaration> variableDeclarationsAndAccessedFieldsInMethod2=pdg2.getVariableDeclarationsAndAccessedFieldsInMethod();
  for (  VariableBindingKeyPair key : this.commonPassedParameters.keySet()) {
    ArrayList<AbstractVariable> value=this.commonPassedParameters.get(key);
    AbstractVariable variableDeclaration1=value.get(0);
    AbstractVariable variableDeclaration2=value.get(1);
    ArrayList<VariableDeclaration> variableDeclarations=new ArrayList<VariableDeclaration>();
    for (    VariableDeclaration variableDeclaration : variableDeclarationsAndAccessedFieldsInMethod1) {
      if (variableDeclaration.resolveBinding().getKey().equals(variableDeclaration1.getVariableBindingKey())) {
        variableDeclarations.add(variableDeclaration);
        break;
      }
    }
    for (    VariableDeclaration variableDeclaration : variableDeclarationsAndAccessedFieldsInMethod2) {
      if (variableDeclaration.resolveBinding().getKey().equals(variableDeclaration2.getVariableBindingKey())) {
        variableDeclarations.add(variableDeclaration);
        break;
      }
    }
    commonPassedParameters.put(key,variableDeclarations);
  }
  return commonPassedParameters;
}"
12071,"public Map<String,ArrayList<VariableDeclaration>> getDeclaredLocalVariablesInMappedNodes(){
  Map<String,ArrayList<VariableDeclaration>> declaredVariables=new LinkedHashMap<String,ArrayList<VariableDeclaration>>();
  Set<VariableDeclaration> variableDeclarationsAndAccessedFieldsInMethod1=pdg1.getVariableDeclarationsAndAccessedFieldsInMethod();
  Set<VariableDeclaration> variableDeclarationsAndAccessedFieldsInMethod2=pdg2.getVariableDeclarationsAndAccessedFieldsInMethod();
  for (  String key : this.declaredLocalVariablesInMappedNodes.keySet()) {
    ArrayList<AbstractVariable> value=this.declaredLocalVariablesInMappedNodes.get(key);
    AbstractVariable variableDeclaration1=value.get(0);
    AbstractVariable variableDeclaration2=value.get(1);
    ArrayList<VariableDeclaration> variableDeclarations=new ArrayList<VariableDeclaration>();
    for (    VariableDeclaration variableDeclaration : variableDeclarationsAndAccessedFieldsInMethod1) {
      if (variableDeclaration.resolveBinding().getKey().equals(variableDeclaration1.getVariableBindingKey())) {
        variableDeclarations.add(variableDeclaration);
        break;
      }
    }
    for (    VariableDeclaration variableDeclaration : variableDeclarationsAndAccessedFieldsInMethod2) {
      if (variableDeclaration.resolveBinding().getKey().equals(variableDeclaration2.getVariableBindingKey())) {
        variableDeclarations.add(variableDeclaration);
        break;
      }
    }
    declaredVariables.put(key,variableDeclarations);
  }
  return declaredVariables;
}","public Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> getDeclaredLocalVariablesInMappedNodes(){
  Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> declaredVariables=new LinkedHashMap<VariableBindingKeyPair,ArrayList<VariableDeclaration>>();
  Set<VariableDeclaration> variableDeclarationsAndAccessedFieldsInMethod1=pdg1.getVariableDeclarationsAndAccessedFieldsInMethod();
  Set<VariableDeclaration> variableDeclarationsAndAccessedFieldsInMethod2=pdg2.getVariableDeclarationsAndAccessedFieldsInMethod();
  for (  VariableBindingKeyPair key : this.declaredLocalVariablesInMappedNodes.keySet()) {
    ArrayList<AbstractVariable> value=this.declaredLocalVariablesInMappedNodes.get(key);
    AbstractVariable variableDeclaration1=value.get(0);
    AbstractVariable variableDeclaration2=value.get(1);
    ArrayList<VariableDeclaration> variableDeclarations=new ArrayList<VariableDeclaration>();
    for (    VariableDeclaration variableDeclaration : variableDeclarationsAndAccessedFieldsInMethod1) {
      if (variableDeclaration.resolveBinding().getKey().equals(variableDeclaration1.getVariableBindingKey())) {
        variableDeclarations.add(variableDeclaration);
        break;
      }
    }
    for (    VariableDeclaration variableDeclaration : variableDeclarationsAndAccessedFieldsInMethod2) {
      if (variableDeclaration.resolveBinding().getKey().equals(variableDeclaration2.getVariableBindingKey())) {
        variableDeclarations.add(variableDeclaration);
        break;
      }
    }
    declaredVariables.put(key,variableDeclarations);
  }
  return declaredVariables;
}"
12072,"private void findPassedParameters(){
  Set<AbstractVariable> passedParametersG1=extractPassedParameters(pdg1,mappedNodesG1);
  Set<AbstractVariable> passedParametersG2=extractPassedParameters(pdg2,mappedNodesG2);
  for (  PDGNodeMapping nodeMapping : maximumStateWithMinimumDifferences.getNodeMappings()) {
    PDGNode nodeG1=nodeMapping.getNodeG1();
    PDGNode nodeG2=nodeMapping.getNodeG2();
    List<AbstractVariable> nonAnonymousDeclaredVariablesG1=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG1=nodeG1.getDeclaredVariableIterator();
    while (declaredVariableIteratorG1.hasNext()) {
      AbstractVariable declaredVariableG1=declaredVariableIteratorG1.next();
      String key1=declaredVariableG1.getVariableBindingKey();
      String declaringType1=key1.substring(0,key1.indexOf(""String_Node_Str""));
      if (!declaringType1.contains(""String_Node_Str"")) {
        nonAnonymousDeclaredVariablesG1.add(declaredVariableG1);
      }
    }
    List<AbstractVariable> nonAnonymousDeclaredVariablesG2=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG2=nodeG2.getDeclaredVariableIterator();
    while (declaredVariableIteratorG2.hasNext()) {
      AbstractVariable declaredVariableG2=declaredVariableIteratorG2.next();
      String key2=declaredVariableG2.getVariableBindingKey();
      String declaringType2=key2.substring(0,key2.indexOf(""String_Node_Str""));
      if (!declaringType2.contains(""String_Node_Str"")) {
        nonAnonymousDeclaredVariablesG2.add(declaredVariableG2);
      }
    }
    int min=Math.min(nonAnonymousDeclaredVariablesG1.size(),nonAnonymousDeclaredVariablesG2.size());
    for (int i=0; i < min; i++) {
      AbstractVariable declaredVariableG1=nonAnonymousDeclaredVariablesG1.get(i);
      AbstractVariable declaredVariableG2=nonAnonymousDeclaredVariablesG2.get(i);
      ArrayList<AbstractVariable> declaredVariables=new ArrayList<AbstractVariable>();
      declaredVariables.add(declaredVariableG1);
      declaredVariables.add(declaredVariableG2);
      declaredLocalVariablesInMappedNodes.put(declaredVariableG1.getVariableBindingKey(),declaredVariables);
    }
    Set<AbstractVariable> dataDependences1=nodeG1.incomingDataDependencesFromNodesDeclaringVariables();
    Set<AbstractVariable> dataDependences2=nodeG2.incomingDataDependencesFromNodesDeclaringVariables();
    dataDependences1.retainAll(passedParametersG1);
    dataDependences2.retainAll(passedParametersG2);
    for (    ArrayList<AbstractVariable> variableDeclarations : commonPassedParameters.values()) {
      AbstractVariable variableDeclaration1=variableDeclarations.get(0);
      AbstractVariable variableDeclaration2=variableDeclarations.get(1);
      dataDependences1.remove(variableDeclaration1);
      dataDependences2.remove(variableDeclaration2);
    }
    if (dataDependences1.size() == dataDependences2.size()) {
      List<AbstractVariable> variables1=new ArrayList<AbstractVariable>(dataDependences1);
      List<AbstractVariable> variables2=new ArrayList<AbstractVariable>(dataDependences2);
      for (int i=0; i < variables1.size(); i++) {
        AbstractVariable variable1=variables1.get(i);
        AbstractVariable variable2=variables2.get(i);
        if (passedParametersG1.contains(variable1) && passedParametersG2.contains(variable2)) {
          ArrayList<AbstractVariable> variableDeclarations=new ArrayList<AbstractVariable>();
          variableDeclarations.add(variable1);
          variableDeclarations.add(variable2);
          commonPassedParameters.put(variable1.getVariableBindingKey(),variableDeclarations);
          passedParametersG1.remove(variable1);
          passedParametersG2.remove(variable2);
        }
      }
    }
  }
  this.passedParametersG1.addAll(passedParametersG1);
  this.passedParametersG2.addAll(passedParametersG2);
}","private void findPassedParameters(){
  Set<AbstractVariable> passedParametersG1=extractPassedParameters(pdg1,mappedNodesG1);
  Set<AbstractVariable> passedParametersG2=extractPassedParameters(pdg2,mappedNodesG2);
  Set<AbstractVariable> parametersToBeRemovedG1=new LinkedHashSet<AbstractVariable>();
  Set<AbstractVariable> parametersToBeRemovedG2=new LinkedHashSet<AbstractVariable>();
  for (  PDGNodeMapping nodeMapping : maximumStateWithMinimumDifferences.getNodeMappings()) {
    PDGNode nodeG1=nodeMapping.getNodeG1();
    PDGNode nodeG2=nodeMapping.getNodeG2();
    List<AbstractVariable> nonAnonymousDeclaredVariablesG1=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG1=nodeG1.getDeclaredVariableIterator();
    while (declaredVariableIteratorG1.hasNext()) {
      AbstractVariable declaredVariableG1=declaredVariableIteratorG1.next();
      String key1=declaredVariableG1.getVariableBindingKey();
      String declaringType1=key1.substring(0,key1.indexOf(""String_Node_Str""));
      if (!declaringType1.contains(""String_Node_Str"")) {
        nonAnonymousDeclaredVariablesG1.add(declaredVariableG1);
      }
    }
    List<AbstractVariable> nonAnonymousDeclaredVariablesG2=new ArrayList<AbstractVariable>();
    Iterator<AbstractVariable> declaredVariableIteratorG2=nodeG2.getDeclaredVariableIterator();
    while (declaredVariableIteratorG2.hasNext()) {
      AbstractVariable declaredVariableG2=declaredVariableIteratorG2.next();
      String key2=declaredVariableG2.getVariableBindingKey();
      String declaringType2=key2.substring(0,key2.indexOf(""String_Node_Str""));
      if (!declaringType2.contains(""String_Node_Str"")) {
        nonAnonymousDeclaredVariablesG2.add(declaredVariableG2);
      }
    }
    int min=Math.min(nonAnonymousDeclaredVariablesG1.size(),nonAnonymousDeclaredVariablesG2.size());
    for (int i=0; i < min; i++) {
      AbstractVariable declaredVariableG1=nonAnonymousDeclaredVariablesG1.get(i);
      AbstractVariable declaredVariableG2=nonAnonymousDeclaredVariablesG2.get(i);
      ArrayList<AbstractVariable> declaredVariables=new ArrayList<AbstractVariable>();
      declaredVariables.add(declaredVariableG1);
      declaredVariables.add(declaredVariableG2);
      VariableBindingKeyPair keyPair=new VariableBindingKeyPair(declaredVariableG1.getVariableBindingKey(),declaredVariableG2.getVariableBindingKey());
      declaredLocalVariablesInMappedNodes.put(keyPair,declaredVariables);
    }
    Set<AbstractVariable> dataDependences1=nodeG1.incomingDataDependencesFromNodesDeclaringVariables();
    Set<AbstractVariable> dataDependences2=nodeG2.incomingDataDependencesFromNodesDeclaringVariables();
    dataDependences1.retainAll(passedParametersG1);
    dataDependences2.retainAll(passedParametersG2);
    if (dataDependences1.size() == dataDependences2.size()) {
      List<AbstractVariable> variables1=new ArrayList<AbstractVariable>(dataDependences1);
      List<AbstractVariable> variables2=new ArrayList<AbstractVariable>(dataDependences2);
      for (int i=0; i < variables1.size(); i++) {
        AbstractVariable variable1=variables1.get(i);
        AbstractVariable variable2=variables2.get(i);
        if (passedParametersG1.contains(variable1) && passedParametersG2.contains(variable2)) {
          ArrayList<AbstractVariable> variableDeclarations=new ArrayList<AbstractVariable>();
          variableDeclarations.add(variable1);
          variableDeclarations.add(variable2);
          VariableBindingKeyPair keyPair=new VariableBindingKeyPair(variable1.getVariableBindingKey(),variable2.getVariableBindingKey());
          commonPassedParameters.put(keyPair,variableDeclarations);
          parametersToBeRemovedG1.add(variable1);
          parametersToBeRemovedG2.add(variable2);
        }
      }
    }
  }
  passedParametersG1.removeAll(parametersToBeRemovedG1);
  passedParametersG2.removeAll(parametersToBeRemovedG2);
  this.passedParametersG1.addAll(passedParametersG1);
  this.passedParametersG2.addAll(passedParametersG2);
}"
12073,"private boolean parameterIsUsedByNodesWithoutDifferences(VariableDeclaration variableDeclaration1,VariableDeclaration variableDeclaration2){
  PlainVariable variable1=new PlainVariable(variableDeclaration1);
  PlainVariable variable2=new PlainVariable(variableDeclaration2);
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode node1=pdgNodeMapping.getNodeG1();
    PDGNode node2=pdgNodeMapping.getNodeG2();
    if (node1.usesLocalVariable(variable1) && node2.usesLocalVariable(variable2)) {
      List<ASTNodeDifference> differences=pdgNodeMapping.getNonOverlappingNodeDifferences();
      if (differences.isEmpty())       return true;
      for (      ASTNodeDifference difference : differences) {
        BindingSignaturePair signaturePair=difference.getBindingSignaturePair();
        if (!signaturePair.getSignature1().containsBinding(variableDeclaration1.resolveBinding().getKey()) && !signaturePair.getSignature2().containsBinding(variableDeclaration2.resolveBinding().getKey())) {
          return true;
        }
      }
    }
  }
  return false;
}","private boolean parameterIsUsedByNodesWithoutDifferences(VariableDeclaration variableDeclaration1,VariableDeclaration variableDeclaration2){
  PlainVariable variable1=new PlainVariable(variableDeclaration1);
  PlainVariable variable2=new PlainVariable(variableDeclaration2);
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode node1=pdgNodeMapping.getNodeG1();
    PDGNode node2=pdgNodeMapping.getNodeG2();
    if (node1.usesLocalVariable(variable1) && node2.usesLocalVariable(variable2)) {
      List<ASTNodeDifference> differences=pdgNodeMapping.getNonOverlappingNodeDifferences();
      if (differences.isEmpty())       return true;
      boolean foundInDifferences=false;
      for (      ASTNodeDifference difference : differences) {
        BindingSignaturePair signaturePair=difference.getBindingSignaturePair();
        if (signaturePair.getSignature1().containsBinding(variableDeclaration1.resolveBinding().getKey()) && signaturePair.getSignature2().containsBinding(variableDeclaration2.resolveBinding().getKey())) {
          foundInDifferences=true;
          break;
        }
      }
      if (!foundInDifferences) {
        return true;
      }
    }
  }
  return false;
}"
12074,"private void modifySourceMethod(CompilationUnit compilationUnit,MethodDeclaration methodDeclaration,TreeSet<PDGNode> removableNodes,TreeSet<PDGNode> remainingNodesMovableBefore,TreeSet<PDGNode> remainingNodesMovableAfter,List<VariableDeclaration> returnedVariables,int index){
  AST ast=methodDeclaration.getAST();
  ASTRewrite methodBodyRewriter=ASTRewrite.create(ast);
  MethodInvocation methodInvocation=ast.newMethodInvocation();
  methodBodyRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  ListRewrite argumentsRewrite=methodBodyRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  String parameterName : originalPassedParameters.keySet()) {
    List<VariableDeclaration> variableDeclarations=originalPassedParameters.get(parameterName);
    argumentsRewrite.insertLast(variableDeclarations.get(index).getName(),null);
  }
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    List<Expression> expressions=new ArrayList<Expression>();
    if (difference.getExpression1() != null) {
      Expression expression1=difference.getExpression1().getExpression();
      expression1=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1);
      expressions.add(expression1);
    }
 else {
      expressions.add(null);
    }
    if (difference.getExpression2() != null) {
      Expression expression2=difference.getExpression2().getExpression();
      expression2=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2);
      expressions.add(expression2);
    }
 else {
      expressions.add(null);
    }
    Expression expression=expressions.get(index);
    boolean isReturnedVariable=false;
    if (expression != null)     isReturnedVariable=isReturnedVariable(expression,returnedVariables);
    if (!isReturnedVariable) {
      if (expression != null)       argumentsRewrite.insertLast(expression,null);
 else       argumentsRewrite.insertLast(ast.newThisExpression(),null);
    }
  }
  Statement firstStatement=removableNodes.first().getASTStatement();
  Block parentBlock=(Block)firstStatement.getParent();
  ListRewrite blockRewrite=methodBodyRewriter.getListRewrite(parentBlock,Block.STATEMENTS_PROPERTY);
  CloneStructureNode root=mapper.getCloneStructureRoot();
  List<CloneStructureNode> processedCloneStructureGapNodes=new ArrayList<CloneStructureNode>();
  Set<PDGNode> remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.addAll(remainingNodesMovableBefore);
  remainingNodes.addAll(remainingNodesMovableAfter);
  List<Statement> statementsToBeMovedBefore=new ArrayList<Statement>();
  List<Statement> statementsToBeMovedAfter=new ArrayList<Statement>();
  for (  PDGNode remainingNode : remainingNodes) {
    CloneStructureNode remainingCloneStructureNode=null;
    if (index == 0)     remainingCloneStructureNode=root.findNodeG1(remainingNode);
 else     remainingCloneStructureNode=root.findNodeG2(remainingNode);
    if (!processedCloneStructureGapNodes.contains(remainingCloneStructureNode.getParent())) {
      Statement statement=processCloneStructureGapNode(remainingCloneStructureNode,ast,methodBodyRewriter,index);
      if (remainingNodesMovableBefore.contains(remainingNode)) {
        statementsToBeMovedBefore.add(statement);
      }
 else       if (remainingNodesMovableAfter.contains(remainingNode)) {
        statementsToBeMovedAfter.add(statement);
      }
      methodBodyRewriter.remove(remainingNode.getASTStatement(),null);
    }
    processedCloneStructureGapNodes.add(remainingCloneStructureNode);
    for (    CloneStructureNode child : remainingCloneStructureNode.getChildren()) {
      if (child.getMapping() instanceof PDGElseGap)       processedCloneStructureGapNodes.add(child);
    }
  }
  Statement extractedMethodInvocationStatement=null;
  if (returnedVariables.size() == 1) {
    VariableDeclaration variableDeclaration=returnedVariables.get(0);
    Type variableType=extractType(variableDeclaration);
    VariableDeclarationFragment newFragment=ast.newVariableDeclarationFragment();
    methodBodyRewriter.set(newFragment,VariableDeclarationFragment.NAME_PROPERTY,variableDeclaration.getName(),null);
    ITypeBinding returnTypeBinding=findReturnTypeBinding();
    if (returnTypeBinding != null && !returnTypeBinding.isEqualTo(variableType.resolveBinding())) {
      CastExpression castExpression=ast.newCastExpression();
      methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
      methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,variableType,null);
      methodBodyRewriter.set(newFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,castExpression,null);
    }
 else {
      methodBodyRewriter.set(newFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,methodInvocation,null);
    }
    VariableDeclarationStatement newVariableDeclarationStatement=ast.newVariableDeclarationStatement(newFragment);
    methodBodyRewriter.set(newVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,variableType,null);
    blockRewrite.insertBefore(newVariableDeclarationStatement,firstStatement,null);
    extractedMethodInvocationStatement=newVariableDeclarationStatement;
  }
 else {
    ITypeBinding returnTypeBinding=findReturnTypeBinding();
    Statement methodInvocationStatement=null;
    if (returnTypeBinding != null) {
      ReturnStatement returnStatement=ast.newReturnStatement();
      if (returnTypeBinding.isEqualTo(methodDeclaration.getReturnType2().resolveBinding())) {
        methodBodyRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,methodInvocation,null);
      }
 else {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,methodDeclaration.getReturnType2(),null);
        methodBodyRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,castExpression,null);
      }
      methodInvocationStatement=returnStatement;
    }
 else {
      methodInvocationStatement=ast.newExpressionStatement(methodInvocation);
    }
    blockRewrite.insertBefore(methodInvocationStatement,firstStatement,null);
    extractedMethodInvocationStatement=methodInvocationStatement;
  }
  for (  Statement movedBefore : statementsToBeMovedBefore) {
    blockRewrite.insertBefore(movedBefore,extractedMethodInvocationStatement,null);
  }
  for (int i=statementsToBeMovedAfter.size() - 1; i >= 0; i--) {
    Statement movedAfter=statementsToBeMovedAfter.get(i);
    blockRewrite.insertAfter(movedAfter,extractedMethodInvocationStatement,null);
  }
  for (  PDGNode pdgNode : removableNodes) {
    Statement statement=pdgNode.getASTStatement();
    methodBodyRewriter.remove(statement,null);
  }
  Set<LabeledStatement> labeledStatements=labeledStatementsToBeRemoved.get(index);
  for (  LabeledStatement labeled : labeledStatements) {
    methodBodyRewriter.remove(labeled,null);
  }
  try {
    TextEdit sourceEdit=methodBodyRewriter.rewriteAST();
    ICompilationUnit sourceICompilationUnit=(ICompilationUnit)compilationUnit.getJavaElement();
    CompilationUnitChange change=compilationUnitChanges.get(sourceICompilationUnit);
    change.getEdit().addChild(sourceEdit);
    change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
}","private void modifySourceMethod(CompilationUnit compilationUnit,MethodDeclaration methodDeclaration,TreeSet<PDGNode> removableNodes,TreeSet<PDGNode> remainingNodesMovableBefore,TreeSet<PDGNode> remainingNodesMovableAfter,List<VariableDeclaration> returnedVariables,int index){
  AST ast=methodDeclaration.getAST();
  ASTRewrite methodBodyRewriter=ASTRewrite.create(ast);
  MethodInvocation methodInvocation=ast.newMethodInvocation();
  methodBodyRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  ListRewrite argumentsRewrite=methodBodyRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  VariableBindingKeyPair parameterName : originalPassedParameters.keySet()) {
    List<VariableDeclaration> variableDeclarations=originalPassedParameters.get(parameterName);
    argumentsRewrite.insertLast(variableDeclarations.get(index).getName(),null);
  }
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    List<Expression> expressions=new ArrayList<Expression>();
    if (difference.getExpression1() != null) {
      Expression expression1=difference.getExpression1().getExpression();
      expression1=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression1);
      expressions.add(expression1);
    }
 else {
      expressions.add(null);
    }
    if (difference.getExpression2() != null) {
      Expression expression2=difference.getExpression2().getExpression();
      expression2=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(expression2);
      expressions.add(expression2);
    }
 else {
      expressions.add(null);
    }
    Expression expression=expressions.get(index);
    boolean isReturnedVariable=false;
    if (expression != null)     isReturnedVariable=isReturnedVariable(expression,returnedVariables);
    if (!isReturnedVariable) {
      if (expression != null)       argumentsRewrite.insertLast(expression,null);
 else       argumentsRewrite.insertLast(ast.newThisExpression(),null);
    }
  }
  Statement firstStatement=removableNodes.first().getASTStatement();
  Block parentBlock=(Block)firstStatement.getParent();
  ListRewrite blockRewrite=methodBodyRewriter.getListRewrite(parentBlock,Block.STATEMENTS_PROPERTY);
  CloneStructureNode root=mapper.getCloneStructureRoot();
  List<CloneStructureNode> processedCloneStructureGapNodes=new ArrayList<CloneStructureNode>();
  Set<PDGNode> remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.addAll(remainingNodesMovableBefore);
  remainingNodes.addAll(remainingNodesMovableAfter);
  List<Statement> statementsToBeMovedBefore=new ArrayList<Statement>();
  List<Statement> statementsToBeMovedAfter=new ArrayList<Statement>();
  for (  PDGNode remainingNode : remainingNodes) {
    CloneStructureNode remainingCloneStructureNode=null;
    if (index == 0)     remainingCloneStructureNode=root.findNodeG1(remainingNode);
 else     remainingCloneStructureNode=root.findNodeG2(remainingNode);
    if (!processedCloneStructureGapNodes.contains(remainingCloneStructureNode.getParent())) {
      Statement statement=processCloneStructureGapNode(remainingCloneStructureNode,ast,methodBodyRewriter,index);
      if (remainingNodesMovableBefore.contains(remainingNode)) {
        statementsToBeMovedBefore.add(statement);
      }
 else       if (remainingNodesMovableAfter.contains(remainingNode)) {
        statementsToBeMovedAfter.add(statement);
      }
      methodBodyRewriter.remove(remainingNode.getASTStatement(),null);
    }
    processedCloneStructureGapNodes.add(remainingCloneStructureNode);
    for (    CloneStructureNode child : remainingCloneStructureNode.getChildren()) {
      if (child.getMapping() instanceof PDGElseGap)       processedCloneStructureGapNodes.add(child);
    }
  }
  Statement extractedMethodInvocationStatement=null;
  if (returnedVariables.size() == 1) {
    VariableDeclaration variableDeclaration=returnedVariables.get(0);
    Type variableType=extractType(variableDeclaration);
    VariableDeclarationFragment newFragment=ast.newVariableDeclarationFragment();
    methodBodyRewriter.set(newFragment,VariableDeclarationFragment.NAME_PROPERTY,variableDeclaration.getName(),null);
    ITypeBinding returnTypeBinding=findReturnTypeBinding();
    if (returnTypeBinding != null && !returnTypeBinding.isEqualTo(variableType.resolveBinding())) {
      CastExpression castExpression=ast.newCastExpression();
      methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
      methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,variableType,null);
      methodBodyRewriter.set(newFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,castExpression,null);
    }
 else {
      methodBodyRewriter.set(newFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,methodInvocation,null);
    }
    VariableDeclarationStatement newVariableDeclarationStatement=ast.newVariableDeclarationStatement(newFragment);
    methodBodyRewriter.set(newVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,variableType,null);
    blockRewrite.insertBefore(newVariableDeclarationStatement,firstStatement,null);
    extractedMethodInvocationStatement=newVariableDeclarationStatement;
  }
 else {
    ITypeBinding returnTypeBinding=findReturnTypeBinding();
    Statement methodInvocationStatement=null;
    if (returnTypeBinding != null) {
      ReturnStatement returnStatement=ast.newReturnStatement();
      if (returnTypeBinding.isEqualTo(methodDeclaration.getReturnType2().resolveBinding())) {
        methodBodyRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,methodInvocation,null);
      }
 else {
        CastExpression castExpression=ast.newCastExpression();
        methodBodyRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,methodInvocation,null);
        methodBodyRewriter.set(castExpression,CastExpression.TYPE_PROPERTY,methodDeclaration.getReturnType2(),null);
        methodBodyRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,castExpression,null);
      }
      methodInvocationStatement=returnStatement;
    }
 else {
      methodInvocationStatement=ast.newExpressionStatement(methodInvocation);
    }
    blockRewrite.insertBefore(methodInvocationStatement,firstStatement,null);
    extractedMethodInvocationStatement=methodInvocationStatement;
  }
  for (  Statement movedBefore : statementsToBeMovedBefore) {
    blockRewrite.insertBefore(movedBefore,extractedMethodInvocationStatement,null);
  }
  for (int i=statementsToBeMovedAfter.size() - 1; i >= 0; i--) {
    Statement movedAfter=statementsToBeMovedAfter.get(i);
    blockRewrite.insertAfter(movedAfter,extractedMethodInvocationStatement,null);
  }
  for (  PDGNode pdgNode : removableNodes) {
    Statement statement=pdgNode.getASTStatement();
    methodBodyRewriter.remove(statement,null);
  }
  Set<LabeledStatement> labeledStatements=labeledStatementsToBeRemoved.get(index);
  for (  LabeledStatement labeled : labeledStatements) {
    methodBodyRewriter.remove(labeled,null);
  }
  try {
    TextEdit sourceEdit=methodBodyRewriter.rewriteAST();
    ICompilationUnit sourceICompilationUnit=(ICompilationUnit)compilationUnit.getJavaElement();
    CompilationUnitChange change=compilationUnitChanges.get(sourceICompilationUnit);
    change.getEdit().addChild(sourceEdit);
    change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
}"
12075,"private void extractClone(){
  CompilationUnit sourceCompilationUnit=null;
  ICompilationUnit sourceICompilationUnit=null;
  TypeDeclaration sourceTypeDeclaration=null;
  ASTRewrite sourceRewriter=null;
  AST ast=null;
  Document document=null;
  IFile file=null;
  ITypeBinding commonSuperTypeOfSourceTypeDeclarations=null;
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding())) {
    sourceCompilationUnit=sourceCompilationUnits.get(0);
    sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
    sourceTypeDeclaration=sourceTypeDeclarations.get(0);
    sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
    ast=sourceTypeDeclaration.getAST();
  }
 else {
    ITypeBinding typeBinding1=sourceTypeDeclarations.get(0).resolveBinding();
    ITypeBinding typeBinding2=sourceTypeDeclarations.get(1).resolveBinding();
    commonSuperTypeOfSourceTypeDeclarations=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
    if (commonSuperTypeOfSourceTypeDeclarations != null) {
      boolean superclassInheritedOnlyByRefactoringSubclasses=false;
      if (!commonSuperTypeOfSourceTypeDeclarations.getQualifiedName().equals(""String_Node_Str"")) {
        CompilationUnitCache cache=CompilationUnitCache.getInstance();
        Set<IType> subTypes=cache.getSubTypes((IType)commonSuperTypeOfSourceTypeDeclarations.getJavaElement());
        if (subTypes.size() == 2 && subTypes.contains((IType)typeBinding1.getJavaElement()) && subTypes.contains((IType)typeBinding2.getJavaElement()))         superclassInheritedOnlyByRefactoringSubclasses=true;
      }
      boolean superclassIsOneOfTheSourceTypeDeclarations=false;
      if (typeBinding1.isEqualTo(commonSuperTypeOfSourceTypeDeclarations) || typeBinding2.isEqualTo(commonSuperTypeOfSourceTypeDeclarations))       superclassIsOneOfTheSourceTypeDeclarations=true;
      if (((mapper.getAccessedLocalFieldsG1().isEmpty() && mapper.getAccessedLocalFieldsG2().isEmpty() && mapper.getAccessedLocalMethodsG1().isEmpty()&& mapper.getAccessedLocalMethodsG2().isEmpty()) || superclassInheritedOnlyByRefactoringSubclasses || superclassIsOneOfTheSourceTypeDeclarations) && ASTReader.getSystemObject().getClassObject(commonSuperTypeOfSourceTypeDeclarations.getQualifiedName()) != null) {
        IJavaElement javaElement=commonSuperTypeOfSourceTypeDeclarations.getJavaElement();
        javaElementsToOpenInEditor.add(javaElement);
        ICompilationUnit iCompilationUnit=(ICompilationUnit)javaElement.getParent();
        ASTParser parser=ASTParser.newParser(AST.JLS4);
        parser.setKind(ASTParser.K_COMPILATION_UNIT);
        parser.setSource(iCompilationUnit);
        parser.setResolveBindings(true);
        CompilationUnit compilationUnit=(CompilationUnit)parser.createAST(null);
        List<AbstractTypeDeclaration> typeDeclarations=compilationUnit.types();
        for (        AbstractTypeDeclaration abstractTypeDeclaration : typeDeclarations) {
          if (abstractTypeDeclaration instanceof TypeDeclaration) {
            TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
            if (typeDeclaration.resolveBinding().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)) {
              sourceCompilationUnit=compilationUnit;
              sourceICompilationUnit=iCompilationUnit;
              sourceTypeDeclaration=typeDeclaration;
              sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
              ast=sourceTypeDeclaration.getAST();
              break;
            }
          }
        }
        MultiTextEdit multiTextEdit=new MultiTextEdit();
        CompilationUnitChange compilationUnitChange=new CompilationUnitChange(""String_Node_Str"",iCompilationUnit);
        compilationUnitChange.setEdit(multiTextEdit);
        compilationUnitChanges.put(iCompilationUnit,compilationUnitChange);
      }
 else {
        this.intermediateClassName=""String_Node_Str"" + commonSuperTypeOfSourceTypeDeclarations.getName();
        CompilationUnit compilationUnit=sourceCompilationUnits.get(0);
        ICompilationUnit iCompilationUnit=(ICompilationUnit)compilationUnit.getJavaElement();
        IContainer container=(IContainer)iCompilationUnit.getResource().getParent();
        if (container instanceof IProject) {
          IProject contextProject=(IProject)container;
          file=contextProject.getFile(intermediateClassName + ""String_Node_Str"");
        }
 else         if (container instanceof IFolder) {
          IFolder contextFolder=(IFolder)container;
          file=contextFolder.getFile(intermediateClassName + ""String_Node_Str"");
        }
        boolean intermediateAlreadyExists=false;
        ICompilationUnit intermediateICompilationUnit=JavaCore.createCompilationUnitFrom(file);
        javaElementsToOpenInEditor.add(intermediateICompilationUnit);
        ASTParser intermediateParser=ASTParser.newParser(AST.JLS4);
        intermediateParser.setKind(ASTParser.K_COMPILATION_UNIT);
        if (file.exists()) {
          intermediateAlreadyExists=true;
          intermediateParser.setSource(intermediateICompilationUnit);
          intermediateParser.setResolveBindings(true);
        }
 else {
          document=new Document();
          intermediateParser.setSource(document.get().toCharArray());
        }
        CompilationUnit intermediateCompilationUnit=(CompilationUnit)intermediateParser.createAST(null);
        AST intermediateAST=intermediateCompilationUnit.getAST();
        ASTRewrite intermediateRewriter=ASTRewrite.create(intermediateAST);
        ListRewrite intermediateTypesRewrite=intermediateRewriter.getListRewrite(intermediateCompilationUnit,CompilationUnit.TYPES_PROPERTY);
        TypeDeclaration intermediateTypeDeclaration=null;
        if (intermediateAlreadyExists) {
          List<AbstractTypeDeclaration> abstractTypeDeclarations=intermediateCompilationUnit.types();
          for (          AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
            if (abstractTypeDeclaration instanceof TypeDeclaration) {
              TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
              if (typeDeclaration.getName().getIdentifier().equals(intermediateClassName)) {
                intermediateTypeDeclaration=typeDeclaration;
                int intermediateModifiers=intermediateTypeDeclaration.getModifiers();
                if ((intermediateModifiers & Modifier.ABSTRACT) == 0) {
                  ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
                  intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
                }
                break;
              }
            }
          }
          MultiTextEdit intermediateMultiTextEdit=new MultiTextEdit();
          CompilationUnitChange intermediateCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",intermediateICompilationUnit);
          intermediateCompilationUnitChange.setEdit(intermediateMultiTextEdit);
          compilationUnitChanges.put(intermediateICompilationUnit,intermediateCompilationUnitChange);
        }
 else {
          if (compilationUnit.getPackage() != null) {
            intermediateRewriter.set(intermediateCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,compilationUnit.getPackage(),null);
          }
          intermediateTypeDeclaration=intermediateAST.newTypeDeclaration();
          SimpleName intermediateName=intermediateAST.newSimpleName(intermediateClassName);
          intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.NAME_PROPERTY,intermediateName,null);
          ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
          intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
          intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
          intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,intermediateAST.newSimpleType(intermediateAST.newSimpleName(commonSuperTypeOfSourceTypeDeclarations.getName())),null);
          intermediateTypesRewrite.insertLast(intermediateTypeDeclaration,null);
        }
        sourceCompilationUnit=intermediateCompilationUnit;
        sourceICompilationUnit=intermediateICompilationUnit;
        sourceTypeDeclaration=intermediateTypeDeclaration;
        sourceRewriter=intermediateRewriter;
        ast=intermediateAST;
      }
    }
  }
  MethodDeclaration sourceMethodDeclaration=sourceMethodDeclarations.get(0);
  Set<ITypeBinding> requiredImportTypeBindings=new LinkedHashSet<ITypeBinding>();
  ListRewrite bodyDeclarationsRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  if (commonSuperTypeOfSourceTypeDeclarations != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding())) {
    Set<VariableDeclaration> accessedLocalFieldsG1=mapper.getAccessedLocalFieldsG1();
    Set<VariableDeclaration> accessedLocalFieldsG2=mapper.getAccessedLocalFieldsG2();
    for (    VariableDeclaration localFieldG1 : accessedLocalFieldsG1) {
      FieldDeclaration originalFieldDeclarationG1=(FieldDeclaration)localFieldG1.getParent();
      for (      VariableDeclaration localFieldG2 : accessedLocalFieldsG2) {
        FieldDeclaration originalFieldDeclarationG2=(FieldDeclaration)localFieldG2.getParent();
        if (localFieldG1.getName().getIdentifier().equals(localFieldG2.getName().getIdentifier())) {
          if (originalFieldDeclarationG1.getType().resolveBinding().isEqualTo(originalFieldDeclarationG2.getType().resolveBinding())) {
            Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
            typeBindings.add(localFieldG1.resolveBinding().getType());
            getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
            fieldDeclarationsToBePulledUp.get(0).add(localFieldG1);
            fieldDeclarationsToBePulledUp.get(1).add(localFieldG2);
            VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
            sourceRewriter.set(fragment,VariableDeclarationFragment.NAME_PROPERTY,ast.newSimpleName(localFieldG1.getName().getIdentifier()),null);
            if (localFieldG1.getInitializer() != null && localFieldG2.getInitializer() != null) {
              Expression initializer1=localFieldG1.getInitializer();
              Expression initializer2=localFieldG2.getInitializer();
              if (initializer1.subtreeMatch(new ASTMatcher(),initializer2)) {
                sourceRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,ASTNode.copySubtree(ast,initializer1),null);
              }
            }
            FieldDeclaration newFieldDeclaration=ast.newFieldDeclaration(fragment);
            sourceRewriter.set(newFieldDeclaration,FieldDeclaration.TYPE_PROPERTY,originalFieldDeclarationG1.getType(),null);
            if (originalFieldDeclarationG1.getJavadoc() != null) {
              sourceRewriter.set(newFieldDeclaration,FieldDeclaration.JAVADOC_PROPERTY,originalFieldDeclarationG1.getJavadoc(),null);
            }
            ListRewrite newFieldDeclarationModifiersRewrite=sourceRewriter.getListRewrite(newFieldDeclaration,FieldDeclaration.MODIFIERS2_PROPERTY);
            newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
            List<IExtendedModifier> originalModifiers=originalFieldDeclarationG1.modifiers();
            for (            IExtendedModifier extendedModifier : originalModifiers) {
              if (extendedModifier.isModifier()) {
                Modifier modifier=(Modifier)extendedModifier;
                if (modifier.isFinal()) {
                  newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.FINAL_KEYWORD),null);
                }
 else                 if (modifier.isStatic()) {
                  newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD),null);
                }
 else                 if (modifier.isTransient()) {
                  newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.TRANSIENT_KEYWORD),null);
                }
 else                 if (modifier.isVolatile()) {
                  newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.VOLATILE_KEYWORD),null);
                }
              }
            }
            bodyDeclarationsRewrite.insertLast(newFieldDeclaration,null);
            break;
          }
        }
      }
    }
    Set<MethodInvocationObject> accessedLocalMethodsG1=mapper.getAccessedLocalMethodsG1();
    Set<MethodInvocationObject> accessedLocalMethodsG2=mapper.getAccessedLocalMethodsG2();
    for (    MethodInvocationObject localMethodG1 : accessedLocalMethodsG1) {
      for (      MethodInvocationObject localMethodG2 : accessedLocalMethodsG2) {
        if (localMethodG1.getMethodName().equals(localMethodG2.getMethodName()) && localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) && localMethodG1.getParameterTypeList().equals(localMethodG2.getParameterTypeList())) {
          MethodDeclaration[] methodDeclarationsG1=sourceTypeDeclarations.get(0).getMethods();
          IMethodBinding localMethodBindingG1=localMethodG1.getMethodInvocation().resolveMethodBinding();
          MethodDeclaration methodDeclaration1=null;
          for (          MethodDeclaration methodDeclarationG1 : methodDeclarationsG1) {
            if (methodDeclarationG1.resolveBinding().isEqualTo(localMethodBindingG1)) {
              methodDeclaration1=methodDeclarationG1;
              break;
            }
          }
          MethodDeclaration[] methodDeclarationsG2=sourceTypeDeclarations.get(1).getMethods();
          IMethodBinding localMethodBindingG2=localMethodG2.getMethodInvocation().resolveMethodBinding();
          MethodDeclaration methodDeclaration2=null;
          for (          MethodDeclaration methodDeclarationG2 : methodDeclarationsG2) {
            if (methodDeclarationG2.resolveBinding().isEqualTo(localMethodBindingG2)) {
              methodDeclaration2=methodDeclarationG2;
              break;
            }
          }
          boolean exactClones=methodDeclaration1.subtreeMatch(new ASTMatcher(),methodDeclaration2);
          if (exactClones) {
            bodyDeclarationsRewrite.insertLast(methodDeclaration1,null);
            methodDeclarationsToBePulledUp.get(0).add(methodDeclaration1);
            methodDeclarationsToBePulledUp.get(1).add(methodDeclaration2);
          }
 else {
            MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
            sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(methodDeclaration1.getName().getIdentifier()),null);
            sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,methodDeclaration1.getReturnType2(),null);
            ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
            List<IExtendedModifier> originalModifiers=methodDeclaration1.modifiers();
            for (            IExtendedModifier extendedModifier : originalModifiers) {
              if (extendedModifier.isModifier()) {
                Modifier modifier=(Modifier)extendedModifier;
                if (modifier.isProtected()) {
                  modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                }
 else                 if (modifier.isPublic()) {
                  modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
                }
              }
            }
            modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
            ListRewrite parametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
            List<SingleVariableDeclaration> parameters=methodDeclaration1.parameters();
            for (            SingleVariableDeclaration parameter : parameters) {
              parametersRewrite.insertLast(parameter,null);
            }
            ListRewrite thrownExceptionsRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
            List<Name> thrownExceptions=methodDeclaration1.thrownExceptions();
            for (            Name thrownException : thrownExceptions) {
              thrownExceptionsRewrite.insertLast(thrownException,null);
            }
            bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
          }
          break;
        }
      }
    }
  }
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  List<VariableDeclaration> returnedVariables1=this.returnedVariables.get(0);
  List<VariableDeclaration> returnedVariables2=this.returnedVariables.get(1);
  ITypeBinding returnTypeBinding=null;
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1) {
    Type returnType1=extractType(returnedVariables1.get(0));
    Type returnType2=extractType(returnedVariables2.get(0));
    if (returnType1.resolveBinding().isEqualTo(returnType2.resolveBinding()))     returnTypeBinding=returnType1.resolveBinding();
 else     returnTypeBinding=ASTNodeMatcher.commonSuperType(returnType1.resolveBinding(),returnType2.resolveBinding());
  }
 else {
    returnTypeBinding=findReturnTypeBinding();
  }
  if (returnTypeBinding != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(returnTypeBinding);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
    Type returnType=generateTypeFromTypeBinding(returnTypeBinding,ast,sourceRewriter);
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
  }
 else {
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
  }
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
  if ((sourceMethodDeclarations.get(0).getModifiers() & Modifier.STATIC) != 0 && (sourceMethodDeclarations.get(1).getModifiers() & Modifier.STATIC) != 0) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  List<Name> thrownExceptions1=sourceMethodDeclarations.get(0).thrownExceptions();
  List<Name> thrownExceptions2=sourceMethodDeclarations.get(1).thrownExceptions();
  for (  Name thrownException1 : thrownExceptions1) {
    for (    Name thrownException2 : thrownExceptions2) {
      if (thrownException1.resolveTypeBinding().isEqualTo(thrownException2.resolveTypeBinding())) {
        thrownExceptionRewrite.insertLast(thrownException1,null);
        break;
      }
    }
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  Map<String,ArrayList<VariableDeclaration>> commonPassedParameters=mapper.getCommonPassedParameters();
  for (  String parameterName : commonPassedParameters.keySet()) {
    ArrayList<VariableDeclaration> variableDeclarations=commonPassedParameters.get(parameterName);
    VariableDeclaration variableDeclaration1=variableDeclarations.get(0);
    VariableDeclaration variableDeclaration2=variableDeclarations.get(1);
    if (parameterIsUsedByNodesWithoutDifferences(variableDeclaration1,variableDeclaration2)) {
      if (!variableDeclaration1.resolveBinding().isField() && !variableDeclaration2.resolveBinding().isField()) {
        ITypeBinding typeBinding1=extractType(variableDeclaration1).resolveBinding();
        ITypeBinding typeBinding2=extractType(variableDeclaration2).resolveBinding();
        ITypeBinding typeBinding=null;
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
        Type variableType=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(typeBinding);
        getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration1.getName(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
        parameterRewrite.insertLast(parameter,null);
        originalPassedParameters.put(parameterName,variableDeclarations);
      }
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode1=pdgNodeMapping.getNodeG1();
    Statement statement1=pdgNode1.getASTStatement();
    TypeVisitor typeVisitor1=new TypeVisitor();
    statement1.accept(typeVisitor1);
    getSimpleTypeBindings(typeVisitor1.getTypeBindings(),requiredImportTypeBindings);
    PDGNode pdgNode2=pdgNodeMapping.getNodeG2();
    Statement statement2=pdgNode2.getASTStatement();
    TypeVisitor typeVisitor2=new TypeVisitor();
    statement2.accept(typeVisitor2);
    getSimpleTypeBindings(typeVisitor2.getTypeBindings(),requiredImportTypeBindings);
  }
  CloneStructureNode root=mapper.getCloneStructureRoot();
  for (  CloneStructureNode child : root.getChildren()) {
    if (child.getMapping() instanceof PDGNodeMapping) {
      Statement statement=processCloneStructureNode(child,ast,sourceRewriter);
      methodBodyRewrite.insertLast(statement,null);
    }
  }
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1 && findReturnTypeBinding() == null) {
    ReturnStatement returnStatement=ast.newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariables1.get(0).getName(),null);
    methodBodyRewrite.insertLast(returnStatement,null);
  }
  int i=0;
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    AbstractExpression expression1=difference.getExpression1();
    AbstractExpression expression2=difference.getExpression2();
    boolean isReturnedVariable=false;
    if (expression1 != null) {
      isReturnedVariable=isReturnedVariable(expression1.getExpression(),this.returnedVariables.get(0));
    }
 else     if (expression2 != null) {
      isReturnedVariable=isReturnedVariable(expression2.getExpression(),this.returnedVariables.get(1));
    }
    if (!isReturnedVariable) {
      ITypeBinding typeBinding=null;
      if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH) || differenceContainsSubDifferenceWithSubclassTypeMismatch(difference)) {
        ITypeBinding typeBinding1=expression1 != null ? expression1.getExpression().resolveTypeBinding() : expression2.getExpression().resolveTypeBinding();
        ITypeBinding typeBinding2=expression2 != null ? expression2.getExpression().resolveTypeBinding() : expression1.getExpression().resolveTypeBinding();
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
      }
 else {
        typeBinding=expression1 != null ? expression1.getExpression().resolveTypeBinding() : expression2.getExpression().resolveTypeBinding();
      }
      Type type=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
      Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
      typeBindings.add(typeBinding);
      getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(""String_Node_Str"" + i),null);
      i++;
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
  try {
    CompilationUnitChange change=compilationUnitChanges.get(sourceICompilationUnit);
    if (change != null) {
      ImportRewrite importRewrite=ImportRewrite.create(sourceCompilationUnit,true);
      for (      ITypeBinding typeBinding : requiredImportTypeBindings) {
        if (!typeBinding.isNested())         importRewrite.addImport(typeBinding);
      }
      TextEdit importEdit=importRewrite.rewriteImports(null);
      if (importRewrite.getCreatedImports().length > 0) {
        change.getEdit().addChild(importEdit);
        change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{importEdit}));
      }
      TextEdit sourceEdit=sourceRewriter.rewriteAST();
      change.getEdit().addChild(sourceEdit);
      change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
    }
    if (document != null) {
      for (      ITypeBinding typeBinding : requiredImportTypeBindings) {
        addImportDeclaration(typeBinding,sourceCompilationUnit,sourceRewriter);
      }
      TextEdit intermediateEdit=sourceRewriter.rewriteAST(document,null);
      intermediateEdit.apply(document);
      CreateCompilationUnitChange createCompilationUnitChange=new CreateCompilationUnitChange(sourceICompilationUnit,document.get(),file.getCharset());
      createCompilationUnitChanges.put(sourceICompilationUnit,createCompilationUnitChange);
    }
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
catch (  CoreException e) {
    e.printStackTrace();
  }
}","private void extractClone(){
  CompilationUnit sourceCompilationUnit=null;
  ICompilationUnit sourceICompilationUnit=null;
  TypeDeclaration sourceTypeDeclaration=null;
  ASTRewrite sourceRewriter=null;
  AST ast=null;
  Document document=null;
  IFile file=null;
  ITypeBinding commonSuperTypeOfSourceTypeDeclarations=null;
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding())) {
    sourceCompilationUnit=sourceCompilationUnits.get(0);
    sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
    sourceTypeDeclaration=sourceTypeDeclarations.get(0);
    sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
    ast=sourceTypeDeclaration.getAST();
  }
 else {
    ITypeBinding typeBinding1=sourceTypeDeclarations.get(0).resolveBinding();
    ITypeBinding typeBinding2=sourceTypeDeclarations.get(1).resolveBinding();
    commonSuperTypeOfSourceTypeDeclarations=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
    if (commonSuperTypeOfSourceTypeDeclarations != null) {
      boolean superclassInheritedOnlyByRefactoringSubclasses=false;
      if (!commonSuperTypeOfSourceTypeDeclarations.getQualifiedName().equals(""String_Node_Str"")) {
        CompilationUnitCache cache=CompilationUnitCache.getInstance();
        Set<IType> subTypes=cache.getSubTypes((IType)commonSuperTypeOfSourceTypeDeclarations.getJavaElement());
        if (subTypes.size() == 2 && subTypes.contains((IType)typeBinding1.getJavaElement()) && subTypes.contains((IType)typeBinding2.getJavaElement()))         superclassInheritedOnlyByRefactoringSubclasses=true;
      }
      boolean superclassIsOneOfTheSourceTypeDeclarations=false;
      if (typeBinding1.isEqualTo(commonSuperTypeOfSourceTypeDeclarations) || typeBinding2.isEqualTo(commonSuperTypeOfSourceTypeDeclarations))       superclassIsOneOfTheSourceTypeDeclarations=true;
      if (((mapper.getAccessedLocalFieldsG1().isEmpty() && mapper.getAccessedLocalFieldsG2().isEmpty() && mapper.getAccessedLocalMethodsG1().isEmpty()&& mapper.getAccessedLocalMethodsG2().isEmpty()) || superclassInheritedOnlyByRefactoringSubclasses || superclassIsOneOfTheSourceTypeDeclarations) && ASTReader.getSystemObject().getClassObject(commonSuperTypeOfSourceTypeDeclarations.getQualifiedName()) != null) {
        IJavaElement javaElement=commonSuperTypeOfSourceTypeDeclarations.getJavaElement();
        javaElementsToOpenInEditor.add(javaElement);
        ICompilationUnit iCompilationUnit=(ICompilationUnit)javaElement.getParent();
        ASTParser parser=ASTParser.newParser(AST.JLS4);
        parser.setKind(ASTParser.K_COMPILATION_UNIT);
        parser.setSource(iCompilationUnit);
        parser.setResolveBindings(true);
        CompilationUnit compilationUnit=(CompilationUnit)parser.createAST(null);
        List<AbstractTypeDeclaration> typeDeclarations=compilationUnit.types();
        for (        AbstractTypeDeclaration abstractTypeDeclaration : typeDeclarations) {
          if (abstractTypeDeclaration instanceof TypeDeclaration) {
            TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
            if (typeDeclaration.resolveBinding().isEqualTo(commonSuperTypeOfSourceTypeDeclarations)) {
              sourceCompilationUnit=compilationUnit;
              sourceICompilationUnit=iCompilationUnit;
              sourceTypeDeclaration=typeDeclaration;
              sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
              ast=sourceTypeDeclaration.getAST();
              break;
            }
          }
        }
        MultiTextEdit multiTextEdit=new MultiTextEdit();
        CompilationUnitChange compilationUnitChange=new CompilationUnitChange(""String_Node_Str"",iCompilationUnit);
        compilationUnitChange.setEdit(multiTextEdit);
        compilationUnitChanges.put(iCompilationUnit,compilationUnitChange);
      }
 else {
        this.intermediateClassName=""String_Node_Str"" + commonSuperTypeOfSourceTypeDeclarations.getName();
        CompilationUnit compilationUnit=sourceCompilationUnits.get(0);
        ICompilationUnit iCompilationUnit=(ICompilationUnit)compilationUnit.getJavaElement();
        IContainer container=(IContainer)iCompilationUnit.getResource().getParent();
        if (container instanceof IProject) {
          IProject contextProject=(IProject)container;
          file=contextProject.getFile(intermediateClassName + ""String_Node_Str"");
        }
 else         if (container instanceof IFolder) {
          IFolder contextFolder=(IFolder)container;
          file=contextFolder.getFile(intermediateClassName + ""String_Node_Str"");
        }
        boolean intermediateAlreadyExists=false;
        ICompilationUnit intermediateICompilationUnit=JavaCore.createCompilationUnitFrom(file);
        javaElementsToOpenInEditor.add(intermediateICompilationUnit);
        ASTParser intermediateParser=ASTParser.newParser(AST.JLS4);
        intermediateParser.setKind(ASTParser.K_COMPILATION_UNIT);
        if (file.exists()) {
          intermediateAlreadyExists=true;
          intermediateParser.setSource(intermediateICompilationUnit);
          intermediateParser.setResolveBindings(true);
        }
 else {
          document=new Document();
          intermediateParser.setSource(document.get().toCharArray());
        }
        CompilationUnit intermediateCompilationUnit=(CompilationUnit)intermediateParser.createAST(null);
        AST intermediateAST=intermediateCompilationUnit.getAST();
        ASTRewrite intermediateRewriter=ASTRewrite.create(intermediateAST);
        ListRewrite intermediateTypesRewrite=intermediateRewriter.getListRewrite(intermediateCompilationUnit,CompilationUnit.TYPES_PROPERTY);
        TypeDeclaration intermediateTypeDeclaration=null;
        if (intermediateAlreadyExists) {
          List<AbstractTypeDeclaration> abstractTypeDeclarations=intermediateCompilationUnit.types();
          for (          AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
            if (abstractTypeDeclaration instanceof TypeDeclaration) {
              TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
              if (typeDeclaration.getName().getIdentifier().equals(intermediateClassName)) {
                intermediateTypeDeclaration=typeDeclaration;
                int intermediateModifiers=intermediateTypeDeclaration.getModifiers();
                if ((intermediateModifiers & Modifier.ABSTRACT) == 0) {
                  ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
                  intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
                }
                break;
              }
            }
          }
          MultiTextEdit intermediateMultiTextEdit=new MultiTextEdit();
          CompilationUnitChange intermediateCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",intermediateICompilationUnit);
          intermediateCompilationUnitChange.setEdit(intermediateMultiTextEdit);
          compilationUnitChanges.put(intermediateICompilationUnit,intermediateCompilationUnitChange);
        }
 else {
          if (compilationUnit.getPackage() != null) {
            intermediateRewriter.set(intermediateCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,compilationUnit.getPackage(),null);
          }
          intermediateTypeDeclaration=intermediateAST.newTypeDeclaration();
          SimpleName intermediateName=intermediateAST.newSimpleName(intermediateClassName);
          intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.NAME_PROPERTY,intermediateName,null);
          ListRewrite intermediateModifiersRewrite=intermediateRewriter.getListRewrite(intermediateTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
          intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
          intermediateModifiersRewrite.insertLast(intermediateAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
          intermediateRewriter.set(intermediateTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,intermediateAST.newSimpleType(intermediateAST.newSimpleName(commonSuperTypeOfSourceTypeDeclarations.getName())),null);
          intermediateTypesRewrite.insertLast(intermediateTypeDeclaration,null);
        }
        sourceCompilationUnit=intermediateCompilationUnit;
        sourceICompilationUnit=intermediateICompilationUnit;
        sourceTypeDeclaration=intermediateTypeDeclaration;
        sourceRewriter=intermediateRewriter;
        ast=intermediateAST;
      }
    }
  }
  MethodDeclaration sourceMethodDeclaration=sourceMethodDeclarations.get(0);
  Set<ITypeBinding> requiredImportTypeBindings=new LinkedHashSet<ITypeBinding>();
  ListRewrite bodyDeclarationsRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  if (commonSuperTypeOfSourceTypeDeclarations != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(commonSuperTypeOfSourceTypeDeclarations);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
  }
  if (!sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclarations.get(1).resolveBinding())) {
    Set<VariableDeclaration> accessedLocalFieldsG1=mapper.getAccessedLocalFieldsG1();
    Set<VariableDeclaration> accessedLocalFieldsG2=mapper.getAccessedLocalFieldsG2();
    for (    VariableDeclaration localFieldG1 : accessedLocalFieldsG1) {
      FieldDeclaration originalFieldDeclarationG1=(FieldDeclaration)localFieldG1.getParent();
      for (      VariableDeclaration localFieldG2 : accessedLocalFieldsG2) {
        FieldDeclaration originalFieldDeclarationG2=(FieldDeclaration)localFieldG2.getParent();
        if (localFieldG1.getName().getIdentifier().equals(localFieldG2.getName().getIdentifier())) {
          if (originalFieldDeclarationG1.getType().resolveBinding().isEqualTo(originalFieldDeclarationG2.getType().resolveBinding())) {
            Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
            typeBindings.add(localFieldG1.resolveBinding().getType());
            getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
            fieldDeclarationsToBePulledUp.get(0).add(localFieldG1);
            fieldDeclarationsToBePulledUp.get(1).add(localFieldG2);
            VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
            sourceRewriter.set(fragment,VariableDeclarationFragment.NAME_PROPERTY,ast.newSimpleName(localFieldG1.getName().getIdentifier()),null);
            if (localFieldG1.getInitializer() != null && localFieldG2.getInitializer() != null) {
              Expression initializer1=localFieldG1.getInitializer();
              Expression initializer2=localFieldG2.getInitializer();
              if (initializer1.subtreeMatch(new ASTMatcher(),initializer2)) {
                sourceRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,ASTNode.copySubtree(ast,initializer1),null);
              }
            }
            FieldDeclaration newFieldDeclaration=ast.newFieldDeclaration(fragment);
            sourceRewriter.set(newFieldDeclaration,FieldDeclaration.TYPE_PROPERTY,originalFieldDeclarationG1.getType(),null);
            if (originalFieldDeclarationG1.getJavadoc() != null) {
              sourceRewriter.set(newFieldDeclaration,FieldDeclaration.JAVADOC_PROPERTY,originalFieldDeclarationG1.getJavadoc(),null);
            }
            ListRewrite newFieldDeclarationModifiersRewrite=sourceRewriter.getListRewrite(newFieldDeclaration,FieldDeclaration.MODIFIERS2_PROPERTY);
            newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
            List<IExtendedModifier> originalModifiers=originalFieldDeclarationG1.modifiers();
            for (            IExtendedModifier extendedModifier : originalModifiers) {
              if (extendedModifier.isModifier()) {
                Modifier modifier=(Modifier)extendedModifier;
                if (modifier.isFinal()) {
                  newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.FINAL_KEYWORD),null);
                }
 else                 if (modifier.isStatic()) {
                  newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD),null);
                }
 else                 if (modifier.isTransient()) {
                  newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.TRANSIENT_KEYWORD),null);
                }
 else                 if (modifier.isVolatile()) {
                  newFieldDeclarationModifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.VOLATILE_KEYWORD),null);
                }
              }
            }
            bodyDeclarationsRewrite.insertLast(newFieldDeclaration,null);
            break;
          }
        }
      }
    }
    Set<MethodInvocationObject> accessedLocalMethodsG1=mapper.getAccessedLocalMethodsG1();
    Set<MethodInvocationObject> accessedLocalMethodsG2=mapper.getAccessedLocalMethodsG2();
    for (    MethodInvocationObject localMethodG1 : accessedLocalMethodsG1) {
      for (      MethodInvocationObject localMethodG2 : accessedLocalMethodsG2) {
        if (localMethodG1.getMethodName().equals(localMethodG2.getMethodName()) && localMethodG1.getReturnType().equals(localMethodG2.getReturnType()) && localMethodG1.getParameterTypeList().equals(localMethodG2.getParameterTypeList())) {
          MethodDeclaration[] methodDeclarationsG1=sourceTypeDeclarations.get(0).getMethods();
          IMethodBinding localMethodBindingG1=localMethodG1.getMethodInvocation().resolveMethodBinding();
          MethodDeclaration methodDeclaration1=null;
          for (          MethodDeclaration methodDeclarationG1 : methodDeclarationsG1) {
            if (methodDeclarationG1.resolveBinding().isEqualTo(localMethodBindingG1)) {
              methodDeclaration1=methodDeclarationG1;
              break;
            }
          }
          MethodDeclaration[] methodDeclarationsG2=sourceTypeDeclarations.get(1).getMethods();
          IMethodBinding localMethodBindingG2=localMethodG2.getMethodInvocation().resolveMethodBinding();
          MethodDeclaration methodDeclaration2=null;
          for (          MethodDeclaration methodDeclarationG2 : methodDeclarationsG2) {
            if (methodDeclarationG2.resolveBinding().isEqualTo(localMethodBindingG2)) {
              methodDeclaration2=methodDeclarationG2;
              break;
            }
          }
          boolean exactClones=methodDeclaration1.subtreeMatch(new ASTMatcher(),methodDeclaration2);
          if (exactClones) {
            bodyDeclarationsRewrite.insertLast(methodDeclaration1,null);
            methodDeclarationsToBePulledUp.get(0).add(methodDeclaration1);
            methodDeclarationsToBePulledUp.get(1).add(methodDeclaration2);
          }
 else {
            MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
            sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(methodDeclaration1.getName().getIdentifier()),null);
            sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,methodDeclaration1.getReturnType2(),null);
            ListRewrite modifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
            List<IExtendedModifier> originalModifiers=methodDeclaration1.modifiers();
            for (            IExtendedModifier extendedModifier : originalModifiers) {
              if (extendedModifier.isModifier()) {
                Modifier modifier=(Modifier)extendedModifier;
                if (modifier.isProtected()) {
                  modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD),null);
                }
 else                 if (modifier.isPublic()) {
                  modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
                }
              }
            }
            modifiersRewrite.insertLast(ast.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
            ListRewrite parametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
            List<SingleVariableDeclaration> parameters=methodDeclaration1.parameters();
            for (            SingleVariableDeclaration parameter : parameters) {
              parametersRewrite.insertLast(parameter,null);
            }
            ListRewrite thrownExceptionsRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
            List<Name> thrownExceptions=methodDeclaration1.thrownExceptions();
            for (            Name thrownException : thrownExceptions) {
              thrownExceptionsRewrite.insertLast(thrownException,null);
            }
            bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
          }
          break;
        }
      }
    }
  }
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractedMethodName),null);
  List<VariableDeclaration> returnedVariables1=this.returnedVariables.get(0);
  List<VariableDeclaration> returnedVariables2=this.returnedVariables.get(1);
  ITypeBinding returnTypeBinding=null;
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1) {
    Type returnType1=extractType(returnedVariables1.get(0));
    Type returnType2=extractType(returnedVariables2.get(0));
    if (returnType1.resolveBinding().isEqualTo(returnType2.resolveBinding()))     returnTypeBinding=returnType1.resolveBinding();
 else     returnTypeBinding=ASTNodeMatcher.commonSuperType(returnType1.resolveBinding(),returnType2.resolveBinding());
  }
 else {
    returnTypeBinding=findReturnTypeBinding();
  }
  if (returnTypeBinding != null) {
    Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
    typeBindings.add(returnTypeBinding);
    getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
    Type returnType=generateTypeFromTypeBinding(returnTypeBinding,ast,sourceRewriter);
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
  }
 else {
    sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
  }
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  if (sourceTypeDeclarations.get(0).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding()) && sourceTypeDeclarations.get(1).resolveBinding().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
 else {
    Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PROTECTED_KEYWORD);
    modifierRewrite.insertLast(accessModifier,null);
  }
  if ((sourceMethodDeclarations.get(0).getModifiers() & Modifier.STATIC) != 0 && (sourceMethodDeclarations.get(1).getModifiers() & Modifier.STATIC) != 0) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  List<Name> thrownExceptions1=sourceMethodDeclarations.get(0).thrownExceptions();
  List<Name> thrownExceptions2=sourceMethodDeclarations.get(1).thrownExceptions();
  for (  Name thrownException1 : thrownExceptions1) {
    for (    Name thrownException2 : thrownExceptions2) {
      if (thrownException1.resolveTypeBinding().isEqualTo(thrownException2.resolveTypeBinding())) {
        thrownExceptionRewrite.insertLast(thrownException1,null);
        break;
      }
    }
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  Map<VariableBindingKeyPair,ArrayList<VariableDeclaration>> commonPassedParameters=mapper.getCommonPassedParameters();
  for (  VariableBindingKeyPair parameterName : commonPassedParameters.keySet()) {
    ArrayList<VariableDeclaration> variableDeclarations=commonPassedParameters.get(parameterName);
    VariableDeclaration variableDeclaration1=variableDeclarations.get(0);
    VariableDeclaration variableDeclaration2=variableDeclarations.get(1);
    if (parameterIsUsedByNodesWithoutDifferences(variableDeclaration1,variableDeclaration2)) {
      if (!variableDeclaration1.resolveBinding().isField() && !variableDeclaration2.resolveBinding().isField()) {
        ITypeBinding typeBinding1=extractType(variableDeclaration1).resolveBinding();
        ITypeBinding typeBinding2=extractType(variableDeclaration2).resolveBinding();
        ITypeBinding typeBinding=null;
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
        Type variableType=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
        Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
        typeBindings.add(typeBinding);
        getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
        SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration1.getName(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
        parameterRewrite.insertLast(parameter,null);
        originalPassedParameters.put(parameterName,variableDeclarations);
      }
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode1=pdgNodeMapping.getNodeG1();
    Statement statement1=pdgNode1.getASTStatement();
    TypeVisitor typeVisitor1=new TypeVisitor();
    statement1.accept(typeVisitor1);
    getSimpleTypeBindings(typeVisitor1.getTypeBindings(),requiredImportTypeBindings);
    PDGNode pdgNode2=pdgNodeMapping.getNodeG2();
    Statement statement2=pdgNode2.getASTStatement();
    TypeVisitor typeVisitor2=new TypeVisitor();
    statement2.accept(typeVisitor2);
    getSimpleTypeBindings(typeVisitor2.getTypeBindings(),requiredImportTypeBindings);
  }
  CloneStructureNode root=mapper.getCloneStructureRoot();
  for (  CloneStructureNode child : root.getChildren()) {
    if (child.getMapping() instanceof PDGNodeMapping) {
      Statement statement=processCloneStructureNode(child,ast,sourceRewriter);
      methodBodyRewrite.insertLast(statement,null);
    }
  }
  if (returnedVariables1.size() == 1 && returnedVariables2.size() == 1 && findReturnTypeBinding() == null) {
    ReturnStatement returnStatement=ast.newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariables1.get(0).getName(),null);
    methodBodyRewrite.insertLast(returnStatement,null);
  }
  int i=0;
  for (  ASTNodeDifference difference : parameterizedDifferenceMap.values()) {
    AbstractExpression expression1=difference.getExpression1();
    AbstractExpression expression2=difference.getExpression2();
    boolean isReturnedVariable=false;
    if (expression1 != null) {
      isReturnedVariable=isReturnedVariable(expression1.getExpression(),this.returnedVariables.get(0));
    }
 else     if (expression2 != null) {
      isReturnedVariable=isReturnedVariable(expression2.getExpression(),this.returnedVariables.get(1));
    }
    if (!isReturnedVariable) {
      ITypeBinding typeBinding=null;
      if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH) || differenceContainsSubDifferenceWithSubclassTypeMismatch(difference)) {
        ITypeBinding typeBinding1=expression1 != null ? expression1.getExpression().resolveTypeBinding() : expression2.getExpression().resolveTypeBinding();
        ITypeBinding typeBinding2=expression2 != null ? expression2.getExpression().resolveTypeBinding() : expression1.getExpression().resolveTypeBinding();
        if (!typeBinding1.isEqualTo(typeBinding2)) {
          ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
          if (commonSuperTypeBinding != null) {
            typeBinding=commonSuperTypeBinding;
          }
        }
 else {
          typeBinding=typeBinding1;
        }
      }
 else {
        typeBinding=expression1 != null ? expression1.getExpression().resolveTypeBinding() : expression2.getExpression().resolveTypeBinding();
      }
      Type type=generateTypeFromTypeBinding(typeBinding,ast,sourceRewriter);
      Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
      typeBindings.add(typeBinding);
      getSimpleTypeBindings(typeBindings,requiredImportTypeBindings);
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(""String_Node_Str"" + i),null);
      i++;
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  bodyDeclarationsRewrite.insertLast(newMethodDeclaration,null);
  try {
    CompilationUnitChange change=compilationUnitChanges.get(sourceICompilationUnit);
    if (change != null) {
      ImportRewrite importRewrite=ImportRewrite.create(sourceCompilationUnit,true);
      for (      ITypeBinding typeBinding : requiredImportTypeBindings) {
        if (!typeBinding.isNested())         importRewrite.addImport(typeBinding);
      }
      TextEdit importEdit=importRewrite.rewriteImports(null);
      if (importRewrite.getCreatedImports().length > 0) {
        change.getEdit().addChild(importEdit);
        change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{importEdit}));
      }
      TextEdit sourceEdit=sourceRewriter.rewriteAST();
      change.getEdit().addChild(sourceEdit);
      change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
    }
    if (document != null) {
      for (      ITypeBinding typeBinding : requiredImportTypeBindings) {
        addImportDeclaration(typeBinding,sourceCompilationUnit,sourceRewriter);
      }
      TextEdit intermediateEdit=sourceRewriter.rewriteAST(document,null);
      intermediateEdit.apply(document);
      CreateCompilationUnitChange createCompilationUnitChange=new CreateCompilationUnitChange(sourceICompilationUnit,document.get(),file.getCharset());
      createCompilationUnitChanges.put(sourceICompilationUnit,createCompilationUnitChange);
    }
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
catch (  CoreException e) {
    e.printStackTrace();
  }
}"
12076,"private ASTNode processASTNodeWithDifferences(AST ast,ASTRewrite sourceRewriter,ASTNode oldASTNode,List<ASTNodeDifference> differences){
  if (differences.isEmpty()) {
    return oldASTNode;
  }
 else {
    Set<String> parameterBindingKeys=originalPassedParameters.keySet();
    Set<String> declaredLocalVariableBindingKeys=mapper.getDeclaredLocalVariablesInMappedNodes().keySet();
    ASTNode newASTNode=ASTNode.copySubtree(ast,oldASTNode);
    for (    ASTNodeDifference difference : differences) {
      Expression oldExpression=difference.getExpression1().getExpression();
      oldExpression=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(oldExpression);
      boolean isCommonParameter=false;
      if (oldExpression instanceof SimpleName) {
        SimpleName oldSimpleName=(SimpleName)oldExpression;
        IBinding binding=oldSimpleName.resolveBinding();
        if (parameterBindingKeys.contains(binding.getKey()) || declaredLocalVariableBindingKeys.contains(binding.getKey()))         isCommonParameter=true;
      }
 else       if (oldExpression instanceof QualifiedName) {
        QualifiedName oldQualifiedName=(QualifiedName)oldExpression;
        SimpleName oldSimpleName=oldQualifiedName.getName();
        IBinding binding=oldSimpleName.resolveBinding();
        if (parameterBindingKeys.contains(binding.getKey()) || declaredLocalVariableBindingKeys.contains(binding.getKey()))         isCommonParameter=true;
      }
      if (!isCommonParameter) {
        if (difference instanceof FieldAccessReplacedWithGetterInvocationDifference) {
          FieldAccessReplacedWithGetterInvocationDifference nodeDifference=(FieldAccessReplacedWithGetterInvocationDifference)difference;
          MethodInvocation newGetterMethodInvocation=generateGetterMethodInvocation(ast,sourceRewriter,nodeDifference);
          if (oldASTNode.equals(oldExpression)) {
            return newGetterMethodInvocation;
          }
 else {
            replaceExpression(sourceRewriter,oldASTNode,newASTNode,oldExpression,newGetterMethodInvocation);
          }
        }
 else         if (difference instanceof FieldAssignmentReplacedWithSetterInvocationDifference) {
          FieldAssignmentReplacedWithSetterInvocationDifference nodeDifference=(FieldAssignmentReplacedWithSetterInvocationDifference)difference;
          MethodInvocation newSetterMethodInvocation=generateSetterMethodInvocation(ast,sourceRewriter,nodeDifference);
          if (oldASTNode.equals(oldExpression)) {
            return newSetterMethodInvocation;
          }
 else {
            replaceExpression(sourceRewriter,oldASTNode,newASTNode,oldExpression,newSetterMethodInvocation);
          }
        }
 else         if (oldExpression.getParent() instanceof Type) {
          Type oldType=(Type)oldExpression.getParent();
          if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH)) {
            ITypeBinding typeBinding1=difference.getExpression1().getExpression().resolveTypeBinding();
            ITypeBinding typeBinding2=difference.getExpression2().getExpression().resolveTypeBinding();
            ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
            if (commonSuperTypeBinding != null) {
              Type arg=generateTypeFromTypeBinding(commonSuperTypeBinding,ast,sourceRewriter);
              TypeVisitor oldTypeVisitor=new TypeVisitor();
              oldASTNode.accept(oldTypeVisitor);
              List<Type> oldTypes=oldTypeVisitor.getTypes();
              TypeVisitor newTypeVisitor=new TypeVisitor();
              newASTNode.accept(newTypeVisitor);
              List<Type> newTypes=newTypeVisitor.getTypes();
              int j=0;
              for (              Type type : oldTypes) {
                Type newType=newTypes.get(j);
                if (type.equals(oldType)) {
                  sourceRewriter.replace(newType,arg,null);
                  break;
                }
                j++;
              }
            }
          }
        }
 else {
          Set<VariableDeclaration> fields1=fieldDeclarationsToBePulledUp.get(0);
          BindingSignature bindingSignature1=difference.getBindingSignaturePair().getSignature1();
          boolean expression1IsFieldToBePulledUp=false;
          for (          VariableDeclaration field : fields1) {
            if (bindingSignature1.containsOnlyBinding(field.resolveBinding().getKey())) {
              expression1IsFieldToBePulledUp=true;
              break;
            }
          }
          Set<VariableDeclaration> fields2=fieldDeclarationsToBePulledUp.get(1);
          BindingSignature bindingSignature2=difference.getBindingSignaturePair().getSignature2();
          boolean expression2IsFieldToBePulledUp=false;
          for (          VariableDeclaration field : fields2) {
            if (bindingSignature2.containsOnlyBinding(field.resolveBinding().getKey())) {
              expression2IsFieldToBePulledUp=true;
              break;
            }
          }
          boolean expressionIsFieldToBePulledUp=expression1IsFieldToBePulledUp && expression2IsFieldToBePulledUp;
          if (!expressionIsFieldToBePulledUp) {
            Expression argument=createArgument(ast,difference);
            if (oldASTNode.equals(oldExpression)) {
              return argument;
            }
 else {
              replaceExpression(sourceRewriter,oldASTNode,newASTNode,oldExpression,argument);
            }
          }
        }
      }
    }
    return newASTNode;
  }
}","private ASTNode processASTNodeWithDifferences(AST ast,ASTRewrite sourceRewriter,ASTNode oldASTNode,List<ASTNodeDifference> differences){
  if (differences.isEmpty()) {
    return oldASTNode;
  }
 else {
    Set<VariableBindingKeyPair> parameterBindingKeys=originalPassedParameters.keySet();
    Set<VariableBindingKeyPair> declaredLocalVariableBindingKeys=mapper.getDeclaredLocalVariablesInMappedNodes().keySet();
    ASTNode newASTNode=ASTNode.copySubtree(ast,oldASTNode);
    for (    ASTNodeDifference difference : differences) {
      Expression oldExpression=difference.getExpression1().getExpression();
      oldExpression=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(oldExpression);
      Expression oldExpression2=difference.getExpression2().getExpression();
      oldExpression2=ASTNodeDifference.getParentExpressionOfMethodNameOrTypeName(oldExpression2);
      boolean isCommonParameter=false;
      if (oldExpression instanceof SimpleName && oldExpression2 instanceof SimpleName) {
        SimpleName oldSimpleName=(SimpleName)oldExpression;
        SimpleName oldSimpleName2=(SimpleName)oldExpression2;
        IBinding binding=oldSimpleName.resolveBinding();
        IBinding binding2=oldSimpleName2.resolveBinding();
        VariableBindingKeyPair keyPair=new VariableBindingKeyPair(binding.getKey(),binding2.getKey());
        if (parameterBindingKeys.contains(keyPair) || declaredLocalVariableBindingKeys.contains(keyPair))         isCommonParameter=true;
      }
 else       if (oldExpression instanceof QualifiedName && oldExpression2 instanceof QualifiedName) {
        QualifiedName oldQualifiedName=(QualifiedName)oldExpression;
        QualifiedName oldQualifiedName2=(QualifiedName)oldExpression2;
        SimpleName oldSimpleName=oldQualifiedName.getName();
        SimpleName oldSimpleName2=oldQualifiedName2.getName();
        IBinding binding=oldSimpleName.resolveBinding();
        IBinding binding2=oldSimpleName2.resolveBinding();
        VariableBindingKeyPair keyPair=new VariableBindingKeyPair(binding.getKey(),binding2.getKey());
        if (parameterBindingKeys.contains(keyPair) || declaredLocalVariableBindingKeys.contains(keyPair))         isCommonParameter=true;
      }
      if (!isCommonParameter) {
        if (difference instanceof FieldAccessReplacedWithGetterInvocationDifference) {
          FieldAccessReplacedWithGetterInvocationDifference nodeDifference=(FieldAccessReplacedWithGetterInvocationDifference)difference;
          MethodInvocation newGetterMethodInvocation=generateGetterMethodInvocation(ast,sourceRewriter,nodeDifference);
          if (oldASTNode.equals(oldExpression)) {
            return newGetterMethodInvocation;
          }
 else {
            replaceExpression(sourceRewriter,oldASTNode,newASTNode,oldExpression,newGetterMethodInvocation);
          }
        }
 else         if (difference instanceof FieldAssignmentReplacedWithSetterInvocationDifference) {
          FieldAssignmentReplacedWithSetterInvocationDifference nodeDifference=(FieldAssignmentReplacedWithSetterInvocationDifference)difference;
          MethodInvocation newSetterMethodInvocation=generateSetterMethodInvocation(ast,sourceRewriter,nodeDifference);
          if (oldASTNode.equals(oldExpression)) {
            return newSetterMethodInvocation;
          }
 else {
            replaceExpression(sourceRewriter,oldASTNode,newASTNode,oldExpression,newSetterMethodInvocation);
          }
        }
 else         if (oldExpression.getParent() instanceof Type) {
          Type oldType=(Type)oldExpression.getParent();
          if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH)) {
            ITypeBinding typeBinding1=difference.getExpression1().getExpression().resolveTypeBinding();
            ITypeBinding typeBinding2=difference.getExpression2().getExpression().resolveTypeBinding();
            ITypeBinding commonSuperTypeBinding=ASTNodeMatcher.commonSuperType(typeBinding1,typeBinding2);
            if (commonSuperTypeBinding != null) {
              Type arg=generateTypeFromTypeBinding(commonSuperTypeBinding,ast,sourceRewriter);
              TypeVisitor oldTypeVisitor=new TypeVisitor();
              oldASTNode.accept(oldTypeVisitor);
              List<Type> oldTypes=oldTypeVisitor.getTypes();
              TypeVisitor newTypeVisitor=new TypeVisitor();
              newASTNode.accept(newTypeVisitor);
              List<Type> newTypes=newTypeVisitor.getTypes();
              int j=0;
              for (              Type type : oldTypes) {
                Type newType=newTypes.get(j);
                if (type.equals(oldType)) {
                  sourceRewriter.replace(newType,arg,null);
                  break;
                }
                j++;
              }
            }
          }
        }
 else {
          Set<VariableDeclaration> fields1=fieldDeclarationsToBePulledUp.get(0);
          BindingSignature bindingSignature1=difference.getBindingSignaturePair().getSignature1();
          boolean expression1IsFieldToBePulledUp=false;
          for (          VariableDeclaration field : fields1) {
            if (bindingSignature1.containsOnlyBinding(field.resolveBinding().getKey())) {
              expression1IsFieldToBePulledUp=true;
              break;
            }
          }
          Set<VariableDeclaration> fields2=fieldDeclarationsToBePulledUp.get(1);
          BindingSignature bindingSignature2=difference.getBindingSignaturePair().getSignature2();
          boolean expression2IsFieldToBePulledUp=false;
          for (          VariableDeclaration field : fields2) {
            if (bindingSignature2.containsOnlyBinding(field.resolveBinding().getKey())) {
              expression2IsFieldToBePulledUp=true;
              break;
            }
          }
          boolean expressionIsFieldToBePulledUp=expression1IsFieldToBePulledUp && expression2IsFieldToBePulledUp;
          if (!expressionIsFieldToBePulledUp) {
            Expression argument=createArgument(ast,difference);
            if (oldASTNode.equals(oldExpression)) {
              return argument;
            }
 else {
              replaceExpression(sourceRewriter,oldASTNode,newASTNode,oldExpression,argument);
            }
          }
        }
      }
    }
    return newASTNode;
  }
}"
12077,"private void initialize(){
  AbstractMethodDeclaration methodObject1=this.mapper.getPDG1().getMethod();
  AbstractMethodDeclaration methodObject2=this.mapper.getPDG2().getMethod();
  MethodDeclaration methodDeclaration1=methodObject1.getMethodDeclaration();
  MethodDeclaration methodDeclaration2=methodObject2.getMethodDeclaration();
  this.sourceCompilationUnits=new ArrayList<CompilationUnit>();
  this.sourceTypeDeclarations=new ArrayList<TypeDeclaration>();
  this.sourceMethodDeclarations=new ArrayList<MethodDeclaration>();
  this.removableStatements=new ArrayList<TreeSet<PDGNode>>();
  removableStatements.add(this.mapper.getRemovableNodesG1());
  removableStatements.add(this.mapper.getRemovableNodesG2());
  this.remainingStatementsMovableBefore=new ArrayList<TreeSet<PDGNode>>();
  remainingStatementsMovableBefore.add(this.mapper.getNonMappedPDGNodesG1MovableBefore());
  remainingStatementsMovableBefore.add(this.mapper.getNonMappedPDGNodesG2MovableBefore());
  this.remainingStatementsMovableAfter=new ArrayList<TreeSet<PDGNode>>();
  remainingStatementsMovableAfter.add(this.mapper.getNonMappedPDGNodesG1MovableAfter());
  remainingStatementsMovableAfter.add(this.mapper.getNonMappedPDGNodesG2MovableAfter());
  this.returnedVariables=new ArrayList<ArrayList<VariableDeclaration>>();
  returnedVariables.add(new ArrayList<VariableDeclaration>(this.mapper.getDeclaredVariablesInMappedNodesUsedByNonMappedNodesG1()));
  returnedVariables.add(new ArrayList<VariableDeclaration>(this.mapper.getDeclaredVariablesInMappedNodesUsedByNonMappedNodesG2()));
  this.fieldDeclarationsToBePulledUp=new ArrayList<Set<VariableDeclaration>>();
  this.methodDeclarationsToBePulledUp=new ArrayList<Set<MethodDeclaration>>();
  this.labeledStatementsToBeRemoved=new ArrayList<Set<LabeledStatement>>();
  for (int i=0; i < 2; i++) {
    fieldDeclarationsToBePulledUp.add(new LinkedHashSet<VariableDeclaration>());
    methodDeclarationsToBePulledUp.add(new LinkedHashSet<MethodDeclaration>());
    labeledStatementsToBeRemoved.add(new LinkedHashSet<LabeledStatement>());
  }
  this.compilationUnitChanges=new LinkedHashMap<ICompilationUnit,CompilationUnitChange>();
  this.createCompilationUnitChanges=new LinkedHashMap<ICompilationUnit,CreateCompilationUnitChange>();
  this.javaElementsToOpenInEditor=new LinkedHashSet<IJavaElement>();
  this.sourceMethodDeclarations.add(methodDeclaration1);
  this.sourceMethodDeclarations.add(methodDeclaration2);
  this.sourceTypeDeclarations.add((TypeDeclaration)methodDeclaration1.getParent());
  this.sourceTypeDeclarations.add((TypeDeclaration)methodDeclaration2.getParent());
  this.sourceCompilationUnits.add((CompilationUnit)methodDeclaration1.getRoot());
  this.sourceCompilationUnits.add((CompilationUnit)methodDeclaration2.getRoot());
  this.originalPassedParameters=new LinkedHashMap<String,ArrayList<VariableDeclaration>>();
  this.parameterizedDifferenceMap=new LinkedHashMap<BindingSignaturePair,ASTNodeDifference>();
  this.sortedNodeMappings=new TreeSet<PDGNodeMapping>(this.mapper.getMaximumStateWithMinimumDifferences().getNodeMappings());
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode=pdgNodeMapping.getNodeG1();
    CFGNode cfgNode=pdgNode.getCFGNode();
    if (cfgNode instanceof CFGBranchDoLoopNode) {
      CFGBranchDoLoopNode cfgDoLoopNode=(CFGBranchDoLoopNode)cfgNode;
      doLoopNodes.add(cfgDoLoopNode);
    }
  }
  for (  CompilationUnit sourceCompilationUnit : sourceCompilationUnits) {
    ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
    MultiTextEdit sourceMultiTextEdit=new MultiTextEdit();
    CompilationUnitChange sourceCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",sourceICompilationUnit);
    sourceCompilationUnitChange.setEdit(sourceMultiTextEdit);
    compilationUnitChanges.put(sourceICompilationUnit,sourceCompilationUnitChange);
  }
  this.intermediateClassName=null;
}","private void initialize(){
  AbstractMethodDeclaration methodObject1=this.mapper.getPDG1().getMethod();
  AbstractMethodDeclaration methodObject2=this.mapper.getPDG2().getMethod();
  MethodDeclaration methodDeclaration1=methodObject1.getMethodDeclaration();
  MethodDeclaration methodDeclaration2=methodObject2.getMethodDeclaration();
  this.sourceCompilationUnits=new ArrayList<CompilationUnit>();
  this.sourceTypeDeclarations=new ArrayList<TypeDeclaration>();
  this.sourceMethodDeclarations=new ArrayList<MethodDeclaration>();
  this.removableStatements=new ArrayList<TreeSet<PDGNode>>();
  removableStatements.add(this.mapper.getRemovableNodesG1());
  removableStatements.add(this.mapper.getRemovableNodesG2());
  this.remainingStatementsMovableBefore=new ArrayList<TreeSet<PDGNode>>();
  remainingStatementsMovableBefore.add(this.mapper.getNonMappedPDGNodesG1MovableBefore());
  remainingStatementsMovableBefore.add(this.mapper.getNonMappedPDGNodesG2MovableBefore());
  this.remainingStatementsMovableAfter=new ArrayList<TreeSet<PDGNode>>();
  remainingStatementsMovableAfter.add(this.mapper.getNonMappedPDGNodesG1MovableAfter());
  remainingStatementsMovableAfter.add(this.mapper.getNonMappedPDGNodesG2MovableAfter());
  this.returnedVariables=new ArrayList<ArrayList<VariableDeclaration>>();
  returnedVariables.add(new ArrayList<VariableDeclaration>(this.mapper.getDeclaredVariablesInMappedNodesUsedByNonMappedNodesG1()));
  returnedVariables.add(new ArrayList<VariableDeclaration>(this.mapper.getDeclaredVariablesInMappedNodesUsedByNonMappedNodesG2()));
  this.fieldDeclarationsToBePulledUp=new ArrayList<Set<VariableDeclaration>>();
  this.methodDeclarationsToBePulledUp=new ArrayList<Set<MethodDeclaration>>();
  this.labeledStatementsToBeRemoved=new ArrayList<Set<LabeledStatement>>();
  for (int i=0; i < 2; i++) {
    fieldDeclarationsToBePulledUp.add(new LinkedHashSet<VariableDeclaration>());
    methodDeclarationsToBePulledUp.add(new LinkedHashSet<MethodDeclaration>());
    labeledStatementsToBeRemoved.add(new LinkedHashSet<LabeledStatement>());
  }
  this.compilationUnitChanges=new LinkedHashMap<ICompilationUnit,CompilationUnitChange>();
  this.createCompilationUnitChanges=new LinkedHashMap<ICompilationUnit,CreateCompilationUnitChange>();
  this.javaElementsToOpenInEditor=new LinkedHashSet<IJavaElement>();
  this.sourceMethodDeclarations.add(methodDeclaration1);
  this.sourceMethodDeclarations.add(methodDeclaration2);
  this.sourceTypeDeclarations.add((TypeDeclaration)methodDeclaration1.getParent());
  this.sourceTypeDeclarations.add((TypeDeclaration)methodDeclaration2.getParent());
  this.sourceCompilationUnits.add((CompilationUnit)methodDeclaration1.getRoot());
  this.sourceCompilationUnits.add((CompilationUnit)methodDeclaration2.getRoot());
  this.originalPassedParameters=new LinkedHashMap<VariableBindingKeyPair,ArrayList<VariableDeclaration>>();
  this.parameterizedDifferenceMap=new LinkedHashMap<BindingSignaturePair,ASTNodeDifference>();
  this.sortedNodeMappings=new TreeSet<PDGNodeMapping>(this.mapper.getMaximumStateWithMinimumDifferences().getNodeMappings());
  for (  PDGNodeMapping pdgNodeMapping : sortedNodeMappings) {
    PDGNode pdgNode=pdgNodeMapping.getNodeG1();
    CFGNode cfgNode=pdgNode.getCFGNode();
    if (cfgNode instanceof CFGBranchDoLoopNode) {
      CFGBranchDoLoopNode cfgDoLoopNode=(CFGBranchDoLoopNode)cfgNode;
      doLoopNodes.add(cfgDoLoopNode);
    }
  }
  for (  CompilationUnit sourceCompilationUnit : sourceCompilationUnits) {
    ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
    MultiTextEdit sourceMultiTextEdit=new MultiTextEdit();
    CompilationUnitChange sourceCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",sourceICompilationUnit);
    sourceCompilationUnitChange.setEdit(sourceMultiTextEdit);
    compilationUnitChanges.put(sourceICompilationUnit,sourceCompilationUnitChange);
  }
  this.intermediateClassName=null;
}"
12078,"public CodeFragmentDecomposer(Set<PDGNode> nodes){
  this.objectNodeMap=new LinkedHashMap<PlainVariable,Set<PDGNode>>();
  Set<PlainVariable> declaredVariables=getDeclaredVariables(nodes);
  for (  PlainVariable objectReference : declaredVariables) {
    Set<PDGNode> nodesDefiningAttributes=getNodesDefiningAttributesOfReference(objectReference,nodes);
    if (!nodesDefiningAttributes.isEmpty()) {
      Set<PDGNode> objectNodes=new LinkedHashSet<PDGNode>();
      PDGNode nodeDeclaringReference=getNodeDeclaringReference(objectReference,nodes);
      if (nodeDeclaringReference != null)       objectNodes.add(nodeDeclaringReference);
      objectNodes.addAll(nodesDefiningAttributes);
      objectNodeMap.put(objectReference,objectNodes);
    }
  }
}","public CodeFragmentDecomposer(Set<PDGNode> nodes,Set<VariableDeclaration> accessedFields){
  this.objectNodeMap=new LinkedHashMap<PlainVariable,Set<PDGNode>>();
  Set<PlainVariable> declaredVariables=getDeclaredVariables(nodes);
  for (  PlainVariable objectReference : declaredVariables) {
    Set<PDGNode> nodesDefiningAttributes=getNodesDefiningAttributesOfReference(objectReference,nodes);
    if (!nodesDefiningAttributes.isEmpty()) {
      Set<PDGNode> objectNodes=new LinkedHashSet<PDGNode>();
      PDGNode nodeDeclaringReference=getNodeDeclaringReference(objectReference,nodes);
      if (nodeDeclaringReference != null)       objectNodes.add(nodeDeclaringReference);
      objectNodes.addAll(nodesDefiningAttributes);
      objectNodeMap.put(objectReference,objectNodes);
    }
  }
  Map<PlainVariable,Set<PDGNode>> definedFieldMap=getDefinedFieldMap(nodes,accessedFields);
  objectNodeMap.putAll(definedFieldMap);
}"
12079,"private Set<PlainVariable> getDeclaredVariables(Set<PDGNode> nodes){
  Set<PlainVariable> declaredVariables=new LinkedHashSet<PlainVariable>();
  for (  PDGNode node : nodes) {
    Iterator<AbstractVariable> iterator=node.getDeclaredVariableIterator();
    if (iterator.hasNext()) {
      AbstractVariable declaredVariable=iterator.next();
      if (declaredVariable instanceof PlainVariable) {
        declaredVariables.add((PlainVariable)declaredVariable);
      }
    }
  }
  return declaredVariables;
}","private Set<PlainVariable> getDeclaredVariables(Set<PDGNode> nodes){
  Set<PlainVariable> declaredVariables=new LinkedHashSet<PlainVariable>();
  for (  PDGNode node : nodes) {
    Iterator<AbstractVariable> iterator=node.getDeclaredVariableIterator();
    while (iterator.hasNext()) {
      AbstractVariable declaredVariable=iterator.next();
      if (declaredVariable instanceof PlainVariable) {
        declaredVariables.add((PlainVariable)declaredVariable);
      }
    }
  }
  return declaredVariables;
}"
12080,"private List<MappingState> matchBasedOnCodeFragments(MappingState parent,Set<PDGNode> nodesG1,Set<PDGNode> nodesG2){
  CodeFragmentDecomposer cfd1=new CodeFragmentDecomposer(nodesG1);
  CodeFragmentDecomposer cfd2=new CodeFragmentDecomposer(nodesG2);
  Map<PlainVariable,Set<PDGNode>> map1=cfd1.getObjectNodeMap();
  Map<PlainVariable,Set<PDGNode>> map2=cfd2.getObjectNodeMap();
  if (map1.isEmpty() || map2.isEmpty()) {
    return processPDGNodes(parent,nodesG1,nodesG2);
  }
 else {
    MappingState finalState=parent;
    for (    PlainVariable variable1 : map1.keySet()) {
      Set<PDGNode> variableNodesG1=map1.get(variable1);
      Set<PDGNode> tempNodesG1=new LinkedHashSet<PDGNode>(variableNodesG1);
      Map<PlainVariable,List<MappingState>> currentStateMap=new LinkedHashMap<PlainVariable,List<MappingState>>();
      for (      PlainVariable variable2 : map2.keySet()) {
        Set<PDGNode> variableNodesG2=map2.get(variable2);
        Set<PDGNode> tempNodesG2=new LinkedHashSet<PDGNode>(variableNodesG2);
        if (finalState != null) {
          for (          PDGNodeMapping mapping : finalState.getNodeMappings()) {
            if (tempNodesG1.contains(mapping.getNodeG1()))             tempNodesG1.remove(mapping.getNodeG1());
            if (tempNodesG2.contains(mapping.getNodeG2()))             tempNodesG2.remove(mapping.getNodeG2());
          }
        }
        List<MappingState> maxStates=processPDGNodes(finalState,tempNodesG1,tempNodesG2);
        currentStateMap.put(variable2,maxStates);
      }
      List<MappingState> currentStates=new ArrayList<MappingState>();
      for (      PlainVariable variable2 : currentStateMap.keySet()) {
        currentStates.addAll(currentStateMap.get(variable2));
      }
      if (!currentStates.isEmpty()) {
        MappingState best=findMaximumStateWithMinimumDifferences(currentStates);
        PlainVariable variableToRemove=null;
        for (        PlainVariable variable2 : currentStateMap.keySet()) {
          if (currentStateMap.get(variable2).contains(best)) {
            variableToRemove=variable2;
            break;
          }
        }
        map2.remove(variableToRemove);
        finalState=best;
      }
    }
    List<MappingState> currentStates=new ArrayList<MappingState>();
    Set<PDGNode> tempNodesG1=new LinkedHashSet<PDGNode>(nodesG1);
    Set<PDGNode> tempNodesG2=new LinkedHashSet<PDGNode>(nodesG2);
    for (    PDGNodeMapping mapping : finalState.getNodeMappings()) {
      if (tempNodesG1.contains(mapping.getNodeG1()))       tempNodesG1.remove(mapping.getNodeG1());
      if (tempNodesG2.contains(mapping.getNodeG2()))       tempNodesG2.remove(mapping.getNodeG2());
    }
    if (tempNodesG1.isEmpty() || tempNodesG2.isEmpty()) {
      currentStates.add(finalState);
    }
 else {
      List<MappingState> maxStates=processPDGNodes(finalState,tempNodesG1,tempNodesG2);
      for (      MappingState temp : maxStates) {
        if (!currentStates.contains(temp)) {
          currentStates.add(temp);
        }
      }
    }
    return currentStates;
  }
}","private List<MappingState> matchBasedOnCodeFragments(MappingState parent,Set<PDGNode> nodesG1,Set<PDGNode> nodesG2){
  CodeFragmentDecomposer cfd1=new CodeFragmentDecomposer(nodesG1,pdg1.getFieldsAccessedInMethod());
  CodeFragmentDecomposer cfd2=new CodeFragmentDecomposer(nodesG2,pdg2.getFieldsAccessedInMethod());
  Map<PlainVariable,Set<PDGNode>> map1=cfd1.getObjectNodeMap();
  Map<PlainVariable,Set<PDGNode>> map2=cfd2.getObjectNodeMap();
  if (map1.isEmpty() || map2.isEmpty()) {
    return processPDGNodes(parent,nodesG1,nodesG2);
  }
 else {
    MappingState finalState=parent;
    for (    PlainVariable variable1 : map1.keySet()) {
      Set<PDGNode> variableNodesG1=map1.get(variable1);
      Set<PDGNode> tempNodesG1=new LinkedHashSet<PDGNode>(variableNodesG1);
      Map<PlainVariable,List<MappingState>> currentStateMap=new LinkedHashMap<PlainVariable,List<MappingState>>();
      for (      PlainVariable variable2 : map2.keySet()) {
        Set<PDGNode> variableNodesG2=map2.get(variable2);
        Set<PDGNode> tempNodesG2=new LinkedHashSet<PDGNode>(variableNodesG2);
        if (finalState != null) {
          for (          PDGNodeMapping mapping : finalState.getNodeMappings()) {
            if (tempNodesG1.contains(mapping.getNodeG1()))             tempNodesG1.remove(mapping.getNodeG1());
            if (tempNodesG2.contains(mapping.getNodeG2()))             tempNodesG2.remove(mapping.getNodeG2());
          }
        }
        List<MappingState> maxStates=processPDGNodes(finalState,tempNodesG1,tempNodesG2);
        currentStateMap.put(variable2,maxStates);
      }
      List<MappingState> currentStates=new ArrayList<MappingState>();
      for (      PlainVariable variable2 : currentStateMap.keySet()) {
        currentStates.addAll(currentStateMap.get(variable2));
      }
      if (!currentStates.isEmpty()) {
        MappingState best=findMaximumStateWithMinimumDifferences(currentStates);
        PlainVariable variableToRemove=null;
        for (        PlainVariable variable2 : currentStateMap.keySet()) {
          if (currentStateMap.get(variable2).contains(best)) {
            variableToRemove=variable2;
            break;
          }
        }
        map2.remove(variableToRemove);
        finalState=best;
      }
    }
    List<MappingState> currentStates=new ArrayList<MappingState>();
    Set<PDGNode> tempNodesG1=new LinkedHashSet<PDGNode>(nodesG1);
    Set<PDGNode> tempNodesG2=new LinkedHashSet<PDGNode>(nodesG2);
    for (    PDGNodeMapping mapping : finalState.getNodeMappings()) {
      if (tempNodesG1.contains(mapping.getNodeG1()))       tempNodesG1.remove(mapping.getNodeG1());
      if (tempNodesG2.contains(mapping.getNodeG2()))       tempNodesG2.remove(mapping.getNodeG2());
    }
    if (tempNodesG1.isEmpty() || tempNodesG2.isEmpty()) {
      currentStates.add(finalState);
    }
 else {
      List<MappingState> maxStates=processPDGNodes(finalState,tempNodesG1,tempNodesG2);
      for (      MappingState temp : maxStates) {
        if (!currentStates.contains(temp)) {
          currentStates.add(temp);
        }
      }
    }
    return currentStates;
  }
}"
12081,"private List<CFGNode> process(List<CFGNode> previousNodes,CompositeStatementObject composite){
  if (composite instanceof TryStatementObject) {
    CFGTryNode tryNode=new CFGTryNode(composite);
    directlyNestedNodeInTryBlock(tryNode);
    findTryNodeControlParent(tryNode);
    directlyNestedNodesInTryBlocks.put(tryNode,new ArrayList<CFGNode>());
    AbstractStatement firstStatement=composite.getStatements().get(0);
    composite=(CompositeStatementObject)firstStatement;
  }
  int i=0;
  for (  AbstractStatement abstractStatement : composite.getStatements()) {
    if (abstractStatement instanceof StatementObject) {
      StatementObject statement=(StatementObject)abstractStatement;
      previousNodes=processNonCompositeStatement(previousNodes,statement,composite);
    }
 else     if (abstractStatement instanceof CompositeStatementObject) {
      CompositeStatementObject compositeStatement=(CompositeStatementObject)abstractStatement;
      if (compositeStatement.getStatement() instanceof Block) {
        previousNodes=process(previousNodes,compositeStatement);
      }
 else       if (compositeStatement.getStatement() instanceof LabeledStatement || compositeStatement.getStatement() instanceof SynchronizedStatement) {
        List<AbstractStatement> nestedStatements=compositeStatement.getStatements();
        if (!nestedStatements.isEmpty()) {
          AbstractStatement firstStatement=nestedStatements.get(0);
          if (firstStatement instanceof CompositeStatementObject)           previousNodes=process(previousNodes,(CompositeStatementObject)firstStatement);
        }
      }
 else       if (compositeStatement instanceof TryStatementObject) {
        TryStatementObject tryStatement=(TryStatementObject)compositeStatement;
        if (!tryStatement.hasResources()) {
          CFGTryNode tryNode=new CFGTryNode(compositeStatement);
          directlyNestedNodeInTryBlock(tryNode);
          findTryNodeControlParent(tryNode);
          directlyNestedNodesInTryBlocks.put(tryNode,new ArrayList<CFGNode>());
          AbstractStatement firstStatement=compositeStatement.getStatements().get(0);
          previousNodes=process(previousNodes,(CompositeStatementObject)firstStatement);
        }
 else {
          CFGTryNode tryNode=new CFGTryNode(compositeStatement);
          directlyNestedNodeInTryBlock(tryNode);
          findTryNodeControlParent(tryNode);
          nodes.add(tryNode);
          directlyNestedNodesInTryBlocks.put(tryNode,new ArrayList<CFGNode>());
          createTopDownFlow(previousNodes,tryNode);
          ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
          currentNodes.add(tryNode);
          previousNodes=currentNodes;
          AbstractStatement firstStatement=compositeStatement.getStatements().get(0);
          previousNodes=process(previousNodes,(CompositeStatementObject)firstStatement);
        }
      }
 else       if (isLoop(compositeStatement)) {
        previousNodes=processLoopStatement(previousNodes,compositeStatement);
      }
 else       if (compositeStatement.getStatement() instanceof DoStatement) {
        previousNodes=processDoStatement(previousNodes,compositeStatement);
      }
 else       if (compositeStatement.getStatement() instanceof SwitchStatement) {
        int action=getAction(composite,i,compositeStatement);
        previousNodes=processSwitchStatement(previousNodes,compositeStatement,action);
      }
 else       if (compositeStatement.getStatement() instanceof IfStatement) {
        int action=getAction(composite,i,compositeStatement);
        previousNodes=processIfStatement(previousNodes,compositeStatement,action);
      }
    }
    i++;
  }
  return previousNodes;
}","private List<CFGNode> process(List<CFGNode> previousNodes,CompositeStatementObject composite){
  if (composite instanceof TryStatementObject) {
    CFGTryNode tryNode=new CFGTryNode(composite);
    directlyNestedNodeInTryBlock(tryNode);
    findTryNodeControlParent(tryNode);
    directlyNestedNodesInTryBlocks.put(tryNode,new ArrayList<CFGNode>());
    AbstractStatement firstStatement=composite.getStatements().get(0);
    composite=(CompositeStatementObject)firstStatement;
  }
  int i=0;
  for (  AbstractStatement abstractStatement : composite.getStatements()) {
    if (abstractStatement instanceof StatementObject) {
      StatementObject statement=(StatementObject)abstractStatement;
      previousNodes=processNonCompositeStatement(previousNodes,statement,composite);
    }
 else     if (abstractStatement instanceof CompositeStatementObject) {
      CompositeStatementObject compositeStatement=(CompositeStatementObject)abstractStatement;
      if (compositeStatement.getStatement() instanceof Block) {
        previousNodes=process(previousNodes,compositeStatement);
      }
 else       if (compositeStatement.getStatement() instanceof LabeledStatement || compositeStatement.getStatement() instanceof SynchronizedStatement) {
        List<AbstractStatement> nestedStatements=compositeStatement.getStatements();
        if (!nestedStatements.isEmpty()) {
          AbstractStatement firstStatement=nestedStatements.get(0);
          if (firstStatement instanceof CompositeStatementObject) {
            CompositeStatementObject compositeStatement2=(CompositeStatementObject)firstStatement;
            if (compositeStatement2.getStatement() instanceof Block) {
              previousNodes=process(previousNodes,compositeStatement2);
            }
 else             if (compositeStatement2 instanceof TryStatementObject) {
              previousNodes=processTryStatement(previousNodes,compositeStatement2);
            }
 else             if (isLoop(compositeStatement2)) {
              previousNodes=processLoopStatement(previousNodes,compositeStatement2);
            }
 else             if (compositeStatement2.getStatement() instanceof DoStatement) {
              previousNodes=processDoStatement(previousNodes,compositeStatement2);
            }
 else             if (compositeStatement2.getStatement() instanceof SwitchStatement) {
              int action=getAction(composite,i,compositeStatement2);
              previousNodes=processSwitchStatement(previousNodes,compositeStatement2,action);
            }
 else             if (compositeStatement2.getStatement() instanceof IfStatement) {
              int action=getAction(composite,i,compositeStatement2);
              previousNodes=processIfStatement(previousNodes,compositeStatement2,action);
            }
          }
 else           if (firstStatement instanceof StatementObject) {
            previousNodes=processNonCompositeStatement(previousNodes,(StatementObject)firstStatement,composite);
          }
        }
      }
 else       if (compositeStatement instanceof TryStatementObject) {
        previousNodes=processTryStatement(previousNodes,compositeStatement);
      }
 else       if (isLoop(compositeStatement)) {
        previousNodes=processLoopStatement(previousNodes,compositeStatement);
      }
 else       if (compositeStatement.getStatement() instanceof DoStatement) {
        previousNodes=processDoStatement(previousNodes,compositeStatement);
      }
 else       if (compositeStatement.getStatement() instanceof SwitchStatement) {
        int action=getAction(composite,i,compositeStatement);
        previousNodes=processSwitchStatement(previousNodes,compositeStatement,action);
      }
 else       if (compositeStatement.getStatement() instanceof IfStatement) {
        int action=getAction(composite,i,compositeStatement);
        previousNodes=processIfStatement(previousNodes,compositeStatement,action);
      }
    }
    i++;
  }
  return previousNodes;
}"
12082,"private int getAction(CompositeStatementObject parentComposite,int i,CompositeStatementObject childComposite){
  int action=PUSH_NEW_LIST;
  List<AbstractStatement> statements=new ArrayList<AbstractStatement>(parentComposite.getStatements());
  CompositeStatementObject parent=(CompositeStatementObject)statements.get(0).getParent();
  boolean isBlockWithoutCompositeParent=isBlockWithoutCompositeParent(parent);
  if (parent.getStatement() instanceof Block)   parent=(CompositeStatementObject)parent.getParent();
  int position=i;
  while (parent != null && parent instanceof TryStatementObject) {
    CompositeStatementObject tryStatement=parent;
    CompositeStatementObject tryStatementParent=(CompositeStatementObject)tryStatement.getParent();
    List<AbstractStatement> tryParentStatements=new ArrayList<AbstractStatement>(tryStatementParent.getStatements());
    if (tryStatementParent.getStatement() instanceof Block)     tryStatementParent=(CompositeStatementObject)tryStatementParent.getParent();
    int positionOfTryStatementInParent=0;
    int j=0;
    for (    AbstractStatement statement : tryParentStatements) {
      if (statement.equals(tryStatement)) {
        positionOfTryStatementInParent=j;
        break;
      }
      j++;
    }
    if (((TryStatementObject)tryStatement).hasResources()) {
      tryParentStatements.addAll(positionOfTryStatementInParent + 1,statements);
    }
 else {
      tryParentStatements.remove(tryStatement);
      tryParentStatements.addAll(positionOfTryStatementInParent,statements);
    }
    statements=tryParentStatements;
    parent=tryStatementParent;
    if (((TryStatementObject)tryStatement).hasResources())     position=positionOfTryStatementInParent + position + 1;
 else     position=positionOfTryStatementInParent + position;
  }
  if (parent != null && parent.getStatement() instanceof SwitchStatement && parentComposite.getStatement() instanceof Block) {
    List<AbstractStatement> switchStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParentSwitch=0;
    int j=0;
    for (    AbstractStatement statement : switchStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParentSwitch=j;
        break;
      }
      j++;
    }
    switchStatements.remove(parentComposite);
    switchStatements.addAll(positionOfBlockInParentSwitch,statements);
    statements=switchStatements;
    position=positionOfBlockInParentSwitch + position;
  }
  if (parent != null && isBlockWithoutCompositeParent) {
    List<AbstractStatement> blockStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParent=0;
    int j=0;
    for (    AbstractStatement statement : blockStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParent=j;
        break;
      }
      j++;
    }
    blockStatements.remove(parentComposite);
    blockStatements.addAll(positionOfBlockInParent,statements);
    statements=blockStatements;
    position=positionOfBlockInParent + position;
  }
  if (statements.size() == 1) {
    action=JOIN_TOP_LIST;
    if (parent != null) {
      if (isLoop(parent) || parent.getStatement() instanceof DoStatement)       action=PUSH_NEW_LIST;
    }
  }
 else   if (statements.size() > 1) {
    AbstractStatement previousStatement=null;
    if (position >= 1)     previousStatement=statements.get(position - 1);
    int j=0;
    while (previousStatement != null && previousStatement instanceof TryStatementObject && !((TryStatementObject)previousStatement).hasResources()) {
      CompositeStatementObject tryStatement=(CompositeStatementObject)previousStatement;
      AbstractStatement firstStatement=tryStatement.getStatements().get(0);
      if (firstStatement instanceof CompositeStatementObject) {
        CompositeStatementObject tryBlock=(CompositeStatementObject)firstStatement;
        List<AbstractStatement> tryBlockStatements=tryBlock.getStatements();
        if (tryBlockStatements.size() > 0) {
          previousStatement=tryBlockStatements.get(tryBlockStatements.size() - 1);
        }
 else {
          if (position >= 2 + j)           previousStatement=statements.get(position - 2 - j);
 else           previousStatement=null;
        }
      }
      j++;
    }
    while (previousStatement != null && isBlockWithoutCompositeParent(previousStatement)) {
      CompositeStatementObject block=(CompositeStatementObject)previousStatement;
      List<AbstractStatement> blockStatements=block.getStatements();
      if (blockStatements.size() > 0) {
        previousStatement=blockStatements.get(blockStatements.size() - 1);
      }
    }
    if (statements.get(statements.size() - 1).equals(childComposite)) {
      if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement) {
        action=JOIN_SECOND_FROM_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PLACE_NEW_LIST_SECOND_FROM_TOP;
      }
 else {
        action=JOIN_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PUSH_NEW_LIST;
      }
    }
 else {
      if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement)       action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else {
        action=PUSH_NEW_LIST;
      }
    }
  }
  return action;
}","private int getAction(CompositeStatementObject parentComposite,int i,CompositeStatementObject childComposite){
  int action=PUSH_NEW_LIST;
  List<AbstractStatement> statements=new ArrayList<AbstractStatement>(parentComposite.getStatements());
  CompositeStatementObject parent=(CompositeStatementObject)statements.get(0).getParent();
  boolean isBlockWithoutCompositeParent=isBlockWithoutCompositeParent(parent);
  if (parent.getStatement() instanceof Block)   parent=(CompositeStatementObject)parent.getParent();
  int position=i;
  while (parent != null && parent instanceof TryStatementObject) {
    CompositeStatementObject tryStatement=parent;
    CompositeStatementObject tryStatementParent=(CompositeStatementObject)tryStatement.getParent();
    List<AbstractStatement> tryParentStatements=new ArrayList<AbstractStatement>(tryStatementParent.getStatements());
    if (tryStatementParent.getStatement() instanceof Block)     tryStatementParent=(CompositeStatementObject)tryStatementParent.getParent();
    int positionOfTryStatementInParent=0;
    int j=0;
    for (    AbstractStatement statement : tryParentStatements) {
      if (statement.equals(tryStatement)) {
        positionOfTryStatementInParent=j;
        break;
      }
      j++;
    }
    if (((TryStatementObject)tryStatement).hasResources()) {
      tryParentStatements.addAll(positionOfTryStatementInParent + 1,statements);
    }
 else {
      tryParentStatements.remove(tryStatement);
      tryParentStatements.addAll(positionOfTryStatementInParent,statements);
    }
    statements=tryParentStatements;
    parent=tryStatementParent;
    if (((TryStatementObject)tryStatement).hasResources())     position=positionOfTryStatementInParent + position + 1;
 else     position=positionOfTryStatementInParent + position;
  }
  if (parent != null && parent.getStatement() instanceof SwitchStatement && parentComposite.getStatement() instanceof Block) {
    List<AbstractStatement> switchStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParentSwitch=0;
    int j=0;
    for (    AbstractStatement statement : switchStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParentSwitch=j;
        break;
      }
      j++;
    }
    switchStatements.remove(parentComposite);
    switchStatements.addAll(positionOfBlockInParentSwitch,statements);
    statements=switchStatements;
    position=positionOfBlockInParentSwitch + position;
  }
  if (parent != null && isBlockWithoutCompositeParent) {
    List<AbstractStatement> blockStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParent=0;
    int j=0;
    for (    AbstractStatement statement : blockStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParent=j;
        break;
      }
      j++;
    }
    blockStatements.remove(parentComposite);
    blockStatements.addAll(positionOfBlockInParent,statements);
    statements=blockStatements;
    position=positionOfBlockInParent + position;
  }
  if (statements.size() == 1) {
    action=JOIN_TOP_LIST;
    if (parent != null) {
      if (isLoop(parent) || parent.getStatement() instanceof DoStatement)       action=PUSH_NEW_LIST;
    }
  }
 else   if (statements.size() > 1) {
    AbstractStatement previousStatement=null;
    if (position >= 1)     previousStatement=statements.get(position - 1);
    int j=0;
    while (previousStatement != null && previousStatement instanceof TryStatementObject && !((TryStatementObject)previousStatement).hasResources()) {
      CompositeStatementObject tryStatement=(CompositeStatementObject)previousStatement;
      AbstractStatement firstStatement=tryStatement.getStatements().get(0);
      if (firstStatement instanceof CompositeStatementObject) {
        CompositeStatementObject tryBlock=(CompositeStatementObject)firstStatement;
        List<AbstractStatement> tryBlockStatements=tryBlock.getStatements();
        if (tryBlockStatements.size() > 0) {
          previousStatement=tryBlockStatements.get(tryBlockStatements.size() - 1);
        }
 else {
          if (position >= 2 + j)           previousStatement=statements.get(position - 2 - j);
 else           previousStatement=null;
        }
      }
      j++;
    }
    while (previousStatement != null && isBlockWithoutCompositeParent(previousStatement)) {
      CompositeStatementObject block=(CompositeStatementObject)previousStatement;
      List<AbstractStatement> blockStatements=block.getStatements();
      if (blockStatements.size() > 0) {
        previousStatement=blockStatements.get(blockStatements.size() - 1);
      }
    }
    if (statements.get(statements.size() - 1).equals(childComposite)) {
      if (previousStatement != null && (previousStatement.getStatement() instanceof IfStatement || previousStatement.getStatement() instanceof SwitchStatement)) {
        action=JOIN_SECOND_FROM_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PLACE_NEW_LIST_SECOND_FROM_TOP;
      }
 else {
        action=JOIN_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PUSH_NEW_LIST;
      }
    }
 else {
      if (previousStatement != null && (previousStatement.getStatement() instanceof IfStatement || previousStatement.getStatement() instanceof SwitchStatement))       action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else {
        action=PUSH_NEW_LIST;
      }
    }
  }
  return action;
}"
12083,"private int getAction(CompositeStatementObject parentComposite,int i,CompositeStatementObject childComposite){
  int action=PUSH_NEW_LIST;
  List<AbstractStatement> statements=new ArrayList<AbstractStatement>(parentComposite.getStatements());
  CompositeStatementObject parent=(CompositeStatementObject)statements.get(0).getParent();
  boolean isBlockWithoutCompositeParent=isBlockWithoutCompositeParent(parent);
  if (parent.getStatement() instanceof Block)   parent=(CompositeStatementObject)parent.getParent();
  int position=i;
  while (parent != null && parent instanceof TryStatementObject) {
    CompositeStatementObject tryStatement=parent;
    CompositeStatementObject tryStatementParent=(CompositeStatementObject)tryStatement.getParent();
    List<AbstractStatement> tryParentStatements=new ArrayList<AbstractStatement>(tryStatementParent.getStatements());
    if (tryStatementParent.getStatement() instanceof Block)     tryStatementParent=(CompositeStatementObject)tryStatementParent.getParent();
    int positionOfTryStatementInParent=0;
    int j=0;
    for (    AbstractStatement statement : tryParentStatements) {
      if (statement.equals(tryStatement)) {
        positionOfTryStatementInParent=j;
        break;
      }
      j++;
    }
    if (((TryStatementObject)tryStatement).hasResources()) {
      tryParentStatements.addAll(positionOfTryStatementInParent + 1,statements);
    }
 else {
      tryParentStatements.remove(tryStatement);
      tryParentStatements.addAll(positionOfTryStatementInParent,statements);
    }
    statements=tryParentStatements;
    parent=tryStatementParent;
    if (((TryStatementObject)tryStatement).hasResources())     position=positionOfTryStatementInParent + position + 1;
 else     position=positionOfTryStatementInParent + position;
  }
  if (parent != null && parent.getStatement() instanceof SwitchStatement && parentComposite.getStatement() instanceof Block) {
    List<AbstractStatement> switchStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParentSwitch=0;
    int j=0;
    for (    AbstractStatement statement : switchStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParentSwitch=j;
        break;
      }
      j++;
    }
    switchStatements.remove(parentComposite);
    switchStatements.addAll(positionOfBlockInParentSwitch,statements);
    statements=switchStatements;
    position=positionOfBlockInParentSwitch + position;
  }
  if (parent != null && isBlockWithoutCompositeParent) {
    List<AbstractStatement> blockStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParent=0;
    int j=0;
    for (    AbstractStatement statement : blockStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParent=j;
        break;
      }
      j++;
    }
    blockStatements.remove(parentComposite);
    blockStatements.addAll(positionOfBlockInParent,statements);
    statements=blockStatements;
    position=positionOfBlockInParent + position;
  }
  if (statements.size() == 1) {
    action=JOIN_TOP_LIST;
    if (parent != null) {
      if (isLoop(parent) || parent.getStatement() instanceof DoStatement)       action=PUSH_NEW_LIST;
    }
  }
 else   if (statements.size() > 1) {
    AbstractStatement previousStatement=null;
    if (position >= 1)     previousStatement=statements.get(position - 1);
    int j=0;
    while (previousStatement != null && previousStatement instanceof TryStatementObject && !((TryStatementObject)previousStatement).hasResources()) {
      CompositeStatementObject tryStatement=(CompositeStatementObject)previousStatement;
      AbstractStatement firstStatement=tryStatement.getStatements().get(0);
      if (firstStatement instanceof CompositeStatementObject) {
        CompositeStatementObject tryBlock=(CompositeStatementObject)firstStatement;
        List<AbstractStatement> tryBlockStatements=tryBlock.getStatements();
        if (tryBlockStatements.size() > 0) {
          previousStatement=tryBlockStatements.get(tryBlockStatements.size() - 1);
        }
 else {
          if (position >= 2 + j)           previousStatement=statements.get(position - 2 - j);
 else           previousStatement=null;
        }
      }
      j++;
    }
    while (previousStatement != null && isBlockWithoutCompositeParent(previousStatement)) {
      CompositeStatementObject block=(CompositeStatementObject)previousStatement;
      List<AbstractStatement> blockStatements=block.getStatements();
      if (blockStatements.size() > 0) {
        previousStatement=blockStatements.get(blockStatements.size() - 1);
      }
    }
    if (statements.get(statements.size() - 1).equals(childComposite)) {
      if (previousStatement != null && (previousStatement.getStatement() instanceof IfStatement || previousStatement.getStatement() instanceof SwitchStatement)) {
        action=JOIN_SECOND_FROM_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PLACE_NEW_LIST_SECOND_FROM_TOP;
      }
 else {
        action=JOIN_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PUSH_NEW_LIST;
      }
    }
 else {
      if (previousStatement != null && (previousStatement.getStatement() instanceof IfStatement || previousStatement.getStatement() instanceof SwitchStatement))       action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else {
        action=PUSH_NEW_LIST;
      }
    }
  }
  return action;
}","private int getAction(CompositeStatementObject parentComposite,int i,CompositeStatementObject childComposite){
  int action=PUSH_NEW_LIST;
  List<AbstractStatement> statements=new ArrayList<AbstractStatement>(parentComposite.getStatements());
  CompositeStatementObject parent=(CompositeStatementObject)statements.get(0).getParent();
  boolean isBlockWithoutCompositeParent=isBlockWithoutCompositeParent(parent);
  if (parent.getStatement() instanceof Block)   parent=(CompositeStatementObject)parent.getParent();
  int position=i;
  while (parent != null && (parent instanceof TryStatementObject || parent instanceof SynchronizedStatementObject)) {
    CompositeStatementObject tryStatement=parent;
    CompositeStatementObject tryStatementParent=(CompositeStatementObject)tryStatement.getParent();
    List<AbstractStatement> tryParentStatements=new ArrayList<AbstractStatement>(tryStatementParent.getStatements());
    if (tryStatementParent.getStatement() instanceof Block)     tryStatementParent=(CompositeStatementObject)tryStatementParent.getParent();
    int positionOfTryStatementInParent=0;
    int j=0;
    for (    AbstractStatement statement : tryParentStatements) {
      if (statement.equals(tryStatement)) {
        positionOfTryStatementInParent=j;
        break;
      }
      j++;
    }
    if (tryStatement instanceof TryStatementObject) {
      TryStatementObject tempTry=(TryStatementObject)tryStatement;
      if (tempTry.hasResources()) {
        tryParentStatements.addAll(positionOfTryStatementInParent + 1,statements);
      }
 else {
        tryParentStatements.remove(tryStatement);
        tryParentStatements.addAll(positionOfTryStatementInParent,statements);
      }
    }
 else {
      tryParentStatements.addAll(positionOfTryStatementInParent + 1,statements);
    }
    statements=tryParentStatements;
    parent=tryStatementParent;
    if (tryStatement instanceof TryStatementObject) {
      TryStatementObject tempTry=(TryStatementObject)tryStatement;
      if (tempTry.hasResources())       position=positionOfTryStatementInParent + position + 1;
 else       position=positionOfTryStatementInParent + position;
    }
 else {
      position=positionOfTryStatementInParent + position + 1;
    }
  }
  if (parent != null && parent.getStatement() instanceof SwitchStatement && parentComposite.getStatement() instanceof Block) {
    List<AbstractStatement> switchStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParentSwitch=0;
    int j=0;
    for (    AbstractStatement statement : switchStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParentSwitch=j;
        break;
      }
      j++;
    }
    switchStatements.remove(parentComposite);
    switchStatements.addAll(positionOfBlockInParentSwitch,statements);
    statements=switchStatements;
    position=positionOfBlockInParentSwitch + position;
  }
  if (parent != null && isBlockWithoutCompositeParent) {
    List<AbstractStatement> blockStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParent=0;
    int j=0;
    for (    AbstractStatement statement : blockStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParent=j;
        break;
      }
      j++;
    }
    blockStatements.remove(parentComposite);
    blockStatements.addAll(positionOfBlockInParent,statements);
    statements=blockStatements;
    position=positionOfBlockInParent + position;
  }
  if (statements.size() == 1) {
    action=JOIN_TOP_LIST;
    if (parent != null) {
      if (isLoop(parent) || parent.getStatement() instanceof DoStatement)       action=PUSH_NEW_LIST;
    }
  }
 else   if (statements.size() > 1) {
    AbstractStatement previousStatement=null;
    if (position >= 1)     previousStatement=statements.get(position - 1);
    int j=0;
    while (previousStatement != null && previousStatement instanceof TryStatementObject && !((TryStatementObject)previousStatement).hasResources()) {
      CompositeStatementObject tryStatement=(CompositeStatementObject)previousStatement;
      AbstractStatement firstStatement=tryStatement.getStatements().get(0);
      if (firstStatement instanceof CompositeStatementObject) {
        CompositeStatementObject tryBlock=(CompositeStatementObject)firstStatement;
        List<AbstractStatement> tryBlockStatements=tryBlock.getStatements();
        if (tryBlockStatements.size() > 0) {
          previousStatement=tryBlockStatements.get(tryBlockStatements.size() - 1);
        }
 else {
          if (position >= 2 + j)           previousStatement=statements.get(position - 2 - j);
 else           previousStatement=null;
        }
      }
      j++;
    }
    while (previousStatement != null && isBlockWithoutCompositeParent(previousStatement)) {
      CompositeStatementObject block=(CompositeStatementObject)previousStatement;
      List<AbstractStatement> blockStatements=block.getStatements();
      if (blockStatements.size() > 0) {
        previousStatement=blockStatements.get(blockStatements.size() - 1);
      }
    }
    if (statements.get(statements.size() - 1).equals(childComposite)) {
      if (previousStatement != null && (previousStatement.getStatement() instanceof IfStatement || previousStatement.getStatement() instanceof SwitchStatement)) {
        action=JOIN_SECOND_FROM_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PLACE_NEW_LIST_SECOND_FROM_TOP;
      }
 else {
        action=JOIN_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PUSH_NEW_LIST;
      }
    }
 else {
      if (previousStatement != null && (previousStatement.getStatement() instanceof IfStatement || previousStatement.getStatement() instanceof SwitchStatement))       action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else {
        action=PUSH_NEW_LIST;
      }
    }
  }
  return action;
}"
12084,"private void processInternalMethodInvocation(ClassObject classObject,MethodObject methodObject,AbstractVariable variableDeclaration,Set<String> processedMethods){
  SystemObject systemObject=ASTReader.getSystemObject();
  if (methodObject.isAbstract() || classObject.isInterface()) {
    TypeDeclaration typeDeclaration=classObject.getTypeDeclaration();
    IMethodBinding superMethodDeclarationBinding=methodObject.getMethodDeclaration().resolveBinding();
    IType superType=(IType)typeDeclaration.resolveBinding().getJavaElement();
    processedMethods.add(superMethodDeclarationBinding.getKey());
    Set<IType> subTypes=CompilationUnitCache.getInstance().getSubTypes(superType);
    Set<IType> subTypesToBeAnalyzed=new LinkedHashSet<IType>();
    if (variableDeclaration != null) {
      String initialReferenceType=variableDeclaration.getVariableType();
      for (      IType subType : subTypes) {
        if (subType.getFullyQualifiedName('.').equals(initialReferenceType)) {
          subTypesToBeAnalyzed.add(subType);
          break;
        }
      }
      if (subTypesToBeAnalyzed.isEmpty())       subTypesToBeAnalyzed.addAll(subTypes);
    }
 else     subTypesToBeAnalyzed.addAll(subTypes);
    for (    IType subType : subTypesToBeAnalyzed) {
      ClassObject subClassObject=systemObject.getClassObject(subType.getFullyQualifiedName('.'));
      if (subClassObject != null) {
        ListIterator<MethodObject> methodIterator=subClassObject.getMethodIterator();
        while (methodIterator.hasNext()) {
          MethodObject subMethod=methodIterator.next();
          if (equalSignature(subMethod.getMethodDeclaration().resolveBinding(),superMethodDeclarationBinding)) {
            processInternalMethodInvocation(subClassObject,subMethod,variableDeclaration,processedMethods);
            break;
          }
        }
      }
    }
  }
 else {
    for (    PlainVariable originalField : methodObject.getDefinedFieldsThroughThisReference()) {
      boolean alreadyContainsOriginalField=false;
      if (variableDeclaration != null && originalField instanceof PlainVariable) {
        if (variableDeclaration.containsPlainVariable((PlainVariable)originalField))         alreadyContainsOriginalField=true;
      }
      if (!alreadyContainsOriginalField) {
        AbstractVariable field=null;
        if (variableDeclaration != null)         field=composeVariable(variableDeclaration,originalField);
 else         field=originalField;
        definedVariables.add(field);
      }
    }
    for (    PlainVariable originalField : methodObject.getUsedFieldsThroughThisReference()) {
      boolean alreadyContainsOriginalField=false;
      if (variableDeclaration != null && originalField instanceof PlainVariable) {
        if (variableDeclaration.containsPlainVariable((PlainVariable)originalField))         alreadyContainsOriginalField=true;
      }
      if (!alreadyContainsOriginalField) {
        AbstractVariable field=null;
        if (variableDeclaration != null)         field=composeVariable(variableDeclaration,originalField);
 else         field=originalField;
        usedVariables.add(field);
      }
    }
    thrownExceptionTypes.addAll(methodObject.getExceptionsInThrowStatements());
    processedMethods.add(methodObject.getMethodDeclaration().resolveBinding().getKey());
    Map<AbstractVariable,LinkedHashSet<MethodInvocationObject>> invokedMethodsThroughFields=methodObject.getInvokedMethodsThroughFields();
    for (    AbstractVariable originalField : invokedMethodsThroughFields.keySet()) {
      boolean alreadyContainsOriginalField=false;
      if (variableDeclaration != null && originalField instanceof PlainVariable) {
        if (variableDeclaration.containsPlainVariable((PlainVariable)originalField))         alreadyContainsOriginalField=true;
      }
      if (!alreadyContainsOriginalField) {
        LinkedHashSet<MethodInvocationObject> methodInvocations=invokedMethodsThroughFields.get(originalField);
        AbstractVariable field=null;
        if (variableDeclaration != null)         field=composeVariable(variableDeclaration,originalField);
 else         field=originalField;
        for (        MethodInvocationObject methodInvocationObject : methodInvocations) {
          MethodInvocation methodInvocation2=methodInvocationObject.getMethodInvocation();
          ClassObject classObject2=systemObject.getClassObject(methodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(methodInvocationObject);
            if (methodObject2 != null) {
              processInternalMethodInvocation(classObject2,methodObject2,field,new LinkedHashSet<String>());
            }
          }
 else {
            LibraryClassStorage instance=LibraryClassStorage.getInstance();
            IMethodBinding invokedMethodBinding=methodInvocation2.resolveMethodBinding();
            if (instance.isAnalyzed(invokedMethodBinding.getKey())) {
              handleAlreadyAnalyzedMethod(invokedMethodBinding.getKey(),field,instance);
            }
 else {
              MethodDeclaration invokedMethodDeclaration=getInvokedMethodDeclaration(invokedMethodBinding);
              if (invokedMethodDeclaration != null)               processExternalMethodInvocation(invokedMethodDeclaration,field,new LinkedHashSet<String>(),0);
            }
          }
        }
      }
    }
    for (    MethodInvocationObject methodInvocationObject : methodObject.getInvokedMethodsThroughThisReference()) {
      MethodObject methodObject2=classObject.getMethod(methodInvocationObject);
      if (methodObject2 != null) {
        if (!methodObject2.equals(methodObject)) {
          MethodInvocation methodInvocation2=methodInvocationObject.getMethodInvocation();
          if (!processedMethods.contains(methodInvocation2.resolveMethodBinding().getKey()))           processInternalMethodInvocation(classObject,methodObject2,variableDeclaration,processedMethods);
        }
      }
 else {
        ClassObject classObject2=systemObject.getClassObject(methodInvocationObject.getOriginClassName());
        if (classObject2 != null) {
          methodObject2=classObject2.getMethod(methodInvocationObject);
          if (methodObject2 != null) {
            thrownExceptionTypes.addAll(methodObject2.getExceptionsInThrowStatements());
          }
        }
      }
    }
    for (    SuperMethodInvocationObject superMethodInvocationObject : methodObject.getSuperMethodInvocations()) {
      ClassObject classObject2=systemObject.getClassObject(superMethodInvocationObject.getOriginClassName());
      if (classObject2 != null) {
        MethodObject methodObject2=classObject2.getMethod(superMethodInvocationObject);
        if (methodObject2 != null) {
          SuperMethodInvocation superMethodInvocation=superMethodInvocationObject.getSuperMethodInvocation();
          if (!processedMethods.contains(superMethodInvocation.resolveMethodBinding().getKey()))           processInternalMethodInvocation(classObject2,methodObject2,variableDeclaration,processedMethods);
        }
      }
    }
  }
}","private void processInternalMethodInvocation(ClassObject classObject,MethodObject methodObject,AbstractVariable variableDeclaration,Set<String> processedMethods){
  SystemObject systemObject=ASTReader.getSystemObject();
  if (methodObject.isAbstract() || classObject.isInterface()) {
    TypeDeclaration typeDeclaration=classObject.getTypeDeclaration();
    IMethodBinding superMethodDeclarationBinding=methodObject.getMethodDeclaration().resolveBinding();
    IType superType=(IType)typeDeclaration.resolveBinding().getJavaElement();
    processedMethods.add(superMethodDeclarationBinding.getKey());
    Set<IType> subTypes=CompilationUnitCache.getInstance().getSubTypes(superType);
    Set<IType> subTypesToBeAnalyzed=new LinkedHashSet<IType>();
    if (variableDeclaration != null) {
      String initialReferenceType=variableDeclaration.getVariableType();
      for (      IType subType : subTypes) {
        if (subType.getFullyQualifiedName('.').equals(initialReferenceType)) {
          subTypesToBeAnalyzed.add(subType);
          break;
        }
      }
      if (subTypesToBeAnalyzed.isEmpty())       subTypesToBeAnalyzed.addAll(subTypes);
    }
 else     subTypesToBeAnalyzed.addAll(subTypes);
    for (    IType subType : subTypesToBeAnalyzed) {
      ClassObject subClassObject=systemObject.getClassObject(subType.getFullyQualifiedName('.'));
      if (subClassObject != null) {
        ListIterator<MethodObject> methodIterator=subClassObject.getMethodIterator();
        while (methodIterator.hasNext()) {
          MethodObject subMethod=methodIterator.next();
          if (equalSignature(subMethod.getMethodDeclaration().resolveBinding(),superMethodDeclarationBinding)) {
            processInternalMethodInvocation(subClassObject,subMethod,variableDeclaration,processedMethods);
            break;
          }
        }
      }
    }
  }
 else {
    for (    PlainVariable originalField : methodObject.getDefinedFieldsThroughThisReference()) {
      boolean alreadyContainsOriginalField=false;
      if (variableDeclaration != null && originalField instanceof PlainVariable) {
        if (variableDeclaration.containsPlainVariable((PlainVariable)originalField))         alreadyContainsOriginalField=true;
      }
      if (!alreadyContainsOriginalField) {
        AbstractVariable field=null;
        if (variableDeclaration != null)         field=composeVariable(variableDeclaration,originalField);
 else         field=originalField;
        definedVariables.add(field);
      }
    }
    for (    PlainVariable originalField : methodObject.getUsedFieldsThroughThisReference()) {
      boolean alreadyContainsOriginalField=false;
      if (variableDeclaration != null && originalField instanceof PlainVariable) {
        if (variableDeclaration.containsPlainVariable((PlainVariable)originalField))         alreadyContainsOriginalField=true;
      }
      if (!alreadyContainsOriginalField) {
        AbstractVariable field=null;
        if (variableDeclaration != null)         field=composeVariable(variableDeclaration,originalField);
 else         field=originalField;
        usedVariables.add(field);
      }
    }
    thrownExceptionTypes.addAll(methodObject.getExceptionsInThrowStatements());
    processedMethods.add(methodObject.getMethodDeclaration().resolveBinding().getKey());
    Map<AbstractVariable,LinkedHashSet<MethodInvocationObject>> invokedMethodsThroughFields=methodObject.getInvokedMethodsThroughFields();
    for (    AbstractVariable originalField : invokedMethodsThroughFields.keySet()) {
      boolean alreadyContainsOriginalField=false;
      if (variableDeclaration != null && originalField instanceof PlainVariable) {
        if (variableDeclaration.containsPlainVariable((PlainVariable)originalField))         alreadyContainsOriginalField=true;
      }
      if (!alreadyContainsOriginalField) {
        LinkedHashSet<MethodInvocationObject> methodInvocations=invokedMethodsThroughFields.get(originalField);
        AbstractVariable field=null;
        if (variableDeclaration != null)         field=composeVariable(variableDeclaration,originalField);
 else         field=originalField;
        for (        MethodInvocationObject methodInvocationObject : methodInvocations) {
          MethodInvocation methodInvocation2=methodInvocationObject.getMethodInvocation();
          ClassObject classObject2=systemObject.getClassObject(methodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(methodInvocationObject);
            if (methodObject2 != null) {
              if (!processedMethods.contains(methodInvocation2.resolveMethodBinding().getKey()))               processInternalMethodInvocation(classObject2,methodObject2,field,new LinkedHashSet<String>());
            }
          }
 else {
            LibraryClassStorage instance=LibraryClassStorage.getInstance();
            IMethodBinding invokedMethodBinding=methodInvocation2.resolveMethodBinding();
            if (instance.isAnalyzed(invokedMethodBinding.getKey())) {
              handleAlreadyAnalyzedMethod(invokedMethodBinding.getKey(),field,instance);
            }
 else {
              MethodDeclaration invokedMethodDeclaration=getInvokedMethodDeclaration(invokedMethodBinding);
              if (invokedMethodDeclaration != null)               processExternalMethodInvocation(invokedMethodDeclaration,field,new LinkedHashSet<String>(),0);
            }
          }
        }
      }
    }
    for (    MethodInvocationObject methodInvocationObject : methodObject.getInvokedMethodsThroughThisReference()) {
      MethodObject methodObject2=classObject.getMethod(methodInvocationObject);
      if (methodObject2 != null) {
        if (!methodObject2.equals(methodObject)) {
          MethodInvocation methodInvocation2=methodInvocationObject.getMethodInvocation();
          if (!processedMethods.contains(methodInvocation2.resolveMethodBinding().getKey()))           processInternalMethodInvocation(classObject,methodObject2,variableDeclaration,processedMethods);
        }
      }
 else {
        ClassObject classObject2=systemObject.getClassObject(methodInvocationObject.getOriginClassName());
        if (classObject2 != null) {
          methodObject2=classObject2.getMethod(methodInvocationObject);
          if (methodObject2 != null) {
            thrownExceptionTypes.addAll(methodObject2.getExceptionsInThrowStatements());
          }
        }
      }
    }
    for (    SuperMethodInvocationObject superMethodInvocationObject : methodObject.getSuperMethodInvocations()) {
      ClassObject classObject2=systemObject.getClassObject(superMethodInvocationObject.getOriginClassName());
      if (classObject2 != null) {
        MethodObject methodObject2=classObject2.getMethod(superMethodInvocationObject);
        if (methodObject2 != null) {
          SuperMethodInvocation superMethodInvocation=superMethodInvocationObject.getSuperMethodInvocation();
          if (!processedMethods.contains(superMethodInvocation.resolveMethodBinding().getKey()))           processInternalMethodInvocation(classObject2,methodObject2,variableDeclaration,processedMethods);
        }
      }
    }
  }
}"
12085,"private int getAction(CompositeStatementObject parentComposite,int i,CompositeStatementObject childComposite){
  int action=PUSH_NEW_LIST;
  List<AbstractStatement> statements=new ArrayList<AbstractStatement>(parentComposite.getStatements());
  CompositeStatementObject parent=(CompositeStatementObject)statements.get(0).getParent();
  boolean isBlockWithoutCompositeParent=isBlockWithoutCompositeParent(parent);
  if (parent.getStatement() instanceof Block)   parent=(CompositeStatementObject)parent.getParent();
  int position=i;
  while (parent != null && parent instanceof TryStatementObject) {
    CompositeStatementObject tryStatement=parent;
    CompositeStatementObject tryStatementParent=(CompositeStatementObject)tryStatement.getParent();
    List<AbstractStatement> tryParentStatements=new ArrayList<AbstractStatement>(tryStatementParent.getStatements());
    if (tryStatementParent.getStatement() instanceof Block)     tryStatementParent=(CompositeStatementObject)tryStatementParent.getParent();
    int positionOfTryStatementInParent=0;
    int j=0;
    for (    AbstractStatement statement : tryParentStatements) {
      if (statement.equals(tryStatement)) {
        positionOfTryStatementInParent=j;
        break;
      }
      j++;
    }
    if (((TryStatementObject)tryStatement).hasResources()) {
      tryParentStatements.addAll(positionOfTryStatementInParent + 1,statements);
    }
 else {
      tryParentStatements.remove(tryStatement);
      tryParentStatements.addAll(positionOfTryStatementInParent,statements);
    }
    statements=tryParentStatements;
    parent=tryStatementParent;
    if (((TryStatementObject)tryStatement).hasResources())     position=positionOfTryStatementInParent + position + 1;
 else     position=positionOfTryStatementInParent + position;
  }
  if (parent != null && parent.getStatement() instanceof SwitchStatement && parentComposite.getStatement() instanceof Block) {
    List<AbstractStatement> switchStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParentSwitch=0;
    int j=0;
    for (    AbstractStatement statement : switchStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParentSwitch=j;
        break;
      }
      j++;
    }
    switchStatements.remove(parentComposite);
    switchStatements.addAll(positionOfBlockInParentSwitch,statements);
    statements=switchStatements;
    position=positionOfBlockInParentSwitch + position;
  }
  if (parent != null && isBlockWithoutCompositeParent) {
    List<AbstractStatement> blockStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParent=0;
    int j=0;
    for (    AbstractStatement statement : blockStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParent=j;
        break;
      }
      j++;
    }
    blockStatements.remove(parentComposite);
    blockStatements.addAll(positionOfBlockInParent,statements);
    statements=blockStatements;
    position=positionOfBlockInParent + position;
  }
  if (statements.size() == 1) {
    action=JOIN_TOP_LIST;
    if (parent != null) {
      if (isLoop(parent))       action=PUSH_NEW_LIST;
 else       if (parent.getStatement() instanceof DoStatement)       action=PLACE_NEW_LIST_SECOND_FROM_TOP;
    }
  }
 else   if (statements.size() > 1) {
    AbstractStatement previousStatement=null;
    if (position >= 1)     previousStatement=statements.get(position - 1);
    int j=0;
    while (previousStatement != null && previousStatement instanceof TryStatementObject && !((TryStatementObject)previousStatement).hasResources()) {
      CompositeStatementObject tryStatement=(CompositeStatementObject)previousStatement;
      AbstractStatement firstStatement=tryStatement.getStatements().get(0);
      if (firstStatement instanceof CompositeStatementObject) {
        CompositeStatementObject tryBlock=(CompositeStatementObject)firstStatement;
        List<AbstractStatement> tryBlockStatements=tryBlock.getStatements();
        if (tryBlockStatements.size() > 0) {
          previousStatement=tryBlockStatements.get(tryBlockStatements.size() - 1);
        }
 else {
          if (position >= 2 + j)           previousStatement=statements.get(position - 2 - j);
 else           previousStatement=null;
        }
      }
      j++;
    }
    while (previousStatement != null && isBlockWithoutCompositeParent(previousStatement)) {
      CompositeStatementObject block=(CompositeStatementObject)previousStatement;
      List<AbstractStatement> blockStatements=block.getStatements();
      if (blockStatements.size() > 0) {
        previousStatement=blockStatements.get(blockStatements.size() - 1);
      }
    }
    if (statements.get(statements.size() - 1).equals(childComposite)) {
      if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement) {
        action=JOIN_SECOND_FROM_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PLACE_NEW_LIST_SECOND_FROM_TOP;
      }
 else {
        action=JOIN_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PUSH_NEW_LIST;
      }
    }
 else {
      if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement)       action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else {
        action=PUSH_NEW_LIST;
      }
    }
  }
  return action;
}","private int getAction(CompositeStatementObject parentComposite,int i,CompositeStatementObject childComposite){
  int action=PUSH_NEW_LIST;
  List<AbstractStatement> statements=new ArrayList<AbstractStatement>(parentComposite.getStatements());
  CompositeStatementObject parent=(CompositeStatementObject)statements.get(0).getParent();
  boolean isBlockWithoutCompositeParent=isBlockWithoutCompositeParent(parent);
  if (parent.getStatement() instanceof Block)   parent=(CompositeStatementObject)parent.getParent();
  int position=i;
  while (parent != null && parent instanceof TryStatementObject) {
    CompositeStatementObject tryStatement=parent;
    CompositeStatementObject tryStatementParent=(CompositeStatementObject)tryStatement.getParent();
    List<AbstractStatement> tryParentStatements=new ArrayList<AbstractStatement>(tryStatementParent.getStatements());
    if (tryStatementParent.getStatement() instanceof Block)     tryStatementParent=(CompositeStatementObject)tryStatementParent.getParent();
    int positionOfTryStatementInParent=0;
    int j=0;
    for (    AbstractStatement statement : tryParentStatements) {
      if (statement.equals(tryStatement)) {
        positionOfTryStatementInParent=j;
        break;
      }
      j++;
    }
    if (((TryStatementObject)tryStatement).hasResources()) {
      tryParentStatements.addAll(positionOfTryStatementInParent + 1,statements);
    }
 else {
      tryParentStatements.remove(tryStatement);
      tryParentStatements.addAll(positionOfTryStatementInParent,statements);
    }
    statements=tryParentStatements;
    parent=tryStatementParent;
    if (((TryStatementObject)tryStatement).hasResources())     position=positionOfTryStatementInParent + position + 1;
 else     position=positionOfTryStatementInParent + position;
  }
  if (parent != null && parent.getStatement() instanceof SwitchStatement && parentComposite.getStatement() instanceof Block) {
    List<AbstractStatement> switchStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParentSwitch=0;
    int j=0;
    for (    AbstractStatement statement : switchStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParentSwitch=j;
        break;
      }
      j++;
    }
    switchStatements.remove(parentComposite);
    switchStatements.addAll(positionOfBlockInParentSwitch,statements);
    statements=switchStatements;
    position=positionOfBlockInParentSwitch + position;
  }
  if (parent != null && isBlockWithoutCompositeParent) {
    List<AbstractStatement> blockStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParent=0;
    int j=0;
    for (    AbstractStatement statement : blockStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParent=j;
        break;
      }
      j++;
    }
    blockStatements.remove(parentComposite);
    blockStatements.addAll(positionOfBlockInParent,statements);
    statements=blockStatements;
    position=positionOfBlockInParent + position;
  }
  if (statements.size() == 1) {
    action=JOIN_TOP_LIST;
    if (parent != null) {
      if (isLoop(parent) || parent.getStatement() instanceof DoStatement)       action=PUSH_NEW_LIST;
    }
  }
 else   if (statements.size() > 1) {
    AbstractStatement previousStatement=null;
    if (position >= 1)     previousStatement=statements.get(position - 1);
    int j=0;
    while (previousStatement != null && previousStatement instanceof TryStatementObject && !((TryStatementObject)previousStatement).hasResources()) {
      CompositeStatementObject tryStatement=(CompositeStatementObject)previousStatement;
      AbstractStatement firstStatement=tryStatement.getStatements().get(0);
      if (firstStatement instanceof CompositeStatementObject) {
        CompositeStatementObject tryBlock=(CompositeStatementObject)firstStatement;
        List<AbstractStatement> tryBlockStatements=tryBlock.getStatements();
        if (tryBlockStatements.size() > 0) {
          previousStatement=tryBlockStatements.get(tryBlockStatements.size() - 1);
        }
 else {
          if (position >= 2 + j)           previousStatement=statements.get(position - 2 - j);
 else           previousStatement=null;
        }
      }
      j++;
    }
    while (previousStatement != null && isBlockWithoutCompositeParent(previousStatement)) {
      CompositeStatementObject block=(CompositeStatementObject)previousStatement;
      List<AbstractStatement> blockStatements=block.getStatements();
      if (blockStatements.size() > 0) {
        previousStatement=blockStatements.get(blockStatements.size() - 1);
      }
    }
    if (statements.get(statements.size() - 1).equals(childComposite)) {
      if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement) {
        action=JOIN_SECOND_FROM_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PLACE_NEW_LIST_SECOND_FROM_TOP;
      }
 else {
        action=JOIN_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PUSH_NEW_LIST;
      }
    }
 else {
      if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement)       action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else {
        action=PUSH_NEW_LIST;
      }
    }
  }
  return action;
}"
12086,"private ASTNode processASTNodeWithDifferences(AST ast,ASTRewrite sourceRewriter,ASTNode oldASTNode,List<ASTNodeDifference> differences){
  if (differences.isEmpty()) {
    return oldASTNode;
  }
 else {
    Set<String> parameterBindingKeys=originalPassedParameters.keySet();
    Set<String> declaredLocalVariableBindingKeys=mapper.getDeclaredLocalVariablesInMappedNodes().keySet();
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ASTNode newASTNode=ASTNode.copySubtree(ast,oldASTNode);
    for (    ASTNodeDifference difference : differences) {
      Expression oldExpression=difference.getExpression1().getExpression();
      boolean isCommonParameter=false;
      if (isMethodName(oldExpression)) {
        SimpleName oldSimpleName=(SimpleName)oldExpression;
        IBinding binding=oldSimpleName.resolveBinding();
        oldExpression=(Expression)oldExpression.getParent();
        if (parameterBindingKeys.contains(binding.getKey()) || declaredLocalVariableBindingKeys.contains(binding.getKey()))         isCommonParameter=true;
      }
 else       if (oldExpression instanceof SimpleName) {
        SimpleName oldSimpleName=(SimpleName)oldExpression;
        IBinding binding=oldSimpleName.resolveBinding();
        if (parameterBindingKeys.contains(binding.getKey()) || declaredLocalVariableBindingKeys.contains(binding.getKey()))         isCommonParameter=true;
      }
 else       if (oldExpression instanceof QualifiedName) {
        QualifiedName oldQualifiedName=(QualifiedName)oldExpression;
        SimpleName oldSimpleName=oldQualifiedName.getName();
        IBinding binding=oldSimpleName.resolveBinding();
        if (parameterBindingKeys.contains(binding.getKey()) || declaredLocalVariableBindingKeys.contains(binding.getKey()))         isCommonParameter=true;
      }
      if (!isCommonParameter) {
        if (oldExpression.getParent() instanceof Type) {
          Type oldType=(Type)oldExpression.getParent();
          if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH)) {
            ITypeBinding typeBinding1=difference.getExpression1().getExpression().resolveTypeBinding();
            ITypeBinding typeBinding2=difference.getExpression2().getExpression().resolveTypeBinding();
            ITypeBinding commonSuperTypeBinding=commonSuperType(typeBinding1,typeBinding2);
            if (commonSuperTypeBinding != null) {
              Type arg=generateTypeFromTypeBinding(commonSuperTypeBinding,ast,sourceRewriter);
              TypeVisitor oldTypeVisitor=new TypeVisitor();
              oldASTNode.accept(oldTypeVisitor);
              List<Type> oldTypes=oldTypeVisitor.getTypes();
              TypeVisitor newTypeVisitor=new TypeVisitor();
              newASTNode.accept(newTypeVisitor);
              List<Type> newTypes=newTypeVisitor.getTypes();
              int j=0;
              for (              Type type : oldTypes) {
                Type newType=newTypes.get(j);
                if (type.equals(oldType)) {
                  sourceRewriter.replace(newType,arg,null);
                  break;
                }
                j++;
              }
            }
          }
        }
 else {
          SimpleName argument;
          Set<VariableDeclaration> fields=fieldDeclarationsToBePulledUp.get(0);
          BindingSignature bindingSignature1=difference.getBindingSignaturePair().getSignature1();
          boolean variableIsFieldToBePulledUp=false;
          for (          VariableDeclaration field : fields) {
            if (bindingSignature1.containsBinding(field.resolveBinding().getKey())) {
              variableIsFieldToBePulledUp=true;
              break;
            }
          }
          if (!variableIsFieldToBePulledUp) {
            if (parameterizedDifferenceMap.containsKey(difference.getBindingSignaturePair())) {
              List<BindingSignaturePair> list=new ArrayList<BindingSignaturePair>(parameterizedDifferenceMap.keySet());
              int index=list.indexOf(difference.getBindingSignaturePair());
              argument=ast.newSimpleName(""String_Node_Str"" + index);
            }
 else {
              argument=ast.newSimpleName(""String_Node_Str"" + parameterizedDifferenceMap.size());
              parameterizedDifferenceMap.put(difference.getBindingSignaturePair(),difference);
            }
            int j=0;
            List<Expression> oldExpressions=expressionExtractor.getAllExpressions(oldASTNode);
            List<Expression> newExpressions=expressionExtractor.getAllExpressions(newASTNode);
            for (            Expression expression : oldExpressions) {
              Expression newExpression=newExpressions.get(j);
              if (expression.equals(oldExpression)) {
                sourceRewriter.replace(newExpression,argument,null);
                break;
              }
              if (oldExpression instanceof QualifiedName) {
                QualifiedName oldQualifiedName=(QualifiedName)oldExpression;
                if (expression.equals(oldQualifiedName.getName())) {
                  sourceRewriter.replace(newExpression.getParent(),argument,null);
                  break;
                }
              }
              j++;
            }
          }
        }
      }
    }
    return newASTNode;
  }
}","private ASTNode processASTNodeWithDifferences(AST ast,ASTRewrite sourceRewriter,ASTNode oldASTNode,List<ASTNodeDifference> differences){
  if (differences.isEmpty()) {
    return oldASTNode;
  }
 else {
    Set<String> parameterBindingKeys=originalPassedParameters.keySet();
    Set<String> declaredLocalVariableBindingKeys=mapper.getDeclaredLocalVariablesInMappedNodes().keySet();
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ASTNode newASTNode=ASTNode.copySubtree(ast,oldASTNode);
    for (    ASTNodeDifference difference : differences) {
      Expression oldExpression=difference.getExpression1().getExpression();
      boolean isCommonParameter=false;
      if (isMethodName(oldExpression)) {
        SimpleName oldSimpleName=(SimpleName)oldExpression;
        IBinding binding=oldSimpleName.resolveBinding();
        oldExpression=(Expression)oldExpression.getParent();
        if (parameterBindingKeys.contains(binding.getKey()) || declaredLocalVariableBindingKeys.contains(binding.getKey()))         isCommonParameter=true;
      }
 else       if (oldExpression instanceof SimpleName) {
        SimpleName oldSimpleName=(SimpleName)oldExpression;
        IBinding binding=oldSimpleName.resolveBinding();
        if (parameterBindingKeys.contains(binding.getKey()) || declaredLocalVariableBindingKeys.contains(binding.getKey()))         isCommonParameter=true;
      }
 else       if (oldExpression instanceof QualifiedName) {
        QualifiedName oldQualifiedName=(QualifiedName)oldExpression;
        SimpleName oldSimpleName=oldQualifiedName.getName();
        IBinding binding=oldSimpleName.resolveBinding();
        if (parameterBindingKeys.contains(binding.getKey()) || declaredLocalVariableBindingKeys.contains(binding.getKey()))         isCommonParameter=true;
      }
      if (!isCommonParameter) {
        if (oldExpression.getParent() instanceof Type) {
          Type oldType=(Type)oldExpression.getParent();
          if (difference.containsDifferenceType(DifferenceType.SUBCLASS_TYPE_MISMATCH)) {
            ITypeBinding typeBinding1=difference.getExpression1().getExpression().resolveTypeBinding();
            ITypeBinding typeBinding2=difference.getExpression2().getExpression().resolveTypeBinding();
            ITypeBinding commonSuperTypeBinding=commonSuperType(typeBinding1,typeBinding2);
            if (commonSuperTypeBinding != null) {
              Type arg=generateTypeFromTypeBinding(commonSuperTypeBinding,ast,sourceRewriter);
              TypeVisitor oldTypeVisitor=new TypeVisitor();
              oldASTNode.accept(oldTypeVisitor);
              List<Type> oldTypes=oldTypeVisitor.getTypes();
              TypeVisitor newTypeVisitor=new TypeVisitor();
              newASTNode.accept(newTypeVisitor);
              List<Type> newTypes=newTypeVisitor.getTypes();
              int j=0;
              for (              Type type : oldTypes) {
                Type newType=newTypes.get(j);
                if (type.equals(oldType)) {
                  sourceRewriter.replace(newType,arg,null);
                  break;
                }
                j++;
              }
            }
          }
        }
 else {
          Set<VariableDeclaration> fields1=fieldDeclarationsToBePulledUp.get(0);
          BindingSignature bindingSignature1=difference.getBindingSignaturePair().getSignature1();
          boolean expression1IsFieldToBePulledUp=false;
          for (          VariableDeclaration field : fields1) {
            if (bindingSignature1.containsOnlyBinding(field.resolveBinding().getKey())) {
              expression1IsFieldToBePulledUp=true;
              break;
            }
          }
          Set<VariableDeclaration> fields2=fieldDeclarationsToBePulledUp.get(1);
          BindingSignature bindingSignature2=difference.getBindingSignaturePair().getSignature2();
          boolean expression2IsFieldToBePulledUp=false;
          for (          VariableDeclaration field : fields2) {
            if (bindingSignature2.containsOnlyBinding(field.resolveBinding().getKey())) {
              expression2IsFieldToBePulledUp=true;
              break;
            }
          }
          boolean expressionIsFieldToBePulledUp=expression1IsFieldToBePulledUp && expression2IsFieldToBePulledUp;
          if (!expressionIsFieldToBePulledUp) {
            SimpleName argument;
            if (parameterizedDifferenceMap.containsKey(difference.getBindingSignaturePair())) {
              List<BindingSignaturePair> list=new ArrayList<BindingSignaturePair>(parameterizedDifferenceMap.keySet());
              int index=list.indexOf(difference.getBindingSignaturePair());
              argument=ast.newSimpleName(""String_Node_Str"" + index);
            }
 else {
              argument=ast.newSimpleName(""String_Node_Str"" + parameterizedDifferenceMap.size());
              parameterizedDifferenceMap.put(difference.getBindingSignaturePair(),difference);
            }
            int j=0;
            List<Expression> oldExpressions=expressionExtractor.getAllExpressions(oldASTNode);
            List<Expression> newExpressions=expressionExtractor.getAllExpressions(newASTNode);
            for (            Expression expression : oldExpressions) {
              Expression newExpression=newExpressions.get(j);
              if (expression.equals(oldExpression)) {
                sourceRewriter.replace(newExpression,argument,null);
                break;
              }
              if (oldExpression instanceof QualifiedName) {
                QualifiedName oldQualifiedName=(QualifiedName)oldExpression;
                if (expression.equals(oldQualifiedName.getName())) {
                  sourceRewriter.replace(newExpression.getParent(),argument,null);
                  break;
                }
              }
              j++;
            }
          }
        }
      }
    }
    return newASTNode;
  }
}"
12087,"private void createStateStrategyHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  PackageDeclaration contextPackageDeclaration=sourceCompilationUnit.getPackage();
  IContainer rootContainer=contextContainer;
  if (contextPackageDeclaration != null) {
    String packageName=contextPackageDeclaration.getName().getFullyQualifiedName();
    String[] subPackages=packageName.split(""String_Node_Str"");
    for (int i=0; i < subPackages.length; i++)     rootContainer=(IContainer)rootContainer.getParent();
  }
  InheritanceTree tree=typeCheckElimination.getInheritanceTreeMatchingWithStaticTypes();
  IFile stateStrategyFile=null;
  if (tree != null) {
    DefaultMutableTreeNode rootNode=tree.getRootNode();
    stateStrategyFile=getFile(rootContainer,(String)rootNode.getUserObject());
  }
 else {
    if (contextContainer instanceof IProject) {
      IProject contextProject=(IProject)contextContainer;
      stateStrategyFile=contextProject.getFile(abstractClassName + ""String_Node_Str"");
    }
 else     if (contextContainer instanceof IFolder) {
      IFolder contextFolder=(IFolder)contextContainer;
      stateStrategyFile=contextFolder.getFile(abstractClassName + ""String_Node_Str"");
    }
  }
  boolean stateStrategyAlreadyExists=false;
  ICompilationUnit stateStrategyICompilationUnit=JavaCore.createCompilationUnitFrom(stateStrategyFile);
  javaElementsToOpenInEditor.add(stateStrategyICompilationUnit);
  ASTParser stateStrategyParser=ASTParser.newParser(AST.JLS4);
  stateStrategyParser.setKind(ASTParser.K_COMPILATION_UNIT);
  Document stateStrategyDocument=null;
  if (stateStrategyFile.exists()) {
    stateStrategyAlreadyExists=true;
    stateStrategyParser.setSource(stateStrategyICompilationUnit);
    stateStrategyParser.setResolveBindings(true);
  }
 else {
    stateStrategyDocument=new Document();
    stateStrategyParser.setSource(stateStrategyDocument.get().toCharArray());
  }
  CompilationUnit stateStrategyCompilationUnit=(CompilationUnit)stateStrategyParser.createAST(null);
  AST stateStrategyAST=stateStrategyCompilationUnit.getAST();
  ASTRewrite stateStrategyRewriter=ASTRewrite.create(stateStrategyAST);
  ListRewrite stateStrategyTypesRewrite=stateStrategyRewriter.getListRewrite(stateStrategyCompilationUnit,CompilationUnit.TYPES_PROPERTY);
  TypeDeclaration stateStrategyTypeDeclaration=null;
  if (stateStrategyAlreadyExists) {
    List<AbstractTypeDeclaration> abstractTypeDeclarations=stateStrategyCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.getName().getIdentifier().equals(abstractClassName)) {
          stateStrategyTypeDeclaration=typeDeclaration;
          requiredImportDeclarationsForContext.add(stateStrategyTypeDeclaration.resolveBinding());
          int stateStrategyModifiers=stateStrategyTypeDeclaration.getModifiers();
          if ((stateStrategyModifiers & Modifier.ABSTRACT) == 0) {
            ListRewrite stateStrategyModifiersRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
            stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
          }
          break;
        }
      }
    }
  }
 else {
    if (sourceCompilationUnit.getPackage() != null) {
      stateStrategyRewriter.set(stateStrategyCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,sourceCompilationUnit.getPackage(),null);
    }
    stateStrategyTypeDeclaration=stateStrategyAST.newTypeDeclaration();
    SimpleName stateStrategyName=stateStrategyAST.newSimpleName(abstractClassName);
    stateStrategyRewriter.set(stateStrategyTypeDeclaration,TypeDeclaration.NAME_PROPERTY,stateStrategyName,null);
    ListRewrite stateStrategyModifiersRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite stateStrategyBodyRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  if (typeCheckElimination.getTypeField() != null) {
    if (getterMethod != null) {
      MethodDeclaration abstractGetterMethodDeclaration=stateStrategyAST.newMethodDeclaration();
      stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,getterMethod.getName(),null);
      stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,getterMethod.getReturnType2(),null);
      ListRewrite abstractGetterMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
      abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
      stateStrategyBodyRewrite.insertLast(abstractGetterMethodDeclaration,null);
    }
 else {
      MethodDeclaration abstractGetterMethodDeclaration=stateStrategyAST.newMethodDeclaration();
      stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(""String_Node_Str"" + abstractClassName),null);
      VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
      Type returnType=((FieldDeclaration)typeField.getParent()).getType();
      stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      ListRewrite abstractGetterMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
      abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
      stateStrategyBodyRewrite.insertLast(abstractGetterMethodDeclaration,null);
    }
  }
  MethodDeclaration abstractMethodDeclaration=stateStrategyAST.newMethodDeclaration();
  stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(typeCheckElimination.getAbstractMethodName()),null);
  if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
    stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,stateStrategyAST.newPrimitiveType(PrimitiveType.VOID),null);
  }
 else {
    if (returnedVariable != null) {
      Type returnType=null;
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        returnType=singleVariableDeclaration.getType();
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        if (variableDeclarationFragment.getParent() instanceof VariableDeclarationStatement) {
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
          returnType=variableDeclarationStatement.getType();
        }
 else         if (variableDeclarationFragment.getParent() instanceof VariableDeclarationExpression) {
          VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)variableDeclarationFragment.getParent();
          returnType=variableDeclarationExpression.getType();
        }
 else         if (variableDeclarationFragment.getParent() instanceof FieldDeclaration) {
          FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarationFragment.getParent();
          returnType=fieldDeclaration.getType();
        }
      }
      stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    }
 else {
      stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    }
  }
  ListRewrite abstractMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  if (returnedVariable != null) {
    if (returnedVariable instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
      abstractMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
    }
 else     if (returnedVariable instanceof VariableDeclarationFragment) {
      SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
      VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
      Type type=null;
      if (variableDeclarationFragment.getParent() instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
        type=variableDeclarationStatement.getType();
      }
 else       if (variableDeclarationFragment.getParent() instanceof VariableDeclarationExpression) {
        VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)variableDeclarationFragment.getParent();
        type=variableDeclarationExpression.getType();
      }
 else       if (variableDeclarationFragment.getParent() instanceof FieldDeclaration) {
        FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarationFragment.getParent();
        type=fieldDeclaration.getType();
      }
      stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    if (!abstractMethodParameter.equals(returnedVariable)) {
      abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
  }
  for (  VariableDeclaration fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      if (fragment instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)fragment;
        abstractMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
      }
 else       if (fragment instanceof VariableDeclarationFragment) {
        SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)fragment;
        Type type=null;
        if (variableDeclarationFragment.getParent() instanceof VariableDeclarationStatement) {
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
          type=variableDeclarationStatement.getType();
        }
 else         if (variableDeclarationFragment.getParent() instanceof VariableDeclarationExpression) {
          VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)variableDeclarationFragment.getParent();
          type=variableDeclarationExpression.getType();
        }
 else         if (variableDeclarationFragment.getParent() instanceof FieldDeclaration) {
          FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarationFragment.getParent();
          type=fieldDeclaration.getType();
        }
        stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
        stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
        abstractMethodParametersRewrite.insertLast(parameter,null);
      }
    }
  }
  if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedFieldBindings().size() > 0 || typeCheckElimination.getSuperAssignedFieldBindings().size() > 0) {
    SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
    SimpleName parameterType=stateStrategyAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,stateStrategyAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(stateStrategyAST.newSimpleName(typeBinding.getName()),null);
  }
  stateStrategyBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  if (!stateStrategyAlreadyExists)   stateStrategyTypesRewrite.insertLast(stateStrategyTypeDeclaration,null);
  if (stateStrategyDocument != null) {
    try {
      for (      ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
        addImportDeclaration(typeBinding,stateStrategyCompilationUnit,stateStrategyRewriter);
      }
      TextEdit stateStrategyEdit=stateStrategyRewriter.rewriteAST(stateStrategyDocument,null);
      stateStrategyEdit.apply(stateStrategyDocument);
      CreateCompilationUnitChange createCompilationUnitChange=new CreateCompilationUnitChange(stateStrategyICompilationUnit,stateStrategyDocument.get(),stateStrategyFile.getCharset());
      createCompilationUnitChanges.put(stateStrategyICompilationUnit,createCompilationUnitChange);
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
  }
 else {
    try {
      MultiTextEdit stateStrategyMultiTextEdit=new MultiTextEdit();
      CompilationUnitChange stateStrategyCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",stateStrategyICompilationUnit);
      stateStrategyCompilationUnitChange.setEdit(stateStrategyMultiTextEdit);
      compilationUnitChanges.put(stateStrategyICompilationUnit,stateStrategyCompilationUnitChange);
      ImportRewrite stateStrategyImportRewrite=ImportRewrite.create(stateStrategyCompilationUnit,true);
      for (      ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
        if (!typeBinding.isNested())         stateStrategyImportRewrite.addImport(typeBinding);
      }
      TextEdit stateStrategyImportEdit=stateStrategyImportRewrite.rewriteImports(null);
      if (stateStrategyImportRewrite.getCreatedImports().length > 0) {
        stateStrategyMultiTextEdit.addChild(stateStrategyImportEdit);
        stateStrategyCompilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{stateStrategyImportEdit}));
      }
      TextEdit stateStrategyEdit=stateStrategyRewriter.rewriteAST();
      stateStrategyMultiTextEdit.addChild(stateStrategyEdit);
      stateStrategyCompilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{stateStrategyEdit}));
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
    }
catch (    CoreException e) {
      e.printStackTrace();
    }
  }
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=new ArrayList<String>(staticFieldMap.values());
  subclassNames.addAll(additionalStaticFieldMap.values());
  if (tree != null) {
    DefaultMutableTreeNode rootNode=tree.getRootNode();
    DefaultMutableTreeNode leaf=rootNode.getFirstLeaf();
    while (leaf != null) {
      String qualifiedSubclassName=(String)leaf.getUserObject();
      String subclassName=null;
      if (qualifiedSubclassName.contains(""String_Node_Str""))       subclassName=qualifiedSubclassName.substring(qualifiedSubclassName.lastIndexOf(""String_Node_Str"") + 1,qualifiedSubclassName.length());
 else       subclassName=qualifiedSubclassName;
      if (!subclassNames.contains(subclassName))       subclassNames.add(subclassName);
      leaf=leaf.getNextLeaf();
    }
  }
  List<SimpleName> staticFields=new ArrayList<SimpleName>(staticFieldMap.keySet());
  for (  SimpleName simpleName : additionalStaticFieldMap.keySet())   staticFields.add(simpleName);
  for (  Expression expression : typeCheckElimination.getTypeCheckExpressions()) {
    List<SimpleName> leafStaticFields=typeCheckElimination.getStaticFields(expression);
    if (leafStaticFields.size() > 1) {
      List<String> leafSubclassNames=new ArrayList<String>();
      for (      SimpleName leafStaticField : leafStaticFields) {
        leafSubclassNames.add(getTypeNameForNamedConstant(leafStaticField));
      }
      ArrayList<Statement> typeCheckStatements2=typeCheckElimination.getTypeCheckStatements(expression);
      createIntermediateClassAndItsSubclasses(leafStaticFields,leafSubclassNames,typeCheckStatements2,tree,rootContainer,contextContainer);
      staticFields.removeAll(leafStaticFields);
      subclassNames.removeAll(leafSubclassNames);
      typeCheckStatements.remove(typeCheckStatements2);
    }
  }
  for (int i=0; i < subclassNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      Expression expression=typeCheckElimination.getExpressionCorrespondingToTypeCheckStatementList(statements);
      remainingIfStatementExpression=typeCheckElimination.getRemainingIfStatementExpression(expression);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=null;
    if (tree != null) {
      DefaultMutableTreeNode rootNode=tree.getRootNode();
      DefaultMutableTreeNode leaf=rootNode.getFirstLeaf();
      while (leaf != null) {
        String qualifiedSubclassName=(String)leaf.getUserObject();
        if ((qualifiedSubclassName.contains(""String_Node_Str"") && qualifiedSubclassName.endsWith(""String_Node_Str"" + subclassNames.get(i))) || qualifiedSubclassName.equals(subclassNames.get(i))) {
          subclassFile=getFile(rootContainer,qualifiedSubclassName);
          break;
        }
        leaf=leaf.getNextLeaf();
      }
    }
 else {
      if (contextContainer instanceof IProject) {
        IProject contextProject=(IProject)contextContainer;
        subclassFile=contextProject.getFile(subclassNames.get(i) + ""String_Node_Str"");
      }
 else       if (contextContainer instanceof IFolder) {
        IFolder contextFolder=(IFolder)contextContainer;
        subclassFile=contextFolder.getFile(subclassNames.get(i) + ""String_Node_Str"");
      }
    }
    boolean subclassAlreadyExists=false;
    ICompilationUnit subclassICompilationUnit=JavaCore.createCompilationUnitFrom(subclassFile);
    javaElementsToOpenInEditor.add(subclassICompilationUnit);
    ASTParser subclassParser=ASTParser.newParser(AST.JLS4);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    Document subclassDocument=null;
    if (subclassFile.exists()) {
      subclassAlreadyExists=true;
      subclassParser.setSource(subclassICompilationUnit);
      subclassParser.setResolveBindings(true);
    }
 else {
      subclassDocument=new Document();
      subclassParser.setSource(subclassDocument.get().toCharArray());
    }
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    ListRewrite subclassTypesRewrite=subclassRewriter.getListRewrite(subclassCompilationUnit,CompilationUnit.TYPES_PROPERTY);
    TypeDeclaration subclassTypeDeclaration=null;
    if (subclassAlreadyExists) {
      List<AbstractTypeDeclaration> abstractTypeDeclarations=subclassCompilationUnit.types();
      for (      AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
        if (abstractTypeDeclaration instanceof TypeDeclaration) {
          TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
          if (typeDeclaration.getName().getIdentifier().equals(subclassNames.get(i))) {
            subclassTypeDeclaration=typeDeclaration;
            requiredImportDeclarationsForContext.add(subclassTypeDeclaration.resolveBinding());
            break;
          }
        }
      }
    }
 else {
      if (sourceCompilationUnit.getPackage() != null) {
        subclassRewriter.set(subclassCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,sourceCompilationUnit.getPackage(),null);
      }
      Javadoc subclassJavaDoc=subclassAST.newJavadoc();
      TagElement subclassTagElement=subclassAST.newTagElement();
      subclassRewriter.set(subclassTagElement,TagElement.TAG_NAME_PROPERTY,TagElement.TAG_SEE,null);
      MemberRef subclassMemberRef=subclassAST.newMemberRef();
      IBinding staticFieldNameBinding=staticFields.get(i).resolveBinding();
      ITypeBinding staticFieldNameDeclaringClass=null;
      if (staticFieldNameBinding != null && staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
        IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
        staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass();
      }
      subclassRewriter.set(subclassMemberRef,MemberRef.NAME_PROPERTY,subclassAST.newSimpleName(staticFieldNameBinding.getName()),null);
      subclassRewriter.set(subclassMemberRef,MemberRef.QUALIFIER_PROPERTY,subclassAST.newName(staticFieldNameDeclaringClass.getQualifiedName()),null);
      ListRewrite subclassTagElementFragmentsRewrite=subclassRewriter.getListRewrite(subclassTagElement,TagElement.FRAGMENTS_PROPERTY);
      subclassTagElementFragmentsRewrite.insertLast(subclassMemberRef,null);
      ListRewrite subclassJavaDocTagsRewrite=subclassRewriter.getListRewrite(subclassJavaDoc,Javadoc.TAGS_PROPERTY);
      subclassJavaDocTagsRewrite.insertLast(subclassTagElement,null);
      subclassTypeDeclaration=subclassAST.newTypeDeclaration();
      SimpleName subclassName=subclassAST.newSimpleName(subclassNames.get(i));
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.NAME_PROPERTY,subclassName,null);
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,subclassAST.newSimpleType(subclassAST.newSimpleName(abstractClassName)),null);
      ListRewrite subclassModifiersRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
      subclassModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.JAVADOC_PROPERTY,subclassJavaDoc,null);
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    if (typeCheckElimination.getTypeField() != null) {
      if (getterMethod != null) {
        MethodDeclaration concreteGetterMethodDeclaration=subclassAST.newMethodDeclaration();
        subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,getterMethod.getName(),null);
        subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,getterMethod.getReturnType2(),null);
        ListRewrite concreteGetterMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
        concreteGetterMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
        Block concreteGetterMethodBody=subclassAST.newBlock();
        ListRewrite concreteGetterMethodBodyRewrite=subclassRewriter.getListRewrite(concreteGetterMethodBody,Block.STATEMENTS_PROPERTY);
        ReturnStatement returnStatement=subclassAST.newReturnStatement();
        IBinding staticFieldNameBinding=staticFields.get(i).resolveBinding();
        String staticFieldNameDeclaringClass=null;
        if (staticFieldNameBinding != null && staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
          IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
          staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass().getName();
        }
        FieldAccess fieldAccess=subclassAST.newFieldAccess();
        subclassRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,staticFields.get(i),null);
        subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,subclassAST.newSimpleName(staticFieldNameDeclaringClass),null);
        subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fieldAccess,null);
        concreteGetterMethodBodyRewrite.insertLast(returnStatement,null);
        subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteGetterMethodBody,null);
        subclassBodyRewrite.insertLast(concreteGetterMethodDeclaration,null);
      }
 else {
        MethodDeclaration concreteGetterMethodDeclaration=subclassAST.newMethodDeclaration();
        subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(""String_Node_Str"" + abstractClassName),null);
        VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
        Type returnType=((FieldDeclaration)typeField.getParent()).getType();
        subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
        ListRewrite concreteGetterMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
        concreteGetterMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
        Block concreteGetterMethodBody=subclassAST.newBlock();
        ListRewrite concreteGetterMethodBodyRewrite=subclassRewriter.getListRewrite(concreteGetterMethodBody,Block.STATEMENTS_PROPERTY);
        ReturnStatement returnStatement=subclassAST.newReturnStatement();
        IBinding staticFieldNameBinding=staticFields.get(i).resolveBinding();
        String staticFieldNameDeclaringClass=null;
        if (staticFieldNameBinding != null && staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
          IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
          staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass().getName();
        }
        FieldAccess fieldAccess=subclassAST.newFieldAccess();
        subclassRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,staticFields.get(i),null);
        subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,subclassAST.newSimpleName(staticFieldNameDeclaringClass),null);
        subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fieldAccess,null);
        concreteGetterMethodBodyRewrite.insertLast(returnStatement,null);
        subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteGetterMethodBody,null);
        subclassBodyRewrite.insertLast(concreteGetterMethodDeclaration,null);
      }
    }
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(typeCheckElimination.getAbstractMethodName()),null);
    if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
      subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,subclassAST.newPrimitiveType(PrimitiveType.VOID),null);
    }
 else {
      if (returnedVariable != null) {
        Type returnType=null;
        if (returnedVariable instanceof SingleVariableDeclaration) {
          SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
          returnType=singleVariableDeclaration.getType();
        }
 else         if (returnedVariable instanceof VariableDeclarationFragment) {
          VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
          if (variableDeclarationFragment.getParent() instanceof VariableDeclarationStatement) {
            VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
            returnType=variableDeclarationStatement.getType();
          }
 else           if (variableDeclarationFragment.getParent() instanceof VariableDeclarationExpression) {
            VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)variableDeclarationFragment.getParent();
            returnType=variableDeclarationExpression.getType();
          }
 else           if (variableDeclarationFragment.getParent() instanceof FieldDeclaration) {
            FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarationFragment.getParent();
            returnType=fieldDeclaration.getType();
          }
        }
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      }
 else {
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      }
    }
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    if (returnedVariable != null) {
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        concreteMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        Type type=null;
        if (variableDeclarationFragment.getParent() instanceof VariableDeclarationStatement) {
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
          type=variableDeclarationStatement.getType();
        }
 else         if (variableDeclarationFragment.getParent() instanceof VariableDeclarationExpression) {
          VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)variableDeclarationFragment.getParent();
          type=variableDeclarationExpression.getType();
        }
 else         if (variableDeclarationFragment.getParent() instanceof FieldDeclaration) {
          FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarationFragment.getParent();
          type=fieldDeclaration.getType();
        }
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable)) {
        concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
      }
    }
    for (    VariableDeclaration fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        if (fragment instanceof SingleVariableDeclaration) {
          SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)fragment;
          concreteMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
        }
 else         if (fragment instanceof VariableDeclarationFragment) {
          SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
          VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)fragment;
          Type type=null;
          if (variableDeclarationFragment.getParent() instanceof VariableDeclarationStatement) {
            VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
            type=variableDeclarationStatement.getType();
          }
 else           if (variableDeclarationFragment.getParent() instanceof VariableDeclarationExpression) {
            VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)variableDeclarationFragment.getParent();
            type=variableDeclarationExpression.getType();
          }
 else           if (variableDeclarationFragment.getParent() instanceof FieldDeclaration) {
            FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarationFragment.getParent();
            type=fieldDeclaration.getType();
          }
          subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
          subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
          concreteMethodParametersRewrite.insertLast(parameter,null);
        }
      }
    }
    Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
    Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
    Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
    Set<IMethodBinding> superAccessedMethods=typeCheckElimination.getSuperAccessedMethods();
    Set<IVariableBinding> superAccessedFields=typeCheckElimination.getSuperAccessedFieldBindings();
    Set<IVariableBinding> superAssignedFields=typeCheckElimination.getSuperAssignedFieldBindings();
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0 || superAccessedFields.size() > 0 || superAssignedFields.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(enclosingIfStatementExpression);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifySourceVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields,superAccessedFields,superAssignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifySourceMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods,superAccessedMethods);
      replaceThisExpressionWithContextParameterInMethodInvocationArguments(newMethodInvocations,subclassAST,subclassRewriter);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(statement);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifySourceVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields,superAccessedFields,superAssignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifySourceMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods,superAccessedMethods);
      replaceThisExpressionWithContextParameterInMethodInvocationArguments(newMethodInvocations,subclassAST,subclassRewriter);
      replaceThisExpressionWithContextParameterInClassInstanceCreationArguments(newStatement,subclassAST,subclassRewriter);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(newStatement,null);
 else       concreteMethodBodyRewrite.insertLast(newStatement,null);
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    if (!subclassAlreadyExists)     subclassTypesRewrite.insertLast(subclassTypeDeclaration,null);
    if (subclassDocument != null) {
      try {
        for (        ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
          addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
        }
        Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=getRequiredImportDeclarationsBasedOnBranch(statements);
        for (        ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
          if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))           addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
        }
        TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
        subclassEdit.apply(subclassDocument);
        CreateCompilationUnitChange createCompilationUnitChange=new CreateCompilationUnitChange(subclassICompilationUnit,subclassDocument.get(),subclassFile.getCharset());
        createCompilationUnitChanges.put(subclassICompilationUnit,createCompilationUnitChange);
      }
 catch (      CoreException e) {
        e.printStackTrace();
      }
catch (      MalformedTreeException e) {
        e.printStackTrace();
      }
catch (      BadLocationException e) {
        e.printStackTrace();
      }
    }
 else {
      try {
        MultiTextEdit subclassMultiTextEdit=new MultiTextEdit();
        CompilationUnitChange subclassCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",subclassICompilationUnit);
        subclassCompilationUnitChange.setEdit(subclassMultiTextEdit);
        compilationUnitChanges.put(subclassICompilationUnit,subclassCompilationUnitChange);
        ImportRewrite subclassImportRewrite=ImportRewrite.create(subclassCompilationUnit,true);
        for (        ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
          if (!typeBinding.isNested())           subclassImportRewrite.addImport(typeBinding);
        }
        Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=getRequiredImportDeclarationsBasedOnBranch(statements);
        for (        ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
          if (!typeBinding.isNested())           subclassImportRewrite.addImport(typeBinding);
        }
        TextEdit subclassImportEdit=subclassImportRewrite.rewriteImports(null);
        if (subclassImportRewrite.getCreatedImports().length > 0) {
          subclassMultiTextEdit.addChild(subclassImportEdit);
          subclassCompilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{subclassImportEdit}));
        }
        TextEdit subclassEdit=subclassRewriter.rewriteAST();
        subclassMultiTextEdit.addChild(subclassEdit);
        subclassCompilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{subclassEdit}));
      }
 catch (      JavaModelException e) {
        e.printStackTrace();
      }
catch (      CoreException e) {
        e.printStackTrace();
      }
    }
  }
}","private void createStateStrategyHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  PackageDeclaration contextPackageDeclaration=sourceCompilationUnit.getPackage();
  IContainer rootContainer=contextContainer;
  if (contextPackageDeclaration != null) {
    String packageName=contextPackageDeclaration.getName().getFullyQualifiedName();
    String[] subPackages=packageName.split(""String_Node_Str"");
    for (int i=0; i < subPackages.length; i++)     rootContainer=(IContainer)rootContainer.getParent();
  }
  InheritanceTree tree=typeCheckElimination.getInheritanceTreeMatchingWithStaticTypes();
  IFile stateStrategyFile=null;
  if (tree != null) {
    DefaultMutableTreeNode rootNode=tree.getRootNode();
    stateStrategyFile=getFile(rootContainer,(String)rootNode.getUserObject());
  }
 else {
    if (contextContainer instanceof IProject) {
      IProject contextProject=(IProject)contextContainer;
      stateStrategyFile=contextProject.getFile(abstractClassName + ""String_Node_Str"");
    }
 else     if (contextContainer instanceof IFolder) {
      IFolder contextFolder=(IFolder)contextContainer;
      stateStrategyFile=contextFolder.getFile(abstractClassName + ""String_Node_Str"");
    }
  }
  boolean stateStrategyAlreadyExists=false;
  ICompilationUnit stateStrategyICompilationUnit=JavaCore.createCompilationUnitFrom(stateStrategyFile);
  javaElementsToOpenInEditor.add(stateStrategyICompilationUnit);
  ASTParser stateStrategyParser=ASTParser.newParser(AST.JLS4);
  stateStrategyParser.setKind(ASTParser.K_COMPILATION_UNIT);
  Document stateStrategyDocument=null;
  if (stateStrategyFile.exists()) {
    stateStrategyAlreadyExists=true;
    stateStrategyParser.setSource(stateStrategyICompilationUnit);
    stateStrategyParser.setResolveBindings(true);
  }
 else {
    stateStrategyDocument=new Document();
    stateStrategyParser.setSource(stateStrategyDocument.get().toCharArray());
  }
  CompilationUnit stateStrategyCompilationUnit=(CompilationUnit)stateStrategyParser.createAST(null);
  AST stateStrategyAST=stateStrategyCompilationUnit.getAST();
  ASTRewrite stateStrategyRewriter=ASTRewrite.create(stateStrategyAST);
  ListRewrite stateStrategyTypesRewrite=stateStrategyRewriter.getListRewrite(stateStrategyCompilationUnit,CompilationUnit.TYPES_PROPERTY);
  TypeDeclaration stateStrategyTypeDeclaration=null;
  if (stateStrategyAlreadyExists) {
    List<AbstractTypeDeclaration> abstractTypeDeclarations=stateStrategyCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.getName().getIdentifier().equals(abstractClassName)) {
          stateStrategyTypeDeclaration=typeDeclaration;
          requiredImportDeclarationsForContext.add(stateStrategyTypeDeclaration.resolveBinding());
          int stateStrategyModifiers=stateStrategyTypeDeclaration.getModifiers();
          if ((stateStrategyModifiers & Modifier.ABSTRACT) == 0) {
            ListRewrite stateStrategyModifiersRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
            stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
          }
          break;
        }
      }
    }
  }
 else {
    if (sourceCompilationUnit.getPackage() != null) {
      stateStrategyRewriter.set(stateStrategyCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,sourceCompilationUnit.getPackage(),null);
    }
    stateStrategyTypeDeclaration=stateStrategyAST.newTypeDeclaration();
    SimpleName stateStrategyName=stateStrategyAST.newSimpleName(abstractClassName);
    stateStrategyRewriter.set(stateStrategyTypeDeclaration,TypeDeclaration.NAME_PROPERTY,stateStrategyName,null);
    ListRewrite stateStrategyModifiersRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite stateStrategyBodyRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  if (typeCheckElimination.getTypeField() != null) {
    if (getterMethod != null) {
      MethodDeclaration abstractGetterMethodDeclaration=stateStrategyAST.newMethodDeclaration();
      stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,getterMethod.getName(),null);
      stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,getterMethod.getReturnType2(),null);
      ListRewrite abstractGetterMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
      abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
      stateStrategyBodyRewrite.insertLast(abstractGetterMethodDeclaration,null);
    }
 else {
      MethodDeclaration abstractGetterMethodDeclaration=stateStrategyAST.newMethodDeclaration();
      stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(""String_Node_Str"" + abstractClassName),null);
      VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
      Type returnType=((FieldDeclaration)typeField.getParent()).getType();
      stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      ListRewrite abstractGetterMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
      abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
      stateStrategyBodyRewrite.insertLast(abstractGetterMethodDeclaration,null);
    }
  }
  MethodDeclaration abstractMethodDeclaration=stateStrategyAST.newMethodDeclaration();
  stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(typeCheckElimination.getAbstractMethodName()),null);
  if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
    stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,stateStrategyAST.newPrimitiveType(PrimitiveType.VOID),null);
  }
 else {
    if (returnedVariable != null) {
      Type returnType=null;
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        returnType=singleVariableDeclaration.getType();
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        if (variableDeclarationFragment.getParent() instanceof VariableDeclarationStatement) {
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
          returnType=variableDeclarationStatement.getType();
        }
 else         if (variableDeclarationFragment.getParent() instanceof VariableDeclarationExpression) {
          VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)variableDeclarationFragment.getParent();
          returnType=variableDeclarationExpression.getType();
        }
 else         if (variableDeclarationFragment.getParent() instanceof FieldDeclaration) {
          FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarationFragment.getParent();
          returnType=fieldDeclaration.getType();
        }
      }
      stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    }
 else {
      stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    }
  }
  ListRewrite abstractMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  if (returnedVariable != null) {
    if (returnedVariable instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
      abstractMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
    }
 else     if (returnedVariable instanceof VariableDeclarationFragment) {
      SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
      VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
      Type type=null;
      if (variableDeclarationFragment.getParent() instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
        type=variableDeclarationStatement.getType();
      }
 else       if (variableDeclarationFragment.getParent() instanceof VariableDeclarationExpression) {
        VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)variableDeclarationFragment.getParent();
        type=variableDeclarationExpression.getType();
      }
 else       if (variableDeclarationFragment.getParent() instanceof FieldDeclaration) {
        FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarationFragment.getParent();
        type=fieldDeclaration.getType();
      }
      stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
      stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    if (!abstractMethodParameter.equals(returnedVariable)) {
      abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
  }
  for (  VariableDeclaration fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      if (fragment instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)fragment;
        abstractMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
      }
 else       if (fragment instanceof VariableDeclarationFragment) {
        SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)fragment;
        Type type=null;
        if (variableDeclarationFragment.getParent() instanceof VariableDeclarationStatement) {
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
          type=variableDeclarationStatement.getType();
        }
 else         if (variableDeclarationFragment.getParent() instanceof VariableDeclarationExpression) {
          VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)variableDeclarationFragment.getParent();
          type=variableDeclarationExpression.getType();
        }
 else         if (variableDeclarationFragment.getParent() instanceof FieldDeclaration) {
          FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarationFragment.getParent();
          type=fieldDeclaration.getType();
        }
        stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
        stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
        abstractMethodParametersRewrite.insertLast(parameter,null);
      }
    }
  }
  if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedFieldBindings().size() > 0 || typeCheckElimination.getSuperAssignedFieldBindings().size() > 0) {
    SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
    SimpleName parameterType=stateStrategyAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,stateStrategyAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(stateStrategyAST.newSimpleName(typeBinding.getName()),null);
  }
  stateStrategyBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  if (!stateStrategyAlreadyExists)   stateStrategyTypesRewrite.insertLast(stateStrategyTypeDeclaration,null);
  if (stateStrategyDocument != null) {
    try {
      for (      ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
        addImportDeclaration(typeBinding,stateStrategyCompilationUnit,stateStrategyRewriter);
      }
      TextEdit stateStrategyEdit=stateStrategyRewriter.rewriteAST(stateStrategyDocument,null);
      stateStrategyEdit.apply(stateStrategyDocument);
      CreateCompilationUnitChange createCompilationUnitChange=new CreateCompilationUnitChange(stateStrategyICompilationUnit,stateStrategyDocument.get(),stateStrategyFile.getCharset());
      createCompilationUnitChanges.put(stateStrategyICompilationUnit,createCompilationUnitChange);
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
  }
 else {
    try {
      MultiTextEdit stateStrategyMultiTextEdit=new MultiTextEdit();
      CompilationUnitChange stateStrategyCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",stateStrategyICompilationUnit);
      stateStrategyCompilationUnitChange.setEdit(stateStrategyMultiTextEdit);
      compilationUnitChanges.put(stateStrategyICompilationUnit,stateStrategyCompilationUnitChange);
      ImportRewrite stateStrategyImportRewrite=ImportRewrite.create(stateStrategyCompilationUnit,true);
      for (      ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
        if (!typeBinding.isNested())         stateStrategyImportRewrite.addImport(typeBinding);
      }
      TextEdit stateStrategyImportEdit=stateStrategyImportRewrite.rewriteImports(null);
      if (stateStrategyImportRewrite.getCreatedImports().length > 0) {
        stateStrategyMultiTextEdit.addChild(stateStrategyImportEdit);
        stateStrategyCompilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{stateStrategyImportEdit}));
      }
      TextEdit stateStrategyEdit=stateStrategyRewriter.rewriteAST();
      stateStrategyMultiTextEdit.addChild(stateStrategyEdit);
      stateStrategyCompilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{stateStrategyEdit}));
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
    }
catch (    CoreException e) {
      e.printStackTrace();
    }
  }
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=new ArrayList<String>(staticFieldMap.values());
  subclassNames.addAll(additionalStaticFieldMap.values());
  if (tree != null) {
    DefaultMutableTreeNode rootNode=tree.getRootNode();
    DefaultMutableTreeNode leaf=rootNode.getFirstLeaf();
    while (leaf != null) {
      String qualifiedSubclassName=(String)leaf.getUserObject();
      String subclassName=null;
      if (qualifiedSubclassName.contains(""String_Node_Str""))       subclassName=qualifiedSubclassName.substring(qualifiedSubclassName.lastIndexOf(""String_Node_Str"") + 1,qualifiedSubclassName.length());
 else       subclassName=qualifiedSubclassName;
      if (!subclassNames.contains(subclassName))       subclassNames.add(subclassName);
      leaf=leaf.getNextLeaf();
    }
  }
  List<SimpleName> staticFields=new ArrayList<SimpleName>(staticFieldMap.keySet());
  for (  SimpleName simpleName : additionalStaticFieldMap.keySet())   staticFields.add(simpleName);
  for (  Expression expression : typeCheckElimination.getTypeCheckExpressions()) {
    List<SimpleName> leafStaticFields=typeCheckElimination.getStaticFields(expression);
    if (leafStaticFields.size() > 1) {
      List<String> leafSubclassNames=new ArrayList<String>();
      for (      SimpleName leafStaticField : leafStaticFields) {
        leafSubclassNames.add(getTypeNameForNamedConstant(leafStaticField));
      }
      ArrayList<Statement> typeCheckStatements2=typeCheckElimination.getTypeCheckStatements(expression);
      createIntermediateClassAndItsSubclasses(leafStaticFields,leafSubclassNames,typeCheckStatements2,tree,rootContainer,contextContainer);
      staticFields.removeAll(leafStaticFields);
      subclassNames.removeAll(leafSubclassNames);
      typeCheckStatements.remove(typeCheckStatements2);
    }
  }
  for (int i=0; i < subclassNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      Expression expression=typeCheckElimination.getExpressionCorrespondingToTypeCheckStatementList(statements);
      remainingIfStatementExpression=typeCheckElimination.getRemainingIfStatementExpression(expression);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=null;
    if (tree != null) {
      DefaultMutableTreeNode rootNode=tree.getRootNode();
      DefaultMutableTreeNode leaf=rootNode.getFirstLeaf();
      while (leaf != null) {
        String qualifiedSubclassName=(String)leaf.getUserObject();
        if ((qualifiedSubclassName.contains(""String_Node_Str"") && qualifiedSubclassName.endsWith(""String_Node_Str"" + subclassNames.get(i))) || qualifiedSubclassName.equals(subclassNames.get(i))) {
          subclassFile=getFile(rootContainer,qualifiedSubclassName);
          break;
        }
        leaf=leaf.getNextLeaf();
      }
    }
 else {
      if (contextContainer instanceof IProject) {
        IProject contextProject=(IProject)contextContainer;
        subclassFile=contextProject.getFile(subclassNames.get(i) + ""String_Node_Str"");
      }
 else       if (contextContainer instanceof IFolder) {
        IFolder contextFolder=(IFolder)contextContainer;
        subclassFile=contextFolder.getFile(subclassNames.get(i) + ""String_Node_Str"");
      }
    }
    boolean subclassAlreadyExists=false;
    ICompilationUnit subclassICompilationUnit=JavaCore.createCompilationUnitFrom(subclassFile);
    javaElementsToOpenInEditor.add(subclassICompilationUnit);
    ASTParser subclassParser=ASTParser.newParser(AST.JLS4);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    Document subclassDocument=null;
    if (subclassFile.exists()) {
      subclassAlreadyExists=true;
      subclassParser.setSource(subclassICompilationUnit);
      subclassParser.setResolveBindings(true);
    }
 else {
      subclassDocument=new Document();
      subclassParser.setSource(subclassDocument.get().toCharArray());
    }
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    ListRewrite subclassTypesRewrite=subclassRewriter.getListRewrite(subclassCompilationUnit,CompilationUnit.TYPES_PROPERTY);
    TypeDeclaration subclassTypeDeclaration=null;
    if (subclassAlreadyExists) {
      List<AbstractTypeDeclaration> abstractTypeDeclarations=subclassCompilationUnit.types();
      for (      AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
        if (abstractTypeDeclaration instanceof TypeDeclaration) {
          TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
          if (typeDeclaration.getName().getIdentifier().equals(subclassNames.get(i))) {
            subclassTypeDeclaration=typeDeclaration;
            requiredImportDeclarationsForContext.add(subclassTypeDeclaration.resolveBinding());
            break;
          }
        }
      }
    }
 else {
      if (sourceCompilationUnit.getPackage() != null) {
        subclassRewriter.set(subclassCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,sourceCompilationUnit.getPackage(),null);
      }
      Javadoc subclassJavaDoc=subclassAST.newJavadoc();
      TagElement subclassTagElement=subclassAST.newTagElement();
      subclassRewriter.set(subclassTagElement,TagElement.TAG_NAME_PROPERTY,TagElement.TAG_SEE,null);
      MemberRef subclassMemberRef=subclassAST.newMemberRef();
      IBinding staticFieldNameBinding=staticFields.get(i).resolveBinding();
      ITypeBinding staticFieldNameDeclaringClass=null;
      if (staticFieldNameBinding != null && staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
        IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
        staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass();
      }
      subclassRewriter.set(subclassMemberRef,MemberRef.NAME_PROPERTY,subclassAST.newSimpleName(staticFieldNameBinding.getName()),null);
      subclassRewriter.set(subclassMemberRef,MemberRef.QUALIFIER_PROPERTY,subclassAST.newName(staticFieldNameDeclaringClass.getQualifiedName()),null);
      ListRewrite subclassTagElementFragmentsRewrite=subclassRewriter.getListRewrite(subclassTagElement,TagElement.FRAGMENTS_PROPERTY);
      subclassTagElementFragmentsRewrite.insertLast(subclassMemberRef,null);
      ListRewrite subclassJavaDocTagsRewrite=subclassRewriter.getListRewrite(subclassJavaDoc,Javadoc.TAGS_PROPERTY);
      subclassJavaDocTagsRewrite.insertLast(subclassTagElement,null);
      subclassTypeDeclaration=subclassAST.newTypeDeclaration();
      SimpleName subclassName=subclassAST.newSimpleName(subclassNames.get(i));
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.NAME_PROPERTY,subclassName,null);
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,subclassAST.newSimpleType(subclassAST.newSimpleName(abstractClassName)),null);
      ListRewrite subclassModifiersRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
      subclassModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.JAVADOC_PROPERTY,subclassJavaDoc,null);
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    if (typeCheckElimination.getTypeField() != null) {
      if (getterMethod != null) {
        MethodDeclaration concreteGetterMethodDeclaration=subclassAST.newMethodDeclaration();
        subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,getterMethod.getName(),null);
        subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,getterMethod.getReturnType2(),null);
        ListRewrite concreteGetterMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
        concreteGetterMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
        Block concreteGetterMethodBody=subclassAST.newBlock();
        ListRewrite concreteGetterMethodBodyRewrite=subclassRewriter.getListRewrite(concreteGetterMethodBody,Block.STATEMENTS_PROPERTY);
        ReturnStatement returnStatement=subclassAST.newReturnStatement();
        IBinding staticFieldNameBinding=staticFields.get(i).resolveBinding();
        String staticFieldNameDeclaringClass=null;
        if (staticFieldNameBinding != null && staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
          IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
          ITypeBinding staticFieldDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass();
          String staticFieldDeclaringClassQualifiedName=staticFieldDeclaringClass.getQualifiedName();
          IPackageBinding packageBinding=staticFieldDeclaringClass.getPackage();
          if (packageBinding != null) {
            String packageBindingQualifiedName=packageBinding.getName();
            staticFieldNameDeclaringClass=staticFieldDeclaringClassQualifiedName.substring(packageBindingQualifiedName.length() + 1,staticFieldDeclaringClassQualifiedName.length());
          }
 else {
            staticFieldNameDeclaringClass=staticFieldDeclaringClassQualifiedName;
          }
        }
        FieldAccess fieldAccess=subclassAST.newFieldAccess();
        subclassRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,staticFields.get(i),null);
        if (!staticFieldNameDeclaringClass.contains(""String_Node_Str"")) {
          subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,subclassAST.newSimpleName(staticFieldNameDeclaringClass),null);
        }
 else {
          QualifiedName qualifiedName=subclassAST.newQualifiedName(subclassAST.newName(staticFieldNameDeclaringClass.substring(0,staticFieldNameDeclaringClass.lastIndexOf(""String_Node_Str""))),subclassAST.newSimpleName(staticFieldNameDeclaringClass.substring(staticFieldNameDeclaringClass.lastIndexOf(""String_Node_Str"") + 1,staticFieldNameDeclaringClass.length())));
          subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifiedName,null);
        }
        subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fieldAccess,null);
        concreteGetterMethodBodyRewrite.insertLast(returnStatement,null);
        subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteGetterMethodBody,null);
        subclassBodyRewrite.insertLast(concreteGetterMethodDeclaration,null);
      }
 else {
        MethodDeclaration concreteGetterMethodDeclaration=subclassAST.newMethodDeclaration();
        subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(""String_Node_Str"" + abstractClassName),null);
        VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
        Type returnType=((FieldDeclaration)typeField.getParent()).getType();
        subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
        ListRewrite concreteGetterMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
        concreteGetterMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
        Block concreteGetterMethodBody=subclassAST.newBlock();
        ListRewrite concreteGetterMethodBodyRewrite=subclassRewriter.getListRewrite(concreteGetterMethodBody,Block.STATEMENTS_PROPERTY);
        ReturnStatement returnStatement=subclassAST.newReturnStatement();
        IBinding staticFieldNameBinding=staticFields.get(i).resolveBinding();
        String staticFieldNameDeclaringClass=null;
        if (staticFieldNameBinding != null && staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
          IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
          staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass().getName();
        }
        FieldAccess fieldAccess=subclassAST.newFieldAccess();
        subclassRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,staticFields.get(i),null);
        subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,subclassAST.newSimpleName(staticFieldNameDeclaringClass),null);
        subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fieldAccess,null);
        concreteGetterMethodBodyRewrite.insertLast(returnStatement,null);
        subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteGetterMethodBody,null);
        subclassBodyRewrite.insertLast(concreteGetterMethodDeclaration,null);
      }
    }
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(typeCheckElimination.getAbstractMethodName()),null);
    if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
      subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,subclassAST.newPrimitiveType(PrimitiveType.VOID),null);
    }
 else {
      if (returnedVariable != null) {
        Type returnType=null;
        if (returnedVariable instanceof SingleVariableDeclaration) {
          SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
          returnType=singleVariableDeclaration.getType();
        }
 else         if (returnedVariable instanceof VariableDeclarationFragment) {
          VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
          if (variableDeclarationFragment.getParent() instanceof VariableDeclarationStatement) {
            VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
            returnType=variableDeclarationStatement.getType();
          }
 else           if (variableDeclarationFragment.getParent() instanceof VariableDeclarationExpression) {
            VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)variableDeclarationFragment.getParent();
            returnType=variableDeclarationExpression.getType();
          }
 else           if (variableDeclarationFragment.getParent() instanceof FieldDeclaration) {
            FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarationFragment.getParent();
            returnType=fieldDeclaration.getType();
          }
        }
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      }
 else {
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      }
    }
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    if (returnedVariable != null) {
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        concreteMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        Type type=null;
        if (variableDeclarationFragment.getParent() instanceof VariableDeclarationStatement) {
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
          type=variableDeclarationStatement.getType();
        }
 else         if (variableDeclarationFragment.getParent() instanceof VariableDeclarationExpression) {
          VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)variableDeclarationFragment.getParent();
          type=variableDeclarationExpression.getType();
        }
 else         if (variableDeclarationFragment.getParent() instanceof FieldDeclaration) {
          FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarationFragment.getParent();
          type=fieldDeclaration.getType();
        }
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable)) {
        concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
      }
    }
    for (    VariableDeclaration fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        if (fragment instanceof SingleVariableDeclaration) {
          SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)fragment;
          concreteMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
        }
 else         if (fragment instanceof VariableDeclarationFragment) {
          SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
          VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)fragment;
          Type type=null;
          if (variableDeclarationFragment.getParent() instanceof VariableDeclarationStatement) {
            VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
            type=variableDeclarationStatement.getType();
          }
 else           if (variableDeclarationFragment.getParent() instanceof VariableDeclarationExpression) {
            VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)variableDeclarationFragment.getParent();
            type=variableDeclarationExpression.getType();
          }
 else           if (variableDeclarationFragment.getParent() instanceof FieldDeclaration) {
            FieldDeclaration fieldDeclaration=(FieldDeclaration)variableDeclarationFragment.getParent();
            type=fieldDeclaration.getType();
          }
          subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,type,null);
          subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
          concreteMethodParametersRewrite.insertLast(parameter,null);
        }
      }
    }
    Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
    Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
    Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
    Set<IMethodBinding> superAccessedMethods=typeCheckElimination.getSuperAccessedMethods();
    Set<IVariableBinding> superAccessedFields=typeCheckElimination.getSuperAccessedFieldBindings();
    Set<IVariableBinding> superAssignedFields=typeCheckElimination.getSuperAssignedFieldBindings();
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0 || superAccessedFields.size() > 0 || superAssignedFields.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(enclosingIfStatementExpression);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifySourceVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields,superAccessedFields,superAssignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifySourceMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods,superAccessedMethods);
      replaceThisExpressionWithContextParameterInMethodInvocationArguments(newMethodInvocations,subclassAST,subclassRewriter);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(statement);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifySourceVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields,superAccessedFields,superAssignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifySourceMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods,superAccessedMethods);
      replaceThisExpressionWithContextParameterInMethodInvocationArguments(newMethodInvocations,subclassAST,subclassRewriter);
      replaceThisExpressionWithContextParameterInClassInstanceCreationArguments(newStatement,subclassAST,subclassRewriter);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(newStatement,null);
 else       concreteMethodBodyRewrite.insertLast(newStatement,null);
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    if (!subclassAlreadyExists)     subclassTypesRewrite.insertLast(subclassTypeDeclaration,null);
    if (subclassDocument != null) {
      try {
        for (        ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
          addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
        }
        Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=getRequiredImportDeclarationsBasedOnBranch(statements);
        for (        ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
          if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))           addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
        }
        TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
        subclassEdit.apply(subclassDocument);
        CreateCompilationUnitChange createCompilationUnitChange=new CreateCompilationUnitChange(subclassICompilationUnit,subclassDocument.get(),subclassFile.getCharset());
        createCompilationUnitChanges.put(subclassICompilationUnit,createCompilationUnitChange);
      }
 catch (      CoreException e) {
        e.printStackTrace();
      }
catch (      MalformedTreeException e) {
        e.printStackTrace();
      }
catch (      BadLocationException e) {
        e.printStackTrace();
      }
    }
 else {
      try {
        MultiTextEdit subclassMultiTextEdit=new MultiTextEdit();
        CompilationUnitChange subclassCompilationUnitChange=new CompilationUnitChange(""String_Node_Str"",subclassICompilationUnit);
        subclassCompilationUnitChange.setEdit(subclassMultiTextEdit);
        compilationUnitChanges.put(subclassICompilationUnit,subclassCompilationUnitChange);
        ImportRewrite subclassImportRewrite=ImportRewrite.create(subclassCompilationUnit,true);
        for (        ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
          if (!typeBinding.isNested())           subclassImportRewrite.addImport(typeBinding);
        }
        Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=getRequiredImportDeclarationsBasedOnBranch(statements);
        for (        ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
          if (!typeBinding.isNested())           subclassImportRewrite.addImport(typeBinding);
        }
        TextEdit subclassImportEdit=subclassImportRewrite.rewriteImports(null);
        if (subclassImportRewrite.getCreatedImports().length > 0) {
          subclassMultiTextEdit.addChild(subclassImportEdit);
          subclassCompilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{subclassImportEdit}));
        }
        TextEdit subclassEdit=subclassRewriter.rewriteAST();
        subclassMultiTextEdit.addChild(subclassEdit);
        subclassCompilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{subclassEdit}));
      }
 catch (      JavaModelException e) {
        e.printStackTrace();
      }
catch (      CoreException e) {
        e.printStackTrace();
      }
    }
  }
}"
12088,"private void modifyTypeFieldAssignmentsInContextClass(boolean modify){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  Set<MethodDeclaration> contextMethods=getAllMethodDeclarationsInSourceClass();
  List<SimpleName> staticFields=typeCheckElimination.getStaticFields();
  MethodDeclaration typeFieldSetterMethod=typeCheckElimination.getTypeFieldSetterMethod();
  for (  MethodDeclaration methodDeclaration : contextMethods) {
    if (!methodDeclaration.equals(typeFieldSetterMethod)) {
      Block methodBody=methodDeclaration.getBody();
      if (methodBody != null) {
        List<Statement> statements=methodBody.statements();
        for (        Statement statement : statements) {
          List<Expression> assignments=expressionExtractor.getAssignments(statement);
          for (          Expression expression : assignments) {
            Assignment assignment=(Assignment)expression;
            Expression leftHandSide=assignment.getLeftHandSide();
            SimpleName assignedVariable=null;
            Expression invoker=null;
            if (leftHandSide instanceof SimpleName) {
              assignedVariable=(SimpleName)leftHandSide;
            }
 else             if (leftHandSide instanceof QualifiedName) {
              QualifiedName qualifiedName=(QualifiedName)leftHandSide;
              assignedVariable=qualifiedName.getName();
              invoker=qualifiedName.getQualifier();
            }
 else             if (leftHandSide instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)leftHandSide;
              assignedVariable=fieldAccess.getName();
              invoker=fieldAccess.getExpression();
            }
            Expression rightHandSide=assignment.getRightHandSide();
            List<Expression> accessedVariables=expressionExtractor.getVariableInstructions(rightHandSide);
            ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
            AST contextAST=sourceTypeDeclaration.getAST();
            boolean rewriteAST=false;
            if (assignedVariable != null) {
              IBinding leftHandBinding=assignedVariable.resolveBinding();
              if (leftHandBinding != null && leftHandBinding.getKind() == IBinding.VARIABLE) {
                IVariableBinding assignedVariableBinding=(IVariableBinding)leftHandBinding;
                if (assignedVariableBinding.isField() && typeCheckElimination.getTypeField().resolveBinding().isEqualTo(assignedVariableBinding)) {
                  if (modify && !nodeExistsInsideTypeCheckCodeFragment(assignment)) {
                    MethodInvocation setterMethodInvocation=contextAST.newMethodInvocation();
                    if (typeCheckElimination.getTypeFieldSetterMethod() != null) {
                      sourceRewriter.set(setterMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckElimination.getTypeFieldSetterMethod().getName(),null);
                    }
 else {
                      sourceRewriter.set(setterMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + abstractClassName),null);
                    }
                    ListRewrite setterMethodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(setterMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                    setterMethodInvocationArgumentsRewrite.insertLast(assignment.getRightHandSide(),null);
                    if (invoker != null) {
                      sourceRewriter.set(setterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,invoker,null);
                    }
                    sourceRewriter.replace(assignment,setterMethodInvocation,null);
                    rewriteAST=true;
                  }
                  for (                  Expression expression2 : accessedVariables) {
                    SimpleName accessedVariable=(SimpleName)expression2;
                    IBinding rightHandBinding=accessedVariable.resolveBinding();
                    if (rightHandBinding != null && rightHandBinding.getKind() == IBinding.VARIABLE) {
                      IVariableBinding accessedVariableBinding=(IVariableBinding)rightHandBinding;
                      if (accessedVariableBinding.isField() && (accessedVariableBinding.getModifiers() & Modifier.STATIC) != 0 && !containsVariable(staticFields,accessedVariable) && accessedVariableBinding.getType().isEqualTo(assignedVariableBinding.getType())) {
                        if (!containsStaticFieldKey(accessedVariable) && !modify)                         additionalStaticFieldMap.put(accessedVariable,generateSubclassName(accessedVariable));
                      }
                    }
                  }
                }
              }
            }
            for (            Expression expression2 : accessedVariables) {
              SimpleName accessedVariable=(SimpleName)expression2;
              IBinding rightHandBinding=accessedVariable.resolveBinding();
              if (rightHandBinding != null && rightHandBinding.getKind() == IBinding.VARIABLE) {
                IVariableBinding accessedVariableBinding=(IVariableBinding)rightHandBinding;
                if (accessedVariableBinding.isField() && typeCheckElimination.getTypeField().resolveBinding().isEqualTo(accessedVariableBinding)) {
                  if (modify && !nodeExistsInsideTypeCheckCodeFragment(accessedVariable)) {
                    MethodInvocation getterMethodInvocation=contextAST.newMethodInvocation();
                    if (typeCheckElimination.getTypeFieldGetterMethod() != null) {
                      sourceRewriter.set(getterMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckElimination.getTypeFieldGetterMethod().getName(),null);
                    }
 else {
                      sourceRewriter.set(getterMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + abstractClassName),null);
                    }
                    sourceRewriter.replace(accessedVariable,getterMethodInvocation,null);
                    rewriteAST=true;
                  }
                }
              }
            }
            if (rewriteAST) {
              try {
                TextEdit sourceEdit=sourceRewriter.rewriteAST();
                ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
                CompilationUnitChange change=compilationUnitChanges.get(sourceICompilationUnit);
                change.getEdit().addChild(sourceEdit);
                change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
              }
 catch (              JavaModelException e) {
                e.printStackTrace();
              }
            }
          }
        }
      }
    }
  }
}","private void modifyTypeFieldAssignmentsInContextClass(boolean modify){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  Set<MethodDeclaration> contextMethods=getAllMethodDeclarationsInSourceClass();
  List<SimpleName> staticFields=typeCheckElimination.getStaticFields();
  MethodDeclaration typeFieldSetterMethod=typeCheckElimination.getTypeFieldSetterMethod();
  for (  MethodDeclaration methodDeclaration : contextMethods) {
    if (!methodDeclaration.equals(typeFieldSetterMethod)) {
      Block methodBody=methodDeclaration.getBody();
      if (methodBody != null) {
        List<Statement> statements=methodBody.statements();
        for (        Statement statement : statements) {
          List<Expression> assignments=expressionExtractor.getAssignments(statement);
          for (          Expression expression : assignments) {
            Assignment assignment=(Assignment)expression;
            Expression leftHandSide=assignment.getLeftHandSide();
            SimpleName assignedVariable=null;
            Expression invoker=null;
            if (leftHandSide instanceof SimpleName) {
              assignedVariable=(SimpleName)leftHandSide;
            }
 else             if (leftHandSide instanceof QualifiedName) {
              QualifiedName qualifiedName=(QualifiedName)leftHandSide;
              assignedVariable=qualifiedName.getName();
              invoker=qualifiedName.getQualifier();
            }
 else             if (leftHandSide instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)leftHandSide;
              assignedVariable=fieldAccess.getName();
              invoker=fieldAccess.getExpression();
            }
            Expression rightHandSide=assignment.getRightHandSide();
            List<Expression> accessedVariables=expressionExtractor.getVariableInstructions(rightHandSide);
            ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
            AST contextAST=sourceTypeDeclaration.getAST();
            boolean rewriteAST=false;
            if (assignedVariable != null) {
              IBinding leftHandBinding=assignedVariable.resolveBinding();
              if (leftHandBinding != null && leftHandBinding.getKind() == IBinding.VARIABLE) {
                IVariableBinding assignedVariableBinding=(IVariableBinding)leftHandBinding;
                if (assignedVariableBinding.isField() && typeCheckElimination.getTypeField().resolveBinding().isEqualTo(assignedVariableBinding)) {
                  if (modify && !nodeExistsInsideTypeCheckCodeFragment(assignment)) {
                    MethodInvocation setterMethodInvocation=contextAST.newMethodInvocation();
                    if (typeCheckElimination.getTypeFieldSetterMethod() != null) {
                      sourceRewriter.set(setterMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckElimination.getTypeFieldSetterMethod().getName(),null);
                    }
 else {
                      sourceRewriter.set(setterMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(setterMethodName()),null);
                    }
                    ListRewrite setterMethodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(setterMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                    setterMethodInvocationArgumentsRewrite.insertLast(assignment.getRightHandSide(),null);
                    if (invoker != null) {
                      sourceRewriter.set(setterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,invoker,null);
                    }
                    sourceRewriter.replace(assignment,setterMethodInvocation,null);
                    rewriteAST=true;
                  }
                  for (                  Expression expression2 : accessedVariables) {
                    SimpleName accessedVariable=(SimpleName)expression2;
                    IBinding rightHandBinding=accessedVariable.resolveBinding();
                    if (rightHandBinding != null && rightHandBinding.getKind() == IBinding.VARIABLE) {
                      IVariableBinding accessedVariableBinding=(IVariableBinding)rightHandBinding;
                      if (accessedVariableBinding.isField() && (accessedVariableBinding.getModifiers() & Modifier.STATIC) != 0 && !containsVariable(staticFields,accessedVariable) && accessedVariableBinding.getType().isEqualTo(assignedVariableBinding.getType())) {
                        if (!containsStaticFieldKey(accessedVariable) && !modify)                         additionalStaticFieldMap.put(accessedVariable,generateSubclassName(accessedVariable));
                      }
                    }
                  }
                }
              }
            }
            for (            Expression expression2 : accessedVariables) {
              SimpleName accessedVariable=(SimpleName)expression2;
              IBinding rightHandBinding=accessedVariable.resolveBinding();
              if (rightHandBinding != null && rightHandBinding.getKind() == IBinding.VARIABLE) {
                IVariableBinding accessedVariableBinding=(IVariableBinding)rightHandBinding;
                if (accessedVariableBinding.isField() && typeCheckElimination.getTypeField().resolveBinding().isEqualTo(accessedVariableBinding)) {
                  if (modify && !nodeExistsInsideTypeCheckCodeFragment(accessedVariable)) {
                    MethodInvocation getterMethodInvocation=contextAST.newMethodInvocation();
                    if (typeCheckElimination.getTypeFieldGetterMethod() != null) {
                      sourceRewriter.set(getterMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckElimination.getTypeFieldGetterMethod().getName(),null);
                    }
 else {
                      sourceRewriter.set(getterMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + abstractClassName),null);
                    }
                    sourceRewriter.replace(accessedVariable,getterMethodInvocation,null);
                    rewriteAST=true;
                  }
                }
              }
            }
            if (rewriteAST) {
              try {
                TextEdit sourceEdit=sourceRewriter.rewriteAST();
                ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
                CompilationUnitChange change=compilationUnitChanges.get(sourceICompilationUnit);
                change.getEdit().addChild(sourceEdit);
                change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
              }
 catch (              JavaModelException e) {
                e.printStackTrace();
              }
            }
          }
        }
      }
    }
  }
}"
12089,"private void generateSetterMethodForStateField(){
  ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
  AST contextAST=sourceTypeDeclaration.getAST();
  ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration setterMethod=typeCheckElimination.getTypeFieldSetterMethod();
  SwitchStatement switchStatement=contextAST.newSwitchStatement();
  List<SimpleName> staticFieldNames=new ArrayList<SimpleName>(staticFieldMap.keySet());
  List<String> subclassNames=new ArrayList<String>(staticFieldMap.values());
  ListRewrite switchStatementStatementsRewrite=sourceRewriter.getListRewrite(switchStatement,SwitchStatement.STATEMENTS_PROPERTY);
  int i=0;
  for (  SimpleName staticFieldName : staticFieldNames) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    IBinding staticFieldNameBinding=staticFieldName.resolveBinding();
    String staticFieldNameDeclaringClass=null;
    boolean isEnumConstant=false;
    if (staticFieldNameBinding != null && staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
      IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
      isEnumConstant=staticFieldNameVariableBinding.isEnumConstant();
      if (!sourceTypeDeclaration.resolveBinding().isEqualTo(staticFieldNameVariableBinding.getDeclaringClass())) {
        staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass().getName();
      }
    }
    if (staticFieldNameDeclaringClass == null || isEnumConstant) {
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,staticFieldName,null);
    }
 else {
      FieldAccess fieldAccess=contextAST.newFieldAccess();
      sourceRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newSimpleName(staticFieldNameDeclaringClass),null);
      sourceRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,staticFieldName,null);
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,fieldAccess,null);
    }
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(subclassNames.get(i)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
    i++;
  }
  for (  SimpleName staticFieldName : additionalStaticFieldMap.keySet()) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    IBinding staticFieldNameBinding=staticFieldName.resolveBinding();
    String staticFieldNameDeclaringClass=null;
    boolean isEnumConstant=false;
    if (staticFieldNameBinding != null && staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
      IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
      isEnumConstant=staticFieldNameVariableBinding.isEnumConstant();
      if (!sourceTypeDeclaration.resolveBinding().isEqualTo(staticFieldNameVariableBinding.getDeclaringClass())) {
        staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass().getName();
      }
    }
    if (staticFieldNameDeclaringClass == null || isEnumConstant) {
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,staticFieldName,null);
    }
 else {
      FieldAccess fieldAccess=contextAST.newFieldAccess();
      sourceRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newSimpleName(staticFieldNameDeclaringClass),null);
      sourceRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,staticFieldName,null);
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,fieldAccess,null);
    }
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(additionalStaticFieldMap.get(staticFieldName)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
  }
  SwitchCase switchCase=contextAST.newSwitchCase();
  sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,null,null);
  switchStatementStatementsRewrite.insertLast(switchCase,null);
  Assignment nullAssignment=contextAST.newAssignment();
  sourceRewriter.set(nullAssignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
  FieldAccess typeFieldAccess=contextAST.newFieldAccess();
  sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
  sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
  sourceRewriter.set(nullAssignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
  sourceRewriter.set(nullAssignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,contextAST.newNullLiteral(),null);
  switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(nullAssignment),null);
  switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
  if (setterMethod != null) {
    List<SingleVariableDeclaration> setterMethodParameters=setterMethod.parameters();
    if (setterMethodParameters.size() == 1) {
      sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,setterMethodParameters.get(0).getName(),null);
    }
    Block setterMethodBody=setterMethod.getBody();
    List<Statement> setterMethodBodyStatements=setterMethodBody.statements();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    if (setterMethodBodyStatements.size() == 1) {
      setterMethodBodyRewrite.replace(setterMethodBodyStatements.get(0),switchStatement,null);
    }
    try {
      TextEdit sourceEdit=sourceRewriter.rewriteAST();
      ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
      CompilationUnitChange change=compilationUnitChanges.get(sourceICompilationUnit);
      change.getEdit().addChild(sourceEdit);
      change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
    }
  }
 else {
    MethodDeclaration setterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + abstractClassName),null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,contextAST.newPrimitiveType(PrimitiveType.VOID),null);
    ListRewrite setterMethodModifiersRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    setterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite setterMethodParameterRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    SingleVariableDeclaration parameter=contextAST.newSingleVariableDeclaration();
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type parameterType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,typeField.getName(),null);
    setterMethodParameterRewrite.insertLast(parameter,null);
    sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,typeField.getName(),null);
    Block setterMethodBody=contextAST.newBlock();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    setterMethodBodyRewrite.insertLast(switchStatement,null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,setterMethodBody,null);
    contextBodyRewrite.insertLast(setterMethodDeclaration,null);
    try {
      TextEdit sourceEdit=sourceRewriter.rewriteAST();
      ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
      CompilationUnitChange change=compilationUnitChanges.get(sourceICompilationUnit);
      change.getEdit().addChild(sourceEdit);
      change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
    }
  }
}","private void generateSetterMethodForStateField(){
  ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
  AST contextAST=sourceTypeDeclaration.getAST();
  ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration setterMethod=typeCheckElimination.getTypeFieldSetterMethod();
  SwitchStatement switchStatement=contextAST.newSwitchStatement();
  List<SimpleName> staticFieldNames=new ArrayList<SimpleName>(staticFieldMap.keySet());
  List<String> subclassNames=new ArrayList<String>(staticFieldMap.values());
  ListRewrite switchStatementStatementsRewrite=sourceRewriter.getListRewrite(switchStatement,SwitchStatement.STATEMENTS_PROPERTY);
  int i=0;
  for (  SimpleName staticFieldName : staticFieldNames) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    IBinding staticFieldNameBinding=staticFieldName.resolveBinding();
    String staticFieldNameDeclaringClass=null;
    boolean isEnumConstant=false;
    if (staticFieldNameBinding != null && staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
      IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
      isEnumConstant=staticFieldNameVariableBinding.isEnumConstant();
      if (!sourceTypeDeclaration.resolveBinding().isEqualTo(staticFieldNameVariableBinding.getDeclaringClass())) {
        staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass().getName();
      }
    }
    if (staticFieldNameDeclaringClass == null || isEnumConstant) {
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,staticFieldName,null);
    }
 else {
      FieldAccess fieldAccess=contextAST.newFieldAccess();
      sourceRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newSimpleName(staticFieldNameDeclaringClass),null);
      sourceRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,staticFieldName,null);
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,fieldAccess,null);
    }
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(subclassNames.get(i)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
    i++;
  }
  for (  SimpleName staticFieldName : additionalStaticFieldMap.keySet()) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    IBinding staticFieldNameBinding=staticFieldName.resolveBinding();
    String staticFieldNameDeclaringClass=null;
    boolean isEnumConstant=false;
    if (staticFieldNameBinding != null && staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
      IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
      isEnumConstant=staticFieldNameVariableBinding.isEnumConstant();
      if (!sourceTypeDeclaration.resolveBinding().isEqualTo(staticFieldNameVariableBinding.getDeclaringClass())) {
        staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass().getName();
      }
    }
    if (staticFieldNameDeclaringClass == null || isEnumConstant) {
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,staticFieldName,null);
    }
 else {
      FieldAccess fieldAccess=contextAST.newFieldAccess();
      sourceRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newSimpleName(staticFieldNameDeclaringClass),null);
      sourceRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,staticFieldName,null);
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,fieldAccess,null);
    }
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(additionalStaticFieldMap.get(staticFieldName)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
  }
  SwitchCase switchCase=contextAST.newSwitchCase();
  sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,null,null);
  switchStatementStatementsRewrite.insertLast(switchCase,null);
  Assignment nullAssignment=contextAST.newAssignment();
  sourceRewriter.set(nullAssignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
  FieldAccess typeFieldAccess=contextAST.newFieldAccess();
  sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
  sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
  sourceRewriter.set(nullAssignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
  sourceRewriter.set(nullAssignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,contextAST.newNullLiteral(),null);
  switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(nullAssignment),null);
  switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
  if (setterMethod != null) {
    List<SingleVariableDeclaration> setterMethodParameters=setterMethod.parameters();
    if (setterMethodParameters.size() == 1) {
      sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,setterMethodParameters.get(0).getName(),null);
    }
    Block setterMethodBody=setterMethod.getBody();
    List<Statement> setterMethodBodyStatements=setterMethodBody.statements();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    if (setterMethodBodyStatements.size() == 1) {
      setterMethodBodyRewrite.replace(setterMethodBodyStatements.get(0),switchStatement,null);
    }
    try {
      TextEdit sourceEdit=sourceRewriter.rewriteAST();
      ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
      CompilationUnitChange change=compilationUnitChanges.get(sourceICompilationUnit);
      change.getEdit().addChild(sourceEdit);
      change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
    }
  }
 else {
    MethodDeclaration setterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(setterMethodName()),null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,contextAST.newPrimitiveType(PrimitiveType.VOID),null);
    ListRewrite setterMethodModifiersRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    setterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite setterMethodParameterRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    SingleVariableDeclaration parameter=contextAST.newSingleVariableDeclaration();
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type parameterType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,typeField.getName(),null);
    setterMethodParameterRewrite.insertLast(parameter,null);
    sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,typeField.getName(),null);
    Block setterMethodBody=contextAST.newBlock();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    setterMethodBodyRewrite.insertLast(switchStatement,null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,setterMethodBody,null);
    contextBodyRewrite.insertLast(setterMethodDeclaration,null);
    try {
      TextEdit sourceEdit=sourceRewriter.rewriteAST();
      ICompilationUnit sourceICompilationUnit=(ICompilationUnit)sourceCompilationUnit.getJavaElement();
      CompilationUnitChange change=compilationUnitChanges.get(sourceICompilationUnit);
      change.getEdit().addChild(sourceEdit);
      change.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
    }
  }
}"
12090,"private void handleInputChanged(){
  String classNamePattern=""String_Node_Str"";
  for (  Text text : textMap.keySet()) {
    if (!Pattern.matches(classNamePattern,text.getText())) {
      setPageComplete(false);
      String message=""String_Node_Str"" + text.getText() + ""String_Node_Str"";
      setMessage(message,ERROR);
      return;
    }
 else     if (parentPackageClassNames.contains(text.getText())) {
      setPageComplete(false);
      String message=""String_Node_Str"" + text.getText() + ""String_Node_Str""+ parentPackage.getElementName();
      setMessage(message,ERROR);
      return;
    }
 else     if (javaLangClassNames.contains(text.getText())) {
      setPageComplete(false);
      String message=""String_Node_Str"" + text.getText() + ""String_Node_Str"";
      setMessage(message,ERROR);
      return;
    }
 else {
      SimpleName namedConstant=textMap.get(text);
      refactoring.setTypeNameForNamedConstant(namedConstant,text.getText());
    }
  }
  setPageComplete(true);
  setMessage(""String_Node_Str"",NONE);
}","private void handleInputChanged(){
  String classNamePattern=""String_Node_Str"";
  for (  Text text : textMap.keySet()) {
    if (!Pattern.matches(classNamePattern,text.getText())) {
      setPageComplete(false);
      String message=""String_Node_Str"" + text.getText() + ""String_Node_Str"";
      setMessage(message,ERROR);
      return;
    }
 else     if (parentPackageClassNames.contains(text.getText())) {
      setPageComplete(false);
      String message=""String_Node_Str"" + text.getText() + ""String_Node_Str"";
      setMessage(message,ERROR);
      return;
    }
 else     if (javaLangClassNames.contains(text.getText())) {
      setPageComplete(false);
      String message=""String_Node_Str"" + text.getText() + ""String_Node_Str"";
      setMessage(message,ERROR);
      return;
    }
 else {
      SimpleName namedConstant=textMap.get(text);
      refactoring.setTypeNameForNamedConstant(namedConstant,text.getText());
    }
  }
  setPageComplete(true);
  setMessage(""String_Node_Str"",NONE);
}"
12091,"public ReplaceTypeCodeWithStateStrategyInputPage(ReplaceTypeCodeWithStateStrategy refactoring){
  super(""String_Node_Str"");
  this.refactoring=refactoring;
  ICompilationUnit sourceCompilationUnit=(ICompilationUnit)refactoring.getSourceCompilationUnit().getJavaElement();
  this.parentPackage=(IPackageFragment)sourceCompilationUnit.getParent();
  this.parentPackageClassNames=new ArrayList<String>();
  try {
    for (    ICompilationUnit compilationUnit : parentPackage.getCompilationUnits()) {
      String className=compilationUnit.getElementName();
      parentPackageClassNames.add(className.substring(0,className.indexOf(""String_Node_Str"")));
    }
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
  this.javaLangClassNames=new ArrayList<String>();
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.textMap=new LinkedHashMap<Text,SimpleName>();
  this.defaultNamingMap=new LinkedHashMap<Text,String>();
}","public ReplaceTypeCodeWithStateStrategyInputPage(ReplaceTypeCodeWithStateStrategy refactoring){
  super(""String_Node_Str"");
  this.refactoring=refactoring;
  ICompilationUnit sourceCompilationUnit=(ICompilationUnit)refactoring.getSourceCompilationUnit().getJavaElement();
  this.parentPackage=(IPackageFragment)sourceCompilationUnit.getParent();
  this.parentPackageClassNames=new ArrayList<String>();
  try {
    for (    ICompilationUnit compilationUnit : parentPackage.getCompilationUnits()) {
      String className=compilationUnit.getElementName();
      parentPackageClassNames.add(className.substring(0,className.indexOf(""String_Node_Str"")));
    }
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
  TypeVisitor typeVisitor=new TypeVisitor();
  refactoring.getSourceCompilationUnit().accept(typeVisitor);
  Set<ITypeBinding> typeBindings=typeVisitor.getTypeBindings();
  for (  ITypeBinding typeBinding : typeBindings) {
    if (!parentPackageClassNames.contains(typeBinding.getName()) && !typeBinding.isNested()) {
      parentPackageClassNames.add(typeBinding.getName());
    }
  }
  this.javaLangClassNames=new ArrayList<String>();
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.javaLangClassNames.add(""String_Node_Str"");
  this.textMap=new LinkedHashMap<Text,SimpleName>();
  this.defaultNamingMap=new LinkedHashMap<Text,String>();
}"
12092,"private void processArgumentOfInternalMethodInvocation(MethodObject methodObject,AbstractVariable argumentDeclaration,int initialArgumentPosition,VariableDeclaration parameterDeclaration,Set<String> processedMethods){
  SystemObject systemObject=ASTReader.getSystemObject();
  if (methodObject.getMethodBody() == null) {
    IMethodBinding superMethodDeclarationBinding=methodObject.getMethodDeclaration().resolveBinding();
    IType superType=(IType)superMethodDeclarationBinding.getDeclaringClass().getJavaElement();
    processedMethods.add(superMethodDeclarationBinding.getKey());
    Set<IType> subTypes=CompilationUnitCache.getInstance().getSubTypes(superType);
    for (    IType subType : subTypes) {
      ClassObject subClassObject=systemObject.getClassObject(subType.getFullyQualifiedName('.'));
      if (subClassObject != null) {
        ListIterator<MethodObject> methodIterator=subClassObject.getMethodIterator();
        while (methodIterator.hasNext()) {
          MethodObject subMethod=methodIterator.next();
          if (equalSignature(subMethod.getMethodDeclaration().resolveBinding(),superMethodDeclarationBinding)) {
            ParameterObject parameterObject=subMethod.getParameter(initialArgumentPosition);
            VariableDeclaration parameterDeclaration2=parameterObject.getSingleVariableDeclaration();
            if (!processedMethods.contains(subMethod.getMethodDeclaration().resolveBinding().getKey()))             processArgumentOfInternalMethodInvocation(subMethod,argumentDeclaration,initialArgumentPosition,parameterDeclaration2,processedMethods);
            break;
          }
        }
      }
    }
  }
 else {
    for (    AbstractVariable originalField : methodObject.getDefinedFieldsThroughParameters()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(originalField.getVariableBindingKey())) {
        AbstractVariable field=new CompositeVariable(argumentDeclaration.getVariableBindingKey(),argumentDeclaration.getVariableName(),argumentDeclaration.getVariableType(),argumentDeclaration.isField(),argumentDeclaration.isParameter(),((CompositeVariable)originalField).getRightPart());
        definedVariables.add(field);
      }
    }
    for (    AbstractVariable originalField : methodObject.getUsedFieldsThroughParameters()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(originalField.getVariableBindingKey())) {
        AbstractVariable field=new CompositeVariable(argumentDeclaration.getVariableBindingKey(),argumentDeclaration.getVariableName(),argumentDeclaration.getVariableType(),argumentDeclaration.isField(),argumentDeclaration.isParameter(),((CompositeVariable)originalField).getRightPart());
        usedVariables.add(field);
      }
    }
    processedMethods.add(methodObject.getMethodDeclaration().resolveBinding().getKey());
    Map<AbstractVariable,LinkedHashSet<MethodInvocationObject>> invokedMethodsThroughParameters=methodObject.getInvokedMethodsThroughParameters();
    for (    AbstractVariable originalField : invokedMethodsThroughParameters.keySet()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(originalField.getVariableBindingKey())) {
        AbstractVariable field=null;
        if (originalField instanceof PlainVariable)         field=argumentDeclaration;
 else         field=new CompositeVariable(argumentDeclaration.getVariableBindingKey(),argumentDeclaration.getVariableName(),argumentDeclaration.getVariableType(),argumentDeclaration.isField(),argumentDeclaration.isParameter(),((CompositeVariable)originalField).getRightPart());
        LinkedHashSet<MethodInvocationObject> methodInvocations=invokedMethodsThroughParameters.get(originalField);
        for (        MethodInvocationObject methodInvocationObject : methodInvocations) {
          MethodInvocation methodInvocation2=methodInvocationObject.getMethodInvocation();
          ClassObject classObject2=systemObject.getClassObject(methodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(methodInvocationObject);
            if (methodObject2 != null) {
              processInternalMethodInvocation(classObject2,methodObject2,field,new LinkedHashSet<String>());
            }
          }
 else {
            LibraryClassStorage instance=LibraryClassStorage.getInstance();
            IMethodBinding invokedMethodBinding=methodInvocation2.resolveMethodBinding();
            if (instance.isAnalyzed(invokedMethodBinding.getKey())) {
              handleAlreadyAnalyzedMethod(invokedMethodBinding.getKey(),field,instance);
            }
 else {
              MethodDeclaration invokedMethodDeclaration=getInvokedMethodDeclaration(invokedMethodBinding);
              if (invokedMethodDeclaration != null)               processExternalMethodInvocation(invokedMethodDeclaration,field,new LinkedHashSet<String>(),0);
            }
          }
        }
      }
    }
    Map<PlainVariable,LinkedHashSet<MethodInvocationObject>> parametersPassedAsArgumentsInMethodInvocations=methodObject.getParametersPassedAsArgumentsInMethodInvocations();
    for (    PlainVariable parameter : parametersPassedAsArgumentsInMethodInvocations.keySet()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(parameter.getVariableBindingKey())) {
        LinkedHashSet<MethodInvocationObject> methodInvocations=parametersPassedAsArgumentsInMethodInvocations.get(parameter);
        for (        MethodInvocationObject methodInvocationObject : methodInvocations) {
          ClassObject classObject2=systemObject.getClassObject(methodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(methodInvocationObject);
            if (methodObject2 != null && !methodObject2.equals(methodObject)) {
              MethodInvocation methodInvocation2=methodInvocationObject.getMethodInvocation();
              int argumentPosition=getArgumentPosition(methodInvocation2.arguments(),parameter);
              ParameterObject parameterObject=methodObject2.getParameter(argumentPosition);
              VariableDeclaration parameterDeclaration2=parameterObject.getSingleVariableDeclaration();
              if (!processedMethods.contains(methodInvocation2.resolveMethodBinding().getKey()))               processArgumentOfInternalMethodInvocation(methodObject2,argumentDeclaration,argumentPosition,parameterDeclaration2,processedMethods);
            }
          }
        }
      }
    }
    Map<PlainVariable,LinkedHashSet<SuperMethodInvocationObject>> parametersPassedAsArgumentsInSuperMethodInvocations=methodObject.getParametersPassedAsArgumentsInSuperMethodInvocations();
    for (    PlainVariable parameter : parametersPassedAsArgumentsInSuperMethodInvocations.keySet()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(parameter.getVariableBindingKey())) {
        LinkedHashSet<SuperMethodInvocationObject> superMethodInvocations=parametersPassedAsArgumentsInSuperMethodInvocations.get(parameter);
        for (        SuperMethodInvocationObject superMethodInvocationObject : superMethodInvocations) {
          ClassObject classObject2=systemObject.getClassObject(superMethodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(superMethodInvocationObject);
            if (methodObject2 != null) {
              SuperMethodInvocation superMethodInvocation=superMethodInvocationObject.getSuperMethodInvocation();
              int argumentPosition=getArgumentPosition(superMethodInvocation.arguments(),parameter);
              ParameterObject parameterObject=methodObject2.getParameter(argumentPosition);
              VariableDeclaration parameterDeclaration2=parameterObject.getSingleVariableDeclaration();
              if (!processedMethods.contains(superMethodInvocation.resolveMethodBinding().getKey()))               processArgumentOfInternalMethodInvocation(methodObject2,argumentDeclaration,argumentPosition,parameterDeclaration2,processedMethods);
            }
          }
        }
      }
    }
  }
}","private void processArgumentOfInternalMethodInvocation(MethodObject methodObject,AbstractVariable argumentDeclaration,int initialArgumentPosition,VariableDeclaration parameterDeclaration,Set<String> processedMethods){
  SystemObject systemObject=ASTReader.getSystemObject();
  if (methodObject.getMethodBody() == null) {
    IMethodBinding superMethodDeclarationBinding=methodObject.getMethodDeclaration().resolveBinding();
    IType superType=(IType)superMethodDeclarationBinding.getDeclaringClass().getJavaElement();
    processedMethods.add(superMethodDeclarationBinding.getKey());
    Set<IType> subTypes=CompilationUnitCache.getInstance().getSubTypes(superType);
    for (    IType subType : subTypes) {
      ClassObject subClassObject=systemObject.getClassObject(subType.getFullyQualifiedName('.'));
      if (subClassObject != null) {
        ListIterator<MethodObject> methodIterator=subClassObject.getMethodIterator();
        while (methodIterator.hasNext()) {
          MethodObject subMethod=methodIterator.next();
          if (equalSignature(subMethod.getMethodDeclaration().resolveBinding(),superMethodDeclarationBinding)) {
            ParameterObject parameterObject=subMethod.getParameter(initialArgumentPosition);
            VariableDeclaration parameterDeclaration2=parameterObject.getSingleVariableDeclaration();
            if (!processedMethods.contains(subMethod.getMethodDeclaration().resolveBinding().getKey()))             processArgumentOfInternalMethodInvocation(subMethod,argumentDeclaration,initialArgumentPosition,parameterDeclaration2,processedMethods);
            break;
          }
        }
      }
    }
  }
 else {
    for (    AbstractVariable originalField : methodObject.getDefinedFieldsThroughParameters()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(originalField.getVariableBindingKey())) {
        AbstractVariable field=new CompositeVariable(argumentDeclaration.getVariableBindingKey(),argumentDeclaration.getVariableName(),argumentDeclaration.getVariableType(),argumentDeclaration.isField(),argumentDeclaration.isParameter(),((CompositeVariable)originalField).getRightPart());
        definedVariables.add(field);
      }
    }
    for (    AbstractVariable originalField : methodObject.getUsedFieldsThroughParameters()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(originalField.getVariableBindingKey())) {
        AbstractVariable field=new CompositeVariable(argumentDeclaration.getVariableBindingKey(),argumentDeclaration.getVariableName(),argumentDeclaration.getVariableType(),argumentDeclaration.isField(),argumentDeclaration.isParameter(),((CompositeVariable)originalField).getRightPart());
        usedVariables.add(field);
      }
    }
    processedMethods.add(methodObject.getMethodDeclaration().resolveBinding().getKey());
    Map<AbstractVariable,LinkedHashSet<MethodInvocationObject>> invokedMethodsThroughParameters=methodObject.getInvokedMethodsThroughParameters();
    for (    AbstractVariable originalField : invokedMethodsThroughParameters.keySet()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(originalField.getVariableBindingKey())) {
        AbstractVariable field=null;
        if (originalField instanceof PlainVariable)         field=argumentDeclaration;
 else         field=new CompositeVariable(argumentDeclaration.getVariableBindingKey(),argumentDeclaration.getVariableName(),argumentDeclaration.getVariableType(),argumentDeclaration.isField(),argumentDeclaration.isParameter(),((CompositeVariable)originalField).getRightPart());
        LinkedHashSet<MethodInvocationObject> methodInvocations=invokedMethodsThroughParameters.get(originalField);
        for (        MethodInvocationObject methodInvocationObject : methodInvocations) {
          MethodInvocation methodInvocation2=methodInvocationObject.getMethodInvocation();
          ClassObject classObject2=systemObject.getClassObject(methodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(methodInvocationObject);
            if (methodObject2 != null) {
              processInternalMethodInvocation(classObject2,methodObject2,field,new LinkedHashSet<String>());
            }
          }
 else {
            LibraryClassStorage instance=LibraryClassStorage.getInstance();
            IMethodBinding invokedMethodBinding=methodInvocation2.resolveMethodBinding();
            if (instance.isAnalyzed(invokedMethodBinding.getKey())) {
              handleAlreadyAnalyzedMethod(invokedMethodBinding.getKey(),field,instance);
            }
 else {
              MethodDeclaration invokedMethodDeclaration=getInvokedMethodDeclaration(invokedMethodBinding);
              if (invokedMethodDeclaration != null)               processExternalMethodInvocation(invokedMethodDeclaration,field,new LinkedHashSet<String>(),0);
            }
          }
        }
      }
    }
    Map<PlainVariable,LinkedHashSet<MethodInvocationObject>> parametersPassedAsArgumentsInMethodInvocations=methodObject.getParametersPassedAsArgumentsInMethodInvocations();
    for (    PlainVariable parameter : parametersPassedAsArgumentsInMethodInvocations.keySet()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(parameter.getVariableBindingKey())) {
        LinkedHashSet<MethodInvocationObject> methodInvocations=parametersPassedAsArgumentsInMethodInvocations.get(parameter);
        for (        MethodInvocationObject methodInvocationObject : methodInvocations) {
          ClassObject classObject2=systemObject.getClassObject(methodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(methodInvocationObject);
            if (methodObject2 != null && !methodObject2.equals(methodObject)) {
              MethodInvocation methodInvocation2=methodInvocationObject.getMethodInvocation();
              int argumentPosition=getArgumentPosition(methodInvocation2.arguments(),parameter);
              ParameterObject parameterObject=methodObject2.getParameter(argumentPosition);
              if (parameterObject != null) {
                VariableDeclaration parameterDeclaration2=parameterObject.getSingleVariableDeclaration();
                if (!processedMethods.contains(methodInvocation2.resolveMethodBinding().getKey()))                 processArgumentOfInternalMethodInvocation(methodObject2,argumentDeclaration,argumentPosition,parameterDeclaration2,processedMethods);
              }
            }
          }
        }
      }
    }
    Map<PlainVariable,LinkedHashSet<SuperMethodInvocationObject>> parametersPassedAsArgumentsInSuperMethodInvocations=methodObject.getParametersPassedAsArgumentsInSuperMethodInvocations();
    for (    PlainVariable parameter : parametersPassedAsArgumentsInSuperMethodInvocations.keySet()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(parameter.getVariableBindingKey())) {
        LinkedHashSet<SuperMethodInvocationObject> superMethodInvocations=parametersPassedAsArgumentsInSuperMethodInvocations.get(parameter);
        for (        SuperMethodInvocationObject superMethodInvocationObject : superMethodInvocations) {
          ClassObject classObject2=systemObject.getClassObject(superMethodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(superMethodInvocationObject);
            if (methodObject2 != null) {
              SuperMethodInvocation superMethodInvocation=superMethodInvocationObject.getSuperMethodInvocation();
              int argumentPosition=getArgumentPosition(superMethodInvocation.arguments(),parameter);
              ParameterObject parameterObject=methodObject2.getParameter(argumentPosition);
              VariableDeclaration parameterDeclaration2=parameterObject.getSingleVariableDeclaration();
              if (!processedMethods.contains(superMethodInvocation.resolveMethodBinding().getKey()))               processArgumentOfInternalMethodInvocation(methodObject2,argumentDeclaration,argumentPosition,parameterDeclaration2,processedMethods);
            }
          }
        }
      }
    }
  }
}"
12093,"private void matchBasedOnControlDependenceTreeStructure(ControlDependenceTreeNode controlDependenceTreePDG1,ControlDependenceTreeNode controlDependenceTreePDG2){
  int maxLevel1=controlDependenceTreePDG1.getMaxLevel();
  int level1=maxLevel1;
  int maxLevel2=controlDependenceTreePDG2.getMaxLevel();
  int level2=maxLevel2;
  if (monitor != null)   monitor.beginTask(""String_Node_Str"",Math.min(maxLevel1,maxLevel2));
  CloneStructureNode root=null;
  MappingState finalState=null;
  List<CloneStructureNode> parents=new ArrayList<CloneStructureNode>();
  while (level1 >= 0 && level2 >= 0) {
    Set<PDGNode> controlPredicateNodesG1=controlDependenceTreePDG1.getControlPredicateNodesInLevel(level1);
    Set<PDGNode> controlPredicateNodesG2=controlDependenceTreePDG2.getControlPredicateNodesInLevel(level2);
    Set<PDGNode> controlPredicateNodesInNextLevelG1=new LinkedHashSet<PDGNode>();
    Set<PDGNode> controlPredicateNodesInNextLevelG2=new LinkedHashSet<PDGNode>();
    if (level1 < maxLevel1) {
      Set<PDGNode> nodesInNextLevel=controlDependenceTreePDG1.getControlPredicateNodesInLevel(level1 + 1);
      controlPredicateNodesInNextLevelG1.addAll(nodesInNextLevel);
      for (      PDGNode node : nodesInNextLevel) {
        if (node instanceof PDGTryNode) {
          controlPredicateNodesInNextLevelG1.addAll(pdg1.getNestedNodesWithinTryNode((PDGTryNode)node));
        }
      }
    }
    if (level2 < maxLevel2) {
      Set<PDGNode> nodesInNextLevel=controlDependenceTreePDG2.getControlPredicateNodesInLevel(level2 + 1);
      controlPredicateNodesInNextLevelG2.addAll(nodesInNextLevel);
      for (      PDGNode node : nodesInNextLevel) {
        if (node instanceof PDGTryNode) {
          controlPredicateNodesInNextLevelG2.addAll(pdg2.getNestedNodesWithinTryNode((PDGTryNode)node));
        }
      }
    }
    for (    PDGNode predicate1 : controlPredicateNodesG1) {
      Set<PDGNode> nodesG1=getNodesInRegion(pdg1,predicate1,controlPredicateNodesG1,controlPredicateNodesInNextLevelG1,controlDependenceTreePDG1);
      if (level1 == 0 && !fullTreeMatch) {
        int maxId=allNodesInSubTreePDG1.last().getId();
        Set<PDGNode> nodesG1ToBeRemoved=new LinkedHashSet<PDGNode>();
        for (        PDGNode nodeG1 : nodesG1) {
          if (nodeG1.getId() > maxId) {
            nodesG1ToBeRemoved.add(nodeG1);
          }
          if (controlDependenceTreePDG1.isElseNode()) {
            double elseNodeId=controlDependenceTreePDG1.getId();
            if (nodeG1.getId() < elseNodeId) {
              nodesG1ToBeRemoved.add(nodeG1);
            }
          }
        }
        nodesG1.removeAll(nodesG1ToBeRemoved);
      }
      this.allNodesInSubTreePDG1.addAll(nodesG1);
      List<MappingState> currentStates=new ArrayList<MappingState>();
      for (      PDGNode predicate2 : controlPredicateNodesG2) {
        Set<PDGNode> nodesG2=getNodesInRegion(pdg2,predicate2,controlPredicateNodesG2,controlPredicateNodesInNextLevelG2,controlDependenceTreePDG2);
        if (level2 == 0 && !fullTreeMatch) {
          int maxId=allNodesInSubTreePDG2.last().getId();
          Set<PDGNode> nodesG2ToBeRemoved=new LinkedHashSet<PDGNode>();
          for (          PDGNode nodeG2 : nodesG2) {
            if (nodeG2.getId() > maxId) {
              nodesG2ToBeRemoved.add(nodeG2);
            }
            if (controlDependenceTreePDG2.isElseNode()) {
              double elseNodeId=controlDependenceTreePDG2.getId();
              if (nodeG2.getId() < elseNodeId) {
                nodesG2ToBeRemoved.add(nodeG2);
              }
            }
          }
          nodesG2.removeAll(nodesG2ToBeRemoved);
        }
        this.allNodesInSubTreePDG2.addAll(nodesG2);
        List<MappingState> maxStates=null;
        if (level1 == 0 || level2 == 0) {
          maxStates=matchBasedOnCodeFragments(finalState,nodesG1,nodesG2);
        }
 else {
          ControlDependenceTreeNode cdtNode1=controlDependenceTreePDG1.getNode(predicate1);
          ControlDependenceTreeNode cdtNode2=controlDependenceTreePDG2.getNode(predicate2);
          ControlDependenceTreeNode cdtNode1Parent=null;
          if (cdtNode1 != null)           cdtNode1Parent=cdtNode1.getParent();
          ControlDependenceTreeNode cdtNode2Parent=null;
          if (cdtNode2 != null)           cdtNode2Parent=cdtNode2.getParent();
          if (cdtNode1Parent != null && cdtNode2Parent != null && !cdtNode1Parent.equals(controlDependenceTreePDG1) && !cdtNode2Parent.equals(controlDependenceTreePDG2)) {
            if ((cdtNode1Parent.getNode() != null && cdtNode1Parent.getNode().getCFGNode() instanceof CFGBranchIfNode && cdtNode2Parent.isElseNode()) || (cdtNode2Parent.getNode() != null && cdtNode2Parent.getNode().getCFGNode() instanceof CFGBranchIfNode && cdtNode1Parent.isElseNode()))             continue;
          }
          if (predicate1.getASTStatement() instanceof SwitchStatement && predicate2.getASTStatement() instanceof SwitchStatement) {
            ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher(iCompilationUnit1,iCompilationUnit2);
            boolean match=astNodeMatcher.match(predicate1,predicate2);
            if (match && astNodeMatcher.isParameterizable()) {
              PDGNodeMapping mapping=new PDGNodeMapping(predicate1,predicate2,astNodeMatcher);
              MappingState state=new MappingState(finalState,mapping);
              if (finalState != null)               finalState.addChild(state);
              Set<PDGNode> switchBodyNodes1=new LinkedHashSet<PDGNode>(nodesG1);
              switchBodyNodes1.remove(predicate1);
              Set<PDGNode> switchBodyNodes2=new LinkedHashSet<PDGNode>(nodesG2);
              switchBodyNodes1.remove(predicate2);
              maxStates=matchBasedOnSwitchCases(state,switchBodyNodes1,switchBodyNodes2);
            }
          }
 else {
            maxStates=processPDGNodes(finalState,nodesG1,nodesG2);
          }
        }
        for (        MappingState temp : maxStates) {
          if (!currentStates.contains(temp)) {
            currentStates.add(temp);
          }
        }
      }
      if (!currentStates.isEmpty()) {
        MappingState best=findMaximumStateWithMinimumDifferences(currentStates);
        List<PDGNodeMapping> nodeMappings=new ArrayList<PDGNodeMapping>(best.getNodeMappings());
        int index=0;
        for (        PDGNodeMapping mapping : nodeMappings) {
          if (mapping.getNodeG1().equals(predicate1)) {
            controlPredicateNodesG2.remove(mapping.getNodeG2());
            break;
          }
          index++;
        }
        finalState=best;
        CloneStructureNode parent=null;
        CloneStructureNode newElseParent=null;
        for (int i=index; i < nodeMappings.size(); i++) {
          PDGNodeMapping mapping=nodeMappings.get(i);
          if (parent == null) {
            parent=new CloneStructureNode(mapping);
          }
 else {
            PDGTryNode nestedUnderTry1=pdg1.isDirectlyNestedWithinTryNode(mapping.getNodeG1());
            PDGTryNode nestedUnderTry2=pdg2.isDirectlyNestedWithinTryNode(mapping.getNodeG2());
            boolean nestedUnderTry=nestedUnderTry1 != null && nestedUnderTry2 != null;
            if (mapping.isFalseControlDependent() && !nestedUnderTry) {
              if (newElseParent == null) {
                ControlDependenceTreeNode elseNodeG1=controlDependenceTreePDG1.getElseNode(parent.getMapping().getNodeG1());
                ControlDependenceTreeNode elseNodeG2=controlDependenceTreePDG2.getElseNode(parent.getMapping().getNodeG2());
                if (elseNodeG1 != null && elseNodeG2 != null) {
                  PDGElseMapping elseMapping=new PDGElseMapping(elseNodeG1.getId(),elseNodeG2.getId());
                  newElseParent=new CloneStructureNode(elseMapping);
                  parent.addChild(newElseParent);
                  CloneStructureNode child=new CloneStructureNode(mapping);
                  newElseParent.addChild(child);
                }
              }
 else {
                CloneStructureNode child=new CloneStructureNode(mapping);
                newElseParent.addChild(child);
              }
            }
 else {
              CloneStructureNode child=new CloneStructureNode(mapping);
              parent.addChild(child);
            }
          }
        }
        if (parent != null) {
          PDGNodeMapping parentNodeMapping=(PDGNodeMapping)parent.getMapping();
          double parentId1=parentNodeMapping.getId1();
          double parentId2=parentNodeMapping.getId2();
          for (ListIterator<CloneStructureNode> parentIterator=parents.listIterator(); parentIterator.hasNext(); ) {
            CloneStructureNode previousParent=parentIterator.next();
            PDGNodeMapping previousParentNodeMapping=(PDGNodeMapping)previousParent.getMapping();
            double previousParentId1=previousParentNodeMapping.getId1();
            double previousParentId2=previousParentNodeMapping.getId2();
            if (controlDependenceTreePDG1.parentChildRelationship(parentId1,previousParentId1) && controlDependenceTreePDG2.parentChildRelationship(parentId2,previousParentId2)) {
              parent.addChild(previousParent);
              parentIterator.remove();
            }
 else             if (previousParentNodeMapping.isFalseControlDependent()) {
              if (newElseParent == null) {
                ControlDependenceTreeNode elseNodeG1=controlDependenceTreePDG1.getElseNode(parentNodeMapping.getNodeG1());
                ControlDependenceTreeNode elseNodeG2=controlDependenceTreePDG2.getElseNode(parentNodeMapping.getNodeG2());
                if (elseNodeG1 != null && elseNodeG2 != null) {
                  if (controlDependenceTreePDG1.parentChildRelationship(elseNodeG1.getId(),previousParentId1) && controlDependenceTreePDG2.parentChildRelationship(elseNodeG2.getId(),previousParentId2)) {
                    PDGElseMapping elseMapping=new PDGElseMapping(elseNodeG1.getId(),elseNodeG2.getId());
                    newElseParent=new CloneStructureNode(elseMapping);
                    parent.addChild(newElseParent);
                    newElseParent.addChild(previousParent);
                    parentIterator.remove();
                  }
                }
              }
 else {
                PDGElseMapping elseMapping=(PDGElseMapping)newElseParent.getMapping();
                if (controlDependenceTreePDG1.parentChildRelationship(elseMapping.getId1(),previousParentId1) && controlDependenceTreePDG2.parentChildRelationship(elseMapping.getId2(),previousParentId2)) {
                  newElseParent.addChild(previousParent);
                  parentIterator.remove();
                }
              }
            }
          }
          boolean isTryBlock=(parentNodeMapping.getNodeG1() instanceof PDGTryNode) && (parentNodeMapping.getNodeG2() instanceof PDGTryNode);
          if (!parent.getChildren().isEmpty() || isTryBlock) {
            parents.add(parent);
          }
 else {
            finalState.getNodeMappings().remove(parent.getMapping());
          }
        }
 else {
          root=new CloneStructureNode(null);
          for (ListIterator<CloneStructureNode> parentIterator=parents.listIterator(); parentIterator.hasNext(); ) {
            CloneStructureNode previousParent=parentIterator.next();
            root.addChild(previousParent);
            parentIterator.remove();
          }
          for (          PDGNodeMapping nodeMapping : best.getNodeMappings()) {
            if (nodesG1.contains(nodeMapping.getNodeG1())) {
              CloneStructureNode childNode=new CloneStructureNode(nodeMapping);
              root.addChild(childNode);
            }
          }
        }
      }
    }
    level1--;
    level2--;
    if (monitor != null)     monitor.worked(1);
  }
  if (monitor != null)   monitor.done();
  if (root == null) {
    root=new CloneStructureNode(null);
    for (ListIterator<CloneStructureNode> parentIterator=parents.listIterator(); parentIterator.hasNext(); ) {
      CloneStructureNode previousParent=parentIterator.next();
      root.addChild(previousParent);
      parentIterator.remove();
    }
  }
  this.maximumStateWithMinimumDifferences=finalState;
  this.cloneStructureRoot=root;
}","private void matchBasedOnControlDependenceTreeStructure(ControlDependenceTreeNode controlDependenceTreePDG1,ControlDependenceTreeNode controlDependenceTreePDG2){
  int maxLevel1=controlDependenceTreePDG1.getMaxLevel();
  int level1=maxLevel1;
  int maxLevel2=controlDependenceTreePDG2.getMaxLevel();
  int level2=maxLevel2;
  if (monitor != null)   monitor.beginTask(""String_Node_Str"",Math.min(maxLevel1,maxLevel2));
  CloneStructureNode root=null;
  MappingState finalState=null;
  List<CloneStructureNode> parents=new ArrayList<CloneStructureNode>();
  while (level1 >= 0 && level2 >= 0) {
    Set<PDGNode> controlPredicateNodesG1=controlDependenceTreePDG1.getControlPredicateNodesInLevel(level1);
    Set<PDGNode> controlPredicateNodesG2=controlDependenceTreePDG2.getControlPredicateNodesInLevel(level2);
    Set<PDGNode> controlPredicateNodesInNextLevelG1=new LinkedHashSet<PDGNode>();
    Set<PDGNode> controlPredicateNodesInNextLevelG2=new LinkedHashSet<PDGNode>();
    if (level1 < maxLevel1) {
      Set<PDGNode> nodesInNextLevel=controlDependenceTreePDG1.getControlPredicateNodesInLevel(level1 + 1);
      controlPredicateNodesInNextLevelG1.addAll(nodesInNextLevel);
      for (      PDGNode node : nodesInNextLevel) {
        if (node instanceof PDGTryNode) {
          controlPredicateNodesInNextLevelG1.addAll(pdg1.getNestedNodesWithinTryNode((PDGTryNode)node));
        }
      }
    }
    if (level2 < maxLevel2) {
      Set<PDGNode> nodesInNextLevel=controlDependenceTreePDG2.getControlPredicateNodesInLevel(level2 + 1);
      controlPredicateNodesInNextLevelG2.addAll(nodesInNextLevel);
      for (      PDGNode node : nodesInNextLevel) {
        if (node instanceof PDGTryNode) {
          controlPredicateNodesInNextLevelG2.addAll(pdg2.getNestedNodesWithinTryNode((PDGTryNode)node));
        }
      }
    }
    for (    PDGNode predicate1 : controlPredicateNodesG1) {
      Set<PDGNode> nodesG1=getNodesInRegion(pdg1,predicate1,controlPredicateNodesG1,controlPredicateNodesInNextLevelG1,controlDependenceTreePDG1);
      if (level1 == 0 && !fullTreeMatch) {
        int maxId=allNodesInSubTreePDG1.last().getId();
        Set<PDGNode> nodesG1ToBeRemoved=new LinkedHashSet<PDGNode>();
        for (        PDGNode nodeG1 : nodesG1) {
          if (nodeG1.getId() > maxId) {
            nodesG1ToBeRemoved.add(nodeG1);
          }
          if (controlDependenceTreePDG1.isElseNode()) {
            double elseNodeId=controlDependenceTreePDG1.getId();
            if (nodeG1.getId() < elseNodeId) {
              nodesG1ToBeRemoved.add(nodeG1);
            }
          }
        }
        nodesG1.removeAll(nodesG1ToBeRemoved);
      }
      this.allNodesInSubTreePDG1.addAll(nodesG1);
      List<MappingState> currentStates=new ArrayList<MappingState>();
      for (      PDGNode predicate2 : controlPredicateNodesG2) {
        Set<PDGNode> nodesG2=getNodesInRegion(pdg2,predicate2,controlPredicateNodesG2,controlPredicateNodesInNextLevelG2,controlDependenceTreePDG2);
        if (level2 == 0 && !fullTreeMatch) {
          int maxId=allNodesInSubTreePDG2.last().getId();
          Set<PDGNode> nodesG2ToBeRemoved=new LinkedHashSet<PDGNode>();
          for (          PDGNode nodeG2 : nodesG2) {
            if (nodeG2.getId() > maxId) {
              nodesG2ToBeRemoved.add(nodeG2);
            }
            if (controlDependenceTreePDG2.isElseNode()) {
              double elseNodeId=controlDependenceTreePDG2.getId();
              if (nodeG2.getId() < elseNodeId) {
                nodesG2ToBeRemoved.add(nodeG2);
              }
            }
          }
          nodesG2.removeAll(nodesG2ToBeRemoved);
        }
        this.allNodesInSubTreePDG2.addAll(nodesG2);
        List<MappingState> maxStates=null;
        if (level1 == 0 || level2 == 0) {
          maxStates=matchBasedOnCodeFragments(finalState,nodesG1,nodesG2);
        }
 else {
          ControlDependenceTreeNode cdtNode1=controlDependenceTreePDG1.getNode(predicate1);
          ControlDependenceTreeNode cdtNode2=controlDependenceTreePDG2.getNode(predicate2);
          ControlDependenceTreeNode cdtNode1Parent=null;
          if (cdtNode1 != null)           cdtNode1Parent=cdtNode1.getParent();
          ControlDependenceTreeNode cdtNode2Parent=null;
          if (cdtNode2 != null)           cdtNode2Parent=cdtNode2.getParent();
          if (cdtNode1Parent != null && cdtNode2Parent != null && !cdtNode1Parent.equals(controlDependenceTreePDG1) && !cdtNode2Parent.equals(controlDependenceTreePDG2)) {
            if ((cdtNode1Parent.getNode() != null && cdtNode1Parent.getNode().getCFGNode() instanceof CFGBranchIfNode && cdtNode2Parent.isElseNode()) || (cdtNode2Parent.getNode() != null && cdtNode2Parent.getNode().getCFGNode() instanceof CFGBranchIfNode && cdtNode1Parent.isElseNode()))             continue;
          }
          if (predicate1.getASTStatement() instanceof SwitchStatement && predicate2.getASTStatement() instanceof SwitchStatement) {
            ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher(iCompilationUnit1,iCompilationUnit2);
            boolean match=astNodeMatcher.match(predicate1,predicate2);
            if (match && astNodeMatcher.isParameterizable()) {
              PDGNodeMapping mapping=new PDGNodeMapping(predicate1,predicate2,astNodeMatcher);
              MappingState state=new MappingState(finalState,mapping);
              if (finalState != null)               finalState.addChild(state);
              Set<PDGNode> switchBodyNodes1=new LinkedHashSet<PDGNode>(nodesG1);
              switchBodyNodes1.remove(predicate1);
              Set<PDGNode> switchBodyNodes2=new LinkedHashSet<PDGNode>(nodesG2);
              switchBodyNodes2.remove(predicate2);
              maxStates=matchBasedOnSwitchCases(state,switchBodyNodes1,switchBodyNodes2);
            }
          }
 else {
            maxStates=processPDGNodes(finalState,nodesG1,nodesG2);
          }
        }
        for (        MappingState temp : maxStates) {
          if (!currentStates.contains(temp)) {
            currentStates.add(temp);
          }
        }
      }
      if (!currentStates.isEmpty()) {
        MappingState best=findMaximumStateWithMinimumDifferences(currentStates);
        List<PDGNodeMapping> nodeMappings=new ArrayList<PDGNodeMapping>(best.getNodeMappings());
        int index=0;
        for (        PDGNodeMapping mapping : nodeMappings) {
          if (mapping.getNodeG1().equals(predicate1)) {
            controlPredicateNodesG2.remove(mapping.getNodeG2());
            break;
          }
          index++;
        }
        finalState=best;
        CloneStructureNode parent=null;
        CloneStructureNode newElseParent=null;
        for (int i=index; i < nodeMappings.size(); i++) {
          PDGNodeMapping mapping=nodeMappings.get(i);
          if (parent == null) {
            parent=new CloneStructureNode(mapping);
          }
 else {
            PDGTryNode nestedUnderTry1=pdg1.isDirectlyNestedWithinTryNode(mapping.getNodeG1());
            PDGTryNode nestedUnderTry2=pdg2.isDirectlyNestedWithinTryNode(mapping.getNodeG2());
            boolean nestedUnderTry=nestedUnderTry1 != null && nestedUnderTry2 != null;
            if (mapping.isFalseControlDependent() && !nestedUnderTry) {
              if (newElseParent == null) {
                ControlDependenceTreeNode elseNodeG1=controlDependenceTreePDG1.getElseNode(parent.getMapping().getNodeG1());
                ControlDependenceTreeNode elseNodeG2=controlDependenceTreePDG2.getElseNode(parent.getMapping().getNodeG2());
                if (elseNodeG1 != null && elseNodeG2 != null) {
                  PDGElseMapping elseMapping=new PDGElseMapping(elseNodeG1.getId(),elseNodeG2.getId());
                  newElseParent=new CloneStructureNode(elseMapping);
                  parent.addChild(newElseParent);
                  CloneStructureNode child=new CloneStructureNode(mapping);
                  newElseParent.addChild(child);
                }
              }
 else {
                CloneStructureNode child=new CloneStructureNode(mapping);
                newElseParent.addChild(child);
              }
            }
 else {
              CloneStructureNode child=new CloneStructureNode(mapping);
              parent.addChild(child);
            }
          }
        }
        if (parent != null) {
          PDGNodeMapping parentNodeMapping=(PDGNodeMapping)parent.getMapping();
          double parentId1=parentNodeMapping.getId1();
          double parentId2=parentNodeMapping.getId2();
          for (ListIterator<CloneStructureNode> parentIterator=parents.listIterator(); parentIterator.hasNext(); ) {
            CloneStructureNode previousParent=parentIterator.next();
            PDGNodeMapping previousParentNodeMapping=(PDGNodeMapping)previousParent.getMapping();
            double previousParentId1=previousParentNodeMapping.getId1();
            double previousParentId2=previousParentNodeMapping.getId2();
            if (controlDependenceTreePDG1.parentChildRelationship(parentId1,previousParentId1) && controlDependenceTreePDG2.parentChildRelationship(parentId2,previousParentId2)) {
              parent.addChild(previousParent);
              parentIterator.remove();
            }
 else             if (previousParentNodeMapping.isFalseControlDependent()) {
              if (newElseParent == null) {
                ControlDependenceTreeNode elseNodeG1=controlDependenceTreePDG1.getElseNode(parentNodeMapping.getNodeG1());
                ControlDependenceTreeNode elseNodeG2=controlDependenceTreePDG2.getElseNode(parentNodeMapping.getNodeG2());
                if (elseNodeG1 != null && elseNodeG2 != null) {
                  if (controlDependenceTreePDG1.parentChildRelationship(elseNodeG1.getId(),previousParentId1) && controlDependenceTreePDG2.parentChildRelationship(elseNodeG2.getId(),previousParentId2)) {
                    PDGElseMapping elseMapping=new PDGElseMapping(elseNodeG1.getId(),elseNodeG2.getId());
                    newElseParent=new CloneStructureNode(elseMapping);
                    parent.addChild(newElseParent);
                    newElseParent.addChild(previousParent);
                    parentIterator.remove();
                  }
                }
              }
 else {
                PDGElseMapping elseMapping=(PDGElseMapping)newElseParent.getMapping();
                if (controlDependenceTreePDG1.parentChildRelationship(elseMapping.getId1(),previousParentId1) && controlDependenceTreePDG2.parentChildRelationship(elseMapping.getId2(),previousParentId2)) {
                  newElseParent.addChild(previousParent);
                  parentIterator.remove();
                }
              }
            }
          }
          boolean isTryBlock=(parentNodeMapping.getNodeG1() instanceof PDGTryNode) && (parentNodeMapping.getNodeG2() instanceof PDGTryNode);
          if (!parent.getChildren().isEmpty() || isTryBlock) {
            parents.add(parent);
          }
 else {
            finalState.getNodeMappings().remove(parent.getMapping());
          }
        }
 else {
          root=new CloneStructureNode(null);
          for (ListIterator<CloneStructureNode> parentIterator=parents.listIterator(); parentIterator.hasNext(); ) {
            CloneStructureNode previousParent=parentIterator.next();
            root.addChild(previousParent);
            parentIterator.remove();
          }
          for (          PDGNodeMapping nodeMapping : best.getNodeMappings()) {
            if (nodesG1.contains(nodeMapping.getNodeG1())) {
              CloneStructureNode childNode=new CloneStructureNode(nodeMapping);
              root.addChild(childNode);
            }
          }
        }
      }
    }
    level1--;
    level2--;
    if (monitor != null)     monitor.worked(1);
  }
  if (monitor != null)   monitor.done();
  if (root == null) {
    root=new CloneStructureNode(null);
    for (ListIterator<CloneStructureNode> parentIterator=parents.listIterator(); parentIterator.hasNext(); ) {
      CloneStructureNode previousParent=parentIterator.next();
      root.addChild(previousParent);
      parentIterator.remove();
    }
  }
  this.maximumStateWithMinimumDifferences=finalState;
  this.cloneStructureRoot=root;
}"
12094,"public void createControl(Composite parent){
  Composite result=new Composite(parent,SWT.NONE);
  setControl(result);
  GridLayout gridLayout=new GridLayout(6,true);
  result.setLayout(gridLayout);
  Label methodLeftName=new Label(result,SWT.WRAP);
  methodLeftName.setText(mapper.getPDG1().getMethod().toString());
  methodLeftName.setFont(new Font(parent.getDisplay(),new FontData(""String_Node_Str"",9,SWT.NORMAL)));
  GridData methodLeftNameGridData=new GridData(SWT.LEFT,SWT.FILL,true,false);
  methodLeftNameGridData.horizontalSpan=3;
  methodLeftName.setLayoutData(methodLeftNameGridData);
  Label methodRightName=new Label(result,SWT.WRAP);
  methodRightName.setText(mapper.getPDG2().getMethod().toString());
  methodRightName.setFont(new Font(parent.getDisplay(),new FontData(""String_Node_Str"",9,SWT.NORMAL)));
  GridData methodRightNameGridData=new GridData(SWT.LEFT,SWT.FILL,true,false);
  methodRightNameGridData.horizontalSpan=3;
  methodRightName.setLayoutData(methodRightNameGridData);
  final TreeViewer treeViewerLeft=new TreeViewer(result,SWT.PUSH | SWT.V_SCROLL | SWT.H_SCROLL);
  treeViewerLeft.setLabelProvider(new CloneDiffStyledLabelProvider(CloneDiffSide.LEFT));
  treeViewerLeft.setContentProvider(new CloneDiffContentProvider());
  treeViewerLeft.setInput(new CloneStructureNode[]{cloneStructureRoot});
  treeViewerLeft.getTree().setLinesVisible(true);
  treeViewerLeft.expandAll();
  GridData treeLeftGridData=new GridData(SWT.FILL,SWT.FILL,true,true);
  treeLeftGridData.horizontalAlignment=SWT.FILL;
  treeLeftGridData.verticalAlignment=SWT.FILL;
  treeLeftGridData.horizontalSpan=3;
  treeViewerLeft.getTree().setLayoutData(treeLeftGridData);
  final TreeViewer treeViewerRight=new TreeViewer(result,SWT.PUSH | SWT.V_SCROLL | SWT.H_SCROLL);
  treeViewerRight.setLabelProvider(new CloneDiffStyledLabelProvider(CloneDiffSide.RIGHT));
  treeViewerRight.setContentProvider(new CloneDiffContentProvider());
  treeViewerRight.setInput(new CloneStructureNode[]{cloneStructureRoot});
  treeViewerRight.getTree().setLinesVisible(true);
  treeViewerRight.expandAll();
  GridData treeRightGridData=new GridData(SWT.FILL,SWT.FILL,true,true);
  treeRightGridData.horizontalAlignment=SWT.FILL;
  treeRightGridData.verticalAlignment=SWT.FILL;
  treeRightGridData.horizontalSpan=3;
  treeViewerRight.getTree().setLayoutData(treeRightGridData);
  final Group legend=new Group(result,SWT.SHADOW_NONE);
  legend.setText(""String_Node_Str"");
  GridData legendGridData=new GridData(SWT.LEFT,SWT.FILL,true,false);
  legendGridData.horizontalSpan=2;
  legendGridData.verticalSpan=5;
  legend.setLayoutData(legendGridData);
  GridLayout legendLayout=new GridLayout();
  legendLayout.numColumns=2;
  legend.setLayout(legendLayout);
  CLabel unmappedStatementsLegendColor=new CLabel(legend,SWT.NONE);
  unmappedStatementsLegendColor.setText(""String_Node_Str"");
  unmappedStatementsLegendColor.setBackground(new Color(null,255,156,156));
  CLabel unmappedStatementsLegendLabel=new CLabel(legend,SWT.NONE);
  unmappedStatementsLegendLabel.setText(""String_Node_Str"");
  CLabel differencesLegendColor=new CLabel(legend,SWT.NONE);
  differencesLegendColor.setText(""String_Node_Str"");
  differencesLegendColor.setBackground(new Color(null,255,255,200));
  CLabel differencesLegendLabel=new CLabel(legend,SWT.NONE);
  differencesLegendLabel.setText(""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") CloneDiffTooltip tooltipLeft=new CloneDiffTooltip(treeViewerLeft,ToolTip.NO_RECREATE,false);
  @SuppressWarnings(""String_Node_Str"") CloneDiffTooltip tooltipRight=new CloneDiffTooltip(treeViewerRight,ToolTip.NO_RECREATE,false);
  treeViewerLeft.addPostSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      if (!correspondingTreeAlreadyChanged) {
        TreeSelection treeSelection=(TreeSelection)event.getSelection();
        correspondingTreeAlreadyChanged=true;
        treeViewerRight.setSelection(treeSelection);
        correspondingTreeAlreadyChanged=false;
      }
      return;
    }
  }
);
  treeViewerRight.addPostSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      if (!correspondingTreeAlreadyChanged) {
        TreeSelection treeSelection=(TreeSelection)event.getSelection();
        correspondingTreeAlreadyChanged=true;
        treeViewerLeft.setSelection(treeSelection);
        correspondingTreeAlreadyChanged=false;
      }
      return;
    }
  }
);
  treeViewerLeft.addTreeListener(new ITreeViewerListener(){
    public void treeExpanded(    TreeExpansionEvent event){
      CloneStructureNode nodeExpanded=(CloneStructureNode)event.getElement();
      treeViewerRight.expandToLevel(nodeExpanded,1);
    }
    public void treeCollapsed(    TreeExpansionEvent event){
      CloneStructureNode nodeCollapsed=(CloneStructureNode)event.getElement();
      treeViewerRight.collapseToLevel(nodeCollapsed,1);
    }
  }
);
  treeViewerRight.addTreeListener(new ITreeViewerListener(){
    public void treeExpanded(    TreeExpansionEvent event){
      CloneStructureNode nodeExpanded=(CloneStructureNode)event.getElement();
      treeViewerLeft.expandToLevel(nodeExpanded,1);
    }
    public void treeCollapsed(    TreeExpansionEvent event){
      CloneStructureNode nodeCollapsed=(CloneStructureNode)event.getElement();
      treeViewerLeft.collapseToLevel(nodeCollapsed,1);
    }
  }
);
  ScrollBar leftVertical=treeViewerLeft.getTree().getVerticalBar();
  leftVertical.addListener(SWT.Selection,new Listener(){
    public void handleEvent(    Event event){
      treeViewerRight.getTree().setTopItem(treeViewerLeft.getTree().getTopItem());
    }
  }
);
  ScrollBar rightVertical=treeViewerRight.getTree().getVerticalBar();
  rightVertical.addListener(SWT.Selection,new Listener(){
    public void handleEvent(    Event event){
      treeViewerLeft.getTree().setTopItem(treeViewerRight.getTree().getTopItem());
    }
  }
);
  final ScrollBar leftHorizontal=treeViewerLeft.getTree().getHorizontalBar();
  final ScrollBar rightHorizontal=treeViewerRight.getTree().getHorizontalBar();
  leftHorizontal.addListener(SWT.Selection,new Listener(){
    public void handleEvent(    Event event){
      rightHorizontal.setValues(leftHorizontal.getSelection(),leftHorizontal.getMinimum(),leftHorizontal.getMaximum(),leftHorizontal.getThumb(),leftHorizontal.getIncrement(),leftHorizontal.getPageIncrement());
    }
  }
);
  rightHorizontal.addListener(SWT.Selection,new Listener(){
    public void handleEvent(    Event event){
      leftHorizontal.setValues(rightHorizontal.getSelection(),rightHorizontal.getMinimum(),rightHorizontal.getMaximum(),rightHorizontal.getThumb(),rightHorizontal.getIncrement(),rightHorizontal.getPageIncrement());
    }
  }
);
}","public void createControl(Composite parent){
  Composite result=new Composite(parent,SWT.NONE);
  setControl(result);
  GridLayout gridLayout=new GridLayout(6,true);
  result.setLayout(gridLayout);
  Label methodLeftName=new Label(result,SWT.WRAP);
  methodLeftName.setText(mapper.getPDG1().getMethod().toString());
  methodLeftName.setFont(new Font(parent.getDisplay(),new FontData(""String_Node_Str"",9,SWT.NORMAL)));
  GridData methodLeftNameGridData=new GridData(SWT.LEFT,SWT.FILL,true,false);
  methodLeftNameGridData.horizontalSpan=3;
  methodLeftName.setLayoutData(methodLeftNameGridData);
  Label methodRightName=new Label(result,SWT.WRAP);
  methodRightName.setText(mapper.getPDG2().getMethod().toString());
  methodRightName.setFont(new Font(parent.getDisplay(),new FontData(""String_Node_Str"",9,SWT.NORMAL)));
  GridData methodRightNameGridData=new GridData(SWT.LEFT,SWT.FILL,true,false);
  methodRightNameGridData.horizontalSpan=3;
  methodRightName.setLayoutData(methodRightNameGridData);
  final TreeViewer treeViewerLeft=new TreeViewer(result,SWT.PUSH | SWT.V_SCROLL | SWT.H_SCROLL);
  treeViewerLeft.setLabelProvider(new CloneDiffStyledLabelProvider(CloneDiffSide.LEFT));
  treeViewerLeft.setContentProvider(new CloneDiffContentProvider());
  treeViewerLeft.setInput(new CloneStructureNode[]{cloneStructureRoot});
  treeViewerLeft.getTree().setLinesVisible(true);
  treeViewerLeft.expandAll();
  GridData treeLeftGridData=new GridData(SWT.FILL,SWT.FILL,true,true);
  treeLeftGridData.horizontalAlignment=SWT.FILL;
  treeLeftGridData.verticalAlignment=SWT.FILL;
  treeLeftGridData.horizontalSpan=3;
  treeViewerLeft.getTree().setLayoutData(treeLeftGridData);
  final TreeViewer treeViewerRight=new TreeViewer(result,SWT.PUSH | SWT.V_SCROLL | SWT.H_SCROLL);
  treeViewerRight.setLabelProvider(new CloneDiffStyledLabelProvider(CloneDiffSide.RIGHT));
  treeViewerRight.setContentProvider(new CloneDiffContentProvider());
  treeViewerRight.setInput(new CloneStructureNode[]{cloneStructureRoot});
  treeViewerRight.getTree().setLinesVisible(true);
  treeViewerRight.expandAll();
  GridData treeRightGridData=new GridData(SWT.FILL,SWT.FILL,true,true);
  treeRightGridData.horizontalAlignment=SWT.FILL;
  treeRightGridData.verticalAlignment=SWT.FILL;
  treeRightGridData.horizontalSpan=3;
  treeViewerRight.getTree().setLayoutData(treeRightGridData);
  final Group legend=new Group(result,SWT.SHADOW_NONE);
  legend.setText(""String_Node_Str"");
  GridData legendGridData=new GridData(SWT.LEFT,SWT.FILL,true,false);
  legendGridData.horizontalSpan=2;
  legendGridData.verticalSpan=5;
  legend.setLayoutData(legendGridData);
  GridLayout legendLayout=new GridLayout();
  legendLayout.numColumns=2;
  legend.setLayout(legendLayout);
  CLabel unmappedStatementsLegendColor=new CLabel(legend,SWT.NONE);
  unmappedStatementsLegendColor.setText(""String_Node_Str"");
  unmappedStatementsLegendColor.setBackground(new Color(null,255,156,156));
  CLabel unmappedStatementsLegendLabel=new CLabel(legend,SWT.NONE);
  unmappedStatementsLegendLabel.setText(""String_Node_Str"");
  CLabel differencesLegendColor=new CLabel(legend,SWT.NONE);
  differencesLegendColor.setText(""String_Node_Str"");
  differencesLegendColor.setBackground(new Color(null,255,255,200));
  CLabel differencesLegendLabel=new CLabel(legend,SWT.NONE);
  differencesLegendLabel.setText(""String_Node_Str"");
  Set<BindingSignaturePair> renamedVariableBindingSignaturePairs=mapper.getRenamedVariables();
  if (renamedVariableBindingSignaturePairs.size() > 0) {
    final Group renamedVariables=new Group(result,SWT.SHADOW_NONE);
    renamedVariables.setText(""String_Node_Str"");
    GridData renamedVariablesGridData=new GridData(SWT.LEFT,SWT.FILL,true,false);
    renamedVariablesGridData.horizontalSpan=3;
    renamedVariablesGridData.verticalSpan=5;
    renamedVariables.setLayoutData(renamedVariablesGridData);
    GridLayout renamedVariablesLayout=new GridLayout();
    renamedVariablesLayout.numColumns=3;
    renamedVariables.setLayout(renamedVariablesLayout);
    for (    BindingSignaturePair bindingSignaturePair : renamedVariableBindingSignaturePairs) {
      CLabel renamedVariableLabel=new CLabel(renamedVariables,SWT.NONE);
      String signature1=bindingSignaturePair.getSignature1().toString();
      String variable1=signature1.substring(signature1.lastIndexOf(""String_Node_Str"") + 1,signature1.length() - 1);
      String signature2=bindingSignaturePair.getSignature2().toString();
      String variable2=signature2.substring(signature2.lastIndexOf(""String_Node_Str"") + 1,signature2.length() - 1);
      renamedVariableLabel.setText(variable1 + ""String_Node_Str"" + variable2);
      renamedVariableLabel.setFont(new Font(parent.getDisplay(),new FontData(""String_Node_Str"",9,SWT.BOLD)));
    }
  }
  @SuppressWarnings(""String_Node_Str"") CloneDiffTooltip tooltipLeft=new CloneDiffTooltip(treeViewerLeft,ToolTip.NO_RECREATE,false);
  @SuppressWarnings(""String_Node_Str"") CloneDiffTooltip tooltipRight=new CloneDiffTooltip(treeViewerRight,ToolTip.NO_RECREATE,false);
  treeViewerLeft.addPostSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      if (!correspondingTreeAlreadyChanged) {
        TreeSelection treeSelection=(TreeSelection)event.getSelection();
        correspondingTreeAlreadyChanged=true;
        treeViewerRight.setSelection(treeSelection);
        correspondingTreeAlreadyChanged=false;
      }
      return;
    }
  }
);
  treeViewerRight.addPostSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      if (!correspondingTreeAlreadyChanged) {
        TreeSelection treeSelection=(TreeSelection)event.getSelection();
        correspondingTreeAlreadyChanged=true;
        treeViewerLeft.setSelection(treeSelection);
        correspondingTreeAlreadyChanged=false;
      }
      return;
    }
  }
);
  treeViewerLeft.addTreeListener(new ITreeViewerListener(){
    public void treeExpanded(    TreeExpansionEvent event){
      CloneStructureNode nodeExpanded=(CloneStructureNode)event.getElement();
      treeViewerRight.expandToLevel(nodeExpanded,1);
    }
    public void treeCollapsed(    TreeExpansionEvent event){
      CloneStructureNode nodeCollapsed=(CloneStructureNode)event.getElement();
      treeViewerRight.collapseToLevel(nodeCollapsed,1);
    }
  }
);
  treeViewerRight.addTreeListener(new ITreeViewerListener(){
    public void treeExpanded(    TreeExpansionEvent event){
      CloneStructureNode nodeExpanded=(CloneStructureNode)event.getElement();
      treeViewerLeft.expandToLevel(nodeExpanded,1);
    }
    public void treeCollapsed(    TreeExpansionEvent event){
      CloneStructureNode nodeCollapsed=(CloneStructureNode)event.getElement();
      treeViewerLeft.collapseToLevel(nodeCollapsed,1);
    }
  }
);
  ScrollBar leftVertical=treeViewerLeft.getTree().getVerticalBar();
  leftVertical.addListener(SWT.Selection,new Listener(){
    public void handleEvent(    Event event){
      treeViewerRight.getTree().setTopItem(treeViewerLeft.getTree().getTopItem());
    }
  }
);
  ScrollBar rightVertical=treeViewerRight.getTree().getVerticalBar();
  rightVertical.addListener(SWT.Selection,new Listener(){
    public void handleEvent(    Event event){
      treeViewerLeft.getTree().setTopItem(treeViewerRight.getTree().getTopItem());
    }
  }
);
  final ScrollBar leftHorizontal=treeViewerLeft.getTree().getHorizontalBar();
  final ScrollBar rightHorizontal=treeViewerRight.getTree().getHorizontalBar();
  leftHorizontal.addListener(SWT.Selection,new Listener(){
    public void handleEvent(    Event event){
      rightHorizontal.setValues(leftHorizontal.getSelection(),leftHorizontal.getMinimum(),leftHorizontal.getMaximum(),leftHorizontal.getThumb(),leftHorizontal.getIncrement(),leftHorizontal.getPageIncrement());
    }
  }
);
  rightHorizontal.addListener(SWT.Selection,new Listener(){
    public void handleEvent(    Event event){
      leftHorizontal.setValues(rightHorizontal.getSelection(),rightHorizontal.getMinimum(),rightHorizontal.getMaximum(),rightHorizontal.getThumb(),rightHorizontal.getIncrement(),rightHorizontal.getPageIncrement());
    }
  }
);
}"
12095,"private void processArgumentOfInternalMethodInvocation(MethodObject methodObject,AbstractVariable argumentDeclaration,int initialArgumentPosition,VariableDeclaration parameterDeclaration,Set<String> processedMethods){
  SystemObject systemObject=ASTReader.getSystemObject();
  if (methodObject.getMethodBody() == null) {
    IMethodBinding superMethodDeclarationBinding=methodObject.getMethodDeclaration().resolveBinding();
    IType superType=(IType)superMethodDeclarationBinding.getDeclaringClass().getJavaElement();
    processedMethods.add(superMethodDeclarationBinding.getKey());
    Set<IType> subTypes=CompilationUnitCache.getInstance().getSubTypes(superType);
    for (    IType subType : subTypes) {
      ClassObject subClassObject=systemObject.getClassObject(subType.getFullyQualifiedName('.'));
      if (subClassObject != null) {
        ListIterator<MethodObject> methodIterator=subClassObject.getMethodIterator();
        while (methodIterator.hasNext()) {
          MethodObject subMethod=methodIterator.next();
          if (equalSignature(subMethod.getMethodDeclaration().resolveBinding(),superMethodDeclarationBinding)) {
            ParameterObject parameterObject=subMethod.getParameter(initialArgumentPosition);
            VariableDeclaration parameterDeclaration2=parameterObject.getSingleVariableDeclaration();
            processArgumentOfInternalMethodInvocation(subMethod,argumentDeclaration,initialArgumentPosition,parameterDeclaration2,processedMethods);
            break;
          }
        }
      }
    }
  }
 else {
    for (    AbstractVariable originalField : methodObject.getDefinedFieldsThroughParameters()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(originalField.getVariableBindingKey())) {
        AbstractVariable field=new CompositeVariable(argumentDeclaration.getVariableBindingKey(),argumentDeclaration.getVariableName(),argumentDeclaration.getVariableType(),argumentDeclaration.isField(),argumentDeclaration.isParameter(),((CompositeVariable)originalField).getRightPart());
        definedVariables.add(field);
      }
    }
    for (    AbstractVariable originalField : methodObject.getUsedFieldsThroughParameters()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(originalField.getVariableBindingKey())) {
        AbstractVariable field=new CompositeVariable(argumentDeclaration.getVariableBindingKey(),argumentDeclaration.getVariableName(),argumentDeclaration.getVariableType(),argumentDeclaration.isField(),argumentDeclaration.isParameter(),((CompositeVariable)originalField).getRightPart());
        usedVariables.add(field);
      }
    }
    processedMethods.add(methodObject.getMethodDeclaration().resolveBinding().getKey());
    Map<AbstractVariable,LinkedHashSet<MethodInvocationObject>> invokedMethodsThroughParameters=methodObject.getInvokedMethodsThroughParameters();
    for (    AbstractVariable originalField : invokedMethodsThroughParameters.keySet()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(originalField.getVariableBindingKey())) {
        AbstractVariable field=null;
        if (originalField instanceof PlainVariable)         field=argumentDeclaration;
 else         field=new CompositeVariable(argumentDeclaration.getVariableBindingKey(),argumentDeclaration.getVariableName(),argumentDeclaration.getVariableType(),argumentDeclaration.isField(),argumentDeclaration.isParameter(),((CompositeVariable)originalField).getRightPart());
        LinkedHashSet<MethodInvocationObject> methodInvocations=invokedMethodsThroughParameters.get(originalField);
        for (        MethodInvocationObject methodInvocationObject : methodInvocations) {
          MethodInvocation methodInvocation2=methodInvocationObject.getMethodInvocation();
          ClassObject classObject2=systemObject.getClassObject(methodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(methodInvocationObject);
            if (methodObject2 != null) {
              processInternalMethodInvocation(classObject2,methodObject2,field,new LinkedHashSet<String>());
            }
          }
 else {
            LibraryClassStorage instance=LibraryClassStorage.getInstance();
            IMethodBinding invokedMethodBinding=methodInvocation2.resolveMethodBinding();
            if (instance.isAnalyzed(invokedMethodBinding.getKey())) {
              handleAlreadyAnalyzedMethod(invokedMethodBinding.getKey(),field,instance);
            }
 else {
              MethodDeclaration invokedMethodDeclaration=getInvokedMethodDeclaration(invokedMethodBinding);
              if (invokedMethodDeclaration != null)               processExternalMethodInvocation(invokedMethodDeclaration,field,new LinkedHashSet<String>(),0);
            }
          }
        }
      }
    }
    Map<PlainVariable,LinkedHashSet<MethodInvocationObject>> parametersPassedAsArgumentsInMethodInvocations=methodObject.getParametersPassedAsArgumentsInMethodInvocations();
    for (    PlainVariable parameter : parametersPassedAsArgumentsInMethodInvocations.keySet()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(parameter.getVariableBindingKey())) {
        LinkedHashSet<MethodInvocationObject> methodInvocations=parametersPassedAsArgumentsInMethodInvocations.get(parameter);
        for (        MethodInvocationObject methodInvocationObject : methodInvocations) {
          ClassObject classObject2=systemObject.getClassObject(methodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(methodInvocationObject);
            if (methodObject2 != null && !methodObject2.equals(methodObject)) {
              MethodInvocation methodInvocation2=methodInvocationObject.getMethodInvocation();
              int argumentPosition=getArgumentPosition(methodInvocation2.arguments(),parameter);
              ParameterObject parameterObject=methodObject2.getParameter(argumentPosition);
              VariableDeclaration parameterDeclaration2=parameterObject.getSingleVariableDeclaration();
              if (!processedMethods.contains(methodInvocation2.resolveMethodBinding().getKey()))               processArgumentOfInternalMethodInvocation(methodObject2,argumentDeclaration,argumentPosition,parameterDeclaration2,processedMethods);
            }
          }
        }
      }
    }
    Map<PlainVariable,LinkedHashSet<SuperMethodInvocationObject>> parametersPassedAsArgumentsInSuperMethodInvocations=methodObject.getParametersPassedAsArgumentsInSuperMethodInvocations();
    for (    PlainVariable parameter : parametersPassedAsArgumentsInSuperMethodInvocations.keySet()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(parameter.getVariableBindingKey())) {
        LinkedHashSet<SuperMethodInvocationObject> superMethodInvocations=parametersPassedAsArgumentsInSuperMethodInvocations.get(parameter);
        for (        SuperMethodInvocationObject superMethodInvocationObject : superMethodInvocations) {
          ClassObject classObject2=systemObject.getClassObject(superMethodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(superMethodInvocationObject);
            if (methodObject2 != null) {
              SuperMethodInvocation superMethodInvocation=superMethodInvocationObject.getSuperMethodInvocation();
              int argumentPosition=getArgumentPosition(superMethodInvocation.arguments(),parameter);
              ParameterObject parameterObject=methodObject2.getParameter(argumentPosition);
              VariableDeclaration parameterDeclaration2=parameterObject.getSingleVariableDeclaration();
              if (!processedMethods.contains(superMethodInvocation.resolveMethodBinding().getKey()))               processArgumentOfInternalMethodInvocation(methodObject2,argumentDeclaration,argumentPosition,parameterDeclaration2,processedMethods);
            }
          }
        }
      }
    }
  }
}","private void processArgumentOfInternalMethodInvocation(MethodObject methodObject,AbstractVariable argumentDeclaration,int initialArgumentPosition,VariableDeclaration parameterDeclaration,Set<String> processedMethods){
  SystemObject systemObject=ASTReader.getSystemObject();
  if (methodObject.getMethodBody() == null) {
    IMethodBinding superMethodDeclarationBinding=methodObject.getMethodDeclaration().resolveBinding();
    IType superType=(IType)superMethodDeclarationBinding.getDeclaringClass().getJavaElement();
    processedMethods.add(superMethodDeclarationBinding.getKey());
    Set<IType> subTypes=CompilationUnitCache.getInstance().getSubTypes(superType);
    for (    IType subType : subTypes) {
      ClassObject subClassObject=systemObject.getClassObject(subType.getFullyQualifiedName('.'));
      if (subClassObject != null) {
        ListIterator<MethodObject> methodIterator=subClassObject.getMethodIterator();
        while (methodIterator.hasNext()) {
          MethodObject subMethod=methodIterator.next();
          if (equalSignature(subMethod.getMethodDeclaration().resolveBinding(),superMethodDeclarationBinding)) {
            ParameterObject parameterObject=subMethod.getParameter(initialArgumentPosition);
            VariableDeclaration parameterDeclaration2=parameterObject.getSingleVariableDeclaration();
            if (!processedMethods.contains(subMethod.getMethodDeclaration().resolveBinding().getKey()))             processArgumentOfInternalMethodInvocation(subMethod,argumentDeclaration,initialArgumentPosition,parameterDeclaration2,processedMethods);
            break;
          }
        }
      }
    }
  }
 else {
    for (    AbstractVariable originalField : methodObject.getDefinedFieldsThroughParameters()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(originalField.getVariableBindingKey())) {
        AbstractVariable field=new CompositeVariable(argumentDeclaration.getVariableBindingKey(),argumentDeclaration.getVariableName(),argumentDeclaration.getVariableType(),argumentDeclaration.isField(),argumentDeclaration.isParameter(),((CompositeVariable)originalField).getRightPart());
        definedVariables.add(field);
      }
    }
    for (    AbstractVariable originalField : methodObject.getUsedFieldsThroughParameters()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(originalField.getVariableBindingKey())) {
        AbstractVariable field=new CompositeVariable(argumentDeclaration.getVariableBindingKey(),argumentDeclaration.getVariableName(),argumentDeclaration.getVariableType(),argumentDeclaration.isField(),argumentDeclaration.isParameter(),((CompositeVariable)originalField).getRightPart());
        usedVariables.add(field);
      }
    }
    processedMethods.add(methodObject.getMethodDeclaration().resolveBinding().getKey());
    Map<AbstractVariable,LinkedHashSet<MethodInvocationObject>> invokedMethodsThroughParameters=methodObject.getInvokedMethodsThroughParameters();
    for (    AbstractVariable originalField : invokedMethodsThroughParameters.keySet()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(originalField.getVariableBindingKey())) {
        AbstractVariable field=null;
        if (originalField instanceof PlainVariable)         field=argumentDeclaration;
 else         field=new CompositeVariable(argumentDeclaration.getVariableBindingKey(),argumentDeclaration.getVariableName(),argumentDeclaration.getVariableType(),argumentDeclaration.isField(),argumentDeclaration.isParameter(),((CompositeVariable)originalField).getRightPart());
        LinkedHashSet<MethodInvocationObject> methodInvocations=invokedMethodsThroughParameters.get(originalField);
        for (        MethodInvocationObject methodInvocationObject : methodInvocations) {
          MethodInvocation methodInvocation2=methodInvocationObject.getMethodInvocation();
          ClassObject classObject2=systemObject.getClassObject(methodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(methodInvocationObject);
            if (methodObject2 != null) {
              processInternalMethodInvocation(classObject2,methodObject2,field,new LinkedHashSet<String>());
            }
          }
 else {
            LibraryClassStorage instance=LibraryClassStorage.getInstance();
            IMethodBinding invokedMethodBinding=methodInvocation2.resolveMethodBinding();
            if (instance.isAnalyzed(invokedMethodBinding.getKey())) {
              handleAlreadyAnalyzedMethod(invokedMethodBinding.getKey(),field,instance);
            }
 else {
              MethodDeclaration invokedMethodDeclaration=getInvokedMethodDeclaration(invokedMethodBinding);
              if (invokedMethodDeclaration != null)               processExternalMethodInvocation(invokedMethodDeclaration,field,new LinkedHashSet<String>(),0);
            }
          }
        }
      }
    }
    Map<PlainVariable,LinkedHashSet<MethodInvocationObject>> parametersPassedAsArgumentsInMethodInvocations=methodObject.getParametersPassedAsArgumentsInMethodInvocations();
    for (    PlainVariable parameter : parametersPassedAsArgumentsInMethodInvocations.keySet()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(parameter.getVariableBindingKey())) {
        LinkedHashSet<MethodInvocationObject> methodInvocations=parametersPassedAsArgumentsInMethodInvocations.get(parameter);
        for (        MethodInvocationObject methodInvocationObject : methodInvocations) {
          ClassObject classObject2=systemObject.getClassObject(methodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(methodInvocationObject);
            if (methodObject2 != null && !methodObject2.equals(methodObject)) {
              MethodInvocation methodInvocation2=methodInvocationObject.getMethodInvocation();
              int argumentPosition=getArgumentPosition(methodInvocation2.arguments(),parameter);
              ParameterObject parameterObject=methodObject2.getParameter(argumentPosition);
              VariableDeclaration parameterDeclaration2=parameterObject.getSingleVariableDeclaration();
              if (!processedMethods.contains(methodInvocation2.resolveMethodBinding().getKey()))               processArgumentOfInternalMethodInvocation(methodObject2,argumentDeclaration,argumentPosition,parameterDeclaration2,processedMethods);
            }
          }
        }
      }
    }
    Map<PlainVariable,LinkedHashSet<SuperMethodInvocationObject>> parametersPassedAsArgumentsInSuperMethodInvocations=methodObject.getParametersPassedAsArgumentsInSuperMethodInvocations();
    for (    PlainVariable parameter : parametersPassedAsArgumentsInSuperMethodInvocations.keySet()) {
      if (parameterDeclaration.resolveBinding().getKey().equals(parameter.getVariableBindingKey())) {
        LinkedHashSet<SuperMethodInvocationObject> superMethodInvocations=parametersPassedAsArgumentsInSuperMethodInvocations.get(parameter);
        for (        SuperMethodInvocationObject superMethodInvocationObject : superMethodInvocations) {
          ClassObject classObject2=systemObject.getClassObject(superMethodInvocationObject.getOriginClassName());
          if (classObject2 != null) {
            MethodObject methodObject2=classObject2.getMethod(superMethodInvocationObject);
            if (methodObject2 != null) {
              SuperMethodInvocation superMethodInvocation=superMethodInvocationObject.getSuperMethodInvocation();
              int argumentPosition=getArgumentPosition(superMethodInvocation.arguments(),parameter);
              ParameterObject parameterObject=methodObject2.getParameter(argumentPosition);
              VariableDeclaration parameterDeclaration2=parameterObject.getSingleVariableDeclaration();
              if (!processedMethods.contains(superMethodInvocation.resolveMethodBinding().getKey()))               processArgumentOfInternalMethodInvocation(methodObject2,argumentDeclaration,argumentPosition,parameterDeclaration2,processedMethods);
            }
          }
        }
      }
    }
  }
}"
12096,"private void matchBasedOnControlDependenceTreeStructure(ControlDependenceTreeNode controlDependenceTreePDG1,ControlDependenceTreeNode controlDependenceTreePDG2){
  int maxLevel1=controlDependenceTreePDG1.getMaxLevel();
  int level1=maxLevel1;
  int maxLevel2=controlDependenceTreePDG2.getMaxLevel();
  int level2=maxLevel2;
  if (monitor != null)   monitor.beginTask(""String_Node_Str"",Math.min(maxLevel1,maxLevel2));
  CloneStructureNode root=null;
  MappingState finalState=null;
  List<CloneStructureNode> parents=new ArrayList<CloneStructureNode>();
  while (level1 >= 0 && level2 >= 0) {
    Set<PDGNode> controlPredicateNodesG1=controlDependenceTreePDG1.getControlPredicateNodesInLevel(level1);
    Set<PDGNode> controlPredicateNodesG2=controlDependenceTreePDG2.getControlPredicateNodesInLevel(level2);
    Set<PDGNode> controlPredicateNodesInNextLevelG1=new LinkedHashSet<PDGNode>();
    Set<PDGNode> controlPredicateNodesInNextLevelG2=new LinkedHashSet<PDGNode>();
    if (level1 < maxLevel1) {
      Set<PDGNode> nodesInNextLevel=controlDependenceTreePDG1.getControlPredicateNodesInLevel(level1 + 1);
      controlPredicateNodesInNextLevelG1.addAll(nodesInNextLevel);
      for (      PDGNode node : nodesInNextLevel) {
        if (node instanceof PDGTryNode) {
          controlPredicateNodesInNextLevelG1.addAll(pdg1.getNestedNodesWithinTryNode((PDGTryNode)node));
        }
      }
    }
    if (level2 < maxLevel2) {
      Set<PDGNode> nodesInNextLevel=controlDependenceTreePDG2.getControlPredicateNodesInLevel(level2 + 1);
      controlPredicateNodesInNextLevelG2.addAll(nodesInNextLevel);
      for (      PDGNode node : nodesInNextLevel) {
        if (node instanceof PDGTryNode) {
          controlPredicateNodesInNextLevelG2.addAll(pdg2.getNestedNodesWithinTryNode((PDGTryNode)node));
        }
      }
    }
    for (    PDGNode predicate1 : controlPredicateNodesG1) {
      Set<PDGNode> nodesG1=getNodesInRegion(pdg1,predicate1,controlPredicateNodesG1,controlPredicateNodesInNextLevelG1,controlDependenceTreePDG1);
      if (level1 == 0 && !fullTreeMatch) {
        int maxId=allNodesInSubTreePDG1.last().getId();
        Set<PDGNode> nodesG1ToBeRemoved=new LinkedHashSet<PDGNode>();
        for (        PDGNode nodeG1 : nodesG1) {
          if (nodeG1.getId() > maxId) {
            nodesG1ToBeRemoved.add(nodeG1);
          }
          if (controlDependenceTreePDG1.isElseNode()) {
            double elseNodeId=controlDependenceTreePDG1.getId();
            if (nodeG1.getId() < elseNodeId) {
              nodesG1ToBeRemoved.add(nodeG1);
            }
          }
        }
        nodesG1.removeAll(nodesG1ToBeRemoved);
      }
      this.allNodesInSubTreePDG1.addAll(nodesG1);
      List<MappingState> currentStates=new ArrayList<MappingState>();
      for (      PDGNode predicate2 : controlPredicateNodesG2) {
        Set<PDGNode> nodesG2=getNodesInRegion(pdg2,predicate2,controlPredicateNodesG2,controlPredicateNodesInNextLevelG2,controlDependenceTreePDG2);
        if (level2 == 0 && !fullTreeMatch) {
          int maxId=allNodesInSubTreePDG2.last().getId();
          Set<PDGNode> nodesG2ToBeRemoved=new LinkedHashSet<PDGNode>();
          for (          PDGNode nodeG2 : nodesG2) {
            if (nodeG2.getId() > maxId) {
              nodesG2ToBeRemoved.add(nodeG2);
            }
            if (controlDependenceTreePDG2.isElseNode()) {
              double elseNodeId=controlDependenceTreePDG2.getId();
              if (nodeG2.getId() < elseNodeId) {
                nodesG2ToBeRemoved.add(nodeG2);
              }
            }
          }
          nodesG2.removeAll(nodesG2ToBeRemoved);
        }
        this.allNodesInSubTreePDG2.addAll(nodesG2);
        List<MappingState> maxStates=null;
        if (level1 == 0 || level2 == 0) {
          maxStates=matchBasedOnCodeFragments(finalState,nodesG1,nodesG2);
        }
 else {
          ControlDependenceTreeNode cdtNode1=controlDependenceTreePDG1.getNode(predicate1);
          ControlDependenceTreeNode cdtNode2=controlDependenceTreePDG2.getNode(predicate2);
          ControlDependenceTreeNode cdtNode1Parent=null;
          if (cdtNode1 != null)           cdtNode1Parent=cdtNode1.getParent();
          ControlDependenceTreeNode cdtNode2Parent=null;
          if (cdtNode2 != null)           cdtNode2Parent=cdtNode2.getParent();
          if (cdtNode1Parent != null && cdtNode2Parent != null) {
            if ((cdtNode1Parent.getNode() != null && cdtNode1Parent.getNode().getCFGNode() instanceof CFGBranchIfNode && cdtNode2Parent.isElseNode()) || (cdtNode2Parent.getNode() != null && cdtNode2Parent.getNode().getCFGNode() instanceof CFGBranchIfNode && cdtNode1Parent.isElseNode()))             continue;
          }
          maxStates=processPDGNodes(finalState,nodesG1,nodesG2);
        }
        for (        MappingState temp : maxStates) {
          if (!currentStates.contains(temp)) {
            currentStates.add(temp);
          }
        }
      }
      if (!currentStates.isEmpty()) {
        MappingState best=findMaximumStateWithMinimumDifferences(currentStates);
        List<PDGNodeMapping> nodeMappings=new ArrayList<PDGNodeMapping>(best.getNodeMappings());
        int index=0;
        for (        PDGNodeMapping mapping : nodeMappings) {
          if (mapping.getNodeG1().equals(predicate1)) {
            controlPredicateNodesG2.remove(mapping.getNodeG2());
            break;
          }
          index++;
        }
        finalState=best;
        CloneStructureNode parent=null;
        CloneStructureNode newElseParent=null;
        for (int i=index; i < nodeMappings.size(); i++) {
          PDGNodeMapping mapping=nodeMappings.get(i);
          if (parent == null) {
            parent=new CloneStructureNode(mapping);
          }
 else {
            PDGTryNode nestedUnderTry1=pdg1.isDirectlyNestedWithinTryNode(mapping.getNodeG1());
            PDGTryNode nestedUnderTry2=pdg2.isDirectlyNestedWithinTryNode(mapping.getNodeG2());
            boolean nestedUnderTry=nestedUnderTry1 != null && nestedUnderTry2 != null;
            if (mapping.isFalseControlDependent() && !nestedUnderTry) {
              if (newElseParent == null) {
                ControlDependenceTreeNode elseNodeG1=controlDependenceTreePDG1.getElseNode(parent.getMapping().getNodeG1());
                ControlDependenceTreeNode elseNodeG2=controlDependenceTreePDG2.getElseNode(parent.getMapping().getNodeG2());
                if (elseNodeG1 != null && elseNodeG2 != null) {
                  PDGElseMapping elseMapping=new PDGElseMapping(elseNodeG1.getId(),elseNodeG2.getId());
                  newElseParent=new CloneStructureNode(elseMapping);
                  parent.addChild(newElseParent);
                  CloneStructureNode child=new CloneStructureNode(mapping);
                  newElseParent.addChild(child);
                }
              }
 else {
                CloneStructureNode child=new CloneStructureNode(mapping);
                newElseParent.addChild(child);
              }
            }
 else {
              CloneStructureNode child=new CloneStructureNode(mapping);
              parent.addChild(child);
            }
          }
        }
        if (parent != null) {
          PDGNodeMapping parentNodeMapping=(PDGNodeMapping)parent.getMapping();
          double parentId1=parentNodeMapping.getId1();
          double parentId2=parentNodeMapping.getId2();
          for (ListIterator<CloneStructureNode> parentIterator=parents.listIterator(); parentIterator.hasNext(); ) {
            CloneStructureNode previousParent=parentIterator.next();
            PDGNodeMapping previousParentNodeMapping=(PDGNodeMapping)previousParent.getMapping();
            double previousParentId1=previousParentNodeMapping.getId1();
            double previousParentId2=previousParentNodeMapping.getId2();
            if (controlDependenceTreePDG1.parentChildRelationship(parentId1,previousParentId1) && controlDependenceTreePDG2.parentChildRelationship(parentId2,previousParentId2)) {
              parent.addChild(previousParent);
              parentIterator.remove();
            }
 else             if (previousParentNodeMapping.isFalseControlDependent()) {
              if (newElseParent == null) {
                ControlDependenceTreeNode elseNodeG1=controlDependenceTreePDG1.getElseNode(parentNodeMapping.getNodeG1());
                ControlDependenceTreeNode elseNodeG2=controlDependenceTreePDG2.getElseNode(parentNodeMapping.getNodeG2());
                if (elseNodeG1 != null && elseNodeG2 != null) {
                  if (controlDependenceTreePDG1.parentChildRelationship(elseNodeG1.getId(),previousParentId1) && controlDependenceTreePDG2.parentChildRelationship(elseNodeG2.getId(),previousParentId2)) {
                    PDGElseMapping elseMapping=new PDGElseMapping(elseNodeG1.getId(),elseNodeG2.getId());
                    newElseParent=new CloneStructureNode(elseMapping);
                    parent.addChild(newElseParent);
                    newElseParent.addChild(previousParent);
                    parentIterator.remove();
                  }
                }
              }
 else {
                PDGElseMapping elseMapping=(PDGElseMapping)newElseParent.getMapping();
                if (controlDependenceTreePDG1.parentChildRelationship(elseMapping.getId1(),previousParentId1) && controlDependenceTreePDG2.parentChildRelationship(elseMapping.getId2(),previousParentId2)) {
                  newElseParent.addChild(previousParent);
                  parentIterator.remove();
                }
              }
            }
          }
          boolean isTryBlock=(parentNodeMapping.getNodeG1() instanceof PDGTryNode) && (parentNodeMapping.getNodeG2() instanceof PDGTryNode);
          if (!parent.getChildren().isEmpty() || isTryBlock) {
            parents.add(parent);
          }
 else {
            finalState.getNodeMappings().remove(parent.getMapping());
          }
        }
 else {
          root=new CloneStructureNode(null);
          for (ListIterator<CloneStructureNode> parentIterator=parents.listIterator(); parentIterator.hasNext(); ) {
            CloneStructureNode previousParent=parentIterator.next();
            root.addChild(previousParent);
            parentIterator.remove();
          }
          for (          PDGNodeMapping nodeMapping : best.getNodeMappings()) {
            if (nodesG1.contains(nodeMapping.getNodeG1())) {
              CloneStructureNode childNode=new CloneStructureNode(nodeMapping);
              root.addChild(childNode);
            }
          }
        }
      }
    }
    level1--;
    level2--;
    if (monitor != null)     monitor.worked(1);
  }
  if (monitor != null)   monitor.done();
  if (root == null) {
    root=new CloneStructureNode(null);
    for (ListIterator<CloneStructureNode> parentIterator=parents.listIterator(); parentIterator.hasNext(); ) {
      CloneStructureNode previousParent=parentIterator.next();
      root.addChild(previousParent);
      parentIterator.remove();
    }
  }
  this.maximumStateWithMinimumDifferences=finalState;
  this.cloneStructureRoot=root;
}","private void matchBasedOnControlDependenceTreeStructure(ControlDependenceTreeNode controlDependenceTreePDG1,ControlDependenceTreeNode controlDependenceTreePDG2){
  int maxLevel1=controlDependenceTreePDG1.getMaxLevel();
  int level1=maxLevel1;
  int maxLevel2=controlDependenceTreePDG2.getMaxLevel();
  int level2=maxLevel2;
  if (monitor != null)   monitor.beginTask(""String_Node_Str"",Math.min(maxLevel1,maxLevel2));
  CloneStructureNode root=null;
  MappingState finalState=null;
  List<CloneStructureNode> parents=new ArrayList<CloneStructureNode>();
  while (level1 >= 0 && level2 >= 0) {
    Set<PDGNode> controlPredicateNodesG1=controlDependenceTreePDG1.getControlPredicateNodesInLevel(level1);
    Set<PDGNode> controlPredicateNodesG2=controlDependenceTreePDG2.getControlPredicateNodesInLevel(level2);
    Set<PDGNode> controlPredicateNodesInNextLevelG1=new LinkedHashSet<PDGNode>();
    Set<PDGNode> controlPredicateNodesInNextLevelG2=new LinkedHashSet<PDGNode>();
    if (level1 < maxLevel1) {
      Set<PDGNode> nodesInNextLevel=controlDependenceTreePDG1.getControlPredicateNodesInLevel(level1 + 1);
      controlPredicateNodesInNextLevelG1.addAll(nodesInNextLevel);
      for (      PDGNode node : nodesInNextLevel) {
        if (node instanceof PDGTryNode) {
          controlPredicateNodesInNextLevelG1.addAll(pdg1.getNestedNodesWithinTryNode((PDGTryNode)node));
        }
      }
    }
    if (level2 < maxLevel2) {
      Set<PDGNode> nodesInNextLevel=controlDependenceTreePDG2.getControlPredicateNodesInLevel(level2 + 1);
      controlPredicateNodesInNextLevelG2.addAll(nodesInNextLevel);
      for (      PDGNode node : nodesInNextLevel) {
        if (node instanceof PDGTryNode) {
          controlPredicateNodesInNextLevelG2.addAll(pdg2.getNestedNodesWithinTryNode((PDGTryNode)node));
        }
      }
    }
    for (    PDGNode predicate1 : controlPredicateNodesG1) {
      Set<PDGNode> nodesG1=getNodesInRegion(pdg1,predicate1,controlPredicateNodesG1,controlPredicateNodesInNextLevelG1,controlDependenceTreePDG1);
      if (level1 == 0 && !fullTreeMatch) {
        int maxId=allNodesInSubTreePDG1.last().getId();
        Set<PDGNode> nodesG1ToBeRemoved=new LinkedHashSet<PDGNode>();
        for (        PDGNode nodeG1 : nodesG1) {
          if (nodeG1.getId() > maxId) {
            nodesG1ToBeRemoved.add(nodeG1);
          }
          if (controlDependenceTreePDG1.isElseNode()) {
            double elseNodeId=controlDependenceTreePDG1.getId();
            if (nodeG1.getId() < elseNodeId) {
              nodesG1ToBeRemoved.add(nodeG1);
            }
          }
        }
        nodesG1.removeAll(nodesG1ToBeRemoved);
      }
      this.allNodesInSubTreePDG1.addAll(nodesG1);
      List<MappingState> currentStates=new ArrayList<MappingState>();
      for (      PDGNode predicate2 : controlPredicateNodesG2) {
        Set<PDGNode> nodesG2=getNodesInRegion(pdg2,predicate2,controlPredicateNodesG2,controlPredicateNodesInNextLevelG2,controlDependenceTreePDG2);
        if (level2 == 0 && !fullTreeMatch) {
          int maxId=allNodesInSubTreePDG2.last().getId();
          Set<PDGNode> nodesG2ToBeRemoved=new LinkedHashSet<PDGNode>();
          for (          PDGNode nodeG2 : nodesG2) {
            if (nodeG2.getId() > maxId) {
              nodesG2ToBeRemoved.add(nodeG2);
            }
            if (controlDependenceTreePDG2.isElseNode()) {
              double elseNodeId=controlDependenceTreePDG2.getId();
              if (nodeG2.getId() < elseNodeId) {
                nodesG2ToBeRemoved.add(nodeG2);
              }
            }
          }
          nodesG2.removeAll(nodesG2ToBeRemoved);
        }
        this.allNodesInSubTreePDG2.addAll(nodesG2);
        List<MappingState> maxStates=null;
        if (level1 == 0 || level2 == 0) {
          maxStates=matchBasedOnCodeFragments(finalState,nodesG1,nodesG2);
        }
 else {
          ControlDependenceTreeNode cdtNode1=controlDependenceTreePDG1.getNode(predicate1);
          ControlDependenceTreeNode cdtNode2=controlDependenceTreePDG2.getNode(predicate2);
          ControlDependenceTreeNode cdtNode1Parent=null;
          if (cdtNode1 != null)           cdtNode1Parent=cdtNode1.getParent();
          ControlDependenceTreeNode cdtNode2Parent=null;
          if (cdtNode2 != null)           cdtNode2Parent=cdtNode2.getParent();
          if (cdtNode1Parent != null && cdtNode2Parent != null && !cdtNode1Parent.equals(controlDependenceTreePDG1) && !cdtNode2Parent.equals(controlDependenceTreePDG2)) {
            if ((cdtNode1Parent.getNode() != null && cdtNode1Parent.getNode().getCFGNode() instanceof CFGBranchIfNode && cdtNode2Parent.isElseNode()) || (cdtNode2Parent.getNode() != null && cdtNode2Parent.getNode().getCFGNode() instanceof CFGBranchIfNode && cdtNode1Parent.isElseNode()))             continue;
          }
          if (predicate1.getASTStatement() instanceof SwitchStatement && predicate2.getASTStatement() instanceof SwitchStatement) {
            ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher(iCompilationUnit1,iCompilationUnit2);
            boolean match=astNodeMatcher.match(predicate1,predicate2);
            if (match && astNodeMatcher.isParameterizable()) {
              PDGNodeMapping mapping=new PDGNodeMapping(predicate1,predicate2,astNodeMatcher);
              MappingState state=new MappingState(finalState,mapping);
              if (finalState != null)               finalState.addChild(state);
              Set<PDGNode> switchBodyNodes1=new LinkedHashSet<PDGNode>(nodesG1);
              switchBodyNodes1.remove(predicate1);
              Set<PDGNode> switchBodyNodes2=new LinkedHashSet<PDGNode>(nodesG2);
              switchBodyNodes1.remove(predicate2);
              maxStates=matchBasedOnSwitchCases(state,switchBodyNodes1,switchBodyNodes2);
            }
          }
 else {
            maxStates=processPDGNodes(finalState,nodesG1,nodesG2);
          }
        }
        for (        MappingState temp : maxStates) {
          if (!currentStates.contains(temp)) {
            currentStates.add(temp);
          }
        }
      }
      if (!currentStates.isEmpty()) {
        MappingState best=findMaximumStateWithMinimumDifferences(currentStates);
        List<PDGNodeMapping> nodeMappings=new ArrayList<PDGNodeMapping>(best.getNodeMappings());
        int index=0;
        for (        PDGNodeMapping mapping : nodeMappings) {
          if (mapping.getNodeG1().equals(predicate1)) {
            controlPredicateNodesG2.remove(mapping.getNodeG2());
            break;
          }
          index++;
        }
        finalState=best;
        CloneStructureNode parent=null;
        CloneStructureNode newElseParent=null;
        for (int i=index; i < nodeMappings.size(); i++) {
          PDGNodeMapping mapping=nodeMappings.get(i);
          if (parent == null) {
            parent=new CloneStructureNode(mapping);
          }
 else {
            PDGTryNode nestedUnderTry1=pdg1.isDirectlyNestedWithinTryNode(mapping.getNodeG1());
            PDGTryNode nestedUnderTry2=pdg2.isDirectlyNestedWithinTryNode(mapping.getNodeG2());
            boolean nestedUnderTry=nestedUnderTry1 != null && nestedUnderTry2 != null;
            if (mapping.isFalseControlDependent() && !nestedUnderTry) {
              if (newElseParent == null) {
                ControlDependenceTreeNode elseNodeG1=controlDependenceTreePDG1.getElseNode(parent.getMapping().getNodeG1());
                ControlDependenceTreeNode elseNodeG2=controlDependenceTreePDG2.getElseNode(parent.getMapping().getNodeG2());
                if (elseNodeG1 != null && elseNodeG2 != null) {
                  PDGElseMapping elseMapping=new PDGElseMapping(elseNodeG1.getId(),elseNodeG2.getId());
                  newElseParent=new CloneStructureNode(elseMapping);
                  parent.addChild(newElseParent);
                  CloneStructureNode child=new CloneStructureNode(mapping);
                  newElseParent.addChild(child);
                }
              }
 else {
                CloneStructureNode child=new CloneStructureNode(mapping);
                newElseParent.addChild(child);
              }
            }
 else {
              CloneStructureNode child=new CloneStructureNode(mapping);
              parent.addChild(child);
            }
          }
        }
        if (parent != null) {
          PDGNodeMapping parentNodeMapping=(PDGNodeMapping)parent.getMapping();
          double parentId1=parentNodeMapping.getId1();
          double parentId2=parentNodeMapping.getId2();
          for (ListIterator<CloneStructureNode> parentIterator=parents.listIterator(); parentIterator.hasNext(); ) {
            CloneStructureNode previousParent=parentIterator.next();
            PDGNodeMapping previousParentNodeMapping=(PDGNodeMapping)previousParent.getMapping();
            double previousParentId1=previousParentNodeMapping.getId1();
            double previousParentId2=previousParentNodeMapping.getId2();
            if (controlDependenceTreePDG1.parentChildRelationship(parentId1,previousParentId1) && controlDependenceTreePDG2.parentChildRelationship(parentId2,previousParentId2)) {
              parent.addChild(previousParent);
              parentIterator.remove();
            }
 else             if (previousParentNodeMapping.isFalseControlDependent()) {
              if (newElseParent == null) {
                ControlDependenceTreeNode elseNodeG1=controlDependenceTreePDG1.getElseNode(parentNodeMapping.getNodeG1());
                ControlDependenceTreeNode elseNodeG2=controlDependenceTreePDG2.getElseNode(parentNodeMapping.getNodeG2());
                if (elseNodeG1 != null && elseNodeG2 != null) {
                  if (controlDependenceTreePDG1.parentChildRelationship(elseNodeG1.getId(),previousParentId1) && controlDependenceTreePDG2.parentChildRelationship(elseNodeG2.getId(),previousParentId2)) {
                    PDGElseMapping elseMapping=new PDGElseMapping(elseNodeG1.getId(),elseNodeG2.getId());
                    newElseParent=new CloneStructureNode(elseMapping);
                    parent.addChild(newElseParent);
                    newElseParent.addChild(previousParent);
                    parentIterator.remove();
                  }
                }
              }
 else {
                PDGElseMapping elseMapping=(PDGElseMapping)newElseParent.getMapping();
                if (controlDependenceTreePDG1.parentChildRelationship(elseMapping.getId1(),previousParentId1) && controlDependenceTreePDG2.parentChildRelationship(elseMapping.getId2(),previousParentId2)) {
                  newElseParent.addChild(previousParent);
                  parentIterator.remove();
                }
              }
            }
          }
          boolean isTryBlock=(parentNodeMapping.getNodeG1() instanceof PDGTryNode) && (parentNodeMapping.getNodeG2() instanceof PDGTryNode);
          if (!parent.getChildren().isEmpty() || isTryBlock) {
            parents.add(parent);
          }
 else {
            finalState.getNodeMappings().remove(parent.getMapping());
          }
        }
 else {
          root=new CloneStructureNode(null);
          for (ListIterator<CloneStructureNode> parentIterator=parents.listIterator(); parentIterator.hasNext(); ) {
            CloneStructureNode previousParent=parentIterator.next();
            root.addChild(previousParent);
            parentIterator.remove();
          }
          for (          PDGNodeMapping nodeMapping : best.getNodeMappings()) {
            if (nodesG1.contains(nodeMapping.getNodeG1())) {
              CloneStructureNode childNode=new CloneStructureNode(nodeMapping);
              root.addChild(childNode);
            }
          }
        }
      }
    }
    level1--;
    level2--;
    if (monitor != null)     monitor.worked(1);
  }
  if (monitor != null)   monitor.done();
  if (root == null) {
    root=new CloneStructureNode(null);
    for (ListIterator<CloneStructureNode> parentIterator=parents.listIterator(); parentIterator.hasNext(); ) {
      CloneStructureNode previousParent=parentIterator.next();
      root.addChild(previousParent);
      parentIterator.remove();
    }
  }
  this.maximumStateWithMinimumDifferences=finalState;
  this.cloneStructureRoot=root;
}"
12097,"public FeatureEnvyVisualizationData(ClassObject sourceClass,MethodObject methodToBeMoved,ClassObject targetClass){
  this.sourceClass=sourceClass;
  this.methodToBeMoved=methodToBeMoved;
  this.targetClass=targetClass;
  this.sourceMethodInvocationMap=new LinkedHashMap<MethodInvocationObject,Integer>();
  List<MethodInvocationObject> sourceMethodInvocations=methodToBeMoved.getNonDistinctInvokedMethodsThroughThisReference();
  for (  MethodInvocationObject methodInvocation : sourceMethodInvocations) {
    if (sourceMethodInvocationMap.containsKey(methodInvocation)) {
      sourceMethodInvocationMap.put(methodInvocation,sourceMethodInvocationMap.get(methodInvocation) + 1);
    }
 else {
      sourceMethodInvocationMap.put(methodInvocation,1);
    }
  }
  this.targetMethodInvocationMap=new LinkedHashMap<MethodInvocationObject,Integer>();
  List<FieldInstructionObject> fieldInstructions=methodToBeMoved.getFieldInstructions();
  List<LocalVariableInstructionObject> localVariableInstructions=methodToBeMoved.getLocalVariableInstructions();
  Map<AbstractVariable,ArrayList<MethodInvocationObject>> externalMethodInvocationsThroughFieldsMap=methodToBeMoved.getNonDistinctInvokedMethodsThroughFields();
  processExternalMethodInvocations(externalMethodInvocationsThroughFieldsMap,fieldInstructions,localVariableInstructions,targetClass);
  Map<AbstractVariable,ArrayList<MethodInvocationObject>> externalMethodInvocationsThroughParametersMap=methodToBeMoved.getNonDistinctInvokedMethodsThroughParameters();
  processExternalMethodInvocations(externalMethodInvocationsThroughParametersMap,fieldInstructions,localVariableInstructions,targetClass);
  this.sourceFieldReadMap=new LinkedHashMap<FieldInstructionObject,Integer>();
  List<PlainVariable> usedFieldsThroughThisReference=methodToBeMoved.getNonDistinctUsedFieldsThroughThisReference();
  for (  PlainVariable variable : usedFieldsThroughThisReference) {
    FieldInstructionObject fieldInstruction=findFieldInstruction(variable,fieldInstructions);
    if (sourceFieldReadMap.containsKey(fieldInstruction)) {
      sourceFieldReadMap.put(fieldInstruction,sourceFieldReadMap.get(fieldInstruction) + 1);
    }
 else {
      sourceFieldReadMap.put(fieldInstruction,1);
    }
  }
  this.sourceFieldWriteMap=new LinkedHashMap<FieldInstructionObject,Integer>();
  List<PlainVariable> definedFieldsThroughThisReference=methodToBeMoved.getNonDistinctDefinedFieldsThroughThisReference();
  for (  PlainVariable variable : definedFieldsThroughThisReference) {
    FieldInstructionObject fieldInstruction=findFieldInstruction(variable,fieldInstructions);
    if (sourceFieldWriteMap.containsKey(fieldInstruction)) {
      sourceFieldWriteMap.put(fieldInstruction,sourceFieldWriteMap.get(fieldInstruction) + 1);
    }
 else {
      sourceFieldWriteMap.put(fieldInstruction,1);
    }
  }
  this.targetFieldReadMap=new LinkedHashMap<FieldInstructionObject,Integer>();
  List<AbstractVariable> usedFieldsThroughFields=methodToBeMoved.getNonDistinctUsedFieldsThroughFields();
  handleUsedFields(usedFieldsThroughFields,fieldInstructions,localVariableInstructions,targetClass);
  List<AbstractVariable> usedFieldsThroughParameters=methodToBeMoved.getNonDistinctUsedFieldsThroughParameters();
  handleUsedFields(usedFieldsThroughParameters,fieldInstructions,localVariableInstructions,targetClass);
  this.targetFieldWriteMap=new LinkedHashMap<FieldInstructionObject,Integer>();
  List<AbstractVariable> definedFieldsThroughFields=methodToBeMoved.getNonDistinctDefinedFieldsThroughFields();
  handleDefinedFields(definedFieldsThroughFields,fieldInstructions,localVariableInstructions,targetClass);
  List<AbstractVariable> definedFieldsThroughParameters=methodToBeMoved.getNonDistinctDefinedFieldsThroughParameters();
  handleDefinedFields(definedFieldsThroughParameters,fieldInstructions,localVariableInstructions,targetClass);
}","public FeatureEnvyVisualizationData(ClassObject sourceClass,MethodObject methodToBeMoved,ClassObject targetClass){
  this.sourceClass=sourceClass;
  this.methodToBeMoved=methodToBeMoved;
  this.targetClass=targetClass;
  this.sourceMethodInvocationMap=new LinkedHashMap<MethodInvocationObject,Integer>();
  List<MethodInvocationObject> sourceMethodInvocations=methodToBeMoved.getNonDistinctInvokedMethodsThroughThisReference();
  this.targetMethodInvocationMap=new LinkedHashMap<MethodInvocationObject,Integer>();
  List<FieldInstructionObject> fieldInstructions=methodToBeMoved.getFieldInstructions();
  List<LocalVariableInstructionObject> localVariableInstructions=methodToBeMoved.getLocalVariableInstructions();
  Map<AbstractVariable,ArrayList<MethodInvocationObject>> externalMethodInvocationsThroughFieldsMap=methodToBeMoved.getNonDistinctInvokedMethodsThroughFields();
  Map<AbstractVariable,ArrayList<MethodInvocationObject>> externalMethodInvocationsThroughParametersMap=methodToBeMoved.getNonDistinctInvokedMethodsThroughParameters();
  this.sourceFieldReadMap=new LinkedHashMap<FieldInstructionObject,Integer>();
  List<PlainVariable> usedFieldsThroughThisReference=methodToBeMoved.getNonDistinctUsedFieldsThroughThisReference();
  this.sourceFieldWriteMap=new LinkedHashMap<FieldInstructionObject,Integer>();
  List<PlainVariable> definedFieldsThroughThisReference=methodToBeMoved.getNonDistinctDefinedFieldsThroughThisReference();
  this.targetFieldReadMap=new LinkedHashMap<FieldInstructionObject,Integer>();
  List<AbstractVariable> usedFieldsThroughFields=methodToBeMoved.getNonDistinctUsedFieldsThroughFields();
  List<AbstractVariable> usedFieldsThroughParameters=methodToBeMoved.getNonDistinctUsedFieldsThroughParameters();
  this.targetFieldWriteMap=new LinkedHashMap<FieldInstructionObject,Integer>();
  List<AbstractVariable> definedFieldsThroughFields=methodToBeMoved.getNonDistinctDefinedFieldsThroughFields();
  List<AbstractVariable> definedFieldsThroughParameters=methodToBeMoved.getNonDistinctDefinedFieldsThroughParameters();
  for (  MethodInvocationObject methodInvocation : sourceMethodInvocations) {
    boolean delegatesToTarget=false;
    MethodObject delegateMethod=sourceClass.getMethod(methodInvocation);
    if (delegateMethod != null) {
      MethodInvocationObject delegateMethodInvocation=delegateMethod.isDelegate();
      if (delegateMethodInvocation != null && delegateMethodInvocation.getOriginClassName().equals(targetClass.getName())) {
        delegatesToTarget=true;
        fieldInstructions.addAll(delegateMethod.getFieldInstructions());
        localVariableInstructions.addAll(delegateMethod.getLocalVariableInstructions());
        Map<AbstractVariable,ArrayList<MethodInvocationObject>> externalMethodInvocationsThroughFieldsMapDelegate=delegateMethod.getNonDistinctInvokedMethodsThroughFields();
        for (        AbstractVariable variable : externalMethodInvocationsThroughFieldsMapDelegate.keySet()) {
          if (externalMethodInvocationsThroughFieldsMap.containsKey(variable)) {
            externalMethodInvocationsThroughFieldsMap.get(variable).addAll(externalMethodInvocationsThroughFieldsMapDelegate.get(variable));
          }
 else {
            externalMethodInvocationsThroughFieldsMap.put(variable,externalMethodInvocationsThroughFieldsMapDelegate.get(variable));
          }
        }
        Map<AbstractVariable,ArrayList<MethodInvocationObject>> externalMethodInvocationsThroughParametersMapDelegate=delegateMethod.getNonDistinctInvokedMethodsThroughParameters();
        for (        AbstractVariable variable : externalMethodInvocationsThroughParametersMapDelegate.keySet()) {
          if (externalMethodInvocationsThroughParametersMap.containsKey(variable)) {
            externalMethodInvocationsThroughParametersMap.get(variable).addAll(externalMethodInvocationsThroughParametersMapDelegate.get(variable));
          }
 else {
            externalMethodInvocationsThroughParametersMap.put(variable,externalMethodInvocationsThroughParametersMapDelegate.get(variable));
          }
        }
        usedFieldsThroughThisReference.addAll(delegateMethod.getNonDistinctUsedFieldsThroughThisReference());
        definedFieldsThroughThisReference.addAll(delegateMethod.getNonDistinctDefinedFieldsThroughThisReference());
        usedFieldsThroughFields.addAll(delegateMethod.getNonDistinctUsedFieldsThroughFields());
        usedFieldsThroughParameters.addAll(delegateMethod.getNonDistinctUsedFieldsThroughParameters());
        definedFieldsThroughFields.addAll(delegateMethod.getNonDistinctDefinedFieldsThroughFields());
        definedFieldsThroughParameters.addAll(delegateMethod.getNonDistinctDefinedFieldsThroughParameters());
      }
    }
    if (!delegatesToTarget) {
      if (sourceMethodInvocationMap.containsKey(methodInvocation)) {
        sourceMethodInvocationMap.put(methodInvocation,sourceMethodInvocationMap.get(methodInvocation) + 1);
      }
 else {
        sourceMethodInvocationMap.put(methodInvocation,1);
      }
    }
  }
  processExternalMethodInvocations(externalMethodInvocationsThroughFieldsMap,fieldInstructions,localVariableInstructions,targetClass);
  processExternalMethodInvocations(externalMethodInvocationsThroughParametersMap,fieldInstructions,localVariableInstructions,targetClass);
  for (  PlainVariable variable : usedFieldsThroughThisReference) {
    FieldInstructionObject fieldInstruction=findFieldInstruction(variable,fieldInstructions);
    if (fieldInstruction.getOwnerClass().equals(targetClass.getName())) {
      if (targetFieldReadMap.containsKey(fieldInstruction)) {
        targetFieldReadMap.put(fieldInstruction,targetFieldReadMap.get(fieldInstruction) + 1);
      }
 else {
        targetFieldReadMap.put(fieldInstruction,1);
      }
    }
 else {
      if (sourceFieldReadMap.containsKey(fieldInstruction)) {
        sourceFieldReadMap.put(fieldInstruction,sourceFieldReadMap.get(fieldInstruction) + 1);
      }
 else {
        sourceFieldReadMap.put(fieldInstruction,1);
      }
    }
  }
  for (  PlainVariable variable : definedFieldsThroughThisReference) {
    FieldInstructionObject fieldInstruction=findFieldInstruction(variable,fieldInstructions);
    if (fieldInstruction.getOwnerClass().equals(targetClass.getName())) {
      if (targetFieldWriteMap.containsKey(fieldInstruction)) {
        targetFieldWriteMap.put(fieldInstruction,targetFieldWriteMap.get(fieldInstruction) + 1);
      }
 else {
        targetFieldWriteMap.put(fieldInstruction,1);
      }
    }
 else {
      if (sourceFieldWriteMap.containsKey(fieldInstruction)) {
        sourceFieldWriteMap.put(fieldInstruction,sourceFieldWriteMap.get(fieldInstruction) + 1);
      }
 else {
        sourceFieldWriteMap.put(fieldInstruction,1);
      }
    }
  }
  handleUsedFields(usedFieldsThroughFields,fieldInstructions,localVariableInstructions,targetClass);
  handleUsedFields(usedFieldsThroughParameters,fieldInstructions,localVariableInstructions,targetClass);
  handleDefinedFields(definedFieldsThroughFields,fieldInstructions,localVariableInstructions,targetClass);
  handleDefinedFields(definedFieldsThroughParameters,fieldInstructions,localVariableInstructions,targetClass);
}"
12098,"public void addThreeCompartments(){
  addFieldCompartment();
  extractMethodFigure.setBorder(new LineBorder());
  extractMethodFigure.setBackgroundColor(EntityFigure.entityColor);
  add(extractMethodFigure);
  add(methodFigure);
}","public void addThreeCompartments(){
  addFieldCompartment();
  extractMethodFigure.setBorder(new LineBorder());
  extractMethodFigure.setBackgroundColor(DecorationConstants.entityColor);
  add(extractMethodFigure);
  add(methodFigure);
}"
12099,"public ClassFigure(String name,Color color){
  ToolbarLayout layout=new ToolbarLayout();
  layout.setSpacing(5);
  setLayoutManager(layout);
  setBorder(new CompoundBorder(new LineBorder(1),new MarginBorder(0,0,0,0)));
  setBackgroundColor(color);
  setOpaque(true);
  Font classFont=new Font(null,""String_Node_Str"",12,SWT.BOLD);
  Label className=new Label(name,CLASS);
  className.setToolTip(new Label(name));
  className.setFont(classFont);
  add(className);
  new ClassFigureMover(this);
}","public ClassFigure(String name,Color color){
  ToolbarLayout layout=new ToolbarLayout();
  layout.setSpacing(5);
  setLayoutManager(layout);
  setBorder(new CompoundBorder(new LineBorder(1),new MarginBorder(0,0,0,0)));
  setBackgroundColor(color);
  setOpaque(true);
  Label className=new Label(name,DecorationConstants.CLASS);
  className.setToolTip(new Label(name));
  className.setFont(DecorationConstants.classFont);
  add(className);
  new ClassFigureMover(this);
}"
12100,"public void addFigure(Figure figure){
  figure.setBackgroundColor(EntityFigure.entityColor);
  figure.setBorder(new CompoundBorder(new LineBorder(1),new MarginBorder(3,3,3,3)));
  add(figure);
}","public void addFigure(Figure figure){
  figure.setBackgroundColor(DecorationConstants.entityColor);
  figure.setBorder(new CompoundBorder(new LineBorder(1),new MarginBorder(3,3,3,3)));
  add(figure);
}"
12101,"public void mouseExited(MouseEvent me){
  List<JConnection> connections=figure.getOutgoingConnections();
  for (  JConnection connection : connections) {
    connection.setAlpha(null);
    connection.setLineWidth(1);
    Label l=connection.getLabel();
    if (l != null) {
      l.setFont(new Font(null,""String_Node_Str"",10,SWT.BOLD));
      ConnectionLocator locator=connection.getLocator();
      locator.setRelativePosition(PositionConstants.CENTER);
      connection.add(l,locator);
    }
  }
}","public void mouseExited(MouseEvent me){
  List<JConnection> connections=figure.getOutgoingConnections();
  for (  JConnection connection : connections) {
    connection.setAlpha(null);
    connection.setLineWidth(1);
    Label l=connection.getLabel();
    if (l != null) {
      l.setFont(DecorationConstants.normalFont);
      ConnectionLocator locator=connection.getLocator();
      locator.setRelativePosition(PositionConstants.CENTER);
      connection.add(l,locator);
    }
  }
}"
12102,"public void mouseEntered(MouseEvent me){
  List<JConnection> connections=figure.getOutgoingConnections();
  for (  JConnection connection : connections) {
    connection.setLineWidth(3);
    Label l=connection.getLabel();
    if (l != null) {
      String fontStyle=""String_Node_Str"";
      ConnectionEndpointLocator locator=new ConnectionEndpointLocator(connection,true);
      if (connection.isWrite()) {
        locator.setUDistance(95);
        locator.setVDistance(0);
      }
 else {
        locator.setUDistance(42);
        locator.setVDistance(0);
      }
      l.setFont(new Font(null,fontStyle,14,SWT.BOLD));
      connection.add(l,locator);
    }
    PolygonDecoration decoration=new PolygonDecoration();
    decoration.setTemplate(PolygonDecoration.TRIANGLE_TIP);
    decoration.setSize(20,20);
    decoration.setBackgroundColor(connection.getForegroundColor());
    connection.setTargetDecoration(decoration);
  }
}","public void mouseEntered(MouseEvent me){
  List<JConnection> connections=figure.getOutgoingConnections();
  for (  JConnection connection : connections) {
    connection.setLineWidth(3);
    Label l=connection.getLabel();
    if (l != null) {
      ConnectionEndpointLocator locator=new ConnectionEndpointLocator(connection,true);
      if (connection.isWrite()) {
        locator.setUDistance(95);
        locator.setVDistance(0);
      }
 else {
        locator.setUDistance(42);
        locator.setVDistance(0);
      }
      l.setFont(DecorationConstants.highlightFont);
      connection.add(l,locator);
    }
    PolygonDecoration decoration=new PolygonDecoration();
    decoration.setTemplate(PolygonDecoration.TRIANGLE_TIP);
    decoration.setSize(20,20);
    decoration.setBackgroundColor(connection.getForegroundColor());
    connection.setTargetDecoration(decoration);
  }
}"
12103,"public FeatureEnvyDiagram(FeatureEnvyVisualizationData data){
  root=new LayeredPane();
  primary=new Layer();
  primary.setLayoutManager(new XYLayout());
  root.setFont(Display.getDefault().getSystemFont());
  root.add(primary,""String_Node_Str"");
  connections=new ConnectionLayer();
  final ClassFigure source=new ClassFigure(data.getSourceClass().getName(),ClassFigure.classColor);
  source.setToolTip(new Label(""String_Node_Str""));
  source.addThreeCompartments();
  final ClassFigure target=new ClassFigure(data.getTargetClass().getName(),ClassFigure.classColor);
  target.addTwoCompartments();
  target.setToolTip(new Label(""String_Node_Str""));
  EntityFigure extractMethod=new EntityFigure(data.getMethodToBeMoved().getName(),EntityFigure.METHOD);
  new ClassFigureMover(extractMethod);
  extractMethod.setLabelAlignment(2);
  extractMethod.setToolTip(new Label(""String_Node_Str""));
  Font font=new Font(null,""String_Node_Str"",10,SWT.BOLD);
  extractMethod.setFont(font);
  EntityFigure extractMethod1=new EntityFigure(data.getMethodToBeMoved().getName(),EntityFigure.METHOD);
  extractMethod1.setFont(font);
  extractMethod1.setLabelAlignment(2);
  extractMethod1.setBorder(new SimpleRaisedBorder(3));
  source.getExtractMethodCompartment().add(extractMethod1);
  int size=data.getSourceMethodInvocationMap().size();
  float interval1=0.1f / size;
  float weight=0.3f;
  for (  Entry<MethodInvocationObject,Integer> entry : data.getSourceMethodInvocationMap().entrySet()) {
    MethodInvocationObject method=entry.getKey();
    Integer occurences=entry.getValue();
    weight=weight - interval1;
    EntityFigure methodFigure=new EntityFigure(method.getSignature(),EntityFigure.METHOD);
    source.getMethodsCompartment().add(methodFigure);
    JConnection connection=extractMethod.addToSourceMethodConnection(ConnectionType.METHOD_CALL_SOURCE,methodFigure,occurences);
    connectionList.add(connection);
    connections.add(connection);
  }
  for (  Entry<MethodInvocationObject,Integer> entry : data.getTargetMethodInvocationMap().entrySet()) {
    MethodInvocationObject method=entry.getKey();
    Integer occurences=entry.getValue();
    EntityFigure methodFigure=new EntityFigure(method.getSignature(),EntityFigure.METHOD);
    target.getMethodsCompartment().add(methodFigure);
    JConnection connection=extractMethod.addToTargetMethodConnection(ConnectionType.METHOD_CALL_TARGET,methodFigure,occurences);
    connectionList.add(connection);
    connections.add(connection);
  }
  weight=0.2f;
  float interval2=0.1f / data.getSourceFieldReadMap().size();
  for (  Entry<FieldInstructionObject,Integer> entry : data.getSourceFieldReadMap().entrySet()) {
    FieldInstructionObject field=entry.getKey();
    Integer occurences=entry.getValue();
    weight=weight + interval2;
    EntityFigure fieldFigure=new EntityFigure(field.getName(),EntityFigure.FIELD);
    source.getFieldsCompartment().add(fieldFigure);
    JConnection connection=extractMethod.addToSourceWeakReadConnection(ConnectionType.READ_FIELD_SOURCE,fieldFigure,occurences);
    connectionList.add(connection);
    connections.add(connection);
  }
  float interval3=0.4f / data.getSourceFieldWriteMap().size();
  weight=0.2f;
  for (  Entry<FieldInstructionObject,Integer> entry : data.getSourceFieldWriteMap().entrySet()) {
    FieldInstructionObject field=entry.getKey();
    Integer occurences=entry.getValue();
    weight=weight + interval3;
    EntityFigure fieldFigure=new EntityFigure(field.getName(),EntityFigure.FIELD);
    boolean contains=false;
    for (    Object child : source.getFieldsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(fieldFigure.getName()))       contains=true;
      JConnection connection=extractMethod.addToSourceBendConnection(ConnectionType.WRITE_FIELD_SOURCE,entity,occurences);
      connectionList.add(connection);
      connections.add(connection);
    }
    if (!contains) {
      source.getFieldsCompartment().add(fieldFigure);
      JConnection connection=extractMethod.addToSourceWeakWriteConnection(ConnectionType.WRITE_FIELD_SOURCE,fieldFigure,occurences);
      connectionList.add(connection);
      connections.add(connection);
    }
  }
  for (  Entry<FieldInstructionObject,Integer> entry : data.getTargetFieldReadMap().entrySet()) {
    FieldInstructionObject field=entry.getKey();
    Integer occurences=entry.getValue();
    EntityFigure fieldFigure=new EntityFigure(field.getName(),EntityFigure.FIELD);
    target.getFieldsCompartment().add(fieldFigure);
    JConnection connection=extractMethod.addToTargetReadConnection(ConnectionType.READ_FIELD_TARGET,fieldFigure,occurences);
    connectionList.add(connection);
    connections.add(connection);
  }
  for (  Entry<FieldInstructionObject,Integer> entry : data.getTargetFieldWriteMap().entrySet()) {
    FieldInstructionObject field=entry.getKey();
    Integer occurences=entry.getValue();
    EntityFigure fieldFigure=new EntityFigure(field.getName(),EntityFigure.FIELD);
    boolean contains=false;
    for (    Object child : target.getFieldsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(fieldFigure.getName())) {
        contains=true;
        JConnection connection=extractMethod.addToTargetBendConnection(ConnectionType.WRITE_FIELD_TARGET,entity,occurences);
        connectionList.add(connection);
        connections.add(connection);
      }
    }
    if (!contains) {
      target.getFieldsCompartment().add(fieldFigure);
      JConnection connection=extractMethod.addToTargetWriteConnection(ConnectionType.WRITE_FIELD_TARGET,fieldFigure,occurences);
      connectionList.add(connection);
      connections.add(connection);
    }
  }
  int classWidth=300;
  int startPointX=100;
  int startPointY=50;
  int methodWidth=150;
  int gap=100;
  extractMethod.setMaximumSize(new Dimension(methodWidth,-1));
  final Legend legend=new Legend(connectionList,false);
  int legendHeight=150;
  int legendWidth=275;
  int legendGap=200;
  primary.add(source,new Rectangle(startPointX,startPointY,classWidth,-1));
  primary.add(target,new Rectangle(startPointX + classWidth + methodWidth+ 2 * gap,startPointY,classWidth,-1));
  int sourceH=source.getPreferredSize().height;
  int targetH=target.getPreferredSize().height;
  primary.add(extractMethod,new Rectangle(startPointX + classWidth + gap,startPointY + Math.min(targetH,sourceH) / 2,-1,-1));
  primary.add(legend,new Rectangle(startPointX,sourceH + legendGap,legendWidth,legendHeight));
  root.add(connections,""String_Node_Str"");
}","public FeatureEnvyDiagram(FeatureEnvyVisualizationData data){
  root=new LayeredPane();
  primary=new Layer();
  primary.setLayoutManager(new XYLayout());
  root.setFont(Display.getDefault().getSystemFont());
  root.add(primary,""String_Node_Str"");
  connections=new ConnectionLayer();
  final ClassFigure source=new ClassFigure(data.getSourceClass().getName(),DecorationConstants.classColor);
  source.setToolTip(new Label(""String_Node_Str""));
  source.addThreeCompartments();
  final ClassFigure target=new ClassFigure(data.getTargetClass().getName(),DecorationConstants.classColor);
  target.addTwoCompartments();
  target.setToolTip(new Label(""String_Node_Str""));
  EntityFigure extractMethod=new EntityFigure(data.getMethodToBeMoved().getName(),DecorationConstants.METHOD);
  new ClassFigureMover(extractMethod);
  extractMethod.setLabelAlignment(2);
  extractMethod.setToolTip(new Label(""String_Node_Str""));
  Font font=DecorationConstants.normalFont;
  extractMethod.setFont(font);
  EntityFigure extractMethod1=new EntityFigure(data.getMethodToBeMoved().getName(),DecorationConstants.METHOD);
  extractMethod1.setFont(font);
  extractMethod1.setLabelAlignment(2);
  extractMethod1.setBorder(new SimpleRaisedBorder(3));
  source.getExtractMethodCompartment().add(extractMethod1);
  int size=data.getSourceMethodInvocationMap().size();
  float interval1=0.1f / size;
  float weight=0.3f;
  for (  Entry<MethodInvocationObject,Integer> entry : data.getSourceMethodInvocationMap().entrySet()) {
    MethodInvocationObject method=entry.getKey();
    Integer occurences=entry.getValue();
    weight=weight - interval1;
    EntityFigure methodFigure=new EntityFigure(method.getSignature(),DecorationConstants.METHOD);
    source.getMethodsCompartment().add(methodFigure);
    JConnection connection=extractMethod.addToSourceMethodConnection(ConnectionType.METHOD_CALL_SOURCE,methodFigure,occurences);
    connectionList.add(connection);
    connections.add(connection);
  }
  for (  Entry<MethodInvocationObject,Integer> entry : data.getTargetMethodInvocationMap().entrySet()) {
    MethodInvocationObject method=entry.getKey();
    Integer occurences=entry.getValue();
    EntityFigure methodFigure=new EntityFigure(method.getSignature(),DecorationConstants.METHOD);
    target.getMethodsCompartment().add(methodFigure);
    JConnection connection=extractMethod.addToTargetMethodConnection(ConnectionType.METHOD_CALL_TARGET,methodFigure,occurences);
    connectionList.add(connection);
    connections.add(connection);
  }
  weight=0.2f;
  float interval2=0.1f / data.getSourceFieldReadMap().size();
  for (  Entry<FieldInstructionObject,Integer> entry : data.getSourceFieldReadMap().entrySet()) {
    FieldInstructionObject field=entry.getKey();
    Integer occurences=entry.getValue();
    weight=weight + interval2;
    EntityFigure fieldFigure=new EntityFigure(field.getName(),DecorationConstants.FIELD);
    source.getFieldsCompartment().add(fieldFigure);
    JConnection connection=extractMethod.addToSourceWeakReadConnection(ConnectionType.READ_FIELD_SOURCE,fieldFigure,occurences);
    connectionList.add(connection);
    connections.add(connection);
  }
  float interval3=0.4f / data.getSourceFieldWriteMap().size();
  weight=0.2f;
  for (  Entry<FieldInstructionObject,Integer> entry : data.getSourceFieldWriteMap().entrySet()) {
    FieldInstructionObject field=entry.getKey();
    Integer occurences=entry.getValue();
    weight=weight + interval3;
    EntityFigure fieldFigure=new EntityFigure(field.getName(),DecorationConstants.FIELD);
    boolean contains=false;
    for (    Object child : source.getFieldsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(fieldFigure.getName()))       contains=true;
      JConnection connection=extractMethod.addToSourceBendConnection(ConnectionType.WRITE_FIELD_SOURCE,entity,occurences);
      connectionList.add(connection);
      connections.add(connection);
    }
    if (!contains) {
      source.getFieldsCompartment().add(fieldFigure);
      JConnection connection=extractMethod.addToSourceWeakWriteConnection(ConnectionType.WRITE_FIELD_SOURCE,fieldFigure,occurences);
      connectionList.add(connection);
      connections.add(connection);
    }
  }
  for (  Entry<FieldInstructionObject,Integer> entry : data.getTargetFieldReadMap().entrySet()) {
    FieldInstructionObject field=entry.getKey();
    Integer occurences=entry.getValue();
    EntityFigure fieldFigure=new EntityFigure(field.getName(),DecorationConstants.FIELD);
    target.getFieldsCompartment().add(fieldFigure);
    JConnection connection=extractMethod.addToTargetReadConnection(ConnectionType.READ_FIELD_TARGET,fieldFigure,occurences);
    connectionList.add(connection);
    connections.add(connection);
  }
  for (  Entry<FieldInstructionObject,Integer> entry : data.getTargetFieldWriteMap().entrySet()) {
    FieldInstructionObject field=entry.getKey();
    Integer occurences=entry.getValue();
    EntityFigure fieldFigure=new EntityFigure(field.getName(),DecorationConstants.FIELD);
    boolean contains=false;
    for (    Object child : target.getFieldsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(fieldFigure.getName())) {
        contains=true;
        JConnection connection=extractMethod.addToTargetBendConnection(ConnectionType.WRITE_FIELD_TARGET,entity,occurences);
        connectionList.add(connection);
        connections.add(connection);
      }
    }
    if (!contains) {
      target.getFieldsCompartment().add(fieldFigure);
      JConnection connection=extractMethod.addToTargetWriteConnection(ConnectionType.WRITE_FIELD_TARGET,fieldFigure,occurences);
      connectionList.add(connection);
      connections.add(connection);
    }
  }
  int classWidth=300;
  int startPointX=100;
  int startPointY=50;
  int methodWidth=150;
  int gap=100;
  extractMethod.setMaximumSize(new Dimension(methodWidth,20));
  final Legend legend=new Legend(connectionList,false);
  int legendHeight=150;
  int legendWidth=275;
  int legendGap=200;
  primary.add(source,new Rectangle(startPointX,startPointY,classWidth,-1));
  primary.add(target,new Rectangle(startPointX + classWidth + methodWidth+ 2 * gap,startPointY,classWidth,-1));
  int sourceH=source.getPreferredSize().height;
  int targetH=target.getPreferredSize().height;
  primary.add(extractMethod,new Rectangle(startPointX + classWidth + gap,startPointY + Math.min(targetH,sourceH) / 2,-1,-1));
  primary.add(legend,new Rectangle(startPointX,sourceH + legendGap,legendWidth,legendHeight));
  root.add(connections,""String_Node_Str"");
}"
12104,"public GodClassDiagram(GodClassVisualizationData data,Composite parent){
  root=new LayeredPane();
  primary=new Layer();
  primary.setLayoutManager(new XYLayout());
  root.setFont(parent.getFont());
  root.add(primary,""String_Node_Str"");
  connections=new ConnectionLayer();
  int classWidth=200;
  final ClassFigure source=new ClassFigure(data.getSourceClass().getName(),ClassFigure.classColor);
  source.setToolTip(new Label(""String_Node_Str""));
  source.addTwoCompartments();
  final ClassFigure extractedClass=new ClassFigure(""String_Node_Str"",ClassFigure.classColor);
  extractedClass.addTwoCompartments();
  extractedClass.setToolTip(new Label(""String_Node_Str""));
  for (  FieldObject field : data.getExtractedFields()) {
    EntityFigure fieldFigure=new EntityFigure(field.getName(),EntityFigure.FIELD);
    extractedClass.getFieldsCompartment().add(fieldFigure);
  }
  for (  MethodObject method : data.getExtractedMethods()) {
    EntityFigure methodFigure=new EntityFigure(method.getName(),EntityFigure.METHOD);
    extractedClass.getMethodsCompartment().add(methodFigure);
  }
  Set<Entry<MethodObject,Map<MethodInvocationObject,Integer>>> internalMethodInvocation=data.getInternalMethodInvocationMap().entrySet();
  for (  Entry<MethodObject,Map<MethodInvocationObject,Integer>> entry : internalMethodInvocation) {
    MethodObject extractedMethod=entry.getKey();
    Map<MethodInvocationObject,Integer> connectionMap=entry.getValue();
    EntityFigure connectionSource=null;
    for (    Object child : extractedClass.getMethodsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(extractedMethod.getName()))       connectionSource=entity;
    }
    for (    Entry<MethodInvocationObject,Integer> map : connectionMap.entrySet()) {
      MethodInvocationObject method=map.getKey();
      Integer occurences=map.getValue();
      EntityFigure methodFigure=new EntityFigure(method.getMethodName(),EntityFigure.METHOD);
      for (      Object child : extractedClass.getMethodsCompartment().getChildren()) {
        EntityFigure entity=(EntityFigure)child;
        if (entity.getName().equals(methodFigure.getName())) {
          connections.add(connectionSource.addToSameClassMethodConnectionRR(ConnectionType.METHOD_CALL_TARGET,entity,occurences,classWidth));
        }
      }
    }
  }
  for (  Entry<MethodObject,Map<MethodInvocationObject,Integer>> entry : data.getExternalMethodInvocationMap().entrySet()) {
    MethodObject extractedMethod=entry.getKey();
    Map<MethodInvocationObject,Integer> connectionMap=entry.getValue();
    EntityFigure connectionSource=null;
    for (    Object child : extractedClass.getMethodsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(extractedMethod.getName()))       connectionSource=entity;
    }
    for (    Entry<MethodInvocationObject,Integer> map : connectionMap.entrySet()) {
      MethodInvocationObject method=map.getKey();
      Integer occurences=map.getValue();
      EntityFigure methodFigure=new EntityFigure(method.getMethodName(),EntityFigure.METHOD);
      boolean contains=false;
      for (      Object child : source.getMethodsCompartment().getChildren()) {
        EntityFigure entity=(EntityFigure)child;
        if (entity.getName().equals(methodFigure.getName())) {
          contains=true;
          connections.add(connectionSource.addToSourceMethodConnection(ConnectionType.METHOD_CALL_SOURCE,entity,occurences));
        }
      }
      if (!contains) {
        source.getMethodsCompartment().add(methodFigure);
        connections.add(connectionSource.addToSourceMethodConnection(ConnectionType.METHOD_CALL_SOURCE,methodFigure,occurences));
      }
    }
  }
  for (  Entry<MethodObject,Map<FieldInstructionObject,Integer>> entry : data.getInternalFieldReadMap().entrySet()) {
    MethodObject extractedMethod=entry.getKey();
    Map<FieldInstructionObject,Integer> connectionMap=entry.getValue();
    EntityFigure connectionSource=null;
    for (    Object child : extractedClass.getMethodsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(extractedMethod.getName()))       connectionSource=entity;
    }
    for (    Entry<FieldInstructionObject,Integer> map : connectionMap.entrySet()) {
      FieldInstructionObject field=map.getKey();
      Integer occurences=map.getValue();
      EntityFigure fieldFigure=new EntityFigure(field.getName(),EntityFigure.FIELD);
      for (      Object child : extractedClass.getFieldsCompartment().getChildren()) {
        EntityFigure entity=(EntityFigure)child;
        if (entity.getName().equals(fieldFigure.getName())) {
          connections.add(connectionSource.addToSameClassReadConnectionRR(ConnectionType.READ_FIELD_TARGET,entity,occurences,classWidth));
        }
      }
    }
  }
  for (  Entry<MethodObject,Map<FieldInstructionObject,Integer>> entry : data.getInternalFieldWriteMap().entrySet()) {
    MethodObject extractedMethod=entry.getKey();
    Map<FieldInstructionObject,Integer> connectionMap=entry.getValue();
    EntityFigure connectionSource=null;
    for (    Object child : extractedClass.getMethodsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(extractedMethod.getName()))       connectionSource=entity;
    }
    for (    Entry<FieldInstructionObject,Integer> map : connectionMap.entrySet()) {
      FieldInstructionObject field=map.getKey();
      Integer occurences=map.getValue();
      EntityFigure fieldFigure=new EntityFigure(field.getName(),EntityFigure.FIELD);
      for (      Object child : extractedClass.getFieldsCompartment().getChildren()) {
        EntityFigure entity=(EntityFigure)child;
        if (entity.getName().equals(fieldFigure.getName())) {
          connections.add(connectionSource.addToSameClassWriteConnectionRR(ConnectionType.WRITE_FIELD_TARGET,entity,occurences,classWidth));
        }
      }
    }
  }
  for (  Entry<MethodObject,Map<FieldInstructionObject,Integer>> entry : data.getExternalFieldReadMap().entrySet()) {
    MethodObject extractedMethod=entry.getKey();
    Map<FieldInstructionObject,Integer> connectionMap=entry.getValue();
    EntityFigure connectionSource=null;
    for (    Object child : extractedClass.getMethodsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(extractedMethod.getName()))       connectionSource=entity;
    }
    for (    Entry<FieldInstructionObject,Integer> map : connectionMap.entrySet()) {
      FieldInstructionObject field=map.getKey();
      Integer occurences=map.getValue();
      EntityFigure fieldFigure=new EntityFigure(field.getName(),EntityFigure.FIELD);
      boolean contains=false;
      for (      Object child : source.getFieldsCompartment().getChildren()) {
        EntityFigure entity=(EntityFigure)child;
        if (entity.getName().equals(fieldFigure.getName())) {
          contains=true;
          connections.add(connectionSource.addToSourceWeakReadConnection(ConnectionType.READ_FIELD_SOURCE,entity,occurences));
        }
      }
      if (!contains) {
        source.getFieldsCompartment().add(fieldFigure);
        connections.add(connectionSource.addToSourceWeakReadConnection(ConnectionType.READ_FIELD_SOURCE,fieldFigure,occurences));
      }
    }
  }
  for (  Entry<MethodObject,Map<FieldInstructionObject,Integer>> entry : data.getExternalFieldWriteMap().entrySet()) {
    MethodObject extractedMethod=entry.getKey();
    Map<FieldInstructionObject,Integer> connectionMap=entry.getValue();
    EntityFigure connectionSource=null;
    for (    Object child : extractedClass.getMethodsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(extractedMethod.getName()))       connectionSource=entity;
    }
    for (    Entry<FieldInstructionObject,Integer> map : connectionMap.entrySet()) {
      FieldInstructionObject field=map.getKey();
      Integer occurences=map.getValue();
      EntityFigure fieldFigure=new EntityFigure(field.getName(),EntityFigure.FIELD);
      boolean contains=false;
      for (      Object child : source.getFieldsCompartment().getChildren()) {
        EntityFigure entity=(EntityFigure)child;
        if (entity.getName().equals(fieldFigure.getName())) {
          contains=true;
          connections.add(connectionSource.addToSourceWeakWriteConnection(ConnectionType.WRITE_FIELD_SOURCE,entity,occurences));
        }
      }
      if (!contains) {
        source.getFieldsCompartment().add(fieldFigure);
        connections.add(connectionSource.addToSourceWeakWriteConnection(ConnectionType.WRITE_FIELD_SOURCE,fieldFigure,occurences));
      }
    }
  }
  int startPointX=100;
  int startPointY=50;
  int gap=300;
  primary.add(source,new Rectangle(startPointX,startPointY,classWidth,-1));
  primary.add(extractedClass,new Rectangle(startPointX + classWidth + gap,startPointY,classWidth,-1));
  root.add(connections,""String_Node_Str"");
  this.canvas=new FigureCanvas(parent,SWT.DOUBLE_BUFFERED);
}","public GodClassDiagram(GodClassVisualizationData data,Composite parent){
  root=new LayeredPane();
  primary=new Layer();
  primary.setLayoutManager(new XYLayout());
  root.setFont(parent.getFont());
  root.add(primary,""String_Node_Str"");
  connections=new ConnectionLayer();
  int classWidth=200;
  final ClassFigure source=new ClassFigure(data.getSourceClass().getName(),DecorationConstants.classColor);
  source.setToolTip(new Label(""String_Node_Str""));
  source.addTwoCompartments();
  final ClassFigure extractedClass=new ClassFigure(""String_Node_Str"",DecorationConstants.classColor);
  extractedClass.addTwoCompartments();
  extractedClass.setToolTip(new Label(""String_Node_Str""));
  for (  FieldObject field : data.getExtractedFields()) {
    EntityFigure fieldFigure=new EntityFigure(field.getName(),DecorationConstants.FIELD);
    extractedClass.getFieldsCompartment().add(fieldFigure);
  }
  for (  MethodObject method : data.getExtractedMethods()) {
    EntityFigure methodFigure=new EntityFigure(method.getName(),DecorationConstants.METHOD);
    extractedClass.getMethodsCompartment().add(methodFigure);
  }
  Set<Entry<MethodObject,Map<MethodInvocationObject,Integer>>> internalMethodInvocation=data.getInternalMethodInvocationMap().entrySet();
  for (  Entry<MethodObject,Map<MethodInvocationObject,Integer>> entry : internalMethodInvocation) {
    MethodObject extractedMethod=entry.getKey();
    Map<MethodInvocationObject,Integer> connectionMap=entry.getValue();
    EntityFigure connectionSource=null;
    for (    Object child : extractedClass.getMethodsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(extractedMethod.getName()))       connectionSource=entity;
    }
    for (    Entry<MethodInvocationObject,Integer> map : connectionMap.entrySet()) {
      MethodInvocationObject method=map.getKey();
      Integer occurences=map.getValue();
      EntityFigure methodFigure=new EntityFigure(method.getMethodName(),DecorationConstants.METHOD);
      for (      Object child : extractedClass.getMethodsCompartment().getChildren()) {
        EntityFigure entity=(EntityFigure)child;
        if (entity.getName().equals(methodFigure.getName())) {
          connections.add(connectionSource.addToSameClassMethodConnectionRR(ConnectionType.METHOD_CALL_TARGET,entity,occurences,classWidth));
        }
      }
    }
  }
  for (  Entry<MethodObject,Map<MethodInvocationObject,Integer>> entry : data.getExternalMethodInvocationMap().entrySet()) {
    MethodObject extractedMethod=entry.getKey();
    Map<MethodInvocationObject,Integer> connectionMap=entry.getValue();
    EntityFigure connectionSource=null;
    for (    Object child : extractedClass.getMethodsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(extractedMethod.getName()))       connectionSource=entity;
    }
    for (    Entry<MethodInvocationObject,Integer> map : connectionMap.entrySet()) {
      MethodInvocationObject method=map.getKey();
      Integer occurences=map.getValue();
      EntityFigure methodFigure=new EntityFigure(method.getMethodName(),DecorationConstants.METHOD);
      boolean contains=false;
      for (      Object child : source.getMethodsCompartment().getChildren()) {
        EntityFigure entity=(EntityFigure)child;
        if (entity.getName().equals(methodFigure.getName())) {
          contains=true;
          connections.add(connectionSource.addToSourceMethodConnection(ConnectionType.METHOD_CALL_SOURCE,entity,occurences));
        }
      }
      if (!contains) {
        source.getMethodsCompartment().add(methodFigure);
        connections.add(connectionSource.addToSourceMethodConnection(ConnectionType.METHOD_CALL_SOURCE,methodFigure,occurences));
      }
    }
  }
  for (  Entry<MethodObject,Map<FieldInstructionObject,Integer>> entry : data.getInternalFieldReadMap().entrySet()) {
    MethodObject extractedMethod=entry.getKey();
    Map<FieldInstructionObject,Integer> connectionMap=entry.getValue();
    EntityFigure connectionSource=null;
    for (    Object child : extractedClass.getMethodsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(extractedMethod.getName()))       connectionSource=entity;
    }
    for (    Entry<FieldInstructionObject,Integer> map : connectionMap.entrySet()) {
      FieldInstructionObject field=map.getKey();
      Integer occurences=map.getValue();
      EntityFigure fieldFigure=new EntityFigure(field.getName(),DecorationConstants.FIELD);
      for (      Object child : extractedClass.getFieldsCompartment().getChildren()) {
        EntityFigure entity=(EntityFigure)child;
        if (entity.getName().equals(fieldFigure.getName())) {
          connections.add(connectionSource.addToSameClassReadConnectionRR(ConnectionType.READ_FIELD_TARGET,entity,occurences,classWidth));
        }
      }
    }
  }
  for (  Entry<MethodObject,Map<FieldInstructionObject,Integer>> entry : data.getInternalFieldWriteMap().entrySet()) {
    MethodObject extractedMethod=entry.getKey();
    Map<FieldInstructionObject,Integer> connectionMap=entry.getValue();
    EntityFigure connectionSource=null;
    for (    Object child : extractedClass.getMethodsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(extractedMethod.getName()))       connectionSource=entity;
    }
    for (    Entry<FieldInstructionObject,Integer> map : connectionMap.entrySet()) {
      FieldInstructionObject field=map.getKey();
      Integer occurences=map.getValue();
      EntityFigure fieldFigure=new EntityFigure(field.getName(),DecorationConstants.FIELD);
      for (      Object child : extractedClass.getFieldsCompartment().getChildren()) {
        EntityFigure entity=(EntityFigure)child;
        if (entity.getName().equals(fieldFigure.getName())) {
          connections.add(connectionSource.addToSameClassWriteConnectionRR(ConnectionType.WRITE_FIELD_TARGET,entity,occurences,classWidth));
        }
      }
    }
  }
  for (  Entry<MethodObject,Map<FieldInstructionObject,Integer>> entry : data.getExternalFieldReadMap().entrySet()) {
    MethodObject extractedMethod=entry.getKey();
    Map<FieldInstructionObject,Integer> connectionMap=entry.getValue();
    EntityFigure connectionSource=null;
    for (    Object child : extractedClass.getMethodsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(extractedMethod.getName()))       connectionSource=entity;
    }
    for (    Entry<FieldInstructionObject,Integer> map : connectionMap.entrySet()) {
      FieldInstructionObject field=map.getKey();
      Integer occurences=map.getValue();
      EntityFigure fieldFigure=new EntityFigure(field.getName(),DecorationConstants.FIELD);
      boolean contains=false;
      for (      Object child : source.getFieldsCompartment().getChildren()) {
        EntityFigure entity=(EntityFigure)child;
        if (entity.getName().equals(fieldFigure.getName())) {
          contains=true;
          connections.add(connectionSource.addToSourceWeakReadConnection(ConnectionType.READ_FIELD_SOURCE,entity,occurences));
        }
      }
      if (!contains) {
        source.getFieldsCompartment().add(fieldFigure);
        connections.add(connectionSource.addToSourceWeakReadConnection(ConnectionType.READ_FIELD_SOURCE,fieldFigure,occurences));
      }
    }
  }
  for (  Entry<MethodObject,Map<FieldInstructionObject,Integer>> entry : data.getExternalFieldWriteMap().entrySet()) {
    MethodObject extractedMethod=entry.getKey();
    Map<FieldInstructionObject,Integer> connectionMap=entry.getValue();
    EntityFigure connectionSource=null;
    for (    Object child : extractedClass.getMethodsCompartment().getChildren()) {
      EntityFigure entity=(EntityFigure)child;
      if (entity.getName().equals(extractedMethod.getName()))       connectionSource=entity;
    }
    for (    Entry<FieldInstructionObject,Integer> map : connectionMap.entrySet()) {
      FieldInstructionObject field=map.getKey();
      Integer occurences=map.getValue();
      EntityFigure fieldFigure=new EntityFigure(field.getName(),DecorationConstants.FIELD);
      boolean contains=false;
      for (      Object child : source.getFieldsCompartment().getChildren()) {
        EntityFigure entity=(EntityFigure)child;
        if (entity.getName().equals(fieldFigure.getName())) {
          contains=true;
          connections.add(connectionSource.addToSourceWeakWriteConnection(ConnectionType.WRITE_FIELD_SOURCE,entity,occurences));
        }
      }
      if (!contains) {
        source.getFieldsCompartment().add(fieldFigure);
        connections.add(connectionSource.addToSourceWeakWriteConnection(ConnectionType.WRITE_FIELD_SOURCE,fieldFigure,occurences));
      }
    }
  }
  int startPointX=100;
  int startPointY=50;
  int gap=300;
  primary.add(source,new Rectangle(startPointX,startPointY,classWidth,-1));
  primary.add(extractedClass,new Rectangle(startPointX + classWidth + gap,startPointY,classWidth,-1));
  root.add(connections,""String_Node_Str"");
  this.canvas=new FigureCanvas(parent,SWT.DOUBLE_BUFFERED);
}"
12105,"private List<CFGNode> process(List<CFGNode> previousNodes,CompositeStatementObject composite){
  if (composite instanceof TryStatementObject) {
    AbstractStatement firstStatement=composite.getStatements().get(0);
    composite=(CompositeStatementObject)firstStatement;
  }
  int i=0;
  for (  AbstractStatement abstractStatement : composite.getStatements()) {
    if (abstractStatement instanceof StatementObject) {
      StatementObject statement=(StatementObject)abstractStatement;
      previousNodes=processNonCompositeStatement(previousNodes,statement,composite);
    }
 else     if (abstractStatement instanceof CompositeStatementObject) {
      CompositeStatementObject compositeStatement=(CompositeStatementObject)abstractStatement;
      if (compositeStatement.getStatement() instanceof Block) {
        previousNodes=process(previousNodes,compositeStatement);
      }
 else       if (compositeStatement instanceof TryStatementObject) {
        TryStatementObject tryStatement=(TryStatementObject)compositeStatement;
        if (!tryStatement.hasResources()) {
          CFGTryNode tryNode=new CFGTryNode(compositeStatement);
          directlyNestedNodeInTryBlock(tryNode);
          directlyNestedNodesInTryBlocks.put(tryNode,new ArrayList<CFGNode>());
          AbstractStatement firstStatement=compositeStatement.getStatements().get(0);
          previousNodes=process(previousNodes,(CompositeStatementObject)firstStatement);
        }
 else {
          CFGTryNode tryNode=new CFGTryNode(compositeStatement);
          directlyNestedNodeInTryBlock(tryNode);
          nodes.add(tryNode);
          directlyNestedNodesInTryBlocks.put(tryNode,new ArrayList<CFGNode>());
          createTopDownFlow(previousNodes,tryNode);
          ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
          currentNodes.add(tryNode);
          previousNodes=currentNodes;
          AbstractStatement firstStatement=compositeStatement.getStatements().get(0);
          previousNodes=process(previousNodes,(CompositeStatementObject)firstStatement);
        }
      }
 else       if (isLoop(compositeStatement)) {
        CFGBranchNode currentNode=new CFGBranchLoopNode(compositeStatement);
        nodes.add(currentNode);
        directlyNestedNodeInTryBlock(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        previousNodes=new ArrayList<CFGNode>();
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes.addAll(process(currentNodes,compositeStatement));
        for (        CFGNode previousNode : previousNodes) {
          Flow flow=new Flow(previousNode,currentNode);
          if (previousNode instanceof CFGBranchNode) {
            if (previousNode.equals(currentNode))             flow.setTrueControlFlow(true);
 else             flow.setFalseControlFlow(true);
          }
          flow.setLoopbackFlow(true);
          edges.add(flow);
        }
        if (previousNodes.size() > 1) {
          List<CFGBranchConditionalNode> conditionalNodes=unjoinedConditionalNodes.pop();
          for (          CFGBranchConditionalNode conditionalNode : conditionalNodes) {
            conditionalNode.setJoinNode(currentNode);
          }
        }
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof DoStatement) {
        List<CFGNode> tmpNodes=previousNodes;
        previousNodes=process(previousNodes,compositeStatement);
        CFGBranchNode currentNode=new CFGBranchDoLoopNode(compositeStatement);
        nodes.add(currentNode);
        directlyNestedNodeInTryBlock(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        CFGNode topNode=getCommonNextNode(tmpNodes);
        if (topNode == null)         topNode=(CFGNode)nodes.toArray()[0];
        Flow flow=new Flow(currentNode,topNode);
        flow.setTrueControlFlow(true);
        flow.setLoopbackFlow(true);
        edges.add(flow);
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof SwitchStatement) {
        int action=getAction(composite,i,compositeStatement);
        previousNodes=processSwitchStatement(previousNodes,compositeStatement,action);
      }
 else       if (compositeStatement.getStatement() instanceof IfStatement) {
        int action=getAction(composite,i,compositeStatement);
        previousNodes=processIfStatement(previousNodes,compositeStatement,action);
      }
    }
    i++;
  }
  return previousNodes;
}","private List<CFGNode> process(List<CFGNode> previousNodes,CompositeStatementObject composite){
  if (composite instanceof TryStatementObject) {
    AbstractStatement firstStatement=composite.getStatements().get(0);
    composite=(CompositeStatementObject)firstStatement;
  }
  int i=0;
  for (  AbstractStatement abstractStatement : composite.getStatements()) {
    if (abstractStatement instanceof StatementObject) {
      StatementObject statement=(StatementObject)abstractStatement;
      previousNodes=processNonCompositeStatement(previousNodes,statement,composite);
    }
 else     if (abstractStatement instanceof CompositeStatementObject) {
      CompositeStatementObject compositeStatement=(CompositeStatementObject)abstractStatement;
      if (compositeStatement.getStatement() instanceof Block) {
        previousNodes=process(previousNodes,compositeStatement);
      }
 else       if (compositeStatement instanceof TryStatementObject) {
        TryStatementObject tryStatement=(TryStatementObject)compositeStatement;
        if (!tryStatement.hasResources()) {
          CFGTryNode tryNode=new CFGTryNode(compositeStatement);
          directlyNestedNodeInTryBlock(tryNode);
          directlyNestedNodesInTryBlocks.put(tryNode,new ArrayList<CFGNode>());
          AbstractStatement firstStatement=compositeStatement.getStatements().get(0);
          previousNodes=process(previousNodes,(CompositeStatementObject)firstStatement);
        }
 else {
          CFGTryNode tryNode=new CFGTryNode(compositeStatement);
          directlyNestedNodeInTryBlock(tryNode);
          nodes.add(tryNode);
          directlyNestedNodesInTryBlocks.put(tryNode,new ArrayList<CFGNode>());
          createTopDownFlow(previousNodes,tryNode);
          ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
          currentNodes.add(tryNode);
          previousNodes=currentNodes;
          AbstractStatement firstStatement=compositeStatement.getStatements().get(0);
          previousNodes=process(previousNodes,(CompositeStatementObject)firstStatement);
        }
      }
 else       if (isLoop(compositeStatement)) {
        previousNodes=processLoopStatement(previousNodes,compositeStatement);
      }
 else       if (compositeStatement.getStatement() instanceof DoStatement) {
        previousNodes=processDoStatement(previousNodes,compositeStatement);
      }
 else       if (compositeStatement.getStatement() instanceof SwitchStatement) {
        int action=getAction(composite,i,compositeStatement);
        previousNodes=processSwitchStatement(previousNodes,compositeStatement,action);
      }
 else       if (compositeStatement.getStatement() instanceof IfStatement) {
        int action=getAction(composite,i,compositeStatement);
        previousNodes=processIfStatement(previousNodes,compositeStatement,action);
      }
    }
    i++;
  }
  return previousNodes;
}"
12106,"private List<CFGNode> processIfStatement(List<CFGNode> previousNodes,CompositeStatementObject compositeStatement,int action){
  CFGBranchIfNode currentNode=new CFGBranchIfNode(compositeStatement);
  handleAction(currentNode,action);
  nodes.add(currentNode);
  directlyNestedNodeInTryBlock(currentNode);
  createTopDownFlow(previousNodes,currentNode);
  previousNodes=new ArrayList<CFGNode>();
  List<AbstractStatement> ifStatementList=compositeStatement.getStatements();
  AbstractStatement thenClause=ifStatementList.get(0);
  if (thenClause instanceof StatementObject) {
    StatementObject thenClauseStatement=(StatementObject)thenClause;
    CFGNode thenClauseNode=createNonCompositeNode(thenClauseStatement);
    nodes.add(thenClauseNode);
    ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
    currentNodes.add(currentNode);
    createTopDownFlow(currentNodes,thenClauseNode);
    previousNodes.add(thenClauseNode);
  }
 else   if (thenClause instanceof CompositeStatementObject) {
    CompositeStatementObject thenClauseCompositeStatement=(CompositeStatementObject)thenClause;
    ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
    currentNodes.add(currentNode);
    if (thenClauseCompositeStatement.getStatement() instanceof IfStatement)     previousNodes.addAll(processIfStatement(currentNodes,thenClauseCompositeStatement,JOIN_TOP_LIST));
 else     previousNodes.addAll(process(currentNodes,thenClauseCompositeStatement));
  }
  if (ifStatementList.size() == 2) {
    AbstractStatement elseClause=ifStatementList.get(1);
    if (elseClause instanceof StatementObject) {
      StatementObject elseClauseStatement=(StatementObject)elseClause;
      CFGNode elseClauseNode=createNonCompositeNode(elseClauseStatement);
      nodes.add(elseClauseNode);
      ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
      currentNodes.add(currentNode);
      createTopDownFlow(currentNodes,elseClauseNode);
      previousNodes.add(elseClauseNode);
    }
 else     if (elseClause instanceof CompositeStatementObject) {
      CompositeStatementObject elseClauseCompositeStatement=(CompositeStatementObject)elseClause;
      ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
      currentNodes.add(currentNode);
      if (elseClauseCompositeStatement.getStatement() instanceof IfStatement)       previousNodes.addAll(processIfStatement(currentNodes,elseClauseCompositeStatement,JOIN_TOP_LIST));
 else       previousNodes.addAll(process(currentNodes,elseClauseCompositeStatement));
    }
  }
 else {
    previousNodes.add(currentNode);
  }
  return previousNodes;
}","private List<CFGNode> processIfStatement(List<CFGNode> previousNodes,CompositeStatementObject compositeStatement,int action){
  CFGBranchIfNode currentNode=new CFGBranchIfNode(compositeStatement);
  handleAction(currentNode,action);
  nodes.add(currentNode);
  directlyNestedNodeInTryBlock(currentNode);
  createTopDownFlow(previousNodes,currentNode);
  previousNodes=new ArrayList<CFGNode>();
  List<AbstractStatement> ifStatementList=compositeStatement.getStatements();
  AbstractStatement thenClause=ifStatementList.get(0);
  if (thenClause instanceof StatementObject) {
    StatementObject thenClauseStatement=(StatementObject)thenClause;
    CFGNode thenClauseNode=createNonCompositeNode(thenClauseStatement);
    nodes.add(thenClauseNode);
    ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
    currentNodes.add(currentNode);
    createTopDownFlow(currentNodes,thenClauseNode);
    previousNodes.add(thenClauseNode);
  }
 else   if (thenClause instanceof CompositeStatementObject) {
    CompositeStatementObject thenClauseCompositeStatement=(CompositeStatementObject)thenClause;
    ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
    currentNodes.add(currentNode);
    if (thenClauseCompositeStatement.getStatement() instanceof IfStatement)     previousNodes.addAll(processIfStatement(currentNodes,thenClauseCompositeStatement,JOIN_TOP_LIST));
 else     if (thenClauseCompositeStatement.getStatement() instanceof SwitchStatement)     previousNodes.addAll(processSwitchStatement(currentNodes,thenClauseCompositeStatement,JOIN_TOP_LIST));
 else     if (isLoop(thenClauseCompositeStatement))     previousNodes.addAll(processLoopStatement(currentNodes,thenClauseCompositeStatement));
 else     if (thenClauseCompositeStatement.getStatement() instanceof DoStatement)     previousNodes.addAll(processDoStatement(currentNodes,thenClauseCompositeStatement));
 else     previousNodes.addAll(process(currentNodes,thenClauseCompositeStatement));
  }
  if (ifStatementList.size() == 2) {
    AbstractStatement elseClause=ifStatementList.get(1);
    if (elseClause instanceof StatementObject) {
      StatementObject elseClauseStatement=(StatementObject)elseClause;
      CFGNode elseClauseNode=createNonCompositeNode(elseClauseStatement);
      nodes.add(elseClauseNode);
      ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
      currentNodes.add(currentNode);
      createTopDownFlow(currentNodes,elseClauseNode);
      previousNodes.add(elseClauseNode);
    }
 else     if (elseClause instanceof CompositeStatementObject) {
      CompositeStatementObject elseClauseCompositeStatement=(CompositeStatementObject)elseClause;
      ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
      currentNodes.add(currentNode);
      if (elseClauseCompositeStatement.getStatement() instanceof IfStatement)       previousNodes.addAll(processIfStatement(currentNodes,elseClauseCompositeStatement,JOIN_TOP_LIST));
 else       if (elseClauseCompositeStatement.getStatement() instanceof SwitchStatement)       previousNodes.addAll(processSwitchStatement(currentNodes,elseClauseCompositeStatement,JOIN_TOP_LIST));
 else       if (isLoop(elseClauseCompositeStatement))       previousNodes.addAll(processLoopStatement(currentNodes,elseClauseCompositeStatement));
 else       if (elseClauseCompositeStatement.getStatement() instanceof DoStatement)       previousNodes.addAll(processDoStatement(currentNodes,elseClauseCompositeStatement));
 else       previousNodes.addAll(process(currentNodes,elseClauseCompositeStatement));
    }
  }
 else {
    previousNodes.add(currentNode);
  }
  return previousNodes;
}"
12107,"private void traverse(MappingState state,PDGNodeMapping nodeMapping){
  PDGNode nodeG1=nodeMapping.getNodeG1();
  PDGNode nodeG2=nodeMapping.getNodeG2();
  Iterator<GraphEdge> nodeG1EdgeIterator=nodeG1.getDependenceIterator();
  while (nodeG1EdgeIterator.hasNext()) {
    PDGDependence edgeG1=(PDGDependence)nodeG1EdgeIterator.next();
    Iterator<GraphEdge> nodeG2EdgeIterator=nodeG2.getDependenceIterator();
    while (nodeG2EdgeIterator.hasNext()) {
      PDGDependence edgeG2=(PDGDependence)nodeG2EdgeIterator.next();
      PDGEdgeMapping edgeMapping=new PDGEdgeMapping(edgeG1,edgeG2);
      if (edgeMapping.isCompatible(nodeMapping)) {
        PDGNode dstNodeG1=null;
        PDGNode dstNodeG2=null;
        if (edgeG1.getSrc().equals(nodeG1) && edgeG2.getSrc().equals(nodeG2)) {
          dstNodeG1=(PDGNode)edgeG1.getDst();
          dstNodeG2=(PDGNode)edgeG2.getDst();
        }
 else         if (edgeG1.getDst().equals(nodeG1) && edgeG2.getDst().equals(nodeG2)) {
          dstNodeG1=(PDGNode)edgeG1.getSrc();
          dstNodeG2=(PDGNode)edgeG2.getSrc();
        }
        if (dstNodeG1 != null && dstNodeG2 != null) {
          if (dstNodeG1 instanceof PDGMethodEntryNode && dstNodeG2 instanceof PDGMethodEntryNode) {
            if (!state.edgeMappings.contains(edgeMapping)) {
              state.edgeMappings.add(edgeMapping);
              state.propagateEdgeMappingToChildren(edgeMapping);
            }
          }
          ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher(nodeMapping.getTypeRoot1(),nodeMapping.getTypeRoot2());
          boolean match;
          if (dstNodeG1 instanceof PDGMethodEntryNode || dstNodeG2 instanceof PDGMethodEntryNode)           match=false;
 else           match=dstNodeG1.getASTStatement().subtreeMatch(astNodeMatcher,dstNodeG2.getASTStatement());
          if (match && astNodeMatcher.isParameterizable()) {
            PDGNodeMapping dstNodeMapping=new PDGNodeMapping(dstNodeG1,dstNodeG2,astNodeMatcher);
            MappingState childState=state.getChildStateWithNodeMapping(dstNodeMapping);
            if (childState != null) {
              if (!childState.edgeMappings.contains(edgeMapping)) {
                childState.edgeMappings.add(edgeMapping);
                childState.propagateEdgeMappingToChildren(edgeMapping);
              }
            }
 else             if (!state.containsAtLeastOneNodeInMappings(dstNodeMapping)) {
              MappingState newMappingState=state.copy();
              state.children.add(newMappingState);
              newMappingState.edgeMappings.add(edgeMapping);
              newMappingState.nodeMappings.add(dstNodeMapping);
              traverse(newMappingState,dstNodeMapping);
            }
          }
        }
      }
    }
  }
}","private void traverse(MappingState state,PDGNodeMapping nodeMapping,Set<PDGNode> visitedNodesG1,Set<PDGNode> visitedNodesG2){
  PDGNode nodeG1=nodeMapping.getNodeG1();
  PDGNode nodeG2=nodeMapping.getNodeG2();
  if (visitedNodesG1.contains(nodeG1) && visitedNodesG2.contains(nodeG2))   return;
  visitedNodesG1.add(nodeG1);
  visitedNodesG2.add(nodeG2);
  Iterator<GraphEdge> nodeG1EdgeIterator=nodeG1.getDependenceIterator();
  while (nodeG1EdgeIterator.hasNext()) {
    PDGDependence edgeG1=(PDGDependence)nodeG1EdgeIterator.next();
    Iterator<GraphEdge> nodeG2EdgeIterator=nodeG2.getDependenceIterator();
    while (nodeG2EdgeIterator.hasNext()) {
      PDGDependence edgeG2=(PDGDependence)nodeG2EdgeIterator.next();
      PDGEdgeMapping edgeMapping=new PDGEdgeMapping(edgeG1,edgeG2);
      if (edgeMapping.isCompatible(nodeMapping)) {
        PDGNode dstNodeG1=null;
        PDGNode dstNodeG2=null;
        if (edgeG1.getSrc().equals(nodeG1) && edgeG2.getSrc().equals(nodeG2)) {
          dstNodeG1=(PDGNode)edgeG1.getDst();
          dstNodeG2=(PDGNode)edgeG2.getDst();
        }
 else         if (edgeG1.getDst().equals(nodeG1) && edgeG2.getDst().equals(nodeG2)) {
          dstNodeG1=(PDGNode)edgeG1.getSrc();
          dstNodeG2=(PDGNode)edgeG2.getSrc();
        }
        if (dstNodeG1 != null && dstNodeG2 != null) {
          if (dstNodeG1 instanceof PDGMethodEntryNode && dstNodeG2 instanceof PDGMethodEntryNode) {
            if (!state.edgeMappings.contains(edgeMapping)) {
              state.edgeMappings.add(edgeMapping);
              state.propagateEdgeMappingToChildren(edgeMapping);
            }
          }
          ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher(nodeMapping.getTypeRoot1(),nodeMapping.getTypeRoot2());
          boolean match;
          if (dstNodeG1 instanceof PDGMethodEntryNode || dstNodeG2 instanceof PDGMethodEntryNode)           match=false;
 else           match=dstNodeG1.getASTStatement().subtreeMatch(astNodeMatcher,dstNodeG2.getASTStatement());
          if (match && astNodeMatcher.isParameterizable()) {
            PDGNode nodeG1ControlParent=dstNodeG1.getControlDependenceParent();
            PDGNode nodeG2ControlParent=dstNodeG2.getControlDependenceParent();
            boolean proceedToNodeMapping=false;
            if (state.containsBothNodesInMappings(nodeG1ControlParent,nodeG2ControlParent))             proceedToNodeMapping=true;
            if (!state.containsNodeG1InMappings(nodeG1ControlParent) && !state.containsNodeG2InMappings(nodeG2ControlParent))             proceedToNodeMapping=true;
            if (proceedToNodeMapping) {
              PDGNodeMapping dstNodeMapping=new PDGNodeMapping(dstNodeG1,dstNodeG2,astNodeMatcher);
              MappingState childState=state.getChildStateWithNodeMapping(dstNodeMapping);
              if (childState != null) {
                if (!childState.edgeMappings.contains(edgeMapping)) {
                  childState.edgeMappings.add(edgeMapping);
                  childState.propagateEdgeMappingToChildren(edgeMapping);
                }
              }
 else               if (!state.containsAtLeastOneNodeInMappings(dstNodeMapping)) {
                MappingState newMappingState=state.copy();
                state.children.add(newMappingState);
                newMappingState.edgeMappings.add(edgeMapping);
                newMappingState.nodeMappings.add(dstNodeMapping);
                traverse(newMappingState,dstNodeMapping,visitedNodesG1,visitedNodesG2);
              }
            }
          }
        }
      }
    }
  }
}"
12108,"public MappingState(MappingState previous,PDGNodeMapping initialNodeMapping){
  this.nodeMappings=new LinkedHashSet<PDGNodeMapping>();
  this.edgeMappings=new LinkedHashSet<PDGEdgeMapping>();
  this.children=new ArrayList<MappingState>();
  if (previous != null) {
    nodeMappings.addAll(previous.nodeMappings);
    edgeMappings.addAll(previous.edgeMappings);
  }
  if (!containsAtLeastOneNodeInMappings(initialNodeMapping))   this.nodeMappings.add(initialNodeMapping);
  traverse(this,initialNodeMapping);
}","public MappingState(MappingState previous,PDGNodeMapping initialNodeMapping){
  this.nodeMappings=new LinkedHashSet<PDGNodeMapping>();
  this.edgeMappings=new LinkedHashSet<PDGEdgeMapping>();
  this.children=new ArrayList<MappingState>();
  if (previous != null) {
    nodeMappings.addAll(previous.nodeMappings);
    edgeMappings.addAll(previous.edgeMappings);
  }
  if (!containsAtLeastOneNodeInMappings(initialNodeMapping))   this.nodeMappings.add(initialNodeMapping);
  traverse(this,initialNodeMapping,new LinkedHashSet<PDGNode>(),new LinkedHashSet<PDGNode>());
}"
12109,"private void processPDGNodes(){
  if (monitor != null)   monitor.beginTask(""String_Node_Str"",pdg1.getTotalNumberOfStatements() * pdg2.getTotalNumberOfStatements());
  List<MappingState> finalStates=new ArrayList<MappingState>();
  Iterator<GraphNode> nodeIterator1=pdg1.getNodeIterator();
  while (nodeIterator1.hasNext()) {
    PDGNode node1=(PDGNode)nodeIterator1.next();
    Iterator<GraphNode> nodeIterator2=pdg2.getNodeIterator();
    List<MappingState> currentStates=new ArrayList<MappingState>();
    while (nodeIterator2.hasNext()) {
      PDGNode node2=(PDGNode)nodeIterator2.next();
      ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher(iCompilationUnit1,iCompilationUnit2);
      boolean match=node1.getASTStatement().subtreeMatch(astNodeMatcher,node2.getASTStatement());
      if (match && astNodeMatcher.isParameterizable()) {
        PDGNodeMapping mapping=new PDGNodeMapping(node1,node2,astNodeMatcher);
        if (finalStates.isEmpty()) {
          MappingState state=new MappingState(null,mapping);
          List<MappingState> maxStates=state.getMaximumCommonSubGraphs();
          for (          MappingState temp : maxStates) {
            if (!currentStates.contains(temp)) {
              currentStates.add(temp);
            }
          }
        }
 else {
          for (          MappingState previousState : finalStates) {
            MappingState state=new MappingState(previousState,mapping);
            List<MappingState> maxStates=state.getMaximumCommonSubGraphs();
            for (            MappingState temp : maxStates) {
              if (!currentStates.contains(temp)) {
                currentStates.add(temp);
              }
            }
          }
        }
      }
      if (monitor != null)       monitor.worked(1);
    }
    if (!currentStates.isEmpty())     finalStates=getMaximumStates(currentStates);
  }
  maximumStates=finalStates;
  if (monitor != null)   monitor.done();
}","private void processPDGNodes(){
  if (monitor != null)   monitor.beginTask(""String_Node_Str"",pdg1.getTotalNumberOfStatements() * pdg2.getTotalNumberOfStatements());
  List<MappingState> finalStates=new ArrayList<MappingState>();
  Iterator<GraphNode> nodeIterator1=pdg1.getNodeIterator();
  while (nodeIterator1.hasNext()) {
    PDGNode node1=(PDGNode)nodeIterator1.next();
    Iterator<GraphNode> nodeIterator2=pdg2.getNodeIterator();
    List<MappingState> currentStates=new ArrayList<MappingState>();
    while (nodeIterator2.hasNext()) {
      PDGNode node2=(PDGNode)nodeIterator2.next();
      ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher(iCompilationUnit1,iCompilationUnit2);
      boolean match=node1.getASTStatement().subtreeMatch(astNodeMatcher,node2.getASTStatement());
      if (match && astNodeMatcher.isParameterizable()) {
        if (finalStates.isEmpty()) {
          PDGNodeMapping mapping=new PDGNodeMapping(node1,node2,astNodeMatcher);
          MappingState state=new MappingState(null,mapping);
          List<MappingState> maxStates=state.getMaximumCommonSubGraphs();
          for (          MappingState temp : maxStates) {
            if (!currentStates.contains(temp)) {
              currentStates.add(temp);
            }
          }
        }
 else {
          for (          MappingState previousState : finalStates) {
            PDGNode nodeG1ControlParent=node1.getControlDependenceParent();
            PDGNode nodeG2ControlParent=node2.getControlDependenceParent();
            boolean proceedToNodeMapping=false;
            if (previousState.containsBothNodesInMappings(nodeG1ControlParent,nodeG2ControlParent))             proceedToNodeMapping=true;
            if (!previousState.containsNodeG1InMappings(nodeG1ControlParent) && !previousState.containsNodeG2InMappings(nodeG2ControlParent))             proceedToNodeMapping=true;
            if (proceedToNodeMapping) {
              PDGNodeMapping mapping=new PDGNodeMapping(node1,node2,astNodeMatcher);
              MappingState state=new MappingState(previousState,mapping);
              List<MappingState> maxStates=state.getMaximumCommonSubGraphs();
              for (              MappingState temp : maxStates) {
                if (!currentStates.contains(temp)) {
                  currentStates.add(temp);
                }
              }
            }
          }
        }
      }
      if (monitor != null)       monitor.worked(1);
    }
    if (!currentStates.isEmpty())     finalStates=getMaximumStates(currentStates);
  }
  maximumStates=finalStates;
  if (monitor != null)   monitor.done();
}"
12110,"private boolean typeBindingMatch(ITypeBinding binding1,ITypeBinding binding2){
  if (binding1.isEqualTo(binding2))   return true;
  ITypeBinding superclass1=binding1.getSuperclass();
  ITypeBinding superclass2=binding2.getSuperclass();
  if (superclass1 != null && superclass2 != null && superclass1.isEqualTo(superclass2))   return true;
  return false;
}","private boolean typeBindingMatch(ITypeBinding binding1,ITypeBinding binding2){
  if (binding1.isEqualTo(binding2))   return true;
  ITypeBinding commonSuperType=commonSuperType(binding1,binding2);
  if (commonSuperType != null && !commonSuperType.getQualifiedName().equals(""String_Node_Str""))   return true;
  return false;
}"
12111,"private void traverse(MappingState state,PDGNodeMapping nodeMapping){
  PDGNode nodeG1=nodeMapping.getNodeG1();
  PDGNode nodeG2=nodeMapping.getNodeG2();
  Iterator<GraphEdge> nodeG1EdgeIterator=nodeG1.getDependenceIterator();
  while (nodeG1EdgeIterator.hasNext()) {
    PDGDependence edgeG1=(PDGDependence)nodeG1EdgeIterator.next();
    Iterator<GraphEdge> nodeG2EdgeIterator=nodeG2.getDependenceIterator();
    while (nodeG2EdgeIterator.hasNext()) {
      PDGDependence edgeG2=(PDGDependence)nodeG2EdgeIterator.next();
      PDGEdgeMapping edgeMapping=new PDGEdgeMapping(edgeG1,edgeG2);
      if (edgeMapping.isCompatible(nodeMapping)) {
        PDGNode dstNodeG1=null;
        PDGNode dstNodeG2=null;
        if (edgeG1.getSrc().equals(nodeG1) && edgeG2.getSrc().equals(nodeG2)) {
          dstNodeG1=(PDGNode)edgeG1.getDst();
          dstNodeG2=(PDGNode)edgeG2.getDst();
        }
 else {
          dstNodeG1=(PDGNode)edgeG1.getSrc();
          dstNodeG2=(PDGNode)edgeG2.getSrc();
        }
        if (dstNodeG1 instanceof PDGMethodEntryNode && dstNodeG2 instanceof PDGMethodEntryNode) {
          if (!state.edgeMappings.contains(edgeMapping)) {
            state.edgeMappings.add(edgeMapping);
            state.propagateEdgeMappingToChildren(edgeMapping);
          }
        }
        ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher(nodeMapping.getTypeRoot1(),nodeMapping.getTypeRoot2());
        boolean match;
        if (dstNodeG1 instanceof PDGMethodEntryNode || dstNodeG2 instanceof PDGMethodEntryNode)         match=false;
 else         match=dstNodeG1.getASTStatement().subtreeMatch(astNodeMatcher,dstNodeG2.getASTStatement());
        if (match) {
          PDGNodeMapping dstNodeMapping=new PDGNodeMapping(dstNodeG1,dstNodeG2,astNodeMatcher);
          MappingState childState=state.getChildStateWithNodeMapping(dstNodeMapping);
          if (childState != null) {
            if (!childState.edgeMappings.contains(edgeMapping)) {
              childState.edgeMappings.add(edgeMapping);
              childState.propagateEdgeMappingToChildren(edgeMapping);
            }
          }
 else           if (!state.containsAtLeastOneNodeInMappings(dstNodeMapping)) {
            MappingState newMappingState=state.copy();
            state.children.add(newMappingState);
            newMappingState.edgeMappings.add(edgeMapping);
            newMappingState.nodeMappings.add(dstNodeMapping);
            traverse(newMappingState,dstNodeMapping);
          }
        }
      }
    }
  }
}","private void traverse(MappingState state,PDGNodeMapping nodeMapping){
  PDGNode nodeG1=nodeMapping.getNodeG1();
  PDGNode nodeG2=nodeMapping.getNodeG2();
  Iterator<GraphEdge> nodeG1EdgeIterator=nodeG1.getDependenceIterator();
  while (nodeG1EdgeIterator.hasNext()) {
    PDGDependence edgeG1=(PDGDependence)nodeG1EdgeIterator.next();
    Iterator<GraphEdge> nodeG2EdgeIterator=nodeG2.getDependenceIterator();
    while (nodeG2EdgeIterator.hasNext()) {
      PDGDependence edgeG2=(PDGDependence)nodeG2EdgeIterator.next();
      PDGEdgeMapping edgeMapping=new PDGEdgeMapping(edgeG1,edgeG2);
      if (edgeMapping.isCompatible(nodeMapping)) {
        PDGNode dstNodeG1=null;
        PDGNode dstNodeG2=null;
        if (edgeG1.getSrc().equals(nodeG1) && edgeG2.getSrc().equals(nodeG2)) {
          dstNodeG1=(PDGNode)edgeG1.getDst();
          dstNodeG2=(PDGNode)edgeG2.getDst();
        }
 else         if (edgeG1.getDst().equals(nodeG1) && edgeG2.getDst().equals(nodeG2)) {
          dstNodeG1=(PDGNode)edgeG1.getSrc();
          dstNodeG2=(PDGNode)edgeG2.getSrc();
        }
        if (dstNodeG1 instanceof PDGMethodEntryNode && dstNodeG2 instanceof PDGMethodEntryNode) {
          if (!state.edgeMappings.contains(edgeMapping)) {
            state.edgeMappings.add(edgeMapping);
            state.propagateEdgeMappingToChildren(edgeMapping);
          }
        }
        ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher(nodeMapping.getTypeRoot1(),nodeMapping.getTypeRoot2());
        boolean match;
        if (dstNodeG1 instanceof PDGMethodEntryNode || dstNodeG2 instanceof PDGMethodEntryNode)         match=false;
 else         match=dstNodeG1.getASTStatement().subtreeMatch(astNodeMatcher,dstNodeG2.getASTStatement());
        if (match && astNodeMatcher.isParameterizable()) {
          PDGNodeMapping dstNodeMapping=new PDGNodeMapping(dstNodeG1,dstNodeG2,astNodeMatcher);
          MappingState childState=state.getChildStateWithNodeMapping(dstNodeMapping);
          if (childState != null) {
            if (!childState.edgeMappings.contains(edgeMapping)) {
              childState.edgeMappings.add(edgeMapping);
              childState.propagateEdgeMappingToChildren(edgeMapping);
            }
          }
 else           if (!state.containsAtLeastOneNodeInMappings(dstNodeMapping)) {
            MappingState newMappingState=state.copy();
            state.children.add(newMappingState);
            newMappingState.edgeMappings.add(edgeMapping);
            newMappingState.nodeMappings.add(dstNodeMapping);
            traverse(newMappingState,dstNodeMapping);
          }
        }
      }
    }
  }
}"
12112,"public boolean isCompatible(PDGNodeMapping nodeMapping){
  if (edgeG1.getClass() == edgeG2.getClass()) {
    if (edgeG1 instanceof PDGControlDependence) {
      return true;
    }
    if (edgeG1 instanceof PDGAbstractDataDependence) {
      AbstractVariable edgeG1Variable=((PDGAbstractDataDependence)edgeG1).getData();
      AbstractVariable edgeG2Variable=((PDGAbstractDataDependence)edgeG2).getData();
      CFGBranchNode edgeG1LoopNode=((PDGAbstractDataDependence)edgeG1).getLoop();
      CFGBranchNode edgeG2LoopNode=((PDGAbstractDataDependence)edgeG2).getLoop();
      if (equalData(edgeG1Variable,edgeG2Variable) || nodeMapping.matchingVariableDifference(edgeG1Variable,edgeG2Variable)) {
        if (edgeG1LoopNode == null && edgeG2LoopNode == null) {
          return true;
        }
 else         if (edgeG1LoopNode != null && edgeG2LoopNode != null) {
          ASTNodeMatcher matcher=new ASTNodeMatcher(nodeMapping.getTypeRoot1(),nodeMapping.getTypeRoot2());
          boolean nodeDiff=edgeG1LoopNode.getASTStatement().subtreeMatch(matcher,edgeG2LoopNode.getASTStatement());
          return nodeDiff;
        }
      }
    }
  }
  return false;
}","public boolean isCompatible(PDGNodeMapping nodeMapping){
  if (edgeG1.getClass() == edgeG2.getClass()) {
    if (edgeG1 instanceof PDGControlDependence) {
      return true;
    }
    if (edgeG1 instanceof PDGAbstractDataDependence) {
      AbstractVariable edgeG1Variable=((PDGAbstractDataDependence)edgeG1).getData();
      AbstractVariable edgeG2Variable=((PDGAbstractDataDependence)edgeG2).getData();
      CFGBranchNode edgeG1LoopNode=((PDGAbstractDataDependence)edgeG1).getLoop();
      CFGBranchNode edgeG2LoopNode=((PDGAbstractDataDependence)edgeG2).getLoop();
      if (equalData(edgeG1Variable,edgeG2Variable) || nodeMapping.matchingVariableDifference(edgeG1Variable,edgeG2Variable)) {
        if (edgeG1LoopNode == null && edgeG2LoopNode == null) {
          return true;
        }
 else         if (edgeG1LoopNode != null && edgeG2LoopNode != null) {
          ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher(nodeMapping.getTypeRoot1(),nodeMapping.getTypeRoot2());
          boolean match=edgeG1LoopNode.getASTStatement().subtreeMatch(astNodeMatcher,edgeG2LoopNode.getASTStatement());
          return match && astNodeMatcher.isParameterizable();
        }
      }
    }
  }
  return false;
}"
12113,"private void processPDGNodes(){
  if (monitor != null)   monitor.beginTask(""String_Node_Str"",pdg1.getTotalNumberOfStatements() * pdg2.getTotalNumberOfStatements());
  List<MappingState> finalStates=new ArrayList<MappingState>();
  Iterator<GraphNode> nodeIterator1=pdg1.getNodeIterator();
  while (nodeIterator1.hasNext()) {
    PDGNode node1=(PDGNode)nodeIterator1.next();
    Iterator<GraphNode> nodeIterator2=pdg2.getNodeIterator();
    List<MappingState> currentStates=new ArrayList<MappingState>();
    while (nodeIterator2.hasNext()) {
      PDGNode node2=(PDGNode)nodeIterator2.next();
      ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher(iCompilationUnit1,iCompilationUnit2);
      boolean match=node1.getASTStatement().subtreeMatch(astNodeMatcher,node2.getASTStatement());
      if (match) {
        PDGNodeMapping mapping=new PDGNodeMapping(node1,node2,astNodeMatcher);
        if (finalStates.isEmpty()) {
          MappingState state=new MappingState(null,mapping);
          List<MappingState> maxStates=state.getMaximumCommonSubGraphs();
          for (          MappingState temp : maxStates) {
            if (!currentStates.contains(temp)) {
              currentStates.add(temp);
            }
          }
        }
 else {
          for (          MappingState previousState : finalStates) {
            MappingState state=new MappingState(previousState,mapping);
            List<MappingState> maxStates=state.getMaximumCommonSubGraphs();
            for (            MappingState temp : maxStates) {
              if (!currentStates.contains(temp)) {
                currentStates.add(temp);
              }
            }
          }
        }
      }
      if (monitor != null)       monitor.worked(1);
    }
    if (!currentStates.isEmpty())     finalStates=getMaximumStates(currentStates);
  }
  maximumStates=finalStates;
  if (monitor != null)   monitor.done();
}","private void processPDGNodes(){
  if (monitor != null)   monitor.beginTask(""String_Node_Str"",pdg1.getTotalNumberOfStatements() * pdg2.getTotalNumberOfStatements());
  List<MappingState> finalStates=new ArrayList<MappingState>();
  Iterator<GraphNode> nodeIterator1=pdg1.getNodeIterator();
  while (nodeIterator1.hasNext()) {
    PDGNode node1=(PDGNode)nodeIterator1.next();
    Iterator<GraphNode> nodeIterator2=pdg2.getNodeIterator();
    List<MappingState> currentStates=new ArrayList<MappingState>();
    while (nodeIterator2.hasNext()) {
      PDGNode node2=(PDGNode)nodeIterator2.next();
      ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher(iCompilationUnit1,iCompilationUnit2);
      boolean match=node1.getASTStatement().subtreeMatch(astNodeMatcher,node2.getASTStatement());
      if (match && astNodeMatcher.isParameterizable()) {
        PDGNodeMapping mapping=new PDGNodeMapping(node1,node2,astNodeMatcher);
        if (finalStates.isEmpty()) {
          MappingState state=new MappingState(null,mapping);
          List<MappingState> maxStates=state.getMaximumCommonSubGraphs();
          for (          MappingState temp : maxStates) {
            if (!currentStates.contains(temp)) {
              currentStates.add(temp);
            }
          }
        }
 else {
          for (          MappingState previousState : finalStates) {
            MappingState state=new MappingState(previousState,mapping);
            List<MappingState> maxStates=state.getMaximumCommonSubGraphs();
            for (            MappingState temp : maxStates) {
              if (!currentStates.contains(temp)) {
                currentStates.add(temp);
              }
            }
          }
        }
      }
      if (monitor != null)       monitor.worked(1);
    }
    if (!currentStates.isEmpty())     finalStates=getMaximumStates(currentStates);
  }
  maximumStates=finalStates;
  if (monitor != null)   monitor.done();
}"
12114,"private SingleVariableDeclaration addParameterToMovedMethod(MethodDeclaration newMethodDeclaration,IVariableBinding variableBinding,ASTRewrite targetRewriter){
  AST ast=newMethodDeclaration.getAST();
  SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
  ITypeBinding typeBinding=variableBinding.getType();
  Type fieldType=null;
  if (typeBinding.isClass() || typeBinding.isInterface()) {
    fieldType=ast.newSimpleType(ast.newSimpleName(typeBinding.getName()));
  }
 else   if (typeBinding.isPrimitive()) {
    String primitiveType=typeBinding.getName();
    if (primitiveType.equals(""String_Node_Str""))     fieldType=ast.newPrimitiveType(PrimitiveType.INT);
 else     if (primitiveType.equals(""String_Node_Str""))     fieldType=ast.newPrimitiveType(PrimitiveType.DOUBLE);
 else     if (primitiveType.equals(""String_Node_Str""))     fieldType=ast.newPrimitiveType(PrimitiveType.BYTE);
 else     if (primitiveType.equals(""String_Node_Str""))     fieldType=ast.newPrimitiveType(PrimitiveType.SHORT);
 else     if (primitiveType.equals(""String_Node_Str""))     fieldType=ast.newPrimitiveType(PrimitiveType.CHAR);
 else     if (primitiveType.equals(""String_Node_Str""))     fieldType=ast.newPrimitiveType(PrimitiveType.LONG);
 else     if (primitiveType.equals(""String_Node_Str""))     fieldType=ast.newPrimitiveType(PrimitiveType.FLOAT);
 else     if (primitiveType.equals(""String_Node_Str""))     fieldType=ast.newPrimitiveType(PrimitiveType.BOOLEAN);
  }
 else   if (typeBinding.isArray()) {
    ITypeBinding elementTypeBinding=typeBinding.getElementType();
    Type elementType=ast.newSimpleType(ast.newSimpleName(elementTypeBinding.getName()));
    fieldType=ast.newArrayType(elementType,typeBinding.getDimensions());
  }
 else   if (typeBinding.isParameterizedType()) {
    fieldType=createParameterizedType(ast,typeBinding,targetRewriter);
  }
  targetRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,fieldType,null);
  targetRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(variableBinding.getName()),null);
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  parametersRewrite.insertLast(parameter,null);
  Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
  typeBindings.add(variableBinding.getType());
  getSimpleTypeBindings(typeBindings,requiredImportDeclarationsInExtractedClass);
  return parameter;
}","private SingleVariableDeclaration addParameterToMovedMethod(MethodDeclaration newMethodDeclaration,IVariableBinding variableBinding,ASTRewrite targetRewriter){
  AST ast=newMethodDeclaration.getAST();
  SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
  ITypeBinding typeBinding=variableBinding.getType();
  Type fieldType=generateTypeFromTypeBinding(typeBinding,ast,targetRewriter);
  targetRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,fieldType,null);
  targetRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,ast.newSimpleName(variableBinding.getName()),null);
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  parametersRewrite.insertLast(parameter,null);
  Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
  typeBindings.add(variableBinding.getType());
  getSimpleTypeBindings(typeBindings,requiredImportDeclarationsInExtractedClass);
  return parameter;
}"
12115,"private Type generateTypeFromTypeBinding(ITypeBinding typeBinding,AST ast,ASTRewrite rewriter){
  Type type=null;
  if (typeBinding.isClass() || typeBinding.isInterface()) {
    type=ast.newSimpleType(ast.newSimpleName(typeBinding.getName()));
  }
 else   if (typeBinding.isPrimitive()) {
    String primitiveType=typeBinding.getName();
    if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.INT);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.DOUBLE);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.BYTE);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.SHORT);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.CHAR);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.LONG);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.FLOAT);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.BOOLEAN);
  }
 else   if (typeBinding.isArray()) {
    ITypeBinding elementTypeBinding=typeBinding.getElementType();
    Type elementType=ast.newSimpleType(ast.newSimpleName(elementTypeBinding.getName()));
    type=ast.newArrayType(elementType,typeBinding.getDimensions());
  }
 else   if (typeBinding.isParameterizedType()) {
    type=createParameterizedType(ast,typeBinding,rewriter);
  }
  return type;
}","private Type generateTypeFromTypeBinding(ITypeBinding typeBinding,AST ast,ASTRewrite rewriter){
  Type type=null;
  if (typeBinding.isClass() || typeBinding.isInterface()) {
    type=ast.newSimpleType(ast.newSimpleName(typeBinding.getName()));
  }
 else   if (typeBinding.isPrimitive()) {
    String primitiveType=typeBinding.getName();
    if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.INT);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.DOUBLE);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.BYTE);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.SHORT);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.CHAR);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.LONG);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.FLOAT);
 else     if (primitiveType.equals(""String_Node_Str""))     type=ast.newPrimitiveType(PrimitiveType.BOOLEAN);
  }
 else   if (typeBinding.isArray()) {
    ITypeBinding elementTypeBinding=typeBinding.getElementType();
    Type elementType=generateTypeFromTypeBinding(elementTypeBinding,ast,rewriter);
    type=ast.newArrayType(elementType,typeBinding.getDimensions());
  }
 else   if (typeBinding.isParameterizedType()) {
    type=createParameterizedType(ast,typeBinding,rewriter);
  }
  return type;
}"
12116,"private int getAction(CompositeStatementObject parentComposite,int i,CompositeStatementObject childComposite){
  int action=PUSH_NEW_LIST;
  List<AbstractStatement> statements=new ArrayList<AbstractStatement>(parentComposite.getStatements());
  CompositeStatementObject parent=(CompositeStatementObject)statements.get(0).getParent();
  if (parent.getStatement() instanceof Block)   parent=(CompositeStatementObject)parent.getParent();
  int position=i;
  while (parent != null && parent instanceof TryStatementObject) {
    CompositeStatementObject tryStatement=parent;
    CompositeStatementObject tryStatementParent=(CompositeStatementObject)tryStatement.getParent();
    List<AbstractStatement> tryParentStatements=new ArrayList<AbstractStatement>(tryStatementParent.getStatements());
    if (tryStatementParent.getStatement() instanceof Block)     tryStatementParent=(CompositeStatementObject)tryStatementParent.getParent();
    int positionOfTryStatementInParent=0;
    int j=0;
    for (    AbstractStatement statement : tryParentStatements) {
      if (statement.equals(tryStatement)) {
        positionOfTryStatementInParent=j;
        break;
      }
      j++;
    }
    if (((TryStatementObject)tryStatement).hasResources()) {
      tryParentStatements.addAll(positionOfTryStatementInParent + 1,statements);
    }
 else {
      tryParentStatements.remove(tryStatement);
      tryParentStatements.addAll(positionOfTryStatementInParent,statements);
    }
    statements=tryParentStatements;
    parent=tryStatementParent;
    if (((TryStatementObject)tryStatement).hasResources())     position=positionOfTryStatementInParent + position + 1;
 else     position=positionOfTryStatementInParent + position;
  }
  if (parent != null && parent.getStatement() instanceof SwitchStatement && parentComposite.getStatement() instanceof Block) {
    List<AbstractStatement> switchStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParentSwitch=0;
    int j=0;
    for (    AbstractStatement statement : switchStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParentSwitch=j;
        break;
      }
      j++;
    }
    switchStatements.remove(parentComposite);
    switchStatements.addAll(positionOfBlockInParentSwitch,statements);
    statements=switchStatements;
    position=positionOfBlockInParentSwitch + position;
  }
  if (statements.size() == 1) {
    action=JOIN_TOP_LIST;
    if (parent != null) {
      if (isLoop(parent))       action=PUSH_NEW_LIST;
 else       if (parent.getStatement() instanceof DoStatement)       action=PLACE_NEW_LIST_SECOND_FROM_TOP;
    }
  }
 else   if (statements.size() > 1) {
    AbstractStatement previousStatement=null;
    if (position >= 1)     previousStatement=statements.get(position - 1);
    int j=0;
    while (previousStatement != null && previousStatement instanceof TryStatementObject && !((TryStatementObject)previousStatement).hasResources()) {
      CompositeStatementObject tryStatement=(CompositeStatementObject)previousStatement;
      AbstractStatement firstStatement=tryStatement.getStatements().get(0);
      if (firstStatement instanceof CompositeStatementObject) {
        CompositeStatementObject tryBlock=(CompositeStatementObject)firstStatement;
        List<AbstractStatement> tryBlockStatements=tryBlock.getStatements();
        if (tryBlockStatements.size() > 0) {
          previousStatement=tryBlockStatements.get(tryBlockStatements.size() - 1);
        }
 else {
          if (position >= 2 + j)           previousStatement=statements.get(position - 2 - j);
 else           previousStatement=null;
        }
      }
      j++;
    }
    if (statements.get(statements.size() - 1).equals(childComposite)) {
      if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement) {
        action=JOIN_SECOND_FROM_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PLACE_NEW_LIST_SECOND_FROM_TOP;
      }
 else {
        action=JOIN_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PUSH_NEW_LIST;
      }
    }
 else {
      if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement)       action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else {
        action=PUSH_NEW_LIST;
        if (parent != null && parent.getStatement() instanceof DoStatement && statements.get(0).getStatement() instanceof IfStatement)         action=PLACE_NEW_LIST_SECOND_FROM_TOP;
      }
    }
  }
  return action;
}","private int getAction(CompositeStatementObject parentComposite,int i,CompositeStatementObject childComposite){
  int action=PUSH_NEW_LIST;
  List<AbstractStatement> statements=new ArrayList<AbstractStatement>(parentComposite.getStatements());
  CompositeStatementObject parent=(CompositeStatementObject)statements.get(0).getParent();
  boolean isBlockWithoutCompositeParent=isBlockWithoutCompositeParent(parent);
  if (parent.getStatement() instanceof Block)   parent=(CompositeStatementObject)parent.getParent();
  int position=i;
  while (parent != null && parent instanceof TryStatementObject) {
    CompositeStatementObject tryStatement=parent;
    CompositeStatementObject tryStatementParent=(CompositeStatementObject)tryStatement.getParent();
    List<AbstractStatement> tryParentStatements=new ArrayList<AbstractStatement>(tryStatementParent.getStatements());
    if (tryStatementParent.getStatement() instanceof Block)     tryStatementParent=(CompositeStatementObject)tryStatementParent.getParent();
    int positionOfTryStatementInParent=0;
    int j=0;
    for (    AbstractStatement statement : tryParentStatements) {
      if (statement.equals(tryStatement)) {
        positionOfTryStatementInParent=j;
        break;
      }
      j++;
    }
    if (((TryStatementObject)tryStatement).hasResources()) {
      tryParentStatements.addAll(positionOfTryStatementInParent + 1,statements);
    }
 else {
      tryParentStatements.remove(tryStatement);
      tryParentStatements.addAll(positionOfTryStatementInParent,statements);
    }
    statements=tryParentStatements;
    parent=tryStatementParent;
    if (((TryStatementObject)tryStatement).hasResources())     position=positionOfTryStatementInParent + position + 1;
 else     position=positionOfTryStatementInParent + position;
  }
  if (parent != null && parent.getStatement() instanceof SwitchStatement && parentComposite.getStatement() instanceof Block) {
    List<AbstractStatement> switchStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParentSwitch=0;
    int j=0;
    for (    AbstractStatement statement : switchStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParentSwitch=j;
        break;
      }
      j++;
    }
    switchStatements.remove(parentComposite);
    switchStatements.addAll(positionOfBlockInParentSwitch,statements);
    statements=switchStatements;
    position=positionOfBlockInParentSwitch + position;
  }
  if (parent != null && isBlockWithoutCompositeParent) {
    List<AbstractStatement> blockStatements=new ArrayList<AbstractStatement>(parent.getStatements());
    int positionOfBlockInParent=0;
    int j=0;
    for (    AbstractStatement statement : blockStatements) {
      if (statement.equals(parentComposite)) {
        positionOfBlockInParent=j;
        break;
      }
      j++;
    }
    blockStatements.remove(parentComposite);
    blockStatements.addAll(positionOfBlockInParent,statements);
    statements=blockStatements;
    position=positionOfBlockInParent + position;
  }
  if (statements.size() == 1) {
    action=JOIN_TOP_LIST;
    if (parent != null) {
      if (isLoop(parent))       action=PUSH_NEW_LIST;
 else       if (parent.getStatement() instanceof DoStatement)       action=PLACE_NEW_LIST_SECOND_FROM_TOP;
    }
  }
 else   if (statements.size() > 1) {
    AbstractStatement previousStatement=null;
    if (position >= 1)     previousStatement=statements.get(position - 1);
    int j=0;
    while (previousStatement != null && previousStatement instanceof TryStatementObject && !((TryStatementObject)previousStatement).hasResources()) {
      CompositeStatementObject tryStatement=(CompositeStatementObject)previousStatement;
      AbstractStatement firstStatement=tryStatement.getStatements().get(0);
      if (firstStatement instanceof CompositeStatementObject) {
        CompositeStatementObject tryBlock=(CompositeStatementObject)firstStatement;
        List<AbstractStatement> tryBlockStatements=tryBlock.getStatements();
        if (tryBlockStatements.size() > 0) {
          previousStatement=tryBlockStatements.get(tryBlockStatements.size() - 1);
        }
 else {
          if (position >= 2 + j)           previousStatement=statements.get(position - 2 - j);
 else           previousStatement=null;
        }
      }
      j++;
    }
    while (previousStatement != null && isBlockWithoutCompositeParent(previousStatement)) {
      CompositeStatementObject block=(CompositeStatementObject)previousStatement;
      List<AbstractStatement> blockStatements=block.getStatements();
      if (blockStatements.size() > 0) {
        previousStatement=blockStatements.get(blockStatements.size() - 1);
      }
    }
    if (statements.get(statements.size() - 1).equals(childComposite)) {
      if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement) {
        action=JOIN_SECOND_FROM_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PLACE_NEW_LIST_SECOND_FROM_TOP;
      }
 else {
        action=JOIN_TOP_LIST;
        if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))         action=PUSH_NEW_LIST;
      }
    }
 else {
      if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement)       action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else {
        action=PUSH_NEW_LIST;
        if (parent != null && parent.getStatement() instanceof DoStatement && statements.get(0).getStatement() instanceof IfStatement)         action=PLACE_NEW_LIST_SECOND_FROM_TOP;
      }
    }
  }
  return action;
}"
12117,"public MappingState(PDGNodeMapping initialNodeMapping){
  this.nodeMappings=new LinkedHashSet<PDGNodeMapping>();
  this.edgeMappings=new LinkedHashSet<PDGEdgeMapping>();
  this.children=new ArrayList<MappingState>();
  this.nodeMappings.add(initialNodeMapping);
  traverse(this,initialNodeMapping);
}","public MappingState(MappingState previous,PDGNodeMapping initialNodeMapping){
  this.nodeMappings=new LinkedHashSet<PDGNodeMapping>();
  this.edgeMappings=new LinkedHashSet<PDGEdgeMapping>();
  this.children=new ArrayList<MappingState>();
  if (previous != null) {
    nodeMappings.addAll(previous.nodeMappings);
    edgeMappings.addAll(previous.edgeMappings);
  }
  if (!containsAtLeastOneNodeInMappings(initialNodeMapping))   this.nodeMappings.add(initialNodeMapping);
  traverse(this,initialNodeMapping);
}"
12118,"private void processPDGNodes(){
  Iterator<GraphNode> nodeIterator1=pdg1.getNodeIterator();
  while (nodeIterator1.hasNext()) {
    PDGNode node1=(PDGNode)nodeIterator1.next();
    Iterator<GraphNode> nodeIterator2=pdg2.getNodeIterator();
    while (nodeIterator2.hasNext()) {
      PDGNode node2=(PDGNode)nodeIterator2.next();
      ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher();
      boolean match=node1.getASTStatement().subtreeMatch(astNodeMatcher,node2.getASTStatement());
      if (match) {
        PDGNodeMapping mapping=new PDGNodeMapping(node1,node2,astNodeMatcher.getDifferences());
        MappingState state=new MappingState(mapping);
        List<MappingState> maxStates=state.getMaximumCommonSubgraph();
        if (maximumState == null) {
          maximumState=maxStates.get(0);
        }
 else         if (maxStates.get(0).getSize() > maximumState.getSize()) {
          maximumState=maxStates.get(0);
        }
      }
    }
  }
}","private void processPDGNodes(){
  List<MappingState> finalStates=new ArrayList<MappingState>();
  Iterator<GraphNode> nodeIterator1=pdg1.getNodeIterator();
  while (nodeIterator1.hasNext()) {
    PDGNode node1=(PDGNode)nodeIterator1.next();
    Iterator<GraphNode> nodeIterator2=pdg2.getNodeIterator();
    List<MappingState> currentStates=new ArrayList<MappingState>();
    while (nodeIterator2.hasNext()) {
      PDGNode node2=(PDGNode)nodeIterator2.next();
      ASTNodeMatcher astNodeMatcher=new ASTNodeMatcher();
      boolean match=node1.getASTStatement().subtreeMatch(astNodeMatcher,node2.getASTStatement());
      if (match) {
        PDGNodeMapping mapping=new PDGNodeMapping(node1,node2,astNodeMatcher.getDifferences());
        if (finalStates.isEmpty()) {
          MappingState state=new MappingState(null,mapping);
          List<MappingState> maxStates=state.getMaximumCommonSubGraphs();
          for (          MappingState temp : maxStates) {
            if (!currentStates.contains(temp)) {
              currentStates.add(temp);
            }
          }
        }
 else {
          for (          MappingState previousState : finalStates) {
            MappingState state=new MappingState(previousState,mapping);
            List<MappingState> maxStates=state.getMaximumCommonSubGraphs();
            for (            MappingState temp : maxStates) {
              if (!currentStates.contains(temp)) {
                currentStates.add(temp);
              }
            }
          }
        }
      }
    }
    if (!currentStates.isEmpty())     finalStates=getMaximumStates(currentStates);
  }
  maximumStates=finalStates;
}"
12119,"public PDGMapper(PDG pdg1,PDG pdg2){
  this.pdg1=pdg1;
  this.pdg2=pdg2;
  processPDGNodes();
}","public PDGMapper(PDG pdg1,PDG pdg2){
  this.pdg1=pdg1;
  this.pdg2=pdg2;
  this.maximumStates=new ArrayList<MappingState>();
  processPDGNodes();
}"
12120,"public MappingState getMaximumState(){
  return maximumState;
}","public MappingState getMaximumState(){
  MappingState maximumState=null;
  if (maximumStates.size() == 1) {
    maximumState=maximumStates.get(0);
  }
 else {
    int minimum=maximumStates.get(0).getDifferenceCount();
    maximumState=maximumStates.get(0);
    for (int i=1; i < maximumStates.size(); i++) {
      MappingState currentState=maximumStates.get(i);
      if (currentState.getDifferenceCount() < minimum) {
        minimum=currentState.getDifferenceCount();
        maximumState=currentState;
      }
    }
  }
  return maximumState;
}"
12121,"private void modifySourceStaticFieldInstructionsInTargetClass(MethodDeclaration sourceMethod,MethodDeclaration newMethodDeclaration,ASTRewrite targetRewriter){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceVariableInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newVariableInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceVariableInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0 && sourceTypeDeclaration.resolveBinding().isEqualTo(variableBinding.getDeclaringClass())) {
        AST ast=newMethodDeclaration.getAST();
        SimpleName qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
        if (simpleName.getParent() instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
          targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
        }
 else         if (!(simpleName.getParent() instanceof QualifiedName)) {
          SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
          QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
          targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
        }
        setPublicModifierToSourceField(variableBinding);
      }
    }
    i++;
  }
}","private void modifySourceStaticFieldInstructionsInTargetClass(MethodDeclaration sourceMethod,MethodDeclaration newMethodDeclaration,ASTRewrite targetRewriter){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceVariableInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newVariableInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceVariableInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
        if (sourceTypeDeclaration.resolveBinding().isEqualTo(variableBinding.getDeclaringClass())) {
          AST ast=newMethodDeclaration.getAST();
          SimpleName qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
          if (simpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
            targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(simpleName.getParent() instanceof QualifiedName)) {
            SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
            QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
            targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
          }
          setPublicModifierToSourceField(variableBinding);
        }
 else {
          AST ast=newMethodDeclaration.getAST();
          SimpleName qualifier=null;
          if ((variableBinding.getModifiers() & Modifier.PUBLIC) != 0) {
            qualifier=ast.newSimpleName(variableBinding.getDeclaringClass().getName());
            Set<ITypeBinding> typeBindings=new LinkedHashSet<ITypeBinding>();
            typeBindings.add(variableBinding.getDeclaringClass());
            getSimpleTypeBindings(typeBindings,requiredImportDeclarationsInExtractedClass);
          }
 else {
            qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
          }
          if (simpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
            targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(simpleName.getParent() instanceof QualifiedName)) {
            SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
            QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
            targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
          }
        }
      }
    }
    i++;
  }
}"
12122,"private void modifySourceStaticFieldInstructionsInTargetClass(MethodDeclaration newMethodDeclaration,ASTRewrite targetRewriter){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceVariableInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newVariableInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceVariableInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0 && sourceTypeDeclaration.resolveBinding().isEqualTo(variableBinding.getDeclaringClass())) {
        AST ast=newMethodDeclaration.getAST();
        SimpleName qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
        if (simpleName.getParent() instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
          targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
        }
 else         if (!(simpleName.getParent() instanceof QualifiedName)) {
          SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
          QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
          targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
        }
        this.additionalTypeBindingsToBeImportedInTargetClass.add(sourceTypeDeclaration.resolveBinding());
        setPublicModifierToSourceField(variableBinding);
      }
    }
    i++;
  }
}","private void modifySourceStaticFieldInstructionsInTargetClass(MethodDeclaration newMethodDeclaration,ASTRewrite targetRewriter){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceVariableInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newVariableInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceVariableInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
        if (sourceTypeDeclaration.resolveBinding().isEqualTo(variableBinding.getDeclaringClass())) {
          AST ast=newMethodDeclaration.getAST();
          SimpleName qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
          if (simpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
            targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(simpleName.getParent() instanceof QualifiedName)) {
            SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
            QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
            targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
          }
          this.additionalTypeBindingsToBeImportedInTargetClass.add(sourceTypeDeclaration.resolveBinding());
          setPublicModifierToSourceField(variableBinding);
        }
 else {
          AST ast=newMethodDeclaration.getAST();
          SimpleName qualifier=null;
          if ((variableBinding.getModifiers() & Modifier.PUBLIC) != 0) {
            qualifier=ast.newSimpleName(variableBinding.getDeclaringClass().getName());
            this.additionalTypeBindingsToBeImportedInTargetClass.add(variableBinding.getDeclaringClass());
          }
 else {
            qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
            this.additionalTypeBindingsToBeImportedInTargetClass.add(sourceTypeDeclaration.resolveBinding());
          }
          if (simpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
            targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(simpleName.getParent() instanceof QualifiedName)) {
            SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
            QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
            targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
          }
        }
      }
    }
    i++;
  }
}"
12123,"public List<TypeCheckEliminationGroup> generateTypeCheckEliminations(Set<ClassObject> classObjectsToBeExamined,IProgressMonitor monitor){
  if (monitor != null)   monitor.beginTask(""String_Node_Str"",classObjectsToBeExamined.size());
  List<TypeCheckElimination> typeCheckEliminationResults=new ArrayList<TypeCheckElimination>();
  List<TypeCheckEliminationGroup> typeCheckEliminationGroups=new ArrayList<TypeCheckEliminationGroup>();
  Map<TypeCheckElimination,List<SimpleName>> staticFieldMap=new LinkedHashMap<TypeCheckElimination,List<SimpleName>>();
  Map<Integer,ArrayList<TypeCheckElimination>> staticFieldRankMap=new TreeMap<Integer,ArrayList<TypeCheckElimination>>();
  Map<String,ArrayList<TypeCheckElimination>> inheritanceTreeMap=new LinkedHashMap<String,ArrayList<TypeCheckElimination>>();
  CompleteInheritanceDetection inheritanceDetection=new CompleteInheritanceDetection(this);
  for (  ClassObject classObject : classObjectsToBeExamined) {
    if (monitor != null && monitor.isCanceled())     throw new OperationCanceledException();
    List<TypeCheckElimination> eliminations=classObject.generateTypeCheckEliminations();
    for (    TypeCheckElimination elimination : eliminations) {
      List<SimpleName> staticFields=elimination.getStaticFields();
      if (!staticFields.isEmpty()) {
        if (allStaticFieldsWithinSystemBoundary(staticFields)) {
          inheritanceHierarchyMatchingWithStaticTypes(elimination,inheritanceDetection);
          boolean isValid=false;
          if (elimination.getTypeField() != null) {
            IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
            ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
            if (typeFieldTypeBinding.isPrimitive() || typeFieldTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeLocalVariable() != null) {
            IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
            ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
            if (typeLocalVariableTypeBinding.isPrimitive() || typeLocalVariableTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeMethodInvocation() != null) {
            MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
            IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
            ITypeBinding typeMethodInvocationDeclaringClass=typeMethodInvocationBinding.getDeclaringClass();
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            ClassObject declaringClassObject=getClassObject(typeMethodInvocationDeclaringClass.getQualifiedName());
            if ((typeMethodInvocationReturnType.isPrimitive() || typeMethodInvocationReturnType.isEnum()) && declaringClassObject != null) {
              MethodDeclaration invokedMethodDeclaration=null;
              ListIterator<MethodObject> methodIterator=declaringClassObject.getMethodIterator();
              while (methodIterator.hasNext()) {
                MethodObject methodObject=methodIterator.next();
                MethodDeclaration methodDeclaration=methodObject.getMethodDeclaration();
                if (typeMethodInvocationBinding.isEqualTo(methodDeclaration.resolveBinding())) {
                  invokedMethodDeclaration=methodDeclaration;
                  break;
                }
              }
              SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(invokedMethodDeclaration);
              if (fieldInstruction != null) {
                ListIterator<FieldObject> fieldIterator=declaringClassObject.getFieldIterator();
                while (fieldIterator.hasNext()) {
                  FieldObject fieldObject=fieldIterator.next();
                  VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                  if (fieldInstruction.resolveBinding().isEqualTo(fragment.resolveBinding())) {
                    elimination.setForeignTypeField(fragment);
                    break;
                  }
                }
                isValid=true;
              }
 else               if (invokedMethodDeclaration.getBody() == null) {
                InheritanceTree tree=elimination.getInheritanceTreeMatchingWithStaticTypes();
                ITypeBinding invokerTypeBinding=handleTypeMethodInvocation(typeMethodInvocation,elimination);
                if (invokerTypeBinding != null) {
                  if (tree != null) {
                    if (invokerTypeBinding.getQualifiedName().equals(tree.getRootNode().getUserObject())) {
                      elimination.setExistingInheritanceTree(tree);
                      if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
                        typeCheckEliminations.add(elimination);
                      }
 else {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                        typeCheckEliminations.add(elimination);
                        inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
                      }
                    }
                  }
 else {
                    InheritanceTree tree2=inheritanceDetection.getTree(invokerTypeBinding.getQualifiedName());
                    if (tree2 != null) {
                      elimination.setExistingInheritanceTree(tree2);
                      if (inheritanceTreeMap.containsKey(tree2.getRootNode().getUserObject())) {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree2.getRootNode().getUserObject());
                        typeCheckEliminations.add(elimination);
                      }
 else {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                        typeCheckEliminations.add(elimination);
                        inheritanceTreeMap.put((String)tree2.getRootNode().getUserObject(),typeCheckEliminations);
                      }
                    }
                  }
                }
              }
            }
          }
          if (isValid) {
            staticFieldMap.put(elimination,staticFields);
            int size=staticFields.size();
            if (staticFieldRankMap.containsKey(size)) {
              ArrayList<TypeCheckElimination> rank=staticFieldRankMap.get(size);
              rank.add(elimination);
            }
 else {
              ArrayList<TypeCheckElimination> rank=new ArrayList<TypeCheckElimination>();
              rank.add(elimination);
              staticFieldRankMap.put(size,rank);
            }
          }
        }
      }
 else {
        if (elimination.getTypeField() != null) {
          IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
          ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeFieldTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeLocalVariable() != null) {
          IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
          ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeLocalVariableTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeMethodInvocation() != null) {
          MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
          IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
          if (typeMethodInvocationBinding.getDeclaringClass().getQualifiedName().equals(""String_Node_Str"") && typeMethodInvocationBinding.getName().equals(""String_Node_Str"")) {
            ITypeBinding invokerTypeBinding=handleTypeMethodInvocation(typeMethodInvocation,elimination);
            if (invokerTypeBinding != null) {
              InheritanceTree tree=inheritanceDetection.getTree(invokerTypeBinding.getQualifiedName());
              elimination.setExistingInheritanceTree(tree);
            }
          }
 else {
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            InheritanceTree tree=inheritanceDetection.getTree(typeMethodInvocationReturnType.getQualifiedName());
            elimination.setExistingInheritanceTree(tree);
          }
        }
        if (elimination.getExistingInheritanceTree() != null) {
          InheritanceTree tree=elimination.getExistingInheritanceTree();
          if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
            ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
            typeCheckEliminations.add(elimination);
          }
 else {
            ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
            typeCheckEliminations.add(elimination);
            inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
          }
        }
      }
    }
    if (monitor != null)     monitor.worked(1);
  }
  for (  String rootNode : inheritanceTreeMap.keySet()) {
    ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(rootNode);
    typeCheckEliminationResults.addAll(typeCheckEliminations);
    typeCheckEliminationGroups.add(handleGroup(typeCheckEliminations));
  }
  List<TypeCheckElimination> sortedEliminations=new ArrayList<TypeCheckElimination>();
  List<Integer> keyList=new ArrayList<Integer>(staticFieldRankMap.keySet());
  ListIterator<Integer> keyListIterator=keyList.listIterator(keyList.size());
  while (keyListIterator.hasPrevious()) {
    Integer states=keyListIterator.previous();
    sortedEliminations.addAll(staticFieldRankMap.get(states));
  }
  while (!sortedEliminations.isEmpty()) {
    TypeCheckElimination selectedElimination=sortedEliminations.get(0);
    List<TypeCheckElimination> affectedEliminations=new ArrayList<TypeCheckElimination>();
    affectedEliminations.add(selectedElimination);
    List<SimpleName> staticFieldUnion=staticFieldMap.get(selectedElimination);
    boolean staticFieldUnionIncreased=true;
    while (staticFieldUnionIncreased) {
      staticFieldUnionIncreased=false;
      for (      TypeCheckElimination elimination : sortedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        if (!affectedEliminations.contains(elimination) && nonEmptyIntersection(staticFieldUnion,staticFields)) {
          staticFieldUnion=constructUnion(staticFieldUnion,staticFields);
          affectedEliminations.add(elimination);
          staticFieldUnionIncreased=true;
        }
      }
    }
    if (affectedEliminations.size() > 1) {
      for (      TypeCheckElimination elimination : affectedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        for (        SimpleName simpleName1 : staticFieldUnion) {
          boolean isContained=false;
          for (          SimpleName simpleName2 : staticFields) {
            if (simpleName1.resolveBinding().isEqualTo(simpleName2.resolveBinding())) {
              isContained=true;
              break;
            }
          }
          if (!isContained)           elimination.addAdditionalStaticField(simpleName1);
        }
      }
    }
    ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
    for (    TypeCheckElimination elimination : affectedEliminations) {
      if (!elimination.isTypeCheckMethodStateSetter())       typeCheckEliminations.add(elimination);
    }
    typeCheckEliminationResults.addAll(typeCheckEliminations);
    typeCheckEliminationGroups.add(handleGroup(typeCheckEliminations));
    sortedEliminations.removeAll(affectedEliminations);
  }
  identifySuperFieldAccessorMethods(typeCheckEliminationResults);
  if (monitor != null)   monitor.done();
  return typeCheckEliminationGroups;
}","public List<TypeCheckEliminationGroup> generateTypeCheckEliminations(Set<ClassObject> classObjectsToBeExamined,IProgressMonitor monitor){
  if (monitor != null)   monitor.beginTask(""String_Node_Str"",classObjectsToBeExamined.size());
  List<TypeCheckElimination> typeCheckEliminationResults=new ArrayList<TypeCheckElimination>();
  List<TypeCheckEliminationGroup> typeCheckEliminationGroups=new ArrayList<TypeCheckEliminationGroup>();
  Map<TypeCheckElimination,List<SimpleName>> staticFieldMap=new LinkedHashMap<TypeCheckElimination,List<SimpleName>>();
  Map<Integer,ArrayList<TypeCheckElimination>> staticFieldRankMap=new TreeMap<Integer,ArrayList<TypeCheckElimination>>();
  Map<String,ArrayList<TypeCheckElimination>> inheritanceTreeMap=new LinkedHashMap<String,ArrayList<TypeCheckElimination>>();
  CompleteInheritanceDetection inheritanceDetection=new CompleteInheritanceDetection(this);
  for (  ClassObject classObject : classObjectsToBeExamined) {
    if (monitor != null && monitor.isCanceled())     throw new OperationCanceledException();
    List<TypeCheckElimination> eliminations=classObject.generateTypeCheckEliminations();
    for (    TypeCheckElimination elimination : eliminations) {
      List<SimpleName> staticFields=elimination.getStaticFields();
      if (!staticFields.isEmpty()) {
        if (allStaticFieldsWithinSystemBoundary(staticFields)) {
          inheritanceHierarchyMatchingWithStaticTypes(elimination,inheritanceDetection);
          boolean isValid=false;
          if (elimination.getTypeField() != null) {
            IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
            ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
            if (typeFieldTypeBinding.isPrimitive() || typeFieldTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeLocalVariable() != null) {
            IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
            ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
            if (typeLocalVariableTypeBinding.isPrimitive() || typeLocalVariableTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeMethodInvocation() != null) {
            MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
            IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
            ITypeBinding typeMethodInvocationDeclaringClass=typeMethodInvocationBinding.getDeclaringClass();
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            ClassObject declaringClassObject=getClassObject(typeMethodInvocationDeclaringClass.getQualifiedName());
            if ((typeMethodInvocationReturnType.isPrimitive() || typeMethodInvocationReturnType.isEnum()) && declaringClassObject != null) {
              MethodDeclaration invokedMethodDeclaration=null;
              ListIterator<MethodObject> methodIterator=declaringClassObject.getMethodIterator();
              while (methodIterator.hasNext()) {
                MethodObject methodObject=methodIterator.next();
                MethodDeclaration methodDeclaration=methodObject.getMethodDeclaration();
                if (typeMethodInvocationBinding.isEqualTo(methodDeclaration.resolveBinding())) {
                  invokedMethodDeclaration=methodDeclaration;
                  break;
                }
              }
              SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(invokedMethodDeclaration);
              if (fieldInstruction != null) {
                ListIterator<FieldObject> fieldIterator=declaringClassObject.getFieldIterator();
                while (fieldIterator.hasNext()) {
                  FieldObject fieldObject=fieldIterator.next();
                  VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                  if (fieldInstruction.resolveBinding().isEqualTo(fragment.resolveBinding())) {
                    elimination.setForeignTypeField(fragment);
                    break;
                  }
                }
                isValid=true;
              }
 else               if (invokedMethodDeclaration.getBody() == null) {
                InheritanceTree tree=elimination.getInheritanceTreeMatchingWithStaticTypes();
                ITypeBinding invokerTypeBinding=handleTypeMethodInvocation(typeMethodInvocation,elimination);
                if (invokerTypeBinding != null) {
                  if (tree != null) {
                    if (invokerTypeBinding.getQualifiedName().equals(tree.getRootNode().getUserObject())) {
                      elimination.setExistingInheritanceTree(tree);
                      if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
                        typeCheckEliminations.add(elimination);
                      }
 else {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                        typeCheckEliminations.add(elimination);
                        inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
                      }
                    }
                  }
 else {
                    InheritanceTree tree2=inheritanceDetection.getTree(invokerTypeBinding.getQualifiedName());
                    if (tree2 != null) {
                      elimination.setExistingInheritanceTree(tree2);
                      if (inheritanceTreeMap.containsKey(tree2.getRootNode().getUserObject())) {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree2.getRootNode().getUserObject());
                        typeCheckEliminations.add(elimination);
                      }
 else {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                        typeCheckEliminations.add(elimination);
                        inheritanceTreeMap.put((String)tree2.getRootNode().getUserObject(),typeCheckEliminations);
                      }
                    }
                  }
                }
              }
            }
          }
          if (isValid) {
            staticFieldMap.put(elimination,staticFields);
            int size=staticFields.size();
            if (staticFieldRankMap.containsKey(size)) {
              ArrayList<TypeCheckElimination> rank=staticFieldRankMap.get(size);
              rank.add(elimination);
            }
 else {
              ArrayList<TypeCheckElimination> rank=new ArrayList<TypeCheckElimination>();
              rank.add(elimination);
              staticFieldRankMap.put(size,rank);
            }
          }
        }
      }
 else {
        if (elimination.getTypeField() != null) {
          IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
          ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeFieldTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeLocalVariable() != null) {
          IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
          ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeLocalVariableTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeMethodInvocation() != null) {
          MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
          IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
          if (typeMethodInvocationBinding.getDeclaringClass().getQualifiedName().equals(""String_Node_Str"") && typeMethodInvocationBinding.getName().equals(""String_Node_Str"")) {
            ITypeBinding invokerTypeBinding=handleTypeMethodInvocation(typeMethodInvocation,elimination);
            if (invokerTypeBinding != null) {
              InheritanceTree tree=inheritanceDetection.getTree(invokerTypeBinding.getQualifiedName());
              elimination.setExistingInheritanceTree(tree);
            }
          }
 else {
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            InheritanceTree tree=inheritanceDetection.getTree(typeMethodInvocationReturnType.getQualifiedName());
            elimination.setExistingInheritanceTree(tree);
          }
        }
        if (elimination.getExistingInheritanceTree() != null) {
          InheritanceTree tree=elimination.getExistingInheritanceTree();
          if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
            ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
            typeCheckEliminations.add(elimination);
          }
 else {
            ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
            typeCheckEliminations.add(elimination);
            inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
          }
        }
      }
    }
    if (monitor != null)     monitor.worked(1);
  }
  for (  String rootNode : inheritanceTreeMap.keySet()) {
    ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(rootNode);
    if (typeCheckEliminations.size() > 0) {
      typeCheckEliminationResults.addAll(typeCheckEliminations);
      typeCheckEliminationGroups.add(handleGroup(typeCheckEliminations));
    }
  }
  List<TypeCheckElimination> sortedEliminations=new ArrayList<TypeCheckElimination>();
  List<Integer> keyList=new ArrayList<Integer>(staticFieldRankMap.keySet());
  ListIterator<Integer> keyListIterator=keyList.listIterator(keyList.size());
  while (keyListIterator.hasPrevious()) {
    Integer states=keyListIterator.previous();
    sortedEliminations.addAll(staticFieldRankMap.get(states));
  }
  while (!sortedEliminations.isEmpty()) {
    TypeCheckElimination selectedElimination=sortedEliminations.get(0);
    List<TypeCheckElimination> affectedEliminations=new ArrayList<TypeCheckElimination>();
    affectedEliminations.add(selectedElimination);
    List<SimpleName> staticFieldUnion=staticFieldMap.get(selectedElimination);
    boolean staticFieldUnionIncreased=true;
    while (staticFieldUnionIncreased) {
      staticFieldUnionIncreased=false;
      for (      TypeCheckElimination elimination : sortedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        if (!affectedEliminations.contains(elimination) && nonEmptyIntersection(staticFieldUnion,staticFields)) {
          staticFieldUnion=constructUnion(staticFieldUnion,staticFields);
          affectedEliminations.add(elimination);
          staticFieldUnionIncreased=true;
        }
      }
    }
    if (affectedEliminations.size() > 1) {
      for (      TypeCheckElimination elimination : affectedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        for (        SimpleName simpleName1 : staticFieldUnion) {
          boolean isContained=false;
          for (          SimpleName simpleName2 : staticFields) {
            if (simpleName1.resolveBinding().isEqualTo(simpleName2.resolveBinding())) {
              isContained=true;
              break;
            }
          }
          if (!isContained)           elimination.addAdditionalStaticField(simpleName1);
        }
      }
    }
    ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
    for (    TypeCheckElimination elimination : affectedEliminations) {
      if (!elimination.isTypeCheckMethodStateSetter())       typeCheckEliminations.add(elimination);
    }
    if (typeCheckEliminations.size() > 0) {
      typeCheckEliminationResults.addAll(typeCheckEliminations);
      typeCheckEliminationGroups.add(handleGroup(typeCheckEliminations));
    }
    sortedEliminations.removeAll(affectedEliminations);
  }
  identifySuperFieldAccessorMethods(typeCheckEliminationResults);
  if (monitor != null)   monitor.done();
  return typeCheckEliminationGroups;
}"
12124,"private Assignment isParentAssignment(ASTNode node){
  if (node.getParent() instanceof Assignment) {
    Assignment assignment=(Assignment)node.getParent();
    if (assignment.getLeftHandSide().subtreeMatch(new ASTMatcher(),node)) {
      return assignment;
    }
 else {
      return null;
    }
  }
 else   if (node.getParent() instanceof MethodDeclaration) {
    return null;
  }
 else {
    return isParentAssignment(node.getParent());
  }
}","private Assignment isParentAssignment(ASTNode node){
  if (node.getParent() instanceof Assignment) {
    Assignment assignment=(Assignment)node.getParent();
    if (assignment.getLeftHandSide().subtreeMatch(new ASTMatcher(),node)) {
      return assignment;
    }
 else {
      return null;
    }
  }
 else   if (node.getParent() instanceof MethodDeclaration || node.getParent() instanceof ArrayAccess) {
    return null;
  }
 else {
    return isParentAssignment(node.getParent());
  }
}"
12125,"private void addMethods(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  ListRewrite targetClassBodyRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  HashMap<MethodDeclaration,MethodDeclaration> newMethods=new HashMap<MethodDeclaration,MethodDeclaration>();
  HashMap<MethodDeclaration,ArrayList<MethodInvocation>> targetInvocationsMap=new HashMap<MethodDeclaration,ArrayList<MethodInvocation>>();
  for (  MethodDeclaration method : extractedMethods) {
    ArrayList<Assignment> assignmentsToReplace=new ArrayList<Assignment>();
    List<Expression> assignments=expressionExtractor.getAssignments(method.getBody());
    for (    Expression expression : assignments) {
      Assignment assignment=(Assignment)expression;
      if (assignment.getLeftHandSide() instanceof FieldAccess) {
        FieldAccess fieldAccess=(FieldAccess)assignment.getLeftHandSide();
        if (!extractedFieldInstructions.containsKey(fieldAccess.resolveFieldBinding()) && sourceFieldInstructions.containsKey(fieldAccess.resolveFieldBinding())) {
          assignmentsToReplace.add(assignment);
        }
      }
 else       if (assignment.getLeftHandSide() instanceof SimpleName) {
        SimpleName simpleName=(SimpleName)assignment.getLeftHandSide();
        if (!extractedFieldInstructions.containsKey(simpleName.resolveBinding()) && sourceFieldInstructions.containsKey(simpleName.resolveBinding())) {
          assignmentsToReplace.add(assignment);
        }
      }
    }
    ArrayList<SimpleName> instructionsToReplace=new ArrayList<SimpleName>();
    List<Expression> instructions=expressionExtractor.getVariableInstructions(method.getBody());
    for (    Expression expression : instructions) {
      SimpleName instruction=(SimpleName)expression;
      if (isParentAssignment(instruction) == null) {
        if (!extractedFieldInstructions.containsKey(instruction.resolveBinding()) && sourceFieldInstructions.containsKey(instruction.resolveBinding())) {
          instructionsToReplace.add(instruction);
        }
      }
    }
    ArrayList<MethodInvocation> invocationsToReplace=new ArrayList<MethodInvocation>();
    ArrayList<MethodInvocation> targetInvocationsToReplace=new ArrayList<MethodInvocation>();
    List<Expression> invocations=expressionExtractor.getMethodInvocations(method.getBody());
    for (    Expression expression : invocations) {
      MethodInvocation invocation=(MethodInvocation)expression;
      invocationsToReplace=addInvocationToReplace(invocation,invocationsToReplace);
      if (extractedMethodInvocations.containsKey(invocation)) {
        targetInvocationsToReplace.add(invocation);
      }
    }
    targetInvocationsMap.put(method,targetInvocationsToReplace);
    ArrayList<ThisExpression> thisExpressionsToReplace=new ArrayList<ThisExpression>();
    List<Expression> thisExpressions=expressionExtractor.getThisExpressions(method.getBody());
    for (    Expression expression : thisExpressions) {
      ThisExpression thisExpression=(ThisExpression)expression;
      if (thisExpression.getParent() instanceof FieldAccess) {
        FieldAccess access=(FieldAccess)thisExpression.getParent();
        if (!this.extractedFieldInstructions.containsKey(access.resolveFieldBinding())) {
          thisExpressionsToReplace.add(thisExpression);
        }
      }
 else       if (thisExpression.getParent() instanceof MethodInvocation) {
        MethodInvocation invocation=(MethodInvocation)thisExpression.getParent();
        if (this.extractedMethodInvocations.containsKey(invocation)) {
          thisExpressionsToReplace.add(thisExpression);
        }
      }
 else {
        thisExpressionsToReplace.add(thisExpression);
      }
    }
    MethodDeclaration newMethod=(MethodDeclaration)ASTNode.copySubtree(targetTypeDeclaration.getAST(),method);
    AST ast=newMethod.getAST();
    SimpleName sourceClassParameter=null;
    if (!assignmentsToReplace.isEmpty()) {
      sourceClassParameter=addSourceClassParameterToMovedMethod(newMethod,method,false);
      List<Expression> newAssignments=expressionExtractor.getAssignments(newMethod.getBody());
      for (      Expression newAssignment : newAssignments) {
        for (        Assignment oldAssignment : assignmentsToReplace) {
          if (newAssignment.subtreeMatch(new ASTMatcher(),oldAssignment)) {
            Assignment assignment=(Assignment)newAssignment;
            String variableName=""String_Node_Str"";
            if (assignment.getLeftHandSide() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)assignment.getLeftHandSide();
              variableName=fieldAccess.getName().toString().replaceFirst(""String_Node_Str"" + fieldAccess.getName().toString().charAt(0),""String_Node_Str"" + fieldAccess.getName().toString().toUpperCase().charAt(0));
            }
 else             if (assignment.getLeftHandSide() instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)assignment.getLeftHandSide();
              variableName=simpleName.toString().replaceFirst(""String_Node_Str"" + simpleName.toString().charAt(0),""String_Node_Str"" + simpleName.toString().toUpperCase().charAt(0));
            }
            if (sourceClassContainsSetter(variableName) != null) {
              ListRewrite sourceBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
              addSetter(sourceTypeDeclaration.getAST(),sourceBodyRewrite,sourceClassContainsSetter(variableName),fragmentToAddSetter,variableName,sourceRewriter);
            }
            replaceAssignmentWithSetter(sourceClassParameter,ast,assignment,variableName,targetRewriter);
          }
        }
      }
    }
    if (!instructionsToReplace.isEmpty()) {
      for (      SimpleName instruction : instructionsToReplace) {
        FieldDeclaration[] sourceFieldDeclarations=sourceTypeDeclaration.getFields();
        for (        FieldDeclaration sourceFieldDeclaration : sourceFieldDeclarations) {
          List<VariableDeclarationFragment> fragments=sourceFieldDeclaration.fragments();
          for (          VariableDeclarationFragment fragment : fragments) {
            if (fragment.resolveBinding().isEqualTo(instruction.resolveBinding())) {
              int modifiers=sourceFieldDeclaration.getModifiers();
              List<Expression> newInstructions=expressionExtractor.getVariableInstructions(newMethod.getBody());
              for (              Expression newInstruction : newInstructions) {
                if (newInstruction.subtreeMatch(new ASTMatcher(),instruction)) {
                  if ((modifiers & Modifier.STATIC) != 0) {
                    QualifiedName qualifiedName=ast.newQualifiedName(ast.newName(sourceTypeDeclaration.getName().getIdentifier()),ast.newSimpleName(instruction.getIdentifier()));
                    targetRewriter.replace(newInstruction,qualifiedName,null);
                  }
 else {
                    addParameterToMovedMethod(newMethod,instruction,method);
                  }
                }
              }
            }
          }
        }
      }
    }
    ArrayList<MethodInvocation> replacedInvocations=new ArrayList<MethodInvocation>();
    Set<String> sourceMethodsWithPublicModifier=new LinkedHashSet<String>();
    if (!invocationsToReplace.isEmpty()) {
      for (      Expression expression : invocationsToReplace) {
        if (expression instanceof MethodInvocation) {
          MethodInvocation methodInvocation=(MethodInvocation)expression;
          if (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression) {
            IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
            if (methodBinding.getDeclaringClass().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
              for (              MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
                if (sourceMethodDeclaration.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
                  SimpleName fieldName=MethodDeclarationUtility.isGetter(sourceMethodDeclaration);
                  int modifiers=sourceMethodDeclaration.getModifiers();
                  List<Expression> newInvocations=expressionExtractor.getMethodInvocations(newMethod.getBody());
                  for (                  Expression newMethodInvocation : newInvocations) {
                    if (newMethodInvocation.subtreeMatch(new ASTMatcher(),methodInvocation)) {
                      if ((modifiers & Modifier.STATIC) != 0) {
                        targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier()),null);
                        if (!sourceMethodsWithPublicModifier.contains(methodInvocation.resolveMethodBinding().getKey())) {
                          setPublicModifierToSourceMethod(methodInvocation);
                          sourceMethodsWithPublicModifier.add(methodInvocation.resolveMethodBinding().getKey());
                          replacedInvocations.add(methodInvocation);
                        }
                      }
 else                       if (fieldName != null) {
                        targetRewriter.replace(newMethodInvocation,ast.newSimpleName(fieldName.getIdentifier()),null);
                        if (!extractedFieldInstructions.containsKey(fieldName.resolveBinding())) {
                          addParameterToMovedMethod(newMethod,fieldName,method);
                          replacedInvocations.add(methodInvocation);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    invocationsToReplace.removeAll(replacedInvocations);
    if (!invocationsToReplace.isEmpty()) {
      boolean foundAnonymousClassDeclaration=false;
      for (      MethodInvocation invocation : invocationsToReplace) {
        if (isParentAnonymousClassDeclaration(invocation)) {
          foundAnonymousClassDeclaration=true;
        }
      }
      if (sourceClassParameter == null) {
        sourceClassParameter=addSourceClassParameterToMovedMethod(newMethod,method,foundAnonymousClassDeclaration);
      }
      List<Expression> newInvocations=expressionExtractor.getMethodInvocations(newMethod.getBody());
      for (      Expression newInvocation : newInvocations) {
        for (        MethodInvocation oldInvocation : invocationsToReplace) {
          if (newInvocation.subtreeMatch(new ASTMatcher(),oldInvocation)) {
            MethodInvocation invocation=(MethodInvocation)newInvocation;
            targetRewriter.set(invocation,MethodInvocation.EXPRESSION_PROPERTY,sourceClassParameter,null);
            setPublicModifierToSourceMethod(oldInvocation);
          }
        }
      }
    }
    if (!thisExpressionsToReplace.isEmpty()) {
      if (sourceClassParameter == null) {
        sourceClassParameter=addSourceClassParameterToMovedMethod(newMethod,method,false);
      }
      List<Expression> newThisExpressions=expressionExtractor.getThisExpressions(newMethod.getBody());
      for (      ThisExpression oldThisExpression : thisExpressionsToReplace) {
        for (        Expression newThisExpression : newThisExpressions) {
          if (oldThisExpression.getParent().subtreeMatch(new ASTMatcher(),newThisExpression.getParent())) {
            ThisExpression thisExpression=(ThisExpression)newThisExpression;
            targetRewriter.replace(thisExpression,sourceClassParameter,null);
          }
        }
      }
    }
    List<MethodDeclaration> oldMethods=Arrays.asList(sourceTypeDeclaration.getMethods());
    for (    MethodDeclaration oldMethod : oldMethods) {
      if (!oldMethod.equals(method)) {
        List<Expression> oldInvocations=expressionExtractor.getMethodInvocations(oldMethod.getBody());
        for (        Expression oldExpression : oldInvocations) {
          if (oldExpression instanceof MethodInvocation) {
            MethodInvocation invocation=(MethodInvocation)oldExpression;
            if (extractedMethodInvocations.containsKey(invocation)) {
              ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethod,MethodDeclaration.MODIFIERS2_PROPERTY);
              Modifier publicModifier=newMethod.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
              boolean modifierFound=false;
              List<IExtendedModifier> modifiers=newMethod.modifiers();
              for (              IExtendedModifier extendedModifier : modifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
                    modifierFound=true;
                  }
 else                   if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
                    modifierFound=true;
                    modifierRewrite.replace(modifier,publicModifier,null);
                  }
                }
              }
              if (!modifierFound) {
                modifierRewrite.insertFirst(publicModifier,null);
              }
            }
          }
        }
      }
    }
    newMethods.put(newMethod,method);
  }
  for (  MethodDeclaration newMethod : newMethods.keySet()) {
    if (!targetInvocationsMap.isEmpty()) {
      List<Expression> newInvocations=expressionExtractor.getMethodInvocations(newMethod.getBody());
      for (      Expression newInvocation : newInvocations) {
        for (        MethodDeclaration oldMethod : targetInvocationsMap.keySet()) {
          Set<IMethodBinding> checkedInvocations=new HashSet<IMethodBinding>();
          if (oldMethod.subtreeMatch(new ASTMatcher(),newMethod)) {
            for (            MethodInvocation oldInvocation : targetInvocationsMap.get(oldMethod)) {
              if (newInvocation.subtreeMatch(new ASTMatcher(),oldInvocation)) {
                for (                MethodDeclaration modifiedMethod : this.additionalArgumentsAddedToMovedMethod.keySet()) {
                  if (modifiedMethod.resolveBinding().isEqualTo(oldInvocation.resolveMethodBinding())) {
                    MethodInvocation invocation=(MethodInvocation)newInvocation;
                    if (!checkedInvocations.contains(oldInvocation.resolveMethodBinding())) {
                      AST ast=invocation.getAST();
                      ListRewrite arguments=targetRewriter.getListRewrite(invocation,MethodInvocation.ARGUMENTS_PROPERTY);
                      Set<String> additionalArguments=new TreeSet<String>(this.additionalArgumentsAddedToMovedMethod.get(modifiedMethod));
                      TreeSet<String> checkedArguments=new TreeSet<String>();
                      for (                      String argument : additionalArguments) {
                        if (!argument.equalsIgnoreCase(sourceTypeDeclaration.getName().getIdentifier())) {
                          if (!containsParameter(newMethods.get(newMethod),argument)) {
                            if (isParentAnonymousClassDeclaration(oldInvocation)) {
                              if (!containsParameter(newMethods.get(newMethod),sourceTypeDeclaration.getName().getIdentifier())) {
                                this.addSourceClassParameterToMovedMethod(newMethod,newMethods.get(newMethod),false);
                              }
                              MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
                              SimpleName fieldName=null;
                              MethodDeclaration methodDeclaration=null;
                              for (                              MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
                                fieldName=MethodDeclarationUtility.isGetter(sourceMethodDeclaration);
                                methodDeclaration=sourceMethodDeclaration;
                                if (fieldName != null && fieldName.getIdentifier().equals(argument))                                 break;
                              }
                              if (fieldName != null) {
                                MethodInvocation methodInvocation=ast.newMethodInvocation();
                                targetRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,methodDeclaration.getName(),null);
                                targetRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier().replaceFirst(Character.toString(sourceTypeDeclaration.getName().getIdentifier().charAt(0)),Character.toString(Character.toLowerCase(sourceTypeDeclaration.getName().getIdentifier().charAt(0))))),null);
                                arguments.insertLast(methodInvocation,null);
                                checkedArguments.add(argument);
                              }
                            }
 else {
                              this.addParameterToMovedMethod(newMethod,ast.newSimpleName(argument),newMethods.get(newMethod));
                            }
                          }
                        }
 else {
                          if (!containsParameter(newMethods.get(newMethod),sourceTypeDeclaration.getName().getIdentifier())) {
                            this.addSourceClassParameterToMovedMethod(newMethod,newMethods.get(newMethod),false);
                          }
                        }
                      }
                      for (                      String argument : this.additionalArgumentsAddedToMovedMethod.get(modifiedMethod)) {
                        if (!checkedArguments.contains(argument)) {
                          if (!argument.equalsIgnoreCase(sourceTypeDeclaration.getName().getIdentifier())) {
                            arguments.insertLast(ast.newSimpleName(argument),null);
                            checkedInvocations.add(invocation.resolveMethodBinding());
                          }
 else {
                            String sourceTypeName=sourceTypeDeclaration.getName().getIdentifier();
                            arguments.insertLast(ast.newSimpleName(sourceTypeName.replaceFirst(Character.toString(sourceTypeName.charAt(0)),Character.toString(Character.toLowerCase(sourceTypeName.charAt(0))))),null);
                            checkedInvocations.add(oldInvocation.resolveMethodBinding());
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    targetClassBodyRewrite.insertLast(newMethod,null);
  }
}","private void addMethods(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  ListRewrite targetClassBodyRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  HashMap<MethodDeclaration,MethodDeclaration> newMethods=new HashMap<MethodDeclaration,MethodDeclaration>();
  HashMap<MethodDeclaration,ArrayList<MethodInvocation>> targetInvocationsMap=new HashMap<MethodDeclaration,ArrayList<MethodInvocation>>();
  for (  MethodDeclaration method : extractedMethods) {
    ArrayList<Assignment> assignmentsToReplace=new ArrayList<Assignment>();
    List<Expression> assignments=expressionExtractor.getAssignments(method.getBody());
    for (    Expression expression : assignments) {
      Assignment assignment=(Assignment)expression;
      if (assignment.getLeftHandSide() instanceof FieldAccess) {
        FieldAccess fieldAccess=(FieldAccess)assignment.getLeftHandSide();
        if (!extractedFieldInstructions.containsKey(fieldAccess.resolveFieldBinding()) && sourceFieldInstructions.containsKey(fieldAccess.resolveFieldBinding())) {
          assignmentsToReplace.add(assignment);
        }
      }
 else       if (assignment.getLeftHandSide() instanceof SimpleName) {
        SimpleName simpleName=(SimpleName)assignment.getLeftHandSide();
        if (!extractedFieldInstructions.containsKey(simpleName.resolveBinding()) && sourceFieldInstructions.containsKey(simpleName.resolveBinding())) {
          assignmentsToReplace.add(assignment);
        }
      }
    }
    ArrayList<SimpleName> instructionsToReplace=new ArrayList<SimpleName>();
    List<Expression> instructions=expressionExtractor.getVariableInstructions(method.getBody());
    for (    Expression expression : instructions) {
      SimpleName instruction=(SimpleName)expression;
      if (isParentAssignment(instruction) == null) {
        if (!extractedFieldInstructions.containsKey(instruction.resolveBinding()) && sourceFieldInstructions.containsKey(instruction.resolveBinding())) {
          instructionsToReplace.add(instruction);
        }
      }
    }
    ArrayList<MethodInvocation> invocationsToReplace=new ArrayList<MethodInvocation>();
    ArrayList<MethodInvocation> targetInvocationsToReplace=new ArrayList<MethodInvocation>();
    List<Expression> invocations=expressionExtractor.getMethodInvocations(method.getBody());
    for (    Expression expression : invocations) {
      MethodInvocation invocation=(MethodInvocation)expression;
      invocationsToReplace=addInvocationToReplace(invocation,invocationsToReplace);
      if (extractedMethodInvocations.containsKey(invocation)) {
        targetInvocationsToReplace.add(invocation);
      }
    }
    targetInvocationsMap.put(method,targetInvocationsToReplace);
    ArrayList<ThisExpression> thisExpressionsToReplace=new ArrayList<ThisExpression>();
    List<Expression> thisExpressions=expressionExtractor.getThisExpressions(method.getBody());
    for (    Expression expression : thisExpressions) {
      ThisExpression thisExpression=(ThisExpression)expression;
      if (thisExpression.getParent() instanceof FieldAccess) {
        FieldAccess access=(FieldAccess)thisExpression.getParent();
        if (!this.extractedFieldInstructions.containsKey(access.resolveFieldBinding())) {
          thisExpressionsToReplace.add(thisExpression);
        }
      }
 else       if (thisExpression.getParent() instanceof MethodInvocation) {
        MethodInvocation invocation=(MethodInvocation)thisExpression.getParent();
        if (this.extractedMethodInvocations.containsKey(invocation) || !(invocation.getExpression() instanceof ThisExpression)) {
          thisExpressionsToReplace.add(thisExpression);
        }
      }
 else {
        thisExpressionsToReplace.add(thisExpression);
      }
    }
    MethodDeclaration newMethod=(MethodDeclaration)ASTNode.copySubtree(targetTypeDeclaration.getAST(),method);
    AST ast=newMethod.getAST();
    SimpleName sourceClassParameter=null;
    if (!assignmentsToReplace.isEmpty()) {
      sourceClassParameter=addSourceClassParameterToMovedMethod(newMethod,method,false);
      List<Expression> newAssignments=expressionExtractor.getAssignments(newMethod.getBody());
      for (      Expression newAssignment : newAssignments) {
        for (        Assignment oldAssignment : assignmentsToReplace) {
          if (newAssignment.subtreeMatch(new ASTMatcher(),oldAssignment)) {
            Assignment assignment=(Assignment)newAssignment;
            String variableName=""String_Node_Str"";
            if (assignment.getLeftHandSide() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)assignment.getLeftHandSide();
              variableName=fieldAccess.getName().toString().replaceFirst(""String_Node_Str"" + fieldAccess.getName().toString().charAt(0),""String_Node_Str"" + fieldAccess.getName().toString().toUpperCase().charAt(0));
            }
 else             if (assignment.getLeftHandSide() instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)assignment.getLeftHandSide();
              variableName=simpleName.toString().replaceFirst(""String_Node_Str"" + simpleName.toString().charAt(0),""String_Node_Str"" + simpleName.toString().toUpperCase().charAt(0));
            }
            if (sourceClassContainsSetter(variableName) != null) {
              ListRewrite sourceBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
              addSetter(sourceTypeDeclaration.getAST(),sourceBodyRewrite,sourceClassContainsSetter(variableName),fragmentToAddSetter,variableName,sourceRewriter);
            }
            replaceAssignmentWithSetter(sourceClassParameter,ast,assignment,variableName,targetRewriter);
          }
        }
      }
    }
    if (!instructionsToReplace.isEmpty()) {
      for (      SimpleName instruction : instructionsToReplace) {
        FieldDeclaration[] sourceFieldDeclarations=sourceTypeDeclaration.getFields();
        for (        FieldDeclaration sourceFieldDeclaration : sourceFieldDeclarations) {
          List<VariableDeclarationFragment> fragments=sourceFieldDeclaration.fragments();
          for (          VariableDeclarationFragment fragment : fragments) {
            if (fragment.resolveBinding().isEqualTo(instruction.resolveBinding())) {
              int modifiers=sourceFieldDeclaration.getModifiers();
              List<Expression> newInstructions=expressionExtractor.getVariableInstructions(newMethod.getBody());
              for (              Expression newInstruction : newInstructions) {
                if (newInstruction.subtreeMatch(new ASTMatcher(),instruction)) {
                  if ((modifiers & Modifier.STATIC) != 0) {
                    QualifiedName qualifiedName=ast.newQualifiedName(ast.newName(sourceTypeDeclaration.getName().getIdentifier()),ast.newSimpleName(instruction.getIdentifier()));
                    targetRewriter.replace(newInstruction,qualifiedName,null);
                  }
 else {
                    addParameterToMovedMethod(newMethod,instruction,method);
                  }
                }
              }
            }
          }
        }
      }
    }
    ArrayList<MethodInvocation> replacedInvocations=new ArrayList<MethodInvocation>();
    Set<String> sourceMethodsWithPublicModifier=new LinkedHashSet<String>();
    if (!invocationsToReplace.isEmpty()) {
      for (      Expression expression : invocationsToReplace) {
        if (expression instanceof MethodInvocation) {
          MethodInvocation methodInvocation=(MethodInvocation)expression;
          if (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression) {
            IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
            if (methodBinding.getDeclaringClass().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
              MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
              for (              MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
                if (sourceMethodDeclaration.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
                  SimpleName fieldName=MethodDeclarationUtility.isGetter(sourceMethodDeclaration);
                  int modifiers=sourceMethodDeclaration.getModifiers();
                  List<Expression> newInvocations=expressionExtractor.getMethodInvocations(newMethod.getBody());
                  for (                  Expression newMethodInvocation : newInvocations) {
                    if (newMethodInvocation.subtreeMatch(new ASTMatcher(),methodInvocation)) {
                      if ((modifiers & Modifier.STATIC) != 0) {
                        targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier()),null);
                        if (!sourceMethodsWithPublicModifier.contains(methodInvocation.resolveMethodBinding().getKey())) {
                          setPublicModifierToSourceMethod(methodInvocation);
                          sourceMethodsWithPublicModifier.add(methodInvocation.resolveMethodBinding().getKey());
                          replacedInvocations.add(methodInvocation);
                        }
                      }
 else                       if (fieldName != null) {
                        targetRewriter.replace(newMethodInvocation,ast.newSimpleName(fieldName.getIdentifier()),null);
                        if (!extractedFieldInstructions.containsKey(fieldName.resolveBinding())) {
                          addParameterToMovedMethod(newMethod,fieldName,method);
                          replacedInvocations.add(methodInvocation);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    invocationsToReplace.removeAll(replacedInvocations);
    if (!invocationsToReplace.isEmpty()) {
      boolean foundAnonymousClassDeclaration=false;
      for (      MethodInvocation invocation : invocationsToReplace) {
        if (isParentAnonymousClassDeclaration(invocation)) {
          foundAnonymousClassDeclaration=true;
        }
      }
      if (sourceClassParameter == null) {
        sourceClassParameter=addSourceClassParameterToMovedMethod(newMethod,method,foundAnonymousClassDeclaration);
      }
      List<Expression> newInvocations=expressionExtractor.getMethodInvocations(newMethod.getBody());
      for (      Expression newInvocation : newInvocations) {
        for (        MethodInvocation oldInvocation : invocationsToReplace) {
          if (newInvocation.subtreeMatch(new ASTMatcher(),oldInvocation)) {
            MethodInvocation invocation=(MethodInvocation)newInvocation;
            targetRewriter.set(invocation,MethodInvocation.EXPRESSION_PROPERTY,sourceClassParameter,null);
            setPublicModifierToSourceMethod(oldInvocation);
          }
        }
      }
    }
    if (!thisExpressionsToReplace.isEmpty()) {
      if (sourceClassParameter == null) {
        sourceClassParameter=addSourceClassParameterToMovedMethod(newMethod,method,false);
      }
      List<Expression> newThisExpressions=expressionExtractor.getThisExpressions(newMethod.getBody());
      for (      ThisExpression oldThisExpression : thisExpressionsToReplace) {
        for (        Expression newThisExpression : newThisExpressions) {
          if (oldThisExpression.getParent().subtreeMatch(new ASTMatcher(),newThisExpression.getParent())) {
            ThisExpression thisExpression=(ThisExpression)newThisExpression;
            targetRewriter.replace(thisExpression,sourceClassParameter,null);
          }
        }
      }
    }
    List<MethodDeclaration> oldMethods=Arrays.asList(sourceTypeDeclaration.getMethods());
    for (    MethodDeclaration oldMethod : oldMethods) {
      if (!oldMethod.equals(method)) {
        List<Expression> oldInvocations=expressionExtractor.getMethodInvocations(oldMethod.getBody());
        for (        Expression oldExpression : oldInvocations) {
          if (oldExpression instanceof MethodInvocation) {
            MethodInvocation invocation=(MethodInvocation)oldExpression;
            if (extractedMethodInvocations.containsKey(invocation)) {
              ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethod,MethodDeclaration.MODIFIERS2_PROPERTY);
              Modifier publicModifier=newMethod.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
              boolean modifierFound=false;
              List<IExtendedModifier> modifiers=newMethod.modifiers();
              for (              IExtendedModifier extendedModifier : modifiers) {
                if (extendedModifier.isModifier()) {
                  Modifier modifier=(Modifier)extendedModifier;
                  if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
                    modifierFound=true;
                  }
 else                   if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
                    modifierFound=true;
                    modifierRewrite.replace(modifier,publicModifier,null);
                  }
                }
              }
              if (!modifierFound) {
                modifierRewrite.insertFirst(publicModifier,null);
              }
            }
          }
        }
      }
    }
    newMethods.put(newMethod,method);
  }
  for (  MethodDeclaration newMethod : newMethods.keySet()) {
    if (!targetInvocationsMap.isEmpty()) {
      List<Expression> newInvocations=expressionExtractor.getMethodInvocations(newMethod.getBody());
      for (      Expression newInvocation : newInvocations) {
        for (        MethodDeclaration oldMethod : targetInvocationsMap.keySet()) {
          Set<IMethodBinding> checkedInvocations=new HashSet<IMethodBinding>();
          if (oldMethod.subtreeMatch(new ASTMatcher(),newMethod)) {
            for (            MethodInvocation oldInvocation : targetInvocationsMap.get(oldMethod)) {
              if (newInvocation.subtreeMatch(new ASTMatcher(),oldInvocation)) {
                for (                MethodDeclaration modifiedMethod : this.additionalArgumentsAddedToMovedMethod.keySet()) {
                  if (modifiedMethod.resolveBinding().isEqualTo(oldInvocation.resolveMethodBinding())) {
                    MethodInvocation invocation=(MethodInvocation)newInvocation;
                    if (!checkedInvocations.contains(oldInvocation.resolveMethodBinding())) {
                      AST ast=invocation.getAST();
                      ListRewrite arguments=targetRewriter.getListRewrite(invocation,MethodInvocation.ARGUMENTS_PROPERTY);
                      Set<String> additionalArguments=new TreeSet<String>(this.additionalArgumentsAddedToMovedMethod.get(modifiedMethod));
                      TreeSet<String> checkedArguments=new TreeSet<String>();
                      for (                      String argument : additionalArguments) {
                        if (!argument.equalsIgnoreCase(sourceTypeDeclaration.getName().getIdentifier())) {
                          if (!containsParameter(newMethods.get(newMethod),argument)) {
                            if (isParentAnonymousClassDeclaration(oldInvocation)) {
                              if (!containsParameter(newMethods.get(newMethod),sourceTypeDeclaration.getName().getIdentifier())) {
                                this.addSourceClassParameterToMovedMethod(newMethod,newMethods.get(newMethod),false);
                              }
                              MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
                              SimpleName fieldName=null;
                              MethodDeclaration methodDeclaration=null;
                              for (                              MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
                                fieldName=MethodDeclarationUtility.isGetter(sourceMethodDeclaration);
                                methodDeclaration=sourceMethodDeclaration;
                                if (fieldName != null && fieldName.getIdentifier().equals(argument))                                 break;
                              }
                              if (fieldName != null) {
                                MethodInvocation methodInvocation=ast.newMethodInvocation();
                                targetRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,methodDeclaration.getName(),null);
                                targetRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier().replaceFirst(Character.toString(sourceTypeDeclaration.getName().getIdentifier().charAt(0)),Character.toString(Character.toLowerCase(sourceTypeDeclaration.getName().getIdentifier().charAt(0))))),null);
                                arguments.insertLast(methodInvocation,null);
                                checkedArguments.add(argument);
                              }
                            }
 else {
                              this.addParameterToMovedMethod(newMethod,ast.newSimpleName(argument),newMethods.get(newMethod));
                            }
                          }
                        }
 else {
                          if (!containsParameter(newMethods.get(newMethod),sourceTypeDeclaration.getName().getIdentifier())) {
                            this.addSourceClassParameterToMovedMethod(newMethod,newMethods.get(newMethod),false);
                          }
                        }
                      }
                      for (                      String argument : this.additionalArgumentsAddedToMovedMethod.get(modifiedMethod)) {
                        if (!checkedArguments.contains(argument)) {
                          if (!argument.equalsIgnoreCase(sourceTypeDeclaration.getName().getIdentifier())) {
                            arguments.insertLast(ast.newSimpleName(argument),null);
                            checkedInvocations.add(invocation.resolveMethodBinding());
                          }
 else {
                            String sourceTypeName=sourceTypeDeclaration.getName().getIdentifier();
                            arguments.insertLast(ast.newSimpleName(sourceTypeName.replaceFirst(Character.toString(sourceTypeName.charAt(0)),Character.toString(Character.toLowerCase(sourceTypeName.charAt(0))))),null);
                            checkedInvocations.add(oldInvocation.resolveMethodBinding());
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    targetClassBodyRewrite.insertLast(newMethod,null);
  }
}"
12126,"private void modifyTargetPublicFieldInstructions(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  FieldDeclaration[] fields=targetTypeDeclaration.getFields();
  for (  FieldDeclaration field : fields) {
    List<VariableDeclarationFragment> fragments=field.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      SimpleName fragmentName=fragment.getName();
      int i=0;
      for (      Expression expression : sourceFieldInstructions) {
        SimpleName simpleName=(SimpleName)expression;
        if (simpleName.getParent() instanceof QualifiedName && fragmentName.getIdentifier().equals(simpleName.getIdentifier())) {
          QualifiedName qualifiedName=(QualifiedName)simpleName.getParent();
          if ((qualifiedName.getQualifier().resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding()) || targetTypeDeclaration.resolveBinding().isEqualTo(qualifiedName.getQualifier().resolveTypeBinding().getSuperclass())) && qualifiedName.getQualifier().getFullyQualifiedName().equals(targetClassVariableName)) {
            SimpleName newSimpleName=(SimpleName)newFieldInstructions.get(i);
            targetRewriter.replace(newSimpleName.getParent(),simpleName,null);
          }
        }
 else         if (simpleName.getParent() instanceof FieldAccess && fragmentName.getIdentifier().equals(simpleName.getIdentifier())) {
          FieldAccess fieldAccess=(FieldAccess)simpleName.getParent();
          Expression fieldAccessExpression=fieldAccess.getExpression();
          if (fieldAccessExpression instanceof FieldAccess) {
            FieldAccess invokerFieldAccess=(FieldAccess)fieldAccessExpression;
            if ((invokerFieldAccess.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding()) || targetTypeDeclaration.resolveBinding().isEqualTo(invokerFieldAccess.resolveTypeBinding().getSuperclass())) && invokerFieldAccess.getName().getIdentifier().equals(targetClassVariableName) && invokerFieldAccess.getExpression() instanceof ThisExpression) {
              SimpleName newSimpleName=(SimpleName)newFieldInstructions.get(i);
              FieldAccess newFieldAccess=(FieldAccess)newSimpleName.getParent();
              targetRewriter.replace(newFieldAccess.getExpression(),newMethodDeclaration.getAST().newThisExpression(),null);
            }
          }
        }
        i++;
      }
    }
  }
}","private void modifyTargetPublicFieldInstructions(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  FieldDeclaration[] fields=targetTypeDeclaration.getFields();
  for (  FieldDeclaration field : fields) {
    List<VariableDeclarationFragment> fragments=field.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      SimpleName fragmentName=fragment.getName();
      int i=0;
      for (      Expression expression : sourceFieldInstructions) {
        SimpleName simpleName=(SimpleName)expression;
        if (simpleName.getParent() instanceof QualifiedName && fragmentName.getIdentifier().equals(simpleName.getIdentifier())) {
          QualifiedName qualifiedName=(QualifiedName)simpleName.getParent();
          if ((qualifiedName.getQualifier().resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding()) || targetTypeDeclaration.resolveBinding().isEqualTo(qualifiedName.getQualifier().resolveTypeBinding().getSuperclass())) && qualifiedName.getQualifier().getFullyQualifiedName().equals(targetClassVariableName)) {
            SimpleName newSimpleName=(SimpleName)newFieldInstructions.get(i);
            targetRewriter.replace(newSimpleName.getParent(),simpleName,null);
          }
        }
 else         if (simpleName.getParent() instanceof FieldAccess && fragmentName.getIdentifier().equals(simpleName.getIdentifier())) {
          FieldAccess fieldAccess=(FieldAccess)simpleName.getParent();
          Expression fieldAccessExpression=fieldAccess.getExpression();
          if (fieldAccessExpression instanceof FieldAccess) {
            FieldAccess invokerFieldAccess=(FieldAccess)fieldAccessExpression;
            if ((invokerFieldAccess.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding()) || targetTypeDeclaration.resolveBinding().isEqualTo(invokerFieldAccess.resolveTypeBinding().getSuperclass())) && invokerFieldAccess.getName().getIdentifier().equals(targetClassVariableName) && invokerFieldAccess.getExpression() instanceof ThisExpression) {
              SimpleName newSimpleName=(SimpleName)newFieldInstructions.get(i);
              FieldAccess newFieldAccess=(FieldAccess)newSimpleName.getParent();
              targetRewriter.replace(newFieldAccess.getExpression(),newMethodDeclaration.getAST().newThisExpression(),null);
            }
          }
        }
        i++;
      }
    }
  }
  if (!targetTypeDeclaration.resolveBinding().getSuperclass().getQualifiedName().equals(""String_Node_Str"")) {
    IVariableBinding[] superclassFields=targetTypeDeclaration.resolveBinding().getSuperclass().getDeclaredFields();
    for (    IVariableBinding superclassField : superclassFields) {
      int i=0;
      for (      Expression expression : sourceFieldInstructions) {
        SimpleName simpleName=(SimpleName)expression;
        if (simpleName.getParent() instanceof QualifiedName && superclassField.isEqualTo(simpleName.resolveBinding())) {
          QualifiedName qualifiedName=(QualifiedName)simpleName.getParent();
          if (qualifiedName.getQualifier().resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding().getSuperclass()) && qualifiedName.getQualifier().getFullyQualifiedName().equals(targetClassVariableName)) {
            SimpleName newSimpleName=(SimpleName)newFieldInstructions.get(i);
            targetRewriter.replace(newSimpleName.getParent(),simpleName,null);
          }
        }
 else         if (simpleName.getParent() instanceof FieldAccess && superclassField.isEqualTo(simpleName.resolveBinding())) {
          FieldAccess fieldAccess=(FieldAccess)simpleName.getParent();
          Expression fieldAccessExpression=fieldAccess.getExpression();
          if (fieldAccessExpression instanceof FieldAccess) {
            FieldAccess invokerFieldAccess=(FieldAccess)fieldAccessExpression;
            if (invokerFieldAccess.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding()) && invokerFieldAccess.getName().getIdentifier().equals(targetClassVariableName) && invokerFieldAccess.getExpression() instanceof ThisExpression) {
              SimpleName newSimpleName=(SimpleName)newFieldInstructions.get(i);
              FieldAccess newFieldAccess=(FieldAccess)newSimpleName.getParent();
              targetRewriter.replace(newFieldAccess.getExpression(),newMethodDeclaration.getAST().newThisExpression(),null);
            }
          }
        }
        i++;
      }
    }
  }
}"
12127,"public TypeCheckEliminationResults generateTypeCheckEliminations(){
  TypeCheckEliminationResults typeCheckEliminationResults=new TypeCheckEliminationResults();
  Map<TypeCheckElimination,List<SimpleName>> staticFieldMap=new LinkedHashMap<TypeCheckElimination,List<SimpleName>>();
  Map<Integer,ArrayList<TypeCheckElimination>> staticFieldRankMap=new TreeMap<Integer,ArrayList<TypeCheckElimination>>();
  Map<String,ArrayList<TypeCheckElimination>> inheritanceTreeMap=new LinkedHashMap<String,ArrayList<TypeCheckElimination>>();
  CompleteInheritanceDetection inheritanceDetection=new CompleteInheritanceDetection(this);
  for (  ClassObject classObject : classList) {
    List<TypeCheckElimination> eliminations=classObject.generateTypeCheckEliminations();
    for (    TypeCheckElimination elimination : eliminations) {
      List<SimpleName> staticFields=elimination.getStaticFields();
      if (!staticFields.isEmpty()) {
        if (allStaticFieldsWithinSystemBoundary(staticFields)) {
          inheritanceHierarchyMatchingWithStaticTypes(elimination,inheritanceDetection);
          boolean isValid=false;
          if (elimination.getTypeField() != null) {
            IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
            ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
            if (typeFieldTypeBinding.isPrimitive() || typeFieldTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeLocalVariable() != null) {
            IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
            ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
            if (typeLocalVariableTypeBinding.isPrimitive() || typeLocalVariableTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeMethodInvocation() != null) {
            MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
            IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
            ITypeBinding typeMethodInvocationDeclaringClass=typeMethodInvocationBinding.getDeclaringClass();
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            ClassObject declaringClassObject=getClassObject(typeMethodInvocationDeclaringClass.getQualifiedName());
            if ((typeMethodInvocationReturnType.isPrimitive() || typeMethodInvocationReturnType.isEnum()) && declaringClassObject != null) {
              MethodDeclaration invokedMethodDeclaration=null;
              ListIterator<MethodObject> methodIterator=declaringClassObject.getMethodIterator();
              while (methodIterator.hasNext()) {
                MethodObject methodObject=methodIterator.next();
                MethodDeclaration methodDeclaration=methodObject.getMethodDeclaration();
                if (typeMethodInvocationBinding.isEqualTo(methodDeclaration.resolveBinding())) {
                  invokedMethodDeclaration=methodDeclaration;
                  break;
                }
              }
              SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(invokedMethodDeclaration);
              if (fieldInstruction != null) {
                ListIterator<FieldObject> fieldIterator=declaringClassObject.getFieldIterator();
                while (fieldIterator.hasNext()) {
                  FieldObject fieldObject=fieldIterator.next();
                  VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                  if (fieldInstruction.resolveBinding().isEqualTo(fragment.resolveBinding())) {
                    elimination.setForeignTypeField(fragment);
                    break;
                  }
                }
                isValid=true;
              }
 else               if (invokedMethodDeclaration.getBody() == null) {
                InheritanceTree tree=elimination.getInheritanceTreeMatchingWithStaticTypes();
                ITypeBinding invokerTypeBinding=handleTypeMethodInvocation(typeMethodInvocation,elimination);
                if (invokerTypeBinding != null) {
                  if (tree != null) {
                    if (invokerTypeBinding.getQualifiedName().equals(tree.getRootNode().getUserObject())) {
                      elimination.setExistingInheritanceTree(tree);
                      if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
                        typeCheckEliminations.add(elimination);
                      }
 else {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                        typeCheckEliminations.add(elimination);
                        inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
                      }
                    }
                  }
 else {
                    InheritanceTree tree2=inheritanceDetection.getTree(invokerTypeBinding.getQualifiedName());
                    if (tree2 != null) {
                      elimination.setExistingInheritanceTree(tree2);
                      if (inheritanceTreeMap.containsKey(tree2.getRootNode().getUserObject())) {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree2.getRootNode().getUserObject());
                        typeCheckEliminations.add(elimination);
                      }
 else {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                        typeCheckEliminations.add(elimination);
                        inheritanceTreeMap.put((String)tree2.getRootNode().getUserObject(),typeCheckEliminations);
                      }
                    }
                  }
                }
              }
            }
          }
          if (isValid) {
            staticFieldMap.put(elimination,staticFields);
            int size=staticFields.size();
            if (staticFieldRankMap.containsKey(size)) {
              ArrayList<TypeCheckElimination> rank=staticFieldRankMap.get(size);
              rank.add(elimination);
            }
 else {
              ArrayList<TypeCheckElimination> rank=new ArrayList<TypeCheckElimination>();
              rank.add(elimination);
              staticFieldRankMap.put(size,rank);
            }
          }
        }
      }
 else {
        if (elimination.getTypeField() != null) {
          IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
          ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeFieldTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeLocalVariable() != null) {
          IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
          ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeLocalVariableTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeMethodInvocation() != null) {
          MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
          IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
          if (typeMethodInvocationBinding.getDeclaringClass().getQualifiedName().equals(""String_Node_Str"") && typeMethodInvocationBinding.getName().equals(""String_Node_Str"")) {
            ITypeBinding invokerTypeBinding=handleTypeMethodInvocation(typeMethodInvocation,elimination);
            if (invokerTypeBinding != null) {
              InheritanceTree tree=inheritanceDetection.getTree(invokerTypeBinding.getQualifiedName());
              elimination.setExistingInheritanceTree(tree);
            }
          }
 else {
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            InheritanceTree tree=inheritanceDetection.getTree(typeMethodInvocationReturnType.getQualifiedName());
            elimination.setExistingInheritanceTree(tree);
          }
        }
        if (elimination.getExistingInheritanceTree() != null) {
          InheritanceTree tree=elimination.getExistingInheritanceTree();
          if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
            ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
            typeCheckEliminations.add(elimination);
          }
 else {
            ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
            typeCheckEliminations.add(elimination);
            inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
          }
        }
      }
    }
  }
  for (  String rootNode : inheritanceTreeMap.keySet()) {
    ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(rootNode);
    typeCheckEliminationResults.addGroup(typeCheckEliminations);
  }
  List<TypeCheckElimination> sortedEliminations=new ArrayList<TypeCheckElimination>();
  List<Integer> keyList=new ArrayList<Integer>(staticFieldRankMap.keySet());
  ListIterator<Integer> keyListIterator=keyList.listIterator(keyList.size());
  while (keyListIterator.hasPrevious()) {
    Integer states=keyListIterator.previous();
    sortedEliminations.addAll(staticFieldRankMap.get(states));
  }
  while (!sortedEliminations.isEmpty()) {
    TypeCheckElimination selectedElimination=sortedEliminations.get(0);
    List<TypeCheckElimination> affectedEliminations=new ArrayList<TypeCheckElimination>();
    affectedEliminations.add(selectedElimination);
    List<SimpleName> staticFieldUnion=staticFieldMap.get(selectedElimination);
    boolean staticFieldUnionIncreased=true;
    while (staticFieldUnionIncreased) {
      staticFieldUnionIncreased=false;
      for (      TypeCheckElimination elimination : sortedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        if (!affectedEliminations.contains(elimination) && nonEmptyIntersection(staticFieldUnion,staticFields)) {
          staticFieldUnion=constructUnion(staticFieldUnion,staticFields);
          affectedEliminations.add(elimination);
          staticFieldUnionIncreased=true;
        }
      }
    }
    if (affectedEliminations.size() > 1) {
      for (      TypeCheckElimination elimination : affectedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        for (        SimpleName simpleName1 : staticFieldUnion) {
          boolean isContained=false;
          for (          SimpleName simpleName2 : staticFields) {
            if (simpleName1.resolveBinding().isEqualTo(simpleName2.resolveBinding())) {
              isContained=true;
              break;
            }
          }
          if (!isContained)           elimination.addAdditionalStaticField(simpleName1);
        }
      }
    }
    ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
    for (    TypeCheckElimination elimination : affectedEliminations) {
      if (!elimination.isTypeCheckMethodStateSetter())       typeCheckEliminations.add(elimination);
    }
    typeCheckEliminationResults.addGroup(typeCheckEliminations);
    sortedEliminations.removeAll(affectedEliminations);
  }
  identifySuperFieldAccessorMethods(typeCheckEliminationResults.getTypeCheckEliminations());
  return typeCheckEliminationResults;
}","public TypeCheckEliminationResults generateTypeCheckEliminations(IProgressMonitor monitor){
  monitor.beginTask(""String_Node_Str"",classList.size());
  TypeCheckEliminationResults typeCheckEliminationResults=new TypeCheckEliminationResults();
  Map<TypeCheckElimination,List<SimpleName>> staticFieldMap=new LinkedHashMap<TypeCheckElimination,List<SimpleName>>();
  Map<Integer,ArrayList<TypeCheckElimination>> staticFieldRankMap=new TreeMap<Integer,ArrayList<TypeCheckElimination>>();
  Map<String,ArrayList<TypeCheckElimination>> inheritanceTreeMap=new LinkedHashMap<String,ArrayList<TypeCheckElimination>>();
  CompleteInheritanceDetection inheritanceDetection=new CompleteInheritanceDetection(this);
  for (  ClassObject classObject : classList) {
    List<TypeCheckElimination> eliminations=classObject.generateTypeCheckEliminations();
    for (    TypeCheckElimination elimination : eliminations) {
      List<SimpleName> staticFields=elimination.getStaticFields();
      if (!staticFields.isEmpty()) {
        if (allStaticFieldsWithinSystemBoundary(staticFields)) {
          inheritanceHierarchyMatchingWithStaticTypes(elimination,inheritanceDetection);
          boolean isValid=false;
          if (elimination.getTypeField() != null) {
            IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
            ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
            if (typeFieldTypeBinding.isPrimitive() || typeFieldTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeLocalVariable() != null) {
            IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
            ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
            if (typeLocalVariableTypeBinding.isPrimitive() || typeLocalVariableTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeMethodInvocation() != null) {
            MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
            IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
            ITypeBinding typeMethodInvocationDeclaringClass=typeMethodInvocationBinding.getDeclaringClass();
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            ClassObject declaringClassObject=getClassObject(typeMethodInvocationDeclaringClass.getQualifiedName());
            if ((typeMethodInvocationReturnType.isPrimitive() || typeMethodInvocationReturnType.isEnum()) && declaringClassObject != null) {
              MethodDeclaration invokedMethodDeclaration=null;
              ListIterator<MethodObject> methodIterator=declaringClassObject.getMethodIterator();
              while (methodIterator.hasNext()) {
                MethodObject methodObject=methodIterator.next();
                MethodDeclaration methodDeclaration=methodObject.getMethodDeclaration();
                if (typeMethodInvocationBinding.isEqualTo(methodDeclaration.resolveBinding())) {
                  invokedMethodDeclaration=methodDeclaration;
                  break;
                }
              }
              SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(invokedMethodDeclaration);
              if (fieldInstruction != null) {
                ListIterator<FieldObject> fieldIterator=declaringClassObject.getFieldIterator();
                while (fieldIterator.hasNext()) {
                  FieldObject fieldObject=fieldIterator.next();
                  VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                  if (fieldInstruction.resolveBinding().isEqualTo(fragment.resolveBinding())) {
                    elimination.setForeignTypeField(fragment);
                    break;
                  }
                }
                isValid=true;
              }
 else               if (invokedMethodDeclaration.getBody() == null) {
                InheritanceTree tree=elimination.getInheritanceTreeMatchingWithStaticTypes();
                ITypeBinding invokerTypeBinding=handleTypeMethodInvocation(typeMethodInvocation,elimination);
                if (invokerTypeBinding != null) {
                  if (tree != null) {
                    if (invokerTypeBinding.getQualifiedName().equals(tree.getRootNode().getUserObject())) {
                      elimination.setExistingInheritanceTree(tree);
                      if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
                        typeCheckEliminations.add(elimination);
                      }
 else {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                        typeCheckEliminations.add(elimination);
                        inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
                      }
                    }
                  }
 else {
                    InheritanceTree tree2=inheritanceDetection.getTree(invokerTypeBinding.getQualifiedName());
                    if (tree2 != null) {
                      elimination.setExistingInheritanceTree(tree2);
                      if (inheritanceTreeMap.containsKey(tree2.getRootNode().getUserObject())) {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree2.getRootNode().getUserObject());
                        typeCheckEliminations.add(elimination);
                      }
 else {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                        typeCheckEliminations.add(elimination);
                        inheritanceTreeMap.put((String)tree2.getRootNode().getUserObject(),typeCheckEliminations);
                      }
                    }
                  }
                }
              }
            }
          }
          if (isValid) {
            staticFieldMap.put(elimination,staticFields);
            int size=staticFields.size();
            if (staticFieldRankMap.containsKey(size)) {
              ArrayList<TypeCheckElimination> rank=staticFieldRankMap.get(size);
              rank.add(elimination);
            }
 else {
              ArrayList<TypeCheckElimination> rank=new ArrayList<TypeCheckElimination>();
              rank.add(elimination);
              staticFieldRankMap.put(size,rank);
            }
          }
        }
      }
 else {
        if (elimination.getTypeField() != null) {
          IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
          ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeFieldTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeLocalVariable() != null) {
          IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
          ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeLocalVariableTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeMethodInvocation() != null) {
          MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
          IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
          if (typeMethodInvocationBinding.getDeclaringClass().getQualifiedName().equals(""String_Node_Str"") && typeMethodInvocationBinding.getName().equals(""String_Node_Str"")) {
            ITypeBinding invokerTypeBinding=handleTypeMethodInvocation(typeMethodInvocation,elimination);
            if (invokerTypeBinding != null) {
              InheritanceTree tree=inheritanceDetection.getTree(invokerTypeBinding.getQualifiedName());
              elimination.setExistingInheritanceTree(tree);
            }
          }
 else {
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            InheritanceTree tree=inheritanceDetection.getTree(typeMethodInvocationReturnType.getQualifiedName());
            elimination.setExistingInheritanceTree(tree);
          }
        }
        if (elimination.getExistingInheritanceTree() != null) {
          InheritanceTree tree=elimination.getExistingInheritanceTree();
          if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
            ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
            typeCheckEliminations.add(elimination);
          }
 else {
            ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
            typeCheckEliminations.add(elimination);
            inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
          }
        }
      }
    }
    monitor.worked(1);
  }
  for (  String rootNode : inheritanceTreeMap.keySet()) {
    ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(rootNode);
    typeCheckEliminationResults.addGroup(typeCheckEliminations);
  }
  List<TypeCheckElimination> sortedEliminations=new ArrayList<TypeCheckElimination>();
  List<Integer> keyList=new ArrayList<Integer>(staticFieldRankMap.keySet());
  ListIterator<Integer> keyListIterator=keyList.listIterator(keyList.size());
  while (keyListIterator.hasPrevious()) {
    Integer states=keyListIterator.previous();
    sortedEliminations.addAll(staticFieldRankMap.get(states));
  }
  while (!sortedEliminations.isEmpty()) {
    TypeCheckElimination selectedElimination=sortedEliminations.get(0);
    List<TypeCheckElimination> affectedEliminations=new ArrayList<TypeCheckElimination>();
    affectedEliminations.add(selectedElimination);
    List<SimpleName> staticFieldUnion=staticFieldMap.get(selectedElimination);
    boolean staticFieldUnionIncreased=true;
    while (staticFieldUnionIncreased) {
      staticFieldUnionIncreased=false;
      for (      TypeCheckElimination elimination : sortedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        if (!affectedEliminations.contains(elimination) && nonEmptyIntersection(staticFieldUnion,staticFields)) {
          staticFieldUnion=constructUnion(staticFieldUnion,staticFields);
          affectedEliminations.add(elimination);
          staticFieldUnionIncreased=true;
        }
      }
    }
    if (affectedEliminations.size() > 1) {
      for (      TypeCheckElimination elimination : affectedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        for (        SimpleName simpleName1 : staticFieldUnion) {
          boolean isContained=false;
          for (          SimpleName simpleName2 : staticFields) {
            if (simpleName1.resolveBinding().isEqualTo(simpleName2.resolveBinding())) {
              isContained=true;
              break;
            }
          }
          if (!isContained)           elimination.addAdditionalStaticField(simpleName1);
        }
      }
    }
    ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
    for (    TypeCheckElimination elimination : affectedEliminations) {
      if (!elimination.isTypeCheckMethodStateSetter())       typeCheckEliminations.add(elimination);
    }
    typeCheckEliminationResults.addGroup(typeCheckEliminations);
    sortedEliminations.removeAll(affectedEliminations);
  }
  identifySuperFieldAccessorMethods(typeCheckEliminationResults.getTypeCheckEliminations());
  monitor.done();
  return typeCheckEliminationResults;
}"
12128,"public boolean containsPlainVariable(PlainVariable variable){
  if (this.name.equals(variable.name))   return true;
  return rightPart.containsPlainVariable(variable);
}","public boolean containsPlainVariable(PlainVariable variable){
  if (this.name.equals(variable.name) || this.name.resolveBinding().isEqualTo(variable.name.resolveBinding()))   return true;
  return rightPart.containsPlainVariable(variable);
}"
12129,"public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o instanceof PlainVariable) {
    PlainVariable plain=(PlainVariable)o;
    return this.name.equals(plain.name);
  }
  return false;
}","public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o instanceof PlainVariable) {
    PlainVariable plain=(PlainVariable)o;
    if (this.name.equals(plain.name) || this.name.resolveBinding().isEqualTo(plain.name.resolveBinding()))     return true;
  }
  return false;
}"
12130,"public ASTSlice(PDGObjectSliceUnion pdgObjectSliceUnion){
  this.sourceMethodDeclaration=pdgObjectSliceUnion.getMethod().getMethodDeclaration();
  this.sourceTypeDeclaration=(TypeDeclaration)sourceMethodDeclaration.getParent();
  this.sliceNodes=pdgObjectSliceUnion.getSliceNodes();
  this.sliceStatements=new LinkedHashSet<Statement>();
  for (  PDGNode node : sliceNodes) {
    sliceStatements.add(node.getASTStatement());
  }
  this.removableStatements=new LinkedHashSet<Statement>();
  for (  PDGNode node : pdgObjectSliceUnion.getRemovableNodes()) {
    removableStatements.add(node.getASTStatement());
  }
  this.localVariableCriterion=pdgObjectSliceUnion.getObjectReference();
  this.passedParameters=new LinkedHashSet<VariableDeclaration>();
  for (  AbstractVariable variable : pdgObjectSliceUnion.getPassedParameters()) {
    passedParameters.add(variable.getName());
  }
  this.extractedMethodInvocationInsertionStatement=pdgObjectSliceUnion.getExtractedMethodInvocationInsertionNode().getASTStatement();
  this.extractedMethodName=localVariableCriterion.toString().replaceAll(""String_Node_Str"",""String_Node_Str"");
  this.declarationOfVariableCriterionBelongsToSliceNodes=pdgObjectSliceUnion.declarationOfObjectReferenceBelongsToSliceNodes();
  this.declarationOfVariableCriterionBelongsToRemovableNodes=pdgObjectSliceUnion.declarationOfObjectReferenceBelongsToRemovableNodes();
  this.iFile=pdgObjectSliceUnion.getIFile();
  this.boundaryBlock=pdgObjectSliceUnion.getBoundaryBlock();
}","public ASTSlice(PDGObjectSliceUnion pdgObjectSliceUnion){
  this.sourceMethodDeclaration=pdgObjectSliceUnion.getMethod().getMethodDeclaration();
  this.sourceTypeDeclaration=(TypeDeclaration)sourceMethodDeclaration.getParent();
  this.sliceNodes=pdgObjectSliceUnion.getSliceNodes();
  this.sliceStatements=new LinkedHashSet<Statement>();
  for (  PDGNode node : sliceNodes) {
    sliceStatements.add(node.getASTStatement());
  }
  this.removableStatements=new LinkedHashSet<Statement>();
  for (  PDGNode node : pdgObjectSliceUnion.getRemovableNodes()) {
    removableStatements.add(node.getASTStatement());
  }
  this.localVariableCriterion=pdgObjectSliceUnion.getObjectReference();
  this.passedParameters=new LinkedHashSet<VariableDeclaration>();
  for (  AbstractVariable variable : pdgObjectSliceUnion.getPassedParameters()) {
    passedParameters.add(variable.getName());
  }
  this.extractedMethodInvocationInsertionStatement=pdgObjectSliceUnion.getExtractedMethodInvocationInsertionNode().getASTStatement();
  this.extractedMethodName=localVariableCriterion.toString().replaceAll(""String_Node_Str"",""String_Node_Str"");
  this.declarationOfVariableCriterionBelongsToSliceNodes=pdgObjectSliceUnion.declarationOfObjectReferenceBelongsToSliceNodes();
  this.declarationOfVariableCriterionBelongsToRemovableNodes=pdgObjectSliceUnion.declarationOfObjectReferenceBelongsToRemovableNodes();
  this.iFile=pdgObjectSliceUnion.getIFile();
  this.boundaryBlock=pdgObjectSliceUnion.getBoundaryBlock();
  this.isObjectSlice=true;
}"
12131,"private void modifySourceMethod(MultiTextEdit root){
  ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
  AST ast=sourceMethodDeclaration.getAST();
  MethodInvocation extractedMethodInvocation=ast.newMethodInvocation();
  sourceRewriter.set(extractedMethodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(slice.getExtractedMethodName()),null);
  ListRewrite argumentRewrite=sourceRewriter.getListRewrite(extractedMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  VariableDeclaration variableDeclaration : slice.getPassedParameters()) {
    if (!variableDeclaration.resolveBinding().isField())     argumentRewrite.insertLast(variableDeclaration.getName(),null);
  }
  VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion().getName();
  if (slice.declarationOfVariableCriterionBelongsToSliceNodes() && slice.declarationOfVariableCriterionBelongsToRemovableNodes()) {
    VariableDeclarationFragment initializationFragment=ast.newVariableDeclarationFragment();
    sourceRewriter.set(initializationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariableDeclaration.getName(),null);
    sourceRewriter.set(initializationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractedMethodInvocation,null);
    VariableDeclarationStatement initializationVariableDeclarationStatement=ast.newVariableDeclarationStatement(initializationFragment);
    Type returnedVariableType=null;
    if (returnedVariableDeclaration instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariableDeclaration;
      returnedVariableType=singleVariableDeclaration.getType();
    }
 else     if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment fragment=(VariableDeclarationFragment)returnedVariableDeclaration;
      if (fragment.getParent() instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        returnedVariableType=variableDeclarationStatement.getType();
      }
 else       if (fragment.getParent() instanceof VariableDeclarationExpression) {
        VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)fragment.getParent();
        returnedVariableType=variableDeclarationExpression.getType();
      }
 else       if (fragment.getParent() instanceof FieldDeclaration) {
        FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
        returnedVariableType=fieldDeclaration.getType();
      }
    }
    sourceRewriter.set(initializationVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedVariableType,null);
    Statement extractedMethodInvocationInsertionStatement=slice.getExtractedMethodInvocationInsertionStatement();
    Block parentStatement=(Block)extractedMethodInvocationInsertionStatement.getParent();
    ListRewrite blockRewrite=sourceRewriter.getListRewrite(parentStatement,Block.STATEMENTS_PROPERTY);
    blockRewrite.insertBefore(initializationVariableDeclarationStatement,extractedMethodInvocationInsertionStatement,null);
  }
 else   if (slice.declarationOfVariableCriterionBelongsToSliceNodes() && !slice.declarationOfVariableCriterionBelongsToRemovableNodes()) {
    if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment oldInitializationFragment=(VariableDeclarationFragment)returnedVariableDeclaration;
      VariableDeclarationFragment newInitializationFragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(newInitializationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariableDeclaration.getName(),null);
      sourceRewriter.set(newInitializationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractedMethodInvocation,null);
      if (oldInitializationFragment.getParent() instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement oldVariableDeclarationStatement=(VariableDeclarationStatement)oldInitializationFragment.getParent();
        List<VariableDeclarationFragment> oldFragments=oldVariableDeclarationStatement.fragments();
        ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(oldVariableDeclarationStatement,VariableDeclarationStatement.FRAGMENTS_PROPERTY);
        for (int i=0; i < oldFragments.size(); i++) {
          if (oldInitializationFragment.equals(oldFragments.get(i)))           fragmentRewrite.replace(oldFragments.get(i),newInitializationFragment,null);
        }
      }
 else       if (oldInitializationFragment.getParent() instanceof VariableDeclarationExpression) {
        VariableDeclarationExpression oldVariableDeclarationExpression=(VariableDeclarationExpression)oldInitializationFragment.getParent();
        List<VariableDeclarationFragment> oldFragments=oldVariableDeclarationExpression.fragments();
        ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(oldVariableDeclarationExpression,VariableDeclarationExpression.FRAGMENTS_PROPERTY);
        for (int i=0; i < oldFragments.size(); i++) {
          if (oldInitializationFragment.equals(oldFragments.get(i)))           fragmentRewrite.replace(oldFragments.get(i),newInitializationFragment,null);
        }
      }
    }
  }
 else {
    Assignment assignment=ast.newAssignment();
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariableDeclaration.getName(),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,extractedMethodInvocation,null);
    ExpressionStatement expressionStatement=ast.newExpressionStatement(assignment);
    Statement extractedMethodInvocationInsertionStatement=slice.getExtractedMethodInvocationInsertionStatement();
    Block parentStatement=(Block)extractedMethodInvocationInsertionStatement.getParent();
    ListRewrite blockRewrite=sourceRewriter.getListRewrite(parentStatement,Block.STATEMENTS_PROPERTY);
    blockRewrite.insertBefore(expressionStatement,extractedMethodInvocationInsertionStatement,null);
  }
  for (  Statement removableStatement : slice.getRemovableStatements()) {
    sourceRewriter.remove(removableStatement,null);
  }
  try {
    TextEdit sourceEdit=sourceRewriter.rewriteAST();
    root.addChild(sourceEdit);
    compilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
}","private void modifySourceMethod(MultiTextEdit root){
  ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
  AST ast=sourceMethodDeclaration.getAST();
  MethodInvocation extractedMethodInvocation=ast.newMethodInvocation();
  sourceRewriter.set(extractedMethodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(slice.getExtractedMethodName()),null);
  ListRewrite argumentRewrite=sourceRewriter.getListRewrite(extractedMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  VariableDeclaration variableDeclaration : slice.getPassedParameters()) {
    if (!variableDeclaration.resolveBinding().isField())     argumentRewrite.insertLast(variableDeclaration.getName(),null);
  }
  VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion().getName();
  if (slice.declarationOfVariableCriterionBelongsToSliceNodes() && slice.declarationOfVariableCriterionBelongsToRemovableNodes()) {
    VariableDeclarationFragment initializationFragment=ast.newVariableDeclarationFragment();
    sourceRewriter.set(initializationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariableDeclaration.getName(),null);
    sourceRewriter.set(initializationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractedMethodInvocation,null);
    VariableDeclarationStatement initializationVariableDeclarationStatement=ast.newVariableDeclarationStatement(initializationFragment);
    Type returnedVariableType=null;
    if (returnedVariableDeclaration instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariableDeclaration;
      returnedVariableType=singleVariableDeclaration.getType();
    }
 else     if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment fragment=(VariableDeclarationFragment)returnedVariableDeclaration;
      if (fragment.getParent() instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        returnedVariableType=variableDeclarationStatement.getType();
      }
 else       if (fragment.getParent() instanceof VariableDeclarationExpression) {
        VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)fragment.getParent();
        returnedVariableType=variableDeclarationExpression.getType();
      }
 else       if (fragment.getParent() instanceof FieldDeclaration) {
        FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
        returnedVariableType=fieldDeclaration.getType();
      }
    }
    sourceRewriter.set(initializationVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedVariableType,null);
    Statement extractedMethodInvocationInsertionStatement=slice.getExtractedMethodInvocationInsertionStatement();
    Block parentStatement=(Block)extractedMethodInvocationInsertionStatement.getParent();
    ListRewrite blockRewrite=sourceRewriter.getListRewrite(parentStatement,Block.STATEMENTS_PROPERTY);
    blockRewrite.insertBefore(initializationVariableDeclarationStatement,extractedMethodInvocationInsertionStatement,null);
  }
 else   if (slice.declarationOfVariableCriterionBelongsToSliceNodes() && !slice.declarationOfVariableCriterionBelongsToRemovableNodes()) {
    if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment oldInitializationFragment=(VariableDeclarationFragment)returnedVariableDeclaration;
      VariableDeclarationFragment newInitializationFragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(newInitializationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariableDeclaration.getName(),null);
      sourceRewriter.set(newInitializationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractedMethodInvocation,null);
      if (oldInitializationFragment.getParent() instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement oldVariableDeclarationStatement=(VariableDeclarationStatement)oldInitializationFragment.getParent();
        List<VariableDeclarationFragment> oldFragments=oldVariableDeclarationStatement.fragments();
        ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(oldVariableDeclarationStatement,VariableDeclarationStatement.FRAGMENTS_PROPERTY);
        for (int i=0; i < oldFragments.size(); i++) {
          if (oldInitializationFragment.equals(oldFragments.get(i)))           fragmentRewrite.replace(oldFragments.get(i),newInitializationFragment,null);
        }
      }
 else       if (oldInitializationFragment.getParent() instanceof VariableDeclarationExpression) {
        VariableDeclarationExpression oldVariableDeclarationExpression=(VariableDeclarationExpression)oldInitializationFragment.getParent();
        List<VariableDeclarationFragment> oldFragments=oldVariableDeclarationExpression.fragments();
        ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(oldVariableDeclarationExpression,VariableDeclarationExpression.FRAGMENTS_PROPERTY);
        for (int i=0; i < oldFragments.size(); i++) {
          if (oldInitializationFragment.equals(oldFragments.get(i)))           fragmentRewrite.replace(oldFragments.get(i),newInitializationFragment,null);
        }
      }
    }
  }
 else {
    if (!slice.isObjectSlice()) {
      Assignment assignment=ast.newAssignment();
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariableDeclaration.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,extractedMethodInvocation,null);
      ExpressionStatement expressionStatement=ast.newExpressionStatement(assignment);
      Statement extractedMethodInvocationInsertionStatement=slice.getExtractedMethodInvocationInsertionStatement();
      Block parentStatement=(Block)extractedMethodInvocationInsertionStatement.getParent();
      ListRewrite blockRewrite=sourceRewriter.getListRewrite(parentStatement,Block.STATEMENTS_PROPERTY);
      blockRewrite.insertBefore(expressionStatement,extractedMethodInvocationInsertionStatement,null);
    }
 else {
      ExpressionStatement expressionStatement=ast.newExpressionStatement(extractedMethodInvocation);
      Statement extractedMethodInvocationInsertionStatement=slice.getExtractedMethodInvocationInsertionStatement();
      Block parentStatement=(Block)extractedMethodInvocationInsertionStatement.getParent();
      ListRewrite blockRewrite=sourceRewriter.getListRewrite(parentStatement,Block.STATEMENTS_PROPERTY);
      blockRewrite.insertBefore(expressionStatement,extractedMethodInvocationInsertionStatement,null);
    }
  }
  for (  Statement removableStatement : slice.getRemovableStatements()) {
    sourceRewriter.remove(removableStatement,null);
  }
  try {
    TextEdit sourceEdit=sourceRewriter.rewriteAST();
    root.addChild(sourceEdit);
    compilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
}"
12132,"private void extractMethod(MultiTextEdit root){
  ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
  AST ast=sourceTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion().getName();
  SimpleName returnedVariableSimpleName=returnedVariableDeclaration.getName();
  Type returnedVariableType=null;
  if (returnedVariableDeclaration instanceof SingleVariableDeclaration) {
    SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariableDeclaration;
    returnedVariableType=singleVariableDeclaration.getType();
  }
 else   if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
    VariableDeclarationFragment fragment=(VariableDeclarationFragment)returnedVariableDeclaration;
    if (fragment.getParent() instanceof VariableDeclarationStatement) {
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      returnedVariableType=variableDeclarationStatement.getType();
    }
 else     if (fragment.getParent() instanceof VariableDeclarationExpression) {
      VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)fragment.getParent();
      returnedVariableType=variableDeclarationExpression.getType();
    }
 else     if (fragment.getParent() instanceof FieldDeclaration) {
      FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
      returnedVariableType=fieldDeclaration.getType();
    }
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(slice.getExtractedMethodName()),null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnedVariableType,null);
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
  modifierRewrite.insertLast(accessModifier,null);
  if ((sourceMethodDeclaration.getModifiers() & Modifier.STATIC) != 0) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  VariableDeclaration variableDeclaration : slice.getPassedParameters()) {
    Type variableType=null;
    if (variableDeclaration instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)variableDeclaration;
      variableType=singleVariableDeclaration.getType();
    }
 else     if (variableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment fragment=(VariableDeclarationFragment)variableDeclaration;
      if (fragment.getParent() instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        variableType=variableDeclarationStatement.getType();
      }
 else       if (fragment.getParent() instanceof VariableDeclarationExpression) {
        VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)fragment.getParent();
        variableType=variableDeclarationExpression.getType();
      }
 else       if (fragment.getParent() instanceof FieldDeclaration) {
        FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
        variableType=fieldDeclaration.getType();
      }
    }
    if (!variableDeclaration.resolveBinding().isField()) {
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration.getName(),null);
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite bodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  List<PDGNode> sliceNodes=new ArrayList<PDGNode>(slice.getSliceNodes());
  List<CFGBranchDoLoopNode> doLoopNodes=new ArrayList<CFGBranchDoLoopNode>();
  for (  PDGNode pdgNode : sliceNodes) {
    CFGNode cfgNode=pdgNode.getCFGNode();
    if (cfgNode instanceof CFGBranchDoLoopNode) {
      CFGBranchDoLoopNode cfgDoLoopNode=(CFGBranchDoLoopNode)cfgNode;
      doLoopNodes.add(cfgDoLoopNode);
    }
  }
  while (!sliceNodes.isEmpty()) {
    PDGNode node=sliceNodes.get(0);
    if (node instanceof PDGStatementNode) {
      boolean nodeIsInsideDoLoop=false;
      for (      CFGBranchDoLoopNode doLoopNode : doLoopNodes) {
        if (node.getId() >= doLoopNode.getJoinNode().getId() && node.getId() < doLoopNode.getId()) {
          nodeIsInsideDoLoop=true;
          PDGControlPredicateNode predicateNode=(PDGControlPredicateNode)doLoopNode.getPDGNode();
          if (sliceNodes.contains(predicateNode)) {
            bodyRewrite.insertLast(processPredicateNode(predicateNode,ast,sourceRewriter,sliceNodes),null);
            break;
          }
        }
      }
      if (!nodeIsInsideDoLoop) {
        bodyRewrite.insertLast(node.getASTStatement(),null);
        sliceNodes.remove(node);
      }
    }
 else     if (node instanceof PDGControlPredicateNode) {
      PDGControlPredicateNode predicateNode=(PDGControlPredicateNode)node;
      bodyRewrite.insertLast(processPredicateNode(predicateNode,ast,sourceRewriter,sliceNodes),null);
    }
  }
  ReturnStatement returnStatement=newMethodBody.getAST().newReturnStatement();
  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariableSimpleName,null);
  bodyRewrite.insertLast(returnStatement,null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  ListRewrite methodDeclarationRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertAfter(newMethodDeclaration,sourceMethodDeclaration,null);
  try {
    TextEdit sourceEdit=sourceRewriter.rewriteAST();
    root.addChild(sourceEdit);
    compilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
}","private void extractMethod(MultiTextEdit root){
  ASTRewrite sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
  AST ast=sourceTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion().getName();
  SimpleName returnedVariableSimpleName=returnedVariableDeclaration.getName();
  Type returnedVariableType=null;
  if (returnedVariableDeclaration instanceof SingleVariableDeclaration) {
    SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariableDeclaration;
    returnedVariableType=singleVariableDeclaration.getType();
  }
 else   if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
    VariableDeclarationFragment fragment=(VariableDeclarationFragment)returnedVariableDeclaration;
    if (fragment.getParent() instanceof VariableDeclarationStatement) {
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      returnedVariableType=variableDeclarationStatement.getType();
    }
 else     if (fragment.getParent() instanceof VariableDeclarationExpression) {
      VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)fragment.getParent();
      returnedVariableType=variableDeclarationExpression.getType();
    }
 else     if (fragment.getParent() instanceof FieldDeclaration) {
      FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
      returnedVariableType=fieldDeclaration.getType();
    }
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(slice.getExtractedMethodName()),null);
  IVariableBinding returnedVariableBinding=returnedVariableDeclaration.resolveBinding();
  if (slice.isObjectSlice() && (returnedVariableBinding.isField() || returnedVariableBinding.isParameter() || !slice.declarationOfVariableCriterionBelongsToSliceNodes()))   sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,ast.newPrimitiveType(PrimitiveType.VOID),null);
 else   sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnedVariableType,null);
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier accessModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
  modifierRewrite.insertLast(accessModifier,null);
  if ((sourceMethodDeclaration.getModifiers() & Modifier.STATIC) != 0) {
    Modifier staticModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD);
    modifierRewrite.insertLast(staticModifier,null);
  }
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  VariableDeclaration variableDeclaration : slice.getPassedParameters()) {
    Type variableType=null;
    if (variableDeclaration instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)variableDeclaration;
      variableType=singleVariableDeclaration.getType();
    }
 else     if (variableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment fragment=(VariableDeclarationFragment)variableDeclaration;
      if (fragment.getParent() instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        variableType=variableDeclarationStatement.getType();
      }
 else       if (fragment.getParent() instanceof VariableDeclarationExpression) {
        VariableDeclarationExpression variableDeclarationExpression=(VariableDeclarationExpression)fragment.getParent();
        variableType=variableDeclarationExpression.getType();
      }
 else       if (fragment.getParent() instanceof FieldDeclaration) {
        FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
        variableType=fieldDeclaration.getType();
      }
    }
    if (!variableDeclaration.resolveBinding().isField()) {
      SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
      sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration.getName(),null);
      sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
      parameterRewrite.insertLast(parameter,null);
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite bodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  List<PDGNode> sliceNodes=new ArrayList<PDGNode>(slice.getSliceNodes());
  List<CFGBranchDoLoopNode> doLoopNodes=new ArrayList<CFGBranchDoLoopNode>();
  for (  PDGNode pdgNode : sliceNodes) {
    CFGNode cfgNode=pdgNode.getCFGNode();
    if (cfgNode instanceof CFGBranchDoLoopNode) {
      CFGBranchDoLoopNode cfgDoLoopNode=(CFGBranchDoLoopNode)cfgNode;
      doLoopNodes.add(cfgDoLoopNode);
    }
  }
  while (!sliceNodes.isEmpty()) {
    PDGNode node=sliceNodes.get(0);
    if (node instanceof PDGStatementNode) {
      boolean nodeIsInsideDoLoop=false;
      for (      CFGBranchDoLoopNode doLoopNode : doLoopNodes) {
        if (node.getId() >= doLoopNode.getJoinNode().getId() && node.getId() < doLoopNode.getId()) {
          nodeIsInsideDoLoop=true;
          PDGControlPredicateNode predicateNode=(PDGControlPredicateNode)doLoopNode.getPDGNode();
          if (sliceNodes.contains(predicateNode)) {
            bodyRewrite.insertLast(processPredicateNode(predicateNode,ast,sourceRewriter,sliceNodes),null);
            break;
          }
        }
      }
      if (!nodeIsInsideDoLoop) {
        bodyRewrite.insertLast(node.getASTStatement(),null);
        sliceNodes.remove(node);
      }
    }
 else     if (node instanceof PDGControlPredicateNode) {
      PDGControlPredicateNode predicateNode=(PDGControlPredicateNode)node;
      bodyRewrite.insertLast(processPredicateNode(predicateNode,ast,sourceRewriter,sliceNodes),null);
    }
  }
  if (!slice.isObjectSlice() || (!returnedVariableBinding.isField() && !returnedVariableBinding.isParameter() && slice.declarationOfVariableCriterionBelongsToSliceNodes())) {
    ReturnStatement returnStatement=newMethodBody.getAST().newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariableSimpleName,null);
    bodyRewrite.insertLast(returnStatement,null);
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  ListRewrite methodDeclarationRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertAfter(newMethodDeclaration,sourceMethodDeclaration,null);
  try {
    TextEdit sourceEdit=sourceRewriter.rewriteAST();
    root.addChild(sourceEdit);
    compilationUnitChange.addTextEditGroup(new TextEditGroup(""String_Node_Str"",new TextEdit[]{sourceEdit}));
  }
 catch (  JavaModelException e) {
    e.printStackTrace();
  }
}"
12133,"public void run(){
  IStructuredSelection selection=(IStructuredSelection)tableViewer.getSelection();
  TypeCheckElimination typeCheckElimination=(TypeCheckElimination)selection.getFirstElement();
  IFile sourceFile=typeCheckElimination.getTypeCheckIFile();
  String typeCheckMethodName=typeCheckElimination.toString();
  Statement typeCheckCodeFragment=typeCheckElimination.getTypeCheckCodeFragment();
  try {
    IJavaElement sourceJavaElement=JavaCore.create(sourceFile);
    ITextEditor sourceEditor=(ITextEditor)JavaUI.openInEditor(sourceJavaElement);
    AnnotationModel annotationModel=(AnnotationModel)sourceEditor.getDocumentProvider().getAnnotationModel(sourceEditor.getEditorInput());
    Iterator<Annotation> annotationIterator=annotationModel.getAnnotationIterator();
    while (annotationIterator.hasNext()) {
      Annotation currentAnnotation=annotationIterator.next();
      if (currentAnnotation.getType().equals(""String_Node_Str"")) {
        annotationModel.removeAnnotation(currentAnnotation);
      }
    }
    Annotation annotation=new Annotation(""String_Node_Str"",false,typeCheckMethodName);
    Position position=new Position(typeCheckCodeFragment.getStartPosition(),typeCheckCodeFragment.getLength());
    annotationModel.addAnnotation(annotation,position);
    sourceEditor.setHighlightRange(typeCheckCodeFragment.getStartPosition(),typeCheckCodeFragment.getLength(),true);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
}","public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
  typeCheckEliminationResults=systemObject.generateTypeCheckEliminations(monitor);
}"
12134,"private TypeCheckElimination[] getTable(){
  if (selectedPackage != null)   new ASTReader(selectedPackage);
 else   new ASTReader(selectedProject);
  SystemObject systemObject=ASTReader.getSystemObject();
  typeCheckEliminationResults=systemObject.generateTypeCheckEliminations();
  List<TypeCheckElimination> typeCheckEliminations=typeCheckEliminationResults.getTypeCheckEliminations();
  TypeCheckElimination[] table=new TypeCheckElimination[typeCheckEliminations.size()];
  int i=0;
  for (  TypeCheckElimination typeCheckElimination : typeCheckEliminations) {
    table[i]=typeCheckElimination;
    i++;
  }
  return table;
}","private TypeCheckElimination[] getTable(){
  if (selectedPackage != null)   new ASTReader(selectedPackage);
 else   new ASTReader(selectedProject);
  final SystemObject systemObject=ASTReader.getSystemObject();
  IWorkbenchWindow window=getSite().getWorkbenchWindow();
  try {
    window.getWorkbench().getProgressService().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        typeCheckEliminationResults=systemObject.generateTypeCheckEliminations(monitor);
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  List<TypeCheckElimination> typeCheckEliminations=typeCheckEliminationResults.getTypeCheckEliminations();
  TypeCheckElimination[] table=new TypeCheckElimination[typeCheckEliminations.size()];
  int i=0;
  for (  TypeCheckElimination typeCheckElimination : typeCheckEliminations) {
    table[i]=typeCheckElimination;
    i++;
  }
  return table;
}"
12135,"public ASTSlice(PDGObjectSliceUnion pdgObjectSliceUnion){
  this.sourceMethodDeclaration=pdgObjectSliceUnion.getMethod().getMethodDeclaration();
  this.sourceTypeDeclaration=(TypeDeclaration)sourceMethodDeclaration.getParent();
  this.sliceNodes=pdgObjectSliceUnion.getSliceNodes();
  this.sliceStatements=new LinkedHashSet<Statement>();
  for (  PDGNode node : sliceNodes) {
    sliceStatements.add(node.getASTStatement());
  }
  this.removableStatements=new LinkedHashSet<Statement>();
  for (  PDGNode node : pdgObjectSliceUnion.getRemovableNodes()) {
    removableStatements.add(node.getASTStatement());
  }
  Set<VariableDeclaration> variableDeclarationsAndAccessedFields=pdgObjectSliceUnion.getVariableDeclarationsAndAccessedFieldsInMethod();
  AbstractVariable criterion=pdgObjectSliceUnion.getObjectReference();
  for (  VariableDeclaration variableDeclaration : variableDeclarationsAndAccessedFields) {
    if (variableDeclaration.resolveBinding().getKey().equals(criterion.getVariableBindingKey())) {
      this.localVariableCriterion=variableDeclaration;
      break;
    }
  }
  this.passedParameters=new LinkedHashSet<VariableDeclaration>();
  for (  AbstractVariable variable : pdgObjectSliceUnion.getPassedParameters()) {
    for (    VariableDeclaration variableDeclaration : variableDeclarationsAndAccessedFields) {
      if (variableDeclaration.resolveBinding().getKey().equals(variable.getVariableBindingKey())) {
        passedParameters.add(variableDeclaration);
        break;
      }
    }
  }
  this.extractedMethodInvocationInsertionStatement=pdgObjectSliceUnion.getExtractedMethodInvocationInsertionNode().getASTStatement();
  this.extractedMethodName=localVariableCriterion.toString().replaceAll(""String_Node_Str"",""String_Node_Str"");
  this.declarationOfVariableCriterionBelongsToSliceNodes=pdgObjectSliceUnion.declarationOfObjectReferenceBelongsToSliceNodes();
  this.declarationOfVariableCriterionBelongsToRemovableNodes=pdgObjectSliceUnion.declarationOfObjectReferenceBelongsToRemovableNodes();
  this.iFile=pdgObjectSliceUnion.getIFile();
  this.boundaryBlock=pdgObjectSliceUnion.getBoundaryBlock();
  this.isObjectSlice=true;
}","public ASTSlice(PDGObjectSliceUnion pdgObjectSliceUnion){
  this.sourceMethodDeclaration=pdgObjectSliceUnion.getMethod().getMethodDeclaration();
  this.sourceTypeDeclaration=(TypeDeclaration)sourceMethodDeclaration.getParent();
  this.sliceNodes=pdgObjectSliceUnion.getSliceNodes();
  this.sliceStatements=new LinkedHashSet<Statement>();
  for (  PDGNode node : sliceNodes) {
    sliceStatements.add(node.getASTStatement());
  }
  this.removableStatements=new LinkedHashSet<Statement>();
  for (  PDGNode node : pdgObjectSliceUnion.getRemovableNodes()) {
    removableStatements.add(node.getASTStatement());
  }
  Set<VariableDeclaration> variableDeclarationsAndAccessedFields=pdgObjectSliceUnion.getVariableDeclarationsAndAccessedFieldsInMethod();
  AbstractVariable criterion=pdgObjectSliceUnion.getObjectReference();
  for (  VariableDeclaration variableDeclaration : variableDeclarationsAndAccessedFields) {
    if (variableDeclaration.resolveBinding().getKey().equals(criterion.getVariableBindingKey())) {
      this.localVariableCriterion=variableDeclaration;
      break;
    }
  }
  this.passedParameters=new LinkedHashSet<VariableDeclaration>();
  for (  AbstractVariable variable : pdgObjectSliceUnion.getPassedParameters()) {
    for (    VariableDeclaration variableDeclaration : variableDeclarationsAndAccessedFields) {
      if (variableDeclaration.resolveBinding().getKey().equals(variable.getVariableBindingKey())) {
        passedParameters.add(variableDeclaration);
        break;
      }
    }
  }
  this.extractedMethodInvocationInsertionStatement=pdgObjectSliceUnion.getExtractedMethodInvocationInsertionNode().getASTStatement();
  this.extractedMethodName=localVariableCriterion.getName().getIdentifier();
  this.declarationOfVariableCriterionBelongsToSliceNodes=pdgObjectSliceUnion.declarationOfObjectReferenceBelongsToSliceNodes();
  this.declarationOfVariableCriterionBelongsToRemovableNodes=pdgObjectSliceUnion.declarationOfObjectReferenceBelongsToRemovableNodes();
  this.iFile=pdgObjectSliceUnion.getIFile();
  this.boundaryBlock=pdgObjectSliceUnion.getBoundaryBlock();
  this.isObjectSlice=true;
}"
12136,"private void aliasSearch(PDGNode currentNode,boolean visitedFromLoopbackFlow,ReachingAliasSet reachingAliasSet){
  CFGNode currentCFGNode=currentNode.getCFGNode();
  for (  GraphEdge edge : currentCFGNode.outgoingEdges) {
    Flow flow=(Flow)edge;
    if (!visitedFromLoopbackFlow || (visitedFromLoopbackFlow && flow.isFalseControlFlow())) {
      CFGNode dstCFGNode=(CFGNode)flow.dst;
      PDGNode dstPDGNode=dstCFGNode.getPDGNode();
      ReachingAliasSet reachingAliasSetCopy=reachingAliasSet.copy();
      dstPDGNode.applyReachingAliasSet(reachingAliasSetCopy);
      dstPDGNode.updateReachingAliasSet(reachingAliasSetCopy);
      if (flow.isLoopbackFlow())       aliasSearch(dstPDGNode,true,reachingAliasSetCopy);
 else       aliasSearch(dstPDGNode,false,reachingAliasSetCopy);
    }
  }
}","private void aliasSearch(PDGNode currentNode,boolean visitedFromLoopbackFlow,ReachingAliasSet reachingAliasSet){
  CFGNode currentCFGNode=currentNode.getCFGNode();
  for (  GraphEdge edge : currentCFGNode.outgoingEdges) {
    Flow flow=(Flow)edge;
    if (!visitedFromLoopbackFlow || (visitedFromLoopbackFlow && flow.isFalseControlFlow())) {
      CFGNode srcCFGNode=(CFGNode)flow.src;
      CFGNode dstCFGNode=(CFGNode)flow.dst;
      PDGNode dstPDGNode=dstCFGNode.getPDGNode();
      ReachingAliasSet reachingAliasSetCopy=reachingAliasSet.copy();
      dstPDGNode.applyReachingAliasSet(reachingAliasSetCopy);
      dstPDGNode.updateReachingAliasSet(reachingAliasSetCopy);
      if (!(srcCFGNode instanceof CFGBranchDoLoopNode && flow.isTrueControlFlow())) {
        if (flow.isLoopbackFlow())         aliasSearch(dstPDGNode,true,reachingAliasSetCopy);
 else         aliasSearch(dstPDGNode,false,reachingAliasSetCopy);
      }
    }
  }
}"
12137,"/** 
 * This is a callback that will allow us to create the viewer and initialize it.
 */
public void createPartControl(Composite parent){
  tableViewer=new TableViewer(parent,SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL| SWT.BORDER| SWT.FULL_SELECTION);
  tableViewer.setContentProvider(new ViewContentProvider());
  tableViewer.setLabelProvider(new ViewLabelProvider());
  tableViewer.setSorter(new NameSorter());
  tableViewer.setInput(getViewSite());
  TableLayout layout=new TableLayout();
  layout.addColumnData(new ColumnWeightData(40,true));
  layout.addColumnData(new ColumnWeightData(60,true));
  layout.addColumnData(new ColumnWeightData(40,true));
  layout.addColumnData(new ColumnWeightData(40,true));
  tableViewer.getTable().setLayout(layout);
  tableViewer.getTable().setLinesVisible(true);
  tableViewer.getTable().setHeaderVisible(true);
  TableColumn column0=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column0.setText(""String_Node_Str"");
  column0.setResizable(true);
  column0.pack();
  TableColumn column1=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column1.setText(""String_Node_Str"");
  column1.setResizable(true);
  column1.pack();
  TableColumn column2=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column2.setText(""String_Node_Str"");
  column2.setResizable(true);
  column2.pack();
  TableColumn column3=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column3.setText(""String_Node_Str"");
  column3.setResizable(true);
  column3.pack();
  makeActions();
  hookDoubleClickAction();
  contributeToActionBars();
  getSite().getWorkbenchWindow().getSelectionService().addSelectionListener(selectionListener);
  JFaceResources.getFontRegistry().put(MyToolTip.HEADER_FONT,JFaceResources.getFontRegistry().getBold(JFaceResources.getDefaultFont().getFontData()[0].getName()).getFontData());
  MyToolTip toolTip=new MyToolTip(tableViewer.getControl());
  toolTip.setShift(new Point(-5,-5));
  toolTip.setHideOnMouseDown(false);
  toolTip.activate();
}","/** 
 * This is a callback that will allow us to create the viewer and initialize it.
 */
public void createPartControl(Composite parent){
  tableViewer=new TableViewer(parent,SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL| SWT.BORDER| SWT.FULL_SELECTION);
  tableViewer.setContentProvider(new ViewContentProvider());
  tableViewer.setLabelProvider(new ViewLabelProvider());
  tableViewer.setSorter(new NameSorter());
  tableViewer.setInput(getViewSite());
  TableLayout layout=new TableLayout();
  layout.addColumnData(new ColumnWeightData(40,true));
  layout.addColumnData(new ColumnWeightData(60,true));
  layout.addColumnData(new ColumnWeightData(40,true));
  layout.addColumnData(new ColumnWeightData(40,true));
  tableViewer.getTable().setLayout(layout);
  tableViewer.getTable().setLinesVisible(true);
  tableViewer.getTable().setHeaderVisible(true);
  TableColumn column0=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column0.setText(""String_Node_Str"");
  column0.setResizable(true);
  column0.pack();
  TableColumn column1=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column1.setText(""String_Node_Str"");
  column1.setResizable(true);
  column1.pack();
  TableColumn column2=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column2.setText(""String_Node_Str"");
  column2.setResizable(true);
  column2.pack();
  TableColumn column3=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column3.setText(""String_Node_Str"");
  column3.setResizable(true);
  column3.pack();
  makeActions();
  hookDoubleClickAction();
  contributeToActionBars();
  getSite().getWorkbenchWindow().getSelectionService().addSelectionListener(selectionListener);
  getSite().getWorkbenchWindow().getWorkbench().getOperationSupport().getOperationHistory().addOperationHistoryListener(new OperationHistoryListener());
  JFaceResources.getFontRegistry().put(MyToolTip.HEADER_FONT,JFaceResources.getFontRegistry().getBold(JFaceResources.getDefaultFont().getFontData()[0].getName()).getFontData());
  MyToolTip toolTip=new MyToolTip(tableViewer.getControl());
  toolTip.setShift(new Point(-5,-5));
  toolTip.setHideOnMouseDown(false);
  toolTip.activate();
}"
12138,"public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
  monitor.beginTask(""String_Node_Str"",systemObject.getClassNumber());
  ListIterator<ClassObject> classIterator=systemObject.getClassListIterator();
  while (classIterator.hasNext()) {
    if (monitor.isCanceled())     throw new OperationCanceledException();
    ClassObject classObject=classIterator.next();
    ListIterator<MethodObject> methodIterator=classObject.getMethodIterator();
    while (methodIterator.hasNext()) {
      MethodObject methodObject=methodIterator.next();
      if (methodObject.getMethodBody() != null) {
        CFG cfg=new CFG(methodObject);
        PDG pdg=new PDG(cfg,classObject.getIFile());
        pdg.setFieldsAccessedInMethod(classObject.getFieldsAccessedInsideMethod(methodObject));
        for (        VariableDeclaration declaration : pdg.getVariableDeclarationsInMethod()) {
          PlainVariable variable=new PlainVariable(declaration);
          PDGSliceUnionCollection sliceUnionCollection=new PDGSliceUnionCollection(pdg,variable);
          for (          PDGSliceUnion sliceUnion : sliceUnionCollection.getSliceUnions()) {
            extractedSlices.add(sliceUnion);
          }
        }
        for (        VariableDeclaration declaration : pdg.getVariableDeclarationsAndAccessedFieldsInMethod()) {
          PlainVariable variable=new PlainVariable(declaration);
          PDGObjectSliceUnionCollection objectSliceUnionCollection=new PDGObjectSliceUnionCollection(pdg,variable);
          for (          PDGObjectSliceUnion objectSliceUnion : objectSliceUnionCollection.getSliceUnions()) {
            extractedObjectSlices.add(objectSliceUnion);
          }
        }
      }
    }
    monitor.worked(1);
  }
  monitor.done();
}","public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
  monitor.beginTask(""String_Node_Str"",systemObject.getClassNumber());
  ListIterator<ClassObject> classIterator=systemObject.getClassListIterator();
  while (classIterator.hasNext()) {
    if (monitor.isCanceled())     throw new OperationCanceledException();
    ClassObject classObject=classIterator.next();
    ListIterator<MethodObject> methodIterator=classObject.getMethodIterator();
    while (methodIterator.hasNext()) {
      MethodObject methodObject=methodIterator.next();
      if (methodObject.getMethodBody() != null) {
        CFG cfg=new CFG(methodObject);
        PDG pdg=new PDG(cfg,classObject.getIFile());
        pdg.setFieldsAccessedInMethod(classObject.getFieldsAccessedInsideMethod(methodObject));
        for (        VariableDeclaration declaration : pdg.getVariableDeclarationsInMethod()) {
          PlainVariable variable=new PlainVariable(declaration);
          PDGSliceUnionCollection sliceUnionCollection=new PDGSliceUnionCollection(pdg,variable);
          for (          PDGSliceUnion sliceUnion : sliceUnionCollection.getSliceUnions()) {
            extractedSlices.add(sliceUnion);
          }
        }
      }
    }
    monitor.worked(1);
  }
  monitor.done();
}"
12139,"private ASTSlice[] getTable(){
  if (selectedPackage != null)   new ASTReader(selectedPackage);
 else   new ASTReader(selectedProject);
  final SystemObject systemObject=ASTReader.getSystemObject();
  final List<PDGSliceUnion> extractedSlices=new ArrayList<PDGSliceUnion>();
  final List<PDGObjectSliceUnion> extractedObjectSlices=new ArrayList<PDGObjectSliceUnion>();
  IWorkbenchWindow window=getSite().getWorkbenchWindow();
  try {
    window.getWorkbench().getProgressService().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        monitor.beginTask(""String_Node_Str"",systemObject.getClassNumber());
        ListIterator<ClassObject> classIterator=systemObject.getClassListIterator();
        while (classIterator.hasNext()) {
          if (monitor.isCanceled())           throw new OperationCanceledException();
          ClassObject classObject=classIterator.next();
          ListIterator<MethodObject> methodIterator=classObject.getMethodIterator();
          while (methodIterator.hasNext()) {
            MethodObject methodObject=methodIterator.next();
            if (methodObject.getMethodBody() != null) {
              CFG cfg=new CFG(methodObject);
              PDG pdg=new PDG(cfg,classObject.getIFile());
              pdg.setFieldsAccessedInMethod(classObject.getFieldsAccessedInsideMethod(methodObject));
              for (              VariableDeclaration declaration : pdg.getVariableDeclarationsInMethod()) {
                PlainVariable variable=new PlainVariable(declaration);
                PDGSliceUnionCollection sliceUnionCollection=new PDGSliceUnionCollection(pdg,variable);
                for (                PDGSliceUnion sliceUnion : sliceUnionCollection.getSliceUnions()) {
                  extractedSlices.add(sliceUnion);
                }
              }
              for (              VariableDeclaration declaration : pdg.getVariableDeclarationsAndAccessedFieldsInMethod()) {
                PlainVariable variable=new PlainVariable(declaration);
                PDGObjectSliceUnionCollection objectSliceUnionCollection=new PDGObjectSliceUnionCollection(pdg,variable);
                for (                PDGObjectSliceUnion objectSliceUnion : objectSliceUnionCollection.getSliceUnions()) {
                  extractedObjectSlices.add(objectSliceUnion);
                }
              }
            }
          }
          monitor.worked(1);
        }
        monitor.done();
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  ASTSlice[] table=new ASTSlice[extractedSlices.size() + extractedObjectSlices.size()];
  for (int i=0; i < extractedSlices.size(); i++) {
    ASTSlice astSlice=new ASTSlice(extractedSlices.get(i));
    table[i]=astSlice;
  }
  for (int i=0; i < extractedObjectSlices.size(); i++) {
    ASTSlice astSlice=new ASTSlice(extractedObjectSlices.get(i));
    table[extractedSlices.size() + i]=astSlice;
  }
  return table;
}","private ASTSlice[] getTable(){
  if (selectedPackage != null)   new ASTReader(selectedPackage);
 else   new ASTReader(selectedProject);
  final SystemObject systemObject=ASTReader.getSystemObject();
  final List<PDGSliceUnion> extractedSlices=new ArrayList<PDGSliceUnion>();
  final List<PDGObjectSliceUnion> extractedObjectSlices=new ArrayList<PDGObjectSliceUnion>();
  IWorkbenchWindow window=getSite().getWorkbenchWindow();
  try {
    window.getWorkbench().getProgressService().run(true,true,new IRunnableWithProgress(){
      public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        monitor.beginTask(""String_Node_Str"",systemObject.getClassNumber());
        ListIterator<ClassObject> classIterator=systemObject.getClassListIterator();
        while (classIterator.hasNext()) {
          if (monitor.isCanceled())           throw new OperationCanceledException();
          ClassObject classObject=classIterator.next();
          ListIterator<MethodObject> methodIterator=classObject.getMethodIterator();
          while (methodIterator.hasNext()) {
            MethodObject methodObject=methodIterator.next();
            if (methodObject.getMethodBody() != null) {
              CFG cfg=new CFG(methodObject);
              PDG pdg=new PDG(cfg,classObject.getIFile());
              pdg.setFieldsAccessedInMethod(classObject.getFieldsAccessedInsideMethod(methodObject));
              for (              VariableDeclaration declaration : pdg.getVariableDeclarationsInMethod()) {
                PlainVariable variable=new PlainVariable(declaration);
                PDGSliceUnionCollection sliceUnionCollection=new PDGSliceUnionCollection(pdg,variable);
                for (                PDGSliceUnion sliceUnion : sliceUnionCollection.getSliceUnions()) {
                  extractedSlices.add(sliceUnion);
                }
              }
            }
          }
          monitor.worked(1);
        }
        monitor.done();
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  ASTSlice[] table=new ASTSlice[extractedSlices.size() + extractedObjectSlices.size()];
  for (int i=0; i < extractedSlices.size(); i++) {
    ASTSlice astSlice=new ASTSlice(extractedSlices.get(i));
    table[i]=astSlice;
  }
  for (int i=0; i < extractedObjectSlices.size(); i++) {
    ASTSlice astSlice=new ASTSlice(extractedObjectSlices.get(i));
    table[extractedSlices.size() + i]=astSlice;
  }
  return table;
}"
12140,"@Override public void createPartControl(Composite parent){
  tableViewer=new TableViewer(parent,SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL| SWT.BORDER| SWT.FULL_SELECTION);
  tableViewer.setContentProvider(new ViewContentProvider());
  tableViewer.setLabelProvider(new ViewLabelProvider());
  tableViewer.setInput(getViewSite());
  TableLayout layout=new TableLayout();
  layout.addColumnData(new ColumnWeightData(20,true));
  layout.addColumnData(new ColumnWeightData(60,true));
  layout.addColumnData(new ColumnWeightData(40,true));
  layout.addColumnData(new ColumnWeightData(20,true));
  layout.addColumnData(new ColumnWeightData(20,true));
  tableViewer.getTable().setLayout(layout);
  tableViewer.getTable().setLinesVisible(true);
  tableViewer.getTable().setHeaderVisible(true);
  TableColumn column0=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column0.setText(""String_Node_Str"");
  column0.setResizable(true);
  column0.pack();
  TableColumn column1=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column1.setText(""String_Node_Str"");
  column1.setResizable(true);
  column1.pack();
  TableColumn column2=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column2.setText(""String_Node_Str"");
  column2.setResizable(true);
  column2.pack();
  TableColumn column3=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column3.setText(""String_Node_Str"");
  column3.setResizable(true);
  column3.pack();
  TableColumn column4=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column4.setText(""String_Node_Str"");
  column4.setResizable(true);
  column4.pack();
  makeActions();
  hookDoubleClickAction();
  contributeToActionBars();
  getSite().getWorkbenchWindow().getSelectionService().addSelectionListener(selectionListener);
}","@Override public void createPartControl(Composite parent){
  tableViewer=new TableViewer(parent,SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL| SWT.BORDER| SWT.FULL_SELECTION);
  tableViewer.setContentProvider(new ViewContentProvider());
  tableViewer.setLabelProvider(new ViewLabelProvider());
  tableViewer.setInput(getViewSite());
  TableLayout layout=new TableLayout();
  layout.addColumnData(new ColumnWeightData(20,true));
  layout.addColumnData(new ColumnWeightData(60,true));
  layout.addColumnData(new ColumnWeightData(40,true));
  layout.addColumnData(new ColumnWeightData(20,true));
  layout.addColumnData(new ColumnWeightData(20,true));
  tableViewer.getTable().setLayout(layout);
  tableViewer.getTable().setLinesVisible(true);
  tableViewer.getTable().setHeaderVisible(true);
  TableColumn column0=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column0.setText(""String_Node_Str"");
  column0.setResizable(true);
  column0.pack();
  TableColumn column1=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column1.setText(""String_Node_Str"");
  column1.setResizable(true);
  column1.pack();
  TableColumn column2=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column2.setText(""String_Node_Str"");
  column2.setResizable(true);
  column2.pack();
  TableColumn column3=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column3.setText(""String_Node_Str"");
  column3.setResizable(true);
  column3.pack();
  TableColumn column4=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column4.setText(""String_Node_Str"");
  column4.setResizable(true);
  column4.pack();
  makeActions();
  hookDoubleClickAction();
  contributeToActionBars();
  getSite().getWorkbenchWindow().getSelectionService().addSelectionListener(selectionListener);
  getSite().getWorkbenchWindow().getWorkbench().getOperationSupport().getOperationHistory().addOperationHistoryListener(new OperationHistoryListener());
}"
12141,"/** 
 * This is a callback that will allow us to create the viewer and initialize it.
 */
public void createPartControl(Composite parent){
  tableViewer=new TableViewer(parent,SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL| SWT.BORDER| SWT.FULL_SELECTION);
  tableViewer.setContentProvider(new ViewContentProvider());
  tableViewer.setLabelProvider(new ViewLabelProvider());
  tableViewer.setSorter(new NameSorter());
  tableViewer.setInput(getViewSite());
  TableLayout layout=new TableLayout();
  layout.addColumnData(new ColumnWeightData(50,true));
  layout.addColumnData(new ColumnWeightData(100,true));
  layout.addColumnData(new ColumnWeightData(30,true));
  layout.addColumnData(new ColumnWeightData(20,true));
  layout.addColumnData(new ColumnWeightData(20,true));
  layout.addColumnData(new ColumnWeightData(20,true));
  tableViewer.getTable().setLayout(layout);
  tableViewer.getTable().setLinesVisible(true);
  tableViewer.getTable().setHeaderVisible(true);
  TableColumn column0=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column0.setText(""String_Node_Str"");
  column0.setResizable(true);
  column0.pack();
  TableColumn column1=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column1.setText(""String_Node_Str"");
  column1.setResizable(true);
  column1.pack();
  TableColumn column2=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column2.setText(""String_Node_Str"");
  column2.setResizable(true);
  column2.pack();
  TableColumn column3=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column3.setText(""String_Node_Str"");
  column3.setResizable(true);
  column3.pack();
  TableColumn column4=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column4.setText(""String_Node_Str"");
  column4.setResizable(true);
  column4.pack();
  TableColumn column5=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column5.setText(""String_Node_Str"");
  column5.setResizable(true);
  column5.pack();
  makeActions();
  hookDoubleClickAction();
  contributeToActionBars();
  getSite().getWorkbenchWindow().getSelectionService().addSelectionListener(selectionListener);
}","/** 
 * This is a callback that will allow us to create the viewer and initialize it.
 */
public void createPartControl(Composite parent){
  tableViewer=new TableViewer(parent,SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL| SWT.BORDER| SWT.FULL_SELECTION);
  tableViewer.setContentProvider(new ViewContentProvider());
  tableViewer.setLabelProvider(new ViewLabelProvider());
  tableViewer.setSorter(new NameSorter());
  tableViewer.setInput(getViewSite());
  TableLayout layout=new TableLayout();
  layout.addColumnData(new ColumnWeightData(50,true));
  layout.addColumnData(new ColumnWeightData(100,true));
  layout.addColumnData(new ColumnWeightData(30,true));
  layout.addColumnData(new ColumnWeightData(20,true));
  layout.addColumnData(new ColumnWeightData(20,true));
  layout.addColumnData(new ColumnWeightData(20,true));
  tableViewer.getTable().setLayout(layout);
  tableViewer.getTable().setLinesVisible(true);
  tableViewer.getTable().setHeaderVisible(true);
  TableColumn column0=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column0.setText(""String_Node_Str"");
  column0.setResizable(true);
  column0.pack();
  TableColumn column1=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column1.setText(""String_Node_Str"");
  column1.setResizable(true);
  column1.pack();
  TableColumn column2=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column2.setText(""String_Node_Str"");
  column2.setResizable(true);
  column2.pack();
  TableColumn column3=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column3.setText(""String_Node_Str"");
  column3.setResizable(true);
  column3.pack();
  TableColumn column4=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column4.setText(""String_Node_Str"");
  column4.setResizable(true);
  column4.pack();
  TableColumn column5=new TableColumn(tableViewer.getTable(),SWT.LEFT);
  column5.setText(""String_Node_Str"");
  column5.setResizable(true);
  column5.pack();
  makeActions();
  hookDoubleClickAction();
  contributeToActionBars();
  getSite().getWorkbenchWindow().getSelectionService().addSelectionListener(selectionListener);
  getSite().getWorkbenchWindow().getWorkbench().getOperationSupport().getOperationHistory().addOperationHistoryListener(new OperationHistoryListener());
}"
12142,"public TypeCheckEliminationResults generateTypeCheckEliminations(){
  TypeCheckEliminationResults typeCheckEliminationResults=new TypeCheckEliminationResults();
  Map<TypeCheckElimination,List<SimpleName>> staticFieldMap=new LinkedHashMap<TypeCheckElimination,List<SimpleName>>();
  Map<Integer,ArrayList<TypeCheckElimination>> staticFieldRankMap=new TreeMap<Integer,ArrayList<TypeCheckElimination>>();
  Map<String,ArrayList<TypeCheckElimination>> inheritanceTreeMap=new LinkedHashMap<String,ArrayList<TypeCheckElimination>>();
  CompleteInheritanceDetection inheritanceDetection=new CompleteInheritanceDetection(this);
  for (  ClassObject classObject : classList) {
    List<TypeCheckElimination> eliminations=classObject.generateTypeCheckEliminations();
    for (    TypeCheckElimination elimination : eliminations) {
      List<SimpleName> staticFields=elimination.getStaticFields();
      if (!staticFields.isEmpty()) {
        if (allStaticFieldsWithinSystemBoundary(staticFields)) {
          inheritanceHierarchyMatchingWithStaticTypes(elimination,inheritanceDetection);
          boolean isValid=false;
          if (elimination.getTypeField() != null) {
            IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
            ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
            if (typeFieldTypeBinding.isPrimitive() || typeFieldTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeLocalVariable() != null) {
            IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
            ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
            if (typeLocalVariableTypeBinding.isPrimitive() || typeLocalVariableTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeMethodInvocation() != null) {
            MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
            IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
            ITypeBinding typeMethodInvocationDeclaringClass=typeMethodInvocationBinding.getDeclaringClass();
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            ClassObject declaringClassObject=getClassObject(typeMethodInvocationDeclaringClass.getQualifiedName());
            if ((typeMethodInvocationReturnType.isPrimitive() || typeMethodInvocationReturnType.isEnum()) && declaringClassObject != null) {
              MethodDeclaration invokedMethodDeclaration=null;
              ListIterator<MethodObject> methodIterator=declaringClassObject.getMethodIterator();
              while (methodIterator.hasNext()) {
                MethodObject methodObject=methodIterator.next();
                MethodDeclaration methodDeclaration=methodObject.getMethodDeclaration();
                if (typeMethodInvocationBinding.isEqualTo(methodDeclaration.resolveBinding())) {
                  invokedMethodDeclaration=methodDeclaration;
                  break;
                }
              }
              SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(invokedMethodDeclaration);
              if (fieldInstruction != null) {
                ListIterator<FieldObject> fieldIterator=declaringClassObject.getFieldIterator();
                while (fieldIterator.hasNext()) {
                  FieldObject fieldObject=fieldIterator.next();
                  VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                  if (fieldInstruction.resolveBinding().isEqualTo(fragment.resolveBinding())) {
                    elimination.setForeignTypeField(fragment);
                    break;
                  }
                }
                isValid=true;
              }
 else               if (invokedMethodDeclaration.getBody() == null) {
                InheritanceTree tree=elimination.getInheritanceTreeMatchingWithStaticTypes();
                if (tree != null) {
                  Expression typeMethodInvocationExpression=typeMethodInvocation.getExpression();
                  ITypeBinding typeCheckClassBinding=elimination.getTypeCheckClass().resolveBinding();
                  ClassObject typeCheckClassObject=getClassObject(typeCheckClassBinding.getQualifiedName());
                  SimpleName invoker=null;
                  if (typeMethodInvocationExpression instanceof SimpleName) {
                    invoker=(SimpleName)typeMethodInvocationExpression;
                  }
 else                   if (typeMethodInvocationExpression instanceof FieldAccess) {
                    FieldAccess fieldAccess=(FieldAccess)typeMethodInvocationExpression;
                    invoker=fieldAccess.getName();
                  }
                  if (invoker != null) {
                    IBinding binding=invoker.resolveBinding();
                    if (binding.getKind() == IBinding.VARIABLE) {
                      IVariableBinding variableBinding=(IVariableBinding)binding;
                      if (variableBinding.isField()) {
                        ListIterator<FieldObject> fieldIterator=typeCheckClassObject.getFieldIterator();
                        while (fieldIterator.hasNext()) {
                          FieldObject fieldObject=fieldIterator.next();
                          VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                          if (variableBinding.isEqualTo(fragment.resolveBinding())) {
                            elimination.setTypeField(fragment);
                            break;
                          }
                        }
                      }
 else                       if (variableBinding.isParameter()) {
                        List<SingleVariableDeclaration> parameters=elimination.getTypeCheckMethodParameters();
                        for (                        SingleVariableDeclaration parameter : parameters) {
                          IVariableBinding parameterVariableBinding=parameter.resolveBinding();
                          if (parameterVariableBinding.isEqualTo(variableBinding)) {
                            elimination.setTypeLocalVariable(parameter);
                            break;
                          }
                        }
                      }
 else {
                        StatementExtractor statementExtractor=new StatementExtractor();
                        Block typeCheckMethodBody=elimination.getTypeCheckMethod().getBody();
                        List<Statement> variableDeclarationStatements=statementExtractor.getVariableDeclarations(typeCheckMethodBody);
                        for (                        Statement vDStatement : variableDeclarationStatements) {
                          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
                          List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
                          for (                          VariableDeclarationFragment fragment : fragments) {
                            IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                            if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                              elimination.setTypeLocalVariable(fragment);
                              break;
                            }
                          }
                        }
                        List<Statement> enhancedForStatements=statementExtractor.getEnhancedForStatements(typeCheckMethodBody);
                        for (                        Statement eFStatement : enhancedForStatements) {
                          EnhancedForStatement enhancedForStatement=(EnhancedForStatement)eFStatement;
                          SingleVariableDeclaration formalParameter=enhancedForStatement.getParameter();
                          IVariableBinding parameterVariableBinding=formalParameter.resolveBinding();
                          if (parameterVariableBinding.isEqualTo(variableBinding)) {
                            elimination.setTypeLocalVariable(formalParameter);
                            break;
                          }
                        }
                      }
                      ITypeBinding invokerType=variableBinding.getType();
                      if (invokerType.getQualifiedName().equals(tree.getRootNode().getUserObject())) {
                        elimination.setExistingInheritanceTree(tree);
                        if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
                          ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
                          typeCheckEliminations.add(elimination);
                        }
 else {
                          ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                          typeCheckEliminations.add(elimination);
                          inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (isValid) {
            staticFieldMap.put(elimination,staticFields);
            int size=staticFields.size();
            if (staticFieldRankMap.containsKey(size)) {
              ArrayList<TypeCheckElimination> rank=staticFieldRankMap.get(size);
              rank.add(elimination);
            }
 else {
              ArrayList<TypeCheckElimination> rank=new ArrayList<TypeCheckElimination>();
              rank.add(elimination);
              staticFieldRankMap.put(size,rank);
            }
          }
        }
      }
 else {
        if (elimination.getTypeField() != null) {
          IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
          ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeFieldTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeLocalVariable() != null) {
          IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
          ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeLocalVariableTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeMethodInvocation() != null) {
          MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
          IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
          if (typeMethodInvocationBinding.getDeclaringClass().getQualifiedName().equals(""String_Node_Str"") && typeMethodInvocationBinding.getName().equals(""String_Node_Str"")) {
            Expression typeMethodInvocationExpression=typeMethodInvocation.getExpression();
            ITypeBinding typeCheckClassBinding=elimination.getTypeCheckClass().resolveBinding();
            ClassObject typeCheckClassObject=getClassObject(typeCheckClassBinding.getQualifiedName());
            SimpleName invoker=null;
            if (typeMethodInvocationExpression instanceof SimpleName) {
              invoker=(SimpleName)typeMethodInvocationExpression;
            }
 else             if (typeMethodInvocationExpression instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)typeMethodInvocationExpression;
              invoker=fieldAccess.getName();
            }
            if (invoker != null) {
              IBinding binding=invoker.resolveBinding();
              if (binding.getKind() == IBinding.VARIABLE) {
                IVariableBinding variableBinding=(IVariableBinding)binding;
                if (variableBinding.isField()) {
                  ListIterator<FieldObject> fieldIterator=typeCheckClassObject.getFieldIterator();
                  while (fieldIterator.hasNext()) {
                    FieldObject fieldObject=fieldIterator.next();
                    VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                    if (variableBinding.isEqualTo(fragment.resolveBinding())) {
                      elimination.setTypeField(fragment);
                      break;
                    }
                  }
                }
 else                 if (variableBinding.isParameter()) {
                  List<SingleVariableDeclaration> parameters=elimination.getTypeCheckMethodParameters();
                  for (                  SingleVariableDeclaration parameter : parameters) {
                    IVariableBinding parameterVariableBinding=parameter.resolveBinding();
                    if (parameterVariableBinding.isEqualTo(variableBinding)) {
                      elimination.setTypeLocalVariable(parameter);
                      break;
                    }
                  }
                }
 else {
                  StatementExtractor statementExtractor=new StatementExtractor();
                  Block typeCheckMethodBody=elimination.getTypeCheckMethod().getBody();
                  List<Statement> variableDeclarationStatements=statementExtractor.getVariableDeclarations(typeCheckMethodBody);
                  for (                  Statement vDStatement : variableDeclarationStatements) {
                    VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
                    List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                      if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                        elimination.setTypeLocalVariable(fragment);
                        break;
                      }
                    }
                  }
                  List<Statement> enhancedForStatements=statementExtractor.getEnhancedForStatements(typeCheckMethodBody);
                  for (                  Statement eFStatement : enhancedForStatements) {
                    EnhancedForStatement enhancedForStatement=(EnhancedForStatement)eFStatement;
                    SingleVariableDeclaration formalParameter=enhancedForStatement.getParameter();
                    IVariableBinding parameterVariableBinding=formalParameter.resolveBinding();
                    if (parameterVariableBinding.isEqualTo(variableBinding)) {
                      elimination.setTypeLocalVariable(formalParameter);
                      break;
                    }
                  }
                }
                ITypeBinding invokerType=variableBinding.getType();
                InheritanceTree tree=inheritanceDetection.getTree(invokerType.getQualifiedName());
                elimination.setExistingInheritanceTree(tree);
              }
            }
          }
 else {
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            InheritanceTree tree=inheritanceDetection.getTree(typeMethodInvocationReturnType.getQualifiedName());
            elimination.setExistingInheritanceTree(tree);
          }
        }
        if (elimination.getExistingInheritanceTree() != null) {
          InheritanceTree tree=elimination.getExistingInheritanceTree();
          if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
            ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
            typeCheckEliminations.add(elimination);
          }
 else {
            ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
            typeCheckEliminations.add(elimination);
            inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
          }
        }
      }
    }
  }
  for (  String rootNode : inheritanceTreeMap.keySet()) {
    ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(rootNode);
    typeCheckEliminationResults.addGroup(typeCheckEliminations);
  }
  List<TypeCheckElimination> sortedEliminations=new ArrayList<TypeCheckElimination>();
  List<Integer> keyList=new ArrayList<Integer>(staticFieldRankMap.keySet());
  ListIterator<Integer> keyListIterator=keyList.listIterator(keyList.size());
  while (keyListIterator.hasPrevious()) {
    Integer states=keyListIterator.previous();
    sortedEliminations.addAll(staticFieldRankMap.get(states));
  }
  while (!sortedEliminations.isEmpty()) {
    TypeCheckElimination selectedElimination=sortedEliminations.get(0);
    List<TypeCheckElimination> affectedEliminations=new ArrayList<TypeCheckElimination>();
    affectedEliminations.add(selectedElimination);
    List<SimpleName> staticFieldUnion=staticFieldMap.get(selectedElimination);
    boolean staticFieldUnionIncreased=true;
    while (staticFieldUnionIncreased) {
      staticFieldUnionIncreased=false;
      for (      TypeCheckElimination elimination : sortedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        if (!affectedEliminations.contains(elimination) && nonEmptyIntersection(staticFieldUnion,staticFields)) {
          staticFieldUnion=constructUnion(staticFieldUnion,staticFields);
          affectedEliminations.add(elimination);
          staticFieldUnionIncreased=true;
        }
      }
    }
    if (affectedEliminations.size() > 1) {
      for (      TypeCheckElimination elimination : affectedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        for (        SimpleName simpleName1 : staticFieldUnion) {
          boolean isContained=false;
          for (          SimpleName simpleName2 : staticFields) {
            if (simpleName1.resolveBinding().isEqualTo(simpleName2.resolveBinding())) {
              isContained=true;
              break;
            }
          }
          if (!isContained)           elimination.addAdditionalStaticField(simpleName1);
        }
      }
    }
    ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
    for (    TypeCheckElimination elimination : affectedEliminations) {
      if (!elimination.isTypeCheckMethodStateSetter())       typeCheckEliminations.add(elimination);
    }
    typeCheckEliminationResults.addGroup(typeCheckEliminations);
    sortedEliminations.removeAll(affectedEliminations);
  }
  identifySuperFieldAccessorMethods(typeCheckEliminationResults.getTypeCheckEliminations());
  return typeCheckEliminationResults;
}","public TypeCheckEliminationResults generateTypeCheckEliminations(){
  TypeCheckEliminationResults typeCheckEliminationResults=new TypeCheckEliminationResults();
  Map<TypeCheckElimination,List<SimpleName>> staticFieldMap=new LinkedHashMap<TypeCheckElimination,List<SimpleName>>();
  Map<Integer,ArrayList<TypeCheckElimination>> staticFieldRankMap=new TreeMap<Integer,ArrayList<TypeCheckElimination>>();
  Map<String,ArrayList<TypeCheckElimination>> inheritanceTreeMap=new LinkedHashMap<String,ArrayList<TypeCheckElimination>>();
  CompleteInheritanceDetection inheritanceDetection=new CompleteInheritanceDetection(this);
  for (  ClassObject classObject : classList) {
    List<TypeCheckElimination> eliminations=classObject.generateTypeCheckEliminations();
    for (    TypeCheckElimination elimination : eliminations) {
      List<SimpleName> staticFields=elimination.getStaticFields();
      if (!staticFields.isEmpty()) {
        if (allStaticFieldsWithinSystemBoundary(staticFields)) {
          inheritanceHierarchyMatchingWithStaticTypes(elimination,inheritanceDetection);
          boolean isValid=false;
          if (elimination.getTypeField() != null) {
            IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
            ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
            if (typeFieldTypeBinding.isPrimitive() || typeFieldTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeLocalVariable() != null) {
            IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
            ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
            if (typeLocalVariableTypeBinding.isPrimitive() || typeLocalVariableTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeMethodInvocation() != null) {
            MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
            IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
            ITypeBinding typeMethodInvocationDeclaringClass=typeMethodInvocationBinding.getDeclaringClass();
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            ClassObject declaringClassObject=getClassObject(typeMethodInvocationDeclaringClass.getQualifiedName());
            if ((typeMethodInvocationReturnType.isPrimitive() || typeMethodInvocationReturnType.isEnum()) && declaringClassObject != null) {
              MethodDeclaration invokedMethodDeclaration=null;
              ListIterator<MethodObject> methodIterator=declaringClassObject.getMethodIterator();
              while (methodIterator.hasNext()) {
                MethodObject methodObject=methodIterator.next();
                MethodDeclaration methodDeclaration=methodObject.getMethodDeclaration();
                if (typeMethodInvocationBinding.isEqualTo(methodDeclaration.resolveBinding())) {
                  invokedMethodDeclaration=methodDeclaration;
                  break;
                }
              }
              SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(invokedMethodDeclaration);
              if (fieldInstruction != null) {
                ListIterator<FieldObject> fieldIterator=declaringClassObject.getFieldIterator();
                while (fieldIterator.hasNext()) {
                  FieldObject fieldObject=fieldIterator.next();
                  VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                  if (fieldInstruction.resolveBinding().isEqualTo(fragment.resolveBinding())) {
                    elimination.setForeignTypeField(fragment);
                    break;
                  }
                }
                isValid=true;
              }
 else               if (invokedMethodDeclaration.getBody() == null) {
                InheritanceTree tree=elimination.getInheritanceTreeMatchingWithStaticTypes();
                ITypeBinding invokerTypeBinding=handleTypeMethodInvocation(typeMethodInvocation,elimination);
                if (invokerTypeBinding != null) {
                  if (tree != null) {
                    if (invokerTypeBinding.getQualifiedName().equals(tree.getRootNode().getUserObject())) {
                      elimination.setExistingInheritanceTree(tree);
                      if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
                        typeCheckEliminations.add(elimination);
                      }
 else {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                        typeCheckEliminations.add(elimination);
                        inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
                      }
                    }
                  }
 else {
                    InheritanceTree tree2=inheritanceDetection.getTree(invokerTypeBinding.getQualifiedName());
                    if (tree2 != null) {
                      elimination.setExistingInheritanceTree(tree2);
                      if (inheritanceTreeMap.containsKey(tree2.getRootNode().getUserObject())) {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree2.getRootNode().getUserObject());
                        typeCheckEliminations.add(elimination);
                      }
 else {
                        ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                        typeCheckEliminations.add(elimination);
                        inheritanceTreeMap.put((String)tree2.getRootNode().getUserObject(),typeCheckEliminations);
                      }
                    }
                  }
                }
              }
            }
          }
          if (isValid) {
            staticFieldMap.put(elimination,staticFields);
            int size=staticFields.size();
            if (staticFieldRankMap.containsKey(size)) {
              ArrayList<TypeCheckElimination> rank=staticFieldRankMap.get(size);
              rank.add(elimination);
            }
 else {
              ArrayList<TypeCheckElimination> rank=new ArrayList<TypeCheckElimination>();
              rank.add(elimination);
              staticFieldRankMap.put(size,rank);
            }
          }
        }
      }
 else {
        if (elimination.getTypeField() != null) {
          IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
          ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeFieldTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeLocalVariable() != null) {
          IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
          ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeLocalVariableTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeMethodInvocation() != null) {
          MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
          IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
          if (typeMethodInvocationBinding.getDeclaringClass().getQualifiedName().equals(""String_Node_Str"") && typeMethodInvocationBinding.getName().equals(""String_Node_Str"")) {
            ITypeBinding invokerTypeBinding=handleTypeMethodInvocation(typeMethodInvocation,elimination);
            if (invokerTypeBinding != null) {
              InheritanceTree tree=inheritanceDetection.getTree(invokerTypeBinding.getQualifiedName());
              elimination.setExistingInheritanceTree(tree);
            }
          }
 else {
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            InheritanceTree tree=inheritanceDetection.getTree(typeMethodInvocationReturnType.getQualifiedName());
            elimination.setExistingInheritanceTree(tree);
          }
        }
        if (elimination.getExistingInheritanceTree() != null) {
          InheritanceTree tree=elimination.getExistingInheritanceTree();
          if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
            ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
            typeCheckEliminations.add(elimination);
          }
 else {
            ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
            typeCheckEliminations.add(elimination);
            inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
          }
        }
      }
    }
  }
  for (  String rootNode : inheritanceTreeMap.keySet()) {
    ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(rootNode);
    typeCheckEliminationResults.addGroup(typeCheckEliminations);
  }
  List<TypeCheckElimination> sortedEliminations=new ArrayList<TypeCheckElimination>();
  List<Integer> keyList=new ArrayList<Integer>(staticFieldRankMap.keySet());
  ListIterator<Integer> keyListIterator=keyList.listIterator(keyList.size());
  while (keyListIterator.hasPrevious()) {
    Integer states=keyListIterator.previous();
    sortedEliminations.addAll(staticFieldRankMap.get(states));
  }
  while (!sortedEliminations.isEmpty()) {
    TypeCheckElimination selectedElimination=sortedEliminations.get(0);
    List<TypeCheckElimination> affectedEliminations=new ArrayList<TypeCheckElimination>();
    affectedEliminations.add(selectedElimination);
    List<SimpleName> staticFieldUnion=staticFieldMap.get(selectedElimination);
    boolean staticFieldUnionIncreased=true;
    while (staticFieldUnionIncreased) {
      staticFieldUnionIncreased=false;
      for (      TypeCheckElimination elimination : sortedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        if (!affectedEliminations.contains(elimination) && nonEmptyIntersection(staticFieldUnion,staticFields)) {
          staticFieldUnion=constructUnion(staticFieldUnion,staticFields);
          affectedEliminations.add(elimination);
          staticFieldUnionIncreased=true;
        }
      }
    }
    if (affectedEliminations.size() > 1) {
      for (      TypeCheckElimination elimination : affectedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        for (        SimpleName simpleName1 : staticFieldUnion) {
          boolean isContained=false;
          for (          SimpleName simpleName2 : staticFields) {
            if (simpleName1.resolveBinding().isEqualTo(simpleName2.resolveBinding())) {
              isContained=true;
              break;
            }
          }
          if (!isContained)           elimination.addAdditionalStaticField(simpleName1);
        }
      }
    }
    ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
    for (    TypeCheckElimination elimination : affectedEliminations) {
      if (!elimination.isTypeCheckMethodStateSetter())       typeCheckEliminations.add(elimination);
    }
    typeCheckEliminationResults.addGroup(typeCheckEliminations);
    sortedEliminations.removeAll(affectedEliminations);
  }
  identifySuperFieldAccessorMethods(typeCheckEliminationResults.getTypeCheckEliminations());
  return typeCheckEliminationResults;
}"
12143,"public LinkedHashSet<VariableDeclaration> getRecursivelyDefinedFields(MethodDeclaration method,Set<MethodDeclaration> processedMethods){
  LinkedHashSet<VariableDeclaration> definedFields=new LinkedHashSet<VariableDeclaration>();
  definedFields.addAll(definedFieldMap.get(method));
  processedMethods.add(method);
  LinkedHashSet<MethodDeclaration> invokedMethods=methodInvocationMap.get(method);
  if (invokedMethods != null) {
    for (    MethodDeclaration invokedMethod : invokedMethods) {
      if (invokedMethod.getBody() != null && !processedMethods.contains(invokedMethod))       definedFields.addAll(getRecursivelyDefinedFields(invokedMethod,processedMethods));
    }
  }
  return definedFields;
}","public LinkedHashSet<VariableDeclaration> getRecursivelyDefinedFields(MethodDeclaration method,Set<MethodDeclaration> processedMethods){
  LinkedHashSet<VariableDeclaration> definedFields=new LinkedHashSet<VariableDeclaration>();
  definedFields.addAll(definedFieldMap.get(method));
  processedMethods.add(method);
  LinkedHashSet<MethodDeclaration> invokedMethods=methodInvocationMap.get(method);
  if (invokedMethods != null) {
    for (    MethodDeclaration invokedMethod : invokedMethods) {
      if (!processedMethods.contains(invokedMethod)) {
        if (invokedMethod.getBody() != null) {
          if ((invokedMethod.getModifiers() & Modifier.NATIVE) != 0) {
          }
 else {
            definedFields.addAll(getRecursivelyDefinedFields(invokedMethod,processedMethods));
          }
        }
 else {
          LinkedHashSet<MethodDeclaration> overridingMethods=overridingMethodMap.get(invokedMethod);
          processedMethods.add(invokedMethod);
          if (overridingMethods != null) {
            for (            MethodDeclaration overridingMethod : overridingMethods) {
              if ((overridingMethod.getModifiers() & Modifier.NATIVE) != 0) {
              }
 else {
                definedFields.addAll(getRecursivelyDefinedFields(overridingMethod,processedMethods));
              }
            }
          }
        }
      }
    }
  }
  return definedFields;
}"
12144,"private LibraryClassStorage(){
  this.compilationUnitMap=new HashMap<IClassFile,CompilationUnit>();
  this.unMatchedClassFiles=new LinkedHashSet<IClassFile>();
  this.methodInvocationMap=new HashMap<MethodDeclaration,LinkedHashSet<MethodDeclaration>>();
  this.definedFieldMap=new HashMap<MethodDeclaration,LinkedHashSet<VariableDeclaration>>();
  this.usedFieldMap=new HashMap<MethodDeclaration,LinkedHashSet<VariableDeclaration>>();
}","private LibraryClassStorage(){
  this.compilationUnitMap=new HashMap<IClassFile,CompilationUnit>();
  this.unMatchedClassFiles=new LinkedHashSet<IClassFile>();
  this.methodInvocationMap=new HashMap<MethodDeclaration,LinkedHashSet<MethodDeclaration>>();
  this.definedFieldMap=new HashMap<MethodDeclaration,LinkedHashSet<VariableDeclaration>>();
  this.usedFieldMap=new HashMap<MethodDeclaration,LinkedHashSet<VariableDeclaration>>();
  this.subTypeMap=new HashMap<IType,LinkedHashSet<IType>>();
  this.overridingMethodMap=new HashMap<MethodDeclaration,LinkedHashSet<MethodDeclaration>>();
}"
12145,"public LinkedHashSet<VariableDeclaration> getRecursivelyUsedFields(MethodDeclaration method,Set<MethodDeclaration> processedMethods){
  LinkedHashSet<VariableDeclaration> usedFields=new LinkedHashSet<VariableDeclaration>();
  usedFields.addAll(usedFieldMap.get(method));
  processedMethods.add(method);
  LinkedHashSet<MethodDeclaration> invokedMethods=methodInvocationMap.get(method);
  if (invokedMethods != null) {
    for (    MethodDeclaration invokedMethod : invokedMethods) {
      if (invokedMethod.getBody() != null && !processedMethods.contains(invokedMethod))       usedFields.addAll(getRecursivelyUsedFields(invokedMethod,processedMethods));
    }
  }
  return usedFields;
}","public LinkedHashSet<VariableDeclaration> getRecursivelyUsedFields(MethodDeclaration method,Set<MethodDeclaration> processedMethods){
  LinkedHashSet<VariableDeclaration> usedFields=new LinkedHashSet<VariableDeclaration>();
  usedFields.addAll(usedFieldMap.get(method));
  processedMethods.add(method);
  LinkedHashSet<MethodDeclaration> invokedMethods=methodInvocationMap.get(method);
  if (invokedMethods != null) {
    for (    MethodDeclaration invokedMethod : invokedMethods) {
      if (!processedMethods.contains(invokedMethod)) {
        if (invokedMethod.getBody() != null) {
          if ((invokedMethod.getModifiers() & Modifier.NATIVE) != 0) {
          }
 else {
            usedFields.addAll(getRecursivelyUsedFields(invokedMethod,processedMethods));
          }
        }
 else {
          LinkedHashSet<MethodDeclaration> overridingMethods=overridingMethodMap.get(invokedMethod);
          processedMethods.add(invokedMethod);
          if (overridingMethods != null) {
            for (            MethodDeclaration overridingMethod : overridingMethods) {
              if ((overridingMethod.getModifiers() & Modifier.NATIVE) != 0) {
              }
 else {
                usedFields.addAll(getRecursivelyUsedFields(overridingMethod,processedMethods));
              }
            }
          }
        }
      }
    }
  }
  return usedFields;
}"
12146,"protected AbstractVariable processFieldInstruction(SimpleName fieldInstructionName,VariableDeclaration parameterDeclaration,AbstractVariable previousVariable){
  VariableDeclaration variableDeclaration=null;
  IBinding binding=fieldInstructionName.resolveBinding();
  if (binding.getKind() == IBinding.VARIABLE) {
    IVariableBinding variableBinding=(IVariableBinding)binding;
    if (variableBinding.isField()) {
      ITypeBinding declaringClassBinding=variableBinding.getDeclaringClass();
      SystemObject systemObject=ASTReader.getSystemObject();
      ClassObject classObject=systemObject.getClassObject(declaringClassBinding.getQualifiedName());
      if (classObject != null) {
        ListIterator<FieldObject> fieldIterator=classObject.getFieldIterator();
        while (fieldIterator.hasNext()) {
          FieldObject fieldObject=fieldIterator.next();
          VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
          if (fragment.resolveBinding().isEqualTo(variableBinding)) {
            variableDeclaration=fragment;
            break;
          }
        }
      }
    }
 else     if (variableBinding.isParameter()) {
      if (parameterDeclaration != null && parameterDeclaration.resolveBinding().isEqualTo(variableBinding))       variableDeclaration=parameterDeclaration;
    }
 else {
      for (      VariableDeclaration declaration : variableDeclarationsInMethod) {
        if (declaration.resolveBinding().isEqualTo(variableBinding)) {
          variableDeclaration=declaration;
          break;
        }
      }
    }
  }
  if (variableDeclaration != null) {
    AbstractVariable currentVariable=null;
    if (previousVariable == null)     currentVariable=new PlainVariable(variableDeclaration);
 else     currentVariable=new CompositeVariable(variableDeclaration,previousVariable);
    if (fieldInstructionName.getParent() instanceof QualifiedName) {
      QualifiedName qualifiedName=(QualifiedName)fieldInstructionName.getParent();
      Name qualifier=qualifiedName.getQualifier();
      if (qualifier instanceof SimpleName) {
        SimpleName qualifierSimpleName=(SimpleName)qualifier;
        if (!qualifierSimpleName.equals(fieldInstructionName))         return processFieldInstruction(qualifierSimpleName,parameterDeclaration,currentVariable);
 else         return currentVariable;
      }
 else       if (qualifier instanceof QualifiedName) {
        QualifiedName qualifiedName2=(QualifiedName)qualifier;
        return processFieldInstruction(qualifiedName2.getName(),parameterDeclaration,currentVariable);
      }
    }
 else     if (fieldInstructionName.getParent() instanceof FieldAccess) {
      FieldAccess fieldAccess=(FieldAccess)fieldInstructionName.getParent();
      Expression fieldAccessExpression=fieldAccess.getExpression();
      if (fieldAccessExpression instanceof FieldAccess) {
        FieldAccess fieldAccess2=(FieldAccess)fieldAccessExpression;
        return processFieldInstruction(fieldAccess2.getName(),parameterDeclaration,currentVariable);
      }
 else       if (fieldAccessExpression instanceof ThisExpression) {
        return currentVariable;
      }
    }
 else {
      return currentVariable;
    }
  }
  return null;
}","protected AbstractVariable processFieldInstruction(SimpleName fieldInstructionName,VariableDeclaration parameterDeclaration,AbstractVariable previousVariable){
  VariableDeclaration variableDeclaration=null;
  IBinding binding=fieldInstructionName.resolveBinding();
  if (binding.getKind() == IBinding.VARIABLE) {
    IVariableBinding variableBinding=(IVariableBinding)binding;
    if (variableBinding.isField()) {
      ITypeBinding declaringClassBinding=variableBinding.getDeclaringClass();
      SystemObject systemObject=ASTReader.getSystemObject();
      ClassObject classObject=systemObject.getClassObject(declaringClassBinding.getQualifiedName());
      if (classObject != null) {
        ListIterator<FieldObject> fieldIterator=classObject.getFieldIterator();
        while (fieldIterator.hasNext()) {
          FieldObject fieldObject=fieldIterator.next();
          VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
          if (fragment.resolveBinding().isEqualTo(variableBinding)) {
            variableDeclaration=fragment;
            break;
          }
        }
      }
    }
 else     if (variableBinding.isParameter() && parameterDeclaration != null) {
      if (parameterDeclaration.resolveBinding().isEqualTo(variableBinding))       variableDeclaration=parameterDeclaration;
    }
 else {
      for (      VariableDeclaration declaration : variableDeclarationsInMethod) {
        if (declaration.resolveBinding().isEqualTo(variableBinding)) {
          variableDeclaration=declaration;
          break;
        }
      }
    }
  }
  if (variableDeclaration != null) {
    AbstractVariable currentVariable=null;
    if (previousVariable == null)     currentVariable=new PlainVariable(variableDeclaration);
 else     currentVariable=new CompositeVariable(variableDeclaration,previousVariable);
    if (fieldInstructionName.getParent() instanceof QualifiedName) {
      QualifiedName qualifiedName=(QualifiedName)fieldInstructionName.getParent();
      Name qualifier=qualifiedName.getQualifier();
      if (qualifier instanceof SimpleName) {
        SimpleName qualifierSimpleName=(SimpleName)qualifier;
        if (!qualifierSimpleName.equals(fieldInstructionName))         return processFieldInstruction(qualifierSimpleName,parameterDeclaration,currentVariable);
 else         return currentVariable;
      }
 else       if (qualifier instanceof QualifiedName) {
        QualifiedName qualifiedName2=(QualifiedName)qualifier;
        return processFieldInstruction(qualifiedName2.getName(),parameterDeclaration,currentVariable);
      }
    }
 else     if (fieldInstructionName.getParent() instanceof FieldAccess) {
      FieldAccess fieldAccess=(FieldAccess)fieldInstructionName.getParent();
      Expression fieldAccessExpression=fieldAccess.getExpression();
      if (fieldAccessExpression instanceof FieldAccess) {
        FieldAccess fieldAccess2=(FieldAccess)fieldAccessExpression;
        return processFieldInstruction(fieldAccess2.getName(),parameterDeclaration,currentVariable);
      }
 else       if (fieldAccessExpression instanceof ThisExpression) {
        return currentVariable;
      }
    }
 else {
      return currentVariable;
    }
  }
  return null;
}"
12147,"private void addRequiredTargetImportDeclarations(){
  List<ITypeBinding> typeBindings=new ArrayList<ITypeBinding>();
  Type returnType=sourceMethod.getReturnType2();
  ITypeBinding returnTypeBinding=returnType.resolveBinding();
  if (!typeBindings.contains(returnTypeBinding))   typeBindings.add(returnTypeBinding);
  List<SingleVariableDeclaration> parameters=sourceMethod.parameters();
  for (  SingleVariableDeclaration parameter : parameters) {
    Type parameterType=parameter.getType();
    ITypeBinding parameterTypeBinding=parameterType.resolveBinding();
    if (!typeBindings.contains(parameterTypeBinding))     typeBindings.add(parameterTypeBinding);
  }
  List<Name> thrownExceptions=sourceMethod.thrownExceptions();
  for (  Name name : thrownExceptions) {
    IBinding binding=name.resolveBinding();
    if (binding.getKind() == IBinding.TYPE) {
      ITypeBinding typeBinding=(ITypeBinding)binding;
      if (!typeBindings.contains(typeBinding))       typeBindings.add(typeBinding);
    }
  }
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(sourceMethod.getBody());
  for (  Expression variableInstruction : variableInstructions) {
    SimpleName simpleName=(SimpleName)variableInstruction;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      ITypeBinding variableTypeBinding=variableBinding.getType();
      if (!typeBindings.contains(variableTypeBinding))       typeBindings.add(variableTypeBinding);
      ITypeBinding declaringClassTypeBinding=variableBinding.getDeclaringClass();
      if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))       typeBindings.add(declaringClassTypeBinding);
    }
  }
  List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(sourceMethod.getBody());
  for (  Expression expression : methodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      if (!additionalMethodsToBeMoved.keySet().contains(methodInvocation)) {
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        ITypeBinding declaringClassTypeBinding=methodBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
        ITypeBinding superclassTypeBinding=sourceTypeDeclaration.resolveBinding().getSuperclass();
        while (superclassTypeBinding != null && !superclassTypeBinding.isEqualTo(methodBinding.getDeclaringClass())) {
          superclassTypeBinding=superclassTypeBinding.getSuperclass();
        }
        if (methodBinding.getDeclaringClass().isEqualTo(superclassTypeBinding) && !typeBindings.contains(sourceTypeDeclaration.resolveBinding()))         typeBindings.add(sourceTypeDeclaration.resolveBinding());
      }
    }
  }
  List<Expression> classInstanceCreations=expressionExtractor.getClassInstanceCreations(sourceMethod.getBody());
  for (  Expression expression : classInstanceCreations) {
    ClassInstanceCreation classInstanceCreation=(ClassInstanceCreation)expression;
    Type classInstanceCreationType=classInstanceCreation.getType();
    ITypeBinding classInstanceCreationTypeBinding=classInstanceCreationType.resolveBinding();
    if (!typeBindings.contains(classInstanceCreationTypeBinding))     typeBindings.add(classInstanceCreationTypeBinding);
  }
  List<Expression> typeLiterals=expressionExtractor.getTypeLiterals(sourceMethod.getBody());
  for (  Expression expression : typeLiterals) {
    TypeLiteral typeLiteral=(TypeLiteral)expression;
    Type typeLiteralType=typeLiteral.getType();
    ITypeBinding typeLiteralTypeBinding=typeLiteralType.resolveBinding();
    if (!typeBindings.contains(typeLiteralTypeBinding))     typeBindings.add(typeLiteralTypeBinding);
  }
  List<Expression> castExpressions=expressionExtractor.getCastExpressions(sourceMethod.getBody());
  for (  Expression expression : castExpressions) {
    CastExpression castExpression=(CastExpression)expression;
    Type castExpressionType=castExpression.getType();
    ITypeBinding typeLiteralTypeBinding=castExpressionType.resolveBinding();
    if (!typeBindings.contains(typeLiteralTypeBinding))     typeBindings.add(typeLiteralTypeBinding);
  }
  getSimpleTypeBindings(typeBindings);
  for (  ITypeBinding typeBinding : requiredTargetImportDeclarationSet)   addImportDeclaration(typeBinding);
}","private void addRequiredTargetImportDeclarations(){
  List<ITypeBinding> typeBindings=new ArrayList<ITypeBinding>();
  Type returnType=sourceMethod.getReturnType2();
  ITypeBinding returnTypeBinding=returnType.resolveBinding();
  if (!typeBindings.contains(returnTypeBinding))   typeBindings.add(returnTypeBinding);
  List<SingleVariableDeclaration> parameters=sourceMethod.parameters();
  for (  SingleVariableDeclaration parameter : parameters) {
    Type parameterType=parameter.getType();
    ITypeBinding parameterTypeBinding=parameterType.resolveBinding();
    if (!typeBindings.contains(parameterTypeBinding))     typeBindings.add(parameterTypeBinding);
  }
  List<Name> thrownExceptions=sourceMethod.thrownExceptions();
  for (  Name name : thrownExceptions) {
    IBinding binding=name.resolveBinding();
    if (binding.getKind() == IBinding.TYPE) {
      ITypeBinding typeBinding=(ITypeBinding)binding;
      if (!typeBindings.contains(typeBinding))       typeBindings.add(typeBinding);
    }
  }
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(sourceMethod.getBody());
  for (  Expression variableInstruction : variableInstructions) {
    SimpleName simpleName=(SimpleName)variableInstruction;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      ITypeBinding variableTypeBinding=variableBinding.getType();
      if (!typeBindings.contains(variableTypeBinding))       typeBindings.add(variableTypeBinding);
      ITypeBinding declaringClassTypeBinding=variableBinding.getDeclaringClass();
      if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))       typeBindings.add(declaringClassTypeBinding);
    }
  }
  List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(sourceMethod.getBody());
  for (  Expression expression : methodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      if (!additionalMethodsToBeMoved.keySet().contains(methodInvocation)) {
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        ITypeBinding declaringClassTypeBinding=methodBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
        ITypeBinding superclassTypeBinding=sourceTypeDeclaration.resolveBinding().getSuperclass();
        while (superclassTypeBinding != null && !superclassTypeBinding.isEqualTo(methodBinding.getDeclaringClass())) {
          superclassTypeBinding=superclassTypeBinding.getSuperclass();
        }
        if (methodBinding.getDeclaringClass().isEqualTo(superclassTypeBinding) && !typeBindings.contains(sourceTypeDeclaration.resolveBinding()))         typeBindings.add(sourceTypeDeclaration.resolveBinding());
      }
    }
  }
  List<Expression> classInstanceCreations=expressionExtractor.getClassInstanceCreations(sourceMethod.getBody());
  for (  Expression expression : classInstanceCreations) {
    ClassInstanceCreation classInstanceCreation=(ClassInstanceCreation)expression;
    Type classInstanceCreationType=classInstanceCreation.getType();
    ITypeBinding classInstanceCreationTypeBinding=classInstanceCreationType.resolveBinding();
    if (!typeBindings.contains(classInstanceCreationTypeBinding))     typeBindings.add(classInstanceCreationTypeBinding);
  }
  List<Expression> typeLiterals=expressionExtractor.getTypeLiterals(sourceMethod.getBody());
  for (  Expression expression : typeLiterals) {
    TypeLiteral typeLiteral=(TypeLiteral)expression;
    Type typeLiteralType=typeLiteral.getType();
    ITypeBinding typeLiteralTypeBinding=typeLiteralType.resolveBinding();
    if (!typeBindings.contains(typeLiteralTypeBinding))     typeBindings.add(typeLiteralTypeBinding);
  }
  List<Expression> castExpressions=expressionExtractor.getCastExpressions(sourceMethod.getBody());
  for (  Expression expression : castExpressions) {
    CastExpression castExpression=(CastExpression)expression;
    Type castExpressionType=castExpression.getType();
    ITypeBinding castExpressionTypeBinding=castExpressionType.resolveBinding();
    if (!typeBindings.contains(castExpressionTypeBinding))     typeBindings.add(castExpressionTypeBinding);
  }
  List<Expression> instanceofExpressions=expressionExtractor.getInstanceofExpressions(sourceMethod.getBody());
  for (  Expression expression : instanceofExpressions) {
    InstanceofExpression instanceofExpression=(InstanceofExpression)expression;
    Type instanceofType=instanceofExpression.getRightOperand();
    ITypeBinding instanceofTypeBinding=instanceofType.resolveBinding();
    if (!typeBindings.contains(instanceofTypeBinding))     typeBindings.add(instanceofTypeBinding);
  }
  getSimpleTypeBindings(typeBindings);
  for (  ITypeBinding typeBinding : requiredTargetImportDeclarationSet)   addImportDeclaration(typeBinding);
}"
12148,"private Set<ITypeBinding> generateRequiredImportDeclarationsBasedOnBranch(ArrayList<Statement> statements){
  List<ITypeBinding> typeBindings=new ArrayList<ITypeBinding>();
  for (  Statement statement : statements) {
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(statement);
    for (    Expression variableInstruction : variableInstructions) {
      SimpleName simpleName=(SimpleName)variableInstruction;
      IBinding binding=simpleName.resolveBinding();
      if (binding.getKind() == IBinding.VARIABLE) {
        IVariableBinding variableBinding=(IVariableBinding)binding;
        ITypeBinding variableTypeBinding=variableBinding.getType();
        if (!typeBindings.contains(variableTypeBinding))         typeBindings.add(variableTypeBinding);
        ITypeBinding declaringClassTypeBinding=variableBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
      }
    }
    List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
    for (    Expression expression : methodInvocations) {
      if (expression instanceof MethodInvocation) {
        MethodInvocation methodInvocation=(MethodInvocation)expression;
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        ITypeBinding declaringClassTypeBinding=methodBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
      }
    }
    List<Expression> classInstanceCreations=expressionExtractor.getClassInstanceCreations(statement);
    for (    Expression expression : classInstanceCreations) {
      ClassInstanceCreation classInstanceCreation=(ClassInstanceCreation)expression;
      Type classInstanceCreationType=classInstanceCreation.getType();
      ITypeBinding classInstanceCreationTypeBinding=classInstanceCreationType.resolveBinding();
      if (!typeBindings.contains(classInstanceCreationTypeBinding))       typeBindings.add(classInstanceCreationTypeBinding);
    }
    List<Expression> typeLiterals=expressionExtractor.getTypeLiterals(statement);
    for (    Expression expression : typeLiterals) {
      TypeLiteral typeLiteral=(TypeLiteral)expression;
      Type typeLiteralType=typeLiteral.getType();
      ITypeBinding typeLiteralTypeBinding=typeLiteralType.resolveBinding();
      if (!typeBindings.contains(typeLiteralTypeBinding))       typeBindings.add(typeLiteralTypeBinding);
    }
    List<Expression> castExpressions=expressionExtractor.getCastExpressions(statement);
    for (    Expression expression : castExpressions) {
      CastExpression castExpression=(CastExpression)expression;
      Type castExpressionType=castExpression.getType();
      ITypeBinding typeLiteralTypeBinding=castExpressionType.resolveBinding();
      if (!typeBindings.contains(typeLiteralTypeBinding))       typeBindings.add(typeLiteralTypeBinding);
    }
  }
  Set<ITypeBinding> finalTypeBindings=new LinkedHashSet<ITypeBinding>();
  getSimpleTypeBindings(typeBindings,finalTypeBindings);
  return finalTypeBindings;
}","private Set<ITypeBinding> generateRequiredImportDeclarationsBasedOnBranch(ArrayList<Statement> statements){
  List<ITypeBinding> typeBindings=new ArrayList<ITypeBinding>();
  for (  Statement statement : statements) {
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(statement);
    for (    Expression variableInstruction : variableInstructions) {
      SimpleName simpleName=(SimpleName)variableInstruction;
      IBinding binding=simpleName.resolveBinding();
      if (binding.getKind() == IBinding.VARIABLE) {
        IVariableBinding variableBinding=(IVariableBinding)binding;
        ITypeBinding variableTypeBinding=variableBinding.getType();
        if (!typeBindings.contains(variableTypeBinding))         typeBindings.add(variableTypeBinding);
        ITypeBinding declaringClassTypeBinding=variableBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
      }
    }
    List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
    for (    Expression expression : methodInvocations) {
      if (expression instanceof MethodInvocation) {
        MethodInvocation methodInvocation=(MethodInvocation)expression;
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        ITypeBinding declaringClassTypeBinding=methodBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
      }
    }
    List<Expression> classInstanceCreations=expressionExtractor.getClassInstanceCreations(statement);
    for (    Expression expression : classInstanceCreations) {
      ClassInstanceCreation classInstanceCreation=(ClassInstanceCreation)expression;
      Type classInstanceCreationType=classInstanceCreation.getType();
      ITypeBinding classInstanceCreationTypeBinding=classInstanceCreationType.resolveBinding();
      if (!typeBindings.contains(classInstanceCreationTypeBinding))       typeBindings.add(classInstanceCreationTypeBinding);
    }
    List<Expression> typeLiterals=expressionExtractor.getTypeLiterals(statement);
    for (    Expression expression : typeLiterals) {
      TypeLiteral typeLiteral=(TypeLiteral)expression;
      Type typeLiteralType=typeLiteral.getType();
      ITypeBinding typeLiteralTypeBinding=typeLiteralType.resolveBinding();
      if (!typeBindings.contains(typeLiteralTypeBinding))       typeBindings.add(typeLiteralTypeBinding);
    }
    List<Expression> castExpressions=expressionExtractor.getCastExpressions(statement);
    for (    Expression expression : castExpressions) {
      CastExpression castExpression=(CastExpression)expression;
      Type castExpressionType=castExpression.getType();
      ITypeBinding castExpressionTypeBinding=castExpressionType.resolveBinding();
      if (!typeBindings.contains(castExpressionTypeBinding))       typeBindings.add(castExpressionTypeBinding);
    }
    List<Expression> instanceofExpressions=expressionExtractor.getInstanceofExpressions(statement);
    for (    Expression expression : instanceofExpressions) {
      InstanceofExpression instanceofExpression=(InstanceofExpression)expression;
      Type instanceofType=instanceofExpression.getRightOperand();
      ITypeBinding instanceofTypeBinding=instanceofType.resolveBinding();
      if (!typeBindings.contains(instanceofTypeBinding))       typeBindings.add(instanceofTypeBinding);
    }
  }
  Set<ITypeBinding> finalTypeBindings=new LinkedHashSet<ITypeBinding>();
  getSimpleTypeBindings(typeBindings,finalTypeBindings);
  return finalTypeBindings;
}"
12149,"private Set<ITypeBinding> generateRequiredImportDeclarationsBasedOnBranch(ArrayList<Statement> statements){
  List<ITypeBinding> typeBindings=new ArrayList<ITypeBinding>();
  for (  Statement statement : statements) {
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(statement);
    for (    Expression variableInstruction : variableInstructions) {
      SimpleName simpleName=(SimpleName)variableInstruction;
      IBinding binding=simpleName.resolveBinding();
      if (binding.getKind() == IBinding.VARIABLE) {
        IVariableBinding variableBinding=(IVariableBinding)binding;
        ITypeBinding variableTypeBinding=variableBinding.getType();
        if (!typeBindings.contains(variableTypeBinding))         typeBindings.add(variableTypeBinding);
        ITypeBinding declaringClassTypeBinding=variableBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
      }
    }
    List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
    for (    Expression expression : methodInvocations) {
      if (expression instanceof MethodInvocation) {
        MethodInvocation methodInvocation=(MethodInvocation)expression;
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        ITypeBinding declaringClassTypeBinding=methodBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
      }
    }
    List<Expression> classInstanceCreations=expressionExtractor.getClassInstanceCreations(statement);
    for (    Expression expression : classInstanceCreations) {
      ClassInstanceCreation classInstanceCreation=(ClassInstanceCreation)expression;
      Type classInstanceCreationType=classInstanceCreation.getType();
      ITypeBinding classInstanceCreationTypeBinding=classInstanceCreationType.resolveBinding();
      if (!typeBindings.contains(classInstanceCreationTypeBinding))       typeBindings.add(classInstanceCreationTypeBinding);
    }
    List<Expression> typeLiterals=expressionExtractor.getTypeLiterals(statement);
    for (    Expression expression : typeLiterals) {
      TypeLiteral typeLiteral=(TypeLiteral)expression;
      Type typeLiteralType=typeLiteral.getType();
      ITypeBinding typeLiteralTypeBinding=typeLiteralType.resolveBinding();
      if (!typeBindings.contains(typeLiteralTypeBinding))       typeBindings.add(typeLiteralTypeBinding);
    }
    List<Expression> castExpressions=expressionExtractor.getCastExpressions(statement);
    for (    Expression expression : castExpressions) {
      CastExpression castExpression=(CastExpression)expression;
      Type castExpressionType=castExpression.getType();
      ITypeBinding typeLiteralTypeBinding=castExpressionType.resolveBinding();
      if (!typeBindings.contains(typeLiteralTypeBinding))       typeBindings.add(typeLiteralTypeBinding);
    }
  }
  Set<ITypeBinding> finalTypeBindings=new LinkedHashSet<ITypeBinding>();
  getSimpleTypeBindings(typeBindings,finalTypeBindings);
  return finalTypeBindings;
}","private Set<ITypeBinding> generateRequiredImportDeclarationsBasedOnBranch(ArrayList<Statement> statements){
  List<ITypeBinding> typeBindings=new ArrayList<ITypeBinding>();
  for (  Statement statement : statements) {
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(statement);
    for (    Expression variableInstruction : variableInstructions) {
      SimpleName simpleName=(SimpleName)variableInstruction;
      IBinding binding=simpleName.resolveBinding();
      if (binding.getKind() == IBinding.VARIABLE) {
        IVariableBinding variableBinding=(IVariableBinding)binding;
        ITypeBinding variableTypeBinding=variableBinding.getType();
        if (!typeBindings.contains(variableTypeBinding))         typeBindings.add(variableTypeBinding);
        ITypeBinding declaringClassTypeBinding=variableBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
      }
    }
    List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
    for (    Expression expression : methodInvocations) {
      if (expression instanceof MethodInvocation) {
        MethodInvocation methodInvocation=(MethodInvocation)expression;
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        ITypeBinding declaringClassTypeBinding=methodBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
      }
    }
    List<Expression> classInstanceCreations=expressionExtractor.getClassInstanceCreations(statement);
    for (    Expression expression : classInstanceCreations) {
      ClassInstanceCreation classInstanceCreation=(ClassInstanceCreation)expression;
      Type classInstanceCreationType=classInstanceCreation.getType();
      ITypeBinding classInstanceCreationTypeBinding=classInstanceCreationType.resolveBinding();
      if (!typeBindings.contains(classInstanceCreationTypeBinding))       typeBindings.add(classInstanceCreationTypeBinding);
    }
    List<Expression> typeLiterals=expressionExtractor.getTypeLiterals(statement);
    for (    Expression expression : typeLiterals) {
      TypeLiteral typeLiteral=(TypeLiteral)expression;
      Type typeLiteralType=typeLiteral.getType();
      ITypeBinding typeLiteralTypeBinding=typeLiteralType.resolveBinding();
      if (!typeBindings.contains(typeLiteralTypeBinding))       typeBindings.add(typeLiteralTypeBinding);
    }
    List<Expression> castExpressions=expressionExtractor.getCastExpressions(statement);
    for (    Expression expression : castExpressions) {
      CastExpression castExpression=(CastExpression)expression;
      Type castExpressionType=castExpression.getType();
      ITypeBinding castExpressionTypeBinding=castExpressionType.resolveBinding();
      if (!typeBindings.contains(castExpressionTypeBinding))       typeBindings.add(castExpressionTypeBinding);
    }
    List<Expression> instanceofExpressions=expressionExtractor.getInstanceofExpressions(statement);
    for (    Expression expression : instanceofExpressions) {
      InstanceofExpression instanceofExpression=(InstanceofExpression)expression;
      Type instanceofType=instanceofExpression.getRightOperand();
      ITypeBinding instanceofTypeBinding=instanceofType.resolveBinding();
      if (!typeBindings.contains(instanceofTypeBinding))       typeBindings.add(instanceofTypeBinding);
    }
  }
  Set<ITypeBinding> finalTypeBindings=new LinkedHashSet<ITypeBinding>();
  getSimpleTypeBindings(typeBindings,finalTypeBindings);
  return finalTypeBindings;
}"
12150,"public Set<PDGNode> getRemovableNodes(){
  Set<PDGNode> removableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGSlice slice : slices) {
    removableNodes.addAll(slice.getRemovableNodes());
  }
  return removableNodes;
}","public Set<PDGNode> getRemovableNodes(){
  Set<PDGNode> removableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGSlice slice : slices) {
    removableNodes.addAll(slice.getRemovableNodes());
  }
  Set<PDGNode> sliceNodes=getSliceNodes();
  List<PDGNode> sliceNodesInReverseOrder=new ArrayList<PDGNode>(sliceNodes);
  Collections.reverse(sliceNodesInReverseOrder);
  for (  PDGNode sliceNode : sliceNodesInReverseOrder) {
    if (sliceNode.getCFGNode() instanceof CFGBranchConditionalNode) {
      int numberOfControlDependentNodes=0;
      int numberOfRemovableControlDependentNodes=0;
      for (      GraphEdge edge : sliceNode.outgoingEdges) {
        PDGDependence dependence=(PDGDependence)edge;
        if (dependence instanceof PDGControlDependence) {
          PDGNode dstPDGNode=(PDGNode)dependence.dst;
          numberOfControlDependentNodes++;
          if (removableNodes.contains(dstPDGNode))           numberOfRemovableControlDependentNodes++;
        }
      }
      if (numberOfControlDependentNodes == numberOfRemovableControlDependentNodes)       removableNodes.add(sliceNode);
    }
  }
  return removableNodes;
}"
12151,"private List<CFGNode> process(List<CFGNode> previousNodes,CompositeStatementObject composite){
  int i=0;
  for (  AbstractStatement abstractStatement : composite.getStatements()) {
    if (abstractStatement instanceof StatementObject) {
      StatementObject statement=(StatementObject)abstractStatement;
      previousNodes=processNonCompositeStatement(previousNodes,statement);
    }
 else     if (abstractStatement instanceof CompositeStatementObject) {
      CompositeStatementObject compositeStatement=(CompositeStatementObject)abstractStatement;
      if (compositeStatement.getStatement() instanceof Block) {
        previousNodes=process(previousNodes,compositeStatement);
      }
 else       if (compositeStatement.getStatement() instanceof TryStatement) {
        AbstractStatement firstStatement=compositeStatement.getStatements().get(0);
        if (firstStatement instanceof StatementObject) {
          previousNodes=processNonCompositeStatement(previousNodes,(StatementObject)firstStatement);
        }
 else         if (firstStatement instanceof CompositeStatementObject) {
          previousNodes=process(previousNodes,(CompositeStatementObject)firstStatement);
        }
      }
 else       if (isLoop(compositeStatement)) {
        CFGBranchNode currentNode=new CFGBranchLoopNode(compositeStatement);
        nodes.add(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        previousNodes=new ArrayList<CFGNode>();
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes.addAll(process(currentNodes,compositeStatement));
        for (        CFGNode previousNode : previousNodes) {
          Flow flow=new Flow(previousNode,currentNode);
          if (previousNode instanceof CFGBranchNode) {
            flow.setFalseControlFlow(true);
          }
          flow.setLoopbackFlow(true);
          edges.add(flow);
        }
        if (previousNodes.size() > 1) {
          List<CFGBranchConditionalNode> conditionalNodes=unjoinedConditionalNodes.pop();
          for (          CFGBranchConditionalNode conditionalNode : conditionalNodes) {
            conditionalNode.setJoinNode(currentNode);
          }
        }
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof DoStatement) {
        List<CFGNode> tmpNodes=previousNodes;
        previousNodes=process(previousNodes,compositeStatement);
        CFGBranchNode currentNode=new CFGBranchDoLoopNode(compositeStatement);
        nodes.add(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        CFGNode topNode=getCommonNextNode(tmpNodes);
        Flow flow=new Flow(currentNode,topNode);
        flow.setTrueControlFlow(true);
        flow.setLoopbackFlow(true);
        edges.add(flow);
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof IfStatement) {
        int action=PUSH_NEW_LIST;
        List<AbstractStatement> statements=composite.getStatements();
        CompositeStatementObject parent=statements.get(0).getParent();
        if (parent.getStatement() instanceof Block)         parent=parent.getParent();
        if (statements.size() == 1) {
          action=JOIN_TOP_LIST;
          if (parent != null) {
            if (isLoop(parent))             action=PUSH_NEW_LIST;
 else             if (parent.getStatement() instanceof DoStatement)             action=PLACE_NEW_LIST_SECOND_FROM_TOP;
          }
        }
 else         if (statements.size() > 1) {
          AbstractStatement previousStatement=null;
          if (i >= 1)           previousStatement=statements.get(i - 1);
          if (statements.get(statements.size() - 1).equals(compositeStatement)) {
            if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement) {
              action=JOIN_SECOND_FROM_TOP_LIST;
              if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))               action=PLACE_NEW_LIST_SECOND_FROM_TOP;
            }
 else {
              action=JOIN_TOP_LIST;
              if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))               action=PUSH_NEW_LIST;
            }
          }
 else {
            if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement)             action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else {
              action=PUSH_NEW_LIST;
              if (parent != null && parent.getStatement() instanceof DoStatement && statements.get(0).getStatement() instanceof IfStatement)               action=PLACE_NEW_LIST_SECOND_FROM_TOP;
            }
          }
        }
        previousNodes=processIfStatement(previousNodes,compositeStatement,action);
      }
    }
    i++;
  }
  return previousNodes;
}","private List<CFGNode> process(List<CFGNode> previousNodes,CompositeStatementObject composite){
  int i=0;
  for (  AbstractStatement abstractStatement : composite.getStatements()) {
    if (abstractStatement instanceof StatementObject) {
      StatementObject statement=(StatementObject)abstractStatement;
      previousNodes=processNonCompositeStatement(previousNodes,statement);
    }
 else     if (abstractStatement instanceof CompositeStatementObject) {
      CompositeStatementObject compositeStatement=(CompositeStatementObject)abstractStatement;
      if (compositeStatement.getStatement() instanceof Block) {
        previousNodes=process(previousNodes,compositeStatement);
      }
 else       if (compositeStatement.getStatement() instanceof TryStatement) {
        AbstractStatement firstStatement=compositeStatement.getStatements().get(0);
        if (firstStatement instanceof CompositeStatementObject) {
          previousNodes=process(previousNodes,(CompositeStatementObject)firstStatement);
        }
      }
 else       if (isLoop(compositeStatement)) {
        CFGBranchNode currentNode=new CFGBranchLoopNode(compositeStatement);
        nodes.add(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        previousNodes=new ArrayList<CFGNode>();
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes.addAll(process(currentNodes,compositeStatement));
        for (        CFGNode previousNode : previousNodes) {
          Flow flow=new Flow(previousNode,currentNode);
          if (previousNode instanceof CFGBranchNode) {
            flow.setFalseControlFlow(true);
          }
          flow.setLoopbackFlow(true);
          edges.add(flow);
        }
        if (previousNodes.size() > 1) {
          List<CFGBranchConditionalNode> conditionalNodes=unjoinedConditionalNodes.pop();
          for (          CFGBranchConditionalNode conditionalNode : conditionalNodes) {
            conditionalNode.setJoinNode(currentNode);
          }
        }
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof DoStatement) {
        List<CFGNode> tmpNodes=previousNodes;
        previousNodes=process(previousNodes,compositeStatement);
        CFGBranchNode currentNode=new CFGBranchDoLoopNode(compositeStatement);
        nodes.add(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        CFGNode topNode=getCommonNextNode(tmpNodes);
        Flow flow=new Flow(currentNode,topNode);
        flow.setTrueControlFlow(true);
        flow.setLoopbackFlow(true);
        edges.add(flow);
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof IfStatement) {
        int action=PUSH_NEW_LIST;
        List<AbstractStatement> statements=new ArrayList<AbstractStatement>(composite.getStatements());
        CompositeStatementObject parent=statements.get(0).getParent();
        if (parent.getStatement() instanceof Block)         parent=parent.getParent();
        int position=i;
        if (parent != null && parent.getStatement() instanceof TryStatement) {
          CompositeStatementObject tryStatement=parent;
          CompositeStatementObject tryStatementParent=tryStatement.getParent();
          List<AbstractStatement> tryParentStatements=new ArrayList<AbstractStatement>(tryStatementParent.getStatements());
          if (tryStatementParent.getStatement() instanceof Block)           tryStatementParent=tryStatementParent.getParent();
          int positionOfTryStatementInParent=0;
          int j=0;
          for (          AbstractStatement statement : tryParentStatements) {
            if (statement.equals(tryStatement)) {
              positionOfTryStatementInParent=j;
              break;
            }
            j++;
          }
          tryParentStatements.remove(tryStatement);
          tryParentStatements.addAll(positionOfTryStatementInParent,statements);
          statements=tryParentStatements;
          parent=tryStatementParent;
          position=positionOfTryStatementInParent + i;
        }
        if (statements.size() == 1) {
          action=JOIN_TOP_LIST;
          if (parent != null) {
            if (isLoop(parent))             action=PUSH_NEW_LIST;
 else             if (parent.getStatement() instanceof DoStatement)             action=PLACE_NEW_LIST_SECOND_FROM_TOP;
          }
        }
 else         if (statements.size() > 1) {
          AbstractStatement previousStatement=null;
          if (position >= 1)           previousStatement=statements.get(position - 1);
          if (previousStatement != null && previousStatement.getStatement() instanceof TryStatement) {
            CompositeStatementObject tryStatement=(CompositeStatementObject)previousStatement;
            AbstractStatement firstStatement=tryStatement.getStatements().get(0);
            if (firstStatement instanceof CompositeStatementObject) {
              CompositeStatementObject tryBlock=(CompositeStatementObject)firstStatement;
              List<AbstractStatement> tryBlockStatements=tryBlock.getStatements();
              if (tryBlockStatements.size() > 0) {
                previousStatement=tryBlockStatements.get(tryBlockStatements.size() - 1);
              }
 else {
                if (position >= 2)                 previousStatement=statements.get(position - 2);
 else                 previousStatement=null;
              }
            }
          }
          if (statements.get(statements.size() - 1).equals(compositeStatement)) {
            if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement) {
              action=JOIN_SECOND_FROM_TOP_LIST;
              if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))               action=PLACE_NEW_LIST_SECOND_FROM_TOP;
            }
 else {
              action=JOIN_TOP_LIST;
              if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))               action=PUSH_NEW_LIST;
            }
          }
 else {
            if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement)             action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else {
              action=PUSH_NEW_LIST;
              if (parent != null && parent.getStatement() instanceof DoStatement && statements.get(0).getStatement() instanceof IfStatement)               action=PLACE_NEW_LIST_SECOND_FROM_TOP;
            }
          }
        }
        previousNodes=processIfStatement(previousNodes,compositeStatement,action);
      }
    }
    i++;
  }
  return previousNodes;
}"
12152,"public boolean satisfiesRules(){
  if (sliceNodes.size() > 1 && !nodeCritetionIsDeclarationOfVariableCriterion() && !variableCriterionIsReturnedVariableInOriginalMethod() && !containsDuplicateNodeWithStateChangingMethodInvocation())   return true;
  return false;
}","public boolean satisfiesRules(){
  if (!nodeCritetionIsDeclarationOfVariableCriterion() && !variableCriterionIsReturnedVariableInOriginalMethod() && !containsDuplicateNodeWithStateChangingMethodInvocation())   return true;
  return false;
}"
12153,"private void modifySourceMethod(){
  AST ast=sourceMethodDeclaration.getAST();
  MethodInvocation extractedMethodInvocation=ast.newMethodInvocation();
  sourceRewriter.set(extractedMethodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(slice.getExtractedMethodName()),null);
  ListRewrite argumentRewrite=sourceRewriter.getListRewrite(extractedMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  VariableDeclaration variableDeclaration : slice.getPassedParameters()) {
    argumentRewrite.insertLast(variableDeclaration.getName(),null);
  }
  if (slice.declarationOfVariableCriterionBelongsToSliceNodes() && slice.declarationOfVariableCriterionBelongsToRemovableNodes()) {
    VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion();
    VariableDeclarationFragment initializationFragment=ast.newVariableDeclarationFragment();
    sourceRewriter.set(initializationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariableDeclaration.getName(),null);
    sourceRewriter.set(initializationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractedMethodInvocation,null);
    VariableDeclarationStatement initializationVariableDeclarationStatement=ast.newVariableDeclarationStatement(initializationFragment);
    Type returnedVariableType=null;
    if (returnedVariableDeclaration instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariableDeclaration;
      returnedVariableType=singleVariableDeclaration.getType();
    }
 else     if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment fragment=(VariableDeclarationFragment)returnedVariableDeclaration;
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      returnedVariableType=variableDeclarationStatement.getType();
    }
    sourceRewriter.set(initializationVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedVariableType,null);
    Statement extractedMethodInvocationInsertionStatement=slice.getExtractedMethodInvocationInsertionStatement();
    Block parentStatement=(Block)extractedMethodInvocationInsertionStatement.getParent();
    ListRewrite blockRewrite=sourceRewriter.getListRewrite(parentStatement,Block.STATEMENTS_PROPERTY);
    blockRewrite.insertBefore(initializationVariableDeclarationStatement,extractedMethodInvocationInsertionStatement,null);
  }
 else   if (slice.declarationOfVariableCriterionBelongsToSliceNodes() && !slice.declarationOfVariableCriterionBelongsToRemovableNodes()) {
    VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion();
    if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment initializationFragment=(VariableDeclarationFragment)returnedVariableDeclaration;
      sourceRewriter.set(initializationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractedMethodInvocation,null);
    }
  }
 else {
    Assignment assignment=ast.newAssignment();
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,slice.getLocalVariableCriterion().getName(),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,extractedMethodInvocation,null);
    ExpressionStatement expressionStatement=ast.newExpressionStatement(assignment);
    Statement extractedMethodInvocationInsertionStatement=slice.getExtractedMethodInvocationInsertionStatement();
    Block parentStatement=(Block)extractedMethodInvocationInsertionStatement.getParent();
    ListRewrite blockRewrite=sourceRewriter.getListRewrite(parentStatement,Block.STATEMENTS_PROPERTY);
    blockRewrite.insertBefore(expressionStatement,extractedMethodInvocationInsertionStatement,null);
  }
  for (  Statement removableStatement : slice.getRemovableStatements()) {
    sourceRewriter.remove(removableStatement,null);
  }
}","private void modifySourceMethod(){
  AST ast=sourceMethodDeclaration.getAST();
  MethodInvocation extractedMethodInvocation=ast.newMethodInvocation();
  sourceRewriter.set(extractedMethodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(slice.getExtractedMethodName()),null);
  ListRewrite argumentRewrite=sourceRewriter.getListRewrite(extractedMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  VariableDeclaration variableDeclaration : slice.getPassedParameters()) {
    argumentRewrite.insertLast(variableDeclaration.getName(),null);
  }
  if (slice.declarationOfVariableCriterionBelongsToSliceNodes() && slice.declarationOfVariableCriterionBelongsToRemovableNodes()) {
    VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion();
    VariableDeclarationFragment initializationFragment=ast.newVariableDeclarationFragment();
    sourceRewriter.set(initializationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariableDeclaration.getName(),null);
    sourceRewriter.set(initializationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractedMethodInvocation,null);
    VariableDeclarationStatement initializationVariableDeclarationStatement=ast.newVariableDeclarationStatement(initializationFragment);
    Type returnedVariableType=null;
    if (returnedVariableDeclaration instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariableDeclaration;
      returnedVariableType=singleVariableDeclaration.getType();
    }
 else     if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment fragment=(VariableDeclarationFragment)returnedVariableDeclaration;
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      returnedVariableType=variableDeclarationStatement.getType();
    }
    sourceRewriter.set(initializationVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,returnedVariableType,null);
    Statement extractedMethodInvocationInsertionStatement=slice.getExtractedMethodInvocationInsertionStatement();
    Block parentStatement=(Block)extractedMethodInvocationInsertionStatement.getParent();
    ListRewrite blockRewrite=sourceRewriter.getListRewrite(parentStatement,Block.STATEMENTS_PROPERTY);
    blockRewrite.insertBefore(initializationVariableDeclarationStatement,extractedMethodInvocationInsertionStatement,null);
  }
 else   if (slice.declarationOfVariableCriterionBelongsToSliceNodes() && !slice.declarationOfVariableCriterionBelongsToRemovableNodes()) {
    VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion();
    if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment oldInitializationFragment=(VariableDeclarationFragment)returnedVariableDeclaration;
      VariableDeclarationFragment newInitializationFragment=ast.newVariableDeclarationFragment();
      sourceRewriter.set(newInitializationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariableDeclaration.getName(),null);
      sourceRewriter.set(newInitializationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractedMethodInvocation,null);
      if (oldInitializationFragment.getParent() instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement oldVariableDeclarationStatement=(VariableDeclarationStatement)oldInitializationFragment.getParent();
        List<VariableDeclarationFragment> oldFragments=oldVariableDeclarationStatement.fragments();
        VariableDeclarationStatement newVariableDeclarationStatement=ast.newVariableDeclarationStatement(newInitializationFragment);
        sourceRewriter.set(newVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,oldVariableDeclarationStatement.getType(),null);
        ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(newVariableDeclarationStatement,VariableDeclarationStatement.FRAGMENTS_PROPERTY);
        for (int i=0; i < oldFragments.size(); i++) {
          if (!oldInitializationFragment.equals(oldFragments.get(i)))           fragmentRewrite.insertLast(oldFragments.get(i),null);
        }
        sourceRewriter.replace(oldVariableDeclarationStatement,newVariableDeclarationStatement,null);
      }
    }
  }
 else {
    Assignment assignment=ast.newAssignment();
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,slice.getLocalVariableCriterion().getName(),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,extractedMethodInvocation,null);
    ExpressionStatement expressionStatement=ast.newExpressionStatement(assignment);
    Statement extractedMethodInvocationInsertionStatement=slice.getExtractedMethodInvocationInsertionStatement();
    Block parentStatement=(Block)extractedMethodInvocationInsertionStatement.getParent();
    ListRewrite blockRewrite=sourceRewriter.getListRewrite(parentStatement,Block.STATEMENTS_PROPERTY);
    blockRewrite.insertBefore(expressionStatement,extractedMethodInvocationInsertionStatement,null);
  }
  for (  Statement removableStatement : slice.getRemovableStatements()) {
    sourceRewriter.remove(removableStatement,null);
  }
}"
12154,"private ASTSlice[] getTable(){
  if (selectedPackage != null)   astReader=new ASTReader(selectedPackage);
 else   astReader=new ASTReader(selectedProject);
  SystemObject systemObject=astReader.getSystemObject();
  List<PDGSliceUnion> extractedSliceUnions=new ArrayList<PDGSliceUnion>();
  ListIterator<ClassObject> classIterator=systemObject.getClassListIterator();
  while (classIterator.hasNext()) {
    ClassObject classObject=classIterator.next();
    ListIterator<MethodObject> methodIterator=classObject.getMethodIterator();
    while (methodIterator.hasNext()) {
      MethodObject methodObject=methodIterator.next();
      if (methodObject.getMethodBody() != null) {
        CFG cfg=new CFG(methodObject);
        PDG pdg=new PDG(cfg);
        for (        VariableDeclaration declaration : pdg.getVariableDeclarationsInMethod()) {
          PDGSliceUnionCollection sliceUnionCollection=new PDGSliceUnionCollection(pdg,declaration);
          for (          PDGSliceUnion sliceUnion : sliceUnionCollection.getSliceUnions()) {
            extractedSliceUnions.add(sliceUnion);
          }
        }
      }
    }
  }
  ASTSlice[] table=new ASTSlice[extractedSliceUnions.size()];
  for (int i=0; i < extractedSliceUnions.size(); i++) {
    ASTSlice astSlice=new ASTSlice(extractedSliceUnions.get(i));
    table[i]=astSlice;
  }
  return table;
}","private ASTSlice[] getTable(){
  if (selectedPackage != null)   astReader=new ASTReader(selectedPackage);
 else   astReader=new ASTReader(selectedProject);
  SystemObject systemObject=astReader.getSystemObject();
  List<PDGSliceUnion> extractedSliceUnions=new ArrayList<PDGSliceUnion>();
  ListIterator<ClassObject> classIterator=systemObject.getClassListIterator();
  while (classIterator.hasNext()) {
    ClassObject classObject=classIterator.next();
    ListIterator<MethodObject> methodIterator=classObject.getMethodIterator();
    while (methodIterator.hasNext()) {
      MethodObject methodObject=methodIterator.next();
      if (methodObject.getMethodBody() != null) {
        CFG cfg=new CFG(methodObject);
        PDG pdg=new PDG(cfg);
        for (        VariableDeclaration declaration : pdg.getVariableDeclarationsInMethod()) {
          PDGSliceUnionCollection sliceUnionCollection=new PDGSliceUnionCollection(pdg,declaration);
          for (          PDGSliceUnion sliceUnion : sliceUnionCollection.getSliceUnions()) {
            if (sliceUnion.getSliceNodes().size() > 1)             extractedSliceUnions.add(sliceUnion);
          }
        }
      }
    }
  }
  ASTSlice[] table=new ASTSlice[extractedSliceUnions.size()];
  for (int i=0; i < extractedSliceUnions.size(); i++) {
    ASTSlice astSlice=new ASTSlice(extractedSliceUnions.get(i));
    table[i]=astSlice;
  }
  return table;
}"
12155,"public Set<PDGSlice> getProgramDependenceSlices(PDGNode sliceNode,LocalVariableInstructionObject sliceVariable){
  Set<PDGSlice> slices=new LinkedHashSet<PDGSlice>();
  Set<BasicBlock> boundaryBlocks=boundaryBlocks(sliceNode);
  for (  BasicBlock boundaryBlock : boundaryBlocks) {
    PDGSlice slice=new PDGSlice(this,boundaryBlock,sliceNode,sliceVariable);
    slices.add(slice);
  }
  return slices;
}","public Set<PDGSlice> getProgramDependenceSlices(PDGNode nodeCriterion){
  Set<PDGSlice> slices=new LinkedHashSet<PDGSlice>();
  Set<LocalVariableInstructionObject> examinedVariables=new LinkedHashSet<LocalVariableInstructionObject>();
  for (  LocalVariableInstructionObject definedVariable : nodeCriterion.definedVariables) {
    if (!examinedVariables.contains(definedVariable)) {
      slices.addAll(getProgramDependenceSlices(nodeCriterion,definedVariable));
      examinedVariables.add(definedVariable);
    }
  }
  for (  LocalVariableInstructionObject usedVariable : nodeCriterion.usedVariables) {
    if (!examinedVariables.contains(usedVariable)) {
      slices.addAll(getProgramDependenceSlices(nodeCriterion,usedVariable));
      examinedVariables.add(usedVariable);
    }
  }
  return slices;
}"
12156,"private Set<PDGNode> traverseBackward(PDGNode node){
  Set<PDGNode> sliceNodes=new LinkedHashSet<PDGNode>();
  sliceNodes.add(node);
  for (  GraphEdge edge : node.incomingEdges) {
    PDGDependence dependence=(PDGDependence)edge;
    if (edges.contains(dependence)) {
      PDGNode srcPDGNode=(PDGNode)dependence.src;
      sliceNodes.addAll(traverseBackward(srcPDGNode));
    }
  }
  return sliceNodes;
}","private Set<PDGNode> traverseBackward(PDGNode node,Set<PDGNode> visitedNodes){
  Set<PDGNode> sliceNodes=new LinkedHashSet<PDGNode>();
  sliceNodes.add(node);
  visitedNodes.add(node);
  for (  GraphEdge edge : node.incomingEdges) {
    PDGDependence dependence=(PDGDependence)edge;
    if (edges.contains(dependence)) {
      PDGNode srcPDGNode=(PDGNode)dependence.src;
      if (!visitedNodes.contains(srcPDGNode))       sliceNodes.addAll(traverseBackward(srcPDGNode,visitedNodes));
    }
  }
  return sliceNodes;
}"
12157,"public PDGSlice(PDG pdg,BasicBlock boundaryBlock,PDGNode sliceNode,LocalVariableInstructionObject sliceLocalVariable){
  super();
  Set<PDGNode> regionNodes=pdg.blockBasedRegion(boundaryBlock);
  for (  PDGNode node : regionNodes) {
    nodes.add(node);
  }
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    if (nodes.contains(dependence.src) && nodes.contains(dependence.dst))     edges.add(dependence);
  }
  this.sliceNode=sliceNode;
  this.sliceLocalVariable=sliceLocalVariable;
}","public PDGSlice(PDG pdg,BasicBlock boundaryBlock,PDGNode nodeCriterion,LocalVariableInstructionObject localVariableCriterion){
  super();
  this.boundaryBlock=boundaryBlock;
  this.nodeCriterion=nodeCriterion;
  this.localVariableCriterion=localVariableCriterion;
  Set<PDGNode> regionNodes=pdg.blockBasedRegion(boundaryBlock);
  for (  PDGNode node : regionNodes) {
    nodes.add(node);
  }
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    if (nodes.contains(dependence.src) && nodes.contains(dependence.dst))     edges.add(dependence);
  }
  this.sliceNodes=new LinkedHashSet<PDGNode>();
  if (nodeCriterion.definesLocalVariable(localVariableCriterion)) {
    sliceNodes.addAll(traverseBackward(nodeCriterion,new LinkedHashSet<PDGNode>()));
  }
 else   if (nodeCriterion.usesLocalVariable(localVariableCriterion)) {
    Set<PDGNode> defNodes=getDefNodes(nodeCriterion,localVariableCriterion);
    for (    PDGNode defNode : defNodes) {
      sliceNodes.addAll(traverseBackward(defNode,new LinkedHashSet<PDGNode>()));
    }
  }
  this.remainingNodes=new LinkedHashSet<PDGNode>();
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!sliceNodes.contains(pdgNode))     remainingNodes.add(pdgNode);
  }
  this.passedParameters=new LinkedHashSet<LocalVariableInstructionObject>();
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    if (dependence instanceof PDGDataDependence) {
      PDGDataDependence dataDependence=(PDGDataDependence)dependence;
      PDGNode srcPDGNode=(PDGNode)dataDependence.src;
      PDGNode dstPDGNode=(PDGNode)dataDependence.dst;
      if (remainingNodes.contains(srcPDGNode) && sliceNodes.contains(dstPDGNode))       passedParameters.add(dataDependence.getData());
    }
  }
}"
12158,"public Set<PDGNode> getSliceNodes(){
  Set<PDGNode> sliceNodes=new LinkedHashSet<PDGNode>();
  if (sliceNode.definesLocalVariable(sliceLocalVariable)) {
    sliceNodes.addAll(traverseBackward(sliceNode));
  }
 else   if (sliceNode.usesLocalVariable(sliceLocalVariable)) {
    Set<PDGNode> defNodes=getDefNodes(sliceNode,sliceLocalVariable);
    for (    PDGNode defNode : defNodes) {
      sliceNodes.addAll(traverseBackward(defNode));
    }
  }
  return sliceNodes;
}","public Set<PDGNode> getSliceNodes(){
  return sliceNodes;
}"
12159,"private List<CFGNode> process(List<CFGNode> previousNodes,CompositeStatementObject composite){
  for (  AbstractStatement abstractStatement : composite.getStatements()) {
    if (abstractStatement instanceof StatementObject) {
      StatementObject statement=(StatementObject)abstractStatement;
      CFGNode currentNode=new CFGNode(statement);
      nodes.add(currentNode);
      createTopDownFlow(previousNodes,currentNode);
      ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
      currentNodes.add(currentNode);
      previousNodes=currentNodes;
    }
 else     if (abstractStatement instanceof CompositeStatementObject) {
      CompositeStatementObject compositeStatement=(CompositeStatementObject)abstractStatement;
      if (compositeStatement.getStatement() instanceof Block) {
        previousNodes=process(previousNodes,compositeStatement);
      }
 else       if (isLoop(compositeStatement)) {
        CFGBranchNode currentNode=new CFGBranchLoopNode(compositeStatement);
        nodes.add(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        previousNodes=new ArrayList<CFGNode>();
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes.addAll(process(currentNodes,compositeStatement));
        for (        CFGNode previousNode : previousNodes) {
          Flow flow=new Flow(previousNode,currentNode);
          if (previousNode instanceof CFGBranchNode) {
            flow.setFalseControlFlow(true);
          }
          flow.setLoopbackFlow(true);
          edges.add(flow);
        }
        if (previousNodes.size() > 1) {
          for (          CFGBranchConditionalNode conditionalNode : unjoinedConditionalNodes) {
            conditionalNode.setJoinNode(currentNode);
          }
          unjoinedConditionalNodes.clear();
        }
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof DoStatement) {
        List<CFGNode> tmpNodes=previousNodes;
        previousNodes=process(previousNodes,compositeStatement);
        CFGBranchNode currentNode=new CFGBranchDoLoopNode(compositeStatement);
        nodes.add(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        CFGNode topNode=getCommonNextNode(tmpNodes);
        Flow flow=new Flow(currentNode,topNode);
        flow.setTrueControlFlow(true);
        flow.setLoopbackFlow(true);
        edges.add(flow);
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof IfStatement) {
        previousNodes=processIfStatement(previousNodes,compositeStatement);
      }
    }
  }
  return previousNodes;
}","private List<CFGNode> process(List<CFGNode> previousNodes,CompositeStatementObject composite){
  int i=0;
  for (  AbstractStatement abstractStatement : composite.getStatements()) {
    if (abstractStatement instanceof StatementObject) {
      StatementObject statement=(StatementObject)abstractStatement;
      CFGNode currentNode=new CFGNode(statement);
      nodes.add(currentNode);
      createTopDownFlow(previousNodes,currentNode);
      ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
      currentNodes.add(currentNode);
      previousNodes=currentNodes;
    }
 else     if (abstractStatement instanceof CompositeStatementObject) {
      CompositeStatementObject compositeStatement=(CompositeStatementObject)abstractStatement;
      if (compositeStatement.getStatement() instanceof Block) {
        previousNodes=process(previousNodes,compositeStatement);
      }
 else       if (isLoop(compositeStatement)) {
        CFGBranchNode currentNode=new CFGBranchLoopNode(compositeStatement);
        nodes.add(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        previousNodes=new ArrayList<CFGNode>();
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes.addAll(process(currentNodes,compositeStatement));
        for (        CFGNode previousNode : previousNodes) {
          Flow flow=new Flow(previousNode,currentNode);
          if (previousNode instanceof CFGBranchNode) {
            flow.setFalseControlFlow(true);
          }
          flow.setLoopbackFlow(true);
          edges.add(flow);
        }
        if (previousNodes.size() > 1) {
          List<CFGBranchConditionalNode> conditionalNodes=unjoinedConditionalNodes.pop();
          for (          CFGBranchConditionalNode conditionalNode : conditionalNodes) {
            conditionalNode.setJoinNode(currentNode);
          }
        }
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof DoStatement) {
        List<CFGNode> tmpNodes=previousNodes;
        previousNodes=process(previousNodes,compositeStatement);
        CFGBranchNode currentNode=new CFGBranchDoLoopNode(compositeStatement);
        nodes.add(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        CFGNode topNode=getCommonNextNode(tmpNodes);
        Flow flow=new Flow(currentNode,topNode);
        flow.setTrueControlFlow(true);
        flow.setLoopbackFlow(true);
        edges.add(flow);
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof IfStatement) {
        int action=PUSH_NEW_LIST;
        List<AbstractStatement> statements=composite.getStatements();
        if (statements.size() == 1)         action=JOIN_TOP_LIST;
 else         if (statements.size() > 1) {
          AbstractStatement previousStatement=null;
          if (i >= 1)           previousStatement=statements.get(i - 1);
          if (statements.get(statements.size() - 1).equals(compositeStatement)) {
            if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement)             action=JOIN_SECOND_FROM_TOP_LIST;
 else             action=JOIN_TOP_LIST;
          }
 else {
            if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement)             action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else             action=PUSH_NEW_LIST;
          }
        }
        previousNodes=processIfStatement(previousNodes,compositeStatement,action);
      }
    }
    i++;
  }
  return previousNodes;
}"
12160,"public CFG(MethodObject method){
  this.method=method;
  this.unjoinedConditionalNodes=new ArrayList<CFGBranchConditionalNode>();
  MethodBodyObject methodBody=method.getMethodBody();
  if (methodBody != null) {
    CompositeStatementObject composite=methodBody.getCompositeStatement();
    process(new ArrayList<CFGNode>(),composite);
    GraphNode.resetNodeNum();
    this.basicBlockCFG=new BasicBlockCFG(this);
  }
}","public CFG(MethodObject method){
  this.method=method;
  this.unjoinedConditionalNodes=new Stack<List<CFGBranchConditionalNode>>();
  MethodBodyObject methodBody=method.getMethodBody();
  if (methodBody != null) {
    CompositeStatementObject composite=methodBody.getCompositeStatement();
    process(new ArrayList<CFGNode>(),composite);
    GraphNode.resetNodeNum();
    this.basicBlockCFG=new BasicBlockCFG(this);
  }
}"
12161,"private void createTopDownFlow(List<CFGNode> previousNodes,CFGNode currentNode){
  for (  CFGNode previousNode : previousNodes) {
    Flow flow=new Flow(previousNode,currentNode);
    if (previousNode instanceof CFGBranchNode) {
      if (currentNode.getId() == previousNode.getId() + 1 && !(previousNode.getASTStatement() instanceof DoStatement))       flow.setTrueControlFlow(true);
 else       flow.setFalseControlFlow(true);
    }
    edges.add(flow);
  }
  if (previousNodes.size() > 1) {
    for (    CFGBranchConditionalNode conditionalNode : unjoinedConditionalNodes) {
      conditionalNode.setJoinNode(currentNode);
    }
    unjoinedConditionalNodes.clear();
  }
}","private void createTopDownFlow(List<CFGNode> previousNodes,CFGNode currentNode){
  for (  CFGNode previousNode : previousNodes) {
    Flow flow=new Flow(previousNode,currentNode);
    if (previousNode instanceof CFGBranchNode) {
      if (currentNode.getId() == previousNode.getId() + 1 && !(previousNode.getASTStatement() instanceof DoStatement))       flow.setTrueControlFlow(true);
 else       flow.setFalseControlFlow(true);
    }
    edges.add(flow);
  }
  if (previousNodes.size() > 1) {
    List<CFGBranchConditionalNode> conditionalNodes=unjoinedConditionalNodes.pop();
    for (    CFGBranchConditionalNode conditionalNode : conditionalNodes) {
      conditionalNode.setJoinNode(currentNode);
    }
  }
}"
12162,"private List<CFGNode> processIfStatement(List<CFGNode> previousNodes,CompositeStatementObject compositeStatement){
  CFGBranchConditionalNode currentNode=new CFGBranchConditionalNode(compositeStatement);
  unjoinedConditionalNodes.add(currentNode);
  nodes.add(currentNode);
  createTopDownFlow(previousNodes,currentNode);
  previousNodes=new ArrayList<CFGNode>();
  List<AbstractStatement> ifStatementList=compositeStatement.getStatements();
  AbstractStatement thenClause=ifStatementList.get(0);
  if (thenClause instanceof StatementObject) {
    StatementObject thenClauseStatement=(StatementObject)thenClause;
    CFGNode thenClauseNode=new CFGNode(thenClauseStatement);
    nodes.add(thenClauseNode);
    ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
    currentNodes.add(currentNode);
    createTopDownFlow(currentNodes,thenClauseNode);
    previousNodes.add(thenClauseNode);
  }
 else   if (thenClause instanceof CompositeStatementObject) {
    CompositeStatementObject thenClauseCompositeStatement=(CompositeStatementObject)thenClause;
    ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
    currentNodes.add(currentNode);
    if (thenClauseCompositeStatement.getStatement() instanceof IfStatement)     previousNodes.addAll(processIfStatement(currentNodes,thenClauseCompositeStatement));
 else     previousNodes.addAll(process(currentNodes,thenClauseCompositeStatement));
  }
  if (ifStatementList.size() == 2) {
    AbstractStatement elseClause=ifStatementList.get(1);
    if (elseClause instanceof StatementObject) {
      StatementObject elseClauseStatement=(StatementObject)elseClause;
      CFGNode elseClauseNode=new CFGNode(elseClauseStatement);
      nodes.add(elseClauseNode);
      ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
      currentNodes.add(currentNode);
      createTopDownFlow(currentNodes,elseClauseNode);
      previousNodes.add(elseClauseNode);
    }
 else     if (elseClause instanceof CompositeStatementObject) {
      CompositeStatementObject elseClauseCompositeStatement=(CompositeStatementObject)elseClause;
      ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
      currentNodes.add(currentNode);
      if (elseClauseCompositeStatement.getStatement() instanceof IfStatement)       previousNodes.addAll(processIfStatement(currentNodes,elseClauseCompositeStatement));
 else       previousNodes.addAll(process(currentNodes,elseClauseCompositeStatement));
    }
  }
 else {
    previousNodes.add(currentNode);
  }
  return previousNodes;
}","private List<CFGNode> processIfStatement(List<CFGNode> previousNodes,CompositeStatementObject compositeStatement,int action){
  CFGBranchConditionalNode currentNode=new CFGBranchConditionalNode(compositeStatement);
  if (action == JOIN_TOP_LIST && !unjoinedConditionalNodes.empty()) {
    List<CFGBranchConditionalNode> topList=unjoinedConditionalNodes.peek();
    topList.add(currentNode);
  }
 else   if (action == JOIN_SECOND_FROM_TOP_LIST) {
    List<CFGBranchConditionalNode> list=unjoinedConditionalNodes.elementAt(unjoinedConditionalNodes.size() - 2);
    list.add(currentNode);
  }
 else   if (action == PLACE_NEW_LIST_SECOND_FROM_TOP) {
    List<CFGBranchConditionalNode> topList=unjoinedConditionalNodes.pop();
    List<CFGBranchConditionalNode> list=new ArrayList<CFGBranchConditionalNode>();
    list.add(currentNode);
    unjoinedConditionalNodes.push(list);
    unjoinedConditionalNodes.push(topList);
  }
 else {
    List<CFGBranchConditionalNode> list=new ArrayList<CFGBranchConditionalNode>();
    list.add(currentNode);
    unjoinedConditionalNodes.push(list);
  }
  nodes.add(currentNode);
  createTopDownFlow(previousNodes,currentNode);
  previousNodes=new ArrayList<CFGNode>();
  List<AbstractStatement> ifStatementList=compositeStatement.getStatements();
  AbstractStatement thenClause=ifStatementList.get(0);
  if (thenClause instanceof StatementObject) {
    StatementObject thenClauseStatement=(StatementObject)thenClause;
    CFGNode thenClauseNode=new CFGNode(thenClauseStatement);
    nodes.add(thenClauseNode);
    ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
    currentNodes.add(currentNode);
    createTopDownFlow(currentNodes,thenClauseNode);
    previousNodes.add(thenClauseNode);
  }
 else   if (thenClause instanceof CompositeStatementObject) {
    CompositeStatementObject thenClauseCompositeStatement=(CompositeStatementObject)thenClause;
    ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
    currentNodes.add(currentNode);
    if (thenClauseCompositeStatement.getStatement() instanceof IfStatement)     previousNodes.addAll(processIfStatement(currentNodes,thenClauseCompositeStatement,JOIN_TOP_LIST));
 else     previousNodes.addAll(process(currentNodes,thenClauseCompositeStatement));
  }
  if (ifStatementList.size() == 2) {
    AbstractStatement elseClause=ifStatementList.get(1);
    if (elseClause instanceof StatementObject) {
      StatementObject elseClauseStatement=(StatementObject)elseClause;
      CFGNode elseClauseNode=new CFGNode(elseClauseStatement);
      nodes.add(elseClauseNode);
      ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
      currentNodes.add(currentNode);
      createTopDownFlow(currentNodes,elseClauseNode);
      previousNodes.add(elseClauseNode);
    }
 else     if (elseClause instanceof CompositeStatementObject) {
      CompositeStatementObject elseClauseCompositeStatement=(CompositeStatementObject)elseClause;
      ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
      currentNodes.add(currentNode);
      if (elseClauseCompositeStatement.getStatement() instanceof IfStatement)       previousNodes.addAll(processIfStatement(currentNodes,elseClauseCompositeStatement,JOIN_TOP_LIST));
 else       previousNodes.addAll(process(currentNodes,elseClauseCompositeStatement));
    }
  }
 else {
    previousNodes.add(currentNode);
  }
  return previousNodes;
}"
12163,"private List<CFGNode> process(List<CFGNode> previousNodes,CompositeStatementObject composite){
  int i=0;
  for (  AbstractStatement abstractStatement : composite.getStatements()) {
    if (abstractStatement instanceof StatementObject) {
      StatementObject statement=(StatementObject)abstractStatement;
      CFGNode currentNode=new CFGNode(statement);
      nodes.add(currentNode);
      createTopDownFlow(previousNodes,currentNode);
      ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
      currentNodes.add(currentNode);
      previousNodes=currentNodes;
    }
 else     if (abstractStatement instanceof CompositeStatementObject) {
      CompositeStatementObject compositeStatement=(CompositeStatementObject)abstractStatement;
      if (compositeStatement.getStatement() instanceof Block) {
        previousNodes=process(previousNodes,compositeStatement);
      }
 else       if (isLoop(compositeStatement)) {
        CFGBranchNode currentNode=new CFGBranchLoopNode(compositeStatement);
        nodes.add(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        previousNodes=new ArrayList<CFGNode>();
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes.addAll(process(currentNodes,compositeStatement));
        for (        CFGNode previousNode : previousNodes) {
          Flow flow=new Flow(previousNode,currentNode);
          if (previousNode instanceof CFGBranchNode) {
            flow.setFalseControlFlow(true);
          }
          flow.setLoopbackFlow(true);
          edges.add(flow);
        }
        if (previousNodes.size() > 1) {
          List<CFGBranchConditionalNode> conditionalNodes=unjoinedConditionalNodes.pop();
          for (          CFGBranchConditionalNode conditionalNode : conditionalNodes) {
            conditionalNode.setJoinNode(currentNode);
          }
        }
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof DoStatement) {
        List<CFGNode> tmpNodes=previousNodes;
        previousNodes=process(previousNodes,compositeStatement);
        CFGBranchNode currentNode=new CFGBranchDoLoopNode(compositeStatement);
        nodes.add(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        CFGNode topNode=getCommonNextNode(tmpNodes);
        Flow flow=new Flow(currentNode,topNode);
        flow.setTrueControlFlow(true);
        flow.setLoopbackFlow(true);
        edges.add(flow);
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof IfStatement) {
        int action=PUSH_NEW_LIST;
        List<AbstractStatement> statements=composite.getStatements();
        if (statements.size() == 1)         action=JOIN_TOP_LIST;
 else         if (statements.size() > 1) {
          AbstractStatement previousStatement=null;
          if (i >= 1)           previousStatement=statements.get(i - 1);
          if (statements.get(statements.size() - 1).equals(compositeStatement)) {
            if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement)             action=JOIN_SECOND_FROM_TOP_LIST;
 else             action=JOIN_TOP_LIST;
          }
 else {
            if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement)             action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else             action=PUSH_NEW_LIST;
          }
        }
        previousNodes=processIfStatement(previousNodes,compositeStatement,action);
      }
    }
    i++;
  }
  return previousNodes;
}","private List<CFGNode> process(List<CFGNode> previousNodes,CompositeStatementObject composite){
  int i=0;
  for (  AbstractStatement abstractStatement : composite.getStatements()) {
    if (abstractStatement instanceof StatementObject) {
      StatementObject statement=(StatementObject)abstractStatement;
      CFGNode currentNode=new CFGNode(statement);
      nodes.add(currentNode);
      createTopDownFlow(previousNodes,currentNode);
      ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
      currentNodes.add(currentNode);
      previousNodes=currentNodes;
    }
 else     if (abstractStatement instanceof CompositeStatementObject) {
      CompositeStatementObject compositeStatement=(CompositeStatementObject)abstractStatement;
      if (compositeStatement.getStatement() instanceof Block) {
        previousNodes=process(previousNodes,compositeStatement);
      }
 else       if (isLoop(compositeStatement)) {
        CFGBranchNode currentNode=new CFGBranchLoopNode(compositeStatement);
        nodes.add(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        previousNodes=new ArrayList<CFGNode>();
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes.addAll(process(currentNodes,compositeStatement));
        for (        CFGNode previousNode : previousNodes) {
          Flow flow=new Flow(previousNode,currentNode);
          if (previousNode instanceof CFGBranchNode) {
            flow.setFalseControlFlow(true);
          }
          flow.setLoopbackFlow(true);
          edges.add(flow);
        }
        if (previousNodes.size() > 1) {
          List<CFGBranchConditionalNode> conditionalNodes=unjoinedConditionalNodes.pop();
          for (          CFGBranchConditionalNode conditionalNode : conditionalNodes) {
            conditionalNode.setJoinNode(currentNode);
          }
        }
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof DoStatement) {
        List<CFGNode> tmpNodes=previousNodes;
        previousNodes=process(previousNodes,compositeStatement);
        CFGBranchNode currentNode=new CFGBranchDoLoopNode(compositeStatement);
        nodes.add(currentNode);
        createTopDownFlow(previousNodes,currentNode);
        CFGNode topNode=getCommonNextNode(tmpNodes);
        Flow flow=new Flow(currentNode,topNode);
        flow.setTrueControlFlow(true);
        flow.setLoopbackFlow(true);
        edges.add(flow);
        ArrayList<CFGNode> currentNodes=new ArrayList<CFGNode>();
        currentNodes.add(currentNode);
        previousNodes=currentNodes;
      }
 else       if (compositeStatement.getStatement() instanceof IfStatement) {
        int action=PUSH_NEW_LIST;
        List<AbstractStatement> statements=composite.getStatements();
        CompositeStatementObject parent=statements.get(0).getParent();
        if (parent.getStatement() instanceof Block)         parent=parent.getParent();
        if (statements.size() == 1) {
          action=JOIN_TOP_LIST;
          if (parent != null) {
            if (isLoop(parent))             action=PUSH_NEW_LIST;
 else             if (parent.getStatement() instanceof DoStatement)             action=PLACE_NEW_LIST_SECOND_FROM_TOP;
          }
        }
 else         if (statements.size() > 1) {
          AbstractStatement previousStatement=null;
          if (i >= 1)           previousStatement=statements.get(i - 1);
          if (statements.get(statements.size() - 1).equals(compositeStatement)) {
            if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement) {
              action=JOIN_SECOND_FROM_TOP_LIST;
              if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))               action=PLACE_NEW_LIST_SECOND_FROM_TOP;
            }
 else {
              action=JOIN_TOP_LIST;
              if (parent != null && (isLoop(parent) || parent.getStatement() instanceof DoStatement))               action=PUSH_NEW_LIST;
            }
          }
 else {
            if (previousStatement != null && previousStatement.getStatement() instanceof IfStatement)             action=PLACE_NEW_LIST_SECOND_FROM_TOP;
 else {
              action=PUSH_NEW_LIST;
              if (parent != null && parent.getStatement() instanceof DoStatement && statements.get(0).getStatement() instanceof IfStatement)               action=PLACE_NEW_LIST_SECOND_FROM_TOP;
            }
          }
        }
        previousNodes=processIfStatement(previousNodes,compositeStatement,action);
      }
    }
    i++;
  }
  return previousNodes;
}"
12164,"public boolean satisfiesRules(){
  for (  PDGSlice slice : slices) {
    if (!slice.satisfiesRules())     return false;
  }
  if (allNodeCriterionsAreDuplicated())   return false;
  if (getSliceNodes().size() <= nodeCriterions.size())   return false;
  return true;
}","public boolean satisfiesRules(){
  for (  PDGSlice slice : slices) {
    if (!slice.satisfiesRules())     return false;
  }
  if (allNodeCriterionsAreDuplicated() || sliceContainsOnlyOneNodeCriterionAndDeclarationOfVariableCriterion())   return false;
  if (getSliceNodes().size() <= nodeCriterions.size())   return false;
  return true;
}"
12165,"private void extractMethod(){
  AST ast=sourceTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion();
  SimpleName returnedVariableSimpleName=returnedVariableDeclaration.getName();
  Type returnedVariableType=null;
  if (returnedVariableDeclaration instanceof SingleVariableDeclaration) {
    SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariableDeclaration;
    returnedVariableType=singleVariableDeclaration.getType();
  }
 else   if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
    VariableDeclarationFragment fragment=(VariableDeclarationFragment)returnedVariableDeclaration;
    VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
    returnedVariableType=variableDeclarationStatement.getType();
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(slice.getExtractedMethodName()),null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnedVariableType,null);
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier modifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
  modifierRewrite.insertLast(modifier,null);
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  VariableDeclaration variableDeclaration : slice.getPassedParameters()) {
    Type variableType=null;
    if (variableDeclaration instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)variableDeclaration;
      variableType=singleVariableDeclaration.getType();
    }
 else     if (variableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment fragment=(VariableDeclarationFragment)variableDeclaration;
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      variableType=variableDeclarationStatement.getType();
    }
    SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration.getName(),null);
    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
    parameterRewrite.insertLast(parameter,null);
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite bodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  List<PDGNode> sliceNodes=new ArrayList<PDGNode>(slice.getSliceNodes());
  while (!sliceNodes.isEmpty()) {
    PDGNode node=sliceNodes.get(0);
    if (node instanceof PDGStatementNode) {
      bodyRewrite.insertLast(node.getASTStatement(),null);
      sliceNodes.remove(node);
    }
 else     if (node instanceof PDGControlPredicateNode) {
      PDGControlPredicateNode predicateNode=(PDGControlPredicateNode)node;
      bodyRewrite.insertLast(processPredicateNode(predicateNode,ast,sliceNodes),null);
    }
  }
  ReturnStatement returnStatement=newMethodBody.getAST().newReturnStatement();
  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariableSimpleName,null);
  bodyRewrite.insertLast(returnStatement,null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  ListRewrite methodDeclarationRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertAfter(newMethodDeclaration,sourceMethodDeclaration,null);
}","private void extractMethod(){
  AST ast=sourceTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  VariableDeclaration returnedVariableDeclaration=slice.getLocalVariableCriterion();
  SimpleName returnedVariableSimpleName=returnedVariableDeclaration.getName();
  Type returnedVariableType=null;
  if (returnedVariableDeclaration instanceof SingleVariableDeclaration) {
    SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariableDeclaration;
    returnedVariableType=singleVariableDeclaration.getType();
  }
 else   if (returnedVariableDeclaration instanceof VariableDeclarationFragment) {
    VariableDeclarationFragment fragment=(VariableDeclarationFragment)returnedVariableDeclaration;
    VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
    returnedVariableType=variableDeclarationStatement.getType();
  }
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(slice.getExtractedMethodName()),null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnedVariableType,null);
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier modifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD);
  modifierRewrite.insertLast(modifier,null);
  ListRewrite parameterRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  VariableDeclaration variableDeclaration : slice.getPassedParameters()) {
    Type variableType=null;
    if (variableDeclaration instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)variableDeclaration;
      variableType=singleVariableDeclaration.getType();
    }
 else     if (variableDeclaration instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment fragment=(VariableDeclarationFragment)variableDeclaration;
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      variableType=variableDeclarationStatement.getType();
    }
    SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclaration.getName(),null);
    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableType,null);
    parameterRewrite.insertLast(parameter,null);
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite bodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  List<PDGNode> sliceNodes=new ArrayList<PDGNode>(slice.getSliceNodes());
  List<CFGBranchDoLoopNode> doLoopNodes=new ArrayList<CFGBranchDoLoopNode>();
  for (  PDGNode pdgNode : sliceNodes) {
    CFGNode cfgNode=pdgNode.getCFGNode();
    if (cfgNode instanceof CFGBranchDoLoopNode) {
      CFGBranchDoLoopNode cfgDoLoopNode=(CFGBranchDoLoopNode)cfgNode;
      doLoopNodes.add(cfgDoLoopNode);
    }
  }
  while (!sliceNodes.isEmpty()) {
    PDGNode node=sliceNodes.get(0);
    if (node instanceof PDGStatementNode) {
      boolean nodeIsInsideDoLoop=false;
      for (      CFGBranchDoLoopNode doLoopNode : doLoopNodes) {
        if (node.getId() >= doLoopNode.getJoinNode().getId() && node.getId() < doLoopNode.getId()) {
          nodeIsInsideDoLoop=true;
          PDGControlPredicateNode predicateNode=(PDGControlPredicateNode)doLoopNode.getPDGNode();
          if (sliceNodes.contains(predicateNode)) {
            bodyRewrite.insertLast(processPredicateNode(predicateNode,ast,sliceNodes),null);
            break;
          }
        }
      }
      if (!nodeIsInsideDoLoop) {
        bodyRewrite.insertLast(node.getASTStatement(),null);
        sliceNodes.remove(node);
      }
    }
 else     if (node instanceof PDGControlPredicateNode) {
      PDGControlPredicateNode predicateNode=(PDGControlPredicateNode)node;
      bodyRewrite.insertLast(processPredicateNode(predicateNode,ast,sliceNodes),null);
    }
  }
  ReturnStatement returnStatement=newMethodBody.getAST().newReturnStatement();
  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariableSimpleName,null);
  bodyRewrite.insertLast(returnStatement,null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  ListRewrite methodDeclarationRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertAfter(newMethodDeclaration,sourceMethodDeclaration,null);
}"
12166,"public Set<PDGSlice> getProgramDependenceSlices(PDGNode nodeCriterion){
  Set<PDGSlice> slices=new LinkedHashSet<PDGSlice>();
  Set<VariableDeclaration> examinedVariables=new LinkedHashSet<VariableDeclaration>();
  for (  VariableDeclaration definedVariable : nodeCriterion.definedVariables) {
    if (!examinedVariables.contains(definedVariable)) {
      slices.addAll(getProgramDependenceSlices(nodeCriterion,definedVariable));
      examinedVariables.add(definedVariable);
    }
  }
  for (  VariableDeclaration usedVariable : nodeCriterion.usedVariables) {
    if (!examinedVariables.contains(usedVariable)) {
      slices.addAll(getProgramDependenceSlices(nodeCriterion,usedVariable));
      examinedVariables.add(usedVariable);
    }
  }
  return slices;
}","public Set<PDGSlice> getProgramDependenceSlices(PDGNode nodeCriterion){
  Set<PDGSlice> slices=new LinkedHashSet<PDGSlice>();
  Set<VariableDeclaration> examinedVariables=new LinkedHashSet<VariableDeclaration>();
  for (  VariableDeclaration definedVariable : nodeCriterion.definedVariables) {
    if (!examinedVariables.contains(definedVariable)) {
      slices.addAll(getProgramDependenceSlices(nodeCriterion,definedVariable));
      examinedVariables.add(definedVariable);
    }
  }
  return slices;
}"
12167,"public PDGSlice(PDG pdg,BasicBlock boundaryBlock,PDGNode nodeCriterion,VariableDeclaration localVariableCriterion){
  super();
  this.method=pdg.getMethod();
  this.boundaryBlock=boundaryBlock;
  this.nodeCriterion=nodeCriterion;
  this.localVariableCriterion=localVariableCriterion;
  Set<PDGNode> regionNodes=pdg.blockBasedRegion(boundaryBlock);
  for (  PDGNode node : regionNodes) {
    nodes.add(node);
  }
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    if (nodes.contains(dependence.src) && nodes.contains(dependence.dst))     edges.add(dependence);
  }
  this.sliceNodes=new TreeSet<PDGNode>();
  sliceNodes.addAll(computeSlice(nodeCriterion,localVariableCriterion));
  this.remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.add(pdg.getEntryNode());
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!sliceNodes.contains(pdgNode))     remainingNodes.add(pdgNode);
  }
  this.passedParameters=new LinkedHashSet<VariableDeclaration>();
  Set<PDGNode> nCD=new LinkedHashSet<PDGNode>();
  Set<PDGNode> nDD=new LinkedHashSet<PDGNode>();
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    PDGNode srcPDGNode=(PDGNode)dependence.src;
    PDGNode dstPDGNode=(PDGNode)dependence.dst;
    if (dependence instanceof PDGDataDependence) {
      PDGDataDependence dataDependence=(PDGDataDependence)dependence;
      if (remainingNodes.contains(srcPDGNode) && sliceNodes.contains(dstPDGNode))       passedParameters.add(dataDependence.getData());
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode) && !dataDependence.getData().equals(localVariableCriterion))       nDD.add(dstPDGNode);
    }
 else     if (dependence instanceof PDGControlDependence) {
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode))       nCD.add(dstPDGNode);
    }
  }
  Set<PDGNode> controlIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nCD) {
    for (    VariableDeclaration usedVariable : p.usedVariables) {
      Set<PDGNode> pSliceNodes=computeSlice(p,usedVariable);
      for (      PDGNode q : pSliceNodes) {
        if (q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
  }
  Set<PDGNode> dataIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nDD) {
    for (    VariableDeclaration definedVariable : p.definedVariables) {
      Set<PDGNode> pSliceNodes=computeSlice(p,definedVariable);
      for (      PDGNode q : pSliceNodes) {
        dataIndispensableNodes.add(q);
      }
    }
  }
  this.indispensableNodes=new LinkedHashSet<PDGNode>();
  indispensableNodes.addAll(controlIndispensableNodes);
  indispensableNodes.addAll(dataIndispensableNodes);
  this.removableNodes=new LinkedHashSet<PDGNode>();
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!remainingNodes.contains(pdgNode) && !indispensableNodes.contains(pdgNode))     removableNodes.add(pdgNode);
  }
}","public PDGSlice(PDG pdg,BasicBlock boundaryBlock,PDGNode nodeCriterion,VariableDeclaration localVariableCriterion){
  super();
  this.method=pdg.getMethod();
  this.boundaryBlock=boundaryBlock;
  this.nodeCriterion=nodeCriterion;
  this.localVariableCriterion=localVariableCriterion;
  Set<PDGNode> regionNodes=pdg.blockBasedRegion(boundaryBlock);
  for (  PDGNode node : regionNodes) {
    nodes.add(node);
  }
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    if (nodes.contains(dependence.src) && nodes.contains(dependence.dst))     edges.add(dependence);
  }
  this.sliceNodes=new TreeSet<PDGNode>();
  sliceNodes.addAll(computeSlice(nodeCriterion,localVariableCriterion));
  this.remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.add(pdg.getEntryNode());
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!sliceNodes.contains(pdgNode))     remainingNodes.add(pdgNode);
  }
  this.passedParameters=new LinkedHashSet<VariableDeclaration>();
  Set<PDGNode> nCD=new LinkedHashSet<PDGNode>();
  Set<PDGNode> nDD=new LinkedHashSet<PDGNode>();
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    PDGNode srcPDGNode=(PDGNode)dependence.src;
    PDGNode dstPDGNode=(PDGNode)dependence.dst;
    if (dependence instanceof PDGDataDependence) {
      PDGDataDependence dataDependence=(PDGDataDependence)dependence;
      if (remainingNodes.contains(srcPDGNode) && sliceNodes.contains(dstPDGNode))       passedParameters.add(dataDependence.getData());
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode) && !dataDependence.getData().equals(localVariableCriterion))       nDD.add(dstPDGNode);
    }
 else     if (dependence instanceof PDGControlDependence) {
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode))       nCD.add(dstPDGNode);
    }
  }
  Set<PDGNode> controlIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nCD) {
    for (    VariableDeclaration usedVariable : p.usedVariables) {
      Set<PDGNode> pSliceNodes=computeSlice(p,usedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
  }
  Set<PDGNode> dataIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nDD) {
    for (    VariableDeclaration definedVariable : p.definedVariables) {
      Set<PDGNode> pSliceNodes=computeSlice(p,definedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q))         dataIndispensableNodes.add(q);
      }
    }
  }
  this.indispensableNodes=new TreeSet<PDGNode>();
  indispensableNodes.addAll(controlIndispensableNodes);
  indispensableNodes.addAll(dataIndispensableNodes);
  this.removableNodes=new LinkedHashSet<PDGNode>();
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!remainingNodes.contains(pdgNode) && !indispensableNodes.contains(pdgNode))     removableNodes.add(pdgNode);
  }
}"
12168,"private ASTSlice[] getTable(){
  if (selectedPackage != null)   astReader=new ASTReader(selectedPackage);
 else   astReader=new ASTReader(selectedProject);
  SystemObject systemObject=astReader.getSystemObject();
  List<PDGSlice> extractedSlices=new ArrayList<PDGSlice>();
  ListIterator<ClassObject> classIterator=systemObject.getClassListIterator();
  while (classIterator.hasNext()) {
    ClassObject classObject=classIterator.next();
    ListIterator<MethodObject> methodIterator=classObject.getMethodIterator();
    while (methodIterator.hasNext()) {
      MethodObject methodObject=methodIterator.next();
      if (methodObject.getMethodBody() != null) {
        CFG cfg=new CFG(methodObject);
        PDG pdg=new PDG(cfg);
        Set<PDGSlice> pdgSlices=pdg.getAllProgramDependenceSlices();
        for (        PDGSlice pdgSlice : pdgSlices) {
          if (pdgSlice.getSliceNodes().size() > 1)           extractedSlices.add(pdgSlice);
        }
      }
    }
  }
  ASTSlice[] table=new ASTSlice[extractedSlices.size()];
  for (int i=0; i < extractedSlices.size(); i++) {
    ASTSlice astSlice=new ASTSlice(extractedSlices.get(i));
    table[i]=astSlice;
  }
  return table;
}","private ASTSlice[] getTable(){
  if (selectedPackage != null)   astReader=new ASTReader(selectedPackage);
 else   astReader=new ASTReader(selectedProject);
  SystemObject systemObject=astReader.getSystemObject();
  List<PDGSlice> extractedSlices=new ArrayList<PDGSlice>();
  ListIterator<ClassObject> classIterator=systemObject.getClassListIterator();
  while (classIterator.hasNext()) {
    ClassObject classObject=classIterator.next();
    ListIterator<MethodObject> methodIterator=classObject.getMethodIterator();
    while (methodIterator.hasNext()) {
      MethodObject methodObject=methodIterator.next();
      if (methodObject.getMethodBody() != null) {
        CFG cfg=new CFG(methodObject);
        PDG pdg=new PDG(cfg);
        Set<PDGSlice> pdgSlices=pdg.getAllProgramDependenceSlices();
        for (        PDGSlice pdgSlice : pdgSlices) {
          if (pdgSlice.getSliceNodes().size() > 1 && !pdgSlice.nodeCriterionBelongsToDuplicatedNodes() && !pdgSlice.containsDuplicateNodeWithDefUseVariable())           extractedSlices.add(pdgSlice);
        }
      }
    }
  }
  ASTSlice[] table=new ASTSlice[extractedSlices.size()];
  for (int i=0; i < extractedSlices.size(); i++) {
    ASTSlice astSlice=new ASTSlice(extractedSlices.get(i));
    table[i]=astSlice;
  }
  return table;
}"
12169,"public Set<CFGNode> getImmediatelyNestedNodesInFalseControlFlow(){
  Set<CFGNode> nestedNodes=new LinkedHashSet<CFGNode>();
  AbstractStatement abstractStatement=getStatement();
  if (abstractStatement instanceof CompositeStatementObject) {
    Set<AbstractStatement> nestedStatements=new LinkedHashSet<AbstractStatement>();
    CompositeStatementObject composite=(CompositeStatementObject)abstractStatement;
    List<AbstractStatement> statements=composite.getStatements();
    if (statements.size() == 2) {
      AbstractStatement falseControlFlowStatement=statements.get(1);
      if (falseControlFlowStatement.getStatement() instanceof Block) {
        CompositeStatementObject blockStatement=(CompositeStatementObject)falseControlFlowStatement;
        nestedStatements.addAll(blockStatement.getStatements());
      }
 else       nestedStatements.add(falseControlFlowStatement);
      List<BasicBlock> nestedBasicBlocks=getNestedBasicBlocks();
      nestedBasicBlocks.add(0,getBasicBlock());
      for (      BasicBlock nestedBlock : nestedBasicBlocks) {
        List<CFGNode> nodes=nestedBlock.getAllNodes();
        for (        CFGNode node : nodes) {
          if (nestedStatements.contains(node.getStatement())) {
            nestedNodes.add(node);
          }
        }
      }
    }
  }
  return nestedNodes;
}","public Set<CFGNode> getImmediatelyNestedNodesInFalseControlFlow(){
  Set<CFGNode> nestedNodes=new LinkedHashSet<CFGNode>();
  AbstractStatement abstractStatement=getStatement();
  if (abstractStatement instanceof CompositeStatementObject) {
    Set<AbstractStatement> nestedStatements=new LinkedHashSet<AbstractStatement>();
    CompositeStatementObject composite=(CompositeStatementObject)abstractStatement;
    List<AbstractStatement> statements=composite.getStatements();
    if (statements.size() == 2) {
      AbstractStatement falseControlFlowStatement=statements.get(1);
      if (falseControlFlowStatement.getStatement() instanceof Block) {
        CompositeStatementObject blockStatement=(CompositeStatementObject)falseControlFlowStatement;
        for (        AbstractStatement statementInsideBlock : blockStatement.getStatements()) {
          if (statementInsideBlock.getStatement() instanceof TryStatement) {
            CompositeStatementObject tryStatement=(CompositeStatementObject)statementInsideBlock;
            processTryStatement(nestedStatements,tryStatement);
          }
 else           nestedStatements.add(statementInsideBlock);
        }
      }
 else       if (falseControlFlowStatement.getStatement() instanceof TryStatement) {
        CompositeStatementObject tryStatement=(CompositeStatementObject)falseControlFlowStatement;
        processTryStatement(nestedStatements,tryStatement);
      }
 else       nestedStatements.add(falseControlFlowStatement);
      List<BasicBlock> nestedBasicBlocks=getNestedBasicBlocks();
      nestedBasicBlocks.add(0,getBasicBlock());
      for (      BasicBlock nestedBlock : nestedBasicBlocks) {
        List<CFGNode> nodes=nestedBlock.getAllNodes();
        for (        CFGNode node : nodes) {
          if (nestedStatements.contains(node.getStatement())) {
            nestedNodes.add(node);
          }
        }
      }
    }
  }
  return nestedNodes;
}"
12170,"public Set<CFGNode> getImmediatelyNestedNodesInTrueControlFlow(){
  Set<CFGNode> nestedNodes=new LinkedHashSet<CFGNode>();
  AbstractStatement abstractStatement=getStatement();
  if (abstractStatement instanceof CompositeStatementObject) {
    Set<AbstractStatement> nestedStatements=new LinkedHashSet<AbstractStatement>();
    CompositeStatementObject composite=(CompositeStatementObject)abstractStatement;
    List<AbstractStatement> statements=composite.getStatements();
    AbstractStatement trueControlFlowStatement=statements.get(0);
    if (trueControlFlowStatement.getStatement() instanceof Block) {
      CompositeStatementObject blockStatement=(CompositeStatementObject)trueControlFlowStatement;
      nestedStatements.addAll(blockStatement.getStatements());
    }
 else     nestedStatements.add(trueControlFlowStatement);
    List<BasicBlock> nestedBasicBlocks=getNestedBasicBlocks();
    nestedBasicBlocks.add(0,getBasicBlock());
    for (    BasicBlock nestedBlock : nestedBasicBlocks) {
      List<CFGNode> nodes=nestedBlock.getAllNodes();
      for (      CFGNode node : nodes) {
        if (nestedStatements.contains(node.getStatement())) {
          nestedNodes.add(node);
        }
      }
    }
  }
  return nestedNodes;
}","public Set<CFGNode> getImmediatelyNestedNodesInTrueControlFlow(){
  Set<CFGNode> nestedNodes=new LinkedHashSet<CFGNode>();
  AbstractStatement abstractStatement=getStatement();
  if (abstractStatement instanceof CompositeStatementObject) {
    Set<AbstractStatement> nestedStatements=new LinkedHashSet<AbstractStatement>();
    CompositeStatementObject composite=(CompositeStatementObject)abstractStatement;
    List<AbstractStatement> statements=composite.getStatements();
    AbstractStatement trueControlFlowStatement=statements.get(0);
    if (trueControlFlowStatement.getStatement() instanceof Block) {
      CompositeStatementObject blockStatement=(CompositeStatementObject)trueControlFlowStatement;
      for (      AbstractStatement statementInsideBlock : blockStatement.getStatements()) {
        if (statementInsideBlock.getStatement() instanceof TryStatement) {
          CompositeStatementObject tryStatement=(CompositeStatementObject)statementInsideBlock;
          processTryStatement(nestedStatements,tryStatement);
        }
 else         nestedStatements.add(statementInsideBlock);
      }
    }
 else     if (trueControlFlowStatement.getStatement() instanceof TryStatement) {
      CompositeStatementObject tryStatement=(CompositeStatementObject)trueControlFlowStatement;
      processTryStatement(nestedStatements,tryStatement);
    }
 else     nestedStatements.add(trueControlFlowStatement);
    List<BasicBlock> nestedBasicBlocks=getNestedBasicBlocks();
    nestedBasicBlocks.add(0,getBasicBlock());
    for (    BasicBlock nestedBlock : nestedBasicBlocks) {
      List<CFGNode> nodes=nestedBlock.getAllNodes();
      for (      CFGNode node : nodes) {
        if (nestedStatements.contains(node.getStatement())) {
          nestedNodes.add(node);
        }
      }
    }
  }
  return nestedNodes;
}"
12171,"public Set<CFGNode> getImmediatelyNestedNodesFromAST(){
  Set<CFGNode> nestedNodes=new LinkedHashSet<CFGNode>();
  AbstractStatement abstractStatement=getStatement();
  if (abstractStatement instanceof CompositeStatementObject) {
    Set<AbstractStatement> nestedStatements=new LinkedHashSet<AbstractStatement>();
    CompositeStatementObject composite=(CompositeStatementObject)abstractStatement;
    List<AbstractStatement> statements=composite.getStatements();
    for (    AbstractStatement statement : statements) {
      if (statement.getStatement() instanceof Block) {
        CompositeStatementObject blockStatement=(CompositeStatementObject)statement;
        nestedStatements.addAll(blockStatement.getStatements());
      }
 else       nestedStatements.add(statement);
    }
    List<BasicBlock> nestedBasicBlocks=getNestedBasicBlocks();
    if (this instanceof CFGBranchDoLoopNode)     nestedBasicBlocks.add(getBasicBlock());
 else     nestedBasicBlocks.add(0,getBasicBlock());
    for (    BasicBlock nestedBlock : nestedBasicBlocks) {
      List<CFGNode> nodes=nestedBlock.getAllNodes();
      for (      CFGNode node : nodes) {
        if (nestedStatements.contains(node.getStatement())) {
          nestedNodes.add(node);
        }
      }
    }
  }
  return nestedNodes;
}","public Set<CFGNode> getImmediatelyNestedNodesFromAST(){
  Set<CFGNode> nestedNodes=new LinkedHashSet<CFGNode>();
  AbstractStatement abstractStatement=getStatement();
  if (abstractStatement instanceof CompositeStatementObject) {
    Set<AbstractStatement> nestedStatements=new LinkedHashSet<AbstractStatement>();
    CompositeStatementObject composite=(CompositeStatementObject)abstractStatement;
    List<AbstractStatement> statements=composite.getStatements();
    for (    AbstractStatement statement : statements) {
      if (statement.getStatement() instanceof Block) {
        CompositeStatementObject blockStatement=(CompositeStatementObject)statement;
        for (        AbstractStatement statementInsideBlock : blockStatement.getStatements()) {
          if (statementInsideBlock.getStatement() instanceof TryStatement) {
            CompositeStatementObject tryStatement=(CompositeStatementObject)statementInsideBlock;
            processTryStatement(nestedStatements,tryStatement);
          }
 else           nestedStatements.add(statementInsideBlock);
        }
      }
 else       if (statement.getStatement() instanceof TryStatement) {
        CompositeStatementObject tryStatement=(CompositeStatementObject)statement;
        processTryStatement(nestedStatements,tryStatement);
      }
 else       nestedStatements.add(statement);
    }
    List<BasicBlock> nestedBasicBlocks=getNestedBasicBlocks();
    if (this instanceof CFGBranchDoLoopNode)     nestedBasicBlocks.add(getBasicBlock());
 else     nestedBasicBlocks.add(0,getBasicBlock());
    for (    BasicBlock nestedBlock : nestedBasicBlocks) {
      List<CFGNode> nodes=nestedBlock.getAllNodes();
      for (      CFGNode node : nodes) {
        if (nestedStatements.contains(node.getStatement())) {
          nestedNodes.add(node);
        }
      }
    }
  }
  return nestedNodes;
}"
12172,"public boolean satisfiesRules(){
  if (!nodeCritetionIsDeclarationOfVariableCriterion() && !variableCriterionIsReturnedVariableInOriginalMethod() && !nodeCriterionAndDeclarationOfVariableCriterionHaveTheSameControlParent()&& !containsBreakContinueSliceNode()&& !containsDuplicateNodeWithStateChangingMethodInvocation())   return true;
  return false;
}","public boolean satisfiesRules(){
  if (!nodeCritetionIsDeclarationOfVariableCriterion() && !variableCriterionIsReturnedVariableInOriginalMethod() && !containsBreakContinueReturnSliceNode()&& !containsDuplicateNodeWithStateChangingMethodInvocation())   return true;
  return false;
}"
12173,"public PDGSlice(PDG pdg,BasicBlock boundaryBlock,PDGNode nodeCriterion,VariableDeclaration localVariableCriterion){
  super();
  this.method=pdg.getMethod();
  this.returnedVariablesInOriginalMethod=pdg.getReturnedVariables();
  this.boundaryBlock=boundaryBlock;
  this.nodeCriterion=nodeCriterion;
  this.localVariableCriterion=localVariableCriterion;
  Set<PDGNode> regionNodes=pdg.blockBasedRegion(boundaryBlock);
  for (  PDGNode node : regionNodes) {
    nodes.add(node);
  }
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    if (nodes.contains(dependence.src) && nodes.contains(dependence.dst))     edges.add(dependence);
  }
  this.sliceNodes=new TreeSet<PDGNode>();
  sliceNodes.addAll(computeSlice(nodeCriterion,localVariableCriterion));
  this.remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.add(pdg.getEntryNode());
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!sliceNodes.contains(pdgNode))     remainingNodes.add(pdgNode);
  }
  this.passedParameters=new LinkedHashSet<VariableDeclaration>();
  Set<PDGNode> nCD=new LinkedHashSet<PDGNode>();
  Set<PDGNode> nDD=new LinkedHashSet<PDGNode>();
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    PDGNode srcPDGNode=(PDGNode)dependence.src;
    PDGNode dstPDGNode=(PDGNode)dependence.dst;
    if (dependence instanceof PDGDataDependence) {
      PDGDataDependence dataDependence=(PDGDataDependence)dependence;
      if (remainingNodes.contains(srcPDGNode) && sliceNodes.contains(dstPDGNode))       passedParameters.add(dataDependence.getData());
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode) && !dataDependence.getData().equals(localVariableCriterion))       nDD.add(dstPDGNode);
    }
 else     if (dependence instanceof PDGControlDependence) {
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode))       nCD.add(dstPDGNode);
    }
  }
  Set<PDGNode> controlIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nCD) {
    for (    VariableDeclaration usedVariable : p.usedVariables) {
      Set<PDGNode> pSliceNodes=computeSlice(p,usedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
  }
  Set<PDGNode> dataIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nDD) {
    for (    VariableDeclaration definedVariable : p.definedVariables) {
      Set<PDGNode> pSliceNodes=computeSlice(p,definedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q))         dataIndispensableNodes.add(q);
      }
    }
  }
  this.indispensableNodes=new TreeSet<PDGNode>();
  indispensableNodes.addAll(controlIndispensableNodes);
  indispensableNodes.addAll(dataIndispensableNodes);
  this.removableNodes=new LinkedHashSet<PDGNode>();
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!remainingNodes.contains(pdgNode) && !indispensableNodes.contains(pdgNode))     removableNodes.add(pdgNode);
  }
}","public PDGSlice(PDG pdg,BasicBlock boundaryBlock,PDGNode nodeCriterion,VariableDeclaration localVariableCriterion){
  super();
  this.method=pdg.getMethod();
  this.returnedVariablesInOriginalMethod=pdg.getReturnedVariables();
  this.boundaryBlock=boundaryBlock;
  this.nodeCriterion=nodeCriterion;
  this.localVariableCriterion=localVariableCriterion;
  Set<PDGNode> regionNodes=pdg.blockBasedRegion(boundaryBlock);
  for (  PDGNode node : regionNodes) {
    nodes.add(node);
  }
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    if (nodes.contains(dependence.src) && nodes.contains(dependence.dst))     edges.add(dependence);
  }
  this.sliceNodes=new TreeSet<PDGNode>();
  sliceNodes.addAll(computeSlice(nodeCriterion,localVariableCriterion));
  this.remainingNodes=new TreeSet<PDGNode>();
  remainingNodes.add(pdg.getEntryNode());
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!sliceNodes.contains(pdgNode))     remainingNodes.add(pdgNode);
  }
  this.passedParameters=new LinkedHashSet<VariableDeclaration>();
  Set<PDGNode> nCD=new LinkedHashSet<PDGNode>();
  Set<PDGNode> nDD=new LinkedHashSet<PDGNode>();
  for (  GraphEdge edge : pdg.edges) {
    PDGDependence dependence=(PDGDependence)edge;
    PDGNode srcPDGNode=(PDGNode)dependence.src;
    PDGNode dstPDGNode=(PDGNode)dependence.dst;
    if (dependence instanceof PDGDataDependence) {
      PDGDataDependence dataDependence=(PDGDataDependence)dependence;
      if (remainingNodes.contains(srcPDGNode) && sliceNodes.contains(dstPDGNode))       passedParameters.add(dataDependence.getData());
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode) && !dataDependence.getData().equals(localVariableCriterion))       nDD.add(dstPDGNode);
    }
 else     if (dependence instanceof PDGControlDependence) {
      if (sliceNodes.contains(srcPDGNode) && remainingNodes.contains(dstPDGNode))       nCD.add(dstPDGNode);
    }
  }
  Set<PDGNode> controlIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nCD) {
    Set<VariableDeclaration> variables=null;
    if (!p.usedVariables.isEmpty())     variables=p.usedVariables;
 else     variables=p.definedVariables;
    for (    VariableDeclaration usedVariable : variables) {
      Set<PDGNode> pSliceNodes=computeSlice(p,usedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q) || q.equals(p))         controlIndispensableNodes.add(q);
      }
    }
  }
  Set<PDGNode> dataIndispensableNodes=new LinkedHashSet<PDGNode>();
  for (  PDGNode p : nDD) {
    for (    VariableDeclaration definedVariable : p.definedVariables) {
      Set<PDGNode> pSliceNodes=computeSlice(p,definedVariable);
      for (      GraphNode node : pdg.nodes) {
        PDGNode q=(PDGNode)node;
        if (pSliceNodes.contains(q))         dataIndispensableNodes.add(q);
      }
    }
  }
  this.indispensableNodes=new TreeSet<PDGNode>();
  indispensableNodes.addAll(controlIndispensableNodes);
  indispensableNodes.addAll(dataIndispensableNodes);
  this.removableNodes=new LinkedHashSet<PDGNode>();
  for (  GraphNode node : pdg.nodes) {
    PDGNode pdgNode=(PDGNode)node;
    if (!remainingNodes.contains(pdgNode) && !indispensableNodes.contains(pdgNode))     removableNodes.add(pdgNode);
  }
}"
12174,"public boolean satisfiesRules(){
  for (  PDGSlice slice : slices) {
    if (!slice.satisfiesRules())     return false;
  }
  return true;
}","public boolean satisfiesRules(){
  for (  PDGSlice slice : slices) {
    if (!slice.satisfiesRules())     return false;
  }
  if (allNodeCriterionsAreDuplicated())   return false;
  if (getSliceNodes().size() <= nodeCriterions.size())   return false;
  return true;
}"
12175,"public PDGSliceUnion(PDG pdg,BasicBlock boundaryBlock,Set<PDGNode> nodeCriterions,VariableDeclaration localVariableCriterion){
  this.slices=new ArrayList<PDGSlice>();
  for (  PDGNode nodeCriterion : nodeCriterions) {
    PDGSlice slice=new PDGSlice(pdg,boundaryBlock,nodeCriterion,localVariableCriterion);
    slices.add(slice);
  }
  this.method=pdg.getMethod();
  this.boundaryBlock=boundaryBlock;
  this.localVariableCriterion=localVariableCriterion;
}","public PDGSliceUnion(PDG pdg,BasicBlock boundaryBlock,Set<PDGNode> nodeCriterions,VariableDeclaration localVariableCriterion){
  this.slices=new ArrayList<PDGSlice>();
  for (  PDGNode nodeCriterion : nodeCriterions) {
    PDGSlice slice=new PDGSlice(pdg,boundaryBlock,nodeCriterion,localVariableCriterion);
    slices.add(slice);
  }
  this.method=pdg.getMethod();
  this.boundaryBlock=boundaryBlock;
  this.nodeCriterions=nodeCriterions;
  this.localVariableCriterion=localVariableCriterion;
}"
12176,"private ASTSlice[] getTable(){
  if (selectedPackage != null)   astReader=new ASTReader(selectedPackage);
 else   astReader=new ASTReader(selectedProject);
  SystemObject systemObject=astReader.getSystemObject();
  List<PDGSliceUnion> extractedSliceUnions=new ArrayList<PDGSliceUnion>();
  ListIterator<ClassObject> classIterator=systemObject.getClassListIterator();
  while (classIterator.hasNext()) {
    ClassObject classObject=classIterator.next();
    ListIterator<MethodObject> methodIterator=classObject.getMethodIterator();
    while (methodIterator.hasNext()) {
      MethodObject methodObject=methodIterator.next();
      if (methodObject.getMethodBody() != null) {
        CFG cfg=new CFG(methodObject);
        PDG pdg=new PDG(cfg);
        for (        VariableDeclaration declaration : pdg.getVariableDeclarationsInMethod()) {
          PDGSliceUnionCollection sliceUnionCollection=new PDGSliceUnionCollection(pdg,declaration);
          for (          PDGSliceUnion sliceUnion : sliceUnionCollection.getSliceUnions()) {
            if (sliceUnion.getSliceNodes().size() > 1)             extractedSliceUnions.add(sliceUnion);
          }
        }
      }
    }
  }
  ASTSlice[] table=new ASTSlice[extractedSliceUnions.size()];
  for (int i=0; i < extractedSliceUnions.size(); i++) {
    ASTSlice astSlice=new ASTSlice(extractedSliceUnions.get(i));
    table[i]=astSlice;
  }
  return table;
}","private ASTSlice[] getTable(){
  if (selectedPackage != null)   astReader=new ASTReader(selectedPackage);
 else   astReader=new ASTReader(selectedProject);
  SystemObject systemObject=astReader.getSystemObject();
  List<PDGSliceUnion> extractedSliceUnions=new ArrayList<PDGSliceUnion>();
  ListIterator<ClassObject> classIterator=systemObject.getClassListIterator();
  while (classIterator.hasNext()) {
    ClassObject classObject=classIterator.next();
    ListIterator<MethodObject> methodIterator=classObject.getMethodIterator();
    while (methodIterator.hasNext()) {
      MethodObject methodObject=methodIterator.next();
      if (methodObject.getMethodBody() != null) {
        CFG cfg=new CFG(methodObject);
        PDG pdg=new PDG(cfg);
        for (        VariableDeclaration declaration : pdg.getVariableDeclarationsInMethod()) {
          PDGSliceUnionCollection sliceUnionCollection=new PDGSliceUnionCollection(pdg,declaration);
          for (          PDGSliceUnion sliceUnion : sliceUnionCollection.getSliceUnions()) {
            extractedSliceUnions.add(sliceUnion);
          }
        }
      }
    }
  }
  ASTSlice[] table=new ASTSlice[extractedSliceUnions.size()];
  for (int i=0; i < extractedSliceUnions.size(); i++) {
    ASTSlice astSlice=new ASTSlice(extractedSliceUnions.get(i));
    table[i]=astSlice;
  }
  return table;
}"
12177,"public TypeCheckEliminationResults generateTypeCheckEliminations(){
  TypeCheckEliminationResults typeCheckEliminationResults=new TypeCheckEliminationResults();
  Map<TypeCheckElimination,List<SimpleName>> staticFieldMap=new LinkedHashMap<TypeCheckElimination,List<SimpleName>>();
  Map<Integer,ArrayList<TypeCheckElimination>> staticFieldRankMap=new TreeMap<Integer,ArrayList<TypeCheckElimination>>();
  Map<String,ArrayList<TypeCheckElimination>> inheritanceTreeMap=new LinkedHashMap<String,ArrayList<TypeCheckElimination>>();
  CompleteInheritanceDetection inheritanceDetection=new CompleteInheritanceDetection(this);
  for (  ClassObject classObject : classList) {
    List<TypeCheckElimination> eliminations=classObject.generateTypeCheckEliminations();
    for (    TypeCheckElimination elimination : eliminations) {
      List<SimpleName> staticFields=elimination.getStaticFields();
      if (!staticFields.isEmpty()) {
        if (allStaticFieldsWithinSystemBoundary(staticFields)) {
          inheritanceHierarchyMatchingWithStaticTypes(elimination,inheritanceDetection);
          boolean isValid=false;
          if (elimination.getTypeField() != null) {
            IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
            ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
            if ((typeFieldTypeBinding.isPrimitive() && typeFieldTypeBinding.getQualifiedName().equals(""String_Node_Str"")) || typeFieldTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeLocalVariable() != null) {
            IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
            ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
            if ((typeLocalVariableTypeBinding.isPrimitive() && typeLocalVariableTypeBinding.getQualifiedName().equals(""String_Node_Str"")) || typeLocalVariableTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeMethodInvocation() != null) {
            MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
            IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
            ITypeBinding typeMethodInvocationDeclaringClass=typeMethodInvocationBinding.getDeclaringClass();
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            ClassObject declaringClassObject=getClassObject(typeMethodInvocationDeclaringClass.getQualifiedName());
            if (((typeMethodInvocationReturnType.isPrimitive() && typeMethodInvocationReturnType.getQualifiedName().equals(""String_Node_Str"")) || typeMethodInvocationReturnType.isEnum()) && declaringClassObject != null) {
              MethodDeclaration invokedMethodDeclaration=null;
              ListIterator<MethodObject> methodIterator=declaringClassObject.getMethodIterator();
              while (methodIterator.hasNext()) {
                MethodObject methodObject=methodIterator.next();
                MethodDeclaration methodDeclaration=methodObject.getMethodDeclaration();
                if (typeMethodInvocationBinding.isEqualTo(methodDeclaration.resolveBinding())) {
                  invokedMethodDeclaration=methodDeclaration;
                  break;
                }
              }
              SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(invokedMethodDeclaration);
              if (fieldInstruction != null) {
                ListIterator<FieldObject> fieldIterator=declaringClassObject.getFieldIterator();
                while (fieldIterator.hasNext()) {
                  FieldObject fieldObject=fieldIterator.next();
                  VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                  if (fieldInstruction.resolveBinding().isEqualTo(fragment.resolveBinding())) {
                    elimination.setForeignTypeField(fragment);
                    break;
                  }
                }
                isValid=true;
              }
 else               if (invokedMethodDeclaration.getBody() == null) {
                InheritanceTree tree=elimination.getInheritanceTreeMatchingWithStaticTypes();
                if (tree != null) {
                  Expression typeMethodInvocationExpression=typeMethodInvocation.getExpression();
                  ITypeBinding typeCheckClassBinding=elimination.getTypeCheckClass().resolveBinding();
                  ClassObject typeCheckClassObject=getClassObject(typeCheckClassBinding.getQualifiedName());
                  SimpleName invoker=null;
                  if (typeMethodInvocationExpression instanceof SimpleName) {
                    invoker=(SimpleName)typeMethodInvocationExpression;
                  }
 else                   if (typeMethodInvocationExpression instanceof FieldAccess) {
                    FieldAccess fieldAccess=(FieldAccess)typeMethodInvocationExpression;
                    invoker=fieldAccess.getName();
                  }
                  if (invoker != null) {
                    IBinding binding=invoker.resolveBinding();
                    if (binding.getKind() == IBinding.VARIABLE) {
                      IVariableBinding variableBinding=(IVariableBinding)binding;
                      if (variableBinding.isField()) {
                        ListIterator<FieldObject> fieldIterator=typeCheckClassObject.getFieldIterator();
                        while (fieldIterator.hasNext()) {
                          FieldObject fieldObject=fieldIterator.next();
                          VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                          if (variableBinding.isEqualTo(fragment.resolveBinding())) {
                            elimination.setTypeField(fragment);
                            break;
                          }
                        }
                      }
 else                       if (variableBinding.isParameter()) {
                        List<SingleVariableDeclaration> parameters=elimination.getTypeCheckMethodParameters();
                        for (                        SingleVariableDeclaration parameter : parameters) {
                          IVariableBinding parameterVariableBinding=parameter.resolveBinding();
                          if (parameterVariableBinding.isEqualTo(variableBinding)) {
                            elimination.setTypeLocalVariable(parameter);
                            break;
                          }
                        }
                      }
 else {
                        StatementExtractor statementExtractor=new StatementExtractor();
                        Block typeCheckMethodBody=elimination.getTypeCheckMethod().getBody();
                        List<Statement> variableDeclarationStatements=statementExtractor.getVariableDeclarations(typeCheckMethodBody);
                        for (                        Statement vDStatement : variableDeclarationStatements) {
                          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
                          List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
                          for (                          VariableDeclarationFragment fragment : fragments) {
                            IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                            if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                              elimination.setTypeLocalVariable(fragment);
                              break;
                            }
                          }
                        }
                        List<Statement> enhancedForStatements=statementExtractor.getEnhancedForStatements(typeCheckMethodBody);
                        for (                        Statement eFStatement : enhancedForStatements) {
                          EnhancedForStatement enhancedForStatement=(EnhancedForStatement)eFStatement;
                          SingleVariableDeclaration formalParameter=enhancedForStatement.getParameter();
                          IVariableBinding parameterVariableBinding=formalParameter.resolveBinding();
                          if (parameterVariableBinding.isEqualTo(variableBinding)) {
                            elimination.setTypeLocalVariable(formalParameter);
                            break;
                          }
                        }
                      }
                      ITypeBinding invokerType=variableBinding.getType();
                      if (invokerType.getQualifiedName().equals(tree.getRootNode().getUserObject())) {
                        elimination.setExistingInheritanceTree(tree);
                        if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
                          ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
                          typeCheckEliminations.add(elimination);
                        }
 else {
                          ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                          typeCheckEliminations.add(elimination);
                          inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (isValid) {
            staticFieldMap.put(elimination,staticFields);
            int size=staticFields.size();
            if (staticFieldRankMap.containsKey(size)) {
              ArrayList<TypeCheckElimination> rank=staticFieldRankMap.get(size);
              rank.add(elimination);
            }
 else {
              ArrayList<TypeCheckElimination> rank=new ArrayList<TypeCheckElimination>();
              rank.add(elimination);
              staticFieldRankMap.put(size,rank);
            }
          }
        }
      }
 else {
        if (elimination.getTypeField() != null) {
          IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
          ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeFieldTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeLocalVariable() != null) {
          IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
          ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeLocalVariableTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeMethodInvocation() != null) {
          MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
          IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
          if (typeMethodInvocationBinding.getDeclaringClass().getQualifiedName().equals(""String_Node_Str"") && typeMethodInvocationBinding.getName().equals(""String_Node_Str"")) {
            Expression typeMethodInvocationExpression=typeMethodInvocation.getExpression();
            ITypeBinding typeCheckClassBinding=elimination.getTypeCheckClass().resolveBinding();
            ClassObject typeCheckClassObject=getClassObject(typeCheckClassBinding.getQualifiedName());
            SimpleName invoker=null;
            if (typeMethodInvocationExpression instanceof SimpleName) {
              invoker=(SimpleName)typeMethodInvocationExpression;
            }
 else             if (typeMethodInvocationExpression instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)typeMethodInvocationExpression;
              invoker=fieldAccess.getName();
            }
            if (invoker != null) {
              IBinding binding=invoker.resolveBinding();
              if (binding.getKind() == IBinding.VARIABLE) {
                IVariableBinding variableBinding=(IVariableBinding)binding;
                if (variableBinding.isField()) {
                  ListIterator<FieldObject> fieldIterator=typeCheckClassObject.getFieldIterator();
                  while (fieldIterator.hasNext()) {
                    FieldObject fieldObject=fieldIterator.next();
                    VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                    if (variableBinding.isEqualTo(fragment.resolveBinding())) {
                      elimination.setTypeField(fragment);
                      break;
                    }
                  }
                }
 else                 if (variableBinding.isParameter()) {
                  List<SingleVariableDeclaration> parameters=elimination.getTypeCheckMethodParameters();
                  for (                  SingleVariableDeclaration parameter : parameters) {
                    IVariableBinding parameterVariableBinding=parameter.resolveBinding();
                    if (parameterVariableBinding.isEqualTo(variableBinding)) {
                      elimination.setTypeLocalVariable(parameter);
                      break;
                    }
                  }
                }
 else {
                  StatementExtractor statementExtractor=new StatementExtractor();
                  Block typeCheckMethodBody=elimination.getTypeCheckMethod().getBody();
                  List<Statement> variableDeclarationStatements=statementExtractor.getVariableDeclarations(typeCheckMethodBody);
                  for (                  Statement vDStatement : variableDeclarationStatements) {
                    VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
                    List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                      if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                        elimination.setTypeLocalVariable(fragment);
                        break;
                      }
                    }
                  }
                  List<Statement> enhancedForStatements=statementExtractor.getEnhancedForStatements(typeCheckMethodBody);
                  for (                  Statement eFStatement : enhancedForStatements) {
                    EnhancedForStatement enhancedForStatement=(EnhancedForStatement)eFStatement;
                    SingleVariableDeclaration formalParameter=enhancedForStatement.getParameter();
                    IVariableBinding parameterVariableBinding=formalParameter.resolveBinding();
                    if (parameterVariableBinding.isEqualTo(variableBinding)) {
                      elimination.setTypeLocalVariable(formalParameter);
                      break;
                    }
                  }
                }
                ITypeBinding invokerType=variableBinding.getType();
                InheritanceTree tree=inheritanceDetection.getTree(invokerType.getQualifiedName());
                elimination.setExistingInheritanceTree(tree);
              }
            }
          }
 else {
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            InheritanceTree tree=inheritanceDetection.getTree(typeMethodInvocationReturnType.getQualifiedName());
            elimination.setExistingInheritanceTree(tree);
          }
        }
        if (elimination.getExistingInheritanceTree() != null) {
          InheritanceTree tree=elimination.getExistingInheritanceTree();
          if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
            ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
            typeCheckEliminations.add(elimination);
          }
 else {
            ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
            typeCheckEliminations.add(elimination);
            inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
          }
        }
      }
    }
  }
  for (  String rootNode : inheritanceTreeMap.keySet()) {
    ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(rootNode);
    typeCheckEliminationResults.addGroup(typeCheckEliminations);
  }
  List<TypeCheckElimination> sortedEliminations=new ArrayList<TypeCheckElimination>();
  List<Integer> keyList=new ArrayList<Integer>(staticFieldRankMap.keySet());
  ListIterator<Integer> keyListIterator=keyList.listIterator(keyList.size());
  while (keyListIterator.hasPrevious()) {
    Integer states=keyListIterator.previous();
    sortedEliminations.addAll(staticFieldRankMap.get(states));
  }
  while (!sortedEliminations.isEmpty()) {
    TypeCheckElimination selectedElimination=sortedEliminations.get(0);
    List<TypeCheckElimination> affectedEliminations=new ArrayList<TypeCheckElimination>();
    affectedEliminations.add(selectedElimination);
    List<SimpleName> staticFieldUnion=staticFieldMap.get(selectedElimination);
    for (    TypeCheckElimination elimination : sortedEliminations) {
      List<SimpleName> staticFields=staticFieldMap.get(elimination);
      if (!selectedElimination.equals(elimination) && nonEmptyIntersection(staticFieldUnion,staticFields)) {
        staticFieldUnion=constructUnion(staticFieldUnion,staticFields);
        affectedEliminations.add(elimination);
      }
    }
    if (affectedEliminations.size() > 1) {
      for (      TypeCheckElimination elimination : affectedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        for (        SimpleName simpleName1 : staticFieldUnion) {
          boolean isContained=false;
          for (          SimpleName simpleName2 : staticFields) {
            if (simpleName1.resolveBinding().isEqualTo(simpleName2.resolveBinding())) {
              isContained=true;
              break;
            }
          }
          if (!isContained)           elimination.addAdditionalStaticField(simpleName1);
        }
      }
    }
    ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
    for (    TypeCheckElimination elimination : affectedEliminations) {
      if (!elimination.isTypeCheckMethodStateSetter())       typeCheckEliminations.add(elimination);
    }
    typeCheckEliminationResults.addGroup(typeCheckEliminations);
    sortedEliminations.removeAll(affectedEliminations);
  }
  identifySuperFieldAccessorMethods(typeCheckEliminationResults.getTypeCheckEliminations());
  return typeCheckEliminationResults;
}","public TypeCheckEliminationResults generateTypeCheckEliminations(){
  TypeCheckEliminationResults typeCheckEliminationResults=new TypeCheckEliminationResults();
  Map<TypeCheckElimination,List<SimpleName>> staticFieldMap=new LinkedHashMap<TypeCheckElimination,List<SimpleName>>();
  Map<Integer,ArrayList<TypeCheckElimination>> staticFieldRankMap=new TreeMap<Integer,ArrayList<TypeCheckElimination>>();
  Map<String,ArrayList<TypeCheckElimination>> inheritanceTreeMap=new LinkedHashMap<String,ArrayList<TypeCheckElimination>>();
  CompleteInheritanceDetection inheritanceDetection=new CompleteInheritanceDetection(this);
  for (  ClassObject classObject : classList) {
    List<TypeCheckElimination> eliminations=classObject.generateTypeCheckEliminations();
    for (    TypeCheckElimination elimination : eliminations) {
      List<SimpleName> staticFields=elimination.getStaticFields();
      if (!staticFields.isEmpty()) {
        if (allStaticFieldsWithinSystemBoundary(staticFields)) {
          inheritanceHierarchyMatchingWithStaticTypes(elimination,inheritanceDetection);
          boolean isValid=false;
          if (elimination.getTypeField() != null) {
            IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
            ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
            if ((typeFieldTypeBinding.isPrimitive() && typeFieldTypeBinding.getQualifiedName().equals(""String_Node_Str"")) || typeFieldTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeLocalVariable() != null) {
            IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
            ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
            if ((typeLocalVariableTypeBinding.isPrimitive() && typeLocalVariableTypeBinding.getQualifiedName().equals(""String_Node_Str"")) || typeLocalVariableTypeBinding.isEnum()) {
              isValid=true;
            }
          }
 else           if (elimination.getTypeMethodInvocation() != null) {
            MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
            IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
            ITypeBinding typeMethodInvocationDeclaringClass=typeMethodInvocationBinding.getDeclaringClass();
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            ClassObject declaringClassObject=getClassObject(typeMethodInvocationDeclaringClass.getQualifiedName());
            if (((typeMethodInvocationReturnType.isPrimitive() && typeMethodInvocationReturnType.getQualifiedName().equals(""String_Node_Str"")) || typeMethodInvocationReturnType.isEnum()) && declaringClassObject != null) {
              MethodDeclaration invokedMethodDeclaration=null;
              ListIterator<MethodObject> methodIterator=declaringClassObject.getMethodIterator();
              while (methodIterator.hasNext()) {
                MethodObject methodObject=methodIterator.next();
                MethodDeclaration methodDeclaration=methodObject.getMethodDeclaration();
                if (typeMethodInvocationBinding.isEqualTo(methodDeclaration.resolveBinding())) {
                  invokedMethodDeclaration=methodDeclaration;
                  break;
                }
              }
              SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(invokedMethodDeclaration);
              if (fieldInstruction != null) {
                ListIterator<FieldObject> fieldIterator=declaringClassObject.getFieldIterator();
                while (fieldIterator.hasNext()) {
                  FieldObject fieldObject=fieldIterator.next();
                  VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                  if (fieldInstruction.resolveBinding().isEqualTo(fragment.resolveBinding())) {
                    elimination.setForeignTypeField(fragment);
                    break;
                  }
                }
                isValid=true;
              }
 else               if (invokedMethodDeclaration.getBody() == null) {
                InheritanceTree tree=elimination.getInheritanceTreeMatchingWithStaticTypes();
                if (tree != null) {
                  Expression typeMethodInvocationExpression=typeMethodInvocation.getExpression();
                  ITypeBinding typeCheckClassBinding=elimination.getTypeCheckClass().resolveBinding();
                  ClassObject typeCheckClassObject=getClassObject(typeCheckClassBinding.getQualifiedName());
                  SimpleName invoker=null;
                  if (typeMethodInvocationExpression instanceof SimpleName) {
                    invoker=(SimpleName)typeMethodInvocationExpression;
                  }
 else                   if (typeMethodInvocationExpression instanceof FieldAccess) {
                    FieldAccess fieldAccess=(FieldAccess)typeMethodInvocationExpression;
                    invoker=fieldAccess.getName();
                  }
                  if (invoker != null) {
                    IBinding binding=invoker.resolveBinding();
                    if (binding.getKind() == IBinding.VARIABLE) {
                      IVariableBinding variableBinding=(IVariableBinding)binding;
                      if (variableBinding.isField()) {
                        ListIterator<FieldObject> fieldIterator=typeCheckClassObject.getFieldIterator();
                        while (fieldIterator.hasNext()) {
                          FieldObject fieldObject=fieldIterator.next();
                          VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                          if (variableBinding.isEqualTo(fragment.resolveBinding())) {
                            elimination.setTypeField(fragment);
                            break;
                          }
                        }
                      }
 else                       if (variableBinding.isParameter()) {
                        List<SingleVariableDeclaration> parameters=elimination.getTypeCheckMethodParameters();
                        for (                        SingleVariableDeclaration parameter : parameters) {
                          IVariableBinding parameterVariableBinding=parameter.resolveBinding();
                          if (parameterVariableBinding.isEqualTo(variableBinding)) {
                            elimination.setTypeLocalVariable(parameter);
                            break;
                          }
                        }
                      }
 else {
                        StatementExtractor statementExtractor=new StatementExtractor();
                        Block typeCheckMethodBody=elimination.getTypeCheckMethod().getBody();
                        List<Statement> variableDeclarationStatements=statementExtractor.getVariableDeclarations(typeCheckMethodBody);
                        for (                        Statement vDStatement : variableDeclarationStatements) {
                          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
                          List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
                          for (                          VariableDeclarationFragment fragment : fragments) {
                            IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                            if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                              elimination.setTypeLocalVariable(fragment);
                              break;
                            }
                          }
                        }
                        List<Statement> enhancedForStatements=statementExtractor.getEnhancedForStatements(typeCheckMethodBody);
                        for (                        Statement eFStatement : enhancedForStatements) {
                          EnhancedForStatement enhancedForStatement=(EnhancedForStatement)eFStatement;
                          SingleVariableDeclaration formalParameter=enhancedForStatement.getParameter();
                          IVariableBinding parameterVariableBinding=formalParameter.resolveBinding();
                          if (parameterVariableBinding.isEqualTo(variableBinding)) {
                            elimination.setTypeLocalVariable(formalParameter);
                            break;
                          }
                        }
                      }
                      ITypeBinding invokerType=variableBinding.getType();
                      if (invokerType.getQualifiedName().equals(tree.getRootNode().getUserObject())) {
                        elimination.setExistingInheritanceTree(tree);
                        if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
                          ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
                          typeCheckEliminations.add(elimination);
                        }
 else {
                          ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
                          typeCheckEliminations.add(elimination);
                          inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (isValid) {
            staticFieldMap.put(elimination,staticFields);
            int size=staticFields.size();
            if (staticFieldRankMap.containsKey(size)) {
              ArrayList<TypeCheckElimination> rank=staticFieldRankMap.get(size);
              rank.add(elimination);
            }
 else {
              ArrayList<TypeCheckElimination> rank=new ArrayList<TypeCheckElimination>();
              rank.add(elimination);
              staticFieldRankMap.put(size,rank);
            }
          }
        }
      }
 else {
        if (elimination.getTypeField() != null) {
          IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
          ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeFieldTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeLocalVariable() != null) {
          IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
          ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeLocalVariableTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeMethodInvocation() != null) {
          MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
          IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
          if (typeMethodInvocationBinding.getDeclaringClass().getQualifiedName().equals(""String_Node_Str"") && typeMethodInvocationBinding.getName().equals(""String_Node_Str"")) {
            Expression typeMethodInvocationExpression=typeMethodInvocation.getExpression();
            ITypeBinding typeCheckClassBinding=elimination.getTypeCheckClass().resolveBinding();
            ClassObject typeCheckClassObject=getClassObject(typeCheckClassBinding.getQualifiedName());
            SimpleName invoker=null;
            if (typeMethodInvocationExpression instanceof SimpleName) {
              invoker=(SimpleName)typeMethodInvocationExpression;
            }
 else             if (typeMethodInvocationExpression instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)typeMethodInvocationExpression;
              invoker=fieldAccess.getName();
            }
            if (invoker != null) {
              IBinding binding=invoker.resolveBinding();
              if (binding.getKind() == IBinding.VARIABLE) {
                IVariableBinding variableBinding=(IVariableBinding)binding;
                if (variableBinding.isField()) {
                  ListIterator<FieldObject> fieldIterator=typeCheckClassObject.getFieldIterator();
                  while (fieldIterator.hasNext()) {
                    FieldObject fieldObject=fieldIterator.next();
                    VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                    if (variableBinding.isEqualTo(fragment.resolveBinding())) {
                      elimination.setTypeField(fragment);
                      break;
                    }
                  }
                }
 else                 if (variableBinding.isParameter()) {
                  List<SingleVariableDeclaration> parameters=elimination.getTypeCheckMethodParameters();
                  for (                  SingleVariableDeclaration parameter : parameters) {
                    IVariableBinding parameterVariableBinding=parameter.resolveBinding();
                    if (parameterVariableBinding.isEqualTo(variableBinding)) {
                      elimination.setTypeLocalVariable(parameter);
                      break;
                    }
                  }
                }
 else {
                  StatementExtractor statementExtractor=new StatementExtractor();
                  Block typeCheckMethodBody=elimination.getTypeCheckMethod().getBody();
                  List<Statement> variableDeclarationStatements=statementExtractor.getVariableDeclarations(typeCheckMethodBody);
                  for (                  Statement vDStatement : variableDeclarationStatements) {
                    VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
                    List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                      if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                        elimination.setTypeLocalVariable(fragment);
                        break;
                      }
                    }
                  }
                  List<Statement> enhancedForStatements=statementExtractor.getEnhancedForStatements(typeCheckMethodBody);
                  for (                  Statement eFStatement : enhancedForStatements) {
                    EnhancedForStatement enhancedForStatement=(EnhancedForStatement)eFStatement;
                    SingleVariableDeclaration formalParameter=enhancedForStatement.getParameter();
                    IVariableBinding parameterVariableBinding=formalParameter.resolveBinding();
                    if (parameterVariableBinding.isEqualTo(variableBinding)) {
                      elimination.setTypeLocalVariable(formalParameter);
                      break;
                    }
                  }
                }
                ITypeBinding invokerType=variableBinding.getType();
                InheritanceTree tree=inheritanceDetection.getTree(invokerType.getQualifiedName());
                elimination.setExistingInheritanceTree(tree);
              }
            }
          }
 else {
            ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
            InheritanceTree tree=inheritanceDetection.getTree(typeMethodInvocationReturnType.getQualifiedName());
            elimination.setExistingInheritanceTree(tree);
          }
        }
        if (elimination.getExistingInheritanceTree() != null) {
          InheritanceTree tree=elimination.getExistingInheritanceTree();
          if (inheritanceTreeMap.containsKey(tree.getRootNode().getUserObject())) {
            ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(tree.getRootNode().getUserObject());
            typeCheckEliminations.add(elimination);
          }
 else {
            ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
            typeCheckEliminations.add(elimination);
            inheritanceTreeMap.put((String)tree.getRootNode().getUserObject(),typeCheckEliminations);
          }
        }
      }
    }
  }
  for (  String rootNode : inheritanceTreeMap.keySet()) {
    ArrayList<TypeCheckElimination> typeCheckEliminations=inheritanceTreeMap.get(rootNode);
    typeCheckEliminationResults.addGroup(typeCheckEliminations);
  }
  List<TypeCheckElimination> sortedEliminations=new ArrayList<TypeCheckElimination>();
  List<Integer> keyList=new ArrayList<Integer>(staticFieldRankMap.keySet());
  ListIterator<Integer> keyListIterator=keyList.listIterator(keyList.size());
  while (keyListIterator.hasPrevious()) {
    Integer states=keyListIterator.previous();
    sortedEliminations.addAll(staticFieldRankMap.get(states));
  }
  while (!sortedEliminations.isEmpty()) {
    TypeCheckElimination selectedElimination=sortedEliminations.get(0);
    List<TypeCheckElimination> affectedEliminations=new ArrayList<TypeCheckElimination>();
    affectedEliminations.add(selectedElimination);
    List<SimpleName> staticFieldUnion=staticFieldMap.get(selectedElimination);
    boolean staticFieldUnionIncreased=true;
    while (staticFieldUnionIncreased) {
      staticFieldUnionIncreased=false;
      for (      TypeCheckElimination elimination : sortedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        if (!affectedEliminations.contains(elimination) && nonEmptyIntersection(staticFieldUnion,staticFields)) {
          staticFieldUnion=constructUnion(staticFieldUnion,staticFields);
          affectedEliminations.add(elimination);
          staticFieldUnionIncreased=true;
        }
      }
    }
    if (affectedEliminations.size() > 1) {
      for (      TypeCheckElimination elimination : affectedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        for (        SimpleName simpleName1 : staticFieldUnion) {
          boolean isContained=false;
          for (          SimpleName simpleName2 : staticFields) {
            if (simpleName1.resolveBinding().isEqualTo(simpleName2.resolveBinding())) {
              isContained=true;
              break;
            }
          }
          if (!isContained)           elimination.addAdditionalStaticField(simpleName1);
        }
      }
    }
    ArrayList<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
    for (    TypeCheckElimination elimination : affectedEliminations) {
      if (!elimination.isTypeCheckMethodStateSetter())       typeCheckEliminations.add(elimination);
    }
    typeCheckEliminationResults.addGroup(typeCheckEliminations);
    sortedEliminations.removeAll(affectedEliminations);
  }
  identifySuperFieldAccessorMethods(typeCheckEliminationResults.getTypeCheckEliminations());
  return typeCheckEliminationResults;
}"
12178,"private void modifySourceVariableInstructionsInSubclass(List<Expression> oldVariableInstructions,List<Expression> newVariableInstructions,AST subclassAST,ASTRewrite subclassRewriter,Set<VariableDeclarationFragment> accessedFields,Set<VariableDeclarationFragment> assignedFields,Set<IVariableBinding> superAccessedFields,Set<IVariableBinding> superAssignedFields){
  int j=0;
  Set<IVariableBinding> accessedFieldBindings=new LinkedHashSet<IVariableBinding>();
  for (  VariableDeclarationFragment fragment : accessedFields) {
    accessedFieldBindings.add(fragment.resolveBinding());
  }
  accessedFieldBindings.addAll(superAccessedFields);
  Set<IVariableBinding> assignedFieldBindings=new LinkedHashSet<IVariableBinding>();
  for (  VariableDeclarationFragment fragment : assignedFields) {
    assignedFieldBindings.add(fragment.resolveBinding());
  }
  assignedFieldBindings.addAll(superAccessedFields);
  for (  Expression expression : newVariableInstructions) {
    SimpleName newSimpleName=(SimpleName)expression;
    SimpleName oldSimpleName=(SimpleName)oldVariableInstructions.get(j);
    Expression newParentExpression=null;
    Expression oldParentExpression=null;
    if (newSimpleName.getParent() instanceof QualifiedName) {
      newParentExpression=(QualifiedName)newSimpleName.getParent();
      oldParentExpression=(QualifiedName)oldSimpleName.getParent();
    }
 else     if (newSimpleName.getParent() instanceof FieldAccess) {
      newParentExpression=(FieldAccess)newSimpleName.getParent();
      oldParentExpression=(FieldAccess)oldSimpleName.getParent();
    }
 else {
      newParentExpression=newSimpleName;
      oldParentExpression=oldSimpleName;
    }
    if (newParentExpression.getParent() instanceof Assignment) {
      Assignment newAssignment=(Assignment)newParentExpression.getParent();
      Assignment oldAssignment=(Assignment)oldParentExpression.getParent();
      Expression newLeftHandSide=newAssignment.getLeftHandSide();
      Expression oldLeftHandSide=oldAssignment.getLeftHandSide();
      SimpleName newLeftHandSideName=null;
      SimpleName oldLeftHandSideName=null;
      if (newLeftHandSide instanceof SimpleName) {
        newLeftHandSideName=(SimpleName)newLeftHandSide;
        oldLeftHandSideName=(SimpleName)oldLeftHandSide;
      }
 else       if (newLeftHandSide instanceof QualifiedName) {
        QualifiedName newLeftHandSideQualifiedName=(QualifiedName)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideQualifiedName.getName();
        QualifiedName oldLeftHandSideQualifiedName=(QualifiedName)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideQualifiedName.getName();
      }
 else       if (newLeftHandSide instanceof FieldAccess) {
        FieldAccess newLeftHandSideFieldAccess=(FieldAccess)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideFieldAccess.getName();
        FieldAccess oldLeftHandSideFieldAccess=(FieldAccess)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideFieldAccess.getName();
      }
      Expression newRightHandSide=newAssignment.getRightHandSide();
      Expression oldRightHandSide=oldAssignment.getRightHandSide();
      SimpleName newRightHandSideName=null;
      SimpleName oldRightHandSideName=null;
      if (newRightHandSide instanceof SimpleName) {
        newRightHandSideName=(SimpleName)newRightHandSide;
        oldRightHandSideName=(SimpleName)oldRightHandSide;
      }
 else       if (newRightHandSide instanceof QualifiedName) {
        QualifiedName newRightHandSideQualifiedName=(QualifiedName)newRightHandSide;
        newRightHandSideName=newRightHandSideQualifiedName.getName();
        QualifiedName oldRightHandSideQualifiedName=(QualifiedName)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideQualifiedName.getName();
      }
 else       if (newRightHandSide instanceof FieldAccess) {
        FieldAccess newRightHandSideFieldAccess=(FieldAccess)newRightHandSide;
        newRightHandSideName=newRightHandSideFieldAccess.getName();
        FieldAccess oldRightHandSideFieldAccess=(FieldAccess)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideFieldAccess.getName();
      }
      String invokerName=sourceTypeDeclaration.getName().getIdentifier();
      invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
      if (newLeftHandSideName != null && newLeftHandSideName.equals(newSimpleName)) {
        for (        IVariableBinding assignedFieldBinding : assignedFieldBindings) {
          if (assignedFieldBinding.isEqualTo(oldLeftHandSideName.resolveBinding())) {
            IMethodBinding setterMethodBinding=null;
            if (superAssignedFields.contains(assignedFieldBinding)) {
              setterMethodBinding=typeCheckElimination.getSetterMethodBindingOfSuperAssignedField(assignedFieldBinding);
            }
 else {
              setterMethodBinding=findSetterMethodInContext(assignedFieldBinding);
            }
            String leftHandMethodName;
            if (setterMethodBinding != null) {
              leftHandMethodName=setterMethodBinding.getName();
            }
 else {
              leftHandMethodName=assignedFieldBinding.getName();
              leftHandMethodName=""String_Node_Str"" + leftHandMethodName.substring(0,1).toUpperCase() + leftHandMethodName.substring(1,leftHandMethodName.length());
            }
            MethodInvocation leftHandMethodInvocation=subclassAST.newMethodInvocation();
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(leftHandMethodName),null);
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            ListRewrite methodInvocationArgumentsRewrite=subclassRewriter.getListRewrite(leftHandMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            if (newRightHandSideName != null) {
              boolean accessedFieldFound=false;
              for (              IVariableBinding accessedFieldBinding : accessedFieldBindings) {
                if (accessedFieldBinding.isEqualTo(oldRightHandSideName.resolveBinding())) {
                  IMethodBinding getterMethodBinding=null;
                  if (superAccessedFields.contains(accessedFieldBinding)) {
                    getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
                  }
 else {
                    getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
                  }
                  String rightHandMethodName;
                  if (getterMethodBinding != null) {
                    rightHandMethodName=getterMethodBinding.getName();
                  }
 else {
                    rightHandMethodName=accessedFieldBinding.getName();
                    rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
                  }
                  MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
                  subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
                  subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
                  methodInvocationArgumentsRewrite.insertLast(rightHandMethodInvocation,null);
                  accessedFieldFound=true;
                  break;
                }
              }
              if (!accessedFieldFound)               methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
 else {
              methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
            subclassRewriter.replace(newAssignment,leftHandMethodInvocation,null);
            break;
          }
        }
      }
      if (newRightHandSideName != null && newRightHandSideName.equals(newSimpleName)) {
        for (        IVariableBinding accessedFieldBinding : accessedFieldBindings) {
          if (accessedFieldBinding.isEqualTo(oldRightHandSideName.resolveBinding())) {
            IMethodBinding getterMethodBinding=null;
            if (superAccessedFields.contains(accessedFieldBinding)) {
              getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
            }
 else {
              getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
            }
            String rightHandMethodName;
            if (getterMethodBinding != null) {
              rightHandMethodName=getterMethodBinding.getName();
            }
 else {
              rightHandMethodName=accessedFieldBinding.getName();
              rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
            }
            MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
            subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
            subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            subclassRewriter.set(newAssignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,rightHandMethodInvocation,null);
            break;
          }
        }
        IBinding oldRightHandSideNameBinding=oldRightHandSideName.resolveBinding();
        if (oldRightHandSideNameBinding.getKind() == IBinding.VARIABLE) {
          IVariableBinding oldRightHandSideNameVariableBinding=(IVariableBinding)oldRightHandSideNameBinding;
          if ((oldRightHandSideNameVariableBinding.getModifiers() & Modifier.STATIC) != 0 && (oldRightHandSideNameVariableBinding.getModifiers() & Modifier.PUBLIC) != 0) {
            SimpleName qualifier=subclassAST.newSimpleName(oldRightHandSideNameVariableBinding.getDeclaringClass().getName());
            if (newRightHandSideName.getParent() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)newRightHandSideName.getParent();
              subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
            }
 else             if (!(newRightHandSideName.getParent() instanceof QualifiedName)) {
              SimpleName simpleName=subclassAST.newSimpleName(newRightHandSideName.getIdentifier());
              QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
              subclassRewriter.replace(newRightHandSideName,newQualifiedName,null);
            }
          }
        }
      }
    }
 else {
      for (      IVariableBinding accessedFieldBinding : accessedFieldBindings) {
        if (accessedFieldBinding.isEqualTo(oldSimpleName.resolveBinding())) {
          IMethodBinding getterMethodBinding=null;
          if (superAccessedFields.contains(accessedFieldBinding)) {
            getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
          }
 else {
            getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
          }
          String methodName;
          if (getterMethodBinding != null) {
            methodName=getterMethodBinding.getName();
          }
 else {
            methodName=accessedFieldBinding.getName();
            methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
          }
          MethodInvocation methodInvocation=subclassAST.newMethodInvocation();
          subclassRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(methodName),null);
          String invokerName=sourceTypeDeclaration.getName().getIdentifier();
          invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
          subclassRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
          subclassRewriter.replace(newSimpleName,methodInvocation,null);
          break;
        }
      }
      IBinding oldSimpleNameBinding=oldSimpleName.resolveBinding();
      if (oldSimpleNameBinding.getKind() == IBinding.VARIABLE) {
        IVariableBinding oldSimpleNameVariableBinding=(IVariableBinding)oldSimpleNameBinding;
        if ((oldSimpleNameVariableBinding.getModifiers() & Modifier.STATIC) != 0 && (oldSimpleNameVariableBinding.getModifiers() & Modifier.PUBLIC) != 0) {
          SimpleName qualifier=subclassAST.newSimpleName(oldSimpleNameVariableBinding.getDeclaringClass().getName());
          if (newSimpleName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
            subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
          }
 else           if (!(newSimpleName.getParent() instanceof QualifiedName)) {
            SimpleName simpleName=subclassAST.newSimpleName(newSimpleName.getIdentifier());
            QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
            subclassRewriter.replace(newSimpleName,newQualifiedName,null);
          }
        }
      }
    }
    j++;
  }
}","private void modifySourceVariableInstructionsInSubclass(List<Expression> oldVariableInstructions,List<Expression> newVariableInstructions,AST subclassAST,ASTRewrite subclassRewriter,Set<VariableDeclarationFragment> accessedFields,Set<VariableDeclarationFragment> assignedFields,Set<IVariableBinding> superAccessedFields,Set<IVariableBinding> superAssignedFields){
  int j=0;
  Set<IVariableBinding> accessedFieldBindings=new LinkedHashSet<IVariableBinding>();
  for (  VariableDeclarationFragment fragment : accessedFields) {
    accessedFieldBindings.add(fragment.resolveBinding());
  }
  accessedFieldBindings.addAll(superAccessedFields);
  Set<IVariableBinding> assignedFieldBindings=new LinkedHashSet<IVariableBinding>();
  for (  VariableDeclarationFragment fragment : assignedFields) {
    assignedFieldBindings.add(fragment.resolveBinding());
  }
  assignedFieldBindings.addAll(superAccessedFields);
  for (  Expression expression : newVariableInstructions) {
    SimpleName newSimpleName=(SimpleName)expression;
    SimpleName oldSimpleName=(SimpleName)oldVariableInstructions.get(j);
    Expression newParentExpression=null;
    Expression oldParentExpression=null;
    if (newSimpleName.getParent() instanceof QualifiedName) {
      newParentExpression=(QualifiedName)newSimpleName.getParent();
      oldParentExpression=(QualifiedName)oldSimpleName.getParent();
    }
 else     if (newSimpleName.getParent() instanceof FieldAccess) {
      newParentExpression=(FieldAccess)newSimpleName.getParent();
      oldParentExpression=(FieldAccess)oldSimpleName.getParent();
    }
 else {
      newParentExpression=newSimpleName;
      oldParentExpression=oldSimpleName;
    }
    if (newParentExpression.getParent() instanceof Assignment) {
      Assignment newAssignment=(Assignment)newParentExpression.getParent();
      Assignment oldAssignment=(Assignment)oldParentExpression.getParent();
      Expression newLeftHandSide=newAssignment.getLeftHandSide();
      Expression oldLeftHandSide=oldAssignment.getLeftHandSide();
      SimpleName newLeftHandSideName=null;
      SimpleName oldLeftHandSideName=null;
      if (newLeftHandSide instanceof SimpleName) {
        newLeftHandSideName=(SimpleName)newLeftHandSide;
        oldLeftHandSideName=(SimpleName)oldLeftHandSide;
      }
 else       if (newLeftHandSide instanceof QualifiedName) {
        QualifiedName newLeftHandSideQualifiedName=(QualifiedName)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideQualifiedName.getName();
        QualifiedName oldLeftHandSideQualifiedName=(QualifiedName)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideQualifiedName.getName();
      }
 else       if (newLeftHandSide instanceof FieldAccess) {
        FieldAccess newLeftHandSideFieldAccess=(FieldAccess)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideFieldAccess.getName();
        FieldAccess oldLeftHandSideFieldAccess=(FieldAccess)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideFieldAccess.getName();
      }
      Expression newRightHandSide=newAssignment.getRightHandSide();
      Expression oldRightHandSide=oldAssignment.getRightHandSide();
      SimpleName newRightHandSideName=null;
      SimpleName oldRightHandSideName=null;
      if (newRightHandSide instanceof SimpleName) {
        newRightHandSideName=(SimpleName)newRightHandSide;
        oldRightHandSideName=(SimpleName)oldRightHandSide;
      }
 else       if (newRightHandSide instanceof QualifiedName) {
        QualifiedName newRightHandSideQualifiedName=(QualifiedName)newRightHandSide;
        newRightHandSideName=newRightHandSideQualifiedName.getName();
        QualifiedName oldRightHandSideQualifiedName=(QualifiedName)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideQualifiedName.getName();
      }
 else       if (newRightHandSide instanceof FieldAccess) {
        FieldAccess newRightHandSideFieldAccess=(FieldAccess)newRightHandSide;
        newRightHandSideName=newRightHandSideFieldAccess.getName();
        FieldAccess oldRightHandSideFieldAccess=(FieldAccess)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideFieldAccess.getName();
      }
      String invokerName=sourceTypeDeclaration.getName().getIdentifier();
      invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
      if (newLeftHandSideName != null && newLeftHandSideName.equals(newSimpleName)) {
        for (        IVariableBinding assignedFieldBinding : assignedFieldBindings) {
          if (assignedFieldBinding.isEqualTo(oldLeftHandSideName.resolveBinding())) {
            IMethodBinding setterMethodBinding=null;
            if (superAssignedFields.contains(assignedFieldBinding)) {
              setterMethodBinding=typeCheckElimination.getSetterMethodBindingOfSuperAssignedField(assignedFieldBinding);
            }
 else {
              setterMethodBinding=findSetterMethodInContext(assignedFieldBinding);
            }
            String leftHandMethodName;
            if (setterMethodBinding != null) {
              leftHandMethodName=setterMethodBinding.getName();
            }
 else {
              leftHandMethodName=assignedFieldBinding.getName();
              leftHandMethodName=""String_Node_Str"" + leftHandMethodName.substring(0,1).toUpperCase() + leftHandMethodName.substring(1,leftHandMethodName.length());
            }
            MethodInvocation leftHandMethodInvocation=subclassAST.newMethodInvocation();
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(leftHandMethodName),null);
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            ListRewrite methodInvocationArgumentsRewrite=subclassRewriter.getListRewrite(leftHandMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            if (newRightHandSideName != null) {
              boolean accessedFieldFound=false;
              for (              IVariableBinding accessedFieldBinding : accessedFieldBindings) {
                if (accessedFieldBinding.isEqualTo(oldRightHandSideName.resolveBinding())) {
                  if ((accessedFieldBinding.getModifiers() & Modifier.STATIC) != 0 && (accessedFieldBinding.getModifiers() & Modifier.PUBLIC) != 0) {
                    SimpleName qualifier=subclassAST.newSimpleName(accessedFieldBinding.getDeclaringClass().getName());
                    if (newRightHandSideName.getParent() instanceof FieldAccess) {
                      FieldAccess fieldAccess=(FieldAccess)newRightHandSideName.getParent();
                      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
                      methodInvocationArgumentsRewrite.insertLast(fieldAccess,null);
                    }
 else                     if (newRightHandSideName.getParent() instanceof QualifiedName) {
                      QualifiedName qualifiedName=(QualifiedName)newRightHandSideName.getParent();
                      methodInvocationArgumentsRewrite.insertLast(qualifiedName,null);
                    }
 else {
                      SimpleName simpleName=subclassAST.newSimpleName(newRightHandSideName.getIdentifier());
                      QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
                      subclassRewriter.replace(newRightHandSideName,newQualifiedName,null);
                      methodInvocationArgumentsRewrite.insertLast(newQualifiedName,null);
                    }
                  }
 else {
                    IMethodBinding getterMethodBinding=null;
                    if (superAccessedFields.contains(accessedFieldBinding)) {
                      getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
                    }
 else {
                      getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
                    }
                    String rightHandMethodName;
                    if (getterMethodBinding != null) {
                      rightHandMethodName=getterMethodBinding.getName();
                    }
 else {
                      rightHandMethodName=accessedFieldBinding.getName();
                      rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
                    }
                    MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
                    subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
                    subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
                    methodInvocationArgumentsRewrite.insertLast(rightHandMethodInvocation,null);
                  }
                  accessedFieldFound=true;
                  break;
                }
              }
              if (!accessedFieldFound)               methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
 else {
              methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
            subclassRewriter.replace(newAssignment,leftHandMethodInvocation,null);
            break;
          }
        }
      }
    }
 else {
      for (      IVariableBinding accessedFieldBinding : accessedFieldBindings) {
        if (accessedFieldBinding.isEqualTo(oldSimpleName.resolveBinding())) {
          if ((accessedFieldBinding.getModifiers() & Modifier.STATIC) != 0 && (accessedFieldBinding.getModifiers() & Modifier.PUBLIC) != 0) {
            SimpleName qualifier=subclassAST.newSimpleName(accessedFieldBinding.getDeclaringClass().getName());
            if (newSimpleName.getParent() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
              subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
            }
 else             if (!(newSimpleName.getParent() instanceof QualifiedName)) {
              SimpleName simpleName=subclassAST.newSimpleName(newSimpleName.getIdentifier());
              QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
              subclassRewriter.replace(newSimpleName,newQualifiedName,null);
            }
          }
 else {
            IMethodBinding getterMethodBinding=null;
            if (superAccessedFields.contains(accessedFieldBinding)) {
              getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
            }
 else {
              getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
            }
            String methodName;
            if (getterMethodBinding != null) {
              methodName=getterMethodBinding.getName();
            }
 else {
              methodName=accessedFieldBinding.getName();
              methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
            }
            MethodInvocation methodInvocation=subclassAST.newMethodInvocation();
            subclassRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(methodName),null);
            String invokerName=sourceTypeDeclaration.getName().getIdentifier();
            invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
            subclassRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            if (newSimpleName.getParent() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
              subclassRewriter.replace(fieldAccess,methodInvocation,null);
            }
 else             if (newSimpleName.getParent() instanceof QualifiedName) {
              QualifiedName qualifiedName=(QualifiedName)newSimpleName.getParent();
              subclassRewriter.replace(qualifiedName,methodInvocation,null);
            }
 else {
              subclassRewriter.replace(newSimpleName,methodInvocation,null);
            }
          }
          break;
        }
      }
    }
    j++;
  }
}"
12179,"private void modifyInheritanceHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  PackageDeclaration contextPackageDeclaration=sourceCompilationUnit.getPackage();
  IContainer rootContainer=contextContainer;
  if (contextPackageDeclaration != null) {
    String packageName=contextPackageDeclaration.getName().getFullyQualifiedName();
    String[] subPackages=packageName.split(""String_Node_Str"");
    for (int i=0; i < subPackages.length; i++)     rootContainer=(IContainer)rootContainer.getParent();
  }
  String abstractClassFullyQualifiedName=typeCheckElimination.getAbstractClassName();
  IFile abstractClassFile=getFile(rootContainer,abstractClassFullyQualifiedName);
  IJavaElement abstractJavaElement=JavaCore.create(abstractClassFile);
  ITextEditor abstractEditor=null;
  try {
    abstractEditor=(ITextEditor)JavaUI.openInEditor(abstractJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit abstractICompilationUnit=(ICompilationUnit)abstractJavaElement;
  ASTParser abstractParser=ASTParser.newParser(AST.JLS3);
  abstractParser.setKind(ASTParser.K_COMPILATION_UNIT);
  abstractParser.setSource(abstractICompilationUnit);
  abstractParser.setResolveBindings(true);
  CompilationUnit abstractCompilationUnit=(CompilationUnit)abstractParser.createAST(null);
  AST abstractAST=abstractCompilationUnit.getAST();
  ASTRewrite abstractRewriter=ASTRewrite.create(abstractAST);
  TypeDeclaration abstractClassTypeDeclaration=null;
  List<AbstractTypeDeclaration> abstractTypeDeclarations=abstractCompilationUnit.types();
  for (  AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
    if (abstractTypeDeclaration instanceof TypeDeclaration) {
      TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
      if (typeDeclaration.resolveBinding().getQualifiedName().equals(typeCheckElimination.getAbstractClassName())) {
        abstractClassTypeDeclaration=typeDeclaration;
        break;
      }
    }
  }
  int abstractClassModifiers=abstractClassTypeDeclaration.getModifiers();
  if ((abstractClassModifiers & Modifier.ABSTRACT) == 0 && !abstractClassTypeDeclaration.isInterface()) {
    ListRewrite abstractModifiersRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    abstractModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite abstractBodyRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration abstractMethodDeclaration=abstractAST.newMethodDeclaration();
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(abstractMethodName),null);
  if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
    abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,abstractAST.newPrimitiveType(PrimitiveType.VOID),null);
  }
 else {
    if (returnedVariable != null) {
      Type returnType=null;
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        returnType=singleVariableDeclaration.getType();
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
        returnType=variableDeclarationStatement.getType();
      }
      abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    }
 else {
      abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    }
  }
  ListRewrite abstractMethodModifiersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  if (returnedVariable != null) {
    if (returnedVariable instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
      abstractMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
    }
 else     if (returnedVariable instanceof VariableDeclarationFragment) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    if (!abstractMethodParameter.equals(returnedVariable) && !abstractMethodParameter.equals(typeVariable)) {
      abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable) && !fragment.equals(typeVariable)) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
  Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
  Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
  Set<IMethodBinding> superAccessedMethods=typeCheckElimination.getSuperAccessedMethods();
  if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0) {
    SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
    SimpleName parameterType=abstractAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,abstractAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(abstractAST.newSimpleName(typeBinding.getName()),null);
  }
  abstractBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,abstractCompilationUnit,abstractRewriter);
  }
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer abstractTextFileBuffer=bufferManager.getTextFileBuffer(abstractClassFile.getFullPath(),LocationKind.IFILE);
  IDocument abstractDocument=abstractTextFileBuffer.getDocument();
  TextEdit abstractEdit=abstractRewriter.rewriteAST(abstractDocument,null);
  try {
    UndoEdit abstractUndoEdit=abstractEdit.apply(abstractDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(abstractClassFile,abstractDocument,abstractUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  abstractEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  DefaultMutableTreeNode root=typeCheckElimination.getExistingInheritanceTree().getRootNode();
  Enumeration<DefaultMutableTreeNode> enumeration=root.children();
  while (enumeration.hasMoreElements()) {
    DefaultMutableTreeNode child=enumeration.nextElement();
    String childClassName=(String)child.getUserObject();
    if (!subclassNames.contains(childClassName))     subclassNames.add(childClassName);
  }
  for (int i=0; i < subclassNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      Expression expression=typeCheckElimination.getExpressionCorrespondingToTypeCheckStatementList(statements);
      remainingIfStatementExpression=typeCheckElimination.getRemainingIfStatementExpression(expression);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=getFile(rootContainer,subclassNames.get(i));
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    TypeDeclaration subclassTypeDeclaration=null;
    List<AbstractTypeDeclaration> subclassAbstractTypeDeclarations=subclassCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : subclassAbstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.resolveBinding().getQualifiedName().equals(subclassNames.get(i))) {
          subclassTypeDeclaration=typeDeclaration;
          break;
        }
      }
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(abstractMethodName),null);
    if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
      subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,subclassAST.newPrimitiveType(PrimitiveType.VOID),null);
    }
 else {
      if (returnedVariable != null) {
        Type returnType=null;
        if (returnedVariable instanceof SingleVariableDeclaration) {
          SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
          returnType=singleVariableDeclaration.getType();
        }
 else         if (returnedVariable instanceof VariableDeclarationFragment) {
          VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
          returnType=variableDeclarationStatement.getType();
        }
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      }
 else {
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      }
    }
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    if (returnedVariable != null) {
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        concreteMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable) && !abstractMethodParameter.equals(typeVariable)) {
        concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
      }
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable) && !fragment.equals(typeVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(enclosingIfStatementExpression);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,subclassTypeDeclaration,accessedMethods,superAccessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    SimpleName invokerSimpleName=null;
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      boolean insert=true;
      if (statement instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)statement;
        List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
        VariableDeclarationFragment fragment=fragments.get(0);
        if (fragment.getInitializer() instanceof CastExpression) {
          CastExpression castExpression=(CastExpression)fragment.getInitializer();
          if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
            invokerSimpleName=fragment.getName();
            insert=false;
          }
        }
      }
 else {
        StatementExtractor statementExtractor=new StatementExtractor();
        List<Statement> oldVariableDeclarations=statementExtractor.getVariableDeclarations(statement);
        List<Statement> newVariableDeclarations=statementExtractor.getVariableDeclarations(newStatement);
        int j=0;
        for (        Statement oldVariableDeclaration : oldVariableDeclarations) {
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)oldVariableDeclaration;
          List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
          VariableDeclarationFragment fragment=fragments.get(0);
          if (fragment.getInitializer() instanceof CastExpression) {
            CastExpression castExpression=(CastExpression)fragment.getInitializer();
            if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
              if (typeVariable.getName().resolveBinding().isEqualTo(fragment.getName().resolveBinding())) {
                invokerSimpleName=fragment.getName();
                subclassRewriter.remove(newVariableDeclarations.get(j),null);
                break;
              }
            }
          }
          j++;
        }
      }
      if (invokerSimpleName != null) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(newStatement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            Expression methodInvocationExpression=methodInvocation.getExpression();
            if (methodInvocationExpression instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)methodInvocationExpression;
              if (simpleName.getIdentifier().equals(invokerSimpleName.getIdentifier())) {
                subclassRewriter.remove(simpleName,null);
              }
            }
          }
        }
      }
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(statement);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,subclassTypeDeclaration,accessedMethods,superAccessedMethods);
      if (insert) {
        if (ifStatementBodyRewrite != null)         ifStatementBodyRewrite.insertLast(newStatement,null);
 else         concreteMethodBodyRewrite.insertLast(newStatement,null);
      }
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}","private void modifyInheritanceHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  PackageDeclaration contextPackageDeclaration=sourceCompilationUnit.getPackage();
  IContainer rootContainer=contextContainer;
  if (contextPackageDeclaration != null) {
    String packageName=contextPackageDeclaration.getName().getFullyQualifiedName();
    String[] subPackages=packageName.split(""String_Node_Str"");
    for (int i=0; i < subPackages.length; i++)     rootContainer=(IContainer)rootContainer.getParent();
  }
  String abstractClassFullyQualifiedName=typeCheckElimination.getAbstractClassName();
  IFile abstractClassFile=getFile(rootContainer,abstractClassFullyQualifiedName);
  IJavaElement abstractJavaElement=JavaCore.create(abstractClassFile);
  ITextEditor abstractEditor=null;
  try {
    abstractEditor=(ITextEditor)JavaUI.openInEditor(abstractJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit abstractICompilationUnit=(ICompilationUnit)abstractJavaElement;
  ASTParser abstractParser=ASTParser.newParser(AST.JLS3);
  abstractParser.setKind(ASTParser.K_COMPILATION_UNIT);
  abstractParser.setSource(abstractICompilationUnit);
  abstractParser.setResolveBindings(true);
  CompilationUnit abstractCompilationUnit=(CompilationUnit)abstractParser.createAST(null);
  AST abstractAST=abstractCompilationUnit.getAST();
  ASTRewrite abstractRewriter=ASTRewrite.create(abstractAST);
  TypeDeclaration abstractClassTypeDeclaration=null;
  List<AbstractTypeDeclaration> abstractTypeDeclarations=abstractCompilationUnit.types();
  for (  AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
    if (abstractTypeDeclaration instanceof TypeDeclaration) {
      TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
      if (typeDeclaration.resolveBinding().getQualifiedName().equals(typeCheckElimination.getAbstractClassName())) {
        abstractClassTypeDeclaration=typeDeclaration;
        break;
      }
    }
  }
  int abstractClassModifiers=abstractClassTypeDeclaration.getModifiers();
  if ((abstractClassModifiers & Modifier.ABSTRACT) == 0 && !abstractClassTypeDeclaration.isInterface()) {
    ListRewrite abstractModifiersRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    abstractModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite abstractBodyRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration abstractMethodDeclaration=abstractAST.newMethodDeclaration();
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(abstractMethodName),null);
  if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
    abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,abstractAST.newPrimitiveType(PrimitiveType.VOID),null);
  }
 else {
    if (returnedVariable != null) {
      Type returnType=null;
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        returnType=singleVariableDeclaration.getType();
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
        returnType=variableDeclarationStatement.getType();
      }
      abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    }
 else {
      abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    }
  }
  ListRewrite abstractMethodModifiersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  if (returnedVariable != null) {
    if (returnedVariable instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
      abstractMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
    }
 else     if (returnedVariable instanceof VariableDeclarationFragment) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    if (!abstractMethodParameter.equals(returnedVariable) && !abstractMethodParameter.equals(typeVariable)) {
      abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable) && !fragment.equals(typeVariable)) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
  Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
  Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
  Set<IMethodBinding> superAccessedMethods=typeCheckElimination.getSuperAccessedMethods();
  if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0) {
    SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
    SimpleName parameterType=abstractAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,abstractAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(abstractAST.newSimpleName(typeBinding.getName()),null);
  }
  abstractBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,abstractCompilationUnit,abstractRewriter);
  }
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer abstractTextFileBuffer=bufferManager.getTextFileBuffer(abstractClassFile.getFullPath(),LocationKind.IFILE);
  IDocument abstractDocument=abstractTextFileBuffer.getDocument();
  TextEdit abstractEdit=abstractRewriter.rewriteAST(abstractDocument,null);
  try {
    UndoEdit abstractUndoEdit=abstractEdit.apply(abstractDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(abstractClassFile,abstractDocument,abstractUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  abstractEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  DefaultMutableTreeNode root=typeCheckElimination.getExistingInheritanceTree().getRootNode();
  Enumeration<DefaultMutableTreeNode> enumeration=root.children();
  while (enumeration.hasMoreElements()) {
    DefaultMutableTreeNode child=enumeration.nextElement();
    String childClassName=(String)child.getUserObject();
    if (!subclassNames.contains(childClassName))     subclassNames.add(childClassName);
  }
  for (int i=0; i < subclassNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      Expression expression=typeCheckElimination.getExpressionCorrespondingToTypeCheckStatementList(statements);
      remainingIfStatementExpression=typeCheckElimination.getRemainingIfStatementExpression(expression);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=getFile(rootContainer,subclassNames.get(i));
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    TypeDeclaration subclassTypeDeclaration=null;
    List<AbstractTypeDeclaration> subclassAbstractTypeDeclarations=subclassCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : subclassAbstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.resolveBinding().getQualifiedName().equals(subclassNames.get(i))) {
          subclassTypeDeclaration=typeDeclaration;
          break;
        }
      }
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(abstractMethodName),null);
    if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
      subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,subclassAST.newPrimitiveType(PrimitiveType.VOID),null);
    }
 else {
      if (returnedVariable != null) {
        Type returnType=null;
        if (returnedVariable instanceof SingleVariableDeclaration) {
          SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
          returnType=singleVariableDeclaration.getType();
        }
 else         if (returnedVariable instanceof VariableDeclarationFragment) {
          VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
          returnType=variableDeclarationStatement.getType();
        }
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      }
 else {
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      }
    }
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    if (returnedVariable != null) {
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        concreteMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable) && !abstractMethodParameter.equals(typeVariable)) {
        concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
      }
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable) && !fragment.equals(typeVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(enclosingIfStatementExpression);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,subclassTypeDeclaration,accessedMethods,superAccessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    SimpleName invokerSimpleName=null;
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      boolean insert=true;
      if (statement instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)statement;
        List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
        VariableDeclarationFragment fragment=fragments.get(0);
        if (fragment.getInitializer() instanceof CastExpression) {
          CastExpression castExpression=(CastExpression)fragment.getInitializer();
          if (castExpression.getExpression() instanceof SimpleName) {
            SimpleName castSimpleName=(SimpleName)castExpression.getExpression();
            if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
              if (typeVariable.getName().resolveBinding().isEqualTo(castSimpleName.resolveBinding())) {
                invokerSimpleName=fragment.getName();
                insert=false;
              }
            }
          }
        }
      }
 else {
        StatementExtractor statementExtractor=new StatementExtractor();
        List<Statement> oldVariableDeclarations=statementExtractor.getVariableDeclarations(statement);
        List<Statement> newVariableDeclarations=statementExtractor.getVariableDeclarations(newStatement);
        int j=0;
        for (        Statement oldVariableDeclaration : oldVariableDeclarations) {
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)oldVariableDeclaration;
          List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
          VariableDeclarationFragment fragment=fragments.get(0);
          if (fragment.getInitializer() instanceof CastExpression) {
            CastExpression castExpression=(CastExpression)fragment.getInitializer();
            if (castExpression.getExpression() instanceof SimpleName) {
              SimpleName castSimpleName=(SimpleName)castExpression.getExpression();
              if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
                if (typeVariable.getName().resolveBinding().isEqualTo(castSimpleName.resolveBinding())) {
                  invokerSimpleName=fragment.getName();
                  subclassRewriter.remove(newVariableDeclarations.get(j),null);
                  break;
                }
              }
            }
          }
          j++;
        }
      }
      if (invokerSimpleName != null) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(newStatement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            Expression methodInvocationExpression=methodInvocation.getExpression();
            if (methodInvocationExpression instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)methodInvocationExpression;
              if (simpleName.getIdentifier().equals(invokerSimpleName.getIdentifier())) {
                subclassRewriter.remove(simpleName,null);
              }
            }
          }
        }
      }
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(statement);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,subclassTypeDeclaration,accessedMethods,superAccessedMethods);
      if (insert) {
        if (ifStatementBodyRewrite != null)         ifStatementBodyRewrite.insertLast(newStatement,null);
 else         concreteMethodBodyRewrite.insertLast(newStatement,null);
      }
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}"
12180,"private void modifyContext(){
  AST contextAST=sourceTypeDeclaration.getAST();
  ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  VariableDeclarationFragment typeFragment=contextAST.newVariableDeclarationFragment();
  sourceRewriter.set(typeFragment,VariableDeclarationFragment.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
  FieldDeclaration typeFieldDeclaration=contextAST.newFieldDeclaration(typeFragment);
  sourceRewriter.set(typeFieldDeclaration,FieldDeclaration.TYPE_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getAbstractClassName()),null);
  ListRewrite typeFieldDeclrationModifiersRewrite=sourceRewriter.getListRewrite(typeFieldDeclaration,FieldDeclaration.MODIFIERS2_PROPERTY);
  typeFieldDeclrationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD),null);
  contextBodyRewrite.insertFirst(typeFieldDeclaration,null);
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  for (  FieldDeclaration fieldDeclaration : fieldDeclarations) {
    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      if (fragment.equals(typeCheckElimination.getTypeField())) {
        if (fragments.size() == 1) {
          contextBodyRewrite.remove(fragment.getParent(),null);
        }
 else {
          ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(fragment.getParent(),FieldDeclaration.FRAGMENTS_PROPERTY);
          fragmentRewrite.remove(fragment,null);
        }
      }
    }
  }
  modifyTypeFieldAssignmentsInContextClass();
  modifyTypeFieldAccessesInContextClass();
  MethodDeclaration setterMethod=typeCheckElimination.getTypeFieldSetterMethod();
  SwitchStatement switchStatement=contextAST.newSwitchStatement();
  List<SimpleName> staticFieldNames=typeCheckElimination.getStaticFields();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  ListRewrite switchStatementStatementsRewrite=sourceRewriter.getListRewrite(switchStatement,SwitchStatement.STATEMENTS_PROPERTY);
  int i=0;
  for (  SimpleName staticFieldName : staticFieldNames) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    IBinding staticFieldNameBinding=staticFieldName.resolveBinding();
    String staticFieldNameDeclaringClass=null;
    boolean isEnumConstant=false;
    if (staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
      IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
      isEnumConstant=staticFieldNameVariableBinding.isEnumConstant();
      if (!sourceTypeDeclaration.resolveBinding().isEqualTo(staticFieldNameVariableBinding.getDeclaringClass())) {
        staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass().getName();
      }
    }
    if (staticFieldNameDeclaringClass == null || isEnumConstant) {
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,staticFieldName,null);
    }
 else {
      FieldAccess fieldAccess=contextAST.newFieldAccess();
      sourceRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newSimpleName(staticFieldNameDeclaringClass),null);
      sourceRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,staticFieldName,null);
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,fieldAccess,null);
    }
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(subclassNames.get(i)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
    i++;
  }
  for (  SimpleName staticFieldName : additionalStaticFields.keySet()) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    IBinding staticFieldNameBinding=staticFieldName.resolveBinding();
    String staticFieldNameDeclaringClass=null;
    boolean isEnumConstant=false;
    if (staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
      IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
      isEnumConstant=staticFieldNameVariableBinding.isEnumConstant();
      if (!sourceTypeDeclaration.resolveBinding().isEqualTo(staticFieldNameVariableBinding.getDeclaringClass())) {
        staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass().getName();
      }
    }
    if (staticFieldNameDeclaringClass == null || isEnumConstant) {
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,staticFieldName,null);
    }
 else {
      FieldAccess fieldAccess=contextAST.newFieldAccess();
      sourceRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newSimpleName(staticFieldNameDeclaringClass),null);
      sourceRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,staticFieldName,null);
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,fieldAccess,null);
    }
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(additionalStaticFields.get(staticFieldName)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
  }
  if (setterMethod != null) {
    List<SingleVariableDeclaration> setterMethodParameters=setterMethod.parameters();
    if (setterMethodParameters.size() == 1) {
      sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,setterMethodParameters.get(0).getName(),null);
    }
    Block setterMethodBody=setterMethod.getBody();
    List<Statement> setterMethodBodyStatements=setterMethodBody.statements();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    if (setterMethodBodyStatements.size() == 1) {
      setterMethodBodyRewrite.replace(setterMethodBodyStatements.get(0),switchStatement,null);
    }
  }
 else {
    MethodDeclaration setterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,contextAST.newPrimitiveType(PrimitiveType.VOID),null);
    ListRewrite setterMethodModifiersRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    setterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite setterMethodParameterRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    SingleVariableDeclaration parameter=contextAST.newSingleVariableDeclaration();
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type parameterType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,typeField.getName(),null);
    setterMethodParameterRewrite.insertLast(parameter,null);
    sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,typeField.getName(),null);
    Block setterMethodBody=contextAST.newBlock();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    setterMethodBodyRewrite.insertLast(switchStatement,null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,setterMethodBody,null);
    contextBodyRewrite.insertLast(setterMethodDeclaration,null);
  }
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  if (getterMethod != null) {
    Block getterMethodBody=getterMethod.getBody();
    List<Statement> getterMethodBodyStatements=getterMethodBody.statements();
    ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
    if (getterMethodBodyStatements.size() == 1) {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
      sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,getterMethod.getName(),null);
      sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
      getterMethodBodyRewrite.replace(getterMethodBodyStatements.get(0),returnStatement,null);
    }
  }
 else {
    MethodDeclaration getterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type returnType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    ListRewrite getterMethodModifiersRewrite=sourceRewriter.getListRewrite(getterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    getterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ReturnStatement returnStatement=contextAST.newReturnStatement();
    MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
    Block getterMethodBody=contextAST.newBlock();
    ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
    getterMethodBodyRewrite.insertLast(returnStatement,null);
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,getterMethodBody,null);
    contextBodyRewrite.insertLast(getterMethodDeclaration,null);
  }
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(abstractMethodName),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
      }
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    ExpressionStatement expressionStatement=contextAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(abstractMethodName),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    if (returnedVariable != null) {
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        methodInvocationArgumentsRewrite.insertLast(singleVariableDeclaration.getName(),null);
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        methodInvocationArgumentsRewrite.insertLast(variableDeclarationFragment.getName(),null);
      }
    }
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
      }
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    if (returnedVariable != null) {
      Assignment assignment=contextAST.newAssignment();
      sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
      ExpressionStatement expressionStatement=contextAST.newExpressionStatement(assignment);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
    }
 else {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractMethodInvocation,null);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),returnStatement,null);
    }
  }
  generateGettersForAccessedFields();
  generateSettersForAssignedFields();
  setPublicModifierToStaticFields();
  setPublicModifierToAccessedMethods();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","private void modifyContext(){
  AST contextAST=sourceTypeDeclaration.getAST();
  ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  VariableDeclarationFragment typeFragment=contextAST.newVariableDeclarationFragment();
  sourceRewriter.set(typeFragment,VariableDeclarationFragment.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
  FieldDeclaration typeFieldDeclaration=contextAST.newFieldDeclaration(typeFragment);
  sourceRewriter.set(typeFieldDeclaration,FieldDeclaration.TYPE_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getAbstractClassName()),null);
  ListRewrite typeFieldDeclrationModifiersRewrite=sourceRewriter.getListRewrite(typeFieldDeclaration,FieldDeclaration.MODIFIERS2_PROPERTY);
  typeFieldDeclrationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD),null);
  contextBodyRewrite.insertFirst(typeFieldDeclaration,null);
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  for (  FieldDeclaration fieldDeclaration : fieldDeclarations) {
    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      if (fragment.equals(typeCheckElimination.getTypeField())) {
        if (fragments.size() == 1) {
          contextBodyRewrite.remove(fragment.getParent(),null);
        }
 else {
          ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(fragment.getParent(),FieldDeclaration.FRAGMENTS_PROPERTY);
          fragmentRewrite.remove(fragment,null);
        }
      }
    }
  }
  modifyTypeFieldAssignmentsInContextClass();
  modifyTypeFieldAccessesInContextClass();
  MethodDeclaration setterMethod=typeCheckElimination.getTypeFieldSetterMethod();
  SwitchStatement switchStatement=contextAST.newSwitchStatement();
  List<SimpleName> staticFieldNames=typeCheckElimination.getStaticFields();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  ListRewrite switchStatementStatementsRewrite=sourceRewriter.getListRewrite(switchStatement,SwitchStatement.STATEMENTS_PROPERTY);
  int i=0;
  for (  SimpleName staticFieldName : staticFieldNames) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    IBinding staticFieldNameBinding=staticFieldName.resolveBinding();
    String staticFieldNameDeclaringClass=null;
    boolean isEnumConstant=false;
    if (staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
      IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
      isEnumConstant=staticFieldNameVariableBinding.isEnumConstant();
      if (!sourceTypeDeclaration.resolveBinding().isEqualTo(staticFieldNameVariableBinding.getDeclaringClass())) {
        staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass().getName();
      }
    }
    if (staticFieldNameDeclaringClass == null || isEnumConstant) {
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,staticFieldName,null);
    }
 else {
      FieldAccess fieldAccess=contextAST.newFieldAccess();
      sourceRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newSimpleName(staticFieldNameDeclaringClass),null);
      sourceRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,staticFieldName,null);
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,fieldAccess,null);
    }
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(subclassNames.get(i)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
    i++;
  }
  for (  SimpleName staticFieldName : additionalStaticFields.keySet()) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    IBinding staticFieldNameBinding=staticFieldName.resolveBinding();
    String staticFieldNameDeclaringClass=null;
    boolean isEnumConstant=false;
    if (staticFieldNameBinding.getKind() == IBinding.VARIABLE) {
      IVariableBinding staticFieldNameVariableBinding=(IVariableBinding)staticFieldNameBinding;
      isEnumConstant=staticFieldNameVariableBinding.isEnumConstant();
      if (!sourceTypeDeclaration.resolveBinding().isEqualTo(staticFieldNameVariableBinding.getDeclaringClass())) {
        staticFieldNameDeclaringClass=staticFieldNameVariableBinding.getDeclaringClass().getName();
      }
    }
    if (staticFieldNameDeclaringClass == null || isEnumConstant) {
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,staticFieldName,null);
    }
 else {
      FieldAccess fieldAccess=contextAST.newFieldAccess();
      sourceRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newSimpleName(staticFieldNameDeclaringClass),null);
      sourceRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,staticFieldName,null);
      sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,fieldAccess,null);
    }
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(additionalStaticFields.get(staticFieldName)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
  }
  SwitchCase switchCase=contextAST.newSwitchCase();
  sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,null,null);
  switchStatementStatementsRewrite.insertLast(switchCase,null);
  Assignment nullAssignment=contextAST.newAssignment();
  sourceRewriter.set(nullAssignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
  FieldAccess typeFieldAccess=contextAST.newFieldAccess();
  sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
  sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
  sourceRewriter.set(nullAssignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
  sourceRewriter.set(nullAssignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,contextAST.newNullLiteral(),null);
  switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(nullAssignment),null);
  switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
  if (setterMethod != null) {
    List<SingleVariableDeclaration> setterMethodParameters=setterMethod.parameters();
    if (setterMethodParameters.size() == 1) {
      sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,setterMethodParameters.get(0).getName(),null);
    }
    Block setterMethodBody=setterMethod.getBody();
    List<Statement> setterMethodBodyStatements=setterMethodBody.statements();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    if (setterMethodBodyStatements.size() == 1) {
      setterMethodBodyRewrite.replace(setterMethodBodyStatements.get(0),switchStatement,null);
    }
  }
 else {
    MethodDeclaration setterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,contextAST.newPrimitiveType(PrimitiveType.VOID),null);
    ListRewrite setterMethodModifiersRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    setterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite setterMethodParameterRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    SingleVariableDeclaration parameter=contextAST.newSingleVariableDeclaration();
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type parameterType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,typeField.getName(),null);
    setterMethodParameterRewrite.insertLast(parameter,null);
    sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,typeField.getName(),null);
    Block setterMethodBody=contextAST.newBlock();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    setterMethodBodyRewrite.insertLast(switchStatement,null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,setterMethodBody,null);
    contextBodyRewrite.insertLast(setterMethodDeclaration,null);
  }
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  if (getterMethod != null) {
    Block getterMethodBody=getterMethod.getBody();
    List<Statement> getterMethodBodyStatements=getterMethodBody.statements();
    ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
    if (getterMethodBodyStatements.size() == 1) {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
      sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,getterMethod.getName(),null);
      sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
      getterMethodBodyRewrite.replace(getterMethodBodyStatements.get(0),returnStatement,null);
    }
  }
 else {
    MethodDeclaration getterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type returnType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    ListRewrite getterMethodModifiersRewrite=sourceRewriter.getListRewrite(getterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    getterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ReturnStatement returnStatement=contextAST.newReturnStatement();
    MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
    Block getterMethodBody=contextAST.newBlock();
    ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
    getterMethodBodyRewrite.insertLast(returnStatement,null);
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,getterMethodBody,null);
    contextBodyRewrite.insertLast(getterMethodDeclaration,null);
  }
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(abstractMethodName),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
      }
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    ExpressionStatement expressionStatement=contextAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(abstractMethodName),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    if (returnedVariable != null) {
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        methodInvocationArgumentsRewrite.insertLast(singleVariableDeclaration.getName(),null);
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        methodInvocationArgumentsRewrite.insertLast(variableDeclarationFragment.getName(),null);
      }
    }
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
      }
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    if (returnedVariable != null) {
      Assignment assignment=contextAST.newAssignment();
      sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
      ExpressionStatement expressionStatement=contextAST.newExpressionStatement(assignment);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
    }
 else {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractMethodInvocation,null);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),returnStatement,null);
    }
  }
  generateGettersForAccessedFields();
  generateSettersForAssignedFields();
  setPublicModifierToStaticFields();
  setPublicModifierToAccessedMethods();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12181,"private void generateGettersForAccessedFields(){
  AST contextAST=sourceTypeDeclaration.getAST();
  Set<VariableDeclarationFragment> accessedFields=new LinkedHashSet<VariableDeclarationFragment>();
  accessedFields.addAll(typeCheckElimination.getAccessedFields());
  accessedFields.addAll(typeCheckElimination.getSuperAccessedFields());
  for (  VariableDeclarationFragment fragment : accessedFields) {
    IMethodBinding getterMethodBinding=null;
    if (typeCheckElimination.getSuperAccessedFields().contains(fragment)) {
      getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(fragment.resolveBinding());
    }
 else {
      getterMethodBinding=findGetterMethodInContext(fragment.resolveBinding());
    }
    if (getterMethodBinding == null) {
      FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
      int modifiers=fieldDeclaration.getModifiers();
      if (!fragment.equals(typeCheckElimination.getTypeField()) && !((modifiers & Modifier.PUBLIC) != 0 && (modifiers & Modifier.STATIC) != 0)) {
        MethodDeclaration newMethodDeclaration=contextAST.newMethodDeclaration();
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,fieldDeclaration.getType(),null);
        ListRewrite methodDeclarationModifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
        methodDeclarationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
        String methodName=fragment.getName().getIdentifier();
        methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(methodName),null);
        Block methodDeclarationBody=contextAST.newBlock();
        ListRewrite methodDeclarationBodyStatementsRewrite=sourceRewriter.getListRewrite(methodDeclarationBody,Block.STATEMENTS_PROPERTY);
        ReturnStatement returnStatement=contextAST.newReturnStatement();
        sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fragment.getName(),null);
        methodDeclarationBodyStatementsRewrite.insertLast(returnStatement,null);
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodDeclarationBody,null);
        ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
        contextBodyRewrite.insertLast(newMethodDeclaration,null);
      }
    }
  }
}","private void generateGettersForAccessedFields(){
  AST contextAST=sourceTypeDeclaration.getAST();
  Set<VariableDeclarationFragment> accessedFields=new LinkedHashSet<VariableDeclarationFragment>();
  accessedFields.addAll(typeCheckElimination.getAccessedFields());
  accessedFields.addAll(typeCheckElimination.getSuperAccessedFields());
  for (  VariableDeclarationFragment fragment : accessedFields) {
    IMethodBinding getterMethodBinding=null;
    if (typeCheckElimination.getSuperAccessedFields().contains(fragment)) {
      for (      IVariableBinding fieldBinding : typeCheckElimination.getSuperAccessedFieldBindings()) {
        if (fieldBinding.isEqualTo(fragment.resolveBinding())) {
          getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(fieldBinding);
          break;
        }
      }
    }
 else {
      getterMethodBinding=findGetterMethodInContext(fragment.resolveBinding());
    }
    if (getterMethodBinding == null) {
      FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
      int modifiers=fieldDeclaration.getModifiers();
      if (!fragment.equals(typeCheckElimination.getTypeField()) && !((modifiers & Modifier.PUBLIC) != 0 && (modifiers & Modifier.STATIC) != 0)) {
        MethodDeclaration newMethodDeclaration=contextAST.newMethodDeclaration();
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,fieldDeclaration.getType(),null);
        ListRewrite methodDeclarationModifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
        methodDeclarationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
        String methodName=fragment.getName().getIdentifier();
        methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(methodName),null);
        Block methodDeclarationBody=contextAST.newBlock();
        ListRewrite methodDeclarationBodyStatementsRewrite=sourceRewriter.getListRewrite(methodDeclarationBody,Block.STATEMENTS_PROPERTY);
        ReturnStatement returnStatement=contextAST.newReturnStatement();
        sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fragment.getName(),null);
        methodDeclarationBodyStatementsRewrite.insertLast(returnStatement,null);
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodDeclarationBody,null);
        ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
        contextBodyRewrite.insertLast(newMethodDeclaration,null);
      }
    }
  }
}"
12182,"private void generateSettersForAssignedFields(){
  AST contextAST=sourceTypeDeclaration.getAST();
  Set<VariableDeclarationFragment> assignedFields=new LinkedHashSet<VariableDeclarationFragment>();
  assignedFields.addAll(typeCheckElimination.getAssignedFields());
  assignedFields.addAll(typeCheckElimination.getSuperAssignedFields());
  for (  VariableDeclarationFragment fragment : assignedFields) {
    IMethodBinding setterMethodBinding=null;
    if (typeCheckElimination.getSuperAssignedFields().contains(fragment)) {
      setterMethodBinding=typeCheckElimination.getSetterMethodBindingOfSuperAssignedField(fragment.resolveBinding());
    }
 else {
      setterMethodBinding=findSetterMethodInContext(fragment.resolveBinding());
    }
    if (setterMethodBinding == null) {
      FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
      if (!fragment.equals(typeCheckElimination.getTypeField())) {
        MethodDeclaration newMethodDeclaration=contextAST.newMethodDeclaration();
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,contextAST.newPrimitiveType(PrimitiveType.VOID),null);
        ListRewrite methodDeclarationModifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
        methodDeclarationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
        String methodName=fragment.getName().getIdentifier();
        methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(methodName),null);
        ListRewrite methodDeclarationParametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
        SingleVariableDeclaration parameter=contextAST.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,fieldDeclaration.getType(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        methodDeclarationParametersRewrite.insertLast(parameter,null);
        Block methodDeclarationBody=contextAST.newBlock();
        ListRewrite methodDeclarationBodyStatementsRewrite=sourceRewriter.getListRewrite(methodDeclarationBody,Block.STATEMENTS_PROPERTY);
        Assignment assignment=contextAST.newAssignment();
        sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,fragment.getName(),null);
        sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
        FieldAccess fieldAccess=contextAST.newFieldAccess();
        sourceRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
        sourceRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,fragment.getName(),null);
        sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,fieldAccess,null);
        ExpressionStatement expressionStatement=contextAST.newExpressionStatement(assignment);
        methodDeclarationBodyStatementsRewrite.insertLast(expressionStatement,null);
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodDeclarationBody,null);
        ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
        contextBodyRewrite.insertLast(newMethodDeclaration,null);
      }
    }
  }
}","private void generateSettersForAssignedFields(){
  AST contextAST=sourceTypeDeclaration.getAST();
  Set<VariableDeclarationFragment> assignedFields=new LinkedHashSet<VariableDeclarationFragment>();
  assignedFields.addAll(typeCheckElimination.getAssignedFields());
  assignedFields.addAll(typeCheckElimination.getSuperAssignedFields());
  for (  VariableDeclarationFragment fragment : assignedFields) {
    IMethodBinding setterMethodBinding=null;
    if (typeCheckElimination.getSuperAssignedFields().contains(fragment)) {
      for (      IVariableBinding fieldBinding : typeCheckElimination.getSuperAssignedFieldBindings()) {
        if (fieldBinding.isEqualTo(fragment.resolveBinding())) {
          setterMethodBinding=typeCheckElimination.getSetterMethodBindingOfSuperAssignedField(fieldBinding);
          break;
        }
      }
    }
 else {
      setterMethodBinding=findSetterMethodInContext(fragment.resolveBinding());
    }
    if (setterMethodBinding == null) {
      FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
      if (!fragment.equals(typeCheckElimination.getTypeField())) {
        MethodDeclaration newMethodDeclaration=contextAST.newMethodDeclaration();
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,contextAST.newPrimitiveType(PrimitiveType.VOID),null);
        ListRewrite methodDeclarationModifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
        methodDeclarationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
        String methodName=fragment.getName().getIdentifier();
        methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(methodName),null);
        ListRewrite methodDeclarationParametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
        SingleVariableDeclaration parameter=contextAST.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,fieldDeclaration.getType(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        methodDeclarationParametersRewrite.insertLast(parameter,null);
        Block methodDeclarationBody=contextAST.newBlock();
        ListRewrite methodDeclarationBodyStatementsRewrite=sourceRewriter.getListRewrite(methodDeclarationBody,Block.STATEMENTS_PROPERTY);
        Assignment assignment=contextAST.newAssignment();
        sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,fragment.getName(),null);
        sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
        FieldAccess fieldAccess=contextAST.newFieldAccess();
        sourceRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
        sourceRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,fragment.getName(),null);
        sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,fieldAccess,null);
        ExpressionStatement expressionStatement=contextAST.newExpressionStatement(assignment);
        methodDeclarationBodyStatementsRewrite.insertLast(expressionStatement,null);
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodDeclarationBody,null);
        ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
        contextBodyRewrite.insertLast(newMethodDeclaration,null);
      }
    }
  }
}"
12183,"private void generateGettersForAccessedFields(){
  AST contextAST=sourceTypeDeclaration.getAST();
  Set<VariableDeclarationFragment> accessedFields=new LinkedHashSet<VariableDeclarationFragment>();
  accessedFields.addAll(typeCheckElimination.getAccessedFields());
  accessedFields.addAll(typeCheckElimination.getSuperAccessedFields());
  for (  VariableDeclarationFragment fragment : accessedFields) {
    IMethodBinding getterMethodBinding=null;
    if (typeCheckElimination.getSuperAccessedFields().contains(fragment)) {
      getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(fragment.resolveBinding());
    }
 else {
      getterMethodBinding=findGetterMethodInContext(fragment.resolveBinding());
    }
    if (getterMethodBinding == null) {
      FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
      int modifiers=fieldDeclaration.getModifiers();
      if (!fragment.equals(typeCheckElimination.getTypeField()) && !((modifiers & Modifier.PUBLIC) != 0 && (modifiers & Modifier.STATIC) != 0)) {
        MethodDeclaration newMethodDeclaration=contextAST.newMethodDeclaration();
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,fieldDeclaration.getType(),null);
        ListRewrite methodDeclarationModifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
        methodDeclarationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
        String methodName=fragment.getName().getIdentifier();
        methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(methodName),null);
        Block methodDeclarationBody=contextAST.newBlock();
        ListRewrite methodDeclarationBodyStatementsRewrite=sourceRewriter.getListRewrite(methodDeclarationBody,Block.STATEMENTS_PROPERTY);
        ReturnStatement returnStatement=contextAST.newReturnStatement();
        sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fragment.getName(),null);
        methodDeclarationBodyStatementsRewrite.insertLast(returnStatement,null);
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodDeclarationBody,null);
        ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
        contextBodyRewrite.insertLast(newMethodDeclaration,null);
      }
    }
  }
}","private void generateGettersForAccessedFields(){
  AST contextAST=sourceTypeDeclaration.getAST();
  Set<VariableDeclarationFragment> accessedFields=new LinkedHashSet<VariableDeclarationFragment>();
  accessedFields.addAll(typeCheckElimination.getAccessedFields());
  accessedFields.addAll(typeCheckElimination.getSuperAccessedFields());
  for (  VariableDeclarationFragment fragment : accessedFields) {
    IMethodBinding getterMethodBinding=null;
    if (typeCheckElimination.getSuperAccessedFields().contains(fragment)) {
      for (      IVariableBinding fieldBinding : typeCheckElimination.getSuperAccessedFieldBindings()) {
        if (fieldBinding.isEqualTo(fragment.resolveBinding())) {
          getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(fieldBinding);
          break;
        }
      }
    }
 else {
      getterMethodBinding=findGetterMethodInContext(fragment.resolveBinding());
    }
    if (getterMethodBinding == null) {
      FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
      int modifiers=fieldDeclaration.getModifiers();
      if (!fragment.equals(typeCheckElimination.getTypeField()) && !((modifiers & Modifier.PUBLIC) != 0 && (modifiers & Modifier.STATIC) != 0)) {
        MethodDeclaration newMethodDeclaration=contextAST.newMethodDeclaration();
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,fieldDeclaration.getType(),null);
        ListRewrite methodDeclarationModifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
        methodDeclarationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
        String methodName=fragment.getName().getIdentifier();
        methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(methodName),null);
        Block methodDeclarationBody=contextAST.newBlock();
        ListRewrite methodDeclarationBodyStatementsRewrite=sourceRewriter.getListRewrite(methodDeclarationBody,Block.STATEMENTS_PROPERTY);
        ReturnStatement returnStatement=contextAST.newReturnStatement();
        sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fragment.getName(),null);
        methodDeclarationBodyStatementsRewrite.insertLast(returnStatement,null);
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodDeclarationBody,null);
        ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
        contextBodyRewrite.insertLast(newMethodDeclaration,null);
      }
    }
  }
}"
12184,"private void generateSettersForAssignedFields(){
  AST contextAST=sourceTypeDeclaration.getAST();
  Set<VariableDeclarationFragment> assignedFields=new LinkedHashSet<VariableDeclarationFragment>();
  assignedFields.addAll(typeCheckElimination.getAssignedFields());
  assignedFields.addAll(typeCheckElimination.getSuperAssignedFields());
  for (  VariableDeclarationFragment fragment : assignedFields) {
    IMethodBinding setterMethodBinding=null;
    if (typeCheckElimination.getSuperAssignedFields().contains(fragment)) {
      setterMethodBinding=typeCheckElimination.getSetterMethodBindingOfSuperAssignedField(fragment.resolveBinding());
    }
 else {
      setterMethodBinding=findSetterMethodInContext(fragment.resolveBinding());
    }
    if (setterMethodBinding == null) {
      FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
      if (!fragment.equals(typeCheckElimination.getTypeField())) {
        MethodDeclaration newMethodDeclaration=contextAST.newMethodDeclaration();
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,contextAST.newPrimitiveType(PrimitiveType.VOID),null);
        ListRewrite methodDeclarationModifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
        methodDeclarationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
        String methodName=fragment.getName().getIdentifier();
        methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(methodName),null);
        ListRewrite methodDeclarationParametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
        SingleVariableDeclaration parameter=contextAST.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,fieldDeclaration.getType(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        methodDeclarationParametersRewrite.insertLast(parameter,null);
        Block methodDeclarationBody=contextAST.newBlock();
        ListRewrite methodDeclarationBodyStatementsRewrite=sourceRewriter.getListRewrite(methodDeclarationBody,Block.STATEMENTS_PROPERTY);
        Assignment assignment=contextAST.newAssignment();
        sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,fragment.getName(),null);
        sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
        FieldAccess fieldAccess=contextAST.newFieldAccess();
        sourceRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
        sourceRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,fragment.getName(),null);
        sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,fieldAccess,null);
        ExpressionStatement expressionStatement=contextAST.newExpressionStatement(assignment);
        methodDeclarationBodyStatementsRewrite.insertLast(expressionStatement,null);
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodDeclarationBody,null);
        ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
        contextBodyRewrite.insertLast(newMethodDeclaration,null);
      }
    }
  }
}","private void generateSettersForAssignedFields(){
  AST contextAST=sourceTypeDeclaration.getAST();
  Set<VariableDeclarationFragment> assignedFields=new LinkedHashSet<VariableDeclarationFragment>();
  assignedFields.addAll(typeCheckElimination.getAssignedFields());
  assignedFields.addAll(typeCheckElimination.getSuperAssignedFields());
  for (  VariableDeclarationFragment fragment : assignedFields) {
    IMethodBinding setterMethodBinding=null;
    if (typeCheckElimination.getSuperAssignedFields().contains(fragment)) {
      for (      IVariableBinding fieldBinding : typeCheckElimination.getSuperAssignedFieldBindings()) {
        if (fieldBinding.isEqualTo(fragment.resolveBinding())) {
          setterMethodBinding=typeCheckElimination.getSetterMethodBindingOfSuperAssignedField(fieldBinding);
          break;
        }
      }
    }
 else {
      setterMethodBinding=findSetterMethodInContext(fragment.resolveBinding());
    }
    if (setterMethodBinding == null) {
      FieldDeclaration fieldDeclaration=(FieldDeclaration)fragment.getParent();
      if (!fragment.equals(typeCheckElimination.getTypeField())) {
        MethodDeclaration newMethodDeclaration=contextAST.newMethodDeclaration();
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,contextAST.newPrimitiveType(PrimitiveType.VOID),null);
        ListRewrite methodDeclarationModifiersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
        methodDeclarationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
        String methodName=fragment.getName().getIdentifier();
        methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(methodName),null);
        ListRewrite methodDeclarationParametersRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
        SingleVariableDeclaration parameter=contextAST.newSingleVariableDeclaration();
        sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,fieldDeclaration.getType(),null);
        sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        methodDeclarationParametersRewrite.insertLast(parameter,null);
        Block methodDeclarationBody=contextAST.newBlock();
        ListRewrite methodDeclarationBodyStatementsRewrite=sourceRewriter.getListRewrite(methodDeclarationBody,Block.STATEMENTS_PROPERTY);
        Assignment assignment=contextAST.newAssignment();
        sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,fragment.getName(),null);
        sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
        FieldAccess fieldAccess=contextAST.newFieldAccess();
        sourceRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
        sourceRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,fragment.getName(),null);
        sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,fieldAccess,null);
        ExpressionStatement expressionStatement=contextAST.newExpressionStatement(assignment);
        methodDeclarationBodyStatementsRewrite.insertLast(expressionStatement,null);
        sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,methodDeclarationBody,null);
        ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
        contextBodyRewrite.insertLast(newMethodDeclaration,null);
      }
    }
  }
}"
12185,"private void modifyInheritanceHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  PackageDeclaration contextPackageDeclaration=sourceCompilationUnit.getPackage();
  IContainer rootContainer=contextContainer;
  if (contextPackageDeclaration != null) {
    String packageName=contextPackageDeclaration.getName().getFullyQualifiedName();
    String[] subPackages=packageName.split(""String_Node_Str"");
    for (int i=0; i < subPackages.length; i++)     rootContainer=(IContainer)rootContainer.getParent();
  }
  String abstractClassFullyQualifiedName=typeCheckElimination.getAbstractClassName();
  IFile abstractClassFile=getFile(rootContainer,abstractClassFullyQualifiedName);
  IJavaElement abstractJavaElement=JavaCore.create(abstractClassFile);
  ITextEditor abstractEditor=null;
  try {
    abstractEditor=(ITextEditor)JavaUI.openInEditor(abstractJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit abstractICompilationUnit=(ICompilationUnit)abstractJavaElement;
  ASTParser abstractParser=ASTParser.newParser(AST.JLS3);
  abstractParser.setKind(ASTParser.K_COMPILATION_UNIT);
  abstractParser.setSource(abstractICompilationUnit);
  abstractParser.setResolveBindings(true);
  CompilationUnit abstractCompilationUnit=(CompilationUnit)abstractParser.createAST(null);
  AST abstractAST=abstractCompilationUnit.getAST();
  ASTRewrite abstractRewriter=ASTRewrite.create(abstractAST);
  TypeDeclaration abstractClassTypeDeclaration=null;
  List<AbstractTypeDeclaration> abstractTypeDeclarations=abstractCompilationUnit.types();
  for (  AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
    if (abstractTypeDeclaration instanceof TypeDeclaration) {
      TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
      if (typeDeclaration.resolveBinding().getQualifiedName().equals(typeCheckElimination.getAbstractClassName())) {
        abstractClassTypeDeclaration=typeDeclaration;
        break;
      }
    }
  }
  int abstractClassModifiers=abstractClassTypeDeclaration.getModifiers();
  if ((abstractClassModifiers & Modifier.ABSTRACT) == 0 && !abstractClassTypeDeclaration.isInterface()) {
    ListRewrite abstractModifiersRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    abstractModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite abstractBodyRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration abstractMethodDeclaration=abstractAST.newMethodDeclaration();
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(abstractMethodName),null);
  if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
    abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,abstractAST.newPrimitiveType(PrimitiveType.VOID),null);
  }
 else {
    if (returnedVariable != null) {
      Type returnType=null;
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        returnType=singleVariableDeclaration.getType();
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
        returnType=variableDeclarationStatement.getType();
      }
      abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    }
 else {
      abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    }
  }
  ListRewrite abstractMethodModifiersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  if (returnedVariable != null) {
    if (returnedVariable instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
      abstractMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
    }
 else     if (returnedVariable instanceof VariableDeclarationFragment) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    if (!abstractMethodParameter.equals(returnedVariable)) {
      abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
  Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
  Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
  Set<IMethodBinding> superAccessedMethods=typeCheckElimination.getSuperAccessedMethods();
  if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0) {
    SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
    SimpleName parameterType=abstractAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,abstractAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(abstractAST.newSimpleName(typeBinding.getName()),null);
  }
  abstractBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,abstractCompilationUnit,abstractRewriter);
  }
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer abstractTextFileBuffer=bufferManager.getTextFileBuffer(abstractClassFile.getFullPath(),LocationKind.IFILE);
  IDocument abstractDocument=abstractTextFileBuffer.getDocument();
  TextEdit abstractEdit=abstractRewriter.rewriteAST(abstractDocument,null);
  try {
    UndoEdit abstractUndoEdit=abstractEdit.apply(abstractDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(abstractClassFile,abstractDocument,abstractUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  abstractEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  DefaultMutableTreeNode root=typeCheckElimination.getExistingInheritanceTree().getRootNode();
  Enumeration<DefaultMutableTreeNode> enumeration=root.children();
  while (enumeration.hasMoreElements()) {
    DefaultMutableTreeNode child=enumeration.nextElement();
    String childClassName=(String)child.getUserObject();
    if (!subclassNames.contains(childClassName))     subclassNames.add(childClassName);
  }
  for (int i=0; i < subclassNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      Expression expression=typeCheckElimination.getExpressionCorrespondingToTypeCheckStatementList(statements);
      remainingIfStatementExpression=typeCheckElimination.getRemainingIfStatementExpression(expression);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=getFile(rootContainer,subclassNames.get(i));
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    TypeDeclaration subclassTypeDeclaration=null;
    List<AbstractTypeDeclaration> subclassAbstractTypeDeclarations=subclassCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : subclassAbstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.resolveBinding().getQualifiedName().equals(subclassNames.get(i))) {
          subclassTypeDeclaration=typeDeclaration;
          break;
        }
      }
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(abstractMethodName),null);
    if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
      subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,subclassAST.newPrimitiveType(PrimitiveType.VOID),null);
    }
 else {
      if (returnedVariable != null) {
        Type returnType=null;
        if (returnedVariable instanceof SingleVariableDeclaration) {
          SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
          returnType=singleVariableDeclaration.getType();
        }
 else         if (returnedVariable instanceof VariableDeclarationFragment) {
          VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
          returnType=variableDeclarationStatement.getType();
        }
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      }
 else {
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      }
    }
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    if (returnedVariable != null) {
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        concreteMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable)) {
        concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
      }
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(enclosingIfStatementExpression);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods,superAccessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    SimpleName invokerSimpleName=null;
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      boolean insert=true;
      if (statement instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)statement;
        List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
        VariableDeclarationFragment fragment=fragments.get(0);
        if (fragment.getInitializer() instanceof CastExpression) {
          CastExpression castExpression=(CastExpression)fragment.getInitializer();
          if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
            invokerSimpleName=fragment.getName();
            insert=false;
          }
        }
      }
 else {
        StatementExtractor statementExtractor=new StatementExtractor();
        List<Statement> oldVariableDeclarations=statementExtractor.getVariableDeclarations(statement);
        List<Statement> newVariableDeclarations=statementExtractor.getVariableDeclarations(newStatement);
        int j=0;
        for (        Statement oldVariableDeclaration : oldVariableDeclarations) {
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)oldVariableDeclaration;
          List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
          VariableDeclarationFragment fragment=fragments.get(0);
          if (fragment.getInitializer() instanceof CastExpression) {
            CastExpression castExpression=(CastExpression)fragment.getInitializer();
            if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
              invokerSimpleName=fragment.getName();
              subclassRewriter.remove(newVariableDeclarations.get(j),null);
              break;
            }
          }
          j++;
        }
      }
      if (invokerSimpleName != null) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(newStatement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            Expression methodInvocationExpression=methodInvocation.getExpression();
            if (methodInvocationExpression instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)methodInvocationExpression;
              if (simpleName.getIdentifier().equals(invokerSimpleName.getIdentifier())) {
                subclassRewriter.remove(simpleName,null);
              }
            }
          }
        }
      }
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(statement);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods,superAccessedMethods);
      if (insert) {
        if (ifStatementBodyRewrite != null)         ifStatementBodyRewrite.insertLast(newStatement,null);
 else         concreteMethodBodyRewrite.insertLast(newStatement,null);
      }
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}","private void modifyInheritanceHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  PackageDeclaration contextPackageDeclaration=sourceCompilationUnit.getPackage();
  IContainer rootContainer=contextContainer;
  if (contextPackageDeclaration != null) {
    String packageName=contextPackageDeclaration.getName().getFullyQualifiedName();
    String[] subPackages=packageName.split(""String_Node_Str"");
    for (int i=0; i < subPackages.length; i++)     rootContainer=(IContainer)rootContainer.getParent();
  }
  String abstractClassFullyQualifiedName=typeCheckElimination.getAbstractClassName();
  IFile abstractClassFile=getFile(rootContainer,abstractClassFullyQualifiedName);
  IJavaElement abstractJavaElement=JavaCore.create(abstractClassFile);
  ITextEditor abstractEditor=null;
  try {
    abstractEditor=(ITextEditor)JavaUI.openInEditor(abstractJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit abstractICompilationUnit=(ICompilationUnit)abstractJavaElement;
  ASTParser abstractParser=ASTParser.newParser(AST.JLS3);
  abstractParser.setKind(ASTParser.K_COMPILATION_UNIT);
  abstractParser.setSource(abstractICompilationUnit);
  abstractParser.setResolveBindings(true);
  CompilationUnit abstractCompilationUnit=(CompilationUnit)abstractParser.createAST(null);
  AST abstractAST=abstractCompilationUnit.getAST();
  ASTRewrite abstractRewriter=ASTRewrite.create(abstractAST);
  TypeDeclaration abstractClassTypeDeclaration=null;
  List<AbstractTypeDeclaration> abstractTypeDeclarations=abstractCompilationUnit.types();
  for (  AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
    if (abstractTypeDeclaration instanceof TypeDeclaration) {
      TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
      if (typeDeclaration.resolveBinding().getQualifiedName().equals(typeCheckElimination.getAbstractClassName())) {
        abstractClassTypeDeclaration=typeDeclaration;
        break;
      }
    }
  }
  int abstractClassModifiers=abstractClassTypeDeclaration.getModifiers();
  if ((abstractClassModifiers & Modifier.ABSTRACT) == 0 && !abstractClassTypeDeclaration.isInterface()) {
    ListRewrite abstractModifiersRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    abstractModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite abstractBodyRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration abstractMethodDeclaration=abstractAST.newMethodDeclaration();
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(abstractMethodName),null);
  if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
    abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,abstractAST.newPrimitiveType(PrimitiveType.VOID),null);
  }
 else {
    if (returnedVariable != null) {
      Type returnType=null;
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        returnType=singleVariableDeclaration.getType();
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
        returnType=variableDeclarationStatement.getType();
      }
      abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    }
 else {
      abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    }
  }
  ListRewrite abstractMethodModifiersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  if (returnedVariable != null) {
    if (returnedVariable instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
      abstractMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
    }
 else     if (returnedVariable instanceof VariableDeclarationFragment) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    if (!abstractMethodParameter.equals(returnedVariable) && !abstractMethodParameter.equals(typeVariable)) {
      abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable) && !fragment.equals(typeVariable)) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
  Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
  Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
  Set<IMethodBinding> superAccessedMethods=typeCheckElimination.getSuperAccessedMethods();
  if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0) {
    SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
    SimpleName parameterType=abstractAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,abstractAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(abstractAST.newSimpleName(typeBinding.getName()),null);
  }
  abstractBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,abstractCompilationUnit,abstractRewriter);
  }
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer abstractTextFileBuffer=bufferManager.getTextFileBuffer(abstractClassFile.getFullPath(),LocationKind.IFILE);
  IDocument abstractDocument=abstractTextFileBuffer.getDocument();
  TextEdit abstractEdit=abstractRewriter.rewriteAST(abstractDocument,null);
  try {
    UndoEdit abstractUndoEdit=abstractEdit.apply(abstractDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(abstractClassFile,abstractDocument,abstractUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  abstractEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  DefaultMutableTreeNode root=typeCheckElimination.getExistingInheritanceTree().getRootNode();
  Enumeration<DefaultMutableTreeNode> enumeration=root.children();
  while (enumeration.hasMoreElements()) {
    DefaultMutableTreeNode child=enumeration.nextElement();
    String childClassName=(String)child.getUserObject();
    if (!subclassNames.contains(childClassName))     subclassNames.add(childClassName);
  }
  for (int i=0; i < subclassNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      Expression expression=typeCheckElimination.getExpressionCorrespondingToTypeCheckStatementList(statements);
      remainingIfStatementExpression=typeCheckElimination.getRemainingIfStatementExpression(expression);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=getFile(rootContainer,subclassNames.get(i));
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    TypeDeclaration subclassTypeDeclaration=null;
    List<AbstractTypeDeclaration> subclassAbstractTypeDeclarations=subclassCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : subclassAbstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.resolveBinding().getQualifiedName().equals(subclassNames.get(i))) {
          subclassTypeDeclaration=typeDeclaration;
          break;
        }
      }
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(abstractMethodName),null);
    if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
      subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,subclassAST.newPrimitiveType(PrimitiveType.VOID),null);
    }
 else {
      if (returnedVariable != null) {
        Type returnType=null;
        if (returnedVariable instanceof SingleVariableDeclaration) {
          SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
          returnType=singleVariableDeclaration.getType();
        }
 else         if (returnedVariable instanceof VariableDeclarationFragment) {
          VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
          returnType=variableDeclarationStatement.getType();
        }
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      }
 else {
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      }
    }
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    if (returnedVariable != null) {
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        concreteMethodParametersRewrite.insertLast(singleVariableDeclaration,null);
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable) && !abstractMethodParameter.equals(typeVariable)) {
        concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
      }
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable) && !fragment.equals(typeVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(enclosingIfStatementExpression);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,subclassTypeDeclaration,accessedMethods,superAccessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    SimpleName invokerSimpleName=null;
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      boolean insert=true;
      if (statement instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)statement;
        List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
        VariableDeclarationFragment fragment=fragments.get(0);
        if (fragment.getInitializer() instanceof CastExpression) {
          CastExpression castExpression=(CastExpression)fragment.getInitializer();
          if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
            invokerSimpleName=fragment.getName();
            insert=false;
          }
        }
      }
 else {
        StatementExtractor statementExtractor=new StatementExtractor();
        List<Statement> oldVariableDeclarations=statementExtractor.getVariableDeclarations(statement);
        List<Statement> newVariableDeclarations=statementExtractor.getVariableDeclarations(newStatement);
        int j=0;
        for (        Statement oldVariableDeclaration : oldVariableDeclarations) {
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)oldVariableDeclaration;
          List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
          VariableDeclarationFragment fragment=fragments.get(0);
          if (fragment.getInitializer() instanceof CastExpression) {
            CastExpression castExpression=(CastExpression)fragment.getInitializer();
            if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
              if (typeVariable.getName().resolveBinding().isEqualTo(fragment.getName().resolveBinding())) {
                invokerSimpleName=fragment.getName();
                subclassRewriter.remove(newVariableDeclarations.get(j),null);
                break;
              }
            }
          }
          j++;
        }
      }
      if (invokerSimpleName != null) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(newStatement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            Expression methodInvocationExpression=methodInvocation.getExpression();
            if (methodInvocationExpression instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)methodInvocationExpression;
              if (simpleName.getIdentifier().equals(invokerSimpleName.getIdentifier())) {
                subclassRewriter.remove(simpleName,null);
              }
            }
          }
        }
      }
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(statement);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,subclassTypeDeclaration,accessedMethods,superAccessedMethods);
      if (insert) {
        if (ifStatementBodyRewrite != null)         ifStatementBodyRewrite.insertLast(newStatement,null);
 else         concreteMethodBodyRewrite.insertLast(newStatement,null);
      }
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}"
12186,"public ReplaceConditionalWithPolymorphism(IFile sourceFile,CompilationUnit sourceCompilationUnit,TypeDeclaration sourceTypeDeclaration,TypeCheckElimination typeCheckElimination){
  this.sourceFile=sourceFile;
  this.sourceCompilationUnit=sourceCompilationUnit;
  this.sourceTypeDeclaration=sourceTypeDeclaration;
  this.typeCheckElimination=typeCheckElimination;
  this.sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
  this.undoRefactoring=new UndoRefactoring();
  this.returnedVariable=typeCheckElimination.getTypeCheckMethodReturnedVariable();
  this.requiredImportDeclarationsBasedOnSignature=new LinkedHashSet<ITypeBinding>();
  this.thrownExceptions=typeCheckElimination.getThrownExceptions();
  this.abstractMethodName=typeCheckElimination.getTypeCheckMethodName();
}","public ReplaceConditionalWithPolymorphism(IFile sourceFile,CompilationUnit sourceCompilationUnit,TypeDeclaration sourceTypeDeclaration,TypeCheckElimination typeCheckElimination){
  this.sourceFile=sourceFile;
  this.sourceCompilationUnit=sourceCompilationUnit;
  this.sourceTypeDeclaration=sourceTypeDeclaration;
  this.typeCheckElimination=typeCheckElimination;
  this.sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
  this.undoRefactoring=new UndoRefactoring();
  this.returnedVariable=typeCheckElimination.getTypeCheckMethodReturnedVariable();
  this.requiredImportDeclarationsBasedOnSignature=new LinkedHashSet<ITypeBinding>();
  this.thrownExceptions=typeCheckElimination.getThrownExceptions();
  this.abstractMethodName=typeCheckElimination.getTypeCheckMethodName();
  if (typeCheckElimination.getTypeField() != null) {
    this.typeVariable=typeCheckElimination.getTypeField();
  }
 else   if (typeCheckElimination.getTypeLocalVariable() != null) {
    this.typeVariable=typeCheckElimination.getTypeLocalVariable();
  }
}"
12187,"private void modifyMethodInvocationsInSubclass(List<Expression> oldMethodInvocations,List<Expression> newMethodInvocations,AST subclassAST,ASTRewrite subclassRewriter,Set<MethodDeclaration> accessedMethods,Set<IMethodBinding> superAccessedMethods){
  int j=0;
  for (  Expression expression : newMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation newMethodInvocation=(MethodInvocation)expression;
      MethodInvocation oldMethodInvocation=(MethodInvocation)oldMethodInvocations.get(j);
      for (      MethodDeclaration methodDeclaration : accessedMethods) {
        if (oldMethodInvocation.resolveMethodBinding().isEqualTo(methodDeclaration.resolveBinding())) {
          String invokerName=sourceTypeDeclaration.getName().getIdentifier();
          invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
          subclassRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
          break;
        }
      }
      for (      IMethodBinding superMethodBinding : superAccessedMethods) {
        if (superMethodBinding.isEqualTo(oldMethodInvocation.resolveMethodBinding())) {
          if (oldMethodInvocation.getExpression() == null || (oldMethodInvocation.getExpression() != null && oldMethodInvocation.getExpression() instanceof ThisExpression)) {
            String invokerName=sourceTypeDeclaration.getName().getIdentifier();
            invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
            subclassRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            break;
          }
        }
      }
    }
    j++;
  }
}","private void modifyMethodInvocationsInSubclass(List<Expression> oldMethodInvocations,List<Expression> newMethodInvocations,AST subclassAST,ASTRewrite subclassRewriter,TypeDeclaration subclassTypeDeclaration,Set<MethodDeclaration> accessedMethods,Set<IMethodBinding> superAccessedMethods){
  int j=0;
  for (  Expression expression : newMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation newMethodInvocation=(MethodInvocation)expression;
      MethodInvocation oldMethodInvocation=(MethodInvocation)oldMethodInvocations.get(j);
      for (      MethodDeclaration methodDeclaration : accessedMethods) {
        if (oldMethodInvocation.resolveMethodBinding().isEqualTo(methodDeclaration.resolveBinding())) {
          String invokerName=sourceTypeDeclaration.getName().getIdentifier();
          invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
          subclassRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
          break;
        }
      }
      for (      IMethodBinding superMethodBinding : superAccessedMethods) {
        if (superMethodBinding.isEqualTo(oldMethodInvocation.resolveMethodBinding())) {
          if (oldMethodInvocation.getExpression() == null || (oldMethodInvocation.getExpression() != null && oldMethodInvocation.getExpression() instanceof ThisExpression)) {
            String invokerName=sourceTypeDeclaration.getName().getIdentifier();
            invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
            subclassRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            break;
          }
        }
      }
      Expression newMethodInvocationExpression=newMethodInvocation.getExpression();
      Expression oldMethodInvocationExpression=oldMethodInvocation.getExpression();
      if (oldMethodInvocationExpression != null && oldMethodInvocationExpression instanceof ParenthesizedExpression) {
        ParenthesizedExpression oldParenthesizedExpression=(ParenthesizedExpression)oldMethodInvocationExpression;
        if (oldParenthesizedExpression.getExpression() instanceof CastExpression) {
          CastExpression oldCastExpression=(CastExpression)oldParenthesizedExpression.getExpression();
          if (oldCastExpression.getExpression() instanceof SimpleName) {
            SimpleName castSimpleName=(SimpleName)oldCastExpression.getExpression();
            if (oldCastExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
              if (typeVariable.getName().resolveBinding().isEqualTo(castSimpleName.resolveBinding())) {
                subclassRewriter.remove(newMethodInvocationExpression,null);
              }
            }
          }
        }
      }
    }
    j++;
  }
}"
12188,"private void modifyClient(){
  AST clientAST=sourceTypeDeclaration.getAST();
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
    MethodInvocation abstractMethodInvocation=clientAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,clientAST.newSimpleName(abstractMethodName),null);
    SimpleName typeVariableName=null;
    if (typeCheckElimination.getTypeField() != null) {
      typeVariableName=typeCheckElimination.getTypeField().getName();
    }
 else     if (typeCheckElimination.getTypeLocalVariable() != null) {
      typeVariableName=typeCheckElimination.getTypeLocalVariable().getName();
    }
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeVariableName,null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
      }
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(clientAST.newThisExpression(),null);
    }
    ExpressionStatement expressionStatement=clientAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    MethodInvocation abstractMethodInvocation=clientAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,clientAST.newSimpleName(abstractMethodName),null);
    SimpleName typeVariableName=null;
    if (typeCheckElimination.getTypeField() != null) {
      typeVariableName=typeCheckElimination.getTypeField().getName();
    }
 else     if (typeCheckElimination.getTypeLocalVariable() != null) {
      typeVariableName=typeCheckElimination.getTypeLocalVariable().getName();
    }
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeVariableName,null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    if (returnedVariable != null) {
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        methodInvocationArgumentsRewrite.insertLast(singleVariableDeclaration.getName(),null);
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        methodInvocationArgumentsRewrite.insertLast(variableDeclarationFragment.getName(),null);
      }
    }
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
      }
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(clientAST.newThisExpression(),null);
    }
    if (returnedVariable != null) {
      Assignment assignment=clientAST.newAssignment();
      sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
      ExpressionStatement expressionStatement=clientAST.newExpressionStatement(assignment);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
    }
 else {
      ReturnStatement returnStatement=clientAST.newReturnStatement();
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractMethodInvocation,null);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),returnStatement,null);
    }
  }
  generateGettersForAccessedFields();
  generateSettersForAssignedFields();
  setPublicModifierToAccessedMethods();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","private void modifyClient(){
  AST clientAST=sourceTypeDeclaration.getAST();
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
    MethodInvocation abstractMethodInvocation=clientAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,clientAST.newSimpleName(abstractMethodName),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeVariable.getName(),null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable) && !abstractMethodParameter.equals(typeVariable)) {
        methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
      }
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable) && !fragment.equals(typeVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(clientAST.newThisExpression(),null);
    }
    ExpressionStatement expressionStatement=clientAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    MethodInvocation abstractMethodInvocation=clientAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,clientAST.newSimpleName(abstractMethodName),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeVariable.getName(),null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    if (returnedVariable != null) {
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        methodInvocationArgumentsRewrite.insertLast(singleVariableDeclaration.getName(),null);
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        methodInvocationArgumentsRewrite.insertLast(variableDeclarationFragment.getName(),null);
      }
    }
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      if (!abstractMethodParameter.equals(returnedVariable) && !abstractMethodParameter.equals(typeVariable)) {
        methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
      }
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable) && !fragment.equals(typeVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(clientAST.newThisExpression(),null);
    }
    if (returnedVariable != null) {
      Assignment assignment=clientAST.newAssignment();
      sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
      ExpressionStatement expressionStatement=clientAST.newExpressionStatement(assignment);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
    }
 else {
      ReturnStatement returnStatement=clientAST.newReturnStatement();
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractMethodInvocation,null);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),returnStatement,null);
    }
  }
  generateGettersForAccessedFields();
  generateSettersForAssignedFields();
  setPublicModifierToAccessedMethods();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12189,"private void generateRequiredImportDeclarationsBasedOnSignature(){
  List<ITypeBinding> typeBindings=new ArrayList<ITypeBinding>();
  if (returnedVariable != null) {
    Type returnType=null;
    if (returnedVariable instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
      returnType=singleVariableDeclaration.getType();
    }
 else     if (returnedVariable instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
      returnType=variableDeclarationStatement.getType();
    }
    ITypeBinding returnTypeBinding=returnType.resolveBinding();
    if (!typeBindings.contains(returnTypeBinding))     typeBindings.add(returnTypeBinding);
  }
  Set<SingleVariableDeclaration> parameters=typeCheckElimination.getAccessedParameters();
  for (  SingleVariableDeclaration parameter : parameters) {
    Type parameterType=parameter.getType();
    ITypeBinding parameterTypeBinding=parameterType.resolveBinding();
    if (!typeBindings.contains(parameterTypeBinding))     typeBindings.add(parameterTypeBinding);
  }
  Set<VariableDeclarationFragment> accessedLocalVariables=typeCheckElimination.getAccessedLocalVariables();
  for (  VariableDeclarationFragment fragment : accessedLocalVariables) {
    if (!fragment.equals(returnedVariable)) {
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      Type variableType=variableDeclarationStatement.getType();
      ITypeBinding variableTypeBinding=variableType.resolveBinding();
      if (!typeBindings.contains(variableTypeBinding))       typeBindings.add(variableTypeBinding);
    }
  }
  if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
    if (!typeBindings.contains(sourceTypeDeclaration.resolveBinding()))     typeBindings.add(sourceTypeDeclaration.resolveBinding());
  }
  for (  ITypeBinding typeBinding : thrownExceptions) {
    if (!typeBindings.contains(typeBinding))     typeBindings.add(typeBinding);
  }
  getSimpleTypeBindings(typeBindings,requiredImportDeclarationsBasedOnSignature);
}","private void generateRequiredImportDeclarationsBasedOnSignature(){
  List<ITypeBinding> typeBindings=new ArrayList<ITypeBinding>();
  if (returnedVariable != null) {
    Type returnType=null;
    if (returnedVariable instanceof SingleVariableDeclaration) {
      SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
      returnType=singleVariableDeclaration.getType();
    }
 else     if (returnedVariable instanceof VariableDeclarationFragment) {
      VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
      returnType=variableDeclarationStatement.getType();
    }
    ITypeBinding returnTypeBinding=returnType.resolveBinding();
    if (!typeBindings.contains(returnTypeBinding))     typeBindings.add(returnTypeBinding);
  }
  Set<SingleVariableDeclaration> parameters=typeCheckElimination.getAccessedParameters();
  for (  SingleVariableDeclaration parameter : parameters) {
    if (!parameter.equals(returnedVariable) && !parameter.equals(typeVariable)) {
      Type parameterType=parameter.getType();
      ITypeBinding parameterTypeBinding=parameterType.resolveBinding();
      if (!typeBindings.contains(parameterTypeBinding))       typeBindings.add(parameterTypeBinding);
    }
  }
  Set<VariableDeclarationFragment> accessedLocalVariables=typeCheckElimination.getAccessedLocalVariables();
  for (  VariableDeclarationFragment fragment : accessedLocalVariables) {
    if (!fragment.equals(returnedVariable) && !fragment.equals(typeVariable)) {
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      Type variableType=variableDeclarationStatement.getType();
      ITypeBinding variableTypeBinding=variableType.resolveBinding();
      if (!typeBindings.contains(variableTypeBinding))       typeBindings.add(variableTypeBinding);
    }
  }
  if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
    if (!typeBindings.contains(sourceTypeDeclaration.resolveBinding()))     typeBindings.add(sourceTypeDeclaration.resolveBinding());
  }
  for (  ITypeBinding typeBinding : thrownExceptions) {
    if (!typeBindings.contains(typeBinding))     typeBindings.add(typeBinding);
  }
  getSimpleTypeBindings(typeBindings,requiredImportDeclarationsBasedOnSignature);
}"
12190,"public List<TypeCheckElimination> generateTypeCheckEliminations(){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  Map<TypeCheckElimination,List<SimpleName>> staticFieldMap=new LinkedHashMap<TypeCheckElimination,List<SimpleName>>();
  Map<Integer,ArrayList<TypeCheckElimination>> staticFieldRankMap=new TreeMap<Integer,ArrayList<TypeCheckElimination>>();
  CompleteInheritanceDetection inheritanceDetection=new CompleteInheritanceDetection(this);
  for (  ClassObject classObject : classList) {
    List<TypeCheckElimination> eliminations=classObject.generateTypeCheckEliminations();
    for (    TypeCheckElimination elimination : eliminations) {
      List<SimpleName> staticFields=elimination.getStaticFields();
      if (!staticFields.isEmpty()) {
        inheritanceHierarchyMatchingWithStaticTypes(elimination,inheritanceDetection);
        boolean isValid=false;
        if (elimination.getTypeField() != null) {
          IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
          ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
          if ((typeFieldTypeBinding.isPrimitive() && typeFieldTypeBinding.getQualifiedName().equals(""String_Node_Str"")) || typeFieldTypeBinding.isEnum()) {
            isValid=true;
          }
        }
 else         if (elimination.getTypeLocalVariable() != null) {
          IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
          ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
          if ((typeLocalVariableTypeBinding.isPrimitive() && typeLocalVariableTypeBinding.getQualifiedName().equals(""String_Node_Str"")) || typeLocalVariableTypeBinding.isEnum()) {
            isValid=true;
          }
        }
 else         if (elimination.getTypeMethodInvocation() != null) {
          MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
          IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
          ITypeBinding typeMethodInvocationDeclaringClass=typeMethodInvocationBinding.getDeclaringClass();
          ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
          ClassObject declaringClassObject=getClassObject(typeMethodInvocationDeclaringClass.getQualifiedName());
          if (((typeMethodInvocationReturnType.isPrimitive() && typeMethodInvocationReturnType.getQualifiedName().equals(""String_Node_Str"")) || typeMethodInvocationReturnType.isEnum()) && declaringClassObject != null) {
            MethodDeclaration invokedMethodDeclaration=null;
            ListIterator<MethodObject> methodIterator=declaringClassObject.getMethodIterator();
            while (methodIterator.hasNext()) {
              MethodObject methodObject=methodIterator.next();
              MethodDeclaration methodDeclaration=methodObject.getMethodDeclaration();
              if (typeMethodInvocationBinding.isEqualTo(methodDeclaration.resolveBinding())) {
                invokedMethodDeclaration=methodDeclaration;
                break;
              }
            }
            SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(invokedMethodDeclaration);
            if (fieldInstruction != null) {
              ListIterator<FieldObject> fieldIterator=declaringClassObject.getFieldIterator();
              while (fieldIterator.hasNext()) {
                FieldObject fieldObject=fieldIterator.next();
                VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                if (fieldInstruction.resolveBinding().isEqualTo(fragment.resolveBinding())) {
                  elimination.setForeignTypeField(fragment);
                  break;
                }
              }
              isValid=true;
            }
 else             if (invokedMethodDeclaration.getBody() == null) {
              InheritanceTree tree=elimination.getInheritanceTreeMatchingWithStaticTypes();
              if (tree != null) {
                Expression typeMethodInvocationExpression=typeMethodInvocation.getExpression();
                ITypeBinding typeCheckClassBinding=elimination.getTypeCheckClass().resolveBinding();
                ClassObject typeCheckClassObject=getClassObject(typeCheckClassBinding.getQualifiedName());
                SimpleName invoker=null;
                if (typeMethodInvocationExpression instanceof SimpleName) {
                  invoker=(SimpleName)typeMethodInvocationExpression;
                }
 else                 if (typeMethodInvocationExpression instanceof FieldAccess) {
                  FieldAccess fieldAccess=(FieldAccess)typeMethodInvocationExpression;
                  invoker=fieldAccess.getName();
                }
                if (invoker != null) {
                  IBinding binding=invoker.resolveBinding();
                  if (binding.getKind() == IBinding.VARIABLE) {
                    IVariableBinding variableBinding=(IVariableBinding)binding;
                    if (variableBinding.isField()) {
                      ListIterator<FieldObject> fieldIterator=typeCheckClassObject.getFieldIterator();
                      while (fieldIterator.hasNext()) {
                        FieldObject fieldObject=fieldIterator.next();
                        VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                        if (variableBinding.isEqualTo(fragment.resolveBinding())) {
                          elimination.setTypeField(fragment);
                          break;
                        }
                      }
                    }
 else                     if (variableBinding.isParameter()) {
                      List<SingleVariableDeclaration> parameters=elimination.getTypeCheckMethodParameters();
                      for (                      SingleVariableDeclaration parameter : parameters) {
                        IVariableBinding parameterVariableBinding=parameter.resolveBinding();
                        if (parameterVariableBinding.isEqualTo(variableBinding)) {
                          elimination.setTypeLocalVariable(parameter);
                          break;
                        }
                      }
                    }
 else {
                      StatementExtractor statementExtractor=new StatementExtractor();
                      Block typeCheckMethodBody=elimination.getTypeCheckMethod().getBody();
                      List<Statement> variableDeclarationStatements=statementExtractor.getVariableDeclarations(typeCheckMethodBody);
                      for (                      Statement vDStatement : variableDeclarationStatements) {
                        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
                        List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
                        for (                        VariableDeclarationFragment fragment : fragments) {
                          IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                          if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                            elimination.setTypeLocalVariable(fragment);
                            break;
                          }
                        }
                      }
                      List<Statement> enhancedForStatements=statementExtractor.getEnhancedForStatements(typeCheckMethodBody);
                      for (                      Statement eFStatement : enhancedForStatements) {
                        EnhancedForStatement enhancedForStatement=(EnhancedForStatement)eFStatement;
                        SingleVariableDeclaration formalParameter=enhancedForStatement.getParameter();
                        IVariableBinding parameterVariableBinding=formalParameter.resolveBinding();
                        if (parameterVariableBinding.isEqualTo(variableBinding)) {
                          elimination.setTypeLocalVariable(formalParameter);
                          break;
                        }
                      }
                    }
                    ITypeBinding invokerType=variableBinding.getType();
                    if (invokerType.getQualifiedName().equals(tree.getRootNode().getUserObject())) {
                      elimination.setExistingInheritanceTree(tree);
                      typeCheckEliminations.add(elimination);
                    }
                  }
                }
              }
            }
          }
        }
        if (isValid) {
          staticFieldMap.put(elimination,staticFields);
          int size=staticFields.size();
          if (staticFieldRankMap.containsKey(size)) {
            ArrayList<TypeCheckElimination> rank=staticFieldRankMap.get(size);
            rank.add(elimination);
          }
 else {
            ArrayList<TypeCheckElimination> rank=new ArrayList<TypeCheckElimination>();
            rank.add(elimination);
            staticFieldRankMap.put(size,rank);
          }
        }
      }
 else {
        if (elimination.getTypeField() != null) {
          IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
          ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeFieldTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeLocalVariable() != null) {
          IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
          ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeLocalVariableTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeMethodInvocation() != null) {
          MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
          Expression typeMethodInvocationExpression=typeMethodInvocation.getExpression();
          ITypeBinding typeCheckClassBinding=elimination.getTypeCheckClass().resolveBinding();
          ClassObject typeCheckClassObject=getClassObject(typeCheckClassBinding.getQualifiedName());
          SimpleName invoker=null;
          if (typeMethodInvocationExpression instanceof SimpleName) {
            invoker=(SimpleName)typeMethodInvocationExpression;
          }
 else           if (typeMethodInvocationExpression instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)typeMethodInvocationExpression;
            invoker=fieldAccess.getName();
          }
          if (invoker != null) {
            IBinding binding=invoker.resolveBinding();
            if (binding.getKind() == IBinding.VARIABLE) {
              IVariableBinding variableBinding=(IVariableBinding)binding;
              if (variableBinding.isField()) {
                ListIterator<FieldObject> fieldIterator=typeCheckClassObject.getFieldIterator();
                while (fieldIterator.hasNext()) {
                  FieldObject fieldObject=fieldIterator.next();
                  VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                  if (variableBinding.isEqualTo(fragment.resolveBinding())) {
                    elimination.setTypeField(fragment);
                    break;
                  }
                }
              }
 else               if (variableBinding.isParameter()) {
                List<SingleVariableDeclaration> parameters=elimination.getTypeCheckMethodParameters();
                for (                SingleVariableDeclaration parameter : parameters) {
                  IVariableBinding parameterVariableBinding=parameter.resolveBinding();
                  if (parameterVariableBinding.isEqualTo(variableBinding)) {
                    elimination.setTypeLocalVariable(parameter);
                    break;
                  }
                }
              }
 else {
                StatementExtractor statementExtractor=new StatementExtractor();
                Block typeCheckMethodBody=elimination.getTypeCheckMethod().getBody();
                List<Statement> variableDeclarationStatements=statementExtractor.getVariableDeclarations(typeCheckMethodBody);
                for (                Statement vDStatement : variableDeclarationStatements) {
                  VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
                  List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
                  for (                  VariableDeclarationFragment fragment : fragments) {
                    IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                    if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                      elimination.setTypeLocalVariable(fragment);
                      break;
                    }
                  }
                }
                List<Statement> enhancedForStatements=statementExtractor.getEnhancedForStatements(typeCheckMethodBody);
                for (                Statement eFStatement : enhancedForStatements) {
                  EnhancedForStatement enhancedForStatement=(EnhancedForStatement)eFStatement;
                  SingleVariableDeclaration formalParameter=enhancedForStatement.getParameter();
                  IVariableBinding parameterVariableBinding=formalParameter.resolveBinding();
                  if (parameterVariableBinding.isEqualTo(variableBinding)) {
                    elimination.setTypeLocalVariable(formalParameter);
                    break;
                  }
                }
              }
              ITypeBinding invokerType=variableBinding.getType();
              InheritanceTree tree=inheritanceDetection.getTree(invokerType.getQualifiedName());
              elimination.setExistingInheritanceTree(tree);
            }
          }
        }
        if (elimination.getExistingInheritanceTree() != null)         typeCheckEliminations.add(elimination);
      }
    }
  }
  List<TypeCheckElimination> sortedEliminations=new ArrayList<TypeCheckElimination>();
  List<Integer> keyList=new ArrayList<Integer>(staticFieldRankMap.keySet());
  ListIterator<Integer> keyListIterator=keyList.listIterator(keyList.size());
  while (keyListIterator.hasPrevious()) {
    Integer states=keyListIterator.previous();
    sortedEliminations.addAll(staticFieldRankMap.get(states));
  }
  while (!sortedEliminations.isEmpty()) {
    TypeCheckElimination selectedElimination=sortedEliminations.get(0);
    List<TypeCheckElimination> affectedEliminations=new ArrayList<TypeCheckElimination>();
    affectedEliminations.add(selectedElimination);
    List<SimpleName> staticFieldUnion=staticFieldMap.get(selectedElimination);
    for (    TypeCheckElimination elimination : sortedEliminations) {
      List<SimpleName> staticFields=staticFieldMap.get(elimination);
      if (!selectedElimination.equals(elimination) && nonEmptyIntersection(staticFieldUnion,staticFields)) {
        staticFieldUnion=constructUnion(staticFieldUnion,staticFields);
        affectedEliminations.add(elimination);
      }
    }
    if (affectedEliminations.size() > 1) {
      for (      TypeCheckElimination elimination : affectedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        for (        SimpleName simpleName1 : staticFieldUnion) {
          boolean isContained=false;
          for (          SimpleName simpleName2 : staticFields) {
            if (simpleName1.resolveBinding().isEqualTo(simpleName2.resolveBinding())) {
              isContained=true;
              break;
            }
          }
          if (!isContained)           elimination.addAdditionalStaticField(simpleName1);
        }
      }
    }
    for (    TypeCheckElimination elimination : affectedEliminations) {
      if (!elimination.isTypeCheckMethodStateSetter())       typeCheckEliminations.add(elimination);
    }
    sortedEliminations.removeAll(affectedEliminations);
  }
  return typeCheckEliminations;
}","public List<TypeCheckElimination> generateTypeCheckEliminations(){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  Map<TypeCheckElimination,List<SimpleName>> staticFieldMap=new LinkedHashMap<TypeCheckElimination,List<SimpleName>>();
  Map<Integer,ArrayList<TypeCheckElimination>> staticFieldRankMap=new TreeMap<Integer,ArrayList<TypeCheckElimination>>();
  CompleteInheritanceDetection inheritanceDetection=new CompleteInheritanceDetection(this);
  for (  ClassObject classObject : classList) {
    List<TypeCheckElimination> eliminations=classObject.generateTypeCheckEliminations();
    for (    TypeCheckElimination elimination : eliminations) {
      List<SimpleName> staticFields=elimination.getStaticFields();
      if (!staticFields.isEmpty()) {
        inheritanceHierarchyMatchingWithStaticTypes(elimination,inheritanceDetection);
        boolean isValid=false;
        if (elimination.getTypeField() != null) {
          IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
          ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
          if ((typeFieldTypeBinding.isPrimitive() && typeFieldTypeBinding.getQualifiedName().equals(""String_Node_Str"")) || typeFieldTypeBinding.isEnum()) {
            isValid=true;
          }
        }
 else         if (elimination.getTypeLocalVariable() != null) {
          IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
          ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
          if ((typeLocalVariableTypeBinding.isPrimitive() && typeLocalVariableTypeBinding.getQualifiedName().equals(""String_Node_Str"")) || typeLocalVariableTypeBinding.isEnum()) {
            isValid=true;
          }
        }
 else         if (elimination.getTypeMethodInvocation() != null) {
          MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
          IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
          ITypeBinding typeMethodInvocationDeclaringClass=typeMethodInvocationBinding.getDeclaringClass();
          ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
          ClassObject declaringClassObject=getClassObject(typeMethodInvocationDeclaringClass.getQualifiedName());
          if (((typeMethodInvocationReturnType.isPrimitive() && typeMethodInvocationReturnType.getQualifiedName().equals(""String_Node_Str"")) || typeMethodInvocationReturnType.isEnum()) && declaringClassObject != null) {
            MethodDeclaration invokedMethodDeclaration=null;
            ListIterator<MethodObject> methodIterator=declaringClassObject.getMethodIterator();
            while (methodIterator.hasNext()) {
              MethodObject methodObject=methodIterator.next();
              MethodDeclaration methodDeclaration=methodObject.getMethodDeclaration();
              if (typeMethodInvocationBinding.isEqualTo(methodDeclaration.resolveBinding())) {
                invokedMethodDeclaration=methodDeclaration;
                break;
              }
            }
            SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(invokedMethodDeclaration);
            if (fieldInstruction != null) {
              ListIterator<FieldObject> fieldIterator=declaringClassObject.getFieldIterator();
              while (fieldIterator.hasNext()) {
                FieldObject fieldObject=fieldIterator.next();
                VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                if (fieldInstruction.resolveBinding().isEqualTo(fragment.resolveBinding())) {
                  elimination.setForeignTypeField(fragment);
                  break;
                }
              }
              isValid=true;
            }
 else             if (invokedMethodDeclaration.getBody() == null) {
              InheritanceTree tree=elimination.getInheritanceTreeMatchingWithStaticTypes();
              if (tree != null) {
                Expression typeMethodInvocationExpression=typeMethodInvocation.getExpression();
                ITypeBinding typeCheckClassBinding=elimination.getTypeCheckClass().resolveBinding();
                ClassObject typeCheckClassObject=getClassObject(typeCheckClassBinding.getQualifiedName());
                SimpleName invoker=null;
                if (typeMethodInvocationExpression instanceof SimpleName) {
                  invoker=(SimpleName)typeMethodInvocationExpression;
                }
 else                 if (typeMethodInvocationExpression instanceof FieldAccess) {
                  FieldAccess fieldAccess=(FieldAccess)typeMethodInvocationExpression;
                  invoker=fieldAccess.getName();
                }
                if (invoker != null) {
                  IBinding binding=invoker.resolveBinding();
                  if (binding.getKind() == IBinding.VARIABLE) {
                    IVariableBinding variableBinding=(IVariableBinding)binding;
                    if (variableBinding.isField()) {
                      ListIterator<FieldObject> fieldIterator=typeCheckClassObject.getFieldIterator();
                      while (fieldIterator.hasNext()) {
                        FieldObject fieldObject=fieldIterator.next();
                        VariableDeclarationFragment fragment=fieldObject.getVariableDeclarationFragment();
                        if (variableBinding.isEqualTo(fragment.resolveBinding())) {
                          elimination.setTypeField(fragment);
                          break;
                        }
                      }
                    }
 else                     if (variableBinding.isParameter()) {
                      List<SingleVariableDeclaration> parameters=elimination.getTypeCheckMethodParameters();
                      for (                      SingleVariableDeclaration parameter : parameters) {
                        IVariableBinding parameterVariableBinding=parameter.resolveBinding();
                        if (parameterVariableBinding.isEqualTo(variableBinding)) {
                          elimination.setTypeLocalVariable(parameter);
                          break;
                        }
                      }
                    }
 else {
                      StatementExtractor statementExtractor=new StatementExtractor();
                      Block typeCheckMethodBody=elimination.getTypeCheckMethod().getBody();
                      List<Statement> variableDeclarationStatements=statementExtractor.getVariableDeclarations(typeCheckMethodBody);
                      for (                      Statement vDStatement : variableDeclarationStatements) {
                        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
                        List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
                        for (                        VariableDeclarationFragment fragment : fragments) {
                          IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                          if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                            elimination.setTypeLocalVariable(fragment);
                            break;
                          }
                        }
                      }
                      List<Statement> enhancedForStatements=statementExtractor.getEnhancedForStatements(typeCheckMethodBody);
                      for (                      Statement eFStatement : enhancedForStatements) {
                        EnhancedForStatement enhancedForStatement=(EnhancedForStatement)eFStatement;
                        SingleVariableDeclaration formalParameter=enhancedForStatement.getParameter();
                        IVariableBinding parameterVariableBinding=formalParameter.resolveBinding();
                        if (parameterVariableBinding.isEqualTo(variableBinding)) {
                          elimination.setTypeLocalVariable(formalParameter);
                          break;
                        }
                      }
                    }
                    ITypeBinding invokerType=variableBinding.getType();
                    if (invokerType.getQualifiedName().equals(tree.getRootNode().getUserObject())) {
                      elimination.setExistingInheritanceTree(tree);
                      typeCheckEliminations.add(elimination);
                    }
                  }
                }
              }
            }
          }
        }
        if (isValid) {
          staticFieldMap.put(elimination,staticFields);
          int size=staticFields.size();
          if (staticFieldRankMap.containsKey(size)) {
            ArrayList<TypeCheckElimination> rank=staticFieldRankMap.get(size);
            rank.add(elimination);
          }
 else {
            ArrayList<TypeCheckElimination> rank=new ArrayList<TypeCheckElimination>();
            rank.add(elimination);
            staticFieldRankMap.put(size,rank);
          }
        }
      }
 else {
        if (elimination.getTypeField() != null) {
          IVariableBinding typeFieldBinding=elimination.getTypeField().resolveBinding();
          ITypeBinding typeFieldTypeBinding=typeFieldBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeFieldTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeLocalVariable() != null) {
          IVariableBinding typeLocalVariableBinding=elimination.getTypeLocalVariable().resolveBinding();
          ITypeBinding typeLocalVariableTypeBinding=typeLocalVariableBinding.getType();
          InheritanceTree tree=inheritanceDetection.getTree(typeLocalVariableTypeBinding.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
 else         if (elimination.getTypeMethodInvocation() != null) {
          MethodInvocation typeMethodInvocation=elimination.getTypeMethodInvocation();
          IMethodBinding typeMethodInvocationBinding=typeMethodInvocation.resolveMethodBinding();
          ITypeBinding typeMethodInvocationReturnType=typeMethodInvocationBinding.getReturnType();
          InheritanceTree tree=inheritanceDetection.getTree(typeMethodInvocationReturnType.getQualifiedName());
          elimination.setExistingInheritanceTree(tree);
        }
        if (elimination.getExistingInheritanceTree() != null)         typeCheckEliminations.add(elimination);
      }
    }
  }
  List<TypeCheckElimination> sortedEliminations=new ArrayList<TypeCheckElimination>();
  List<Integer> keyList=new ArrayList<Integer>(staticFieldRankMap.keySet());
  ListIterator<Integer> keyListIterator=keyList.listIterator(keyList.size());
  while (keyListIterator.hasPrevious()) {
    Integer states=keyListIterator.previous();
    sortedEliminations.addAll(staticFieldRankMap.get(states));
  }
  while (!sortedEliminations.isEmpty()) {
    TypeCheckElimination selectedElimination=sortedEliminations.get(0);
    List<TypeCheckElimination> affectedEliminations=new ArrayList<TypeCheckElimination>();
    affectedEliminations.add(selectedElimination);
    List<SimpleName> staticFieldUnion=staticFieldMap.get(selectedElimination);
    for (    TypeCheckElimination elimination : sortedEliminations) {
      List<SimpleName> staticFields=staticFieldMap.get(elimination);
      if (!selectedElimination.equals(elimination) && nonEmptyIntersection(staticFieldUnion,staticFields)) {
        staticFieldUnion=constructUnion(staticFieldUnion,staticFields);
        affectedEliminations.add(elimination);
      }
    }
    if (affectedEliminations.size() > 1) {
      for (      TypeCheckElimination elimination : affectedEliminations) {
        List<SimpleName> staticFields=staticFieldMap.get(elimination);
        for (        SimpleName simpleName1 : staticFieldUnion) {
          boolean isContained=false;
          for (          SimpleName simpleName2 : staticFields) {
            if (simpleName1.resolveBinding().isEqualTo(simpleName2.resolveBinding())) {
              isContained=true;
              break;
            }
          }
          if (!isContained)           elimination.addAdditionalStaticField(simpleName1);
        }
      }
    }
    for (    TypeCheckElimination elimination : affectedEliminations) {
      if (!elimination.isTypeCheckMethodStateSetter())       typeCheckEliminations.add(elimination);
    }
    sortedEliminations.removeAll(affectedEliminations);
  }
  return typeCheckEliminations;
}"
12191,"public List<TypeCheckElimination> generateTypeCheckEliminations(CompleteInheritanceDetection inheritanceDetection){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  for (  MethodObject methodObject : methodList) {
    MethodBodyObject methodBodyObject=methodObject.getMethodBody();
    if (methodBodyObject != null) {
      List<TypeCheckElimination> list=methodBodyObject.generateTypeCheckEliminations();
      for (      TypeCheckElimination typeCheckElimination : list) {
        if (!typeCheckElimination.allTypeCheckBranchesAreEmpty()) {
          TypeCheckCodeFragmentAnalyzer analyzer=new TypeCheckCodeFragmentAnalyzer(typeCheckElimination,typeDeclaration,methodObject.getMethodDeclaration(),inheritanceDetection);
          if ((typeCheckElimination.getTypeField() != null || typeCheckElimination.getTypeLocalVariable() != null) && typeCheckElimination.allTypeCheckingsContainStaticFieldOrSubclassType() && typeCheckElimination.isApplicable()) {
            analyzer.processTypeCheckCodeFragmentBranches();
            if (typeCheckElimination.getExistingInheritanceTree() == null)             analyzer.inheritanceHierarchyMatchingWithStaticTypes();
            if (!typeCheckElimination.isTypeCheckMethodStateSetter())             typeCheckEliminations.add(typeCheckElimination);
          }
        }
      }
    }
  }
  return typeCheckEliminations;
}","public List<TypeCheckElimination> generateTypeCheckEliminations(CompleteInheritanceDetection inheritanceDetection){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  for (  MethodObject methodObject : methodList) {
    MethodBodyObject methodBodyObject=methodObject.getMethodBody();
    if (methodBodyObject != null) {
      List<TypeCheckElimination> list=methodBodyObject.generateTypeCheckEliminations();
      for (      TypeCheckElimination typeCheckElimination : list) {
        if (!typeCheckElimination.allTypeCheckBranchesAreEmpty()) {
          TypeCheckCodeFragmentAnalyzer analyzer=new TypeCheckCodeFragmentAnalyzer(typeCheckElimination,typeDeclaration,methodObject.getMethodDeclaration(),inheritanceDetection);
          if ((typeCheckElimination.getTypeField() != null || typeCheckElimination.getTypeLocalVariable() != null) && typeCheckElimination.allTypeCheckingsContainStaticFieldOrSubclassType() && typeCheckElimination.isApplicable()) {
            if (typeCheckElimination.getExistingInheritanceTree() == null)             analyzer.inheritanceHierarchyMatchingWithStaticTypes();
            if (!typeCheckElimination.isTypeCheckMethodStateSetter())             typeCheckEliminations.add(typeCheckElimination);
          }
        }
      }
    }
  }
  return typeCheckEliminations;
}"
12192,"public void processTypeCheckCodeFragmentBranches(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<ArrayList<Statement>> allTypeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  if (!typeCheckElimination.getDefaultCaseStatements().isEmpty()) {
    allTypeCheckStatements.add(typeCheckElimination.getDefaultCaseStatements());
  }
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment=statementExtractor.getVariableDeclarations(typeCheckMethod.getBody());
  for (  ArrayList<Statement> typeCheckStatementList : allTypeCheckStatements) {
    for (    Statement statement : typeCheckStatementList) {
      variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment.removeAll(statementExtractor.getVariableDeclarations(statement));
    }
  }
  for (  ArrayList<Statement> typeCheckStatementList : allTypeCheckStatements) {
    for (    Statement statement : typeCheckStatementList) {
      List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
      for (      Expression expression : methodInvocations) {
        if (expression instanceof MethodInvocation) {
          MethodInvocation methodInvocation=(MethodInvocation)expression;
          IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
          if (methodBinding.getDeclaringClass().isEqualTo(typeDeclaration.resolveBinding())) {
            for (            MethodDeclaration method : methods) {
              if (method.resolveBinding().isEqualTo(methodBinding)) {
                typeCheckElimination.addAccessedMethod(method);
              }
            }
          }
 else {
            ITypeBinding superclassTypeBinding=typeDeclaration.resolveBinding().getSuperclass();
            while (superclassTypeBinding != null && !superclassTypeBinding.isEqualTo(methodBinding.getDeclaringClass())) {
              superclassTypeBinding=superclassTypeBinding.getSuperclass();
            }
            if (methodBinding.getDeclaringClass().isEqualTo(superclassTypeBinding))             typeCheckElimination.addSuperAccessedMethod(methodBinding);
          }
        }
      }
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(statement);
      for (      Expression variableInstruction : variableInstructions) {
        SimpleName simpleName=(SimpleName)variableInstruction;
        IBinding variableInstructionBinding=simpleName.resolveBinding();
        if (variableInstructionBinding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableInstructionVariableBinding=(IVariableBinding)variableInstructionBinding;
          if (variableInstructionVariableBinding.isField()) {
            if (variableInstructionVariableBinding.getDeclaringClass() != null && variableInstructionVariableBinding.getDeclaringClass().isEqualTo(typeDeclaration.resolveBinding())) {
              for (              FieldDeclaration field : fields) {
                List<VariableDeclarationFragment> fragments=field.fragments();
                for (                VariableDeclarationFragment fragment : fragments) {
                  IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                  if (fragmentVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                    Expression parentExpression=null;
                    if (simpleName.getParent() instanceof QualifiedName) {
                      parentExpression=(QualifiedName)simpleName.getParent();
                    }
 else                     if (simpleName.getParent() instanceof FieldAccess) {
                      parentExpression=(FieldAccess)simpleName.getParent();
                    }
 else {
                      parentExpression=simpleName;
                    }
                    boolean isLeftHandOfAssignment=false;
                    if (parentExpression.getParent() instanceof Assignment) {
                      Assignment assignment=(Assignment)parentExpression.getParent();
                      Expression leftHandSide=assignment.getLeftHandSide();
                      SimpleName leftHandSideName=null;
                      if (leftHandSide instanceof SimpleName) {
                        leftHandSideName=(SimpleName)leftHandSide;
                      }
 else                       if (leftHandSide instanceof QualifiedName) {
                        QualifiedName leftHandSideQualifiedName=(QualifiedName)leftHandSide;
                        leftHandSideName=leftHandSideQualifiedName.getName();
                      }
 else                       if (leftHandSide instanceof FieldAccess) {
                        FieldAccess leftHandSideFieldAccess=(FieldAccess)leftHandSide;
                        leftHandSideName=leftHandSideFieldAccess.getName();
                      }
                      if (leftHandSideName != null && leftHandSideName.equals(simpleName)) {
                        isLeftHandOfAssignment=true;
                        typeCheckElimination.addAssignedField(fragment);
                      }
                    }
                    if (!isLeftHandOfAssignment)                     typeCheckElimination.addAccessedField(fragment);
                  }
                }
              }
            }
          }
 else           if (variableInstructionVariableBinding.isParameter()) {
            List<SingleVariableDeclaration> parameters=typeCheckMethod.parameters();
            for (            SingleVariableDeclaration parameter : parameters) {
              IVariableBinding parameterVariableBinding=parameter.resolveBinding();
              if (parameterVariableBinding.isEqualTo(variableInstructionVariableBinding))               typeCheckElimination.addAccessedParameter(parameter);
            }
          }
 else {
            for (            Statement vDStatement : variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment) {
              VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
              List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
              for (              VariableDeclarationFragment fragment : fragments) {
                IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                if (fragmentVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                  typeCheckElimination.addAccessedLocalVariable(fragment);
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
  processRemainingIfStatementExpressions(variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment);
}","private void processTypeCheckCodeFragmentBranches(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<ArrayList<Statement>> allTypeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  if (!typeCheckElimination.getDefaultCaseStatements().isEmpty()) {
    allTypeCheckStatements.add(typeCheckElimination.getDefaultCaseStatements());
  }
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment=statementExtractor.getVariableDeclarations(typeCheckMethod.getBody());
  for (  ArrayList<Statement> typeCheckStatementList : allTypeCheckStatements) {
    for (    Statement statement : typeCheckStatementList) {
      variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment.removeAll(statementExtractor.getVariableDeclarations(statement));
    }
  }
  for (  ArrayList<Statement> typeCheckStatementList : allTypeCheckStatements) {
    for (    Statement statement : typeCheckStatementList) {
      List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
      for (      Expression expression : methodInvocations) {
        if (expression instanceof MethodInvocation) {
          MethodInvocation methodInvocation=(MethodInvocation)expression;
          IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
          if (methodBinding.getDeclaringClass().isEqualTo(typeDeclaration.resolveBinding())) {
            for (            MethodDeclaration method : methods) {
              if (method.resolveBinding().isEqualTo(methodBinding)) {
                typeCheckElimination.addAccessedMethod(method);
              }
            }
          }
 else           if (methodInvocation.getExpression() == null || (methodInvocation.getExpression() != null && methodInvocation.getExpression() instanceof ThisExpression)) {
            ITypeBinding superclassTypeBinding=typeDeclaration.resolveBinding().getSuperclass();
            while (superclassTypeBinding != null && !superclassTypeBinding.isEqualTo(methodBinding.getDeclaringClass())) {
              superclassTypeBinding=superclassTypeBinding.getSuperclass();
            }
            if (methodBinding.getDeclaringClass().isEqualTo(superclassTypeBinding))             typeCheckElimination.addSuperAccessedMethod(methodBinding);
          }
        }
      }
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(statement);
      for (      Expression variableInstruction : variableInstructions) {
        SimpleName simpleName=(SimpleName)variableInstruction;
        IBinding variableInstructionBinding=simpleName.resolveBinding();
        if (variableInstructionBinding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableInstructionVariableBinding=(IVariableBinding)variableInstructionBinding;
          if (variableInstructionVariableBinding.isField()) {
            if (variableInstructionVariableBinding.getDeclaringClass() != null && variableInstructionVariableBinding.getDeclaringClass().isEqualTo(typeDeclaration.resolveBinding())) {
              for (              FieldDeclaration field : fields) {
                List<VariableDeclarationFragment> fragments=field.fragments();
                for (                VariableDeclarationFragment fragment : fragments) {
                  IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                  if (fragmentVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                    Expression parentExpression=null;
                    if (simpleName.getParent() instanceof QualifiedName) {
                      parentExpression=(QualifiedName)simpleName.getParent();
                    }
 else                     if (simpleName.getParent() instanceof FieldAccess) {
                      parentExpression=(FieldAccess)simpleName.getParent();
                    }
 else {
                      parentExpression=simpleName;
                    }
                    boolean isLeftHandOfAssignment=false;
                    if (parentExpression.getParent() instanceof Assignment) {
                      Assignment assignment=(Assignment)parentExpression.getParent();
                      Expression leftHandSide=assignment.getLeftHandSide();
                      SimpleName leftHandSideName=null;
                      if (leftHandSide instanceof SimpleName) {
                        leftHandSideName=(SimpleName)leftHandSide;
                      }
 else                       if (leftHandSide instanceof QualifiedName) {
                        QualifiedName leftHandSideQualifiedName=(QualifiedName)leftHandSide;
                        leftHandSideName=leftHandSideQualifiedName.getName();
                      }
 else                       if (leftHandSide instanceof FieldAccess) {
                        FieldAccess leftHandSideFieldAccess=(FieldAccess)leftHandSide;
                        leftHandSideName=leftHandSideFieldAccess.getName();
                      }
                      if (leftHandSideName != null && leftHandSideName.equals(simpleName)) {
                        isLeftHandOfAssignment=true;
                        typeCheckElimination.addAssignedField(fragment);
                      }
                    }
                    if (!isLeftHandOfAssignment)                     typeCheckElimination.addAccessedField(fragment);
                  }
                }
              }
            }
          }
 else           if (variableInstructionVariableBinding.isParameter()) {
            List<SingleVariableDeclaration> parameters=typeCheckMethod.parameters();
            for (            SingleVariableDeclaration parameter : parameters) {
              IVariableBinding parameterVariableBinding=parameter.resolveBinding();
              if (parameterVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                boolean isLeftHandOfAssignment=false;
                if (simpleName.getParent() instanceof Assignment) {
                  Assignment assignment=(Assignment)simpleName.getParent();
                  Expression leftHandSide=assignment.getLeftHandSide();
                  if (leftHandSide instanceof SimpleName) {
                    SimpleName leftHandSideName=(SimpleName)leftHandSide;
                    if (leftHandSideName.equals(simpleName)) {
                      isLeftHandOfAssignment=true;
                      typeCheckElimination.addAssignedParameter(parameter);
                    }
                  }
                }
                if (!isLeftHandOfAssignment)                 typeCheckElimination.addAccessedParameter(parameter);
                break;
              }
            }
          }
 else {
            for (            Statement vDStatement : variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment) {
              VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
              List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
              for (              VariableDeclarationFragment fragment : fragments) {
                IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                if (fragmentVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                  boolean isLeftHandOfAssignment=false;
                  if (simpleName.getParent() instanceof Assignment) {
                    Assignment assignment=(Assignment)simpleName.getParent();
                    Expression leftHandSide=assignment.getLeftHandSide();
                    if (leftHandSide instanceof SimpleName) {
                      SimpleName leftHandSideName=(SimpleName)leftHandSide;
                      if (leftHandSideName.equals(simpleName)) {
                        isLeftHandOfAssignment=true;
                        typeCheckElimination.addAssignedLocalVariable(fragment);
                      }
                    }
                  }
                  if (!isLeftHandOfAssignment)                   typeCheckElimination.addAccessedLocalVariable(fragment);
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
  processRemainingIfStatementExpressions(variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment);
}"
12193,"private void processTypeCheckCodeFragment(){
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  ArrayList<Statement> firstBlockOfStatements=typeCheckStatements.get(0);
  Statement firstStatementOfBlock=firstBlockOfStatements.get(0);
  if (firstStatementOfBlock.getParent() instanceof SwitchStatement) {
    SwitchStatement switchStatement=(SwitchStatement)firstStatementOfBlock.getParent();
    Expression switchStatementExpression=switchStatement.getExpression();
    SimpleName switchStatementExpressionName=extractOperandName(switchStatementExpression);
    if (switchStatementExpressionName != null) {
      IBinding switchStatementExpressionNameBinding=switchStatementExpressionName.resolveBinding();
      if (switchStatementExpressionNameBinding.getKind() == IBinding.VARIABLE) {
        IVariableBinding switchStatementExpressionNameVariableBinding=(IVariableBinding)switchStatementExpressionNameBinding;
        ITypeBinding variableTypeBinding=switchStatementExpressionNameVariableBinding.getType();
        InheritanceTree tree=inheritanceDetection.getTree(variableTypeBinding.getQualifiedName());
        typeCheckElimination.setExistingInheritanceTree(tree);
        if (switchStatementExpressionNameVariableBinding.isField()) {
          for (          FieldDeclaration field : fields) {
            List<VariableDeclarationFragment> fragments=field.fragments();
            for (            VariableDeclarationFragment fragment : fragments) {
              IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
              if (fragmentVariableBinding.isEqualTo(switchStatementExpressionNameVariableBinding)) {
                typeCheckElimination.setTypeField(fragment);
                for (                MethodDeclaration method : methods) {
                  SimpleName fieldInstruction=MethodDeclarationUtility.isSetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldSetterMethod(method);
                  }
                  fieldInstruction=MethodDeclarationUtility.isGetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldGetterMethod(method);
                  }
                }
                break;
              }
            }
          }
        }
 else {
          typeCheckElimination.setTypeLocalVariable(switchStatementExpressionName);
        }
      }
    }
  }
  Set<Expression> typeCheckExpressions=typeCheckElimination.getTypeCheckExpressions();
  for (  Expression typeCheckExpression : typeCheckExpressions) {
    if (typeCheckExpression.getParent() instanceof SwitchCase) {
      if (typeCheckExpression instanceof SimpleName) {
        SimpleName simpleName=(SimpleName)typeCheckExpression;
        IBinding binding=simpleName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
            typeCheckElimination.addStaticType(typeCheckExpression,simpleName);
          }
        }
      }
 else       if (typeCheckExpression instanceof QualifiedName) {
        QualifiedName qualifiedName=(QualifiedName)typeCheckExpression;
        IBinding binding=qualifiedName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
            typeCheckElimination.addStaticType(typeCheckExpression,qualifiedName.getName());
          }
        }
      }
 else       if (typeCheckExpression instanceof FieldAccess) {
        FieldAccess fieldAccess=(FieldAccess)typeCheckExpression;
        IVariableBinding variableBinding=fieldAccess.resolveFieldBinding();
        if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
          typeCheckElimination.addStaticType(typeCheckExpression,fieldAccess.getName());
        }
      }
    }
 else     if (typeCheckExpression instanceof InstanceofExpression) {
      InstanceofExpression instanceofExpression=(InstanceofExpression)typeCheckExpression;
      SimpleName operandName=extractOperandName(instanceofExpression.getLeftOperand());
      if (operandName != null) {
        SimpleName keySimpleName=containsKey(operandName);
        if (keySimpleName != null) {
          typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
        }
 else {
          typeVariableCounterMap.put(operandName,1);
        }
        typeCheckElimination.addSubclassType(typeCheckExpression,instanceofExpression.getRightOperand());
      }
    }
 else     if (typeCheckExpression instanceof InfixExpression) {
      InfixExpression infixExpression=(InfixExpression)typeCheckExpression;
      IfStatementExpressionAnalyzer analyzer=new IfStatementExpressionAnalyzer(infixExpression);
      for (      InfixExpression leafInfixExpression : analyzer.getInfixExpressionsWithEqualsOperator()) {
        Expression leftOperand=leafInfixExpression.getLeftOperand();
        Expression rightOperand=leafInfixExpression.getRightOperand();
        SimpleName leftOperandName=extractOperandName(leftOperand);
        SimpleName rightOperandName=extractOperandName(rightOperand);
        SimpleName typeVariableName=null;
        SimpleName staticFieldName=null;
        Type subclassType=null;
        if (leftOperandName != null && rightOperandName != null) {
          IBinding leftOperandNameBinding=leftOperandName.resolveBinding();
          if (leftOperandNameBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding leftOperandNameVariableBinding=(IVariableBinding)leftOperandNameBinding;
            if (leftOperandNameVariableBinding.isField() && (leftOperandNameVariableBinding.getModifiers() & Modifier.STATIC) != 0)             staticFieldName=leftOperandName;
          }
          IBinding rightOperandNameBinding=rightOperandName.resolveBinding();
          if (rightOperandNameBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding rightOperandNameVariableBinding=(IVariableBinding)rightOperandNameBinding;
            if (rightOperandNameVariableBinding.isField() && (rightOperandNameVariableBinding.getModifiers() & Modifier.STATIC) != 0)             staticFieldName=rightOperandName;
          }
          if (staticFieldName != null && staticFieldName.equals(leftOperandName))           typeVariableName=rightOperandName;
 else           if (staticFieldName != null && staticFieldName.equals(rightOperandName))           typeVariableName=leftOperandName;
        }
 else         if (leftOperandName != null && rightOperandName == null) {
          if (rightOperand instanceof TypeLiteral) {
            TypeLiteral typeLiteral=(TypeLiteral)rightOperand;
            subclassType=typeLiteral.getType();
            typeVariableName=leftOperandName;
          }
        }
 else         if (leftOperandName == null && rightOperandName != null) {
          if (leftOperand instanceof TypeLiteral) {
            TypeLiteral typeLiteral=(TypeLiteral)leftOperand;
            subclassType=typeLiteral.getType();
            typeVariableName=rightOperandName;
          }
        }
        if (typeVariableName != null && staticFieldName != null) {
          SimpleName keySimpleName=containsKey(typeVariableName);
          if (keySimpleName != null) {
            typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
          }
 else {
            typeVariableCounterMap.put(typeVariableName,1);
          }
          if (analyzer.allParentNodesAreConditionalAndOperators()) {
            analyzer.putTypeVariableExpression(typeVariableName,leafInfixExpression);
            analyzer.putTypeVariableStaticField(typeVariableName,staticFieldName);
          }
        }
        if (typeVariableName != null && subclassType != null) {
          SimpleName keySimpleName=containsKey(typeVariableName);
          if (keySimpleName != null) {
            typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
          }
 else {
            typeVariableCounterMap.put(typeVariableName,1);
          }
          if (analyzer.allParentNodesAreConditionalAndOperators()) {
            analyzer.putTypeVariableExpression(typeVariableName,leafInfixExpression);
            analyzer.putTypeVariableSubclass(typeVariableName,subclassType);
          }
        }
      }
      for (      InstanceofExpression leafInstanceofExpression : analyzer.getInstanceofExpressions()) {
        SimpleName operandName=extractOperandName(leafInstanceofExpression.getLeftOperand());
        if (operandName != null) {
          SimpleName keySimpleName=containsKey(operandName);
          if (keySimpleName != null) {
            typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
          }
 else {
            typeVariableCounterMap.put(operandName,1);
          }
          if (analyzer.allParentNodesAreConditionalAndOperators()) {
            analyzer.putTypeVariableExpression(operandName,leafInstanceofExpression);
            analyzer.putTypeVariableSubclass(operandName,leafInstanceofExpression.getRightOperand());
          }
        }
      }
      complexExpressionMap.put(typeCheckExpression,analyzer);
    }
  }
  for (  SimpleName typeVariable : typeVariableCounterMap.keySet()) {
    if (typeVariableCounterMap.get(typeVariable) == typeCheckExpressions.size()) {
      for (      Expression complexExpression : complexExpressionMap.keySet()) {
        IfStatementExpressionAnalyzer analyzer=complexExpressionMap.get(complexExpression);
        for (        SimpleName analyzerTypeVariable : analyzer.getTargetVariables()) {
          if (analyzerTypeVariable.resolveBinding().isEqualTo(typeVariable.resolveBinding())) {
            typeCheckElimination.addRemainingIfStatementExpression(analyzer.getCompleteExpression(),analyzer.getRemainingExpression(analyzer.getTypeVariableExpression(analyzerTypeVariable)));
            SimpleName staticField=analyzer.getTypeVariableStaticField(analyzerTypeVariable);
            if (staticField != null)             typeCheckElimination.addStaticType(analyzer.getCompleteExpression(),staticField);
            Type subclassType=analyzer.getTypeVariableSubclass(analyzerTypeVariable);
            if (subclassType != null)             typeCheckElimination.addSubclassType(analyzer.getCompleteExpression(),subclassType);
          }
        }
      }
      IBinding binding=typeVariable.resolveBinding();
      if (binding.getKind() == IBinding.VARIABLE) {
        IVariableBinding variableBinding=(IVariableBinding)binding;
        ITypeBinding variableTypeBinding=variableBinding.getType();
        InheritanceTree tree=inheritanceDetection.getTree(variableTypeBinding.getQualifiedName());
        typeCheckElimination.setExistingInheritanceTree(tree);
        if (variableBinding.isField()) {
          for (          FieldDeclaration field : fields) {
            List<VariableDeclarationFragment> fragments=field.fragments();
            for (            VariableDeclarationFragment fragment : fragments) {
              IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
              if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                typeCheckElimination.setTypeField(fragment);
                for (                MethodDeclaration method : methods) {
                  SimpleName fieldInstruction=MethodDeclarationUtility.isSetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldSetterMethod(method);
                  }
                  fieldInstruction=MethodDeclarationUtility.isGetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldGetterMethod(method);
                  }
                }
                break;
              }
            }
          }
        }
 else {
          typeCheckElimination.setTypeLocalVariable(typeVariable);
        }
      }
    }
  }
}","private void processTypeCheckCodeFragment(){
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  ArrayList<Statement> firstBlockOfStatements=typeCheckStatements.get(0);
  Statement firstStatementOfBlock=firstBlockOfStatements.get(0);
  if (firstStatementOfBlock.getParent() instanceof SwitchStatement) {
    SwitchStatement switchStatement=(SwitchStatement)firstStatementOfBlock.getParent();
    Expression switchStatementExpression=switchStatement.getExpression();
    SimpleName switchStatementExpressionName=extractOperandName(switchStatementExpression);
    if (switchStatementExpressionName != null) {
      IBinding switchStatementExpressionNameBinding=switchStatementExpressionName.resolveBinding();
      if (switchStatementExpressionNameBinding.getKind() == IBinding.VARIABLE) {
        IVariableBinding switchStatementExpressionNameVariableBinding=(IVariableBinding)switchStatementExpressionNameBinding;
        ITypeBinding variableTypeBinding=switchStatementExpressionNameVariableBinding.getType();
        InheritanceTree tree=inheritanceDetection.getTree(variableTypeBinding.getQualifiedName());
        typeCheckElimination.setExistingInheritanceTree(tree);
        if (switchStatementExpressionNameVariableBinding.isField()) {
          for (          FieldDeclaration field : fields) {
            List<VariableDeclarationFragment> fragments=field.fragments();
            for (            VariableDeclarationFragment fragment : fragments) {
              IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
              if (fragmentVariableBinding.isEqualTo(switchStatementExpressionNameVariableBinding)) {
                typeCheckElimination.setTypeField(fragment);
                for (                MethodDeclaration method : methods) {
                  SimpleName fieldInstruction=MethodDeclarationUtility.isSetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldSetterMethod(method);
                  }
                  fieldInstruction=MethodDeclarationUtility.isGetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldGetterMethod(method);
                  }
                }
                break;
              }
            }
          }
        }
 else {
          typeCheckElimination.setTypeLocalVariable(switchStatementExpressionName);
        }
      }
    }
  }
  Set<Expression> typeCheckExpressions=typeCheckElimination.getTypeCheckExpressions();
  for (  Expression typeCheckExpression : typeCheckExpressions) {
    if (typeCheckExpression.getParent() instanceof SwitchCase) {
      if (typeCheckExpression instanceof SimpleName) {
        SimpleName simpleName=(SimpleName)typeCheckExpression;
        IBinding binding=simpleName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
            typeCheckElimination.addStaticType(typeCheckExpression,simpleName);
          }
        }
      }
 else       if (typeCheckExpression instanceof QualifiedName) {
        QualifiedName qualifiedName=(QualifiedName)typeCheckExpression;
        IBinding binding=qualifiedName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
            typeCheckElimination.addStaticType(typeCheckExpression,qualifiedName.getName());
          }
        }
      }
 else       if (typeCheckExpression instanceof FieldAccess) {
        FieldAccess fieldAccess=(FieldAccess)typeCheckExpression;
        IVariableBinding variableBinding=fieldAccess.resolveFieldBinding();
        if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
          typeCheckElimination.addStaticType(typeCheckExpression,fieldAccess.getName());
        }
      }
    }
 else     if (typeCheckExpression instanceof InstanceofExpression) {
      InstanceofExpression instanceofExpression=(InstanceofExpression)typeCheckExpression;
      SimpleName operandName=extractOperandName(instanceofExpression.getLeftOperand());
      if (operandName != null) {
        SimpleName keySimpleName=containsKey(operandName);
        if (keySimpleName != null) {
          typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
        }
 else {
          typeVariableCounterMap.put(operandName,1);
        }
        typeCheckElimination.addSubclassType(typeCheckExpression,instanceofExpression.getRightOperand());
      }
    }
 else     if (typeCheckExpression instanceof InfixExpression) {
      InfixExpression infixExpression=(InfixExpression)typeCheckExpression;
      IfStatementExpressionAnalyzer analyzer=new IfStatementExpressionAnalyzer(infixExpression);
      for (      InfixExpression leafInfixExpression : analyzer.getInfixExpressionsWithEqualsOperator()) {
        Expression leftOperand=leafInfixExpression.getLeftOperand();
        Expression rightOperand=leafInfixExpression.getRightOperand();
        SimpleName leftOperandName=extractOperandName(leftOperand);
        SimpleName rightOperandName=extractOperandName(rightOperand);
        SimpleName typeVariableName=null;
        SimpleName staticFieldName=null;
        Type subclassType=null;
        if (leftOperandName != null && rightOperandName != null) {
          IBinding leftOperandNameBinding=leftOperandName.resolveBinding();
          if (leftOperandNameBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding leftOperandNameVariableBinding=(IVariableBinding)leftOperandNameBinding;
            if (leftOperandNameVariableBinding.isField() && (leftOperandNameVariableBinding.getModifiers() & Modifier.STATIC) != 0)             staticFieldName=leftOperandName;
          }
          IBinding rightOperandNameBinding=rightOperandName.resolveBinding();
          if (rightOperandNameBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding rightOperandNameVariableBinding=(IVariableBinding)rightOperandNameBinding;
            if (rightOperandNameVariableBinding.isField() && (rightOperandNameVariableBinding.getModifiers() & Modifier.STATIC) != 0)             staticFieldName=rightOperandName;
          }
          if (staticFieldName != null && staticFieldName.equals(leftOperandName))           typeVariableName=rightOperandName;
 else           if (staticFieldName != null && staticFieldName.equals(rightOperandName))           typeVariableName=leftOperandName;
        }
 else         if (leftOperandName != null && rightOperandName == null) {
          if (rightOperand instanceof TypeLiteral) {
            TypeLiteral typeLiteral=(TypeLiteral)rightOperand;
            subclassType=typeLiteral.getType();
            typeVariableName=leftOperandName;
          }
        }
 else         if (leftOperandName == null && rightOperandName != null) {
          if (leftOperand instanceof TypeLiteral) {
            TypeLiteral typeLiteral=(TypeLiteral)leftOperand;
            subclassType=typeLiteral.getType();
            typeVariableName=rightOperandName;
          }
        }
        if (typeVariableName != null && staticFieldName != null) {
          SimpleName keySimpleName=containsKey(typeVariableName);
          if (keySimpleName != null) {
            typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
          }
 else {
            typeVariableCounterMap.put(typeVariableName,1);
          }
          if (analyzer.allParentNodesAreConditionalAndOperators()) {
            analyzer.putTypeVariableExpression(typeVariableName,leafInfixExpression);
            analyzer.putTypeVariableStaticField(typeVariableName,staticFieldName);
          }
        }
        if (typeVariableName != null && subclassType != null) {
          SimpleName keySimpleName=containsKey(typeVariableName);
          if (keySimpleName != null) {
            typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
          }
 else {
            typeVariableCounterMap.put(typeVariableName,1);
          }
          if (analyzer.allParentNodesAreConditionalAndOperators()) {
            analyzer.putTypeVariableExpression(typeVariableName,leafInfixExpression);
            analyzer.putTypeVariableSubclass(typeVariableName,subclassType);
          }
        }
      }
      for (      InstanceofExpression leafInstanceofExpression : analyzer.getInstanceofExpressions()) {
        SimpleName operandName=extractOperandName(leafInstanceofExpression.getLeftOperand());
        if (operandName != null) {
          SimpleName keySimpleName=containsKey(operandName);
          if (keySimpleName != null) {
            typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
          }
 else {
            typeVariableCounterMap.put(operandName,1);
          }
          if (analyzer.allParentNodesAreConditionalAndOperators()) {
            analyzer.putTypeVariableExpression(operandName,leafInstanceofExpression);
            analyzer.putTypeVariableSubclass(operandName,leafInstanceofExpression.getRightOperand());
          }
        }
      }
      complexExpressionMap.put(typeCheckExpression,analyzer);
    }
  }
  for (  SimpleName typeVariable : typeVariableCounterMap.keySet()) {
    if (typeVariableCounterMap.get(typeVariable) == typeCheckExpressions.size()) {
      for (      Expression complexExpression : complexExpressionMap.keySet()) {
        IfStatementExpressionAnalyzer analyzer=complexExpressionMap.get(complexExpression);
        for (        SimpleName analyzerTypeVariable : analyzer.getTargetVariables()) {
          if (analyzerTypeVariable.resolveBinding().isEqualTo(typeVariable.resolveBinding())) {
            typeCheckElimination.addRemainingIfStatementExpression(analyzer.getCompleteExpression(),analyzer.getRemainingExpression(analyzer.getTypeVariableExpression(analyzerTypeVariable)));
            SimpleName staticField=analyzer.getTypeVariableStaticField(analyzerTypeVariable);
            if (staticField != null)             typeCheckElimination.addStaticType(analyzer.getCompleteExpression(),staticField);
            Type subclassType=analyzer.getTypeVariableSubclass(analyzerTypeVariable);
            if (subclassType != null)             typeCheckElimination.addSubclassType(analyzer.getCompleteExpression(),subclassType);
          }
        }
      }
      IBinding binding=typeVariable.resolveBinding();
      if (binding.getKind() == IBinding.VARIABLE) {
        IVariableBinding variableBinding=(IVariableBinding)binding;
        ITypeBinding variableTypeBinding=variableBinding.getType();
        InheritanceTree tree=inheritanceDetection.getTree(variableTypeBinding.getQualifiedName());
        typeCheckElimination.setExistingInheritanceTree(tree);
        if (variableBinding.isField()) {
          for (          FieldDeclaration field : fields) {
            List<VariableDeclarationFragment> fragments=field.fragments();
            for (            VariableDeclarationFragment fragment : fragments) {
              IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
              if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                typeCheckElimination.setTypeField(fragment);
                for (                MethodDeclaration method : methods) {
                  SimpleName fieldInstruction=MethodDeclarationUtility.isSetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldSetterMethod(method);
                  }
                  fieldInstruction=MethodDeclarationUtility.isGetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldGetterMethod(method);
                  }
                }
                break;
              }
            }
          }
        }
 else {
          typeCheckElimination.setTypeLocalVariable(typeVariable);
        }
      }
    }
  }
  processTypeCheckCodeFragmentBranches();
}"
12194,"private void processRemainingIfStatementExpressions(List<Statement> variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  for (  Expression complexExpression : complexExpressionMap.keySet()) {
    DefaultMutableTreeNode root=typeCheckElimination.getRemainingIfStatementExpression(complexExpression);
    if (root != null) {
      DefaultMutableTreeNode leaf=root.getFirstLeaf();
      while (leaf != null) {
        Expression leafExpression=(Expression)leaf.getUserObject();
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(leafExpression);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
            if (methodBinding.getDeclaringClass().isEqualTo(typeDeclaration.resolveBinding())) {
              for (              MethodDeclaration method : methods) {
                if (method.resolveBinding().isEqualTo(methodBinding)) {
                  typeCheckElimination.addAccessedMethod(method);
                }
              }
            }
 else {
              ITypeBinding superclassTypeBinding=typeDeclaration.resolveBinding().getSuperclass();
              while (superclassTypeBinding != null && !superclassTypeBinding.isEqualTo(methodBinding.getDeclaringClass())) {
                superclassTypeBinding=superclassTypeBinding.getSuperclass();
              }
              if (methodBinding.getDeclaringClass().isEqualTo(superclassTypeBinding))               typeCheckElimination.addSuperAccessedMethod(methodBinding);
            }
          }
        }
        List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(leafExpression);
        for (        Expression variableInstruction : variableInstructions) {
          SimpleName simpleName=(SimpleName)variableInstruction;
          IBinding variableInstructionBinding=simpleName.resolveBinding();
          if (variableInstructionBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding variableInstructionVariableBinding=(IVariableBinding)variableInstructionBinding;
            if (variableInstructionVariableBinding.isField()) {
              if (variableInstructionVariableBinding.getDeclaringClass() != null && variableInstructionVariableBinding.getDeclaringClass().isEqualTo(typeDeclaration.resolveBinding())) {
                for (                FieldDeclaration field : fields) {
                  List<VariableDeclarationFragment> fragments=field.fragments();
                  for (                  VariableDeclarationFragment fragment : fragments) {
                    IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                    if (fragmentVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                      Expression parentExpression=null;
                      if (simpleName.getParent() instanceof QualifiedName) {
                        parentExpression=(QualifiedName)simpleName.getParent();
                      }
 else                       if (simpleName.getParent() instanceof FieldAccess) {
                        parentExpression=(FieldAccess)simpleName.getParent();
                      }
 else {
                        parentExpression=simpleName;
                      }
                      boolean isLeftHandOfAssignment=false;
                      if (parentExpression.getParent() instanceof Assignment) {
                        Assignment assignment=(Assignment)parentExpression.getParent();
                        Expression leftHandSide=assignment.getLeftHandSide();
                        SimpleName leftHandSideName=null;
                        if (leftHandSide instanceof SimpleName) {
                          leftHandSideName=(SimpleName)leftHandSide;
                        }
 else                         if (leftHandSide instanceof QualifiedName) {
                          QualifiedName leftHandSideQualifiedName=(QualifiedName)leftHandSide;
                          leftHandSideName=leftHandSideQualifiedName.getName();
                        }
 else                         if (leftHandSide instanceof FieldAccess) {
                          FieldAccess leftHandSideFieldAccess=(FieldAccess)leftHandSide;
                          leftHandSideName=leftHandSideFieldAccess.getName();
                        }
                        if (leftHandSideName != null && leftHandSideName.equals(simpleName)) {
                          isLeftHandOfAssignment=true;
                          typeCheckElimination.addAssignedField(fragment);
                        }
                      }
                      if (!isLeftHandOfAssignment)                       typeCheckElimination.addAccessedField(fragment);
                    }
                  }
                }
              }
            }
 else             if (variableInstructionVariableBinding.isParameter()) {
              List<SingleVariableDeclaration> parameters=typeCheckMethod.parameters();
              for (              SingleVariableDeclaration parameter : parameters) {
                IVariableBinding parameterVariableBinding=parameter.resolveBinding();
                if (parameterVariableBinding.isEqualTo(variableInstructionVariableBinding))                 typeCheckElimination.addAccessedParameter(parameter);
              }
            }
 else {
              for (              Statement vDStatement : variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment) {
                VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
                List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
                for (                VariableDeclarationFragment fragment : fragments) {
                  IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                  if (fragmentVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                    typeCheckElimination.addAccessedLocalVariable(fragment);
                    break;
                  }
                }
              }
            }
          }
        }
        leaf=leaf.getNextLeaf();
      }
    }
  }
}","private void processRemainingIfStatementExpressions(List<Statement> variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  for (  Expression complexExpression : complexExpressionMap.keySet()) {
    DefaultMutableTreeNode root=typeCheckElimination.getRemainingIfStatementExpression(complexExpression);
    if (root != null) {
      DefaultMutableTreeNode leaf=root.getFirstLeaf();
      while (leaf != null) {
        Expression leafExpression=(Expression)leaf.getUserObject();
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(leafExpression);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
            if (methodBinding.getDeclaringClass().isEqualTo(typeDeclaration.resolveBinding())) {
              for (              MethodDeclaration method : methods) {
                if (method.resolveBinding().isEqualTo(methodBinding)) {
                  typeCheckElimination.addAccessedMethod(method);
                }
              }
            }
 else             if (methodInvocation.getExpression() == null || (methodInvocation.getExpression() != null && methodInvocation.getExpression() instanceof ThisExpression)) {
              ITypeBinding superclassTypeBinding=typeDeclaration.resolveBinding().getSuperclass();
              while (superclassTypeBinding != null && !superclassTypeBinding.isEqualTo(methodBinding.getDeclaringClass())) {
                superclassTypeBinding=superclassTypeBinding.getSuperclass();
              }
              if (methodBinding.getDeclaringClass().isEqualTo(superclassTypeBinding))               typeCheckElimination.addSuperAccessedMethod(methodBinding);
            }
          }
        }
        List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(leafExpression);
        for (        Expression variableInstruction : variableInstructions) {
          SimpleName simpleName=(SimpleName)variableInstruction;
          IBinding variableInstructionBinding=simpleName.resolveBinding();
          if (variableInstructionBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding variableInstructionVariableBinding=(IVariableBinding)variableInstructionBinding;
            if (variableInstructionVariableBinding.isField()) {
              if (variableInstructionVariableBinding.getDeclaringClass() != null && variableInstructionVariableBinding.getDeclaringClass().isEqualTo(typeDeclaration.resolveBinding())) {
                for (                FieldDeclaration field : fields) {
                  List<VariableDeclarationFragment> fragments=field.fragments();
                  for (                  VariableDeclarationFragment fragment : fragments) {
                    IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                    if (fragmentVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                      Expression parentExpression=null;
                      if (simpleName.getParent() instanceof QualifiedName) {
                        parentExpression=(QualifiedName)simpleName.getParent();
                      }
 else                       if (simpleName.getParent() instanceof FieldAccess) {
                        parentExpression=(FieldAccess)simpleName.getParent();
                      }
 else {
                        parentExpression=simpleName;
                      }
                      boolean isLeftHandOfAssignment=false;
                      if (parentExpression.getParent() instanceof Assignment) {
                        Assignment assignment=(Assignment)parentExpression.getParent();
                        Expression leftHandSide=assignment.getLeftHandSide();
                        SimpleName leftHandSideName=null;
                        if (leftHandSide instanceof SimpleName) {
                          leftHandSideName=(SimpleName)leftHandSide;
                        }
 else                         if (leftHandSide instanceof QualifiedName) {
                          QualifiedName leftHandSideQualifiedName=(QualifiedName)leftHandSide;
                          leftHandSideName=leftHandSideQualifiedName.getName();
                        }
 else                         if (leftHandSide instanceof FieldAccess) {
                          FieldAccess leftHandSideFieldAccess=(FieldAccess)leftHandSide;
                          leftHandSideName=leftHandSideFieldAccess.getName();
                        }
                        if (leftHandSideName != null && leftHandSideName.equals(simpleName)) {
                          isLeftHandOfAssignment=true;
                          typeCheckElimination.addAssignedField(fragment);
                        }
                      }
                      if (!isLeftHandOfAssignment)                       typeCheckElimination.addAccessedField(fragment);
                    }
                  }
                }
              }
            }
 else             if (variableInstructionVariableBinding.isParameter()) {
              List<SingleVariableDeclaration> parameters=typeCheckMethod.parameters();
              for (              SingleVariableDeclaration parameter : parameters) {
                IVariableBinding parameterVariableBinding=parameter.resolveBinding();
                if (parameterVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                  boolean isLeftHandOfAssignment=false;
                  if (simpleName.getParent() instanceof Assignment) {
                    Assignment assignment=(Assignment)simpleName.getParent();
                    Expression leftHandSide=assignment.getLeftHandSide();
                    if (leftHandSide instanceof SimpleName) {
                      SimpleName leftHandSideName=(SimpleName)leftHandSide;
                      if (leftHandSideName.equals(simpleName)) {
                        isLeftHandOfAssignment=true;
                        typeCheckElimination.addAssignedParameter(parameter);
                      }
                    }
                  }
                  if (!isLeftHandOfAssignment)                   typeCheckElimination.addAccessedParameter(parameter);
                  break;
                }
              }
            }
 else {
              for (              Statement vDStatement : variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment) {
                VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
                List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
                for (                VariableDeclarationFragment fragment : fragments) {
                  IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                  if (fragmentVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                    boolean isLeftHandOfAssignment=false;
                    if (simpleName.getParent() instanceof Assignment) {
                      Assignment assignment=(Assignment)simpleName.getParent();
                      Expression leftHandSide=assignment.getLeftHandSide();
                      if (leftHandSide instanceof SimpleName) {
                        SimpleName leftHandSideName=(SimpleName)leftHandSide;
                        if (leftHandSideName.equals(simpleName)) {
                          isLeftHandOfAssignment=true;
                          typeCheckElimination.addAssignedLocalVariable(fragment);
                        }
                      }
                    }
                    if (!isLeftHandOfAssignment)                     typeCheckElimination.addAccessedLocalVariable(fragment);
                    break;
                  }
                }
              }
            }
          }
        }
        leaf=leaf.getNextLeaf();
      }
    }
  }
}"
12195,"public List<TypeCheckElimination> generateTypeCheckEliminations(){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> switchStatements=statementExtractor.getSwitchStatements(compositeStatement.getStatement());
  for (  Statement statement : switchStatements) {
    SwitchStatement switchStatement=(SwitchStatement)statement;
    TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
    typeCheckElimination.setTypeCheckCodeFragment(switchStatement);
    List<Statement> statements=switchStatement.statements();
    Expression switchCaseExpression=null;
    boolean isDefaultCase=false;
    Set<Expression> switchCaseExpressions=new LinkedHashSet<Expression>();
    for (    Statement statement2 : statements) {
      if (statement2 instanceof SwitchCase) {
        SwitchCase switchCase=(SwitchCase)statement2;
        switchCaseExpression=switchCase.getExpression();
        isDefaultCase=switchCase.isDefault();
        if (!isDefaultCase)         switchCaseExpressions.add(switchCaseExpression);
      }
 else {
        if (!(statement2 instanceof BreakStatement)) {
          for (          Expression expression : switchCaseExpressions) {
            typeCheckElimination.addTypeCheck(expression,statement2);
          }
          if (!isDefaultCase) {
            typeCheckElimination.addDefaultCaseStatement(statement2);
          }
        }
        List<Statement> branchingStatements=statementExtractor.getBranchingStatements(statement2);
        if (statement2 instanceof BreakStatement || statement2 instanceof ReturnStatement || branchingStatements.size() > 0) {
          switchCaseExpressions.clear();
        }
      }
    }
    typeCheckEliminations.add(typeCheckElimination);
  }
  List<Statement> ifStatements=statementExtractor.getIfStatements(compositeStatement.getStatement());
  TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
  int i=0;
  for (  Statement statement : ifStatements) {
    IfStatement ifStatement=(IfStatement)statement;
    Expression ifExpression=ifStatement.getExpression();
    Statement thenStatement=ifStatement.getThenStatement();
    if (thenStatement instanceof Block) {
      Block block=(Block)thenStatement;
      List<Statement> statements=block.statements();
      for (      Statement statement2 : statements) {
        typeCheckElimination.addTypeCheck(ifExpression,statement2);
      }
    }
 else {
      typeCheckElimination.addTypeCheck(ifExpression,thenStatement);
    }
    Statement elseStatement=ifStatement.getElseStatement();
    if (elseStatement != null) {
      if (elseStatement instanceof Block) {
        Block block=(Block)elseStatement;
        List<Statement> statements=block.statements();
        for (        Statement statement2 : statements) {
          typeCheckElimination.addDefaultCaseStatement(statement2);
        }
      }
 else       if (!(elseStatement instanceof IfStatement)) {
        typeCheckElimination.addDefaultCaseStatement(elseStatement);
      }
    }
    if (ifStatements.size() - 1 > i) {
      IfStatement nextIfStatement=(IfStatement)ifStatements.get(i + 1);
      if (!ifStatement.getParent().equals(nextIfStatement)) {
        typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
        typeCheckEliminations.add(typeCheckElimination);
        typeCheckElimination=new TypeCheckElimination();
      }
    }
 else {
      typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
      typeCheckEliminations.add(typeCheckElimination);
    }
    i++;
  }
  return typeCheckEliminations;
}","public List<TypeCheckElimination> generateTypeCheckEliminations(){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> switchStatements=statementExtractor.getSwitchStatements(compositeStatement.getStatement());
  for (  Statement statement : switchStatements) {
    SwitchStatement switchStatement=(SwitchStatement)statement;
    TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
    typeCheckElimination.setTypeCheckCodeFragment(switchStatement);
    List<Statement> statements=switchStatement.statements();
    Expression switchCaseExpression=null;
    boolean isDefaultCase=false;
    Set<Expression> switchCaseExpressions=new LinkedHashSet<Expression>();
    for (    Statement statement2 : statements) {
      if (statement2 instanceof SwitchCase) {
        SwitchCase switchCase=(SwitchCase)statement2;
        switchCaseExpression=switchCase.getExpression();
        isDefaultCase=switchCase.isDefault();
        if (!isDefaultCase)         switchCaseExpressions.add(switchCaseExpression);
      }
 else {
        if (!(statement2 instanceof BreakStatement)) {
          for (          Expression expression : switchCaseExpressions) {
            typeCheckElimination.addTypeCheck(expression,statement2);
          }
          if (isDefaultCase) {
            typeCheckElimination.addDefaultCaseStatement(statement2);
          }
        }
        List<Statement> branchingStatements=statementExtractor.getBranchingStatements(statement2);
        if (statement2 instanceof BreakStatement || statement2 instanceof ReturnStatement || branchingStatements.size() > 0) {
          switchCaseExpressions.clear();
        }
      }
    }
    typeCheckEliminations.add(typeCheckElimination);
  }
  List<Statement> ifStatements=statementExtractor.getIfStatements(compositeStatement.getStatement());
  TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
  int i=0;
  for (  Statement statement : ifStatements) {
    IfStatement ifStatement=(IfStatement)statement;
    Expression ifExpression=ifStatement.getExpression();
    Statement thenStatement=ifStatement.getThenStatement();
    if (thenStatement instanceof Block) {
      Block block=(Block)thenStatement;
      List<Statement> statements=block.statements();
      for (      Statement statement2 : statements) {
        typeCheckElimination.addTypeCheck(ifExpression,statement2);
      }
    }
 else {
      typeCheckElimination.addTypeCheck(ifExpression,thenStatement);
    }
    Statement elseStatement=ifStatement.getElseStatement();
    if (elseStatement != null) {
      if (elseStatement instanceof Block) {
        Block block=(Block)elseStatement;
        List<Statement> statements=block.statements();
        for (        Statement statement2 : statements) {
          typeCheckElimination.addDefaultCaseStatement(statement2);
        }
      }
 else       if (!(elseStatement instanceof IfStatement)) {
        typeCheckElimination.addDefaultCaseStatement(elseStatement);
      }
    }
    if (ifStatements.size() - 1 > i) {
      IfStatement nextIfStatement=(IfStatement)ifStatements.get(i + 1);
      if (!ifStatement.getParent().equals(nextIfStatement)) {
        typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
        typeCheckEliminations.add(typeCheckElimination);
        typeCheckElimination=new TypeCheckElimination();
      }
    }
 else {
      typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
      typeCheckEliminations.add(typeCheckElimination);
    }
    i++;
  }
  return typeCheckEliminations;
}"
12196,"private void modifyInheritanceHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  PackageDeclaration contextPackageDeclaration=sourceCompilationUnit.getPackage();
  IContainer rootContainer=contextContainer;
  if (contextPackageDeclaration != null) {
    String packageName=contextPackageDeclaration.getName().getFullyQualifiedName();
    String[] subPackages=packageName.split(""String_Node_Str"");
    for (int i=0; i < subPackages.length; i++)     rootContainer=(IContainer)rootContainer.getParent();
  }
  String abstractClassFullyQualifiedName=typeCheckElimination.getAbstractClassName();
  IFile abstractClassFile=getFile(rootContainer,abstractClassFullyQualifiedName);
  IJavaElement abstractJavaElement=JavaCore.create(abstractClassFile);
  ITextEditor abstractEditor=null;
  try {
    abstractEditor=(ITextEditor)JavaUI.openInEditor(abstractJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit abstractICompilationUnit=(ICompilationUnit)abstractJavaElement;
  ASTParser abstractParser=ASTParser.newParser(AST.JLS3);
  abstractParser.setKind(ASTParser.K_COMPILATION_UNIT);
  abstractParser.setSource(abstractICompilationUnit);
  abstractParser.setResolveBindings(true);
  CompilationUnit abstractCompilationUnit=(CompilationUnit)abstractParser.createAST(null);
  AST abstractAST=abstractCompilationUnit.getAST();
  ASTRewrite abstractRewriter=ASTRewrite.create(abstractAST);
  TypeDeclaration abstractClassTypeDeclaration=null;
  List<AbstractTypeDeclaration> abstractTypeDeclarations=abstractCompilationUnit.types();
  for (  AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
    if (abstractTypeDeclaration instanceof TypeDeclaration) {
      TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
      if (typeDeclaration.resolveBinding().getQualifiedName().equals(typeCheckElimination.getAbstractClassName())) {
        abstractClassTypeDeclaration=typeDeclaration;
        break;
      }
    }
  }
  int abstractClassModifiers=abstractClassTypeDeclaration.getModifiers();
  if ((abstractClassModifiers & Modifier.ABSTRACT) == 0 && !abstractClassTypeDeclaration.isInterface()) {
    ListRewrite abstractModifiersRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    abstractModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite abstractBodyRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration abstractMethodDeclaration=abstractAST.newMethodDeclaration();
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(abstractMethodName),null);
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
  ListRewrite abstractMethodModifiersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
  Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
  Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
  Set<IMethodBinding> superAccessedMethods=typeCheckElimination.getSuperAccessedMethods();
  if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0) {
    SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
    SimpleName parameterType=abstractAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,abstractAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(abstractAST.newSimpleName(typeBinding.getName()),null);
  }
  abstractBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,abstractCompilationUnit,abstractRewriter);
  }
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer abstractTextFileBuffer=bufferManager.getTextFileBuffer(abstractClassFile.getFullPath(),LocationKind.IFILE);
  IDocument abstractDocument=abstractTextFileBuffer.getDocument();
  TextEdit abstractEdit=abstractRewriter.rewriteAST(abstractDocument,null);
  try {
    UndoEdit abstractUndoEdit=abstractEdit.apply(abstractDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(abstractClassFile,abstractDocument,abstractUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  abstractEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  DefaultMutableTreeNode root=typeCheckElimination.getExistingInheritanceTree().getRootNode();
  Enumeration<DefaultMutableTreeNode> enumeration=root.children();
  while (enumeration.hasMoreElements()) {
    DefaultMutableTreeNode child=enumeration.nextElement();
    String childClassName=(String)child.getUserObject();
    if (!subclassNames.contains(childClassName))     subclassNames.add(childClassName);
  }
  for (int i=0; i < subclassNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      Expression expression=typeCheckElimination.getExpressionCorrespondingToTypeCheckStatementList(statements);
      remainingIfStatementExpression=typeCheckElimination.getRemainingIfStatementExpression(expression);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=getFile(rootContainer,subclassNames.get(i));
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    TypeDeclaration subclassTypeDeclaration=null;
    List<AbstractTypeDeclaration> subclassAbstractTypeDeclarations=subclassCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : subclassAbstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.resolveBinding().getQualifiedName().equals(subclassNames.get(i))) {
          subclassTypeDeclaration=typeDeclaration;
          break;
        }
      }
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(abstractMethodName),null);
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(enclosingIfStatementExpression);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods,superAccessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    if (returnedVariable != null && !returnedVariable.resolveBinding().isParameter()) {
      VariableDeclarationFragment variableDeclarationFragment=subclassAST.newVariableDeclarationFragment();
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariable.getName(),null);
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,returnedVariable.getInitializer(),null);
      VariableDeclarationStatement variableDeclarationStatement=subclassAST.newVariableDeclarationStatement(variableDeclarationFragment);
      subclassRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      concreteMethodBodyRewrite.insertFirst(variableDeclarationStatement,null);
    }
    SimpleName invokerSimpleName=null;
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      boolean insert=true;
      if (statement instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)statement;
        List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
        VariableDeclarationFragment fragment=fragments.get(0);
        if (fragment.getInitializer() instanceof CastExpression) {
          CastExpression castExpression=(CastExpression)fragment.getInitializer();
          if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
            invokerSimpleName=fragment.getName();
            insert=false;
          }
        }
      }
 else {
        StatementExtractor statementExtractor=new StatementExtractor();
        List<Statement> oldVariableDeclarations=statementExtractor.getVariableDeclarations(statement);
        List<Statement> newVariableDeclarations=statementExtractor.getVariableDeclarations(newStatement);
        int j=0;
        for (        Statement oldVariableDeclaration : oldVariableDeclarations) {
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)oldVariableDeclaration;
          List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
          VariableDeclarationFragment fragment=fragments.get(0);
          if (fragment.getInitializer() instanceof CastExpression) {
            CastExpression castExpression=(CastExpression)fragment.getInitializer();
            if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
              invokerSimpleName=fragment.getName();
              subclassRewriter.remove(newVariableDeclarations.get(j),null);
              break;
            }
          }
          j++;
        }
      }
      if (invokerSimpleName != null) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(newStatement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            Expression methodInvocationExpression=methodInvocation.getExpression();
            if (methodInvocationExpression instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)methodInvocationExpression;
              if (simpleName.getIdentifier().equals(invokerSimpleName.getIdentifier())) {
                subclassRewriter.remove(simpleName,null);
              }
            }
          }
        }
      }
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(statement);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods,superAccessedMethods);
      if (insert) {
        if (ifStatementBodyRewrite != null)         ifStatementBodyRewrite.insertLast(newStatement,null);
 else         concreteMethodBodyRewrite.insertLast(newStatement,null);
      }
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}","private void modifyInheritanceHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  PackageDeclaration contextPackageDeclaration=sourceCompilationUnit.getPackage();
  IContainer rootContainer=contextContainer;
  if (contextPackageDeclaration != null) {
    String packageName=contextPackageDeclaration.getName().getFullyQualifiedName();
    String[] subPackages=packageName.split(""String_Node_Str"");
    for (int i=0; i < subPackages.length; i++)     rootContainer=(IContainer)rootContainer.getParent();
  }
  String abstractClassFullyQualifiedName=typeCheckElimination.getAbstractClassName();
  IFile abstractClassFile=getFile(rootContainer,abstractClassFullyQualifiedName);
  IJavaElement abstractJavaElement=JavaCore.create(abstractClassFile);
  ITextEditor abstractEditor=null;
  try {
    abstractEditor=(ITextEditor)JavaUI.openInEditor(abstractJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit abstractICompilationUnit=(ICompilationUnit)abstractJavaElement;
  ASTParser abstractParser=ASTParser.newParser(AST.JLS3);
  abstractParser.setKind(ASTParser.K_COMPILATION_UNIT);
  abstractParser.setSource(abstractICompilationUnit);
  abstractParser.setResolveBindings(true);
  CompilationUnit abstractCompilationUnit=(CompilationUnit)abstractParser.createAST(null);
  AST abstractAST=abstractCompilationUnit.getAST();
  ASTRewrite abstractRewriter=ASTRewrite.create(abstractAST);
  TypeDeclaration abstractClassTypeDeclaration=null;
  List<AbstractTypeDeclaration> abstractTypeDeclarations=abstractCompilationUnit.types();
  for (  AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
    if (abstractTypeDeclaration instanceof TypeDeclaration) {
      TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
      if (typeDeclaration.resolveBinding().getQualifiedName().equals(typeCheckElimination.getAbstractClassName())) {
        abstractClassTypeDeclaration=typeDeclaration;
        break;
      }
    }
  }
  int abstractClassModifiers=abstractClassTypeDeclaration.getModifiers();
  if ((abstractClassModifiers & Modifier.ABSTRACT) == 0 && !abstractClassTypeDeclaration.isInterface()) {
    ListRewrite abstractModifiersRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    abstractModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite abstractBodyRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration abstractMethodDeclaration=abstractAST.newMethodDeclaration();
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(abstractMethodName),null);
  if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
    abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,abstractAST.newPrimitiveType(PrimitiveType.VOID),null);
  }
 else {
    if (returnedVariable != null) {
      Type returnType=null;
      if (returnedVariable instanceof SingleVariableDeclaration) {
        SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
        returnType=singleVariableDeclaration.getType();
      }
 else       if (returnedVariable instanceof VariableDeclarationFragment) {
        VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
        returnType=variableDeclarationStatement.getType();
      }
      abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    }
 else {
      abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    }
  }
  ListRewrite abstractMethodModifiersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
  Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
  Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
  Set<IMethodBinding> superAccessedMethods=typeCheckElimination.getSuperAccessedMethods();
  if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0) {
    SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
    SimpleName parameterType=abstractAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,abstractAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(abstractAST.newSimpleName(typeBinding.getName()),null);
  }
  abstractBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,abstractCompilationUnit,abstractRewriter);
  }
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer abstractTextFileBuffer=bufferManager.getTextFileBuffer(abstractClassFile.getFullPath(),LocationKind.IFILE);
  IDocument abstractDocument=abstractTextFileBuffer.getDocument();
  TextEdit abstractEdit=abstractRewriter.rewriteAST(abstractDocument,null);
  try {
    UndoEdit abstractUndoEdit=abstractEdit.apply(abstractDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(abstractClassFile,abstractDocument,abstractUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  abstractEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  DefaultMutableTreeNode root=typeCheckElimination.getExistingInheritanceTree().getRootNode();
  Enumeration<DefaultMutableTreeNode> enumeration=root.children();
  while (enumeration.hasMoreElements()) {
    DefaultMutableTreeNode child=enumeration.nextElement();
    String childClassName=(String)child.getUserObject();
    if (!subclassNames.contains(childClassName))     subclassNames.add(childClassName);
  }
  for (int i=0; i < subclassNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      Expression expression=typeCheckElimination.getExpressionCorrespondingToTypeCheckStatementList(statements);
      remainingIfStatementExpression=typeCheckElimination.getRemainingIfStatementExpression(expression);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=getFile(rootContainer,subclassNames.get(i));
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    TypeDeclaration subclassTypeDeclaration=null;
    List<AbstractTypeDeclaration> subclassAbstractTypeDeclarations=subclassCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : subclassAbstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.resolveBinding().getQualifiedName().equals(subclassNames.get(i))) {
          subclassTypeDeclaration=typeDeclaration;
          break;
        }
      }
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(abstractMethodName),null);
    if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
      subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,subclassAST.newPrimitiveType(PrimitiveType.VOID),null);
    }
 else {
      if (returnedVariable != null) {
        Type returnType=null;
        if (returnedVariable instanceof SingleVariableDeclaration) {
          SingleVariableDeclaration singleVariableDeclaration=(SingleVariableDeclaration)returnedVariable;
          returnType=singleVariableDeclaration.getType();
        }
 else         if (returnedVariable instanceof VariableDeclarationFragment) {
          VariableDeclarationFragment variableDeclarationFragment=(VariableDeclarationFragment)returnedVariable;
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)variableDeclarationFragment.getParent();
          returnType=variableDeclarationStatement.getType();
        }
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      }
 else {
        subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      }
    }
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0 || superAccessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(enclosingIfStatementExpression);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods,superAccessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    if (returnedVariable != null && !returnedVariable.resolveBinding().isParameter()) {
      VariableDeclarationFragment variableDeclarationFragment=subclassAST.newVariableDeclarationFragment();
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariable.getName(),null);
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,returnedVariable.getInitializer(),null);
      VariableDeclarationStatement variableDeclarationStatement=subclassAST.newVariableDeclarationStatement(variableDeclarationFragment);
      subclassRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      concreteMethodBodyRewrite.insertFirst(variableDeclarationStatement,null);
    }
    SimpleName invokerSimpleName=null;
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      boolean insert=true;
      if (statement instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)statement;
        List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
        VariableDeclarationFragment fragment=fragments.get(0);
        if (fragment.getInitializer() instanceof CastExpression) {
          CastExpression castExpression=(CastExpression)fragment.getInitializer();
          if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
            invokerSimpleName=fragment.getName();
            insert=false;
          }
        }
      }
 else {
        StatementExtractor statementExtractor=new StatementExtractor();
        List<Statement> oldVariableDeclarations=statementExtractor.getVariableDeclarations(statement);
        List<Statement> newVariableDeclarations=statementExtractor.getVariableDeclarations(newStatement);
        int j=0;
        for (        Statement oldVariableDeclaration : oldVariableDeclarations) {
          VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)oldVariableDeclaration;
          List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
          VariableDeclarationFragment fragment=fragments.get(0);
          if (fragment.getInitializer() instanceof CastExpression) {
            CastExpression castExpression=(CastExpression)fragment.getInitializer();
            if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
              invokerSimpleName=fragment.getName();
              subclassRewriter.remove(newVariableDeclarations.get(j),null);
              break;
            }
          }
          j++;
        }
      }
      if (invokerSimpleName != null) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(newStatement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            Expression methodInvocationExpression=methodInvocation.getExpression();
            if (methodInvocationExpression instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)methodInvocationExpression;
              if (simpleName.getIdentifier().equals(invokerSimpleName.getIdentifier())) {
                subclassRewriter.remove(simpleName,null);
              }
            }
          }
        }
      }
      List<Expression> oldVariableInstructions=expressionExtractor.getVariableInstructions(statement);
      List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(oldVariableInstructions,newVariableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods,superAccessedMethods);
      if (insert) {
        if (ifStatementBodyRewrite != null)         ifStatementBodyRewrite.insertLast(newStatement,null);
 else         concreteMethodBodyRewrite.insertLast(newStatement,null);
      }
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}"
12197,"private void modifyMethodInvocationsInSubclass(List<Expression> oldMethodInvocations,List<Expression> newMethodInvocations,AST subclassAST,ASTRewrite subclassRewriter,Set<MethodDeclaration> accessedMethods,Set<IMethodBinding> superAccessedMethods){
  int j=0;
  for (  Expression expression : newMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation newMethodInvocation=(MethodInvocation)expression;
      MethodInvocation oldMethodInvocation=(MethodInvocation)oldMethodInvocations.get(j);
      for (      MethodDeclaration methodDeclaration : accessedMethods) {
        if (oldMethodInvocation.resolveMethodBinding().isEqualTo(methodDeclaration.resolveBinding())) {
          String invokerName=sourceTypeDeclaration.getName().getIdentifier();
          invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
          subclassRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
          break;
        }
      }
      for (      IMethodBinding superMethodBinding : superAccessedMethods) {
        if (superMethodBinding.isEqualTo(oldMethodInvocation.resolveMethodBinding())) {
          String invokerName=sourceTypeDeclaration.getName().getIdentifier();
          invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
          subclassRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
          break;
        }
      }
    }
    j++;
  }
}","private void modifyMethodInvocationsInSubclass(List<Expression> oldMethodInvocations,List<Expression> newMethodInvocations,AST subclassAST,ASTRewrite subclassRewriter,Set<MethodDeclaration> accessedMethods,Set<IMethodBinding> superAccessedMethods){
  int j=0;
  for (  Expression expression : newMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation newMethodInvocation=(MethodInvocation)expression;
      MethodInvocation oldMethodInvocation=(MethodInvocation)oldMethodInvocations.get(j);
      for (      MethodDeclaration methodDeclaration : accessedMethods) {
        if (oldMethodInvocation.resolveMethodBinding().isEqualTo(methodDeclaration.resolveBinding())) {
          String invokerName=sourceTypeDeclaration.getName().getIdentifier();
          invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
          subclassRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
          break;
        }
      }
      for (      IMethodBinding superMethodBinding : superAccessedMethods) {
        if (superMethodBinding.isEqualTo(oldMethodInvocation.resolveMethodBinding())) {
          if (oldMethodInvocation.getExpression() == null || (oldMethodInvocation.getExpression() != null && oldMethodInvocation.getExpression() instanceof ThisExpression)) {
            String invokerName=sourceTypeDeclaration.getName().getIdentifier();
            invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
            subclassRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            break;
          }
        }
      }
    }
    j++;
  }
}"
12198,"private void modifyClient(){
  AST clientAST=sourceTypeDeclaration.getAST();
  MethodDeclaration typeCheckMethod=typeCheckElimination.getTypeCheckMethod();
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  Type typeCheckMethodReturnType=typeCheckMethod.getReturnType2();
  if (typeCheckMethodReturnType.isPrimitiveType() && ((PrimitiveType)typeCheckMethodReturnType).getPrimitiveTypeCode().equals(PrimitiveType.VOID)) {
    MethodInvocation abstractMethodInvocation=clientAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,clientAST.newSimpleName(abstractMethodName),null);
    SimpleName typeVariableName=null;
    if (typeCheckElimination.getTypeField() != null) {
      typeVariableName=typeCheckElimination.getTypeField().getName();
    }
 else     if (typeCheckElimination.getTypeLocalVariable() != null) {
      typeVariableName=typeCheckElimination.getTypeLocalVariable();
    }
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeVariableName,null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(clientAST.newThisExpression(),null);
    }
    ExpressionStatement expressionStatement=clientAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    MethodInvocation abstractMethodInvocation=clientAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,clientAST.newSimpleName(abstractMethodName),null);
    SimpleName typeVariableName=null;
    if (typeCheckElimination.getTypeField() != null) {
      typeVariableName=typeCheckElimination.getTypeField().getName();
    }
 else     if (typeCheckElimination.getTypeLocalVariable() != null) {
      typeVariableName=typeCheckElimination.getTypeLocalVariable();
    }
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeVariableName,null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(clientAST.newThisExpression(),null);
    }
    if (returnedVariable != null) {
      Assignment assignment=clientAST.newAssignment();
      sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
      ExpressionStatement expressionStatement=clientAST.newExpressionStatement(assignment);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
    }
 else {
      ReturnStatement returnStatement=clientAST.newReturnStatement();
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractMethodInvocation,null);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),returnStatement,null);
    }
  }
  generateGettersForAccessedFields();
  generateSettersForAssignedFields();
  setPublicModifierToAccessedMethods();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","private void modifyClient(){
  AST clientAST=sourceTypeDeclaration.getAST();
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  if (returnedVariable == null && !typeCheckElimination.typeCheckCodeFragmentContainsReturnStatement()) {
    MethodInvocation abstractMethodInvocation=clientAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,clientAST.newSimpleName(abstractMethodName),null);
    SimpleName typeVariableName=null;
    if (typeCheckElimination.getTypeField() != null) {
      typeVariableName=typeCheckElimination.getTypeField().getName();
    }
 else     if (typeCheckElimination.getTypeLocalVariable() != null) {
      typeVariableName=typeCheckElimination.getTypeLocalVariable();
    }
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeVariableName,null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(clientAST.newThisExpression(),null);
    }
    ExpressionStatement expressionStatement=clientAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    MethodInvocation abstractMethodInvocation=clientAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,clientAST.newSimpleName(abstractMethodName),null);
    SimpleName typeVariableName=null;
    if (typeCheckElimination.getTypeField() != null) {
      typeVariableName=typeCheckElimination.getTypeField().getName();
    }
 else     if (typeCheckElimination.getTypeLocalVariable() != null) {
      typeVariableName=typeCheckElimination.getTypeLocalVariable();
    }
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeVariableName,null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0 || typeCheckElimination.getSuperAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(clientAST.newThisExpression(),null);
    }
    if (returnedVariable != null) {
      Assignment assignment=clientAST.newAssignment();
      sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
      ExpressionStatement expressionStatement=clientAST.newExpressionStatement(assignment);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
    }
 else {
      ReturnStatement returnStatement=clientAST.newReturnStatement();
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractMethodInvocation,null);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),returnStatement,null);
    }
  }
  generateGettersForAccessedFields();
  generateSettersForAssignedFields();
  setPublicModifierToAccessedMethods();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12199,"private void modifySourceVariableInstructionsInSubclass(List<Expression> oldVariableInstructions,List<Expression> newVariableInstructions,AST subclassAST,ASTRewrite subclassRewriter,Set<VariableDeclarationFragment> accessedFields,Set<VariableDeclarationFragment> assignedFields,Set<IVariableBinding> superAccessedFields,Set<IVariableBinding> superAssignedFields){
  int j=0;
  Set<IVariableBinding> accessedFieldBindings=new LinkedHashSet<IVariableBinding>();
  for (  VariableDeclarationFragment fragment : accessedFields) {
    accessedFieldBindings.add(fragment.resolveBinding());
  }
  accessedFieldBindings.addAll(superAccessedFields);
  Set<IVariableBinding> assignedFieldBindings=new LinkedHashSet<IVariableBinding>();
  for (  VariableDeclarationFragment fragment : assignedFields) {
    assignedFieldBindings.add(fragment.resolveBinding());
  }
  assignedFieldBindings.addAll(superAccessedFields);
  for (  Expression expression : newVariableInstructions) {
    SimpleName newSimpleName=(SimpleName)expression;
    SimpleName oldSimpleName=(SimpleName)oldVariableInstructions.get(j);
    Expression newParentExpression=null;
    Expression oldParentExpression=null;
    if (newSimpleName.getParent() instanceof QualifiedName) {
      newParentExpression=(QualifiedName)newSimpleName.getParent();
      oldParentExpression=(QualifiedName)oldSimpleName.getParent();
    }
 else     if (newSimpleName.getParent() instanceof FieldAccess) {
      newParentExpression=(FieldAccess)newSimpleName.getParent();
      oldParentExpression=(FieldAccess)oldSimpleName.getParent();
    }
 else {
      newParentExpression=newSimpleName;
      oldParentExpression=oldSimpleName;
    }
    if (newParentExpression.getParent() instanceof Assignment) {
      Assignment newAssignment=(Assignment)newParentExpression.getParent();
      Assignment oldAssignment=(Assignment)oldParentExpression.getParent();
      Expression newLeftHandSide=newAssignment.getLeftHandSide();
      Expression oldLeftHandSide=oldAssignment.getLeftHandSide();
      SimpleName newLeftHandSideName=null;
      SimpleName oldLeftHandSideName=null;
      if (newLeftHandSide instanceof SimpleName) {
        newLeftHandSideName=(SimpleName)newLeftHandSide;
        oldLeftHandSideName=(SimpleName)oldLeftHandSide;
      }
 else       if (newLeftHandSide instanceof QualifiedName) {
        QualifiedName newLeftHandSideQualifiedName=(QualifiedName)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideQualifiedName.getName();
        QualifiedName oldLeftHandSideQualifiedName=(QualifiedName)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideQualifiedName.getName();
      }
 else       if (newLeftHandSide instanceof FieldAccess) {
        FieldAccess newLeftHandSideFieldAccess=(FieldAccess)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideFieldAccess.getName();
        FieldAccess oldLeftHandSideFieldAccess=(FieldAccess)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideFieldAccess.getName();
      }
      Expression newRightHandSide=newAssignment.getRightHandSide();
      Expression oldRightHandSide=oldAssignment.getRightHandSide();
      SimpleName newRightHandSideName=null;
      SimpleName oldRightHandSideName=null;
      if (newRightHandSide instanceof SimpleName) {
        newRightHandSideName=(SimpleName)newRightHandSide;
        oldRightHandSideName=(SimpleName)oldRightHandSide;
      }
 else       if (newRightHandSide instanceof QualifiedName) {
        QualifiedName newRightHandSideQualifiedName=(QualifiedName)newRightHandSide;
        newRightHandSideName=newRightHandSideQualifiedName.getName();
        QualifiedName oldRightHandSideQualifiedName=(QualifiedName)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideQualifiedName.getName();
      }
 else       if (newRightHandSide instanceof FieldAccess) {
        FieldAccess newRightHandSideFieldAccess=(FieldAccess)newRightHandSide;
        newRightHandSideName=newRightHandSideFieldAccess.getName();
        FieldAccess oldRightHandSideFieldAccess=(FieldAccess)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideFieldAccess.getName();
      }
      String invokerName=sourceTypeDeclaration.getName().getIdentifier();
      invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
      if (newLeftHandSideName != null && newLeftHandSideName.equals(newSimpleName)) {
        for (        IVariableBinding assignedFieldBinding : assignedFieldBindings) {
          if (assignedFieldBinding.isEqualTo(oldLeftHandSideName.resolveBinding())) {
            IMethodBinding setterMethodBinding=null;
            if (superAssignedFields.contains(assignedFieldBinding)) {
              setterMethodBinding=typeCheckElimination.getSetterMethodBindingOfSuperAssignedField(assignedFieldBinding);
            }
 else {
              setterMethodBinding=findSetterMethodInContext(assignedFieldBinding);
            }
            String leftHandMethodName;
            if (setterMethodBinding != null) {
              leftHandMethodName=setterMethodBinding.getName();
            }
 else {
              leftHandMethodName=assignedFieldBinding.getName();
              leftHandMethodName=""String_Node_Str"" + leftHandMethodName.substring(0,1).toUpperCase() + leftHandMethodName.substring(1,leftHandMethodName.length());
            }
            MethodInvocation leftHandMethodInvocation=subclassAST.newMethodInvocation();
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(leftHandMethodName),null);
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            ListRewrite methodInvocationArgumentsRewrite=subclassRewriter.getListRewrite(leftHandMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            if (newRightHandSideName != null) {
              boolean accessedFieldFound=false;
              for (              IVariableBinding accessedFieldBinding : accessedFieldBindings) {
                if (accessedFieldBinding.isEqualTo(oldRightHandSideName.resolveBinding())) {
                  if ((accessedFieldBinding.getModifiers() & Modifier.STATIC) != 0 && (accessedFieldBinding.getModifiers() & Modifier.PUBLIC) != 0) {
                    SimpleName qualifier=subclassAST.newSimpleName(accessedFieldBinding.getDeclaringClass().getName());
                    if (newRightHandSideName.getParent() instanceof FieldAccess) {
                      FieldAccess fieldAccess=(FieldAccess)newRightHandSideName.getParent();
                      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
                      methodInvocationArgumentsRewrite.insertLast(fieldAccess,null);
                    }
 else                     if (newRightHandSideName.getParent() instanceof QualifiedName) {
                      QualifiedName qualifiedName=(QualifiedName)newRightHandSideName.getParent();
                      methodInvocationArgumentsRewrite.insertLast(qualifiedName,null);
                    }
 else {
                      SimpleName simpleName=subclassAST.newSimpleName(newRightHandSideName.getIdentifier());
                      QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
                      subclassRewriter.replace(newRightHandSideName,newQualifiedName,null);
                      methodInvocationArgumentsRewrite.insertLast(newQualifiedName,null);
                    }
                  }
 else {
                    IMethodBinding getterMethodBinding=null;
                    if (superAccessedFields.contains(accessedFieldBinding)) {
                      getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
                    }
 else {
                      getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
                    }
                    String rightHandMethodName;
                    if (getterMethodBinding != null) {
                      rightHandMethodName=getterMethodBinding.getName();
                    }
 else {
                      rightHandMethodName=accessedFieldBinding.getName();
                      rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
                    }
                    MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
                    subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
                    subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
                    methodInvocationArgumentsRewrite.insertLast(rightHandMethodInvocation,null);
                  }
                  accessedFieldFound=true;
                  break;
                }
              }
              if (!accessedFieldFound)               methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
 else {
              methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
            subclassRewriter.replace(newAssignment,leftHandMethodInvocation,null);
            break;
          }
        }
      }
    }
 else {
      for (      IVariableBinding accessedFieldBinding : accessedFieldBindings) {
        if (accessedFieldBinding.isEqualTo(oldSimpleName.resolveBinding())) {
          if ((accessedFieldBinding.getModifiers() & Modifier.STATIC) != 0 && (accessedFieldBinding.getModifiers() & Modifier.PUBLIC) != 0) {
            SimpleName qualifier=subclassAST.newSimpleName(accessedFieldBinding.getDeclaringClass().getName());
            if (newSimpleName.getParent() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
              subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
            }
 else             if (!(newSimpleName.getParent() instanceof QualifiedName)) {
              SimpleName simpleName=subclassAST.newSimpleName(newSimpleName.getIdentifier());
              QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
              subclassRewriter.replace(newSimpleName,newQualifiedName,null);
            }
          }
 else {
            IMethodBinding getterMethodBinding=null;
            if (superAccessedFields.contains(accessedFieldBinding)) {
              getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
            }
 else {
              getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
            }
            String methodName;
            if (getterMethodBinding != null) {
              methodName=getterMethodBinding.getName();
            }
 else {
              methodName=accessedFieldBinding.getName();
              methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
            }
            MethodInvocation methodInvocation=subclassAST.newMethodInvocation();
            subclassRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(methodName),null);
            String invokerName=sourceTypeDeclaration.getName().getIdentifier();
            invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
            subclassRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            if (newSimpleName.getParent() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
              subclassRewriter.replace(fieldAccess,methodInvocation,null);
            }
 else             if (newSimpleName.getParent() instanceof QualifiedName) {
              QualifiedName qualifiedName=(QualifiedName)newSimpleName.getParent();
              subclassRewriter.replace(qualifiedName,methodInvocation,null);
            }
 else {
              subclassRewriter.replace(newSimpleName,methodInvocation,null);
            }
          }
          break;
        }
      }
    }
    j++;
  }
}","private void modifySourceVariableInstructionsInSubclass(List<Expression> oldVariableInstructions,List<Expression> newVariableInstructions,AST subclassAST,ASTRewrite subclassRewriter,Set<VariableDeclarationFragment> accessedFields,Set<VariableDeclarationFragment> assignedFields,Set<IVariableBinding> superAccessedFields,Set<IVariableBinding> superAssignedFields){
  int j=0;
  Set<IVariableBinding> accessedFieldBindings=new LinkedHashSet<IVariableBinding>();
  for (  VariableDeclarationFragment fragment : accessedFields) {
    accessedFieldBindings.add(fragment.resolveBinding());
  }
  accessedFieldBindings.addAll(superAccessedFields);
  Set<IVariableBinding> assignedFieldBindings=new LinkedHashSet<IVariableBinding>();
  for (  VariableDeclarationFragment fragment : assignedFields) {
    assignedFieldBindings.add(fragment.resolveBinding());
  }
  assignedFieldBindings.addAll(superAccessedFields);
  for (  Expression expression : newVariableInstructions) {
    SimpleName newSimpleName=(SimpleName)expression;
    SimpleName oldSimpleName=(SimpleName)oldVariableInstructions.get(j);
    Expression newParentExpression=null;
    Expression oldParentExpression=null;
    if (newSimpleName.getParent() instanceof QualifiedName) {
      newParentExpression=(QualifiedName)newSimpleName.getParent();
      oldParentExpression=(QualifiedName)oldSimpleName.getParent();
    }
 else     if (newSimpleName.getParent() instanceof FieldAccess) {
      newParentExpression=(FieldAccess)newSimpleName.getParent();
      oldParentExpression=(FieldAccess)oldSimpleName.getParent();
    }
 else {
      newParentExpression=newSimpleName;
      oldParentExpression=oldSimpleName;
    }
    if (newParentExpression.getParent() instanceof Assignment) {
      Assignment newAssignment=(Assignment)newParentExpression.getParent();
      Assignment oldAssignment=(Assignment)oldParentExpression.getParent();
      Expression newLeftHandSide=newAssignment.getLeftHandSide();
      Expression oldLeftHandSide=oldAssignment.getLeftHandSide();
      SimpleName newLeftHandSideName=null;
      SimpleName oldLeftHandSideName=null;
      if (newLeftHandSide instanceof SimpleName) {
        newLeftHandSideName=(SimpleName)newLeftHandSide;
        oldLeftHandSideName=(SimpleName)oldLeftHandSide;
      }
 else       if (newLeftHandSide instanceof QualifiedName) {
        QualifiedName newLeftHandSideQualifiedName=(QualifiedName)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideQualifiedName.getName();
        QualifiedName oldLeftHandSideQualifiedName=(QualifiedName)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideQualifiedName.getName();
      }
 else       if (newLeftHandSide instanceof FieldAccess) {
        FieldAccess newLeftHandSideFieldAccess=(FieldAccess)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideFieldAccess.getName();
        FieldAccess oldLeftHandSideFieldAccess=(FieldAccess)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideFieldAccess.getName();
      }
      Expression newRightHandSide=newAssignment.getRightHandSide();
      Expression oldRightHandSide=oldAssignment.getRightHandSide();
      SimpleName newRightHandSideName=null;
      SimpleName oldRightHandSideName=null;
      if (newRightHandSide instanceof SimpleName) {
        newRightHandSideName=(SimpleName)newRightHandSide;
        oldRightHandSideName=(SimpleName)oldRightHandSide;
      }
 else       if (newRightHandSide instanceof QualifiedName) {
        QualifiedName newRightHandSideQualifiedName=(QualifiedName)newRightHandSide;
        newRightHandSideName=newRightHandSideQualifiedName.getName();
        QualifiedName oldRightHandSideQualifiedName=(QualifiedName)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideQualifiedName.getName();
      }
 else       if (newRightHandSide instanceof FieldAccess) {
        FieldAccess newRightHandSideFieldAccess=(FieldAccess)newRightHandSide;
        newRightHandSideName=newRightHandSideFieldAccess.getName();
        FieldAccess oldRightHandSideFieldAccess=(FieldAccess)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideFieldAccess.getName();
      }
      String invokerName=sourceTypeDeclaration.getName().getIdentifier();
      invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
      if (newLeftHandSideName != null && newLeftHandSideName.equals(newSimpleName)) {
        for (        IVariableBinding assignedFieldBinding : assignedFieldBindings) {
          if (assignedFieldBinding.isEqualTo(oldLeftHandSideName.resolveBinding())) {
            IMethodBinding setterMethodBinding=null;
            if (superAssignedFields.contains(assignedFieldBinding)) {
              setterMethodBinding=typeCheckElimination.getSetterMethodBindingOfSuperAssignedField(assignedFieldBinding);
            }
 else {
              setterMethodBinding=findSetterMethodInContext(assignedFieldBinding);
            }
            String leftHandMethodName;
            if (setterMethodBinding != null) {
              leftHandMethodName=setterMethodBinding.getName();
            }
 else {
              leftHandMethodName=assignedFieldBinding.getName();
              leftHandMethodName=""String_Node_Str"" + leftHandMethodName.substring(0,1).toUpperCase() + leftHandMethodName.substring(1,leftHandMethodName.length());
            }
            MethodInvocation leftHandMethodInvocation=subclassAST.newMethodInvocation();
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(leftHandMethodName),null);
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            ListRewrite methodInvocationArgumentsRewrite=subclassRewriter.getListRewrite(leftHandMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            if (newRightHandSideName != null) {
              boolean accessedFieldFound=false;
              for (              IVariableBinding accessedFieldBinding : accessedFieldBindings) {
                if (accessedFieldBinding.isEqualTo(oldRightHandSideName.resolveBinding())) {
                  if ((accessedFieldBinding.getModifiers() & Modifier.STATIC) != 0 && (accessedFieldBinding.getModifiers() & Modifier.PUBLIC) != 0) {
                    SimpleName qualifier=subclassAST.newSimpleName(accessedFieldBinding.getDeclaringClass().getName());
                    if (newRightHandSideName.getParent() instanceof FieldAccess) {
                      FieldAccess fieldAccess=(FieldAccess)newRightHandSideName.getParent();
                      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
                      methodInvocationArgumentsRewrite.insertLast(fieldAccess,null);
                    }
 else                     if (newRightHandSideName.getParent() instanceof QualifiedName) {
                      QualifiedName qualifiedName=(QualifiedName)newRightHandSideName.getParent();
                      methodInvocationArgumentsRewrite.insertLast(qualifiedName,null);
                    }
 else {
                      SimpleName simpleName=subclassAST.newSimpleName(newRightHandSideName.getIdentifier());
                      QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
                      subclassRewriter.replace(newRightHandSideName,newQualifiedName,null);
                      methodInvocationArgumentsRewrite.insertLast(newQualifiedName,null);
                    }
                  }
 else {
                    IMethodBinding getterMethodBinding=null;
                    if (superAccessedFields.contains(accessedFieldBinding)) {
                      getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
                    }
 else {
                      getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
                    }
                    String rightHandMethodName;
                    if (getterMethodBinding != null) {
                      rightHandMethodName=getterMethodBinding.getName();
                    }
 else {
                      rightHandMethodName=accessedFieldBinding.getName();
                      rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
                    }
                    MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
                    subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
                    subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
                    methodInvocationArgumentsRewrite.insertLast(rightHandMethodInvocation,null);
                  }
                  accessedFieldFound=true;
                  break;
                }
              }
              if (!accessedFieldFound)               methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
 else {
              methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
            subclassRewriter.replace(newAssignment,leftHandMethodInvocation,null);
            break;
          }
        }
      }
      if (newRightHandSideName != null && newRightHandSideName.equals(newSimpleName)) {
        for (        IVariableBinding accessedFieldBinding : accessedFieldBindings) {
          if (accessedFieldBinding.isEqualTo(oldRightHandSideName.resolveBinding())) {
            if ((accessedFieldBinding.getModifiers() & Modifier.STATIC) != 0 && (accessedFieldBinding.getModifiers() & Modifier.PUBLIC) != 0) {
              SimpleName qualifier=subclassAST.newSimpleName(accessedFieldBinding.getDeclaringClass().getName());
              if (newSimpleName.getParent() instanceof FieldAccess) {
                FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
                subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
              }
 else               if (!(newSimpleName.getParent() instanceof QualifiedName)) {
                SimpleName simpleName=subclassAST.newSimpleName(newSimpleName.getIdentifier());
                QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
                subclassRewriter.replace(newSimpleName,newQualifiedName,null);
              }
            }
 else {
              IMethodBinding getterMethodBinding=null;
              if (superAccessedFields.contains(accessedFieldBinding)) {
                getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
              }
 else {
                getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
              }
              String rightHandMethodName;
              if (getterMethodBinding != null) {
                rightHandMethodName=getterMethodBinding.getName();
              }
 else {
                rightHandMethodName=accessedFieldBinding.getName();
                rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
              }
              MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
              subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
              subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
              subclassRewriter.set(newAssignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,rightHandMethodInvocation,null);
            }
            break;
          }
        }
      }
    }
 else {
      for (      IVariableBinding accessedFieldBinding : accessedFieldBindings) {
        if (accessedFieldBinding.isEqualTo(oldSimpleName.resolveBinding())) {
          if ((accessedFieldBinding.getModifiers() & Modifier.STATIC) != 0 && (accessedFieldBinding.getModifiers() & Modifier.PUBLIC) != 0) {
            SimpleName qualifier=subclassAST.newSimpleName(accessedFieldBinding.getDeclaringClass().getName());
            if (newSimpleName.getParent() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
              subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
            }
 else             if (!(newSimpleName.getParent() instanceof QualifiedName)) {
              SimpleName simpleName=subclassAST.newSimpleName(newSimpleName.getIdentifier());
              QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
              subclassRewriter.replace(newSimpleName,newQualifiedName,null);
            }
          }
 else {
            IMethodBinding getterMethodBinding=null;
            if (superAccessedFields.contains(accessedFieldBinding)) {
              getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
            }
 else {
              getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
            }
            String methodName;
            if (getterMethodBinding != null) {
              methodName=getterMethodBinding.getName();
            }
 else {
              methodName=accessedFieldBinding.getName();
              methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
            }
            MethodInvocation methodInvocation=subclassAST.newMethodInvocation();
            subclassRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(methodName),null);
            String invokerName=sourceTypeDeclaration.getName().getIdentifier();
            invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
            subclassRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            if (newSimpleName.getParent() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
              subclassRewriter.replace(fieldAccess,methodInvocation,null);
            }
 else             if (newSimpleName.getParent() instanceof QualifiedName) {
              QualifiedName qualifiedName=(QualifiedName)newSimpleName.getParent();
              subclassRewriter.replace(qualifiedName,methodInvocation,null);
            }
 else {
              subclassRewriter.replace(newSimpleName,methodInvocation,null);
            }
          }
          break;
        }
      }
    }
    j++;
  }
}"
12200,"private void modifySourceVariableInstructionsInSubclass(List<Expression> oldVariableInstructions,List<Expression> newVariableInstructions,AST subclassAST,ASTRewrite subclassRewriter,Set<VariableDeclarationFragment> accessedFields,Set<VariableDeclarationFragment> assignedFields,Set<IVariableBinding> superAccessedFields,Set<IVariableBinding> superAssignedFields){
  int j=0;
  Set<IVariableBinding> accessedFieldBindings=new LinkedHashSet<IVariableBinding>();
  for (  VariableDeclarationFragment fragment : accessedFields) {
    accessedFieldBindings.add(fragment.resolveBinding());
  }
  accessedFieldBindings.addAll(superAccessedFields);
  Set<IVariableBinding> assignedFieldBindings=new LinkedHashSet<IVariableBinding>();
  for (  VariableDeclarationFragment fragment : assignedFields) {
    assignedFieldBindings.add(fragment.resolveBinding());
  }
  assignedFieldBindings.addAll(superAccessedFields);
  for (  Expression expression : newVariableInstructions) {
    SimpleName newSimpleName=(SimpleName)expression;
    SimpleName oldSimpleName=(SimpleName)oldVariableInstructions.get(j);
    Expression newParentExpression=null;
    Expression oldParentExpression=null;
    if (newSimpleName.getParent() instanceof QualifiedName) {
      newParentExpression=(QualifiedName)newSimpleName.getParent();
      oldParentExpression=(QualifiedName)oldSimpleName.getParent();
    }
 else     if (newSimpleName.getParent() instanceof FieldAccess) {
      newParentExpression=(FieldAccess)newSimpleName.getParent();
      oldParentExpression=(FieldAccess)oldSimpleName.getParent();
    }
 else {
      newParentExpression=newSimpleName;
      oldParentExpression=oldSimpleName;
    }
    if (newParentExpression.getParent() instanceof Assignment) {
      Assignment newAssignment=(Assignment)newParentExpression.getParent();
      Assignment oldAssignment=(Assignment)oldParentExpression.getParent();
      Expression newLeftHandSide=newAssignment.getLeftHandSide();
      Expression oldLeftHandSide=oldAssignment.getLeftHandSide();
      SimpleName newLeftHandSideName=null;
      SimpleName oldLeftHandSideName=null;
      if (newLeftHandSide instanceof SimpleName) {
        newLeftHandSideName=(SimpleName)newLeftHandSide;
        oldLeftHandSideName=(SimpleName)oldLeftHandSide;
      }
 else       if (newLeftHandSide instanceof QualifiedName) {
        QualifiedName newLeftHandSideQualifiedName=(QualifiedName)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideQualifiedName.getName();
        QualifiedName oldLeftHandSideQualifiedName=(QualifiedName)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideQualifiedName.getName();
      }
 else       if (newLeftHandSide instanceof FieldAccess) {
        FieldAccess newLeftHandSideFieldAccess=(FieldAccess)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideFieldAccess.getName();
        FieldAccess oldLeftHandSideFieldAccess=(FieldAccess)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideFieldAccess.getName();
      }
      Expression newRightHandSide=newAssignment.getRightHandSide();
      Expression oldRightHandSide=oldAssignment.getRightHandSide();
      SimpleName newRightHandSideName=null;
      SimpleName oldRightHandSideName=null;
      if (newRightHandSide instanceof SimpleName) {
        newRightHandSideName=(SimpleName)newRightHandSide;
        oldRightHandSideName=(SimpleName)oldRightHandSide;
      }
 else       if (newRightHandSide instanceof QualifiedName) {
        QualifiedName newRightHandSideQualifiedName=(QualifiedName)newRightHandSide;
        newRightHandSideName=newRightHandSideQualifiedName.getName();
        QualifiedName oldRightHandSideQualifiedName=(QualifiedName)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideQualifiedName.getName();
      }
 else       if (newRightHandSide instanceof FieldAccess) {
        FieldAccess newRightHandSideFieldAccess=(FieldAccess)newRightHandSide;
        newRightHandSideName=newRightHandSideFieldAccess.getName();
        FieldAccess oldRightHandSideFieldAccess=(FieldAccess)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideFieldAccess.getName();
      }
      String invokerName=sourceTypeDeclaration.getName().getIdentifier();
      invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
      if (newLeftHandSideName != null && newLeftHandSideName.equals(newSimpleName)) {
        for (        IVariableBinding assignedFieldBinding : assignedFieldBindings) {
          if (assignedFieldBinding.isEqualTo(oldLeftHandSideName.resolveBinding())) {
            IMethodBinding setterMethodBinding=null;
            if (superAssignedFields.contains(assignedFieldBinding)) {
              setterMethodBinding=typeCheckElimination.getSetterMethodBindingOfSuperAssignedField(assignedFieldBinding);
            }
 else {
              setterMethodBinding=findSetterMethodInContext(assignedFieldBinding);
            }
            String leftHandMethodName;
            if (setterMethodBinding != null) {
              leftHandMethodName=setterMethodBinding.getName();
            }
 else {
              leftHandMethodName=assignedFieldBinding.getName();
              leftHandMethodName=""String_Node_Str"" + leftHandMethodName.substring(0,1).toUpperCase() + leftHandMethodName.substring(1,leftHandMethodName.length());
            }
            MethodInvocation leftHandMethodInvocation=subclassAST.newMethodInvocation();
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(leftHandMethodName),null);
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            ListRewrite methodInvocationArgumentsRewrite=subclassRewriter.getListRewrite(leftHandMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            if (newRightHandSideName != null) {
              boolean accessedFieldFound=false;
              for (              IVariableBinding accessedFieldBinding : accessedFieldBindings) {
                if (accessedFieldBinding.isEqualTo(oldRightHandSideName.resolveBinding())) {
                  if ((accessedFieldBinding.getModifiers() & Modifier.STATIC) != 0 && (accessedFieldBinding.getModifiers() & Modifier.PUBLIC) != 0) {
                    SimpleName qualifier=subclassAST.newSimpleName(accessedFieldBinding.getDeclaringClass().getName());
                    if (newRightHandSideName.getParent() instanceof FieldAccess) {
                      FieldAccess fieldAccess=(FieldAccess)newRightHandSideName.getParent();
                      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
                      methodInvocationArgumentsRewrite.insertLast(fieldAccess,null);
                    }
 else                     if (newRightHandSideName.getParent() instanceof QualifiedName) {
                      QualifiedName qualifiedName=(QualifiedName)newRightHandSideName.getParent();
                      methodInvocationArgumentsRewrite.insertLast(qualifiedName,null);
                    }
 else {
                      SimpleName simpleName=subclassAST.newSimpleName(newRightHandSideName.getIdentifier());
                      QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
                      subclassRewriter.replace(newRightHandSideName,newQualifiedName,null);
                      methodInvocationArgumentsRewrite.insertLast(newQualifiedName,null);
                    }
                  }
 else {
                    IMethodBinding getterMethodBinding=null;
                    if (superAccessedFields.contains(accessedFieldBinding)) {
                      getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
                    }
 else {
                      getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
                    }
                    String rightHandMethodName;
                    if (getterMethodBinding != null) {
                      rightHandMethodName=getterMethodBinding.getName();
                    }
 else {
                      rightHandMethodName=accessedFieldBinding.getName();
                      rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
                    }
                    MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
                    subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
                    subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
                    methodInvocationArgumentsRewrite.insertLast(rightHandMethodInvocation,null);
                  }
                  accessedFieldFound=true;
                  break;
                }
              }
              if (!accessedFieldFound)               methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
 else {
              methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
            subclassRewriter.replace(newAssignment,leftHandMethodInvocation,null);
            break;
          }
        }
      }
    }
 else {
      for (      IVariableBinding accessedFieldBinding : accessedFieldBindings) {
        if (accessedFieldBinding.isEqualTo(oldSimpleName.resolveBinding())) {
          if ((accessedFieldBinding.getModifiers() & Modifier.STATIC) != 0 && (accessedFieldBinding.getModifiers() & Modifier.PUBLIC) != 0) {
            SimpleName qualifier=subclassAST.newSimpleName(accessedFieldBinding.getDeclaringClass().getName());
            if (newSimpleName.getParent() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
              subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
            }
 else             if (!(newSimpleName.getParent() instanceof QualifiedName)) {
              SimpleName simpleName=subclassAST.newSimpleName(newSimpleName.getIdentifier());
              QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
              subclassRewriter.replace(newSimpleName,newQualifiedName,null);
            }
          }
 else {
            IMethodBinding getterMethodBinding=null;
            if (superAccessedFields.contains(accessedFieldBinding)) {
              getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
            }
 else {
              getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
            }
            String methodName;
            if (getterMethodBinding != null) {
              methodName=getterMethodBinding.getName();
            }
 else {
              methodName=accessedFieldBinding.getName();
              methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
            }
            MethodInvocation methodInvocation=subclassAST.newMethodInvocation();
            subclassRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(methodName),null);
            String invokerName=sourceTypeDeclaration.getName().getIdentifier();
            invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
            subclassRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            if (newSimpleName.getParent() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
              subclassRewriter.replace(fieldAccess,methodInvocation,null);
            }
 else             if (newSimpleName.getParent() instanceof QualifiedName) {
              QualifiedName qualifiedName=(QualifiedName)newSimpleName.getParent();
              subclassRewriter.replace(qualifiedName,methodInvocation,null);
            }
 else {
              subclassRewriter.replace(newSimpleName,methodInvocation,null);
            }
          }
          break;
        }
      }
    }
    j++;
  }
}","private void modifySourceVariableInstructionsInSubclass(List<Expression> oldVariableInstructions,List<Expression> newVariableInstructions,AST subclassAST,ASTRewrite subclassRewriter,Set<VariableDeclarationFragment> accessedFields,Set<VariableDeclarationFragment> assignedFields,Set<IVariableBinding> superAccessedFields,Set<IVariableBinding> superAssignedFields){
  int j=0;
  Set<IVariableBinding> accessedFieldBindings=new LinkedHashSet<IVariableBinding>();
  for (  VariableDeclarationFragment fragment : accessedFields) {
    accessedFieldBindings.add(fragment.resolveBinding());
  }
  accessedFieldBindings.addAll(superAccessedFields);
  Set<IVariableBinding> assignedFieldBindings=new LinkedHashSet<IVariableBinding>();
  for (  VariableDeclarationFragment fragment : assignedFields) {
    assignedFieldBindings.add(fragment.resolveBinding());
  }
  assignedFieldBindings.addAll(superAccessedFields);
  for (  Expression expression : newVariableInstructions) {
    SimpleName newSimpleName=(SimpleName)expression;
    SimpleName oldSimpleName=(SimpleName)oldVariableInstructions.get(j);
    Expression newParentExpression=null;
    Expression oldParentExpression=null;
    if (newSimpleName.getParent() instanceof QualifiedName) {
      newParentExpression=(QualifiedName)newSimpleName.getParent();
      oldParentExpression=(QualifiedName)oldSimpleName.getParent();
    }
 else     if (newSimpleName.getParent() instanceof FieldAccess) {
      newParentExpression=(FieldAccess)newSimpleName.getParent();
      oldParentExpression=(FieldAccess)oldSimpleName.getParent();
    }
 else {
      newParentExpression=newSimpleName;
      oldParentExpression=oldSimpleName;
    }
    if (newParentExpression.getParent() instanceof Assignment) {
      Assignment newAssignment=(Assignment)newParentExpression.getParent();
      Assignment oldAssignment=(Assignment)oldParentExpression.getParent();
      Expression newLeftHandSide=newAssignment.getLeftHandSide();
      Expression oldLeftHandSide=oldAssignment.getLeftHandSide();
      SimpleName newLeftHandSideName=null;
      SimpleName oldLeftHandSideName=null;
      if (newLeftHandSide instanceof SimpleName) {
        newLeftHandSideName=(SimpleName)newLeftHandSide;
        oldLeftHandSideName=(SimpleName)oldLeftHandSide;
      }
 else       if (newLeftHandSide instanceof QualifiedName) {
        QualifiedName newLeftHandSideQualifiedName=(QualifiedName)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideQualifiedName.getName();
        QualifiedName oldLeftHandSideQualifiedName=(QualifiedName)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideQualifiedName.getName();
      }
 else       if (newLeftHandSide instanceof FieldAccess) {
        FieldAccess newLeftHandSideFieldAccess=(FieldAccess)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideFieldAccess.getName();
        FieldAccess oldLeftHandSideFieldAccess=(FieldAccess)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideFieldAccess.getName();
      }
      Expression newRightHandSide=newAssignment.getRightHandSide();
      Expression oldRightHandSide=oldAssignment.getRightHandSide();
      SimpleName newRightHandSideName=null;
      SimpleName oldRightHandSideName=null;
      if (newRightHandSide instanceof SimpleName) {
        newRightHandSideName=(SimpleName)newRightHandSide;
        oldRightHandSideName=(SimpleName)oldRightHandSide;
      }
 else       if (newRightHandSide instanceof QualifiedName) {
        QualifiedName newRightHandSideQualifiedName=(QualifiedName)newRightHandSide;
        newRightHandSideName=newRightHandSideQualifiedName.getName();
        QualifiedName oldRightHandSideQualifiedName=(QualifiedName)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideQualifiedName.getName();
      }
 else       if (newRightHandSide instanceof FieldAccess) {
        FieldAccess newRightHandSideFieldAccess=(FieldAccess)newRightHandSide;
        newRightHandSideName=newRightHandSideFieldAccess.getName();
        FieldAccess oldRightHandSideFieldAccess=(FieldAccess)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideFieldAccess.getName();
      }
      String invokerName=sourceTypeDeclaration.getName().getIdentifier();
      invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
      if (newLeftHandSideName != null && newLeftHandSideName.equals(newSimpleName)) {
        for (        IVariableBinding assignedFieldBinding : assignedFieldBindings) {
          if (assignedFieldBinding.isEqualTo(oldLeftHandSideName.resolveBinding())) {
            IMethodBinding setterMethodBinding=null;
            if (superAssignedFields.contains(assignedFieldBinding)) {
              setterMethodBinding=typeCheckElimination.getSetterMethodBindingOfSuperAssignedField(assignedFieldBinding);
            }
 else {
              setterMethodBinding=findSetterMethodInContext(assignedFieldBinding);
            }
            String leftHandMethodName;
            if (setterMethodBinding != null) {
              leftHandMethodName=setterMethodBinding.getName();
            }
 else {
              leftHandMethodName=assignedFieldBinding.getName();
              leftHandMethodName=""String_Node_Str"" + leftHandMethodName.substring(0,1).toUpperCase() + leftHandMethodName.substring(1,leftHandMethodName.length());
            }
            MethodInvocation leftHandMethodInvocation=subclassAST.newMethodInvocation();
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(leftHandMethodName),null);
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            ListRewrite methodInvocationArgumentsRewrite=subclassRewriter.getListRewrite(leftHandMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            if (newRightHandSideName != null) {
              boolean accessedFieldFound=false;
              for (              IVariableBinding accessedFieldBinding : accessedFieldBindings) {
                if (accessedFieldBinding.isEqualTo(oldRightHandSideName.resolveBinding())) {
                  if ((accessedFieldBinding.getModifiers() & Modifier.STATIC) != 0 && (accessedFieldBinding.getModifiers() & Modifier.PUBLIC) != 0) {
                    SimpleName qualifier=subclassAST.newSimpleName(accessedFieldBinding.getDeclaringClass().getName());
                    if (newRightHandSideName.getParent() instanceof FieldAccess) {
                      FieldAccess fieldAccess=(FieldAccess)newRightHandSideName.getParent();
                      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
                      methodInvocationArgumentsRewrite.insertLast(fieldAccess,null);
                    }
 else                     if (newRightHandSideName.getParent() instanceof QualifiedName) {
                      QualifiedName qualifiedName=(QualifiedName)newRightHandSideName.getParent();
                      methodInvocationArgumentsRewrite.insertLast(qualifiedName,null);
                    }
 else {
                      SimpleName simpleName=subclassAST.newSimpleName(newRightHandSideName.getIdentifier());
                      QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
                      subclassRewriter.replace(newRightHandSideName,newQualifiedName,null);
                      methodInvocationArgumentsRewrite.insertLast(newQualifiedName,null);
                    }
                  }
 else {
                    IMethodBinding getterMethodBinding=null;
                    if (superAccessedFields.contains(accessedFieldBinding)) {
                      getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
                    }
 else {
                      getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
                    }
                    String rightHandMethodName;
                    if (getterMethodBinding != null) {
                      rightHandMethodName=getterMethodBinding.getName();
                    }
 else {
                      rightHandMethodName=accessedFieldBinding.getName();
                      rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
                    }
                    MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
                    subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
                    subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
                    methodInvocationArgumentsRewrite.insertLast(rightHandMethodInvocation,null);
                  }
                  accessedFieldFound=true;
                  break;
                }
              }
              if (!accessedFieldFound)               methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
 else {
              methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
            subclassRewriter.replace(newAssignment,leftHandMethodInvocation,null);
            break;
          }
        }
      }
      if (newRightHandSideName != null && newRightHandSideName.equals(newSimpleName)) {
        for (        IVariableBinding accessedFieldBinding : accessedFieldBindings) {
          if (accessedFieldBinding.isEqualTo(oldRightHandSideName.resolveBinding())) {
            if ((accessedFieldBinding.getModifiers() & Modifier.STATIC) != 0 && (accessedFieldBinding.getModifiers() & Modifier.PUBLIC) != 0) {
              SimpleName qualifier=subclassAST.newSimpleName(accessedFieldBinding.getDeclaringClass().getName());
              if (newSimpleName.getParent() instanceof FieldAccess) {
                FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
                subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
              }
 else               if (!(newSimpleName.getParent() instanceof QualifiedName)) {
                SimpleName simpleName=subclassAST.newSimpleName(newSimpleName.getIdentifier());
                QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
                subclassRewriter.replace(newSimpleName,newQualifiedName,null);
              }
            }
 else {
              IMethodBinding getterMethodBinding=null;
              if (superAccessedFields.contains(accessedFieldBinding)) {
                getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
              }
 else {
                getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
              }
              String rightHandMethodName;
              if (getterMethodBinding != null) {
                rightHandMethodName=getterMethodBinding.getName();
              }
 else {
                rightHandMethodName=accessedFieldBinding.getName();
                rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
              }
              MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
              subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
              subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
              subclassRewriter.set(newAssignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,rightHandMethodInvocation,null);
            }
            break;
          }
        }
      }
    }
 else {
      for (      IVariableBinding accessedFieldBinding : accessedFieldBindings) {
        if (accessedFieldBinding.isEqualTo(oldSimpleName.resolveBinding())) {
          if ((accessedFieldBinding.getModifiers() & Modifier.STATIC) != 0 && (accessedFieldBinding.getModifiers() & Modifier.PUBLIC) != 0) {
            SimpleName qualifier=subclassAST.newSimpleName(accessedFieldBinding.getDeclaringClass().getName());
            if (newSimpleName.getParent() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
              subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
            }
 else             if (!(newSimpleName.getParent() instanceof QualifiedName)) {
              SimpleName simpleName=subclassAST.newSimpleName(newSimpleName.getIdentifier());
              QualifiedName newQualifiedName=subclassAST.newQualifiedName(qualifier,simpleName);
              subclassRewriter.replace(newSimpleName,newQualifiedName,null);
            }
          }
 else {
            IMethodBinding getterMethodBinding=null;
            if (superAccessedFields.contains(accessedFieldBinding)) {
              getterMethodBinding=typeCheckElimination.getGetterMethodBindingOfSuperAccessedField(accessedFieldBinding);
            }
 else {
              getterMethodBinding=findGetterMethodInContext(accessedFieldBinding);
            }
            String methodName;
            if (getterMethodBinding != null) {
              methodName=getterMethodBinding.getName();
            }
 else {
              methodName=accessedFieldBinding.getName();
              methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
            }
            MethodInvocation methodInvocation=subclassAST.newMethodInvocation();
            subclassRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(methodName),null);
            String invokerName=sourceTypeDeclaration.getName().getIdentifier();
            invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
            subclassRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            if (newSimpleName.getParent() instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)newSimpleName.getParent();
              subclassRewriter.replace(fieldAccess,methodInvocation,null);
            }
 else             if (newSimpleName.getParent() instanceof QualifiedName) {
              QualifiedName qualifiedName=(QualifiedName)newSimpleName.getParent();
              subclassRewriter.replace(qualifiedName,methodInvocation,null);
            }
 else {
              subclassRewriter.replace(newSimpleName,methodInvocation,null);
            }
          }
          break;
        }
      }
    }
    j++;
  }
}"
12201,"public IfStatementExpressionAnalyzer(Expression completeExpression){
  this.root=new DefaultMutableTreeNode();
  this.completeExpression=completeExpression;
  processExpression(root,completeExpression);
}","public IfStatementExpressionAnalyzer(Expression completeExpression){
  this.root=new DefaultMutableTreeNode();
  this.completeExpression=completeExpression;
  this.typeVariableExpressionMap=new LinkedHashMap<SimpleName,Expression>();
  this.typeVariableStaticFieldMap=new LinkedHashMap<SimpleName,SimpleName>();
  this.typeVariableSubclassMap=new LinkedHashMap<SimpleName,Type>();
  processExpression(root,completeExpression);
}"
12202,"public TypeCheckCodeFragmentAnalyzer(TypeCheckElimination typeCheckElimination,TypeDeclaration typeDeclaration,MethodDeclaration typeCheckMethod,List<InheritanceTree> inheritanceTreeList){
  this.typeCheckElimination=typeCheckElimination;
  this.typeDeclaration=typeDeclaration;
  this.typeCheckMethod=typeCheckMethod;
  this.fields=typeDeclaration.getFields();
  this.methods=typeDeclaration.getMethods();
  this.inheritanceTreeList=inheritanceTreeList;
  this.typeVariableCounterMap=new LinkedHashMap<SimpleName,Integer>();
  typeCheckElimination.setTypeCheckMethod(typeCheckMethod);
  processTypeCheckCodeFragment();
}","public TypeCheckCodeFragmentAnalyzer(TypeCheckElimination typeCheckElimination,TypeDeclaration typeDeclaration,MethodDeclaration typeCheckMethod,List<InheritanceTree> inheritanceTreeList){
  this.typeCheckElimination=typeCheckElimination;
  this.typeDeclaration=typeDeclaration;
  this.typeCheckMethod=typeCheckMethod;
  this.fields=typeDeclaration.getFields();
  this.methods=typeDeclaration.getMethods();
  this.inheritanceTreeList=inheritanceTreeList;
  this.typeVariableCounterMap=new LinkedHashMap<SimpleName,Integer>();
  this.complexExpressionMap=new LinkedHashMap<Expression,IfStatementExpressionAnalyzer>();
  typeCheckElimination.setTypeCheckMethod(typeCheckMethod);
  processTypeCheckCodeFragment();
}"
12203,"private void processTypeCheckCodeFragment(){
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  ArrayList<Statement> firstBlockOfStatements=typeCheckStatements.get(0);
  Statement firstStatementOfBlock=firstBlockOfStatements.get(0);
  if (firstStatementOfBlock.getParent() instanceof SwitchStatement) {
    SwitchStatement switchStatement=(SwitchStatement)firstStatementOfBlock.getParent();
    Expression switchStatementExpression=switchStatement.getExpression();
    SimpleName switchStatementExpressionName=extractOperandName(switchStatementExpression);
    if (switchStatementExpressionName != null) {
      IBinding switchStatementExpressionNameBinding=switchStatementExpressionName.resolveBinding();
      if (switchStatementExpressionNameBinding.getKind() == IBinding.VARIABLE) {
        IVariableBinding switchStatementExpressionNameVariableBinding=(IVariableBinding)switchStatementExpressionNameBinding;
        for (        InheritanceTree tree : inheritanceTreeList) {
          DefaultMutableTreeNode root=tree.getRootNode();
          String rootClassName=(String)root.getUserObject();
          ITypeBinding variableTypeBinding=switchStatementExpressionNameVariableBinding.getType();
          if (rootClassName.equals(variableTypeBinding.getQualifiedName())) {
            typeCheckElimination.setExistingInheritanceTree(tree);
            break;
          }
        }
        if (switchStatementExpressionNameVariableBinding.isField()) {
          for (          FieldDeclaration field : fields) {
            List<VariableDeclarationFragment> fragments=field.fragments();
            for (            VariableDeclarationFragment fragment : fragments) {
              IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
              if (fragmentVariableBinding.isEqualTo(switchStatementExpressionNameVariableBinding)) {
                typeCheckElimination.setTypeField(fragment);
                for (                MethodDeclaration method : methods) {
                  SimpleName fieldInstruction=MethodDeclarationUtility.isSetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldSetterMethod(method);
                  }
                  fieldInstruction=MethodDeclarationUtility.isGetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldGetterMethod(method);
                  }
                }
                break;
              }
            }
          }
        }
 else {
          typeCheckElimination.setTypeLocalVariable(switchStatementExpressionName);
        }
      }
    }
  }
  Set<Expression> typeCheckExpressions=typeCheckElimination.getTypeCheckExpressions();
  for (  Expression typeCheckExpression : typeCheckExpressions) {
    if (typeCheckExpression.getParent() instanceof SwitchCase) {
      if (typeCheckExpression instanceof SimpleName) {
        SimpleName simpleName=(SimpleName)typeCheckExpression;
        IBinding binding=simpleName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
            typeCheckElimination.addStaticType(typeCheckExpression,simpleName);
          }
        }
      }
 else       if (typeCheckExpression instanceof QualifiedName) {
        QualifiedName qualifiedName=(QualifiedName)typeCheckExpression;
        IBinding binding=qualifiedName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
            typeCheckElimination.addStaticType(typeCheckExpression,qualifiedName.getName());
          }
        }
      }
 else       if (typeCheckExpression instanceof FieldAccess) {
        FieldAccess fieldAccess=(FieldAccess)typeCheckExpression;
        IVariableBinding variableBinding=fieldAccess.resolveFieldBinding();
        if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
          typeCheckElimination.addStaticType(typeCheckExpression,fieldAccess.getName());
        }
      }
    }
 else     if (typeCheckExpression instanceof InstanceofExpression) {
      InstanceofExpression instanceofExpression=(InstanceofExpression)typeCheckExpression;
      SimpleName operandName=extractOperandName(instanceofExpression.getLeftOperand());
      if (operandName != null) {
        SimpleName keySimpleName=containsKey(operandName);
        if (keySimpleName != null) {
          typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
        }
 else {
          typeVariableCounterMap.put(operandName,1);
        }
        typeCheckElimination.addSubclassType(typeCheckExpression,instanceofExpression.getRightOperand());
      }
    }
 else     if (typeCheckExpression instanceof InfixExpression) {
      InfixExpression infixExpression=(InfixExpression)typeCheckExpression;
      IfStatementExpressionAnalyzer analyzer=new IfStatementExpressionAnalyzer(infixExpression);
      for (      InfixExpression leafInfixExpression : analyzer.getInfixExpressionsWithEqualsOperator()) {
        Expression leftOperand=leafInfixExpression.getLeftOperand();
        Expression rightOperand=leafInfixExpression.getRightOperand();
        infixExpressionHandler(leftOperand,leafInfixExpression,analyzer);
        infixExpressionHandler(rightOperand,leafInfixExpression,analyzer);
      }
      for (      InstanceofExpression leafInstanceofExpression : analyzer.getInstanceofExpressions()) {
        SimpleName operandName=extractOperandName(leafInstanceofExpression.getLeftOperand());
        if (operandName != null) {
          SimpleName keySimpleName=containsKey(operandName);
          if (keySimpleName != null && analyzer.allParentNodesAreConditionalAndOperators()) {
            typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
          }
 else {
            typeVariableCounterMap.put(operandName,1);
          }
          typeCheckElimination.addRemainingIfStatementExpression(analyzer.getCompleteExpression(),analyzer.getRemainingExpression(leafInstanceofExpression));
          typeCheckElimination.addSubclassType(typeCheckExpression,leafInstanceofExpression.getRightOperand());
        }
      }
    }
  }
  for (  SimpleName typeVariable : typeVariableCounterMap.keySet()) {
    if (typeVariableCounterMap.get(typeVariable) == typeCheckExpressions.size()) {
      IBinding binding=typeVariable.resolveBinding();
      if (binding.getKind() == IBinding.VARIABLE) {
        IVariableBinding variableBinding=(IVariableBinding)binding;
        for (        InheritanceTree tree : inheritanceTreeList) {
          DefaultMutableTreeNode root=tree.getRootNode();
          String rootClassName=(String)root.getUserObject();
          ITypeBinding variableTypeBinding=variableBinding.getType();
          if (rootClassName.equals(variableTypeBinding.getQualifiedName())) {
            typeCheckElimination.setExistingInheritanceTree(tree);
            break;
          }
        }
        if (variableBinding.isField()) {
          for (          FieldDeclaration field : fields) {
            List<VariableDeclarationFragment> fragments=field.fragments();
            for (            VariableDeclarationFragment fragment : fragments) {
              IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
              if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                typeCheckElimination.setTypeField(fragment);
                for (                MethodDeclaration method : methods) {
                  SimpleName fieldInstruction=MethodDeclarationUtility.isSetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldSetterMethod(method);
                  }
                  fieldInstruction=MethodDeclarationUtility.isGetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldGetterMethod(method);
                  }
                }
                break;
              }
            }
          }
        }
 else {
          typeCheckElimination.setTypeLocalVariable(typeVariable);
        }
      }
    }
  }
}","private void processTypeCheckCodeFragment(){
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  ArrayList<Statement> firstBlockOfStatements=typeCheckStatements.get(0);
  Statement firstStatementOfBlock=firstBlockOfStatements.get(0);
  if (firstStatementOfBlock.getParent() instanceof SwitchStatement) {
    SwitchStatement switchStatement=(SwitchStatement)firstStatementOfBlock.getParent();
    Expression switchStatementExpression=switchStatement.getExpression();
    SimpleName switchStatementExpressionName=extractOperandName(switchStatementExpression);
    if (switchStatementExpressionName != null) {
      IBinding switchStatementExpressionNameBinding=switchStatementExpressionName.resolveBinding();
      if (switchStatementExpressionNameBinding.getKind() == IBinding.VARIABLE) {
        IVariableBinding switchStatementExpressionNameVariableBinding=(IVariableBinding)switchStatementExpressionNameBinding;
        for (        InheritanceTree tree : inheritanceTreeList) {
          DefaultMutableTreeNode root=tree.getRootNode();
          String rootClassName=(String)root.getUserObject();
          ITypeBinding variableTypeBinding=switchStatementExpressionNameVariableBinding.getType();
          if (rootClassName.equals(variableTypeBinding.getQualifiedName())) {
            typeCheckElimination.setExistingInheritanceTree(tree);
            break;
          }
        }
        if (switchStatementExpressionNameVariableBinding.isField()) {
          for (          FieldDeclaration field : fields) {
            List<VariableDeclarationFragment> fragments=field.fragments();
            for (            VariableDeclarationFragment fragment : fragments) {
              IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
              if (fragmentVariableBinding.isEqualTo(switchStatementExpressionNameVariableBinding)) {
                typeCheckElimination.setTypeField(fragment);
                for (                MethodDeclaration method : methods) {
                  SimpleName fieldInstruction=MethodDeclarationUtility.isSetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldSetterMethod(method);
                  }
                  fieldInstruction=MethodDeclarationUtility.isGetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldGetterMethod(method);
                  }
                }
                break;
              }
            }
          }
        }
 else {
          typeCheckElimination.setTypeLocalVariable(switchStatementExpressionName);
        }
      }
    }
  }
  Set<Expression> typeCheckExpressions=typeCheckElimination.getTypeCheckExpressions();
  for (  Expression typeCheckExpression : typeCheckExpressions) {
    if (typeCheckExpression.getParent() instanceof SwitchCase) {
      if (typeCheckExpression instanceof SimpleName) {
        SimpleName simpleName=(SimpleName)typeCheckExpression;
        IBinding binding=simpleName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
            typeCheckElimination.addStaticType(typeCheckExpression,simpleName);
          }
        }
      }
 else       if (typeCheckExpression instanceof QualifiedName) {
        QualifiedName qualifiedName=(QualifiedName)typeCheckExpression;
        IBinding binding=qualifiedName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
            typeCheckElimination.addStaticType(typeCheckExpression,qualifiedName.getName());
          }
        }
      }
 else       if (typeCheckExpression instanceof FieldAccess) {
        FieldAccess fieldAccess=(FieldAccess)typeCheckExpression;
        IVariableBinding variableBinding=fieldAccess.resolveFieldBinding();
        if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
          typeCheckElimination.addStaticType(typeCheckExpression,fieldAccess.getName());
        }
      }
    }
 else     if (typeCheckExpression instanceof InstanceofExpression) {
      InstanceofExpression instanceofExpression=(InstanceofExpression)typeCheckExpression;
      SimpleName operandName=extractOperandName(instanceofExpression.getLeftOperand());
      if (operandName != null) {
        SimpleName keySimpleName=containsKey(operandName);
        if (keySimpleName != null) {
          typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
        }
 else {
          typeVariableCounterMap.put(operandName,1);
        }
        typeCheckElimination.addSubclassType(typeCheckExpression,instanceofExpression.getRightOperand());
      }
    }
 else     if (typeCheckExpression instanceof InfixExpression) {
      InfixExpression infixExpression=(InfixExpression)typeCheckExpression;
      IfStatementExpressionAnalyzer analyzer=new IfStatementExpressionAnalyzer(infixExpression);
      for (      InfixExpression leafInfixExpression : analyzer.getInfixExpressionsWithEqualsOperator()) {
        Expression leftOperand=leafInfixExpression.getLeftOperand();
        Expression rightOperand=leafInfixExpression.getRightOperand();
        SimpleName leftOperandName=extractOperandName(leftOperand);
        SimpleName rightOperandName=extractOperandName(rightOperand);
        SimpleName typeVariableName=null;
        SimpleName staticFieldName=null;
        if (leftOperandName != null && rightOperandName != null) {
          IBinding leftOperandNameBinding=leftOperandName.resolveBinding();
          if (leftOperandNameBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding leftOperandNameVariableBinding=(IVariableBinding)leftOperandNameBinding;
            if (leftOperandNameVariableBinding.isField() && (leftOperandNameVariableBinding.getModifiers() & Modifier.STATIC) != 0)             staticFieldName=leftOperandName;
          }
          IBinding rightOperandNameBinding=rightOperandName.resolveBinding();
          if (rightOperandNameBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding rightOperandNameVariableBinding=(IVariableBinding)rightOperandNameBinding;
            if (rightOperandNameVariableBinding.isField() && (rightOperandNameVariableBinding.getModifiers() & Modifier.STATIC) != 0)             staticFieldName=rightOperandName;
          }
          if (staticFieldName != null && staticFieldName.equals(leftOperandName))           typeVariableName=rightOperandName;
 else           if (staticFieldName != null && staticFieldName.equals(rightOperandName))           typeVariableName=leftOperandName;
        }
        if (typeVariableName != null && staticFieldName != null) {
          SimpleName keySimpleName=containsKey(typeVariableName);
          if (keySimpleName != null) {
            typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
          }
 else {
            typeVariableCounterMap.put(typeVariableName,1);
          }
          if (analyzer.allParentNodesAreConditionalAndOperators()) {
            analyzer.putTypeVariableExpression(typeVariableName,leafInfixExpression);
            analyzer.putTypeVariableStaticField(typeVariableName,staticFieldName);
          }
        }
      }
      for (      InstanceofExpression leafInstanceofExpression : analyzer.getInstanceofExpressions()) {
        SimpleName operandName=extractOperandName(leafInstanceofExpression.getLeftOperand());
        if (operandName != null) {
          SimpleName keySimpleName=containsKey(operandName);
          if (keySimpleName != null) {
            typeVariableCounterMap.put(keySimpleName,typeVariableCounterMap.get(keySimpleName) + 1);
          }
 else {
            typeVariableCounterMap.put(operandName,1);
          }
          if (analyzer.allParentNodesAreConditionalAndOperators()) {
            analyzer.putTypeVariableExpression(operandName,leafInstanceofExpression);
            analyzer.putTypeVariableSubclass(operandName,leafInstanceofExpression.getRightOperand());
          }
        }
      }
      complexExpressionMap.put(typeCheckExpression,analyzer);
    }
  }
  for (  SimpleName typeVariable : typeVariableCounterMap.keySet()) {
    if (typeVariableCounterMap.get(typeVariable) == typeCheckExpressions.size()) {
      for (      Expression complexExpression : complexExpressionMap.keySet()) {
        IfStatementExpressionAnalyzer analyzer=complexExpressionMap.get(complexExpression);
        for (        SimpleName analyzerTypeVariable : analyzer.getTargetVariables()) {
          if (analyzerTypeVariable.resolveBinding().isEqualTo(typeVariable.resolveBinding())) {
            typeCheckElimination.addRemainingIfStatementExpression(analyzer.getCompleteExpression(),analyzer.getRemainingExpression(analyzer.getTypeVariableExpression(analyzerTypeVariable)));
            SimpleName staticField=analyzer.getTypeVariableStaticField(analyzerTypeVariable);
            if (staticField != null)             typeCheckElimination.addStaticType(analyzer.getCompleteExpression(),staticField);
            Type subclassType=analyzer.getTypeVariableSubclass(analyzerTypeVariable);
            if (subclassType != null)             typeCheckElimination.addSubclassType(analyzer.getCompleteExpression(),subclassType);
          }
        }
      }
      IBinding binding=typeVariable.resolveBinding();
      if (binding.getKind() == IBinding.VARIABLE) {
        IVariableBinding variableBinding=(IVariableBinding)binding;
        for (        InheritanceTree tree : inheritanceTreeList) {
          DefaultMutableTreeNode root=tree.getRootNode();
          String rootClassName=(String)root.getUserObject();
          ITypeBinding variableTypeBinding=variableBinding.getType();
          if (rootClassName.equals(variableTypeBinding.getQualifiedName())) {
            typeCheckElimination.setExistingInheritanceTree(tree);
            break;
          }
        }
        if (variableBinding.isField()) {
          for (          FieldDeclaration field : fields) {
            List<VariableDeclarationFragment> fragments=field.fragments();
            for (            VariableDeclarationFragment fragment : fragments) {
              IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
              if (fragmentVariableBinding.isEqualTo(variableBinding)) {
                typeCheckElimination.setTypeField(fragment);
                for (                MethodDeclaration method : methods) {
                  SimpleName fieldInstruction=MethodDeclarationUtility.isSetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldSetterMethod(method);
                  }
                  fieldInstruction=MethodDeclarationUtility.isGetter(method);
                  if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                    typeCheckElimination.setTypeFieldGetterMethod(method);
                  }
                }
                break;
              }
            }
          }
        }
 else {
          typeCheckElimination.setTypeLocalVariable(typeVariable);
        }
      }
    }
  }
}"
12204,"public List<String> getStaticFieldNames(){
  List<String> staticFieldNames=new ArrayList<String>();
  for (  SimpleName simpleName : staticFieldMap.values()) {
    staticFieldNames.add(simpleName.getIdentifier());
  }
  return staticFieldNames;
}","public List<String> getStaticFieldNames(){
  List<String> staticFieldNames=new ArrayList<String>();
  for (  Expression expression : typeCheckMap.keySet()) {
    SimpleName simpleName=staticFieldMap.get(expression);
    staticFieldNames.add(simpleName.getIdentifier());
  }
  return staticFieldNames;
}"
12205,"public List<SimpleName> getStaticFields(){
  return new ArrayList<SimpleName>(staticFieldMap.values());
}","public List<SimpleName> getStaticFields(){
  ArrayList<SimpleName> staticFields=new ArrayList<SimpleName>();
  for (  Expression expression : typeCheckMap.keySet()) {
    SimpleName simpleName=staticFieldMap.get(expression);
    staticFields.add(simpleName);
  }
  return staticFields;
}"
12206,"private void replaceTargetClassVariableNameWithThisExpressionInVariableDeclarationInitializers(MethodDeclaration newMethodDeclaration){
  StatementExtractor extractor=new StatementExtractor();
  List<Statement> variableDeclarations=extractor.getVariableDeclarations(newMethodDeclaration.getBody());
  for (  Statement declaration : variableDeclarations) {
    VariableDeclarationStatement variableDeclaration=(VariableDeclarationStatement)declaration;
    List<VariableDeclarationFragment> fragments=variableDeclaration.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      Expression initializer=fragment.getInitializer();
      if (initializer instanceof SimpleName) {
        SimpleName simpleNameInitializer=(SimpleName)initializer;
        if (simpleNameInitializer.getIdentifier().equals(targetClassVariableName)) {
          AST ast=newMethodDeclaration.getAST();
          targetRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,ast.newThisExpression(),null);
        }
      }
    }
  }
}","private void replaceTargetClassVariableNameWithThisExpressionInVariableDeclarationInitializers(MethodDeclaration newMethodDeclaration){
  StatementExtractor extractor=new StatementExtractor();
  List<Statement> variableDeclarations=extractor.getVariableDeclarations(newMethodDeclaration.getBody());
  for (  Statement declaration : variableDeclarations) {
    VariableDeclarationStatement variableDeclaration=(VariableDeclarationStatement)declaration;
    List<VariableDeclarationFragment> fragments=variableDeclaration.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      Expression initializer=fragment.getInitializer();
      if (initializer instanceof SimpleName) {
        SimpleName simpleNameInitializer=(SimpleName)initializer;
        if (simpleNameInitializer.getIdentifier().equals(targetClassVariableName)) {
          AST ast=newMethodDeclaration.getAST();
          targetRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,ast.newThisExpression(),null);
        }
      }
 else       if (initializer instanceof FieldAccess) {
        FieldAccess fieldAccess=(FieldAccess)initializer;
        SimpleName simpleNameInitializer=fieldAccess.getName();
        if (simpleNameInitializer.getIdentifier().equals(targetClassVariableName)) {
          AST ast=newMethodDeclaration.getAST();
          targetRewriter.set(fragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,ast.newThisExpression(),null);
        }
      }
    }
  }
}"
12207,"private void modifyMovedMethodInvocationInSourceClass(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<TypeDeclaration> sourceTypeDeclarationList=new ArrayList<TypeDeclaration>();
  sourceTypeDeclarationList.add(sourceTypeDeclaration);
  TypeDeclaration[] types=sourceTypeDeclaration.getTypes();
  for (  TypeDeclaration type : types) {
    sourceTypeDeclarationList.add(type);
  }
  for (  TypeDeclaration typeDeclaration : sourceTypeDeclarationList) {
    MethodDeclaration[] methodDeclarations=typeDeclaration.getMethods();
    for (    MethodDeclaration methodDeclaration : methodDeclarations) {
      Block methodBody=methodDeclaration.getBody();
      if (methodBody != null) {
        List<Statement> statements=methodBody.statements();
        for (        Statement statement : statements) {
          List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
          for (          Expression expression : methodInvocations) {
            if (expression instanceof MethodInvocation) {
              MethodInvocation methodInvocation=(MethodInvocation)expression;
              if (sourceMethod.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
                List<Expression> arguments=methodInvocation.arguments();
                boolean foundInArguments=false;
                for (                Expression argument : arguments) {
                  if (argument.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                    foundInArguments=true;
                    ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                    argumentRewrite.remove(argument,null);
                    sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,argument,null);
                    break;
                  }
                }
                boolean foundInFields=false;
                if (!foundInArguments) {
                  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                  for (                  FieldDeclaration fieldDeclaration : fieldDeclarations) {
                    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                        foundInFields=true;
                        sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                        break;
                      }
                    }
                  }
                }
                if (!foundInArguments && !foundInFields) {
                  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                  for (                  FieldDeclaration fieldDeclaration : fieldDeclarations) {
                    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass())) {
                        sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                        break;
                      }
                    }
                  }
                }
                ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                AST ast=methodInvocation.getAST();
                for (                String argument : additionalArgumentsAddedToMovedMethod) {
                  if (argument.equals(""String_Node_Str""))                   argumentRewrite.insertLast(ast.newThisExpression(),null);
 else                   argumentRewrite.insertLast(ast.newSimpleName(argument),null);
                }
              }
            }
          }
        }
      }
    }
  }
}","private void modifyMovedMethodInvocationInSourceClass(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<TypeDeclaration> sourceTypeDeclarationList=new ArrayList<TypeDeclaration>();
  sourceTypeDeclarationList.add(sourceTypeDeclaration);
  TypeDeclaration[] types=sourceTypeDeclaration.getTypes();
  for (  TypeDeclaration type : types) {
    sourceTypeDeclarationList.add(type);
  }
  for (  TypeDeclaration typeDeclaration : sourceTypeDeclarationList) {
    MethodDeclaration[] methodDeclarations=typeDeclaration.getMethods();
    for (    MethodDeclaration methodDeclaration : methodDeclarations) {
      Block methodBody=methodDeclaration.getBody();
      if (methodBody != null) {
        List<Statement> statements=methodBody.statements();
        for (        Statement statement : statements) {
          List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
          for (          Expression expression : methodInvocations) {
            if (expression instanceof MethodInvocation) {
              MethodInvocation methodInvocation=(MethodInvocation)expression;
              if (sourceMethod.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
                List<Expression> arguments=methodInvocation.arguments();
                boolean foundInArguments=false;
                for (                Expression argument : arguments) {
                  if (argument.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding()) || targetTypeDeclaration.resolveBinding().isEqualTo(argument.resolveTypeBinding().getSuperclass())) {
                    foundInArguments=true;
                    ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                    argumentRewrite.remove(argument,null);
                    sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,argument,null);
                    break;
                  }
                }
                boolean foundInFields=false;
                if (!foundInArguments) {
                  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                  for (                  FieldDeclaration fieldDeclaration : fieldDeclarations) {
                    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                        foundInFields=true;
                        sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                        break;
                      }
                    }
                  }
                }
                if (!foundInArguments && !foundInFields) {
                  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                  for (                  FieldDeclaration fieldDeclaration : fieldDeclarations) {
                    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass())) {
                        sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                        break;
                      }
                    }
                  }
                }
                ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                AST ast=methodInvocation.getAST();
                for (                String argument : additionalArgumentsAddedToMovedMethod) {
                  if (argument.equals(""String_Node_Str""))                   argumentRewrite.insertLast(ast.newThisExpression(),null);
 else                   argumentRewrite.insertLast(ast.newSimpleName(argument),null);
                }
              }
            }
          }
        }
      }
    }
  }
}"
12208,"private void replaceTargetClassVariableNameWithThisExpressionInInfixExpressions(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> infixExpressions=extractor.getInfixExpressions(newMethodDeclaration.getBody());
  for (  Expression expression : infixExpressions) {
    InfixExpression infixExpression=(InfixExpression)expression;
    if (infixExpression.getLeftOperand() instanceof SimpleName) {
      SimpleName leftOperand=(SimpleName)infixExpression.getLeftOperand();
      if (leftOperand.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(infixExpression,InfixExpression.LEFT_OPERAND_PROPERTY,ast.newThisExpression(),null);
      }
    }
    if (infixExpression.getRightOperand() instanceof SimpleName) {
      SimpleName rightOperand=(SimpleName)infixExpression.getRightOperand();
      if (rightOperand.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(infixExpression,InfixExpression.RIGHT_OPERAND_PROPERTY,ast.newThisExpression(),null);
      }
    }
  }
}","private void replaceTargetClassVariableNameWithThisExpressionInInfixExpressions(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> infixExpressions=extractor.getInfixExpressions(newMethodDeclaration.getBody());
  for (  Expression expression : infixExpressions) {
    InfixExpression infixExpression=(InfixExpression)expression;
    if (infixExpression.getLeftOperand() instanceof SimpleName) {
      SimpleName leftOperand=(SimpleName)infixExpression.getLeftOperand();
      if (leftOperand.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(infixExpression,InfixExpression.LEFT_OPERAND_PROPERTY,ast.newThisExpression(),null);
      }
    }
 else     if (infixExpression.getLeftOperand() instanceof FieldAccess) {
      FieldAccess fieldAccess=(FieldAccess)infixExpression.getLeftOperand();
      SimpleName leftOperand=fieldAccess.getName();
      if (leftOperand.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(infixExpression,InfixExpression.LEFT_OPERAND_PROPERTY,ast.newThisExpression(),null);
      }
    }
    if (infixExpression.getRightOperand() instanceof SimpleName) {
      SimpleName rightOperand=(SimpleName)infixExpression.getRightOperand();
      if (rightOperand.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(infixExpression,InfixExpression.RIGHT_OPERAND_PROPERTY,ast.newThisExpression(),null);
      }
    }
 else     if (infixExpression.getRightOperand() instanceof FieldAccess) {
      FieldAccess fieldAccess=(FieldAccess)infixExpression.getRightOperand();
      SimpleName rightOperand=fieldAccess.getName();
      if (rightOperand.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(infixExpression,InfixExpression.RIGHT_OPERAND_PROPERTY,ast.newThisExpression(),null);
      }
    }
  }
}"
12209,"private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
      targetClassVariableName=parameter.getName().getIdentifier();
      parametersRewrite.remove(newMethodParameters.get(i),null);
      break;
    }
    i++;
  }
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newMethodDeclaration.getBody());
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  modifySourceStaticMethodInvocationsInTargetClass(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInVariableDeclarationInitializers(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInfixExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInCastExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInstanceofExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInAssignments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInVariableDeclarationInitializers(newMethodDeclaration);
  ListRewrite targetClassBodyRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  targetClassBodyRewrite.insertLast(newMethodDeclaration,null);
}","private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
      targetClassVariableName=parameter.getName().getIdentifier();
      parametersRewrite.remove(newMethodParameters.get(i),null);
      break;
    }
    i++;
  }
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newMethodDeclaration.getBody());
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  modifySourceStaticMethodInvocationsInTargetClass(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInClassInstanceCreationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInVariableDeclarationInitializers(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInfixExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInCastExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInstanceofExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInAssignments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInVariableDeclarationInitializers(newMethodDeclaration);
  ListRewrite targetClassBodyRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  targetClassBodyRewrite.insertLast(newMethodDeclaration,null);
}"
12210,"private void replaceTargetClassVariableNameWithThisExpressionInAssignments(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> assignments=extractor.getAssignments(newMethodDeclaration.getBody());
  for (  Expression expression : assignments) {
    Assignment assignment=(Assignment)expression;
    if (assignment.getLeftHandSide() instanceof SimpleName) {
      SimpleName leftHandSide=(SimpleName)assignment.getLeftHandSide();
      if (leftHandSide.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,ast.newThisExpression(),null);
      }
    }
    if (assignment.getRightHandSide() instanceof SimpleName) {
      SimpleName rightHandSide=(SimpleName)assignment.getRightHandSide();
      if (rightHandSide.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,ast.newThisExpression(),null);
      }
    }
  }
}","private void replaceTargetClassVariableNameWithThisExpressionInAssignments(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> assignments=extractor.getAssignments(newMethodDeclaration.getBody());
  for (  Expression expression : assignments) {
    Assignment assignment=(Assignment)expression;
    if (assignment.getLeftHandSide() instanceof SimpleName) {
      SimpleName leftHandSide=(SimpleName)assignment.getLeftHandSide();
      if (leftHandSide.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,ast.newThisExpression(),null);
      }
    }
 else     if (assignment.getLeftHandSide() instanceof FieldAccess) {
      FieldAccess fieldAccess=(FieldAccess)assignment.getLeftHandSide();
      SimpleName leftHandSide=fieldAccess.getName();
      if (leftHandSide.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,ast.newThisExpression(),null);
      }
    }
    if (assignment.getRightHandSide() instanceof SimpleName) {
      SimpleName rightHandSide=(SimpleName)assignment.getRightHandSide();
      if (rightHandSide.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,ast.newThisExpression(),null);
      }
    }
 else     if (assignment.getRightHandSide() instanceof FieldAccess) {
      FieldAccess fieldAccess=(FieldAccess)assignment.getRightHandSide();
      SimpleName rightHandSide=fieldAccess.getName();
      if (rightHandSide.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,ast.newThisExpression(),null);
      }
    }
  }
}"
12211,"private void replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression invocation : newMethodInvocations) {
    if (invocation instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)invocation;
      List<Expression> arguments=methodInvocation.arguments();
      for (      Expression argument : arguments) {
        if (argument instanceof SimpleName) {
          SimpleName simpleNameArgument=(SimpleName)argument;
          if (simpleNameArgument.getIdentifier().equals(targetClassVariableName)) {
            ListRewrite argumentRewrite=targetRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            MethodInvocation sourceMethodInvocation=(MethodInvocation)sourceMethodInvocations.get(i);
            if (sourceMethod.resolveBinding().isEqualTo(sourceMethodInvocation.resolveMethodBinding())) {
              argumentRewrite.remove(argument,null);
            }
 else {
              AST ast=newMethodDeclaration.getAST();
              argumentRewrite.replace(argument,ast.newThisExpression(),null);
            }
          }
        }
      }
    }
    i++;
  }
}","private void replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression invocation : newMethodInvocations) {
    if (invocation instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)invocation;
      List<Expression> arguments=methodInvocation.arguments();
      for (      Expression argument : arguments) {
        if (argument instanceof SimpleName) {
          SimpleName simpleNameArgument=(SimpleName)argument;
          if (simpleNameArgument.getIdentifier().equals(targetClassVariableName)) {
            ListRewrite argumentRewrite=targetRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            MethodInvocation sourceMethodInvocation=(MethodInvocation)sourceMethodInvocations.get(i);
            if (sourceMethod.resolveBinding().isEqualTo(sourceMethodInvocation.resolveMethodBinding())) {
              argumentRewrite.remove(argument,null);
            }
 else {
              AST ast=newMethodDeclaration.getAST();
              argumentRewrite.replace(argument,ast.newThisExpression(),null);
            }
          }
        }
 else         if (argument instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)argument;
          SimpleName simpleNameArgument=fieldAccess.getName();
          if (simpleNameArgument.getIdentifier().equals(targetClassVariableName)) {
            ListRewrite argumentRewrite=targetRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            MethodInvocation sourceMethodInvocation=(MethodInvocation)sourceMethodInvocations.get(i);
            if (sourceMethod.resolveBinding().isEqualTo(sourceMethodInvocation.resolveMethodBinding())) {
              argumentRewrite.remove(argument,null);
            }
 else {
              AST ast=newMethodDeclaration.getAST();
              argumentRewrite.replace(argument,ast.newThisExpression(),null);
            }
          }
        }
      }
    }
    i++;
  }
}"
12212,"private void replaceTargetClassVariableNameWithThisExpressionInCastExpressions(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> castExpressions=extractor.getCastExpressions(newMethodDeclaration.getBody());
  for (  Expression expression : castExpressions) {
    CastExpression castExpression=(CastExpression)expression;
    if (castExpression.getExpression() instanceof SimpleName) {
      SimpleName simpleName=(SimpleName)castExpression.getExpression();
      if (simpleName.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,ast.newThisExpression(),null);
      }
    }
  }
}","private void replaceTargetClassVariableNameWithThisExpressionInCastExpressions(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> castExpressions=extractor.getCastExpressions(newMethodDeclaration.getBody());
  for (  Expression expression : castExpressions) {
    CastExpression castExpression=(CastExpression)expression;
    if (castExpression.getExpression() instanceof SimpleName) {
      SimpleName simpleName=(SimpleName)castExpression.getExpression();
      if (simpleName.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,ast.newThisExpression(),null);
      }
    }
 else     if (castExpression.getExpression() instanceof FieldAccess) {
      FieldAccess fieldAccess=(FieldAccess)castExpression.getExpression();
      SimpleName simpleName=fieldAccess.getName();
      if (simpleName.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(castExpression,CastExpression.EXPRESSION_PROPERTY,ast.newThisExpression(),null);
      }
    }
  }
}"
12213,"private void replaceTargetClassVariableNameWithThisExpressionInInstanceofExpressions(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> instanceofExpressions=extractor.getInstanceofExpressions(newMethodDeclaration.getBody());
  for (  Expression expression : instanceofExpressions) {
    InstanceofExpression instanceofExpression=(InstanceofExpression)expression;
    if (instanceofExpression.getLeftOperand() instanceof SimpleName) {
      SimpleName simpleName=(SimpleName)instanceofExpression.getLeftOperand();
      if (simpleName.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(instanceofExpression,InstanceofExpression.LEFT_OPERAND_PROPERTY,ast.newThisExpression(),null);
      }
    }
  }
}","private void replaceTargetClassVariableNameWithThisExpressionInInstanceofExpressions(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> instanceofExpressions=extractor.getInstanceofExpressions(newMethodDeclaration.getBody());
  for (  Expression expression : instanceofExpressions) {
    InstanceofExpression instanceofExpression=(InstanceofExpression)expression;
    if (instanceofExpression.getLeftOperand() instanceof SimpleName) {
      SimpleName simpleName=(SimpleName)instanceofExpression.getLeftOperand();
      if (simpleName.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(instanceofExpression,InstanceofExpression.LEFT_OPERAND_PROPERTY,ast.newThisExpression(),null);
      }
    }
 else     if (instanceofExpression.getLeftOperand() instanceof FieldAccess) {
      FieldAccess fieldAccess=(FieldAccess)instanceofExpression.getLeftOperand();
      SimpleName simpleName=fieldAccess.getName();
      if (simpleName.getIdentifier().equals(targetClassVariableName)) {
        AST ast=newMethodDeclaration.getAST();
        targetRewriter.set(instanceofExpression,InstanceofExpression.LEFT_OPERAND_PROPERTY,ast.newThisExpression(),null);
      }
    }
  }
}"
12214,"public List<TypeCheckElimination> generateTypeCheckEliminations(){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> switchStatements=statementExtractor.getSwitchStatements(compositeStatement.getStatement());
  for (  Statement statement : switchStatements) {
    SwitchStatement switchStatement=(SwitchStatement)statement;
    TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
    typeCheckElimination.setTypeCheckCodeFragment(switchStatement);
    List<Statement> statements=switchStatement.statements();
    Expression switchCaseExpression=null;
    boolean isDefaultCase=false;
    Map<Expression,Integer> switchCaseExpressionStatementCounterMap=new LinkedHashMap<Expression,Integer>();
    for (    Statement statement2 : statements) {
      if (statement2 instanceof SwitchCase) {
        SwitchCase switchCase=(SwitchCase)statement2;
        switchCaseExpression=switchCase.getExpression();
        isDefaultCase=switchCase.isDefault();
        if (!isDefaultCase)         switchCaseExpressionStatementCounterMap.put(switchCaseExpression,0);
      }
 else {
        if (!isDefaultCase) {
          if (!(statement2 instanceof BreakStatement)) {
            switchCaseExpressionStatementCounterMap.put(switchCaseExpression,switchCaseExpressionStatementCounterMap.get(switchCaseExpression) + 1);
            typeCheckElimination.addTypeCheck(switchCaseExpression,statement2);
          }
 else {
            switchCaseExpressionStatementCounterMap.clear();
          }
        }
 else {
          if (!(statement2 instanceof BreakStatement)) {
            for (            Expression expression : switchCaseExpressionStatementCounterMap.keySet()) {
              if (switchCaseExpressionStatementCounterMap.get(expression) == 0) {
                typeCheckElimination.addTypeCheck(expression,statement2);
              }
            }
            typeCheckElimination.addDefaultCaseStatement(statement2);
          }
        }
      }
    }
    typeCheckEliminations.add(typeCheckElimination);
  }
  List<Statement> ifStatements=statementExtractor.getIfStatements(compositeStatement.getStatement());
  TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
  int i=0;
  for (  Statement statement : ifStatements) {
    IfStatement ifStatement=(IfStatement)statement;
    Expression ifExpression=ifStatement.getExpression();
    Statement thenStatement=ifStatement.getThenStatement();
    if (thenStatement instanceof Block) {
      Block block=(Block)thenStatement;
      List<Statement> statements=block.statements();
      for (      Statement statement2 : statements) {
        typeCheckElimination.addTypeCheck(ifExpression,statement2);
      }
    }
 else {
      typeCheckElimination.addTypeCheck(ifExpression,thenStatement);
    }
    Statement elseStatement=ifStatement.getElseStatement();
    if (elseStatement != null) {
      if (elseStatement instanceof Block) {
        Block block=(Block)elseStatement;
        List<Statement> statements=block.statements();
        for (        Statement statement2 : statements) {
          typeCheckElimination.addDefaultCaseStatement(statement2);
        }
      }
 else       if (!(elseStatement instanceof IfStatement)) {
        typeCheckElimination.addDefaultCaseStatement(elseStatement);
      }
    }
    if (ifStatements.size() - 1 > i) {
      IfStatement nextIfStatement=(IfStatement)ifStatements.get(i + 1);
      if (!ifStatement.getParent().equals(nextIfStatement)) {
        typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
        typeCheckEliminations.add(typeCheckElimination);
        typeCheckElimination=new TypeCheckElimination();
      }
    }
 else {
      typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
      typeCheckEliminations.add(typeCheckElimination);
    }
    i++;
  }
  return typeCheckEliminations;
}","public List<TypeCheckElimination> generateTypeCheckEliminations(){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> switchStatements=statementExtractor.getSwitchStatements(compositeStatement.getStatement());
  for (  Statement statement : switchStatements) {
    SwitchStatement switchStatement=(SwitchStatement)statement;
    TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
    typeCheckElimination.setTypeCheckCodeFragment(switchStatement);
    List<Statement> statements=switchStatement.statements();
    Expression switchCaseExpression=null;
    boolean isDefaultCase=false;
    Set<Expression> switchCaseExpressions=new LinkedHashSet<Expression>();
    for (    Statement statement2 : statements) {
      if (statement2 instanceof SwitchCase) {
        SwitchCase switchCase=(SwitchCase)statement2;
        switchCaseExpression=switchCase.getExpression();
        isDefaultCase=switchCase.isDefault();
        if (!isDefaultCase)         switchCaseExpressions.add(switchCaseExpression);
      }
 else {
        if (!(statement2 instanceof BreakStatement)) {
          for (          Expression expression : switchCaseExpressions) {
            typeCheckElimination.addTypeCheck(expression,statement2);
          }
          if (!isDefaultCase) {
            typeCheckElimination.addDefaultCaseStatement(statement2);
          }
        }
        List<Statement> branchingStatements=statementExtractor.getBranchingStatements(statement2);
        if (statement2 instanceof BreakStatement || statement2 instanceof ReturnStatement || branchingStatements.size() > 0) {
          switchCaseExpressions.clear();
        }
      }
    }
    typeCheckEliminations.add(typeCheckElimination);
  }
  List<Statement> ifStatements=statementExtractor.getIfStatements(compositeStatement.getStatement());
  TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
  int i=0;
  for (  Statement statement : ifStatements) {
    IfStatement ifStatement=(IfStatement)statement;
    Expression ifExpression=ifStatement.getExpression();
    Statement thenStatement=ifStatement.getThenStatement();
    if (thenStatement instanceof Block) {
      Block block=(Block)thenStatement;
      List<Statement> statements=block.statements();
      for (      Statement statement2 : statements) {
        typeCheckElimination.addTypeCheck(ifExpression,statement2);
      }
    }
 else {
      typeCheckElimination.addTypeCheck(ifExpression,thenStatement);
    }
    Statement elseStatement=ifStatement.getElseStatement();
    if (elseStatement != null) {
      if (elseStatement instanceof Block) {
        Block block=(Block)elseStatement;
        List<Statement> statements=block.statements();
        for (        Statement statement2 : statements) {
          typeCheckElimination.addDefaultCaseStatement(statement2);
        }
      }
 else       if (!(elseStatement instanceof IfStatement)) {
        typeCheckElimination.addDefaultCaseStatement(elseStatement);
      }
    }
    if (ifStatements.size() - 1 > i) {
      IfStatement nextIfStatement=(IfStatement)ifStatements.get(i + 1);
      if (!ifStatement.getParent().equals(nextIfStatement)) {
        typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
        typeCheckEliminations.add(typeCheckElimination);
        typeCheckElimination=new TypeCheckElimination();
      }
    }
 else {
      typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
      typeCheckEliminations.add(typeCheckElimination);
    }
    i++;
  }
  return typeCheckEliminations;
}"
12215,"public boolean leaveDelegate(){
  List<ClassObject> excludedClasses=new ArrayList<ClassObject>();
  excludedClasses.add(getSourceClass().getClassObject());
  excludedClasses.add(getTargetClass().getClassObject());
  return system.getSystemObject().containsMethodInvocation(getSourceMethod().getMethodObject().generateMethodInvocation(),excludedClasses);
}","public boolean leaveDelegate(){
  return system.getSystemObject().containsMethodInvocation(getSourceMethod().getMethodObject().generateMethodInvocation(),getSourceClass().getClassObject());
}"
12216,"public void applySourceFirst(){
  if (!sourceCompilationUnit.equals(targetCompilationUnit))   addRequiredTargetImportDeclarations();
  createMovedMethod();
  moveAdditionalMethods();
  modifyMovedMethodInvocationInTargetClass();
  if (leaveDelegate) {
    addDelegationInSourceMethod();
  }
 else {
    removeSourceMethod();
  }
  modifyMovedMethodInvocationInSourceClass();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit undoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  ITextFileBuffer targetTextFileBuffer=bufferManager.getTextFileBuffer(targetFile.getFullPath(),LocationKind.IFILE);
  IDocument targetDocument=targetTextFileBuffer.getDocument();
  TextEdit targetEdit=targetRewriter.rewriteAST(targetDocument,null);
  try {
    UndoEdit undoEdit=targetEdit.apply(targetDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(targetFile,targetDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","public void applySourceFirst(){
  if (!sourceCompilationUnit.equals(targetCompilationUnit))   addRequiredTargetImportDeclarations();
  createMovedMethod();
  moveAdditionalMethods();
  if (leaveDelegate) {
    addDelegationInSourceMethod();
  }
 else {
    removeSourceMethod();
  }
  modifyMovedMethodInvocationInSourceClass();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit undoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  ITextFileBuffer targetTextFileBuffer=bufferManager.getTextFileBuffer(targetFile.getFullPath(),LocationKind.IFILE);
  IDocument targetDocument=targetTextFileBuffer.getDocument();
  TextEdit targetEdit=targetRewriter.rewriteAST(targetDocument,null);
  try {
    UndoEdit undoEdit=targetEdit.apply(targetDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(targetFile,targetDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12217,"public void applyTargetFirst(){
  if (!sourceCompilationUnit.equals(targetCompilationUnit))   addRequiredTargetImportDeclarations();
  createMovedMethod();
  moveAdditionalMethods();
  modifyMovedMethodInvocationInTargetClass();
  if (leaveDelegate) {
    addDelegationInSourceMethod();
  }
 else {
    removeSourceMethod();
  }
  modifyMovedMethodInvocationInSourceClass();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer targetTextFileBuffer=bufferManager.getTextFileBuffer(targetFile.getFullPath(),LocationKind.IFILE);
  IDocument targetDocument=targetTextFileBuffer.getDocument();
  TextEdit targetEdit=targetRewriter.rewriteAST(targetDocument,null);
  try {
    UndoEdit undoEdit=targetEdit.apply(targetDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(targetFile,targetDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit undoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","public void applyTargetFirst(){
  if (!sourceCompilationUnit.equals(targetCompilationUnit))   addRequiredTargetImportDeclarations();
  createMovedMethod();
  moveAdditionalMethods();
  if (leaveDelegate) {
    addDelegationInSourceMethod();
  }
 else {
    removeSourceMethod();
  }
  modifyMovedMethodInvocationInSourceClass();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer targetTextFileBuffer=bufferManager.getTextFileBuffer(targetFile.getFullPath(),LocationKind.IFILE);
  IDocument targetDocument=targetTextFileBuffer.getDocument();
  TextEdit targetEdit=targetRewriter.rewriteAST(targetDocument,null);
  try {
    UndoEdit undoEdit=targetEdit.apply(targetDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(targetFile,targetDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit undoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12218,"public void processTypeCheckCodeFragmentBranches(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<ArrayList<Statement>> allTypeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  if (!typeCheckElimination.getDefaultCaseStatements().isEmpty()) {
    allTypeCheckStatements.add(typeCheckElimination.getDefaultCaseStatements());
  }
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment=statementExtractor.getVariableDeclarations(typeCheckMethod.getBody());
  for (  ArrayList<Statement> typeCheckStatementList : allTypeCheckStatements) {
    for (    Statement statement : typeCheckStatementList) {
      variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment.removeAll(statementExtractor.getVariableDeclarations(statement));
    }
  }
  for (  ArrayList<Statement> typeCheckStatementList : allTypeCheckStatements) {
    for (    Statement statement : typeCheckStatementList) {
      List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
      for (      Expression expression : methodInvocations) {
        if (expression instanceof MethodInvocation) {
          MethodInvocation methodInvocation=(MethodInvocation)expression;
          IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
          if (methodBinding.getDeclaringClass().isEqualTo(typeDeclaration.resolveBinding())) {
            for (            MethodDeclaration method : methods) {
              if (method.resolveBinding().isEqualTo(methodBinding)) {
                typeCheckElimination.addAccessedMethod(method);
              }
            }
          }
        }
      }
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(statement);
      for (      Expression variableInstruction : variableInstructions) {
        SimpleName simpleName=(SimpleName)variableInstruction;
        IBinding variableInstructionBinding=simpleName.resolveBinding();
        if (variableInstructionBinding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableInstructionVariableBinding=(IVariableBinding)variableInstructionBinding;
          if (variableInstructionVariableBinding.isField()) {
            if (variableInstructionVariableBinding.getDeclaringClass() != null && variableInstructionVariableBinding.getDeclaringClass().isEqualTo(typeDeclaration.resolveBinding())) {
              for (              FieldDeclaration field : fields) {
                List<VariableDeclarationFragment> fragments=field.fragments();
                for (                VariableDeclarationFragment fragment : fragments) {
                  IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                  if (fragmentVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                    Expression parentExpression=null;
                    if (simpleName.getParent() instanceof QualifiedName) {
                      parentExpression=(QualifiedName)simpleName.getParent();
                    }
 else                     if (simpleName.getParent() instanceof FieldAccess) {
                      parentExpression=(FieldAccess)simpleName.getParent();
                    }
 else {
                      parentExpression=simpleName;
                    }
                    boolean isLeftHandOfAssignment=false;
                    if (parentExpression.getParent() instanceof Assignment) {
                      Assignment assignment=(Assignment)parentExpression.getParent();
                      Expression leftHandSide=assignment.getLeftHandSide();
                      SimpleName leftHandSideName=null;
                      if (leftHandSide instanceof SimpleName) {
                        leftHandSideName=(SimpleName)leftHandSide;
                      }
 else                       if (leftHandSide instanceof QualifiedName) {
                        QualifiedName leftHandSideQualifiedName=(QualifiedName)leftHandSide;
                        leftHandSideName=leftHandSideQualifiedName.getName();
                      }
 else                       if (leftHandSide instanceof FieldAccess) {
                        FieldAccess leftHandSideFieldAccess=(FieldAccess)leftHandSide;
                        leftHandSideName=leftHandSideFieldAccess.getName();
                      }
                      if (leftHandSideName != null && leftHandSideName.equals(simpleName)) {
                        isLeftHandOfAssignment=true;
                        typeCheckElimination.addAssignedField(fragment);
                      }
                    }
                    if (!isLeftHandOfAssignment)                     typeCheckElimination.addAccessedField(fragment);
                  }
                }
              }
            }
          }
 else           if (variableInstructionVariableBinding.isParameter()) {
            List<SingleVariableDeclaration> parameters=typeCheckMethod.parameters();
            for (            SingleVariableDeclaration parameter : parameters) {
              IVariableBinding parameterVariableBinding=parameter.resolveBinding();
              if (parameterVariableBinding.isEqualTo(variableInstructionVariableBinding))               typeCheckElimination.addAccessedParameter(parameter);
            }
          }
 else {
            for (            Statement vDStatement : variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment) {
              VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
              List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
              for (              VariableDeclarationFragment fragment : fragments) {
                IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                if (fragmentVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                  typeCheckElimination.addAccessedLocalVariable(fragment);
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
}","public void processTypeCheckCodeFragmentBranches(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<ArrayList<Statement>> allTypeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  if (!typeCheckElimination.getDefaultCaseStatements().isEmpty()) {
    allTypeCheckStatements.add(typeCheckElimination.getDefaultCaseStatements());
  }
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment=statementExtractor.getVariableDeclarations(typeCheckMethod.getBody());
  for (  ArrayList<Statement> typeCheckStatementList : allTypeCheckStatements) {
    for (    Statement statement : typeCheckStatementList) {
      variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment.removeAll(statementExtractor.getVariableDeclarations(statement));
    }
  }
  for (  ArrayList<Statement> typeCheckStatementList : allTypeCheckStatements) {
    for (    Statement statement : typeCheckStatementList) {
      List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
      for (      Expression expression : methodInvocations) {
        if (expression instanceof MethodInvocation) {
          MethodInvocation methodInvocation=(MethodInvocation)expression;
          IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
          if (methodBinding.getDeclaringClass().isEqualTo(typeDeclaration.resolveBinding())) {
            for (            MethodDeclaration method : methods) {
              if (method.resolveBinding().isEqualTo(methodBinding)) {
                typeCheckElimination.addAccessedMethod(method);
              }
            }
          }
 else {
            ITypeBinding superclassTypeBinding=typeDeclaration.resolveBinding().getSuperclass();
            while (superclassTypeBinding != null && !superclassTypeBinding.isEqualTo(methodBinding.getDeclaringClass())) {
              superclassTypeBinding=superclassTypeBinding.getSuperclass();
            }
            if (methodBinding.getDeclaringClass().isEqualTo(superclassTypeBinding))             typeCheckElimination.addSuperAccessedMethod(methodBinding);
          }
        }
      }
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(statement);
      for (      Expression variableInstruction : variableInstructions) {
        SimpleName simpleName=(SimpleName)variableInstruction;
        IBinding variableInstructionBinding=simpleName.resolveBinding();
        if (variableInstructionBinding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableInstructionVariableBinding=(IVariableBinding)variableInstructionBinding;
          if (variableInstructionVariableBinding.isField()) {
            if (variableInstructionVariableBinding.getDeclaringClass() != null && variableInstructionVariableBinding.getDeclaringClass().isEqualTo(typeDeclaration.resolveBinding())) {
              for (              FieldDeclaration field : fields) {
                List<VariableDeclarationFragment> fragments=field.fragments();
                for (                VariableDeclarationFragment fragment : fragments) {
                  IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                  if (fragmentVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                    Expression parentExpression=null;
                    if (simpleName.getParent() instanceof QualifiedName) {
                      parentExpression=(QualifiedName)simpleName.getParent();
                    }
 else                     if (simpleName.getParent() instanceof FieldAccess) {
                      parentExpression=(FieldAccess)simpleName.getParent();
                    }
 else {
                      parentExpression=simpleName;
                    }
                    boolean isLeftHandOfAssignment=false;
                    if (parentExpression.getParent() instanceof Assignment) {
                      Assignment assignment=(Assignment)parentExpression.getParent();
                      Expression leftHandSide=assignment.getLeftHandSide();
                      SimpleName leftHandSideName=null;
                      if (leftHandSide instanceof SimpleName) {
                        leftHandSideName=(SimpleName)leftHandSide;
                      }
 else                       if (leftHandSide instanceof QualifiedName) {
                        QualifiedName leftHandSideQualifiedName=(QualifiedName)leftHandSide;
                        leftHandSideName=leftHandSideQualifiedName.getName();
                      }
 else                       if (leftHandSide instanceof FieldAccess) {
                        FieldAccess leftHandSideFieldAccess=(FieldAccess)leftHandSide;
                        leftHandSideName=leftHandSideFieldAccess.getName();
                      }
                      if (leftHandSideName != null && leftHandSideName.equals(simpleName)) {
                        isLeftHandOfAssignment=true;
                        typeCheckElimination.addAssignedField(fragment);
                      }
                    }
                    if (!isLeftHandOfAssignment)                     typeCheckElimination.addAccessedField(fragment);
                  }
                }
              }
            }
          }
 else           if (variableInstructionVariableBinding.isParameter()) {
            List<SingleVariableDeclaration> parameters=typeCheckMethod.parameters();
            for (            SingleVariableDeclaration parameter : parameters) {
              IVariableBinding parameterVariableBinding=parameter.resolveBinding();
              if (parameterVariableBinding.isEqualTo(variableInstructionVariableBinding))               typeCheckElimination.addAccessedParameter(parameter);
            }
          }
 else {
            for (            Statement vDStatement : variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment) {
              VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)vDStatement;
              List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
              for (              VariableDeclarationFragment fragment : fragments) {
                IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
                if (fragmentVariableBinding.isEqualTo(variableInstructionVariableBinding)) {
                  typeCheckElimination.addAccessedLocalVariable(fragment);
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
  processRemainingIfStatementExpressions(variableDeclarationStatementsInsideTypeCheckMethodApartFromTypeCheckCodeFragment);
}"
12219,"private void addRequiredTargetImportDeclarations(){
  List<ITypeBinding> typeBindings=new ArrayList<ITypeBinding>();
  Type returnType=sourceMethod.getReturnType2();
  ITypeBinding returnTypeBinding=returnType.resolveBinding();
  if (!typeBindings.contains(returnTypeBinding))   typeBindings.add(returnTypeBinding);
  List<SingleVariableDeclaration> parameters=sourceMethod.parameters();
  for (  SingleVariableDeclaration parameter : parameters) {
    Type parameterType=parameter.getType();
    ITypeBinding parameterTypeBinding=parameterType.resolveBinding();
    if (!typeBindings.contains(parameterTypeBinding))     typeBindings.add(parameterTypeBinding);
  }
  List<Name> thrownExceptions=sourceMethod.thrownExceptions();
  for (  Name name : thrownExceptions) {
    IBinding binding=name.resolveBinding();
    if (binding.getKind() == IBinding.TYPE) {
      ITypeBinding typeBinding=(ITypeBinding)binding;
      if (!typeBindings.contains(typeBinding))       typeBindings.add(typeBinding);
    }
  }
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(sourceMethod.getBody());
  for (  Expression variableInstruction : variableInstructions) {
    SimpleName simpleName=(SimpleName)variableInstruction;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      ITypeBinding variableTypeBinding=variableBinding.getType();
      if (!typeBindings.contains(variableTypeBinding))       typeBindings.add(variableTypeBinding);
      ITypeBinding declaringClassTypeBinding=variableBinding.getDeclaringClass();
      if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))       typeBindings.add(declaringClassTypeBinding);
    }
  }
  List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(sourceMethod.getBody());
  for (  Expression expression : methodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      if (!additionalMethodsToBeMoved.keySet().contains(methodInvocation)) {
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        ITypeBinding declaringClassTypeBinding=methodBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
      }
    }
  }
  List<Expression> classInstanceCreations=expressionExtractor.getClassInstanceCreations(sourceMethod.getBody());
  for (  Expression expression : classInstanceCreations) {
    ClassInstanceCreation classInstanceCreation=(ClassInstanceCreation)expression;
    Type classInstanceCreationType=classInstanceCreation.getType();
    ITypeBinding classInstanceCreationTypeBinding=classInstanceCreationType.resolveBinding();
    if (!typeBindings.contains(classInstanceCreationTypeBinding))     typeBindings.add(classInstanceCreationTypeBinding);
  }
  List<Expression> typeLiterals=expressionExtractor.getTypeLiterals(sourceMethod.getBody());
  for (  Expression expression : typeLiterals) {
    TypeLiteral typeLiteral=(TypeLiteral)expression;
    Type typeLiteralType=typeLiteral.getType();
    ITypeBinding typeLiteralTypeBinding=typeLiteralType.resolveBinding();
    if (!typeBindings.contains(typeLiteralTypeBinding))     typeBindings.add(typeLiteralTypeBinding);
  }
  List<Expression> castExpressions=expressionExtractor.getCastExpressions(sourceMethod.getBody());
  for (  Expression expression : castExpressions) {
    CastExpression castExpression=(CastExpression)expression;
    Type castExpressionType=castExpression.getType();
    ITypeBinding typeLiteralTypeBinding=castExpressionType.resolveBinding();
    if (!typeBindings.contains(typeLiteralTypeBinding))     typeBindings.add(typeLiteralTypeBinding);
  }
  getSimpleTypeBindings(typeBindings);
  for (  ITypeBinding typeBinding : requiredTargetImportDeclarationSet)   addImportDeclaration(typeBinding);
}","private void addRequiredTargetImportDeclarations(){
  List<ITypeBinding> typeBindings=new ArrayList<ITypeBinding>();
  Type returnType=sourceMethod.getReturnType2();
  ITypeBinding returnTypeBinding=returnType.resolveBinding();
  if (!typeBindings.contains(returnTypeBinding))   typeBindings.add(returnTypeBinding);
  List<SingleVariableDeclaration> parameters=sourceMethod.parameters();
  for (  SingleVariableDeclaration parameter : parameters) {
    Type parameterType=parameter.getType();
    ITypeBinding parameterTypeBinding=parameterType.resolveBinding();
    if (!typeBindings.contains(parameterTypeBinding))     typeBindings.add(parameterTypeBinding);
  }
  List<Name> thrownExceptions=sourceMethod.thrownExceptions();
  for (  Name name : thrownExceptions) {
    IBinding binding=name.resolveBinding();
    if (binding.getKind() == IBinding.TYPE) {
      ITypeBinding typeBinding=(ITypeBinding)binding;
      if (!typeBindings.contains(typeBinding))       typeBindings.add(typeBinding);
    }
  }
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(sourceMethod.getBody());
  for (  Expression variableInstruction : variableInstructions) {
    SimpleName simpleName=(SimpleName)variableInstruction;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      ITypeBinding variableTypeBinding=variableBinding.getType();
      if (!typeBindings.contains(variableTypeBinding))       typeBindings.add(variableTypeBinding);
      ITypeBinding declaringClassTypeBinding=variableBinding.getDeclaringClass();
      if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))       typeBindings.add(declaringClassTypeBinding);
    }
  }
  List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(sourceMethod.getBody());
  for (  Expression expression : methodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      if (!additionalMethodsToBeMoved.keySet().contains(methodInvocation)) {
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        ITypeBinding declaringClassTypeBinding=methodBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
        ITypeBinding superclassTypeBinding=sourceTypeDeclaration.resolveBinding().getSuperclass();
        while (superclassTypeBinding != null && !superclassTypeBinding.isEqualTo(methodBinding.getDeclaringClass())) {
          superclassTypeBinding=superclassTypeBinding.getSuperclass();
        }
        if (methodBinding.getDeclaringClass().isEqualTo(superclassTypeBinding) && !typeBindings.contains(sourceTypeDeclaration.resolveBinding()))         typeBindings.add(sourceTypeDeclaration.resolveBinding());
      }
    }
  }
  List<Expression> classInstanceCreations=expressionExtractor.getClassInstanceCreations(sourceMethod.getBody());
  for (  Expression expression : classInstanceCreations) {
    ClassInstanceCreation classInstanceCreation=(ClassInstanceCreation)expression;
    Type classInstanceCreationType=classInstanceCreation.getType();
    ITypeBinding classInstanceCreationTypeBinding=classInstanceCreationType.resolveBinding();
    if (!typeBindings.contains(classInstanceCreationTypeBinding))     typeBindings.add(classInstanceCreationTypeBinding);
  }
  List<Expression> typeLiterals=expressionExtractor.getTypeLiterals(sourceMethod.getBody());
  for (  Expression expression : typeLiterals) {
    TypeLiteral typeLiteral=(TypeLiteral)expression;
    Type typeLiteralType=typeLiteral.getType();
    ITypeBinding typeLiteralTypeBinding=typeLiteralType.resolveBinding();
    if (!typeBindings.contains(typeLiteralTypeBinding))     typeBindings.add(typeLiteralTypeBinding);
  }
  List<Expression> castExpressions=expressionExtractor.getCastExpressions(sourceMethod.getBody());
  for (  Expression expression : castExpressions) {
    CastExpression castExpression=(CastExpression)expression;
    Type castExpressionType=castExpression.getType();
    ITypeBinding typeLiteralTypeBinding=castExpressionType.resolveBinding();
    if (!typeBindings.contains(typeLiteralTypeBinding))     typeBindings.add(typeLiteralTypeBinding);
  }
  getSimpleTypeBindings(typeBindings);
  for (  ITypeBinding typeBinding : requiredTargetImportDeclarationSet)   addImportDeclaration(typeBinding);
}"
12220,"private void modifyMovedMethodInvocationInSourceClass(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<TypeDeclaration> sourceTypeDeclarationList=new ArrayList<TypeDeclaration>();
  sourceTypeDeclarationList.add(sourceTypeDeclaration);
  TypeDeclaration[] types=sourceTypeDeclaration.getTypes();
  for (  TypeDeclaration type : types) {
    sourceTypeDeclarationList.add(type);
  }
  for (  TypeDeclaration typeDeclaration : sourceTypeDeclarationList) {
    MethodDeclaration[] methodDeclarations=typeDeclaration.getMethods();
    for (    MethodDeclaration methodDeclaration : methodDeclarations) {
      Block methodBody=methodDeclaration.getBody();
      if (methodBody != null) {
        List<Statement> statements=methodBody.statements();
        for (        Statement statement : statements) {
          List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
          for (          Expression expression : methodInvocations) {
            if (expression instanceof MethodInvocation) {
              MethodInvocation methodInvocation=(MethodInvocation)expression;
              if (sourceMethod.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
                AST ast=methodInvocation.getAST();
                sourceRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(movedMethodName),null);
                List<Expression> arguments=methodInvocation.arguments();
                boolean foundInArguments=false;
                for (                Expression argument : arguments) {
                  if (argument.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding()) || targetTypeDeclaration.resolveBinding().isEqualTo(argument.resolveTypeBinding().getSuperclass())) {
                    foundInArguments=true;
                    ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                    argumentRewrite.remove(argument,null);
                    sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,argument,null);
                    break;
                  }
                }
                boolean foundInFields=false;
                if (!foundInArguments) {
                  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                  for (                  FieldDeclaration fieldDeclaration : fieldDeclarations) {
                    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                        foundInFields=true;
                        sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                        break;
                      }
                    }
                  }
                }
                if (!foundInArguments && !foundInFields) {
                  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                  for (                  FieldDeclaration fieldDeclaration : fieldDeclarations) {
                    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass())) {
                        sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                        break;
                      }
                    }
                  }
                }
                ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                for (                String argument : additionalArgumentsAddedToMovedMethod) {
                  if (argument.equals(""String_Node_Str""))                   argumentRewrite.insertLast(ast.newThisExpression(),null);
 else                   argumentRewrite.insertLast(ast.newSimpleName(argument),null);
                }
              }
            }
          }
        }
      }
    }
  }
}","private void modifyMovedMethodInvocationInSourceClass(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<TypeDeclaration> sourceTypeDeclarationList=new ArrayList<TypeDeclaration>();
  sourceTypeDeclarationList.add(sourceTypeDeclaration);
  TypeDeclaration[] types=sourceTypeDeclaration.getTypes();
  for (  TypeDeclaration type : types) {
    sourceTypeDeclarationList.add(type);
  }
  for (  TypeDeclaration typeDeclaration : sourceTypeDeclarationList) {
    MethodDeclaration[] methodDeclarations=typeDeclaration.getMethods();
    for (    MethodDeclaration methodDeclaration : methodDeclarations) {
      Block methodBody=methodDeclaration.getBody();
      if (methodBody != null) {
        List<Statement> statements=methodBody.statements();
        for (        Statement statement : statements) {
          List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
          for (          Expression expression : methodInvocations) {
            if (expression instanceof MethodInvocation) {
              MethodInvocation methodInvocation=(MethodInvocation)expression;
              if (sourceMethod.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
                AST ast=methodInvocation.getAST();
                sourceRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(movedMethodName),null);
                List<Expression> arguments=methodInvocation.arguments();
                boolean foundInArguments=false;
                for (                Expression argument : arguments) {
                  if (argument.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding()) || targetTypeDeclaration.resolveBinding().isEqualTo(argument.resolveTypeBinding().getSuperclass())) {
                    foundInArguments=true;
                    ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                    argumentRewrite.remove(argument,null);
                    sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,argument,null);
                    break;
                  }
                }
                boolean foundInFields=false;
                if (!foundInArguments) {
                  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                  for (                  FieldDeclaration fieldDeclaration : fieldDeclarations) {
                    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding()) && fragment.getName().getIdentifier().equals(targetClassVariableName)) {
                        foundInFields=true;
                        sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                        break;
                      }
                    }
                  }
                }
                if (!foundInArguments && !foundInFields) {
                  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                  for (                  FieldDeclaration fieldDeclaration : fieldDeclarations) {
                    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass()) && fragment.getName().getIdentifier().equals(targetClassVariableName)) {
                        sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                        break;
                      }
                    }
                  }
                }
                ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                for (                String argument : additionalArgumentsAddedToMovedMethod) {
                  if (argument.equals(""String_Node_Str""))                   argumentRewrite.insertLast(ast.newThisExpression(),null);
 else                   argumentRewrite.insertLast(ast.newSimpleName(argument),null);
                }
              }
            }
          }
        }
      }
    }
  }
}"
12221,"private void addDelegationInSourceMethod(){
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  String targetClassVariableName=null;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
      targetClassVariableName=parameter.getName().getIdentifier();
      break;
    }
  }
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
          targetClassVariableName=fragment.getName().getIdentifier();
          break;
        }
      }
    }
  }
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass())) {
          targetClassVariableName=fragment.getName().getIdentifier();
          break;
        }
      }
    }
  }
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(sourceMethod.getBody(),Block.STATEMENTS_PROPERTY);
  List<Statement> sourceMethodStatements=sourceMethod.getBody().statements();
  for (  Statement statement : sourceMethodStatements) {
    methodBodyRewrite.remove(statement,null);
  }
  Type sourceMethodReturnType=sourceMethod.getReturnType2();
  ITypeBinding sourceMethodReturnTypeBinding=sourceMethodReturnType.resolveBinding();
  AST ast=sourceMethod.getBody().getAST();
  MethodInvocation delegation=ast.newMethodInvocation();
  sourceRewriter.set(delegation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(movedMethodName),null);
  SimpleName expressionName=ast.newSimpleName(targetClassVariableName);
  sourceRewriter.set(delegation,MethodInvocation.EXPRESSION_PROPERTY,expressionName,null);
  ListRewrite argumentRewrite=sourceRewriter.getListRewrite(delegation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    if (!targetClassVariableName.equals(parameter.getName().getIdentifier())) {
      SimpleName argumentName=ast.newSimpleName(parameter.getName().getIdentifier());
      argumentRewrite.insertLast(argumentName,null);
    }
  }
  for (  String argument : additionalArgumentsAddedToMovedMethod) {
    if (argument.equals(""String_Node_Str""))     argumentRewrite.insertLast(ast.newThisExpression(),null);
 else     argumentRewrite.insertLast(ast.newSimpleName(argument),null);
  }
  if (sourceMethodReturnTypeBinding.getName().equals(""String_Node_Str"")) {
    ExpressionStatement expressionStatement=ast.newExpressionStatement(delegation);
    methodBodyRewrite.insertLast(expressionStatement,null);
  }
 else {
    ReturnStatement returnStatement=ast.newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,delegation,null);
    methodBodyRewrite.insertLast(returnStatement,null);
  }
}","private void addDelegationInSourceMethod(){
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  String targetClassVariableName=null;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding()) && parameter.getName().getIdentifier().equals(this.targetClassVariableName)) {
      targetClassVariableName=parameter.getName().getIdentifier();
      break;
    }
  }
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding()) && fragment.getName().getIdentifier().equals(this.targetClassVariableName)) {
          targetClassVariableName=fragment.getName().getIdentifier();
          break;
        }
      }
    }
  }
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass()) && fragment.getName().getIdentifier().equals(this.targetClassVariableName)) {
          targetClassVariableName=fragment.getName().getIdentifier();
          break;
        }
      }
    }
  }
  ListRewrite methodBodyRewrite=sourceRewriter.getListRewrite(sourceMethod.getBody(),Block.STATEMENTS_PROPERTY);
  List<Statement> sourceMethodStatements=sourceMethod.getBody().statements();
  for (  Statement statement : sourceMethodStatements) {
    methodBodyRewrite.remove(statement,null);
  }
  Type sourceMethodReturnType=sourceMethod.getReturnType2();
  ITypeBinding sourceMethodReturnTypeBinding=sourceMethodReturnType.resolveBinding();
  AST ast=sourceMethod.getBody().getAST();
  MethodInvocation delegation=ast.newMethodInvocation();
  sourceRewriter.set(delegation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(movedMethodName),null);
  SimpleName expressionName=ast.newSimpleName(targetClassVariableName);
  sourceRewriter.set(delegation,MethodInvocation.EXPRESSION_PROPERTY,expressionName,null);
  ListRewrite argumentRewrite=sourceRewriter.getListRewrite(delegation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    if (!targetClassVariableName.equals(parameter.getName().getIdentifier())) {
      SimpleName argumentName=ast.newSimpleName(parameter.getName().getIdentifier());
      argumentRewrite.insertLast(argumentName,null);
    }
  }
  for (  String argument : additionalArgumentsAddedToMovedMethod) {
    if (argument.equals(""String_Node_Str""))     argumentRewrite.insertLast(ast.newThisExpression(),null);
 else     argumentRewrite.insertLast(ast.newSimpleName(argument),null);
  }
  if (sourceMethodReturnTypeBinding.getName().equals(""String_Node_Str"")) {
    ExpressionStatement expressionStatement=ast.newExpressionStatement(delegation);
    methodBodyRewrite.insertLast(expressionStatement,null);
  }
 else {
    ReturnStatement returnStatement=ast.newReturnStatement();
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,delegation,null);
    methodBodyRewrite.insertLast(returnStatement,null);
  }
}"
12222,"public List<TypeCheckElimination> generateTypeCheckEliminations(){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> switchStatements=statementExtractor.getSwitchStatements(compositeStatement.getStatement());
  for (  Statement statement : switchStatements) {
    SwitchStatement switchStatement=(SwitchStatement)statement;
    TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
    typeCheckElimination.setTypeCheckCodeFragment(switchStatement);
    List<Statement> statements=switchStatement.statements();
    Expression switchCaseExpression=null;
    boolean isDefaultCase=false;
    for (    Statement statement2 : statements) {
      if (statement2 instanceof SwitchCase) {
        SwitchCase switchCase=(SwitchCase)statement2;
        switchCaseExpression=switchCase.getExpression();
        isDefaultCase=switchCase.isDefault();
      }
 else {
        if (!isDefaultCase) {
          if (!(statement2 instanceof BreakStatement))           typeCheckElimination.addTypeCheck(switchCaseExpression,statement2);
        }
 else {
          if (!(statement2 instanceof BreakStatement))           typeCheckElimination.addDefaultCaseStatement(statement2);
        }
      }
    }
    typeCheckEliminations.add(typeCheckElimination);
  }
  List<Statement> ifStatements=statementExtractor.getIfStatements(compositeStatement.getStatement());
  TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
  int i=0;
  for (  Statement statement : ifStatements) {
    IfStatement ifStatement=(IfStatement)statement;
    Expression ifExpression=ifStatement.getExpression();
    Statement thenStatement=ifStatement.getThenStatement();
    if (thenStatement instanceof Block) {
      Block block=(Block)thenStatement;
      List<Statement> statements=block.statements();
      for (      Statement statement2 : statements) {
        typeCheckElimination.addTypeCheck(ifExpression,statement2);
      }
    }
 else {
      typeCheckElimination.addTypeCheck(ifExpression,thenStatement);
    }
    Statement elseStatement=ifStatement.getElseStatement();
    if (elseStatement != null) {
      if (elseStatement instanceof Block) {
        Block block=(Block)elseStatement;
        List<Statement> statements=block.statements();
        for (        Statement statement2 : statements) {
          typeCheckElimination.addDefaultCaseStatement(statement2);
        }
      }
 else       if (!(elseStatement instanceof IfStatement)) {
        typeCheckElimination.addDefaultCaseStatement(elseStatement);
      }
    }
    if (ifStatements.size() - 1 > i) {
      IfStatement nextIfStatement=(IfStatement)ifStatements.get(i + 1);
      if (!ifStatement.getParent().equals(nextIfStatement)) {
        typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
        typeCheckEliminations.add(typeCheckElimination);
        typeCheckElimination=new TypeCheckElimination();
      }
    }
 else {
      typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
      typeCheckEliminations.add(typeCheckElimination);
    }
    i++;
  }
  return typeCheckEliminations;
}","public List<TypeCheckElimination> generateTypeCheckEliminations(){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> switchStatements=statementExtractor.getSwitchStatements(compositeStatement.getStatement());
  for (  Statement statement : switchStatements) {
    SwitchStatement switchStatement=(SwitchStatement)statement;
    TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
    typeCheckElimination.setTypeCheckCodeFragment(switchStatement);
    List<Statement> statements=switchStatement.statements();
    Expression switchCaseExpression=null;
    boolean isDefaultCase=false;
    Map<Expression,Integer> switchCaseExpressionStatementCounterMap=new LinkedHashMap<Expression,Integer>();
    for (    Statement statement2 : statements) {
      if (statement2 instanceof SwitchCase) {
        SwitchCase switchCase=(SwitchCase)statement2;
        switchCaseExpression=switchCase.getExpression();
        isDefaultCase=switchCase.isDefault();
        if (!isDefaultCase)         switchCaseExpressionStatementCounterMap.put(switchCaseExpression,0);
      }
 else {
        if (!isDefaultCase) {
          if (!(statement2 instanceof BreakStatement)) {
            switchCaseExpressionStatementCounterMap.put(switchCaseExpression,switchCaseExpressionStatementCounterMap.get(switchCaseExpression) + 1);
            typeCheckElimination.addTypeCheck(switchCaseExpression,statement2);
          }
 else {
            switchCaseExpressionStatementCounterMap.clear();
          }
        }
 else {
          if (!(statement2 instanceof BreakStatement)) {
            for (            Expression expression : switchCaseExpressionStatementCounterMap.keySet()) {
              if (switchCaseExpressionStatementCounterMap.get(expression) == 0) {
                typeCheckElimination.addTypeCheck(expression,statement2);
              }
            }
            typeCheckElimination.addDefaultCaseStatement(statement2);
          }
        }
      }
    }
    typeCheckEliminations.add(typeCheckElimination);
  }
  List<Statement> ifStatements=statementExtractor.getIfStatements(compositeStatement.getStatement());
  TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
  int i=0;
  for (  Statement statement : ifStatements) {
    IfStatement ifStatement=(IfStatement)statement;
    Expression ifExpression=ifStatement.getExpression();
    Statement thenStatement=ifStatement.getThenStatement();
    if (thenStatement instanceof Block) {
      Block block=(Block)thenStatement;
      List<Statement> statements=block.statements();
      for (      Statement statement2 : statements) {
        typeCheckElimination.addTypeCheck(ifExpression,statement2);
      }
    }
 else {
      typeCheckElimination.addTypeCheck(ifExpression,thenStatement);
    }
    Statement elseStatement=ifStatement.getElseStatement();
    if (elseStatement != null) {
      if (elseStatement instanceof Block) {
        Block block=(Block)elseStatement;
        List<Statement> statements=block.statements();
        for (        Statement statement2 : statements) {
          typeCheckElimination.addDefaultCaseStatement(statement2);
        }
      }
 else       if (!(elseStatement instanceof IfStatement)) {
        typeCheckElimination.addDefaultCaseStatement(elseStatement);
      }
    }
    if (ifStatements.size() - 1 > i) {
      IfStatement nextIfStatement=(IfStatement)ifStatements.get(i + 1);
      if (!ifStatement.getParent().equals(nextIfStatement)) {
        typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
        typeCheckEliminations.add(typeCheckElimination);
        typeCheckElimination=new TypeCheckElimination();
      }
    }
 else {
      typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
      typeCheckEliminations.add(typeCheckElimination);
    }
    i++;
  }
  return typeCheckEliminations;
}"
12223,"public void identifyTypeLocalVariableAccessesInTypeCheckMethod(){
  List<String> staticFieldNames=typeCheckElimination.getStaticFieldNames();
  Block methodBody=typeCheckElimination.getTypeCheckMethod().getBody();
  if (methodBody != null) {
    List<Statement> statements=methodBody.statements();
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    for (    Statement statement : statements) {
      List<Expression> infixExpressions=expressionExtractor.getInfixExpressions(statement);
      for (      Expression expression : infixExpressions) {
        InfixExpression infixExpression=(InfixExpression)expression;
        Expression leftOperand=infixExpression.getLeftOperand();
        Expression rightOperand=infixExpression.getRightOperand();
        SimpleName accessedVariable=null;
        SimpleName comparedVariable=null;
        boolean typeLocalVariableIsFound=false;
        if (leftOperand instanceof SimpleName) {
          accessedVariable=(SimpleName)leftOperand;
        }
 else         if (leftOperand instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)leftOperand;
          accessedVariable=fieldAccess.getName();
        }
        if (rightOperand instanceof SimpleName) {
          comparedVariable=(SimpleName)rightOperand;
        }
 else         if (rightOperand instanceof QualifiedName) {
          QualifiedName qualifiedName=(QualifiedName)rightOperand;
          comparedVariable=qualifiedName.getName();
        }
 else         if (rightOperand instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)rightOperand;
          comparedVariable=fieldAccess.getName();
        }
        if (accessedVariable != null) {
          IBinding leftOperandBinding=accessedVariable.resolveBinding();
          if (leftOperandBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding accessedVariableBinding=(IVariableBinding)leftOperandBinding;
            if (typeCheckElimination.getTypeLocalVariable().resolveBinding().isEqualTo(accessedVariable.resolveBinding())) {
              typeLocalVariableIsFound=true;
              if (comparedVariable != null) {
                IBinding rightOperandBinding=comparedVariable.resolveBinding();
                if (rightOperandBinding.getKind() == IBinding.VARIABLE) {
                  IVariableBinding comparedVariableBinding=(IVariableBinding)rightOperandBinding;
                  if (comparedVariableBinding.isField() && (comparedVariableBinding.getModifiers() & Modifier.STATIC) != 0 && !staticFieldNames.contains(comparedVariable.getIdentifier())) {
                    String subclassName=""String_Node_Str"";
                    StringTokenizer tokenizer=new StringTokenizer(comparedVariable.getIdentifier(),""String_Node_Str"");
                    while (tokenizer.hasMoreTokens()) {
                      String tempName=tokenizer.nextToken().toLowerCase().toString();
                      subclassName+=tempName.subSequence(0,1).toString().toUpperCase() + tempName.subSequence(1,tempName.length()).toString();
                    }
                    if (!containsStaticFieldKey(comparedVariable))                     additionalStaticFields.put(comparedVariable,subclassName);
                  }
                }
              }
            }
          }
        }
        if (!typeLocalVariableIsFound) {
          if (rightOperand instanceof SimpleName) {
            accessedVariable=(SimpleName)rightOperand;
          }
 else           if (rightOperand instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)rightOperand;
            accessedVariable=fieldAccess.getName();
          }
          if (leftOperand instanceof SimpleName) {
            comparedVariable=(SimpleName)leftOperand;
          }
 else           if (leftOperand instanceof QualifiedName) {
            QualifiedName qualifiedName=(QualifiedName)leftOperand;
            comparedVariable=qualifiedName.getName();
          }
 else           if (leftOperand instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)leftOperand;
            comparedVariable=fieldAccess.getName();
          }
          if (accessedVariable != null) {
            IBinding rightOperandBinding=accessedVariable.resolveBinding();
            if (rightOperandBinding.getKind() == IBinding.VARIABLE) {
              IVariableBinding accessedVariableBinding=(IVariableBinding)rightOperandBinding;
              if (typeCheckElimination.getTypeLocalVariable().resolveBinding().isEqualTo(accessedVariable.resolveBinding())) {
                if (comparedVariable != null) {
                  IBinding leftOperandBinding=comparedVariable.resolveBinding();
                  if (leftOperandBinding.getKind() == IBinding.VARIABLE) {
                    IVariableBinding comparedVariableBinding=(IVariableBinding)leftOperandBinding;
                    if (comparedVariableBinding.isField() && (comparedVariableBinding.getModifiers() & Modifier.STATIC) != 0 && !staticFieldNames.contains(comparedVariable.getIdentifier())) {
                      String subclassName=""String_Node_Str"";
                      StringTokenizer tokenizer=new StringTokenizer(comparedVariable.getIdentifier(),""String_Node_Str"");
                      while (tokenizer.hasMoreTokens()) {
                        String tempName=tokenizer.nextToken().toLowerCase().toString();
                        subclassName+=tempName.subSequence(0,1).toString().toUpperCase() + tempName.subSequence(1,tempName.length()).toString();
                      }
                      if (!containsStaticFieldKey(comparedVariable))                       additionalStaticFields.put(comparedVariable,subclassName);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}","private void identifyTypeLocalVariableAccessesInTypeCheckMethod(){
  List<String> staticFieldNames=typeCheckElimination.getStaticFieldNames();
  Block methodBody=typeCheckElimination.getTypeCheckMethod().getBody();
  if (methodBody != null) {
    List<Statement> statements=methodBody.statements();
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    for (    Statement statement : statements) {
      List<Expression> infixExpressions=expressionExtractor.getInfixExpressions(statement);
      for (      Expression expression : infixExpressions) {
        InfixExpression infixExpression=(InfixExpression)expression;
        Expression leftOperand=infixExpression.getLeftOperand();
        Expression rightOperand=infixExpression.getRightOperand();
        SimpleName accessedVariable=null;
        SimpleName comparedVariable=null;
        boolean typeLocalVariableIsFound=false;
        if (leftOperand instanceof SimpleName) {
          accessedVariable=(SimpleName)leftOperand;
        }
 else         if (leftOperand instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)leftOperand;
          accessedVariable=fieldAccess.getName();
        }
        if (rightOperand instanceof SimpleName) {
          comparedVariable=(SimpleName)rightOperand;
        }
 else         if (rightOperand instanceof QualifiedName) {
          QualifiedName qualifiedName=(QualifiedName)rightOperand;
          comparedVariable=qualifiedName.getName();
        }
 else         if (rightOperand instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)rightOperand;
          comparedVariable=fieldAccess.getName();
        }
        if (accessedVariable != null) {
          IBinding leftOperandBinding=accessedVariable.resolveBinding();
          if (leftOperandBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding accessedVariableBinding=(IVariableBinding)leftOperandBinding;
            if (typeCheckElimination.getTypeLocalVariable().resolveBinding().isEqualTo(accessedVariable.resolveBinding())) {
              typeLocalVariableIsFound=true;
              if (comparedVariable != null) {
                IBinding rightOperandBinding=comparedVariable.resolveBinding();
                if (rightOperandBinding.getKind() == IBinding.VARIABLE) {
                  IVariableBinding comparedVariableBinding=(IVariableBinding)rightOperandBinding;
                  if (comparedVariableBinding.isField() && (comparedVariableBinding.getModifiers() & Modifier.STATIC) != 0 && !staticFieldNames.contains(comparedVariable.getIdentifier())) {
                    String subclassName=""String_Node_Str"";
                    StringTokenizer tokenizer=new StringTokenizer(comparedVariable.getIdentifier(),""String_Node_Str"");
                    while (tokenizer.hasMoreTokens()) {
                      String tempName=tokenizer.nextToken().toLowerCase().toString();
                      subclassName+=tempName.subSequence(0,1).toString().toUpperCase() + tempName.subSequence(1,tempName.length()).toString();
                    }
                    if (!containsStaticFieldKey(comparedVariable))                     additionalStaticFields.put(comparedVariable,subclassName);
                  }
                }
              }
            }
          }
        }
        if (!typeLocalVariableIsFound) {
          if (rightOperand instanceof SimpleName) {
            accessedVariable=(SimpleName)rightOperand;
          }
 else           if (rightOperand instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)rightOperand;
            accessedVariable=fieldAccess.getName();
          }
          if (leftOperand instanceof SimpleName) {
            comparedVariable=(SimpleName)leftOperand;
          }
 else           if (leftOperand instanceof QualifiedName) {
            QualifiedName qualifiedName=(QualifiedName)leftOperand;
            comparedVariable=qualifiedName.getName();
          }
 else           if (leftOperand instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)leftOperand;
            comparedVariable=fieldAccess.getName();
          }
          if (accessedVariable != null) {
            IBinding rightOperandBinding=accessedVariable.resolveBinding();
            if (rightOperandBinding.getKind() == IBinding.VARIABLE) {
              IVariableBinding accessedVariableBinding=(IVariableBinding)rightOperandBinding;
              if (typeCheckElimination.getTypeLocalVariable().resolveBinding().isEqualTo(accessedVariable.resolveBinding())) {
                if (comparedVariable != null) {
                  IBinding leftOperandBinding=comparedVariable.resolveBinding();
                  if (leftOperandBinding.getKind() == IBinding.VARIABLE) {
                    IVariableBinding comparedVariableBinding=(IVariableBinding)leftOperandBinding;
                    if (comparedVariableBinding.isField() && (comparedVariableBinding.getModifiers() & Modifier.STATIC) != 0 && !staticFieldNames.contains(comparedVariable.getIdentifier())) {
                      String subclassName=""String_Node_Str"";
                      StringTokenizer tokenizer=new StringTokenizer(comparedVariable.getIdentifier(),""String_Node_Str"");
                      while (tokenizer.hasMoreTokens()) {
                        String tempName=tokenizer.nextToken().toLowerCase().toString();
                        subclassName+=tempName.subSequence(0,1).toString().toUpperCase() + tempName.subSequence(1,tempName.length()).toString();
                      }
                      if (!containsStaticFieldKey(comparedVariable))                       additionalStaticFields.put(comparedVariable,subclassName);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}"
12224,"public void identifyTypeLocalVariableAssignmentsInTypeCheckMethod(){
  List<String> staticFieldNames=typeCheckElimination.getStaticFieldNames();
  Block methodBody=typeCheckElimination.getTypeCheckMethod().getBody();
  if (methodBody != null) {
    List<Statement> statements=methodBody.statements();
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    for (    Statement statement : statements) {
      List<Expression> assignments=expressionExtractor.getAssignments(statement);
      for (      Expression expression : assignments) {
        Assignment assignment=(Assignment)expression;
        Expression leftHandSide=assignment.getLeftHandSide();
        SimpleName assignedVariable=null;
        Expression invoker=null;
        if (leftHandSide instanceof SimpleName) {
          assignedVariable=(SimpleName)leftHandSide;
        }
 else         if (leftHandSide instanceof QualifiedName) {
          QualifiedName qualifiedName=(QualifiedName)leftHandSide;
          assignedVariable=qualifiedName.getName();
          invoker=qualifiedName.getQualifier();
        }
 else         if (leftHandSide instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)leftHandSide;
          assignedVariable=fieldAccess.getName();
          invoker=fieldAccess.getExpression();
        }
        Expression rightHandSide=assignment.getRightHandSide();
        SimpleName accessedVariable=decomposeRightHandSide(rightHandSide);
        if (assignedVariable != null) {
          IBinding leftHandBinding=assignedVariable.resolveBinding();
          if (leftHandBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding assignedVariableBinding=(IVariableBinding)leftHandBinding;
            if (typeCheckElimination.getTypeLocalVariable().resolveBinding().isEqualTo(assignedVariableBinding)) {
              if (accessedVariable != null) {
                IBinding rightHandBinding=accessedVariable.resolveBinding();
                if (rightHandBinding.getKind() == IBinding.VARIABLE) {
                  IVariableBinding accessedVariableBinding=(IVariableBinding)rightHandBinding;
                  if (accessedVariableBinding.isField() && (accessedVariableBinding.getModifiers() & Modifier.STATIC) != 0 && !staticFieldNames.contains(accessedVariable.getIdentifier())) {
                    String subclassName=""String_Node_Str"";
                    StringTokenizer tokenizer=new StringTokenizer(accessedVariable.getIdentifier(),""String_Node_Str"");
                    while (tokenizer.hasMoreTokens()) {
                      String tempName=tokenizer.nextToken().toLowerCase().toString();
                      subclassName+=tempName.subSequence(0,1).toString().toUpperCase() + tempName.subSequence(1,tempName.length()).toString();
                    }
                    if (!containsStaticFieldKey(accessedVariable))                     additionalStaticFields.put(accessedVariable,subclassName);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}","private void identifyTypeLocalVariableAssignmentsInTypeCheckMethod(){
  List<String> staticFieldNames=typeCheckElimination.getStaticFieldNames();
  Block methodBody=typeCheckElimination.getTypeCheckMethod().getBody();
  if (methodBody != null) {
    List<Statement> statements=methodBody.statements();
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    for (    Statement statement : statements) {
      List<Expression> assignments=expressionExtractor.getAssignments(statement);
      for (      Expression expression : assignments) {
        Assignment assignment=(Assignment)expression;
        Expression leftHandSide=assignment.getLeftHandSide();
        SimpleName assignedVariable=null;
        Expression invoker=null;
        if (leftHandSide instanceof SimpleName) {
          assignedVariable=(SimpleName)leftHandSide;
        }
 else         if (leftHandSide instanceof QualifiedName) {
          QualifiedName qualifiedName=(QualifiedName)leftHandSide;
          assignedVariable=qualifiedName.getName();
          invoker=qualifiedName.getQualifier();
        }
 else         if (leftHandSide instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)leftHandSide;
          assignedVariable=fieldAccess.getName();
          invoker=fieldAccess.getExpression();
        }
        Expression rightHandSide=assignment.getRightHandSide();
        SimpleName accessedVariable=decomposeRightHandSide(rightHandSide);
        if (assignedVariable != null) {
          IBinding leftHandBinding=assignedVariable.resolveBinding();
          if (leftHandBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding assignedVariableBinding=(IVariableBinding)leftHandBinding;
            if (typeCheckElimination.getTypeLocalVariable().resolveBinding().isEqualTo(assignedVariableBinding)) {
              if (accessedVariable != null) {
                IBinding rightHandBinding=accessedVariable.resolveBinding();
                if (rightHandBinding.getKind() == IBinding.VARIABLE) {
                  IVariableBinding accessedVariableBinding=(IVariableBinding)rightHandBinding;
                  if (accessedVariableBinding.isField() && (accessedVariableBinding.getModifiers() & Modifier.STATIC) != 0 && !staticFieldNames.contains(accessedVariable.getIdentifier())) {
                    String subclassName=""String_Node_Str"";
                    StringTokenizer tokenizer=new StringTokenizer(accessedVariable.getIdentifier(),""String_Node_Str"");
                    while (tokenizer.hasMoreTokens()) {
                      String tempName=tokenizer.nextToken().toLowerCase().toString();
                      subclassName+=tempName.subSequence(0,1).toString().toUpperCase() + tempName.subSequence(1,tempName.length()).toString();
                    }
                    if (!containsStaticFieldKey(accessedVariable))                     additionalStaticFields.put(accessedVariable,subclassName);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}"
12225,"private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  targetRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(movedMethodName),null);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
      targetClassVariableName=parameter.getName().getIdentifier();
      parametersRewrite.remove(newMethodParameters.get(i),null);
      break;
    }
    i++;
  }
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newMethodDeclaration.getBody());
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  modifySourceStaticMethodInvocationsInTargetClass(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInClassInstanceCreationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInVariableDeclarationInitializers(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInfixExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInCastExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInstanceofExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInAssignments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInVariableDeclarationInitializers(newMethodDeclaration);
  ListRewrite targetClassBodyRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  targetClassBodyRewrite.insertLast(newMethodDeclaration,null);
}","private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  targetRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(movedMethodName),null);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
      for (      Expression expression : newVariableInstructions) {
        SimpleName simpleName=(SimpleName)expression;
        if (parameter.getName().getIdentifier().equals(simpleName.getIdentifier())) {
          targetClassVariableName=parameter.getName().getIdentifier();
          parametersRewrite.remove(newMethodParameters.get(i),null);
          break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
    i++;
  }
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(sourceMethod.getBody());
  MethodDeclaration[] methodDeclarations=sourceTypeDeclaration.getMethods();
  if (targetClassVariableName == null) {
    for (    Expression oldMethodInvocation : oldMethodInvocations) {
      if (oldMethodInvocation instanceof MethodInvocation) {
        MethodInvocation methodInvocation=(MethodInvocation)oldMethodInvocation;
        for (        MethodDeclaration methodDeclaration : methodDeclarations) {
          if (methodInvocation.resolveMethodBinding().isEqualTo(methodDeclaration.resolveBinding())) {
            SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(methodDeclaration);
            if (fieldInstruction != null && fieldInstruction.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
              targetClassVariableName=fieldInstruction.getIdentifier();
              break;
            }
          }
        }
        if (targetClassVariableName != null)         break;
      }
    }
  }
  if (targetClassVariableName == null) {
    for (    Expression oldMethodInvocation : oldMethodInvocations) {
      if (oldMethodInvocation instanceof MethodInvocation) {
        MethodInvocation methodInvocation=(MethodInvocation)oldMethodInvocation;
        for (        MethodDeclaration methodDeclaration : methodDeclarations) {
          if (methodInvocation.resolveMethodBinding().isEqualTo(methodDeclaration.resolveBinding())) {
            MethodInvocation delegation=MethodDeclarationUtility.isDelegate(methodDeclaration);
            if (delegation != null && delegation.resolveMethodBinding().getDeclaringClass().isEqualTo(targetTypeDeclaration.resolveBinding())) {
              List<Expression> delegateMethodVariableInstructions=expressionExtractor.getVariableInstructions(methodDeclaration.getBody());
              for (              Expression expression : delegateMethodVariableInstructions) {
                SimpleName fieldInstruction=(SimpleName)expression;
                IBinding fieldInstructionBinding=fieldInstruction.resolveBinding();
                if (fieldInstructionBinding.getKind() == IBinding.VARIABLE) {
                  IVariableBinding fieldInstructionVariableBinding=(IVariableBinding)fieldInstructionBinding;
                  if (fieldInstructionVariableBinding.isField() && fieldInstructionVariableBinding.getType().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                    targetClassVariableName=fieldInstruction.getIdentifier();
                    break;
                  }
                }
              }
              if (targetClassVariableName != null)               break;
            }
          }
        }
        if (targetClassVariableName != null)         break;
      }
    }
  }
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  modifySourceStaticMethodInvocationsInTargetClass(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInClassInstanceCreationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInVariableDeclarationInitializers(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInfixExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInCastExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInstanceofExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInAssignments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInVariableDeclarationInitializers(newMethodDeclaration);
  ListRewrite targetClassBodyRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  targetClassBodyRewrite.insertLast(newMethodDeclaration,null);
}"
12226,"private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  targetRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(movedMethodName),null);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
      for (      Expression expression : newVariableInstructions) {
        SimpleName simpleName=(SimpleName)expression;
        if (parameter.getName().getIdentifier().equals(simpleName.getIdentifier())) {
          targetClassVariableName=parameter.getName().getIdentifier();
          parametersRewrite.remove(newMethodParameters.get(i),null);
          isTargetClassVariableParameter=true;
          break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
    i++;
  }
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(sourceMethod.getBody());
  MethodDeclaration[] methodDeclarations=sourceTypeDeclaration.getMethods();
  if (targetClassVariableName == null) {
    for (    Expression oldMethodInvocation : oldMethodInvocations) {
      if (oldMethodInvocation instanceof MethodInvocation) {
        MethodInvocation methodInvocation=(MethodInvocation)oldMethodInvocation;
        if (methodInvocation.resolveMethodBinding().getDeclaringClass().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
          for (          MethodDeclaration methodDeclaration : methodDeclarations) {
            if (methodInvocation.resolveMethodBinding().isEqualTo(methodDeclaration.resolveBinding())) {
              SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(methodDeclaration);
              if (fieldInstruction != null && fieldInstruction.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                targetClassVariableName=fieldInstruction.getIdentifier();
                break;
              }
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
    }
  }
  if (targetClassVariableName == null) {
    for (    Expression oldMethodInvocation : oldMethodInvocations) {
      if (oldMethodInvocation instanceof MethodInvocation) {
        MethodInvocation methodInvocation=(MethodInvocation)oldMethodInvocation;
        if (methodInvocation.resolveMethodBinding().getDeclaringClass().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
          for (          MethodDeclaration methodDeclaration : methodDeclarations) {
            if (methodInvocation.resolveMethodBinding().isEqualTo(methodDeclaration.resolveBinding())) {
              MethodInvocation delegation=MethodDeclarationUtility.isDelegate(methodDeclaration);
              if (delegation != null && delegation.resolveMethodBinding().getDeclaringClass().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                List<Expression> delegateMethodVariableInstructions=expressionExtractor.getVariableInstructions(methodDeclaration.getBody());
                for (                Expression expression : delegateMethodVariableInstructions) {
                  SimpleName fieldInstruction=(SimpleName)expression;
                  IBinding fieldInstructionBinding=fieldInstruction.resolveBinding();
                  if (fieldInstructionBinding.getKind() == IBinding.VARIABLE) {
                    IVariableBinding fieldInstructionVariableBinding=(IVariableBinding)fieldInstructionBinding;
                    if (fieldInstructionVariableBinding.isField() && fieldInstructionVariableBinding.getType().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                      targetClassVariableName=fieldInstruction.getIdentifier();
                      break;
                    }
                  }
                }
                if (targetClassVariableName != null)                 break;
              }
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
    }
  }
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  modifySourceStaticMethodInvocationsInTargetClass(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInClassInstanceCreationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInVariableDeclarationInitializers(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInfixExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInCastExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInstanceofExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInAssignments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInVariableDeclarationInitializers(newMethodDeclaration);
  ListRewrite targetClassBodyRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  targetClassBodyRewrite.insertLast(newMethodDeclaration,null);
}","private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  targetRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(movedMethodName),null);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
      for (      Expression expression : newVariableInstructions) {
        SimpleName simpleName=(SimpleName)expression;
        if (parameter.getName().getIdentifier().equals(simpleName.getIdentifier())) {
          targetClassVariableName=parameter.getName().getIdentifier();
          parametersRewrite.remove(newMethodParameters.get(i),null);
          isTargetClassVariableParameter=true;
          break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
    i++;
  }
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(sourceMethod.getBody());
  MethodDeclaration[] methodDeclarations=sourceTypeDeclaration.getMethods();
  if (targetClassVariableName == null) {
    for (    Expression oldMethodInvocation : oldMethodInvocations) {
      if (oldMethodInvocation instanceof MethodInvocation) {
        MethodInvocation methodInvocation=(MethodInvocation)oldMethodInvocation;
        if (methodInvocation.resolveMethodBinding().getDeclaringClass().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
          for (          MethodDeclaration methodDeclaration : methodDeclarations) {
            if (methodInvocation.resolveMethodBinding().isEqualTo(methodDeclaration.resolveBinding())) {
              SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(methodDeclaration);
              if (fieldInstruction != null && fieldInstruction.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                targetClassVariableName=fieldInstruction.getIdentifier();
                break;
              }
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
    }
  }
  if (targetClassVariableName == null) {
    for (    Expression oldMethodInvocation : oldMethodInvocations) {
      if (oldMethodInvocation instanceof MethodInvocation) {
        MethodInvocation methodInvocation=(MethodInvocation)oldMethodInvocation;
        if (methodInvocation.resolveMethodBinding().getDeclaringClass().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
          for (          MethodDeclaration methodDeclaration : methodDeclarations) {
            if (methodInvocation.resolveMethodBinding().isEqualTo(methodDeclaration.resolveBinding())) {
              MethodInvocation delegation=MethodDeclarationUtility.isDelegate(methodDeclaration);
              if (delegation != null && delegation.resolveMethodBinding().getDeclaringClass().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                List<Expression> delegateMethodVariableInstructions=expressionExtractor.getVariableInstructions(methodDeclaration.getBody());
                for (                Expression expression : delegateMethodVariableInstructions) {
                  SimpleName fieldInstruction=(SimpleName)expression;
                  IBinding fieldInstructionBinding=fieldInstruction.resolveBinding();
                  if (fieldInstructionBinding.getKind() == IBinding.VARIABLE) {
                    IVariableBinding fieldInstructionVariableBinding=(IVariableBinding)fieldInstructionBinding;
                    if (fieldInstructionVariableBinding.isField() && fieldInstructionVariableBinding.getType().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                      targetClassVariableName=fieldInstruction.getIdentifier();
                      break;
                    }
                  }
                }
                if (targetClassVariableName != null)                 break;
              }
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
    }
  }
  if (targetClassVariableName == null) {
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  modifySourceStaticMethodInvocationsInTargetClass(newMethodDeclaration);
  modifyRecursiveMethodInvocationsOfTheMovedMethod(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInClassInstanceCreationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInVariableDeclarationInitializers(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInfixExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInCastExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInstanceofExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInAssignments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInVariableDeclarationInitializers(newMethodDeclaration);
  ListRewrite targetClassBodyRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  targetClassBodyRewrite.insertLast(newMethodDeclaration,null);
}"
12227,"private void replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression invocation : newMethodInvocations) {
    if (invocation instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)invocation;
      List<Expression> arguments=methodInvocation.arguments();
      for (      Expression argument : arguments) {
        if (argument instanceof SimpleName) {
          SimpleName simpleNameArgument=(SimpleName)argument;
          if (simpleNameArgument.getIdentifier().equals(targetClassVariableName)) {
            ListRewrite argumentRewrite=targetRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            MethodInvocation sourceMethodInvocation=(MethodInvocation)sourceMethodInvocations.get(i);
            AST ast=newMethodDeclaration.getAST();
            if (sourceMethod.resolveBinding().isEqualTo(sourceMethodInvocation.resolveMethodBinding())) {
              targetRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(movedMethodName),null);
              argumentRewrite.remove(argument,null);
            }
 else {
              argumentRewrite.replace(argument,ast.newThisExpression(),null);
            }
          }
        }
 else         if (argument instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)argument;
          SimpleName simpleNameArgument=fieldAccess.getName();
          if (simpleNameArgument.getIdentifier().equals(targetClassVariableName)) {
            ListRewrite argumentRewrite=targetRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            MethodInvocation sourceMethodInvocation=(MethodInvocation)sourceMethodInvocations.get(i);
            AST ast=newMethodDeclaration.getAST();
            if (sourceMethod.resolveBinding().isEqualTo(sourceMethodInvocation.resolveMethodBinding())) {
              targetRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(movedMethodName),null);
              argumentRewrite.remove(argument,null);
            }
 else {
              argumentRewrite.replace(argument,ast.newThisExpression(),null);
            }
          }
        }
      }
    }
    i++;
  }
}","private void replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression invocation : newMethodInvocations) {
    if (invocation instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)invocation;
      List<Expression> arguments=methodInvocation.arguments();
      for (      Expression argument : arguments) {
        if (argument instanceof SimpleName) {
          SimpleName simpleNameArgument=(SimpleName)argument;
          if (simpleNameArgument.getIdentifier().equals(targetClassVariableName)) {
            ListRewrite argumentRewrite=targetRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            MethodInvocation sourceMethodInvocation=(MethodInvocation)sourceMethodInvocations.get(i);
            AST ast=newMethodDeclaration.getAST();
            if (!sourceMethod.resolveBinding().isEqualTo(sourceMethodInvocation.resolveMethodBinding())) {
              argumentRewrite.replace(argument,ast.newThisExpression(),null);
            }
          }
        }
 else         if (argument instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)argument;
          SimpleName simpleNameArgument=fieldAccess.getName();
          if (simpleNameArgument.getIdentifier().equals(targetClassVariableName)) {
            ListRewrite argumentRewrite=targetRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            MethodInvocation sourceMethodInvocation=(MethodInvocation)sourceMethodInvocations.get(i);
            AST ast=newMethodDeclaration.getAST();
            if (!sourceMethod.resolveBinding().isEqualTo(sourceMethodInvocation.resolveMethodBinding())) {
              argumentRewrite.replace(argument,ast.newThisExpression(),null);
            }
          }
        }
      }
    }
    i++;
  }
}"
12228,"public boolean containsMethodInvocation(MethodInvocationObject methodInvocation,ClassObject excludedClass){
  for (  ClassObject classObject : classList) {
    TypeDeclaration outerTypeDeclaration=classObject.getOuterClass();
    boolean isInnerOfExcludedClasses=false;
    if (outerTypeDeclaration != null) {
      if (outerTypeDeclaration.equals(excludedClass.getTypeDeclaration()))       isInnerOfExcludedClasses=true;
    }
    if (!isInnerOfExcludedClasses && !excludedClass.equals(classObject) && classObject.containsMethodInvocation(methodInvocation))     return true;
  }
  return false;
}","public boolean containsMethodInvocation(MethodInvocationObject methodInvocation,ClassObject excludedClass){
  for (  ClassObject classObject : classList) {
    if (!excludedClass.equals(classObject) && classObject.containsMethodInvocation(methodInvocation))     return true;
  }
  return false;
}"
12229,"private void modifyMovedMethodInvocationInSourceClass(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<TypeDeclaration> sourceTypeDeclarationList=new ArrayList<TypeDeclaration>();
  sourceTypeDeclarationList.add(sourceTypeDeclaration);
  TypeDeclaration[] types=sourceTypeDeclaration.getTypes();
  for (  TypeDeclaration type : types) {
    sourceTypeDeclarationList.add(type);
  }
  for (  TypeDeclaration typeDeclaration : sourceTypeDeclarationList) {
    MethodDeclaration[] methodDeclarations=typeDeclaration.getMethods();
    for (    MethodDeclaration methodDeclaration : methodDeclarations) {
      Block methodBody=methodDeclaration.getBody();
      if (methodBody != null) {
        List<Statement> statements=methodBody.statements();
        for (        Statement statement : statements) {
          List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
          for (          Expression expression : methodInvocations) {
            if (expression instanceof MethodInvocation) {
              MethodInvocation methodInvocation=(MethodInvocation)expression;
              if (sourceMethod.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
                AST ast=methodInvocation.getAST();
                sourceRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(movedMethodName),null);
                List<Expression> arguments=methodInvocation.arguments();
                boolean foundInArguments=false;
                for (                Expression argument : arguments) {
                  if (argument.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                    foundInArguments=true;
                    ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                    argumentRewrite.remove(argument,null);
                    sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,argument,null);
                    break;
                  }
                }
                boolean foundInFields=false;
                if (!foundInArguments) {
                  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                  for (                  FieldDeclaration fieldDeclaration : fieldDeclarations) {
                    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding()) && fragment.getName().getIdentifier().equals(targetClassVariableName)) {
                        foundInFields=true;
                        sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                        break;
                      }
                    }
                  }
                }
                if (!foundInArguments && !foundInFields) {
                  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                  for (                  FieldDeclaration fieldDeclaration : fieldDeclarations) {
                    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                    for (                    VariableDeclarationFragment fragment : fragments) {
                      if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass()) && fragment.getName().getIdentifier().equals(targetClassVariableName)) {
                        sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                        break;
                      }
                    }
                  }
                }
                ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                for (                String argument : additionalArgumentsAddedToMovedMethod) {
                  if (argument.equals(""String_Node_Str""))                   argumentRewrite.insertLast(ast.newThisExpression(),null);
 else                   argumentRewrite.insertLast(ast.newSimpleName(argument),null);
                }
              }
            }
          }
        }
      }
    }
  }
}","private void modifyMovedMethodInvocationInSourceClass(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  MethodDeclaration[] methodDeclarations=sourceTypeDeclaration.getMethods();
  for (  MethodDeclaration methodDeclaration : methodDeclarations) {
    Block methodBody=methodDeclaration.getBody();
    if (methodBody != null) {
      List<Statement> statements=methodBody.statements();
      for (      Statement statement : statements) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            if (sourceMethod.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
              AST ast=methodInvocation.getAST();
              sourceRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,ast.newSimpleName(movedMethodName),null);
              List<Expression> arguments=methodInvocation.arguments();
              boolean foundInArguments=false;
              for (              Expression argument : arguments) {
                if (argument.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                  foundInArguments=true;
                  ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                  argumentRewrite.remove(argument,null);
                  sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,argument,null);
                  break;
                }
              }
              boolean foundInFields=false;
              if (!foundInArguments) {
                FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                for (                FieldDeclaration fieldDeclaration : fieldDeclarations) {
                  List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                  for (                  VariableDeclarationFragment fragment : fragments) {
                    if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding()) && fragment.getName().getIdentifier().equals(targetClassVariableName)) {
                      foundInFields=true;
                      sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                      break;
                    }
                  }
                }
              }
              if (!foundInArguments && !foundInFields) {
                FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                for (                FieldDeclaration fieldDeclaration : fieldDeclarations) {
                  List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                  for (                  VariableDeclarationFragment fragment : fragments) {
                    if (targetTypeDeclaration.resolveBinding().isEqualTo(fieldDeclaration.getType().resolveBinding().getSuperclass()) && fragment.getName().getIdentifier().equals(targetClassVariableName)) {
                      sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                      break;
                    }
                  }
                }
              }
              ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
              for (              String argument : additionalArgumentsAddedToMovedMethod) {
                if (argument.equals(""String_Node_Str""))                 argumentRewrite.insertLast(ast.newThisExpression(),null);
 else                 argumentRewrite.insertLast(ast.newSimpleName(argument),null);
              }
            }
          }
        }
      }
    }
  }
}"
12230,"private void modifyVariableInstructionsInSubclass(List<Expression> oldVariableInstructions,List<Expression> newVariableInstructions,AST subclassAST,ASTRewrite subclassRewriter,Set<VariableDeclarationFragment> accessedFields,Set<VariableDeclarationFragment> assignedFields){
  int j=0;
  for (  Expression expression : newVariableInstructions) {
    SimpleName newSimpleName=(SimpleName)expression;
    SimpleName oldSimpleName=(SimpleName)oldVariableInstructions.get(j);
    Expression newParentExpression=null;
    Expression oldParentExpression=null;
    if (newSimpleName.getParent() instanceof QualifiedName) {
      newParentExpression=(QualifiedName)newSimpleName.getParent();
      oldParentExpression=(QualifiedName)oldSimpleName.getParent();
    }
 else     if (newSimpleName.getParent() instanceof FieldAccess) {
      newParentExpression=(FieldAccess)newSimpleName.getParent();
      oldParentExpression=(FieldAccess)oldSimpleName.getParent();
    }
 else {
      newParentExpression=newSimpleName;
      oldParentExpression=oldSimpleName;
    }
    if (newParentExpression.getParent() instanceof Assignment) {
      Assignment newAssignment=(Assignment)newParentExpression.getParent();
      Assignment oldAssignment=(Assignment)oldParentExpression.getParent();
      Expression newLeftHandSide=newAssignment.getLeftHandSide();
      Expression oldLeftHandSide=oldAssignment.getLeftHandSide();
      SimpleName newLeftHandSideName=null;
      SimpleName oldLeftHandSideName=null;
      if (newLeftHandSide instanceof SimpleName) {
        newLeftHandSideName=(SimpleName)newLeftHandSide;
        oldLeftHandSideName=(SimpleName)oldLeftHandSide;
      }
 else       if (newLeftHandSide instanceof QualifiedName) {
        QualifiedName newLeftHandSideQualifiedName=(QualifiedName)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideQualifiedName.getName();
        QualifiedName oldLeftHandSideQualifiedName=(QualifiedName)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideQualifiedName.getName();
      }
 else       if (newLeftHandSide instanceof FieldAccess) {
        FieldAccess newLeftHandSideFieldAccess=(FieldAccess)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideFieldAccess.getName();
        FieldAccess oldLeftHandSideFieldAccess=(FieldAccess)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideFieldAccess.getName();
      }
      Expression newRightHandSide=newAssignment.getRightHandSide();
      Expression oldRightHandSide=oldAssignment.getRightHandSide();
      SimpleName newRightHandSideName=null;
      SimpleName oldRightHandSideName=null;
      if (newRightHandSide instanceof SimpleName) {
        newRightHandSideName=(SimpleName)newRightHandSide;
        oldRightHandSideName=(SimpleName)oldRightHandSide;
      }
 else       if (newRightHandSide instanceof QualifiedName) {
        QualifiedName newRightHandSideQualifiedName=(QualifiedName)newRightHandSide;
        newRightHandSideName=newRightHandSideQualifiedName.getName();
        QualifiedName oldRightHandSideQualifiedName=(QualifiedName)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideQualifiedName.getName();
      }
 else       if (newRightHandSide instanceof FieldAccess) {
        FieldAccess newRightHandSideFieldAccess=(FieldAccess)newRightHandSide;
        newRightHandSideName=newRightHandSideFieldAccess.getName();
        FieldAccess oldRightHandSideFieldAccess=(FieldAccess)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideFieldAccess.getName();
      }
      String invokerName=sourceTypeDeclaration.getName().getIdentifier();
      invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
      if (newLeftHandSideName != null && newLeftHandSideName.equals(newSimpleName)) {
        for (        VariableDeclarationFragment assignedFragment : assignedFields) {
          if (assignedFragment.resolveBinding().isEqualTo(oldLeftHandSideName.resolveBinding())) {
            MethodInvocation leftHandMethodInvocation=subclassAST.newMethodInvocation();
            String leftHandMethodName=assignedFragment.getName().getIdentifier();
            leftHandMethodName=""String_Node_Str"" + leftHandMethodName.substring(0,1).toUpperCase() + leftHandMethodName.substring(1,leftHandMethodName.length());
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(leftHandMethodName),null);
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            ListRewrite methodInvocationArgumentsRewrite=subclassRewriter.getListRewrite(leftHandMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            if (newRightHandSideName != null) {
              boolean accessedFieldFound=false;
              for (              VariableDeclarationFragment accessedFragment : accessedFields) {
                if (accessedFragment.resolveBinding().isEqualTo(oldRightHandSideName.resolveBinding())) {
                  MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
                  String rightHandMethodName=accessedFragment.getName().getIdentifier();
                  rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
                  subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
                  subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
                  methodInvocationArgumentsRewrite.insertLast(rightHandMethodInvocation,null);
                  accessedFieldFound=true;
                  break;
                }
              }
              if (!accessedFieldFound)               methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
 else {
              methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
            subclassRewriter.replace(newAssignment,leftHandMethodInvocation,null);
            break;
          }
        }
      }
      if (newRightHandSideName != null && newRightHandSideName.equals(newSimpleName)) {
        for (        VariableDeclarationFragment accessedFragment : accessedFields) {
          if (accessedFragment.resolveBinding().isEqualTo(oldRightHandSideName.resolveBinding())) {
            MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
            String rightHandMethodName=accessedFragment.getName().getIdentifier();
            rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
            subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
            subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            subclassRewriter.set(newAssignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,rightHandMethodInvocation,null);
            break;
          }
        }
      }
    }
 else {
      for (      VariableDeclarationFragment fragment : accessedFields) {
        if (fragment.resolveBinding().isEqualTo(oldSimpleName.resolveBinding())) {
          MethodInvocation methodInvocation=subclassAST.newMethodInvocation();
          String methodName=fragment.getName().getIdentifier();
          methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
          subclassRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(methodName),null);
          String invokerName=sourceTypeDeclaration.getName().getIdentifier();
          invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
          subclassRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
          subclassRewriter.replace(newSimpleName,methodInvocation,null);
          break;
        }
      }
    }
    j++;
  }
}","private void modifyVariableInstructionsInSubclass(List<Expression> oldVariableInstructions,List<Expression> newVariableInstructions,AST subclassAST,ASTRewrite subclassRewriter,Set<VariableDeclarationFragment> accessedFields,Set<VariableDeclarationFragment> assignedFields){
  int j=0;
  for (  Expression expression : newVariableInstructions) {
    SimpleName newSimpleName=(SimpleName)expression;
    SimpleName oldSimpleName=(SimpleName)oldVariableInstructions.get(j);
    Expression newParentExpression=null;
    Expression oldParentExpression=null;
    if (newSimpleName.getParent() instanceof QualifiedName) {
      newParentExpression=(QualifiedName)newSimpleName.getParent();
      oldParentExpression=(QualifiedName)oldSimpleName.getParent();
    }
 else     if (newSimpleName.getParent() instanceof FieldAccess) {
      newParentExpression=(FieldAccess)newSimpleName.getParent();
      oldParentExpression=(FieldAccess)oldSimpleName.getParent();
    }
 else {
      newParentExpression=newSimpleName;
      oldParentExpression=oldSimpleName;
    }
    if (newParentExpression.getParent() instanceof Assignment) {
      Assignment newAssignment=(Assignment)newParentExpression.getParent();
      Assignment oldAssignment=(Assignment)oldParentExpression.getParent();
      Expression newLeftHandSide=newAssignment.getLeftHandSide();
      Expression oldLeftHandSide=oldAssignment.getLeftHandSide();
      SimpleName newLeftHandSideName=null;
      SimpleName oldLeftHandSideName=null;
      if (newLeftHandSide instanceof SimpleName) {
        newLeftHandSideName=(SimpleName)newLeftHandSide;
        oldLeftHandSideName=(SimpleName)oldLeftHandSide;
      }
 else       if (newLeftHandSide instanceof QualifiedName) {
        QualifiedName newLeftHandSideQualifiedName=(QualifiedName)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideQualifiedName.getName();
        QualifiedName oldLeftHandSideQualifiedName=(QualifiedName)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideQualifiedName.getName();
      }
 else       if (newLeftHandSide instanceof FieldAccess) {
        FieldAccess newLeftHandSideFieldAccess=(FieldAccess)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideFieldAccess.getName();
        FieldAccess oldLeftHandSideFieldAccess=(FieldAccess)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideFieldAccess.getName();
      }
      Expression newRightHandSide=newAssignment.getRightHandSide();
      Expression oldRightHandSide=oldAssignment.getRightHandSide();
      SimpleName newRightHandSideName=null;
      SimpleName oldRightHandSideName=null;
      if (newRightHandSide instanceof SimpleName) {
        newRightHandSideName=(SimpleName)newRightHandSide;
        oldRightHandSideName=(SimpleName)oldRightHandSide;
      }
 else       if (newRightHandSide instanceof QualifiedName) {
        QualifiedName newRightHandSideQualifiedName=(QualifiedName)newRightHandSide;
        newRightHandSideName=newRightHandSideQualifiedName.getName();
        QualifiedName oldRightHandSideQualifiedName=(QualifiedName)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideQualifiedName.getName();
      }
 else       if (newRightHandSide instanceof FieldAccess) {
        FieldAccess newRightHandSideFieldAccess=(FieldAccess)newRightHandSide;
        newRightHandSideName=newRightHandSideFieldAccess.getName();
        FieldAccess oldRightHandSideFieldAccess=(FieldAccess)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideFieldAccess.getName();
      }
      String invokerName=sourceTypeDeclaration.getName().getIdentifier();
      invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
      if (newLeftHandSideName != null && newLeftHandSideName.equals(newSimpleName)) {
        for (        VariableDeclarationFragment assignedFragment : assignedFields) {
          if (assignedFragment.resolveBinding().isEqualTo(oldLeftHandSideName.resolveBinding()) || assignedFragment.getName().getIdentifier().equals(newLeftHandSideName.getIdentifier())) {
            MethodInvocation leftHandMethodInvocation=subclassAST.newMethodInvocation();
            String leftHandMethodName=assignedFragment.getName().getIdentifier();
            leftHandMethodName=""String_Node_Str"" + leftHandMethodName.substring(0,1).toUpperCase() + leftHandMethodName.substring(1,leftHandMethodName.length());
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(leftHandMethodName),null);
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            ListRewrite methodInvocationArgumentsRewrite=subclassRewriter.getListRewrite(leftHandMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            if (newRightHandSideName != null) {
              boolean accessedFieldFound=false;
              for (              VariableDeclarationFragment accessedFragment : accessedFields) {
                if (accessedFragment.resolveBinding().isEqualTo(oldRightHandSideName.resolveBinding()) || accessedFragment.getName().getIdentifier().equals(newRightHandSideName.getIdentifier())) {
                  MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
                  String rightHandMethodName=accessedFragment.getName().getIdentifier();
                  rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
                  subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
                  subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
                  methodInvocationArgumentsRewrite.insertLast(rightHandMethodInvocation,null);
                  accessedFieldFound=true;
                  break;
                }
              }
              if (!accessedFieldFound)               methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
 else {
              methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
            subclassRewriter.replace(newAssignment,leftHandMethodInvocation,null);
            break;
          }
        }
      }
      if (newRightHandSideName != null && newRightHandSideName.equals(newSimpleName)) {
        for (        VariableDeclarationFragment accessedFragment : accessedFields) {
          if (accessedFragment.resolveBinding().isEqualTo(oldRightHandSideName.resolveBinding()) || accessedFragment.getName().getIdentifier().equals(newRightHandSideName.getIdentifier())) {
            MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
            String rightHandMethodName=accessedFragment.getName().getIdentifier();
            rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
            subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
            subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            subclassRewriter.set(newAssignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,rightHandMethodInvocation,null);
            break;
          }
        }
      }
    }
 else {
      for (      VariableDeclarationFragment fragment : accessedFields) {
        if (fragment.resolveBinding().isEqualTo(oldSimpleName.resolveBinding()) || fragment.getName().getIdentifier().equals(newSimpleName.getIdentifier())) {
          MethodInvocation methodInvocation=subclassAST.newMethodInvocation();
          String methodName=fragment.getName().getIdentifier();
          methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
          subclassRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(methodName),null);
          String invokerName=sourceTypeDeclaration.getName().getIdentifier();
          invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
          subclassRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
          subclassRewriter.replace(newSimpleName,methodInvocation,null);
          break;
        }
      }
    }
    j++;
  }
}"
12231,"private void modifyVariableInstructionsInSubclass(List<Expression> oldVariableInstructions,List<Expression> newVariableInstructions,AST subclassAST,ASTRewrite subclassRewriter,Set<VariableDeclarationFragment> accessedFields,Set<VariableDeclarationFragment> assignedFields){
  int j=0;
  for (  Expression expression : newVariableInstructions) {
    SimpleName newSimpleName=(SimpleName)expression;
    SimpleName oldSimpleName=(SimpleName)oldVariableInstructions.get(j);
    Expression newParentExpression=null;
    Expression oldParentExpression=null;
    if (newSimpleName.getParent() instanceof QualifiedName) {
      newParentExpression=(QualifiedName)newSimpleName.getParent();
      oldParentExpression=(QualifiedName)oldSimpleName.getParent();
    }
 else     if (newSimpleName.getParent() instanceof FieldAccess) {
      newParentExpression=(FieldAccess)newSimpleName.getParent();
      oldParentExpression=(FieldAccess)oldSimpleName.getParent();
    }
 else {
      newParentExpression=newSimpleName;
      oldParentExpression=oldSimpleName;
    }
    if (newParentExpression.getParent() instanceof Assignment) {
      Assignment newAssignment=(Assignment)newParentExpression.getParent();
      Assignment oldAssignment=(Assignment)oldParentExpression.getParent();
      Expression newLeftHandSide=newAssignment.getLeftHandSide();
      Expression oldLeftHandSide=oldAssignment.getLeftHandSide();
      SimpleName newLeftHandSideName=null;
      SimpleName oldLeftHandSideName=null;
      if (newLeftHandSide instanceof SimpleName) {
        newLeftHandSideName=(SimpleName)newLeftHandSide;
        oldLeftHandSideName=(SimpleName)oldLeftHandSide;
      }
 else       if (newLeftHandSide instanceof QualifiedName) {
        QualifiedName newLeftHandSideQualifiedName=(QualifiedName)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideQualifiedName.getName();
        QualifiedName oldLeftHandSideQualifiedName=(QualifiedName)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideQualifiedName.getName();
      }
 else       if (newLeftHandSide instanceof FieldAccess) {
        FieldAccess newLeftHandSideFieldAccess=(FieldAccess)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideFieldAccess.getName();
        FieldAccess oldLeftHandSideFieldAccess=(FieldAccess)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideFieldAccess.getName();
      }
      Expression newRightHandSide=newAssignment.getRightHandSide();
      Expression oldRightHandSide=oldAssignment.getRightHandSide();
      SimpleName newRightHandSideName=null;
      SimpleName oldRightHandSideName=null;
      if (newRightHandSide instanceof SimpleName) {
        newRightHandSideName=(SimpleName)newRightHandSide;
        oldRightHandSideName=(SimpleName)oldRightHandSide;
      }
 else       if (newRightHandSide instanceof QualifiedName) {
        QualifiedName newRightHandSideQualifiedName=(QualifiedName)newRightHandSide;
        newRightHandSideName=newRightHandSideQualifiedName.getName();
        QualifiedName oldRightHandSideQualifiedName=(QualifiedName)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideQualifiedName.getName();
      }
 else       if (newRightHandSide instanceof FieldAccess) {
        FieldAccess newRightHandSideFieldAccess=(FieldAccess)newRightHandSide;
        newRightHandSideName=newRightHandSideFieldAccess.getName();
        FieldAccess oldRightHandSideFieldAccess=(FieldAccess)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideFieldAccess.getName();
      }
      String invokerName=sourceTypeDeclaration.getName().getIdentifier();
      invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
      if (newLeftHandSideName != null && newLeftHandSideName.equals(newSimpleName)) {
        for (        VariableDeclarationFragment assignedFragment : assignedFields) {
          if (assignedFragment.resolveBinding().isEqualTo(oldLeftHandSideName.resolveBinding())) {
            MethodInvocation leftHandMethodInvocation=subclassAST.newMethodInvocation();
            String leftHandMethodName=assignedFragment.getName().getIdentifier();
            leftHandMethodName=""String_Node_Str"" + leftHandMethodName.substring(0,1).toUpperCase() + leftHandMethodName.substring(1,leftHandMethodName.length());
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(leftHandMethodName),null);
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            ListRewrite methodInvocationArgumentsRewrite=subclassRewriter.getListRewrite(leftHandMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            if (newRightHandSideName != null) {
              boolean accessedFieldFound=false;
              for (              VariableDeclarationFragment accessedFragment : accessedFields) {
                if (accessedFragment.resolveBinding().isEqualTo(oldRightHandSideName.resolveBinding())) {
                  MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
                  String rightHandMethodName=accessedFragment.getName().getIdentifier();
                  rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
                  subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
                  subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
                  methodInvocationArgumentsRewrite.insertLast(rightHandMethodInvocation,null);
                  accessedFieldFound=true;
                  break;
                }
              }
              if (!accessedFieldFound)               methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
 else {
              methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
            subclassRewriter.replace(newAssignment,leftHandMethodInvocation,null);
            break;
          }
        }
      }
      if (newRightHandSideName != null && newRightHandSideName.equals(newSimpleName)) {
        for (        VariableDeclarationFragment accessedFragment : accessedFields) {
          if (accessedFragment.resolveBinding().isEqualTo(oldRightHandSideName.resolveBinding())) {
            MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
            String rightHandMethodName=accessedFragment.getName().getIdentifier();
            rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
            subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
            subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            subclassRewriter.set(newAssignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,rightHandMethodInvocation,null);
            break;
          }
        }
      }
    }
 else {
      for (      VariableDeclarationFragment fragment : accessedFields) {
        if (fragment.resolveBinding().isEqualTo(oldSimpleName.resolveBinding())) {
          MethodInvocation methodInvocation=subclassAST.newMethodInvocation();
          String methodName=fragment.getName().getIdentifier();
          methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
          subclassRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(methodName),null);
          String invokerName=sourceTypeDeclaration.getName().getIdentifier();
          invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
          subclassRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
          subclassRewriter.replace(newSimpleName,methodInvocation,null);
          break;
        }
      }
    }
    j++;
  }
}","private void modifyVariableInstructionsInSubclass(List<Expression> oldVariableInstructions,List<Expression> newVariableInstructions,AST subclassAST,ASTRewrite subclassRewriter,Set<VariableDeclarationFragment> accessedFields,Set<VariableDeclarationFragment> assignedFields){
  int j=0;
  for (  Expression expression : newVariableInstructions) {
    SimpleName newSimpleName=(SimpleName)expression;
    SimpleName oldSimpleName=(SimpleName)oldVariableInstructions.get(j);
    Expression newParentExpression=null;
    Expression oldParentExpression=null;
    if (newSimpleName.getParent() instanceof QualifiedName) {
      newParentExpression=(QualifiedName)newSimpleName.getParent();
      oldParentExpression=(QualifiedName)oldSimpleName.getParent();
    }
 else     if (newSimpleName.getParent() instanceof FieldAccess) {
      newParentExpression=(FieldAccess)newSimpleName.getParent();
      oldParentExpression=(FieldAccess)oldSimpleName.getParent();
    }
 else {
      newParentExpression=newSimpleName;
      oldParentExpression=oldSimpleName;
    }
    if (newParentExpression.getParent() instanceof Assignment) {
      Assignment newAssignment=(Assignment)newParentExpression.getParent();
      Assignment oldAssignment=(Assignment)oldParentExpression.getParent();
      Expression newLeftHandSide=newAssignment.getLeftHandSide();
      Expression oldLeftHandSide=oldAssignment.getLeftHandSide();
      SimpleName newLeftHandSideName=null;
      SimpleName oldLeftHandSideName=null;
      if (newLeftHandSide instanceof SimpleName) {
        newLeftHandSideName=(SimpleName)newLeftHandSide;
        oldLeftHandSideName=(SimpleName)oldLeftHandSide;
      }
 else       if (newLeftHandSide instanceof QualifiedName) {
        QualifiedName newLeftHandSideQualifiedName=(QualifiedName)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideQualifiedName.getName();
        QualifiedName oldLeftHandSideQualifiedName=(QualifiedName)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideQualifiedName.getName();
      }
 else       if (newLeftHandSide instanceof FieldAccess) {
        FieldAccess newLeftHandSideFieldAccess=(FieldAccess)newLeftHandSide;
        newLeftHandSideName=newLeftHandSideFieldAccess.getName();
        FieldAccess oldLeftHandSideFieldAccess=(FieldAccess)oldLeftHandSide;
        oldLeftHandSideName=oldLeftHandSideFieldAccess.getName();
      }
      Expression newRightHandSide=newAssignment.getRightHandSide();
      Expression oldRightHandSide=oldAssignment.getRightHandSide();
      SimpleName newRightHandSideName=null;
      SimpleName oldRightHandSideName=null;
      if (newRightHandSide instanceof SimpleName) {
        newRightHandSideName=(SimpleName)newRightHandSide;
        oldRightHandSideName=(SimpleName)oldRightHandSide;
      }
 else       if (newRightHandSide instanceof QualifiedName) {
        QualifiedName newRightHandSideQualifiedName=(QualifiedName)newRightHandSide;
        newRightHandSideName=newRightHandSideQualifiedName.getName();
        QualifiedName oldRightHandSideQualifiedName=(QualifiedName)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideQualifiedName.getName();
      }
 else       if (newRightHandSide instanceof FieldAccess) {
        FieldAccess newRightHandSideFieldAccess=(FieldAccess)newRightHandSide;
        newRightHandSideName=newRightHandSideFieldAccess.getName();
        FieldAccess oldRightHandSideFieldAccess=(FieldAccess)oldRightHandSide;
        oldRightHandSideName=oldRightHandSideFieldAccess.getName();
      }
      String invokerName=sourceTypeDeclaration.getName().getIdentifier();
      invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
      if (newLeftHandSideName != null && newLeftHandSideName.equals(newSimpleName)) {
        for (        VariableDeclarationFragment assignedFragment : assignedFields) {
          if (assignedFragment.resolveBinding().isEqualTo(oldLeftHandSideName.resolveBinding()) || assignedFragment.getName().getIdentifier().equals(newLeftHandSideName.getIdentifier())) {
            MethodInvocation leftHandMethodInvocation=subclassAST.newMethodInvocation();
            String leftHandMethodName=assignedFragment.getName().getIdentifier();
            leftHandMethodName=""String_Node_Str"" + leftHandMethodName.substring(0,1).toUpperCase() + leftHandMethodName.substring(1,leftHandMethodName.length());
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(leftHandMethodName),null);
            subclassRewriter.set(leftHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            ListRewrite methodInvocationArgumentsRewrite=subclassRewriter.getListRewrite(leftHandMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            if (newRightHandSideName != null) {
              boolean accessedFieldFound=false;
              for (              VariableDeclarationFragment accessedFragment : accessedFields) {
                if (accessedFragment.resolveBinding().isEqualTo(oldRightHandSideName.resolveBinding()) || accessedFragment.getName().getIdentifier().equals(newRightHandSideName.getIdentifier())) {
                  MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
                  String rightHandMethodName=accessedFragment.getName().getIdentifier();
                  rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
                  subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
                  subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
                  methodInvocationArgumentsRewrite.insertLast(rightHandMethodInvocation,null);
                  accessedFieldFound=true;
                  break;
                }
              }
              if (!accessedFieldFound)               methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
 else {
              methodInvocationArgumentsRewrite.insertLast(newAssignment.getRightHandSide(),null);
            }
            subclassRewriter.replace(newAssignment,leftHandMethodInvocation,null);
            break;
          }
        }
      }
      if (newRightHandSideName != null && newRightHandSideName.equals(newSimpleName)) {
        for (        VariableDeclarationFragment accessedFragment : accessedFields) {
          if (accessedFragment.resolveBinding().isEqualTo(oldRightHandSideName.resolveBinding()) || accessedFragment.getName().getIdentifier().equals(newRightHandSideName.getIdentifier())) {
            MethodInvocation rightHandMethodInvocation=subclassAST.newMethodInvocation();
            String rightHandMethodName=accessedFragment.getName().getIdentifier();
            rightHandMethodName=""String_Node_Str"" + rightHandMethodName.substring(0,1).toUpperCase() + rightHandMethodName.substring(1,rightHandMethodName.length());
            subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(rightHandMethodName),null);
            subclassRewriter.set(rightHandMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
            subclassRewriter.set(newAssignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,rightHandMethodInvocation,null);
            break;
          }
        }
      }
    }
 else {
      for (      VariableDeclarationFragment fragment : accessedFields) {
        if (fragment.resolveBinding().isEqualTo(oldSimpleName.resolveBinding()) || fragment.getName().getIdentifier().equals(newSimpleName.getIdentifier())) {
          MethodInvocation methodInvocation=subclassAST.newMethodInvocation();
          String methodName=fragment.getName().getIdentifier();
          methodName=""String_Node_Str"" + methodName.substring(0,1).toUpperCase() + methodName.substring(1,methodName.length());
          subclassRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,subclassAST.newSimpleName(methodName),null);
          String invokerName=sourceTypeDeclaration.getName().getIdentifier();
          invokerName=invokerName.substring(0,1).toLowerCase() + invokerName.substring(1,invokerName.length());
          subclassRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,subclassAST.newSimpleName(invokerName),null);
          subclassRewriter.replace(newSimpleName,methodInvocation,null);
          break;
        }
      }
    }
    j++;
  }
}"
12232,"public void applySourceFirst(){
  if (leaveDelegate) {
    addDelegationInSourceMethod();
  }
 else {
    removeSourceMethod();
  }
  modifyMovedMethodInvocationInSourceClass();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit undoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  addRequiredTargetImportDeclarations();
  createMovedMethod();
  moveAdditionalMethods();
  modifyMovedMethodInvocationInTargetClass();
  ITextFileBuffer targetTextFileBuffer=bufferManager.getTextFileBuffer(targetFile.getFullPath(),LocationKind.IFILE);
  IDocument targetDocument=targetTextFileBuffer.getDocument();
  TextEdit targetEdit=targetRewriter.rewriteAST(targetDocument,null);
  try {
    UndoEdit undoEdit=targetEdit.apply(targetDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(targetFile,targetDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","public void applySourceFirst(){
  if (!sourceCompilationUnit.equals(targetCompilationUnit))   addRequiredTargetImportDeclarations();
  createMovedMethod();
  moveAdditionalMethods();
  modifyMovedMethodInvocationInTargetClass();
  if (leaveDelegate) {
    addDelegationInSourceMethod();
  }
 else {
    removeSourceMethod();
  }
  modifyMovedMethodInvocationInSourceClass();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit undoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  ITextFileBuffer targetTextFileBuffer=bufferManager.getTextFileBuffer(targetFile.getFullPath(),LocationKind.IFILE);
  IDocument targetDocument=targetTextFileBuffer.getDocument();
  TextEdit targetEdit=targetRewriter.rewriteAST(targetDocument,null);
  try {
    UndoEdit undoEdit=targetEdit.apply(targetDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(targetFile,targetDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12233,"public void applyTargetFirst(){
  addRequiredTargetImportDeclarations();
  createMovedMethod();
  moveAdditionalMethods();
  modifyMovedMethodInvocationInTargetClass();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer targetTextFileBuffer=bufferManager.getTextFileBuffer(targetFile.getFullPath(),LocationKind.IFILE);
  IDocument targetDocument=targetTextFileBuffer.getDocument();
  TextEdit targetEdit=targetRewriter.rewriteAST(targetDocument,null);
  try {
    UndoEdit undoEdit=targetEdit.apply(targetDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(targetFile,targetDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  if (leaveDelegate) {
    addDelegationInSourceMethod();
  }
 else {
    removeSourceMethod();
  }
  modifyMovedMethodInvocationInSourceClass();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit undoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","public void applyTargetFirst(){
  if (!sourceCompilationUnit.equals(targetCompilationUnit))   addRequiredTargetImportDeclarations();
  createMovedMethod();
  moveAdditionalMethods();
  modifyMovedMethodInvocationInTargetClass();
  if (leaveDelegate) {
    addDelegationInSourceMethod();
  }
 else {
    removeSourceMethod();
  }
  modifyMovedMethodInvocationInSourceClass();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer targetTextFileBuffer=bufferManager.getTextFileBuffer(targetFile.getFullPath(),LocationKind.IFILE);
  IDocument targetDocument=targetTextFileBuffer.getDocument();
  TextEdit targetEdit=targetRewriter.rewriteAST(targetDocument,null);
  try {
    UndoEdit undoEdit=targetEdit.apply(targetDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(targetFile,targetDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit undoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12234,"public List<TypeCheckElimination> generateTypeCheckEliminations(){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> switchStatements=statementExtractor.getSwitchStatements(compositeStatement.getStatement());
  for (  Statement statement : switchStatements) {
    SwitchStatement switchStatement=(SwitchStatement)statement;
    TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
    typeCheckElimination.setTypeCheckCodeFragment(switchStatement);
    List<Statement> statements=switchStatement.statements();
    Expression switchCaseExpression=null;
    boolean isDefaultCase=false;
    for (    Statement statement2 : statements) {
      if (statement2 instanceof SwitchCase) {
        SwitchCase switchCase=(SwitchCase)statement2;
        switchCaseExpression=switchCase.getExpression();
        isDefaultCase=switchCase.isDefault();
      }
 else {
        if (!isDefaultCase) {
          if (!(statement2 instanceof BreakStatement))           typeCheckElimination.addTypeCheck(switchCaseExpression,statement2);
        }
 else {
          if (!(statement2 instanceof BreakStatement))           typeCheckElimination.addDefaultCaseStatement(statement2);
        }
      }
    }
    typeCheckEliminations.add(typeCheckElimination);
  }
  List<Statement> ifStatements=statementExtractor.getIfStatements(compositeStatement.getStatement());
  TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
  int i=0;
  for (  Statement statement : ifStatements) {
    IfStatement ifStatement=(IfStatement)statement;
    Expression ifExpression=ifStatement.getExpression();
    Statement thenStatement=ifStatement.getThenStatement();
    if (thenStatement instanceof Block) {
      Block block=(Block)thenStatement;
      List<Statement> statements=block.statements();
      for (      Statement statement2 : statements) {
        typeCheckElimination.addTypeCheck(ifExpression,statement2);
      }
    }
 else {
      typeCheckElimination.addTypeCheck(ifExpression,thenStatement);
    }
    Statement elseStatement=ifStatement.getElseStatement();
    if (elseStatement instanceof Block) {
      Block block=(Block)elseStatement;
      List<Statement> statements=block.statements();
      for (      Statement statement2 : statements) {
        typeCheckElimination.addDefaultCaseStatement(statement2);
      }
    }
 else     if (!(elseStatement instanceof IfStatement)) {
      typeCheckElimination.addDefaultCaseStatement(elseStatement);
    }
    if (ifStatements.size() - 1 > i) {
      IfStatement nextIfStatement=(IfStatement)ifStatements.get(i + 1);
      if (!ifStatement.getParent().equals(nextIfStatement)) {
        typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
        typeCheckEliminations.add(typeCheckElimination);
        typeCheckElimination=new TypeCheckElimination();
      }
    }
 else {
      typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
      typeCheckEliminations.add(typeCheckElimination);
    }
    i++;
  }
  return typeCheckEliminations;
}","public List<TypeCheckElimination> generateTypeCheckEliminations(){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> switchStatements=statementExtractor.getSwitchStatements(compositeStatement.getStatement());
  for (  Statement statement : switchStatements) {
    SwitchStatement switchStatement=(SwitchStatement)statement;
    TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
    typeCheckElimination.setTypeCheckCodeFragment(switchStatement);
    List<Statement> statements=switchStatement.statements();
    Expression switchCaseExpression=null;
    boolean isDefaultCase=false;
    for (    Statement statement2 : statements) {
      if (statement2 instanceof SwitchCase) {
        SwitchCase switchCase=(SwitchCase)statement2;
        switchCaseExpression=switchCase.getExpression();
        isDefaultCase=switchCase.isDefault();
      }
 else {
        if (!isDefaultCase) {
          if (!(statement2 instanceof BreakStatement))           typeCheckElimination.addTypeCheck(switchCaseExpression,statement2);
        }
 else {
          if (!(statement2 instanceof BreakStatement))           typeCheckElimination.addDefaultCaseStatement(statement2);
        }
      }
    }
    typeCheckEliminations.add(typeCheckElimination);
  }
  List<Statement> ifStatements=statementExtractor.getIfStatements(compositeStatement.getStatement());
  TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
  int i=0;
  for (  Statement statement : ifStatements) {
    IfStatement ifStatement=(IfStatement)statement;
    Expression ifExpression=ifStatement.getExpression();
    Statement thenStatement=ifStatement.getThenStatement();
    if (thenStatement instanceof Block) {
      Block block=(Block)thenStatement;
      List<Statement> statements=block.statements();
      for (      Statement statement2 : statements) {
        typeCheckElimination.addTypeCheck(ifExpression,statement2);
      }
    }
 else {
      typeCheckElimination.addTypeCheck(ifExpression,thenStatement);
    }
    Statement elseStatement=ifStatement.getElseStatement();
    if (elseStatement != null) {
      if (elseStatement instanceof Block) {
        Block block=(Block)elseStatement;
        List<Statement> statements=block.statements();
        for (        Statement statement2 : statements) {
          typeCheckElimination.addDefaultCaseStatement(statement2);
        }
      }
 else       if (!(elseStatement instanceof IfStatement)) {
        typeCheckElimination.addDefaultCaseStatement(elseStatement);
      }
    }
    if (ifStatements.size() - 1 > i) {
      IfStatement nextIfStatement=(IfStatement)ifStatements.get(i + 1);
      if (!ifStatement.getParent().equals(nextIfStatement)) {
        typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
        typeCheckEliminations.add(typeCheckElimination);
        typeCheckElimination=new TypeCheckElimination();
      }
    }
 else {
      typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
      typeCheckEliminations.add(typeCheckElimination);
    }
    i++;
  }
  return typeCheckEliminations;
}"
12235,"private void modifyContext(){
  AST contextAST=sourceTypeDeclaration.getAST();
  ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  VariableDeclarationFragment typeFragment=contextAST.newVariableDeclarationFragment();
  sourceRewriter.set(typeFragment,VariableDeclarationFragment.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
  FieldDeclaration typeFieldDeclaration=contextAST.newFieldDeclaration(typeFragment);
  sourceRewriter.set(typeFieldDeclaration,FieldDeclaration.TYPE_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getAbstractClassName()),null);
  ListRewrite typeFieldDeclrationModifiersRewrite=sourceRewriter.getListRewrite(typeFieldDeclaration,FieldDeclaration.MODIFIERS2_PROPERTY);
  typeFieldDeclrationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD),null);
  contextBodyRewrite.insertFirst(typeFieldDeclaration,null);
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  for (  FieldDeclaration fieldDeclaration : fieldDeclarations) {
    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      if (fragment.equals(typeCheckElimination.getTypeField())) {
        if (fragments.size() == 1) {
          contextBodyRewrite.remove(fragment.getParent(),null);
        }
 else {
          ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(fragment.getParent(),FieldDeclaration.FRAGMENTS_PROPERTY);
          fragmentRewrite.remove(fragment,null);
        }
      }
    }
  }
  modifyTypeFieldAssignmentsInContextClass();
  MethodDeclaration setterMethod=typeCheckElimination.getTypeFieldSetterMethod();
  SwitchStatement switchStatement=contextAST.newSwitchStatement();
  List<SimpleName> staticFieldNames=typeCheckElimination.getStaticFields();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  ListRewrite switchStatementStatementsRewrite=sourceRewriter.getListRewrite(switchStatement,SwitchStatement.STATEMENTS_PROPERTY);
  int i=0;
  for (  SimpleName staticFieldName : staticFieldNames) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,staticFieldName,null);
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(subclassNames.get(i)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
    i++;
  }
  for (  String staticFieldName : additionalStaticFields.keySet()) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,contextAST.newSimpleName(staticFieldName),null);
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(additionalStaticFields.get(staticFieldName)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
  }
  if (setterMethod != null) {
    List<SingleVariableDeclaration> setterMethodParameters=setterMethod.parameters();
    if (setterMethodParameters.size() == 1) {
      sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,setterMethodParameters.get(0).getName(),null);
    }
    Block setterMethodBody=setterMethod.getBody();
    List<Statement> setterMethodBodyStatements=setterMethodBody.statements();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    if (setterMethodBodyStatements.size() == 1) {
      setterMethodBodyRewrite.replace(setterMethodBodyStatements.get(0),switchStatement,null);
    }
  }
 else {
    MethodDeclaration setterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,contextAST.newPrimitiveType(PrimitiveType.VOID),null);
    ListRewrite setterMethodModifiersRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    setterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite setterMethodParameterRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    SingleVariableDeclaration parameter=contextAST.newSingleVariableDeclaration();
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type parameterType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,typeField.getName(),null);
    setterMethodParameterRewrite.insertLast(parameter,null);
    sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,typeField.getName(),null);
    Block setterMethodBody=contextAST.newBlock();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    setterMethodBodyRewrite.insertLast(switchStatement,null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,setterMethodBody,null);
    contextBodyRewrite.insertLast(setterMethodDeclaration,null);
  }
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  if (getterMethod != null) {
    Block getterMethodBody=getterMethod.getBody();
    List<Statement> getterMethodBodyStatements=getterMethodBody.statements();
    ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
    if (getterMethodBodyStatements.size() == 1) {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
      sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,getterMethod.getName(),null);
      sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
      getterMethodBodyRewrite.replace(getterMethodBodyStatements.get(0),returnStatement,null);
    }
  }
 else {
    MethodDeclaration getterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type returnType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    ListRewrite getterMethodModifiersRewrite=sourceRewriter.getListRewrite(getterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    getterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ReturnStatement returnStatement=contextAST.newReturnStatement();
    MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
    Block getterMethodBody=contextAST.newBlock();
    ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
    getterMethodBodyRewrite.insertLast(returnStatement,null);
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,getterMethodBody,null);
    contextBodyRewrite.insertLast(getterMethodDeclaration,null);
  }
  MethodDeclaration typeCheckMethod=typeCheckElimination.getTypeCheckMethod();
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  Type typeCheckMethodReturnType=typeCheckMethod.getReturnType2();
  if (typeCheckMethodReturnType.isPrimitiveType() && ((PrimitiveType)typeCheckMethodReturnType).getPrimitiveTypeCode().equals(PrimitiveType.VOID)) {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    ExpressionStatement expressionStatement=contextAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    if (returnedVariable != null) {
      Assignment assignment=contextAST.newAssignment();
      sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
      ExpressionStatement expressionStatement=contextAST.newExpressionStatement(assignment);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
    }
 else {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractMethodInvocation,null);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),returnStatement,null);
    }
  }
  generateGettersForAccessedFields();
  generateSettersForAssignedFields();
  setPublicModifierToStaticFields();
  modifyTypeFieldAccessesInContextClass();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","private void modifyContext(){
  AST contextAST=sourceTypeDeclaration.getAST();
  ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  VariableDeclarationFragment typeFragment=contextAST.newVariableDeclarationFragment();
  sourceRewriter.set(typeFragment,VariableDeclarationFragment.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
  FieldDeclaration typeFieldDeclaration=contextAST.newFieldDeclaration(typeFragment);
  sourceRewriter.set(typeFieldDeclaration,FieldDeclaration.TYPE_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getAbstractClassName()),null);
  ListRewrite typeFieldDeclrationModifiersRewrite=sourceRewriter.getListRewrite(typeFieldDeclaration,FieldDeclaration.MODIFIERS2_PROPERTY);
  typeFieldDeclrationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD),null);
  contextBodyRewrite.insertFirst(typeFieldDeclaration,null);
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  for (  FieldDeclaration fieldDeclaration : fieldDeclarations) {
    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      if (fragment.equals(typeCheckElimination.getTypeField())) {
        if (fragments.size() == 1) {
          contextBodyRewrite.remove(fragment.getParent(),null);
        }
 else {
          ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(fragment.getParent(),FieldDeclaration.FRAGMENTS_PROPERTY);
          fragmentRewrite.remove(fragment,null);
        }
      }
    }
  }
  modifyTypeFieldAssignmentsInContextClass();
  MethodDeclaration setterMethod=typeCheckElimination.getTypeFieldSetterMethod();
  SwitchStatement switchStatement=contextAST.newSwitchStatement();
  List<SimpleName> staticFieldNames=typeCheckElimination.getStaticFields();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  ListRewrite switchStatementStatementsRewrite=sourceRewriter.getListRewrite(switchStatement,SwitchStatement.STATEMENTS_PROPERTY);
  int i=0;
  for (  SimpleName staticFieldName : staticFieldNames) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,staticFieldName,null);
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(subclassNames.get(i)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
    i++;
  }
  for (  String staticFieldName : additionalStaticFields.keySet()) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,contextAST.newSimpleName(staticFieldName),null);
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(additionalStaticFields.get(staticFieldName)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    switchStatementStatementsRewrite.insertLast(contextAST.newBreakStatement(),null);
  }
  if (setterMethod != null) {
    List<SingleVariableDeclaration> setterMethodParameters=setterMethod.parameters();
    if (setterMethodParameters.size() == 1) {
      sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,setterMethodParameters.get(0).getName(),null);
    }
    Block setterMethodBody=setterMethod.getBody();
    List<Statement> setterMethodBodyStatements=setterMethodBody.statements();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    if (setterMethodBodyStatements.size() == 1) {
      setterMethodBodyRewrite.replace(setterMethodBodyStatements.get(0),switchStatement,null);
    }
  }
 else {
    MethodDeclaration setterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,contextAST.newPrimitiveType(PrimitiveType.VOID),null);
    ListRewrite setterMethodModifiersRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    setterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite setterMethodParameterRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    SingleVariableDeclaration parameter=contextAST.newSingleVariableDeclaration();
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type parameterType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,typeField.getName(),null);
    setterMethodParameterRewrite.insertLast(parameter,null);
    sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,typeField.getName(),null);
    Block setterMethodBody=contextAST.newBlock();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    setterMethodBodyRewrite.insertLast(switchStatement,null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,setterMethodBody,null);
    contextBodyRewrite.insertLast(setterMethodDeclaration,null);
  }
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  if (getterMethod != null) {
    Block getterMethodBody=getterMethod.getBody();
    List<Statement> getterMethodBodyStatements=getterMethodBody.statements();
    ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
    if (getterMethodBodyStatements.size() == 1) {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
      sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,getterMethod.getName(),null);
      sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
      getterMethodBodyRewrite.replace(getterMethodBodyStatements.get(0),returnStatement,null);
    }
  }
 else {
    MethodDeclaration getterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type returnType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    ListRewrite getterMethodModifiersRewrite=sourceRewriter.getListRewrite(getterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    getterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ReturnStatement returnStatement=contextAST.newReturnStatement();
    MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
    Block getterMethodBody=contextAST.newBlock();
    ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
    getterMethodBodyRewrite.insertLast(returnStatement,null);
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,getterMethodBody,null);
    contextBodyRewrite.insertLast(getterMethodDeclaration,null);
  }
  MethodDeclaration typeCheckMethod=typeCheckElimination.getTypeCheckMethod();
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  Type typeCheckMethodReturnType=typeCheckMethod.getReturnType2();
  if (typeCheckMethodReturnType.isPrimitiveType() && ((PrimitiveType)typeCheckMethodReturnType).getPrimitiveTypeCode().equals(PrimitiveType.VOID)) {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    ExpressionStatement expressionStatement=contextAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    if (returnedVariable != null) {
      Assignment assignment=contextAST.newAssignment();
      sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
      ExpressionStatement expressionStatement=contextAST.newExpressionStatement(assignment);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
    }
 else {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractMethodInvocation,null);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),returnStatement,null);
    }
  }
  generateGettersForAccessedFields();
  generateSettersForAssignedFields();
  setPublicModifierToStaticFields();
  setPublicModifierToAccessedMethods();
  modifyTypeFieldAccessesInContextClass();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12236,"private void modifyInheritanceHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  PackageDeclaration contextPackageDeclaration=sourceCompilationUnit.getPackage();
  IContainer rootContainer=contextContainer;
  if (contextPackageDeclaration != null) {
    String packageName=contextPackageDeclaration.getName().getFullyQualifiedName();
    String[] subPackages=packageName.split(""String_Node_Str"");
    for (int i=0; i < subPackages.length; i++)     rootContainer=(IContainer)rootContainer.getParent();
  }
  String abstractClassFullyQualifiedName=typeCheckElimination.getAbstractClassName();
  IFile abstractClassFile=getFile(rootContainer,abstractClassFullyQualifiedName);
  IJavaElement abstractJavaElement=JavaCore.create(abstractClassFile);
  ITextEditor abstractEditor=null;
  try {
    abstractEditor=(ITextEditor)JavaUI.openInEditor(abstractJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit abstractICompilationUnit=(ICompilationUnit)abstractJavaElement;
  ASTParser abstractParser=ASTParser.newParser(AST.JLS3);
  abstractParser.setKind(ASTParser.K_COMPILATION_UNIT);
  abstractParser.setSource(abstractICompilationUnit);
  abstractParser.setResolveBindings(true);
  CompilationUnit abstractCompilationUnit=(CompilationUnit)abstractParser.createAST(null);
  AST abstractAST=abstractCompilationUnit.getAST();
  ASTRewrite abstractRewriter=ASTRewrite.create(abstractAST);
  TypeDeclaration abstractClassTypeDeclaration=null;
  List<AbstractTypeDeclaration> abstractTypeDeclarations=abstractCompilationUnit.types();
  for (  AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
    if (abstractTypeDeclaration instanceof TypeDeclaration) {
      TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
      if (typeDeclaration.resolveBinding().getQualifiedName().equals(typeCheckElimination.getAbstractClassName())) {
        abstractClassTypeDeclaration=typeDeclaration;
        break;
      }
    }
  }
  int abstractClassModifiers=abstractClassTypeDeclaration.getModifiers();
  if ((abstractClassModifiers & Modifier.ABSTRACT) == 0) {
    ListRewrite abstractModifiersRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    abstractModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite abstractBodyRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration abstractMethodDeclaration=abstractAST.newMethodDeclaration();
  String abstractMethodName=typeCheckElimination.getTypeCheckMethodName();
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(abstractMethodName),null);
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
  ListRewrite abstractMethodModifiersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  if (typeCheckElimination.getAccessedFields().size() > 0) {
    SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
    SimpleName parameterType=abstractAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,abstractAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(abstractAST.newSimpleName(typeBinding.getName()),null);
  }
  abstractBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,abstractCompilationUnit,abstractRewriter);
  }
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer abstractTextFileBuffer=bufferManager.getTextFileBuffer(abstractClassFile.getFullPath(),LocationKind.IFILE);
  IDocument abstractDocument=abstractTextFileBuffer.getDocument();
  TextEdit abstractEdit=abstractRewriter.rewriteAST(abstractDocument,null);
  try {
    UndoEdit abstractUndoEdit=abstractEdit.apply(abstractDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(abstractClassFile,abstractDocument,abstractUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  abstractEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  DefaultMutableTreeNode root=typeCheckElimination.getExistingInheritanceTree().getRootNode();
  Enumeration<DefaultMutableTreeNode> enumeration=root.children();
  while (enumeration.hasMoreElements()) {
    DefaultMutableTreeNode child=enumeration.nextElement();
    String childClassName=(String)child.getUserObject();
    if (!subclassNames.contains(childClassName))     subclassNames.add(childClassName);
  }
  List<DefaultMutableTreeNode> remainingIfStatementExpressions=typeCheckElimination.getRemainingIfStatementExpressions();
  for (int i=0; i < subclassNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      remainingIfStatementExpression=remainingIfStatementExpressions.get(i);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=getFile(rootContainer,subclassNames.get(i));
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    TypeDeclaration subclassTypeDeclaration=null;
    List<AbstractTypeDeclaration> subclassAbstractTypeDeclarations=subclassCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : subclassAbstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.resolveBinding().getQualifiedName().equals(subclassNames.get(i))) {
          subclassTypeDeclaration=typeDeclaration;
          break;
        }
      }
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    String concreteMethodName=typeCheckElimination.getTypeCheckMethodName();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(concreteMethodName),null);
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
    Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
    Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,subclassRewriter,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    if (returnedVariable != null) {
      VariableDeclarationFragment variableDeclarationFragment=subclassAST.newVariableDeclarationFragment();
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariable.getName(),null);
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,returnedVariable.getInitializer(),null);
      VariableDeclarationStatement variableDeclarationStatement=subclassAST.newVariableDeclarationStatement(variableDeclarationFragment);
      subclassRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertFirst(variableDeclarationStatement,null);
 else       concreteMethodBodyRewrite.insertFirst(variableDeclarationStatement,null);
    }
    SimpleName invokerSimpleName=null;
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      boolean insert=true;
      if (statement instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)statement;
        List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
        VariableDeclarationFragment fragment=fragments.get(0);
        if (fragment.getInitializer() instanceof CastExpression) {
          CastExpression castExpression=(CastExpression)fragment.getInitializer();
          if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
            invokerSimpleName=fragment.getName();
            insert=false;
          }
        }
      }
      if (invokerSimpleName != null) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(newStatement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            Expression methodInvocationExpression=methodInvocation.getExpression();
            if (methodInvocationExpression instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)methodInvocationExpression;
              if (simpleName.getIdentifier().equals(invokerSimpleName.getIdentifier())) {
                subclassRewriter.remove(simpleName,null);
              }
            }
          }
        }
      }
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      if (insert) {
        if (ifStatementBodyRewrite != null)         ifStatementBodyRewrite.insertLast(newStatement,null);
 else         concreteMethodBodyRewrite.insertLast(newStatement,null);
      }
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(returnStatement,null);
 else       concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}","private void modifyInheritanceHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  PackageDeclaration contextPackageDeclaration=sourceCompilationUnit.getPackage();
  IContainer rootContainer=contextContainer;
  if (contextPackageDeclaration != null) {
    String packageName=contextPackageDeclaration.getName().getFullyQualifiedName();
    String[] subPackages=packageName.split(""String_Node_Str"");
    for (int i=0; i < subPackages.length; i++)     rootContainer=(IContainer)rootContainer.getParent();
  }
  String abstractClassFullyQualifiedName=typeCheckElimination.getAbstractClassName();
  IFile abstractClassFile=getFile(rootContainer,abstractClassFullyQualifiedName);
  IJavaElement abstractJavaElement=JavaCore.create(abstractClassFile);
  ITextEditor abstractEditor=null;
  try {
    abstractEditor=(ITextEditor)JavaUI.openInEditor(abstractJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit abstractICompilationUnit=(ICompilationUnit)abstractJavaElement;
  ASTParser abstractParser=ASTParser.newParser(AST.JLS3);
  abstractParser.setKind(ASTParser.K_COMPILATION_UNIT);
  abstractParser.setSource(abstractICompilationUnit);
  abstractParser.setResolveBindings(true);
  CompilationUnit abstractCompilationUnit=(CompilationUnit)abstractParser.createAST(null);
  AST abstractAST=abstractCompilationUnit.getAST();
  ASTRewrite abstractRewriter=ASTRewrite.create(abstractAST);
  TypeDeclaration abstractClassTypeDeclaration=null;
  List<AbstractTypeDeclaration> abstractTypeDeclarations=abstractCompilationUnit.types();
  for (  AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
    if (abstractTypeDeclaration instanceof TypeDeclaration) {
      TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
      if (typeDeclaration.resolveBinding().getQualifiedName().equals(typeCheckElimination.getAbstractClassName())) {
        abstractClassTypeDeclaration=typeDeclaration;
        break;
      }
    }
  }
  int abstractClassModifiers=abstractClassTypeDeclaration.getModifiers();
  if ((abstractClassModifiers & Modifier.ABSTRACT) == 0) {
    ListRewrite abstractModifiersRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    abstractModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite abstractBodyRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration abstractMethodDeclaration=abstractAST.newMethodDeclaration();
  String abstractMethodName=typeCheckElimination.getTypeCheckMethodName();
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(abstractMethodName),null);
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
  ListRewrite abstractMethodModifiersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  if (typeCheckElimination.getAccessedFields().size() > 0) {
    SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
    SimpleName parameterType=abstractAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,abstractAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(abstractAST.newSimpleName(typeBinding.getName()),null);
  }
  abstractBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,abstractCompilationUnit,abstractRewriter);
  }
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer abstractTextFileBuffer=bufferManager.getTextFileBuffer(abstractClassFile.getFullPath(),LocationKind.IFILE);
  IDocument abstractDocument=abstractTextFileBuffer.getDocument();
  TextEdit abstractEdit=abstractRewriter.rewriteAST(abstractDocument,null);
  try {
    UndoEdit abstractUndoEdit=abstractEdit.apply(abstractDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(abstractClassFile,abstractDocument,abstractUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  abstractEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  DefaultMutableTreeNode root=typeCheckElimination.getExistingInheritanceTree().getRootNode();
  Enumeration<DefaultMutableTreeNode> enumeration=root.children();
  while (enumeration.hasMoreElements()) {
    DefaultMutableTreeNode child=enumeration.nextElement();
    String childClassName=(String)child.getUserObject();
    if (!subclassNames.contains(childClassName))     subclassNames.add(childClassName);
  }
  List<DefaultMutableTreeNode> remainingIfStatementExpressions=typeCheckElimination.getRemainingIfStatementExpressions();
  for (int i=0; i < subclassNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      if (!remainingIfStatementExpressions.isEmpty())       remainingIfStatementExpression=remainingIfStatementExpressions.get(i);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=getFile(rootContainer,subclassNames.get(i));
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    TypeDeclaration subclassTypeDeclaration=null;
    List<AbstractTypeDeclaration> subclassAbstractTypeDeclarations=subclassCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : subclassAbstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.resolveBinding().getQualifiedName().equals(subclassNames.get(i))) {
          subclassTypeDeclaration=typeDeclaration;
          break;
        }
      }
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    String concreteMethodName=typeCheckElimination.getTypeCheckMethodName();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(concreteMethodName),null);
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
    Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
    Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,subclassRewriter,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    if (returnedVariable != null) {
      VariableDeclarationFragment variableDeclarationFragment=subclassAST.newVariableDeclarationFragment();
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariable.getName(),null);
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,returnedVariable.getInitializer(),null);
      VariableDeclarationStatement variableDeclarationStatement=subclassAST.newVariableDeclarationStatement(variableDeclarationFragment);
      subclassRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertFirst(variableDeclarationStatement,null);
 else       concreteMethodBodyRewrite.insertFirst(variableDeclarationStatement,null);
    }
    SimpleName invokerSimpleName=null;
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      boolean insert=true;
      if (statement instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)statement;
        List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
        VariableDeclarationFragment fragment=fragments.get(0);
        if (fragment.getInitializer() instanceof CastExpression) {
          CastExpression castExpression=(CastExpression)fragment.getInitializer();
          if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
            invokerSimpleName=fragment.getName();
            insert=false;
          }
        }
      }
      if (invokerSimpleName != null) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(newStatement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            Expression methodInvocationExpression=methodInvocation.getExpression();
            if (methodInvocationExpression instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)methodInvocationExpression;
              if (simpleName.getIdentifier().equals(invokerSimpleName.getIdentifier())) {
                subclassRewriter.remove(simpleName,null);
              }
            }
          }
        }
      }
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      if (insert) {
        if (ifStatementBodyRewrite != null)         ifStatementBodyRewrite.insertLast(newStatement,null);
 else         concreteMethodBodyRewrite.insertLast(newStatement,null);
      }
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(returnStatement,null);
 else       concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}"
12237,"private void createStateStrategyHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  IFile stateStrategyFile=null;
  if (contextContainer instanceof IProject) {
    IProject contextProject=(IProject)contextContainer;
    stateStrategyFile=contextProject.getFile(typeCheckElimination.getAbstractClassName() + ""String_Node_Str"");
  }
 else   if (contextContainer instanceof IFolder) {
    IFolder contextFolder=(IFolder)contextContainer;
    stateStrategyFile=contextFolder.getFile(typeCheckElimination.getAbstractClassName() + ""String_Node_Str"");
  }
  boolean stateStrategyAlreadyExists=false;
  try {
    stateStrategyFile.create(new ByteArrayInputStream(""String_Node_Str"".getBytes()),true,null);
    undoRefactoring.addNewlyCreatedFile(stateStrategyFile);
  }
 catch (  CoreException e) {
    stateStrategyAlreadyExists=true;
  }
  IJavaElement stateStrategyJavaElement=JavaCore.create(stateStrategyFile);
  ITextEditor stateStrategyEditor=null;
  try {
    stateStrategyEditor=(ITextEditor)JavaUI.openInEditor(stateStrategyJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit stateStrategyICompilationUnit=(ICompilationUnit)stateStrategyJavaElement;
  ASTParser stateStrategyParser=ASTParser.newParser(AST.JLS3);
  stateStrategyParser.setKind(ASTParser.K_COMPILATION_UNIT);
  stateStrategyParser.setSource(stateStrategyICompilationUnit);
  stateStrategyParser.setResolveBindings(true);
  CompilationUnit stateStrategyCompilationUnit=(CompilationUnit)stateStrategyParser.createAST(null);
  AST stateStrategyAST=stateStrategyCompilationUnit.getAST();
  ASTRewrite stateStrategyRewriter=ASTRewrite.create(stateStrategyAST);
  ListRewrite stateStrategyTypesRewrite=stateStrategyRewriter.getListRewrite(stateStrategyCompilationUnit,CompilationUnit.TYPES_PROPERTY);
  TypeDeclaration stateStrategyTypeDeclaration=null;
  if (stateStrategyAlreadyExists) {
    List<AbstractTypeDeclaration> abstractTypeDeclarations=stateStrategyCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.getName().getIdentifier().equals(typeCheckElimination.getAbstractClassName())) {
          stateStrategyTypeDeclaration=typeDeclaration;
          int stateStrategyModifiers=stateStrategyTypeDeclaration.getModifiers();
          if ((stateStrategyModifiers & Modifier.ABSTRACT) == 0) {
            ListRewrite stateStrategyModifiersRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
            stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
          }
          break;
        }
      }
    }
  }
 else {
    if (sourceCompilationUnit.getPackage() != null) {
      stateStrategyRewriter.set(stateStrategyCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,sourceCompilationUnit.getPackage(),null);
    }
    stateStrategyTypeDeclaration=stateStrategyAST.newTypeDeclaration();
    SimpleName stateStrategyName=stateStrategyAST.newSimpleName(typeCheckElimination.getAbstractClassName());
    stateStrategyRewriter.set(stateStrategyTypeDeclaration,TypeDeclaration.NAME_PROPERTY,stateStrategyName,null);
    ListRewrite stateStrategyModifiersRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite stateStrategyBodyRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  if (getterMethod != null) {
    MethodDeclaration abstractGetterMethodDeclaration=stateStrategyAST.newMethodDeclaration();
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,getterMethod.getName(),null);
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,getterMethod.getReturnType2(),null);
    ListRewrite abstractGetterMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
    stateStrategyBodyRewrite.insertLast(abstractGetterMethodDeclaration,null);
  }
 else {
    MethodDeclaration abstractGetterMethodDeclaration=stateStrategyAST.newMethodDeclaration();
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type returnType=((FieldDeclaration)typeField.getParent()).getType();
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    ListRewrite abstractGetterMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
    stateStrategyBodyRewrite.insertLast(abstractGetterMethodDeclaration,null);
  }
  MethodDeclaration abstractMethodDeclaration=stateStrategyAST.newMethodDeclaration();
  String abstractMethodName=typeCheckElimination.getTypeCheckMethodName();
  stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(abstractMethodName),null);
  stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
  ListRewrite abstractMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0) {
    SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
    SimpleName parameterType=stateStrategyAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,stateStrategyAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(stateStrategyAST.newSimpleName(typeBinding.getName()),null);
  }
  stateStrategyBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,stateStrategyCompilationUnit,stateStrategyRewriter);
  }
  if (!stateStrategyAlreadyExists)   stateStrategyTypesRewrite.insertLast(stateStrategyTypeDeclaration,null);
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer stateStrategyTextFileBuffer=bufferManager.getTextFileBuffer(stateStrategyFile.getFullPath(),LocationKind.IFILE);
  IDocument stateStrategyDocument=stateStrategyTextFileBuffer.getDocument();
  TextEdit stateStrategyEdit=stateStrategyRewriter.rewriteAST(stateStrategyDocument,null);
  try {
    UndoEdit stateStrategyUndoEdit=stateStrategyEdit.apply(stateStrategyDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(stateStrategyFile,stateStrategyDocument,stateStrategyUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  stateStrategyEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  subclassNames.addAll(additionalStaticFields.values());
  List<String> staticFieldNames=typeCheckElimination.getStaticFieldNames();
  staticFieldNames.addAll(additionalStaticFields.keySet());
  List<DefaultMutableTreeNode> remainingIfStatementExpressions=typeCheckElimination.getRemainingIfStatementExpressions();
  for (int i=0; i < staticFieldNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      remainingIfStatementExpression=remainingIfStatementExpressions.get(i);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=null;
    if (contextContainer instanceof IProject) {
      IProject contextProject=(IProject)contextContainer;
      subclassFile=contextProject.getFile(subclassNames.get(i) + ""String_Node_Str"");
    }
 else     if (contextContainer instanceof IFolder) {
      IFolder contextFolder=(IFolder)contextContainer;
      subclassFile=contextFolder.getFile(subclassNames.get(i) + ""String_Node_Str"");
    }
    boolean subclassAlreadyExists=false;
    try {
      subclassFile.create(new ByteArrayInputStream(""String_Node_Str"".getBytes()),true,null);
      undoRefactoring.addNewlyCreatedFile(subclassFile);
    }
 catch (    CoreException e) {
      subclassAlreadyExists=true;
    }
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    ListRewrite subclassTypesRewrite=subclassRewriter.getListRewrite(subclassCompilationUnit,CompilationUnit.TYPES_PROPERTY);
    TypeDeclaration subclassTypeDeclaration=null;
    if (subclassAlreadyExists) {
      List<AbstractTypeDeclaration> abstractTypeDeclarations=subclassCompilationUnit.types();
      for (      AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
        if (abstractTypeDeclaration instanceof TypeDeclaration) {
          TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
          if (typeDeclaration.getName().getIdentifier().equals(subclassNames.get(i))) {
            subclassTypeDeclaration=typeDeclaration;
            break;
          }
        }
      }
    }
 else {
      if (sourceCompilationUnit.getPackage() != null) {
        subclassRewriter.set(subclassCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,sourceCompilationUnit.getPackage(),null);
      }
      subclassTypeDeclaration=subclassAST.newTypeDeclaration();
      SimpleName subclassName=subclassAST.newSimpleName(subclassNames.get(i));
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.NAME_PROPERTY,subclassName,null);
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,subclassAST.newSimpleType(subclassAST.newSimpleName(typeCheckElimination.getAbstractClassName())),null);
      ListRewrite subclassModifiersRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
      subclassModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    if (getterMethod != null) {
      MethodDeclaration concreteGetterMethodDeclaration=subclassAST.newMethodDeclaration();
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,getterMethod.getName(),null);
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,getterMethod.getReturnType2(),null);
      ListRewrite concreteGetterMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
      concreteGetterMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      Block concreteGetterMethodBody=subclassAST.newBlock();
      ListRewrite concreteGetterMethodBodyRewrite=subclassRewriter.getListRewrite(concreteGetterMethodBody,Block.STATEMENTS_PROPERTY);
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      FieldAccess fieldAccess=subclassAST.newFieldAccess();
      subclassRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,subclassAST.newSimpleName(staticFieldNames.get(i)),null);
      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,sourceTypeDeclaration.getName(),null);
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fieldAccess,null);
      concreteGetterMethodBodyRewrite.insertLast(returnStatement,null);
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteGetterMethodBody,null);
      subclassBodyRewrite.insertLast(concreteGetterMethodDeclaration,null);
    }
 else {
      MethodDeclaration concreteGetterMethodDeclaration=subclassAST.newMethodDeclaration();
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
      VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
      Type returnType=((FieldDeclaration)typeField.getParent()).getType();
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      ListRewrite concreteGetterMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
      concreteGetterMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      Block concreteGetterMethodBody=subclassAST.newBlock();
      ListRewrite concreteGetterMethodBodyRewrite=subclassRewriter.getListRewrite(concreteGetterMethodBody,Block.STATEMENTS_PROPERTY);
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      FieldAccess fieldAccess=subclassAST.newFieldAccess();
      subclassRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,subclassAST.newSimpleName(staticFieldNames.get(i)),null);
      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,sourceTypeDeclaration.getName(),null);
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fieldAccess,null);
      concreteGetterMethodBodyRewrite.insertLast(returnStatement,null);
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteGetterMethodBody,null);
      subclassBodyRewrite.insertLast(concreteGetterMethodDeclaration,null);
    }
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    String concreteMethodName=typeCheckElimination.getTypeCheckMethodName();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(concreteMethodName),null);
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
    Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
    Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,subclassRewriter,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    if (returnedVariable != null) {
      VariableDeclarationFragment variableDeclarationFragment=subclassAST.newVariableDeclarationFragment();
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariable.getName(),null);
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,returnedVariable.getInitializer(),null);
      VariableDeclarationStatement variableDeclarationStatement=subclassAST.newVariableDeclarationStatement(variableDeclarationFragment);
      subclassRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertFirst(variableDeclarationStatement,null);
 else       concreteMethodBodyRewrite.insertFirst(variableDeclarationStatement,null);
    }
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(newStatement,null);
 else       concreteMethodBodyRewrite.insertLast(newStatement,null);
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(returnStatement,null);
 else       concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    if (!subclassAlreadyExists)     subclassTypesRewrite.insertLast(subclassTypeDeclaration,null);
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}","private void createStateStrategyHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  IFile stateStrategyFile=null;
  if (contextContainer instanceof IProject) {
    IProject contextProject=(IProject)contextContainer;
    stateStrategyFile=contextProject.getFile(typeCheckElimination.getAbstractClassName() + ""String_Node_Str"");
  }
 else   if (contextContainer instanceof IFolder) {
    IFolder contextFolder=(IFolder)contextContainer;
    stateStrategyFile=contextFolder.getFile(typeCheckElimination.getAbstractClassName() + ""String_Node_Str"");
  }
  boolean stateStrategyAlreadyExists=false;
  try {
    stateStrategyFile.create(new ByteArrayInputStream(""String_Node_Str"".getBytes()),true,null);
    undoRefactoring.addNewlyCreatedFile(stateStrategyFile);
  }
 catch (  CoreException e) {
    stateStrategyAlreadyExists=true;
  }
  IJavaElement stateStrategyJavaElement=JavaCore.create(stateStrategyFile);
  ITextEditor stateStrategyEditor=null;
  try {
    stateStrategyEditor=(ITextEditor)JavaUI.openInEditor(stateStrategyJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit stateStrategyICompilationUnit=(ICompilationUnit)stateStrategyJavaElement;
  ASTParser stateStrategyParser=ASTParser.newParser(AST.JLS3);
  stateStrategyParser.setKind(ASTParser.K_COMPILATION_UNIT);
  stateStrategyParser.setSource(stateStrategyICompilationUnit);
  stateStrategyParser.setResolveBindings(true);
  CompilationUnit stateStrategyCompilationUnit=(CompilationUnit)stateStrategyParser.createAST(null);
  AST stateStrategyAST=stateStrategyCompilationUnit.getAST();
  ASTRewrite stateStrategyRewriter=ASTRewrite.create(stateStrategyAST);
  ListRewrite stateStrategyTypesRewrite=stateStrategyRewriter.getListRewrite(stateStrategyCompilationUnit,CompilationUnit.TYPES_PROPERTY);
  TypeDeclaration stateStrategyTypeDeclaration=null;
  if (stateStrategyAlreadyExists) {
    List<AbstractTypeDeclaration> abstractTypeDeclarations=stateStrategyCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.getName().getIdentifier().equals(typeCheckElimination.getAbstractClassName())) {
          stateStrategyTypeDeclaration=typeDeclaration;
          int stateStrategyModifiers=stateStrategyTypeDeclaration.getModifiers();
          if ((stateStrategyModifiers & Modifier.ABSTRACT) == 0) {
            ListRewrite stateStrategyModifiersRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
            stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
          }
          break;
        }
      }
    }
  }
 else {
    if (sourceCompilationUnit.getPackage() != null) {
      stateStrategyRewriter.set(stateStrategyCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,sourceCompilationUnit.getPackage(),null);
    }
    stateStrategyTypeDeclaration=stateStrategyAST.newTypeDeclaration();
    SimpleName stateStrategyName=stateStrategyAST.newSimpleName(typeCheckElimination.getAbstractClassName());
    stateStrategyRewriter.set(stateStrategyTypeDeclaration,TypeDeclaration.NAME_PROPERTY,stateStrategyName,null);
    ListRewrite stateStrategyModifiersRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite stateStrategyBodyRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  if (getterMethod != null) {
    MethodDeclaration abstractGetterMethodDeclaration=stateStrategyAST.newMethodDeclaration();
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,getterMethod.getName(),null);
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,getterMethod.getReturnType2(),null);
    ListRewrite abstractGetterMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
    stateStrategyBodyRewrite.insertLast(abstractGetterMethodDeclaration,null);
  }
 else {
    MethodDeclaration abstractGetterMethodDeclaration=stateStrategyAST.newMethodDeclaration();
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type returnType=((FieldDeclaration)typeField.getParent()).getType();
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    ListRewrite abstractGetterMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
    stateStrategyBodyRewrite.insertLast(abstractGetterMethodDeclaration,null);
  }
  MethodDeclaration abstractMethodDeclaration=stateStrategyAST.newMethodDeclaration();
  String abstractMethodName=typeCheckElimination.getTypeCheckMethodName();
  stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(abstractMethodName),null);
  stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
  ListRewrite abstractMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0) {
    SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
    SimpleName parameterType=stateStrategyAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,stateStrategyAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(stateStrategyAST.newSimpleName(typeBinding.getName()),null);
  }
  stateStrategyBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,stateStrategyCompilationUnit,stateStrategyRewriter);
  }
  if (!stateStrategyAlreadyExists)   stateStrategyTypesRewrite.insertLast(stateStrategyTypeDeclaration,null);
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer stateStrategyTextFileBuffer=bufferManager.getTextFileBuffer(stateStrategyFile.getFullPath(),LocationKind.IFILE);
  IDocument stateStrategyDocument=stateStrategyTextFileBuffer.getDocument();
  TextEdit stateStrategyEdit=stateStrategyRewriter.rewriteAST(stateStrategyDocument,null);
  try {
    UndoEdit stateStrategyUndoEdit=stateStrategyEdit.apply(stateStrategyDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(stateStrategyFile,stateStrategyDocument,stateStrategyUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  stateStrategyEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  subclassNames.addAll(additionalStaticFields.values());
  List<String> staticFieldNames=typeCheckElimination.getStaticFieldNames();
  staticFieldNames.addAll(additionalStaticFields.keySet());
  List<DefaultMutableTreeNode> remainingIfStatementExpressions=typeCheckElimination.getRemainingIfStatementExpressions();
  for (int i=0; i < staticFieldNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      if (!remainingIfStatementExpressions.isEmpty())       remainingIfStatementExpression=remainingIfStatementExpressions.get(i);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=null;
    if (contextContainer instanceof IProject) {
      IProject contextProject=(IProject)contextContainer;
      subclassFile=contextProject.getFile(subclassNames.get(i) + ""String_Node_Str"");
    }
 else     if (contextContainer instanceof IFolder) {
      IFolder contextFolder=(IFolder)contextContainer;
      subclassFile=contextFolder.getFile(subclassNames.get(i) + ""String_Node_Str"");
    }
    boolean subclassAlreadyExists=false;
    try {
      subclassFile.create(new ByteArrayInputStream(""String_Node_Str"".getBytes()),true,null);
      undoRefactoring.addNewlyCreatedFile(subclassFile);
    }
 catch (    CoreException e) {
      subclassAlreadyExists=true;
    }
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    ListRewrite subclassTypesRewrite=subclassRewriter.getListRewrite(subclassCompilationUnit,CompilationUnit.TYPES_PROPERTY);
    TypeDeclaration subclassTypeDeclaration=null;
    if (subclassAlreadyExists) {
      List<AbstractTypeDeclaration> abstractTypeDeclarations=subclassCompilationUnit.types();
      for (      AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
        if (abstractTypeDeclaration instanceof TypeDeclaration) {
          TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
          if (typeDeclaration.getName().getIdentifier().equals(subclassNames.get(i))) {
            subclassTypeDeclaration=typeDeclaration;
            break;
          }
        }
      }
    }
 else {
      if (sourceCompilationUnit.getPackage() != null) {
        subclassRewriter.set(subclassCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,sourceCompilationUnit.getPackage(),null);
      }
      subclassTypeDeclaration=subclassAST.newTypeDeclaration();
      SimpleName subclassName=subclassAST.newSimpleName(subclassNames.get(i));
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.NAME_PROPERTY,subclassName,null);
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,subclassAST.newSimpleType(subclassAST.newSimpleName(typeCheckElimination.getAbstractClassName())),null);
      ListRewrite subclassModifiersRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
      subclassModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    if (getterMethod != null) {
      MethodDeclaration concreteGetterMethodDeclaration=subclassAST.newMethodDeclaration();
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,getterMethod.getName(),null);
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,getterMethod.getReturnType2(),null);
      ListRewrite concreteGetterMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
      concreteGetterMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      Block concreteGetterMethodBody=subclassAST.newBlock();
      ListRewrite concreteGetterMethodBodyRewrite=subclassRewriter.getListRewrite(concreteGetterMethodBody,Block.STATEMENTS_PROPERTY);
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      FieldAccess fieldAccess=subclassAST.newFieldAccess();
      subclassRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,subclassAST.newSimpleName(staticFieldNames.get(i)),null);
      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,sourceTypeDeclaration.getName(),null);
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fieldAccess,null);
      concreteGetterMethodBodyRewrite.insertLast(returnStatement,null);
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteGetterMethodBody,null);
      subclassBodyRewrite.insertLast(concreteGetterMethodDeclaration,null);
    }
 else {
      MethodDeclaration concreteGetterMethodDeclaration=subclassAST.newMethodDeclaration();
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
      VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
      Type returnType=((FieldDeclaration)typeField.getParent()).getType();
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      ListRewrite concreteGetterMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
      concreteGetterMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      Block concreteGetterMethodBody=subclassAST.newBlock();
      ListRewrite concreteGetterMethodBodyRewrite=subclassRewriter.getListRewrite(concreteGetterMethodBody,Block.STATEMENTS_PROPERTY);
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      FieldAccess fieldAccess=subclassAST.newFieldAccess();
      subclassRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,subclassAST.newSimpleName(staticFieldNames.get(i)),null);
      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,sourceTypeDeclaration.getName(),null);
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fieldAccess,null);
      concreteGetterMethodBodyRewrite.insertLast(returnStatement,null);
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteGetterMethodBody,null);
      subclassBodyRewrite.insertLast(concreteGetterMethodDeclaration,null);
    }
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    String concreteMethodName=typeCheckElimination.getTypeCheckMethodName();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(concreteMethodName),null);
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
    Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
    Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,subclassRewriter,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    if (returnedVariable != null) {
      VariableDeclarationFragment variableDeclarationFragment=subclassAST.newVariableDeclarationFragment();
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariable.getName(),null);
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,returnedVariable.getInitializer(),null);
      VariableDeclarationStatement variableDeclarationStatement=subclassAST.newVariableDeclarationStatement(variableDeclarationFragment);
      subclassRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertFirst(variableDeclarationStatement,null);
 else       concreteMethodBodyRewrite.insertFirst(variableDeclarationStatement,null);
    }
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(newStatement,null);
 else       concreteMethodBodyRewrite.insertLast(newStatement,null);
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(returnStatement,null);
 else       concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    if (!subclassAlreadyExists)     subclassTypesRewrite.insertLast(subclassTypeDeclaration,null);
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}"
12238,"public ASTExtractionBlock getASTExtractionBlock(){
  ASTExtractionBlock astExtractionBlock=new ASTExtractionBlock(extractionBlock.getExtractedMethodName(),getReturnVariableDeclarationFragment(),getReturnVariableDeclarationStatement(),getStatementsForExtraction(),getAllVariableDeclarationStatements(),extractionBlock.getAssignmentOperators());
  if (extractionBlock.getParentStatementForCopy() != null)   astExtractionBlock.setParentStatementForCopy(extractionBlock.getParentStatementForCopy().getStatement());
  for (  LocalVariableDeclarationObject lvdo : extractionBlock.getAdditionalRequiredVariableDeclarations()) {
    VariableDeclarationStatement variableDeclarationStatement=extractionBlock.getAdditionalRequiredVariableDeclarationStatement(lvdo);
    astExtractionBlock.addRequiredVariableDeclarationStatement(getVariableDeclarationFragment(lvdo,variableDeclarationStatement),variableDeclarationStatement);
  }
  return astExtractionBlock;
}","public ASTExtractionBlock getASTExtractionBlock(){
  List<VariableDeclarationStatement> allVariableDeclarationStatements=new ArrayList<VariableDeclarationStatement>();
  List<VariableDeclarationExpression> allVariableDeclarationExpressions=new ArrayList<VariableDeclarationExpression>();
  List<LocalVariableInstructionObject> discreteLocalVariableInstructions=new ArrayList<LocalVariableInstructionObject>();
  for (  AbstractStatement abstractStatement : extractionBlock.getStatementsForExtraction()) {
    List<LocalVariableInstructionObject> instructionList=abstractStatement.getLocalVariableInstructions();
    for (    LocalVariableInstructionObject instruction : instructionList) {
      if (!discreteLocalVariableInstructions.contains(instruction)) {
        discreteLocalVariableInstructions.add(instruction);
        VariableDeclarationStatement variableDeclarationStatement=sourceMethod.getMethodObject().getVariableDeclarationStatement(instruction.generateLocalVariableDeclaration());
        if (variableDeclarationStatement != null) {
          allVariableDeclarationStatements.add(variableDeclarationStatement);
        }
 else {
          VariableDeclarationExpression variableDeclarationExpression=sourceMethod.getMethodObject().getVariableDeclarationExpression(instruction.generateLocalVariableDeclaration());
          if (variableDeclarationExpression != null)           allVariableDeclarationExpressions.add(variableDeclarationExpression);
        }
      }
    }
  }
  ASTExtractionBlock astExtractionBlock=new ASTExtractionBlock(extractionBlock.getExtractedMethodName(),getReturnVariableDeclarationFragment(),getReturnVariableDeclarationStatement(),getStatementsForExtraction(),allVariableDeclarationStatements,allVariableDeclarationExpressions,extractionBlock.getAssignmentOperators());
  if (extractionBlock.getParentStatementForCopy() != null)   astExtractionBlock.setParentStatementForCopy(extractionBlock.getParentStatementForCopy().getStatement());
  for (  LocalVariableDeclarationObject lvdo : extractionBlock.getAdditionalRequiredVariableDeclarations()) {
    VariableDeclarationStatement variableDeclarationStatement=extractionBlock.getAdditionalRequiredVariableDeclarationStatement(lvdo);
    astExtractionBlock.addRequiredVariableDeclarationStatement(getVariableDeclarationFragment(lvdo,variableDeclarationStatement),variableDeclarationStatement);
  }
  return astExtractionBlock;
}"
12239,"public ASTExtractionBlock(String extractedMethodName,VariableDeclarationFragment returnVariableDeclarationFragment,VariableDeclarationStatement returnVariableDeclarationStatement,List<Statement> statementsForExtraction,List<VariableDeclarationStatement> allVariableDeclarationStatements,List<String> assignmentOperators){
  this.extractedMethodName=extractedMethodName;
  this.returnVariableDeclarationFragment=returnVariableDeclarationFragment;
  this.returnVariableDeclarationStatement=returnVariableDeclarationStatement;
  this.statementsForExtraction=statementsForExtraction;
  this.allVariableDeclarationStatements=allVariableDeclarationStatements;
  this.assignmentOperators=assignmentOperators;
  this.parentStatementForCopy=null;
  this.additionalRequiredVariableDeclarationStatementMap=new LinkedHashMap<VariableDeclarationFragment,VariableDeclarationStatement>();
}","public ASTExtractionBlock(String extractedMethodName,VariableDeclarationFragment returnVariableDeclarationFragment,VariableDeclarationStatement returnVariableDeclarationStatement,List<Statement> statementsForExtraction,List<VariableDeclarationStatement> allVariableDeclarationStatements,List<VariableDeclarationExpression> allVariableDeclarationExpressions,List<String> assignmentOperators){
  this.extractedMethodName=extractedMethodName;
  this.returnVariableDeclarationFragment=returnVariableDeclarationFragment;
  this.returnVariableDeclarationStatement=returnVariableDeclarationStatement;
  this.statementsForExtraction=statementsForExtraction;
  this.allVariableDeclarationStatements=allVariableDeclarationStatements;
  this.allVariableDeclarationExpressions=allVariableDeclarationExpressions;
  this.assignmentOperators=assignmentOperators;
  this.parentStatementForCopy=null;
  this.additionalRequiredVariableDeclarationStatementMap=new LinkedHashMap<VariableDeclarationFragment,VariableDeclarationStatement>();
}"
12240,"private void extractMethod(){
  AST ast=sourceTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  SimpleName returnVariableSimpleName=extractionBlock.getReturnVariableDeclarationFragment().getName();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractionBlock.getExtractedMethodName()),null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,extractionBlock.getReturnVariableDeclarationStatement().getType(),null);
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier modifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  modifierRewrite.insertLast(modifier,null);
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<SimpleName> extractedMethodArguments=new ArrayList<SimpleName>();
  List<String> extractedMethodArgumentIdentifiers=new ArrayList<String>();
  List<String> variableDeclarationIdentifiers=new ArrayList<String>();
  for (  VariableDeclarationFragment fragment : extractionBlock.getAdditionalRequiredVariableDeclarationFragments())   variableDeclarationIdentifiers.add(fragment.getName().getIdentifier());
  VariableDeclarationFragment returnFragment=extractionBlock.getReturnVariableDeclarationFragment();
  Expression returnInitializer=returnFragment.getInitializer();
  List<Expression> returnList=extractor.getVariableInstructions(returnInitializer);
  processIdentifiers(returnList,returnVariableSimpleName,extractedMethodArguments,extractedMethodArgumentIdentifiers,variableDeclarationIdentifiers);
  for (  VariableDeclarationFragment fragment : extractionBlock.getAdditionalRequiredVariableDeclarationFragments()) {
    Expression initializer=fragment.getInitializer();
    List<Expression> list=extractor.getVariableInstructions(initializer);
    processIdentifiers(list,returnVariableSimpleName,extractedMethodArguments,extractedMethodArgumentIdentifiers,variableDeclarationIdentifiers);
  }
  if (extractionBlock.getParentStatementForCopy() != null) {
    Statement parentStatementForCopy=extractionBlock.getParentStatementForCopy();
    if (parentStatementForCopy.getNodeType() == Statement.IF_STATEMENT) {
      IfStatement ifStatement=(IfStatement)parentStatementForCopy;
      List<Expression> list=extractor.getVariableInstructions(ifStatement.getExpression());
      processIdentifiers(list,returnVariableSimpleName,extractedMethodArguments,extractedMethodArgumentIdentifiers,variableDeclarationIdentifiers);
    }
  }
  for (  Statement statement : extractionBlock.getStatementsForExtraction()) {
    List<Expression> list=extractor.getVariableInstructions(statement);
    processIdentifiers(list,returnVariableSimpleName,extractedMethodArguments,extractedMethodArgumentIdentifiers,variableDeclarationIdentifiers);
  }
  ListRewrite paramRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SimpleName argument : extractedMethodArguments) {
    Type argumentVariableDeclarationType=null;
    for (    VariableDeclarationStatement statement : extractionBlock.getAllVariableDeclarationStatements()) {
      List<VariableDeclarationFragment> fragmentList=statement.fragments();
      for (      VariableDeclarationFragment fragment : fragmentList) {
        if (fragment.getName().getIdentifier().equals(argument.getIdentifier())) {
          argumentVariableDeclarationType=statement.getType();
          break;
        }
      }
    }
    if (argumentVariableDeclarationType == null) {
      List<SingleVariableDeclaration> sourceMethodParameters=sourceMethodDeclaration.parameters();
      for (      SingleVariableDeclaration variableDeclaration : sourceMethodParameters) {
        if (variableDeclaration.getName().getIdentifier().equals(argument.getIdentifier())) {
          argumentVariableDeclarationType=variableDeclaration.getType();
          break;
        }
      }
    }
    if (argumentVariableDeclarationType != null) {
      SingleVariableDeclaration newParam=newMethodDeclaration.getAST().newSingleVariableDeclaration();
      sourceRewriter.set(newParam,SingleVariableDeclaration.NAME_PROPERTY,argument,null);
      sourceRewriter.set(newParam,SingleVariableDeclaration.TYPE_PROPERTY,argumentVariableDeclarationType,null);
      paramRewrite.insertLast(newParam,null);
    }
  }
  Set<ITypeBinding> thrownExceptions=extractionBlock.getThrownExceptions();
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding thrownException : thrownExceptions) {
    SimpleName simpleName=ast.newSimpleName(thrownException.getName());
    thrownExceptionRewrite.insertLast(simpleName,null);
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite bodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  VariableDeclarationFragment returnVariableDeclarationFragment=newMethodBody.getAST().newVariableDeclarationFragment();
  sourceRewriter.set(returnVariableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,extractionBlock.getReturnVariableDeclarationFragment().getName(),null);
  sourceRewriter.set(returnVariableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractionBlock.getReturnVariableDeclarationFragment().getInitializer(),null);
  VariableDeclarationStatement returnVariableDeclarationStatement=newMethodBody.getAST().newVariableDeclarationStatement(returnVariableDeclarationFragment);
  sourceRewriter.set(returnVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,extractionBlock.getReturnVariableDeclarationStatement().getType(),null);
  bodyRewrite.insertLast(returnVariableDeclarationStatement,null);
  for (  VariableDeclarationFragment fragment : extractionBlock.getAdditionalRequiredVariableDeclarationFragments()) {
    VariableDeclarationFragment variableDeclarationFragment=newMethodBody.getAST().newVariableDeclarationFragment();
    sourceRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,fragment.getName(),null);
    sourceRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,fragment.getInitializer(),null);
    VariableDeclarationStatement variableDeclarationStatement=newMethodBody.getAST().newVariableDeclarationStatement(variableDeclarationFragment);
    sourceRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,extractionBlock.getAdditionalRequiredVariableDeclarationStatement(fragment).getType(),null);
    bodyRewrite.insertLast(variableDeclarationStatement,null);
  }
  if (extractionBlock.getParentStatementForCopy() == null) {
    for (    Statement statement : extractionBlock.getStatementsForExtraction()) {
      bodyRewrite.insertLast(statement,null);
    }
  }
 else {
    Statement parentStatement=extractionBlock.getParentStatementForCopy();
    Statement copiedParentStatement=(Statement)ASTNode.copySubtree(ast,parentStatement);
    if (copiedParentStatement.getNodeType() == ASTNode.IF_STATEMENT) {
      IfStatement oldIfStatement=(IfStatement)parentStatement;
      IfStatement newIfStatement=(IfStatement)copiedParentStatement;
      modifyExtractionBlock(oldIfStatement,newIfStatement);
    }
    bodyRewrite.insertLast(copiedParentStatement,null);
  }
  ReturnStatement returnStatement=newMethodBody.getAST().newReturnStatement();
  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnVariableSimpleName,null);
  bodyRewrite.insertLast(returnStatement,null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  ListRewrite methodDeclarationRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertLast(newMethodDeclaration,null);
  if (extractionBlock.getParentStatementForCopy() == null) {
    replaceExtractedCodeWithMethodInvocation(extractedMethodArguments);
  }
 else {
    insertMethodInvocationBeforeParentStatement(extractedMethodArguments);
  }
}","private void extractMethod(){
  AST ast=sourceTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  SimpleName returnVariableSimpleName=extractionBlock.getReturnVariableDeclarationFragment().getName();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractionBlock.getExtractedMethodName()),null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,extractionBlock.getReturnVariableDeclarationStatement().getType(),null);
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier modifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  modifierRewrite.insertLast(modifier,null);
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<SimpleName> extractedMethodArguments=new ArrayList<SimpleName>();
  List<String> extractedMethodArgumentIdentifiers=new ArrayList<String>();
  List<String> variableDeclarationIdentifiers=new ArrayList<String>();
  for (  VariableDeclarationFragment fragment : extractionBlock.getAdditionalRequiredVariableDeclarationFragments())   variableDeclarationIdentifiers.add(fragment.getName().getIdentifier());
  VariableDeclarationFragment returnFragment=extractionBlock.getReturnVariableDeclarationFragment();
  Expression returnInitializer=returnFragment.getInitializer();
  List<Expression> returnList=extractor.getVariableInstructions(returnInitializer);
  processIdentifiers(returnList,returnVariableSimpleName,extractedMethodArguments,extractedMethodArgumentIdentifiers,variableDeclarationIdentifiers);
  for (  VariableDeclarationFragment fragment : extractionBlock.getAdditionalRequiredVariableDeclarationFragments()) {
    Expression initializer=fragment.getInitializer();
    List<Expression> list=extractor.getVariableInstructions(initializer);
    processIdentifiers(list,returnVariableSimpleName,extractedMethodArguments,extractedMethodArgumentIdentifiers,variableDeclarationIdentifiers);
  }
  if (extractionBlock.getParentStatementForCopy() != null) {
    Statement parentStatementForCopy=extractionBlock.getParentStatementForCopy();
    if (parentStatementForCopy.getNodeType() == Statement.IF_STATEMENT) {
      IfStatement ifStatement=(IfStatement)parentStatementForCopy;
      List<Expression> list=extractor.getVariableInstructions(ifStatement.getExpression());
      processIdentifiers(list,returnVariableSimpleName,extractedMethodArguments,extractedMethodArgumentIdentifiers,variableDeclarationIdentifiers);
    }
  }
  for (  Statement statement : extractionBlock.getStatementsForExtraction()) {
    List<Expression> list=extractor.getVariableInstructions(statement);
    processIdentifiers(list,returnVariableSimpleName,extractedMethodArguments,extractedMethodArgumentIdentifiers,variableDeclarationIdentifiers);
  }
  ListRewrite paramRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SimpleName argument : extractedMethodArguments) {
    Type argumentVariableDeclarationType=null;
    for (    VariableDeclarationStatement statement : extractionBlock.getAllVariableDeclarationStatements()) {
      List<VariableDeclarationFragment> fragmentList=statement.fragments();
      for (      VariableDeclarationFragment fragment : fragmentList) {
        if (fragment.getName().getIdentifier().equals(argument.getIdentifier())) {
          argumentVariableDeclarationType=statement.getType();
          break;
        }
      }
    }
    if (argumentVariableDeclarationType == null) {
      for (      VariableDeclarationExpression expression : extractionBlock.getAllVariableDeclarationExpressions()) {
        List<VariableDeclarationFragment> fragmentList=expression.fragments();
        for (        VariableDeclarationFragment fragment : fragmentList) {
          if (fragment.getName().getIdentifier().equals(argument.getIdentifier())) {
            argumentVariableDeclarationType=expression.getType();
            break;
          }
        }
      }
    }
    if (argumentVariableDeclarationType == null) {
      List<SingleVariableDeclaration> sourceMethodParameters=sourceMethodDeclaration.parameters();
      for (      SingleVariableDeclaration variableDeclaration : sourceMethodParameters) {
        if (variableDeclaration.getName().getIdentifier().equals(argument.getIdentifier())) {
          argumentVariableDeclarationType=variableDeclaration.getType();
          break;
        }
      }
    }
    if (argumentVariableDeclarationType != null) {
      SingleVariableDeclaration newParam=newMethodDeclaration.getAST().newSingleVariableDeclaration();
      sourceRewriter.set(newParam,SingleVariableDeclaration.NAME_PROPERTY,argument,null);
      sourceRewriter.set(newParam,SingleVariableDeclaration.TYPE_PROPERTY,argumentVariableDeclarationType,null);
      paramRewrite.insertLast(newParam,null);
    }
  }
  Set<ITypeBinding> thrownExceptions=extractionBlock.getThrownExceptions();
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding thrownException : thrownExceptions) {
    SimpleName simpleName=ast.newSimpleName(thrownException.getName());
    thrownExceptionRewrite.insertLast(simpleName,null);
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite bodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  VariableDeclarationFragment returnVariableDeclarationFragment=newMethodBody.getAST().newVariableDeclarationFragment();
  sourceRewriter.set(returnVariableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,extractionBlock.getReturnVariableDeclarationFragment().getName(),null);
  sourceRewriter.set(returnVariableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractionBlock.getReturnVariableDeclarationFragment().getInitializer(),null);
  VariableDeclarationStatement returnVariableDeclarationStatement=newMethodBody.getAST().newVariableDeclarationStatement(returnVariableDeclarationFragment);
  sourceRewriter.set(returnVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,extractionBlock.getReturnVariableDeclarationStatement().getType(),null);
  bodyRewrite.insertLast(returnVariableDeclarationStatement,null);
  for (  VariableDeclarationFragment fragment : extractionBlock.getAdditionalRequiredVariableDeclarationFragments()) {
    VariableDeclarationFragment variableDeclarationFragment=newMethodBody.getAST().newVariableDeclarationFragment();
    sourceRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,fragment.getName(),null);
    sourceRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,fragment.getInitializer(),null);
    VariableDeclarationStatement variableDeclarationStatement=newMethodBody.getAST().newVariableDeclarationStatement(variableDeclarationFragment);
    sourceRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,extractionBlock.getAdditionalRequiredVariableDeclarationStatement(fragment).getType(),null);
    bodyRewrite.insertLast(variableDeclarationStatement,null);
  }
  if (extractionBlock.getParentStatementForCopy() == null) {
    for (    Statement statement : extractionBlock.getStatementsForExtraction()) {
      bodyRewrite.insertLast(statement,null);
    }
  }
 else {
    Statement parentStatement=extractionBlock.getParentStatementForCopy();
    Statement copiedParentStatement=(Statement)ASTNode.copySubtree(ast,parentStatement);
    if (copiedParentStatement.getNodeType() == ASTNode.IF_STATEMENT) {
      IfStatement oldIfStatement=(IfStatement)parentStatement;
      IfStatement newIfStatement=(IfStatement)copiedParentStatement;
      modifyExtractionBlock(oldIfStatement,newIfStatement);
    }
    bodyRewrite.insertLast(copiedParentStatement,null);
  }
  ReturnStatement returnStatement=newMethodBody.getAST().newReturnStatement();
  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnVariableSimpleName,null);
  bodyRewrite.insertLast(returnStatement,null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  ListRewrite methodDeclarationRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertLast(newMethodDeclaration,null);
  if (extractionBlock.getParentStatementForCopy() == null) {
    replaceExtractedCodeWithMethodInvocation(extractedMethodArguments);
  }
 else {
    insertMethodInvocationBeforeParentStatement(extractedMethodArguments);
  }
}"
12241,"private void modifyContextConstructors(){
  if (typeCheckElimination.getTypeFieldSetterMethod() != null) {
    AST contextAST=sourceTypeDeclaration.getAST();
    MethodDeclaration[] contextMethods=sourceTypeDeclaration.getMethods();
    for (    MethodDeclaration methodDeclaration : contextMethods) {
      if (methodDeclaration.isConstructor()) {
        Block constructorBody=methodDeclaration.getBody();
        List<Statement> statements=constructorBody.statements();
        ExpressionExtractor expressionExtractor=new ExpressionExtractor();
        for (        Statement statement : statements) {
          List<Expression> assignments=expressionExtractor.getAssignments(statement);
          for (          Expression expression : assignments) {
            Assignment assignment=(Assignment)expression;
            Expression leftHandSide=assignment.getLeftHandSide();
            SimpleName simpleName=null;
            if (leftHandSide instanceof SimpleName) {
              simpleName=(SimpleName)leftHandSide;
            }
 else             if (leftHandSide instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)leftHandSide;
              simpleName=fieldAccess.getName();
            }
            IBinding binding=simpleName.resolveBinding();
            if (binding.getKind() == IBinding.VARIABLE) {
              IVariableBinding variableBinding=(IVariableBinding)binding;
              if (variableBinding.isField() && typeCheckElimination.getTypeField().getName().getIdentifier().equals(simpleName.getIdentifier())) {
                ListRewrite constructorBodyStatementsRewrite=sourceRewriter.getListRewrite(constructorBody,Block.STATEMENTS_PROPERTY);
                MethodInvocation setterMethodInvocation=contextAST.newMethodInvocation();
                sourceRewriter.set(setterMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckElimination.getTypeFieldSetterMethod().getName(),null);
                ListRewrite setterMethodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(setterMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                setterMethodInvocationArgumentsRewrite.insertLast(assignment.getRightHandSide(),null);
                ExpressionStatement expressionStatement=contextAST.newExpressionStatement(setterMethodInvocation);
                constructorBodyStatementsRewrite.replace(statement,expressionStatement,null);
              }
            }
          }
        }
      }
    }
  }
}","private void modifyContextConstructors(){
  if (typeCheckElimination.getTypeFieldSetterMethod() != null) {
    AST contextAST=sourceTypeDeclaration.getAST();
    MethodDeclaration[] contextMethods=sourceTypeDeclaration.getMethods();
    for (    MethodDeclaration methodDeclaration : contextMethods) {
      if (methodDeclaration.isConstructor()) {
        Block constructorBody=methodDeclaration.getBody();
        List<Statement> statements=constructorBody.statements();
        ExpressionExtractor expressionExtractor=new ExpressionExtractor();
        for (        Statement statement : statements) {
          List<Expression> assignments=expressionExtractor.getAssignments(statement);
          for (          Expression expression : assignments) {
            Assignment assignment=(Assignment)expression;
            Expression leftHandSide=assignment.getLeftHandSide();
            SimpleName simpleName=null;
            if (leftHandSide instanceof SimpleName) {
              simpleName=(SimpleName)leftHandSide;
            }
 else             if (leftHandSide instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)leftHandSide;
              simpleName=fieldAccess.getName();
            }
            IBinding binding=simpleName.resolveBinding();
            if (binding.getKind() == IBinding.VARIABLE) {
              IVariableBinding variableBinding=(IVariableBinding)binding;
              if (variableBinding.isField() && typeCheckElimination.getTypeField().getName().getIdentifier().equals(simpleName.getIdentifier())) {
                MethodInvocation setterMethodInvocation=contextAST.newMethodInvocation();
                sourceRewriter.set(setterMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckElimination.getTypeFieldSetterMethod().getName(),null);
                ListRewrite setterMethodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(setterMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                setterMethodInvocationArgumentsRewrite.insertLast(assignment.getRightHandSide(),null);
                ExpressionStatement expressionStatement=contextAST.newExpressionStatement(setterMethodInvocation);
                if (assignment.getParent() instanceof ExpressionStatement)                 sourceRewriter.replace(assignment.getParent(),expressionStatement,null);
              }
            }
          }
        }
      }
    }
  }
}"
12242,"private void modifyTypeFieldAssignmentsInContextClass(){
  AST contextAST=sourceTypeDeclaration.getAST();
  MethodDeclaration[] contextMethods=sourceTypeDeclaration.getMethods();
  List<String> staticFieldNames=typeCheckElimination.getStaticFieldNames();
  for (  MethodDeclaration methodDeclaration : contextMethods) {
    Block methodBody=methodDeclaration.getBody();
    if (methodBody != null) {
      List<Statement> statements=methodBody.statements();
      ExpressionExtractor expressionExtractor=new ExpressionExtractor();
      for (      Statement statement : statements) {
        List<Expression> assignments=expressionExtractor.getAssignments(statement);
        for (        Expression expression : assignments) {
          Assignment assignment=(Assignment)expression;
          Expression leftHandSide=assignment.getLeftHandSide();
          SimpleName assignedVariable=null;
          Expression invoker=null;
          if (leftHandSide instanceof SimpleName) {
            assignedVariable=(SimpleName)leftHandSide;
          }
 else           if (leftHandSide instanceof QualifiedName) {
            QualifiedName qualifiedName=(QualifiedName)leftHandSide;
            assignedVariable=qualifiedName.getName();
            invoker=qualifiedName.getQualifier();
          }
 else           if (leftHandSide instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)leftHandSide;
            assignedVariable=fieldAccess.getName();
            invoker=fieldAccess.getExpression();
          }
          IBinding leftHandBinding=assignedVariable.resolveBinding();
          if (leftHandBinding.getKind() == IBinding.VARIABLE) {
            IVariableBinding assignedVariableBinding=(IVariableBinding)leftHandBinding;
            if (assignedVariableBinding.isField() && typeCheckElimination.getTypeField().getName().getIdentifier().equals(assignedVariable.getIdentifier())) {
              MethodInvocation setterMethodInvocation=contextAST.newMethodInvocation();
              if (typeCheckElimination.getTypeFieldSetterMethod() != null) {
                sourceRewriter.set(setterMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckElimination.getTypeFieldSetterMethod().getName(),null);
              }
 else {
                sourceRewriter.set(setterMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
              }
              ListRewrite setterMethodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(setterMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
              setterMethodInvocationArgumentsRewrite.insertLast(assignment.getRightHandSide(),null);
              if (invoker != null) {
                sourceRewriter.set(setterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,invoker,null);
              }
              sourceRewriter.replace(assignment,setterMethodInvocation,null);
              Expression rightHandSide=assignment.getRightHandSide();
              SimpleName staticVariable=decomposeRightHandSide(rightHandSide);
              if (staticVariable != null) {
                IBinding rightHandBinding=staticVariable.resolveBinding();
                if (leftHandBinding.getKind() == IBinding.VARIABLE) {
                  IVariableBinding staticVariableBinding=(IVariableBinding)rightHandBinding;
                  if (staticVariableBinding.isField() && (staticVariableBinding.getModifiers() & Modifier.STATIC) != 0 && !staticFieldNames.contains(staticVariable.getIdentifier())) {
                    String subclassName=""String_Node_Str"";
                    StringTokenizer tokenizer=new StringTokenizer(staticVariable.getIdentifier(),""String_Node_Str"");
                    while (tokenizer.hasMoreTokens()) {
                      String tempName=tokenizer.nextToken().toLowerCase().toString();
                      subclassName+=tempName.subSequence(0,1).toString().toUpperCase() + tempName.subSequence(1,tempName.length()).toString();
                    }
                    additionalStaticFields.put(staticVariable.getIdentifier(),subclassName);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}","private void modifyTypeFieldAssignmentsInContextClass(){
  AST contextAST=sourceTypeDeclaration.getAST();
  MethodDeclaration[] contextMethods=sourceTypeDeclaration.getMethods();
  List<String> staticFieldNames=typeCheckElimination.getStaticFieldNames();
  for (  MethodDeclaration methodDeclaration : contextMethods) {
    Block methodBody=methodDeclaration.getBody();
    if (methodBody != null) {
      List<Statement> statements=methodBody.statements();
      ExpressionExtractor expressionExtractor=new ExpressionExtractor();
      for (      Statement statement : statements) {
        List<Expression> assignments=expressionExtractor.getAssignments(statement);
        for (        Expression expression : assignments) {
          Assignment assignment=(Assignment)expression;
          Expression leftHandSide=assignment.getLeftHandSide();
          SimpleName assignedVariable=null;
          Expression invoker=null;
          if (leftHandSide instanceof SimpleName) {
            assignedVariable=(SimpleName)leftHandSide;
          }
 else           if (leftHandSide instanceof QualifiedName) {
            QualifiedName qualifiedName=(QualifiedName)leftHandSide;
            assignedVariable=qualifiedName.getName();
            invoker=qualifiedName.getQualifier();
          }
 else           if (leftHandSide instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)leftHandSide;
            assignedVariable=fieldAccess.getName();
            invoker=fieldAccess.getExpression();
          }
          if (assignedVariable != null) {
            IBinding leftHandBinding=assignedVariable.resolveBinding();
            if (leftHandBinding.getKind() == IBinding.VARIABLE) {
              IVariableBinding assignedVariableBinding=(IVariableBinding)leftHandBinding;
              if (assignedVariableBinding.isField() && typeCheckElimination.getTypeField().getName().getIdentifier().equals(assignedVariable.getIdentifier())) {
                MethodInvocation setterMethodInvocation=contextAST.newMethodInvocation();
                if (typeCheckElimination.getTypeFieldSetterMethod() != null) {
                  sourceRewriter.set(setterMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckElimination.getTypeFieldSetterMethod().getName(),null);
                }
 else {
                  sourceRewriter.set(setterMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
                }
                ListRewrite setterMethodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(setterMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                setterMethodInvocationArgumentsRewrite.insertLast(assignment.getRightHandSide(),null);
                if (invoker != null) {
                  sourceRewriter.set(setterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,invoker,null);
                }
                sourceRewriter.replace(assignment,setterMethodInvocation,null);
                Expression rightHandSide=assignment.getRightHandSide();
                SimpleName staticVariable=decomposeRightHandSide(rightHandSide);
                if (staticVariable != null) {
                  IBinding rightHandBinding=staticVariable.resolveBinding();
                  if (leftHandBinding.getKind() == IBinding.VARIABLE) {
                    IVariableBinding staticVariableBinding=(IVariableBinding)rightHandBinding;
                    if (staticVariableBinding.isField() && (staticVariableBinding.getModifiers() & Modifier.STATIC) != 0 && !staticFieldNames.contains(staticVariable.getIdentifier())) {
                      String subclassName=""String_Node_Str"";
                      StringTokenizer tokenizer=new StringTokenizer(staticVariable.getIdentifier(),""String_Node_Str"");
                      while (tokenizer.hasMoreTokens()) {
                        String tempName=tokenizer.nextToken().toLowerCase().toString();
                        subclassName+=tempName.subSequence(0,1).toString().toUpperCase() + tempName.subSequence(1,tempName.length()).toString();
                      }
                      additionalStaticFields.put(staticVariable.getIdentifier(),subclassName);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}"
12243,"private void infixExpressionHandler(Expression operand,Expression typeCheckExpression,IfStatementExpressionAnalyzer analyzer){
  SimpleName leftOperandName=null;
  if (operand instanceof SimpleName) {
    SimpleName leftOperandSimpleName=(SimpleName)operand;
    leftOperandName=leftOperandSimpleName;
  }
 else   if (operand instanceof QualifiedName) {
    QualifiedName leftOperandQualifiedName=(QualifiedName)operand;
    leftOperandName=leftOperandQualifiedName.getName();
  }
 else   if (operand instanceof FieldAccess) {
    FieldAccess leftOperandFieldAccess=(FieldAccess)operand;
    leftOperandName=leftOperandFieldAccess.getName();
  }
 else   if (operand instanceof MethodInvocation) {
    MethodInvocation methodInvocation=(MethodInvocation)operand;
    for (    MethodDeclaration method : methods) {
      SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(method);
      if (fieldInstruction != null && method.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
        leftOperandName=fieldInstruction;
        break;
      }
      MethodInvocation delegateMethodInvocation=MethodDeclarationUtility.isDelegate(method);
      if (delegateMethodInvocation != null && method.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
        methodInvocation=delegateMethodInvocation;
        break;
      }
    }
    if (leftOperandName == null) {
      IMethodBinding methodInvocationBinding=methodInvocation.resolveMethodBinding();
      for (      InheritanceTree tree : inheritanceTreeList) {
        DefaultMutableTreeNode root=tree.getRootNode();
        String rootClassName=(String)root.getUserObject();
        ITypeBinding declaringClassTypeBinding=methodInvocationBinding.getDeclaringClass();
        if (rootClassName.equals(declaringClassTypeBinding.getQualifiedName())) {
          boolean found=false;
          for (          MethodInvocation key : typeMethodInvocationCounterMap.keySet()) {
            if (key.toString().equals(methodInvocation.toString())) {
              typeMethodInvocationCounterMap.put(key,typeMethodInvocationCounterMap.get(key) + 1);
              found=true;
            }
          }
          if (!found)           typeMethodInvocationCounterMap.put(methodInvocation,1);
          break;
        }
      }
    }
  }
  if (leftOperandName != null) {
    IBinding leftOperandNameBinding=leftOperandName.resolveBinding();
    if (leftOperandNameBinding.getKind() == IBinding.VARIABLE) {
      IVariableBinding leftOperandNameVariableBinding=(IVariableBinding)leftOperandNameBinding;
      if (leftOperandNameVariableBinding.isField() && (leftOperandNameVariableBinding.getModifiers() & Modifier.STATIC) != 0) {
        typeCheckElimination.addStaticType(analyzer.getCompleteExpression(),leftOperandName);
        typeCheckElimination.addRemainingIfStatementExpression(analyzer.getCompleteExpression(),analyzer.getRemainingExpression(typeCheckExpression));
      }
 else {
        for (        FieldDeclaration field : fields) {
          List<VariableDeclarationFragment> fragments=field.fragments();
          for (          VariableDeclarationFragment fragment : fragments) {
            IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
            if (fragmentVariableBinding.isEqualTo(leftOperandNameVariableBinding)) {
              if (fieldTypeCounterMap.containsKey(fragment)) {
                fieldTypeCounterMap.put(fragment,fieldTypeCounterMap.get(fragment) + 1);
              }
 else {
                fieldTypeCounterMap.put(fragment,1);
              }
            }
          }
        }
      }
    }
  }
}","private void infixExpressionHandler(Expression operand,Expression typeCheckExpression,IfStatementExpressionAnalyzer analyzer){
  SimpleName leftOperandName=null;
  if (operand instanceof SimpleName) {
    SimpleName leftOperandSimpleName=(SimpleName)operand;
    leftOperandName=leftOperandSimpleName;
  }
 else   if (operand instanceof QualifiedName) {
    QualifiedName leftOperandQualifiedName=(QualifiedName)operand;
    leftOperandName=leftOperandQualifiedName.getName();
  }
 else   if (operand instanceof FieldAccess) {
    FieldAccess leftOperandFieldAccess=(FieldAccess)operand;
    leftOperandName=leftOperandFieldAccess.getName();
  }
 else   if (operand instanceof MethodInvocation) {
    MethodInvocation methodInvocation=(MethodInvocation)operand;
    for (    MethodDeclaration method : methods) {
      SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(method);
      if (fieldInstruction != null && method.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
        leftOperandName=fieldInstruction;
        break;
      }
      MethodInvocation delegateMethodInvocation=MethodDeclarationUtility.isDelegate(method);
      if (delegateMethodInvocation != null && method.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
        methodInvocation=delegateMethodInvocation;
        break;
      }
    }
    if (leftOperandName == null) {
      IMethodBinding methodInvocationBinding=methodInvocation.resolveMethodBinding();
      for (      InheritanceTree tree : inheritanceTreeList) {
        DefaultMutableTreeNode root=tree.getRootNode();
        String rootClassName=(String)root.getUserObject();
        ITypeBinding declaringClassTypeBinding=methodInvocationBinding.getDeclaringClass();
        if (rootClassName.equals(declaringClassTypeBinding.getQualifiedName())) {
          boolean found=false;
          for (          MethodInvocation key : typeMethodInvocationCounterMap.keySet()) {
            if (key.toString().equals(methodInvocation.toString())) {
              typeMethodInvocationCounterMap.put(key,typeMethodInvocationCounterMap.get(key) + 1);
              found=true;
            }
          }
          if (!found)           typeMethodInvocationCounterMap.put(methodInvocation,1);
          break;
        }
      }
    }
  }
  if (leftOperandName != null) {
    IBinding leftOperandNameBinding=leftOperandName.resolveBinding();
    if (leftOperandNameBinding.getKind() == IBinding.VARIABLE) {
      IVariableBinding leftOperandNameVariableBinding=(IVariableBinding)leftOperandNameBinding;
      if (leftOperandNameVariableBinding.isField() && (leftOperandNameVariableBinding.getModifiers() & Modifier.STATIC) != 0) {
        if (analyzer.allParentNodesAreConditionalAndOperators()) {
          typeCheckElimination.addStaticType(analyzer.getCompleteExpression(),leftOperandName);
          typeCheckElimination.addRemainingIfStatementExpression(analyzer.getCompleteExpression(),analyzer.getRemainingExpression(typeCheckExpression));
        }
      }
 else {
        for (        FieldDeclaration field : fields) {
          List<VariableDeclarationFragment> fragments=field.fragments();
          for (          VariableDeclarationFragment fragment : fragments) {
            IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
            if (fragmentVariableBinding.isEqualTo(leftOperandNameVariableBinding)) {
              if (fieldTypeCounterMap.containsKey(fragment)) {
                fieldTypeCounterMap.put(fragment,fieldTypeCounterMap.get(fragment) + 1);
              }
 else {
                fieldTypeCounterMap.put(fragment,1);
              }
            }
          }
        }
      }
    }
  }
}"
12244,"private void modifyInheritanceHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  PackageDeclaration contextPackageDeclaration=sourceCompilationUnit.getPackage();
  IContainer rootContainer=contextContainer;
  if (contextPackageDeclaration != null) {
    String packageName=contextPackageDeclaration.getName().getFullyQualifiedName();
    String[] subPackages=packageName.split(""String_Node_Str"");
    for (int i=0; i < subPackages.length; i++)     rootContainer=(IContainer)rootContainer.getParent();
  }
  String abstractClassFullyQualifiedName=typeCheckElimination.getAbstractClassName();
  IFile abstractClassFile=getFile(rootContainer,abstractClassFullyQualifiedName);
  IJavaElement abstractJavaElement=JavaCore.create(abstractClassFile);
  ITextEditor abstractEditor=null;
  try {
    abstractEditor=(ITextEditor)JavaUI.openInEditor(abstractJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit abstractICompilationUnit=(ICompilationUnit)abstractJavaElement;
  ASTParser abstractParser=ASTParser.newParser(AST.JLS3);
  abstractParser.setKind(ASTParser.K_COMPILATION_UNIT);
  abstractParser.setSource(abstractICompilationUnit);
  abstractParser.setResolveBindings(true);
  CompilationUnit abstractCompilationUnit=(CompilationUnit)abstractParser.createAST(null);
  AST abstractAST=abstractCompilationUnit.getAST();
  ASTRewrite abstractRewriter=ASTRewrite.create(abstractAST);
  TypeDeclaration abstractClassTypeDeclaration=null;
  List<AbstractTypeDeclaration> abstractTypeDeclarations=abstractCompilationUnit.types();
  for (  AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
    if (abstractTypeDeclaration instanceof TypeDeclaration) {
      TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
      if (typeDeclaration.resolveBinding().getQualifiedName().equals(typeCheckElimination.getAbstractClassName())) {
        abstractClassTypeDeclaration=typeDeclaration;
        break;
      }
    }
  }
  int abstractClassModifiers=abstractClassTypeDeclaration.getModifiers();
  if ((abstractClassModifiers & Modifier.ABSTRACT) == 0) {
    ListRewrite abstractModifiersRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    abstractModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite abstractBodyRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration abstractMethodDeclaration=abstractAST.newMethodDeclaration();
  String abstractMethodName=typeCheckElimination.getTypeCheckMethodName();
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(abstractMethodName),null);
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
  ListRewrite abstractMethodModifiersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  if (typeCheckElimination.getAccessedFields().size() > 0) {
    SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
    SimpleName parameterType=abstractAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,abstractAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(abstractAST.newSimpleName(typeBinding.getName()),null);
  }
  abstractBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,abstractCompilationUnit,abstractRewriter);
  }
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer abstractTextFileBuffer=bufferManager.getTextFileBuffer(abstractClassFile.getFullPath(),LocationKind.IFILE);
  IDocument abstractDocument=abstractTextFileBuffer.getDocument();
  TextEdit abstractEdit=abstractRewriter.rewriteAST(abstractDocument,null);
  try {
    UndoEdit abstractUndoEdit=abstractEdit.apply(abstractDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(abstractClassFile,abstractDocument,abstractUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  abstractEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  DefaultMutableTreeNode root=typeCheckElimination.getExistingInheritanceTree().getRootNode();
  Enumeration<DefaultMutableTreeNode> enumeration=root.children();
  while (enumeration.hasMoreElements()) {
    DefaultMutableTreeNode child=enumeration.nextElement();
    String childClassName=(String)child.getUserObject();
    if (!subclassNames.contains(childClassName))     subclassNames.add(childClassName);
  }
  List<DefaultMutableTreeNode> remainingIfStatementExpressions=typeCheckElimination.getRemainingIfStatementExpressions();
  for (int i=0; i < subclassNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      if (!remainingIfStatementExpressions.isEmpty())       remainingIfStatementExpression=remainingIfStatementExpressions.get(i);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=getFile(rootContainer,subclassNames.get(i));
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    TypeDeclaration subclassTypeDeclaration=null;
    List<AbstractTypeDeclaration> subclassAbstractTypeDeclarations=subclassCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : subclassAbstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.resolveBinding().getQualifiedName().equals(subclassNames.get(i))) {
          subclassTypeDeclaration=typeDeclaration;
          break;
        }
      }
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    String concreteMethodName=typeCheckElimination.getTypeCheckMethodName();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(concreteMethodName),null);
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
    Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
    Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,subclassRewriter,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    if (returnedVariable != null) {
      VariableDeclarationFragment variableDeclarationFragment=subclassAST.newVariableDeclarationFragment();
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariable.getName(),null);
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,returnedVariable.getInitializer(),null);
      VariableDeclarationStatement variableDeclarationStatement=subclassAST.newVariableDeclarationStatement(variableDeclarationFragment);
      subclassRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertFirst(variableDeclarationStatement,null);
 else       concreteMethodBodyRewrite.insertFirst(variableDeclarationStatement,null);
    }
    SimpleName invokerSimpleName=null;
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      boolean insert=true;
      if (statement instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)statement;
        List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
        VariableDeclarationFragment fragment=fragments.get(0);
        if (fragment.getInitializer() instanceof CastExpression) {
          CastExpression castExpression=(CastExpression)fragment.getInitializer();
          if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
            invokerSimpleName=fragment.getName();
            insert=false;
          }
        }
      }
      if (invokerSimpleName != null) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(newStatement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            Expression methodInvocationExpression=methodInvocation.getExpression();
            if (methodInvocationExpression instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)methodInvocationExpression;
              if (simpleName.getIdentifier().equals(invokerSimpleName.getIdentifier())) {
                subclassRewriter.remove(simpleName,null);
              }
            }
          }
        }
      }
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      if (insert) {
        if (ifStatementBodyRewrite != null)         ifStatementBodyRewrite.insertLast(newStatement,null);
 else         concreteMethodBodyRewrite.insertLast(newStatement,null);
      }
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(returnStatement,null);
 else       concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}","private void modifyInheritanceHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  PackageDeclaration contextPackageDeclaration=sourceCompilationUnit.getPackage();
  IContainer rootContainer=contextContainer;
  if (contextPackageDeclaration != null) {
    String packageName=contextPackageDeclaration.getName().getFullyQualifiedName();
    String[] subPackages=packageName.split(""String_Node_Str"");
    for (int i=0; i < subPackages.length; i++)     rootContainer=(IContainer)rootContainer.getParent();
  }
  String abstractClassFullyQualifiedName=typeCheckElimination.getAbstractClassName();
  IFile abstractClassFile=getFile(rootContainer,abstractClassFullyQualifiedName);
  IJavaElement abstractJavaElement=JavaCore.create(abstractClassFile);
  ITextEditor abstractEditor=null;
  try {
    abstractEditor=(ITextEditor)JavaUI.openInEditor(abstractJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit abstractICompilationUnit=(ICompilationUnit)abstractJavaElement;
  ASTParser abstractParser=ASTParser.newParser(AST.JLS3);
  abstractParser.setKind(ASTParser.K_COMPILATION_UNIT);
  abstractParser.setSource(abstractICompilationUnit);
  abstractParser.setResolveBindings(true);
  CompilationUnit abstractCompilationUnit=(CompilationUnit)abstractParser.createAST(null);
  AST abstractAST=abstractCompilationUnit.getAST();
  ASTRewrite abstractRewriter=ASTRewrite.create(abstractAST);
  TypeDeclaration abstractClassTypeDeclaration=null;
  List<AbstractTypeDeclaration> abstractTypeDeclarations=abstractCompilationUnit.types();
  for (  AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
    if (abstractTypeDeclaration instanceof TypeDeclaration) {
      TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
      if (typeDeclaration.resolveBinding().getQualifiedName().equals(typeCheckElimination.getAbstractClassName())) {
        abstractClassTypeDeclaration=typeDeclaration;
        break;
      }
    }
  }
  int abstractClassModifiers=abstractClassTypeDeclaration.getModifiers();
  if ((abstractClassModifiers & Modifier.ABSTRACT) == 0) {
    ListRewrite abstractModifiersRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    abstractModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite abstractBodyRewrite=abstractRewriter.getListRewrite(abstractClassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration abstractMethodDeclaration=abstractAST.newMethodDeclaration();
  String abstractMethodName=typeCheckElimination.getTypeCheckMethodName();
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(abstractMethodName),null);
  abstractRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
  ListRewrite abstractMethodModifiersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(abstractAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  if (typeCheckElimination.getAccessedFields().size() > 0) {
    SingleVariableDeclaration parameter=abstractAST.newSingleVariableDeclaration();
    SimpleName parameterType=abstractAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    abstractRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,abstractAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    abstractRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,abstractAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=abstractRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(abstractAST.newSimpleName(typeBinding.getName()),null);
  }
  abstractBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,abstractCompilationUnit,abstractRewriter);
  }
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer abstractTextFileBuffer=bufferManager.getTextFileBuffer(abstractClassFile.getFullPath(),LocationKind.IFILE);
  IDocument abstractDocument=abstractTextFileBuffer.getDocument();
  TextEdit abstractEdit=abstractRewriter.rewriteAST(abstractDocument,null);
  try {
    UndoEdit abstractUndoEdit=abstractEdit.apply(abstractDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(abstractClassFile,abstractDocument,abstractUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  abstractEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  DefaultMutableTreeNode root=typeCheckElimination.getExistingInheritanceTree().getRootNode();
  Enumeration<DefaultMutableTreeNode> enumeration=root.children();
  while (enumeration.hasMoreElements()) {
    DefaultMutableTreeNode child=enumeration.nextElement();
    String childClassName=(String)child.getUserObject();
    if (!subclassNames.contains(childClassName))     subclassNames.add(childClassName);
  }
  List<DefaultMutableTreeNode> remainingIfStatementExpressions=typeCheckElimination.getRemainingIfStatementExpressions();
  for (int i=0; i < subclassNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      if (!remainingIfStatementExpressions.isEmpty())       remainingIfStatementExpression=remainingIfStatementExpressions.get(i);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=getFile(rootContainer,subclassNames.get(i));
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    TypeDeclaration subclassTypeDeclaration=null;
    List<AbstractTypeDeclaration> subclassAbstractTypeDeclarations=subclassCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : subclassAbstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.resolveBinding().getQualifiedName().equals(subclassNames.get(i))) {
          subclassTypeDeclaration=typeDeclaration;
          break;
        }
      }
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    String concreteMethodName=typeCheckElimination.getTypeCheckMethodName();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(concreteMethodName),null);
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
    Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
    Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    if (returnedVariable != null) {
      VariableDeclarationFragment variableDeclarationFragment=subclassAST.newVariableDeclarationFragment();
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariable.getName(),null);
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,returnedVariable.getInitializer(),null);
      VariableDeclarationStatement variableDeclarationStatement=subclassAST.newVariableDeclarationStatement(variableDeclarationFragment);
      subclassRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertFirst(variableDeclarationStatement,null);
 else       concreteMethodBodyRewrite.insertFirst(variableDeclarationStatement,null);
    }
    SimpleName invokerSimpleName=null;
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      boolean insert=true;
      if (statement instanceof VariableDeclarationStatement) {
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)statement;
        List<VariableDeclarationFragment> fragments=variableDeclarationStatement.fragments();
        VariableDeclarationFragment fragment=fragments.get(0);
        if (fragment.getInitializer() instanceof CastExpression) {
          CastExpression castExpression=(CastExpression)fragment.getInitializer();
          if (castExpression.getType().resolveBinding().isEqualTo(subclassTypeDeclaration.resolveBinding())) {
            invokerSimpleName=fragment.getName();
            insert=false;
          }
        }
      }
      if (invokerSimpleName != null) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(newStatement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            Expression methodInvocationExpression=methodInvocation.getExpression();
            if (methodInvocationExpression instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)methodInvocationExpression;
              if (simpleName.getIdentifier().equals(invokerSimpleName.getIdentifier())) {
                subclassRewriter.remove(simpleName,null);
              }
            }
          }
        }
      }
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      if (insert) {
        if (ifStatementBodyRewrite != null)         ifStatementBodyRewrite.insertLast(newStatement,null);
 else         concreteMethodBodyRewrite.insertLast(newStatement,null);
      }
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(returnStatement,null);
 else       concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}"
12245,"private Expression constructExpression(AST ast,ASTRewrite rewriter,DefaultMutableTreeNode node){
  Object object=node.getUserObject();
  if (object instanceof InfixExpression.Operator) {
    InfixExpression.Operator operator=(InfixExpression.Operator)object;
    InfixExpression infixExpression=ast.newInfixExpression();
    rewriter.set(infixExpression,InfixExpression.OPERATOR_PROPERTY,operator,null);
    DefaultMutableTreeNode leftChild=(DefaultMutableTreeNode)node.getChildAt(0);
    DefaultMutableTreeNode rightChild=(DefaultMutableTreeNode)node.getChildAt(1);
    rewriter.set(infixExpression,InfixExpression.LEFT_OPERAND_PROPERTY,constructExpression(ast,rewriter,leftChild),null);
    rewriter.set(infixExpression,InfixExpression.RIGHT_OPERAND_PROPERTY,constructExpression(ast,rewriter,rightChild),null);
    return infixExpression;
  }
 else   if (object instanceof Expression) {
    Expression expression=(Expression)object;
    return expression;
  }
  return null;
}","private Expression constructExpression(AST ast,DefaultMutableTreeNode node){
  Object object=node.getUserObject();
  if (object instanceof InfixExpression.Operator) {
    InfixExpression.Operator operator=(InfixExpression.Operator)object;
    InfixExpression infixExpression=ast.newInfixExpression();
    infixExpression.setOperator(operator);
    DefaultMutableTreeNode leftChild=(DefaultMutableTreeNode)node.getChildAt(0);
    DefaultMutableTreeNode rightChild=(DefaultMutableTreeNode)node.getChildAt(1);
    infixExpression.setLeftOperand(constructExpression(ast,leftChild));
    infixExpression.setRightOperand(constructExpression(ast,rightChild));
    return infixExpression;
  }
 else   if (object instanceof Expression) {
    Expression expression=(Expression)object;
    return (Expression)ASTNode.copySubtree(ast,expression);
  }
  return null;
}"
12246,"private void createStateStrategyHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  IFile stateStrategyFile=null;
  if (contextContainer instanceof IProject) {
    IProject contextProject=(IProject)contextContainer;
    stateStrategyFile=contextProject.getFile(typeCheckElimination.getAbstractClassName() + ""String_Node_Str"");
  }
 else   if (contextContainer instanceof IFolder) {
    IFolder contextFolder=(IFolder)contextContainer;
    stateStrategyFile=contextFolder.getFile(typeCheckElimination.getAbstractClassName() + ""String_Node_Str"");
  }
  boolean stateStrategyAlreadyExists=false;
  try {
    stateStrategyFile.create(new ByteArrayInputStream(""String_Node_Str"".getBytes()),true,null);
    undoRefactoring.addNewlyCreatedFile(stateStrategyFile);
  }
 catch (  CoreException e) {
    stateStrategyAlreadyExists=true;
  }
  IJavaElement stateStrategyJavaElement=JavaCore.create(stateStrategyFile);
  ITextEditor stateStrategyEditor=null;
  try {
    stateStrategyEditor=(ITextEditor)JavaUI.openInEditor(stateStrategyJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit stateStrategyICompilationUnit=(ICompilationUnit)stateStrategyJavaElement;
  ASTParser stateStrategyParser=ASTParser.newParser(AST.JLS3);
  stateStrategyParser.setKind(ASTParser.K_COMPILATION_UNIT);
  stateStrategyParser.setSource(stateStrategyICompilationUnit);
  stateStrategyParser.setResolveBindings(true);
  CompilationUnit stateStrategyCompilationUnit=(CompilationUnit)stateStrategyParser.createAST(null);
  AST stateStrategyAST=stateStrategyCompilationUnit.getAST();
  ASTRewrite stateStrategyRewriter=ASTRewrite.create(stateStrategyAST);
  ListRewrite stateStrategyTypesRewrite=stateStrategyRewriter.getListRewrite(stateStrategyCompilationUnit,CompilationUnit.TYPES_PROPERTY);
  TypeDeclaration stateStrategyTypeDeclaration=null;
  if (stateStrategyAlreadyExists) {
    List<AbstractTypeDeclaration> abstractTypeDeclarations=stateStrategyCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.getName().getIdentifier().equals(typeCheckElimination.getAbstractClassName())) {
          stateStrategyTypeDeclaration=typeDeclaration;
          int stateStrategyModifiers=stateStrategyTypeDeclaration.getModifiers();
          if ((stateStrategyModifiers & Modifier.ABSTRACT) == 0) {
            ListRewrite stateStrategyModifiersRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
            stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
          }
          break;
        }
      }
    }
  }
 else {
    if (sourceCompilationUnit.getPackage() != null) {
      stateStrategyRewriter.set(stateStrategyCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,sourceCompilationUnit.getPackage(),null);
    }
    stateStrategyTypeDeclaration=stateStrategyAST.newTypeDeclaration();
    SimpleName stateStrategyName=stateStrategyAST.newSimpleName(typeCheckElimination.getAbstractClassName());
    stateStrategyRewriter.set(stateStrategyTypeDeclaration,TypeDeclaration.NAME_PROPERTY,stateStrategyName,null);
    ListRewrite stateStrategyModifiersRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite stateStrategyBodyRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  if (getterMethod != null) {
    MethodDeclaration abstractGetterMethodDeclaration=stateStrategyAST.newMethodDeclaration();
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,getterMethod.getName(),null);
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,getterMethod.getReturnType2(),null);
    ListRewrite abstractGetterMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
    stateStrategyBodyRewrite.insertLast(abstractGetterMethodDeclaration,null);
  }
 else {
    MethodDeclaration abstractGetterMethodDeclaration=stateStrategyAST.newMethodDeclaration();
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type returnType=((FieldDeclaration)typeField.getParent()).getType();
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    ListRewrite abstractGetterMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
    stateStrategyBodyRewrite.insertLast(abstractGetterMethodDeclaration,null);
  }
  MethodDeclaration abstractMethodDeclaration=stateStrategyAST.newMethodDeclaration();
  String abstractMethodName=typeCheckElimination.getTypeCheckMethodName();
  stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(abstractMethodName),null);
  stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
  ListRewrite abstractMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0) {
    SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
    SimpleName parameterType=stateStrategyAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,stateStrategyAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(stateStrategyAST.newSimpleName(typeBinding.getName()),null);
  }
  stateStrategyBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,stateStrategyCompilationUnit,stateStrategyRewriter);
  }
  if (!stateStrategyAlreadyExists)   stateStrategyTypesRewrite.insertLast(stateStrategyTypeDeclaration,null);
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer stateStrategyTextFileBuffer=bufferManager.getTextFileBuffer(stateStrategyFile.getFullPath(),LocationKind.IFILE);
  IDocument stateStrategyDocument=stateStrategyTextFileBuffer.getDocument();
  TextEdit stateStrategyEdit=stateStrategyRewriter.rewriteAST(stateStrategyDocument,null);
  try {
    UndoEdit stateStrategyUndoEdit=stateStrategyEdit.apply(stateStrategyDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(stateStrategyFile,stateStrategyDocument,stateStrategyUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  stateStrategyEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  subclassNames.addAll(additionalStaticFields.values());
  List<String> staticFieldNames=typeCheckElimination.getStaticFieldNames();
  staticFieldNames.addAll(additionalStaticFields.keySet());
  List<DefaultMutableTreeNode> remainingIfStatementExpressions=typeCheckElimination.getRemainingIfStatementExpressions();
  for (int i=0; i < staticFieldNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      if (!remainingIfStatementExpressions.isEmpty())       remainingIfStatementExpression=remainingIfStatementExpressions.get(i);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=null;
    if (contextContainer instanceof IProject) {
      IProject contextProject=(IProject)contextContainer;
      subclassFile=contextProject.getFile(subclassNames.get(i) + ""String_Node_Str"");
    }
 else     if (contextContainer instanceof IFolder) {
      IFolder contextFolder=(IFolder)contextContainer;
      subclassFile=contextFolder.getFile(subclassNames.get(i) + ""String_Node_Str"");
    }
    boolean subclassAlreadyExists=false;
    try {
      subclassFile.create(new ByteArrayInputStream(""String_Node_Str"".getBytes()),true,null);
      undoRefactoring.addNewlyCreatedFile(subclassFile);
    }
 catch (    CoreException e) {
      subclassAlreadyExists=true;
    }
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    ListRewrite subclassTypesRewrite=subclassRewriter.getListRewrite(subclassCompilationUnit,CompilationUnit.TYPES_PROPERTY);
    TypeDeclaration subclassTypeDeclaration=null;
    if (subclassAlreadyExists) {
      List<AbstractTypeDeclaration> abstractTypeDeclarations=subclassCompilationUnit.types();
      for (      AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
        if (abstractTypeDeclaration instanceof TypeDeclaration) {
          TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
          if (typeDeclaration.getName().getIdentifier().equals(subclassNames.get(i))) {
            subclassTypeDeclaration=typeDeclaration;
            break;
          }
        }
      }
    }
 else {
      if (sourceCompilationUnit.getPackage() != null) {
        subclassRewriter.set(subclassCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,sourceCompilationUnit.getPackage(),null);
      }
      subclassTypeDeclaration=subclassAST.newTypeDeclaration();
      SimpleName subclassName=subclassAST.newSimpleName(subclassNames.get(i));
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.NAME_PROPERTY,subclassName,null);
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,subclassAST.newSimpleType(subclassAST.newSimpleName(typeCheckElimination.getAbstractClassName())),null);
      ListRewrite subclassModifiersRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
      subclassModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    if (getterMethod != null) {
      MethodDeclaration concreteGetterMethodDeclaration=subclassAST.newMethodDeclaration();
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,getterMethod.getName(),null);
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,getterMethod.getReturnType2(),null);
      ListRewrite concreteGetterMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
      concreteGetterMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      Block concreteGetterMethodBody=subclassAST.newBlock();
      ListRewrite concreteGetterMethodBodyRewrite=subclassRewriter.getListRewrite(concreteGetterMethodBody,Block.STATEMENTS_PROPERTY);
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      FieldAccess fieldAccess=subclassAST.newFieldAccess();
      subclassRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,subclassAST.newSimpleName(staticFieldNames.get(i)),null);
      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,sourceTypeDeclaration.getName(),null);
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fieldAccess,null);
      concreteGetterMethodBodyRewrite.insertLast(returnStatement,null);
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteGetterMethodBody,null);
      subclassBodyRewrite.insertLast(concreteGetterMethodDeclaration,null);
    }
 else {
      MethodDeclaration concreteGetterMethodDeclaration=subclassAST.newMethodDeclaration();
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
      VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
      Type returnType=((FieldDeclaration)typeField.getParent()).getType();
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      ListRewrite concreteGetterMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
      concreteGetterMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      Block concreteGetterMethodBody=subclassAST.newBlock();
      ListRewrite concreteGetterMethodBodyRewrite=subclassRewriter.getListRewrite(concreteGetterMethodBody,Block.STATEMENTS_PROPERTY);
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      FieldAccess fieldAccess=subclassAST.newFieldAccess();
      subclassRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,subclassAST.newSimpleName(staticFieldNames.get(i)),null);
      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,sourceTypeDeclaration.getName(),null);
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fieldAccess,null);
      concreteGetterMethodBodyRewrite.insertLast(returnStatement,null);
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteGetterMethodBody,null);
      subclassBodyRewrite.insertLast(concreteGetterMethodDeclaration,null);
    }
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    String concreteMethodName=typeCheckElimination.getTypeCheckMethodName();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(concreteMethodName),null);
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
    Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
    Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,subclassRewriter,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    if (returnedVariable != null) {
      VariableDeclarationFragment variableDeclarationFragment=subclassAST.newVariableDeclarationFragment();
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariable.getName(),null);
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,returnedVariable.getInitializer(),null);
      VariableDeclarationStatement variableDeclarationStatement=subclassAST.newVariableDeclarationStatement(variableDeclarationFragment);
      subclassRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertFirst(variableDeclarationStatement,null);
 else       concreteMethodBodyRewrite.insertFirst(variableDeclarationStatement,null);
    }
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(newStatement,null);
 else       concreteMethodBodyRewrite.insertLast(newStatement,null);
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(returnStatement,null);
 else       concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    if (!subclassAlreadyExists)     subclassTypesRewrite.insertLast(subclassTypeDeclaration,null);
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}","private void createStateStrategyHierarchy(){
  IContainer contextContainer=(IContainer)sourceFile.getParent();
  IFile stateStrategyFile=null;
  if (contextContainer instanceof IProject) {
    IProject contextProject=(IProject)contextContainer;
    stateStrategyFile=contextProject.getFile(typeCheckElimination.getAbstractClassName() + ""String_Node_Str"");
  }
 else   if (contextContainer instanceof IFolder) {
    IFolder contextFolder=(IFolder)contextContainer;
    stateStrategyFile=contextFolder.getFile(typeCheckElimination.getAbstractClassName() + ""String_Node_Str"");
  }
  boolean stateStrategyAlreadyExists=false;
  try {
    stateStrategyFile.create(new ByteArrayInputStream(""String_Node_Str"".getBytes()),true,null);
    undoRefactoring.addNewlyCreatedFile(stateStrategyFile);
  }
 catch (  CoreException e) {
    stateStrategyAlreadyExists=true;
  }
  IJavaElement stateStrategyJavaElement=JavaCore.create(stateStrategyFile);
  ITextEditor stateStrategyEditor=null;
  try {
    stateStrategyEditor=(ITextEditor)JavaUI.openInEditor(stateStrategyJavaElement);
  }
 catch (  PartInitException e) {
    e.printStackTrace();
  }
catch (  JavaModelException e) {
    e.printStackTrace();
  }
  ICompilationUnit stateStrategyICompilationUnit=(ICompilationUnit)stateStrategyJavaElement;
  ASTParser stateStrategyParser=ASTParser.newParser(AST.JLS3);
  stateStrategyParser.setKind(ASTParser.K_COMPILATION_UNIT);
  stateStrategyParser.setSource(stateStrategyICompilationUnit);
  stateStrategyParser.setResolveBindings(true);
  CompilationUnit stateStrategyCompilationUnit=(CompilationUnit)stateStrategyParser.createAST(null);
  AST stateStrategyAST=stateStrategyCompilationUnit.getAST();
  ASTRewrite stateStrategyRewriter=ASTRewrite.create(stateStrategyAST);
  ListRewrite stateStrategyTypesRewrite=stateStrategyRewriter.getListRewrite(stateStrategyCompilationUnit,CompilationUnit.TYPES_PROPERTY);
  TypeDeclaration stateStrategyTypeDeclaration=null;
  if (stateStrategyAlreadyExists) {
    List<AbstractTypeDeclaration> abstractTypeDeclarations=stateStrategyCompilationUnit.types();
    for (    AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
      if (abstractTypeDeclaration instanceof TypeDeclaration) {
        TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
        if (typeDeclaration.getName().getIdentifier().equals(typeCheckElimination.getAbstractClassName())) {
          stateStrategyTypeDeclaration=typeDeclaration;
          int stateStrategyModifiers=stateStrategyTypeDeclaration.getModifiers();
          if ((stateStrategyModifiers & Modifier.ABSTRACT) == 0) {
            ListRewrite stateStrategyModifiersRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
            stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
          }
          break;
        }
      }
    }
  }
 else {
    if (sourceCompilationUnit.getPackage() != null) {
      stateStrategyRewriter.set(stateStrategyCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,sourceCompilationUnit.getPackage(),null);
    }
    stateStrategyTypeDeclaration=stateStrategyAST.newTypeDeclaration();
    SimpleName stateStrategyName=stateStrategyAST.newSimpleName(typeCheckElimination.getAbstractClassName());
    stateStrategyRewriter.set(stateStrategyTypeDeclaration,TypeDeclaration.NAME_PROPERTY,stateStrategyName,null);
    ListRewrite stateStrategyModifiersRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
    stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    stateStrategyModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  }
  ListRewrite stateStrategyBodyRewrite=stateStrategyRewriter.getListRewrite(stateStrategyTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  if (getterMethod != null) {
    MethodDeclaration abstractGetterMethodDeclaration=stateStrategyAST.newMethodDeclaration();
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,getterMethod.getName(),null);
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,getterMethod.getReturnType2(),null);
    ListRewrite abstractGetterMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
    stateStrategyBodyRewrite.insertLast(abstractGetterMethodDeclaration,null);
  }
 else {
    MethodDeclaration abstractGetterMethodDeclaration=stateStrategyAST.newMethodDeclaration();
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type returnType=((FieldDeclaration)typeField.getParent()).getType();
    stateStrategyRewriter.set(abstractGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    ListRewrite abstractGetterMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    abstractGetterMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
    stateStrategyBodyRewrite.insertLast(abstractGetterMethodDeclaration,null);
  }
  MethodDeclaration abstractMethodDeclaration=stateStrategyAST.newMethodDeclaration();
  String abstractMethodName=typeCheckElimination.getTypeCheckMethodName();
  stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(abstractMethodName),null);
  stateStrategyRewriter.set(abstractMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
  ListRewrite abstractMethodModifiersRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  abstractMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
  abstractMethodModifiersRewrite.insertLast(stateStrategyAST.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD),null);
  ListRewrite abstractMethodParametersRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
    abstractMethodParametersRewrite.insertLast(abstractMethodParameter,null);
  }
  for (  VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
    if (!fragment.equals(returnedVariable)) {
      SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
      VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
      stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
      stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
      abstractMethodParametersRewrite.insertLast(parameter,null);
    }
  }
  if (typeCheckElimination.getAccessedFields().size() > 0 || typeCheckElimination.getAssignedFields().size() > 0 || typeCheckElimination.getAccessedMethods().size() > 0) {
    SingleVariableDeclaration parameter=stateStrategyAST.newSingleVariableDeclaration();
    SimpleName parameterType=stateStrategyAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
    stateStrategyRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,stateStrategyAST.newSimpleType(parameterType),null);
    String parameterName=sourceTypeDeclaration.getName().getIdentifier();
    parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
    stateStrategyRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,stateStrategyAST.newSimpleName(parameterName),null);
    abstractMethodParametersRewrite.insertLast(parameter,null);
  }
  ListRewrite abstractMethodThrownExceptionsRewrite=stateStrategyRewriter.getListRewrite(abstractMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  ITypeBinding typeBinding : thrownExceptions) {
    abstractMethodThrownExceptionsRewrite.insertLast(stateStrategyAST.newSimpleName(typeBinding.getName()),null);
  }
  stateStrategyBodyRewrite.insertLast(abstractMethodDeclaration,null);
  generateRequiredImportDeclarationsBasedOnSignature();
  for (  ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
    addImportDeclaration(typeBinding,stateStrategyCompilationUnit,stateStrategyRewriter);
  }
  if (!stateStrategyAlreadyExists)   stateStrategyTypesRewrite.insertLast(stateStrategyTypeDeclaration,null);
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer stateStrategyTextFileBuffer=bufferManager.getTextFileBuffer(stateStrategyFile.getFullPath(),LocationKind.IFILE);
  IDocument stateStrategyDocument=stateStrategyTextFileBuffer.getDocument();
  TextEdit stateStrategyEdit=stateStrategyRewriter.rewriteAST(stateStrategyDocument,null);
  try {
    UndoEdit stateStrategyUndoEdit=stateStrategyEdit.apply(stateStrategyDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(stateStrategyFile,stateStrategyDocument,stateStrategyUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  stateStrategyEditor.doSave(null);
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  subclassNames.addAll(additionalStaticFields.values());
  List<String> staticFieldNames=typeCheckElimination.getStaticFieldNames();
  staticFieldNames.addAll(additionalStaticFields.keySet());
  List<DefaultMutableTreeNode> remainingIfStatementExpressions=typeCheckElimination.getRemainingIfStatementExpressions();
  for (int i=0; i < staticFieldNames.size(); i++) {
    ArrayList<Statement> statements=null;
    DefaultMutableTreeNode remainingIfStatementExpression=null;
    if (i < typeCheckStatements.size()) {
      statements=typeCheckStatements.get(i);
      if (!remainingIfStatementExpressions.isEmpty())       remainingIfStatementExpression=remainingIfStatementExpressions.get(i);
    }
 else {
      statements=typeCheckElimination.getDefaultCaseStatements();
    }
    IFile subclassFile=null;
    if (contextContainer instanceof IProject) {
      IProject contextProject=(IProject)contextContainer;
      subclassFile=contextProject.getFile(subclassNames.get(i) + ""String_Node_Str"");
    }
 else     if (contextContainer instanceof IFolder) {
      IFolder contextFolder=(IFolder)contextContainer;
      subclassFile=contextFolder.getFile(subclassNames.get(i) + ""String_Node_Str"");
    }
    boolean subclassAlreadyExists=false;
    try {
      subclassFile.create(new ByteArrayInputStream(""String_Node_Str"".getBytes()),true,null);
      undoRefactoring.addNewlyCreatedFile(subclassFile);
    }
 catch (    CoreException e) {
      subclassAlreadyExists=true;
    }
    IJavaElement subclassJavaElement=JavaCore.create(subclassFile);
    ITextEditor subclassEditor=null;
    try {
      subclassEditor=(ITextEditor)JavaUI.openInEditor(subclassJavaElement);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    JavaModelException e) {
      e.printStackTrace();
    }
    ICompilationUnit subclassICompilationUnit=(ICompilationUnit)subclassJavaElement;
    ASTParser subclassParser=ASTParser.newParser(AST.JLS3);
    subclassParser.setKind(ASTParser.K_COMPILATION_UNIT);
    subclassParser.setSource(subclassICompilationUnit);
    subclassParser.setResolveBindings(true);
    CompilationUnit subclassCompilationUnit=(CompilationUnit)subclassParser.createAST(null);
    AST subclassAST=subclassCompilationUnit.getAST();
    ASTRewrite subclassRewriter=ASTRewrite.create(subclassAST);
    ListRewrite subclassTypesRewrite=subclassRewriter.getListRewrite(subclassCompilationUnit,CompilationUnit.TYPES_PROPERTY);
    TypeDeclaration subclassTypeDeclaration=null;
    if (subclassAlreadyExists) {
      List<AbstractTypeDeclaration> abstractTypeDeclarations=subclassCompilationUnit.types();
      for (      AbstractTypeDeclaration abstractTypeDeclaration : abstractTypeDeclarations) {
        if (abstractTypeDeclaration instanceof TypeDeclaration) {
          TypeDeclaration typeDeclaration=(TypeDeclaration)abstractTypeDeclaration;
          if (typeDeclaration.getName().getIdentifier().equals(subclassNames.get(i))) {
            subclassTypeDeclaration=typeDeclaration;
            break;
          }
        }
      }
    }
 else {
      if (sourceCompilationUnit.getPackage() != null) {
        subclassRewriter.set(subclassCompilationUnit,CompilationUnit.PACKAGE_PROPERTY,sourceCompilationUnit.getPackage(),null);
      }
      subclassTypeDeclaration=subclassAST.newTypeDeclaration();
      SimpleName subclassName=subclassAST.newSimpleName(subclassNames.get(i));
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.NAME_PROPERTY,subclassName,null);
      subclassRewriter.set(subclassTypeDeclaration,TypeDeclaration.SUPERCLASS_TYPE_PROPERTY,subclassAST.newSimpleType(subclassAST.newSimpleName(typeCheckElimination.getAbstractClassName())),null);
      ListRewrite subclassModifiersRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.MODIFIERS2_PROPERTY);
      subclassModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    }
    ListRewrite subclassBodyRewrite=subclassRewriter.getListRewrite(subclassTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
    if (getterMethod != null) {
      MethodDeclaration concreteGetterMethodDeclaration=subclassAST.newMethodDeclaration();
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,getterMethod.getName(),null);
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,getterMethod.getReturnType2(),null);
      ListRewrite concreteGetterMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
      concreteGetterMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      Block concreteGetterMethodBody=subclassAST.newBlock();
      ListRewrite concreteGetterMethodBodyRewrite=subclassRewriter.getListRewrite(concreteGetterMethodBody,Block.STATEMENTS_PROPERTY);
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      FieldAccess fieldAccess=subclassAST.newFieldAccess();
      subclassRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,subclassAST.newSimpleName(staticFieldNames.get(i)),null);
      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,sourceTypeDeclaration.getName(),null);
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fieldAccess,null);
      concreteGetterMethodBodyRewrite.insertLast(returnStatement,null);
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteGetterMethodBody,null);
      subclassBodyRewrite.insertLast(concreteGetterMethodDeclaration,null);
    }
 else {
      MethodDeclaration concreteGetterMethodDeclaration=subclassAST.newMethodDeclaration();
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
      VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
      Type returnType=((FieldDeclaration)typeField.getParent()).getType();
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
      ListRewrite concreteGetterMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteGetterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
      concreteGetterMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
      Block concreteGetterMethodBody=subclassAST.newBlock();
      ListRewrite concreteGetterMethodBodyRewrite=subclassRewriter.getListRewrite(concreteGetterMethodBody,Block.STATEMENTS_PROPERTY);
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      FieldAccess fieldAccess=subclassAST.newFieldAccess();
      subclassRewriter.set(fieldAccess,FieldAccess.NAME_PROPERTY,subclassAST.newSimpleName(staticFieldNames.get(i)),null);
      subclassRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,sourceTypeDeclaration.getName(),null);
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,fieldAccess,null);
      concreteGetterMethodBodyRewrite.insertLast(returnStatement,null);
      subclassRewriter.set(concreteGetterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteGetterMethodBody,null);
      subclassBodyRewrite.insertLast(concreteGetterMethodDeclaration,null);
    }
    MethodDeclaration concreteMethodDeclaration=subclassAST.newMethodDeclaration();
    String concreteMethodName=typeCheckElimination.getTypeCheckMethodName();
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(concreteMethodName),null);
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
    ListRewrite concreteMethodModifiersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    concreteMethodModifiersRewrite.insertLast(subclassAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite concreteMethodParametersRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      concreteMethodParametersRewrite.insertLast(abstractMethodParameter,null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
        VariableDeclarationStatement variableDeclarationStatement=(VariableDeclarationStatement)fragment.getParent();
        subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
        subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,fragment.getName(),null);
        concreteMethodParametersRewrite.insertLast(parameter,null);
      }
    }
    Set<VariableDeclarationFragment> accessedFields=typeCheckElimination.getAccessedFields();
    Set<VariableDeclarationFragment> assignedFields=typeCheckElimination.getAssignedFields();
    Set<MethodDeclaration> accessedMethods=typeCheckElimination.getAccessedMethods();
    if (accessedFields.size() > 0 || assignedFields.size() > 0 || accessedMethods.size() > 0) {
      SingleVariableDeclaration parameter=subclassAST.newSingleVariableDeclaration();
      SimpleName parameterType=subclassAST.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
      subclassRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,subclassAST.newSimpleType(parameterType),null);
      String parameterName=sourceTypeDeclaration.getName().getIdentifier();
      parameterName=parameterName.substring(0,1).toLowerCase() + parameterName.substring(1,parameterName.length());
      subclassRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,subclassAST.newSimpleName(parameterName),null);
      concreteMethodParametersRewrite.insertLast(parameter,null);
    }
    ListRewrite concreteMethodThrownExceptionsRewrite=subclassRewriter.getListRewrite(concreteMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
    for (    ITypeBinding typeBinding : thrownExceptions) {
      concreteMethodThrownExceptionsRewrite.insertLast(subclassAST.newSimpleName(typeBinding.getName()),null);
    }
    Block concreteMethodBody=subclassAST.newBlock();
    ListRewrite concreteMethodBodyRewrite=subclassRewriter.getListRewrite(concreteMethodBody,Block.STATEMENTS_PROPERTY);
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    ListRewrite ifStatementBodyRewrite=null;
    if (remainingIfStatementExpression != null) {
      IfStatement enclosingIfStatement=subclassAST.newIfStatement();
      Expression enclosingIfStatementExpression=constructExpression(subclassAST,remainingIfStatementExpression);
      Expression newEnclosingIfStatementExpression=(Expression)ASTNode.copySubtree(subclassAST,enclosingIfStatementExpression);
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newEnclosingIfStatementExpression);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(enclosingIfStatementExpression);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newEnclosingIfStatementExpression);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      subclassRewriter.set(enclosingIfStatement,IfStatement.EXPRESSION_PROPERTY,newEnclosingIfStatementExpression,null);
      Block ifStatementBody=subclassAST.newBlock();
      ifStatementBodyRewrite=subclassRewriter.getListRewrite(ifStatementBody,Block.STATEMENTS_PROPERTY);
      subclassRewriter.set(enclosingIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,ifStatementBody,null);
      concreteMethodBodyRewrite.insertLast(enclosingIfStatement,null);
    }
    if (returnedVariable != null) {
      VariableDeclarationFragment variableDeclarationFragment=subclassAST.newVariableDeclarationFragment();
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,returnedVariable.getName(),null);
      subclassRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,returnedVariable.getInitializer(),null);
      VariableDeclarationStatement variableDeclarationStatement=subclassAST.newVariableDeclarationStatement(variableDeclarationFragment);
      subclassRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,typeCheckElimination.getTypeCheckMethodReturnType(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertFirst(variableDeclarationStatement,null);
 else       concreteMethodBodyRewrite.insertFirst(variableDeclarationStatement,null);
    }
    for (    Statement statement : statements) {
      Statement newStatement=(Statement)ASTNode.copySubtree(subclassAST,statement);
      List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(newStatement);
      modifyVariableInstructionsInSubclass(variableInstructions,subclassAST,subclassRewriter,accessedFields,assignedFields);
      List<Expression> oldMethodInvocations=expressionExtractor.getMethodInvocations(statement);
      List<Expression> newMethodInvocations=expressionExtractor.getMethodInvocations(newStatement);
      modifyMethodInvocationsInSubclass(oldMethodInvocations,newMethodInvocations,subclassAST,subclassRewriter,accessedMethods);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(newStatement,null);
 else       concreteMethodBodyRewrite.insertLast(newStatement,null);
    }
    if (returnedVariable != null) {
      ReturnStatement returnStatement=subclassAST.newReturnStatement();
      subclassRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnedVariable.getName(),null);
      if (ifStatementBodyRewrite != null)       ifStatementBodyRewrite.insertLast(returnStatement,null);
 else       concreteMethodBodyRewrite.insertLast(returnStatement,null);
    }
    subclassRewriter.set(concreteMethodDeclaration,MethodDeclaration.BODY_PROPERTY,concreteMethodBody,null);
    subclassBodyRewrite.insertLast(concreteMethodDeclaration,null);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnSignature) {
      addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    Set<ITypeBinding> requiredImportDeclarationsBasedOnBranch=generateRequiredImportDeclarationsBasedOnBranch(statements);
    for (    ITypeBinding typeBinding : requiredImportDeclarationsBasedOnBranch) {
      if (!requiredImportDeclarationsBasedOnSignature.contains(typeBinding))       addImportDeclaration(typeBinding,subclassCompilationUnit,subclassRewriter);
    }
    if (!subclassAlreadyExists)     subclassTypesRewrite.insertLast(subclassTypeDeclaration,null);
    ITextFileBuffer subclassTextFileBuffer=bufferManager.getTextFileBuffer(subclassFile.getFullPath(),LocationKind.IFILE);
    IDocument subclassDocument=subclassTextFileBuffer.getDocument();
    TextEdit subclassEdit=subclassRewriter.rewriteAST(subclassDocument,null);
    try {
      UndoEdit subclassUndoEdit=subclassEdit.apply(subclassDocument,UndoEdit.CREATE_UNDO);
      undoRefactoring.put(subclassFile,subclassDocument,subclassUndoEdit);
    }
 catch (    MalformedTreeException e) {
      e.printStackTrace();
    }
catch (    BadLocationException e) {
      e.printStackTrace();
    }
    subclassEditor.doSave(null);
  }
}"
12247,"private Expression constructExpression(AST ast,ASTRewrite rewriter,DefaultMutableTreeNode node){
  Object object=node.getUserObject();
  if (object instanceof InfixExpression.Operator) {
    InfixExpression.Operator operator=(InfixExpression.Operator)object;
    InfixExpression infixExpression=ast.newInfixExpression();
    rewriter.set(infixExpression,InfixExpression.OPERATOR_PROPERTY,operator,null);
    DefaultMutableTreeNode leftChild=(DefaultMutableTreeNode)node.getChildAt(0);
    DefaultMutableTreeNode rightChild=(DefaultMutableTreeNode)node.getChildAt(1);
    rewriter.set(infixExpression,InfixExpression.LEFT_OPERAND_PROPERTY,constructExpression(ast,rewriter,leftChild),null);
    rewriter.set(infixExpression,InfixExpression.RIGHT_OPERAND_PROPERTY,constructExpression(ast,rewriter,rightChild),null);
    return infixExpression;
  }
 else   if (object instanceof Expression) {
    Expression expression=(Expression)object;
    return expression;
  }
  return null;
}","private Expression constructExpression(AST ast,DefaultMutableTreeNode node){
  Object object=node.getUserObject();
  if (object instanceof InfixExpression.Operator) {
    InfixExpression.Operator operator=(InfixExpression.Operator)object;
    InfixExpression infixExpression=ast.newInfixExpression();
    infixExpression.setOperator(operator);
    DefaultMutableTreeNode leftChild=(DefaultMutableTreeNode)node.getChildAt(0);
    DefaultMutableTreeNode rightChild=(DefaultMutableTreeNode)node.getChildAt(1);
    infixExpression.setLeftOperand(constructExpression(ast,leftChild));
    infixExpression.setRightOperand(constructExpression(ast,rightChild));
    return infixExpression;
  }
 else   if (object instanceof Expression) {
    Expression expression=(Expression)object;
    return (Expression)ASTNode.copySubtree(ast,expression);
  }
  return null;
}"
12248,"private void modifyContext(){
  AST contextAST=sourceTypeDeclaration.getAST();
  ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  VariableDeclarationFragment typeFragment=contextAST.newVariableDeclarationFragment();
  sourceRewriter.set(typeFragment,VariableDeclarationFragment.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
  FieldDeclaration typeFieldDeclaration=contextAST.newFieldDeclaration(typeFragment);
  sourceRewriter.set(typeFieldDeclaration,FieldDeclaration.TYPE_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getAbstractClassName()),null);
  ListRewrite typeFieldDeclrationModifiersRewrite=sourceRewriter.getListRewrite(typeFieldDeclaration,FieldDeclaration.MODIFIERS2_PROPERTY);
  typeFieldDeclrationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD),null);
  contextBodyRewrite.insertFirst(typeFieldDeclaration,null);
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  for (  FieldDeclaration fieldDeclaration : fieldDeclarations) {
    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      if (fragment.equals(typeCheckElimination.getTypeField())) {
        if (fragments.size() == 1) {
          contextBodyRewrite.remove(fragment.getParent(),null);
        }
 else {
          ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(fragment.getParent(),FieldDeclaration.FRAGMENTS_PROPERTY);
          fragmentRewrite.remove(fragment,null);
        }
      }
    }
  }
  modifyTypeFieldAssignmentsInContextClass();
  MethodDeclaration setterMethod=typeCheckElimination.getTypeFieldSetterMethod();
  SwitchStatement switchStatement=contextAST.newSwitchStatement();
  List<SimpleName> staticFieldNames=typeCheckElimination.getStaticFields();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  ListRewrite switchStatementStatementsRewrite=sourceRewriter.getListRewrite(switchStatement,SwitchStatement.STATEMENTS_PROPERTY);
  int i=0;
  for (  SimpleName staticFieldName : staticFieldNames) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,staticFieldName,null);
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(subclassNames.get(i)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    i++;
  }
  for (  String staticFieldName : additionalStaticFields.keySet()) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,contextAST.newSimpleName(staticFieldName),null);
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(additionalStaticFields.get(staticFieldName)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
  }
  if (setterMethod != null) {
    List<SingleVariableDeclaration> setterMethodParameters=setterMethod.parameters();
    if (setterMethodParameters.size() == 1) {
      sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,setterMethodParameters.get(0).getName(),null);
    }
    Block setterMethodBody=setterMethod.getBody();
    List<Statement> setterMethodBodyStatements=setterMethodBody.statements();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    if (setterMethodBodyStatements.size() == 1) {
      setterMethodBodyRewrite.replace(setterMethodBodyStatements.get(0),switchStatement,null);
    }
  }
 else {
    MethodDeclaration setterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,contextAST.newPrimitiveType(PrimitiveType.VOID),null);
    ListRewrite setterMethodModifiersRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    setterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite setterMethodParameterRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    SingleVariableDeclaration parameter=contextAST.newSingleVariableDeclaration();
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type parameterType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,typeField.getName(),null);
    setterMethodParameterRewrite.insertLast(parameter,null);
    sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,typeField.getName(),null);
    Block setterMethodBody=contextAST.newBlock();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    setterMethodBodyRewrite.insertLast(switchStatement,null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,setterMethodBody,null);
    contextBodyRewrite.insertLast(setterMethodDeclaration,null);
  }
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  if (getterMethod != null) {
    Block getterMethodBody=getterMethod.getBody();
    List<Statement> getterMethodBodyStatements=getterMethodBody.statements();
    ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
    if (getterMethodBodyStatements.size() == 1) {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
      sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,getterMethod.getName(),null);
      sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
      getterMethodBodyRewrite.replace(getterMethodBodyStatements.get(0),returnStatement,null);
    }
  }
 else {
    MethodDeclaration getterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type returnType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    ListRewrite getterMethodModifiersRewrite=sourceRewriter.getListRewrite(getterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    getterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ReturnStatement returnStatement=contextAST.newReturnStatement();
    MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
    Block getterMethodBody=contextAST.newBlock();
    ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
    getterMethodBodyRewrite.insertLast(returnStatement,null);
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,getterMethodBody,null);
    contextBodyRewrite.insertLast(getterMethodDeclaration,null);
  }
  MethodDeclaration typeCheckMethod=typeCheckElimination.getTypeCheckMethod();
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  Type typeCheckMethodReturnType=typeCheckMethod.getReturnType2();
  if (typeCheckMethodReturnType.isPrimitiveType() && ((PrimitiveType)typeCheckMethodReturnType).getPrimitiveTypeCode().equals(PrimitiveType.VOID)) {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    ExpressionStatement expressionStatement=contextAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    if (typeCheckElimination.getAccessedFields().size() > 0) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    if (returnedVariable != null) {
      Assignment assignment=contextAST.newAssignment();
      sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
      ExpressionStatement expressionStatement=contextAST.newExpressionStatement(assignment);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
    }
 else {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractMethodInvocation,null);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),returnStatement,null);
    }
  }
  generateGettersForAccessedFields();
  setPublicModifierToStaticFields();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","private void modifyContext(){
  AST contextAST=sourceTypeDeclaration.getAST();
  ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  VariableDeclarationFragment typeFragment=contextAST.newVariableDeclarationFragment();
  sourceRewriter.set(typeFragment,VariableDeclarationFragment.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
  FieldDeclaration typeFieldDeclaration=contextAST.newFieldDeclaration(typeFragment);
  sourceRewriter.set(typeFieldDeclaration,FieldDeclaration.TYPE_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getAbstractClassName()),null);
  ListRewrite typeFieldDeclrationModifiersRewrite=sourceRewriter.getListRewrite(typeFieldDeclaration,FieldDeclaration.MODIFIERS2_PROPERTY);
  typeFieldDeclrationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD),null);
  contextBodyRewrite.insertFirst(typeFieldDeclaration,null);
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  for (  FieldDeclaration fieldDeclaration : fieldDeclarations) {
    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      if (fragment.equals(typeCheckElimination.getTypeField())) {
        if (fragments.size() == 1) {
          contextBodyRewrite.remove(fragment.getParent(),null);
        }
 else {
          ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(fragment.getParent(),FieldDeclaration.FRAGMENTS_PROPERTY);
          fragmentRewrite.remove(fragment,null);
        }
      }
    }
  }
  modifyTypeFieldAssignmentsInContextClass();
  MethodDeclaration setterMethod=typeCheckElimination.getTypeFieldSetterMethod();
  SwitchStatement switchStatement=contextAST.newSwitchStatement();
  List<SimpleName> staticFieldNames=typeCheckElimination.getStaticFields();
  List<String> subclassNames=typeCheckElimination.getSubclassNames();
  ListRewrite switchStatementStatementsRewrite=sourceRewriter.getListRewrite(switchStatement,SwitchStatement.STATEMENTS_PROPERTY);
  int i=0;
  for (  SimpleName staticFieldName : staticFieldNames) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,staticFieldName,null);
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(subclassNames.get(i)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
    i++;
  }
  for (  String staticFieldName : additionalStaticFields.keySet()) {
    SwitchCase switchCase=contextAST.newSwitchCase();
    sourceRewriter.set(switchCase,SwitchCase.EXPRESSION_PROPERTY,contextAST.newSimpleName(staticFieldName),null);
    switchStatementStatementsRewrite.insertLast(switchCase,null);
    Assignment assignment=contextAST.newAssignment();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    FieldAccess typeFieldAccess=contextAST.newFieldAccess();
    sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
    sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
    ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
    sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(additionalStaticFields.get(staticFieldName)),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
    switchStatementStatementsRewrite.insertLast(contextAST.newExpressionStatement(assignment),null);
  }
  if (setterMethod != null) {
    List<SingleVariableDeclaration> setterMethodParameters=setterMethod.parameters();
    if (setterMethodParameters.size() == 1) {
      sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,setterMethodParameters.get(0).getName(),null);
    }
    Block setterMethodBody=setterMethod.getBody();
    List<Statement> setterMethodBodyStatements=setterMethodBody.statements();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    if (setterMethodBodyStatements.size() == 1) {
      setterMethodBodyRewrite.replace(setterMethodBodyStatements.get(0),switchStatement,null);
    }
  }
 else {
    MethodDeclaration setterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,contextAST.newPrimitiveType(PrimitiveType.VOID),null);
    ListRewrite setterMethodModifiersRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    setterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ListRewrite setterMethodParameterRewrite=sourceRewriter.getListRewrite(setterMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
    SingleVariableDeclaration parameter=contextAST.newSingleVariableDeclaration();
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type parameterType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
    sourceRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,typeField.getName(),null);
    setterMethodParameterRewrite.insertLast(parameter,null);
    sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,typeField.getName(),null);
    Block setterMethodBody=contextAST.newBlock();
    ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
    setterMethodBodyRewrite.insertLast(switchStatement,null);
    sourceRewriter.set(setterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,setterMethodBody,null);
    contextBodyRewrite.insertLast(setterMethodDeclaration,null);
  }
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  if (getterMethod != null) {
    Block getterMethodBody=getterMethod.getBody();
    List<Statement> getterMethodBodyStatements=getterMethodBody.statements();
    ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
    if (getterMethodBodyStatements.size() == 1) {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
      sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,getterMethod.getName(),null);
      sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
      getterMethodBodyRewrite.replace(getterMethodBodyStatements.get(0),returnStatement,null);
    }
  }
 else {
    MethodDeclaration getterMethodDeclaration=contextAST.newMethodDeclaration();
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    VariableDeclarationFragment typeField=typeCheckElimination.getTypeField();
    Type returnType=((FieldDeclaration)typeField.getParent()).getType();
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,returnType,null);
    ListRewrite getterMethodModifiersRewrite=sourceRewriter.getListRewrite(getterMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
    getterMethodModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD),null);
    ReturnStatement returnStatement=contextAST.newReturnStatement();
    MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,contextAST.newSimpleName(""String_Node_Str"" + typeCheckElimination.getAbstractClassName()),null);
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
    Block getterMethodBody=contextAST.newBlock();
    ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
    getterMethodBodyRewrite.insertLast(returnStatement,null);
    sourceRewriter.set(getterMethodDeclaration,MethodDeclaration.BODY_PROPERTY,getterMethodBody,null);
    contextBodyRewrite.insertLast(getterMethodDeclaration,null);
  }
  MethodDeclaration typeCheckMethod=typeCheckElimination.getTypeCheckMethod();
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  Type typeCheckMethodReturnType=typeCheckMethod.getReturnType2();
  if (typeCheckMethodReturnType.isPrimitiveType() && ((PrimitiveType)typeCheckMethodReturnType).getPrimitiveTypeCode().equals(PrimitiveType.VOID)) {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    for (    VariableDeclarationFragment fragment : typeCheckElimination.getAccessedLocalVariables()) {
      if (!fragment.equals(returnedVariable)) {
        methodInvocationArgumentsRewrite.insertLast(fragment.getName(),null);
      }
    }
    if (typeCheckElimination.getAccessedFields().size() > 0) {
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    ExpressionStatement expressionStatement=contextAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    if (typeCheckElimination.getAccessedFields().size() > 0) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    if (returnedVariable != null) {
      Assignment assignment=contextAST.newAssignment();
      sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
      ExpressionStatement expressionStatement=contextAST.newExpressionStatement(assignment);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
    }
 else {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractMethodInvocation,null);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),returnStatement,null);
    }
  }
  generateGettersForAccessedFields();
  setPublicModifierToStaticFields();
  modifyTypeFieldAccessesInContextClass();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12249,"private void processTypeCheckCodeFragment(){
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  ArrayList<Statement> firstBlockOfStatements=typeCheckStatements.get(0);
  Statement firstStatementOfBlock=firstBlockOfStatements.get(0);
  if (firstStatementOfBlock.getParent() instanceof SwitchStatement) {
    SwitchStatement switchStatement=(SwitchStatement)firstStatementOfBlock.getParent();
    Expression switchStatementExpression=switchStatement.getExpression();
    SimpleName switchStatementExpressionName=null;
    if (switchStatementExpression instanceof SimpleName) {
      SimpleName simpleName=(SimpleName)switchStatementExpression;
      switchStatementExpressionName=simpleName;
    }
 else     if (switchStatementExpression instanceof FieldAccess) {
      FieldAccess fieldAccess=(FieldAccess)switchStatementExpression;
      switchStatementExpressionName=fieldAccess.getName();
    }
 else     if (switchStatementExpression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)switchStatementExpression;
      for (      MethodDeclaration method : methods) {
        SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(method);
        if (fieldInstruction != null && method.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding()))         switchStatementExpressionName=fieldInstruction;
      }
      if (switchStatementExpressionName == null) {
        IMethodBinding methodInvocationBinding=methodInvocation.resolveMethodBinding();
        if ((methodInvocationBinding.getModifiers() & Modifier.ABSTRACT) != 0) {
          for (          InheritanceTree tree : inheritanceTreeList) {
            DefaultMutableTreeNode root=tree.getRootNode();
            String rootClassName=(String)root.getUserObject();
            ITypeBinding declaringClassTypeBinding=methodInvocationBinding.getDeclaringClass();
            if (rootClassName.equals(declaringClassTypeBinding.getQualifiedName())) {
              typeCheckElimination.setTypeMethodInvocation(methodInvocation);
              typeCheckElimination.setExistingInheritanceTree(tree);
              break;
            }
          }
        }
      }
    }
    IBinding switchStatementExpressionNameBinding=switchStatementExpressionName.resolveBinding();
    IVariableBinding switchStatementExpressionNameVariableBinding=null;
    if (switchStatementExpressionNameBinding.getKind() == IBinding.VARIABLE)     switchStatementExpressionNameVariableBinding=(IVariableBinding)switchStatementExpressionNameBinding;
    for (    FieldDeclaration field : fields) {
      List<VariableDeclarationFragment> fragments=field.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
        if (fragmentVariableBinding.isEqualTo(switchStatementExpressionNameVariableBinding)) {
          typeCheckElimination.setTypeField(fragment);
          for (          MethodDeclaration method : methods) {
            SimpleName fieldInstruction=MethodDeclarationUtility.isSetter(method);
            if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
              typeCheckElimination.setTypeFieldSetterMethod(method);
            }
            fieldInstruction=MethodDeclarationUtility.isGetter(method);
            if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
              typeCheckElimination.setTypeFieldGetterMethod(method);
            }
          }
          break;
        }
      }
    }
  }
  Set<Expression> typeCheckExpressions=typeCheckElimination.getTypeCheckExpressions();
  for (  Expression typeCheckExpression : typeCheckExpressions) {
    if (typeCheckExpression.getParent() instanceof SwitchCase) {
      if (typeCheckExpression instanceof SimpleName) {
        SimpleName simpleName=(SimpleName)typeCheckExpression;
        IBinding binding=simpleName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
            typeCheckElimination.addStaticType(typeCheckExpression,simpleName);
          }
        }
      }
 else       if (typeCheckExpression instanceof QualifiedName) {
        QualifiedName qualifiedName=(QualifiedName)typeCheckExpression;
        IBinding binding=qualifiedName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
            typeCheckElimination.addStaticType(typeCheckExpression,qualifiedName.getName());
          }
        }
      }
 else       if (typeCheckExpression instanceof FieldAccess) {
        FieldAccess fieldAccess=(FieldAccess)typeCheckExpression;
        IVariableBinding variableBinding=fieldAccess.resolveFieldBinding();
        if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
          typeCheckElimination.addStaticType(typeCheckExpression,fieldAccess.getName());
        }
      }
    }
 else     if (typeCheckExpression instanceof InfixExpression) {
      InfixExpression infixExpression=(InfixExpression)typeCheckExpression;
      IfStatementExpressionAnalyzer analyzer=new IfStatementExpressionAnalyzer(infixExpression);
      for (      InfixExpression leafInfixExpression : analyzer.getInfixExpressionsWithEqualsOperator()) {
        Expression leftOperand=leafInfixExpression.getLeftOperand();
        Expression rightOperand=leafInfixExpression.getRightOperand();
        infixExpressionHandler(leftOperand,leafInfixExpression,analyzer);
        infixExpressionHandler(rightOperand,leafInfixExpression,analyzer);
      }
    }
  }
  for (  VariableDeclarationFragment fragment : fieldTypeCounterMap.keySet()) {
    if (fieldTypeCounterMap.get(fragment) == typeCheckExpressions.size()) {
      typeCheckElimination.setTypeField(fragment);
      for (      MethodDeclaration method : methods) {
        SimpleName fieldInstruction=MethodDeclarationUtility.isSetter(method);
        if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
          typeCheckElimination.setTypeFieldSetterMethod(method);
        }
        fieldInstruction=MethodDeclarationUtility.isGetter(method);
        if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
          typeCheckElimination.setTypeFieldGetterMethod(method);
        }
      }
    }
  }
  for (  MethodInvocation methodInvocation : typeMethodInvocationCounterMap.keySet()) {
    if (typeMethodInvocationCounterMap.get(methodInvocation) == typeCheckExpressions.size()) {
      typeCheckElimination.setTypeMethodInvocation(methodInvocation);
      IMethodBinding methodInvocationBinding=methodInvocation.resolveMethodBinding();
      for (      InheritanceTree tree : inheritanceTreeList) {
        DefaultMutableTreeNode root=tree.getRootNode();
        String rootClassName=(String)root.getUserObject();
        ITypeBinding declaringClassTypeBinding=methodInvocationBinding.getDeclaringClass();
        if (rootClassName.equals(declaringClassTypeBinding.getQualifiedName())) {
          typeCheckElimination.setExistingInheritanceTree(tree);
          break;
        }
      }
    }
  }
}","private void processTypeCheckCodeFragment(){
  List<ArrayList<Statement>> typeCheckStatements=typeCheckElimination.getTypeCheckStatements();
  ArrayList<Statement> firstBlockOfStatements=typeCheckStatements.get(0);
  Statement firstStatementOfBlock=firstBlockOfStatements.get(0);
  if (firstStatementOfBlock.getParent() instanceof SwitchStatement) {
    SwitchStatement switchStatement=(SwitchStatement)firstStatementOfBlock.getParent();
    Expression switchStatementExpression=switchStatement.getExpression();
    SimpleName switchStatementExpressionName=null;
    if (switchStatementExpression instanceof SimpleName) {
      SimpleName simpleName=(SimpleName)switchStatementExpression;
      switchStatementExpressionName=simpleName;
    }
 else     if (switchStatementExpression instanceof QualifiedName) {
      QualifiedName qualifiedName=(QualifiedName)switchStatementExpression;
      switchStatementExpressionName=qualifiedName.getName();
    }
 else     if (switchStatementExpression instanceof FieldAccess) {
      FieldAccess fieldAccess=(FieldAccess)switchStatementExpression;
      switchStatementExpressionName=fieldAccess.getName();
    }
 else     if (switchStatementExpression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)switchStatementExpression;
      for (      MethodDeclaration method : methods) {
        SimpleName fieldInstruction=MethodDeclarationUtility.isGetter(method);
        if (fieldInstruction != null && method.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding()))         switchStatementExpressionName=fieldInstruction;
      }
      if (switchStatementExpressionName == null) {
        IMethodBinding methodInvocationBinding=methodInvocation.resolveMethodBinding();
        if ((methodInvocationBinding.getModifiers() & Modifier.ABSTRACT) != 0) {
          for (          InheritanceTree tree : inheritanceTreeList) {
            DefaultMutableTreeNode root=tree.getRootNode();
            String rootClassName=(String)root.getUserObject();
            ITypeBinding declaringClassTypeBinding=methodInvocationBinding.getDeclaringClass();
            if (rootClassName.equals(declaringClassTypeBinding.getQualifiedName())) {
              typeCheckElimination.setTypeMethodInvocation(methodInvocation);
              typeCheckElimination.setExistingInheritanceTree(tree);
              break;
            }
          }
        }
      }
    }
    if (switchStatementExpressionName != null) {
      IBinding switchStatementExpressionNameBinding=switchStatementExpressionName.resolveBinding();
      if (switchStatementExpressionNameBinding.getKind() == IBinding.VARIABLE) {
        IVariableBinding switchStatementExpressionNameVariableBinding=(IVariableBinding)switchStatementExpressionNameBinding;
        for (        FieldDeclaration field : fields) {
          List<VariableDeclarationFragment> fragments=field.fragments();
          for (          VariableDeclarationFragment fragment : fragments) {
            IVariableBinding fragmentVariableBinding=fragment.resolveBinding();
            if (fragmentVariableBinding.isEqualTo(switchStatementExpressionNameVariableBinding)) {
              typeCheckElimination.setTypeField(fragment);
              for (              MethodDeclaration method : methods) {
                SimpleName fieldInstruction=MethodDeclarationUtility.isSetter(method);
                if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                  typeCheckElimination.setTypeFieldSetterMethod(method);
                }
                fieldInstruction=MethodDeclarationUtility.isGetter(method);
                if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
                  typeCheckElimination.setTypeFieldGetterMethod(method);
                }
              }
              break;
            }
          }
        }
      }
    }
  }
  Set<Expression> typeCheckExpressions=typeCheckElimination.getTypeCheckExpressions();
  for (  Expression typeCheckExpression : typeCheckExpressions) {
    if (typeCheckExpression.getParent() instanceof SwitchCase) {
      if (typeCheckExpression instanceof SimpleName) {
        SimpleName simpleName=(SimpleName)typeCheckExpression;
        IBinding binding=simpleName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
            typeCheckElimination.addStaticType(typeCheckExpression,simpleName);
          }
        }
      }
 else       if (typeCheckExpression instanceof QualifiedName) {
        QualifiedName qualifiedName=(QualifiedName)typeCheckExpression;
        IBinding binding=qualifiedName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
            typeCheckElimination.addStaticType(typeCheckExpression,qualifiedName.getName());
          }
        }
      }
 else       if (typeCheckExpression instanceof FieldAccess) {
        FieldAccess fieldAccess=(FieldAccess)typeCheckExpression;
        IVariableBinding variableBinding=fieldAccess.resolveFieldBinding();
        if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0) {
          typeCheckElimination.addStaticType(typeCheckExpression,fieldAccess.getName());
        }
      }
    }
 else     if (typeCheckExpression instanceof InfixExpression) {
      InfixExpression infixExpression=(InfixExpression)typeCheckExpression;
      IfStatementExpressionAnalyzer analyzer=new IfStatementExpressionAnalyzer(infixExpression);
      for (      InfixExpression leafInfixExpression : analyzer.getInfixExpressionsWithEqualsOperator()) {
        Expression leftOperand=leafInfixExpression.getLeftOperand();
        Expression rightOperand=leafInfixExpression.getRightOperand();
        infixExpressionHandler(leftOperand,leafInfixExpression,analyzer);
        infixExpressionHandler(rightOperand,leafInfixExpression,analyzer);
      }
    }
  }
  for (  VariableDeclarationFragment fragment : fieldTypeCounterMap.keySet()) {
    if (fieldTypeCounterMap.get(fragment) == typeCheckExpressions.size()) {
      typeCheckElimination.setTypeField(fragment);
      for (      MethodDeclaration method : methods) {
        SimpleName fieldInstruction=MethodDeclarationUtility.isSetter(method);
        if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
          typeCheckElimination.setTypeFieldSetterMethod(method);
        }
        fieldInstruction=MethodDeclarationUtility.isGetter(method);
        if (fieldInstruction != null && fragment.getName().getIdentifier().equals(fieldInstruction.getIdentifier())) {
          typeCheckElimination.setTypeFieldGetterMethod(method);
        }
      }
    }
  }
  for (  MethodInvocation methodInvocation : typeMethodInvocationCounterMap.keySet()) {
    if (typeMethodInvocationCounterMap.get(methodInvocation) == typeCheckExpressions.size()) {
      typeCheckElimination.setTypeMethodInvocation(methodInvocation);
      IMethodBinding methodInvocationBinding=methodInvocation.resolveMethodBinding();
      for (      InheritanceTree tree : inheritanceTreeList) {
        DefaultMutableTreeNode root=tree.getRootNode();
        String rootClassName=(String)root.getUserObject();
        ITypeBinding declaringClassTypeBinding=methodInvocationBinding.getDeclaringClass();
        if (rootClassName.equals(declaringClassTypeBinding.getQualifiedName())) {
          typeCheckElimination.setExistingInheritanceTree(tree);
          break;
        }
      }
    }
  }
}"
12250,"public static Set<String> intersection(Set<String> set1,Set<String> set2){
  Set<String> set=new HashSet<String>();
  for (  String s1 : set1) {
    for (    String s2 : set2) {
      if (s1.equals(s2))       set.add(s1);
    }
  }
  return set;
}","public static Set<String> intersection(Set<String> set1,Set<String> set2){
  Set<String> set=new HashSet<String>();
  set.addAll(set1);
  set.retainAll(set2);
  return set;
}"
12251,"public List<String> getSubclassNames(){
  List<String> subclassNames=new ArrayList<String>();
  for (  Expression expression : staticFieldMap.keySet()) {
    SimpleName simpleName=staticFieldMap.get(expression);
    String staticFieldName=simpleName.getIdentifier();
    Type castingType=isFirstStatementACastingVariableDeclaration(typeCheckMap.get(expression));
    if (!staticFieldName.contains(""String_Node_Str"")) {
      String subclassName=staticFieldName.substring(0,1).toUpperCase() + staticFieldName.substring(1,staticFieldName.length()).toLowerCase();
      if (existingInheritanceTree != null && castingType != null) {
        DefaultMutableTreeNode root=existingInheritanceTree.getRootNode();
        Enumeration<DefaultMutableTreeNode> enumeration=root.children();
        boolean found=false;
        while (enumeration.hasMoreElements()) {
          DefaultMutableTreeNode child=enumeration.nextElement();
          String childClassName=(String)child.getUserObject();
          if (castingType.resolveBinding().getQualifiedName().equals(childClassName)) {
            subclassNames.add(childClassName);
            found=true;
            break;
          }
        }
        if (!found)         subclassNames.add(null);
      }
 else {
        subclassNames.add(subclassName);
      }
    }
 else {
      String finalName=""String_Node_Str"";
      StringTokenizer tokenizer=new StringTokenizer(staticFieldName,""String_Node_Str"");
      while (tokenizer.hasMoreTokens()) {
        String tempName=tokenizer.nextToken().toLowerCase().toString();
        finalName+=tempName.subSequence(0,1).toString().toUpperCase() + tempName.subSequence(1,tempName.length()).toString();
      }
      if (existingInheritanceTree != null && castingType != null) {
        DefaultMutableTreeNode root=existingInheritanceTree.getRootNode();
        Enumeration<DefaultMutableTreeNode> enumeration=root.children();
        boolean found=false;
        while (enumeration.hasMoreElements()) {
          DefaultMutableTreeNode child=enumeration.nextElement();
          String childClassName=(String)child.getUserObject();
          if (castingType.resolveBinding().getQualifiedName().equals(childClassName)) {
            subclassNames.add(childClassName);
            found=true;
            break;
          }
        }
        if (!found)         subclassNames.add(null);
      }
 else {
        subclassNames.add(finalName);
      }
    }
  }
  return subclassNames;
}","public List<String> getSubclassNames(){
  List<String> subclassNames=new ArrayList<String>();
  for (  Expression expression : staticFieldMap.keySet()) {
    SimpleName simpleName=staticFieldMap.get(expression);
    String staticFieldName=simpleName.getIdentifier();
    Type castingType=isFirstStatementACastingVariableDeclaration(typeCheckMap.get(expression));
    String subclassName=null;
    if (!staticFieldName.contains(""String_Node_Str"")) {
      subclassName=staticFieldName.substring(0,1).toUpperCase() + staticFieldName.substring(1,staticFieldName.length()).toLowerCase();
    }
 else {
      subclassName=""String_Node_Str"";
      StringTokenizer tokenizer=new StringTokenizer(staticFieldName,""String_Node_Str"");
      while (tokenizer.hasMoreTokens()) {
        String tempName=tokenizer.nextToken().toLowerCase().toString();
        subclassName+=tempName.subSequence(0,1).toString().toUpperCase() + tempName.subSequence(1,tempName.length()).toString();
      }
    }
    if (existingInheritanceTree != null) {
      DefaultMutableTreeNode root=existingInheritanceTree.getRootNode();
      Enumeration<DefaultMutableTreeNode> enumeration=root.children();
      boolean found=false;
      while (enumeration.hasMoreElements()) {
        DefaultMutableTreeNode child=enumeration.nextElement();
        String childClassName=(String)child.getUserObject();
        if (childClassName.endsWith(subclassName)) {
          subclassNames.add(childClassName);
          found=true;
          break;
        }
 else         if (castingType != null && castingType.resolveBinding().getQualifiedName().equals(childClassName)) {
          subclassNames.add(childClassName);
          found=true;
          break;
        }
      }
      if (!found)       subclassNames.add(null);
    }
 else {
      subclassNames.add(subclassName);
    }
  }
  return subclassNames;
}"
12252,"private void extractMethod(){
  AST ast=sourceTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  SimpleName returnVariableSimpleName=extractionBlock.getReturnVariableDeclarationFragment().getName();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractionBlock.getExtractedMethodName()),null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,extractionBlock.getReturnVariableDeclarationStatement().getType(),null);
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier modifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  modifierRewrite.insertLast(modifier,null);
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<SimpleName> extractedMethodArguments=new ArrayList<SimpleName>();
  List<String> extractedMethodArgumentIdentifiers=new ArrayList<String>();
  List<String> variableDeclarationIdentifiers=new ArrayList<String>();
  for (  VariableDeclarationFragment fragment : extractionBlock.getAdditionalRequiredVariableDeclarationFragments())   variableDeclarationIdentifiers.add(fragment.getName().getIdentifier());
  if (extractionBlock.getParentStatementForCopy() != null) {
    Statement parentStatementForCopy=extractionBlock.getParentStatementForCopy();
    if (parentStatementForCopy.getNodeType() == Statement.IF_STATEMENT) {
      IfStatement ifStatement=(IfStatement)parentStatementForCopy;
      List<Expression> list=extractor.getVariableInstructions(ifStatement.getExpression());
      for (      Expression expression : list) {
        SimpleName simpleName=(SimpleName)expression;
        IBinding binding=simpleName.resolveBinding();
        if (binding.getKind() == IBinding.VARIABLE) {
          IVariableBinding variableBinding=(IVariableBinding)binding;
          String simpleNameIdentifier=simpleName.getIdentifier();
          if (!variableBinding.isField() && !simpleName.isDeclaration() && !returnVariableSimpleName.getIdentifier().equals(simpleNameIdentifier)) {
            if (!extractedMethodArgumentIdentifiers.contains(simpleNameIdentifier) && !variableDeclarationIdentifiers.contains(simpleNameIdentifier)) {
              extractedMethodArgumentIdentifiers.add(simpleNameIdentifier);
              extractedMethodArguments.add(simpleName);
            }
          }
 else {
            if (!variableDeclarationIdentifiers.contains(simpleNameIdentifier))             variableDeclarationIdentifiers.add(simpleNameIdentifier);
          }
        }
      }
    }
  }
  for (  Statement statement : extractionBlock.getStatementsForExtraction()) {
    List<Expression> list=extractor.getVariableInstructions(statement);
    for (    Expression expression : list) {
      SimpleName simpleName=(SimpleName)expression;
      IBinding binding=simpleName.resolveBinding();
      if (binding.getKind() == IBinding.VARIABLE) {
        IVariableBinding variableBinding=(IVariableBinding)binding;
        String simpleNameIdentifier=simpleName.getIdentifier();
        if (!variableBinding.isField() && !simpleName.isDeclaration() && !returnVariableSimpleName.getIdentifier().equals(simpleNameIdentifier)) {
          if (!extractedMethodArgumentIdentifiers.contains(simpleNameIdentifier) && !variableDeclarationIdentifiers.contains(simpleNameIdentifier)) {
            extractedMethodArgumentIdentifiers.add(simpleNameIdentifier);
            extractedMethodArguments.add(simpleName);
          }
        }
 else {
          if (!variableDeclarationIdentifiers.contains(simpleNameIdentifier))           variableDeclarationIdentifiers.add(simpleNameIdentifier);
        }
      }
    }
  }
  ListRewrite paramRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SimpleName argument : extractedMethodArguments) {
    Type argumentVariableDeclarationType=null;
    for (    VariableDeclarationStatement statement : extractionBlock.getAllVariableDeclarationStatements()) {
      List<VariableDeclarationFragment> fragmentList=statement.fragments();
      for (      VariableDeclarationFragment fragment : fragmentList) {
        if (fragment.getName().getIdentifier().equals(argument.getIdentifier())) {
          argumentVariableDeclarationType=statement.getType();
          break;
        }
      }
    }
    if (argumentVariableDeclarationType == null) {
      List<SingleVariableDeclaration> sourceMethodParameters=sourceMethodDeclaration.parameters();
      for (      SingleVariableDeclaration variableDeclaration : sourceMethodParameters) {
        if (variableDeclaration.getName().getIdentifier().equals(argument.getIdentifier())) {
          argumentVariableDeclarationType=variableDeclaration.getType();
          break;
        }
      }
    }
    if (argumentVariableDeclarationType != null) {
      SingleVariableDeclaration newParam=newMethodDeclaration.getAST().newSingleVariableDeclaration();
      sourceRewriter.set(newParam,SingleVariableDeclaration.NAME_PROPERTY,argument,null);
      sourceRewriter.set(newParam,SingleVariableDeclaration.TYPE_PROPERTY,argumentVariableDeclarationType,null);
      paramRewrite.insertLast(newParam,null);
    }
  }
  Set<String> thrownExceptions=extractionBlock.getThrownExceptions();
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  String thrownException : thrownExceptions) {
    SimpleName simpleName=ast.newSimpleName(thrownException);
    thrownExceptionRewrite.insertLast(simpleName,null);
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite bodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  VariableDeclarationFragment returnVariableDeclarationFragment=newMethodBody.getAST().newVariableDeclarationFragment();
  sourceRewriter.set(returnVariableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,extractionBlock.getReturnVariableDeclarationFragment().getName(),null);
  sourceRewriter.set(returnVariableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractionBlock.getReturnVariableDeclarationFragment().getInitializer(),null);
  VariableDeclarationStatement returnVariableDeclarationStatement=newMethodBody.getAST().newVariableDeclarationStatement(returnVariableDeclarationFragment);
  sourceRewriter.set(returnVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,extractionBlock.getReturnVariableDeclarationStatement().getType(),null);
  bodyRewrite.insertLast(returnVariableDeclarationStatement,null);
  for (  VariableDeclarationFragment fragment : extractionBlock.getAdditionalRequiredVariableDeclarationFragments()) {
    VariableDeclarationFragment variableDeclarationFragment=newMethodBody.getAST().newVariableDeclarationFragment();
    sourceRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,fragment.getName(),null);
    sourceRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,fragment.getInitializer(),null);
    VariableDeclarationStatement variableDeclarationStatement=newMethodBody.getAST().newVariableDeclarationStatement(variableDeclarationFragment);
    sourceRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,extractionBlock.getAdditionalRequiredVariableDeclarationStatement(fragment).getType(),null);
    bodyRewrite.insertLast(variableDeclarationStatement,null);
  }
  if (extractionBlock.getParentStatementForCopy() == null) {
    for (    Statement statement : extractionBlock.getStatementsForExtraction()) {
      bodyRewrite.insertLast(statement,null);
    }
  }
 else {
    Statement parentStatement=extractionBlock.getParentStatementForCopy();
    Statement copiedParentStatement=(Statement)ASTNode.copySubtree(ast,parentStatement);
    if (copiedParentStatement.getNodeType() == ASTNode.IF_STATEMENT) {
      IfStatement oldIfStatement=(IfStatement)parentStatement;
      IfStatement newIfStatement=(IfStatement)copiedParentStatement;
      modifyExtractionBlock(oldIfStatement,newIfStatement);
    }
    bodyRewrite.insertLast(copiedParentStatement,null);
  }
  ReturnStatement returnStatement=newMethodBody.getAST().newReturnStatement();
  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnVariableSimpleName,null);
  bodyRewrite.insertLast(returnStatement,null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  ListRewrite methodDeclarationRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertLast(newMethodDeclaration,null);
  if (extractionBlock.getParentStatementForCopy() == null) {
    replaceExtractedCodeWithMethodInvocation(extractedMethodArguments);
  }
 else {
    insertMethodInvocationBeforeParentStatement(extractedMethodArguments);
  }
}","private void extractMethod(){
  AST ast=sourceTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  SimpleName returnVariableSimpleName=extractionBlock.getReturnVariableDeclarationFragment().getName();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,ast.newSimpleName(extractionBlock.getExtractedMethodName()),null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,extractionBlock.getReturnVariableDeclarationStatement().getType(),null);
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier modifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  modifierRewrite.insertLast(modifier,null);
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<SimpleName> extractedMethodArguments=new ArrayList<SimpleName>();
  List<String> extractedMethodArgumentIdentifiers=new ArrayList<String>();
  List<String> variableDeclarationIdentifiers=new ArrayList<String>();
  for (  VariableDeclarationFragment fragment : extractionBlock.getAdditionalRequiredVariableDeclarationFragments())   variableDeclarationIdentifiers.add(fragment.getName().getIdentifier());
  VariableDeclarationFragment returnFragment=extractionBlock.getReturnVariableDeclarationFragment();
  Expression returnInitializer=returnFragment.getInitializer();
  List<Expression> returnList=extractor.getVariableInstructions(returnInitializer);
  processIdentifiers(returnList,returnVariableSimpleName,extractedMethodArguments,extractedMethodArgumentIdentifiers,variableDeclarationIdentifiers);
  for (  VariableDeclarationFragment fragment : extractionBlock.getAdditionalRequiredVariableDeclarationFragments()) {
    Expression initializer=fragment.getInitializer();
    List<Expression> list=extractor.getVariableInstructions(initializer);
    processIdentifiers(list,returnVariableSimpleName,extractedMethodArguments,extractedMethodArgumentIdentifiers,variableDeclarationIdentifiers);
  }
  if (extractionBlock.getParentStatementForCopy() != null) {
    Statement parentStatementForCopy=extractionBlock.getParentStatementForCopy();
    if (parentStatementForCopy.getNodeType() == Statement.IF_STATEMENT) {
      IfStatement ifStatement=(IfStatement)parentStatementForCopy;
      List<Expression> list=extractor.getVariableInstructions(ifStatement.getExpression());
      processIdentifiers(list,returnVariableSimpleName,extractedMethodArguments,extractedMethodArgumentIdentifiers,variableDeclarationIdentifiers);
    }
  }
  for (  Statement statement : extractionBlock.getStatementsForExtraction()) {
    List<Expression> list=extractor.getVariableInstructions(statement);
    processIdentifiers(list,returnVariableSimpleName,extractedMethodArguments,extractedMethodArgumentIdentifiers,variableDeclarationIdentifiers);
  }
  ListRewrite paramRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SimpleName argument : extractedMethodArguments) {
    Type argumentVariableDeclarationType=null;
    for (    VariableDeclarationStatement statement : extractionBlock.getAllVariableDeclarationStatements()) {
      List<VariableDeclarationFragment> fragmentList=statement.fragments();
      for (      VariableDeclarationFragment fragment : fragmentList) {
        if (fragment.getName().getIdentifier().equals(argument.getIdentifier())) {
          argumentVariableDeclarationType=statement.getType();
          break;
        }
      }
    }
    if (argumentVariableDeclarationType == null) {
      List<SingleVariableDeclaration> sourceMethodParameters=sourceMethodDeclaration.parameters();
      for (      SingleVariableDeclaration variableDeclaration : sourceMethodParameters) {
        if (variableDeclaration.getName().getIdentifier().equals(argument.getIdentifier())) {
          argumentVariableDeclarationType=variableDeclaration.getType();
          break;
        }
      }
    }
    if (argumentVariableDeclarationType != null) {
      SingleVariableDeclaration newParam=newMethodDeclaration.getAST().newSingleVariableDeclaration();
      sourceRewriter.set(newParam,SingleVariableDeclaration.NAME_PROPERTY,argument,null);
      sourceRewriter.set(newParam,SingleVariableDeclaration.TYPE_PROPERTY,argumentVariableDeclarationType,null);
      paramRewrite.insertLast(newParam,null);
    }
  }
  Set<String> thrownExceptions=extractionBlock.getThrownExceptions();
  ListRewrite thrownExceptionRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.THROWN_EXCEPTIONS_PROPERTY);
  for (  String thrownException : thrownExceptions) {
    SimpleName simpleName=ast.newSimpleName(thrownException);
    thrownExceptionRewrite.insertLast(simpleName,null);
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite bodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  VariableDeclarationFragment returnVariableDeclarationFragment=newMethodBody.getAST().newVariableDeclarationFragment();
  sourceRewriter.set(returnVariableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,extractionBlock.getReturnVariableDeclarationFragment().getName(),null);
  sourceRewriter.set(returnVariableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,extractionBlock.getReturnVariableDeclarationFragment().getInitializer(),null);
  VariableDeclarationStatement returnVariableDeclarationStatement=newMethodBody.getAST().newVariableDeclarationStatement(returnVariableDeclarationFragment);
  sourceRewriter.set(returnVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,extractionBlock.getReturnVariableDeclarationStatement().getType(),null);
  bodyRewrite.insertLast(returnVariableDeclarationStatement,null);
  for (  VariableDeclarationFragment fragment : extractionBlock.getAdditionalRequiredVariableDeclarationFragments()) {
    VariableDeclarationFragment variableDeclarationFragment=newMethodBody.getAST().newVariableDeclarationFragment();
    sourceRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,fragment.getName(),null);
    sourceRewriter.set(variableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,fragment.getInitializer(),null);
    VariableDeclarationStatement variableDeclarationStatement=newMethodBody.getAST().newVariableDeclarationStatement(variableDeclarationFragment);
    sourceRewriter.set(variableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,extractionBlock.getAdditionalRequiredVariableDeclarationStatement(fragment).getType(),null);
    bodyRewrite.insertLast(variableDeclarationStatement,null);
  }
  if (extractionBlock.getParentStatementForCopy() == null) {
    for (    Statement statement : extractionBlock.getStatementsForExtraction()) {
      bodyRewrite.insertLast(statement,null);
    }
  }
 else {
    Statement parentStatement=extractionBlock.getParentStatementForCopy();
    Statement copiedParentStatement=(Statement)ASTNode.copySubtree(ast,parentStatement);
    if (copiedParentStatement.getNodeType() == ASTNode.IF_STATEMENT) {
      IfStatement oldIfStatement=(IfStatement)parentStatement;
      IfStatement newIfStatement=(IfStatement)copiedParentStatement;
      modifyExtractionBlock(oldIfStatement,newIfStatement);
    }
    bodyRewrite.insertLast(copiedParentStatement,null);
  }
  ReturnStatement returnStatement=newMethodBody.getAST().newReturnStatement();
  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnVariableSimpleName,null);
  bodyRewrite.insertLast(returnStatement,null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  ListRewrite methodDeclarationRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertLast(newMethodDeclaration,null);
  if (extractionBlock.getParentStatementForCopy() == null) {
    replaceExtractedCodeWithMethodInvocation(extractedMethodArguments);
  }
 else {
    insertMethodInvocationBeforeParentStatement(extractedMethodArguments);
  }
}"
12253,"private void modifyContextConstructors(){
  AST contextAST=sourceTypeDeclaration.getAST();
  MethodDeclaration[] contextMethods=sourceTypeDeclaration.getMethods();
  for (  MethodDeclaration methodDeclaration : contextMethods) {
    if (methodDeclaration.isConstructor()) {
      Block constructorBody=methodDeclaration.getBody();
      List<Statement> statements=constructorBody.statements();
      ExpressionExtractor expressionExtractor=new ExpressionExtractor();
      for (      Statement statement : statements) {
        List<Expression> assignments=expressionExtractor.getAssignments(statement);
        for (        Expression expression : assignments) {
          Assignment assignment=(Assignment)expression;
          Expression leftHandSide=assignment.getLeftHandSide();
          SimpleName simpleName=null;
          if (leftHandSide instanceof SimpleName) {
            simpleName=(SimpleName)leftHandSide;
          }
 else           if (leftHandSide instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)leftHandSide;
            simpleName=fieldAccess.getName();
          }
          IBinding binding=simpleName.resolveBinding();
          if (binding.getKind() == IBinding.VARIABLE) {
            IVariableBinding variableBinding=(IVariableBinding)binding;
            if (variableBinding.isField() && typeCheckElimination.getTypeField().getName().getIdentifier().equals(simpleName.getIdentifier())) {
              ListRewrite constructorBodyStatementsRewrite=sourceRewriter.getListRewrite(constructorBody,Block.STATEMENTS_PROPERTY);
              MethodInvocation setterMethodInvocation=contextAST.newMethodInvocation();
              sourceRewriter.set(setterMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckElimination.getTypeFieldSetterMethod().getName(),null);
              ListRewrite setterMethodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(setterMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
              setterMethodInvocationArgumentsRewrite.insertLast(assignment.getRightHandSide(),null);
              ExpressionStatement expressionStatement=contextAST.newExpressionStatement(setterMethodInvocation);
              constructorBodyStatementsRewrite.replace(statement,expressionStatement,null);
            }
          }
        }
      }
    }
  }
}","private void modifyContextConstructors(){
  if (typeCheckElimination.getTypeFieldSetterMethod() != null) {
    AST contextAST=sourceTypeDeclaration.getAST();
    MethodDeclaration[] contextMethods=sourceTypeDeclaration.getMethods();
    for (    MethodDeclaration methodDeclaration : contextMethods) {
      if (methodDeclaration.isConstructor()) {
        Block constructorBody=methodDeclaration.getBody();
        List<Statement> statements=constructorBody.statements();
        ExpressionExtractor expressionExtractor=new ExpressionExtractor();
        for (        Statement statement : statements) {
          List<Expression> assignments=expressionExtractor.getAssignments(statement);
          for (          Expression expression : assignments) {
            Assignment assignment=(Assignment)expression;
            Expression leftHandSide=assignment.getLeftHandSide();
            SimpleName simpleName=null;
            if (leftHandSide instanceof SimpleName) {
              simpleName=(SimpleName)leftHandSide;
            }
 else             if (leftHandSide instanceof FieldAccess) {
              FieldAccess fieldAccess=(FieldAccess)leftHandSide;
              simpleName=fieldAccess.getName();
            }
            IBinding binding=simpleName.resolveBinding();
            if (binding.getKind() == IBinding.VARIABLE) {
              IVariableBinding variableBinding=(IVariableBinding)binding;
              if (variableBinding.isField() && typeCheckElimination.getTypeField().getName().getIdentifier().equals(simpleName.getIdentifier())) {
                ListRewrite constructorBodyStatementsRewrite=sourceRewriter.getListRewrite(constructorBody,Block.STATEMENTS_PROPERTY);
                MethodInvocation setterMethodInvocation=contextAST.newMethodInvocation();
                sourceRewriter.set(setterMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckElimination.getTypeFieldSetterMethod().getName(),null);
                ListRewrite setterMethodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(setterMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                setterMethodInvocationArgumentsRewrite.insertLast(assignment.getRightHandSide(),null);
                ExpressionStatement expressionStatement=contextAST.newExpressionStatement(setterMethodInvocation);
                constructorBodyStatementsRewrite.replace(statement,expressionStatement,null);
              }
            }
          }
        }
      }
    }
  }
}"
12254,"public boolean allTypeChecksContainStaticField(){
  return typeCheckMap.keySet().size() == staticFieldMap.keySet().size();
}","public boolean allTypeChecksContainStaticField(){
  return (typeCheckMap.keySet().size() > 1) && (typeCheckMap.keySet().size() == staticFieldMap.keySet().size());
}"
12255,"private void modifySourceStaticFieldInstructionsInTargetClass(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceVariableInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newVariableInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceVariableInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0 && variableBinding.getDeclaringClass() != null && variableBinding.getDeclaringClass().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
        AST ast=newMethodDeclaration.getAST();
        SimpleName qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
        if (simpleName.getParent() instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
          targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
        }
 else         if (!(simpleName.getParent() instanceof QualifiedName)) {
          SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
          QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
          targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
        }
      }
    }
    i++;
  }
}","private void modifySourceStaticFieldInstructionsInTargetClass(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceVariableInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newVariableInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceVariableInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) != 0 && sourceTypeDeclaration.resolveBinding().isEqualTo(variableBinding.getDeclaringClass())) {
        AST ast=newMethodDeclaration.getAST();
        SimpleName qualifier=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
        if (simpleName.getParent() instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)newVariableInstructions.get(i).getParent();
          targetRewriter.set(fieldAccess,FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
        }
 else         if (!(simpleName.getParent() instanceof QualifiedName)) {
          SimpleName newSimpleName=ast.newSimpleName(simpleName.getIdentifier());
          QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
          targetRewriter.replace(newVariableInstructions.get(i),newQualifiedName,null);
        }
      }
    }
    i++;
  }
}"
12256,"private void modifySourceMemberAccessesInTargetClass(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  List<Expression> expressionsToBeRemoved=new ArrayList<Expression>();
  for (  MethodInvocation methodInvocation : additionalMethodsToBeMoved.keySet()) {
    for (    Expression expression : sourceMethodInvocations) {
      if (expression instanceof MethodInvocation) {
        MethodInvocation sourceMethodInvocation=(MethodInvocation)expression;
        if (methodInvocation.equals(sourceMethodInvocation)) {
          expressionsToBeRemoved.add(methodInvocation);
        }
      }
    }
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  expressionsToBeRemoved.clear();
  int k=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      ITypeBinding methodInvocationDeclaringClassTypeBinding=methodInvocation.resolveMethodBinding().getDeclaringClass();
      if (methodInvocationDeclaringClassTypeBinding.isEqualTo(sourceTypeDeclaration.resolveBinding()) && (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression)) {
        MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
        for (        MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
          if (sourceMethodDeclaration.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
            MethodInvocation delegation=isDelegate(sourceMethodDeclaration);
            if (delegation != null) {
              ITypeBinding delegationDeclaringClassTypeBinding=delegation.resolveMethodBinding().getDeclaringClass();
              if (delegationDeclaringClassTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
                if (delegation.getExpression() != null) {
                  MethodInvocation newMethodInvocation=(MethodInvocation)ASTNode.copySubtree(newMethodDeclaration.getAST(),delegation);
                  targetRewriter.remove(newMethodInvocation.getExpression(),null);
                  targetRewriter.replace(newMethodInvocations.get(k),newMethodInvocation,null);
                }
                expressionsToBeRemoved.add(methodInvocation);
              }
            }
          }
        }
      }
 else       if (methodInvocationDeclaringClassTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding()) && methodInvocation.getExpression() != null) {
        Expression methodInvocationExpression=methodInvocation.getExpression();
        if (methodInvocationExpression instanceof MethodInvocation) {
          MethodInvocation invoker=(MethodInvocation)methodInvocationExpression;
          if (invoker.getExpression() == null || invoker.getExpression() instanceof ThisExpression) {
            MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
            for (            MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
              if (sourceMethodDeclaration.resolveBinding().isEqualTo(invoker.resolveMethodBinding())) {
                SimpleName fieldInstruction=isGetter(sourceMethodDeclaration);
                if (fieldInstruction != null && fieldInstruction.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                  int index=sourceMethodInvocations.indexOf(invoker);
                  targetRewriter.remove(newMethodInvocations.get(index),null);
                  expressionsToBeRemoved.add(invoker);
                  expressionsToBeRemoved.add(methodInvocation);
                }
              }
            }
          }
        }
      }
    }
    k++;
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceFieldInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) == 0) {
        if (sourceTypeDeclaration.resolveBinding().isEqualTo(variableBinding.getDeclaringClass())) {
          SimpleName expressionName=(SimpleName)newFieldInstructions.get(i);
          if (expressionName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)expressionName.getParent();
            if (fieldAccess.getExpression() instanceof ThisExpression && !expressionName.getIdentifier().equals(targetClassVariableName)) {
              targetRewriter.replace(expressionName.getParent(),expressionName,null);
              if (!additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))               addParameterToMovedMethod(newMethodDeclaration,expressionName);
            }
          }
 else           if (!expressionName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))           addParameterToMovedMethod(newMethodDeclaration,expressionName);
        }
 else {
          Type superclassType=sourceTypeDeclaration.getSuperclassType();
          ITypeBinding superclassTypeBinding=null;
          if (superclassType != null)           superclassTypeBinding=superclassType.resolveBinding();
          while (superclassTypeBinding != null && !variableBinding.getDeclaringClass().isEqualTo(superclassTypeBinding)) {
            superclassTypeBinding=superclassTypeBinding.getSuperclass();
          }
          if (superclassTypeBinding != null) {
            IVariableBinding[] superclassFieldBindings=superclassTypeBinding.getDeclaredFields();
            for (            IVariableBinding superclassFieldBinding : superclassFieldBindings) {
              if (superclassFieldBinding.isEqualTo(variableBinding)) {
                SimpleName expressionName=(SimpleName)newFieldInstructions.get(i);
                if (!expressionName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))                 addParameterToMovedMethod(newMethodDeclaration,variableBinding);
              }
            }
          }
        }
      }
    }
    i++;
  }
  SimpleName parameterName=null;
  Set<String> sourceMethodsWithPublicModifier=new LinkedHashSet<String>();
  int j=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      if (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression) {
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        if (methodBinding.getDeclaringClass().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
          MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
          for (          MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
            if (sourceMethodDeclaration.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding()) && !sourceMethod.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
              SimpleName fieldName=isGetter(sourceMethodDeclaration);
              MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(j);
              if (fieldName != null) {
                AST ast=newMethodDeclaration.getAST();
                targetRewriter.replace(newMethodInvocation,ast.newSimpleName(fieldName.getIdentifier()),null);
                if (!fieldName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(fieldName.getIdentifier()))                 addParameterToMovedMethod(newMethodDeclaration,fieldName);
              }
 else {
                if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
                  parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
                }
                targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
                if (!sourceMethodsWithPublicModifier.contains(methodInvocation.resolveMethodBinding().toString())) {
                  setPublicModifierToSourceMethod(methodInvocation);
                  sourceMethodsWithPublicModifier.add(methodInvocation.resolveMethodBinding().toString());
                }
              }
            }
          }
        }
 else {
          Type superclassType=sourceTypeDeclaration.getSuperclassType();
          ITypeBinding superclassTypeBinding=null;
          if (superclassType != null)           superclassTypeBinding=superclassType.resolveBinding();
          while (superclassTypeBinding != null && !methodBinding.getDeclaringClass().isEqualTo(superclassTypeBinding)) {
            superclassTypeBinding=superclassTypeBinding.getSuperclass();
          }
          if (superclassTypeBinding != null) {
            IMethodBinding[] superclassMethodBindings=superclassTypeBinding.getDeclaredMethods();
            for (            IMethodBinding superclassMethodBinding : superclassMethodBindings) {
              if (superclassMethodBinding.isEqualTo(methodBinding)) {
                MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(j);
                if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
                  parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
                }
                targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
              }
            }
          }
        }
      }
    }
    j++;
  }
}","private void modifySourceMemberAccessesInTargetClass(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  List<Expression> expressionsToBeRemoved=new ArrayList<Expression>();
  for (  MethodInvocation methodInvocation : additionalMethodsToBeMoved.keySet()) {
    for (    Expression expression : sourceMethodInvocations) {
      if (expression instanceof MethodInvocation) {
        MethodInvocation sourceMethodInvocation=(MethodInvocation)expression;
        if (methodInvocation.equals(sourceMethodInvocation)) {
          expressionsToBeRemoved.add(methodInvocation);
        }
      }
    }
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  expressionsToBeRemoved.clear();
  int k=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      ITypeBinding methodInvocationDeclaringClassTypeBinding=methodInvocation.resolveMethodBinding().getDeclaringClass();
      if (methodInvocationDeclaringClassTypeBinding.isEqualTo(sourceTypeDeclaration.resolveBinding()) && (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression)) {
        MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
        for (        MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
          if (sourceMethodDeclaration.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
            MethodInvocation delegation=isDelegate(sourceMethodDeclaration);
            if (delegation != null) {
              ITypeBinding delegationDeclaringClassTypeBinding=delegation.resolveMethodBinding().getDeclaringClass();
              if (delegationDeclaringClassTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
                if (delegation.getExpression() != null) {
                  MethodInvocation newMethodInvocation=(MethodInvocation)ASTNode.copySubtree(newMethodDeclaration.getAST(),delegation);
                  targetRewriter.remove(newMethodInvocation.getExpression(),null);
                  targetRewriter.replace(newMethodInvocations.get(k),newMethodInvocation,null);
                }
                expressionsToBeRemoved.add(methodInvocation);
              }
            }
          }
        }
      }
 else       if (methodInvocationDeclaringClassTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding()) && methodInvocation.getExpression() != null) {
        Expression methodInvocationExpression=methodInvocation.getExpression();
        if (methodInvocationExpression instanceof MethodInvocation) {
          MethodInvocation invoker=(MethodInvocation)methodInvocationExpression;
          if (invoker.getExpression() == null || invoker.getExpression() instanceof ThisExpression) {
            MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
            for (            MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
              if (sourceMethodDeclaration.resolveBinding().isEqualTo(invoker.resolveMethodBinding())) {
                SimpleName fieldInstruction=isGetter(sourceMethodDeclaration);
                if (fieldInstruction != null && fieldInstruction.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                  int index=sourceMethodInvocations.indexOf(invoker);
                  targetRewriter.remove(newMethodInvocations.get(index),null);
                  expressionsToBeRemoved.add(invoker);
                  expressionsToBeRemoved.add(methodInvocation);
                }
              }
            }
          }
        }
      }
    }
    k++;
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceFieldInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && (variableBinding.getModifiers() & Modifier.STATIC) == 0) {
        if (sourceTypeDeclaration.resolveBinding().isEqualTo(variableBinding.getDeclaringClass())) {
          SimpleName expressionName=(SimpleName)newFieldInstructions.get(i);
          if (expressionName.getParent() instanceof FieldAccess) {
            FieldAccess fieldAccess=(FieldAccess)expressionName.getParent();
            if (fieldAccess.getExpression() instanceof ThisExpression && !expressionName.getIdentifier().equals(targetClassVariableName)) {
              targetRewriter.replace(expressionName.getParent(),expressionName,null);
              if (!additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))               addParameterToMovedMethod(newMethodDeclaration,expressionName);
            }
          }
 else           if (!expressionName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))           addParameterToMovedMethod(newMethodDeclaration,expressionName);
        }
 else {
          Type superclassType=sourceTypeDeclaration.getSuperclassType();
          ITypeBinding superclassTypeBinding=null;
          if (superclassType != null)           superclassTypeBinding=superclassType.resolveBinding();
          while (superclassTypeBinding != null && !superclassTypeBinding.isEqualTo(variableBinding.getDeclaringClass())) {
            superclassTypeBinding=superclassTypeBinding.getSuperclass();
          }
          if (superclassTypeBinding != null) {
            IVariableBinding[] superclassFieldBindings=superclassTypeBinding.getDeclaredFields();
            for (            IVariableBinding superclassFieldBinding : superclassFieldBindings) {
              if (superclassFieldBinding.isEqualTo(variableBinding)) {
                SimpleName expressionName=(SimpleName)newFieldInstructions.get(i);
                if (!expressionName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))                 addParameterToMovedMethod(newMethodDeclaration,variableBinding);
              }
            }
          }
        }
      }
    }
    i++;
  }
  SimpleName parameterName=null;
  Set<String> sourceMethodsWithPublicModifier=new LinkedHashSet<String>();
  int j=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      if (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression) {
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        if (methodBinding.getDeclaringClass().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
          MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
          for (          MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
            if (sourceMethodDeclaration.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding()) && !sourceMethod.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
              SimpleName fieldName=isGetter(sourceMethodDeclaration);
              MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(j);
              if (fieldName != null) {
                AST ast=newMethodDeclaration.getAST();
                targetRewriter.replace(newMethodInvocation,ast.newSimpleName(fieldName.getIdentifier()),null);
                if (!fieldName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(fieldName.getIdentifier()))                 addParameterToMovedMethod(newMethodDeclaration,fieldName);
              }
 else {
                if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
                  parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
                }
                targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
                if (!sourceMethodsWithPublicModifier.contains(methodInvocation.resolveMethodBinding().toString())) {
                  setPublicModifierToSourceMethod(methodInvocation);
                  sourceMethodsWithPublicModifier.add(methodInvocation.resolveMethodBinding().toString());
                }
              }
            }
          }
        }
 else {
          Type superclassType=sourceTypeDeclaration.getSuperclassType();
          ITypeBinding superclassTypeBinding=null;
          if (superclassType != null)           superclassTypeBinding=superclassType.resolveBinding();
          while (superclassTypeBinding != null && !methodBinding.getDeclaringClass().isEqualTo(superclassTypeBinding)) {
            superclassTypeBinding=superclassTypeBinding.getSuperclass();
          }
          if (superclassTypeBinding != null) {
            IMethodBinding[] superclassMethodBindings=superclassTypeBinding.getDeclaredMethods();
            for (            IMethodBinding superclassMethodBinding : superclassMethodBindings) {
              if (superclassMethodBinding.isEqualTo(methodBinding)) {
                MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(j);
                if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
                  parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
                }
                targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
              }
            }
          }
        }
      }
    }
    j++;
  }
}"
12257,"public List<TypeCheckElimination> generateTypeCheckEliminations(){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> switchStatements=statementExtractor.getSwitchStatements(compositeStatement.getStatement());
  for (  Statement statement : switchStatements) {
    SwitchStatement switchStatement=(SwitchStatement)statement;
    TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
    typeCheckElimination.setTypeCheckCodeFragment(switchStatement);
    List<Statement> statements=switchStatement.statements();
    Expression switchCaseExpression=null;
    for (    Statement statement2 : statements) {
      if (statement2 instanceof SwitchCase) {
        SwitchCase switchCase=(SwitchCase)statement2;
        switchCaseExpression=switchCase.getExpression();
      }
 else {
        if (switchCaseExpression != null && !(statement2 instanceof BreakStatement))         typeCheckElimination.addTypeCheck(switchCaseExpression,statement2);
      }
    }
    typeCheckEliminations.add(typeCheckElimination);
  }
  List<Statement> ifStatements=statementExtractor.getIfStatements(compositeStatement.getStatement());
  TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
  int i=0;
  for (  Statement statement : ifStatements) {
    IfStatement ifStatement=(IfStatement)statement;
    Expression ifExpression=ifStatement.getExpression();
    Statement thenStatement=ifStatement.getThenStatement();
    typeCheckElimination.addTypeCheck(ifExpression,thenStatement);
    if (ifStatements.size() - 1 > i) {
      IfStatement nextIfStatement=(IfStatement)ifStatements.get(i + 1);
      if (!ifStatement.getParent().equals(nextIfStatement)) {
        typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
        typeCheckEliminations.add(typeCheckElimination);
        typeCheckElimination=new TypeCheckElimination();
      }
    }
 else {
      typeCheckEliminations.add(typeCheckElimination);
    }
    i++;
  }
  return typeCheckEliminations;
}","public List<TypeCheckElimination> generateTypeCheckEliminations(){
  List<TypeCheckElimination> typeCheckEliminations=new ArrayList<TypeCheckElimination>();
  StatementExtractor statementExtractor=new StatementExtractor();
  List<Statement> switchStatements=statementExtractor.getSwitchStatements(compositeStatement.getStatement());
  for (  Statement statement : switchStatements) {
    SwitchStatement switchStatement=(SwitchStatement)statement;
    TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
    typeCheckElimination.setTypeCheckCodeFragment(switchStatement);
    List<Statement> statements=switchStatement.statements();
    Expression switchCaseExpression=null;
    for (    Statement statement2 : statements) {
      if (statement2 instanceof SwitchCase) {
        SwitchCase switchCase=(SwitchCase)statement2;
        switchCaseExpression=switchCase.getExpression();
      }
 else {
        if (switchCaseExpression != null && !(statement2 instanceof BreakStatement))         typeCheckElimination.addTypeCheck(switchCaseExpression,statement2);
      }
    }
    typeCheckEliminations.add(typeCheckElimination);
  }
  List<Statement> ifStatements=statementExtractor.getIfStatements(compositeStatement.getStatement());
  TypeCheckElimination typeCheckElimination=new TypeCheckElimination();
  int i=0;
  for (  Statement statement : ifStatements) {
    IfStatement ifStatement=(IfStatement)statement;
    Expression ifExpression=ifStatement.getExpression();
    Statement thenStatement=ifStatement.getThenStatement();
    typeCheckElimination.addTypeCheck(ifExpression,thenStatement);
    if (ifStatements.size() - 1 > i) {
      IfStatement nextIfStatement=(IfStatement)ifStatements.get(i + 1);
      if (!ifStatement.getParent().equals(nextIfStatement)) {
        typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
        typeCheckEliminations.add(typeCheckElimination);
        typeCheckElimination=new TypeCheckElimination();
      }
    }
 else {
      typeCheckElimination.setTypeCheckCodeFragment(ifStatement);
      typeCheckEliminations.add(typeCheckElimination);
    }
    i++;
  }
  return typeCheckEliminations;
}"
12258,"private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
      targetClassVariableName=parameter.getName().getIdentifier();
      parametersRewrite.remove(newMethodParameters.get(i),null);
      break;
    }
    i++;
  }
  if (targetClassVariableName == null) {
    FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
          targetClassVariableName=fragment.getName().getIdentifier();
          break;
        }
      }
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  modifySourceStaticMethodInvocationsInTargetClass(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInVariableDeclarationInitializers(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInfixExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInCastExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInstanceofExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInAssignments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInVariableDeclarationInitializers(newMethodDeclaration);
  ListRewrite targetClassBodyRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  targetClassBodyRewrite.insertLast(newMethodDeclaration,null);
}","private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
      targetClassVariableName=parameter.getName().getIdentifier();
      parametersRewrite.remove(newMethodParameters.get(i),null);
      break;
    }
    i++;
  }
  if (targetClassVariableName == null) {
    ExpressionExtractor expressionExtractor=new ExpressionExtractor();
    List<Expression> newVariableInstructions=expressionExtractor.getVariableInstructions(newMethodDeclaration.getBody());
    FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
          for (          Expression expression : newVariableInstructions) {
            SimpleName simpleName=(SimpleName)expression;
            if (fragment.getName().getIdentifier().equals(simpleName.getIdentifier())) {
              targetClassVariableName=fragment.getName().getIdentifier();
              break;
            }
          }
          if (targetClassVariableName != null)           break;
        }
      }
      if (targetClassVariableName != null)       break;
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  modifySourceStaticMethodInvocationsInTargetClass(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInVariableDeclarationInitializers(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInfixExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInCastExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInInstanceofExpressions(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInAssignments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInVariableDeclarationInitializers(newMethodDeclaration);
  ListRewrite targetClassBodyRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  targetClassBodyRewrite.insertLast(newMethodDeclaration,null);
}"
12259,"private void modifyClient(){
  AST clientAST=sourceTypeDeclaration.getAST();
  MethodDeclaration typeCheckMethod=typeCheckElimination.getTypeCheckMethod();
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  Type typeCheckMethodReturnType=typeCheckMethod.getReturnType2();
  if (typeCheckMethodReturnType.isPrimitiveType() && ((PrimitiveType)typeCheckMethodReturnType).getPrimitiveTypeCode().equals(PrimitiveType.VOID)) {
    MethodInvocation abstractMethodInvocation=clientAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeMethodInvocation().getExpression(),null);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    ExpressionStatement expressionStatement=clientAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    Assignment assignment=clientAST.newAssignment();
    MethodInvocation abstractMethodInvocation=clientAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeMethodInvocation().getExpression(),null);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    VariableDeclarationFragment returnedVariable=typeCheckElimination.getTypeCheckMethodReturnedVariable();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
    ExpressionStatement expressionStatement=clientAST.newExpressionStatement(assignment);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","private void modifyClient(){
  AST clientAST=sourceTypeDeclaration.getAST();
  MethodDeclaration typeCheckMethod=typeCheckElimination.getTypeCheckMethod();
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  Type typeCheckMethodReturnType=typeCheckMethod.getReturnType2();
  if (typeCheckMethodReturnType.isPrimitiveType() && ((PrimitiveType)typeCheckMethodReturnType).getPrimitiveTypeCode().equals(PrimitiveType.VOID)) {
    MethodInvocation abstractMethodInvocation=clientAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeMethodInvocation().getExpression(),null);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    ExpressionStatement expressionStatement=clientAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    MethodInvocation abstractMethodInvocation=clientAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeMethodInvocation().getExpression(),null);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    VariableDeclarationFragment returnedVariable=typeCheckElimination.getTypeCheckMethodReturnedVariable();
    if (returnedVariable != null) {
      Assignment assignment=clientAST.newAssignment();
      sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
      ExpressionStatement expressionStatement=clientAST.newExpressionStatement(assignment);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
    }
 else {
      ReturnStatement returnStatement=clientAST.newReturnStatement();
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractMethodInvocation,null);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),returnStatement,null);
    }
  }
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12260,"private void modifyContext(){
  AST contextAST=sourceTypeDeclaration.getAST();
  ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  VariableDeclarationFragment typeFragment=contextAST.newVariableDeclarationFragment();
  sourceRewriter.set(typeFragment,VariableDeclarationFragment.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
  FieldDeclaration typeFieldDeclaration=contextAST.newFieldDeclaration(typeFragment);
  sourceRewriter.set(typeFieldDeclaration,FieldDeclaration.TYPE_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getAbstractClassName()),null);
  ListRewrite typeFieldDeclrationModifiersRewrite=sourceRewriter.getListRewrite(typeFieldDeclaration,FieldDeclaration.MODIFIERS2_PROPERTY);
  typeFieldDeclrationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD),null);
  contextBodyRewrite.insertFirst(typeFieldDeclaration,null);
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  for (  FieldDeclaration fieldDeclaration : fieldDeclarations) {
    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      if (fragment.equals(typeCheckElimination.getTypeField())) {
        if (fragments.size() == 1) {
          contextBodyRewrite.remove(fragment.getParent(),null);
        }
 else {
          ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(fragment.getParent(),FieldDeclaration.FRAGMENTS_PROPERTY);
          fragmentRewrite.remove(fragment,null);
        }
      }
    }
  }
  MethodDeclaration setterMethod=typeCheckElimination.getTypeFieldSetterMethod();
  List<SingleVariableDeclaration> setterMethodParameters=setterMethod.parameters();
  Statement setterMethodStatement=(Statement)ASTNode.copySubtree(contextAST,typeCheckElimination.getTypeCheckCodeFragment());
  if (setterMethodStatement instanceof SwitchStatement) {
    SwitchStatement switchStatement=(SwitchStatement)setterMethodStatement;
    List<Statement> switchStatementStatements=switchStatement.statements();
    if (setterMethodParameters.size() == 1) {
      sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,setterMethodParameters.get(0).getName(),null);
    }
    ListRewrite switchStatementStatementsRewrite=sourceRewriter.getListRewrite(switchStatement,SwitchStatement.STATEMENTS_PROPERTY);
    List<String> subclassNames=typeCheckElimination.getSubclassNames();
    Collection<ArrayList<Statement>> allTypeCheckStatements=typeCheckElimination.getTypeCheckStatements();
    int i=0;
    for (    ArrayList<Statement> typeCheckStatements : allTypeCheckStatements) {
      int matches=0;
      for (      Statement oldStatement : typeCheckStatements) {
        for (        Statement newStatement : switchStatementStatements) {
          if (oldStatement.toString().equals(newStatement.toString())) {
            matches++;
            if (matches == typeCheckStatements.size()) {
              Assignment assignment=contextAST.newAssignment();
              sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
              FieldAccess typeFieldAccess=contextAST.newFieldAccess();
              sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
              sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
              sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
              ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
              sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(subclassNames.get(i)),null);
              sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
              switchStatementStatementsRewrite.replace(newStatement,contextAST.newExpressionStatement(assignment),null);
            }
 else {
              switchStatementStatementsRewrite.remove(newStatement,null);
            }
          }
        }
      }
      i++;
    }
  }
 else   if (setterMethodStatement instanceof IfStatement) {
    IfStatement typeCheckIfStatement=(IfStatement)setterMethodStatement;
    List<String> subclassNames=typeCheckElimination.getSubclassNames();
    Collection<ArrayList<Statement>> allTypeCheckStatements=typeCheckElimination.getTypeCheckStatements();
    int i=0;
    for (    ArrayList<Statement> typeCheckStatements : allTypeCheckStatements) {
      if (typeCheckStatements.size() == 1) {
        Statement oldStatement=typeCheckStatements.get(0);
        IfStatement ifStatement=typeCheckIfStatement;
        Statement newStatement=typeCheckIfStatement.getThenStatement();
        while (!oldStatement.toString().equals(newStatement.toString())) {
          Statement elseStatement=ifStatement.getElseStatement();
          if (elseStatement instanceof IfStatement) {
            ifStatement=(IfStatement)elseStatement;
            newStatement=ifStatement.getThenStatement();
          }
        }
        IfStatement parentIfStatement=(IfStatement)newStatement.getParent();
        Assignment assignment=contextAST.newAssignment();
        sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
        FieldAccess typeFieldAccess=contextAST.newFieldAccess();
        sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
        sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
        sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
        ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
        sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(subclassNames.get(i)),null);
        sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
        sourceRewriter.set(parentIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,contextAST.newExpressionStatement(assignment),null);
        InfixExpression infixExpression=(InfixExpression)parentIfStatement.getExpression();
        Expression leftOperand=infixExpression.getLeftOperand();
        if (leftOperand instanceof SimpleName) {
          SimpleName simpleName=(SimpleName)leftOperand;
          if (simpleName.getIdentifier().equals(typeCheckElimination.getTypeField().getName().getIdentifier())) {
            sourceRewriter.set(infixExpression,InfixExpression.LEFT_OPERAND_PROPERTY,setterMethodParameters.get(0).getName(),null);
          }
        }
 else         if (leftOperand instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)leftOperand;
          if (fieldAccess.getName().getIdentifier().equals(typeCheckElimination.getTypeField().getName().getIdentifier())) {
            sourceRewriter.set(infixExpression,InfixExpression.LEFT_OPERAND_PROPERTY,setterMethodParameters.get(0).getName(),null);
          }
        }
 else         if (leftOperand instanceof MethodInvocation) {
          MethodInvocation methodInvocation=(MethodInvocation)leftOperand;
          MethodDeclaration[] contextMethods=sourceTypeDeclaration.getMethods();
          for (          MethodDeclaration methodDeclaration : contextMethods) {
            if (methodDeclaration.getName().getIdentifier().equals(methodInvocation.getName().getIdentifier())) {
              SimpleName simpleName=MethodDeclarationUtility.isGetter(methodDeclaration);
              if (simpleName != null && simpleName.getIdentifier().equals(typeCheckElimination.getTypeField().getName().getIdentifier())) {
                sourceRewriter.set(infixExpression,InfixExpression.LEFT_OPERAND_PROPERTY,setterMethodParameters.get(0).getName(),null);
                break;
              }
            }
          }
        }
        Expression rightOperand=infixExpression.getRightOperand();
        if (rightOperand instanceof SimpleName) {
          SimpleName simpleName=(SimpleName)rightOperand;
          if (simpleName.getIdentifier().equals(typeCheckElimination.getTypeField().getName().getIdentifier())) {
            sourceRewriter.set(infixExpression,InfixExpression.RIGHT_OPERAND_PROPERTY,setterMethodParameters.get(0).getName(),null);
          }
        }
 else         if (rightOperand instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)rightOperand;
          if (fieldAccess.getName().getIdentifier().equals(typeCheckElimination.getTypeField().getName().getIdentifier())) {
            sourceRewriter.set(infixExpression,InfixExpression.RIGHT_OPERAND_PROPERTY,setterMethodParameters.get(0).getName(),null);
          }
        }
 else         if (rightOperand instanceof MethodInvocation) {
          MethodInvocation methodInvocation=(MethodInvocation)rightOperand;
          MethodDeclaration[] contextMethods=sourceTypeDeclaration.getMethods();
          for (          MethodDeclaration methodDeclaration : contextMethods) {
            if (methodDeclaration.getName().getIdentifier().equals(methodInvocation.getName().getIdentifier())) {
              SimpleName simpleName=MethodDeclarationUtility.isGetter(methodDeclaration);
              if (simpleName != null && simpleName.getIdentifier().equals(typeCheckElimination.getTypeField().getName().getIdentifier())) {
                sourceRewriter.set(infixExpression,InfixExpression.RIGHT_OPERAND_PROPERTY,setterMethodParameters.get(0).getName(),null);
                break;
              }
            }
          }
        }
      }
      i++;
    }
  }
  Block setterMethodBody=setterMethod.getBody();
  List<Statement> setterMethodBodyStatements=setterMethodBody.statements();
  ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
  if (setterMethodBodyStatements.size() == 1) {
    setterMethodBodyRewrite.replace(setterMethodBodyStatements.get(0),setterMethodStatement,null);
  }
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  Block getterMethodBody=getterMethod.getBody();
  List<Statement> getterMethodBodyStatements=getterMethodBody.statements();
  ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
  if (getterMethodBodyStatements.size() == 1) {
    ReturnStatement returnStatement=contextAST.newReturnStatement();
    MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,getterMethod.getName(),null);
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
    getterMethodBodyRewrite.replace(getterMethodBodyStatements.get(0),returnStatement,null);
  }
  MethodDeclaration typeCheckMethod=typeCheckElimination.getTypeCheckMethod();
  Block typeCheckMethodBody=typeCheckMethod.getBody();
  ListRewrite typeCheckMethodBodyStatementsRewrite=sourceRewriter.getListRewrite(typeCheckMethodBody,Block.STATEMENTS_PROPERTY);
  Type typeCheckMethodReturnType=typeCheckMethod.getReturnType2();
  if (typeCheckMethodReturnType.isPrimitiveType() && ((PrimitiveType)typeCheckMethodReturnType).getPrimitiveTypeCode().equals(PrimitiveType.VOID)) {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    if (typeCheckElimination.getAccessedFields().size() > 0) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    ExpressionStatement expressionStatement=contextAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckMethodBodyStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    Assignment assignment=contextAST.newAssignment();
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    if (typeCheckElimination.getAccessedFields().size() > 0) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    VariableDeclarationFragment returnedVariable=typeCheckElimination.getTypeCheckMethodReturnedVariable();
    sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
    sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
    sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
    ExpressionStatement expressionStatement=contextAST.newExpressionStatement(assignment);
    typeCheckMethodBodyStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
  modifyContextConstructors();
  generateGettersForAccessedFields();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","private void modifyContext(){
  AST contextAST=sourceTypeDeclaration.getAST();
  ListRewrite contextBodyRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  VariableDeclarationFragment typeFragment=contextAST.newVariableDeclarationFragment();
  sourceRewriter.set(typeFragment,VariableDeclarationFragment.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
  FieldDeclaration typeFieldDeclaration=contextAST.newFieldDeclaration(typeFragment);
  sourceRewriter.set(typeFieldDeclaration,FieldDeclaration.TYPE_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getAbstractClassName()),null);
  ListRewrite typeFieldDeclrationModifiersRewrite=sourceRewriter.getListRewrite(typeFieldDeclaration,FieldDeclaration.MODIFIERS2_PROPERTY);
  typeFieldDeclrationModifiersRewrite.insertLast(contextAST.newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD),null);
  contextBodyRewrite.insertFirst(typeFieldDeclaration,null);
  FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
  for (  FieldDeclaration fieldDeclaration : fieldDeclarations) {
    List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      if (fragment.equals(typeCheckElimination.getTypeField())) {
        if (fragments.size() == 1) {
          contextBodyRewrite.remove(fragment.getParent(),null);
        }
 else {
          ListRewrite fragmentRewrite=sourceRewriter.getListRewrite(fragment.getParent(),FieldDeclaration.FRAGMENTS_PROPERTY);
          fragmentRewrite.remove(fragment,null);
        }
      }
    }
  }
  MethodDeclaration setterMethod=typeCheckElimination.getTypeFieldSetterMethod();
  List<SingleVariableDeclaration> setterMethodParameters=setterMethod.parameters();
  Statement setterMethodStatement=(Statement)ASTNode.copySubtree(contextAST,typeCheckElimination.getTypeCheckCodeFragment());
  if (setterMethodStatement instanceof SwitchStatement) {
    SwitchStatement switchStatement=(SwitchStatement)setterMethodStatement;
    List<Statement> switchStatementStatements=switchStatement.statements();
    if (setterMethodParameters.size() == 1) {
      sourceRewriter.set(switchStatement,SwitchStatement.EXPRESSION_PROPERTY,setterMethodParameters.get(0).getName(),null);
    }
    ListRewrite switchStatementStatementsRewrite=sourceRewriter.getListRewrite(switchStatement,SwitchStatement.STATEMENTS_PROPERTY);
    List<String> subclassNames=typeCheckElimination.getSubclassNames();
    Collection<ArrayList<Statement>> allTypeCheckStatements=typeCheckElimination.getTypeCheckStatements();
    int i=0;
    for (    ArrayList<Statement> typeCheckStatements : allTypeCheckStatements) {
      int matches=0;
      for (      Statement oldStatement : typeCheckStatements) {
        for (        Statement newStatement : switchStatementStatements) {
          if (oldStatement.toString().equals(newStatement.toString())) {
            matches++;
            if (matches == typeCheckStatements.size()) {
              Assignment assignment=contextAST.newAssignment();
              sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
              FieldAccess typeFieldAccess=contextAST.newFieldAccess();
              sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
              sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
              sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
              ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
              sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(subclassNames.get(i)),null);
              sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
              switchStatementStatementsRewrite.replace(newStatement,contextAST.newExpressionStatement(assignment),null);
            }
 else {
              switchStatementStatementsRewrite.remove(newStatement,null);
            }
          }
        }
      }
      i++;
    }
  }
 else   if (setterMethodStatement instanceof IfStatement) {
    IfStatement typeCheckIfStatement=(IfStatement)setterMethodStatement;
    List<String> subclassNames=typeCheckElimination.getSubclassNames();
    Collection<ArrayList<Statement>> allTypeCheckStatements=typeCheckElimination.getTypeCheckStatements();
    int i=0;
    for (    ArrayList<Statement> typeCheckStatements : allTypeCheckStatements) {
      if (typeCheckStatements.size() == 1) {
        Statement oldStatement=typeCheckStatements.get(0);
        IfStatement ifStatement=typeCheckIfStatement;
        Statement newStatement=typeCheckIfStatement.getThenStatement();
        while (!oldStatement.toString().equals(newStatement.toString())) {
          Statement elseStatement=ifStatement.getElseStatement();
          if (elseStatement instanceof IfStatement) {
            ifStatement=(IfStatement)elseStatement;
            newStatement=ifStatement.getThenStatement();
          }
        }
        IfStatement parentIfStatement=(IfStatement)newStatement.getParent();
        Assignment assignment=contextAST.newAssignment();
        sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
        FieldAccess typeFieldAccess=contextAST.newFieldAccess();
        sourceRewriter.set(typeFieldAccess,FieldAccess.EXPRESSION_PROPERTY,contextAST.newThisExpression(),null);
        sourceRewriter.set(typeFieldAccess,FieldAccess.NAME_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
        sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,typeFieldAccess,null);
        ClassInstanceCreation classInstanceCreation=contextAST.newClassInstanceCreation();
        sourceRewriter.set(classInstanceCreation,ClassInstanceCreation.TYPE_PROPERTY,contextAST.newSimpleName(subclassNames.get(i)),null);
        sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,classInstanceCreation,null);
        sourceRewriter.set(parentIfStatement,IfStatement.THEN_STATEMENT_PROPERTY,contextAST.newExpressionStatement(assignment),null);
        InfixExpression infixExpression=(InfixExpression)parentIfStatement.getExpression();
        Expression leftOperand=infixExpression.getLeftOperand();
        if (leftOperand instanceof SimpleName) {
          SimpleName simpleName=(SimpleName)leftOperand;
          if (simpleName.getIdentifier().equals(typeCheckElimination.getTypeField().getName().getIdentifier())) {
            sourceRewriter.set(infixExpression,InfixExpression.LEFT_OPERAND_PROPERTY,setterMethodParameters.get(0).getName(),null);
          }
        }
 else         if (leftOperand instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)leftOperand;
          if (fieldAccess.getName().getIdentifier().equals(typeCheckElimination.getTypeField().getName().getIdentifier())) {
            sourceRewriter.set(infixExpression,InfixExpression.LEFT_OPERAND_PROPERTY,setterMethodParameters.get(0).getName(),null);
          }
        }
 else         if (leftOperand instanceof MethodInvocation) {
          MethodInvocation methodInvocation=(MethodInvocation)leftOperand;
          MethodDeclaration[] contextMethods=sourceTypeDeclaration.getMethods();
          for (          MethodDeclaration methodDeclaration : contextMethods) {
            if (methodDeclaration.getName().getIdentifier().equals(methodInvocation.getName().getIdentifier())) {
              SimpleName simpleName=MethodDeclarationUtility.isGetter(methodDeclaration);
              if (simpleName != null && simpleName.getIdentifier().equals(typeCheckElimination.getTypeField().getName().getIdentifier())) {
                sourceRewriter.set(infixExpression,InfixExpression.LEFT_OPERAND_PROPERTY,setterMethodParameters.get(0).getName(),null);
                break;
              }
            }
          }
        }
        Expression rightOperand=infixExpression.getRightOperand();
        if (rightOperand instanceof SimpleName) {
          SimpleName simpleName=(SimpleName)rightOperand;
          if (simpleName.getIdentifier().equals(typeCheckElimination.getTypeField().getName().getIdentifier())) {
            sourceRewriter.set(infixExpression,InfixExpression.RIGHT_OPERAND_PROPERTY,setterMethodParameters.get(0).getName(),null);
          }
        }
 else         if (rightOperand instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)rightOperand;
          if (fieldAccess.getName().getIdentifier().equals(typeCheckElimination.getTypeField().getName().getIdentifier())) {
            sourceRewriter.set(infixExpression,InfixExpression.RIGHT_OPERAND_PROPERTY,setterMethodParameters.get(0).getName(),null);
          }
        }
 else         if (rightOperand instanceof MethodInvocation) {
          MethodInvocation methodInvocation=(MethodInvocation)rightOperand;
          MethodDeclaration[] contextMethods=sourceTypeDeclaration.getMethods();
          for (          MethodDeclaration methodDeclaration : contextMethods) {
            if (methodDeclaration.getName().getIdentifier().equals(methodInvocation.getName().getIdentifier())) {
              SimpleName simpleName=MethodDeclarationUtility.isGetter(methodDeclaration);
              if (simpleName != null && simpleName.getIdentifier().equals(typeCheckElimination.getTypeField().getName().getIdentifier())) {
                sourceRewriter.set(infixExpression,InfixExpression.RIGHT_OPERAND_PROPERTY,setterMethodParameters.get(0).getName(),null);
                break;
              }
            }
          }
        }
      }
      i++;
    }
  }
  Block setterMethodBody=setterMethod.getBody();
  List<Statement> setterMethodBodyStatements=setterMethodBody.statements();
  ListRewrite setterMethodBodyRewrite=sourceRewriter.getListRewrite(setterMethodBody,Block.STATEMENTS_PROPERTY);
  if (setterMethodBodyStatements.size() == 1) {
    setterMethodBodyRewrite.replace(setterMethodBodyStatements.get(0),setterMethodStatement,null);
  }
  MethodDeclaration getterMethod=typeCheckElimination.getTypeFieldGetterMethod();
  Block getterMethodBody=getterMethod.getBody();
  List<Statement> getterMethodBodyStatements=getterMethodBody.statements();
  ListRewrite getterMethodBodyRewrite=sourceRewriter.getListRewrite(getterMethodBody,Block.STATEMENTS_PROPERTY);
  if (getterMethodBodyStatements.size() == 1) {
    ReturnStatement returnStatement=contextAST.newReturnStatement();
    MethodInvocation abstractGetterMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.NAME_PROPERTY,getterMethod.getName(),null);
    sourceRewriter.set(abstractGetterMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,typeCheckElimination.getTypeField().getName(),null);
    sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractGetterMethodInvocation,null);
    getterMethodBodyRewrite.replace(getterMethodBodyStatements.get(0),returnStatement,null);
  }
  MethodDeclaration typeCheckMethod=typeCheckElimination.getTypeCheckMethod();
  Block typeCheckCodeFragmentParentBlock=(Block)typeCheckElimination.getTypeCheckCodeFragment().getParent();
  ListRewrite typeCheckCodeFragmentParentBlockStatementsRewrite=sourceRewriter.getListRewrite(typeCheckCodeFragmentParentBlock,Block.STATEMENTS_PROPERTY);
  Type typeCheckMethodReturnType=typeCheckMethod.getReturnType2();
  if (typeCheckMethodReturnType.isPrimitiveType() && ((PrimitiveType)typeCheckMethodReturnType).getPrimitiveTypeCode().equals(PrimitiveType.VOID)) {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    if (typeCheckElimination.getAccessedFields().size() > 0) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    ExpressionStatement expressionStatement=contextAST.newExpressionStatement(abstractMethodInvocation);
    typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
  }
 else {
    MethodInvocation abstractMethodInvocation=contextAST.newMethodInvocation();
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.NAME_PROPERTY,typeCheckMethod.getName(),null);
    sourceRewriter.set(abstractMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,contextAST.newSimpleName(typeCheckElimination.getTypeField().getName().getIdentifier()),null);
    for (    SingleVariableDeclaration abstractMethodParameter : typeCheckElimination.getAccessedParameters()) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(abstractMethodParameter.getName(),null);
    }
    if (typeCheckElimination.getAccessedFields().size() > 0) {
      ListRewrite methodInvocationArgumentsRewrite=sourceRewriter.getListRewrite(abstractMethodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
      methodInvocationArgumentsRewrite.insertLast(contextAST.newThisExpression(),null);
    }
    VariableDeclarationFragment returnedVariable=typeCheckElimination.getTypeCheckMethodReturnedVariable();
    if (returnedVariable != null) {
      Assignment assignment=contextAST.newAssignment();
      sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
      sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,returnedVariable.getName(),null);
      sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,abstractMethodInvocation,null);
      ExpressionStatement expressionStatement=contextAST.newExpressionStatement(assignment);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),expressionStatement,null);
    }
 else {
      ReturnStatement returnStatement=contextAST.newReturnStatement();
      sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,abstractMethodInvocation,null);
      typeCheckCodeFragmentParentBlockStatementsRewrite.replace(typeCheckElimination.getTypeCheckCodeFragment(),returnStatement,null);
    }
  }
  modifyContextConstructors();
  generateGettersForAccessedFields();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit sourceUndoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,sourceUndoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12261,"public String getAbstractClassName(){
  if (typeField != null) {
    String typeFieldName=typeField.getName().getIdentifier();
    return typeFieldName.substring(0,1).toUpperCase() + typeFieldName.substring(1,typeFieldName.length());
  }
 else   if (existingInheritanceTree != null) {
    DefaultMutableTreeNode root=existingInheritanceTree.getRootNode();
    return (String)root.getUserObject();
  }
 else {
    return null;
  }
}","public String getAbstractClassName(){
  if (typeField != null) {
    String typeFieldName=typeField.getName().getIdentifier().replaceAll(""String_Node_Str"",""String_Node_Str"");
    return typeFieldName.substring(0,1).toUpperCase() + typeFieldName.substring(1,typeFieldName.length());
  }
 else   if (existingInheritanceTree != null) {
    DefaultMutableTreeNode root=existingInheritanceTree.getRootNode();
    return (String)root.getUserObject();
  }
 else {
    return null;
  }
}"
12262,"private void addRequiredTargetImportDeclarations(){
  List<ITypeBinding> typeBindings=new ArrayList<ITypeBinding>();
  Type returnType=sourceMethod.getReturnType2();
  ITypeBinding returnTypeBinding=returnType.resolveBinding();
  if (!typeBindings.contains(returnTypeBinding))   typeBindings.add(returnTypeBinding);
  List<SingleVariableDeclaration> parameters=sourceMethod.parameters();
  for (  SingleVariableDeclaration parameter : parameters) {
    Type parameterType=parameter.getType();
    ITypeBinding parameterTypeBinding=parameterType.resolveBinding();
    if (!typeBindings.contains(parameterTypeBinding))     typeBindings.add(parameterTypeBinding);
  }
  List<Name> thrownExceptions=sourceMethod.thrownExceptions();
  for (  Name name : thrownExceptions) {
    IBinding binding=name.resolveBinding();
    if (binding.getKind() == IBinding.TYPE) {
      ITypeBinding typeBinding=(ITypeBinding)binding;
      if (!typeBindings.contains(typeBinding))       typeBindings.add(typeBinding);
    }
  }
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(sourceMethod.getBody());
  for (  Expression variableInstruction : variableInstructions) {
    SimpleName simpleName=(SimpleName)variableInstruction;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      ITypeBinding variableTypeBinding=variableBinding.getType();
      if (!typeBindings.contains(variableTypeBinding))       typeBindings.add(variableTypeBinding);
    }
  }
  List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(sourceMethod.getBody());
  for (  Expression expression : methodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      if (!additionalMethodsToBeMoved.keySet().contains(methodInvocation)) {
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        ITypeBinding declaringClassTypeBinding=methodBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
      }
    }
  }
  List<Expression> classInstanceCreations=expressionExtractor.getClassInstanceCreations(sourceMethod.getBody());
  for (  Expression expression : classInstanceCreations) {
    ClassInstanceCreation classInstanceCreation=(ClassInstanceCreation)expression;
    Type classInstanceCreationType=classInstanceCreation.getType();
    ITypeBinding classInstanceCreationTypeBinding=classInstanceCreationType.resolveBinding();
    if (!typeBindings.contains(classInstanceCreationTypeBinding))     typeBindings.add(classInstanceCreationTypeBinding);
  }
  List<Expression> typeLiterals=expressionExtractor.getTypeLiterals(sourceMethod.getBody());
  for (  Expression expression : typeLiterals) {
    TypeLiteral typeLiteral=(TypeLiteral)expression;
    Type typeLiteralType=typeLiteral.getType();
    ITypeBinding typeLiteralTypeBinding=typeLiteralType.resolveBinding();
    if (!typeBindings.contains(typeLiteralTypeBinding))     typeBindings.add(typeLiteralTypeBinding);
  }
  List<Expression> castExpressions=expressionExtractor.getCastExpressions(sourceMethod.getBody());
  for (  Expression expression : castExpressions) {
    CastExpression castExpression=(CastExpression)expression;
    Type castExpressionType=castExpression.getType();
    ITypeBinding typeLiteralTypeBinding=castExpressionType.resolveBinding();
    if (!typeBindings.contains(typeLiteralTypeBinding))     typeBindings.add(typeLiteralTypeBinding);
  }
  getSimpleTypeBindings(typeBindings);
  for (  ITypeBinding typeBinding : requiredTargetImportDeclarationSet)   addImportDeclaration(typeBinding);
}","private void addRequiredTargetImportDeclarations(){
  List<ITypeBinding> typeBindings=new ArrayList<ITypeBinding>();
  Type returnType=sourceMethod.getReturnType2();
  ITypeBinding returnTypeBinding=returnType.resolveBinding();
  if (!typeBindings.contains(returnTypeBinding))   typeBindings.add(returnTypeBinding);
  List<SingleVariableDeclaration> parameters=sourceMethod.parameters();
  for (  SingleVariableDeclaration parameter : parameters) {
    Type parameterType=parameter.getType();
    ITypeBinding parameterTypeBinding=parameterType.resolveBinding();
    if (!typeBindings.contains(parameterTypeBinding))     typeBindings.add(parameterTypeBinding);
  }
  List<Name> thrownExceptions=sourceMethod.thrownExceptions();
  for (  Name name : thrownExceptions) {
    IBinding binding=name.resolveBinding();
    if (binding.getKind() == IBinding.TYPE) {
      ITypeBinding typeBinding=(ITypeBinding)binding;
      if (!typeBindings.contains(typeBinding))       typeBindings.add(typeBinding);
    }
  }
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  List<Expression> variableInstructions=expressionExtractor.getVariableInstructions(sourceMethod.getBody());
  for (  Expression variableInstruction : variableInstructions) {
    SimpleName simpleName=(SimpleName)variableInstruction;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      ITypeBinding variableTypeBinding=variableBinding.getType();
      if (!typeBindings.contains(variableTypeBinding))       typeBindings.add(variableTypeBinding);
      ITypeBinding declaringClassTypeBinding=variableBinding.getDeclaringClass();
      if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))       typeBindings.add(declaringClassTypeBinding);
    }
  }
  List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(sourceMethod.getBody());
  for (  Expression expression : methodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      if (!additionalMethodsToBeMoved.keySet().contains(methodInvocation)) {
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        ITypeBinding declaringClassTypeBinding=methodBinding.getDeclaringClass();
        if (declaringClassTypeBinding != null && !typeBindings.contains(declaringClassTypeBinding))         typeBindings.add(declaringClassTypeBinding);
      }
    }
  }
  List<Expression> classInstanceCreations=expressionExtractor.getClassInstanceCreations(sourceMethod.getBody());
  for (  Expression expression : classInstanceCreations) {
    ClassInstanceCreation classInstanceCreation=(ClassInstanceCreation)expression;
    Type classInstanceCreationType=classInstanceCreation.getType();
    ITypeBinding classInstanceCreationTypeBinding=classInstanceCreationType.resolveBinding();
    if (!typeBindings.contains(classInstanceCreationTypeBinding))     typeBindings.add(classInstanceCreationTypeBinding);
  }
  List<Expression> typeLiterals=expressionExtractor.getTypeLiterals(sourceMethod.getBody());
  for (  Expression expression : typeLiterals) {
    TypeLiteral typeLiteral=(TypeLiteral)expression;
    Type typeLiteralType=typeLiteral.getType();
    ITypeBinding typeLiteralTypeBinding=typeLiteralType.resolveBinding();
    if (!typeBindings.contains(typeLiteralTypeBinding))     typeBindings.add(typeLiteralTypeBinding);
  }
  List<Expression> castExpressions=expressionExtractor.getCastExpressions(sourceMethod.getBody());
  for (  Expression expression : castExpressions) {
    CastExpression castExpression=(CastExpression)expression;
    Type castExpressionType=castExpression.getType();
    ITypeBinding typeLiteralTypeBinding=castExpressionType.resolveBinding();
    if (!typeBindings.contains(typeLiteralTypeBinding))     typeBindings.add(typeLiteralTypeBinding);
  }
  getSimpleTypeBindings(typeBindings);
  for (  ITypeBinding typeBinding : requiredTargetImportDeclarationSet)   addImportDeclaration(typeBinding);
}"
12263,"public void setParentStatementForCopy(AbstractStatement parentStatementForCopy){
  this.parentStatementForCopy=parentStatementForCopy;
}","public void setParentStatementForCopy(CompositeStatementObject parentStatementForCopy){
  this.parentStatementForCopy=parentStatementForCopy;
}"
12264,"public boolean canBeMovedTo(ClassObject sourceClass,ClassObject targetClass,MethodObject sourceMethod){
  List<LocalVariableInstructionObject> localVariableInstructions=new ArrayList<LocalVariableInstructionObject>();
  for (  AbstractStatement statement : statementsForExtraction) {
    localVariableInstructions.addAll(statement.getLocalVariableInstructions());
  }
  for (  LocalVariableInstructionObject localVariableInstruction : localVariableInstructions) {
    if (localVariableInstruction.getType().getClassType().equals(targetClass.getName())) {
      VariableDeclarationStatement variableDeclarationStatement=null;
      LocalVariableDeclarationObject localVariableDeclaration=localVariableInstruction.generateLocalVariableDeclaration();
      for (      AbstractStatement statement : statementsForExtraction) {
        if (statement instanceof CompositeStatementObject) {
          CompositeStatementObject compositeStatement=(CompositeStatementObject)statement;
          variableDeclarationStatement=compositeStatement.getVariableDeclarationStatement(localVariableDeclaration);
        }
 else         if (statement instanceof StatementObject) {
          StatementObject statementObject=(StatementObject)statement;
          if (statementObject.containsLocalVariableDeclaration(localVariableDeclaration))           variableDeclarationStatement=(VariableDeclarationStatement)statementObject.getStatement();
        }
      }
      if (variableDeclarationStatement != null) {
        return false;
      }
 else {
        variableDeclarationStatement=sourceMethod.getVariableDeclarationStatement(localVariableDeclaration);
        if (variableDeclarationStatement != null)         return true;
        ListIterator<ParameterObject> parameterIterator=sourceMethod.getParameterListIterator();
        while (parameterIterator.hasNext()) {
          ParameterObject parameter=parameterIterator.next();
          if (localVariableInstruction.getName().equals(parameter.getName()))           return true;
        }
      }
    }
  }
  List<FieldInstructionObject> fieldInstructions=new ArrayList<FieldInstructionObject>();
  for (  AbstractStatement statement : statementsForExtraction) {
    fieldInstructions.addAll(statement.getFieldInstructions());
  }
  for (  FieldInstructionObject fieldInstruction : fieldInstructions) {
    if (fieldInstruction.getType().getClassType().equals(targetClass.getName())) {
      ListIterator<FieldObject> fieldIterator=sourceClass.getFieldIterator();
      while (fieldIterator.hasNext()) {
        FieldObject field=fieldIterator.next();
        if (fieldInstruction.getName().equals(field.getName()))         return true;
      }
    }
  }
  List<MethodInvocationObject> methodInvocations=new ArrayList<MethodInvocationObject>();
  for (  AbstractStatement statement : statementsForExtraction) {
    methodInvocations.addAll(statement.getMethodInvocations());
  }
  for (  MethodInvocationObject methodInvocation : methodInvocations) {
    if (methodInvocation.getOriginClassName().equals(sourceClass.getName())) {
      MethodObject invokedMethod=sourceClass.getMethod(methodInvocation);
      FieldInstructionObject fieldInstruction=invokedMethod.isGetter();
      if (fieldInstruction != null && fieldInstruction.getType().getClassType().equals(targetClass.getName()))       return true;
      MethodInvocationObject delegation=invokedMethod.isDelegate();
      if (delegation != null && delegation.getOriginClassName().equals(targetClass.getName()))       return true;
    }
  }
  return false;
}","public boolean canBeMovedTo(ClassObject sourceClass,ClassObject targetClass,MethodObject sourceMethod){
  List<LocalVariableInstructionObject> localVariableInstructions=new ArrayList<LocalVariableInstructionObject>();
  if (parentStatementForCopy != null) {
    for (    AbstractExpression expression : parentStatementForCopy.getExpressions()) {
      localVariableInstructions.addAll(expression.getLocalVariableInstructions());
    }
  }
  for (  AbstractStatement statement : statementsForExtraction) {
    localVariableInstructions.addAll(statement.getLocalVariableInstructions());
  }
  for (  LocalVariableInstructionObject localVariableInstruction : localVariableInstructions) {
    if (localVariableInstruction.getType().getClassType().equals(targetClass.getName())) {
      VariableDeclarationStatement variableDeclarationStatement=null;
      LocalVariableDeclarationObject localVariableDeclaration=localVariableInstruction.generateLocalVariableDeclaration();
      for (      AbstractStatement statement : statementsForExtraction) {
        if (statement instanceof CompositeStatementObject) {
          CompositeStatementObject compositeStatement=(CompositeStatementObject)statement;
          variableDeclarationStatement=compositeStatement.getVariableDeclarationStatement(localVariableDeclaration);
        }
 else         if (statement instanceof StatementObject) {
          StatementObject statementObject=(StatementObject)statement;
          if (statementObject.containsLocalVariableDeclaration(localVariableDeclaration))           variableDeclarationStatement=(VariableDeclarationStatement)statementObject.getStatement();
        }
      }
      if (variableDeclarationStatement != null) {
        return false;
      }
 else {
        variableDeclarationStatement=sourceMethod.getVariableDeclarationStatement(localVariableDeclaration);
        if (variableDeclarationStatement != null)         return true;
        ListIterator<ParameterObject> parameterIterator=sourceMethod.getParameterListIterator();
        while (parameterIterator.hasNext()) {
          ParameterObject parameter=parameterIterator.next();
          if (localVariableInstruction.getName().equals(parameter.getName()))           return true;
        }
      }
    }
  }
  List<FieldInstructionObject> fieldInstructions=new ArrayList<FieldInstructionObject>();
  if (parentStatementForCopy != null) {
    for (    AbstractExpression expression : parentStatementForCopy.getExpressions()) {
      fieldInstructions.addAll(expression.getFieldInstructions());
    }
  }
  for (  AbstractStatement statement : statementsForExtraction) {
    fieldInstructions.addAll(statement.getFieldInstructions());
  }
  for (  FieldInstructionObject fieldInstruction : fieldInstructions) {
    if (fieldInstruction.getType().getClassType().equals(targetClass.getName())) {
      ListIterator<FieldObject> fieldIterator=sourceClass.getFieldIterator();
      while (fieldIterator.hasNext()) {
        FieldObject field=fieldIterator.next();
        if (fieldInstruction.getName().equals(field.getName()))         return true;
      }
    }
  }
  List<MethodInvocationObject> methodInvocations=new ArrayList<MethodInvocationObject>();
  if (parentStatementForCopy != null) {
    for (    AbstractExpression expression : parentStatementForCopy.getExpressions()) {
      methodInvocations.addAll(expression.getMethodInvocations());
    }
  }
  for (  AbstractStatement statement : statementsForExtraction) {
    methodInvocations.addAll(statement.getMethodInvocations());
  }
  for (  MethodInvocationObject methodInvocation : methodInvocations) {
    if (methodInvocation.getOriginClassName().equals(sourceClass.getName())) {
      MethodObject invokedMethod=sourceClass.getMethod(methodInvocation);
      FieldInstructionObject fieldInstruction=invokedMethod.isGetter();
      if (fieldInstruction != null && fieldInstruction.getType().getClassType().equals(targetClass.getName()))       return true;
      MethodInvocationObject delegation=invokedMethod.isDelegate();
      if (delegation != null && delegation.getOriginClassName().equals(targetClass.getName()))       return true;
    }
  }
  return false;
}"
12265,"private AbstractStatement haveRecursivelyTheSameParent(List<AbstractStatement> list){
  Map<AbstractStatement,Integer> depthOfNestingMap=new LinkedHashMap<AbstractStatement,Integer>();
  for (  AbstractStatement statement : list) {
    int depthOfNesting=0;
    AbstractStatement parentStatement=statement.getParent();
    while (parentStatement != null) {
      parentStatement=parentStatement.getParent();
      depthOfNesting++;
    }
    depthOfNestingMap.put(statement,depthOfNesting);
  }
  TreeSet<Integer> depths=new TreeSet<Integer>();
  for (  Integer depth : depthOfNestingMap.values()) {
    depths.add(depth);
  }
  int minimumDepthOfNesting=depths.first();
  if (minimumDepthOfNesting == 1) {
    return null;
  }
 else {
    for (    AbstractStatement statement : depthOfNestingMap.keySet()) {
      int depth=depthOfNestingMap.get(statement);
      if (depth > minimumDepthOfNesting) {
        AbstractStatement parentStatement=statement;
        for (int i=0; i < depth - minimumDepthOfNesting; i++) {
          parentStatement=parentStatement.getParent();
        }
        int index=list.indexOf(statement);
        list.remove(index);
        list.add(index,parentStatement);
      }
    }
  }
  List<AbstractStatement> parentStatements=new ArrayList<AbstractStatement>();
  for (  AbstractStatement statement : list) {
    parentStatements.add(statement.getParent());
  }
  AbstractStatement parentStatement=parentStatements.get(0);
  for (int i=1; i < parentStatements.size(); i++) {
    if (!parentStatement.equals(parentStatements.get(i))) {
      return haveRecursivelyTheSameParent(parentStatements);
    }
  }
  if (parentStatement.getParent() != null)   return parentStatement;
 else   return null;
}","private CompositeStatementObject haveRecursivelyTheSameParent(List<AbstractStatement> list){
  List<AbstractStatement> copiedList=new ArrayList<AbstractStatement>(list);
  Map<AbstractStatement,Integer> depthOfNestingMap=new LinkedHashMap<AbstractStatement,Integer>();
  for (  AbstractStatement statement : copiedList) {
    int depthOfNesting=0;
    AbstractStatement parentStatement=statement.getParent();
    while (parentStatement != null) {
      parentStatement=parentStatement.getParent();
      depthOfNesting++;
    }
    depthOfNestingMap.put(statement,depthOfNesting);
  }
  TreeSet<Integer> depths=new TreeSet<Integer>();
  for (  Integer depth : depthOfNestingMap.values()) {
    depths.add(depth);
  }
  int minimumDepthOfNesting=depths.first();
  if (minimumDepthOfNesting == 1) {
    return null;
  }
 else {
    for (    AbstractStatement statement : depthOfNestingMap.keySet()) {
      int depth=depthOfNestingMap.get(statement);
      if (depth > minimumDepthOfNesting) {
        AbstractStatement parentStatement=statement;
        for (int i=0; i < depth - minimumDepthOfNesting; i++) {
          parentStatement=parentStatement.getParent();
        }
        int index=copiedList.indexOf(statement);
        copiedList.remove(index);
        copiedList.add(index,parentStatement);
      }
    }
  }
  List<AbstractStatement> parentStatements=new ArrayList<AbstractStatement>();
  for (  AbstractStatement statement : copiedList) {
    parentStatements.add(statement.getParent());
  }
  AbstractStatement parentStatement=parentStatements.get(0);
  for (int i=1; i < parentStatements.size(); i++) {
    if (!parentStatement.equals(parentStatements.get(i))) {
      return haveRecursivelyTheSameParent(parentStatements);
    }
  }
  if (parentStatement.getParent() != null)   return (CompositeStatementObject)parentStatement;
 else   return null;
}"
12266,"public List<ExtractionBlock> generateExtractionBlocks(){
  Map<LocalVariableDeclarationObject,List<AbstractStatement>> assignmentMap=new LinkedHashMap<LocalVariableDeclarationObject,List<AbstractStatement>>();
  for (  LocalVariableDeclarationObject lvdo : getLocalVariableDeclarations()) {
    List<AbstractStatement> localVariableAssignments=compositeStatement.getLocalVariableAssignments(lvdo);
    if (localVariableAssignments.size() > 0)     assignmentMap.put(lvdo,localVariableAssignments);
  }
  List<ExtractionBlock> extractionBlockList=new ArrayList<ExtractionBlock>();
  for (  LocalVariableDeclarationObject variableDeclaration : assignmentMap.keySet()) {
    List<AbstractStatement> localVariableAssignments=assignmentMap.get(variableDeclaration);
    List<String> assignmentOperators=new ArrayList<String>();
    Set<LocalVariableInstructionObject> localVariableInstructionsFoundInAssignments=new HashSet<LocalVariableInstructionObject>();
    for (    AbstractStatement localVariableAssignment : localVariableAssignments) {
      assignmentOperators.add(getAssignmentOperator(localVariableAssignment));
      List<LocalVariableInstructionObject> instructions=localVariableAssignment.getLocalVariableInstructions();
      for (      LocalVariableInstructionObject instruction : instructions) {
        if (assignmentMap.containsKey(instruction.generateLocalVariableDeclaration()))         localVariableInstructionsFoundInAssignments.add(instruction);
      }
    }
    Set<LocalVariableDeclarationObject> nonAcceptedVariableAssignments=new HashSet<LocalVariableDeclarationObject>(assignmentMap.keySet());
    for (    LocalVariableInstructionObject variableInstruction : localVariableInstructionsFoundInAssignments) {
      LocalVariableDeclarationObject lvdo=variableInstruction.generateLocalVariableDeclaration();
      nonAcceptedVariableAssignments.remove(lvdo);
    }
    List<AbstractStatement> newLocalVariableAssignments=new ArrayList<AbstractStatement>();
    for (    AbstractStatement statement : localVariableAssignments) {
      CompositeStatementObject parent=statement.getParent();
      AbstractStatement current=statement;
      while (parent != null && parent.getLocalVariableAssignments(nonAcceptedVariableAssignments).size() == 0 && removeExceptionVariableDeclarations(parent.getLocalVariableDeclarations()).size() == 0 && !parent.containsLocalVariableInstruction(nonAcceptedVariableAssignments)) {
        current=parent;
        parent=current.getParent();
      }
      if (!newLocalVariableAssignments.contains(current) && current.getParent() != null)       newLocalVariableAssignments.add(current);
    }
    AbstractStatement currentStatement=newLocalVariableAssignments.get(0);
    AbstractStatement parent=currentStatement.getParent();
    if (parent.getParent() == null) {
      boolean onlyLocalVariableDeclarationsFound=true;
      AbstractStatement previousStatement=compositeStatement.getPreviousStatement(currentStatement);
      while (previousStatement != null) {
        if (!(previousStatement.getStatement() instanceof VariableDeclarationStatement)) {
          onlyLocalVariableDeclarationsFound=false;
          break;
        }
        previousStatement=compositeStatement.getPreviousStatement(previousStatement);
      }
      if (onlyLocalVariableDeclarationsFound)       newLocalVariableAssignments.clear();
    }
    if ((newLocalVariableAssignments.size() > 1 && belongToTheSameBlock(newLocalVariableAssignments) && consecutive(newLocalVariableAssignments)) || (newLocalVariableAssignments.size() == 1 && !(newLocalVariableAssignments.get(0) instanceof StatementObject))) {
      ExtractionBlock block=new ExtractionBlock(variableDeclaration,getVariableDeclarationStatement(variableDeclaration),newLocalVariableAssignments,assignmentOperators);
      for (      LocalVariableInstructionObject variableInstruction : localVariableInstructionsFoundInAssignments) {
        LocalVariableDeclarationObject lvdo=variableInstruction.generateLocalVariableDeclaration();
        if (!lvdo.equals(variableDeclaration) && !hasAssignmentBeforeStatement(lvdo,newLocalVariableAssignments.get(0))) {
          VariableDeclarationStatement variableDeclarationStatement=getVariableDeclarationStatement(lvdo);
          if (variableDeclarationStatement != null)           block.addRequiredVariableDeclarationStatement(lvdo,variableDeclarationStatement);
        }
      }
      extractionBlockList.add(block);
    }
 else     if (newLocalVariableAssignments.size() > 1) {
      AbstractStatement parentStatement=haveRecursivelyTheSameParent(newLocalVariableAssignments);
      if (parentStatement != null && !(parentStatement.getStatement() instanceof Block)) {
        List<AbstractStatement> tempLocalVariableAssignments=new ArrayList<AbstractStatement>(newLocalVariableAssignments);
        for (        AbstractStatement statement : tempLocalVariableAssignments) {
          int index=newLocalVariableAssignments.indexOf(statement);
          AbstractStatement previousStatement=this.compositeStatement.getPreviousStatement(statement);
          while (previousStatement != null) {
            if (previousStatement instanceof StatementObject) {
              StatementObject previousStatementObject=(StatementObject)previousStatement;
              if (!previousStatementObject.isLocalVariableAssignment(nonAcceptedVariableAssignments)) {
                if (!(previousStatementObject.getStatement() instanceof EmptyStatement)) {
                  newLocalVariableAssignments.add(index,previousStatement);
                  index=newLocalVariableAssignments.indexOf(previousStatement);
                }
                previousStatement=this.compositeStatement.getPreviousStatement(previousStatement);
              }
 else {
                break;
              }
            }
 else             if (previousStatement instanceof CompositeStatementObject) {
              CompositeStatementObject previousCompositeStatement=(CompositeStatementObject)previousStatement;
              if (previousCompositeStatement.getLocalVariableAssignments(nonAcceptedVariableAssignments).size() == 0) {
                newLocalVariableAssignments.add(index,previousStatement);
                index=newLocalVariableAssignments.indexOf(previousStatement);
                previousStatement=this.compositeStatement.getPreviousStatement(previousStatement);
              }
 else {
                break;
              }
            }
          }
        }
        ExtractionBlock block=new ExtractionBlock(variableDeclaration,getVariableDeclarationStatement(variableDeclaration),newLocalVariableAssignments,assignmentOperators);
        for (        LocalVariableInstructionObject variableInstruction : localVariableInstructionsFoundInAssignments) {
          LocalVariableDeclarationObject lvdo=variableInstruction.generateLocalVariableDeclaration();
          if (!lvdo.equals(variableDeclaration) && !hasAssignmentBeforeStatement(lvdo,newLocalVariableAssignments.get(0))) {
            VariableDeclarationStatement variableDeclarationStatement=getVariableDeclarationStatement(lvdo);
            if (variableDeclarationStatement != null)             block.addRequiredVariableDeclarationStatement(lvdo,variableDeclarationStatement);
          }
        }
        block.setParentStatementForCopy(parentStatement);
        extractionBlockList.add(block);
      }
    }
  }
  return extractionBlockList;
}","public List<ExtractionBlock> generateExtractionBlocks(){
  Map<LocalVariableDeclarationObject,List<AbstractStatement>> assignmentMap=new LinkedHashMap<LocalVariableDeclarationObject,List<AbstractStatement>>();
  for (  LocalVariableDeclarationObject lvdo : getLocalVariableDeclarations()) {
    List<AbstractStatement> localVariableAssignments=compositeStatement.getLocalVariableAssignments(lvdo);
    if (localVariableAssignments.size() > 0)     assignmentMap.put(lvdo,localVariableAssignments);
  }
  List<ExtractionBlock> extractionBlockList=new ArrayList<ExtractionBlock>();
  for (  LocalVariableDeclarationObject variableDeclaration : assignmentMap.keySet()) {
    List<AbstractStatement> localVariableAssignments=assignmentMap.get(variableDeclaration);
    List<String> assignmentOperators=new ArrayList<String>();
    Set<LocalVariableInstructionObject> localVariableInstructionsFoundInAssignments=new HashSet<LocalVariableInstructionObject>();
    for (    AbstractStatement localVariableAssignment : localVariableAssignments) {
      assignmentOperators.add(getAssignmentOperator(localVariableAssignment));
      List<LocalVariableInstructionObject> instructions=localVariableAssignment.getLocalVariableInstructions();
      for (      LocalVariableInstructionObject instruction : instructions) {
        if (assignmentMap.containsKey(instruction.generateLocalVariableDeclaration()))         localVariableInstructionsFoundInAssignments.add(instruction);
      }
    }
    Set<LocalVariableDeclarationObject> nonAcceptedVariableAssignments=new HashSet<LocalVariableDeclarationObject>(assignmentMap.keySet());
    for (    LocalVariableInstructionObject variableInstruction : localVariableInstructionsFoundInAssignments) {
      LocalVariableDeclarationObject lvdo=variableInstruction.generateLocalVariableDeclaration();
      nonAcceptedVariableAssignments.remove(lvdo);
    }
    List<AbstractStatement> newLocalVariableAssignments=new ArrayList<AbstractStatement>();
    for (    AbstractStatement statement : localVariableAssignments) {
      CompositeStatementObject parent=statement.getParent();
      AbstractStatement current=statement;
      while (parent != null && parent.getLocalVariableAssignments(nonAcceptedVariableAssignments).size() == 0 && removeExceptionVariableDeclarations(parent.getLocalVariableDeclarations()).size() == 0 && !parent.containsLocalVariableInstruction(nonAcceptedVariableAssignments)) {
        current=parent;
        parent=current.getParent();
      }
      if (!newLocalVariableAssignments.contains(current) && current.getParent() != null)       newLocalVariableAssignments.add(current);
    }
    AbstractStatement currentStatement=newLocalVariableAssignments.get(0);
    AbstractStatement parent=currentStatement.getParent();
    if (parent.getParent() == null) {
      boolean onlyLocalVariableDeclarationsFound=true;
      AbstractStatement previousStatement=compositeStatement.getPreviousStatement(currentStatement);
      while (previousStatement != null) {
        if (!(previousStatement.getStatement() instanceof VariableDeclarationStatement)) {
          onlyLocalVariableDeclarationsFound=false;
          break;
        }
        previousStatement=compositeStatement.getPreviousStatement(previousStatement);
      }
      if (onlyLocalVariableDeclarationsFound)       newLocalVariableAssignments.clear();
    }
    if ((newLocalVariableAssignments.size() > 1 && belongToTheSameBlock(newLocalVariableAssignments) && consecutive(newLocalVariableAssignments)) || (newLocalVariableAssignments.size() == 1 && !(newLocalVariableAssignments.get(0) instanceof StatementObject))) {
      ExtractionBlock block=new ExtractionBlock(variableDeclaration,getVariableDeclarationStatement(variableDeclaration),newLocalVariableAssignments,assignmentOperators);
      for (      LocalVariableInstructionObject variableInstruction : localVariableInstructionsFoundInAssignments) {
        LocalVariableDeclarationObject lvdo=variableInstruction.generateLocalVariableDeclaration();
        if (!lvdo.equals(variableDeclaration) && !hasAssignmentBeforeStatement(lvdo,newLocalVariableAssignments.get(0))) {
          VariableDeclarationStatement variableDeclarationStatement=getVariableDeclarationStatement(lvdo);
          if (variableDeclarationStatement != null)           block.addRequiredVariableDeclarationStatement(lvdo,variableDeclarationStatement);
        }
      }
      extractionBlockList.add(block);
    }
 else     if (newLocalVariableAssignments.size() > 1) {
      CompositeStatementObject parentStatement=haveRecursivelyTheSameParent(newLocalVariableAssignments);
      if (parentStatement != null && !(parentStatement.getStatement() instanceof Block)) {
        List<AbstractStatement> tempLocalVariableAssignments=new ArrayList<AbstractStatement>(newLocalVariableAssignments);
        for (        AbstractStatement statement : tempLocalVariableAssignments) {
          int index=newLocalVariableAssignments.indexOf(statement);
          AbstractStatement previousStatement=this.compositeStatement.getPreviousStatement(statement);
          while (previousStatement != null) {
            if (previousStatement instanceof StatementObject) {
              StatementObject previousStatementObject=(StatementObject)previousStatement;
              if (!previousStatementObject.isLocalVariableAssignment(nonAcceptedVariableAssignments)) {
                if (!(previousStatementObject.getStatement() instanceof EmptyStatement)) {
                  newLocalVariableAssignments.add(index,previousStatement);
                  index=newLocalVariableAssignments.indexOf(previousStatement);
                }
                previousStatement=this.compositeStatement.getPreviousStatement(previousStatement);
              }
 else {
                break;
              }
            }
 else             if (previousStatement instanceof CompositeStatementObject) {
              CompositeStatementObject previousCompositeStatement=(CompositeStatementObject)previousStatement;
              if (previousCompositeStatement.getLocalVariableAssignments(nonAcceptedVariableAssignments).size() == 0) {
                newLocalVariableAssignments.add(index,previousStatement);
                index=newLocalVariableAssignments.indexOf(previousStatement);
                previousStatement=this.compositeStatement.getPreviousStatement(previousStatement);
              }
 else {
                break;
              }
            }
          }
        }
        ExtractionBlock block=new ExtractionBlock(variableDeclaration,getVariableDeclarationStatement(variableDeclaration),newLocalVariableAssignments,assignmentOperators);
        for (        LocalVariableInstructionObject variableInstruction : localVariableInstructionsFoundInAssignments) {
          LocalVariableDeclarationObject lvdo=variableInstruction.generateLocalVariableDeclaration();
          if (!lvdo.equals(variableDeclaration) && !hasAssignmentBeforeStatement(lvdo,newLocalVariableAssignments.get(0))) {
            VariableDeclarationStatement variableDeclarationStatement=getVariableDeclarationStatement(lvdo);
            if (variableDeclarationStatement != null)             block.addRequiredVariableDeclarationStatement(lvdo,variableDeclarationStatement);
          }
        }
        block.setParentStatementForCopy(parentStatement);
        extractionBlockList.add(block);
      }
    }
  }
  return extractionBlockList;
}"
12267,"private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
      targetClassVariableName=parameter.getName().getIdentifier();
      parametersRewrite.remove(newMethodParameters.get(i),null);
      break;
    }
    i++;
  }
  if (targetClassVariableName == null) {
    FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
          targetClassVariableName=fragment.getName().getIdentifier();
          break;
        }
      }
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(newMethodDeclaration);
  insertTargetClassVariableNameAsVariableDeclaration(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(newMethodDeclaration);
  ListRewrite targetClassBodyRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  targetClassBodyRewrite.insertLast(newMethodDeclaration,null);
}","private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
      targetClassVariableName=parameter.getName().getIdentifier();
      parametersRewrite.remove(newMethodParameters.get(i),null);
      break;
    }
    i++;
  }
  if (targetClassVariableName == null) {
    FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
          targetClassVariableName=fragment.getName().getIdentifier();
          break;
        }
      }
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(newMethodDeclaration);
  insertTargetClassVariableNameAsVariableDeclaration(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInVariableDeclarationInitializers(newMethodDeclaration);
  ListRewrite targetClassBodyRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  targetClassBodyRewrite.insertLast(newMethodDeclaration,null);
}"
12268,"private void modifySourceMemberAccessesInTargetClass(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  List<Expression> expressionsToBeRemoved=new ArrayList<Expression>();
  for (  MethodInvocation methodInvocation : additionalMethodsToBeMoved.keySet()) {
    for (    Expression expression : sourceMethodInvocations) {
      if (expression instanceof MethodInvocation) {
        MethodInvocation sourceMethodInvocation=(MethodInvocation)expression;
        if (methodInvocation.equals(sourceMethodInvocation)) {
          expressionsToBeRemoved.add(methodInvocation);
        }
      }
    }
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  expressionsToBeRemoved.clear();
  int k=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      ITypeBinding methodInvocationDeclaringClassTypeBinding=methodInvocation.resolveMethodBinding().getDeclaringClass();
      if (methodInvocationDeclaringClassTypeBinding.isEqualTo(sourceTypeDeclaration.resolveBinding()) && (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression)) {
        MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
        for (        MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
          if (sourceMethodDeclaration.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
            MethodInvocation delegation=isDelegate(sourceMethodDeclaration);
            if (delegation != null) {
              ITypeBinding delegationDeclaringClassTypeBinding=delegation.resolveMethodBinding().getDeclaringClass();
              if (delegationDeclaringClassTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
                if (delegation.getExpression() != null) {
                  MethodInvocation newMethodInvocation=(MethodInvocation)ASTNode.copySubtree(newMethodDeclaration.getAST(),delegation);
                  targetRewriter.remove(newMethodInvocation.getExpression(),null);
                  targetRewriter.replace(newMethodInvocations.get(k),newMethodInvocation,null);
                }
                expressionsToBeRemoved.add(methodInvocation);
              }
            }
          }
        }
      }
 else       if (methodInvocationDeclaringClassTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding()) && methodInvocation.getExpression() != null) {
        Expression methodInvocationExpression=methodInvocation.getExpression();
        if (methodInvocationExpression instanceof MethodInvocation) {
          MethodInvocation invoker=(MethodInvocation)methodInvocationExpression;
          if (invoker.getExpression() == null || invoker.getExpression() instanceof ThisExpression) {
            MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
            for (            MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
              if (sourceMethodDeclaration.resolveBinding().isEqualTo(invoker.resolveMethodBinding())) {
                SimpleName fieldInstruction=isGetter(sourceMethodDeclaration);
                if (fieldInstruction != null && fieldInstruction.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                  int index=sourceMethodInvocations.indexOf(invoker);
                  targetRewriter.remove(newMethodInvocations.get(index),null);
                  expressionsToBeRemoved.add(invoker);
                  expressionsToBeRemoved.add(methodInvocation);
                }
              }
            }
          }
        }
      }
    }
    k++;
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceFieldInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && sourceTypeDeclaration.resolveBinding().isEqualTo(variableBinding.getDeclaringClass()) && (variableBinding.getModifiers() & Modifier.STATIC) == 0) {
        SimpleName expressionName=(SimpleName)newFieldInstructions.get(i);
        if (expressionName.getParent() instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)expressionName.getParent();
          if (fieldAccess.getExpression() instanceof ThisExpression && !expressionName.getIdentifier().equals(targetClassVariableName)) {
            targetRewriter.replace(expressionName.getParent(),expressionName,null);
            if (!additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))             addParameterToMovedMethod(newMethodDeclaration,expressionName);
          }
        }
 else         if (!expressionName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))         addParameterToMovedMethod(newMethodDeclaration,expressionName);
      }
    }
    i++;
  }
  SimpleName parameterName=null;
  int j=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      if (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression) {
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        if (methodBinding.getDeclaringClass().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
          MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
          for (          MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
            if (sourceMethodDeclaration.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
              SimpleName fieldName=isGetter(sourceMethodDeclaration);
              MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(j);
              if (fieldName != null) {
                AST ast=newMethodDeclaration.getAST();
                targetRewriter.replace(newMethodInvocation,ast.newSimpleName(fieldName.getIdentifier()),null);
                if (!fieldName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(fieldName.getIdentifier()))                 addParameterToMovedMethod(newMethodDeclaration,fieldName);
              }
 else {
                if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
                  parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
                }
                targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
                setPublicModifierToSourceMethod(methodInvocation);
              }
            }
          }
        }
 else {
          Type superclassType=sourceTypeDeclaration.getSuperclassType();
          ITypeBinding superclassTypeBinding=null;
          if (superclassType != null)           superclassTypeBinding=superclassType.resolveBinding();
          while (superclassTypeBinding != null && !methodBinding.getDeclaringClass().isEqualTo(superclassTypeBinding)) {
            superclassTypeBinding=superclassTypeBinding.getSuperclass();
          }
          if (superclassTypeBinding != null) {
            IMethodBinding[] superclassMethodBindings=superclassTypeBinding.getDeclaredMethods();
            for (            IMethodBinding superclassMethodBinding : superclassMethodBindings) {
              if (superclassMethodBinding.isEqualTo(methodInvocation.resolveMethodBinding())) {
                MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(j);
                if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
                  parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
                }
                targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
              }
            }
          }
        }
      }
    }
    j++;
  }
}","private void modifySourceMemberAccessesInTargetClass(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  List<Expression> expressionsToBeRemoved=new ArrayList<Expression>();
  for (  MethodInvocation methodInvocation : additionalMethodsToBeMoved.keySet()) {
    for (    Expression expression : sourceMethodInvocations) {
      if (expression instanceof MethodInvocation) {
        MethodInvocation sourceMethodInvocation=(MethodInvocation)expression;
        if (methodInvocation.equals(sourceMethodInvocation)) {
          expressionsToBeRemoved.add(methodInvocation);
        }
      }
    }
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  expressionsToBeRemoved.clear();
  int k=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      ITypeBinding methodInvocationDeclaringClassTypeBinding=methodInvocation.resolveMethodBinding().getDeclaringClass();
      if (methodInvocationDeclaringClassTypeBinding.isEqualTo(sourceTypeDeclaration.resolveBinding()) && (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression)) {
        MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
        for (        MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
          if (sourceMethodDeclaration.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
            MethodInvocation delegation=isDelegate(sourceMethodDeclaration);
            if (delegation != null) {
              ITypeBinding delegationDeclaringClassTypeBinding=delegation.resolveMethodBinding().getDeclaringClass();
              if (delegationDeclaringClassTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding())) {
                if (delegation.getExpression() != null) {
                  MethodInvocation newMethodInvocation=(MethodInvocation)ASTNode.copySubtree(newMethodDeclaration.getAST(),delegation);
                  targetRewriter.remove(newMethodInvocation.getExpression(),null);
                  targetRewriter.replace(newMethodInvocations.get(k),newMethodInvocation,null);
                }
                expressionsToBeRemoved.add(methodInvocation);
              }
            }
          }
        }
      }
 else       if (methodInvocationDeclaringClassTypeBinding.isEqualTo(targetTypeDeclaration.resolveBinding()) && methodInvocation.getExpression() != null) {
        Expression methodInvocationExpression=methodInvocation.getExpression();
        if (methodInvocationExpression instanceof MethodInvocation) {
          MethodInvocation invoker=(MethodInvocation)methodInvocationExpression;
          if (invoker.getExpression() == null || invoker.getExpression() instanceof ThisExpression) {
            MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
            for (            MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
              if (sourceMethodDeclaration.resolveBinding().isEqualTo(invoker.resolveMethodBinding())) {
                SimpleName fieldInstruction=isGetter(sourceMethodDeclaration);
                if (fieldInstruction != null && fieldInstruction.resolveTypeBinding().isEqualTo(targetTypeDeclaration.resolveBinding())) {
                  int index=sourceMethodInvocations.indexOf(invoker);
                  targetRewriter.remove(newMethodInvocations.get(index),null);
                  expressionsToBeRemoved.add(invoker);
                  expressionsToBeRemoved.add(methodInvocation);
                }
              }
            }
          }
        }
      }
    }
    k++;
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceFieldInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && sourceTypeDeclaration.resolveBinding().isEqualTo(variableBinding.getDeclaringClass()) && (variableBinding.getModifiers() & Modifier.STATIC) == 0) {
        SimpleName expressionName=(SimpleName)newFieldInstructions.get(i);
        if (expressionName.getParent() instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)expressionName.getParent();
          if (fieldAccess.getExpression() instanceof ThisExpression && !expressionName.getIdentifier().equals(targetClassVariableName)) {
            targetRewriter.replace(expressionName.getParent(),expressionName,null);
            if (!additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))             addParameterToMovedMethod(newMethodDeclaration,expressionName);
          }
        }
 else         if (!expressionName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))         addParameterToMovedMethod(newMethodDeclaration,expressionName);
      }
    }
    i++;
  }
  SimpleName parameterName=null;
  Set<String> sourceMethodsWithPublicModifier=new LinkedHashSet<String>();
  int j=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      if (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression) {
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        if (methodBinding.getDeclaringClass().isEqualTo(sourceTypeDeclaration.resolveBinding())) {
          MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
          for (          MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
            if (sourceMethodDeclaration.resolveBinding().isEqualTo(methodInvocation.resolveMethodBinding())) {
              SimpleName fieldName=isGetter(sourceMethodDeclaration);
              MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(j);
              if (fieldName != null) {
                AST ast=newMethodDeclaration.getAST();
                targetRewriter.replace(newMethodInvocation,ast.newSimpleName(fieldName.getIdentifier()),null);
                if (!fieldName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(fieldName.getIdentifier()))                 addParameterToMovedMethod(newMethodDeclaration,fieldName);
              }
 else {
                if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
                  parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
                }
                targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
                if (!sourceMethodsWithPublicModifier.contains(methodInvocation.resolveMethodBinding().toString())) {
                  setPublicModifierToSourceMethod(methodInvocation);
                  sourceMethodsWithPublicModifier.add(methodInvocation.resolveMethodBinding().toString());
                }
              }
            }
          }
        }
 else {
          Type superclassType=sourceTypeDeclaration.getSuperclassType();
          ITypeBinding superclassTypeBinding=null;
          if (superclassType != null)           superclassTypeBinding=superclassType.resolveBinding();
          while (superclassTypeBinding != null && !methodBinding.getDeclaringClass().isEqualTo(superclassTypeBinding)) {
            superclassTypeBinding=superclassTypeBinding.getSuperclass();
          }
          if (superclassTypeBinding != null) {
            IMethodBinding[] superclassMethodBindings=superclassTypeBinding.getDeclaredMethods();
            for (            IMethodBinding superclassMethodBinding : superclassMethodBindings) {
              if (superclassMethodBinding.isEqualTo(methodInvocation.resolveMethodBinding())) {
                MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(j);
                if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
                  parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
                }
                targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
              }
            }
          }
        }
      }
    }
    j++;
  }
}"
12269,"private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
      targetClassVariableName=parameter.getName().getIdentifier();
      parametersRewrite.remove(newMethodParameters.get(i),null);
      break;
    }
    i++;
  }
  if (targetClassVariableName == null) {
    FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
          targetClassVariableName=fragment.getName().getIdentifier();
          break;
        }
      }
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(newMethodDeclaration);
  ListRewrite methodDeclarationRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertLast(newMethodDeclaration,null);
}","private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
      targetClassVariableName=parameter.getName().getIdentifier();
      parametersRewrite.remove(newMethodParameters.get(i),null);
      break;
    }
    i++;
  }
  if (targetClassVariableName == null) {
    FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
          targetClassVariableName=fragment.getName().getIdentifier();
          break;
        }
      }
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  replaceTargetClassVariableNameWithThisExpressionInMethodInvocationArguments(newMethodDeclaration);
  insertTargetClassVariableNameAsVariableDeclaration(newMethodDeclaration);
  replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(newMethodDeclaration);
  ListRewrite methodDeclarationRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertLast(newMethodDeclaration,null);
}"
12270,"private void modifyMovedMethodInvocationInSourceClass(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  MethodDeclaration[] methodDeclarations=sourceTypeDeclaration.getMethods();
  for (  MethodDeclaration methodDeclaration : methodDeclarations) {
    Block methodBody=methodDeclaration.getBody();
    List<Statement> statements=methodBody.statements();
    for (    Statement statement : statements) {
      List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
      for (      Expression expression : methodInvocations) {
        if (expression instanceof MethodInvocation) {
          MethodInvocation methodInvocation=(MethodInvocation)expression;
          if (identicalSignature(sourceMethod,methodInvocation)) {
            List<Expression> arguments=methodInvocation.arguments();
            boolean foundInArguments=false;
            for (            Expression argument : arguments) {
              if (argument.resolveTypeBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
                foundInArguments=true;
                ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                argumentRewrite.remove(argument,null);
                sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,argument,null);
                break;
              }
            }
            boolean foundInLocalVariableDeclarations=false;
            if (!foundInArguments) {
              StatementExtractor statementExtractor=new StatementExtractor();
              List<Statement> variableDeclarationStatements=statementExtractor.getVariableDeclarations(methodBody);
              for (              Statement variableDeclarationStatement : variableDeclarationStatements) {
                VariableDeclarationStatement variableDeclaration=(VariableDeclarationStatement)variableDeclarationStatement;
                List<VariableDeclarationFragment> fragments=variableDeclaration.fragments();
                for (                VariableDeclarationFragment fragment : fragments) {
                  if (variableDeclaration.getType().resolveBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName()) && variableDeclaration.getStartPosition() < methodInvocation.getStartPosition()) {
                    foundInLocalVariableDeclarations=true;
                    sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                    break;
                  }
                }
              }
            }
            if (!foundInArguments && !foundInLocalVariableDeclarations) {
              FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
              for (              FieldDeclaration fieldDeclaration : fieldDeclarations) {
                List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                for (                VariableDeclarationFragment fragment : fragments) {
                  if (fieldDeclaration.getType().resolveBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
                    sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                    break;
                  }
                }
              }
            }
            ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
            AST ast=methodInvocation.getAST();
            for (            String argument : additionalArgumentsAddedToMovedMethod) {
              if (argument.equals(""String_Node_Str""))               argumentRewrite.insertLast(ast.newThisExpression(),null);
 else               argumentRewrite.insertLast(ast.newSimpleName(argument),null);
            }
          }
        }
      }
    }
  }
}","private void modifyMovedMethodInvocationInSourceClass(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  MethodDeclaration[] methodDeclarations=sourceTypeDeclaration.getMethods();
  for (  MethodDeclaration methodDeclaration : methodDeclarations) {
    Block methodBody=methodDeclaration.getBody();
    if (methodBody != null) {
      List<Statement> statements=methodBody.statements();
      for (      Statement statement : statements) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            if (identicalSignature(sourceMethod,methodInvocation)) {
              List<Expression> arguments=methodInvocation.arguments();
              boolean foundInArguments=false;
              for (              Expression argument : arguments) {
                if (argument.resolveTypeBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
                  foundInArguments=true;
                  ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                  argumentRewrite.remove(argument,null);
                  sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,argument,null);
                  break;
                }
              }
              boolean foundInLocalVariableDeclarations=false;
              if (!foundInArguments) {
                StatementExtractor statementExtractor=new StatementExtractor();
                List<Statement> variableDeclarationStatements=statementExtractor.getVariableDeclarations(methodBody);
                for (                Statement variableDeclarationStatement : variableDeclarationStatements) {
                  VariableDeclarationStatement variableDeclaration=(VariableDeclarationStatement)variableDeclarationStatement;
                  List<VariableDeclarationFragment> fragments=variableDeclaration.fragments();
                  for (                  VariableDeclarationFragment fragment : fragments) {
                    if (variableDeclaration.getType().resolveBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName()) && variableDeclaration.getStartPosition() < methodInvocation.getStartPosition()) {
                      foundInLocalVariableDeclarations=true;
                      sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                      break;
                    }
                  }
                }
              }
              if (!foundInArguments && !foundInLocalVariableDeclarations) {
                FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
                for (                FieldDeclaration fieldDeclaration : fieldDeclarations) {
                  List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
                  for (                  VariableDeclarationFragment fragment : fragments) {
                    if (fieldDeclaration.getType().resolveBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
                      sourceRewriter.set(methodInvocation,MethodInvocation.EXPRESSION_PROPERTY,fragment.getName(),null);
                      break;
                    }
                  }
                }
              }
              ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
              AST ast=methodInvocation.getAST();
              for (              String argument : additionalArgumentsAddedToMovedMethod) {
                if (argument.equals(""String_Node_Str""))                 argumentRewrite.insertLast(ast.newThisExpression(),null);
 else                 argumentRewrite.insertLast(ast.newSimpleName(argument),null);
              }
            }
          }
        }
      }
    }
  }
}"
12271,"private void modifyMovedMethodInvocationInTargetClass(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  MethodDeclaration[] methodDeclarations=targetTypeDeclaration.getMethods();
  for (  MethodDeclaration methodDeclaration : methodDeclarations) {
    Block methodBody=methodDeclaration.getBody();
    List<Statement> statements=methodBody.statements();
    Map<String,Integer> invokerCounterMap=new LinkedHashMap<String,Integer>();
    for (    Statement statement : statements) {
      List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
      for (      Expression expression : methodInvocations) {
        if (expression instanceof MethodInvocation) {
          MethodInvocation methodInvocation=(MethodInvocation)expression;
          if (identicalSignature(sourceMethod,methodInvocation)) {
            Expression invoker=methodInvocation.getExpression();
            if (invoker instanceof SimpleName) {
              SimpleName simpleName=(SimpleName)invoker;
              targetRewriter.remove(simpleName,null);
              String identifier=simpleName.getIdentifier();
              if (invokerCounterMap.containsKey(identifier)) {
                invokerCounterMap.put(identifier,invokerCounterMap.get(identifier) + 1);
              }
 else {
                invokerCounterMap.put(identifier,1);
              }
            }
            List<Expression> arguments=methodInvocation.arguments();
            for (            Expression argument : arguments) {
              if (argument instanceof ThisExpression) {
                ListRewrite argumentRewrite=targetRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                argumentRewrite.remove(argument,null);
              }
            }
          }
        }
      }
    }
  }
}","private void modifyMovedMethodInvocationInTargetClass(){
  ExpressionExtractor expressionExtractor=new ExpressionExtractor();
  MethodDeclaration[] methodDeclarations=targetTypeDeclaration.getMethods();
  for (  MethodDeclaration methodDeclaration : methodDeclarations) {
    Block methodBody=methodDeclaration.getBody();
    if (methodBody != null) {
      List<Statement> statements=methodBody.statements();
      Map<String,Integer> invokerCounterMap=new LinkedHashMap<String,Integer>();
      for (      Statement statement : statements) {
        List<Expression> methodInvocations=expressionExtractor.getMethodInvocations(statement);
        for (        Expression expression : methodInvocations) {
          if (expression instanceof MethodInvocation) {
            MethodInvocation methodInvocation=(MethodInvocation)expression;
            if (identicalSignature(sourceMethod,methodInvocation)) {
              Expression invoker=methodInvocation.getExpression();
              if (invoker instanceof SimpleName) {
                SimpleName simpleName=(SimpleName)invoker;
                targetRewriter.remove(simpleName,null);
                String identifier=simpleName.getIdentifier();
                if (invokerCounterMap.containsKey(identifier)) {
                  invokerCounterMap.put(identifier,invokerCounterMap.get(identifier) + 1);
                }
 else {
                  invokerCounterMap.put(identifier,1);
                }
              }
              List<Expression> arguments=methodInvocation.arguments();
              for (              Expression argument : arguments) {
                if (argument instanceof ThisExpression) {
                  ListRewrite argumentRewrite=targetRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
                  argumentRewrite.remove(argument,null);
                }
              }
            }
          }
        }
      }
    }
  }
}"
12272,"public List<ExtractAndMoveMethodCandidateRefactoring> getExtractAndMoveMethodCandidateRefactorings(){
  List<ExtractAndMoveMethodCandidateRefactoring> extractMethodCandidateRefactoringList=new ArrayList<ExtractAndMoveMethodCandidateRefactoring>();
  Set<String> extractedMethodNames=new LinkedHashSet<String>();
  Iterator<MyClass> classIt=system.getClassIterator();
  while (classIt.hasNext()) {
    MyClass myClass=classIt.next();
    ListIterator<MyMethod> methodIterator=myClass.getMethodIterator();
    while (methodIterator.hasNext()) {
      MyMethod method=methodIterator.next();
      if (method.getMethodObject().getMethodBody() != null) {
        List<ExtractionBlock> extractionBlockList=method.getMethodObject().getMethodBody().generateExtractionBlocks();
        for (        ExtractionBlock block : extractionBlockList) {
          if (extractedMethodNames.contains(block.getExtractedMethodName())) {
            block.setExtractedMethodName(block.getReturnVariableDeclaration().getName() + method.getMethodName().replace(method.getMethodName().charAt(0),Character.toUpperCase(method.getMethodName().charAt(0))));
          }
 else {
            extractedMethodNames.add(block.getExtractedMethodName());
          }
          ExtractAndMoveMethodCandidateRefactoring candidate=new ExtractAndMoveMethodCandidateRefactoring(system,myClass,myClass,method,block);
          extractMethodCandidateRefactoringList.add(candidate);
        }
      }
    }
  }
  Double[][] blockDistanceMatrix=new Double[extractMethodCandidateRefactoringList.size()][classList.size()];
  for (int i=0; i < extractMethodCandidateRefactoringList.size(); i++) {
    ExtractAndMoveMethodCandidateRefactoring candidate=extractMethodCandidateRefactoringList.get(i);
    for (int j=0; j < classList.size(); j++) {
      blockDistanceMatrix[i][j]=DistanceCalculator.getDistance(candidate.getEntitySet(),classMap.get(classNames[j]));
    }
  }
  List<ExtractAndMoveMethodCandidateRefactoring> candidateRefactoringList=new ArrayList<ExtractAndMoveMethodCandidateRefactoring>();
  ;
  Map<Integer,Double> minValueMap=new LinkedHashMap<Integer,Double>();
  for (int i=0; i < blockDistanceMatrix.length; i++) {
    double minValue=1;
    for (int j=0; j < blockDistanceMatrix[i].length; j++) {
      if (blockDistanceMatrix[i][j] < minValue) {
        minValue=blockDistanceMatrix[i][j];
      }
    }
    minValueMap.put(i,minValue);
  }
  for (  Integer i : minValueMap.keySet()) {
    double minValue=minValueMap.get(i);
    ExtractAndMoveMethodCandidateRefactoring candidate=extractMethodCandidateRefactoringList.get(i);
    String rowClass=candidate.getSourceClass().getName();
    if (minValue != 1) {
      for (int j=0; j < blockDistanceMatrix[i].length; j++) {
        if (blockDistanceMatrix[i][j] == minValue) {
          if (!rowClass.equals(classNames[j])) {
            MyClass targetClass=classList.get(j);
            ExtractAndMoveMethodCandidateRefactoring newCandidate=new ExtractAndMoveMethodCandidateRefactoring(system,candidate.getSourceClass(),targetClass,candidate.getSourceMethod(),candidate.getExtractionBlock());
            boolean applicable=newCandidate.apply();
            if (applicable)             candidateRefactoringList.add(newCandidate);
          }
        }
      }
    }
  }
  return candidateRefactoringList;
}","public List<ExtractAndMoveMethodCandidateRefactoring> getExtractAndMoveMethodCandidateRefactorings(){
  List<ExtractAndMoveMethodCandidateRefactoring> extractMethodCandidateRefactoringList=new ArrayList<ExtractAndMoveMethodCandidateRefactoring>();
  Map<String,ArrayList<ExtractAndMoveMethodCandidateRefactoring>> extractedMethodNameMap=new LinkedHashMap<String,ArrayList<ExtractAndMoveMethodCandidateRefactoring>>();
  Iterator<MyClass> classIt=system.getClassIterator();
  while (classIt.hasNext()) {
    MyClass myClass=classIt.next();
    ListIterator<MyMethod> methodIterator=myClass.getMethodIterator();
    while (methodIterator.hasNext()) {
      MyMethod method=methodIterator.next();
      if (method.getMethodObject().getMethodBody() != null) {
        List<ExtractionBlock> extractionBlockList=method.getMethodObject().getMethodBody().generateExtractionBlocks();
        for (        ExtractionBlock block : extractionBlockList) {
          ExtractAndMoveMethodCandidateRefactoring candidate=new ExtractAndMoveMethodCandidateRefactoring(system,myClass,myClass,method,block);
          extractMethodCandidateRefactoringList.add(candidate);
          if (!extractedMethodNameMap.containsKey(block.getExtractedMethodName())) {
            ArrayList<ExtractAndMoveMethodCandidateRefactoring> list=new ArrayList<ExtractAndMoveMethodCandidateRefactoring>();
            list.add(candidate);
            extractedMethodNameMap.put(block.getExtractedMethodName(),list);
          }
 else {
            ArrayList<ExtractAndMoveMethodCandidateRefactoring> list=extractedMethodNameMap.get(block.getExtractedMethodName());
            list.add(candidate);
          }
        }
      }
    }
  }
  for (  String extractedMethodName : extractedMethodNameMap.keySet()) {
    List<ExtractAndMoveMethodCandidateRefactoring> list=extractedMethodNameMap.get(extractedMethodName);
    if (list.size() > 1) {
      for (      ExtractAndMoveMethodCandidateRefactoring candidate : list) {
        candidate.setDistinctExtractedMethodName();
      }
    }
  }
  Double[][] blockDistanceMatrix=new Double[extractMethodCandidateRefactoringList.size()][classList.size()];
  for (int i=0; i < extractMethodCandidateRefactoringList.size(); i++) {
    ExtractAndMoveMethodCandidateRefactoring candidate=extractMethodCandidateRefactoringList.get(i);
    for (int j=0; j < classList.size(); j++) {
      blockDistanceMatrix[i][j]=DistanceCalculator.getDistance(candidate.getEntitySet(),classMap.get(classNames[j]));
    }
  }
  List<ExtractAndMoveMethodCandidateRefactoring> candidateRefactoringList=new ArrayList<ExtractAndMoveMethodCandidateRefactoring>();
  ;
  Map<Integer,Double> minValueMap=new LinkedHashMap<Integer,Double>();
  for (int i=0; i < blockDistanceMatrix.length; i++) {
    double minValue=1;
    for (int j=0; j < blockDistanceMatrix[i].length; j++) {
      if (blockDistanceMatrix[i][j] < minValue) {
        minValue=blockDistanceMatrix[i][j];
      }
    }
    minValueMap.put(i,minValue);
  }
  for (  Integer i : minValueMap.keySet()) {
    double minValue=minValueMap.get(i);
    ExtractAndMoveMethodCandidateRefactoring candidate=extractMethodCandidateRefactoringList.get(i);
    String rowClass=candidate.getSourceClass().getName();
    if (minValue != 1) {
      for (int j=0; j < blockDistanceMatrix[i].length; j++) {
        if (blockDistanceMatrix[i][j] == minValue) {
          if (!rowClass.equals(classNames[j])) {
            MyClass targetClass=classList.get(j);
            ExtractAndMoveMethodCandidateRefactoring newCandidate=new ExtractAndMoveMethodCandidateRefactoring(system,candidate.getSourceClass(),targetClass,candidate.getSourceMethod(),candidate.getExtractionBlock());
            boolean applicable=newCandidate.apply();
            if (applicable)             candidateRefactoringList.add(newCandidate);
          }
        }
      }
    }
  }
  return candidateRefactoringList;
}"
12273,"private SimpleName addSourceClassParameterToMovedMethod(MethodDeclaration newMethodDeclaration){
  AST ast=newMethodDeclaration.getAST();
  SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
  SimpleName typeName=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
  Type parameterType=ast.newSimpleType(typeName);
  targetRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
  String sourceTypeName=sourceTypeDeclaration.getName().getIdentifier();
  SimpleName parameterName=ast.newSimpleName(sourceTypeName.replace(sourceTypeName.charAt(0),Character.toLowerCase(sourceTypeName.charAt(0))));
  targetRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,parameterName,null);
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  parametersRewrite.insertLast(parameter,null);
  this.additionalArgumentsAddedToMovedMethod.add(""String_Node_Str"");
  return parameterName;
}","private SimpleName addSourceClassParameterToMovedMethod(MethodDeclaration newMethodDeclaration){
  AST ast=newMethodDeclaration.getAST();
  SingleVariableDeclaration parameter=ast.newSingleVariableDeclaration();
  SimpleName typeName=ast.newSimpleName(sourceTypeDeclaration.getName().getIdentifier());
  Type parameterType=ast.newSimpleType(typeName);
  targetRewriter.set(parameter,SingleVariableDeclaration.TYPE_PROPERTY,parameterType,null);
  String sourceTypeName=sourceTypeDeclaration.getName().getIdentifier();
  SimpleName parameterName=ast.newSimpleName(sourceTypeName.replaceFirst(Character.toString(sourceTypeName.charAt(0)),Character.toString(Character.toLowerCase(sourceTypeName.charAt(0)))));
  targetRewriter.set(parameter,SingleVariableDeclaration.NAME_PROPERTY,parameterName,null);
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  parametersRewrite.insertLast(parameter,null);
  this.additionalArgumentsAddedToMovedMethod.add(""String_Node_Str"");
  return parameterName;
}"
12274,"private void replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> methodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  for (  Expression invocation : methodInvocations) {
    if (invocation instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)invocation;
      List<Expression> arguments=methodInvocation.arguments();
      for (      Expression argument : arguments) {
        if (argument instanceof ThisExpression) {
          SimpleName parameterName=null;
          if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
            parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
          }
 else {
            AST ast=newMethodDeclaration.getAST();
            String sourceTypeName=sourceTypeDeclaration.getName().getIdentifier();
            parameterName=ast.newSimpleName(sourceTypeName.replace(sourceTypeName.charAt(0),Character.toLowerCase(sourceTypeName.charAt(0))));
          }
          ListRewrite argumentRewrite=targetRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
          argumentRewrite.replace(argument,parameterName,null);
        }
      }
    }
  }
}","private void replaceThisExpressionWithSourceClassParameterInMethodInvocationArguments(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> methodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  for (  Expression invocation : methodInvocations) {
    if (invocation instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)invocation;
      List<Expression> arguments=methodInvocation.arguments();
      for (      Expression argument : arguments) {
        if (argument instanceof ThisExpression) {
          SimpleName parameterName=null;
          if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
            parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
          }
 else {
            AST ast=newMethodDeclaration.getAST();
            String sourceTypeName=sourceTypeDeclaration.getName().getIdentifier();
            parameterName=ast.newSimpleName(sourceTypeName.replaceFirst(Character.toString(sourceTypeName.charAt(0)),Character.toString(Character.toLowerCase(sourceTypeName.charAt(0)))));
          }
          ListRewrite argumentRewrite=targetRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
          argumentRewrite.replace(argument,parameterName,null);
        }
      }
    }
  }
}"
12275,"private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
      targetClassVariableName=parameter.getName().getIdentifier();
      parametersRewrite.remove(newMethodParameters.get(i),null);
      break;
    }
    i++;
  }
  if (targetClassVariableName == null) {
    FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
          targetClassVariableName=fragment.getName().getIdentifier();
          break;
        }
      }
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration,targetClassVariableName);
    modifyTargetPublicFieldInstructions(newMethodDeclaration,targetClassVariableName);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  ListRewrite methodDeclarationRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertLast(newMethodDeclaration,null);
}","private void createMovedMethod(){
  AST ast=targetTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=(MethodDeclaration)ASTNode.copySubtree(ast,sourceMethod);
  ListRewrite modifierRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier publicModifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  boolean modifierFound=false;
  List<Modifier> modifiers=newMethodDeclaration.modifiers();
  for (  Modifier modifier : modifiers) {
    if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PUBLIC_KEYWORD)) {
      modifierFound=true;
    }
 else     if (modifier.getKeyword().equals(Modifier.ModifierKeyword.PRIVATE_KEYWORD) || modifier.getKeyword().equals(Modifier.ModifierKeyword.PROTECTED_KEYWORD)) {
      modifierFound=true;
      modifierRewrite.replace(modifier,publicModifier,null);
    }
  }
  if (!modifierFound) {
    modifierRewrite.insertFirst(publicModifier,null);
  }
  ListRewrite parametersRewrite=targetRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  List<SingleVariableDeclaration> sourceMethodParameters=sourceMethod.parameters();
  List<SingleVariableDeclaration> newMethodParameters=newMethodDeclaration.parameters();
  int i=0;
  for (  SingleVariableDeclaration parameter : sourceMethodParameters) {
    ITypeBinding parameterTypeBinding=parameter.getType().resolveBinding();
    if (parameterTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
      targetClassVariableName=parameter.getName().getIdentifier();
      parametersRewrite.remove(newMethodParameters.get(i),null);
      break;
    }
    i++;
  }
  if (targetClassVariableName == null) {
    FieldDeclaration[] fieldDeclarations=sourceTypeDeclaration.getFields();
    for (    FieldDeclaration fieldDeclaration : fieldDeclarations) {
      List<VariableDeclarationFragment> fragments=fieldDeclaration.fragments();
      for (      VariableDeclarationFragment fragment : fragments) {
        if (fieldDeclaration.getType().resolveBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
          targetClassVariableName=fragment.getName().getIdentifier();
          break;
        }
      }
    }
  }
  modifySourceMemberAccessesInTargetClass(newMethodDeclaration);
  if (targetClassVariableName != null) {
    modifyTargetMethodInvocations(newMethodDeclaration);
    modifyTargetPublicFieldInstructions(newMethodDeclaration);
  }
  modifySourceStaticFieldInstructionsInTargetClass(newMethodDeclaration);
  ListRewrite methodDeclarationRewrite=targetRewriter.getListRewrite(targetTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertLast(newMethodDeclaration,null);
}"
12276,"private void modifyTargetPublicFieldInstructions(MethodDeclaration newMethodDeclaration,String targetClassVariableName){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  FieldDeclaration[] fields=targetTypeDeclaration.getFields();
  for (  FieldDeclaration field : fields) {
    List<VariableDeclarationFragment> fragments=field.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      SimpleName fragmentName=fragment.getName();
      int i=0;
      for (      Expression expression : sourceFieldInstructions) {
        SimpleName simpleName=(SimpleName)expression;
        if (simpleName.getParent() instanceof QualifiedName && fragmentName.getIdentifier().equals(simpleName.getIdentifier())) {
          QualifiedName qualifiedName=(QualifiedName)simpleName.getParent();
          if (qualifiedName.getQualifier().resolveTypeBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName()) && targetClassVariableName.equals(qualifiedName.getQualifier().getFullyQualifiedName())) {
            SimpleName newSimpleName=(SimpleName)newFieldInstructions.get(i);
            targetRewriter.replace(newSimpleName.getParent(),simpleName,null);
          }
        }
        i++;
      }
    }
  }
}","private void modifyTargetPublicFieldInstructions(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  FieldDeclaration[] fields=targetTypeDeclaration.getFields();
  for (  FieldDeclaration field : fields) {
    List<VariableDeclarationFragment> fragments=field.fragments();
    for (    VariableDeclarationFragment fragment : fragments) {
      SimpleName fragmentName=fragment.getName();
      int i=0;
      for (      Expression expression : sourceFieldInstructions) {
        SimpleName simpleName=(SimpleName)expression;
        if (simpleName.getParent() instanceof QualifiedName && fragmentName.getIdentifier().equals(simpleName.getIdentifier())) {
          QualifiedName qualifiedName=(QualifiedName)simpleName.getParent();
          if (qualifiedName.getQualifier().resolveTypeBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName()) && qualifiedName.getQualifier().getFullyQualifiedName().equals(targetClassVariableName)) {
            SimpleName newSimpleName=(SimpleName)newFieldInstructions.get(i);
            targetRewriter.replace(newSimpleName.getParent(),simpleName,null);
          }
        }
 else         if (simpleName.getParent() instanceof FieldAccess && fragmentName.getIdentifier().equals(simpleName.getIdentifier())) {
          FieldAccess fieldAccess=(FieldAccess)simpleName.getParent();
          Expression fieldAccessExpression=fieldAccess.getExpression();
          if (fieldAccessExpression instanceof FieldAccess) {
            FieldAccess invokerFieldAccess=(FieldAccess)fieldAccessExpression;
            if (invokerFieldAccess.resolveTypeBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName()) && invokerFieldAccess.getName().getIdentifier().equals(targetClassVariableName) && invokerFieldAccess.getExpression() instanceof ThisExpression) {
              SimpleName newSimpleName=(SimpleName)newFieldInstructions.get(i);
              FieldAccess newFieldAccess=(FieldAccess)newSimpleName.getParent();
              targetRewriter.replace(newFieldAccess.getExpression(),newMethodDeclaration.getAST().newThisExpression(),null);
            }
          }
        }
        i++;
      }
    }
  }
}"
12277,"private void modifyTargetMethodInvocations(MethodDeclaration newMethodDeclaration,String targetClassVariableName){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      Expression methodInvocationExpression=methodInvocation.getExpression();
      if (methodInvocationExpression instanceof SimpleName) {
        SimpleName methodInvocationExpressionSimpleName=(SimpleName)methodInvocationExpression;
        if (methodInvocationExpressionSimpleName.resolveTypeBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName()) && targetClassVariableName.equals(methodInvocationExpressionSimpleName.getIdentifier())) {
          MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(i);
          targetRewriter.remove(newMethodInvocation.getExpression(),null);
        }
      }
    }
    i++;
  }
}","private void modifyTargetMethodInvocations(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      Expression methodInvocationExpression=methodInvocation.getExpression();
      if (methodInvocationExpression instanceof SimpleName) {
        SimpleName methodInvocationExpressionSimpleName=(SimpleName)methodInvocationExpression;
        if (methodInvocationExpressionSimpleName.resolveTypeBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName()) && methodInvocationExpressionSimpleName.getIdentifier().equals(targetClassVariableName)) {
          MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(i);
          targetRewriter.remove(newMethodInvocation.getExpression(),null);
        }
      }
 else       if (methodInvocationExpression instanceof FieldAccess) {
        FieldAccess methodInvocationExpressionFieldAccess=(FieldAccess)methodInvocationExpression;
        if (methodInvocationExpressionFieldAccess.getName().resolveTypeBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName()) && methodInvocationExpressionFieldAccess.getName().getIdentifier().equals(targetClassVariableName)) {
          MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(i);
          targetRewriter.remove(newMethodInvocation.getExpression(),null);
        }
      }
    }
    i++;
  }
}"
12278,"private void modifySourceMemberAccessesInTargetClass(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  List<Expression> expressionsToBeRemoved=new ArrayList<Expression>();
  int k=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      ITypeBinding methodInvocationDeclaringClassTypeBinding=methodInvocation.resolveMethodBinding().getDeclaringClass();
      if (methodInvocationDeclaringClassTypeBinding.getQualifiedName().equals(sourceTypeDeclaration.resolveBinding().getQualifiedName())) {
        MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
        for (        MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
          if (identicalSignature(sourceMethodDeclaration,methodInvocation)) {
            MethodInvocation delegation=isDelegate(sourceMethodDeclaration);
            if (delegation != null) {
              ITypeBinding delegationDeclaringClassTypeBinding=delegation.resolveMethodBinding().getDeclaringClass();
              if (delegationDeclaringClassTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
                if (delegation.getExpression() != null) {
                  MethodInvocation newMethodInvocation=(MethodInvocation)ASTNode.copySubtree(newMethodDeclaration.getAST(),delegation);
                  targetRewriter.remove(newMethodInvocation.getExpression(),null);
                  targetRewriter.replace(newMethodInvocations.get(k),newMethodInvocation,null);
                }
                expressionsToBeRemoved.add(methodInvocation);
              }
            }
          }
        }
      }
 else       if (methodInvocationDeclaringClassTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName()) && methodInvocation.getExpression() != null) {
        Expression methodInvocationExpression=methodInvocation.getExpression();
        if (methodInvocationExpression instanceof MethodInvocation) {
          MethodInvocation invoker=(MethodInvocation)methodInvocationExpression;
          MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
          for (          MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
            if (identicalSignature(sourceMethodDeclaration,invoker)) {
              SimpleName fieldInstruction=isGetter(sourceMethodDeclaration);
              if (fieldInstruction != null && fieldInstruction.resolveTypeBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
                int index=sourceMethodInvocations.indexOf(invoker);
                targetRewriter.remove(newMethodInvocations.get(index),null);
                expressionsToBeRemoved.add(invoker);
                expressionsToBeRemoved.add(methodInvocation);
              }
            }
          }
        }
      }
    }
    k++;
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceFieldInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && variableBinding.getDeclaringClass().equals(sourceTypeDeclaration.resolveBinding()) && (variableBinding.getModifiers() & Modifier.STATIC) == 0) {
        SimpleName expressionName=(SimpleName)newFieldInstructions.get(i);
        if (expressionName.getParent() instanceof FieldAccess) {
          if (expressionName.getIdentifier().equals(targetClassVariableName))           targetRewriter.remove(expressionName.getParent(),null);
 else           targetRewriter.replace(expressionName.getParent(),expressionName,null);
        }
 else {
          if (expressionName.getIdentifier().equals(targetClassVariableName))           targetRewriter.remove(expressionName,null);
        }
        if (!expressionName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))         addParameterToMovedMethod(newMethodDeclaration,expressionName);
      }
    }
    i++;
  }
  SimpleName parameterName=null;
  int j=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
      if (methodBinding.getDeclaringClass().equals(sourceTypeDeclaration.resolveBinding())) {
        MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
        for (        MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
          if (identicalSignature(sourceMethodDeclaration,methodInvocation)) {
            SimpleName fieldName=isGetter(sourceMethodDeclaration);
            MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(j);
            if (fieldName != null) {
              AST ast=newMethodDeclaration.getAST();
              targetRewriter.replace(newMethodInvocation,ast.newSimpleName(fieldName.getIdentifier()),null);
              if (!fieldName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(fieldName.getIdentifier()))               addParameterToMovedMethod(newMethodDeclaration,fieldName);
            }
 else {
              if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
                parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
              }
              targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
              setPublicModifierToSourceMethod(methodInvocation);
            }
          }
        }
      }
    }
    j++;
  }
}","private void modifySourceMemberAccessesInTargetClass(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  List<Expression> expressionsToBeRemoved=new ArrayList<Expression>();
  int k=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      ITypeBinding methodInvocationDeclaringClassTypeBinding=methodInvocation.resolveMethodBinding().getDeclaringClass();
      if (methodInvocationDeclaringClassTypeBinding.getQualifiedName().equals(sourceTypeDeclaration.resolveBinding().getQualifiedName())) {
        MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
        for (        MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
          if (identicalSignature(sourceMethodDeclaration,methodInvocation)) {
            MethodInvocation delegation=isDelegate(sourceMethodDeclaration);
            if (delegation != null) {
              ITypeBinding delegationDeclaringClassTypeBinding=delegation.resolveMethodBinding().getDeclaringClass();
              if (delegationDeclaringClassTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
                if (delegation.getExpression() != null) {
                  MethodInvocation newMethodInvocation=(MethodInvocation)ASTNode.copySubtree(newMethodDeclaration.getAST(),delegation);
                  targetRewriter.remove(newMethodInvocation.getExpression(),null);
                  targetRewriter.replace(newMethodInvocations.get(k),newMethodInvocation,null);
                }
                expressionsToBeRemoved.add(methodInvocation);
              }
            }
          }
        }
      }
 else       if (methodInvocationDeclaringClassTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName()) && methodInvocation.getExpression() != null) {
        Expression methodInvocationExpression=methodInvocation.getExpression();
        if (methodInvocationExpression instanceof MethodInvocation) {
          MethodInvocation invoker=(MethodInvocation)methodInvocationExpression;
          MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
          for (          MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
            if (identicalSignature(sourceMethodDeclaration,invoker)) {
              SimpleName fieldInstruction=isGetter(sourceMethodDeclaration);
              if (fieldInstruction != null && fieldInstruction.resolveTypeBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
                int index=sourceMethodInvocations.indexOf(invoker);
                targetRewriter.remove(newMethodInvocations.get(index),null);
                expressionsToBeRemoved.add(invoker);
                expressionsToBeRemoved.add(methodInvocation);
              }
            }
          }
        }
      }
    }
    k++;
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceFieldInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && variableBinding.getDeclaringClass().equals(sourceTypeDeclaration.resolveBinding()) && (variableBinding.getModifiers() & Modifier.STATIC) == 0) {
        SimpleName expressionName=(SimpleName)newFieldInstructions.get(i);
        if (expressionName.getParent() instanceof FieldAccess && !expressionName.getIdentifier().equals(targetClassVariableName)) {
          targetRewriter.replace(expressionName.getParent(),expressionName,null);
        }
        if (!expressionName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))         addParameterToMovedMethod(newMethodDeclaration,expressionName);
      }
    }
    i++;
  }
  SimpleName parameterName=null;
  int j=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
      if (methodBinding.getDeclaringClass().equals(sourceTypeDeclaration.resolveBinding())) {
        MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
        for (        MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
          if (identicalSignature(sourceMethodDeclaration,methodInvocation)) {
            SimpleName fieldName=isGetter(sourceMethodDeclaration);
            MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(j);
            if (fieldName != null) {
              AST ast=newMethodDeclaration.getAST();
              targetRewriter.replace(newMethodInvocation,ast.newSimpleName(fieldName.getIdentifier()),null);
              if (!fieldName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(fieldName.getIdentifier()))               addParameterToMovedMethod(newMethodDeclaration,fieldName);
            }
 else {
              if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
                parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
              }
              targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
              setPublicModifierToSourceMethod(methodInvocation);
            }
          }
        }
      }
    }
    j++;
  }
}"
12279,"public void setDistinctExtractedMethodName(){
  String sourceMethodName=sourceMethod.getMethodName();
  extractionBlock.setExtractedMethodName(extractionBlock.getReturnVariableDeclaration().getName() + sourceMethodName.replaceFirst(Character.toString(sourceMethodName.charAt(0)),Character.toString(Character.toUpperCase(sourceMethodName.charAt(0)))));
  System.out.println(""String_Node_Str"");
}","public void setDistinctExtractedMethodName(){
  String sourceMethodName=sourceMethod.getMethodName();
  extractionBlock.setExtractedMethodName(extractionBlock.getReturnVariableDeclaration().getName() + sourceMethodName.replaceFirst(Character.toString(sourceMethodName.charAt(0)),Character.toString(Character.toUpperCase(sourceMethodName.charAt(0)))));
}"
12280,"public void apply(){
  addRequiredTargetImportDeclarations();
  createMovedMethod();
  moveAdditionalMethods();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer targetTextFileBuffer=bufferManager.getTextFileBuffer(targetFile.getFullPath(),LocationKind.IFILE);
  IDocument targetDocument=targetTextFileBuffer.getDocument();
  TextEdit targetEdit=targetRewriter.rewriteAST(targetDocument,null);
  try {
    UndoEdit undoEdit=targetEdit.apply(targetDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(targetFile,targetDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  if (leaveDelegate) {
    addDelegationInSourceMethod();
  }
 else {
    removeSourceMethod();
  }
  modifyMovedMethodInvocationInSourceClass();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit undoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","public void apply(){
  addRequiredTargetImportDeclarations();
  createMovedMethod();
  moveAdditionalMethods();
  modifyMovedMethodInvocationInTargetClass();
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer targetTextFileBuffer=bufferManager.getTextFileBuffer(targetFile.getFullPath(),LocationKind.IFILE);
  IDocument targetDocument=targetTextFileBuffer.getDocument();
  TextEdit targetEdit=targetRewriter.rewriteAST(targetDocument,null);
  try {
    UndoEdit undoEdit=targetEdit.apply(targetDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(targetFile,targetDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
  if (leaveDelegate) {
    addDelegationInSourceMethod();
  }
 else {
    removeSourceMethod();
  }
  modifyMovedMethodInvocationInSourceClass();
  ITextFileBuffer sourceTextFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument sourceDocument=sourceTextFileBuffer.getDocument();
  TextEdit sourceEdit=sourceRewriter.rewriteAST(sourceDocument,null);
  try {
    UndoEdit undoEdit=sourceEdit.apply(sourceDocument,UndoEdit.CREATE_UNDO);
    undoRefactoring.put(sourceFile,sourceDocument,undoEdit);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12281,"private void modifySourceMemberAccessesInTargetClass(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  List<Expression> expressionsToBeRemoved=new ArrayList<Expression>();
  for (  MethodInvocation methodInvocation : additionalMethodsToBeMoved.keySet()) {
    for (    Expression expression : sourceMethodInvocations) {
      if (expression instanceof MethodInvocation) {
        MethodInvocation sourceMethodInvocation=(MethodInvocation)expression;
        if (methodInvocation.equals(sourceMethodInvocation)) {
          expressionsToBeRemoved.add(methodInvocation);
        }
      }
    }
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  expressionsToBeRemoved.clear();
  int k=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      ITypeBinding methodInvocationDeclaringClassTypeBinding=methodInvocation.resolveMethodBinding().getDeclaringClass();
      if (methodInvocationDeclaringClassTypeBinding.getQualifiedName().equals(sourceTypeDeclaration.resolveBinding().getQualifiedName()) && (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression)) {
        MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
        for (        MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
          if (identicalSignature(sourceMethodDeclaration,methodInvocation)) {
            MethodInvocation delegation=isDelegate(sourceMethodDeclaration);
            if (delegation != null) {
              ITypeBinding delegationDeclaringClassTypeBinding=delegation.resolveMethodBinding().getDeclaringClass();
              if (delegationDeclaringClassTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
                if (delegation.getExpression() != null) {
                  MethodInvocation newMethodInvocation=(MethodInvocation)ASTNode.copySubtree(newMethodDeclaration.getAST(),delegation);
                  targetRewriter.remove(newMethodInvocation.getExpression(),null);
                  targetRewriter.replace(newMethodInvocations.get(k),newMethodInvocation,null);
                }
                expressionsToBeRemoved.add(methodInvocation);
              }
            }
          }
        }
      }
 else       if (methodInvocationDeclaringClassTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName()) && methodInvocation.getExpression() != null) {
        Expression methodInvocationExpression=methodInvocation.getExpression();
        if (methodInvocationExpression instanceof MethodInvocation) {
          MethodInvocation invoker=(MethodInvocation)methodInvocationExpression;
          if (invoker.getExpression() == null || invoker.getExpression() instanceof ThisExpression) {
            MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
            for (            MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
              if (identicalSignature(sourceMethodDeclaration,invoker)) {
                SimpleName fieldInstruction=isGetter(sourceMethodDeclaration);
                if (fieldInstruction != null && fieldInstruction.resolveTypeBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
                  int index=sourceMethodInvocations.indexOf(invoker);
                  targetRewriter.remove(newMethodInvocations.get(index),null);
                  expressionsToBeRemoved.add(invoker);
                  expressionsToBeRemoved.add(methodInvocation);
                }
              }
            }
          }
        }
      }
    }
    k++;
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceFieldInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && variableBinding.getDeclaringClass().equals(sourceTypeDeclaration.resolveBinding()) && (variableBinding.getModifiers() & Modifier.STATIC) == 0) {
        SimpleName expressionName=(SimpleName)newFieldInstructions.get(i);
        if (expressionName.getParent() instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)expressionName.getParent();
          if (fieldAccess.getExpression() instanceof ThisExpression && !expressionName.getIdentifier().equals(targetClassVariableName)) {
            targetRewriter.replace(expressionName.getParent(),expressionName,null);
            if (!additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))             addParameterToMovedMethod(newMethodDeclaration,expressionName);
          }
        }
 else         if (!expressionName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))         addParameterToMovedMethod(newMethodDeclaration,expressionName);
      }
    }
    i++;
  }
  SimpleName parameterName=null;
  int j=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      if (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression) {
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        if (methodBinding.getDeclaringClass().equals(sourceTypeDeclaration.resolveBinding())) {
          MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
          for (          MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
            if (identicalSignature(sourceMethodDeclaration,methodInvocation)) {
              SimpleName fieldName=isGetter(sourceMethodDeclaration);
              MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(j);
              if (fieldName != null) {
                AST ast=newMethodDeclaration.getAST();
                targetRewriter.replace(newMethodInvocation,ast.newSimpleName(fieldName.getIdentifier()),null);
                if (!fieldName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(fieldName.getIdentifier()))                 addParameterToMovedMethod(newMethodDeclaration,fieldName);
              }
 else {
                if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
                  parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
                }
                targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
                setPublicModifierToSourceMethod(methodInvocation);
              }
            }
          }
        }
      }
    }
    j++;
  }
}","private void modifySourceMemberAccessesInTargetClass(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  List<Expression> expressionsToBeRemoved=new ArrayList<Expression>();
  for (  MethodInvocation methodInvocation : additionalMethodsToBeMoved.keySet()) {
    for (    Expression expression : sourceMethodInvocations) {
      if (expression instanceof MethodInvocation) {
        MethodInvocation sourceMethodInvocation=(MethodInvocation)expression;
        if (methodInvocation.equals(sourceMethodInvocation)) {
          expressionsToBeRemoved.add(methodInvocation);
        }
      }
    }
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  expressionsToBeRemoved.clear();
  int k=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      ITypeBinding methodInvocationDeclaringClassTypeBinding=methodInvocation.resolveMethodBinding().getDeclaringClass();
      if (methodInvocationDeclaringClassTypeBinding.getQualifiedName().equals(sourceTypeDeclaration.resolveBinding().getQualifiedName()) && (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression)) {
        MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
        for (        MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
          if (identicalSignature(sourceMethodDeclaration,methodInvocation)) {
            MethodInvocation delegation=isDelegate(sourceMethodDeclaration);
            if (delegation != null) {
              ITypeBinding delegationDeclaringClassTypeBinding=delegation.resolveMethodBinding().getDeclaringClass();
              if (delegationDeclaringClassTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
                if (delegation.getExpression() != null) {
                  MethodInvocation newMethodInvocation=(MethodInvocation)ASTNode.copySubtree(newMethodDeclaration.getAST(),delegation);
                  targetRewriter.remove(newMethodInvocation.getExpression(),null);
                  targetRewriter.replace(newMethodInvocations.get(k),newMethodInvocation,null);
                }
                expressionsToBeRemoved.add(methodInvocation);
              }
            }
          }
        }
      }
 else       if (methodInvocationDeclaringClassTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName()) && methodInvocation.getExpression() != null) {
        Expression methodInvocationExpression=methodInvocation.getExpression();
        if (methodInvocationExpression instanceof MethodInvocation) {
          MethodInvocation invoker=(MethodInvocation)methodInvocationExpression;
          if (invoker.getExpression() == null || invoker.getExpression() instanceof ThisExpression) {
            MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
            for (            MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
              if (identicalSignature(sourceMethodDeclaration,invoker)) {
                SimpleName fieldInstruction=isGetter(sourceMethodDeclaration);
                if (fieldInstruction != null && fieldInstruction.resolveTypeBinding().getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
                  int index=sourceMethodInvocations.indexOf(invoker);
                  targetRewriter.remove(newMethodInvocations.get(index),null);
                  expressionsToBeRemoved.add(invoker);
                  expressionsToBeRemoved.add(methodInvocation);
                }
              }
            }
          }
        }
      }
    }
    k++;
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  int i=0;
  for (  Expression expression : sourceFieldInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && sourceTypeDeclaration.resolveBinding().equals(variableBinding.getDeclaringClass()) && (variableBinding.getModifiers() & Modifier.STATIC) == 0) {
        SimpleName expressionName=(SimpleName)newFieldInstructions.get(i);
        if (expressionName.getParent() instanceof FieldAccess) {
          FieldAccess fieldAccess=(FieldAccess)expressionName.getParent();
          if (fieldAccess.getExpression() instanceof ThisExpression && !expressionName.getIdentifier().equals(targetClassVariableName)) {
            targetRewriter.replace(expressionName.getParent(),expressionName,null);
            if (!additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))             addParameterToMovedMethod(newMethodDeclaration,expressionName);
          }
        }
 else         if (!expressionName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(expressionName.getIdentifier()))         addParameterToMovedMethod(newMethodDeclaration,expressionName);
      }
    }
    i++;
  }
  SimpleName parameterName=null;
  int j=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      if (methodInvocation.getExpression() == null || methodInvocation.getExpression() instanceof ThisExpression) {
        IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
        if (methodBinding.getDeclaringClass().equals(sourceTypeDeclaration.resolveBinding())) {
          MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
          for (          MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
            if (identicalSignature(sourceMethodDeclaration,methodInvocation)) {
              SimpleName fieldName=isGetter(sourceMethodDeclaration);
              MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(j);
              if (fieldName != null) {
                AST ast=newMethodDeclaration.getAST();
                targetRewriter.replace(newMethodInvocation,ast.newSimpleName(fieldName.getIdentifier()),null);
                if (!fieldName.getIdentifier().equals(targetClassVariableName) && !additionalArgumentsAddedToMovedMethod.contains(fieldName.getIdentifier()))                 addParameterToMovedMethod(newMethodDeclaration,fieldName);
              }
 else {
                if (!additionalArgumentsAddedToMovedMethod.contains(""String_Node_Str"")) {
                  parameterName=addSourceClassParameterToMovedMethod(newMethodDeclaration);
                }
                targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
                setPublicModifierToSourceMethod(methodInvocation);
              }
            }
          }
        }
      }
    }
    j++;
  }
}"
12282,"public List<ExtractAndMoveMethodCandidateRefactoring> getExtractAndMoveMethodCandidateRefactorings(){
  List<ExtractAndMoveMethodCandidateRefactoring> extractMethodCandidateRefactoringList=new ArrayList<ExtractAndMoveMethodCandidateRefactoring>();
  Map<String,ArrayList<ExtractAndMoveMethodCandidateRefactoring>> extractedMethodNameMap=new LinkedHashMap<String,ArrayList<ExtractAndMoveMethodCandidateRefactoring>>();
  Iterator<MyClass> classIt=system.getClassIterator();
  while (classIt.hasNext()) {
    MyClass myClass=classIt.next();
    ListIterator<MyMethod> methodIterator=myClass.getMethodIterator();
    while (methodIterator.hasNext()) {
      MyMethod method=methodIterator.next();
      if (method.getMethodObject().getMethodBody() != null) {
        List<ExtractionBlock> extractionBlockList=method.getMethodObject().getMethodBody().generateExtractionBlocks();
        for (        ExtractionBlock block : extractionBlockList) {
          ExtractAndMoveMethodCandidateRefactoring candidate=new ExtractAndMoveMethodCandidateRefactoring(system,myClass,myClass,method,block);
          extractMethodCandidateRefactoringList.add(candidate);
          if (!extractedMethodNameMap.containsKey(block.getExtractedMethodName())) {
            ArrayList<ExtractAndMoveMethodCandidateRefactoring> list=new ArrayList<ExtractAndMoveMethodCandidateRefactoring>();
            list.add(candidate);
            extractedMethodNameMap.put(block.getExtractedMethodName(),list);
          }
 else {
            ArrayList<ExtractAndMoveMethodCandidateRefactoring> list=extractedMethodNameMap.get(block.getExtractedMethodName());
            list.add(candidate);
          }
        }
      }
    }
  }
  for (  String extractedMethodName : extractedMethodNameMap.keySet()) {
    List<ExtractAndMoveMethodCandidateRefactoring> list=extractedMethodNameMap.get(extractedMethodName);
    if (list.size() > 1) {
      for (      ExtractAndMoveMethodCandidateRefactoring candidate : list) {
        candidate.setDistinctExtractedMethodName();
      }
    }
  }
  Double[][] blockDistanceMatrix=new Double[extractMethodCandidateRefactoringList.size()][classList.size()];
  for (int i=0; i < extractMethodCandidateRefactoringList.size(); i++) {
    ExtractAndMoveMethodCandidateRefactoring candidate=extractMethodCandidateRefactoringList.get(i);
    for (int j=0; j < classList.size(); j++) {
      blockDistanceMatrix[i][j]=DistanceCalculator.getDistance(candidate.getEntitySet(),classMap.get(classNames[j]));
    }
  }
  List<ExtractAndMoveMethodCandidateRefactoring> candidateRefactoringList=new ArrayList<ExtractAndMoveMethodCandidateRefactoring>();
  ;
  Map<Integer,Double> minValueMap=new LinkedHashMap<Integer,Double>();
  for (int i=0; i < blockDistanceMatrix.length; i++) {
    double minValue=1;
    for (int j=0; j < blockDistanceMatrix[i].length; j++) {
      if (blockDistanceMatrix[i][j] < minValue) {
        minValue=blockDistanceMatrix[i][j];
      }
    }
    minValueMap.put(i,minValue);
  }
  for (  Integer i : minValueMap.keySet()) {
    double minValue=minValueMap.get(i);
    ExtractAndMoveMethodCandidateRefactoring candidate=extractMethodCandidateRefactoringList.get(i);
    String rowClass=candidate.getSourceClass().getName();
    if (minValue != 1) {
      for (int j=0; j < blockDistanceMatrix[i].length; j++) {
        if (blockDistanceMatrix[i][j] == minValue) {
          if (!rowClass.equals(classNames[j])) {
            MyClass targetClass=classList.get(j);
            ExtractAndMoveMethodCandidateRefactoring newCandidate=new ExtractAndMoveMethodCandidateRefactoring(system,candidate.getSourceClass(),targetClass,candidate.getSourceMethod(),candidate.getExtractionBlock());
            boolean applicable=newCandidate.apply();
            if (applicable)             candidateRefactoringList.add(newCandidate);
          }
        }
      }
    }
  }
  return candidateRefactoringList;
}","public List<ExtractAndMoveMethodCandidateRefactoring> getExtractAndMoveMethodCandidateRefactorings(){
  List<ExtractAndMoveMethodCandidateRefactoring> extractMethodCandidateRefactoringList=new ArrayList<ExtractAndMoveMethodCandidateRefactoring>();
  Iterator<MyClass> classIt=system.getClassIterator();
  while (classIt.hasNext()) {
    MyClass myClass=classIt.next();
    ListIterator<MyMethod> methodIterator=myClass.getMethodIterator();
    while (methodIterator.hasNext()) {
      MyMethod method=methodIterator.next();
      if (method.getMethodObject().getMethodBody() != null) {
        List<ExtractionBlock> extractionBlockList=method.getMethodObject().getMethodBody().generateExtractionBlocks();
        for (        ExtractionBlock block : extractionBlockList) {
          ExtractAndMoveMethodCandidateRefactoring candidate=new ExtractAndMoveMethodCandidateRefactoring(system,myClass,myClass,method,block);
          extractMethodCandidateRefactoringList.add(candidate);
        }
      }
    }
  }
  Double[][] blockDistanceMatrix=new Double[extractMethodCandidateRefactoringList.size()][classList.size()];
  for (int i=0; i < extractMethodCandidateRefactoringList.size(); i++) {
    ExtractAndMoveMethodCandidateRefactoring candidate=extractMethodCandidateRefactoringList.get(i);
    for (int j=0; j < classList.size(); j++) {
      blockDistanceMatrix[i][j]=DistanceCalculator.getDistance(candidate.getEntitySet(),classMap.get(classNames[j]));
    }
  }
  List<ExtractAndMoveMethodCandidateRefactoring> candidateRefactoringList=new ArrayList<ExtractAndMoveMethodCandidateRefactoring>();
  ;
  Map<Integer,Double> minValueMap=new LinkedHashMap<Integer,Double>();
  for (int i=0; i < blockDistanceMatrix.length; i++) {
    double minValue=1;
    for (int j=0; j < blockDistanceMatrix[i].length; j++) {
      if (blockDistanceMatrix[i][j] < minValue) {
        minValue=blockDistanceMatrix[i][j];
      }
    }
    minValueMap.put(i,minValue);
  }
  Map<String,ArrayList<ExtractAndMoveMethodCandidateRefactoring>> extractedMethodNameMap=new LinkedHashMap<String,ArrayList<ExtractAndMoveMethodCandidateRefactoring>>();
  for (  Integer i : minValueMap.keySet()) {
    double minValue=minValueMap.get(i);
    ExtractAndMoveMethodCandidateRefactoring candidate=extractMethodCandidateRefactoringList.get(i);
    String rowClass=candidate.getSourceClass().getName();
    if (minValue != 1) {
      for (int j=0; j < blockDistanceMatrix[i].length; j++) {
        if (blockDistanceMatrix[i][j] == minValue) {
          if (!rowClass.equals(classNames[j])) {
            MyClass targetClass=classList.get(j);
            ExtractAndMoveMethodCandidateRefactoring newCandidate=new ExtractAndMoveMethodCandidateRefactoring(system,candidate.getSourceClass(),targetClass,candidate.getSourceMethod(),candidate.getExtractionBlock());
            boolean applicable=newCandidate.apply();
            if (applicable) {
              candidateRefactoringList.add(newCandidate);
              if (!extractedMethodNameMap.containsKey(newCandidate.getExtractionBlock().getExtractedMethodName() + targetClass.getName())) {
                ArrayList<ExtractAndMoveMethodCandidateRefactoring> list=new ArrayList<ExtractAndMoveMethodCandidateRefactoring>();
                list.add(newCandidate);
                extractedMethodNameMap.put(newCandidate.getExtractionBlock().getExtractedMethodName() + targetClass.getName(),list);
              }
 else {
                ArrayList<ExtractAndMoveMethodCandidateRefactoring> list=extractedMethodNameMap.get(newCandidate.getExtractionBlock().getExtractedMethodName() + targetClass.getName());
                list.add(newCandidate);
              }
            }
          }
        }
      }
    }
  }
  for (  String extractedMethodName : extractedMethodNameMap.keySet()) {
    List<ExtractAndMoveMethodCandidateRefactoring> list=extractedMethodNameMap.get(extractedMethodName);
    if (list.size() > 1) {
      for (      ExtractAndMoveMethodCandidateRefactoring candidate : list) {
        candidate.setDistinctExtractedMethodName();
      }
    }
  }
  return candidateRefactoringList;
}"
12283,"private void modifySourceMemberAccessesInTargetClass(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  List<Expression> expressionsToBeRemoved=new ArrayList<Expression>();
  int k=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
      for (      MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
        if (identicalSignature(sourceMethodDeclaration,methodInvocation)) {
          MethodInvocation delegation=isDelegate(sourceMethodDeclaration);
          if (delegation != null) {
            ITypeBinding declaringClassTypeBinding=delegation.resolveMethodBinding().getDeclaringClass();
            if (declaringClassTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
              if (delegation.getExpression() != null) {
                MethodInvocation newMethodInvocation=(MethodInvocation)ASTNode.copySubtree(newMethodDeclaration.getAST(),delegation);
                targetRewriter.remove(newMethodInvocation.getExpression(),null);
                targetRewriter.replace(newMethodInvocations.get(k),newMethodInvocation,null);
              }
              expressionsToBeRemoved.add(methodInvocation);
            }
          }
        }
      }
    }
    k++;
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  SimpleName parameterName=null;
  int numberOfOccurences=0;
  int i=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
      if (methodBinding.getDeclaringClass().equals(sourceTypeDeclaration.resolveBinding())) {
        numberOfOccurences++;
        if (numberOfOccurences == 1) {
          parameterName=addSourceClassParameter(newMethodDeclaration);
        }
        MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(i);
        targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
      }
    }
    i++;
  }
  int j=0;
  for (  Expression expression : sourceFieldInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && variableBinding.getDeclaringClass().equals(sourceTypeDeclaration.resolveBinding()) && (variableBinding.getModifiers() & Modifier.STATIC) == 0) {
        numberOfOccurences++;
        if (numberOfOccurences == 1) {
          parameterName=addSourceClassParameter(newMethodDeclaration);
        }
        SimpleName expressionName=(SimpleName)newFieldInstructions.get(j);
        AST ast=newMethodDeclaration.getAST();
        if (expressionName.getParent() instanceof FieldAccess) {
          SimpleName qualifier=ast.newSimpleName(parameterName.getIdentifier());
          targetRewriter.set(expressionName.getParent(),FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
        }
 else {
          SimpleName newSimpleName=ast.newSimpleName(expressionName.getIdentifier());
          SimpleName qualifier=ast.newSimpleName(parameterName.getIdentifier());
          QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
          targetRewriter.replace(expressionName,newQualifiedName,null);
        }
      }
    }
    j++;
  }
}","private void modifySourceMemberAccessesInTargetClass(MethodDeclaration newMethodDeclaration){
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<Expression> sourceMethodInvocations=extractor.getMethodInvocations(sourceMethod.getBody());
  List<Expression> newMethodInvocations=extractor.getMethodInvocations(newMethodDeclaration.getBody());
  List<Expression> expressionsToBeRemoved=new ArrayList<Expression>();
  int k=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      MethodDeclaration[] sourceMethodDeclarations=sourceTypeDeclaration.getMethods();
      for (      MethodDeclaration sourceMethodDeclaration : sourceMethodDeclarations) {
        if (identicalSignature(sourceMethodDeclaration,methodInvocation)) {
          MethodInvocation delegation=isDelegate(sourceMethodDeclaration);
          if (delegation != null) {
            ITypeBinding declaringClassTypeBinding=delegation.resolveMethodBinding().getDeclaringClass();
            if (declaringClassTypeBinding.getQualifiedName().equals(targetTypeDeclaration.resolveBinding().getQualifiedName())) {
              if (delegation.getExpression() != null) {
                MethodInvocation newMethodInvocation=(MethodInvocation)ASTNode.copySubtree(newMethodDeclaration.getAST(),delegation);
                targetRewriter.remove(newMethodInvocation.getExpression(),null);
                targetRewriter.replace(newMethodInvocations.get(k),newMethodInvocation,null);
              }
              expressionsToBeRemoved.add(methodInvocation);
            }
          }
        }
      }
    }
    k++;
  }
  for (  Expression expression : expressionsToBeRemoved) {
    int index=sourceMethodInvocations.indexOf(expression);
    sourceMethodInvocations.remove(index);
    newMethodInvocations.remove(index);
  }
  List<Expression> sourceFieldInstructions=extractor.getVariableInstructions(sourceMethod.getBody());
  List<Expression> newFieldInstructions=extractor.getVariableInstructions(newMethodDeclaration.getBody());
  SimpleName parameterName=null;
  int numberOfOccurences=0;
  int i=0;
  for (  Expression expression : sourceMethodInvocations) {
    if (expression instanceof MethodInvocation) {
      MethodInvocation methodInvocation=(MethodInvocation)expression;
      IMethodBinding methodBinding=methodInvocation.resolveMethodBinding();
      if (methodBinding.getDeclaringClass().equals(sourceTypeDeclaration.resolveBinding())) {
        numberOfOccurences++;
        if (numberOfOccurences == 1) {
          parameterName=addSourceClassParameter(newMethodDeclaration);
        }
        MethodInvocation newMethodInvocation=(MethodInvocation)newMethodInvocations.get(i);
        targetRewriter.set(newMethodInvocation,MethodInvocation.EXPRESSION_PROPERTY,parameterName,null);
      }
    }
    i++;
  }
  int j=0;
  for (  Expression expression : sourceFieldInstructions) {
    SimpleName simpleName=(SimpleName)expression;
    IBinding binding=simpleName.resolveBinding();
    if (binding.getKind() == IBinding.VARIABLE) {
      IVariableBinding variableBinding=(IVariableBinding)binding;
      if (variableBinding.isField() && variableBinding.getDeclaringClass().equals(sourceTypeDeclaration.resolveBinding()) && (variableBinding.getModifiers() & Modifier.STATIC) == 0 && !targetClassVariableNames.contains(simpleName.getIdentifier())) {
        numberOfOccurences++;
        if (numberOfOccurences == 1) {
          parameterName=addSourceClassParameter(newMethodDeclaration);
        }
        SimpleName expressionName=(SimpleName)newFieldInstructions.get(j);
        AST ast=newMethodDeclaration.getAST();
        if (expressionName.getParent() instanceof FieldAccess) {
          SimpleName qualifier=ast.newSimpleName(parameterName.getIdentifier());
          targetRewriter.set(expressionName.getParent(),FieldAccess.EXPRESSION_PROPERTY,qualifier,null);
        }
 else {
          SimpleName newSimpleName=ast.newSimpleName(expressionName.getIdentifier());
          SimpleName qualifier=ast.newSimpleName(parameterName.getIdentifier());
          QualifiedName newQualifiedName=ast.newQualifiedName(qualifier,newSimpleName);
          targetRewriter.replace(expressionName,newQualifiedName,null);
        }
      }
    }
    j++;
  }
}"
12284,"public ExtractMethodRefactoring(IFile sourceFile,TypeDeclaration sourceTypeDeclaration,MethodDeclaration sourceMethodDeclaration,VariableDeclarationStatement variableDeclarationStatement,VariableDeclarationFragment variableDeclarationFragment,List<Statement> extractStatementList,List<VariableDeclarationStatement> variableDeclarationStatementList){
  this.sourceFile=sourceFile;
  this.sourceTypeDeclaration=sourceTypeDeclaration;
  this.sourceMethodDeclaration=sourceMethodDeclaration;
  this.variableDeclarationStatement=variableDeclarationStatement;
  this.variableDeclarationFragment=variableDeclarationFragment;
  this.extractStatementList=extractStatementList;
  this.variableDeclarationStatementList=variableDeclarationStatementList;
}","public ExtractMethodRefactoring(IFile sourceFile,TypeDeclaration sourceTypeDeclaration,MethodDeclaration sourceMethodDeclaration,VariableDeclarationStatement variableDeclarationStatement,VariableDeclarationFragment variableDeclarationFragment,List<Statement> extractStatementList,List<VariableDeclarationStatement> variableDeclarationStatementList){
  this.sourceFile=sourceFile;
  this.sourceTypeDeclaration=sourceTypeDeclaration;
  this.sourceMethodDeclaration=sourceMethodDeclaration;
  this.variableDeclarationStatement=variableDeclarationStatement;
  this.variableDeclarationFragment=variableDeclarationFragment;
  this.extractStatementList=extractStatementList;
  this.variableDeclarationStatementList=variableDeclarationStatementList;
  this.sourceRewriter=ASTRewrite.create(sourceTypeDeclaration.getAST());
}"
12285,"private void replaceExtractedCodeWithMethodInvocation(ASTRewrite rewriter){
  ASTNode parent=extractStatementList.get(0).getParent();
  Assignment assignment=parent.getAST().newAssignment();
  rewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,variableDeclarationFragment.getName(),null);
  if (variableDeclarationStatement.getType().isPrimitiveType() && parent != variableDeclarationStatement.getParent() && isLoop(parent))   rewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.PLUS_ASSIGN,null);
 else   rewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
  MethodInvocation methodInvocation=assignment.getAST().newMethodInvocation();
  rewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
  ListRewrite argumentRewrite=rewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  VariableDeclarationStatement statement : variableDeclarationStatementList) {
    List<VariableDeclarationFragment> fragmentList=statement.fragments();
    for (    VariableDeclarationFragment fragment : fragmentList) {
      if (!fragment.getName().getIdentifier().equals(variableDeclarationFragment.getName().getIdentifier()))       argumentRewrite.insertLast(fragment.getName(),null);
    }
  }
  rewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,methodInvocation,null);
  ExpressionStatement expressionStatement=parent.getAST().newExpressionStatement(assignment);
  for (int i=0; i < extractStatementList.size(); i++) {
    Statement statement=extractStatementList.get(i);
    ListRewrite bodyRewrite=rewriter.getListRewrite(statement.getParent(),Block.STATEMENTS_PROPERTY);
    if (i == extractStatementList.size() - 1)     bodyRewrite.replace(statement,expressionStatement,null);
 else     bodyRewrite.remove(statement,null);
  }
}","private void replaceExtractedCodeWithMethodInvocation(List<SimpleName> extractedMethodArguments){
  ASTNode parent=extractStatementList.get(0).getParent();
  Assignment assignment=parent.getAST().newAssignment();
  sourceRewriter.set(assignment,Assignment.LEFT_HAND_SIDE_PROPERTY,variableDeclarationFragment.getName(),null);
  if (variableDeclarationStatement.getType().isPrimitiveType() && parent != variableDeclarationStatement.getParent() && isLoop(parent))   sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.PLUS_ASSIGN,null);
 else   sourceRewriter.set(assignment,Assignment.OPERATOR_PROPERTY,Assignment.Operator.ASSIGN,null);
  MethodInvocation methodInvocation=assignment.getAST().newMethodInvocation();
  sourceRewriter.set(methodInvocation,MethodInvocation.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
  ListRewrite argumentRewrite=sourceRewriter.getListRewrite(methodInvocation,MethodInvocation.ARGUMENTS_PROPERTY);
  for (  SimpleName argument : extractedMethodArguments) {
    argumentRewrite.insertLast(argument,null);
  }
  sourceRewriter.set(assignment,Assignment.RIGHT_HAND_SIDE_PROPERTY,methodInvocation,null);
  ExpressionStatement expressionStatement=parent.getAST().newExpressionStatement(assignment);
  for (int i=0; i < extractStatementList.size(); i++) {
    Statement statement=extractStatementList.get(i);
    ListRewrite bodyRewrite=sourceRewriter.getListRewrite(statement.getParent(),Block.STATEMENTS_PROPERTY);
    if (i == extractStatementList.size() - 1)     bodyRewrite.replace(statement,expressionStatement,null);
 else     bodyRewrite.remove(statement,null);
  }
}"
12286,"public void extractMethod(){
  AST ast=sourceTypeDeclaration.getAST();
  ASTRewrite rewriter=ASTRewrite.create(ast);
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  SimpleName returnVariableSimpleName=variableDeclarationFragment.getName();
  rewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,returnVariableSimpleName,null);
  rewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,variableDeclarationStatement.getType(),null);
  ListRewrite modifierRewrite=rewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier modifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  modifierRewrite.insertLast(modifier,null);
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<SimpleName> discreteLocalVariableInstructions=new ArrayList<SimpleName>();
  List<String> discreteLocalVariableInstructionIdentifiers=new ArrayList<String>();
  for (  Statement statement : extractStatementList) {
    List<Expression> list=extractor.getVariableInstructions(statement);
    for (    Expression expression : list) {
      SimpleName simpleName=(SimpleName)expression;
      IBinding binding=simpleName.resolveBinding();
      if (binding.getKind() == IBinding.VARIABLE) {
        IVariableBinding variableBinding=(IVariableBinding)binding;
        if (!variableBinding.isField() && !simpleName.isDeclaration()) {
          if (!discreteLocalVariableInstructionIdentifiers.contains(simpleName.getIdentifier())) {
            discreteLocalVariableInstructionIdentifiers.add(simpleName.getIdentifier());
            discreteLocalVariableInstructions.add(simpleName);
          }
        }
      }
    }
  }
  ListRewrite paramRewrite=rewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SimpleName instruction : discreteLocalVariableInstructions) {
    if (!returnVariableSimpleName.getIdentifier().equals(instruction.getIdentifier())) {
      Type paramVariableDeclarationType=null;
      for (      VariableDeclarationStatement statement : variableDeclarationStatementList) {
        List<VariableDeclarationFragment> fragmentList=statement.fragments();
        for (        VariableDeclarationFragment fragment : fragmentList) {
          if (fragment.getName().getIdentifier().equals(instruction.getIdentifier()))           paramVariableDeclarationType=statement.getType();
        }
      }
      if (paramVariableDeclarationType != null) {
        SingleVariableDeclaration newParam=newMethodDeclaration.getAST().newSingleVariableDeclaration();
        rewriter.set(newParam,SingleVariableDeclaration.NAME_PROPERTY,instruction,null);
        rewriter.set(newParam,SingleVariableDeclaration.TYPE_PROPERTY,paramVariableDeclarationType,null);
        paramRewrite.insertLast(newParam,null);
      }
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite bodyRewrite=rewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  VariableDeclarationFragment localVariableDeclarationFragment=newMethodBody.getAST().newVariableDeclarationFragment();
  rewriter.set(localVariableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
  rewriter.set(localVariableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,variableDeclarationFragment.getInitializer(),null);
  VariableDeclarationStatement localVariableDeclarationStatement=newMethodBody.getAST().newVariableDeclarationStatement(localVariableDeclarationFragment);
  rewriter.set(localVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
  bodyRewrite.insertLast(localVariableDeclarationStatement,null);
  for (  Statement statement : extractStatementList) {
    bodyRewrite.insertLast(statement,null);
  }
  ReturnStatement returnStatement=newMethodBody.getAST().newReturnStatement();
  rewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnVariableSimpleName,null);
  bodyRewrite.insertLast(returnStatement,null);
  rewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  ListRewrite methodDeclarationRewrite=rewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertLast(newMethodDeclaration,null);
  replaceExtractedCodeWithMethodInvocation(rewriter);
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer textFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument document=textFileBuffer.getDocument();
  TextEdit edit=rewriter.rewriteAST(document,null);
  try {
    edit.apply(document);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}","public void extractMethod(){
  AST ast=sourceTypeDeclaration.getAST();
  MethodDeclaration newMethodDeclaration=ast.newMethodDeclaration();
  SimpleName returnVariableSimpleName=variableDeclarationFragment.getName();
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.NAME_PROPERTY,returnVariableSimpleName,null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.RETURN_TYPE2_PROPERTY,variableDeclarationStatement.getType(),null);
  ListRewrite modifierRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.MODIFIERS2_PROPERTY);
  Modifier modifier=newMethodDeclaration.getAST().newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD);
  modifierRewrite.insertLast(modifier,null);
  ExpressionExtractor extractor=new ExpressionExtractor();
  List<SimpleName> extractedMethodArguments=new ArrayList<SimpleName>();
  List<String> extractedMethodArgumentIdentifiers=new ArrayList<String>();
  List<String> variableDeclarationIdentifiers=new ArrayList<String>();
  for (  Statement statement : extractStatementList) {
    List<Expression> list=extractor.getVariableInstructions(statement);
    for (    Expression expression : list) {
      SimpleName simpleName=(SimpleName)expression;
      IBinding binding=simpleName.resolveBinding();
      if (binding.getKind() == IBinding.VARIABLE) {
        IVariableBinding variableBinding=(IVariableBinding)binding;
        String simpleNameIdentifier=simpleName.getIdentifier();
        if (!variableBinding.isField() && !simpleName.isDeclaration() && !returnVariableSimpleName.getIdentifier().equals(simpleNameIdentifier)) {
          if (!extractedMethodArgumentIdentifiers.contains(simpleNameIdentifier) && !variableDeclarationIdentifiers.contains(simpleNameIdentifier)) {
            extractedMethodArgumentIdentifiers.add(simpleNameIdentifier);
            extractedMethodArguments.add(simpleName);
          }
        }
 else {
          if (!variableDeclarationIdentifiers.contains(simpleNameIdentifier))           variableDeclarationIdentifiers.add(simpleNameIdentifier);
        }
      }
    }
  }
  ListRewrite paramRewrite=sourceRewriter.getListRewrite(newMethodDeclaration,MethodDeclaration.PARAMETERS_PROPERTY);
  for (  SimpleName argument : extractedMethodArguments) {
    Type argumentVariableDeclarationType=null;
    for (    VariableDeclarationStatement statement : variableDeclarationStatementList) {
      List<VariableDeclarationFragment> fragmentList=statement.fragments();
      for (      VariableDeclarationFragment fragment : fragmentList) {
        if (fragment.getName().getIdentifier().equals(argument.getIdentifier())) {
          argumentVariableDeclarationType=statement.getType();
          break;
        }
      }
    }
    if (argumentVariableDeclarationType == null) {
      List<SingleVariableDeclaration> sourceMethodParameters=sourceMethodDeclaration.parameters();
      for (      SingleVariableDeclaration variableDeclaration : sourceMethodParameters) {
        if (variableDeclaration.getName().getIdentifier().equals(argument.getIdentifier())) {
          argumentVariableDeclarationType=variableDeclaration.getType();
          break;
        }
      }
    }
    if (argumentVariableDeclarationType != null) {
      SingleVariableDeclaration newParam=newMethodDeclaration.getAST().newSingleVariableDeclaration();
      sourceRewriter.set(newParam,SingleVariableDeclaration.NAME_PROPERTY,argument,null);
      sourceRewriter.set(newParam,SingleVariableDeclaration.TYPE_PROPERTY,argumentVariableDeclarationType,null);
      paramRewrite.insertLast(newParam,null);
    }
  }
  Block newMethodBody=newMethodDeclaration.getAST().newBlock();
  ListRewrite bodyRewrite=sourceRewriter.getListRewrite(newMethodBody,Block.STATEMENTS_PROPERTY);
  VariableDeclarationFragment localVariableDeclarationFragment=newMethodBody.getAST().newVariableDeclarationFragment();
  sourceRewriter.set(localVariableDeclarationFragment,VariableDeclarationFragment.NAME_PROPERTY,variableDeclarationFragment.getName(),null);
  sourceRewriter.set(localVariableDeclarationFragment,VariableDeclarationFragment.INITIALIZER_PROPERTY,variableDeclarationFragment.getInitializer(),null);
  VariableDeclarationStatement localVariableDeclarationStatement=newMethodBody.getAST().newVariableDeclarationStatement(localVariableDeclarationFragment);
  sourceRewriter.set(localVariableDeclarationStatement,VariableDeclarationStatement.TYPE_PROPERTY,variableDeclarationStatement.getType(),null);
  bodyRewrite.insertLast(localVariableDeclarationStatement,null);
  for (  Statement statement : extractStatementList) {
    bodyRewrite.insertLast(statement,null);
  }
  ReturnStatement returnStatement=newMethodBody.getAST().newReturnStatement();
  sourceRewriter.set(returnStatement,ReturnStatement.EXPRESSION_PROPERTY,returnVariableSimpleName,null);
  bodyRewrite.insertLast(returnStatement,null);
  sourceRewriter.set(newMethodDeclaration,MethodDeclaration.BODY_PROPERTY,newMethodBody,null);
  ListRewrite methodDeclarationRewrite=sourceRewriter.getListRewrite(sourceTypeDeclaration,TypeDeclaration.BODY_DECLARATIONS_PROPERTY);
  methodDeclarationRewrite.insertLast(newMethodDeclaration,null);
  replaceExtractedCodeWithMethodInvocation(extractedMethodArguments);
  ITextFileBufferManager bufferManager=FileBuffers.getTextFileBufferManager();
  ITextFileBuffer textFileBuffer=bufferManager.getTextFileBuffer(sourceFile.getFullPath(),LocationKind.IFILE);
  IDocument document=textFileBuffer.getDocument();
  TextEdit edit=sourceRewriter.rewriteAST(document,null);
  try {
    edit.apply(document);
  }
 catch (  MalformedTreeException e) {
    e.printStackTrace();
  }
catch (  BadLocationException e) {
    e.printStackTrace();
  }
}"
12287,"public static void main(String[] args) throws IOException, SAXException, ParserConfigurationException {
  System.out.println(""String_Node_Str"" + countWordsInTerms(args[0]));
  System.out.println(""String_Node_Str"" + countWords(args[0]));
  parse(args[0],args[1]);
}","public static void main(String[] args) throws IOException, SAXException, ParserConfigurationException {
  parse(args[0],args[1]);
}"
12288,"public static void parse(String xmlFile,String outFolder) throws ParserConfigurationException, IOException, SAXException {
  DocumentBuilder docBuilder=DocumentBuilderFactory.newInstance().newDocumentBuilder();
  FileInputStream xmlFileStream=new FileInputStream(new File(xmlFile));
  try {
    Document document=docBuilder.parse(xmlFileStream);
    NodeList nodeList=document.getDocumentElement().getElementsByTagName(""String_Node_Str"");
    for (int i=0; i < nodeList.getLength(); i++) {
      Element doc=(Element)nodeList.item(i);
      NodeList docId=doc.getElementsByTagName(""String_Node_Str"");
      String id=docId.item(0).getFirstChild().getNodeValue();
      id=i + ""String_Node_Str"" + id.replaceAll(""String_Node_Str"",""String_Node_Str"");
      PrintWriter p=new PrintWriter(outFolder + File.separator + id+ ""String_Node_Str"");
      NodeList sentences=doc.getElementsByTagName(""String_Node_Str"");
      for (int j=0; j < sentences.getLength(); j++) {
        Node sent=sentences.item(j);
        p.println(sent.getTextContent());
      }
      p.close();
    }
  }
  finally {
    xmlFileStream.close();
  }
}","public static void parse(String xmlFile,String outFolder) throws ParserConfigurationException, IOException, SAXException {
  DocumentBuilder docBuilder=DocumentBuilderFactory.newInstance().newDocumentBuilder();
  FileInputStream xmlFileStream=new FileInputStream(new File(xmlFile));
  try {
    Document document=docBuilder.parse(xmlFileStream);
    NodeList nodeList=document.getDocumentElement().getElementsByTagName(""String_Node_Str"");
    for (int i=0; i < nodeList.getLength(); i++) {
      Element doc=(Element)nodeList.item(i);
      NodeList docId=doc.getElementsByTagName(""String_Node_Str"");
      String id=docId.item(0).getFirstChild().getNodeValue();
      id=i + ""String_Node_Str"" + id.replaceAll(""String_Node_Str"",""String_Node_Str"");
      PrintWriter p=new PrintWriter(outFolder + File.separator + id+ ""String_Node_Str"");
      NodeList sentences=doc.getElementsByTagName(""String_Node_Str"");
      for (int j=0; j < sentences.getLength(); j++) {
        Node sent=sentences.item(j);
        if (j == 0) {
          p.println(sent.getTextContent());
        }
        p.print(sent.getTextContent() + ""String_Node_Str"");
      }
      p.close();
    }
  }
  finally {
    xmlFileStream.close();
  }
}"
12289,"@Override public final boolean incrementToken() throws IOException {
  if (first) {
    loadAll();
    restartAtBeginning();
    first=false;
  }
  if (sentences.length == 0) {
    first=true;
    return false;
  }
  int sentenceOffset=sentences[indexSentence].getStart();
  if (wordSet == null) {
    wordSet=words[indexSentence];
  }
  clearAttributes();
  while (indexSentence < sentences.length) {
    while (indexWord == wordSet.length) {
      indexSentence++;
      if (indexSentence < sentences.length) {
        wordSet=words[indexSentence];
        indexWord=0;
        sentenceOffset=sentences[indexSentence].getStart();
      }
 else {
        first=true;
        return false;
      }
    }
    Span sentence=sentences[indexSentence];
    Span word=wordSet[indexWord];
    int spot=sentence.getStart() + word.getStart();
    termAtt.setEmpty();
    int termLength=word.getEnd() - word.getStart();
    if (termAtt.buffer().length < termLength) {
      termAtt.resizeBuffer(termLength);
    }
    termAtt.setLength(termLength);
    char[] buffer=termAtt.buffer();
    finalOffset=correctOffset(sentenceOffset + word.getEnd());
    int start=correctOffset(word.getStart() + sentenceOffset);
    if (finalOffset - start > termLength) {
      offsetAtt.setOffset(start,sentenceOffset + word.getEnd());
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + start + ""String_Node_Str""+ finalOffset+ ""String_Node_Str""+ termLength+ ""String_Node_Str"");
    }
 else     offsetAtt.setOffset(start,finalOffset);
    for (int i=0; i < termLength; i++) {
      buffer[i]=fullText[spot + i];
    }
    addSentenceContext(sentenceContextAtt,indexWord,indexWord,null,indexSentence);
    indexWord++;
    return true;
  }
  first=true;
  return false;
}","@Override public final boolean incrementToken() throws IOException {
  if (first) {
    loadAll();
    restartAtBeginning();
    first=false;
  }
  if (sentences.length == 0) {
    first=true;
    return false;
  }
  int sentenceOffset=sentences[indexSentence].getStart();
  if (wordSet == null) {
    wordSet=words[indexSentence];
  }
  clearAttributes();
  while (indexSentence < sentences.length) {
    while (indexWord == wordSet.length) {
      indexSentence++;
      if (indexSentence < sentences.length) {
        wordSet=words[indexSentence];
        indexWord=0;
        sentenceOffset=sentences[indexSentence].getStart();
      }
 else {
        first=true;
        return false;
      }
    }
    Span sentence=sentences[indexSentence];
    Span word=wordSet[indexWord];
    int spot=sentence.getStart() + word.getStart();
    termAtt.setEmpty();
    int termLength=word.getEnd() - word.getStart();
    if (termAtt.buffer().length < termLength) {
      termAtt.resizeBuffer(termLength);
    }
    termAtt.setLength(termLength);
    char[] buffer=termAtt.buffer();
    finalOffset=correctOffset(sentenceOffset + word.getEnd());
    int start=correctOffset(word.getStart() + sentenceOffset);
    if (finalOffset - start > termLength) {
      offsetAtt.setOffset(start,start + termLength);
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + start + ""String_Node_Str""+ finalOffset+ ""String_Node_Str""+ termLength+ ""String_Node_Str"");
    }
 else     offsetAtt.setOffset(start,finalOffset);
    for (int i=0; i < termLength; i++) {
      buffer[i]=fullText[spot + i];
    }
    addSentenceContext(sentenceContextAtt,indexWord,indexWord,null,indexSentence);
    indexWord++;
    return true;
  }
  first=true;
  return false;
}"
12290,"private void iterateAddDomainTermFields(boolean isBoosted,String domainTermsFieldName,IndexSchema indexSchema,Document doc,List<Pair<String,Double>> filteredCandidateTerms){
  for (  Pair<String,Double> filteredTerm : filteredCandidateTerms) {
    if (filteredTerm == null) {
      continue;
    }
    if (isBoosted) {
      doc.add(indexSchema.getField(domainTermsFieldName).createField(filteredTerm.getKey(),filteredTerm.getValue().floatValue()));
    }
 else {
      doc.add(indexSchema.getField(domainTermsFieldName).createField(filteredTerm.getKey(),DEFAULT_BOOST_VALUE));
    }
  }
}","private void iterateAddDomainTermFields(boolean isBoosted,String domainTermsFieldName,IndexSchema indexSchema,Document doc,List<Pair<String,Double>> filteredCandidateTerms){
  doc.removeFields(domainTermsFieldName);
  for (  Pair<String,Double> filteredTerm : filteredCandidateTerms) {
    if (filteredTerm == null) {
      continue;
    }
    if (isBoosted) {
      doc.add(indexSchema.getField(domainTermsFieldName).createField(filteredTerm.getKey(),filteredTerm.getValue().floatValue()));
    }
 else {
      doc.add(indexSchema.getField(domainTermsFieldName).createField(filteredTerm.getKey(),DEFAULT_BOOST_VALUE));
    }
  }
}"
12291,"/** 
 * Index weighted & filtered final terms back into Solr
 * @param filteredTerms   filtered JATE terms
 * @param jateProperties  jate properties for integration config between jate2.0 and solr instance
 * @param indexSearcher   solr index searcher
 * @param isBoosted       true or false to indivate whether term will be boosted with ATE score
 * @throws JATEException
 */
public void indexTerms(List<JATETerm> filteredTerms,JATEProperties jateProperties,SolrIndexSearcher indexSearcher,boolean isBoosted,boolean isExtraction) throws JATEException {
  int numDocs=indexSearcher.maxDoc();
  String domainTermsFieldName=jateProperties.getSolrFieldNameJATEDomainTerms();
  String candidateTermFieldName=jateProperties.getSolrFieldNameJATECTerms();
  log.info(String.format(""String_Node_Str"",filteredTerms.size(),domainTermsFieldName,numDocs));
  if (filteredTerms.size() == 0) {
    return;
  }
  SolrCore core=indexSearcher.getCore();
  IndexSchema indexSchema=core.getLatestSchema();
  try {
    IndexWriter writerIn=core.getSolrCoreState().getIndexWriter(core).get();
    Map<String,List<CopyField>> copyFields=indexSchema.getCopyFieldsMap();
    for (int docID=0; docID < numDocs; docID++) {
      try {
        Document doc=indexSearcher.doc(docID);
        if (isExtraction) {
          SolrUtil.copyFields(copyFields,DEFAULT_BOOST_VALUE,doc);
        }
        Terms indexedCandidateTermsVectors=SolrUtil.getTermVector(docID,candidateTermFieldName,indexSearcher);
        List<String> candidateTerms=SolrUtil.getNormalisedTerms(indexedCandidateTermsVectors);
        List<Pair<String,Double>> filteredCandidateTerms=getSelectedWeightedCandidates(filteredTerms,candidateTerms);
        iterateAddDomainTermFields(isBoosted,domainTermsFieldName,indexSchema,doc,filteredCandidateTerms);
        writerIn.updateDocument(new Term(""String_Node_Str"",doc.get(""String_Node_Str"")),doc);
      }
 catch (      IOException e) {
        throw new JATEException(String.format(""String_Node_Str"" + ""String_Node_Str"",docID,e.toString()));
      }
    }
  }
 catch (  IOException ioe) {
    throw new JATEException(String.format(""String_Node_Str"" + ""String_Node_Str"",ioe.toString()));
  }
  log.info(String.format(""String_Node_Str"",domainTermsFieldName));
}","/** 
 * Index weighted & filtered final terms back into Solr
 * @param filteredTerms   filtered JATE terms
 * @param jateProperties  jate properties for integration config between jate2.0 and solr instance
 * @param indexSearcher   solr index searcher
 * @param isBoosted       true or false to indicate whether term will be boosted with ATE score
 * @throws JATEException
 */
public void indexTerms(List<JATETerm> filteredTerms,JATEProperties jateProperties,SolrIndexSearcher indexSearcher,boolean isBoosted,boolean isExtraction) throws JATEException {
  int numDocs=indexSearcher.maxDoc();
  String domainTermsFieldName=jateProperties.getSolrFieldNameJATEDomainTerms();
  String candidateTermFieldName=jateProperties.getSolrFieldNameJATECTerms();
  log.info(String.format(""String_Node_Str"",filteredTerms.size(),domainTermsFieldName,numDocs));
  if (filteredTerms.size() == 0) {
    return;
  }
  SolrCore core=indexSearcher.getCore();
  IndexSchema indexSchema=core.getLatestSchema();
  IndexWriter writerIn=null;
  try {
    writerIn=core.getSolrCoreState().getIndexWriter(core).get();
    Map<String,List<CopyField>> copyFields=indexSchema.getCopyFieldsMap();
    for (int docID=0; docID < numDocs; docID++) {
      try {
        Document doc=indexSearcher.doc(docID);
        if (isExtraction) {
          SolrUtil.copyFields(copyFields,DEFAULT_BOOST_VALUE,doc);
        }
        Terms indexedCandidateTermsVectors=SolrUtil.getTermVector(docID,candidateTermFieldName,indexSearcher);
        if (indexedCandidateTermsVectors == null) {
          continue;
        }
        List<String> candidateTerms=SolrUtil.getNormalisedTerms(indexedCandidateTermsVectors);
        List<Pair<String,Double>> filteredCandidateTerms=getSelectedWeightedCandidates(filteredTerms,candidateTerms);
        iterateAddDomainTermFields(isBoosted,domainTermsFieldName,indexSchema,doc,filteredCandidateTerms);
        log.debug(String.format(""String_Node_Str"",doc.get(""String_Node_Str""),doc.get(""String_Node_Str"")));
        String currentVersionNo=doc.get(""String_Node_Str"");
        doc.removeField(""String_Node_Str"");
        doc.add(indexSchema.getField(""String_Node_Str"").createField(versionIncrement(currentVersionNo),DEFAULT_BOOST_VALUE));
        writerIn.updateDocument(new Term(""String_Node_Str"",doc.get(""String_Node_Str"")),doc);
      }
 catch (      IOException e) {
        throw new JATEException(String.format(""String_Node_Str"" + ""String_Node_Str"",docID,e.toString()));
      }
    }
    writerIn.forceMerge(1,false);
    writerIn.commit();
  }
 catch (  IOException ioe) {
    throw new JATEException(String.format(""String_Node_Str"" + ""String_Node_Str"",ioe.toString()));
  }
  log.info(String.format(""String_Node_Str"",domainTermsFieldName));
}"
12292,"@Override public void handleRequestBody(SolrQueryRequest req,SolrQueryResponse rsp) throws Exception {
  log.info(""String_Node_Str"");
  setTopInitArgsAsInvariants(req);
  final String jatePropertyFile=req.getParams().get(JATE_PROPERTY_FILE);
  final String algorithmName=req.getParams().get(TERM_RANKING_ALGORITHM);
  final Boolean isExtraction=req.getParams().getBool(CANDIDATE_EXTRACTION);
  final String outFilePath=req.getParams().get(AppParams.OUTPUT_FILE.getParamKey());
  final Boolean isIndexTerms=req.getParams().getBool(INDEX_TERM);
  final Boolean isBoosted=req.getParams().getBool(BOOSTING);
  final Algorithm algorithm=getAlgorithm(algorithmName);
  JATEProperties properties=App.getJateProperties(jatePropertyFile);
  final SolrIndexSearcher searcher=req.getSearcher();
  if (isExtraction) {
    log.info(""String_Node_Str"");
    generalTRProcessor.candidateExtraction(searcher.getCore(),jatePropertyFile);
    log.info(""String_Node_Str"");
  }
  Map<String,String> trRunTimeParams=initialiseTRRunTimeParams(req);
  List<JATETerm> termList=generalTRProcessor.rankingAndFiltering(searcher.getCore(),jatePropertyFile,trRunTimeParams,algorithm);
  log.info(String.format(""String_Node_Str"",termList.size()));
  if (isExport(outFilePath)) {
    generalTRProcessor.export(termList);
  }
  if (isIndexTerms) {
    log.info(""String_Node_Str"");
    indexTerms(termList,properties,searcher,isBoosted,isExtraction);
    log.info(""String_Node_Str"");
  }
}","@Override public void handleRequestBody(SolrQueryRequest req,SolrQueryResponse rsp) throws Exception {
  log.info(""String_Node_Str"");
  setTopInitArgsAsInvariants(req);
  final String jatePropertyFile=req.getParams().get(JATE_PROPERTY_FILE);
  final String algorithmName=req.getParams().get(TERM_RANKING_ALGORITHM);
  final Boolean isExtraction=req.getParams().getBool(CANDIDATE_EXTRACTION);
  final String outFilePath=req.getParams().get(AppParams.OUTPUT_FILE.getParamKey());
  final Boolean isIndexTerms=req.getParams().getBool(INDEX_TERM);
  final Boolean isBoosted=req.getParams().getBool(BOOSTING);
  final Algorithm algorithm=getAlgorithm(algorithmName);
  JATEProperties properties=App.getJateProperties(jatePropertyFile);
  final SolrIndexSearcher searcher=req.getSearcher();
  if (isExtraction) {
    log.info(""String_Node_Str"");
    generalTRProcessor.candidateExtraction(searcher.getCore(),jatePropertyFile);
    log.info(""String_Node_Str"");
  }
  Map<String,String> trRunTimeParams=initialiseTRRunTimeParams(req);
  List<JATETerm> termList=generalTRProcessor.rankingAndFiltering(searcher.getCore(),jatePropertyFile,trRunTimeParams,algorithm);
  log.info(String.format(""String_Node_Str"",termList.size()));
  if (isExport(outFilePath)) {
    generalTRProcessor.export(termList);
  }
  if (isIndexTerms) {
    log.info(""String_Node_Str"");
    indexTerms(termList,properties,searcher,isBoosted,isExtraction);
    searcher.getCore().getUpdateHandler().commit(new CommitUpdateCommand(req,true));
    log.info(""String_Node_Str"");
  }
}"
12293,"private Algorithm getAlgorithm(String algName) throws JATEException {
  if (StringUtils.isEmpty(algName)) {
    throw new JATEException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (algName.equalsIgnoreCase(Algorithm.C_VALUE.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.C_VALUE.getAlgorithmName()));
    return Algorithm.C_VALUE;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.ATTF.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.ATTF.getAlgorithmName()));
    return Algorithm.ATTF;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.CHI_SQUARE.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.CHI_SQUARE.getAlgorithmName()));
    return Algorithm.CHI_SQUARE;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.GLOSSEX.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.GLOSSEX.getAlgorithmName()));
    return Algorithm.GLOSSEX;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.RAKE.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.RAKE.getAlgorithmName()));
    return Algorithm.RAKE;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.RIDF.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.RIDF.getAlgorithmName()));
    return Algorithm.RIDF;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.TERM_EX.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.TERM_EX.getAlgorithmName()));
    return Algorithm.TERM_EX;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.TF_IDF.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.TF_IDF.getAlgorithmName()));
    return Algorithm.TF_IDF;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.TTF.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.TTF.getAlgorithmName()));
    return Algorithm.TTF;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.WEIRDNESS.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.WEIRDNESS.getAlgorithmName()));
    return Algorithm.WEIRDNESS;
  }
 else {
    throw new JATEException(String.format(""String_Node_Str"",algName));
  }
}","private Algorithm getAlgorithm(String algName) throws JATEException {
  if (StringUtils.isEmpty(algName)) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (algName.equalsIgnoreCase(Algorithm.C_VALUE.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.C_VALUE.getAlgorithmName()));
    return Algorithm.C_VALUE;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.ATTF.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.ATTF.getAlgorithmName()));
    return Algorithm.ATTF;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.CHI_SQUARE.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.CHI_SQUARE.getAlgorithmName()));
    return Algorithm.CHI_SQUARE;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.GLOSSEX.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.GLOSSEX.getAlgorithmName()));
    return Algorithm.GLOSSEX;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.RAKE.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.RAKE.getAlgorithmName()));
    return Algorithm.RAKE;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.RIDF.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.RIDF.getAlgorithmName()));
    return Algorithm.RIDF;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.TERM_EX.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.TERM_EX.getAlgorithmName()));
    return Algorithm.TERM_EX;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.TF_IDF.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.TF_IDF.getAlgorithmName()));
    return Algorithm.TF_IDF;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.TTF.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.TTF.getAlgorithmName()));
    return Algorithm.TTF;
  }
 else   if (algName.equalsIgnoreCase(Algorithm.WEIRDNESS.getAlgorithmName())) {
    log.debug(String.format(""String_Node_Str"",Algorithm.WEIRDNESS.getAlgorithmName()));
    return Algorithm.WEIRDNESS;
  }
 else {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,String.format(""String_Node_Str"" + ""String_Node_Str"",algName));
  }
}"
12294,"public static Terms getTermVector(int docId,String fieldname,SolrIndexSearcher solrIndexSearcher) throws JATEException {
  try {
    Terms vector=solrIndexSearcher.getLeafReader().getTermVector(docId,fieldname);
    if (vector == null)     throw new JATEException(""String_Node_Str"" + fieldname + ""String_Node_Str"");
    return vector;
  }
 catch (  IOException ioe) {
    StringBuilder sb=new StringBuilder(String.format(""String_Node_Str"",fieldname));
    sb.append(org.apache.commons.lang.exception.ExceptionUtils.getFullStackTrace(ioe));
    throw new JATEException(sb.toString());
  }
}","public static Terms getTermVector(int docId,String fieldname,SolrIndexSearcher solrIndexSearcher) throws JATEException {
  try {
    Terms vector=solrIndexSearcher.getLeafReader().getTermVector(docId,fieldname);
    return vector;
  }
 catch (  IOException ioe) {
    StringBuilder sb=new StringBuilder(String.format(""String_Node_Str"",fieldname));
    sb.append(org.apache.commons.lang.exception.ExceptionUtils.getFullStackTrace(ioe));
    throw new JATEException(sb.toString());
  }
}"
12295,"public static void copyFields(Map<String,List<CopyField>> copyFields,float boost,Document doc){
  for (  String sourceField : copyFields.keySet()) {
    List<CopyField> copyFieldList=copyFields.get(sourceField);
    for (    CopyField copyField : copyFieldList) {
      IndexableField jateField=copyField.getDestination().createField(doc.get(copyField.getSource().getName()),boost);
      doc.add(jateField);
    }
  }
}","public static void copyFields(Map<String,List<CopyField>> copyFields,float boost,Document doc){
  for (  String sourceField : copyFields.keySet()) {
    List<CopyField> copyFieldList=copyFields.get(sourceField);
    for (    CopyField copyField : copyFieldList) {
      doc.removeField(copyField.getDestination().getName());
      IndexableField jateField=copyField.getDestination().createField(doc.get(copyField.getSource().getName()),boost);
      doc.add(jateField);
    }
  }
}"
12296,"@Override public final boolean incrementToken() throws IOException {
  if (first) {
    loadAll();
    restartAtBeginning();
    first=false;
  }
  if (sentences.length == 0) {
    first=true;
    return false;
  }
  int sentenceOffset=sentences[indexSentence].getStart();
  if (wordSet == null) {
    wordSet=words[indexSentence];
  }
  clearAttributes();
  while (indexSentence < sentences.length) {
    while (indexWord == wordSet.length) {
      indexSentence++;
      if (indexSentence < sentences.length) {
        wordSet=words[indexSentence];
        indexWord=0;
        sentenceOffset=sentences[indexSentence].getStart();
      }
 else {
        first=true;
        return false;
      }
    }
    Span sentence=sentences[indexSentence];
    Span word=wordSet[indexWord];
    int spot=sentence.getStart() + word.getStart();
    termAtt.setEmpty();
    int termLength=word.getEnd() - word.getStart();
    if (termAtt.buffer().length < termLength) {
      termAtt.resizeBuffer(termLength);
    }
    termAtt.setLength(termLength);
    char[] buffer=termAtt.buffer();
    finalOffset=correctOffset(sentenceOffset + word.getEnd());
    int start=correctOffset(word.getStart() + sentenceOffset);
    if (finalOffset - start > termLength) {
      offsetAtt.setOffset(start,start + termLength);
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + start + ""String_Node_Str""+ finalOffset+ ""String_Node_Str""+ termLength+ ""String_Node_Str"");
    }
 else     offsetAtt.setOffset(start,finalOffset);
    for (int i=0; i < termLength; i++) {
      buffer[i]=fullText[spot + i];
    }
    addSentenceContext(sentenceContextAtt,indexWord,indexWord,null,indexSentence);
    indexWord++;
    return true;
  }
  first=true;
  return false;
}","@Override public final boolean incrementToken() throws IOException {
  if (first) {
    loadAll();
    restartAtBeginning();
    first=false;
  }
  if (sentences.length == 0) {
    first=true;
    return false;
  }
  int sentenceOffset=sentences[indexSentence].getStart();
  if (wordSet == null) {
    wordSet=words[indexSentence];
  }
  clearAttributes();
  while (indexSentence < sentences.length) {
    while (indexWord == wordSet.length) {
      indexSentence++;
      if (indexSentence < sentences.length) {
        wordSet=words[indexSentence];
        indexWord=0;
        sentenceOffset=sentences[indexSentence].getStart();
      }
 else {
        first=true;
        return false;
      }
    }
    Span sentence=sentences[indexSentence];
    Span word=wordSet[indexWord];
    int spot=sentence.getStart() + word.getStart();
    termAtt.setEmpty();
    int termLength=word.getEnd() - word.getStart();
    if (termAtt.buffer().length < termLength) {
      termAtt.resizeBuffer(termLength);
    }
    termAtt.setLength(termLength);
    char[] buffer=termAtt.buffer();
    finalOffset=correctOffset(sentenceOffset + word.getEnd());
    int start=correctOffset(word.getStart() + sentenceOffset);
    for (int i=0; i < termLength; i++) {
      buffer[i]=fullText[spot + i];
    }
    if (finalOffset - start > termLength) {
      offsetAtt.setOffset(start,start + termLength);
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + start + ""String_Node_Str""+ finalOffset+ ""String_Node_Str""+ termLength+ ""String_Node_Str"");
    }
 else     offsetAtt.setOffset(start,finalOffset);
    addSentenceContext(sentenceContextAtt,indexWord,indexWord,null,indexSentence);
    indexWord++;
    return true;
  }
  first=true;
  return false;
}"
12297,"/** 
 * Initialise common run-time parameters
 * @param params, command line run-time parameters (paramKey, value) for termranking algorithms <p> see also {code CommandLineParams}
 * @throws JATEException
 */
App(Map<String,String> params) throws JATEException {
  if (params.containsKey(AppParams.CUTOFF_TOP_K.getParamKey())) {
    String topKSetting=params.get(AppParams.CUTOFF_TOP_K.getParamKey());
    this.cutoffTopK=parseIntParam(""String_Node_Str"" + AppParams.CUTOFF_TOP_K.getParamKey(),topKSetting);
    log.debug(String.format(""String_Node_Str"",topKSetting));
  }
  if (params.containsKey(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey())) {
    String topPercSetting=params.get(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey());
    this.cutoffTopKPercent=parseDoubleParam(""String_Node_Str"" + AppParams.CUTOFF_TOP_K_PERCENT.getParamKey(),topPercSetting);
    log.debug(String.format(""String_Node_Str"",topPercSetting));
  }
  if (params.containsKey(AppParams.CUTOFF_THRESHOLD.getParamKey())) {
    String cutOffThreshold=params.get(AppParams.CUTOFF_THRESHOLD.getParamKey());
    this.cutoffThreshold=parseDoubleParam(""String_Node_Str"" + AppParams.CUTOFF_THRESHOLD.getParamKey(),cutOffThreshold);
    log.debug(String.format(""String_Node_Str"",cutOffThreshold));
  }
  if (params.containsKey(AppParams.PREFILTER_MIN_TERM_CONTEXT_FREQUENCY.getParamKey())) {
    String minTCF=params.get(AppParams.PREFILTER_MIN_TERM_CONTEXT_FREQUENCY.getParamKey());
    this.prefilterMinTCF=parseIntParam(""String_Node_Str"" + AppParams.PREFILTER_MIN_TERM_CONTEXT_FREQUENCY,minTCF);
    log.debug(String.format(""String_Node_Str"",prefilterMinTCF));
  }
  if (params.containsKey(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey())) {
    String minTTF=params.get(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey());
    this.prefilterMinTTF=parseIntParam(""String_Node_Str"" + AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY,minTTF);
    log.debug(String.format(""String_Node_Str"",prefilterMinTCF));
  }
  if (params.containsKey(AppParams.COLLECT_TERM_INFO.getParamKey())) {
    String collectTermOffsets=params.get(AppParams.COLLECT_TERM_INFO.getParamKey());
    if (collectTermOffsets != null && collectTermOffsets.equalsIgnoreCase(""String_Node_Str"")) {
      this.collectTermInfo=true;
      log.debug(""String_Node_Str"");
    }
  }
  if (params.containsKey(AppParams.OUTPUT_FILE.getParamKey())) {
    String outFile=params.get(AppParams.OUTPUT_FILE.getParamKey());
    StringBuilder msg=new StringBuilder(""String_Node_Str"");
    msg.append(""String_Node_Str"");
    if (outFile == null) {
      log.warn(msg.toString());
      outputFile=""String_Node_Str"";
    }
 else {
      try {
        PrintWriter p=new PrintWriter(outFile);
        p.close();
        outputFile=outFile;
      }
 catch (      IOException ioe) {
        log.warn(msg.toString());
        outputFile=""String_Node_Str"";
      }
    }
  }
}","/** 
 * Initialise common run-time parameters
 * @param params, command line run-time parameters (paramKey, value) for termranking algorithms
 * @see AppParams
 * @throws JATEException
 * @see AppParams
 */
App(Map<String,String> params) throws JATEException {
  if (params.containsKey(AppParams.CUTOFF_TOP_K.getParamKey())) {
    String topKSetting=params.get(AppParams.CUTOFF_TOP_K.getParamKey());
    this.cutoffTopK=parseIntParam(""String_Node_Str"" + AppParams.CUTOFF_TOP_K.getParamKey(),topKSetting);
    log.debug(String.format(""String_Node_Str"",topKSetting));
  }
  if (params.containsKey(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey())) {
    String topPercSetting=params.get(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey());
    this.cutoffTopKPercent=parseDoubleParam(""String_Node_Str"" + AppParams.CUTOFF_TOP_K_PERCENT.getParamKey(),topPercSetting);
    log.debug(String.format(""String_Node_Str"",topPercSetting));
  }
  if (params.containsKey(AppParams.CUTOFF_THRESHOLD.getParamKey())) {
    String cutOffThreshold=params.get(AppParams.CUTOFF_THRESHOLD.getParamKey());
    this.cutoffThreshold=parseDoubleParam(""String_Node_Str"" + AppParams.CUTOFF_THRESHOLD.getParamKey(),cutOffThreshold);
    log.debug(String.format(""String_Node_Str"",cutOffThreshold));
  }
  if (params.containsKey(AppParams.PREFILTER_MIN_TERM_CONTEXT_FREQUENCY.getParamKey())) {
    String minTCF=params.get(AppParams.PREFILTER_MIN_TERM_CONTEXT_FREQUENCY.getParamKey());
    this.prefilterMinTCF=parseIntParam(""String_Node_Str"" + AppParams.PREFILTER_MIN_TERM_CONTEXT_FREQUENCY,minTCF);
    log.debug(String.format(""String_Node_Str"",prefilterMinTCF));
  }
  if (params.containsKey(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey())) {
    String minTTF=params.get(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey());
    this.prefilterMinTTF=parseIntParam(""String_Node_Str"" + AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY,minTTF);
    log.debug(String.format(""String_Node_Str"",prefilterMinTCF));
  }
  if (params.containsKey(AppParams.COLLECT_TERM_INFO.getParamKey())) {
    String collectTermOffsets=params.get(AppParams.COLLECT_TERM_INFO.getParamKey());
    if (collectTermOffsets != null && collectTermOffsets.equalsIgnoreCase(""String_Node_Str"")) {
      this.collectTermInfo=true;
      log.debug(""String_Node_Str"");
    }
  }
  if (params.containsKey(AppParams.OUTPUT_FILE.getParamKey())) {
    String outFile=params.get(AppParams.OUTPUT_FILE.getParamKey());
    String msg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
    if (outFile == null) {
      log.warn(msg);
      outputFile=DEFAULT_OUTPUT_FILE;
    }
 else {
      try {
        PrintWriter p=new PrintWriter(outFile);
        p.close();
        outputFile=outFile;
      }
 catch (      IOException ioe) {
        log.warn(msg);
        outputFile=DEFAULT_OUTPUT_FILE;
      }
    }
  }
}"
12298,"private double parseDoubleParam(String name,String value) throws JATEException {
  try {
    return Double.parseDouble(value);
  }
 catch (  NumberFormatException nfe) {
    StringBuilder msg=new StringBuilder(name);
    msg.append(""String_Node_Str"");
    msg.append(value);
    log.error(msg.toString());
    throw new JATEException(msg.toString());
  }
}","private double parseDoubleParam(String name,String value) throws JATEException {
  try {
    return Double.parseDouble(value);
  }
 catch (  NumberFormatException nfe) {
    String msg=String.format(""String_Node_Str"" + ""String_Node_Str"",name,value);
    log.error(msg);
    throw new JATEException(msg);
  }
}"
12299,"/** 
 * Only effective under the Embedded mode. User can choose to output term offset information. If this is the case, this method will be called upon every final term. Iterating through the solr index can be slow so this method can take some time.
 * @param leafReader
 * @param terms
 * @param ngramInfoFieldname
 * @param idFieldname
 * @throws IOException
 */
public void collectTermOffsets(List<JATETerm> terms,LeafReader leafReader,String ngramInfoFieldname,String idFieldname) throws IOException {
  TermInfoCollector infoCollector=new TermInfoCollector(leafReader,ngramInfoFieldname,idFieldname);
  log.info(""String_Node_Str"" + terms.size());
  int count=0;
  for (  JATETerm jt : terms) {
    jt.setTermInfo(infoCollector.collect(jt.getString()));
    count++;
    if (count % 500 == 0)     log.info(""String_Node_Str"" + count);
  }
}","/** 
 * Only effective under the Embedded mode. <p> User can choose to output term offset information. If this is the case, this method will be called upon every final term. Iterating through the solr index can be slow so this method can take some time.
 * @param leafReader, index reader
 * @param terms, term list
 * @param ngramInfoFieldname, indexed n-gram field, see 'jate_text_2_ngrams' field in example schema
 * @param idFieldname, doc unique id field
 * @throws IOException
 */
public void collectTermOffsets(List<JATETerm> terms,LeafReader leafReader,String ngramInfoFieldname,String idFieldname) throws IOException {
  TermInfoCollector infoCollector=new TermInfoCollector(leafReader,ngramInfoFieldname,idFieldname);
  log.info(""String_Node_Str"" + terms.size());
  int count=0;
  for (  JATETerm jt : terms) {
    jt.setTermInfo(infoCollector.collect(jt.getString()));
    count++;
    if (count % 500 == 0)     log.info(""String_Node_Str"" + count);
  }
}"
12300,"protected void initalizeRefFreqParam(Map<String,String> initParams) throws JATEException {
  if (initParams.containsKey(AppParams.REFERENCE_FREQUENCY_FILE.getParamKey())) {
    String refFreqFilePath=initParams.get(AppParams.REFERENCE_FREQUENCY_FILE.getParamKey());
    if (refFreqFilePath == null) {
      StringBuilder msg=new StringBuilder(""String_Node_Str"");
      msg.append(AppParams.REFERENCE_FREQUENCY_FILE.getParamKey()).append(""String_Node_Str"");
      log.error(msg.toString());
      throw new JATEException(msg.toString());
    }
    File refFreqFile=new File(refFreqFilePath);
    if (!refFreqFile.exists()) {
      StringBuilder msg=new StringBuilder(""String_Node_Str"");
      msg.append(AppParams.REFERENCE_FREQUENCY_FILE.getParamKey()).append(""String_Node_Str"").append(refFreqFilePath);
      log.error(msg.toString());
      throw new JATEException(msg.toString());
    }
    this.referenceFrequencyFilePath=refFreqFilePath;
  }
 else {
    StringBuilder msg=new StringBuilder(""String_Node_Str"");
    msg.append(AppParams.REFERENCE_FREQUENCY_FILE.getParamKey()).append(""String_Node_Str"");
    log.error(msg.toString());
    throw new JATEException(msg.toString());
  }
}","/** 
 * @param initParams, map param accepting reference frequency file
 * @throws JATEException
 * @see AppParams#REFERENCE_FREQUENCY_FILE
 */
protected void initalizeRefFreqParam(Map<String,String> initParams) throws JATEException {
  if (initParams.containsKey(AppParams.REFERENCE_FREQUENCY_FILE.getParamKey())) {
    String refFreqFilePath=initParams.get(AppParams.REFERENCE_FREQUENCY_FILE.getParamKey());
    if (refFreqFilePath == null) {
      String msg=String.format(""String_Node_Str"",AppParams.REFERENCE_FREQUENCY_FILE.getParamKey());
      log.error(msg);
      throw new JATEException(msg);
    }
    File refFreqFile=new File(refFreqFilePath);
    if (!refFreqFile.exists()) {
      String msg=String.format(""String_Node_Str"",AppParams.REFERENCE_FREQUENCY_FILE.getParamKey(),refFreqFilePath);
      log.error(msg);
      throw new JATEException(msg);
    }
    this.referenceFrequencyFilePath=refFreqFilePath;
  }
 else {
    String msg=String.format(""String_Node_Str"",AppParams.REFERENCE_FREQUENCY_FILE.getParamKey());
    log.error(msg);
    throw new JATEException(msg);
  }
}"
12301,"private int parseIntParam(String name,String value) throws JATEException {
  try {
    return Integer.parseInt(value);
  }
 catch (  NumberFormatException nfe) {
    StringBuilder msg=new StringBuilder(name);
    msg.append(""String_Node_Str"");
    msg.append(value);
    log.error(msg.toString());
    throw new JATEException(msg.toString());
  }
}","private int parseIntParam(String name,String value) throws JATEException {
  try {
    return Integer.parseInt(value);
  }
 catch (  NumberFormatException nfe) {
    String msg=String.format(""String_Node_Str"" + ""String_Node_Str"",name,value);
    log.error(msg);
    throw new JATEException(msg);
  }
}"
12302,"/** 
 * Rank and Filter terms candidates based on a given Solr index This method assume that documents are indexed in the solr container (solrHomePath) and term candidates have already been extracted at index-time. jate properties provides necessary information needed by the ATE algorithm (e.g., text field, ngram info field, term candiate field, cut-off threshold)
 * @param solrHomePath,     solr core home directory path
 * @param coreName,         solr core name from where term recognition is executed
 * @param jatePropertyFile, jate property file path
 * @return List<JATETerm>, the list of terms extracted
 * @throws IOException
 * @throws JATEException
 */
public List<JATETerm> extract(String solrHomePath,String coreName,String jatePropertyFile) throws IOException, JATEException {
  EmbeddedSolrServer solrServer=null;
  SolrCore core=null;
  List<JATETerm> result=new ArrayList<JATETerm>();
  try {
    solrServer=new EmbeddedSolrServer(Paths.get(solrHomePath),coreName);
    core=solrServer.getCoreContainer().getCore(coreName);
    result=extract(core,jatePropertyFile);
  }
  finally {
    try {
      if (core != null) {
        core.close();
      }
      if (solrServer != null) {
        solrServer.close();
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"");
      log.error(ExceptionUtils.getFullStackTrace(e));
    }
  }
  return result;
}","/** 
 * Rank and Filter terms candidates based on a given Solr index <p> This method assume that documents are indexed in the solr container (solrHomePath) and term candidates have already been extracted at index-time. <p> jate properties provides necessary information needed by the ATE algorithm (e.g., text field, ngram info field, term candiate field, cut-off threshold)
 * @param solrHomePath,     solr core home directory path
 * @param coreName,         solr core name from where term recognition is executed
 * @param jatePropertyFile, jate property file path
 * @return List<JATETerm>, the list of terms extracted
 * @throws IOException
 * @throws JATEException
 */
public List<JATETerm> extract(String solrHomePath,String coreName,String jatePropertyFile) throws IOException, JATEException {
  EmbeddedSolrServer solrServer=null;
  SolrCore core=null;
  List<JATETerm> result=new ArrayList<JATETerm>();
  try {
    solrServer=new EmbeddedSolrServer(Paths.get(solrHomePath),coreName);
    core=solrServer.getCoreContainer().getCore(coreName);
    result=extract(core,jatePropertyFile);
  }
  finally {
    try {
      if (core != null) {
        core.close();
      }
      if (solrServer != null) {
        solrServer.close();
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"");
      log.error(ExceptionUtils.getFullStackTrace(e));
    }
  }
  return result;
}"
12303,"/** 
 * @param args
 */
public static void main(String[] args){
  if (args.length < 1) {
    printHelp();
    System.exit(1);
  }
  String solrHomePath=args[args.length - 3];
  String solrCoreName=args[args.length - 2];
  String jatePropertyFile=args[args.length - 1];
  Map<String,String> params=getParams(args);
  List<JATETerm> terms;
  try {
    AppATTF app=new AppATTF(params);
    terms=app.extract(solrHomePath,solrCoreName,jatePropertyFile);
    app.write(terms);
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
  }
catch (  JATEException e) {
    e.printStackTrace();
  }
}","/** 
 * @param args, command-line params accepting solr home path, solr core name,jate properties file and more optional run-time parameters
 * @see uk.ac.shef.dcs.jate.app.AppParams
 */
public static void main(String[] args){
  if (args.length < 1) {
    printHelp();
    System.exit(1);
  }
  String solrHomePath=args[args.length - 3];
  String solrCoreName=args[args.length - 2];
  String jatePropertyFile=args[args.length - 1];
  Map<String,String> params=getParams(args);
  List<JATETerm> terms;
  try {
    AppATTF app=new AppATTF(params);
    terms=app.extract(solrHomePath,solrCoreName,jatePropertyFile);
    app.write(terms);
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
  }
catch (  JATEException e) {
    e.printStackTrace();
  }
}"
12304,"public AppCValue(Map<String,String> initParams) throws JATEException {
  super(initParams);
}","/** 
 * @param initParams, initial parameters including pre-filtering and post-filtering parameters
 * @throws JATEException
 * @see uk.ac.shef.dcs.jate.app.AppParams
 */
public AppCValue(Map<String,String> initParams) throws JATEException {
  super(initParams);
}"
12305,"public static void main(String[] args){
  if (args.length < 1) {
    printHelp();
    System.exit(1);
  }
  String solrHomePath=args[args.length - 3];
  String solrCoreName=args[args.length - 2];
  String jatePropertyFile=args[args.length - 1];
  Map<String,String> params=getParams(args);
  List<JATETerm> terms;
  try {
    App app=new AppCValue(params);
    terms=app.extract(solrHomePath,solrCoreName,jatePropertyFile);
    app.write(terms);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JATEException e) {
    e.printStackTrace();
  }
}","/** 
 * @param args, command-line params accepting solr home path, solr core name,jate properties file and more optional run-time parameters
 * @see uk.ac.shef.dcs.jate.app.AppParams
 */
public static void main(String[] args){
  if (args.length < 1) {
    printHelp();
    System.exit(1);
  }
  String solrHomePath=args[args.length - 3];
  String solrCoreName=args[args.length - 2];
  String jatePropertyFile=args[args.length - 1];
  Map<String,String> params=getParams(args);
  List<JATETerm> terms;
  try {
    App app=new AppCValue(params);
    terms=app.extract(solrHomePath,solrCoreName,jatePropertyFile);
    app.write(terms);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JATEException e) {
    e.printStackTrace();
  }
}"
12306,"@Override public AbstractFeature build() throws JATEException {
  List<ContextWindow> contextWindows=new ArrayList<>(ref_frequencyCtxBased.getMapCtx2TTF().keySet());
  Collections.sort(contextWindows);
  int cores=properties.getMaxCPUCores();
  cores=cores == 0 ? 1 : cores;
  int maxPerThread=contextWindows.size() / cores;
  if (maxPerThread == 0)   maxPerThread=50;
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(cores).append(""String_Node_Str"").append(contextWindows.size()).append(""String_Node_Str"").append(maxPerThread);
  LOG.info(sb.toString());
  LOG.info(""String_Node_Str"" + minTTF + ""String_Node_Str""+ minTCF);
  Set<String> termsPassingPrefilter=new HashSet<>();
  for (  ContextWindow ctx : contextWindows) {
    Map<String,Integer> termsInContext=frequencyCtxBased.getTFIC(ctx);
    if (minTTF == 0 && minTCF == 0)     termsPassingPrefilter.addAll(termsInContext.keySet());
 else {
      for (      String term : termsInContext.keySet()) {
        if (frequencyTermBased.getTTF(term) >= minTTF && frequencyCtxBased.getContexts(term).size() >= minTCF)         termsPassingPrefilter.add(term);
      }
    }
  }
  Cooccurrence feature=new Cooccurrence(termsPassingPrefilter.size(),ref_frequencyCtxBased.getMapTerm2Ctx().size());
  LOG.info(""String_Node_Str"" + termsPassingPrefilter.size() + ""String_Node_Str""+ contextWindows.size());
  CooccurrenceFBWorker worker=new CooccurrenceFBWorker(feature,contextWindows,frequencyTermBased,minTTF,frequencyCtxBased,ref_frequencyCtxBased,minTCF,maxPerThread);
  ForkJoinPool forkJoinPool=new ForkJoinPool(cores);
  int total=forkJoinPool.invoke(worker);
  Map<String,ContextOverlap> overlaps=frequencyCtxBased.getCtxOverlapZones();
  if (overlaps.size() > 0) {
    LOG.info(""String_Node_Str"" + overlaps.size());
    for (    Map.Entry<String,ContextOverlap> en : overlaps.entrySet()) {
      String key=en.getKey();
      ContextOverlap co=en.getValue();
      Map<String,Integer> freq=new HashMap<>();
      for (      String t : co.getTerms()) {
        Integer f=freq.get(t);
        f=f == null ? 0 : f;
        f++;
        freq.put(t,f);
      }
      if (freq.size() <= 1)       continue;
      ContextOverlap ref_co=ref_frequencyCtxBased.getCtxOverlapZones().get(key);
      Map<String,Integer> ref_freq=new HashMap<>();
      if (ref_co != null) {
        for (        String t : ref_co.getTerms()) {
          Integer f=ref_freq.get(t);
          f=f == null ? 0 : f;
          f++;
          ref_freq.put(t,f);
        }
      }
      if (ref_freq.size() <= 1)       continue;
      for (      Map.Entry<String,Integer> term_in_co : freq.entrySet()) {
        int f=term_in_co.getValue();
        for (        Map.Entry<String,Integer> term_in_ref_co : ref_freq.entrySet()) {
          int rf=term_in_ref_co.getValue();
          if (term_in_co.getKey().equals(term_in_ref_co.getKey()))           continue;
          int deduce=f < rf ? f : rf;
          int tid=feature.lookupTerm(term_in_co.getKey());
          int tid_f=feature.lookupRefTerm(term_in_ref_co.getKey());
          if (tid == -1 || tid_f == -1)           continue;
          feature.deduce(tid,tid_f,deduce);
        }
      }
    }
  }
  sb=new StringBuilder(""String_Node_Str"" + total);
  sb.append(""String_Node_Str"").append(feature.termCounter).append(""String_Node_Str"").append(""String_Node_Str"").append(feature.ctxTermCounter);
  LOG.info(sb.toString());
  return feature;
}","@Override public AbstractFeature build() throws JATEException {
  List<ContextWindow> contextWindows=new ArrayList<>(frequencyCtxBased.getMapCtx2TTF().keySet());
  Collections.sort(contextWindows);
  int cores=properties.getMaxCPUCores();
  cores=cores == 0 ? 1 : cores;
  int maxPerThread=contextWindows.size() / cores;
  if (maxPerThread == 0)   maxPerThread=50;
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(cores).append(""String_Node_Str"").append(contextWindows.size()).append(""String_Node_Str"").append(maxPerThread);
  LOG.info(sb.toString());
  LOG.info(""String_Node_Str"" + minTTF + ""String_Node_Str""+ minTCF);
  Set<String> termsPassingPrefilter=new HashSet<>();
  for (  ContextWindow ctx : contextWindows) {
    Map<String,Integer> termsInContext=frequencyCtxBased.getTFIC(ctx);
    if (minTTF == 0 && minTCF == 0)     termsPassingPrefilter.addAll(termsInContext.keySet());
 else {
      for (      String term : termsInContext.keySet()) {
        if (frequencyTermBased.getTTF(term) >= minTTF && frequencyCtxBased.getContexts(term).size() >= minTCF)         termsPassingPrefilter.add(term);
      }
    }
  }
  Cooccurrence feature=new Cooccurrence(termsPassingPrefilter.size(),ref_frequencyCtxBased.getMapTerm2Ctx().size());
  LOG.info(""String_Node_Str"" + termsPassingPrefilter.size() + ""String_Node_Str""+ contextWindows.size());
  CooccurrenceFBWorker worker=new CooccurrenceFBWorker(feature,contextWindows,frequencyTermBased,minTTF,frequencyCtxBased,ref_frequencyCtxBased,minTCF,maxPerThread);
  ForkJoinPool forkJoinPool=new ForkJoinPool(cores);
  int total=forkJoinPool.invoke(worker);
  Map<String,ContextOverlap> overlaps=frequencyCtxBased.getCtxOverlapZones();
  if (overlaps.size() > 0) {
    LOG.info(""String_Node_Str"" + overlaps.size());
    for (    Map.Entry<String,ContextOverlap> en : overlaps.entrySet()) {
      String key=en.getKey();
      ContextOverlap co=en.getValue();
      Map<String,Integer> freq=new HashMap<>();
      for (      String t : co.getTerms()) {
        Integer f=freq.get(t);
        f=f == null ? 0 : f;
        f++;
        freq.put(t,f);
      }
      if (freq.size() <= 1)       continue;
      ContextOverlap ref_co=ref_frequencyCtxBased.getCtxOverlapZones().get(key);
      Map<String,Integer> ref_freq=new HashMap<>();
      if (ref_co != null) {
        for (        String t : ref_co.getTerms()) {
          Integer f=ref_freq.get(t);
          f=f == null ? 0 : f;
          f++;
          ref_freq.put(t,f);
        }
      }
      if (ref_freq.size() <= 1)       continue;
      for (      Map.Entry<String,Integer> term_in_co : freq.entrySet()) {
        int f=term_in_co.getValue();
        for (        Map.Entry<String,Integer> term_in_ref_co : ref_freq.entrySet()) {
          int rf=term_in_ref_co.getValue();
          if (term_in_co.getKey().equals(term_in_ref_co.getKey()))           continue;
          int deduce=f < rf ? f : rf;
          int tid=feature.lookupTerm(term_in_co.getKey());
          int tid_f=feature.lookupRefTerm(term_in_ref_co.getKey());
          if (tid == -1 || tid_f == -1)           continue;
          feature.deduce(tid,tid_f,deduce);
        }
      }
    }
  }
  sb=new StringBuilder(""String_Node_Str"" + total);
  sb.append(""String_Node_Str"").append(feature.termCounter).append(""String_Node_Str"").append(""String_Node_Str"").append(feature.ctxTermCounter);
  LOG.info(sb.toString());
  return feature;
}"
12307,"@Override protected Integer computeSingleWorker(List<ContextWindow> contextWindows){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(contextWindows.size()).append(""String_Node_Str"").append(ref_frequencyCtxBased.getMapTerm2Ctx().size());
  LOG.info(sb.toString());
  int total=0;
  for (  ContextWindow ctx : contextWindows) {
    Map<String,Integer> refTerm2TFIC=ref_frequencyCtxBased.getTFIC(ctx);
    if (refTerm2TFIC.size() == 0)     continue;
    Map<String,Integer> term2TFIC=frequencyCtxBased.getTFIC(ctx);
    List<String> terms=new ArrayList<>(term2TFIC.keySet());
    for (int i=0; i < terms.size(); i++) {
      String targetTerm=terms.get(i);
      if ((minTTF > 0 && frequencyTermBased.getTTF(targetTerm) < minTTF) || (minTCF > 0 && frequencyCtxBased.getContexts(targetTerm).size() < minTCF))       continue;
      int targetFIC=term2TFIC.get(targetTerm);
      int targetIdx=feature.lookupAndIndexTerm(targetTerm);
      for (      Map.Entry<String,Integer> en : refTerm2TFIC.entrySet()) {
        String refTerm=en.getKey();
        if (refTerm.equals(targetTerm))         continue;
        int refTermFIC=en.getValue();
        int refIdx=feature.lookupAndIndexRefTerm(refTerm);
        int coocurringFreq=targetFIC < refTermFIC ? targetFIC : refTermFIC;
        feature.increment(targetIdx,refIdx,coocurringFreq);
      }
    }
    total++;
  }
  return total;
}","@Override protected Integer computeSingleWorker(List<ContextWindow> contextWindows){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(contextWindows.size()).append(""String_Node_Str"").append(ref_frequencyCtxBased.getMapTerm2Ctx().size());
  LOG.info(sb.toString());
  int total=0;
  for (  ContextWindow ctx : contextWindows) {
    Map<String,Integer> refTerm2TFIC=ref_frequencyCtxBased.getTFIC(ctx);
    Map<String,Integer> term2TFIC=frequencyCtxBased.getTFIC(ctx);
    List<String> terms=new ArrayList<>(term2TFIC.keySet());
    for (int i=0; i < terms.size(); i++) {
      String targetTerm=terms.get(i);
      if ((minTTF > 0 && frequencyTermBased.getTTF(targetTerm) < minTTF) || (minTCF > 0 && frequencyCtxBased.getContexts(targetTerm).size() < minTCF))       continue;
      int targetFIC=term2TFIC.get(targetTerm);
      int targetIdx=feature.lookupAndIndexTerm(targetTerm);
      for (      Map.Entry<String,Integer> en : refTerm2TFIC.entrySet()) {
        String refTerm=en.getKey();
        if (refTerm.equals(targetTerm))         continue;
        int refTermFIC=en.getValue();
        int refIdx=feature.lookupAndIndexRefTerm(refTerm);
        int coocurringFreq=targetFIC < refTermFIC ? targetFIC : refTermFIC;
        feature.increment(targetIdx,refIdx,coocurringFreq);
      }
    }
    total++;
  }
  return total;
}"
12308,"/** 
 * To run the test class via <p> mvn exec:java -Dexec.mainClass=""uk.ac.shef.dcs.jate.app.AppATEACLRDTECTest"" -Dexec.classpathScope=""test""
 * @param args
 * @throws JATEException
 */
public static void main(String[] args) throws JATEException {
  try {
    AppATEACLRDTECTest appATETest=new AppATEACLRDTECTest(solrHome.toString(),solrCoreName);
    boolean reindex=false;
    if (args.length > 0) {
      try {
        reindex=Boolean.valueOf(args[0]);
      }
 catch (      Exception e) {
      }
    }
    long numOfDocs=validate_indexing();
    if (numOfDocs == 0 || reindex) {
      appATETest.indexAndExtract(corpusDir);
    }
    List<JATETerm> terms=null;
    AppATTFTest appATTFTest=new AppATTFTest();
    terms=appATTFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appATTFTest.evaluate(terms,AppATTF.class.getSimpleName());
    AppChiSquareTest appChiSquareTest=new AppChiSquareTest();
    terms=appChiSquareTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appChiSquareTest.evaluate(terms,AppChiSquare.class.getSimpleName());
    AppCValueTest appCValueTest=new AppCValueTest();
    terms=appCValueTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appCValueTest.evaluate(terms,AppCValue.class.getSimpleName());
    AppGlossExTest appGlossExTest=new AppGlossExTest();
    terms=appGlossExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appGlossExTest.evaluate(terms,AppGlossEx.class.getSimpleName());
    AppRAKETest appRAKETest=new AppRAKETest();
    terms=appRAKETest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRAKETest.evaluate(terms,AppRAKE.class.getSimpleName());
    AppRIDFTest appRIDFTest=new AppRIDFTest();
    terms=appRIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRIDFTest.evaluate(terms,AppRIDF.class.getSimpleName());
    AppTermExTest appTermExTest=new AppTermExTest();
    terms=appTermExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTermExTest.evaluate(terms,AppTermEx.class.getSimpleName());
    AppTFIDFTest appTFIDFTest=new AppTFIDFTest();
    terms=appTFIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTFIDFTest.evaluate(terms,AppTFIDF.class.getSimpleName());
    AppTTFTest appTTFTest=new AppTTFTest();
    terms=appTTFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTTFTest.evaluate(terms,AppTTF.class.getSimpleName());
    AppWeirdnessTest appWeirdnessTest=new AppWeirdnessTest();
    terms=appWeirdnessTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appWeirdnessTest.evaluate(terms,AppWeirdness.class.getSimpleName());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      server.getCoreContainer().getCore(solrCoreName).close();
      server.getCoreContainer().shutdown();
      server.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  System.exit(0);
}","/** 
 * To run the test class via <p> mvn exec:java -Dexec.mainClass=""uk.ac.shef.dcs.jate.app.AppATEACLRDTECTest"" -Dexec.classpathScope=""test""
 * @param args
 * @throws JATEException
 */
public static void main(String[] args) throws JATEException {
  try {
    AppATEACLRDTECTest appATETest=new AppATEACLRDTECTest(solrHome.toString(),solrCoreName);
    boolean reindex=false;
    if (args.length > 0) {
      try {
        reindex=Boolean.valueOf(args[0]);
      }
 catch (      Exception e) {
      }
    }
    long numOfDocs=validate_indexing();
    if (numOfDocs == 0 || reindex) {
      appATETest.indexAndExtract(corpusDir);
    }
    List<JATETerm> terms=null;
    AppChiSquareTest appChiSquareTest=new AppChiSquareTest();
    terms=appChiSquareTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appChiSquareTest.evaluate(terms,AppChiSquare.class.getSimpleName());
    System.exit(0);
    AppCValueTest appCValueTest=new AppCValueTest();
    terms=appCValueTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appCValueTest.evaluate(terms,AppCValue.class.getSimpleName());
    AppGlossExTest appGlossExTest=new AppGlossExTest();
    terms=appGlossExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appGlossExTest.evaluate(terms,AppGlossEx.class.getSimpleName());
    AppRAKETest appRAKETest=new AppRAKETest();
    terms=appRAKETest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRAKETest.evaluate(terms,AppRAKE.class.getSimpleName());
    AppRIDFTest appRIDFTest=new AppRIDFTest();
    terms=appRIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRIDFTest.evaluate(terms,AppRIDF.class.getSimpleName());
    AppTermExTest appTermExTest=new AppTermExTest();
    terms=appTermExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTermExTest.evaluate(terms,AppTermEx.class.getSimpleName());
    AppTFIDFTest appTFIDFTest=new AppTFIDFTest();
    terms=appTFIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTFIDFTest.evaluate(terms,AppTFIDF.class.getSimpleName());
    AppTTFTest appTTFTest=new AppTTFTest();
    terms=appTTFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTTFTest.evaluate(terms,AppTTF.class.getSimpleName());
    AppWeirdnessTest appWeirdnessTest=new AppWeirdnessTest();
    terms=appWeirdnessTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appWeirdnessTest.evaluate(terms,AppWeirdness.class.getSimpleName());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      server.getCoreContainer().getCore(solrCoreName).close();
      server.getCoreContainer().shutdown();
      server.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  System.exit(0);
}"
12309,"protected void setReindex(){
  reindex=true;
}","protected void setReindex(){
  reindex=false;
}"
12310,"@Test public void benchmarking_appWeirdness() throws JATEException, IOException {
}","public void benchmarking_appWeirdness() throws JATEException, IOException {
}"
12311,"public void benchmarking_appChiSquare() throws IOException, JATEException {
}","@Test public void benchmarking_appChiSquare() throws IOException, JATEException {
}"
12312,"protected String[][] walkTokens() throws IOException {
  List<String> wordList=new ArrayList<>();
  List<String> posList=new ArrayList<>();
  while (input.incrementToken()) {
    CharTermAttribute textAtt=input.getAttribute(CharTermAttribute.class);
    OffsetAttribute offsetAtt=input.getAttribute(OffsetAttribute.class);
    char[] buffer=textAtt.buffer();
    String word=new String(buffer,0,offsetAtt.endOffset() - offsetAtt.startOffset());
    wordList.add(word);
    PayloadAttribute posAtt=input.getAttribute(PayloadAttribute.class);
    if (posAtt != null) {
      posList.add(new SentenceContext(posAtt.getPayload().utf8ToString()).getPosTag());
    }
    AttributeSource attrs=input.cloneAttributes();
    tokenAttrs.add(attrs);
  }
  if (wordList.size() != posList.size()) {
    StringBuilder sb=new StringBuilder(this.getClass().getName());
    sb.append(""String_Node_Str"").append(wordList.size()).append(""String_Node_Str"").append(posList.size()).append(""String_Node_Str"").append(""String_Node_Str"");
    throw new IOException(sb.toString());
  }
  String[] words=new String[wordList.size()];
  String[] pos=new String[posList.size()];
  for (int i=0; i < words.length; i++) {
    words[i]=wordList.get(i);
    pos[i]=posList.get(i);
  }
  clearAttributes();
  return new String[][]{words,pos};
}","protected String[][] walkTokens() throws IOException {
  List<String> wordList=new ArrayList<>();
  List<String> posList=new ArrayList<>();
  while (input.incrementToken()) {
    CharTermAttribute textAtt=input.getAttribute(CharTermAttribute.class);
    OffsetAttribute offsetAtt=input.getAttribute(OffsetAttribute.class);
    char[] buffer=textAtt.buffer();
    String word=null;
    try {
      word=new String(buffer,0,offsetAtt.endOffset() - offsetAtt.startOffset());
    }
 catch (    StringIndexOutOfBoundsException ioe) {
      LOG.error(ioe.toString());
      word=((PackedTokenAttributeImpl)offsetAtt).toString();
    }
    wordList.add(word);
    PayloadAttribute posAtt=input.getAttribute(PayloadAttribute.class);
    if (posAtt != null) {
      posList.add(new SentenceContext(posAtt.getPayload().utf8ToString()).getPosTag());
    }
    AttributeSource attrs=input.cloneAttributes();
    tokenAttrs.add(attrs);
  }
  if (wordList.size() != posList.size()) {
    StringBuilder sb=new StringBuilder(this.getClass().getName());
    sb.append(""String_Node_Str"").append(wordList.size()).append(""String_Node_Str"").append(posList.size()).append(""String_Node_Str"").append(""String_Node_Str"");
    throw new IOException(sb.toString());
  }
  String[] words=new String[wordList.size()];
  String[] pos=new String[posList.size()];
  for (int i=0; i < words.length; i++) {
    words[i]=wordList.get(i);
    pos[i]=posList.get(i);
  }
  clearAttributes();
  return new String[][]{words,pos};
}"
12313,"protected String[] walkTokens() throws IOException {
  List<String> wordList=new ArrayList<>();
  while (input.incrementToken()) {
    CharTermAttribute textAtt=input.getAttribute(CharTermAttribute.class);
    OffsetAttribute offsetAtt=input.getAttribute(OffsetAttribute.class);
    char[] buffer=textAtt.buffer();
    String word=new String(buffer,0,offsetAtt.endOffset() - offsetAtt.startOffset());
    wordList.add(word);
    AttributeSource attrs=input.cloneAttributes();
    tokenAttrs.add(attrs);
  }
  String[] words=new String[wordList.size()];
  for (int i=0; i < words.length; i++) {
    words[i]=wordList.get(i);
  }
  return words;
}","protected String[] walkTokens() throws IOException {
  List<String> wordList=new ArrayList<>();
  while (input.incrementToken()) {
    CharTermAttribute textAtt=input.getAttribute(CharTermAttribute.class);
    OffsetAttribute offsetAtt=input.getAttribute(OffsetAttribute.class);
    char[] buffer=textAtt.buffer();
    String word=null;
    try {
      word=new String(buffer,0,offsetAtt.endOffset() - offsetAtt.startOffset());
    }
 catch (    StringIndexOutOfBoundsException ioe) {
      LOG.error(ioe.toString());
      word=((PackedTokenAttributeImpl)offsetAtt).toString();
    }
    wordList.add(word);
    AttributeSource attrs=input.cloneAttributes();
    tokenAttrs.add(attrs);
  }
  String[] words=new String[wordList.size()];
  for (int i=0; i < words.length; i++) {
    words[i]=wordList.get(i);
  }
  return words;
}"
12314,"protected void write(List<JATETerm> terms) throws IOException {
  Gson gson=new Gson();
  if (outputFile == null) {
    throw new IOException(""String_Node_Str"");
  }
 else {
    Writer w=IOUtil.getUTF8Writer(outputFile);
    gson.toJson(terms,w);
    w.close();
  }
}","public void write(List<JATETerm> terms) throws IOException {
  Gson gson=new Gson();
  if (outputFile == null) {
    throw new IOException(""String_Node_Str"");
  }
 else {
    Writer w=IOUtil.getUTF8Writer(outputFile);
    gson.toJson(terms,w);
    w.close();
  }
}"
12315,"public static JATEDocument loadACLRDTECDocument(InputStream fileInputStream) throws JATEException {
  SAXParserFactory factory=SAXParserFactory.newInstance();
  SAXParser saxParser=null;
  JATEDocument jateDocument=null;
  try {
    saxParser=factory.newSAXParser();
    StringBuffer paperParagraphs=new StringBuffer();
    StringBuffer paperId=new StringBuffer();
    StringBuffer paperTitle=new StringBuffer();
    DefaultHandler handler=new DefaultHandler(){
      boolean paper=false;
      boolean title=false;
      boolean section=false;
      boolean sectionTitle=false;
      boolean paragraph=false;
      boolean reference=false;
      public void startElement(      String uri,      String localName,      String qName,      org.xml.sax.Attributes attributes) throws SAXException {
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          paper=true;
          paperId.append(attributes.getValue(""String_Node_Str""));
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          title=true;
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          section=true;
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          sectionTitle=true;
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          paragraph=true;
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          reference=true;
        }
      }
      public void endElement(      String uri,      String localName,      String qName) throws SAXException {
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          paragraph=false;
        }
      }
      public void characters(      char ch[],      int start,      int length) throws SAXException {
        if (paper) {
          paper=false;
        }
        if (title) {
          title=false;
          if (!reference) {
            paperTitle.append(new String(ch,start,length)).append(""String_Node_Str"");
          }
          reference=false;
        }
        if (section) {
          section=false;
        }
        if (sectionTitle) {
          sectionTitle=false;
        }
        if (paragraph) {
          String paragraph=new String(ch,start,length);
          paperParagraphs.append(paragraph);
        }
      }
    }
;
    saxParser.parse(fileInputStream,handler);
    StringBuffer fullText=new StringBuffer();
    fullText.append(paperTitle).append(""String_Node_Str"").append(paperParagraphs);
    String normalizedText=Normalizer.normalize(fullText.toString(),Normalizer.Form.NFD);
    normalizedText=StringEscapeUtils.unescapeXml(normalizedText);
    String cleanedText=cleanText(normalizedText);
    jateDocument=new JATEDocument(paperId.toString());
    jateDocument.setContent(cleanedText.trim());
  }
 catch (  ParserConfigurationException e) {
    throw new JATEException(""String_Node_Str"" + e.toString());
  }
catch (  SAXException e) {
    throw new JATEException(""String_Node_Str"" + e.toString());
  }
catch (  IOException ioe) {
    throw new JATEException(""String_Node_Str"" + ioe.toString());
  }
  return jateDocument;
}","public static JATEDocument loadACLRDTECDocument(InputStream fileInputStream) throws JATEException {
  return loadJATEDocFromXML(fileInputStream);
}"
12316,"static void indexJATEDocuments(Path file,JATEProperties jateProp,boolean commit) throws JATEException {
  try {
    JATEDocument jateDocument=JATEUtil.loadACLRDTECDocument(new FileInputStream(file.toFile()));
    if (jateDocument.getContent().trim().length() != 0)     JATEUtil.addNewDoc(server,jateDocument.getId(),jateDocument.getId(),jateDocument.getContent(),jateProp,commit);
  }
 catch (  FileNotFoundException ffe) {
    throw new JATEException(ffe.toString());
  }
catch (  IOException ioe) {
    throw new JATEException(String.format(""String_Node_Str"",file.toString()) + ioe.toString());
  }
catch (  SolrServerException sse) {
    throw new JATEException(String.format(""String_Node_Str"",file.toString()) + sse.toString());
  }
}","static void indexJATEDocuments(Path file,JATEProperties jateProp,boolean commit) throws JATEException {
  if (file == null || file.toString().contains(""String_Node_Str"")) {
    return;
  }
  try {
    JATEDocument jateDocument=JATEUtil.loadACLRDTECDocument(new FileInputStream(file.toFile()));
    if (jateDocument.getContent().trim().length() != 0)     JATEUtil.addNewDoc(server,jateDocument.getId(),jateDocument.getId(),jateDocument.getContent(),jateProp,commit);
  }
 catch (  FileNotFoundException ffe) {
    throw new JATEException(ffe.toString());
  }
catch (  IOException ioe) {
    throw new JATEException(String.format(""String_Node_Str"",file.toString()) + ioe.toString());
  }
catch (  SolrServerException sse) {
    throw new JATEException(String.format(""String_Node_Str"",file.toString()) + sse.toString());
  }
}"
12317,"/** 
 * Corpus indexing and candidate term (at index-time)
 * @param corpusDir, ACL RD-TEC cleansed text xml.zip corpus directory
 * @return List<JATETerm>
 * @throws JATEException
 */
public void indexAndExtract(Path corpusDir) throws JATEException {
  List<Path> files=JATEUtil.loadFiles(corpusDir);
  Collections.sort(files);
  LOG.info(""String_Node_Str"" + files.size() + ""String_Node_Str"");
  int count=0;
  for (  Path file : files) {
    try {
      if (!file.toString().contains(""String_Node_Str"")) {
        indexJATEDocuments(file,jateProp,false);
        count++;
        if (count % 100 == 0)         LOG.info(""String_Node_Str"" + count + ""String_Node_Str""+ files.size());
      }
    }
 catch (    NullPointerException e) {
      e.printStackTrace();
    }
  }
  try {
    server.commit();
    LOG.info(""String_Node_Str"");
  }
 catch (  SolrServerException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Corpus indexing and candidate term (at index-time)
 * @param corpusDir, ACL RD-TEC cleansed text xml.zip corpus directory
 * @return List<JATETerm>
 * @throws JATEException
 */
public void indexAndExtract(Path corpusDir) throws JATEException {
  List<Path> files=JATEUtil.loadFiles(corpusDir);
  LOG.info(""String_Node_Str"" + files.size() + ""String_Node_Str"");
  int count=0;
  for (  Path file : files) {
    try {
      indexJATEDocuments(file,jateProp,false);
      count++;
      if (count % 100 == 0)       LOG.info(""String_Node_Str"" + count + ""String_Node_Str""+ files.size());
    }
 catch (    NullPointerException e) {
      e.printStackTrace();
    }
  }
  try {
    server.commit();
    LOG.info(""String_Node_Str"");
  }
 catch (  SolrServerException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}"
12318,"@Override public List<JATETerm> execute(Collection<String> candidates) throws JATEException {
  AbstractFeature feature=features.get(FrequencyTermBased.class.getName() + SUFFIX_WORD);
  validateFeature(feature,FrequencyTermBased.class);
  FrequencyTermBased fFeatureWords=(FrequencyTermBased)feature;
  AbstractFeature feature2=features.get(FrequencyTermBased.class.getName() + SUFFIX_TERM);
  validateFeature(feature2,FrequencyTermBased.class);
  FrequencyTermBased fFeatureTerms=(FrequencyTermBased)feature2;
  AbstractFeature tciFeature=features.get(TermComponentIndex.class.getName());
  validateFeature(tciFeature,TermComponentIndex.class);
  TermComponentIndex fFeatureTermCompIndex=(TermComponentIndex)tciFeature;
  int cores=Runtime.getRuntime().availableProcessors();
  int maxPerWorker=candidates.size() / cores;
  StringBuilder msg=new StringBuilder(""String_Node_Str"");
  msg.append(cores).append(""String_Node_Str"" + candidates.size()).append(""String_Node_Str"").append(""String_Node_Str"").append(maxPerWorker);
  LOG.info(msg.toString());
  ForkJoinPool forkJoinPool=new ForkJoinPool(cores);
  RAKEWorker worker=new RAKEWorker(new ArrayList<>(candidates),maxPerWorker,fFeatureWords,fFeatureTerms,fFeatureTermCompIndex);
  List<JATETerm> result=forkJoinPool.invoke(worker);
  Collections.sort(result);
  LOG.info(""String_Node_Str"");
  return result;
}","@Override public List<JATETerm> execute(Collection<String> candidates) throws JATEException {
  AbstractFeature feature=features.get(FrequencyTermBased.class.getName() + SUFFIX_WORD);
  validateFeature(feature,FrequencyTermBased.class);
  FrequencyTermBased fFeatureWords=(FrequencyTermBased)feature;
  AbstractFeature feature2=features.get(FrequencyTermBased.class.getName() + SUFFIX_TERM);
  validateFeature(feature2,FrequencyTermBased.class);
  FrequencyTermBased fFeatureTerms=(FrequencyTermBased)feature2;
  AbstractFeature tciFeature=features.get(TermComponentIndex.class.getName());
  validateFeature(tciFeature,TermComponentIndex.class);
  TermComponentIndex fFeatureTermCompIndex=(TermComponentIndex)tciFeature;
  int cores=Runtime.getRuntime().availableProcessors();
  int maxPerWorker=candidates.size() / cores;
  if (maxPerWorker == 0)   maxPerWorker=50;
  StringBuilder msg=new StringBuilder(""String_Node_Str"");
  msg.append(cores).append(""String_Node_Str"" + candidates.size()).append(""String_Node_Str"").append(""String_Node_Str"").append(maxPerWorker);
  LOG.info(msg.toString());
  ForkJoinPool forkJoinPool=new ForkJoinPool(cores);
  RAKEWorker worker=new RAKEWorker(new ArrayList<>(candidates),Integer.MAX_VALUE,fFeatureWords,fFeatureTerms,fFeatureTermCompIndex);
  List<JATETerm> result=forkJoinPool.invoke(worker);
  Collections.sort(result);
  LOG.info(""String_Node_Str"");
  return result;
}"
12319,"@Override protected List<JATETerm> computeSingleWorker(List<String> candidates){
  List<JATETerm> result=new ArrayList<>();
  int count=0;
  for (  String tString : candidates) {
    String[] elements=tString.split(""String_Node_Str"");
    double score=0;
    for (    String e : elements) {
      int freq=fFeatureWords.getTTF(e);
      if (freq == 0)       continue;
      int degree=freq;
      List<Pair<String,Integer>> parentTerms=fTermCompIndex.getSorted(e);
      for (      Pair<String,Integer> pTerm : parentTerms) {
        String pTermStr=pTerm.getKey();
        if (pTerm.getValue() == 1)         continue;
        int pTF=fFeatureTerms.getTTF(pTermStr);
        String[] pTermElements=pTermStr.split(""String_Node_Str"");
        for (        String ep : pTermElements) {
          if (ep.equals(e))           continue;
          degree+=pTF;
        }
      }
      double wScore=(double)degree / freq;
      score+=wScore;
    }
    JATETerm term=new JATETerm(tString,score);
    result.add(term);
    count++;
    if (count % 2000 == 0) {
      LOG.info(""String_Node_Str"" + count + ""String_Node_Str""+ candidates.size());
    }
  }
  return result;
}","@Override protected List<JATETerm> computeSingleWorker(List<String> candidates){
  List<JATETerm> result=new ArrayList<>();
  int count=0;
  for (  String tString : candidates) {
    if (tString.equals(""String_Node_Str"") || tString.equals(""String_Node_Str""))     System.out.println(""String_Node_Str"");
    String[] elements=tString.split(""String_Node_Str"");
    double score=0;
    for (    String e : elements) {
      int freq=fFeatureWords.getTTF(e);
      if (freq == 0)       continue;
      int degree=freq;
      List<Pair<String,Integer>> parentTerms=fTermCompIndex.getSorted(e);
      for (      Pair<String,Integer> pTerm : parentTerms) {
        String pTermStr=pTerm.getKey();
        if (pTerm.getValue() == 1)         continue;
        int pTF=fFeatureTerms.getTTF(pTermStr);
        String[] pTermElements=pTermStr.split(""String_Node_Str"");
        for (        String ep : pTermElements) {
          if (ep.equals(e))           continue;
          degree+=pTF;
        }
      }
      double wScore=(double)degree / freq;
      score+=wScore;
    }
    JATETerm term=new JATETerm(tString,score);
    result.add(term);
    count++;
    if (count % 2000 == 0) {
      LOG.info(""String_Node_Str"" + count + ""String_Node_Str""+ candidates.size());
    }
  }
  return result;
}"
12320,"protected void setReindex(){
  reindex=true;
}","protected void setReindex(){
  reindex=false;
}"
12321,"@Test public void benchmarking_appCValue() throws IOException, JATEException {
}","public void benchmarking_appCValue() throws IOException, JATEException {
}"
12322,"@Test public void benchmarking_appWeirdness() throws JATEException, IOException {
}","public void benchmarking_appWeirdness() throws JATEException, IOException {
}"
12323,"@Test public void benchmarking_appGlossEx() throws JATEException, IOException {
}","public void benchmarking_appGlossEx() throws JATEException, IOException {
}"
12324,"@Test public void benchmarking_appTTF() throws JATEException, IOException {
}","public void benchmarking_appTTF() throws JATEException, IOException {
}"
12325,"@Test public void validate_indexing(){
  ModifiableSolrParams params=new ModifiableSolrParams();
  params.set(""String_Node_Str"",""String_Node_Str"");
  try {
    QueryResponse qResp=server.query(params);
    SolrDocumentList docList=qResp.getResults();
    assert(docList.getNumFound() == 2000);
  }
 catch (  SolrServerException e) {
    e.printStackTrace();
  }
catch (  IOException ioe) {
    ioe.printStackTrace();
  }
}","public void validate_indexing(){
  ModifiableSolrParams params=new ModifiableSolrParams();
  params.set(""String_Node_Str"",""String_Node_Str"");
  try {
    QueryResponse qResp=server.query(params);
    SolrDocumentList docList=qResp.getResults();
    assert(docList.getNumFound() == 2000);
  }
 catch (  SolrServerException e) {
    e.printStackTrace();
  }
catch (  IOException ioe) {
    ioe.printStackTrace();
  }
}"
12326,"@Test public void benchmarking_appChiSquare() throws IOException, JATEException {
}","public void benchmarking_appChiSquare() throws IOException, JATEException {
}"
12327,"@Test public void benchmarking_appATTF() throws JATEException, IOException {
}","public void benchmarking_appATTF() throws JATEException, IOException {
}"
12328,"@Test public void benchmarking_appTermEx() throws JATEException, IOException {
}","public void benchmarking_appTermEx() throws JATEException, IOException {
}"
12329,"@Test public void benchmarking_appRIDF() throws JATEException, IOException {
}","public void benchmarking_appRIDF() throws JATEException, IOException {
}"
12330,"@Test public void benchmarking_appTFIDF() throws JATEException, IOException {
}","public void benchmarking_appTFIDF() throws JATEException, IOException {
}"
12331,"protected String[][] walkTokens() throws IOException {
  List<String> wordList=new ArrayList<>();
  List<String> posList=new ArrayList<>();
  while (input.incrementToken()) {
    CharTermAttribute textAtt=input.getAttribute(CharTermAttribute.class);
    OffsetAttribute offsetAtt=input.getAttribute(OffsetAttribute.class);
    char[] buffer=textAtt.buffer();
    String word=null;
    try {
      word=new String(buffer,0,offsetAtt.endOffset() - offsetAtt.startOffset());
    }
 catch (    StringIndexOutOfBoundsException ioe) {
      LOG.error(ioe.toString());
      word=((PackedTokenAttributeImpl)offsetAtt).toString();
    }
    wordList.add(word);
    PayloadAttribute posAtt=input.getAttribute(PayloadAttribute.class);
    if (posAtt != null) {
      posList.add(new SentenceContext(posAtt.getPayload().utf8ToString()).getPosTag());
    }
    AttributeSource attrs=input.cloneAttributes();
    tokenAttrs.add(attrs);
  }
  if (wordList.size() != posList.size()) {
    StringBuilder sb=new StringBuilder(this.getClass().getName());
    sb.append(""String_Node_Str"").append(wordList.size()).append(""String_Node_Str"").append(posList.size()).append(""String_Node_Str"").append(""String_Node_Str"");
    throw new IOException(sb.toString());
  }
  String[] words=new String[wordList.size()];
  String[] pos=new String[posList.size()];
  for (int i=0; i < words.length; i++) {
    words[i]=wordList.get(i);
    pos[i]=posList.get(i);
  }
  clearAttributes();
  return new String[][]{words,pos};
}","protected String[][] walkTokens() throws IOException {
  List<String> wordList=new ArrayList<>();
  List<String> posList=new ArrayList<>();
  while (input.incrementToken()) {
    CharTermAttribute textAtt=input.getAttribute(CharTermAttribute.class);
    OffsetAttribute offsetAtt=input.getAttribute(OffsetAttribute.class);
    char[] buffer=textAtt.buffer();
    String word=null;
    try {
      word=new String(buffer,0,offsetAtt.endOffset() - offsetAtt.startOffset());
    }
 catch (    StringIndexOutOfBoundsException ioe) {
      LOG.error(ExceptionUtils.getFullStackTrace(ioe));
      word=offsetAtt.toString();
    }
    wordList.add(word);
    PayloadAttribute posAtt=input.getAttribute(PayloadAttribute.class);
    if (posAtt != null) {
      posList.add(new SentenceContext(posAtt.getPayload().utf8ToString()).getPosTag());
    }
    AttributeSource attrs=input.cloneAttributes();
    tokenAttrs.add(attrs);
  }
  if (wordList.size() != posList.size()) {
    StringBuilder sb=new StringBuilder(this.getClass().getName());
    sb.append(""String_Node_Str"").append(wordList.size()).append(""String_Node_Str"").append(posList.size()).append(""String_Node_Str"").append(""String_Node_Str"");
    throw new IOException(sb.toString());
  }
  String[] words=new String[wordList.size()];
  String[] pos=new String[posList.size()];
  for (int i=0; i < words.length; i++) {
    words[i]=wordList.get(i);
    pos[i]=posList.get(i);
  }
  clearAttributes();
  return new String[][]{words,pos};
}"
12332,"protected String[] walkTokens() throws IOException {
  List<String> wordList=new ArrayList<>();
  while (input.incrementToken()) {
    CharTermAttribute textAtt=input.getAttribute(CharTermAttribute.class);
    OffsetAttribute offsetAtt=input.getAttribute(OffsetAttribute.class);
    char[] buffer=textAtt.buffer();
    String word=null;
    try {
      word=new String(buffer,0,offsetAtt.endOffset() - offsetAtt.startOffset());
    }
 catch (    StringIndexOutOfBoundsException ioe) {
      LOG.error(ioe.toString());
      word=((PackedTokenAttributeImpl)offsetAtt).toString();
    }
    wordList.add(word);
    AttributeSource attrs=input.cloneAttributes();
    tokenAttrs.add(attrs);
  }
  String[] words=new String[wordList.size()];
  for (int i=0; i < words.length; i++) {
    words[i]=wordList.get(i);
  }
  return words;
}","protected String[] walkTokens() throws IOException {
  List<String> wordList=new ArrayList<>();
  while (input.incrementToken()) {
    CharTermAttribute textAtt=input.getAttribute(CharTermAttribute.class);
    OffsetAttribute offsetAtt=input.getAttribute(OffsetAttribute.class);
    char[] buffer=textAtt.buffer();
    String word=null;
    try {
      word=new String(buffer,0,offsetAtt.endOffset() - offsetAtt.startOffset());
    }
 catch (    StringIndexOutOfBoundsException ioe) {
      LOG.error(ioe.toString());
      word=offsetAtt.toString();
    }
    wordList.add(word);
    AttributeSource attrs=input.cloneAttributes();
    tokenAttrs.add(attrs);
  }
  String[] words=new String[wordList.size()];
  for (int i=0; i < words.length; i++) {
    words[i]=wordList.get(i);
  }
  return words;
}"
12333,"@Override public boolean incrementToken() throws IOException {
  if (input.incrementToken()) {
    String tok=new String(termAtt.buffer(),0,termAtt.length());
    tok=tok.trim();
    if (tok.length() > 0) {
      String normalised=stripPunctuations(tok,stripAnySymbols,stripLeadingSymbols,stripTrailingSymbols);
      if (normalised.length() == 0)       clearAttributes();
 else       termAtt.setEmpty().append(tok);
    }
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean incrementToken() throws IOException {
  if (input.incrementToken()) {
    String tok=new String(termAtt.buffer(),0,termAtt.length());
    tok=tok.trim();
    if (tok.length() > 0) {
      String normalised=stripPunctuations(tok,stripAnySymbols,stripLeadingSymbols,stripTrailingSymbols);
      if (normalised.length() == 0)       clearAttributes();
 else       termAtt.setEmpty().append(normalised);
    }
    return true;
  }
 else {
    return false;
  }
}"
12334,"/** 
 * To run the test class via <p> mvn exec:java -Dexec.mainClass=""uk.ac.shef.dcs.jate.app.AppATEACLRDTECTest"" -Dexec.classpathScope=""test""
 * @param args, true or false for indexing
 * @throws JATEException
 */
public static void main(String[] args) throws JATEException {
  try {
    AppATEACLRDTECTest appATETest=new AppATEACLRDTECTest(solrHome.toString(),solrCoreName);
    boolean reindex=true;
    if (args.length > 0) {
      try {
        reindex=Boolean.valueOf(args[0]);
      }
 catch (      Exception e) {
        throw new JATEException(e);
      }
    }
    long numOfDocs=validate_indexing();
    LOG.info(""String_Node_Str"");
    if (numOfDocs == 0 || reindex) {
      long startTime=System.currentTimeMillis();
      appATETest.indexAndExtract(corpusDir);
      long endTime=System.currentTimeMillis();
      LOG.info(String.format(""String_Node_Str"",(endTime - startTime)));
    }
    LOG.info(""String_Node_Str"");
    List<JATETerm> terms=null;
    AppATTFTest appATTFTest=new AppATTFTest();
    terms=appATTFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appATTFTest.evaluate(terms,AppATTF.class.getSimpleName());
    AppChiSquareTest appChiSquareTest=new AppChiSquareTest();
    terms=appChiSquareTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appChiSquareTest.evaluate(terms,AppChiSquare.class.getSimpleName());
    AppCValueTest appCValueTest=new AppCValueTest();
    terms=appCValueTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appCValueTest.evaluate(terms,AppCValue.class.getSimpleName());
    AppGlossExTest appGlossExTest=new AppGlossExTest();
    terms=appGlossExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appGlossExTest.evaluate(terms,AppGlossEx.class.getSimpleName());
    AppRAKETest appRAKETest=new AppRAKETest();
    terms=appRAKETest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRAKETest.evaluate(terms,AppRAKE.class.getSimpleName());
    AppRIDFTest appRIDFTest=new AppRIDFTest();
    terms=appRIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRIDFTest.evaluate(terms,AppRIDF.class.getSimpleName());
    AppTermExTest appTermExTest=new AppTermExTest();
    terms=appTermExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTermExTest.evaluate(terms,AppTermEx.class.getSimpleName());
    AppTFIDFTest appTFIDFTest=new AppTFIDFTest();
    terms=appTFIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTFIDFTest.evaluate(terms,AppTFIDF.class.getSimpleName());
    AppTTFTest appTTFTest=new AppTTFTest();
    terms=appTTFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTTFTest.evaluate(terms,AppTTF.class.getSimpleName());
    AppWeirdnessTest appWeirdnessTest=new AppWeirdnessTest();
    terms=appWeirdnessTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appWeirdnessTest.evaluate(terms,AppWeirdness.class.getSimpleName());
  }
 catch (  Exception e) {
    throw new JATEException(e);
  }
 finally {
    try {
      server.getCoreContainer().getCore(solrCoreName).close();
      server.getCoreContainer().shutdown();
      server.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
catch (    SolrException solrEx) {
      solrEx.printStackTrace();
    }
 finally {
      System.exit(0);
    }
  }
  unlock();
  System.exit(0);
}","/** 
 * To run the test class via <p> mvn exec:java -Dexec.mainClass=""uk.ac.shef.dcs.jate.app.AppATEACLRDTECTest"" -Dexec.classpathScope=""test""
 * @param args, true or false for indexing
 * @throws JATEException
 */
public static void main(String[] args) throws JATEException {
  try {
    AppATEACLRDTECTest appATETest=new AppATEACLRDTECTest(solrHome.toString(),solrCoreName);
    boolean reindex=true;
    if (args.length > 0) {
      try {
        reindex=Boolean.valueOf(args[0]);
      }
 catch (      Exception e) {
        throw new JATEException(e);
      }
    }
    long numOfDocs=validate_indexing();
    LOG.info(""String_Node_Str"");
    if (numOfDocs == 0 || reindex) {
      long startTime=System.currentTimeMillis();
      appATETest.indexAndExtract(corpusDir);
      long endTime=System.currentTimeMillis();
      LOG.info(String.format(""String_Node_Str"",(endTime - startTime)));
    }
    LOG.info(""String_Node_Str"");
    List<JATETerm> terms=null;
    AppATTFTest appATTFTest=new AppATTFTest();
    terms=appATTFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appATTFTest.evaluate(terms,AppATTF.class.getSimpleName());
    AppChiSquareTest appChiSquareTest=new AppChiSquareTest();
    terms=appChiSquareTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appChiSquareTest.evaluate(terms,AppChiSquare.class.getSimpleName());
    AppCValueTest appCValueTest=new AppCValueTest();
    terms=appCValueTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appCValueTest.evaluate(terms,AppCValue.class.getSimpleName());
    AppGlossExTest appGlossExTest=new AppGlossExTest();
    terms=appGlossExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appGlossExTest.evaluate(terms,AppGlossEx.class.getSimpleName());
    AppRAKETest appRAKETest=new AppRAKETest();
    terms=appRAKETest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRAKETest.evaluate(terms,AppRAKE.class.getSimpleName());
    AppRIDFTest appRIDFTest=new AppRIDFTest();
    terms=appRIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRIDFTest.evaluate(terms,AppRIDF.class.getSimpleName());
    AppTermExTest appTermExTest=new AppTermExTest();
    terms=appTermExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTermExTest.evaluate(terms,AppTermEx.class.getSimpleName());
    AppTFIDFTest appTFIDFTest=new AppTFIDFTest();
    terms=appTFIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTFIDFTest.evaluate(terms,AppTFIDF.class.getSimpleName());
    AppTTFTest appTTFTest=new AppTTFTest();
    terms=appTTFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTTFTest.evaluate(terms,AppTTF.class.getSimpleName());
    AppWeirdnessTest appWeirdnessTest=new AppWeirdnessTest();
    terms=appWeirdnessTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appWeirdnessTest.evaluate(terms,AppWeirdness.class.getSimpleName());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      server.getCoreContainer().getCore(solrCoreName).close();
      server.getCoreContainer().shutdown();
      server.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
catch (    SolrException solrEx) {
      solrEx.printStackTrace();
    }
 finally {
      System.exit(0);
    }
  }
  unlock();
  System.exit(0);
}"
12335,"public EnglishLemmatisationFilter(EngLemmatiser lemmatiser,TokenStream input){
  super(input);
  this.lemmatiser=lemmatiser;
  tagLookUp=new HashMap<>();
  tagLookUp.put(""String_Node_Str"",1);
  tagLookUp.put(""String_Node_Str"",1);
  tagLookUp.put(""String_Node_Str"",1);
  tagLookUp.put(""String_Node_Str"",1);
  tagLookUp.put(""String_Node_Str"",2);
  tagLookUp.put(""String_Node_Str"",2);
  tagLookUp.put(""String_Node_Str"",2);
  tagLookUp.put(""String_Node_Str"",2);
  tagLookUp.put(""String_Node_Str"",2);
  tagLookUp.put(""String_Node_Str"",2);
  tagLookUp.put(""String_Node_Str"",3);
  tagLookUp.put(""String_Node_Str"",3);
  tagLookUp.put(""String_Node_Str"",3);
  tagLookUp.put(""String_Node_Str"",4);
  tagLookUp.put(""String_Node_Str"",4);
  tagLookUp.put(""String_Node_Str"",4);
}","public EnglishLemmatisationFilter(EngLemmatiser dragontoolLemmatiser,TokenStream input){
  super(input);
  lemmatiser=new Lemmatiser(dragontoolLemmatiser);
}"
12336,"@Override public boolean incrementToken() throws IOException {
  if (input.incrementToken()) {
    String tok=new String(termAtt.buffer(),0,termAtt.length());
    BytesRef payload=exitingPayload.getPayload();
    String pos=""String_Node_Str"";
    if (payload != null) {
      String attachedInfo=payload.utf8ToString();
      int index=attachedInfo.lastIndexOf(""String_Node_Str"");
      if (index != -1) {
        pos=attachedInfo.substring(index + 2);
        int end=pos.indexOf(""String_Node_Str"");
        if (end != -1)         pos=pos.substring(0,end);
      }
    }
    if (tok.length() > 2) {
      tok=normalize(tok,""String_Node_Str"");
    }
    termAtt.setEmpty().append(tok);
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean incrementToken() throws IOException {
  if (input.incrementToken()) {
    String tok=new String(termAtt.buffer(),0,termAtt.length());
    BytesRef payload=exitingPayload.getPayload();
    String pos=""String_Node_Str"";
    if (payload != null) {
      String attachedInfo=payload.utf8ToString();
      int index=attachedInfo.lastIndexOf(""String_Node_Str"");
      if (index != -1) {
        pos=attachedInfo.substring(index + 2);
        int end=pos.indexOf(""String_Node_Str"");
        if (end != -1)         pos=pos.substring(0,end);
      }
    }
    if (tok.length() > 2) {
      tok=lemmatiser.normalize(tok,""String_Node_Str"");
    }
    termAtt.setEmpty().append(tok);
    return true;
  }
 else {
    return false;
  }
}"
12337,"public static List<String> loadACLRD(String file,boolean lowercase,boolean normalize) throws IOException {
  List<String> raw=FileUtils.readLines(new File(file));
  List<String> terms=new ArrayList<>(raw.size() - 1);
  int count=0;
  for (  String r : raw) {
    if (count == 0) {
      count++;
      continue;
    }
    String[] splits=r.split(""String_Node_Str"");
    if (splits[2].equals(""String_Node_Str""))     continue;
    terms.add(splits[1].trim());
  }
  return terms;
}","public static List<String> loadACLRD(String file) throws IOException {
  List<String> raw=FileUtils.readLines(new File(file));
  List<String> terms=new ArrayList<>(raw.size() - 1);
  int count=0;
  for (  String r : raw) {
    if (count == 0) {
      count++;
      continue;
    }
    String[] splits=r.split(""String_Node_Str"");
    if (splits[2].equals(""String_Node_Str""))     continue;
    terms.add(splits[1].trim());
  }
  return terms;
}"
12338,"public static List<String> loadGenia(File file,boolean lowercase,boolean normalize) throws IOException {
  List<String> terms=FileUtils.readLines(file);
  return prune(terms,lowercase,normalize);
}","/** 
 * @param file
 * @return
 */
public static List<String> loadGenia(String file) throws IOException {
  List<String> terms=FileUtils.readLines(new File(file));
  return terms;
}"
12339,"public static void createReportACLRD(String ateOutputFolder,String gsFile,String outFile,boolean ignoreSymbols,boolean ignoreDigits,boolean lowercase,int minChar,int maxChar,int minTokens,int maxTokens,int... ranks) throws IOException {
  PrintWriter p=new PrintWriter(outFile);
  List<String> gs=GSLoader.loadACLRD(gsFile,true,true);
  Map<String,double[]> scores=new HashMap<>();
  for (  File f : new File(ateOutputFolder).listFiles()) {
    String name=f.getName();
    if (name.charAt(0) == '.')     continue;
    System.out.println(f);
    List<String> terms=ATEResultLoader.load(f.toString());
    double[] s=computePrecisionAtRank(gs,terms,ignoreSymbols,ignoreDigits,lowercase,minChar,maxChar,minTokens,maxTokens,ranks);
    scores.put(name,s);
  }
  StringBuilder sb=new StringBuilder();
  for (  int i : ranks) {
    sb.append(""String_Node_Str"").append(i);
  }
  sb.append(""String_Node_Str"");
  for (  Map.Entry<String,double[]> en : scores.entrySet()) {
    sb.append(en.getKey()).append(""String_Node_Str"");
    double[] s=en.getValue();
    for (int i=0; i < ranks.length; i++) {
      sb.append(s[i]).append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
  }
  p.println(sb.toString());
  p.close();
}","public static void createReportACLRD(Lemmatiser lemmatiser,String ateOutputFolder,String gsFile,String outFile,boolean ignoreSymbols,boolean ignoreDigits,boolean lowercase,int minChar,int maxChar,int minTokens,int maxTokens,int... ranks) throws IOException, JATEException {
  PrintWriter p=new PrintWriter(outFile);
  List<String> gs=GSLoader.loadACLRD(gsFile);
  Map<String,double[]> scores=new HashMap<>();
  for (  File f : new File(ateOutputFolder).listFiles()) {
    String name=f.getName();
    if (name.charAt(0) == '.')     continue;
    System.out.println(f);
    List<String> terms=ATEResultLoader.load(f.toString());
    double[] s=computePrecisionAtRank(lemmatiser,gs,terms,ignoreSymbols,ignoreDigits,lowercase,minChar,maxChar,minTokens,maxTokens,ranks);
    scores.put(name,s);
  }
  StringBuilder sb=new StringBuilder();
  for (  int i : ranks) {
    sb.append(""String_Node_Str"").append(i);
  }
  sb.append(""String_Node_Str"");
  for (  Map.Entry<String,double[]> en : scores.entrySet()) {
    sb.append(en.getKey()).append(""String_Node_Str"");
    double[] s=en.getValue();
    for (int i=0; i < ranks.length; i++) {
      sb.append(s[i]).append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
  }
  p.println(sb.toString());
  p.close();
}"
12340,"/** 
 * prune term list for benchmarking this methods enable to calculate the agreement of two term set on a strict or lenient basis
 * @param terms, term list to be pruned
 * @param ignoreSymbols, remove symbols
 * @param ignoreDigits, remove digits
 * @param minChar, minimum characters allowed
 * @param maxChar, maximum characters allowed
 * @param minTokens, minimum tokens allowed
 * @param maxTokens, maximum tokens allowed
 * @return List, list of normalised term set
 */
public static List<String> prune(List<String> terms,boolean ignoreSymbols,boolean ignoreDigits,boolean lowercase,int minChar,int maxChar,int minTokens,int maxTokens){
  List<String> result=new ArrayList<>();
  for (  String term : terms) {
    if (ignoreDigits)     term=term.replaceAll(digitsPattern,""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
    if (ignoreSymbols)     term=term.replaceAll(symbolsPattern,""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
    term=term.trim();
    if (term.length() >= minChar && term.length() <= maxChar) {
      int tokens=term.split(""String_Node_Str"").length;
      if (tokens >= minTokens && tokens <= maxTokens)       if (lowercase) {
        result.add(term.toLowerCase());
      }
 else {
        result.add(term);
      }
    }
  }
  return result;
}","/** 
 * prune term list for benchmarking this methods enable to calculate the agreement of two term set on a strict or lenient basis
 * @param terms, term list to be pruned
 * @param ignoreSymbols, remove symbols
 * @param ignoreDigits, remove digits
 * @param minChar, minimum characters allowed
 * @param maxChar, maximum characters allowed
 * @param minTokens, minimum tokens allowed
 * @param maxTokens, maximum tokens allowed
 * @return List, list of normalised term set
 */
public static List<String> prune(List<String> terms,boolean ignoreSymbols,boolean ignoreDigits,boolean lowercase,int minChar,int maxChar,int minTokens,int maxTokens){
  List<String> result=new ArrayList<>();
  for (  String term : terms) {
    if (ignoreDigits)     term=term.replaceAll(digitsPattern,""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
    if (ignoreSymbols)     term=term.replaceAll(symbolsPattern,""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
    int start=0, end=term.length();
    for (int i=0; i < term.length(); i++) {
      if (Character.isLetterOrDigit(term.charAt(i))) {
        start=i;
        break;
      }
    }
    for (int i=term.length() - 1; i > -1; i--) {
      if (Character.isLetterOrDigit(term.charAt(i))) {
        end=i + 1;
        break;
      }
    }
    term=term.substring(start,end).trim();
    if (term.length() >= minChar && term.length() <= maxChar) {
      int tokens=term.split(""String_Node_Str"").length;
      if (tokens >= minTokens && tokens <= maxTokens)       if (lowercase) {
        result.add(term.toLowerCase());
      }
 else {
        result.add(term);
      }
    }
  }
  return result;
}"
12341,"public static void main(String[] args) throws IOException {
  if (args[3].equals(""String_Node_Str"")) {
    createReportGenia(args[0],args[1],args[2],true,false,true,2,150,1,5,50,100,500,1000,5000,10000);
    System.out.println(""String_Node_Str"");
  }
 else {
    createReportACLRD(args[0],args[1],args[2],true,false,true,2,150,1,5,50,100,500,1000,5000,10000);
    System.out.println();
  }
}","public static void main(String[] args) throws IOException, JATEException {
  Lemmatiser lem=new Lemmatiser(new EngLemmatiser(args[4],false,false));
  if (args[3].equals(""String_Node_Str"")) {
    createReportGenia(lem,args[0],args[1],args[2],true,false,true,2,100,1,10,50,100,500,1000,5000,10000);
  }
 else {
    createReportACLRD(lem,args[0],args[1],args[2],true,false,true,2,100,1,10,50,100,500,1000,5000,10000);
  }
}"
12342,"public static void createReportGenia(String ateOutputFolder,String gsFile,String outFile,boolean ignoreSymbols,boolean ignoreDigits,boolean lowercase,int minChar,int maxChar,int minTokens,int maxTokens,int... ranks) throws IOException {
  PrintWriter p=new PrintWriter(outFile);
  List<String> gs=GSLoader.loadGenia(gsFile,true,true);
  Map<String,double[]> scores=new HashMap<>();
  for (  File f : new File(ateOutputFolder).listFiles()) {
    String name=f.getName();
    if (name.charAt(0) == '.')     continue;
    System.out.println(f);
    List<String> terms=ATEResultLoader.load(f.toString());
    double[] s=computePrecisionAtRank(gs,terms,ignoreSymbols,ignoreDigits,lowercase,minChar,maxChar,minTokens,maxTokens,ranks);
    scores.put(name,s);
  }
  StringBuilder sb=new StringBuilder();
  for (  int i : ranks) {
    sb.append(""String_Node_Str"").append(i);
  }
  sb.append(""String_Node_Str"");
  for (  Map.Entry<String,double[]> en : scores.entrySet()) {
    sb.append(en.getKey()).append(""String_Node_Str"");
    double[] s=en.getValue();
    for (int i=0; i < ranks.length; i++) {
      sb.append(s[i]).append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
  }
  p.println(sb.toString());
  p.close();
}","public static void createReportGenia(Lemmatiser lemmatiser,String ateOutputFolder,String gsFile,String outFile,boolean ignoreSymbols,boolean ignoreDigits,boolean lowercase,int minChar,int maxChar,int minTokens,int maxTokens,int... ranks) throws IOException {
  PrintWriter p=new PrintWriter(outFile);
  List<String> gs=GSLoader.loadGenia(gsFile);
  Map<String,double[]> scores=new HashMap<>();
  for (  File f : new File(ateOutputFolder).listFiles()) {
    String name=f.getName();
    if (name.charAt(0) == '.')     continue;
    System.out.println(f);
    List<String> terms=ATEResultLoader.load(f.toString());
    double[] s=computePrecisionAtRank(lemmatiser,gs,terms,ignoreSymbols,ignoreDigits,lowercase,minChar,maxChar,minTokens,maxTokens,ranks);
    scores.put(name,s);
  }
  StringBuilder sb=new StringBuilder();
  for (  int i : ranks) {
    sb.append(""String_Node_Str"").append(i);
  }
  sb.append(""String_Node_Str"");
  for (  Map.Entry<String,double[]> en : scores.entrySet()) {
    sb.append(en.getKey()).append(""String_Node_Str"");
    double[] s=en.getValue();
    for (int i=0; i < ranks.length; i++) {
      sb.append(s[i]).append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
  }
  p.println(sb.toString());
  p.close();
}"
12343,"/** 
 * compute pre-configured top Ks precision with normalisation for both gold standard spans and ranked terms
 * @param gs, gold standards
 * @param terms, extracted results
 * @param ignoreSymbols, remove symbols
 * @param ignoreDigits, remove digits
 * @param minChar,
 * @param maxChar
 * @param minTokens
 * @param maxTokens
 * @param ranks
 * @return
 */
public static double[] computePrecisionAtRank(List<String> gs,List<String> terms,boolean ignoreSymbols,boolean ignoreDigits,boolean lowercase,int minChar,int maxChar,int minTokens,int maxTokens,int... ranks){
  gs=stem(gs);
  gs=prune(gs,ignoreSymbols,ignoreDigits,lowercase,minChar,maxChar,minTokens,maxTokens);
  terms=prune(terms,ignoreSymbols,ignoreDigits,lowercase,minChar,maxChar,minTokens,maxTokens);
  double[] scores=new double[ranks.length];
  for (int i=0; i < ranks.length; i++) {
    double p=precision(gs,terms.subList(0,ranks[i]));
    scores[i]=round(p,2);
  }
  return scores;
}","/** 
 * compute pre-configured top Ks precision with normalisation for both gold standard spans and ranked terms
 * @param gs, gold standards
 * @param terms, extracted results
 * @param ignoreSymbols, remove symbols
 * @param ignoreDigits, remove digits
 * @param minChar,
 * @param maxChar
 * @param minTokens
 * @param maxTokens
 * @param ranks
 * @return
 */
public static double[] computePrecisionAtRank(Lemmatiser lemmatiser,List<String> gs,List<String> terms,boolean ignoreSymbols,boolean ignoreDigits,boolean lowercase,int minChar,int maxChar,int minTokens,int maxTokens,int... ranks){
  gs=prune(gs,ignoreSymbols,ignoreDigits,lowercase,minChar,maxChar,minTokens,maxTokens);
  gs=normalize(gs,lemmatiser);
  terms=prune(terms,ignoreSymbols,ignoreDigits,lowercase,minChar,maxChar,minTokens,maxTokens);
  double[] scores=new double[ranks.length];
  for (int i=0; i < ranks.length; i++) {
    double p=precision(gs,terms.subList(0,ranks[i]));
    scores[i]=round(p,2);
  }
  return scores;
}"
12344,"protected String[] walkTokens() throws IOException {
  List<String> wordList=new ArrayList<>();
  while (input.incrementToken()) {
    CharTermAttribute textAtt=input.getAttribute(CharTermAttribute.class);
    OffsetAttribute offsetAtt=input.getAttribute(OffsetAttribute.class);
    char[] buffer=textAtt.buffer();
    String word=null;
    try {
      word=new String(buffer,0,offsetAtt.endOffset() - offsetAtt.startOffset());
    }
 catch (    StringIndexOutOfBoundsException ioe) {
      LOG.error(ioe.toString());
      word=offsetAtt.toString();
    }
    wordList.add(word);
    AttributeSource attrs=input.cloneAttributes();
    tokenAttrs.add(attrs);
  }
  String[] words=new String[wordList.size()];
  for (int i=0; i < words.length; i++) {
    words[i]=wordList.get(i);
  }
  return words;
}","protected String[] walkTokens() throws IOException {
  List<String> wordList=new ArrayList<>();
  while (input.incrementToken()) {
    CharTermAttribute textAtt=input.getAttribute(CharTermAttribute.class);
    OffsetAttribute offsetAtt=input.getAttribute(OffsetAttribute.class);
    char[] buffer=textAtt.buffer();
    String word=new String(buffer,0,offsetAtt.endOffset() - offsetAtt.startOffset());
    wordList.add(word);
    AttributeSource attrs=input.cloneAttributes();
    tokenAttrs.add(attrs);
  }
  String[] words=new String[wordList.size()];
  for (int i=0; i < words.length; i++) {
    words[i]=wordList.get(i);
  }
  return words;
}"
12345,"@Override public final boolean incrementToken() throws IOException {
  if (first) {
    loadAll();
    restartAtBeginning();
    first=false;
  }
  if (sentences.length == 0) {
    first=true;
    return false;
  }
  int sentenceOffset=sentences[indexSentence].getStart();
  if (wordSet == null) {
    wordSet=words[indexSentence];
  }
  clearAttributes();
  while (indexSentence < sentences.length) {
    while (indexWord == wordSet.length) {
      indexSentence++;
      if (indexSentence < sentences.length) {
        wordSet=words[indexSentence];
        indexWord=0;
        sentenceOffset=sentences[indexSentence].getStart();
      }
 else {
        first=true;
        return false;
      }
    }
    Span sentence=sentences[indexSentence];
    Span word=wordSet[indexWord];
    int spot=sentence.getStart() + word.getStart();
    termAtt.setEmpty();
    int termLength=word.getEnd() - word.getStart();
    if (termAtt.buffer().length < termLength) {
      termAtt.resizeBuffer(termLength);
    }
    termAtt.setLength(termLength);
    char[] buffer=termAtt.buffer();
    finalOffset=correctOffset(sentenceOffset + word.getEnd());
    int start=correctOffset(word.getStart() + sentenceOffset);
    offsetAtt.setOffset(start,finalOffset);
    for (int i=0; i < termLength; i++) {
      buffer[i]=fullText[spot + i];
    }
    addSentenceContext(sentenceContextAtt,indexWord,indexWord,null,indexSentence);
    indexWord++;
    return true;
  }
  first=true;
  return false;
}","@Override public final boolean incrementToken() throws IOException {
  if (first) {
    loadAll();
    restartAtBeginning();
    first=false;
  }
  if (sentences.length == 0) {
    first=true;
    return false;
  }
  int sentenceOffset=sentences[indexSentence].getStart();
  if (wordSet == null) {
    wordSet=words[indexSentence];
  }
  clearAttributes();
  while (indexSentence < sentences.length) {
    while (indexWord == wordSet.length) {
      indexSentence++;
      if (indexSentence < sentences.length) {
        wordSet=words[indexSentence];
        indexWord=0;
        sentenceOffset=sentences[indexSentence].getStart();
      }
 else {
        first=true;
        return false;
      }
    }
    Span sentence=sentences[indexSentence];
    Span word=wordSet[indexWord];
    int spot=sentence.getStart() + word.getStart();
    termAtt.setEmpty();
    int termLength=word.getEnd() - word.getStart();
    if (termAtt.buffer().length < termLength) {
      termAtt.resizeBuffer(termLength);
    }
    termAtt.setLength(termLength);
    char[] buffer=termAtt.buffer();
    finalOffset=correctOffset(sentenceOffset + word.getEnd());
    int start=correctOffset(word.getStart() + sentenceOffset);
    if (finalOffset - start > termLength) {
      offsetAtt.setOffset(start,sentenceOffset + word.getEnd());
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + start + ""String_Node_Str""+ finalOffset+ ""String_Node_Str""+ termLength+ ""String_Node_Str"");
    }
 else     offsetAtt.setOffset(start,finalOffset);
    for (int i=0; i < termLength; i++) {
      buffer[i]=fullText[spot + i];
    }
    addSentenceContext(sentenceContextAtt,indexWord,indexWord,null,indexSentence);
    indexWord++;
    return true;
  }
  first=true;
  return false;
}"
12346,"public static void main(String[] args) throws IOException, JATEException {
  Lemmatiser lem=new Lemmatiser(new EngLemmatiser(args[4],false,false));
  if (args[3].equals(""String_Node_Str"")) {
    createReportGenia(lem,args[0],args[1],args[2],true,false,true,2,100,1,5,50,100,500,1000,5000,10000);
  }
 else {
    createReportACLRD(lem,args[0],args[1],args[2],true,false,true,2,100,1,10,50,100,500,1000,5000,10000);
  }
}","public static void main(String[] args) throws IOException, JATEException {
  Lemmatiser lem=new Lemmatiser(new EngLemmatiser(args[4],false,false));
  if (args[3].equals(""String_Node_Str"")) {
    createReportGenia(lem,args[0],args[1],args[2],true,false,true,2,100,1,5,50,100,300,500,800,1000,1500,2000,3000,4000,5000,6000,7000,8000,9000,10000);
  }
 else {
    createReportACLRD(lem,args[0],args[1],args[2],true,false,true,2,100,1,10,50,100,300,500,800,1000,1500,2000,3000,4000,5000,6000,7000,8000,9000,10000);
  }
}"
12347,"/** 
 * Retrieve term candidates from solr field see @code {uk.ac.shef.dcs.jate.JATEProperties.PROPERTY_SOLR_FIELD_CONTENT_TERMS} The method assumes that the term candidates are extracted at index-time and stored in pre-configured field
 * @return Set, a set of term candidate surface form
 * @throws JATEException
 * @throws IOException
 */
protected Set<String> getUniqueTerms() throws JATEException, IOException {
  Terms terms=SolrUtil.getTermVector(properties.getSolrFieldNameJATECTerms(),solrIndexSearcher);
  TermsEnum termsEnum=terms.iterator();
  Set<String> allTermCandidates=new HashSet<>();
  while (termsEnum.next() != null) {
    BytesRef t=termsEnum.term();
    if (t.length == 0)     continue;
    allTermCandidates.add(t.utf8ToString());
  }
  return allTermCandidates;
}","/** 
 * Retrieve term candidates from solr field see @code {uk.ac.shef.dcs.jate.JATEProperties.PROPERTY_SOLR_FIELD_CONTENT_TERMS} The method assumes that the term candidates are extracted at index-time and stored in pre-configured field
 * @return Set, a set of term candidate surface form
 * @throws JATEException
 * @throws IOException
 */
protected Set<String> getUniqueTerms() throws JATEException, IOException {
  Terms terms=SolrUtil.getTermVector(properties.getSolrFieldNameJATECTerms(),solrIndexSearcher);
  TermsEnum termsEnum=terms.iterator();
  Set<String> allTermCandidates=new HashSet<>();
  while (termsEnum.next() != null) {
    BytesRef t=termsEnum.term();
    if (t.length == 0)     continue;
    allTermCandidates.add(t.utf8ToString());
    if (t.utf8ToString().equals(""String_Node_Str""))     System.out.println();
  }
  return allTermCandidates;
}"
12348,"/** 
 * Corpus indexing and candidate term (at index-time)
 * @param corpusDir, ACL RD-TEC cleansed text xml.zip corpus directory
 * @return List<JATETerm>
 * @throws JATEException
 */
public void indexAndExtract(Path corpusDir) throws JATEException {
  List<Path> files=JATEUtil.loadFiles(corpusDir);
  LOG.info(""String_Node_Str"" + files.size() + ""String_Node_Str"");
  int count=0;
  for (  Path file : files) {
    try {
      indexJATEDocuments(file,jateProp,false);
      count++;
      if (count % 100 == 0)       LOG.info(""String_Node_Str"" + count + ""String_Node_Str""+ files.size());
    }
 catch (    NullPointerException e) {
      e.printStackTrace();
    }
  }
  try {
    server.commit();
    LOG.info(""String_Node_Str"");
  }
 catch (  SolrServerException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Corpus indexing and candidate term (at index-time)
 * @param corpusDir, ACL RD-TEC cleansed text xml.zip corpus directory
 * @return List<JATETerm>
 * @throws JATEException
 */
public void indexAndExtract(Path corpusDir) throws JATEException {
  List<Path> files=JATEUtil.loadFiles(corpusDir);
  LOG.info(""String_Node_Str"" + files.size() + ""String_Node_Str"");
  int count=0;
  for (  Path file : files) {
    try {
      System.out.println(file);
      indexJATEDocuments(file,jateProp,false);
      count++;
      if (count % 100 == 0)       LOG.info(""String_Node_Str"" + count + ""String_Node_Str""+ files.size());
    }
 catch (    NullPointerException e) {
      e.printStackTrace();
    }
  }
  try {
    server.commit();
    LOG.info(""String_Node_Str"");
  }
 catch (  SolrServerException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}"
12349,"protected String[][] walkTokens() throws IOException {
  List<String> wordList=new ArrayList<>();
  List<String> posList=new ArrayList<>();
  while (input.incrementToken()) {
    CharTermAttribute textAtt=input.getAttribute(CharTermAttribute.class);
    OffsetAttribute offsetAtt=input.getAttribute(OffsetAttribute.class);
    char[] buffer=textAtt.buffer();
    String word=new String(buffer,0,offsetAtt.endOffset() - offsetAtt.startOffset());
    wordList.add(word);
    PayloadAttribute posAtt=input.getAttribute(PayloadAttribute.class);
    if (posAtt != null) {
      posList.add(new SentenceContext(posAtt.getPayload().utf8ToString()).getPosTag());
    }
    AttributeSource attrs=input.cloneAttributes();
    tokenAttrs.add(attrs);
  }
  if (wordList.size() != posList.size()) {
    StringBuilder sb=new StringBuilder(this.getClass().getName());
    sb.append(""String_Node_Str"").append(wordList.size()).append(""String_Node_Str"").append(posList.size()).append(""String_Node_Str"").append(""String_Node_Str"");
    throw new IOException(sb.toString());
  }
  String[] words=new String[wordList.size()];
  String[] pos=new String[posList.size()];
  for (int i=0; i < words.length; i++) {
    words[i]=wordList.get(i);
    pos[i]=posList.get(i);
  }
  return new String[][]{words,pos};
}","protected String[][] walkTokens() throws IOException {
  List<String> wordList=new ArrayList<>();
  List<String> posList=new ArrayList<>();
  while (input.incrementToken()) {
    CharTermAttribute textAtt=input.getAttribute(CharTermAttribute.class);
    OffsetAttribute offsetAtt=input.getAttribute(OffsetAttribute.class);
    char[] buffer=textAtt.buffer();
    String word=new String(buffer,0,offsetAtt.endOffset() - offsetAtt.startOffset());
    wordList.add(word);
    PayloadAttribute posAtt=input.getAttribute(PayloadAttribute.class);
    if (posAtt != null) {
      posList.add(new SentenceContext(posAtt.getPayload().utf8ToString()).getPosTag());
    }
    AttributeSource attrs=input.cloneAttributes();
    tokenAttrs.add(attrs);
  }
  if (wordList.size() != posList.size()) {
    StringBuilder sb=new StringBuilder(this.getClass().getName());
    sb.append(""String_Node_Str"").append(wordList.size()).append(""String_Node_Str"").append(posList.size()).append(""String_Node_Str"").append(""String_Node_Str"");
    throw new IOException(sb.toString());
  }
  String[] words=new String[wordList.size()];
  String[] pos=new String[posList.size()];
  for (int i=0; i < words.length; i++) {
    words[i]=wordList.get(i);
    pos[i]=posList.get(i);
  }
  clearAttributes();
  return new String[][]{words,pos};
}"
12350,"protected void resetParams(){
  first=true;
  tokenIdx=0;
  chunkStart=-1;
  chunkEnd=-1;
  chunkSpans.clear();
  chunkTypes.clear();
}","protected void resetParams(){
  first=true;
  tokenIdx=0;
  chunkStart=-1;
  chunkEnds.clear();
  ;
  chunkSpans.clear();
  chunkTypes.clear();
}"
12351,"protected boolean addMWE(){
  AttributeSource start=tokenAttrs.get(chunkStart);
  AttributeSource end=tokenAttrs.get(chunkEnd - 1);
  SentenceContext firstTokenSentCtx=parseSentenceContextPayload(start.getAttribute(PayloadAttribute.class));
  SentenceContext lastTokenSentCtx=parseSentenceContextPayload(end.getAttribute(PayloadAttribute.class));
  boolean added=false;
  if (!crossBoundary(firstTokenSentCtx,lastTokenSentCtx)) {
    StringBuilder phrase=new StringBuilder();
    for (int i=chunkStart; i <= chunkEnd - 1; i++)     phrase.append(tokenAttrs.get(i).getAttribute(CharTermAttribute.class).buffer()).append(""String_Node_Str"");
    termAtt.setEmpty().append(phrase.toString().trim());
    offsetAtt.setOffset(start.getAttribute(OffsetAttribute.class).startOffset(),end.getAttribute(OffsetAttribute.class).endOffset());
    typeAtt.setType(chunkTypes.get(chunkStart));
    addSentenceContextPayload(firstTokenSentCtx,lastTokenSentCtx);
    added=true;
  }
  chunkStart=-1;
  chunkEnd=-1;
  return added;
}","protected boolean addMWE(int chunkEnd){
  AttributeSource start=tokenAttrs.get(chunkStart);
  AttributeSource end=tokenAttrs.get(chunkEnd - 1);
  SentenceContext firstTokenSentCtx=parseSentenceContextPayload(start.getAttribute(PayloadAttribute.class));
  SentenceContext lastTokenSentCtx=parseSentenceContextPayload(end.getAttribute(PayloadAttribute.class));
  boolean added=false;
  if (!crossBoundary(firstTokenSentCtx,lastTokenSentCtx)) {
    StringBuilder phrase=new StringBuilder();
    for (int i=chunkStart; i <= chunkEnd - 1; i++)     phrase.append(tokenAttrs.get(i).getAttribute(CharTermAttribute.class).buffer()).append(""String_Node_Str"");
    termAtt.setEmpty().append(phrase.toString().trim());
    offsetAtt.setOffset(start.getAttribute(OffsetAttribute.class).startOffset(),end.getAttribute(OffsetAttribute.class).endOffset());
    typeAtt.setType(chunkTypes.get(chunkStart));
    addSentenceContextPayload(firstTokenSentCtx,lastTokenSentCtx);
    added=true;
  }
  chunkEnds.remove(Integer.valueOf(chunkEnd));
  if (chunkEnds.size() == 0) {
    tokenIdx=chunkStart + 1;
    chunkStart=-1;
  }
 else {
    tokenIdx=chunkEnds.get(0);
  }
  return added;
}"
12352,"@Override public boolean incrementToken() throws IOException {
  clearAttributes();
  if (first) {
    String[][] wordsAndPOS=walkTokens();
    String[] words=wordsAndPOS[0];
    if (words.length == 0) {
      return false;
    }
    String[] pos=wordsAndPOS[1];
    Span[] chunks=regexChunker.find(pos);
    chunks=prune(chunks,words);
    for (    Span sp : chunks) {
      chunkSpans.put(sp.getStart(),sp.getEnd());
      chunkTypes.put(sp.getStart(),sp.getType());
    }
    first=false;
    tokenIdx=0;
  }
  if (tokenIdx == tokenAttrs.size()) {
    resetParams();
    return false;
  }
  if (chunkStart != -1 && tokenIdx == chunkEnd) {
    boolean added=addMWE();
    return true;
  }
  if (chunkSpans.containsKey(tokenIdx)) {
    chunkStart=tokenIdx;
    chunkEnd=chunkSpans.get(tokenIdx);
    tokenIdx++;
    return true;
  }
 else {
    tokenIdx++;
    return true;
  }
}","@Override public boolean incrementToken() throws IOException {
  clearAttributes();
  if (first) {
    String[][] wordsAndPOS=walkTokens();
    String[] words=wordsAndPOS[0];
    if (words.length == 0) {
      return false;
    }
    String[] pos=wordsAndPOS[1];
    Span[] chunks=regexChunker.find(pos);
    chunks=prune(chunks,words);
    for (    Span sp : chunks) {
      List<Integer> ends=chunkSpans.get(sp.getStart());
      if (ends == null)       ends=new ArrayList<>();
      ends.add(sp.getEnd());
      chunkSpans.put(sp.getStart(),ends);
      chunkTypes.put(sp.getStart(),sp.getType());
    }
    first=false;
    tokenIdx=0;
  }
  if (tokenIdx == tokenAttrs.size()) {
    resetParams();
    return false;
  }
  if (chunkStart != -1 && chunkEnds.contains(tokenIdx)) {
    boolean added=addMWE(tokenIdx);
    return true;
  }
  if (chunkSpans.containsKey(tokenIdx)) {
    chunkStart=tokenIdx;
    chunkEnds=chunkSpans.get(tokenIdx);
    tokenIdx=chunkEnds.get(0);
    return true;
  }
 else {
    tokenIdx++;
    return true;
  }
}"
12353,"public static void main(String[] args) throws IOException {
  createReportGenia(args[0],args[1],args[2],true,false,true,2,150,1,5,50,100,500,1000,5000,10000);
  System.out.println(""String_Node_Str"");
  System.out.println();
}","public static void main(String[] args) throws IOException {
  if (args[3].equals(""String_Node_Str"")) {
    createReportGenia(args[0],args[1],args[2],true,false,true,2,150,1,5,50,100,500,1000,5000,10000);
    System.out.println(""String_Node_Str"");
  }
 else {
    createReportACLRD(args[0],args[1],args[2],true,false,true,2,150,1,5,50,100,500,1000,5000,10000);
    System.out.println();
  }
}"
12354,"/** 
 * To run the test class via <p> mvn exec:java -Dexec.mainClass=""uk.ac.shef.dcs.jate.app.AppATEACLRDTECTest"" -Dexec.classpathScope=""test""
 * @param args
 * @throws JATEException
 */
public static void main(String[] args) throws JATEException {
  try {
    AppATEACLRDTECTest appATETest=new AppATEACLRDTECTest(solrHome.toString(),solrCoreName);
    boolean reindex=false;
    if (args.length > 0) {
      try {
        reindex=Boolean.valueOf(args[0]);
      }
 catch (      Exception e) {
      }
    }
    long numOfDocs=validate_indexing();
    if (numOfDocs == 0 || reindex) {
      appATETest.indexAndExtract(corpusDir);
    }
    System.exit(1);
    List<JATETerm> terms=null;
    AppATTFTest appATTFTest=new AppATTFTest();
    terms=appATTFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appATTFTest.evaluate(terms,AppATTF.class.getSimpleName());
    AppChiSquareTest appChiSquareTest=new AppChiSquareTest();
    terms=appChiSquareTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appChiSquareTest.evaluate(terms,AppChiSquare.class.getSimpleName());
    AppCValueTest appCValueTest=new AppCValueTest();
    terms=appCValueTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appCValueTest.evaluate(terms,AppCValue.class.getSimpleName());
    AppGlossExTest appGlossExTest=new AppGlossExTest();
    terms=appGlossExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appGlossExTest.evaluate(terms,AppGlossEx.class.getSimpleName());
    AppRAKETest appRAKETest=new AppRAKETest();
    terms=appRAKETest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRAKETest.evaluate(terms,AppRAKE.class.getSimpleName());
    AppRIDFTest appRIDFTest=new AppRIDFTest();
    terms=appRIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRIDFTest.evaluate(terms,AppRIDF.class.getSimpleName());
    AppTermExTest appTermExTest=new AppTermExTest();
    terms=appTermExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTermExTest.evaluate(terms,AppTermEx.class.getSimpleName());
    AppTFIDFTest appTFIDFTest=new AppTFIDFTest();
    terms=appTFIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTFIDFTest.evaluate(terms,AppTFIDF.class.getSimpleName());
    AppTTFTest appTTFTest=new AppTTFTest();
    terms=appTTFTest.rankAndFilter(server,solrCoreName,appTTFTest.jateProp);
    appTTFTest.evaluate(terms,AppTTF.class.getSimpleName());
    AppWeirdnessTest appWeirdnessTest=new AppWeirdnessTest();
    terms=appWeirdnessTest.rankAndFilter(server,solrCoreName,appWeirdnessTest.jateProp);
    appWeirdnessTest.evaluate(terms,AppWeirdness.class.getSimpleName());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      server.getCoreContainer().shutdown();
      server.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  System.exit(0);
}","/** 
 * To run the test class via <p> mvn exec:java -Dexec.mainClass=""uk.ac.shef.dcs.jate.app.AppATEACLRDTECTest"" -Dexec.classpathScope=""test""
 * @param args
 * @throws JATEException
 */
public static void main(String[] args) throws JATEException {
  try {
    AppATEACLRDTECTest appATETest=new AppATEACLRDTECTest(solrHome.toString(),solrCoreName);
    boolean reindex=false;
    if (args.length > 0) {
      try {
        reindex=Boolean.valueOf(args[0]);
      }
 catch (      Exception e) {
      }
    }
    long numOfDocs=validate_indexing();
    if (numOfDocs == 0 || reindex) {
      appATETest.indexAndExtract(corpusDir);
    }
    List<JATETerm> terms=null;
    AppATTFTest appATTFTest=new AppATTFTest();
    terms=appATTFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appATTFTest.evaluate(terms,AppATTF.class.getSimpleName());
    System.exit(0);
    AppChiSquareTest appChiSquareTest=new AppChiSquareTest();
    terms=appChiSquareTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appChiSquareTest.evaluate(terms,AppChiSquare.class.getSimpleName());
    AppCValueTest appCValueTest=new AppCValueTest();
    terms=appCValueTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appCValueTest.evaluate(terms,AppCValue.class.getSimpleName());
    AppGlossExTest appGlossExTest=new AppGlossExTest();
    terms=appGlossExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appGlossExTest.evaluate(terms,AppGlossEx.class.getSimpleName());
    AppRAKETest appRAKETest=new AppRAKETest();
    terms=appRAKETest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRAKETest.evaluate(terms,AppRAKE.class.getSimpleName());
    AppRIDFTest appRIDFTest=new AppRIDFTest();
    terms=appRIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRIDFTest.evaluate(terms,AppRIDF.class.getSimpleName());
    AppTermExTest appTermExTest=new AppTermExTest();
    terms=appTermExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTermExTest.evaluate(terms,AppTermEx.class.getSimpleName());
    AppTFIDFTest appTFIDFTest=new AppTFIDFTest();
    terms=appTFIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTFIDFTest.evaluate(terms,AppTFIDF.class.getSimpleName());
    AppTTFTest appTTFTest=new AppTTFTest();
    terms=appTTFTest.rankAndFilter(server,solrCoreName,appTTFTest.jateProp);
    appTTFTest.evaluate(terms,AppTTF.class.getSimpleName());
    AppWeirdnessTest appWeirdnessTest=new AppWeirdnessTest();
    terms=appWeirdnessTest.rankAndFilter(server,solrCoreName,appWeirdnessTest.jateProp);
    appWeirdnessTest.evaluate(terms,AppWeirdness.class.getSimpleName());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      server.getCoreContainer().shutdown();
      server.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  System.exit(0);
}"
12355,"@Test public void benchmarking_appWeirdness() throws JATEException, IOException {
}","public void benchmarking_appWeirdness() throws JATEException, IOException {
}"
12356,"public void benchmarking_appTTF() throws JATEException, IOException {
}","@Test public void benchmarking_appTTF() throws JATEException, IOException {
}"
12357,"@Test public void benchmarking_appCValue() throws IOException, JATEException {
}","public void benchmarking_appCValue() throws IOException, JATEException {
}"
12358,"public void benchmarking_appWeirdness() throws JATEException, IOException {
}","@Test public void benchmarking_appWeirdness() throws JATEException, IOException {
}"
12359,"public void benchmarking_appTermEx() throws JATEException, IOException {
  initParams.put(AppParams.REFERENCE_FREQUENCY_FILE.getParamKey(),FREQ_GENIC_FILE.toString());
  AppTermEx appTermEx=new AppTermEx(initParams);
  List<JATETerm> termList=appTermEx.extract(server.getCoreContainer().getCore(solrCoreName),jateProperties);
  Assert.assertEquals(""String_Node_Str"",10681,termList.size());
  List<String> rankedTerms=ATEResultLoader.load(termList);
  double[] scores=Scorer.computePrecisionAtRank(gsTerms,rankedTerms,true,false,true,2,100,1,5,50,100,500,1000,3000,5000,8000,10000);
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"" + scores[0]);
  LOG.info(""String_Node_Str"" + scores[1]);
  LOG.info(""String_Node_Str"" + scores[2]);
  LOG.info(""String_Node_Str"" + scores[3]);
  LOG.info(""String_Node_Str"" + scores[4]);
  LOG.info(""String_Node_Str"" + scores[5]);
  LOG.info(""String_Node_Str"" + scores[6]);
  LOG.info(""String_Node_Str"" + scores[7]);
  LOG.info(""String_Node_Str"" + 0);
}","public void benchmarking_appTermEx() throws JATEException, IOException {
}"
12360,"public void characters(char ch[],int start,int length) throws SAXException {
  if (paper) {
    paper=false;
  }
  if (title) {
    title=false;
    if (!reference) {
      paperTitle.append(new String(ch,start,length)).append(""String_Node_Str"");
    }
    reference=false;
  }
  if (section) {
    section=false;
  }
  if (sectionTitle) {
    sectionTitle=false;
  }
  if (paragraph) {
    paragraph=false;
    paperParagraphs.append(new String(ch,start,length));
  }
}","public void characters(char ch[],int start,int length) throws SAXException {
  if (paper) {
    paper=false;
  }
  if (title) {
    title=false;
    if (!reference) {
      paperTitle.append(new String(ch,start,length)).append(""String_Node_Str"");
    }
    reference=false;
  }
  if (section) {
    section=false;
  }
  if (sectionTitle) {
    sectionTitle=false;
  }
  if (paragraph) {
    String paragraph=new String(ch,start,length);
    paperParagraphs.append(paragraph);
  }
}"
12361,"public static JATEDocument loadACLRDTECDocument(InputStream fileInputStream) throws JATEException {
  SAXParserFactory factory=SAXParserFactory.newInstance();
  SAXParser saxParser=null;
  JATEDocument jateDocument=null;
  try {
    saxParser=factory.newSAXParser();
    StringBuffer paperParagraphs=new StringBuffer();
    StringBuffer paperId=new StringBuffer();
    StringBuffer paperTitle=new StringBuffer();
    DefaultHandler handler=new DefaultHandler(){
      boolean paper=false;
      boolean title=false;
      boolean section=false;
      boolean sectionTitle=false;
      boolean paragraph=false;
      boolean reference=false;
      public void startElement(      String uri,      String localName,      String qName,      org.xml.sax.Attributes attributes) throws SAXException {
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          paper=true;
          paperId.append(attributes.getValue(""String_Node_Str""));
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          title=true;
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          section=true;
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          sectionTitle=true;
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          paragraph=true;
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          reference=true;
        }
      }
      public void endElement(      String uri,      String localName,      String qName) throws SAXException {
      }
      public void characters(      char ch[],      int start,      int length) throws SAXException {
        if (paper) {
          paper=false;
        }
        if (title) {
          title=false;
          if (!reference) {
            paperTitle.append(new String(ch,start,length)).append(""String_Node_Str"");
          }
          reference=false;
        }
        if (section) {
          section=false;
        }
        if (sectionTitle) {
          sectionTitle=false;
        }
        if (paragraph) {
          paragraph=false;
          paperParagraphs.append(new String(ch,start,length));
        }
      }
    }
;
    saxParser.parse(fileInputStream,handler);
    StringBuffer fullText=new StringBuffer();
    fullText.append(paperTitle).append(""String_Node_Str"").append(paperParagraphs);
    String normalizedText=Normalizer.normalize(fullText.toString(),Normalizer.Form.NFD);
    String cleanedText=cleanText(normalizedText);
    jateDocument=new JATEDocument(paperId.toString());
    jateDocument.setContent(cleanedText);
  }
 catch (  ParserConfigurationException e) {
    throw new JATEException(""String_Node_Str"" + e.toString());
  }
catch (  SAXException e) {
    throw new JATEException(""String_Node_Str"" + e.toString());
  }
catch (  IOException ioe) {
    throw new JATEException(""String_Node_Str"" + ioe.toString());
  }
  return jateDocument;
}","public static JATEDocument loadACLRDTECDocument(InputStream fileInputStream) throws JATEException {
  SAXParserFactory factory=SAXParserFactory.newInstance();
  SAXParser saxParser=null;
  JATEDocument jateDocument=null;
  try {
    saxParser=factory.newSAXParser();
    StringBuffer paperParagraphs=new StringBuffer();
    StringBuffer paperId=new StringBuffer();
    StringBuffer paperTitle=new StringBuffer();
    DefaultHandler handler=new DefaultHandler(){
      boolean paper=false;
      boolean title=false;
      boolean section=false;
      boolean sectionTitle=false;
      boolean paragraph=false;
      boolean reference=false;
      public void startElement(      String uri,      String localName,      String qName,      org.xml.sax.Attributes attributes) throws SAXException {
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          paper=true;
          paperId.append(attributes.getValue(""String_Node_Str""));
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          title=true;
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          section=true;
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          sectionTitle=true;
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          paragraph=true;
        }
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          reference=true;
        }
      }
      public void endElement(      String uri,      String localName,      String qName) throws SAXException {
        if (qName.equalsIgnoreCase(""String_Node_Str"")) {
          paragraph=false;
        }
      }
      public void characters(      char ch[],      int start,      int length) throws SAXException {
        if (paper) {
          paper=false;
        }
        if (title) {
          title=false;
          if (!reference) {
            paperTitle.append(new String(ch,start,length)).append(""String_Node_Str"");
          }
          reference=false;
        }
        if (section) {
          section=false;
        }
        if (sectionTitle) {
          sectionTitle=false;
        }
        if (paragraph) {
          String paragraph=new String(ch,start,length);
          paperParagraphs.append(paragraph);
        }
      }
    }
;
    saxParser.parse(fileInputStream,handler);
    StringBuffer fullText=new StringBuffer();
    fullText.append(paperTitle).append(""String_Node_Str"").append(paperParagraphs);
    String normalizedText=Normalizer.normalize(fullText.toString(),Normalizer.Form.NFD);
    String cleanedText=cleanText(normalizedText);
    jateDocument=new JATEDocument(paperId.toString());
    jateDocument.setContent(cleanedText);
  }
 catch (  ParserConfigurationException e) {
    throw new JATEException(""String_Node_Str"" + e.toString());
  }
catch (  SAXException e) {
    throw new JATEException(""String_Node_Str"" + e.toString());
  }
catch (  IOException ioe) {
    throw new JATEException(""String_Node_Str"" + ioe.toString());
  }
  return jateDocument;
}"
12362,"public void endElement(String uri,String localName,String qName) throws SAXException {
}","public void endElement(String uri,String localName,String qName) throws SAXException {
  if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    paragraph=false;
  }
}"
12363,"/** 
 * To run the test class via <p> mvn exec:java -Dexec.mainClass=""uk.ac.shef.dcs.jate.app.AppATEACLRDTECTest"" -Dexec.classpathScope=""test""
 * @param args
 * @throws JATEException
 */
public static void main(String[] args) throws JATEException {
  try {
    AppATEACLRDTECTest appATETest=new AppATEACLRDTECTest(solrHome.toString(),solrCoreName);
    boolean reindex=false;
    if (args.length > 0) {
      try {
        reindex=Boolean.valueOf(args[0]);
      }
 catch (      Exception e) {
      }
    }
    long numOfDocs=validate_indexing();
    if (numOfDocs == 0 || reindex) {
      appATETest.indexAndExtract(corpusDir);
    }
    System.exit(1);
    List<JATETerm> terms=null;
    AppATTFTest appATTFTest=new AppATTFTest();
    terms=appATTFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appATTFTest.evaluate(terms,AppATTF.class.getSimpleName());
    AppChiSquareTest appChiSquareTest=new AppChiSquareTest();
    terms=appChiSquareTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appChiSquareTest.evaluate(terms,AppChiSquare.class.getSimpleName());
    AppCValueTest appCValueTest=new AppCValueTest();
    terms=appCValueTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appCValueTest.evaluate(terms,AppCValue.class.getSimpleName());
    AppGlossExTest appGlossExTest=new AppGlossExTest();
    terms=appGlossExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appGlossExTest.evaluate(terms,AppGlossEx.class.getSimpleName());
    AppRAKETest appRAKETest=new AppRAKETest();
    terms=appRAKETest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRAKETest.evaluate(terms,AppRAKE.class.getSimpleName());
    AppRIDFTest appRIDFTest=new AppRIDFTest();
    terms=appRIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRIDFTest.evaluate(terms,AppRIDF.class.getSimpleName());
    AppTermExTest appTermExTest=new AppTermExTest();
    terms=appTermExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTermExTest.evaluate(terms,AppTermEx.class.getSimpleName());
    AppTFIDFTest appTFIDFTest=new AppTFIDFTest();
    terms=appTFIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTFIDFTest.evaluate(terms,AppTFIDF.class.getSimpleName());
    AppTTFTest appTTFTest=new AppTTFTest();
    terms=appTTFTest.rankAndFilter(server,solrCoreName,appTTFTest.jateProp);
    appTTFTest.evaluate(terms,AppTTF.class.getSimpleName());
    AppWeirdnessTest appWeirdnessTest=new AppWeirdnessTest();
    terms=appWeirdnessTest.rankAndFilter(server,solrCoreName,appWeirdnessTest.jateProp);
    appWeirdnessTest.evaluate(terms,AppWeirdness.class.getSimpleName());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      server.getCoreContainer().shutdown();
      server.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  System.exit(0);
}","/** 
 * To run the test class via <p> mvn exec:java -Dexec.mainClass=""uk.ac.shef.dcs.jate.app.AppATEACLRDTECTest"" -Dexec.classpathScope=""test""
 * @param args
 * @throws JATEException
 */
public static void main(String[] args) throws JATEException {
  try {
    AppATEACLRDTECTest appATETest=new AppATEACLRDTECTest(solrHome.toString(),solrCoreName);
    boolean reindex=false;
    if (args.length > 0) {
      try {
        reindex=Boolean.valueOf(args[0]);
      }
 catch (      Exception e) {
      }
    }
    long numOfDocs=validate_indexing();
    if (numOfDocs == 0 || reindex) {
      appATETest.indexAndExtract(corpusDir);
    }
    List<JATETerm> terms=null;
    AppATTFTest appATTFTest=new AppATTFTest();
    terms=appATTFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appATTFTest.evaluate(terms,AppATTF.class.getSimpleName());
    AppChiSquareTest appChiSquareTest=new AppChiSquareTest();
    terms=appChiSquareTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appChiSquareTest.evaluate(terms,AppChiSquare.class.getSimpleName());
    AppCValueTest appCValueTest=new AppCValueTest();
    terms=appCValueTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appCValueTest.evaluate(terms,AppCValue.class.getSimpleName());
    AppGlossExTest appGlossExTest=new AppGlossExTest();
    terms=appGlossExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appGlossExTest.evaluate(terms,AppGlossEx.class.getSimpleName());
    AppRAKETest appRAKETest=new AppRAKETest();
    terms=appRAKETest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRAKETest.evaluate(terms,AppRAKE.class.getSimpleName());
    AppRIDFTest appRIDFTest=new AppRIDFTest();
    terms=appRIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appRIDFTest.evaluate(terms,AppRIDF.class.getSimpleName());
    AppTermExTest appTermExTest=new AppTermExTest();
    terms=appTermExTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTermExTest.evaluate(terms,AppTermEx.class.getSimpleName());
    AppTFIDFTest appTFIDFTest=new AppTFIDFTest();
    terms=appTFIDFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTFIDFTest.evaluate(terms,AppTFIDF.class.getSimpleName());
    AppTTFTest appTTFTest=new AppTTFTest();
    terms=appTTFTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appTTFTest.evaluate(terms,AppTTF.class.getSimpleName());
    AppWeirdnessTest appWeirdnessTest=new AppWeirdnessTest();
    terms=appWeirdnessTest.rankAndFilter(server,solrCoreName,appATETest.jateProp);
    appWeirdnessTest.evaluate(terms,AppWeirdness.class.getSimpleName());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      server.getCoreContainer().getCore(solrCoreName).close();
      server.getCoreContainer().shutdown();
      server.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  System.exit(0);
}"
12364,"@Override public AbstractFeature build() throws JATEException {
  List<ContextWindow> contextWindows=new ArrayList<>(ref_frequencyCtxBased.getMapCtx2TTF().keySet());
  int cores=properties.getMaxCPUCores();
  cores=cores == 0 ? 1 : cores;
  int maxPerThread=contextWindows.size() / cores;
  if (maxPerThread == 0)   maxPerThread=50;
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(cores).append(""String_Node_Str"").append(contextWindows.size()).append(""String_Node_Str"").append(maxPerThread);
  LOG.info(sb.toString());
  LOG.info(""String_Node_Str"" + minTTF + ""String_Node_Str""+ minTCF);
  Set<String> termsPassingPrefilter=new HashSet<>();
  for (  ContextWindow ctx : contextWindows) {
    Map<String,Integer> termsInContext=frequencyCtxBased.getTFIC(ctx);
    if (minTTF == 0 && minTCF == 0)     termsPassingPrefilter.addAll(termsInContext.keySet());
 else {
      for (      String term : termsInContext.keySet()) {
        if (frequencyTermBased.getTTF(term) >= minTTF && frequencyCtxBased.getContexts(term).size() >= minTCF)         termsPassingPrefilter.add(term);
      }
    }
  }
  Cooccurrence feature=new Cooccurrence(termsPassingPrefilter.size(),ref_frequencyCtxBased.getMapTerm2Ctx().size());
  LOG.info(""String_Node_Str"" + termsPassingPrefilter.size() + ""String_Node_Str""+ contextWindows.size());
  CooccurrenceFBWorker worker=new CooccurrenceFBWorker(feature,contextWindows,frequencyTermBased,minTTF,frequencyCtxBased,ref_frequencyCtxBased,minTCF,maxPerThread);
  ForkJoinPool forkJoinPool=new ForkJoinPool(cores);
  int total=forkJoinPool.invoke(worker);
  List<String> col=new ArrayList<>(frequencyCtxBased.getCtxOverlapZones().keySet());
  col.removeAll(ref_frequencyCtxBased.getCtxOverlapZones().keySet());
  System.out.println(col.size());
  Map<String,ContextOverlap> overlaps=frequencyCtxBased.getCtxOverlapZones();
  if (overlaps.size() > 0) {
    LOG.info(""String_Node_Str"" + overlaps.size());
    for (    Map.Entry<String,ContextOverlap> en : overlaps.entrySet()) {
      String key=en.getKey();
      ContextOverlap co=en.getValue();
      Map<String,Integer> freq=new HashMap<>();
      for (      String t : co.getTerms()) {
        Integer f=freq.get(t);
        f=f == null ? 0 : f;
        f++;
        freq.put(t,f);
      }
      if (freq.size() <= 1)       continue;
      ContextOverlap ref_co=ref_frequencyCtxBased.getCtxOverlapZones().get(key);
      Map<String,Integer> ref_freq=new HashMap<>();
      if (ref_co != null) {
        for (        String t : ref_co.getTerms()) {
          Integer f=ref_freq.get(t);
          f=f == null ? 0 : f;
          f++;
          ref_freq.put(t,f);
        }
      }
      if (ref_freq.size() <= 1)       continue;
      for (      Map.Entry<String,Integer> term_in_co : freq.entrySet()) {
        int f=term_in_co.getValue();
        for (        Map.Entry<String,Integer> term_in_ref_co : ref_freq.entrySet()) {
          int rf=term_in_ref_co.getValue();
          if (term_in_co.getKey().equals(term_in_ref_co.getKey()))           continue;
          int deduce=f < rf ? f : rf;
          int tid=feature.lookupTerm(term_in_co.getKey());
          int tid_f=feature.lookupRefTerm(term_in_ref_co.getKey());
          if (tid == -1 || tid_f == -1)           continue;
          feature.deduce(tid,tid_f,deduce);
        }
      }
    }
  }
  sb=new StringBuilder(""String_Node_Str"" + total);
  LOG.info(sb.toString());
  return feature;
}","@Override public AbstractFeature build() throws JATEException {
  List<ContextWindow> contextWindows=new ArrayList<>(ref_frequencyCtxBased.getMapCtx2TTF().keySet());
  int cores=properties.getMaxCPUCores();
  cores=cores == 0 ? 1 : cores;
  int maxPerThread=contextWindows.size() / cores;
  if (maxPerThread == 0)   maxPerThread=50;
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(cores).append(""String_Node_Str"").append(contextWindows.size()).append(""String_Node_Str"").append(maxPerThread);
  LOG.info(sb.toString());
  LOG.info(""String_Node_Str"" + minTTF + ""String_Node_Str""+ minTCF);
  Set<String> termsPassingPrefilter=new HashSet<>();
  for (  ContextWindow ctx : contextWindows) {
    Map<String,Integer> termsInContext=frequencyCtxBased.getTFIC(ctx);
    if (minTTF == 0 && minTCF == 0)     termsPassingPrefilter.addAll(termsInContext.keySet());
 else {
      for (      String term : termsInContext.keySet()) {
        if (frequencyTermBased.getTTF(term) >= minTTF && frequencyCtxBased.getContexts(term).size() >= minTCF)         termsPassingPrefilter.add(term);
      }
    }
  }
  Cooccurrence feature=new Cooccurrence(termsPassingPrefilter.size(),ref_frequencyCtxBased.getMapTerm2Ctx().size());
  LOG.info(""String_Node_Str"" + termsPassingPrefilter.size() + ""String_Node_Str""+ contextWindows.size());
  CooccurrenceFBWorker worker=new CooccurrenceFBWorker(feature,contextWindows,frequencyTermBased,minTTF,frequencyCtxBased,ref_frequencyCtxBased,minTCF,maxPerThread);
  ForkJoinPool forkJoinPool=new ForkJoinPool(cores);
  int total=forkJoinPool.invoke(worker);
  Map<String,ContextOverlap> overlaps=frequencyCtxBased.getCtxOverlapZones();
  if (overlaps.size() > 0) {
    LOG.info(""String_Node_Str"" + overlaps.size());
    for (    Map.Entry<String,ContextOverlap> en : overlaps.entrySet()) {
      String key=en.getKey();
      ContextOverlap co=en.getValue();
      Map<String,Integer> freq=new HashMap<>();
      for (      String t : co.getTerms()) {
        Integer f=freq.get(t);
        f=f == null ? 0 : f;
        f++;
        freq.put(t,f);
      }
      if (freq.size() <= 1)       continue;
      ContextOverlap ref_co=ref_frequencyCtxBased.getCtxOverlapZones().get(key);
      Map<String,Integer> ref_freq=new HashMap<>();
      if (ref_co != null) {
        for (        String t : ref_co.getTerms()) {
          Integer f=ref_freq.get(t);
          f=f == null ? 0 : f;
          f++;
          ref_freq.put(t,f);
        }
      }
      if (ref_freq.size() <= 1)       continue;
      for (      Map.Entry<String,Integer> term_in_co : freq.entrySet()) {
        int f=term_in_co.getValue();
        for (        Map.Entry<String,Integer> term_in_ref_co : ref_freq.entrySet()) {
          int rf=term_in_ref_co.getValue();
          if (term_in_co.getKey().equals(term_in_ref_co.getKey()))           continue;
          int deduce=f < rf ? f : rf;
          int tid=feature.lookupTerm(term_in_co.getKey());
          int tid_f=feature.lookupRefTerm(term_in_ref_co.getKey());
          if (tid == -1 || tid_f == -1)           continue;
          feature.deduce(tid,tid_f,deduce);
        }
      }
    }
  }
  sb=new StringBuilder(""String_Node_Str"" + total);
  LOG.info(sb.toString());
  return feature;
}"
12365,"/** 
 * Use existing context windows to count term/word frequency within contexts. Context overlap zones are generated for adjacent context windows.
 * @param docIds
 * @return
 */
private int useExistingContexts(List<Integer> docIds){
  int count=0;
  for (  int docId : docIds) {
    count++;
    try {
      Terms lookupVector=SolrUtil.getTermVector(docId,properties.getSolrFieldnameJATENGramInfo(),solrIndexSearcher);
      List<MWEInSentence> terms=collectTermSentenceContext(lookupVector,new HashMap<>());
      List<ContextWindow> contexts_in_doc=contextLookup.get(docId);
      if (contexts_in_doc == null || contexts_in_doc.size() == 0)       continue;
      Collections.sort(contexts_in_doc);
      int cursor=0;
      ContextWindow prevCtx=null;
      for (      ContextWindow ctx : contexts_in_doc) {
        ContextOverlap co=null;
        if (prevCtx != null && prevCtx.getSentenceId() == ctx.getSentenceId()) {
          if (prevCtx.getLastTok() >= ctx.getFirstTok()) {
            co=new ContextOverlap(prevCtx,ctx,new ArrayList<>());
          }
        }
        if (ctx.getDocId() == 399 && ctx.getSentenceId() == 1 && ctx.getFirstTok() == 13 && ctx.getLastTok() == 23)         System.out.println(""String_Node_Str"");
        int indexFirstIncludedTermByContext=-1;
        for (int i=cursor; i < terms.size(); i++) {
          MWEInSentence t=terms.get(i);
          if (ctx.getSentenceId() < t.sentenceId) {
            cursor=indexFirstIncludedTermByContext;
            break;
          }
 else           if (ctx.getSentenceId() > t.sentenceId) {
            continue;
          }
          boolean outOfContext=false;
          if ((t.firstTokenIndex >= ctx.getFirstTok() && t.firstTokenIndex <= ctx.getLastTok()) || t.lastTokenIndex >= ctx.getFirstTok() && t.lastTokenIndex <= ctx.getLastTok()) {
            feature.increment(ctx,1);
            feature.increment(ctx,t.string,1);
            if (indexFirstIncludedTermByContext == -1)             indexFirstIncludedTermByContext=i;
          }
 else           if (t.lastTokenIndex < ctx.getFirstTok()) {
            continue;
          }
 else {
            outOfContext=true;
            if (indexFirstIncludedTermByContext != -1)             cursor=indexFirstIncludedTermByContext;
          }
          if (co != null) {
            if ((co.getPrevContext().getLastTok() >= t.firstTokenIndex && co.getNextContext().getFirstTok() <= t.firstTokenIndex) || (co.getPrevContext().getLastTok() >= t.lastTokenIndex && co.getNextContext().getFirstTok() <= t.lastTokenIndex) || (co.getPrevContext().getFirstTok() <= t.firstTokenIndex && co.getPrevContext().getLastTok() >= t.firstTokenIndex && co.getNextContext().getLastTok() >= t.lastTokenIndex && co.getNextContext().getFirstTok() <= t.lastTokenIndex)) {
              co.getTerms().add(t.string);
            }
          }
          if (outOfContext)           break;
        }
        prevCtx=ctx;
        if (co != null && co.getTerms().size() > 0)         feature.addCtxOverlapZone(co);
      }
    }
 catch (    IOException|JATEException ioe) {
      StringBuilder sb=new StringBuilder(""String_Node_Str"");
      sb.append(docId).append(""String_Node_Str"");
      sb.append(ExceptionUtils.getFullStackTrace(ioe));
      LOG.severe(sb.toString());
    }
  }
  return count;
}","/** 
 * Use existing context windows to count term/word frequency within contexts. Context overlap zones are generated for adjacent context windows.
 * @param docIds
 * @return
 */
private int useExistingContexts(List<Integer> docIds){
  int count=0;
  for (  int docId : docIds) {
    count++;
    try {
      Terms lookupVector=SolrUtil.getTermVector(docId,properties.getSolrFieldnameJATENGramInfo(),solrIndexSearcher);
      List<MWEInSentence> terms=collectTermSentenceContext(lookupVector,new HashMap<>());
      List<ContextWindow> contexts_in_doc=contextLookup.get(docId);
      if (contexts_in_doc == null || contexts_in_doc.size() == 0)       continue;
      Collections.sort(contexts_in_doc);
      int cursor=0;
      ContextWindow prevCtx=null;
      for (      ContextWindow ctx : contexts_in_doc) {
        ContextOverlap co=null;
        if (prevCtx != null && prevCtx.getSentenceId() == ctx.getSentenceId()) {
          if (prevCtx.getLastTok() >= ctx.getFirstTok()) {
            co=new ContextOverlap(prevCtx,ctx,new ArrayList<>());
          }
        }
        int indexFirstIncludedTermByContext=-1;
        for (int i=cursor; i < terms.size(); i++) {
          MWEInSentence t=terms.get(i);
          if (ctx.getSentenceId() < t.sentenceId) {
            cursor=indexFirstIncludedTermByContext;
            break;
          }
 else           if (ctx.getSentenceId() > t.sentenceId) {
            continue;
          }
          boolean outOfContext=false;
          if ((t.firstTokenIndex >= ctx.getFirstTok() && t.firstTokenIndex <= ctx.getLastTok()) || t.lastTokenIndex >= ctx.getFirstTok() && t.lastTokenIndex <= ctx.getLastTok()) {
            feature.increment(ctx,1);
            feature.increment(ctx,t.string,1);
            if (indexFirstIncludedTermByContext == -1)             indexFirstIncludedTermByContext=i;
          }
 else           if (t.lastTokenIndex < ctx.getFirstTok()) {
            continue;
          }
 else {
            outOfContext=true;
            if (indexFirstIncludedTermByContext != -1)             cursor=indexFirstIncludedTermByContext;
          }
          if (co != null) {
            if ((co.getPrevContext().getLastTok() >= t.firstTokenIndex && co.getNextContext().getFirstTok() <= t.firstTokenIndex) || (co.getPrevContext().getLastTok() >= t.lastTokenIndex && co.getNextContext().getFirstTok() <= t.lastTokenIndex) || (co.getPrevContext().getFirstTok() <= t.firstTokenIndex && co.getPrevContext().getLastTok() >= t.firstTokenIndex && co.getNextContext().getLastTok() >= t.lastTokenIndex && co.getNextContext().getFirstTok() <= t.lastTokenIndex)) {
              co.getTerms().add(t.string);
            }
          }
          if (outOfContext)           break;
        }
        prevCtx=ctx;
        if (co != null && co.getTerms().size() > 0)         feature.addCtxOverlapZone(co);
      }
    }
 catch (    IOException|JATEException ioe) {
      StringBuilder sb=new StringBuilder(""String_Node_Str"");
      sb.append(docId).append(""String_Node_Str"");
      sb.append(ExceptionUtils.getFullStackTrace(ioe));
      LOG.severe(sb.toString());
    }
  }
  return count;
}"
12366,"private int generateNewContexts(List<Integer> docIds){
  int count=0;
  Set<Integer> firstTokenIndexes=new HashSet<>();
  for (  int docId : docIds) {
    count++;
    try {
      Terms lookupVector=SolrUtil.getTermVector(docId,properties.getSolrFieldnameJATENGramInfo(),solrIndexSearcher);
      Map<Integer,Integer> sentenceBoundaries=new HashMap<>();
      List<MWEInSentence> terms=collectTermSentenceContext(lookupVector,sentenceBoundaries);
      int lastToken=-1;
      int currSentenceId=-1, currWindowStart=-1, currWindowEnd=-1;
      ContextWindow prevCtx=null;
      List<Integer> prevWindowRight=new ArrayList<>();
      for (int i=0; i < terms.size(); i++) {
        MWEInSentence term=terms.get(i);
        firstTokenIndexes.add(term.firstTokenIndex);
        if (currSentenceId == -1 || (currSentenceId != -1 && term.sentenceId != currSentenceId)) {
          currSentenceId=term.sentenceId;
          currWindowStart=-1;
          currWindowEnd=-1;
          lastToken=sentenceBoundaries.get(currSentenceId);
        }
        if (term.firstTokenIndex >= currWindowStart && term.firstTokenIndex <= currWindowEnd)         continue;
        currWindowStart=term.firstTokenIndex - window;
        if (currWindowStart < 0)         currWindowStart=0;
        currWindowEnd=term.lastTokenIndex + window;
        if (currWindowEnd >= lastToken)         currWindowEnd=lastToken;
        ContextWindow ctx=new ContextWindow();
        ctx.setDocId(docId);
        ctx.setSentenceId(currSentenceId);
        ctx.setFirstTok(currWindowStart);
        ctx.setLastTok(currWindowEnd);
        if (docId == 399 && currSentenceId == 1 && currWindowStart == 5 && currWindowEnd == 17)         System.out.println(""String_Node_Str"");
        if (docId == 399 && currSentenceId == 1 && currWindowStart == 13 && currWindowEnd == 23)         System.out.println(""String_Node_Str"");
        feature.increment(ctx,1);
        feature.increment(ctx,term.string,1);
        List<String> termsInOverlap=new ArrayList<>();
        List<Integer> currentWindowRight=new ArrayList<>();
        for (int j=i - 1; j > -1; j--) {
          MWEInSentence prevTerm=terms.get(j);
          if (prevWindowRight.size() > 0) {
            if (j < prevWindowRight.get(0))             break;
          }
 else           if (prevTerm.lastTokenIndex < currWindowStart || prevTerm.sentenceId != ctx.getSentenceId())           break;
          if ((prevTerm.firstTokenIndex >= ctx.getFirstTok() && prevTerm.firstTokenIndex <= ctx.getLastTok()) || (prevTerm.lastTokenIndex >= ctx.getFirstTok() && prevTerm.lastTokenIndex <= ctx.getLastTok())) {
            feature.increment(ctx,1);
            feature.increment(ctx,prevTerm.string,1);
            if (prevWindowRight.contains(j)) {
              termsInOverlap.add(prevTerm.string);
            }
          }
          if (prevTerm.sentenceId == term.sentenceId && prevTerm.lastTokenIndex > term.lastTokenIndex)           currentWindowRight.add(j);
        }
        if (prevCtx != null && prevCtx.getSentenceId() == ctx.getSentenceId() && termsInOverlap.size() > 0 && prevCtx.getLastTok() >= ctx.getFirstTok()) {
          ContextOverlap co=new ContextOverlap(prevCtx,ctx,termsInOverlap);
          feature.addCtxOverlapZone(co);
        }
        for (int j=i + 1; j < terms.size(); j++) {
          i=j - 1;
          MWEInSentence nextTerm=terms.get(j);
          if (nextTerm.firstTokenIndex > currWindowEnd || nextTerm.sentenceId != ctx.getSentenceId())           break;
          feature.increment(ctx,1);
          feature.increment(ctx,nextTerm.string,1);
          currentWindowRight.add(j);
        }
        prevWindowRight=currentWindowRight;
        prevCtx=ctx;
      }
    }
 catch (    IOException ioe) {
      StringBuilder sb=new StringBuilder(""String_Node_Str"");
      sb.append(docId).append(""String_Node_Str"");
      sb.append(ExceptionUtils.getFullStackTrace(ioe));
      LOG.severe(sb.toString());
    }
catch (    JATEException je) {
      StringBuilder sb=new StringBuilder(""String_Node_Str"");
      sb.append(docId).append(""String_Node_Str"");
      sb.append(ExceptionUtils.getFullStackTrace(je));
      LOG.severe(sb.toString());
    }
  }
  if (firstTokenIndexes.size() / docIds.size() <= 1)   try {
    LOG.warning(""String_Node_Str"" + properties.getSolrFieldnameJATENGramInfo() + ""String_Node_Str"");
  }
 catch (  JATEException e) {
  }
  return count;
}","private int generateNewContexts(List<Integer> docIds){
  int count=0;
  Set<Integer> firstTokenIndexes=new HashSet<>();
  for (  int docId : docIds) {
    count++;
    try {
      Terms lookupVector=SolrUtil.getTermVector(docId,properties.getSolrFieldnameJATENGramInfo(),solrIndexSearcher);
      Map<Integer,Integer> sentenceBoundaries=new HashMap<>();
      List<MWEInSentence> terms=collectTermSentenceContext(lookupVector,sentenceBoundaries);
      int lastToken=-1;
      int currSentenceId=-1, currWindowStart=-1, currWindowEnd=-1;
      ContextWindow prevCtx=null;
      List<Integer> prevWindowRight=new ArrayList<>();
      for (int i=0; i < terms.size(); i++) {
        MWEInSentence term=terms.get(i);
        firstTokenIndexes.add(term.firstTokenIndex);
        if (currSentenceId == -1 || (currSentenceId != -1 && term.sentenceId != currSentenceId)) {
          currSentenceId=term.sentenceId;
          currWindowStart=-1;
          currWindowEnd=-1;
          lastToken=sentenceBoundaries.get(currSentenceId);
        }
        if (term.firstTokenIndex >= currWindowStart && term.firstTokenIndex <= currWindowEnd)         continue;
        currWindowStart=term.firstTokenIndex - window;
        if (currWindowStart < 0)         currWindowStart=0;
        currWindowEnd=term.lastTokenIndex + window;
        if (currWindowEnd >= lastToken)         currWindowEnd=lastToken;
        ContextWindow ctx=new ContextWindow();
        ctx.setDocId(docId);
        ctx.setSentenceId(currSentenceId);
        ctx.setFirstTok(currWindowStart);
        ctx.setLastTok(currWindowEnd);
        feature.increment(ctx,1);
        feature.increment(ctx,term.string,1);
        List<String> termsInOverlap=new ArrayList<>();
        List<Integer> currentWindowRight=new ArrayList<>();
        for (int j=i - 1; j > -1; j--) {
          MWEInSentence prevTerm=terms.get(j);
          if (prevWindowRight.size() > 0) {
            if (j < prevWindowRight.get(0))             break;
          }
 else           if (prevTerm.lastTokenIndex < currWindowStart || prevTerm.sentenceId != ctx.getSentenceId())           break;
          if ((prevTerm.firstTokenIndex >= ctx.getFirstTok() && prevTerm.firstTokenIndex <= ctx.getLastTok()) || (prevTerm.lastTokenIndex >= ctx.getFirstTok() && prevTerm.lastTokenIndex <= ctx.getLastTok())) {
            feature.increment(ctx,1);
            feature.increment(ctx,prevTerm.string,1);
            if (prevWindowRight.contains(j)) {
              termsInOverlap.add(prevTerm.string);
            }
          }
          if (prevTerm.sentenceId == term.sentenceId && prevTerm.lastTokenIndex > term.lastTokenIndex)           currentWindowRight.add(j);
        }
        if (prevCtx != null && prevCtx.getSentenceId() == ctx.getSentenceId() && termsInOverlap.size() > 0 && prevCtx.getLastTok() >= ctx.getFirstTok()) {
          ContextOverlap co=new ContextOverlap(prevCtx,ctx,termsInOverlap);
          feature.addCtxOverlapZone(co);
        }
        for (int j=i + 1; j < terms.size(); j++) {
          i=j - 1;
          MWEInSentence nextTerm=terms.get(j);
          if (nextTerm.firstTokenIndex > currWindowEnd || nextTerm.sentenceId != ctx.getSentenceId())           break;
          feature.increment(ctx,1);
          feature.increment(ctx,nextTerm.string,1);
          currentWindowRight.add(j);
        }
        prevWindowRight=currentWindowRight;
        prevCtx=ctx;
      }
    }
 catch (    IOException ioe) {
      StringBuilder sb=new StringBuilder(""String_Node_Str"");
      sb.append(docId).append(""String_Node_Str"");
      sb.append(ExceptionUtils.getFullStackTrace(ioe));
      LOG.severe(sb.toString());
    }
catch (    JATEException je) {
      StringBuilder sb=new StringBuilder(""String_Node_Str"");
      sb.append(docId).append(""String_Node_Str"");
      sb.append(ExceptionUtils.getFullStackTrace(je));
      LOG.severe(sb.toString());
    }
  }
  if (firstTokenIndexes.size() / docIds.size() <= 1)   try {
    LOG.warning(""String_Node_Str"" + properties.getSolrFieldnameJATENGramInfo() + ""String_Node_Str"");
  }
 catch (  JATEException e) {
  }
  return count;
}"
12367,"@Override public boolean incrementToken() throws IOException {
  boolean tokenAvailable=false;
  int builtGramSize=0;
  if (gramSize.atMinValue() || inputWindow.size() < gramSize.getValue()) {
    shiftInputWindow();
    if (sentenceBoundaryAware)     sentenceBoundaryInWindow=findSentenceBoundary();
    gramBuilder.setLength(0);
  }
 else {
    builtGramSize=gramSize.getPreviousValue();
  }
  if (inputWindow.size() >= gramSize.getValue()) {
    boolean isAllFiller=true;
    InputWindowToken nextToken=null;
    Iterator<InputWindowToken> iter=inputWindow.iterator();
    int idxInWindow=-1;
    boolean outputThisShingle=true;
    for (int gramNum=1; iter.hasNext() && builtGramSize < gramSize.getValue(); ++gramNum) {
      nextToken=iter.next();
      idxInWindow++;
      if (idxInWindow == 0)       outputThisShingle=checkToken(nextToken);
      if (outputThisShingle && sentenceBoundaryAware)       outputThisShingle=checkSentenceBoundary(idxInWindow);
      if (outputThisShingle && idxInWindow == gramSize.getValue() - 1)       outputThisShingle=checkToken(nextToken);
      if (builtGramSize < gramNum) {
        if (builtGramSize > 0) {
          gramBuilder.append(tokenSeparator);
        }
        gramBuilder.append(nextToken.termAtt.buffer(),0,nextToken.termAtt.length());
        ++builtGramSize;
      }
      if (isAllFiller && nextToken.isFiller) {
        if (gramNum == gramSize.getValue()) {
          gramSize.advance();
        }
      }
 else {
        isAllFiller=false;
      }
    }
    if (!isAllFiller && builtGramSize == gramSize.getValue()) {
      if (gramBuilder.length() > maxCharLength || gramBuilder.length() < minCharLength)       outputThisShingle=false;
      if (outputThisShingle) {
        inputWindow.getFirst().attSource.copyTo(this);
        posIncrAtt.setPositionIncrement(isOutputHere ? 0 : 1);
        termAtt.setEmpty().append(gramBuilder);
        if (gramSize.getValue() > 1) {
          typeAtt.setType(tokenType);
          noShingleOutput=false;
        }
        offsetAtt.setOffset(offsetAtt.startOffset(),nextToken.offsetAtt.endOffset());
        if (sentenceBoundaryAware && sentenceBoundaryInWindow != -1)         posLenAtt.setPositionLength(sentenceBoundaryInWindow + 1);
 else         posIncrAtt.setPositionIncrement(builtGramSize);
        isOutputHere=true;
        gramSize.advance();
        tokenAvailable=true;
        System.out.println(new String(offsetAtt.startOffset() + ""String_Node_Str"" + offsetAtt.endOffset()+ ""String_Node_Str""+ gramBuilder.toString()));
      }
 else {
        clearAttributes();
        gramSize.advance();
        isOutputHere=true;
        tokenAvailable=true;
      }
    }
  }
  return tokenAvailable;
}","@Override public boolean incrementToken() throws IOException {
  boolean tokenAvailable=false;
  int builtGramSize=0;
  if (gramSize.atMinValue() || inputWindow.size() < gramSize.getValue()) {
    shiftInputWindow();
    if (sentenceBoundaryAware)     sentenceBoundaryInWindow=findSentenceBoundary();
    gramBuilder.setLength(0);
  }
 else {
    builtGramSize=gramSize.getPreviousValue();
  }
  if (inputWindow.size() >= gramSize.getValue()) {
    boolean isAllFiller=true;
    InputWindowToken nextToken=null;
    Iterator<InputWindowToken> iter=inputWindow.iterator();
    int idxInWindow=-1;
    boolean outputThisShingle=true;
    for (int gramNum=1; iter.hasNext() && builtGramSize < gramSize.getValue(); ++gramNum) {
      nextToken=iter.next();
      idxInWindow++;
      if (idxInWindow == 0)       outputThisShingle=checkToken(nextToken);
      if (outputThisShingle && sentenceBoundaryAware)       outputThisShingle=checkSentenceBoundary(idxInWindow);
      if (outputThisShingle && idxInWindow == gramSize.getValue() - 1)       outputThisShingle=checkToken(nextToken);
      if (builtGramSize < gramNum) {
        if (builtGramSize > 0) {
          gramBuilder.append(tokenSeparator);
        }
        gramBuilder.append(nextToken.termAtt.buffer(),0,nextToken.termAtt.length());
        ++builtGramSize;
      }
      if (isAllFiller && nextToken.isFiller) {
        if (gramNum == gramSize.getValue()) {
          gramSize.advance();
        }
      }
 else {
        isAllFiller=false;
      }
    }
    if (!isAllFiller && builtGramSize == gramSize.getValue()) {
      if (gramBuilder.length() > maxCharLength || gramBuilder.length() < minCharLength)       outputThisShingle=false;
      if (outputThisShingle) {
        inputWindow.getFirst().attSource.copyTo(this);
        posIncrAtt.setPositionIncrement(isOutputHere ? 0 : 1);
        termAtt.setEmpty().append(gramBuilder);
        if (gramSize.getValue() > 1) {
          typeAtt.setType(tokenType);
          noShingleOutput=false;
        }
        offsetAtt.setOffset(offsetAtt.startOffset(),nextToken.offsetAtt.endOffset());
        if (sentenceBoundaryAware && sentenceBoundaryInWindow != -1)         posLenAtt.setPositionLength(sentenceBoundaryInWindow + 1);
 else         posIncrAtt.setPositionIncrement(builtGramSize);
        isOutputHere=true;
        gramSize.advance();
        tokenAvailable=true;
      }
 else {
        clearAttributes();
        gramSize.advance();
        isOutputHere=true;
        tokenAvailable=true;
      }
    }
  }
  return tokenAvailable;
}"
12368,"@Override public boolean incrementToken() throws IOException {
  clearAttributes();
  if (first) {
    String[] words=walkTokens();
    if (words.length == 0) {
      return false;
    }
    String[] pos=createTags(words);
    Span[] chunks=regexChunker.find(pos);
    chunks=prune(chunks,words);
    for (    Span sp : chunks) {
      chunkSpans.put(sp.getStart(),sp.getEnd());
      chunkTypes.put(sp.getStart(),sp.getType());
    }
    first=false;
    tokenIdx=0;
  }
  if (tokenIdx == tokenAttrs.size()) {
    resetParams();
    return false;
  }
  if (chunkStart != -1 && tokenIdx == chunkEnd) {
    AttributeSource start=tokenAttrs.get(chunkStart);
    AttributeSource end=tokenAttrs.get(chunkEnd - 1);
    StringBuilder phrase=new StringBuilder();
    for (int i=chunkStart; i <= chunkEnd - 1; i++) {
      phrase.append(tokenAttrs.get(i).getAttribute(CharTermAttribute.class).buffer()).append(""String_Node_Str"");
    }
    if (phrase.toString().trim().equals(""String_Node_Str"") || phrase.toString().trim().equals(""String_Node_Str""))     System.out.println();
    termAtt.setEmpty().append(phrase.toString().trim());
    offsetAtt.setOffset(start.getAttribute(OffsetAttribute.class).startOffset(),end.getAttribute(OffsetAttribute.class).endOffset());
    typeAtt.setType(chunkTypes.get(chunkStart));
    chunkStart=-1;
    chunkEnd=-1;
    return true;
  }
  if (chunkSpans.containsKey(tokenIdx)) {
    chunkStart=tokenIdx;
    chunkEnd=chunkSpans.get(tokenIdx);
    tokenIdx++;
    return true;
  }
 else {
    tokenIdx++;
    return true;
  }
}","@Override public boolean incrementToken() throws IOException {
  clearAttributes();
  if (first) {
    String[] words=walkTokens();
    if (words.length == 0) {
      return false;
    }
    String[] pos=createTags(words);
    Span[] chunks=regexChunker.find(pos);
    chunks=prune(chunks,words);
    for (    Span sp : chunks) {
      chunkSpans.put(sp.getStart(),sp.getEnd());
      chunkTypes.put(sp.getStart(),sp.getType());
    }
    first=false;
    tokenIdx=0;
  }
  if (tokenIdx == tokenAttrs.size()) {
    resetParams();
    return false;
  }
  if (chunkStart != -1 && tokenIdx == chunkEnd) {
    AttributeSource start=tokenAttrs.get(chunkStart);
    AttributeSource end=tokenAttrs.get(chunkEnd - 1);
    StringBuilder phrase=new StringBuilder();
    for (int i=chunkStart; i <= chunkEnd - 1; i++) {
      phrase.append(tokenAttrs.get(i).getAttribute(CharTermAttribute.class).buffer()).append(""String_Node_Str"");
    }
    termAtt.setEmpty().append(phrase.toString().trim());
    offsetAtt.setOffset(start.getAttribute(OffsetAttribute.class).startOffset(),end.getAttribute(OffsetAttribute.class).endOffset());
    typeAtt.setType(chunkTypes.get(chunkStart));
    chunkStart=-1;
    chunkEnd=-1;
    return true;
  }
  if (chunkSpans.containsKey(tokenIdx)) {
    chunkStart=tokenIdx;
    chunkEnd=chunkSpans.get(tokenIdx);
    tokenIdx++;
    return true;
  }
 else {
    tokenIdx++;
    return true;
  }
}"
12369,"@Override public List<JATETerm> extract(SolrCore core,String jatePropertyFile) throws IOException, JATEException {
  SolrIndexSearcher searcher=core.getSearcher().get();
  try {
    JATEProperties properties=new JATEProperties(jatePropertyFile);
    FrequencyTermBasedFBMaster ftbb=new FrequencyTermBasedFBMaster(searcher,properties,0);
    FrequencyTermBased ftb=(FrequencyTermBased)ftbb.build();
    FrequencyCtxWindowBasedFBMaster fcsbb=new FrequencyCtxWindowBasedFBMaster(searcher,properties,null,5,0);
    FrequencyCtxBased fcsb=(FrequencyCtxBased)fcsbb.build();
    FrequencyCtxBased ref_fcsb=(FrequencyCtxBased)(new FrequencyCtxWindowBasedFBMaster(searcher,properties,fcsb.getMapCtx2TTF().keySet(),5,0).build());
    CooccurrenceFBMaster cb=new CooccurrenceFBMaster(searcher,properties,ftb,this.prefilterMinTTF,fcsb,ref_fcsb,this.prefilterMinTCF);
    Cooccurrence co=(Cooccurrence)cb.build();
    ChiSquare chi=new ChiSquare();
    chi.registerFeature(FrequencyTermBased.class.getName(),ftb);
    chi.registerFeature(FrequencyCtxBased.class.getName() + ChiSquare.SUFFIX_TERM,fcsb);
    chi.registerFeature(FrequencyCtxBased.class.getName() + ChiSquare.SUFFIX_REF_TERM,ref_fcsb);
    chi.registerFeature(Cooccurrence.class.getName(),co);
    List<JATETerm> terms=chi.execute(co.getTerms());
    terms=cutoff(terms);
    addAdditionalTermInfo(terms,searcher,properties.getSolrFieldnameJATENGramInfo(),properties.getSolrFieldnameID());
    return terms;
  }
  finally {
    searcher.close();
  }
}","@Override public List<JATETerm> extract(SolrCore core,String jatePropertyFile) throws IOException, JATEException {
  SolrIndexSearcher searcher=core.getSearcher().get();
  try {
    JATEProperties properties=new JATEProperties(jatePropertyFile);
    FrequencyTermBasedFBMaster ftbb=new FrequencyTermBasedFBMaster(searcher,properties,0);
    FrequencyTermBased ftb=(FrequencyTermBased)ftbb.build();
    FrequencyCtxWindowBasedFBMaster fcsbb=new FrequencyCtxWindowBasedFBMaster(searcher,properties,null,5,0);
    FrequencyCtxBased fcsb=(FrequencyCtxBased)fcsbb.build();
    FrequencyCtxBased ref_fcsb=(FrequencyCtxBased)(new FrequencyCtxWindowBasedFBMaster(searcher,properties,fcsb.getMapCtx2TTF().keySet(),5,0).build());
    List<String> inter=new ArrayList<>(fcsb.getCtxOverlapZones().keySet());
    inter.removeAll(ref_fcsb.getCtxOverlapZones().keySet());
    Collections.sort(inter);
    CooccurrenceFBMaster cb=new CooccurrenceFBMaster(searcher,properties,ftb,this.prefilterMinTTF,fcsb,ref_fcsb,this.prefilterMinTCF);
    Cooccurrence co=(Cooccurrence)cb.build();
    ChiSquare chi=new ChiSquare();
    chi.registerFeature(FrequencyTermBased.class.getName(),ftb);
    chi.registerFeature(FrequencyCtxBased.class.getName() + ChiSquare.SUFFIX_TERM,fcsb);
    chi.registerFeature(FrequencyCtxBased.class.getName() + ChiSquare.SUFFIX_REF_TERM,ref_fcsb);
    chi.registerFeature(Cooccurrence.class.getName(),co);
    List<JATETerm> terms=chi.execute(co.getTerms());
    terms=cutoff(terms);
    addAdditionalTermInfo(terms,searcher,properties.getSolrFieldnameJATENGramInfo(),properties.getSolrFieldnameID());
    return terms;
  }
  finally {
    searcher.close();
  }
}"
12370,"public boolean equals(Object o){
  if (o instanceof ContextWindow) {
    ContextWindow ctx=(ContextWindow)o;
    return ctx.getDocId() == getDocId() && ctx.getSentenceId() == getSentenceId() && ctx.getTokStart() == getTokStart() && ctx.getTokEnd() == getTokEnd();
  }
  return false;
}","public boolean equals(Object o){
  if (o instanceof ContextWindow) {
    ContextWindow ctx=(ContextWindow)o;
    return ctx.getDocId() == getDocId() && ctx.getSentenceId() == getSentenceId() && ctx.getFirstTok() == getFirstTok() && ctx.getLastTok() == getLastTok();
  }
  return false;
}"
12371,"public String getContextId(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(docId).append(""String_Node_Str"").append(sentenceId).append(""String_Node_Str"").append(tokStart).append(""String_Node_Str"").append(tokEnd);
  return sb.toString();
}","public String getContextId(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(docId).append(""String_Node_Str"").append(sentenceId).append(""String_Node_Str"").append(firstTok).append(""String_Node_Str"").append(lastTok);
  return sb.toString();
}"
12372,"@Override public int compareTo(ContextWindow o){
  if (docId == o.docId) {
    if (sentenceId == o.sentenceId) {
      if (tokStart == o.tokStart) {
        return Integer.valueOf(tokEnd).compareTo(o.tokEnd);
      }
      return Integer.valueOf(tokStart).compareTo(o.tokStart);
    }
    return Integer.valueOf(sentenceId).compareTo(o.sentenceId);
  }
  return Integer.valueOf(docId).compareTo(o.docId);
}","@Override public int compareTo(ContextWindow o){
  if (docId == o.docId) {
    if (sentenceId == o.sentenceId) {
      if (firstTok == o.firstTok) {
        return Integer.valueOf(lastTok).compareTo(o.lastTok);
      }
      return Integer.valueOf(firstTok).compareTo(o.firstTok);
    }
    return Integer.valueOf(sentenceId).compareTo(o.sentenceId);
  }
  return Integer.valueOf(docId).compareTo(o.docId);
}"
12373,"void deduce(int rowIndex,int colIndex,int value){
  int newValue=cooccurrence.get(rowIndex,colIndex);
  newValue-=value;
  newValue=newValue < 0 ? 0 : newValue;
  cooccurrence.setQuick(rowIndex,colIndex,newValue);
}","void deduce(int rowIndex,int colIndex,int value){
  int newValue=cooccurrence.get(rowIndex,colIndex);
  if (newValue == 0) {
    System.out.println(rowIndex + ""String_Node_Str"" + colIndex);
    System.out.println(lookupTerm(rowIndex) + ""String_Node_Str"" + lookupRefTerm(colIndex));
  }
  newValue-=value;
  newValue=newValue < 0 ? 0 : newValue;
  cooccurrence.setQuick(rowIndex,colIndex,newValue);
}"
12374,"@Override public AbstractFeature build() throws JATEException {
  List<ContextWindow> contextWindows=new ArrayList<>(ref_frequencyCtxBased.getMapCtx2TTF().keySet());
  int cores=properties.getMaxCPUCores();
  cores=cores == 0 ? 1 : cores;
  int maxPerThread=contextWindows.size() / cores;
  if (maxPerThread == 0)   maxPerThread=50;
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(cores).append(""String_Node_Str"").append(contextWindows.size()).append(""String_Node_Str"").append(maxPerThread);
  LOG.info(sb.toString());
  LOG.info(""String_Node_Str"" + minTTF + ""String_Node_Str""+ minTCF);
  Set<String> termsPassingPrefilter=new HashSet<>();
  for (  ContextWindow ctx : contextWindows) {
    Map<String,Integer> termsInContext=frequencyCtxBased.getTFIC(ctx);
    if (minTTF == 0 && minTCF == 0)     termsPassingPrefilter.addAll(termsInContext.keySet());
 else {
      for (      String term : termsInContext.keySet()) {
        if (frequencyTermBased.getTTF(term) >= minTTF && frequencyCtxBased.getContexts(term).size() >= minTCF)         termsPassingPrefilter.add(term);
      }
    }
  }
  Cooccurrence feature=new Cooccurrence(termsPassingPrefilter.size(),ref_frequencyCtxBased.getMapTerm2Ctx().size());
  LOG.info(""String_Node_Str"" + termsPassingPrefilter.size() + ""String_Node_Str""+ contextWindows.size());
  CooccurrenceFBWorker worker=new CooccurrenceFBWorker(feature,contextWindows,frequencyTermBased,minTTF,frequencyCtxBased,ref_frequencyCtxBased,minTCF,maxPerThread);
  ForkJoinPool forkJoinPool=new ForkJoinPool(cores);
  int total=forkJoinPool.invoke(worker);
  Map<String,ContextOverlap> overlaps=frequencyCtxBased.getCtxOverlapZones();
  if (overlaps.size() > 0) {
    LOG.info(""String_Node_Str"" + overlaps.size());
    for (    Map.Entry<String,ContextOverlap> en : overlaps.entrySet()) {
      String key=en.getKey();
      ContextOverlap co=en.getValue();
      Map<String,Integer> freq=new HashMap<>();
      for (      String t : co.getTerms()) {
        Integer f=freq.get(t);
        f=f == null ? 0 : f;
        f++;
        freq.put(t,f);
      }
      if (freq.size() <= 1)       continue;
      ContextOverlap ref_co=ref_frequencyCtxBased.getCtxOverlapZones().get(key);
      Map<String,Integer> ref_freq=new HashMap<>();
      if (ref_co != null) {
        for (        String t : ref_co.getTerms()) {
          Integer f=ref_freq.get(t);
          f=f == null ? 0 : f;
          f++;
          ref_freq.put(t,f);
        }
      }
      if (ref_freq.size() <= 1)       continue;
      for (      Map.Entry<String,Integer> term_in_co : freq.entrySet()) {
        int f=term_in_co.getValue();
        for (        Map.Entry<String,Integer> term_in_ref_co : ref_freq.entrySet()) {
          int rf=term_in_ref_co.getValue();
          int deduce=f < rf ? f : rf;
          int tid=feature.lookupTerm(term_in_co.getKey());
          int tid_f=feature.lookupRefTerm(term_in_ref_co.getKey());
          feature.deduce(tid,tid_f,deduce);
        }
      }
    }
  }
  sb=new StringBuilder(""String_Node_Str"" + total);
  LOG.info(sb.toString());
  return feature;
}","@Override public AbstractFeature build() throws JATEException {
  List<ContextWindow> contextWindows=new ArrayList<>(ref_frequencyCtxBased.getMapCtx2TTF().keySet());
  int cores=properties.getMaxCPUCores();
  cores=cores == 0 ? 1 : cores;
  int maxPerThread=contextWindows.size() / cores;
  if (maxPerThread == 0)   maxPerThread=50;
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(cores).append(""String_Node_Str"").append(contextWindows.size()).append(""String_Node_Str"").append(maxPerThread);
  LOG.info(sb.toString());
  LOG.info(""String_Node_Str"" + minTTF + ""String_Node_Str""+ minTCF);
  Set<String> termsPassingPrefilter=new HashSet<>();
  for (  ContextWindow ctx : contextWindows) {
    Map<String,Integer> termsInContext=frequencyCtxBased.getTFIC(ctx);
    if (minTTF == 0 && minTCF == 0)     termsPassingPrefilter.addAll(termsInContext.keySet());
 else {
      for (      String term : termsInContext.keySet()) {
        if (frequencyTermBased.getTTF(term) >= minTTF && frequencyCtxBased.getContexts(term).size() >= minTCF)         termsPassingPrefilter.add(term);
      }
    }
  }
  Cooccurrence feature=new Cooccurrence(termsPassingPrefilter.size(),ref_frequencyCtxBased.getMapTerm2Ctx().size());
  LOG.info(""String_Node_Str"" + termsPassingPrefilter.size() + ""String_Node_Str""+ contextWindows.size());
  CooccurrenceFBWorker worker=new CooccurrenceFBWorker(feature,contextWindows,frequencyTermBased,minTTF,frequencyCtxBased,ref_frequencyCtxBased,minTCF,maxPerThread);
  ForkJoinPool forkJoinPool=new ForkJoinPool(cores);
  int total=forkJoinPool.invoke(worker);
  List<String> col=new ArrayList<>(frequencyCtxBased.getCtxOverlapZones().keySet());
  col.removeAll(ref_frequencyCtxBased.getCtxOverlapZones().keySet());
  System.out.println(col.size());
  Map<String,ContextOverlap> overlaps=frequencyCtxBased.getCtxOverlapZones();
  if (overlaps.size() > 0) {
    LOG.info(""String_Node_Str"" + overlaps.size());
    for (    Map.Entry<String,ContextOverlap> en : overlaps.entrySet()) {
      String key=en.getKey();
      ContextOverlap co=en.getValue();
      Map<String,Integer> freq=new HashMap<>();
      for (      String t : co.getTerms()) {
        Integer f=freq.get(t);
        f=f == null ? 0 : f;
        f++;
        freq.put(t,f);
      }
      if (freq.size() <= 1)       continue;
      ContextOverlap ref_co=ref_frequencyCtxBased.getCtxOverlapZones().get(key);
      Map<String,Integer> ref_freq=new HashMap<>();
      if (ref_co != null) {
        for (        String t : ref_co.getTerms()) {
          Integer f=ref_freq.get(t);
          f=f == null ? 0 : f;
          f++;
          ref_freq.put(t,f);
        }
      }
      if (ref_freq.size() <= 1)       continue;
      for (      Map.Entry<String,Integer> term_in_co : freq.entrySet()) {
        int f=term_in_co.getValue();
        for (        Map.Entry<String,Integer> term_in_ref_co : ref_freq.entrySet()) {
          int rf=term_in_ref_co.getValue();
          if (term_in_co.getKey().equals(term_in_ref_co.getKey()))           continue;
          int deduce=f < rf ? f : rf;
          int tid=feature.lookupTerm(term_in_co.getKey());
          int tid_f=feature.lookupRefTerm(term_in_ref_co.getKey());
          if (tid == -1 || tid_f == -1)           continue;
          feature.deduce(tid,tid_f,deduce);
        }
      }
    }
  }
  sb=new StringBuilder(""String_Node_Str"" + total);
  LOG.info(sb.toString());
  return feature;
}"
12375,"public void addCtxOverlapZone(ContextOverlap ctxOverlapZone){
  this.ctxOverlapZones.put(ctxOverlapZone.getPrevContext().getContextId() + ""String_Node_Str"" + ctxOverlapZone.getNextContext().getContextId(),ctxOverlapZone);
}","protected synchronized void addCtxOverlapZone(ContextOverlap ctxOverlapZone){
  this.ctxOverlapZones.put(ctxOverlapZone.getPrevContext().getContextId() + ""String_Node_Str"" + ctxOverlapZone.getNextContext().getContextId(),ctxOverlapZone);
}"
12376,"/** 
 * @param solrIndexSearcher
 * @param properties
 * @param existingContextWindows  if we want to use context windows already generated by another processof FrequencyCtxWindowBasedFBMaster, pass them here. otherwise, context windows will be generated, in this case use null or an empty set
 * @param window
 * @param termOrWord
 */
public FrequencyCtxWindowBasedFBMaster(SolrIndexSearcher solrIndexSearcher,JATEProperties properties,Set<ContextWindow> existingContextWindows,int window,int termOrWord){
  super(solrIndexSearcher,properties);
  this.termOrWord=termOrWord;
  this.window=window;
  if (existingContextWindows != null) {
    contextLookup=new HashMap<>();
    for (    ContextWindow ctx : existingContextWindows) {
      List<ContextWindow> container=contextLookup.get(ctx.getDocId());
      if (container == null)       container=new ArrayList<>();
      container.add(ctx);
      contextLookup.put(ctx.getDocId(),container);
    }
  }
}","/** 
 * @param solrIndexSearcher
 * @param properties
 * @param existingContextWindows  if we want to use context windows already generated by another processof FrequencyCtxWindowBasedFBMaster, pass them here. In that case, the existing context windows are used as references, within which candidate terms/words are searched. Otherwise, context windows will be generated, in this case pass null or an empty set
 * @param window
 * @param termOrWord
 */
public FrequencyCtxWindowBasedFBMaster(SolrIndexSearcher solrIndexSearcher,JATEProperties properties,Set<ContextWindow> existingContextWindows,int window,int termOrWord){
  super(solrIndexSearcher,properties);
  this.termOrWord=termOrWord;
  this.window=window;
  if (existingContextWindows != null) {
    contextLookup=new HashMap<>();
    for (    ContextWindow ctx : existingContextWindows) {
      List<ContextWindow> container=contextLookup.get(ctx.getDocId());
      if (container == null)       container=new ArrayList<>();
      container.add(ctx);
      contextLookup.put(ctx.getDocId(),container);
    }
  }
}"
12377,"@Override public boolean incrementToken() throws IOException {
  boolean tokenAvailable=false;
  int builtGramSize=0;
  if (gramSize.atMinValue() || inputWindow.size() < gramSize.getValue()) {
    shiftInputWindow();
    if (sentenceBoundaryAware)     sentenceBoundaryInWindow=findSentenceBoundary();
    gramBuilder.setLength(0);
  }
 else {
    builtGramSize=gramSize.getPreviousValue();
  }
  if (inputWindow.size() >= gramSize.getValue()) {
    boolean isAllFiller=true;
    InputWindowToken nextToken=null;
    Iterator<InputWindowToken> iter=inputWindow.iterator();
    int idxInWindow=-1;
    boolean outputThisShingle=true;
    for (int gramNum=1; iter.hasNext() && builtGramSize < gramSize.getValue(); ++gramNum) {
      nextToken=iter.next();
      idxInWindow++;
      if (idxInWindow == 0)       outputThisShingle=checkToken(nextToken);
      if (outputThisShingle && sentenceBoundaryAware)       outputThisShingle=checkSentenceBoundary(idxInWindow);
      if (outputThisShingle && idxInWindow == gramSize.getValue() - 1)       outputThisShingle=checkToken(nextToken);
      if (builtGramSize < gramNum) {
        if (builtGramSize > 0) {
          gramBuilder.append(tokenSeparator);
        }
        gramBuilder.append(nextToken.termAtt.buffer(),0,nextToken.termAtt.length());
        ++builtGramSize;
      }
      if (isAllFiller && nextToken.isFiller) {
        if (gramNum == gramSize.getValue()) {
          gramSize.advance();
        }
      }
 else {
        isAllFiller=false;
      }
    }
    if (!isAllFiller && builtGramSize == gramSize.getValue()) {
      if (gramBuilder.length() > maxCharLength || gramBuilder.length() < minCharLength)       outputThisShingle=false;
      if (outputThisShingle) {
        inputWindow.getFirst().attSource.copyTo(this);
        posIncrAtt.setPositionIncrement(isOutputHere ? 0 : 1);
        termAtt.setEmpty().append(gramBuilder);
        if (gramSize.getValue() > 1) {
          typeAtt.setType(tokenType);
          noShingleOutput=false;
        }
        offsetAtt.setOffset(offsetAtt.startOffset(),nextToken.offsetAtt.endOffset());
        if (sentenceBoundaryAware && sentenceBoundaryInWindow != -1)         posLenAtt.setPositionLength(sentenceBoundaryInWindow + 1);
 else         posIncrAtt.setPositionIncrement(builtGramSize);
        isOutputHere=true;
        gramSize.advance();
        tokenAvailable=true;
        System.out.println(new String(offsetAtt.startOffset() + ""String_Node_Str"" + offsetAtt.endOffset()+ ""String_Node_Str""+ gramBuilder.toString()));
      }
 else {
        clearAttributes();
        gramSize.advance();
        isOutputHere=true;
        tokenAvailable=true;
      }
    }
  }
  return tokenAvailable;
}","@Override public boolean incrementToken() throws IOException {
  boolean tokenAvailable=false;
  int builtGramSize=0;
  if (gramSize.atMinValue() || inputWindow.size() < gramSize.getValue()) {
    shiftInputWindow();
    if (sentenceBoundaryAware)     sentenceBoundaryInWindow=findSentenceBoundary();
    gramBuilder.setLength(0);
  }
 else {
    builtGramSize=gramSize.getPreviousValue();
  }
  if (inputWindow.size() >= gramSize.getValue()) {
    boolean isAllFiller=true;
    InputWindowToken nextToken=null;
    Iterator<InputWindowToken> iter=inputWindow.iterator();
    int idxInWindow=-1;
    boolean outputThisShingle=true;
    for (int gramNum=1; iter.hasNext() && builtGramSize < gramSize.getValue(); ++gramNum) {
      nextToken=iter.next();
      idxInWindow++;
      if (idxInWindow == 0)       outputThisShingle=checkToken(nextToken);
      if (outputThisShingle && sentenceBoundaryAware)       outputThisShingle=checkSentenceBoundary(idxInWindow);
      if (outputThisShingle && idxInWindow == gramSize.getValue() - 1)       outputThisShingle=checkToken(nextToken);
      if (builtGramSize < gramNum) {
        if (builtGramSize > 0) {
          gramBuilder.append(tokenSeparator);
        }
        gramBuilder.append(nextToken.termAtt.buffer(),0,nextToken.termAtt.length());
        ++builtGramSize;
      }
      if (isAllFiller && nextToken.isFiller) {
        if (gramNum == gramSize.getValue()) {
          gramSize.advance();
        }
      }
 else {
        isAllFiller=false;
      }
    }
    if (!isAllFiller && builtGramSize == gramSize.getValue()) {
      if (gramBuilder.length() > maxCharLength || gramBuilder.length() < minCharLength)       outputThisShingle=false;
      if (outputThisShingle) {
        inputWindow.getFirst().attSource.copyTo(this);
        posIncrAtt.setPositionIncrement(isOutputHere ? 0 : 1);
        termAtt.setEmpty().append(gramBuilder);
        if (gramSize.getValue() > 1) {
          typeAtt.setType(tokenType);
          noShingleOutput=false;
        }
        offsetAtt.setOffset(offsetAtt.startOffset(),nextToken.offsetAtt.endOffset());
        if (sentenceBoundaryAware && sentenceBoundaryInWindow != -1)         posLenAtt.setPositionLength(sentenceBoundaryInWindow + 1);
 else         posIncrAtt.setPositionIncrement(builtGramSize);
        isOutputHere=true;
        gramSize.advance();
        tokenAvailable=true;
      }
 else {
        clearAttributes();
        gramSize.advance();
        isOutputHere=true;
        tokenAvailable=true;
      }
    }
  }
  return tokenAvailable;
}"
12378,"protected int[] clean(int start,int end,String[] tokens){
  int newStart=start, newEnd=end;
  if (removeLeadingStopwords) {
    String tok=tokens[newStart];
    if (stopWordsIgnoreCase)     tok=tok.toLowerCase();
    if (stopWords.contains(tok)) {
      newStart++;
      if (newStart > newEnd)       return null;
    }
  }
  if (removeTrailingStopwords) {
    String tok=tokens[newEnd];
    if (stopWordsIgnoreCase)     tok=tok.toLowerCase();
    if (stopWords.contains(tok)) {
      newEnd--;
      if (newStart > newEnd)       return null;
    }
  }
  if (removeLeadingSymbolicTokens) {
    String tok=tokens[newStart];
    String normalized=tok.replaceAll(""String_Node_Str"",""String_Node_Str"");
    if (normalized.length() == 0) {
      newStart++;
      if (newStart > newEnd)       return null;
    }
  }
  if (removeLeadingSymbolicTokens) {
    String tok=tokens[newEnd];
    String normalized=tok.replaceAll(""String_Node_Str"",""String_Node_Str"");
    if (normalized.length() == 0) {
      newEnd--;
      if (newStart > newEnd)       return null;
    }
  }
  if (newEnd == end && newStart == start)   return new int[]{newStart,newEnd};
 else   return clean(newStart,newEnd,tokens);
}","/** 
 * @param start
 * @param end THIS IS EXCLUSIVE
 * @param tokens
 * @return
 */
protected int[] clean(int start,int end,String[] tokens){
  int newStart=start, newEnd=end;
  if (removeLeadingStopwords) {
    String tok=tokens[newStart];
    if (stopWordsIgnoreCase)     tok=tok.toLowerCase();
    if (stopWords.contains(tok)) {
      newStart++;
      if (newStart >= newEnd)       return null;
    }
  }
  if (removeTrailingStopwords) {
    String tok=tokens[newEnd - 1];
    if (stopWordsIgnoreCase)     tok=tok.toLowerCase();
    if (stopWords.contains(tok)) {
      newEnd--;
      if (newStart >= newEnd)       return null;
    }
  }
  if (removeLeadingSymbolicTokens) {
    String tok=tokens[newStart];
    String normalized=tok.replaceAll(""String_Node_Str"",""String_Node_Str"");
    if (normalized.length() == 0) {
      newStart++;
      if (newStart >= newEnd)       return null;
    }
  }
  if (removeLeadingSymbolicTokens) {
    String tok=tokens[newEnd - 1];
    String normalized=tok.replaceAll(""String_Node_Str"",""String_Node_Str"");
    if (normalized.length() == 0) {
      newEnd--;
      if (newStart >= newEnd)       return null;
    }
  }
  if (newEnd == end && newStart == start)   return new int[]{newStart,newEnd};
 else   if (newEnd - newStart == 1)   return new int[]{newStart,newEnd};
 else   return clean(newStart,newEnd,tokens);
}"
12379,"/** 
 * Assert that the User-Agent header is of the expected form.
 */
@Test public void testUserAgentHeaderString(){
  assertTrue(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",new Version().getUserAgentString().matches(userAgentRegex));
}","/** 
 * Assert that the User-Agent header is of the expected form.
 */
@Test public void testUserAgentHeaderString(){
  assertTrue(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",new LibraryVersion().getUserAgentString().matches(userAgentRegex));
}"
12380,"/** 
 * <p> Execute request without returning data from server. </p> <p> Call   {@code responseAsString},   {@code responseAsBytes}, or   {@code responseAsInputStream}after   {@code execute} if the response body is required.</p> <P> Note if the URL contains user information it will be encoded in a BasicAuth header. </P>
 * @return An {@link HttpConnection} which can be used to obtain the response body
 * @throws IOException if there was a problem writing data to the server
 */
public HttpConnection execute() throws IOException {
  boolean retry=true;
  int n=numberOfRetries;
  while (retry && n-- > 0) {
    connection=connectionFactory.openConnection(url);
    connection.setRequestProperty(""String_Node_Str"",USER_AGENT);
    if (url.getUserInfo() != null) {
      requestInterceptors.add(0,new BasicAuthInterceptor(url.getUserInfo()));
    }
    connection.setDoInput(true);
    connection.setRequestMethod(requestMethod);
    if (contentType != null) {
      connection.setRequestProperty(""String_Node_Str"",contentType);
    }
    HttpConnectionInterceptorContext currentContext=new HttpConnectionInterceptorContext(this);
    for (    HttpConnectionRequestInterceptor requestInterceptor : requestInterceptors) {
      currentContext=requestInterceptor.interceptRequest(currentContext);
    }
    for (    String key : requestProperties.keySet()) {
      connection.setRequestProperty(key,requestProperties.get(key));
    }
    if (input != null) {
      connection.setDoOutput(true);
      if (inputLength != -1) {
        connection.setFixedLengthStreamingMode((int)this.inputLength);
      }
 else {
        connection.setChunkedStreamingMode(1024);
      }
      InputStream is=input.getInputStream();
      OutputStream os=connection.getOutputStream();
      try {
        IOUtils.copy(is,os);
        os.flush();
      }
  finally {
        IOUtils.closeQuietly(is);
        IOUtils.closeQuietly(os);
      }
    }
    for (    HttpConnectionResponseInterceptor responseInterceptor : responseInterceptors) {
      currentContext=responseInterceptor.interceptResponse(currentContext);
    }
    retry=currentContext.replayRequest;
    if (n == 0) {
      logger.info(""String_Node_Str"");
    }
  }
  return this;
}","/** 
 * <p> Execute request without returning data from server. </p> <p> Call   {@code responseAsString},   {@code responseAsBytes}, or   {@code responseAsInputStream}after   {@code execute} if the response body is required.</p> <P> Note if the URL contains user information it will be encoded in a BasicAuth header. </P>
 * @return An {@link HttpConnection} which can be used to obtain the response body
 * @throws IOException if there was a problem writing data to the server
 */
public HttpConnection execute() throws IOException {
  boolean retry=true;
  int n=numberOfRetries;
  while (retry && n-- > 0) {
    connection=connectionFactory.openConnection(url);
    connection.setRequestProperty(""String_Node_Str"",USER_AGENT);
    if (url.getUserInfo() != null) {
      requestInterceptors.add(0,new BasicAuthInterceptor(url.getUserInfo()));
    }
    connection.setDoInput(true);
    connection.setRequestMethod(requestMethod);
    if (contentType != null) {
      connection.setRequestProperty(""String_Node_Str"",contentType);
    }
    HttpConnectionInterceptorContext currentContext=new HttpConnectionInterceptorContext(this);
    for (    HttpConnectionRequestInterceptor requestInterceptor : requestInterceptors) {
      currentContext=requestInterceptor.interceptRequest(currentContext);
    }
    for (    Map.Entry<String,String> property : requestProperties.entrySet()) {
      connection.setRequestProperty(property.getKey(),property.getValue());
    }
    if (input != null) {
      connection.setDoOutput(true);
      if (inputLength != -1) {
        connection.setFixedLengthStreamingMode((int)this.inputLength);
      }
 else {
        connection.setChunkedStreamingMode(1024);
      }
      InputStream is=input.getInputStream();
      OutputStream os=connection.getOutputStream();
      try {
        IOUtils.copy(is,os);
        os.flush();
      }
  finally {
        IOUtils.closeQuietly(is);
        IOUtils.closeQuietly(os);
      }
    }
    for (    HttpConnectionResponseInterceptor responseInterceptor : responseInterceptors) {
      currentContext=responseInterceptor.interceptResponse(currentContext);
    }
    retry=currentContext.replayRequest;
    if (n == 0) {
      logger.info(""String_Node_Str"");
    }
  }
  return this;
}"
12381,"private DatabaseURIHelper revId(String revId){
  this.path(revId);
  return returnThis();
}","private DatabaseURIHelper revId(String revId){
  this.query(""String_Node_Str"",revId);
  return returnThis();
}"
12382,"public InputStream executeToInputStream(HttpConnection connection) throws CouchDbException {
  if (proxyUrl != null) {
    connection.setProxy(proxyUrl);
  }
  connection.requestProperties.put(""String_Node_Str"",""String_Node_Str"");
  connection.responseInterceptors.addAll(this.responseInterceptors);
  connection.requestInterceptors.addAll(this.requestInterceptors);
  InputStream is=null;
  InputStream es=null;
  String response=null;
  int code=-1;
  Throwable cause=null;
  try {
    is=connection.execute().responseAsInputStream();
  }
 catch (  IOException ioe) {
    cause=ioe;
  }
  try {
    code=connection.getConnection().getResponseCode();
    response=connection.getConnection().getResponseMessage();
    if (code / 100 == 2) {
      return is;
    }
 else     if (code == 404) {
      throw new NoDocumentException(response,cause);
    }
 else     if (code == 412) {
      throw new PreconditionFailedException(response,cause);
    }
 else {
      CouchDbException ex=new CouchDbException(response,code);
      es=connection.getConnection().getErrorStream();
      if (es != null) {
        try {
          ex=getGson().fromJson(new InputStreamReader(es),CouchDbException.class);
          ex.setStatusCode(code);
        }
 catch (        JsonParseException e) {
        }
      }
      throw ex;
    }
  }
 catch (  IOException ioe) {
    throw new CouchDbException(""String_Node_Str"",ioe,code);
  }
 finally {
    close(es);
  }
}","public InputStream executeToInputStream(HttpConnection connection) throws CouchDbException {
  if (proxyUrl != null) {
    connection.setProxy(proxyUrl);
  }
  connection.requestProperties.put(""String_Node_Str"",""String_Node_Str"");
  connection.responseInterceptors.addAll(this.responseInterceptors);
  connection.requestInterceptors.addAll(this.requestInterceptors);
  InputStream es=null;
  try {
    connection=connection.execute();
    int code=connection.getConnection().getResponseCode();
    String response=connection.getConnection().getResponseMessage();
    if (code / 100 == 2) {
      return connection.responseAsInputStream();
    }
 else {
      CouchDbException ex=new CouchDbException(response,code);
switch (code) {
case 404:
        ex=new NoDocumentException(response);
      break;
case 409:
    ex=new DocumentConflictException(response);
  break;
case 412:
ex=new PreconditionFailedException(response);
break;
}
es=connection.getConnection().getErrorStream();
if (es != null) {
Class<? extends CouchDbException> exceptionClass=ex.getClass();
try {
ex=getGson().fromJson(new InputStreamReader(es),exceptionClass);
}
 catch (JsonParseException e) {
}
}
ex.setStatusCode(code);
throw ex;
}
}
 catch (IOException ioe) {
throw new CouchDbException(""String_Node_Str"",ioe);
}
 finally {
close(es);
}
}"
12383,"/** 
 * Performs a HTTP PUT request, saves or updates a document.
 * @param object    Object for updating request
 * @param newEntity If true, saves a new document. Else, updates an existing one.
 * @return {@link Response}
 */
public Response put(URI uri,Object object,boolean newEntity,int writeQuorum){
  assertNotEmpty(object,""String_Node_Str"");
  try {
    final JsonObject json=getGson().toJsonTree(object).getAsJsonObject();
    String id=getAsString(json,""String_Node_Str"");
    String rev=getAsString(json,""String_Node_Str"");
    if (newEntity) {
      assertNull(rev,""String_Node_Str"");
      id=(id == null) ? generateUUID() : id;
    }
 else {
      assertNotEmpty(id,""String_Node_Str"");
      assertNotEmpty(rev,""String_Node_Str"");
    }
    URI httpUri=null;
    if (writeQuorum > -1) {
      httpUri=buildUri(uri).pathToEncode(id).query(""String_Node_Str"",writeQuorum).buildEncoded();
    }
 else {
      httpUri=buildUri(uri).pathToEncode(id).buildEncoded();
    }
    HttpConnection connection=Http.PUT(httpUri,""String_Node_Str"");
    connection.setRequestBody(json.toString());
    return executeToResponse(connection);
  }
 catch (  CouchDbException e) {
    if (e.getStatusCode() == 409) {
      throw new DocumentConflictException(e.toString());
    }
 else {
      throw e;
    }
  }
}","/** 
 * Performs a HTTP PUT request, saves or updates a document.
 * @param object    Object for updating request
 * @param newEntity If true, saves a new document. Else, updates an existing one.
 * @return {@link Response}
 */
public Response put(URI uri,Object object,boolean newEntity,int writeQuorum){
  assertNotEmpty(object,""String_Node_Str"");
  final JsonObject json=getGson().toJsonTree(object).getAsJsonObject();
  String id=getAsString(json,""String_Node_Str"");
  String rev=getAsString(json,""String_Node_Str"");
  if (newEntity) {
    assertNull(rev,""String_Node_Str"");
    id=(id == null) ? generateUUID() : id;
  }
 else {
    assertNotEmpty(id,""String_Node_Str"");
    assertNotEmpty(rev,""String_Node_Str"");
  }
  URI httpUri=null;
  if (writeQuorum > -1) {
    httpUri=buildUri(uri).pathToEncode(id).query(""String_Node_Str"",writeQuorum).buildEncoded();
  }
 else {
    httpUri=buildUri(uri).pathToEncode(id).buildEncoded();
  }
  HttpConnection connection=Http.PUT(httpUri,""String_Node_Str"");
  connection.setRequestBody(json.toString());
  return executeToResponse(connection);
}"
12384,"/** 
 * Executes a HTTP request. <p><b>Note</b>: The stream must be closed after use to release the connection.
 * @param connection The HTTP request to execute.
 * @return Class type of object T (i.e. {@link Response}
 */
public Response executeToResponse(HttpConnection connection){
  InputStream is=null;
  try {
    is=this.executeToInputStream(connection);
    return getResponse(is,Response.class,getGson());
  }
 catch (  CouchDbException e) {
    if (e.getStatusCode() == 409) {
      throw new DocumentConflictException(e.toString());
    }
 else {
      throw e;
    }
  }
 finally {
    close(is);
  }
}","/** 
 * Executes a HTTP request. <p><b>Note</b>: The stream must be closed after use to release the connection.
 * @param connection The HTTP request to execute.
 * @return Class type of object T (i.e. {@link Response}
 */
public Response executeToResponse(HttpConnection connection){
  InputStream is=null;
  try {
    is=this.executeToInputStream(connection);
    return getResponse(is,Response.class,getGson());
  }
  finally {
    close(is);
  }
}"
12385,"/** 
 * <p> Execute request without returning data from server. </p> <p> Call   {@code responseAsString},   {@code responseAsBytes}, or   {@code responseAsInputStream}after   {@code execute} if the response body is required.</p>
 * @return An {@link HttpConnection} which can be used to obtain the response body
 * @throws IOException if there was a problem writing data to the server
 */
public HttpConnection execute() throws IOException {
  boolean retry=true;
  int n=numberOfRetries;
  while (retry && n-- > 0) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    if (proxy != null) {
      connection=(HttpURLConnection)url.openConnection(proxy);
    }
 else {
      connection=(HttpURLConnection)url.openConnection();
    }
    connection.setRequestProperty(""String_Node_Str"",AgentHelper.USER_AGENT);
    if (url.getUserInfo() != null) {
      requestInterceptors.add(new BasicAuthInterceptor(url.getUserInfo()));
    }
    connection.setDoInput(true);
    connection.setRequestMethod(requestMethod);
    if (contentType != null) {
      connection.setRequestProperty(""String_Node_Str"",contentType);
    }
    HttpConnectionInterceptorContext currentContext=new HttpConnectionInterceptorContext(this);
    for (    HttpConnectionRequestInterceptor requestInterceptor : requestInterceptors) {
      currentContext=requestInterceptor.interceptRequest(currentContext);
    }
    for (    String key : requestProperties.keySet()) {
      connection.setRequestProperty(key,requestProperties.get(key));
    }
    if (input != null) {
      connection.setDoOutput(true);
      if (inputLength != -1) {
        connection.setFixedLengthStreamingMode((int)this.inputLength);
      }
 else {
        connection.setChunkedStreamingMode(1024);
      }
      connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      int bufSize=1024;
      int nRead=0;
      byte[] buf=new byte[bufSize];
      InputStream is=input;
      OutputStream os=connection.getOutputStream();
      while ((nRead=is.read(buf)) >= 0) {
        os.write(buf,0,nRead);
      }
      os.flush();
    }
    for (    HttpConnectionResponseInterceptor responseInterceptor : responseInterceptors) {
      currentContext=responseInterceptor.interceptResponse(currentContext);
    }
    retry=currentContext.replayRequest;
    if (n == 0) {
      logger.info(""String_Node_Str"");
    }
  }
  return this;
}","/** 
 * <p> Execute request without returning data from server. </p> <p> Call   {@code responseAsString},   {@code responseAsBytes}, or   {@code responseAsInputStream}after   {@code execute} if the response body is required.</p>
 * @return An {@link HttpConnection} which can be used to obtain the response body
 * @throws IOException if there was a problem writing data to the server
 */
public HttpConnection execute() throws IOException {
  boolean retry=true;
  int n=numberOfRetries;
  while (retry && n-- > 0) {
    if (proxy != null) {
      connection=(HttpURLConnection)url.openConnection(proxy);
    }
 else {
      connection=(HttpURLConnection)url.openConnection();
    }
    connection.setRequestProperty(""String_Node_Str"",AgentHelper.USER_AGENT);
    if (url.getUserInfo() != null) {
      requestInterceptors.add(new BasicAuthInterceptor(url.getUserInfo()));
    }
    connection.setDoInput(true);
    connection.setRequestMethod(requestMethod);
    if (contentType != null) {
      connection.setRequestProperty(""String_Node_Str"",contentType);
    }
    HttpConnectionInterceptorContext currentContext=new HttpConnectionInterceptorContext(this);
    for (    HttpConnectionRequestInterceptor requestInterceptor : requestInterceptors) {
      currentContext=requestInterceptor.interceptRequest(currentContext);
    }
    for (    String key : requestProperties.keySet()) {
      connection.setRequestProperty(key,requestProperties.get(key));
    }
    if (input != null) {
      connection.setDoOutput(true);
      if (inputLength != -1) {
        connection.setFixedLengthStreamingMode((int)this.inputLength);
      }
 else {
        connection.setChunkedStreamingMode(1024);
      }
      connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      int bufSize=1024;
      int nRead=0;
      byte[] buf=new byte[bufSize];
      InputStream is=input;
      OutputStream os=connection.getOutputStream();
      while ((nRead=is.read(buf)) >= 0) {
        os.write(buf,0,nRead);
      }
      os.flush();
    }
    for (    HttpConnectionResponseInterceptor responseInterceptor : responseInterceptors) {
      currentContext=responseInterceptor.interceptResponse(currentContext);
    }
    retry=currentContext.replayRequest;
    if (n == 0) {
      logger.info(""String_Node_Str"");
    }
  }
  return this;
}"
12386,"/** 
 * @return A JSON element as a String, or null if not found, from the response
 */
public static String getAsString(InputStream response,String e){
  InputStream instream=null;
  try {
    Reader reader=new InputStreamReader(instream,""String_Node_Str"");
    return getAsString(new JsonParser().parse(reader).getAsJsonObject(),e);
  }
 catch (  UnsupportedEncodingException e1) {
    throw new RuntimeException(e1);
  }
 finally {
    close(instream);
  }
}","/** 
 * @return A JSON element as a String, or null if not found, from the response
 */
public static String getAsString(InputStream response,String e){
  Reader reader=null;
  try {
    reader=new InputStreamReader(response,""String_Node_Str"");
    return getAsString(new JsonParser().parse(reader).getAsJsonObject(),e);
  }
 catch (  UnsupportedEncodingException e1) {
    throw new RuntimeException(e1);
  }
 finally {
    close(reader);
    close(response);
  }
}"
12387,"/** 
 * Build a request for the _all_docs endpoint. <P> Example usage: <pre>  {@code getAllDocsRequestBuilder().build().getResponse();}</pre> </P>
 * @return a request builder for the _all_docs endpoint of this database
 */
public AllDocsRequestBuilder getAllDocsRequestBuilder(){
  return new AllDocsRequestBuilderImpl(new ViewQueryParameters<String,Document.Revision>(client,this,""String_Node_Str"",""String_Node_Str"",String.class,Document.Revision.class){
    protected URIBuilder getViewURIBuilder(){
      return URIBuilder.buildUri(db.getDBUri()).path(""String_Node_Str"");
    }
  }
);
}","/** 
 * Build a request for the _all_docs endpoint. <P> Example usage: </P> <pre>  {@code getAllDocsRequestBuilder().build().getResponse();}</pre>
 * @return a request builder for the _all_docs endpoint of this database
 */
public AllDocsRequestBuilder getAllDocsRequestBuilder(){
  return new AllDocsRequestBuilderImpl(new ViewQueryParameters<String,Document.Revision>(client,this,""String_Node_Str"",""String_Node_Str"",String.class,Document.Revision.class){
    protected URIBuilder getViewURIBuilder(){
      return URIBuilder.buildUri(db.getDBUri()).path(""String_Node_Str"");
    }
  }
);
}"
12388,"/** 
 * Constructs a new instance of this class and connects to the cloudant account with the specified credentials
 * @param account The cloudant account to connect to
 * @param authCookie The cookie obtained from last login
 * @param connectOptions optional properties to connect e.g connectionTime,socketTimeout,etc 
 */
public CloudantClient(String account,String authCookie,ConnectOptions connectOptions){
  super();
  Map<String,String> h=parseAccount(account);
  assertNotEmpty(authCookie,""String_Node_Str"");
  CouchDbProperties props=new CouchDbProperties(h.get(""String_Node_Str""),h.get(""String_Node_Str""),new Integer(h.get(""String_Node_Str"")).intValue(),authCookie);
  if (connectOptions != null) {
    props.setConnectionTimeout(connectOptions.getConnectionTimeout());
    props.setSocketTimeout(connectOptions.getSocketTimeout());
    props.setMaxConnections(connectOptions.getMaxConnections());
    props.setProxyHost(connectOptions.getProxyHost());
    props.setProxyPort(connectOptions.getProxyPort());
  }
  this.client=new CouchDbClient(props);
}","/** 
 * Constructs a new instance of this class and connects to the cloudant account with the specified credentials
 * @param account For cloudant.com, the cloudant account to connect to. For Cloudant local, the server URL
 * @param account The cloudant account to connect to
 * @param authCookie The cookie obtained from last login
 * @param connectOptions optional properties to connect e.g connectionTime,socketTimeout,etc 
 */
public CloudantClient(String account,String authCookie,ConnectOptions connectOptions){
  super();
  Map<String,String> h=parseAccount(account);
  assertNotEmpty(authCookie,""String_Node_Str"");
  CouchDbProperties props=new CouchDbProperties(h.get(""String_Node_Str""),h.get(""String_Node_Str""),new Integer(h.get(""String_Node_Str"")).intValue(),authCookie);
  if (connectOptions != null) {
    props.setConnectionTimeout(connectOptions.getConnectionTimeout());
    props.setSocketTimeout(connectOptions.getSocketTimeout());
    props.setMaxConnections(connectOptions.getMaxConnections());
    props.setProxyHost(connectOptions.getProxyHost());
    props.setProxyPort(connectOptions.getProxyPort());
  }
  this.client=new CouchDbClient(props);
}"
12389,"/** 
 * @param selectorJson
 * @param sortOrder
 * @param limit
 * @param skip
 * @param returnFields
 * @param readQuorum
 * @return
 */
private String getFindByIndexBody(String selectorJson,FindByIndexOptions options){
  StringBuilder rf=null;
  if (options.getFields().size() > 0) {
    rf=new StringBuilder(""String_Node_Str"");
    int i=0;
    for (    String s : options.getFields()) {
      if (i > 0) {
        rf.append(""String_Node_Str"");
      }
      rf.append(""String_Node_Str"").append(s).append(""String_Node_Str"");
      i++;
    }
    rf.append(""String_Node_Str"");
  }
  StringBuilder so=null;
  if (options.getSort().size() > 0) {
    so=new StringBuilder(""String_Node_Str"");
    int i=0;
    for (    IndexField idxfld : options.getSort()) {
      if (i > 0) {
        so.append(""String_Node_Str"");
      }
      so.append(""String_Node_Str"").append(idxfld.getName()).append(""String_Node_Str"").append(idxfld.getOrder()).append(""String_Node_Str"");
    }
    so.append(""String_Node_Str"");
  }
  StringBuilder finalbody=new StringBuilder(""String_Node_Str"" + selectorJson);
  if (rf != null) {
    finalbody.append(""String_Node_Str"").append(rf.toString());
  }
  if (so != null) {
    finalbody.append(""String_Node_Str"").append(so.toString());
  }
  if (options.getLimit() != null) {
    finalbody.append(""String_Node_Str"").append(""String_Node_Str"").append(options.getLimit());
  }
  if (options.getSkip() != null) {
    finalbody.append(""String_Node_Str"").append(""String_Node_Str"").append(options.getSkip());
  }
  if (options.getReadQuorum() != null) {
    finalbody.append(""String_Node_Str"").append(""String_Node_Str"").append(options.getReadQuorum());
  }
  finalbody.append(""String_Node_Str"");
  return finalbody.toString();
}","/** 
 * @param selectorJson
 * @param sortOrder
 * @param limit
 * @param skip
 * @param returnFields
 * @param readQuorum
 * @return
 */
private String getFindByIndexBody(String selectorJson,FindByIndexOptions options){
  StringBuilder rf=null;
  if (options.getFields().size() > 0) {
    rf=new StringBuilder(""String_Node_Str"");
    int i=0;
    for (    String s : options.getFields()) {
      if (i > 0) {
        rf.append(""String_Node_Str"");
      }
      rf.append(""String_Node_Str"").append(s).append(""String_Node_Str"");
      i++;
    }
    rf.append(""String_Node_Str"");
  }
  StringBuilder so=null;
  if (options.getSort().size() > 0) {
    so=new StringBuilder(""String_Node_Str"");
    int i=0;
    for (    IndexField idxfld : options.getSort()) {
      if (i > 0) {
        so.append(""String_Node_Str"");
      }
      so.append(""String_Node_Str"").append(idxfld.getName()).append(""String_Node_Str"").append(idxfld.getOrder()).append(""String_Node_Str"");
    }
    so.append(""String_Node_Str"");
  }
  boolean isObject=true;
  try {
    getGson().fromJson(selectorJson,JsonObject.class);
  }
 catch (  JsonParseException e) {
    isObject=false;
  }
  if (!isObject) {
    if (!(selectorJson.trim().startsWith(""String_Node_Str""))) {
      throw new JsonParseException(""String_Node_Str"");
    }
  }
  StringBuilder finalbody=new StringBuilder();
  if (isObject) {
    finalbody.append(""String_Node_Str"").append(selectorJson);
  }
 else {
    finalbody.append(""String_Node_Str"" + selectorJson);
  }
  if (rf != null) {
    finalbody.append(""String_Node_Str"").append(rf.toString());
  }
  if (so != null) {
    finalbody.append(""String_Node_Str"").append(so.toString());
  }
  if (options.getLimit() != null) {
    finalbody.append(""String_Node_Str"").append(""String_Node_Str"").append(options.getLimit());
  }
  if (options.getSkip() != null) {
    finalbody.append(""String_Node_Str"").append(""String_Node_Str"").append(options.getSkip());
  }
  if (options.getReadQuorum() != null) {
    finalbody.append(""String_Node_Str"").append(""String_Node_Str"").append(options.getReadQuorum());
  }
  finalbody.append(""String_Node_Str"");
  return finalbody.toString();
}"
12390,"@Test public void indexTestAll(){
  db.createIndex(""String_Node_Str"",""String_Node_Str"",null,new IndexField[]{new IndexField(""String_Node_Str"",SortOrder.asc),new IndexField(""String_Node_Str"",SortOrder.asc)});
  db.createIndex(""String_Node_Str"",""String_Node_Str"",null,new IndexField[]{new IndexField(""String_Node_Str"",SortOrder.asc)});
  List<Index> indices=db.listIndices();
  assertNotNull(indices);
  assert(indices.size() > 0);
  for (  Index i : indices) {
    assertNotNull(i.getName());
    assertNotNull(i.getFields());
    Iterator<IndexField> flds=i.getFields();
    assert(flds.hasNext());
    while (flds.hasNext()) {
      IndexField fld=flds.next();
      assertNotNull(fld.getName());
      assertNotNull(fld.getOrder());
    }
  }
  List<Movie> movies=db.findByIndex(""String_Node_Str"",Movie.class,new FindByIndexOptions().sort(new IndexField(""String_Node_Str"",SortOrder.desc)).fields(""String_Node_Str"").fields(""String_Node_Str""));
  assertNotNull(movies);
  assert(movies.size() > 0);
  for (  Movie m : movies) {
    assertNotNull(m.getMovie_name());
    assertNotNull(m.getMovie_year());
  }
  movies=db.findByIndex(""String_Node_Str"",Movie.class,new FindByIndexOptions().sort(new IndexField(""String_Node_Str"",SortOrder.desc)).fields(""String_Node_Str"").fields(""String_Node_Str"").limit(1).skip(1).readQuorum(2));
  assertNotNull(movies);
  assert(movies.size() == 1);
  for (  Movie m : movies) {
    assertNotNull(m.getMovie_name());
    assertNotNull(m.getMovie_year());
  }
  db.deleteIndex(""String_Node_Str"",""String_Node_Str"");
  db.deleteIndex(""String_Node_Str"",""String_Node_Str"");
}","@Test public void indexTestAll(){
  db.createIndex(""String_Node_Str"",""String_Node_Str"",null,new IndexField[]{new IndexField(""String_Node_Str"",SortOrder.asc),new IndexField(""String_Node_Str"",SortOrder.asc)});
  db.createIndex(""String_Node_Str"",""String_Node_Str"",null,new IndexField[]{new IndexField(""String_Node_Str"",SortOrder.asc)});
  List<Index> indices=db.listIndices();
  assertNotNull(indices);
  assert(indices.size() > 0);
  for (  Index i : indices) {
    assertNotNull(i.getName());
    assertNotNull(i.getFields());
    Iterator<IndexField> flds=i.getFields();
    assert(flds.hasNext());
    while (flds.hasNext()) {
      IndexField fld=flds.next();
      assertNotNull(fld.getName());
      assertNotNull(fld.getOrder());
    }
  }
  List<Movie> movies=db.findByIndex(""String_Node_Str"",Movie.class,new FindByIndexOptions().sort(new IndexField(""String_Node_Str"",SortOrder.desc)).fields(""String_Node_Str"").fields(""String_Node_Str""));
  assertNotNull(movies);
  assert(movies.size() > 0);
  for (  Movie m : movies) {
    assertNotNull(m.getMovie_name());
    assertNotNull(m.getMovie_year());
  }
  movies=db.findByIndex(""String_Node_Str"",Movie.class,new FindByIndexOptions().sort(new IndexField(""String_Node_Str"",SortOrder.desc)).fields(""String_Node_Str"").fields(""String_Node_Str"").limit(1).skip(1).readQuorum(2));
  assertNotNull(movies);
  assert(movies.size() == 1);
  for (  Movie m : movies) {
    assertNotNull(m.getMovie_name());
    assertNotNull(m.getMovie_year());
  }
  Map<String,Object> year=new HashMap<String,Object>();
  year.put(""String_Node_Str"",new Integer(1960));
  Map<String,Object> selector=new HashMap<String,Object>();
  selector.put(""String_Node_Str"",year);
  selector.put(""String_Node_Str"",""String_Node_Str"");
  movies=db.findByIndex(new GsonBuilder().create().toJson(selector),Movie.class,new FindByIndexOptions().sort(new IndexField(""String_Node_Str"",SortOrder.desc)).fields(""String_Node_Str"").fields(""String_Node_Str"").limit(1).skip(1).readQuorum(2));
  assertNotNull(movies);
  assert(movies.size() == 1);
  for (  Movie m : movies) {
    assertNotNull(m.getMovie_name());
    assertNotNull(m.getMovie_year());
  }
  db.deleteIndex(""String_Node_Str"",""String_Node_Str"");
  db.deleteIndex(""String_Node_Str"",""String_Node_Str"");
}"
12391,"/** 
 * Constructs a new instance of this class and connects to the cloudant account with the specified credentials
 * @param account For cloudant.com, the cloudant account to connect to. For Cloudant local, the server URL
 * @param account The cloudant account to connect to
 * @param authCookie The cookie obtained from last login
 * @param connectOptions optional properties to connect e.g connectionTime,socketTimeout,etc 
 */
public CloudantClient(String account,String authCookie,ConnectOptions connectOptions){
  super();
  Map<String,String> h=parseAccount(account);
  assertNotEmpty(authCookie,""String_Node_Str"");
  CouchDbProperties props=new CouchDbProperties(h.get(""String_Node_Str""),h.get(""String_Node_Str""),new Integer(h.get(""String_Node_Str"")).intValue(),authCookie);
  if (connectOptions != null) {
    props.setConnectionTimeout(connectOptions.getConnectionTimeout());
    props.setSocketTimeout(connectOptions.getSocketTimeout());
    props.setMaxConnections(connectOptions.getMaxConnections());
    props.setProxyHost(connectOptions.getProxyHost());
    props.setProxyPort(connectOptions.getProxyPort());
  }
  this.client=new CouchDbClient(props);
}","/** 
 * Constructs a new instance of this class and connects to the cloudant account with the specified credentials
 * @param account For cloudant.com, the cloudant account to connect to. For Cloudant local, the server URL
 * @param account The cloudant account to connect to
 * @param authCookie The cookie obtained from last login
 * @param connectOptions optional properties to connect e.g connectionTime,socketTimeout,etc 
 */
public CloudantClient(String account,String authCookie,ConnectOptions connectOptions){
  super();
  Map<String,String> h=parseAccount(account);
  assertNotEmpty(authCookie,""String_Node_Str"");
  doInit(h.get(""String_Node_Str""),h.get(""String_Node_Str""),new Integer(h.get(""String_Node_Str"")).intValue(),null,null,connectOptions,authCookie);
}"
12392,"/** 
 * Get all active tasks
 * @return List of tasks
 */
public List<Task> getActiveTasks(){
  HttpResponse response=null;
  HttpGet get=new HttpGet(buildUri(getBaseUri()).path(""String_Node_Str"").build());
  try {
    response=executeRequest(get);
    return getResponseList(response,Database.getGson(),Task.class,new TypeToken<List<Task>>(){
    }
.getType());
  }
  finally {
    close(response);
  }
}","/** 
 * Get all active tasks
 * @return List of tasks
 */
public List<Task> getActiveTasks(){
  HttpResponse response=null;
  HttpGet get=new HttpGet(buildUri(getBaseUri()).path(""String_Node_Str"").build());
  try {
    response=executeRequest(get);
    return getResponseList(response,client.getGson(),Task.class,new TypeToken<List<Task>>(){
    }
.getType());
  }
  finally {
    close(response);
  }
}"
12393,"/** 
 * List all indices
 * @return List of Index
 */
public List<Index> listIndices(){
  HttpResponse response=null;
  try {
    response=client.executeRequest(new HttpGet(buildUri(getDBUri()).path(""String_Node_Str"").build()));
    return getResponseList(response,ownGSON,Index.class,new TypeToken<List<Index>>(){
    }
.getType());
  }
  finally {
    close(response);
  }
}","/** 
 * List all indices
 * @return List of Index
 */
public List<Index> listIndices(){
  HttpResponse response=null;
  try {
    response=client.executeRequest(new HttpGet(buildUri(getDBUri()).path(""String_Node_Str"").build()));
    return getResponseList(response,client.getGson(),Index.class,new TypeToken<List<Index>>(){
    }
.getType());
  }
  finally {
    close(response);
  }
}"
12394,"/** 
 * Saves an object in the database, using HTTP <tt>PUT</tt> request. <p>If the object doesn't have an <code>_id</code> value, the code will assign a <code>UUID</code> as the document id.
 * @param object The object to save
 * @param writeQuorum the write Quorum
 * @throws DocumentConflictException If a conflict is detected during the save.
 * @return {@link Response}
 */
public com.cloudant.client.api.model.Response save(Object object,int writeQuorum){
  Response couchDbResponse=client.put(getDBUri(),object,true,writeQuorum,getGson());
  com.cloudant.client.api.model.Response response=new com.cloudant.client.api.model.Response(couchDbResponse);
  return response;
}","/** 
 * Saves an object in the database, using HTTP <tt>PUT</tt> request. <p>If the object doesn't have an <code>_id</code> value, the code will assign a <code>UUID</code> as the document id.
 * @param object The object to save
 * @param writeQuorum the write Quorum
 * @throws DocumentConflictException If a conflict is detected during the save.
 * @return {@link Response}
 */
public com.cloudant.client.api.model.Response save(Object object,int writeQuorum){
  Response couchDbResponse=client.put(getDBUri(),object,true,writeQuorum,client.getGson());
  com.cloudant.client.api.model.Response response=new com.cloudant.client.api.model.Response(couchDbResponse);
  return response;
}"
12395,"/** 
 * Updates an object in the database, the object must have the correct <code>_id</code> and <code>_rev</code> values.
 * @param object The object to update
 * @param writeQuorum the write Quorum
 * @throws DocumentConflictException If a conflict is detected during the update.
 * @return {@link Response}
 */
public com.cloudant.client.api.model.Response update(Object object,int writeQuorum){
  Response couchDbResponse=client.put(getDBUri(),object,false,writeQuorum,getGson());
  com.cloudant.client.api.model.Response response=new com.cloudant.client.api.model.Response(couchDbResponse);
  return response;
}","/** 
 * Updates an object in the database, the object must have the correct <code>_id</code> and <code>_rev</code> values.
 * @param object The object to update
 * @param writeQuorum the write Quorum
 * @throws DocumentConflictException If a conflict is detected during the update.
 * @return {@link Response}
 */
public com.cloudant.client.api.model.Response update(Object object,int writeQuorum){
  Response couchDbResponse=client.put(getDBUri(),object,false,writeQuorum,client.getGson());
  com.cloudant.client.api.model.Response response=new com.cloudant.client.api.model.Response(couchDbResponse);
  return response;
}"
12396,"/** 
 * Set permissions for a user/apiKey on the database
 * @param userNameorApikey
 * @param permissions permissions to grant
 */
public void setPermissions(String userNameorApikey,EnumSet<Permissions> permissions){
  assertNotEmpty(userNameorApikey,""String_Node_Str"");
  assertNotEmpty(permissions,""String_Node_Str"");
  final JsonArray jsonPermissions=new JsonArray();
  for (  Permissions s : permissions) {
    final JsonPrimitive permission=new JsonPrimitive(s.toString());
    jsonPermissions.add(permission);
  }
  URI uri=buildUri(getDBUri()).path(""String_Node_Str"").build();
  JsonObject perms=client.get(uri,JsonObject.class);
  JsonElement elem=perms.getAsJsonObject().get(""String_Node_Str"");
  if (elem == null) {
    perms.addProperty(""String_Node_Str"",""String_Node_Str"");
    elem=new JsonObject();
    perms.add(""String_Node_Str"",elem);
  }
  elem.getAsJsonObject().add(userNameorApikey,jsonPermissions);
  HttpResponse response=null;
  HttpPut put=new HttpPut(buildUri(uri).build());
  setEntity(put,getGson().toJson(perms),""String_Node_Str"");
  try {
    response=executeRequest(put);
    String ok=getAsString(response,""String_Node_Str"");
    if (!ok.equalsIgnoreCase(""String_Node_Str"")) {
    }
  }
  finally {
    close(response);
  }
}","/** 
 * Set permissions for a user/apiKey on the database
 * @param userNameorApikey
 * @param permissions permissions to grant
 */
public void setPermissions(String userNameorApikey,EnumSet<Permissions> permissions){
  assertNotEmpty(userNameorApikey,""String_Node_Str"");
  assertNotEmpty(permissions,""String_Node_Str"");
  final JsonArray jsonPermissions=new JsonArray();
  for (  Permissions s : permissions) {
    final JsonPrimitive permission=new JsonPrimitive(s.toString());
    jsonPermissions.add(permission);
  }
  URI uri=buildUri(getDBUri()).path(""String_Node_Str"").build();
  JsonObject perms=client.get(uri,JsonObject.class);
  JsonElement elem=perms.getAsJsonObject().get(""String_Node_Str"");
  if (elem == null) {
    perms.addProperty(""String_Node_Str"",""String_Node_Str"");
    elem=new JsonObject();
    perms.add(""String_Node_Str"",elem);
  }
  elem.getAsJsonObject().add(userNameorApikey,jsonPermissions);
  HttpResponse response=null;
  HttpPut put=new HttpPut(buildUri(uri).build());
  setEntity(put,client.getGson().toJson(perms),""String_Node_Str"");
  try {
    response=executeRequest(put);
    String ok=getAsString(response,""String_Node_Str"");
    if (!ok.equalsIgnoreCase(""String_Node_Str"")) {
    }
  }
  finally {
    close(response);
  }
}"
12397,"/** 
 * Delete an index
 * @param indexName name of the index
 * @param designDocId ID of the design doc
 */
public void deleteIndex(String indexName,String designDocId){
  assertNotEmpty(indexName,""String_Node_Str"");
  assertNotEmpty(designDocId,""String_Node_Str"");
  URI uri=buildUri(getDBUri()).path(""String_Node_Str"").path(designDocId).path(""String_Node_Str"").path(indexName).build();
  HttpResponse response=null;
  try {
    response=client.executeRequest(new HttpDelete(uri));
    getResponse(response,Response.class,getGson());
  }
  finally {
    close(response);
  }
}","/** 
 * Delete an index
 * @param indexName name of the index
 * @param designDocId ID of the design doc
 */
public void deleteIndex(String indexName,String designDocId){
  assertNotEmpty(indexName,""String_Node_Str"");
  assertNotEmpty(designDocId,""String_Node_Str"");
  URI uri=buildUri(getDBUri()).path(""String_Node_Str"").path(designDocId).path(""String_Node_Str"").path(indexName).build();
  HttpResponse response=null;
  try {
    response=client.executeRequest(new HttpDelete(uri));
    getResponse(response,Response.class,client.getGson());
  }
  finally {
    close(response);
  }
}"
12398,"/** 
 * Saves an object in the database using HTTP <tt>POST</tt> request with specificied write quorum <p>The database will be responsible for generating the document id.
 * @param object The object to save
 * @param writeQuorum the write Quorum
 * @return {@link Response}
 */
public com.cloudant.client.api.model.Response post(Object object,int writeQuorum){
  assertNotEmpty(object,""String_Node_Str"");
  HttpResponse response=null;
  try {
    URI uri=buildUri(getDBUri()).query(""String_Node_Str"",writeQuorum).build();
    response=client.executeRequest(createPost(uri,getGson().toJson(object),""String_Node_Str""));
    Response couchDbResponse=getResponse(response,Response.class,getGson());
    com.cloudant.client.api.model.Response cloudantResponse=new com.cloudant.client.api.model.Response(couchDbResponse);
    return cloudantResponse;
  }
  finally {
    close(response);
  }
}","/** 
 * Saves an object in the database using HTTP <tt>POST</tt> request with specificied write quorum <p>The database will be responsible for generating the document id.
 * @param object The object to save
 * @param writeQuorum the write Quorum
 * @return {@link Response}
 */
public com.cloudant.client.api.model.Response post(Object object,int writeQuorum){
  assertNotEmpty(object,""String_Node_Str"");
  HttpResponse response=null;
  try {
    URI uri=buildUri(getDBUri()).query(""String_Node_Str"",writeQuorum).build();
    response=client.executeRequest(createPost(uri,client.getGson().toJson(object),""String_Node_Str""));
    Response couchDbResponse=getResponse(response,Response.class,client.getGson());
    com.cloudant.client.api.model.Response cloudantResponse=new com.cloudant.client.api.model.Response(couchDbResponse);
    return cloudantResponse;
  }
  finally {
    close(response);
  }
}"
12399,"/** 
 * @param selectorJson
 * @param sortOrder
 * @param limit
 * @param skip
 * @param returnFields
 * @param readQuorum
 * @return
 */
private String getFindByIndexBody(String selectorJson,FindByIndexOptions options){
  StringBuilder rf=null;
  if (options.getFields().size() > 0) {
    rf=new StringBuilder(""String_Node_Str"");
    int i=0;
    for (    String s : options.getFields()) {
      if (i > 0) {
        rf.append(""String_Node_Str"");
      }
      rf.append(""String_Node_Str"").append(s).append(""String_Node_Str"");
      i++;
    }
    rf.append(""String_Node_Str"");
  }
  StringBuilder so=null;
  if (options.getSort().size() > 0) {
    so=new StringBuilder(""String_Node_Str"");
    int i=0;
    for (    IndexField idxfld : options.getSort()) {
      if (i > 0) {
        so.append(""String_Node_Str"");
      }
      so.append(""String_Node_Str"").append(idxfld.getName()).append(""String_Node_Str"").append(idxfld.getOrder()).append(""String_Node_Str"");
    }
    so.append(""String_Node_Str"");
  }
  boolean isObject=true;
  try {
    getGson().fromJson(selectorJson,JsonObject.class);
  }
 catch (  JsonParseException e) {
    isObject=false;
  }
  if (!isObject) {
    if (!(selectorJson.trim().startsWith(""String_Node_Str""))) {
      throw new JsonParseException(""String_Node_Str"");
    }
  }
  StringBuilder finalbody=new StringBuilder();
  if (isObject) {
    finalbody.append(""String_Node_Str"").append(selectorJson);
  }
 else {
    finalbody.append(""String_Node_Str"" + selectorJson);
  }
  if (rf != null) {
    finalbody.append(""String_Node_Str"").append(rf.toString());
  }
  if (so != null) {
    finalbody.append(""String_Node_Str"").append(so.toString());
  }
  if (options.getLimit() != null) {
    finalbody.append(""String_Node_Str"").append(""String_Node_Str"").append(options.getLimit());
  }
  if (options.getSkip() != null) {
    finalbody.append(""String_Node_Str"").append(""String_Node_Str"").append(options.getSkip());
  }
  if (options.getReadQuorum() != null) {
    finalbody.append(""String_Node_Str"").append(""String_Node_Str"").append(options.getReadQuorum());
  }
  finalbody.append(""String_Node_Str"");
  return finalbody.toString();
}","/** 
 * @param selectorJson
 * @param sortOrder
 * @param limit
 * @param skip
 * @param returnFields
 * @param readQuorum
 * @return
 */
private String getFindByIndexBody(String selectorJson,FindByIndexOptions options){
  StringBuilder rf=null;
  if (options.getFields().size() > 0) {
    rf=new StringBuilder(""String_Node_Str"");
    int i=0;
    for (    String s : options.getFields()) {
      if (i > 0) {
        rf.append(""String_Node_Str"");
      }
      rf.append(""String_Node_Str"").append(s).append(""String_Node_Str"");
      i++;
    }
    rf.append(""String_Node_Str"");
  }
  StringBuilder so=null;
  if (options.getSort().size() > 0) {
    so=new StringBuilder(""String_Node_Str"");
    int i=0;
    for (    IndexField idxfld : options.getSort()) {
      if (i > 0) {
        so.append(""String_Node_Str"");
      }
      so.append(""String_Node_Str"").append(idxfld.getName()).append(""String_Node_Str"").append(idxfld.getOrder()).append(""String_Node_Str"");
    }
    so.append(""String_Node_Str"");
  }
  boolean isObject=true;
  try {
    client.getGson().fromJson(selectorJson,JsonObject.class);
  }
 catch (  JsonParseException e) {
    isObject=false;
  }
  if (!isObject) {
    if (!(selectorJson.trim().startsWith(""String_Node_Str""))) {
      throw new JsonParseException(""String_Node_Str"");
    }
  }
  StringBuilder finalbody=new StringBuilder();
  if (isObject) {
    finalbody.append(""String_Node_Str"").append(selectorJson);
  }
 else {
    finalbody.append(""String_Node_Str"" + selectorJson);
  }
  if (rf != null) {
    finalbody.append(""String_Node_Str"").append(rf.toString());
  }
  if (so != null) {
    finalbody.append(""String_Node_Str"").append(so.toString());
  }
  if (options.getLimit() != null) {
    finalbody.append(""String_Node_Str"").append(""String_Node_Str"").append(options.getLimit());
  }
  if (options.getSkip() != null) {
    finalbody.append(""String_Node_Str"").append(""String_Node_Str"").append(options.getSkip());
  }
  if (options.getReadQuorum() != null) {
    finalbody.append(""String_Node_Str"").append(""String_Node_Str"").append(options.getReadQuorum());
  }
  finalbody.append(""String_Node_Str"");
  return finalbody.toString();
}"
12400,"/** 
 * Returns the Permissions on the database from the /db/_security document
 * @return Map<String,EnumSet<Permissions>> the map of userNames to their Permissions
 */
public Map<String,EnumSet<Permissions>> getPermissions(){
  HttpResponse resp=null;
  HttpGet get=new HttpGet(buildUri(getDBUri()).path(""String_Node_Str"").build());
  try {
    resp=client.executeRequest(get);
    return getResponseMap(resp,ownGSON,new TypeToken<Map<String,EnumSet<Permissions>>>(){
    }
.getType());
  }
  finally {
    close(resp);
  }
}","/** 
 * Returns the Permissions on the database from the /db/_security document
 * @return Map<String,EnumSet<Permissions>> the map of userNames to their Permissions
 */
public Map<String,EnumSet<Permissions>> getPermissions(){
  HttpResponse resp=null;
  HttpGet get=new HttpGet(buildUri(getDBUri()).path(""String_Node_Str"").build());
  try {
    resp=client.executeRequest(get);
    return getResponseMap(resp,client.getGson(),new TypeToken<Map<String,EnumSet<Permissions>>>(){
    }
.getType());
  }
  finally {
    close(resp);
  }
}"
12401,"/** 
 * Find documents using an index 
 * @param selectorJson JSON object describing criteria used to select documents.Is of the form ""selector"": { <your data here> }  @see <a href=""http://docs.cloudant.com/api/cloudant-query.html#cloudant-query-selectors"">selector syntax</a>
 * @param options   {@link FindByIndexOptions query Index options} 
 * @param classOfT The class of Java objects to be returned
 * @return List of classOfT objects
 */
public <T>List<T> findByIndex(String selectorJson,Class<T> classOfT,FindByIndexOptions options){
  assertNotEmpty(selectorJson,""String_Node_Str"");
  assertNotEmpty(options,""String_Node_Str"");
  URI uri=buildUri(getDBUri()).path(""String_Node_Str"").build();
  String body=getFindByIndexBody(selectorJson,options);
  InputStream stream=null;
  try {
    stream=getStream(client.executeRequest(createPost(uri,body,""String_Node_Str"")));
    Reader reader=new InputStreamReader(stream);
    JsonArray jsonArray=new JsonParser().parse(reader).getAsJsonObject().getAsJsonArray(""String_Node_Str"");
    List<T> list=new ArrayList<T>();
    for (    JsonElement jsonElem : jsonArray) {
      JsonElement elem=jsonElem.getAsJsonObject();
      T t=ownGSON.fromJson(elem,classOfT);
      list.add(t);
    }
    return list;
  }
  finally {
    close(stream);
  }
}","/** 
 * Find documents using an index 
 * @param selectorJson JSON object describing criteria used to select documents.Is of the form ""selector"": { <your data here> }  @see <a href=""http://docs.cloudant.com/api/cloudant-query.html#cloudant-query-selectors"">selector syntax</a>
 * @param options   {@link FindByIndexOptions query Index options} 
 * @param classOfT The class of Java objects to be returned
 * @return List of classOfT objects
 */
public <T>List<T> findByIndex(String selectorJson,Class<T> classOfT,FindByIndexOptions options){
  assertNotEmpty(selectorJson,""String_Node_Str"");
  assertNotEmpty(options,""String_Node_Str"");
  URI uri=buildUri(getDBUri()).path(""String_Node_Str"").build();
  String body=getFindByIndexBody(selectorJson,options);
  InputStream stream=null;
  try {
    stream=getStream(client.executeRequest(createPost(uri,body,""String_Node_Str"")));
    Reader reader=new InputStreamReader(stream);
    JsonArray jsonArray=new JsonParser().parse(reader).getAsJsonObject().getAsJsonArray(""String_Node_Str"");
    List<T> list=new ArrayList<T>();
    for (    JsonElement jsonElem : jsonArray) {
      JsonElement elem=jsonElem.getAsJsonObject();
      T t=client.getGson().fromJson(elem,classOfT);
      list.add(t);
    }
    return list;
  }
  finally {
    close(stream);
  }
}"
12402,"/** 
 * Get info about the shards in the database
 * @return List of shards
 */
public List<Shard> getShards(){
  HttpResponse response=null;
  HttpGet get=new HttpGet(buildUri(db.getDBUri()).path(""String_Node_Str"").build());
  try {
    response=client.executeRequest(get);
    return getResponseList(response,ownGSON,Shard.class,new TypeToken<List<Shard>>(){
    }
.getType());
  }
  finally {
    close(response);
  }
}","/** 
 * Get info about the shards in the database
 * @return List of shards
 */
public List<Shard> getShards(){
  HttpResponse response=null;
  HttpGet get=new HttpGet(buildUri(db.getDBUri()).path(""String_Node_Str"").build());
  try {
    response=client.executeRequest(get);
    return getResponseList(response,client.getGson(),Shard.class,new TypeToken<List<Shard>>(){
    }
.getType());
  }
  finally {
    close(response);
  }
}"
12403,"static Gson getGson(){
  return ownGSON;
}","Gson getGson(){
  return client.getGson();
}"
12404,"/** 
 * Queries a Search Index and returns grouped results in a map where key of the map is the groupName. In case the query didnt use grouping, an empty map is returned
 * @param < T > Object type T
 * @param query the Lucene query to be passed to the Search index
 * @param classOfT The class of type T
 * @return The result of the grouped search query as a ordered {@code Map<String,T> }
 */
public <T>Map<String,List<T>> queryGroups(String query,Class<T> classOfT){
  InputStream instream=null;
  try {
    Reader reader=new InputStreamReader(instream=queryForStream(query));
    JsonObject json=new JsonParser().parse(reader).getAsJsonObject();
    Map<String,List<T>> result=new LinkedHashMap<String,List<T>>();
    if (json.has(""String_Node_Str"")) {
      for (      JsonElement e : json.getAsJsonArray(""String_Node_Str"")) {
        String groupName=e.getAsJsonObject().get(""String_Node_Str"").getAsString();
        List<T> orows=new ArrayList<T>();
        if (!includeDocs) {
          log.warn(""String_Node_Str"" + ""String_Node_Str"");
        }
        for (        JsonElement rows : e.getAsJsonObject().getAsJsonArray(""String_Node_Str"")) {
          orows.add(JsonToObject(Database.getGson(),rows,""String_Node_Str"",classOfT));
        }
        result.put(groupName,orows);
      }
    }
 else {
      log.warn(""String_Node_Str"");
    }
    return result;
  }
  finally {
    close(instream);
  }
}","/** 
 * Queries a Search Index and returns grouped results in a map where key of the map is the groupName. In case the query didnt use grouping, an empty map is returned
 * @param < T > Object type T
 * @param query the Lucene query to be passed to the Search index
 * @param classOfT The class of type T
 * @return The result of the grouped search query as a ordered {@code Map<String,T> }
 */
public <T>Map<String,List<T>> queryGroups(String query,Class<T> classOfT){
  InputStream instream=null;
  try {
    Reader reader=new InputStreamReader(instream=queryForStream(query));
    JsonObject json=new JsonParser().parse(reader).getAsJsonObject();
    Map<String,List<T>> result=new LinkedHashMap<String,List<T>>();
    if (json.has(""String_Node_Str"")) {
      for (      JsonElement e : json.getAsJsonArray(""String_Node_Str"")) {
        String groupName=e.getAsJsonObject().get(""String_Node_Str"").getAsString();
        List<T> orows=new ArrayList<T>();
        if (!includeDocs) {
          log.warn(""String_Node_Str"" + ""String_Node_Str"");
        }
        for (        JsonElement rows : e.getAsJsonObject().getAsJsonArray(""String_Node_Str"")) {
          orows.add(JsonToObject(db.getGson(),rows,""String_Node_Str"",classOfT));
        }
        result.put(groupName,orows);
      }
    }
 else {
      log.warn(""String_Node_Str"");
    }
    return result;
  }
  finally {
    close(instream);
  }
}"
12405,"/** 
 * Queries a Search Index and returns ungrouped results. In case the query used grouping, an empty list is returned
 * @param < T > Object type T
 * @param query the Lucene query to be passed to the Search index
 * @param classOfT The class of type T
 * @return The result of the search query as a {@code List<T> }
 */
public <T>List<T> query(String query,Class<T> classOfT){
  InputStream instream=null;
  List<T> result=new ArrayList<T>();
  try {
    Reader reader=new InputStreamReader(instream=queryForStream(query));
    JsonObject json=new JsonParser().parse(reader).getAsJsonObject();
    if (json.has(""String_Node_Str"")) {
      if (!includeDocs) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"");
      }
      for (      JsonElement e : json.getAsJsonArray(""String_Node_Str"")) {
        result.add(JsonToObject(Database.getGson(),e,""String_Node_Str"",classOfT));
      }
    }
 else {
      log.warn(""String_Node_Str"");
    }
    return result;
  }
  finally {
    close(instream);
  }
}","/** 
 * Queries a Search Index and returns ungrouped results. In case the query used grouping, an empty list is returned
 * @param < T > Object type T
 * @param query the Lucene query to be passed to the Search index
 * @param classOfT The class of type T
 * @return The result of the search query as a {@code List<T> }
 */
public <T>List<T> query(String query,Class<T> classOfT){
  InputStream instream=null;
  List<T> result=new ArrayList<T>();
  try {
    Reader reader=new InputStreamReader(instream=queryForStream(query));
    JsonObject json=new JsonParser().parse(reader).getAsJsonObject();
    if (json.has(""String_Node_Str"")) {
      if (!includeDocs) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"");
      }
      for (      JsonElement e : json.getAsJsonArray(""String_Node_Str"")) {
        result.add(JsonToObject(db.getGson(),e,""String_Node_Str"",classOfT));
      }
    }
 else {
      log.warn(""String_Node_Str"");
    }
    return result;
  }
  finally {
    close(instream);
  }
}"
12406,"private <T>List<SearchResult<T>.SearchResultRows> getRows(JsonArray jsonrows,SearchResult<T> sr,Class<T> classOfT){
  List<SearchResult<T>.SearchResultRows> ret=new ArrayList<SearchResult<T>.SearchResultRows>();
  for (  JsonElement e : jsonrows) {
    SearchResult<T>.SearchResultRows row=sr.new SearchResultRows();
    JsonObject oe=e.getAsJsonObject();
    row.setId(oe.get(""String_Node_Str"").getAsString());
    row.setOrder(JsonToObject(Database.getGson(),e,""String_Node_Str"",Object[].class));
    row.setFields(JsonToObject(Database.getGson(),e,""String_Node_Str"",classOfT));
    if (includeDocs) {
      row.setDoc(JsonToObject(Database.getGson(),e,""String_Node_Str"",classOfT));
    }
    ret.add(row);
  }
  return ret;
}","private <T>List<SearchResult<T>.SearchResultRows> getRows(JsonArray jsonrows,SearchResult<T> sr,Class<T> classOfT){
  List<SearchResult<T>.SearchResultRows> ret=new ArrayList<SearchResult<T>.SearchResultRows>();
  for (  JsonElement e : jsonrows) {
    SearchResult<T>.SearchResultRows row=sr.new SearchResultRows();
    JsonObject oe=e.getAsJsonObject();
    row.setId(oe.get(""String_Node_Str"").getAsString());
    row.setOrder(JsonToObject(db.getGson(),e,""String_Node_Str"",Object[].class));
    row.setFields(JsonToObject(db.getGson(),e,""String_Node_Str"",classOfT));
    if (includeDocs) {
      row.setDoc(JsonToObject(db.getGson(),e,""String_Node_Str"",classOfT));
    }
    ret.add(row);
  }
  return ret;
}"
12407,"Changes(CouchDbClientBase dbc){
  this.dbc=dbc;
  this.gson=dbc.getGson();
  this.uriBuilder=URIBuilder.builder(dbc.getDBUri()).path(""String_Node_Str"");
}","Changes(CouchDbClientBase dbc){
  this.dbc=dbc;
  this.gson=dbc.getGson();
  this.uriBuilder=URIBuilder.buildUri(dbc.getDBUri()).path(""String_Node_Str"");
}"
12408,"/** 
 * <p>Requests Change notifications of feed type continuous. <p>Feed notifications are accessed in an <i>iterator</i> style.
 */
public Changes continuousChanges(){
  URI uri=uriBuilder.query(""String_Node_Str"",""String_Node_Str"").build();
  httpGet=new HttpGet(uri);
  InputStream in=dbc.get(httpGet);
  InputStreamReader is=new InputStreamReader(in);
  setReader(new BufferedReader(is));
  return this;
}","/** 
 * Requests Change notifications of feed type continuous. <p>Feed notifications are accessed in an <i>iterator</i> style.
 */
public Changes continuousChanges(){
  final URI uri=uriBuilder.query(""String_Node_Str"",""String_Node_Str"").build();
  httpGet=new HttpGet(uri);
  final InputStream in=dbc.get(httpGet);
  final InputStreamReader is=new InputStreamReader(in);
  setReader(new BufferedReader(is));
  return this;
}"
12409,"/** 
 * Requests Change notifications of feed type normal.
 */
public ChangesResult getChanges(){
  URI uri=uriBuilder.query(""String_Node_Str"",""String_Node_Str"").build();
  return dbc.get(uri,ChangesResult.class);
}","/** 
 * Requests Change notifications of feed type normal.
 */
public ChangesResult getChanges(){
  final URI uri=uriBuilder.query(""String_Node_Str"",""String_Node_Str"").build();
  return dbc.get(uri,ChangesResult.class);
}"
12410,"/** 
 * @return {@link DefaultHttpClient} instance.
 */
@Override HttpClient createHttpClient(CouchDbProperties props){
  DefaultHttpClient httpclient=null;
  try {
    SchemeRegistry schemeRegistry=createRegistry(props);
    HttpParams params=new BasicHttpParams();
    params.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET,""String_Node_Str"");
    params.setParameter(CoreConnectionPNames.SO_TIMEOUT,props.getSocketTimeout());
    params.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT,props.getConnectionTimeout());
    ThreadSafeClientConnManager ccm=new ThreadSafeClientConnManager(params,schemeRegistry);
    httpclient=new DefaultHttpClient(ccm,params);
    if (props.getProxyHost() != null) {
      HttpHost proxy=new HttpHost(props.getProxyHost(),props.getProxyPort());
      httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,proxy);
    }
    if (props.getUsername() != null && props.getPassword() != null) {
      httpclient.getCredentialsProvider().setCredentials(new AuthScope(props.getHost(),props.getPort()),new UsernamePasswordCredentials(props.getUsername(),props.getPassword()));
      props.clearPassword();
    }
    registerInterceptors(httpclient);
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
  return httpclient;
}","/** 
 * @return {@link DefaultHttpClient} instance.
 */
@Override HttpClient createHttpClient(CouchDbProperties props){
  DefaultHttpClient httpclient=null;
  try {
    final SchemeRegistry schemeRegistry=createRegistry(props);
    final HttpParams params=new BasicHttpParams();
    params.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET,""String_Node_Str"");
    params.setParameter(CoreConnectionPNames.SO_TIMEOUT,props.getSocketTimeout());
    params.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT,props.getConnectionTimeout());
    final ThreadSafeClientConnManager ccm=new ThreadSafeClientConnManager(params,schemeRegistry);
    httpclient=new DefaultHttpClient(ccm,params);
    if (props.getProxyHost() != null) {
      HttpHost proxy=new HttpHost(props.getProxyHost(),props.getProxyPort());
      httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,proxy);
    }
    if (props.getUsername() != null && props.getPassword() != null) {
      httpclient.getCredentialsProvider().setCredentials(new AuthScope(props.getHost(),props.getPort()),new UsernamePasswordCredentials(props.getUsername(),props.getPassword()));
      props.clearPassword();
    }
    registerInterceptors(httpclient);
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
  return httpclient;
}"
12411,"/** 
 * Queries a view.
 * @param < K > Object type K (key)
 * @param < V > Object type V (value)
 * @param classOfK The class of type K.
 * @param classOfV The class of type V.
 * @param classOfT The class of type T.
 * @return The View result entries.
 */
public <K,V,T>ViewResult<K,V,T> queryView(Class<K> classOfK,Class<V> classOfV,Class<T> classOfT){
  InputStream instream=null;
  try {
    Reader reader=new InputStreamReader(instream=queryForStream());
    JsonObject json=new JsonParser().parse(reader).getAsJsonObject();
    ViewResult<K,V,T> vr=new ViewResult<K,V,T>();
    vr.setTotalRows(getElementAsLong(json,""String_Node_Str""));
    vr.setOffset(getElementAsInt(json,""String_Node_Str""));
    vr.setUpdateSeq(getElementAsLong(json,""String_Node_Str""));
    JsonArray jsonArray=json.getAsJsonArray(""String_Node_Str"");
    if (jsonArray.size() == 0) {
      throw new NoDocumentException(""String_Node_Str"");
    }
    for (    JsonElement e : jsonArray) {
      ViewResult<K,V,T>.Rows row=vr.new Rows();
      row.setId(JsonToObject(gson,e,""String_Node_Str"",String.class));
      row.setKey(JsonToObject(gson,e,""String_Node_Str"",classOfK));
      row.setValue(JsonToObject(gson,e,""String_Node_Str"",classOfV));
      if (includeDocs == Boolean.TRUE) {
        row.setDoc(JsonToObject(gson,e,""String_Node_Str"",classOfT));
      }
      vr.getRows().add(row);
    }
    return vr;
  }
  finally {
    close(instream);
  }
}","/** 
 * Queries a view.
 * @param < K > Object type K (key)
 * @param < V > Object type V (value)
 * @param classOfK The class of type K.
 * @param classOfV The class of type V.
 * @param classOfT The class of type T.
 * @return The View result entries.
 */
public <K,V,T>ViewResult<K,V,T> queryView(Class<K> classOfK,Class<V> classOfV,Class<T> classOfT){
  InputStream instream=null;
  try {
    Reader reader=new InputStreamReader(instream=queryForStream());
    JsonObject json=new JsonParser().parse(reader).getAsJsonObject();
    ViewResult<K,V,T> vr=new ViewResult<K,V,T>();
    vr.setTotalRows(getElementAsLong(json,""String_Node_Str""));
    vr.setOffset(getElementAsInt(json,""String_Node_Str""));
    vr.setUpdateSeq(getElementAsLong(json,""String_Node_Str""));
    JsonArray jsonArray=json.getAsJsonArray(""String_Node_Str"");
    if (jsonArray.size() == 0) {
      throw new NoDocumentException(""String_Node_Str"");
    }
    for (    JsonElement e : jsonArray) {
      ViewResult<K,V,T>.Rows row=vr.new Rows();
      row.setId(JsonToObject(gson,e,""String_Node_Str"",String.class));
      row.setKey(JsonToObject(gson,e,""String_Node_Str"",classOfK));
      row.setValue(JsonToObject(gson,e,""String_Node_Str"",classOfV));
      if (Boolean.TRUE.equals(this.includeDocs)) {
        row.setDoc(JsonToObject(gson,e,""String_Node_Str"",classOfT));
      }
      vr.getRows().add(row);
    }
    return vr;
  }
  finally {
    close(instream);
  }
}"
12412,"@Override public void add(Payload payload){
  payloadService.add(payload);
}","@Override public void add(Payload payload){
  payload.setStatusId(PayloadStatus.Pending);
  payload.setTotalUsers(0);
  payloadService.add(payload);
}"
12413,"private Connection buildConnection(ChannelHandlerContext ctx,PBAPNSEvent pbapnsEvent){
  Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
  boolean newOne=true;
  if (null != conn) {
    if (!conn.getDeviceId().equalsIgnoreCase(pbapnsEvent.getDeviceId())) {
      ConnectionKeeper.remove(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
      logger.error(""String_Node_Str"",ctx,conn);
      ack(ctx,conn,pbapnsEvent,MULTI_CLIENTS);
      newOne=true;
    }
 else     if (conn.getContext().channel().hashCode() != ctx.channel().hashCode()) {
      InetSocketAddress ip=(InetSocketAddress)conn.getContext().channel().remoteAddress();
      InetSocketAddress ip2=(InetSocketAddress)ctx.channel().remoteAddress();
      if (ip.getAddress().getHostAddress().equalsIgnoreCase(ip2.getAddress().getHostAddress())) {
        if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
          logger.warn(""String_Node_Str"",ip,ip);
          ack(ctx,conn,pbapnsEvent,MULTI_CLIENTS);
          newOne=true;
        }
 else {
          ConnectionKeeper.remove(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
          newOne=true;
        }
      }
 else {
        logger.warn(""String_Node_Str"",ip,ip2);
        ConnectionKeeper.remove(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
        newOne=true;
      }
    }
 else {
      newOne=false;
      conn.setStatusId(ClientStatus.Online);
    }
  }
  if (newOne) {
    logger.debug(""String_Node_Str"",pbapnsEvent.getUserId(),ctx.channel().remoteAddress());
    conn=new Connection(ctx);
    conn.setUserId(pbapnsEvent.getUserId());
    conn.setAppKey(pbapnsEvent.getAppKey());
    conn.setDeviceId(pbapnsEvent.getDeviceId());
    ConnectionKeeper.add(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId(),conn);
  }
  return conn;
}","private Connection buildConnection(ChannelHandlerContext ctx,PBAPNSEvent pbapnsEvent){
  Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
  boolean newOne=true;
  if (null != conn) {
    if (!conn.getDeviceId().equalsIgnoreCase(pbapnsEvent.getDeviceId())) {
      ConnectionKeeper.remove(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
      logger.error(""String_Node_Str"",ctx,conn);
      ack(ctx,conn,pbapnsEvent,MULTI_CLIENTS);
      newOne=true;
    }
 else     if (conn.getContext().channel().hashCode() != ctx.channel().hashCode()) {
      InetSocketAddress ip=(InetSocketAddress)conn.getContext().channel().remoteAddress();
      InetSocketAddress ip2=(InetSocketAddress)ctx.channel().remoteAddress();
      if (ip.getAddress().getHostAddress().equalsIgnoreCase(ip2.getAddress().getHostAddress())) {
        if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
          logger.warn(""String_Node_Str"",ip,ip);
          ack(ctx,conn,pbapnsEvent,MULTI_CLIENTS);
          newOne=true;
        }
 else {
          ConnectionKeeper.remove(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
          newOne=true;
        }
      }
 else {
        logger.warn(""String_Node_Str"",ip,ip2);
        ConnectionKeeper.remove(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
        newOne=true;
      }
    }
 else {
      newOne=true;
      conn.setStatusId(ClientStatus.Online);
    }
  }
  if (newOne) {
    logger.debug(""String_Node_Str"",pbapnsEvent.getUserId(),ctx.channel().remoteAddress());
    conn=new Connection(ctx);
    conn.setUserId(pbapnsEvent.getUserId());
    conn.setAppKey(pbapnsEvent.getAppKey());
    conn.setDeviceId(pbapnsEvent.getDeviceId());
    ConnectionKeeper.add(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId(),conn);
  }
  return conn;
}"
12414,"@TxMain private void postSaveAfterSent(final Payload payload){
  try {
    mainJdbc.update(new PreparedStatementCreator(){
      @Override public PreparedStatement createPreparedStatement(      Connection connection) throws SQLException {
        PreparedStatement ps=connection.prepareStatement(SQL_PAYLOAD_INSERT,Statement.RETURN_GENERATED_KEYS);
        ps.setObject(1,payload.getId());
        ps.setObject(2,payload.getTitle());
        ps.setObject(3,payload.getBadge());
        ps.setObject(4,payload.getExtras());
        ps.setObject(5,payload.getSound());
        ps.setObject(6,payload.getProductId());
        ps.setObject(7,payload.getTotalUsers());
        ps.setObject(8,payload.getCreateAt());
        ps.setObject(9,payload.getStatusId());
        ps.setObject(10,payload.getBroadcast());
        ps.setObject(11,payload.getSentDate());
        ps.setObject(12,payload.getOfflineMode());
        ps.setObject(13,payload.getToMode());
        ps.setObject(14,payload.getApnsMode());
        return ps;
      }
    }
);
  }
 catch (  DataAccessException e) {
    logger.error(""String_Node_Str"",e);
  }
  MetricBuilder.jdbcUpdateMeter.mark(1);
  if (payload.getClients() != null) {
    try {
      mainJdbc.batchUpdate(SQL_PAYLOAD_CLIENT_INSERT,new BatchPreparedStatementSetter(){
        @Override public void setValues(        PreparedStatement preparedStatement,        int i) throws SQLException {
          String userId=payload.getClients().get(i);
          PushStatus error=payload.getStatus().get(userId);
          int statusId=error.getPayloadStatus();
          int onlineMode=error.getOnlineMode(payload.getOfflineMode().intValue());
          preparedStatement.setObject(1,payload.getId());
          preparedStatement.setObject(2,userId);
          preparedStatement.setObject(3,payload.getProductId());
          preparedStatement.setObject(4,statusId);
          preparedStatement.setObject(5,new Date().getTime() / 1000);
          preparedStatement.setObject(6,onlineMode);
          preparedStatement.setObject(7,error != null ? error.getCode() : null);
          preparedStatement.setObject(8,error != null ? error.getMsg() : null);
        }
        @Override public int getBatchSize(){
          return payload.getClients().size();
        }
      }
);
    }
 catch (    DataAccessException e) {
      logger.error(""String_Node_Str"",e);
    }
    MetricBuilder.jdbcUpdateMeter.mark(1);
  }
}","@TxMain private void postSaveAfterSent(final Payload payload){
  try {
    mainJdbc.update(new PreparedStatementCreator(){
      @Override public PreparedStatement createPreparedStatement(      Connection connection) throws SQLException {
        PreparedStatement ps=connection.prepareStatement(SQL_PAYLOAD_INSERT,Statement.RETURN_GENERATED_KEYS);
        ps.setObject(1,payload.getId());
        ps.setObject(2,payload.getTitle());
        ps.setObject(3,payload.getBadge());
        ps.setObject(4,payload.getExtras());
        ps.setObject(5,payload.getSound());
        ps.setObject(6,payload.getProductId());
        ps.setObject(7,payload.getTotalUsers());
        ps.setObject(8,payload.getCreateAt());
        ps.setObject(9,payload.getStatusId());
        ps.setObject(10,payload.getBroadcast());
        ps.setObject(11,payload.getSentDate());
        ps.setObject(12,payload.getOfflineMode());
        ps.setObject(13,payload.getToMode());
        ps.setObject(14,payload.getApnsMode());
        return ps;
      }
    }
);
  }
 catch (  DataAccessException e) {
    logger.error(""String_Node_Str"",e);
  }
  MetricBuilder.jdbcUpdateMeter.mark(1);
  if (payload.getClients() != null) {
    try {
      mainJdbc.batchUpdate(SQL_PAYLOAD_CLIENT_INSERT,new BatchPreparedStatementSetter(){
        @Override public void setValues(        PreparedStatement preparedStatement,        int i) throws SQLException {
          String userId=payload.getClients().get(i);
          PushStatus error=payload.getStatus().get(userId);
          int statusId=error.getPayloadStatus();
          int onlineMode=error.getOnlineMode(payload.getOfflineMode().intValue());
          preparedStatement.setObject(1,payload.getId());
          preparedStatement.setObject(2,userId);
          preparedStatement.setObject(3,payload.getProductId());
          preparedStatement.setObject(4,statusId);
          preparedStatement.setObject(5,System.currentTimeMillis() / 1000);
          preparedStatement.setObject(6,onlineMode);
          preparedStatement.setObject(7,error != null ? error.getCode() : null);
          preparedStatement.setObject(8,error != null ? error.getMsg() : null);
        }
        @Override public int getBatchSize(){
          return payload.getClients().size();
        }
      }
);
    }
 catch (    DataAccessException e) {
      logger.error(""String_Node_Str"",e);
    }
    MetricBuilder.jdbcUpdateMeter.mark(1);
  }
}"
12415,"@TxMain private void postAddPayload(final Payload payload){
  mainJdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(SQL_PAYLOAD_INSERT,Statement.RETURN_GENERATED_KEYS);
      ps.setObject(1,payload.getId());
      ps.setObject(2,payload.getTitle());
      ps.setObject(3,payload.getBadge());
      ps.setObject(4,payload.getExtras());
      ps.setObject(5,payload.getSound());
      ps.setObject(6,payload.getProductId());
      ps.setObject(7,payload.getTotalUsers());
      ps.setObject(8,payload.getCreateAt());
      ps.setObject(9,payload.getStatusId());
      ps.setObject(10,payload.getBroadcast());
      ps.setObject(11,payload.getSentDate());
      ps.setObject(12,payload.getOfflineMode());
      ps.setObject(13,payload.getToMode());
      ps.setObject(14,payload.getApnsMode());
      return ps;
    }
  }
);
  if (payload.getClients() != null) {
    mainJdbc.batchUpdate(SQL_PAYLOAD_CLIENT_INSERT,new BatchPreparedStatementSetter(){
      @Override public void setValues(      PreparedStatement preparedStatement,      int i) throws SQLException {
        preparedStatement.setObject(1,payload.getId());
        preparedStatement.setObject(2,payload.getClients().get(i));
        preparedStatement.setObject(3,payload.getProductId());
        preparedStatement.setObject(4,0);
        preparedStatement.setObject(5,new Date().getTime() / 1000);
      }
      @Override public int getBatchSize(){
        return payload.getClients().size();
      }
    }
);
  }
}","@TxMain private void postAddPayload(final Payload payload){
  mainJdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(SQL_PAYLOAD_INSERT,Statement.RETURN_GENERATED_KEYS);
      ps.setObject(1,payload.getId());
      ps.setObject(2,payload.getTitle());
      ps.setObject(3,payload.getBadge());
      ps.setObject(4,payload.getExtras());
      ps.setObject(5,payload.getSound());
      ps.setObject(6,payload.getProductId());
      ps.setObject(7,payload.getTotalUsers());
      ps.setObject(8,payload.getCreateAt());
      ps.setObject(9,payload.getStatusId());
      ps.setObject(10,payload.getBroadcast());
      ps.setObject(11,payload.getSentDate());
      ps.setObject(12,payload.getOfflineMode());
      ps.setObject(13,payload.getToMode());
      ps.setObject(14,payload.getApnsMode());
      return ps;
    }
  }
);
  if (payload.getClients() != null) {
    mainJdbc.batchUpdate(SQL_PAYLOAD_CLIENT_INSERT,new BatchPreparedStatementSetter(){
      @Override public void setValues(      PreparedStatement preparedStatement,      int i) throws SQLException {
        preparedStatement.setObject(1,payload.getId());
        preparedStatement.setObject(2,payload.getClients().get(i));
        preparedStatement.setObject(3,payload.getProductId());
        preparedStatement.setObject(4,0);
        preparedStatement.setObject(5,System.currentTimeMillis() / 1000);
      }
      @Override public int getBatchSize(){
        return payload.getClients().size();
      }
    }
);
  }
}"
12416,"private Integer doSend() throws Exception {
  if (message == null) {
    return 0;
  }
  List<String> clients=message.getClients();
  if (clients == null || clients.size() == 0) {
    logger.error(""String_Node_Str"",message);
    if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
      message.setStatusId(PayloadStatus.Failed);
      message.setTotalUsers(0);
      PayloadServiceImpl.instance.add(message);
    }
 else {
      message.setStatusId(PayloadStatus.Failed);
      message.setTotalUsers(0);
      PayloadServiceImpl.instance.updateSendStatus(message);
    }
    return 0;
  }
  if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
    message.setStatusId(PayloadStatus.Pending);
    message.setTotalUsers(0);
    PayloadServiceImpl.instance.add(message);
  }
  logger.info(""String_Node_Str"",clients.size());
  for (int i=0; i < clients.size(); i++) {
    String client=clients.get(i);
    Client cc=ClientServiceImpl.instance.findByUserId(client);
    if (cc == null) {
      logger.error(""String_Node_Str"",client);
      if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
        message.setStatus(client,new PushStatus(PushStatus.NoClient));
      }
      continue;
    }
    message.setBadge(cc.getBadge() + 1);
    Connection c=ConnectionKeeper.get(product.getAppKey(),client);
    if (c != null) {
      if (c.getStatusId() == ClientStatus.Online) {
        c.send(message);
        message.setStatus(client,new PushStatus(PushStatus.TcpSent));
      }
 else {
        sendMessageToOfflineClient(client,cc);
      }
    }
 else {
      sendMessageToOfflineClient(client,cc);
    }
  }
  PayloadServiceImpl.instance.updateSendStatus(message);
  return clients.size();
}","private Integer doSend() throws Exception {
  if (message == null) {
    return 0;
  }
  List<String> clients=message.getClients();
  if (clients == null || clients.size() == 0) {
    logger.error(""String_Node_Str"",message);
    if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
      message.setStatusId(PayloadStatus.Failed);
      message.setTotalUsers(0);
      PayloadServiceImpl.instance.add(message);
    }
 else {
      message.setStatusId(PayloadStatus.Failed);
      message.setTotalUsers(0);
      PayloadServiceImpl.instance.updateSendStatus(message);
    }
    return 0;
  }
  if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
    message.setStatusId(PayloadStatus.Pending);
    message.setTotalUsers(0);
    PayloadServiceImpl.instance.add(message);
  }
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",message.getId(),clients.size());
  }
  for (int i=0; i < clients.size(); i++) {
    String client=clients.get(i);
    Client cc=ClientServiceImpl.instance.findByUserId(client);
    if (cc == null) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",message.getId(),client);
      }
      if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
        message.setStatus(client,new PushStatus(PushStatus.WaitOnline));
      }
 else {
        message.setStatus(client,new PushStatus(PushStatus.NoClient));
      }
      continue;
    }
    message.setBadge(cc.getBadge() + 1);
    Connection c=ConnectionKeeper.get(product.getAppKey(),client);
    if (c != null) {
      if (c.getStatusId() == ClientStatus.Online) {
        c.send(message);
        message.setStatus(client,new PushStatus(PushStatus.TcpSent));
      }
 else {
        sendMessageToOfflineClient(client,cc);
      }
    }
 else {
      sendMessageToOfflineClient(client,cc);
    }
  }
  PayloadServiceImpl.instance.updateSendStatus(message);
  return clients.size();
}"
12417,"private void sendMessageToOfflineClient(String client,Client cc){
  if (!cc.supportAPNS()) {
    logger.error(""String_Node_Str"",client);
    message.setStatus(cc.getUserId(),new PushStatus(PushStatus.NoConnections));
    return;
  }
  int offlineMode=message.getOfflineMode().intValue();
  if (StringUtils.isBlank(cc.getDeviceToken()) || NULL.equalsIgnoreCase(cc.getDeviceToken())) {
    logger.error(""String_Node_Str"",client);
    if (offlineMode == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
      message.setStatus(cc.getUserId(),new PushStatus(PushStatus.NO_DEVICE_TOKEN));
    }
 else {
      message.setStatus(cc.getUserId(),new PushStatus(PushStatus.Ignore));
    }
    return;
  }
  if (PBAPNSMessage.APNSModes.All_VALUE == message.getToMode()) {
    if (offlineMode == PBAPNSMessage.OfflineModes.APNS_VALUE) {
      if (PBAPNSMessage.APNSModes.Signined_VALUE == message.getApnsMode()) {
        if (ClientStatus.Offline == cc.getStatusId()) {
          message.setStatus(cc.getUserId(),new PushStatus(PushStatus.WaitOnline));
        }
 else {
          APNSKeeper.instance.push(this.product,cc,message);
        }
      }
 else {
        APNSKeeper.instance.push(this.product,cc,message);
      }
    }
 else     if (offlineMode == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
      message.setStatus(cc.getUserId(),new PushStatus(PushStatus.WaitOnline));
    }
  }
 else {
    message.setStatus(cc.getUserId(),new PushStatus(PushStatus.Ignore));
  }
}","private void sendMessageToOfflineClient(String client,Client cc){
  int offlineMode=message.getOfflineMode().intValue();
  if (!cc.supportAPNS()) {
    logger.error(""String_Node_Str"",client);
    if (offlineMode == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
      message.setStatus(client,new PushStatus(PushStatus.WaitOnline));
    }
 else {
      message.setStatus(client,new PushStatus(PushStatus.NoConnections));
    }
    return;
  }
  if (StringUtils.isBlank(cc.getDeviceToken()) || NULL.equalsIgnoreCase(cc.getDeviceToken())) {
    logger.error(""String_Node_Str"",client);
    if (offlineMode == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
      message.setStatus(cc.getUserId(),new PushStatus(PushStatus.NO_DEVICE_TOKEN));
    }
 else {
      message.setStatus(cc.getUserId(),new PushStatus(PushStatus.Ignore));
    }
    return;
  }
  if (PBAPNSMessage.APNSModes.All_VALUE == message.getToMode()) {
    if (offlineMode == PBAPNSMessage.OfflineModes.APNS_VALUE) {
      if (PBAPNSMessage.APNSModes.Signined_VALUE == message.getApnsMode()) {
        if (ClientStatus.Offline == cc.getStatusId()) {
          message.setStatus(cc.getUserId(),new PushStatus(PushStatus.WaitOnline));
        }
 else {
          APNSKeeper.instance.push(this.product,cc,message);
        }
      }
 else {
        APNSKeeper.instance.push(this.product,cc,message);
      }
    }
 else     if (offlineMode == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
      message.setStatus(cc.getUserId(),new PushStatus(PushStatus.WaitOnline));
    }
 else {
      message.setStatus(cc.getUserId(),new PushStatus(PushStatus.Ignore));
    }
  }
 else {
    message.setStatus(cc.getUserId(),new PushStatus(PushStatus.Ignore));
  }
}"
12418,"/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (logger.isDebugEnabled()) {
    logger.info(""String_Node_Str"",ctx.channel().hashCode());
  }
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent pbapnsEvent;
  try {
    byte[] bytes=(byte[])msg;
    pbapnsEvent=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ctx.close();
    return;
  }
  ReferenceCountUtil.release(msg);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",pbapnsEvent);
  }
  if (StringUtils.isEmpty(pbapnsEvent.getUserId()) || pbapnsEvent.getOp() <= 0) {
    logger.error(""String_Node_Str"");
    ctx.close();
    return;
  }
  if (pbapnsEvent.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (pbapnsEvent.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (null != conn) {
      logger.error(""String_Node_Str"",pbapnsEvent,conn);
      ack(ctx,conn,pbapnsEvent,MULTI_CLIENTS);
    }
    conn=new Connection(ctx);
    conn.setUserId(pbapnsEvent.getUserId());
    conn.setAppKey(pbapnsEvent.getAppKey());
    ConnectionKeeper.add(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId(),conn);
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(pbapnsEvent));
    ack(ctx,conn,pbapnsEvent,SYNC);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",pbapnsEvent);
    }
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Sleep_VALUE) {
    MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientServiceImpl.instance.findByUserId(pbapnsEvent.getUserId());
        if (c0 != null) {
          ClientServiceImpl.instance.updateStatus(c0.getId(),2);
        }
      }
    }
);
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Awake_VALUE) {
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (null == conn) {
      conn=new Connection(ctx);
      conn.setUserId(pbapnsEvent.getUserId());
      conn.setAppKey(pbapnsEvent.getAppKey());
      ConnectionKeeper.add(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId(),conn);
    }
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(pbapnsEvent));
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    if (pbapnsEvent.getRead() > 0) {
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          ClientServiceImpl.instance.updateBadge(pbapnsEvent.getUserId(),pbapnsEvent.getRead() * -1);
        }
      }
);
    }
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    final Connection connection=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (connection != null) {
      ConnectionKeeper.remove(connection.getAppKey(),connection.getUserId());
      connection.close();
      logger.info(""String_Node_Str"",pbapnsEvent);
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          Client c0=ClientServiceImpl.instance.findByUserId(pbapnsEvent.getUserId());
          if (c0 != null) {
            ClientServiceImpl.instance.updateOfflineTs(c0.getId(),connection.getLastOpTime());
          }
        }
      }
);
    }
    ctx.close();
  }
}","/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (logger.isDebugEnabled()) {
    logger.info(""String_Node_Str"",ctx.channel().hashCode());
  }
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent pbapnsEvent;
  try {
    byte[] bytes=(byte[])msg;
    pbapnsEvent=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ctx.close();
    return;
  }
  ReferenceCountUtil.release(msg);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",pbapnsEvent);
  }
  if (StringUtils.isEmpty(pbapnsEvent.getUserId()) || pbapnsEvent.getOp() <= 0) {
    logger.error(""String_Node_Str"");
    ctx.close();
    return;
  }
  if (pbapnsEvent.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (pbapnsEvent.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    boolean newDevice=false;
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (null != conn) {
      if (!conn.getToken().equalsIgnoreCase(pbapnsEvent.getToken())) {
        newDevice=true;
        logger.error(""String_Node_Str"",pbapnsEvent,conn);
        ack(ctx,conn,pbapnsEvent,MULTI_CLIENTS);
      }
    }
    if (newDevice) {
      conn=new Connection(ctx);
      conn.setUserId(pbapnsEvent.getUserId());
      conn.setAppKey(pbapnsEvent.getAppKey());
      conn.setToken(pbapnsEvent.getToken());
      ConnectionKeeper.add(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId(),conn);
    }
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(pbapnsEvent));
    ack(ctx,conn,pbapnsEvent,SYNC);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",pbapnsEvent);
    }
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Sleep_VALUE) {
    MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientServiceImpl.instance.findByUserId(pbapnsEvent.getUserId());
        if (c0 != null) {
          ClientServiceImpl.instance.updateStatus(c0.getId(),2);
        }
      }
    }
);
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Awake_VALUE) {
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (null == conn) {
      conn=new Connection(ctx);
      conn.setUserId(pbapnsEvent.getUserId());
      conn.setAppKey(pbapnsEvent.getAppKey());
      ConnectionKeeper.add(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId(),conn);
    }
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(pbapnsEvent));
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    if (pbapnsEvent.getRead() > 0) {
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          ClientServiceImpl.instance.updateBadge(pbapnsEvent.getUserId(),pbapnsEvent.getRead() * -1);
        }
      }
);
    }
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    final Connection connection=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (connection != null) {
      ConnectionKeeper.remove(connection.getAppKey(),connection.getUserId());
      connection.close();
      logger.info(""String_Node_Str"",pbapnsEvent);
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          Client c0=ClientServiceImpl.instance.findByUserId(pbapnsEvent.getUserId());
          if (c0 != null) {
            ClientServiceImpl.instance.updateOfflineTs(c0.getId(),connection.getLastOpTime());
          }
        }
      }
);
    }
    ctx.close();
  }
}"
12419,"/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (logger.isDebugEnabled()) {
    logger.info(""String_Node_Str"",ctx.channel().hashCode());
  }
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent pbapnsEvent;
  try {
    byte[] bytes=(byte[])msg;
    pbapnsEvent=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ctx.close();
    return;
  }
  ReferenceCountUtil.release(msg);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",pbapnsEvent);
  }
  if (StringUtils.isEmpty(pbapnsEvent.getUserId()) || pbapnsEvent.getOp() <= 0) {
    logger.error(""String_Node_Str"");
    ctx.close();
    return;
  }
  if (pbapnsEvent.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (pbapnsEvent.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    boolean newDevice=false;
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (null != conn) {
      if (!conn.getToken().equalsIgnoreCase(pbapnsEvent.getToken())) {
        newDevice=true;
        logger.error(""String_Node_Str"",pbapnsEvent,conn);
        ack(ctx,conn,pbapnsEvent,MULTI_CLIENTS);
      }
    }
    if (newDevice) {
      conn=new Connection(ctx);
      conn.setUserId(pbapnsEvent.getUserId());
      conn.setAppKey(pbapnsEvent.getAppKey());
      conn.setToken(pbapnsEvent.getToken());
      ConnectionKeeper.add(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId(),conn);
    }
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(pbapnsEvent));
    ack(ctx,conn,pbapnsEvent,SYNC);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",pbapnsEvent);
    }
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Sleep_VALUE) {
    MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientServiceImpl.instance.findByUserId(pbapnsEvent.getUserId());
        if (c0 != null) {
          ClientServiceImpl.instance.updateStatus(c0.getId(),2);
        }
      }
    }
);
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Awake_VALUE) {
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (null == conn) {
      conn=new Connection(ctx);
      conn.setUserId(pbapnsEvent.getUserId());
      conn.setAppKey(pbapnsEvent.getAppKey());
      ConnectionKeeper.add(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId(),conn);
    }
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(pbapnsEvent));
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    if (pbapnsEvent.getRead() > 0) {
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          ClientServiceImpl.instance.updateBadge(pbapnsEvent.getUserId(),pbapnsEvent.getRead() * -1);
        }
      }
);
    }
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    final Connection connection=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (connection != null) {
      ConnectionKeeper.remove(connection.getAppKey(),connection.getUserId());
      connection.close();
      logger.info(""String_Node_Str"",pbapnsEvent);
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          Client c0=ClientServiceImpl.instance.findByUserId(pbapnsEvent.getUserId());
          if (c0 != null) {
            ClientServiceImpl.instance.updateOfflineTs(c0.getId(),connection.getLastOpTime());
          }
        }
      }
);
    }
    ctx.close();
  }
}","/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (logger.isDebugEnabled()) {
    logger.info(""String_Node_Str"",ctx.channel().hashCode());
  }
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent pbapnsEvent;
  try {
    byte[] bytes=(byte[])msg;
    pbapnsEvent=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ctx.close();
    return;
  }
  ReferenceCountUtil.release(msg);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",pbapnsEvent);
  }
  if (StringUtils.isEmpty(pbapnsEvent.getUserId()) || pbapnsEvent.getOp() <= 0) {
    logger.error(""String_Node_Str"");
    ctx.close();
    return;
  }
  if (pbapnsEvent.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (pbapnsEvent.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    boolean newConnection=true;
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (null != conn) {
      if (!conn.getToken().equalsIgnoreCase(pbapnsEvent.getToken())) {
        newConnection=true;
        logger.error(""String_Node_Str"",pbapnsEvent,conn);
        ack(ctx,conn,pbapnsEvent,MULTI_CLIENTS);
      }
 else {
        newConnection=false;
      }
    }
    if (newConnection) {
      conn=new Connection(ctx);
      conn.setUserId(pbapnsEvent.getUserId());
      conn.setAppKey(pbapnsEvent.getAppKey());
      conn.setToken(pbapnsEvent.getToken());
      ConnectionKeeper.add(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId(),conn);
    }
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(pbapnsEvent));
    ack(ctx,conn,pbapnsEvent,SYNC);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",pbapnsEvent);
    }
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Sleep_VALUE) {
    MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientServiceImpl.instance.findByUserId(pbapnsEvent.getUserId());
        if (c0 != null) {
          ClientServiceImpl.instance.updateStatus(c0.getId(),2);
        }
      }
    }
);
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Awake_VALUE) {
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (null == conn) {
      conn=new Connection(ctx);
      conn.setUserId(pbapnsEvent.getUserId());
      conn.setAppKey(pbapnsEvent.getAppKey());
      ConnectionKeeper.add(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId(),conn);
    }
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(pbapnsEvent));
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    if (pbapnsEvent.getRead() > 0) {
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          ClientServiceImpl.instance.updateBadge(pbapnsEvent.getUserId(),pbapnsEvent.getRead() * -1);
        }
      }
);
    }
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    final Connection connection=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (connection != null) {
      ConnectionKeeper.remove(connection.getAppKey(),connection.getUserId());
      connection.close();
      logger.info(""String_Node_Str"",pbapnsEvent);
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          Client c0=ClientServiceImpl.instance.findByUserId(pbapnsEvent.getUserId());
          if (c0 != null) {
            ClientServiceImpl.instance.updateOfflineTs(c0.getId(),connection.getLastOpTime());
          }
        }
      }
);
    }
    ctx.close();
  }
}"
12420,"/** 
 * 添加连接
 * @param productId:   Product Id
 * @param token
 * @param conn
 */
public static boolean add(String productId,String token,Connection conn){
  Integer cid=ClientKeeper.get(productId,token);
  if (cid != null) {
    Connection c=pools.remove(cid);
    if (c != null) {
      ServerMetrics.decrConnection();
    }
  }
  cid=conn.getContext().hashCode();
  ClientKeeper.add(productId,token,cid);
  pools.put(cid,conn);
  ServerMetrics.incrConnection();
  return true;
}","/** 
 * 添加连接
 * @param productId:   Product Id
 * @param token
 * @param conn
 */
public static boolean add(String productId,String token,Connection conn){
  Integer cid=ClientKeeper.get(productId,token);
  if (cid != null) {
    Connection c=pools.remove(cid);
    if (c != null) {
      ServerMetrics.decrConnection();
    }
  }
  cid=conn.getContext().channel().hashCode();
  ClientKeeper.add(productId,token,cid);
  pools.put(cid,conn);
  ServerMetrics.incrConnection();
  return true;
}"
12421,"/** 
 * Rigourous Test :-)
 */
public void testApp(){
  assertTrue(true);
}","/** 
 * Rigourous Test :-)
 */
public void testApp(){
  print(intToBytes(50));
  System.out.println(toInt(intToBytes(50)));
  print(intToBytes(127));
  System.out.println(toInt(intToBytes(127)));
  print(intToBytes(128));
  System.out.println(toInt(intToBytes(128)));
  print(intToBytes(200));
  System.out.println(toInt(intToBytes(200)));
}"
12422,"/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (logger.isDebugEnabled()) {
    logger.info(""String_Node_Str"",ctx.channel().hashCode());
  }
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent cc;
  try {
    byte[] bytes=(byte[])msg;
    cc=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ctx.close();
    return;
  }
  ReferenceCountUtil.release(msg);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",cc);
  }
  if (StringUtils.isEmpty(cc.getUserId()) || cc.getOp() <= 0) {
    logger.error(""String_Node_Str"");
    ctx.close();
    return;
  }
  if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    Connection conn=ConnectionKeeper.get(cc.getAppKey(),cc.getUserId());
    if (null != conn) {
      logger.error(""String_Node_Str"",cc,conn);
      ack(ctx,cc,MULTI_CLIENTS);
      conn.close();
    }
    conn=new Connection(ctx.channel());
    conn.setUserId(cc.getUserId());
    conn.setAppKey(cc.getAppKey());
    ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),conn);
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(cc));
    ack(ctx,cc,SYNC);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",cc);
    }
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    ack(ctx,cc,SYNC);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Sleep_VALUE) {
    MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientServiceImpl.instance.findByUserId(cc.getUserId());
        if (c0 != null) {
          ClientServiceImpl.instance.updateStatus(c0.getId(),2);
        }
      }
    }
);
    ack(ctx,cc,SYNC);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Awake_VALUE) {
    Connection conn=ConnectionKeeper.get(cc.getAppKey(),cc.getUserId());
    if (null == conn) {
      conn=new Connection(ctx.channel());
      conn.setUserId(cc.getUserId());
      conn.setAppKey(cc.getAppKey());
      ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),conn);
    }
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(cc));
    ack(ctx,cc,SYNC);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    if (cc.getRead() > 0) {
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          ClientServiceImpl.instance.updateBadge(cc.getUserId(),cc.getRead() * -1);
        }
      }
);
    }
    ack(ctx,cc,SYNC);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    final Connection connection=ConnectionKeeper.get(cc.getAppKey(),cc.getUserId());
    if (connection != null) {
      ConnectionKeeper.remove(connection.getAppKey(),connection.getUserId());
      connection.close();
      logger.info(""String_Node_Str"",cc);
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          Client c0=ClientServiceImpl.instance.findByUserId(cc.getUserId());
          if (c0 != null) {
            ClientServiceImpl.instance.updateOfflineTs(c0.getId(),connection.getLastOpTime());
          }
        }
      }
);
    }
    ctx.close();
  }
}","/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (logger.isDebugEnabled()) {
    logger.info(""String_Node_Str"",ctx.channel().hashCode());
  }
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent cc;
  try {
    byte[] bytes=(byte[])msg;
    cc=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ctx.close();
    return;
  }
  ReferenceCountUtil.release(msg);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",cc);
  }
  if (StringUtils.isEmpty(cc.getUserId()) || cc.getOp() <= 0) {
    logger.error(""String_Node_Str"");
    ctx.close();
    return;
  }
  if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    Connection conn=ConnectionKeeper.get(cc.getAppKey(),cc.getUserId());
    if (null != conn) {
      logger.error(""String_Node_Str"",cc,conn);
      ack(ctx,cc,MULTI_CLIENTS);
    }
    conn=new Connection(ctx.channel());
    conn.setUserId(cc.getUserId());
    conn.setAppKey(cc.getAppKey());
    ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),conn);
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(cc));
    ack(ctx,cc,SYNC);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",cc);
    }
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    ack(ctx,cc,SYNC);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Sleep_VALUE) {
    MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientServiceImpl.instance.findByUserId(cc.getUserId());
        if (c0 != null) {
          ClientServiceImpl.instance.updateStatus(c0.getId(),2);
        }
      }
    }
);
    ack(ctx,cc,SYNC);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Awake_VALUE) {
    Connection conn=ConnectionKeeper.get(cc.getAppKey(),cc.getUserId());
    if (null == conn) {
      conn=new Connection(ctx.channel());
      conn.setUserId(cc.getUserId());
      conn.setAppKey(cc.getAppKey());
      ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),conn);
    }
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(cc));
    ack(ctx,cc,SYNC);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    if (cc.getRead() > 0) {
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          ClientServiceImpl.instance.updateBadge(cc.getUserId(),cc.getRead() * -1);
        }
      }
);
    }
    ack(ctx,cc,SYNC);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    final Connection connection=ConnectionKeeper.get(cc.getAppKey(),cc.getUserId());
    if (connection != null) {
      ConnectionKeeper.remove(connection.getAppKey(),connection.getUserId());
      connection.close();
      logger.info(""String_Node_Str"",cc);
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          Client c0=ClientServiceImpl.instance.findByUserId(cc.getUserId());
          if (c0 != null) {
            ClientServiceImpl.instance.updateOfflineTs(c0.getId(),connection.getLastOpTime());
          }
        }
      }
);
    }
    ctx.close();
  }
}"
12423,"private Integer doSend() throws Exception {
  if (message == null) {
    return 0;
  }
  if (message.getClients() == null || message.getClients().size() == 0) {
    logger.error(""String_Node_Str"",message);
    message.setStatusId(PayloadStatus.Failed);
    message.setTotalUsers(0);
    PayloadServiceImpl.instance.add(message);
    return 0;
  }
  message.setStatusId(PayloadStatus.Pending);
  message.setTotalUsers(0);
  PayloadServiceImpl.instance.add(message);
  for (  String client : message.getClients()) {
    Client cc=ClientServiceImpl.instance.findByUserId(client);
    if (cc == null) {
      logger.error(""String_Node_Str"" + client);
      if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
        message.setStatus(client,new PushStatus(PushStatus.NoClient));
      }
      continue;
    }
    message.setBadge(cc.getBadge() + 1);
    Connection c=ConnectionKeeper.get(product.getAppKey(),client);
    if (c != null) {
      c.send(message);
    }
 else {
      if (!cc.isDevice(ClientType.iOS)) {
        logger.error(""String_Node_Str"" + client);
        message.setStatus(cc.getUserId(),new PushStatus(PushStatus.NoConnections));
        continue;
      }
      if (StringUtils.isBlank(cc.getDeviceToken()) || ""String_Node_Str"".equalsIgnoreCase(cc.getDeviceToken())) {
        logger.error(""String_Node_Str"" + client);
        if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
          message.setStatus(cc.getUserId(),new PushStatus(PushStatus.NO_DEVICE_TOKEN));
        }
 else {
          message.setStatus(cc.getUserId(),new PushStatus(PushStatus.Ignore));
        }
        continue;
      }
      if (0 == message.getToMode()) {
        if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.APNS_VALUE) {
          APNSKeeper.instance.push(this.product,cc,message);
        }
 else         if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
          message.setStatus(cc.getUserId(),new PushStatus(PushStatus.WaitOnline));
        }
      }
 else {
        message.setStatus(cc.getUserId(),new PushStatus(PushStatus.Ignore));
      }
    }
  }
  PayloadServiceImpl.instance.updateSendStatus(message);
  return message.getClients().size();
}","private Integer doSend() throws Exception {
  if (message == null) {
    return 0;
  }
  if (message.getClients() == null || message.getClients().size() == 0) {
    logger.error(""String_Node_Str"",message);
    message.setStatusId(PayloadStatus.Failed);
    message.setTotalUsers(0);
    PayloadServiceImpl.instance.add(message);
    return 0;
  }
  if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
    message.setStatusId(PayloadStatus.Pending);
    message.setTotalUsers(0);
    PayloadServiceImpl.instance.add(message);
  }
  for (  String client : message.getClients()) {
    Client cc=ClientServiceImpl.instance.findByUserId(client);
    if (cc == null) {
      logger.error(""String_Node_Str"" + client);
      if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
        message.setStatus(client,new PushStatus(PushStatus.NoClient));
      }
      continue;
    }
    message.setBadge(cc.getBadge() + 1);
    Connection c=ConnectionKeeper.get(product.getAppKey(),client);
    if (c != null) {
      c.send(message);
    }
 else {
      if (!cc.isDevice(ClientType.iOS)) {
        logger.error(""String_Node_Str"" + client);
        message.setStatus(cc.getUserId(),new PushStatus(PushStatus.NoConnections));
        continue;
      }
      if (StringUtils.isBlank(cc.getDeviceToken()) || ""String_Node_Str"".equalsIgnoreCase(cc.getDeviceToken())) {
        logger.error(""String_Node_Str"" + client);
        if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
          message.setStatus(cc.getUserId(),new PushStatus(PushStatus.NO_DEVICE_TOKEN));
        }
 else {
          message.setStatus(cc.getUserId(),new PushStatus(PushStatus.Ignore));
        }
        continue;
      }
      if (0 == message.getToMode()) {
        if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.APNS_VALUE) {
          APNSKeeper.instance.push(this.product,cc,message);
        }
 else         if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
          message.setStatus(cc.getUserId(),new PushStatus(PushStatus.WaitOnline));
        }
      }
 else {
        message.setStatus(cc.getUserId(),new PushStatus(PushStatus.Ignore));
      }
    }
  }
  PayloadServiceImpl.instance.updateSendStatus(message);
  return message.getClients().size();
}"
12424,"protected ThreadPoolTaskExecutor createPool(){
  int min=Integer.parseInt(this.conf.getProperty(DISPATCHER_THREAD_MIN,""String_Node_Str""));
  int max=Integer.parseInt(this.conf.getProperty(DISPATCHER_THREAD_MAX,""String_Node_Str""));
  ThreadPoolTaskExecutor exe=new ThreadPoolTaskExecutor();
  exe.setCorePoolSize(min);
  exe.setMaxPoolSize(max);
  exe.setWaitForTasksToCompleteOnShutdown(true);
  exe.afterPropertiesSet();
  return exe;
}","protected ThreadPoolTaskExecutor createPool(){
  int min=Integer.parseInt(this.conf.getProperty(DISPATCHER_THREAD_MIN,""String_Node_Str""));
  int max=Integer.parseInt(this.conf.getProperty(DISPATCHER_THREAD_MAX,""String_Node_Str""));
  ThreadPoolTaskExecutor exe=new ThreadPoolTaskExecutor();
  exe.setCorePoolSize(min);
  exe.setMaxPoolSize(max);
  exe.setWaitForTasksToCompleteOnShutdown(true);
  exe.setThreadGroupName(""String_Node_Str"" + product.getId() + ""String_Node_Str"");
  exe.afterPropertiesSet();
  return exe;
}"
12425,"@Override public Integer call() throws Exception {
  List<Long> ids=PayloadServiceImpl.instance.findLatestToOfflineClients(product.getId(),userId,0);
  logger.info(""String_Node_Str"",userId,product,ids.size());
  if (ids == null || ids.size() == 0) {
    return 0;
  }
  List<Payload> list=PayloadServiceImpl.instance.getSimpleList(ids);
  for (  Payload message : list) {
    this.doSendMessage(message);
  }
  return 0;
}","@Override public Integer call() throws Exception {
  List<Long> ids=PayloadServiceImpl.instance.findLatestToOfflineClients(product.getId(),userId,0);
  logger.info(""String_Node_Str"",userId,product,ids.size());
  if (ids == null || ids.size() == 0) {
    return 0;
  }
  List<Payload> list=PayloadServiceImpl.instance.getSimpleList(ids);
  for (  Payload message : list) {
    this.doSendMessage(message);
  }
  return list.size();
}"
12426,"private Integer doSendMessage(Payload message){
  if (message != null) {
    SentProgress progress=new SentProgress(1);
    Connection c=ConnectionKeeper.get(product.getAppKey(),this.userId);
    if (c != null) {
      c.send(message);
    }
 else {
      progress.incrFailed();
    }
    try {
      progress.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    int total=progress.getSuccess().get();
    if (total > 0) {
      try {
        message.setClients(new ArrayList<String>());
        message.getClients().add(this.userId);
        PayloadServiceImpl.instance.updateSendStatus(message);
      }
 catch (      Exception e) {
        logger.error(e.getMessage(),e);
      }
    }
    return total;
  }
  return 0;
}","private Integer doSendMessage(Payload message){
  if (message != null) {
    Connection c=ConnectionKeeper.get(product.getAppKey(),this.userId);
    if (c != null) {
      c.send(message);
      return 1;
    }
  }
  return 0;
}"
12427,"/** 
 * 添加连接
 * @param productId:   Product Id
 * @param token
 * @param conn
 */
public static boolean add(String productId,String token,Connection conn){
  Integer cid=ClientKeeper.get(productId,token);
  if (cid != null) {
    Connection c=pools.remove(cid);
    if (c != null) {
      c.close();
      ServerMetrics.decrConnection();
    }
  }
  cid=conn.getChannel().hashCode();
  ClientKeeper.add(productId,token,cid);
  pools.put(cid,conn);
  ServerMetrics.incrConnection();
  return true;
}","/** 
 * 添加连接
 * @param productId:   Product Id
 * @param token
 * @param conn
 */
public static boolean add(String productId,String token,Connection conn){
  Integer cid=ClientKeeper.get(productId,token);
  if (cid != null) {
    Connection c=pools.remove(cid);
    if (c != null) {
      ServerMetrics.decrConnection();
    }
  }
  cid=conn.getChannel().hashCode();
  ClientKeeper.add(productId,token,cid);
  pools.put(cid,conn);
  ServerMetrics.incrConnection();
  return true;
}"
12428,"private void ack(final ChannelHandlerContext ctx,PBAPNSEvent cc,final String result){
  PBAPNSMessage.Builder builder=PBAPNSMessage.newBuilder();
  builder.setAps(PBAPNSBody.newBuilder().setAlert(""String_Node_Str"").setBadge(0));
  PBAPNSUserInfo.Builder infoBuilder=PBAPNSUserInfo.newBuilder().setKey(""String_Node_Str"").setValue(result);
  builder.addUserInfo(infoBuilder);
  infoBuilder=PBAPNSUserInfo.newBuilder().setKey(""String_Node_Str"").setValue(SYNC);
  builder.addUserInfo(infoBuilder);
  byte[] bytes=builder.build().toByteArray();
  final ByteBuf data=ctx.alloc().buffer(bytes.length);
  data.writeBytes(bytes);
  final ChannelFuture cf=ctx.channel().writeAndFlush(data);
  cf.addListener(new GenericFutureListener<Future<? super Void>>(){
    @Override public void operationComplete(    Future<? super Void> future) throws Exception {
      if (cf.cause() != null) {
        logger.error(""String_Node_Str"",cf.cause());
        ctx.close();
      }
 else {
        if (result.equalsIgnoreCase(MULTI_CLIENTS)) {
          ctx.close();
        }
      }
    }
  }
);
}","private void ack(final ChannelHandlerContext ctx,final Connection cc,PBAPNSEvent event,final String result){
  PBAPNSMessage.Builder builder=PBAPNSMessage.newBuilder();
  builder.setAps(PBAPNSBody.newBuilder().setAlert(""String_Node_Str"").setBadge(0));
  PBAPNSUserInfo.Builder infoBuilder=PBAPNSUserInfo.newBuilder().setKey(""String_Node_Str"").setValue(result);
  builder.addUserInfo(infoBuilder);
  infoBuilder=PBAPNSUserInfo.newBuilder().setKey(""String_Node_Str"").setValue(SYNC);
  builder.addUserInfo(infoBuilder);
  byte[] bytes=builder.build().toByteArray();
  final ByteBuf data=ctx.alloc().buffer(bytes.length);
  data.writeBytes(bytes);
  final ChannelFuture cf=cc.getChannel().writeAndFlush(data);
  cf.addListener(new GenericFutureListener<Future<? super Void>>(){
    @Override public void operationComplete(    Future<? super Void> future) throws Exception {
      if (cf.cause() != null) {
        logger.error(""String_Node_Str"",cf.cause());
        cc.close();
      }
 else {
        if (result.equalsIgnoreCase(MULTI_CLIENTS)) {
          cc.close();
        }
      }
    }
  }
);
}"
12429,"@Override public void operationComplete(Future<? super Void> future) throws Exception {
  if (cf.cause() != null) {
    logger.error(""String_Node_Str"",cf.cause());
    ctx.close();
  }
 else {
    if (result.equalsIgnoreCase(MULTI_CLIENTS)) {
      ctx.close();
    }
  }
}","@Override public void operationComplete(Future<? super Void> future) throws Exception {
  if (cf.cause() != null) {
    logger.error(""String_Node_Str"",cf.cause());
    cc.close();
  }
 else {
    if (result.equalsIgnoreCase(MULTI_CLIENTS)) {
      cc.close();
    }
  }
}"
12430,"/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (logger.isDebugEnabled()) {
    logger.info(""String_Node_Str"",ctx.channel().hashCode());
  }
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent cc;
  try {
    byte[] bytes=(byte[])msg;
    cc=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ctx.close();
    return;
  }
  ReferenceCountUtil.release(msg);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",cc);
  }
  if (StringUtils.isEmpty(cc.getUserId()) || cc.getOp() <= 0) {
    logger.error(""String_Node_Str"");
    ctx.close();
    return;
  }
  if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    Connection conn=ConnectionKeeper.get(cc.getAppKey(),cc.getUserId());
    if (null != conn) {
      logger.error(""String_Node_Str"",cc,conn);
      ack(ctx,cc,MULTI_CLIENTS);
    }
    conn=new Connection(ctx.channel());
    conn.setUserId(cc.getUserId());
    conn.setAppKey(cc.getAppKey());
    ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),conn);
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(cc));
    ack(ctx,cc,SYNC);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",cc);
    }
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    ack(ctx,cc,SYNC);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Sleep_VALUE) {
    MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientServiceImpl.instance.findByUserId(cc.getUserId());
        if (c0 != null) {
          ClientServiceImpl.instance.updateStatus(c0.getId(),2);
        }
      }
    }
);
    ack(ctx,cc,SYNC);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Awake_VALUE) {
    Connection conn=ConnectionKeeper.get(cc.getAppKey(),cc.getUserId());
    if (null == conn) {
      conn=new Connection(ctx.channel());
      conn.setUserId(cc.getUserId());
      conn.setAppKey(cc.getAppKey());
      ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),conn);
    }
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(cc));
    ack(ctx,cc,SYNC);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    if (cc.getRead() > 0) {
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          ClientServiceImpl.instance.updateBadge(cc.getUserId(),cc.getRead() * -1);
        }
      }
);
    }
    ack(ctx,cc,SYNC);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    final Connection connection=ConnectionKeeper.get(cc.getAppKey(),cc.getUserId());
    if (connection != null) {
      ConnectionKeeper.remove(connection.getAppKey(),connection.getUserId());
      connection.close();
      logger.info(""String_Node_Str"",cc);
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          Client c0=ClientServiceImpl.instance.findByUserId(cc.getUserId());
          if (c0 != null) {
            ClientServiceImpl.instance.updateOfflineTs(c0.getId(),connection.getLastOpTime());
          }
        }
      }
);
    }
    ctx.close();
  }
}","/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (logger.isDebugEnabled()) {
    logger.info(""String_Node_Str"",ctx.channel().hashCode());
  }
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent pbapnsEvent;
  try {
    byte[] bytes=(byte[])msg;
    pbapnsEvent=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ctx.close();
    return;
  }
  ReferenceCountUtil.release(msg);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",pbapnsEvent);
  }
  if (StringUtils.isEmpty(pbapnsEvent.getUserId()) || pbapnsEvent.getOp() <= 0) {
    logger.error(""String_Node_Str"");
    ctx.close();
    return;
  }
  if (pbapnsEvent.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (pbapnsEvent.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (null != conn) {
      logger.error(""String_Node_Str"",pbapnsEvent,conn);
      ack(ctx,conn,pbapnsEvent,MULTI_CLIENTS);
    }
    conn=new Connection(ctx.channel());
    conn.setUserId(pbapnsEvent.getUserId());
    conn.setAppKey(pbapnsEvent.getAppKey());
    ConnectionKeeper.add(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId(),conn);
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(pbapnsEvent));
    ack(ctx,conn,pbapnsEvent,SYNC);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",pbapnsEvent);
    }
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Sleep_VALUE) {
    MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientServiceImpl.instance.findByUserId(pbapnsEvent.getUserId());
        if (c0 != null) {
          ClientServiceImpl.instance.updateStatus(c0.getId(),2);
        }
      }
    }
);
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Awake_VALUE) {
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (null == conn) {
      conn=new Connection(ctx.channel());
      conn.setUserId(pbapnsEvent.getUserId());
      conn.setAppKey(pbapnsEvent.getAppKey());
      ConnectionKeeper.add(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId(),conn);
    }
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(pbapnsEvent));
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    if (pbapnsEvent.getRead() > 0) {
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          ClientServiceImpl.instance.updateBadge(pbapnsEvent.getUserId(),pbapnsEvent.getRead() * -1);
        }
      }
);
    }
    Connection conn=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    ack(ctx,conn,pbapnsEvent,SYNC);
  }
 else   if (pbapnsEvent.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    final Connection connection=ConnectionKeeper.get(pbapnsEvent.getAppKey(),pbapnsEvent.getUserId());
    if (connection != null) {
      ConnectionKeeper.remove(connection.getAppKey(),connection.getUserId());
      connection.close();
      logger.info(""String_Node_Str"",pbapnsEvent);
      MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
        @Override public void run(){
          Client c0=ClientServiceImpl.instance.findByUserId(pbapnsEvent.getUserId());
          if (c0 != null) {
            ClientServiceImpl.instance.updateOfflineTs(c0.getId(),connection.getLastOpTime());
          }
        }
      }
);
    }
    ctx.close();
  }
}"
12431,"@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  ctx.fireChannelInactive();
  System.out.println(""String_Node_Str"" + ctx.channel());
  ClientProxyDelegate.instance.remove(ctx.channel());
  reconnect();
}","@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  ctx.fireChannelInactive();
  logger.error(""String_Node_Str"" + ctx.channel());
  ClientProxyDelegate.instance.remove(ctx.channel());
  reconnect();
}"
12432,"@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {
  System.out.println(""String_Node_Str"" + ctx.channel());
  ClientProxyDelegate.instance.save(ctx.channel());
}","@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + ctx.channel());
  }
  ClientProxyDelegate.instance.save(ctx.channel());
}"
12433,"@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  String jsonString=new String((byte[])msg);
  System.out.println(""String_Node_Str"" + ctx.channel() + ""String_Node_Str""+ jsonString);
  ctx.fireChannelRead(msg);
}","@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  String jsonString=new String((byte[])msg);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + ctx.channel() + ""String_Node_Str""+ jsonString);
  }
  ctx.fireChannelRead(msg);
}"
12434,"public void get(final ChannelAvaliable task){
  Channel c=channelList.pollFirst();
  if (c == null) {
    final ChannelFuture f=newChannel();
    if (f == null) {
      return;
    }
    f.addListener(new GenericFutureListener<Future<? super java.lang.Void>>(){
      @Override public void operationComplete(      Future<? super Void> future) throws Exception {
        if (future.cause() == null) {
          final Channel c0=f.channel();
          task.execute(c0);
        }
 else {
          future.cause().printStackTrace();
        }
      }
    }
);
  }
 else {
    task.execute(c);
    channelList.add(c);
  }
}","public void get(final ChannelAvaliable task){
  Channel c=channelList.pollFirst();
  if (c == null) {
    final ChannelFuture f=newChannel();
    if (f == null) {
      return;
    }
    f.addListener(new GenericFutureListener<Future<? super java.lang.Void>>(){
      @Override public void operationComplete(      Future<? super Void> future) throws Exception {
        if (future.cause() == null) {
          final Channel c0=f.channel();
          task.execute(c0);
        }
 else {
          logger.error(""String_Node_Str"",f.cause());
        }
      }
    }
);
  }
 else {
    task.execute(c);
    channelList.add(c);
  }
}"
12435,"public ChannelFuture newChannel(){
  ChannelFuture f=b.connect(host,port);
  if (f.cause() != null) {
    f.cause().printStackTrace();
    return null;
  }
  return f;
}","public ChannelFuture newChannel(){
  ChannelFuture f=b.connect(host,port);
  if (f.cause() != null) {
    logger.error(""String_Node_Str"",f.cause());
    return null;
  }
  return f;
}"
12436,"@Override public void operationComplete(Future<? super Void> future) throws Exception {
  if (future.cause() == null) {
    final Channel c0=f.channel();
    task.execute(c0);
  }
 else {
    future.cause().printStackTrace();
  }
}","@Override public void operationComplete(Future<? super Void> future) throws Exception {
  if (future.cause() == null) {
    final Channel c0=f.channel();
    task.execute(c0);
  }
 else {
    logger.error(""String_Node_Str"",f.cause());
  }
}"
12437,"private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",client,message);
      }
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        Client cc=ClientServiceImpl.instance.findByUserId(client);
        if (cc == null) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoConnections,null));
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoDevivceToken,null));
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadServiceImpl.instance.saveAfterSent(message);
      }
 else {
        PayloadServiceImpl.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
 else {
    logger.error(""String_Node_Str"",message);
  }
  return 0;
}","private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",client,message);
      }
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        Client cc=ClientServiceImpl.instance.findByUserId(client);
        if (cc == null) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          message.addFailedClient(client,new PushError(PushError.NoClient,null));
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoConnections,null));
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoDevivceToken,null));
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadServiceImpl.instance.saveAfterSent(message);
      }
 else {
        PayloadServiceImpl.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
 else {
    logger.error(""String_Node_Str"",message);
  }
  return 0;
}"
12438,"public void send(final SentProgress progress,final Payload message,final byte[] msg){
  try {
    final ByteBuf data=channel.config().getAllocator().buffer(msg.length);
    data.writeBytes(msg);
    final ChannelFuture cf=channel.writeAndFlush(data);
    cf.addListener(new GenericFutureListener<Future<? super Void>>(){
      @Override public void operationComplete(      Future<? super Void> future) throws Exception {
        if (cf.cause() != null) {
          logger.error(""String_Node_Str"",channel,cf.cause());
          progress.incrFailed();
          message.addFailedClient(userId,new PushError(PushError.UnKnown,cf.cause().getMessage()));
        }
 else {
          progress.incrSuccess();
          if (logger.isDebugEnabled()) {
            logger.debug(""String_Node_Str"",channel,channel.hashCode());
          }
        }
      }
    }
);
  }
 catch (  Exception e) {
    progress.incrFailed();
    message.addFailedClient(userId,new PushError(PushError.UnKnown,e.getMessage()));
    logger.error(e.getMessage(),e);
  }
}","public void send(final SentProgress progress,final Payload message,final byte[] msg){
  try {
    final ByteBuf data=channel.config().getAllocator().buffer(msg.length);
    data.writeBytes(msg);
    final ChannelFuture cf=channel.writeAndFlush(data);
    cf.addListener(new GenericFutureListener<Future<? super Void>>(){
      @Override public void operationComplete(      Future<? super Void> future) throws Exception {
        if (cf.cause() != null) {
          logger.error(""String_Node_Str"",channel,cf.cause());
          progress.incrFailed();
          message.addFailedClient(userId,new PushError(PushError.WriterError,cf.cause().getMessage()));
        }
 else {
          progress.incrSuccess();
          if (logger.isDebugEnabled()) {
            logger.debug(""String_Node_Str"",channel,channel.hashCode());
          }
        }
      }
    }
);
  }
 catch (  Exception e) {
    progress.incrFailed();
    message.addFailedClient(userId,new PushError(PushError.UnKnown,e.getMessage()));
    logger.error(e.getMessage(),e);
  }
}"
12439,"@Override public void operationComplete(Future<? super Void> future) throws Exception {
  if (cf.cause() != null) {
    logger.error(""String_Node_Str"",channel,cf.cause());
    progress.incrFailed();
    message.addFailedClient(userId,new PushError(PushError.UnKnown,cf.cause().getMessage()));
  }
 else {
    progress.incrSuccess();
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",channel,channel.hashCode());
    }
  }
}","@Override public void operationComplete(Future<? super Void> future) throws Exception {
  if (cf.cause() != null) {
    logger.error(""String_Node_Str"",channel,cf.cause());
    progress.incrFailed();
    message.addFailedClient(userId,new PushError(PushError.WriterError,cf.cause().getMessage()));
  }
 else {
    progress.incrSuccess();
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",channel,channel.hashCode());
    }
  }
}"
12440,"private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",client,message);
      }
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        Client cc=ClientServiceImpl.instance.findByUserId(client);
        if (cc == null) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          message.addFailedClient(client,new PushError(PushError.NoClient,null));
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoConnections,null));
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoDevivceToken,null));
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadServiceImpl.instance.saveAfterSent(message);
      }
 else {
        PayloadServiceImpl.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
 else {
    this.progress.incrFailed();
    logger.error(""String_Node_Str"",message);
  }
  return 0;
}","private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",client,message);
      }
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        Client cc=ClientServiceImpl.instance.findByUserId(client);
        if (cc == null) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          message.addFailedClient(client,new PushError(PushError.NoClient,null));
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoConnections,null));
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoDevivceToken,null));
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await(message.getClients().size() * 5,TimeUnit.SECONDS);
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadServiceImpl.instance.saveAfterSent(message);
      }
 else {
        PayloadServiceImpl.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
 else {
    this.progress.incrFailed();
    logger.error(""String_Node_Str"",message);
  }
  return 0;
}"
12441,"@Override @TxMain public void add(final Client client){
  if (client == null) {
    return;
  }
  final String sql=""String_Node_Str"";
  KeyHolder holder=new GeneratedKeyHolder();
  this.mainJdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
      ps.setObject(1,client.getProductId());
      ps.setObject(2,client.getUserId());
      ps.setObject(3,client.getDeviceToken());
      ps.setObject(4,new Date());
      ps.setObject(5,ClientStatus.NewlyAdd);
      ps.setObject(6,client.getTypeId());
      return ps;
    }
  }
,holder);
  client.setId(holder.getKey().longValue());
}","@Override @TxMain public void add(final Client client){
  if (client == null) {
    return;
  }
  final String sql=""String_Node_Str"";
  KeyHolder holder=new GeneratedKeyHolder();
  this.mainJdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
      ps.setObject(1,client.getProductId());
      ps.setObject(2,client.getUserId());
      ps.setObject(3,client.getDeviceToken());
      ps.setObject(4,new Date());
      ps.setObject(5,ClientStatus.Online);
      ps.setObject(6,client.getTypeId());
      return ps;
    }
  }
,holder);
  client.setId(holder.getKey().longValue());
}"
12442,"@Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
  ps.setObject(1,client.getProductId());
  ps.setObject(2,client.getUserId());
  ps.setObject(3,client.getDeviceToken());
  ps.setObject(4,new Date());
  ps.setObject(5,ClientStatus.NewlyAdd);
  ps.setObject(6,client.getTypeId());
  return ps;
}","@Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
  ps.setObject(1,client.getProductId());
  ps.setObject(2,client.getUserId());
  ps.setObject(3,client.getDeviceToken());
  ps.setObject(4,new Date());
  ps.setObject(5,ClientStatus.Online);
  ps.setObject(6,client.getTypeId());
  return ps;
}"
12443,"@Override @TxMain public void updateOnlineTs(long id){
  String sql=""String_Node_Str"";
  this.mainJdbc.update(sql,new Date().getTime() / 1000,id);
}","@Override @TxMain public void updateOnlineTs(long id){
  String sql=""String_Node_Str"";
  this.mainJdbc.update(sql,new Date().getTime() / 1000,ClientStatus.Online,id);
}"
12444,"@Override @TxMain public void updateSendStatus(final Payload message,final int counting){
  jdbcExecutor.submit(new Runnable(){
    @Override public void run(){
      String sql=""String_Node_Str"";
      mainJdbc.update(sql,counting > 0 ? PayloadStatus.Sent : PayloadStatus.Pending,counting,new Date().getTime() / 1000,message.getId());
      sql=""String_Node_Str"";
      mainJdbc.update(sql,counting > 0 ? PayloadStatus.Sent : PayloadStatus.Pending,message.getId());
      MetricBuilder.jdbcUpdateMeter.mark(2);
      updatePendingCount(false);
    }
  }
);
  updatePendingCount(true);
}","@Override @TxMain public void updateSendStatus(final Payload message,final int counting){
  jdbcExecutor.submit(new Runnable(){
    @Override public void run(){
      String sql=""String_Node_Str"";
      mainJdbc.update(sql,counting > 0 ? PayloadStatus.Sent : PayloadStatus.Pending,counting,new Date().getTime() / 1000,message.getId());
      sql=""String_Node_Str"";
      List<Object[]> args=Lists.newArrayList();
      Set<String> cc=message.getFailedClients();
      for (      String userId : message.getClients()) {
        int statusId=cc.contains(userId) ? 0 : 1;
        args.add(new Object[]{statusId,new Date().getTime() / 1000,message.getId(),userId});
      }
      mainJdbc.batchUpdate(sql,args);
      MetricBuilder.jdbcUpdateMeter.mark(2);
      updatePendingCount(false);
    }
  }
);
  updatePendingCount(true);
}"
12445,"public void send(final SentProgress progress,final byte[] msg){
  try {
    final ByteBuf data=channel.config().getAllocator().buffer(msg.length);
    data.writeBytes(msg);
    final ChannelFuture cf=channel.writeAndFlush(data);
    cf.addListener(new GenericFutureListener<Future<? super Void>>(){
      @Override public void operationComplete(      Future<? super Void> future) throws Exception {
        if (cf.cause() != null) {
          logger.error(""String_Node_Str"",channel,cf.cause());
          progress.incrFailed();
        }
 else {
          progress.incrSuccess();
          if (logger.isDebugEnabled()) {
            logger.debug(""String_Node_Str"",channel,channel.hashCode());
          }
        }
      }
    }
);
  }
 catch (  Exception e) {
    progress.incrFailed();
    logger.error(e.getMessage(),e);
  }
}","public void send(final SentProgress progress,final Payload message,final byte[] msg){
  try {
    final ByteBuf data=channel.config().getAllocator().buffer(msg.length);
    data.writeBytes(msg);
    final ChannelFuture cf=channel.writeAndFlush(data);
    cf.addListener(new GenericFutureListener<Future<? super Void>>(){
      @Override public void operationComplete(      Future<? super Void> future) throws Exception {
        if (cf.cause() != null) {
          logger.error(""String_Node_Str"",channel,cf.cause());
          progress.incrFailed();
          message.addFailedClient(userId);
        }
 else {
          progress.incrSuccess();
          if (logger.isDebugEnabled()) {
            logger.debug(""String_Node_Str"",channel,channel.hashCode());
          }
        }
      }
    }
);
  }
 catch (  Exception e) {
    progress.incrFailed();
    message.addFailedClient(userId);
    logger.error(e.getMessage(),e);
  }
}"
12446,"@Override public void operationComplete(Future<? super Void> future) throws Exception {
  if (cf.cause() != null) {
    logger.error(""String_Node_Str"",channel,cf.cause());
    progress.incrFailed();
  }
 else {
    progress.incrSuccess();
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",channel,channel.hashCode());
    }
  }
}","@Override public void operationComplete(Future<? super Void> future) throws Exception {
  if (cf.cause() != null) {
    logger.error(""String_Node_Str"",channel,cf.cause());
    progress.incrFailed();
    message.addFailedClient(userId);
  }
 else {
    progress.incrSuccess();
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",channel,channel.hashCode());
    }
  }
}"
12447,"private void saveBoradcastStatus(Payload message,int total){
  try {
    if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
      message.setTotalUsers(total);
      message.setSentDate(new Date().getTime() / 1000);
      message.setStatusId(PayloadStatus.Sent);
      PayloadServiceImpl.instance.saveWithId(message);
    }
 else {
      PayloadServiceImpl.instance.updateSendStatus(message,total);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if (total > 0) {
    MetricBuilder.pushMeter.mark(total);
    MetricBuilder.boradcastMeter.mark(total);
  }
}","private void saveBoradcastStatus(Payload message,int total){
  try {
    if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
      message.setTotalUsers(total);
      message.setSentDate(new Date().getTime() / 1000);
      message.setStatusId(PayloadStatus.Sent);
      PayloadServiceImpl.instance.saveAfterSent(message);
    }
 else {
      PayloadServiceImpl.instance.updateSendStatus(message,total);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if (total > 0) {
    MetricBuilder.pushMeter.mark(total);
    MetricBuilder.boradcastMeter.mark(total);
  }
}"
12448,"private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",client,message);
      }
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        if (product.getClientTypeid().intValue() != ClientType.iOS) {
          thisProg.incrFailed();
          continue;
        }
        Client cc=ClientServiceImpl.instance.findByUserId(client);
        if (cc == null) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          thisProg.incrFailed();
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          thisProg.incrFailed();
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadServiceImpl.instance.saveWithId(message);
      }
 else {
        PayloadServiceImpl.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
 else {
    logger.error(""String_Node_Str"",message);
  }
  return 0;
}","private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",client,message);
      }
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        Client cc=ClientServiceImpl.instance.findByUserId(client);
        if (cc == null) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId());
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId());
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadServiceImpl.instance.saveAfterSent(message);
      }
 else {
        PayloadServiceImpl.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
 else {
    logger.error(""String_Node_Str"",message);
  }
  return 0;
}"
12449,"/** 
 * 连接断开，移除连接影射，客户端发起重连
 */
@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  ConnectionKeeper.remove(ctx.channel().hashCode());
}","/** 
 * 连接断开，移除连接影射，客户端发起重连
 */
@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  Connection connection=ConnectionKeeper.get(ctx.channel().hashCode());
  if (null != connection) {
    Client client=ClientServiceImpl.instance.findByUserId(connection.getUserId());
    if (null != client) {
      ClientServiceImpl.instance.updateStatus(client.getId(),ClientStatus.Offline);
    }
  }
  ConnectionKeeper.remove(ctx.channel().hashCode());
}"
12450,"@Override public void run(){
  Client c0=ClientServiceImpl.instance.findByUserId(cc.getUserId());
  if (c0 != null) {
    ClientServiceImpl.instance.updateOnlineTs(c0.getId());
  }
}","@Override public void run(){
  Client c0=ClientServiceImpl.instance.findByUserId(cc.getUserId());
  if (c0 != null) {
    ClientServiceImpl.instance.updateStatus(c0.getId(),ClientStatus.Offline);
  }
}"
12451,"/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (logger.isDebugEnabled()) {
    logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  }
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent cc;
  try {
    byte[] bytes=(byte[])msg;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",bytes.length);
      logger.debug(""String_Node_Str"",bytes);
    }
    cc=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ack(ctx,null);
    return;
  }
  ReferenceCountUtil.release(msg);
  if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",cc);
    }
    ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),new Connection(ctx.channel()));
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(cc));
    ack(ctx,cc);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",cc);
    }
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientServiceImpl.instance.findByUserId(cc.getUserId());
        if (c0 != null) {
          ClientServiceImpl.instance.updateOnlineTs(c0.getId());
        }
      }
    }
);
    ctx.close();
  }
}","/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (logger.isDebugEnabled()) {
    logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  }
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent cc;
  try {
    byte[] bytes=(byte[])msg;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",bytes.length);
      logger.debug(""String_Node_Str"",bytes);
    }
    cc=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ack(ctx,null);
    return;
  }
  ReferenceCountUtil.release(msg);
  if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",cc);
    }
    Connection conn=new Connection(ctx.channel());
    conn.setUserId(cc.getUserId());
    conn.setAppKey(cc.getAppKey());
    ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),conn);
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(cc));
    ack(ctx,cc);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",cc);
    }
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientServiceImpl.instance.findByUserId(cc.getUserId());
        if (c0 != null) {
          ClientServiceImpl.instance.updateStatus(c0.getId(),ClientStatus.Offline);
        }
      }
    }
);
    ctx.close();
  }
}"
12452,"public static void push(SentProgress progress,Product product,Client cc,Payload message){
  String json=message.asJson();
  ApnsService service=get(product);
  if (service != null) {
    try {
      service.push(cc.getDeviceToken(),json);
      progress.incrSuccess();
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      progress.incrFailed();
    }
  }
}","public static void push(SentProgress progress,Product product,Client cc,Payload message){
  String json=message.asJson();
  ApnsService service=get(product);
  if (service != null) {
    try {
      service.push(cc.getDeviceToken(),json);
      progress.incrSuccess();
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      progress.incrFailed();
      message.addFailedClient(cc.getUserId());
    }
  }
}"
12453,"public void addFailedClient(String userId){
  failedClients.put(userId,1);
}","public void addFailedClient(String userId,PushError error){
  failedClients.put(userId,error);
}"
12454,"public Set<String> getFailedClients(){
  return failedClients.keySet();
}","public Map<String,PushError> getFailedClients(){
  return failedClients;
}"
12455,"@Override @TxMain public void saveAfterSent(final Payload payload) throws Exception {
  if (payload == null) {
    return;
  }
  if (payload.getId() == null || payload.getId().intValue() == 0) {
    throw new Exception(""String_Node_Str"");
  }
  jdbcExecutor.submit(new Runnable(){
    @Override public void run(){
      final String sql=""String_Node_Str"";
      mainJdbc.update(new PreparedStatementCreator(){
        @Override public PreparedStatement createPreparedStatement(        Connection connection) throws SQLException {
          PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
          ps.setObject(1,payload.getId());
          ps.setObject(2,payload.getTitle());
          ps.setObject(3,payload.getBadge());
          ps.setObject(4,payload.getExtras());
          ps.setObject(5,payload.getSound());
          ps.setObject(6,payload.getProductId());
          ps.setObject(7,payload.getTotalUsers());
          ps.setObject(8,payload.getCreateAt());
          ps.setObject(9,payload.getStatusId());
          ps.setObject(10,payload.getBroadcast());
          ps.setObject(11,payload.getSentDate());
          return ps;
        }
      }
);
      MetricBuilder.jdbcUpdateMeter.mark(1);
      if (payload.getClients() != null) {
        List<Object[]> args=Lists.newArrayList();
        Set<String> cc=payload.getFailedClients();
        final String sql0=""String_Node_Str"";
        for (        String userId : payload.getClients()) {
          int statusId=cc.contains(userId) ? 0 : 1;
          args.add(new Object[]{payload.getId(),userId,payload.getProductId(),statusId,new Date().getTime() / 1000});
        }
        mainJdbc.batchUpdate(sql0,args);
        MetricBuilder.jdbcUpdateMeter.mark(1);
      }
      updatePendingCount(false);
    }
  }
);
  updatePendingCount(true);
}","@Override @TxMain public void saveAfterSent(final Payload payload) throws Exception {
  if (payload == null) {
    return;
  }
  if (payload.getId() == null || payload.getId().intValue() == 0) {
    throw new Exception(""String_Node_Str"");
  }
  jdbcExecutor.submit(new Runnable(){
    @Override public void run(){
      final String sql=""String_Node_Str"";
      mainJdbc.update(new PreparedStatementCreator(){
        @Override public PreparedStatement createPreparedStatement(        Connection connection) throws SQLException {
          PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
          ps.setObject(1,payload.getId());
          ps.setObject(2,payload.getTitle());
          ps.setObject(3,payload.getBadge());
          ps.setObject(4,payload.getExtras());
          ps.setObject(5,payload.getSound());
          ps.setObject(6,payload.getProductId());
          ps.setObject(7,payload.getTotalUsers());
          ps.setObject(8,payload.getCreateAt());
          ps.setObject(9,payload.getStatusId());
          ps.setObject(10,payload.getBroadcast());
          ps.setObject(11,payload.getSentDate());
          return ps;
        }
      }
);
      MetricBuilder.jdbcUpdateMeter.mark(1);
      if (payload.getClients() != null) {
        List<Object[]> args=Lists.newArrayList();
        final String sql0=""String_Node_Str"";
        for (        String userId : payload.getClients()) {
          PushError error=payload.getFailedClients().get(userId);
          int statusId=error != null ? 0 : 1;
          args.add(new Object[]{payload.getId(),userId,payload.getProductId(),statusId,new Date().getTime() / 1000,error != null ? error.getCode() : null,error != null ? error.getMsg() : null});
        }
        mainJdbc.batchUpdate(sql0,args);
        MetricBuilder.jdbcUpdateMeter.mark(1);
      }
      updatePendingCount(false);
    }
  }
);
  updatePendingCount(true);
}"
12456,"@Override @TxMain public void updateSendStatus(final Payload message,final int counting){
  jdbcExecutor.submit(new Runnable(){
    @Override public void run(){
      String sql=""String_Node_Str"";
      mainJdbc.update(sql,counting > 0 ? PayloadStatus.Sent : PayloadStatus.Pending,counting,new Date().getTime() / 1000,message.getId());
      sql=""String_Node_Str"";
      List<Object[]> args=Lists.newArrayList();
      Set<String> cc=message.getFailedClients();
      for (      String userId : message.getClients()) {
        int statusId=cc.contains(userId) ? 0 : 1;
        args.add(new Object[]{statusId,new Date().getTime() / 1000,message.getId(),userId});
      }
      mainJdbc.batchUpdate(sql,args);
      MetricBuilder.jdbcUpdateMeter.mark(2);
      updatePendingCount(false);
    }
  }
);
  updatePendingCount(true);
}","@Override @TxMain public void updateSendStatus(final Payload message,final int counting){
  jdbcExecutor.submit(new Runnable(){
    @Override public void run(){
      String sql=""String_Node_Str"";
      mainJdbc.update(sql,counting > 0 ? PayloadStatus.Sent : PayloadStatus.Pending,counting,new Date().getTime() / 1000,message.getId());
      sql=""String_Node_Str"";
      List<Object[]> args=Lists.newArrayList();
      for (      String userId : message.getClients()) {
        PushError error=message.getFailedClients().get(userId);
        int statusId=error != null ? 0 : 1;
        args.add(new Object[]{statusId,new Date().getTime() / 1000,error != null ? error.getCode() : null,error != null ? error.getMsg() : null,message.getId(),userId});
      }
      mainJdbc.batchUpdate(sql,args);
      MetricBuilder.jdbcUpdateMeter.mark(2);
      updatePendingCount(false);
    }
  }
);
  updatePendingCount(true);
}"
12457,"public void send(final SentProgress progress,final Payload message,final byte[] msg){
  try {
    final ByteBuf data=channel.config().getAllocator().buffer(msg.length);
    data.writeBytes(msg);
    final ChannelFuture cf=channel.writeAndFlush(data);
    cf.addListener(new GenericFutureListener<Future<? super Void>>(){
      @Override public void operationComplete(      Future<? super Void> future) throws Exception {
        if (cf.cause() != null) {
          logger.error(""String_Node_Str"",channel,cf.cause());
          progress.incrFailed();
          message.addFailedClient(userId);
        }
 else {
          progress.incrSuccess();
          if (logger.isDebugEnabled()) {
            logger.debug(""String_Node_Str"",channel,channel.hashCode());
          }
        }
      }
    }
);
  }
 catch (  Exception e) {
    progress.incrFailed();
    message.addFailedClient(userId);
    logger.error(e.getMessage(),e);
  }
}","public void send(final SentProgress progress,final Payload message,final byte[] msg){
  try {
    final ByteBuf data=channel.config().getAllocator().buffer(msg.length);
    data.writeBytes(msg);
    final ChannelFuture cf=channel.writeAndFlush(data);
    cf.addListener(new GenericFutureListener<Future<? super Void>>(){
      @Override public void operationComplete(      Future<? super Void> future) throws Exception {
        if (cf.cause() != null) {
          logger.error(""String_Node_Str"",channel,cf.cause());
          progress.incrFailed();
          message.addFailedClient(userId,new PushError(PushError.UnKnown,cf.cause().getMessage()));
        }
 else {
          progress.incrSuccess();
          if (logger.isDebugEnabled()) {
            logger.debug(""String_Node_Str"",channel,channel.hashCode());
          }
        }
      }
    }
);
  }
 catch (  Exception e) {
    progress.incrFailed();
    message.addFailedClient(userId,new PushError(PushError.UnKnown,e.getMessage()));
    logger.error(e.getMessage(),e);
  }
}"
12458,"@Override public void operationComplete(Future<? super Void> future) throws Exception {
  if (cf.cause() != null) {
    logger.error(""String_Node_Str"",channel,cf.cause());
    progress.incrFailed();
    message.addFailedClient(userId);
  }
 else {
    progress.incrSuccess();
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",channel,channel.hashCode());
    }
  }
}","@Override public void operationComplete(Future<? super Void> future) throws Exception {
  if (cf.cause() != null) {
    logger.error(""String_Node_Str"",channel,cf.cause());
    progress.incrFailed();
    message.addFailedClient(userId,new PushError(PushError.UnKnown,cf.cause().getMessage()));
  }
 else {
    progress.incrSuccess();
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",channel,channel.hashCode());
    }
  }
}"
12459,"private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",client,message);
      }
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        Client cc=ClientServiceImpl.instance.findByUserId(client);
        if (cc == null) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId());
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId());
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadServiceImpl.instance.saveAfterSent(message);
      }
 else {
        PayloadServiceImpl.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
 else {
    logger.error(""String_Node_Str"",message);
  }
  return 0;
}","private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",client,message);
      }
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        Client cc=ClientServiceImpl.instance.findByUserId(client);
        if (cc == null) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoConnections,null));
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoDevivceToken,null));
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadServiceImpl.instance.saveAfterSent(message);
      }
 else {
        PayloadServiceImpl.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
 else {
    logger.error(""String_Node_Str"",message);
  }
  return 0;
}"
12460,"public static void push(SentProgress progress,Product product,Client cc,Payload message){
  String json=message.asJson();
  ApnsService service=get(product);
  if (service != null) {
    try {
      service.push(cc.getDeviceToken(),json);
      progress.incrSuccess();
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      progress.incrFailed();
      message.addFailedClient(cc.getUserId());
    }
  }
}","public static void push(SentProgress progress,Product product,Client cc,Payload message){
  String json=message.asJson();
  ApnsService service=get(product);
  if (service != null) {
    try {
      service.push(cc.getDeviceToken(),json);
      progress.incrSuccess();
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      progress.incrFailed();
      message.addFailedClient(cc.getUserId(),new PushError(PushError.iOSPushError,e.getMessage()));
    }
  }
}"
12461,"private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",client,message);
      }
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        Client cc=ClientServiceImpl.instance.findByUserId(client);
        if (cc == null) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          message.addFailedClient(client,new PushError(PushError.NoClient,null));
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoConnections,null));
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoDevivceToken,null));
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadServiceImpl.instance.saveAfterSent(message);
      }
 else {
        PayloadServiceImpl.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
 else {
    this.progress.incrFailed();
    logger.error(""String_Node_Str"",message);
  }
  return 0;
}","private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",client,message);
      }
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        Client cc=ClientServiceImpl.instance.findByUserId(client);
        if (cc == null) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          message.addFailedClient(client,new PushError(PushError.NoClient,null));
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoConnections,null));
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoDevivceToken,null));
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadServiceImpl.instance.saveAfterSent(message);
      }
 else {
        PayloadServiceImpl.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
 else {
    this.progress.incrFailed();
    logger.error(""String_Node_Str"",message);
  }
  return 0;
}"
12462,"public static ApnsService get(Product product){
  if (product.getClientTypeid().intValue() != ClientType.iOS) {
    return null;
  }
  ApnsService service=mapping.get(product.getId());
  if (service == null) {
    boolean sandbox=(Boolean)ServerConfig.getConf().get(""String_Node_Str"");
    ApnsServiceBuilder builder=APNS.newService();
    if (sandbox) {
      builder.withCert(product.getDevCertPath(),product.getDevCertPass());
      builder.withSandboxDestination();
    }
 else {
      builder.withCert(product.getCertPath(),product.getCertPass());
    }
    service=builder.asPool(10).withDelegate(delegateAdapter).build();
    mapping.put(product.getId(),service);
  }
  return service;
}","public static ApnsService get(Product product){
  if (product.getClientTypeid().intValue() != ClientType.iOS) {
    return null;
  }
  if (StringUtils.isBlank(product.getDevCertPath()) || StringUtils.isBlank(product.getDevCertPass()) || StringUtils.isBlank(product.getCertPath())|| StringUtils.isBlank(product.getCertPass())) {
    logger.error(""String_Node_Str"",product);
    return null;
  }
  ApnsService service=mapping.get(product.getId());
  if (service == null) {
    boolean sandbox=(Boolean)ServerConfig.getConf().get(""String_Node_Str"");
    ApnsServiceBuilder builder=APNS.newService();
    if (sandbox) {
      builder.withCert(product.getDevCertPath(),product.getDevCertPass());
      builder.withSandboxDestination();
    }
 else {
      builder.withCert(product.getCertPath(),product.getCertPass());
    }
    service=builder.asPool(10).withDelegate(delegateAdapter).build();
    mapping.put(product.getId(),service);
  }
  return service;
}"
12463,"public static void push(SentProgress progress,Product product,Client cc,Payload message){
  String json=message.asJson();
  ApnsService service=get(product);
  if (service != null) {
    try {
      service.push(cc.getDeviceToken(),json);
      progress.incrSuccess();
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      progress.incrFailed();
      message.addFailedClient(cc.getUserId(),new PushError(PushError.iOSPushError,e.getMessage()));
    }
  }
}","public static void push(SentProgress progress,Product product,Client cc,Payload message){
  String json=message.asJson();
  ApnsService service=get(product);
  if (service != null) {
    try {
      service.push(cc.getDeviceToken(),json);
      progress.incrSuccess();
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      progress.incrFailed();
      message.addFailedClient(cc.getUserId(),new PushError(PushError.iOSPushError,e.getMessage()));
    }
  }
 else {
    logger.error(""String_Node_Str"");
    progress.incrFailed();
    message.addFailedClient(cc.getUserId(),new PushError(PushError.iOSPushConfigError,null));
  }
}"
12464,"@Override public void afterPropertiesSet() throws Exception {
  instance=this;
  int limit=Integer.parseInt(appConfigs.getProperty(""String_Node_Str"",""String_Node_Str""));
  jdbcExecutor=new ThreadPoolTaskExecutor();
  jdbcExecutor.setCorePoolSize(limit / 5);
  jdbcExecutor.setMaxPoolSize(limit);
  jdbcExecutor.setWaitForTasksToCompleteOnShutdown(true);
  jdbcExecutor.afterPropertiesSet();
  Thread thread=new Thread(new Runnable(){
    @Override public void run(){
      long total=jdbcPending.get();
      logger.info(""String_Node_Str"" + total);
      try {
        Thread.sleep(10 * 1000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
);
  thread.start();
}","@Override public void afterPropertiesSet() throws Exception {
  instance=this;
  int limit=Integer.parseInt(appConfigs.getProperty(""String_Node_Str"",""String_Node_Str""));
  jdbcExecutor=new ThreadPoolTaskExecutor();
  jdbcExecutor.setCorePoolSize(limit / 5);
  jdbcExecutor.setMaxPoolSize(limit);
  jdbcExecutor.setWaitForTasksToCompleteOnShutdown(true);
  jdbcExecutor.afterPropertiesSet();
  Thread thread=new Thread(new Runnable(){
    @Override public void run(){
      while (!stopping) {
        long total=jdbcPending.get();
        logger.info(""String_Node_Str"" + total);
        try {
          Thread.sleep(10 * 1000);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
);
  thread.start();
}"
12465,"@Override public void run(){
  long total=jdbcPending.get();
  logger.info(""String_Node_Str"" + total);
  try {
    Thread.sleep(10 * 1000);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","@Override public void run(){
  while (!stopping) {
    long total=jdbcPending.get();
    logger.info(""String_Node_Str"" + total);
    try {
      Thread.sleep(10 * 1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}"
12466,"@Override @TxMain public void updateSendStatus(final Payload message,final int counting){
  jdbcExecutor.submit(new Runnable(){
    @Override public void run(){
      String sql=""String_Node_Str"";
      mainJdbc.update(sql,counting > 0 ? PayloadStatus.Sent : PayloadStatus.Pending,counting,new Date().getTime() / 1000,message.getId());
      sql=""String_Node_Str"";
      List<Object[]> args=Lists.newArrayList();
      for (      String userId : message.getClients()) {
        PushError error=message.getFailedClients().get(userId);
        int statusId=error != null ? 0 : 1;
        args.add(new Object[]{statusId,new Date().getTime() / 1000,error != null ? error.getCode() : null,error != null ? error.getMsg() : null,message.getId(),userId});
      }
      mainJdbc.batchUpdate(sql,args);
      MetricBuilder.jdbcUpdateMeter.mark(2);
      updatePendingCount(false);
    }
  }
);
  updatePendingCount(true);
}","@Override @TxMain public void updateSendStatus(final Payload message,final int counting){
  jdbcExecutor.submit(new Runnable(){
    @Override public void run(){
      String sql=""String_Node_Str"";
      mainJdbc.update(sql,counting > 0 ? PayloadStatus.Sent : PayloadStatus.Pending,counting,new Date().getTime() / 1000,message.getId());
      sql=""String_Node_Str"";
      List<Object[]> args=Lists.newArrayList();
      for (      String userId : message.getClients()) {
        PushError error=message.getFailedClients().get(userId);
        int statusId=error != null ? 0 : 1;
        args.add(new Object[]{statusId,new Date().getTime() / 1000,error != null ? error.getCode() : null,error != null ? error.getMsg() : null,message.getId(),userId});
      }
      mainJdbc.batchUpdate(sql,args);
      MetricBuilder.jdbcUpdateMeter.mark(2);
      updatePendingCount(false);
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"");
      }
    }
  }
);
  updatePendingCount(true);
}"
12467,"private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",client,message);
      }
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        Client cc=ClientServiceImpl.instance.findByUserId(client);
        if (cc == null) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          message.addFailedClient(client,new PushError(PushError.NoClient,null));
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoConnections,null));
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoDevivceToken,null));
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadServiceImpl.instance.saveAfterSent(message);
      }
 else {
        PayloadServiceImpl.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
 else {
    logger.error(""String_Node_Str"",message);
  }
  return 0;
}","private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"",client,message);
      }
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        Client cc=ClientServiceImpl.instance.findByUserId(client);
        if (cc == null) {
          logger.error(""String_Node_Str"" + client);
          thisProg.incrFailed();
          message.addFailedClient(client,new PushError(PushError.NoClient,null));
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoConnections,null));
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoDevivceToken,null));
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadServiceImpl.instance.saveAfterSent(message);
      }
 else {
        PayloadServiceImpl.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
 else {
    this.progress.incrFailed();
    logger.error(""String_Node_Str"",message);
  }
  return 0;
}"
12468,"/** 
 * 更新最后发送时间
 */
public void updateOpTime(){
  lastOpTime=(int)(new Date().getTime() - epoch);
}","/** 
 * 更新最后发送时间
 */
public void updateOpTime(){
  lastOpTime=(int)(new Date().getTime() / 1000 - epoch);
}"
12469,"private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() == null || message.getClients().size() == 0) {
    this.progress.incrFailed();
    logger.error(""String_Node_Str"",message);
    return 0;
  }
  SentProgress thisProg=new SentProgress(message.getClients().size());
  for (  String client : message.getClients()) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",client,message);
    }
    Connection c=ConnectionKeeper.get(product.getAppKey(),client);
    if (c != null) {
      c.send(thisProg,message);
    }
 else {
      Client cc=ClientServiceImpl.instance.findByUserId(client);
      if (cc == null) {
        logger.error(""String_Node_Str"" + client);
        thisProg.incrFailed();
        if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoClient));
        }
 else {
          thisProg.incrSuccess();
        }
        continue;
      }
      if (!cc.isDevice(ClientType.iOS)) {
        logger.error(""String_Node_Str"" + client);
        thisProg.incrFailed();
        message.addFailedClient(cc.getUserId(),new PushError(PushError.NoConnections));
        continue;
      }
      if (StringUtils.isBlank(cc.getDeviceToken())) {
        logger.error(""String_Node_Str"" + client);
        if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoDevivceToken));
        }
 else {
          thisProg.incrSuccess();
        }
        continue;
      }
      if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.APNS_VALUE) {
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
 else       if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
        thisProg.incrFailed();
        message.addFailedClient(cc.getUserId(),new PushError(PushError.WaitOnline));
      }
 else {
        thisProg.incrSuccess();
      }
    }
  }
  try {
    thisProg.getCountDownLatch().await(message.getClients().size() * 5,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    logger.error(e.getMessage(),e);
  }
  logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
  int total=thisProg.getSuccess().get();
  if (total > 0) {
    MetricBuilder.pushMeter.mark(total);
    MetricBuilder.pushSingleMeter.mark(total);
  }
  try {
    if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
      message.setTotalUsers(total);
      message.setSentDate(new Date().getTime() / 1000);
      message.setStatusId(PayloadStatus.Sent);
      PayloadServiceImpl.instance.saveAfterSent(message);
    }
 else {
      PayloadServiceImpl.instance.updateSendStatus(message,total);
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
  }
  this.progress.incrSuccess();
  return total;
}","private Integer doSend() throws Exception {
  if (message == null) {
    this.progress.incrFailed();
    return 0;
  }
  if (message.getClients() == null || message.getClients().size() == 0) {
    this.progress.incrFailed();
    logger.error(""String_Node_Str"",message);
    return 0;
  }
  SentProgress thisProg=new SentProgress(message.getClients().size());
  for (  String client : message.getClients()) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",client,message);
    }
    Connection c=ConnectionKeeper.get(product.getAppKey(),client);
    if (c != null) {
      c.send(thisProg,message);
    }
 else {
      Client cc=ClientServiceImpl.instance.findByUserId(client);
      if (cc == null) {
        logger.error(""String_Node_Str"" + client);
        thisProg.incrFailed();
        if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
          thisProg.incrFailed();
          message.addFailedClient(client,new PushError(PushError.NoClient));
        }
 else {
          thisProg.incrSuccess();
        }
        continue;
      }
      if (!cc.isDevice(ClientType.iOS)) {
        logger.error(""String_Node_Str"" + client);
        thisProg.incrFailed();
        message.addFailedClient(cc.getUserId(),new PushError(PushError.NoConnections));
        continue;
      }
      if (StringUtils.isBlank(cc.getDeviceToken())) {
        logger.error(""String_Node_Str"" + client);
        if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
          thisProg.incrFailed();
          message.addFailedClient(cc.getUserId(),new PushError(PushError.NoDevivceToken));
        }
 else {
          thisProg.incrSuccess();
        }
        continue;
      }
      if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.APNS_VALUE) {
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
 else       if (message.getOfflineMode().intValue() == PBAPNSMessage.OfflineModes.SendAfterOnline_VALUE) {
        thisProg.incrFailed();
        message.addFailedClient(cc.getUserId(),new PushError(PushError.WaitOnline));
      }
 else {
        thisProg.incrSuccess();
      }
    }
  }
  try {
    thisProg.getCountDownLatch().await(message.getClients().size() * 5,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    logger.error(e.getMessage(),e);
  }
  logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
  int total=thisProg.getSuccess().get();
  if (total > 0) {
    MetricBuilder.pushMeter.mark(total);
    MetricBuilder.pushSingleMeter.mark(total);
  }
  try {
    if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
      message.setTotalUsers(total);
      message.setSentDate(new Date().getTime() / 1000);
      message.setStatusId(PayloadStatus.Sent);
      PayloadServiceImpl.instance.saveAfterSent(message);
    }
 else {
      PayloadServiceImpl.instance.updateSendStatus(message,total);
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
  }
  this.progress.incrSuccess();
  return total;
}"
12470,"public void send(final SentProgress progress,final byte[] msg){
  final ByteBuf data=channel.config().getAllocator().buffer(msg.length);
  data.writeBytes(msg);
  final ChannelFuture cf=channel.writeAndFlush(data);
  cf.addListener(new GenericFutureListener<Future<? super java.lang.Void>>(){
    @Override public void operationComplete(    Future<? super Void> future) throws Exception {
      if (cf.cause() != null) {
        logger.error(""String_Node_Str"",channel,cf.cause());
        progress.incrFailed();
      }
 else {
        progress.incrSuccess();
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"",channel,channel.hashCode());
        }
      }
    }
  }
);
}","public void send(final SentProgress progress,final byte[] msg){
  try {
    final ByteBuf data=channel.config().getAllocator().buffer(msg.length);
    data.writeBytes(msg);
    final ChannelFuture cf=channel.writeAndFlush(data);
    cf.addListener(new GenericFutureListener<Future<? super Void>>(){
      @Override public void operationComplete(      Future<? super Void> future) throws Exception {
        if (cf.cause() != null) {
          logger.error(""String_Node_Str"",channel,cf.cause());
          progress.incrFailed();
        }
 else {
          progress.incrSuccess();
          if (logger.isDebugEnabled()) {
            logger.debug(""String_Node_Str"",channel,channel.hashCode());
          }
        }
      }
    }
);
  }
 catch (  Exception e) {
    progress.incrFailed();
    logger.error(e.getMessage(),e);
  }
}"
12471,"public Payload(PayloadMessage message){
  this.title=message.title;
  this.badge=message.badge;
  this.sound=message.sound;
  this.clients=message.clients;
  this.extras=MessageUtils.toJson(message.ext);
  this.broadcast=message.broadcast ? 1 : 0;
}","public Payload(PayloadMessage message){
  this.title=message.title;
  this.badge=message.badge;
  this.sound=message.sound;
  this.clients=message.clients;
  this.extras=MessageUtils.toJson(message.ext);
  this.broadcast=message.broadcast == null || !message.broadcast ? 0 : 1;
}"
12472,"private void ack(final ChannelHandlerContext ctx,PBAPNSEvent cc){
  PBAPNSMessage.Builder builder=PBAPNSMessage.newBuilder();
  builder.setAps(PBAPNSBody.newBuilder().setAlert(""String_Node_Str"").setBadge(0));
  if (cc != null) {
    builder.addUserInfo(PBAPNSUserInfo.newBuilder().setKey(""String_Node_Str"").setValue(cc.getOp() + ""String_Node_Str""));
  }
 else {
    builder.addUserInfo(PBAPNSUserInfo.newBuilder().setKey(""String_Node_Str"").setValue(""String_Node_Str""));
  }
  byte[] bytes=builder.build().toByteArray();
  final ByteBuf data=ctx.alloc().buffer(bytes.length);
  data.writeBytes(bytes);
  final ChannelFuture cf=ctx.channel().writeAndFlush(data);
  cf.addListener(new GenericFutureListener<Future<? super Void>>(){
    @Override public void operationComplete(    Future<? super Void> future) throws Exception {
      if (cf.cause() != null) {
        logger.error(""String_Node_Str"",cf.cause());
        ctx.close();
      }
    }
  }
);
}","private void ack(final ChannelHandlerContext ctx,PBAPNSEvent cc){
  PBAPNSMessage.Builder builder=PBAPNSMessage.newBuilder();
  builder.setAps(PBAPNSBody.newBuilder().setAlert(""String_Node_Str"").setBadge(0));
  if (cc != null) {
    builder.addUserInfo(PBAPNSUserInfo.newBuilder().setKey(""String_Node_Str"").setValue(cc.getOp() + ""String_Node_Str"").setKey(""String_Node_Str"").setValue(""String_Node_Str""));
  }
 else {
    builder.addUserInfo(PBAPNSUserInfo.newBuilder().setKey(""String_Node_Str"").setValue(""String_Node_Str"").setKey(""String_Node_Str"").setValue(""String_Node_Str""));
  }
  byte[] bytes=builder.build().toByteArray();
  final ByteBuf data=ctx.alloc().buffer(bytes.length);
  data.writeBytes(bytes);
  final ChannelFuture cf=ctx.channel().writeAndFlush(data);
  cf.addListener(new GenericFutureListener<Future<? super Void>>(){
    @Override public void operationComplete(    Future<? super Void> future) throws Exception {
      if (cf.cause() != null) {
        logger.error(""String_Node_Str"",cf.cause());
        ctx.close();
      }
    }
  }
);
}"
12473,"/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent cc;
  try {
    byte[] bytes=(byte[])msg;
    logger.info(""String_Node_Str"",bytes.length);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",bytes);
    }
    cc=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ack(ctx,null);
    return;
  }
  ReferenceCountUtil.release(msg);
  if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),new Connection(ctx.channel()));
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(cc));
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientService.instance.findByUserId(cc.getUserId());
        if (c0 != null) {
          ClientService.instance.updateOnlineTs(c0.getId());
        }
      }
    }
);
    ctx.close();
  }
}","/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (logger.isDebugEnabled()) {
    logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  }
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent cc;
  try {
    byte[] bytes=(byte[])msg;
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",bytes.length);
      logger.debug(""String_Node_Str"",bytes);
    }
    cc=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ack(ctx,null);
    return;
  }
  ReferenceCountUtil.release(msg);
  if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",cc);
    }
    ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),new Connection(ctx.channel()));
    MessageHandlerPoolTasks.instance.getExecutor().submit(new OnNewlyAddThread(cc));
    ack(ctx,cc);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",cc);
    }
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    MessageHandlerPoolTasks.instance.getExecutor().submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientService.instance.findByUserId(cc.getUserId());
        if (c0 != null) {
          ClientService.instance.updateOnlineTs(c0.getId());
        }
      }
    }
);
    ctx.close();
  }
}"
12474,"public void start(){
  Thread thread=new Thread(new Runnable(){
    @Override public void run(){
      connect();
    }
  }
);
  thread.start();
  try {
    countDownLatch.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  logger.info(""String_Node_Str"");
}","public void start(){
  connect();
}"
12475,"private void connect(){
  port=Integer.parseInt(props.getProperty(""String_Node_Str"",""String_Node_Str""));
  host=props.getProperty(""String_Node_Str"",""String_Node_Str"");
  logger.info(""String_Node_Str"" + host + ""String_Node_Str""+ port);
  workerGroup=new NioEventLoopGroup();
  try {
    b.group(workerGroup);
    b.channel(NioSocketChannel.class);
    b.option(ChannelOption.SO_KEEPALIVE,true);
    b.option(ChannelOption.TCP_NODELAY,true);
    b.handler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ChannelPipeline pipeline=ch.pipeline();
        pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
        pipeline.addLast(""String_Node_Str"",new ByteArrayDecoder());
        pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4,false));
        pipeline.addLast(""String_Node_Str"",new ByteArrayEncoder());
        pipeline.addLast(""String_Node_Str"",new ClientConnectHandler());
      }
    }
);
    for (int i=0; i < workerGroup.executorCount(); i++) {
      ChannelFuture f=newChannel();
      if (f != null) {
        try {
          f.get();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
catch (        ExecutionException e) {
          e.printStackTrace();
        }
      }
    }
    countDownLatch.countDown();
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    workerGroup.shutdownGracefully();
  }
}","private void connect(){
  port=Integer.parseInt(props.getProperty(""String_Node_Str"",""String_Node_Str""));
  host=props.getProperty(""String_Node_Str"",""String_Node_Str"");
  logger.info(""String_Node_Str"" + host + ""String_Node_Str""+ port);
  workerGroup=new NioEventLoopGroup();
  try {
    b.group(workerGroup);
    b.channel(NioSocketChannel.class);
    b.option(ChannelOption.SO_KEEPALIVE,true);
    b.option(ChannelOption.TCP_NODELAY,true);
    b.handler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ChannelPipeline pipeline=ch.pipeline();
        pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
        pipeline.addLast(""String_Node_Str"",new ByteArrayDecoder());
        pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4,false));
        pipeline.addLast(""String_Node_Str"",new ByteArrayEncoder());
        pipeline.addLast(""String_Node_Str"",new ClientConnectHandler());
      }
    }
);
    for (int i=0; i < workerGroup.executorCount(); i++) {
      ChannelFuture f=newChannel();
      if (f != null) {
        try {
          f.get();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
catch (        ExecutionException e) {
          e.printStackTrace();
        }
      }
    }
    countDownLatch.countDown();
    logger.info(""String_Node_Str"",host,port);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    workerGroup.shutdownGracefully();
  }
}"
12476,"@Override public Integer call() throws Exception {
  Payload message=PayloadService.instance.findLatest(product.getId(),userId);
  if (message == null) {
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress progress=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(progress,message);
      }
 else {
        progress.incrFailed();
      }
    }
    try {
      progress.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    int total=progress.getSuccess().get();
    try {
      PayloadService.instance.updateSendStatus(message,total);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    return total;
  }
  return 0;
}","@Override public Integer call() throws Exception {
  Payload message=PayloadService.instance.findLatest(product.getId(),userId);
  if (message == null) {
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress progress=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(progress,message);
      }
 else {
        progress.incrFailed();
      }
    }
    try {
      progress.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    int total=progress.getSuccess().get();
    try {
      PayloadService.instance.updateSendStatus(message,total);
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    return total;
  }
  return 0;
}"
12477,"@Override public Integer call() throws Exception {
  if (message == null) {
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        if (product.getClientTypeid().intValue() != ClientType.iOS) {
          continue;
        }
        Client cc=ClientService.instance.findByUserId(client);
        if (cc == null) {
          logger.warn(""String_Node_Str"" + client);
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadService.instance.saveWithId(message);
      }
 else {
        PayloadService.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    this.progress.incrSuccess();
    return total;
  }
  return 0;
}","@Override public Integer call() throws Exception {
  if (message == null) {
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress thisProg=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(thisProg,message);
      }
 else {
        if (product.getClientTypeid().intValue() != ClientType.iOS) {
          continue;
        }
        Client cc=ClientService.instance.findByUserId(client);
        if (cc == null) {
          logger.warn(""String_Node_Str"" + client);
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(thisProg,this.product,cc,message);
      }
    }
    try {
      thisProg.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage(),e);
    }
    logger.info(""String_Node_Str"" + message.getId() + ""String_Node_Str""+ thisProg);
    int total=thisProg.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      if (message.getStatusId().intValue() == PayloadStatus.Pending0) {
        message.setTotalUsers(total);
        message.setSentDate(new Date().getTime() / 1000);
        message.setStatusId(PayloadStatus.Sent);
        PayloadService.instance.saveWithId(message);
      }
 else {
        PayloadService.instance.updateSendStatus(message,total);
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    this.progress.incrSuccess();
    return total;
  }
  return 0;
}"
12478,"@Override public Boolean call() throws Exception {
  Client client=ClientService.instance.findByUserId(cc.getUserId());
  boolean isnew=false;
  if (client == null) {
    client=new Client();
    Product product=ProductService.instance.findByKey(cc.getAppKey());
    client.setProductId(product.getId());
    client.setUserId(cc.getUserId());
    client.setTypeId(cc.getTypeId());
    client.setDeviceToken(cc.getToken());
    try {
      ClientService.instance.add(client);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    isnew=true;
  }
  if (!isnew) {
    Dispatcher dispatcher=DispatcherRunner.instance.get(cc.getAppKey());
    if (dispatcher != null) {
      dispatcher.pushOfflinePayload(cc.getUserId());
    }
    try {
      ClientService.instance.updateOnlineTs(client.getId());
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return true;
}","@Override public Boolean call() throws Exception {
  Client client=ClientService.instance.findByUserId(cc.getUserId());
  boolean isnew=false;
  if (client == null) {
    client=new Client();
    Product product=ProductService.instance.findByKey(cc.getAppKey());
    client.setProductId(product.getId());
    client.setUserId(cc.getUserId());
    client.setTypeId(cc.getTypeId());
    client.setDeviceToken(cc.getToken());
    try {
      ClientService.instance.add(client);
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
    isnew=true;
  }
  if (!isnew) {
    Dispatcher dispatcher=DispatcherRunner.instance.get(cc.getAppKey());
    if (dispatcher != null) {
      dispatcher.pushOfflinePayload(cc.getUserId());
    }
    try {
      ClientService.instance.updateOnlineTs(client.getId());
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
  }
  return true;
}"
12479,"/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent cc;
  try {
    byte[] bytes=(byte[])msg;
    logger.info(""String_Node_Str"",bytes.length);
    cc=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ack(ctx,null);
    return;
  }
  ReferenceCountUtil.release(msg);
  if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),new Connection(ctx.channel()));
    poolTaskExecutor.submit(new OnNewlyAddThread(cc));
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    poolTaskExecutor.submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientService.instance.findByUserId(cc.getUserId());
        if (c0 != null) {
          ClientService.instance.updateOnlineTs(c0.getId());
        }
      }
    }
);
    ctx.close();
  }
}","/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent cc;
  try {
    byte[] bytes=(byte[])msg;
    logger.info(""String_Node_Str"",bytes.length);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",bytes);
    }
    cc=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ack(ctx,null);
    return;
  }
  ReferenceCountUtil.release(msg);
  if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),new Connection(ctx.channel()));
    poolTaskExecutor.submit(new OnNewlyAddThread(cc));
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    poolTaskExecutor.submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientService.instance.findByUserId(cc.getUserId());
        if (c0 != null) {
          ClientService.instance.updateOnlineTs(c0.getId());
        }
      }
    }
);
    ctx.close();
  }
}"
12480,"private void ack(final ChannelHandlerContext ctx,PBAPNSEvent cc){
  PBAPNSMessage.Builder builder=PBAPNSMessage.newBuilder();
  builder.setAps(PBAPNSBody.newBuilder().setAlert(""String_Node_Str"").setBadge(0));
  builder.addUserInfo(PBAPNSUserInfo.newBuilder().setKey(""String_Node_Str"").setValue(cc.getOp() + ""String_Node_Str""));
  byte[] bytes=builder.build().toByteArray();
  final ByteBuf data=ctx.alloc().buffer(bytes.length);
  data.writeBytes(bytes);
  final ChannelFuture cf=ctx.channel().writeAndFlush(data);
  cf.addListener(new GenericFutureListener<Future<? super Void>>(){
    @Override public void operationComplete(    Future<? super Void> future) throws Exception {
      if (cf.cause() != null) {
        logger.error(""String_Node_Str"",cf.cause());
        ctx.close();
      }
    }
  }
);
}","private void ack(final ChannelHandlerContext ctx,PBAPNSEvent cc){
  PBAPNSMessage.Builder builder=PBAPNSMessage.newBuilder();
  builder.setAps(PBAPNSBody.newBuilder().setAlert(""String_Node_Str"").setBadge(0));
  if (cc != null) {
    builder.addUserInfo(PBAPNSUserInfo.newBuilder().setKey(""String_Node_Str"").setValue(cc.getOp() + ""String_Node_Str""));
  }
 else {
    builder.addUserInfo(PBAPNSUserInfo.newBuilder().setKey(""String_Node_Str"").setValue(""String_Node_Str""));
  }
  byte[] bytes=builder.build().toByteArray();
  final ByteBuf data=ctx.alloc().buffer(bytes.length);
  data.writeBytes(bytes);
  final ChannelFuture cf=ctx.channel().writeAndFlush(data);
  cf.addListener(new GenericFutureListener<Future<? super Void>>(){
    @Override public void operationComplete(    Future<? super Void> future) throws Exception {
      if (cf.cause() != null) {
        logger.error(""String_Node_Str"",cf.cause());
        ctx.close();
      }
    }
  }
);
}"
12481,"/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent cc;
  try {
    cc=PBAPNSEvent.newBuilder().mergeFrom((byte[])msg).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ack(ctx,null);
    return;
  }
  ReferenceCountUtil.release(msg);
  if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),new Connection(ctx.channel()));
    poolTaskExecutor.submit(new OnNewlyAddThread(cc));
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    poolTaskExecutor.submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientService.instance.findByUserId(cc.getUserId());
        if (c0 != null) {
          ClientService.instance.updateOnlineTs(c0.getId());
        }
      }
    }
);
    ctx.close();
  }
}","/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  MetricBuilder.requestMeter.mark();
  final PBAPNSEvent cc;
  try {
    byte[] bytes=(byte[])msg;
    logger.info(""String_Node_Str"",bytes.length);
    cc=PBAPNSEvent.newBuilder().mergeFrom(bytes).build();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ack(ctx,null);
    return;
  }
  ReferenceCountUtil.release(msg);
  if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.Android_VALUE) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.getTypeId() == PBAPNSEvent.DeviceTypes.iOS_VALUE) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.getOp() == PBAPNSEvent.Ops.Online_VALUE) {
    ConnectionKeeper.add(cc.getAppKey(),cc.getUserId(),new Connection(ctx.channel()));
    poolTaskExecutor.submit(new OnNewlyAddThread(cc));
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.KeepAlive_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.PushAck_VALUE) {
    ack(ctx,cc);
  }
 else   if (cc.getOp() == PBAPNSEvent.Ops.Offline_VALUE) {
    poolTaskExecutor.submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientService.instance.findByUserId(cc.getUserId());
        if (c0 != null) {
          ClientService.instance.updateOnlineTs(c0.getId());
        }
      }
    }
);
    ctx.close();
  }
}"
12482,"@Override public void add(Payload payload){
  BinaryShardedJedis jedis=redisBucket.getResource();
  try {
    long id=jedis.incr(QPUSH_PK);
    payload.setId(id);
    payload.setStatusId(PayloadStatus.Pending0);
    payload.setCreateAt(new Date().getTime() / 1000);
    String key=String.format(""String_Node_Str"",payload.getProductId(),payload.getBroadcast());
    jedis.rpush(key.getBytes(),MessageUtils.asBytes(payload));
    long total=jedis.incr(QPUSH_PENDING);
    redisBucket.returnResource(jedis);
    logger.info(""String_Node_Str"" + total);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    redisBucket.returnBrokenResource(jedis);
  }
}","@Override public void add(Payload payload){
  BinaryShardedJedis jedis=redisBucket.getResource();
  try {
    long id=jedis.incr(QPUSH_PK);
    payload.setId(id);
    payload.setStatusId(PayloadStatus.Pending0);
    payload.setCreateAt(new Date().getTime() / 1000);
    String key=String.format(""String_Node_Str"",payload.getProductId(),payload.getBroadcast());
    long ret=jedis.rpush(key.getBytes(),MessageUtils.asBytes(payload));
    long total=jedis.incr(QPUSH_PENDING);
    redisBucket.returnResource(jedis);
    logger.info(""String_Node_Str"",total,ret);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    redisBucket.returnBrokenResource(jedis);
  }
}"
12483,"public void add(final Client client){
  if (client == null) {
    return;
  }
  final String sql=""String_Node_Str"";
  KeyHolder holder=new GeneratedKeyHolder();
  this.mainJdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
      ps.setObject(0,client.getProductId());
      ps.setObject(1,client.getUserId());
      ps.setObject(2,client.getDeviceToken());
      ps.setObject(3,new Date());
      ps.setObject(4,ClientStatus.NewlyAdd);
      ps.setObject(5,client.getTypeId());
      return ps;
    }
  }
,holder);
  client.setId(holder.getKey().longValue());
}","public void add(final Client client){
  if (client == null) {
    return;
  }
  final String sql=""String_Node_Str"";
  KeyHolder holder=new GeneratedKeyHolder();
  this.mainJdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
      ps.setObject(1,client.getProductId());
      ps.setObject(2,client.getUserId());
      ps.setObject(3,client.getDeviceToken());
      ps.setObject(4,new Date());
      ps.setObject(5,ClientStatus.NewlyAdd);
      ps.setObject(6,client.getTypeId());
      return ps;
    }
  }
,holder);
  client.setId(holder.getKey().longValue());
}"
12484,"@Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
  ps.setObject(0,client.getProductId());
  ps.setObject(1,client.getUserId());
  ps.setObject(2,client.getDeviceToken());
  ps.setObject(3,new Date());
  ps.setObject(4,ClientStatus.NewlyAdd);
  ps.setObject(5,client.getTypeId());
  return ps;
}","@Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
  ps.setObject(1,client.getProductId());
  ps.setObject(2,client.getUserId());
  ps.setObject(3,client.getDeviceToken());
  ps.setObject(4,new Date());
  ps.setObject(5,ClientStatus.NewlyAdd);
  ps.setObject(6,client.getTypeId());
  return ps;
}"
12485,"public void add(final Payload payload){
  if (payload == null) {
    return;
  }
  final String sql=""String_Node_Str"";
  if (payload.getClients() != null) {
    payload.setTotalUsers(payload.getClients().size());
  }
 else {
    payload.setTotalUsers(-1);
  }
  KeyHolder holder=new GeneratedKeyHolder();
  this.mainJdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
      ps.setObject(0,payload.getTitle());
      ps.setObject(1,payload.getBadge());
      ps.setObject(2,payload.getExtras());
      ps.setObject(3,payload.getSound());
      ps.setObject(4,payload.getProductId());
      ps.setObject(5,payload.getTotalUsers());
      ps.setObject(6,new Date().getTime() / 1000);
      ps.setObject(7,PayloadStatus.Pending);
      ps.setObject(8,payload.getBroadcast());
      return ps;
    }
  }
,holder);
  payload.setId(holder.getKey().longValue());
  if (payload.getClients() != null) {
    List<Object[]> args=Lists.newArrayList();
    final String sql0=""String_Node_Str"";
    for (    String userId : payload.getClients()) {
      args.add(new Object[]{payload.getId(),userId,payload.getProductId()});
    }
    this.mainJdbc.batchUpdate(sql0,args);
  }
}","public void add(final Payload payload){
  if (payload == null) {
    return;
  }
  final String sql=""String_Node_Str"";
  if (payload.getClients() != null) {
    payload.setTotalUsers(payload.getClients().size());
  }
 else {
    payload.setTotalUsers(-1);
  }
  KeyHolder holder=new GeneratedKeyHolder();
  this.mainJdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
      ps.setObject(1,payload.getTitle());
      ps.setObject(2,payload.getBadge());
      ps.setObject(3,payload.getExtras());
      ps.setObject(4,payload.getSound());
      ps.setObject(5,payload.getProductId());
      ps.setObject(6,payload.getTotalUsers());
      ps.setObject(7,new Date().getTime() / 1000);
      ps.setObject(8,PayloadStatus.Pending);
      ps.setObject(9,payload.getBroadcast());
      return ps;
    }
  }
,holder);
  payload.setId(holder.getKey().longValue());
  if (payload.getClients() != null) {
    List<Object[]> args=Lists.newArrayList();
    final String sql0=""String_Node_Str"";
    for (    String userId : payload.getClients()) {
      args.add(new Object[]{payload.getId(),userId,payload.getProductId()});
    }
    this.mainJdbc.batchUpdate(sql0,args);
  }
}"
12486,"@Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
  ps.setObject(0,payload.getTitle());
  ps.setObject(1,payload.getBadge());
  ps.setObject(2,payload.getExtras());
  ps.setObject(3,payload.getSound());
  ps.setObject(4,payload.getProductId());
  ps.setObject(5,payload.getTotalUsers());
  ps.setObject(6,new Date().getTime() / 1000);
  ps.setObject(7,PayloadStatus.Pending);
  ps.setObject(8,payload.getBroadcast());
  return ps;
}","@Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
  ps.setObject(1,payload.getTitle());
  ps.setObject(2,payload.getBadge());
  ps.setObject(3,payload.getExtras());
  ps.setObject(4,payload.getSound());
  ps.setObject(5,payload.getProductId());
  ps.setObject(6,payload.getTotalUsers());
  ps.setObject(7,new Date().getTime() / 1000);
  ps.setObject(8,PayloadStatus.Pending);
  ps.setObject(9,payload.getBroadcast());
  return ps;
}"
12487,"public void add(final Product product){
  if (product == null) {
    return;
  }
  product.setKey(UUID.randomUUID().toString().replace(""String_Node_Str"",""String_Node_Str""));
  product.setSecret(UUID.randomUUID().toString().replace(""String_Node_Str"",""String_Node_Str""));
  final String sql=""String_Node_Str"";
  KeyHolder holder=new GeneratedKeyHolder();
  this.mainJdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
      ps.setObject(0,product.getTitle());
      ps.setObject(1,product.getKey());
      ps.setObject(2,product.getSecret());
      ps.setObject(3,product.getClientTypeid());
      ps.setObject(4,product.getCertPath());
      ps.setObject(5,product.getDevCertPath());
      return ps;
    }
  }
,holder);
  product.setId(holder.getKey().intValue());
}","public void add(final Product product){
  if (product == null) {
    return;
  }
  product.setKey(UUID.randomUUID().toString().replace(""String_Node_Str"",""String_Node_Str""));
  product.setSecret(UUID.randomUUID().toString().replace(""String_Node_Str"",""String_Node_Str""));
  final String sql=""String_Node_Str"";
  KeyHolder holder=new GeneratedKeyHolder();
  this.mainJdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    Connection connection) throws SQLException {
      PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
      ps.setObject(1,product.getTitle());
      ps.setObject(2,product.getKey());
      ps.setObject(3,product.getSecret());
      ps.setObject(4,product.getClientTypeid());
      ps.setObject(5,product.getCertPath());
      ps.setObject(6,product.getDevCertPath());
      return ps;
    }
  }
,holder);
  product.setId(holder.getKey().intValue());
}"
12488,"@Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
  ps.setObject(0,product.getTitle());
  ps.setObject(1,product.getKey());
  ps.setObject(2,product.getSecret());
  ps.setObject(3,product.getClientTypeid());
  ps.setObject(4,product.getCertPath());
  ps.setObject(5,product.getDevCertPath());
  return ps;
}","@Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
  PreparedStatement ps=connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
  ps.setObject(1,product.getTitle());
  ps.setObject(2,product.getKey());
  ps.setObject(3,product.getSecret());
  ps.setObject(4,product.getClientTypeid());
  ps.setObject(5,product.getCertPath());
  ps.setObject(6,product.getDevCertPath());
  return ps;
}"
12489,"@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  System.out.println(""String_Node_Str"" + ctx.channel());
  printMsg(msg);
  ctx.fireChannelRead(msg);
}","@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  String jsonString=new String((byte[])msg);
  System.out.println(""String_Node_Str"" + ctx.channel() + ""String_Node_Str""+ jsonString);
  ctx.fireChannelRead(msg);
}"
12490,"@Override public void initChannel(SocketChannel ch) throws Exception {
  ch.pipeline().addLast(new ClientConnectHandler());
}","@Override public void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline pipeline=ch.pipeline();
  pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
  pipeline.addLast(""String_Node_Str"",new ByteArrayDecoder());
  pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4,false));
  pipeline.addLast(""String_Node_Str"",new ByteArrayEncoder());
  pipeline.addLast(""String_Node_Str"",new ClientConnectHandler());
}"
12491,"private static void connect(){
  final int port=Integer.parseInt(props.getProperty(""String_Node_Str"",""String_Node_Str""));
  final int pool=Integer.parseInt(props.getProperty(""String_Node_Str"",""String_Node_Str""));
  final String host=props.getProperty(""String_Node_Str"",""String_Node_Str"");
  logger.info(""String_Node_Str"" + host + ""String_Node_Str""+ port);
  workerGroup=new NioEventLoopGroup(pool);
  try {
    b.group(workerGroup);
    b.channel(NioSocketChannel.class);
    b.option(ChannelOption.SO_KEEPALIVE,true);
    b.option(ChannelOption.TCP_NODELAY,true);
    b.handler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ch.pipeline().addLast(new ClientConnectHandler());
      }
    }
);
    final List<ChannelFuture> fs=new ArrayList<ChannelFuture>();
    for (int i=0; i < pool; i++) {
      ChannelFuture f=b.connect(host,port);
      if (f.cause() != null) {
        f.cause().printStackTrace();
        continue;
      }
      fs.add(f);
    }
    for (    ChannelFuture f : fs) {
      if (!f.isDone()) {
        f.get();
      }
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    workerGroup.shutdownGracefully();
  }
}","private static void connect(){
  final int port=Integer.parseInt(props.getProperty(""String_Node_Str"",""String_Node_Str""));
  final int pool=Integer.parseInt(props.getProperty(""String_Node_Str"",""String_Node_Str""));
  final String host=props.getProperty(""String_Node_Str"",""String_Node_Str"");
  logger.info(""String_Node_Str"" + host + ""String_Node_Str""+ port);
  workerGroup=new NioEventLoopGroup(pool);
  try {
    b.group(workerGroup);
    b.channel(NioSocketChannel.class);
    b.option(ChannelOption.SO_KEEPALIVE,true);
    b.option(ChannelOption.TCP_NODELAY,true);
    b.handler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ChannelPipeline pipeline=ch.pipeline();
        pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
        pipeline.addLast(""String_Node_Str"",new ByteArrayDecoder());
        pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4,false));
        pipeline.addLast(""String_Node_Str"",new ByteArrayEncoder());
        pipeline.addLast(""String_Node_Str"",new ClientConnectHandler());
      }
    }
);
    final List<ChannelFuture> fs=new ArrayList<ChannelFuture>();
    for (int i=0; i < pool; i++) {
      ChannelFuture f=b.connect(host,port);
      if (f.cause() != null) {
        f.cause().printStackTrace();
        continue;
      }
      fs.add(f);
    }
    for (    ChannelFuture f : fs) {
      if (!f.isDone()) {
        f.get();
      }
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    workerGroup.shutdownGracefully();
  }
}"
12492,"public void start(){
  Thread thread=new Thread(new Runnable(){
    @Override public void run(){
      connect();
    }
  }
);
  thread.start();
  Thread pingThread=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        try {
          ping();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        try {
          Thread.sleep(10 * 1000);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
);
  pingThread.start();
  try {
    Thread.sleep(10 * 1000);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public void start(){
  Thread thread=new Thread(new Runnable(){
    @Override public void run(){
      connect();
    }
  }
);
  thread.start();
  Thread pingThread=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        try {
          ping();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        try {
          Thread.sleep(10 * 1000);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
);
  pingThread.start();
}"
12493,"@Override public void initChannel(SocketChannel ch) throws Exception {
  ch.pipeline().addLast(new MobileAppClientHandler());
}","@Override public void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline pipeline=ch.pipeline();
  pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
  pipeline.addLast(""String_Node_Str"",new ByteArrayDecoder());
  pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4,false));
  pipeline.addLast(""String_Node_Str"",new ByteArrayEncoder());
  pipeline.addLast(""String_Node_Str"",new MobileAppClientHandler());
}"
12494,"protected void printMsg(ChannelHandlerContext ctx,Object msg){
  ByteBuf b=(ByteBuf)msg;
  byte[] dd=new byte[b.readableBytes()];
  b.readBytes(dd);
  try {
    APNSMessage event=MessageUtils.asT(APNSMessage.class,dd);
    if (event != null && event.aps != null) {
      System.out.println(""String_Node_Str"" + ctx.channel() + ""String_Node_Str""+ event);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","protected void printMsg(ChannelHandlerContext ctx,Object msg){
  byte[] dd=(byte[])msg;
  System.out.println(""String_Node_Str"" + dd.length);
  try {
    APNSMessage event=MessageUtils.asT(APNSMessage.class,dd);
    if (event != null && event.aps != null) {
      System.out.println(""String_Node_Str"" + dd.length + ""String_Node_Str""+ event);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
12495,"@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  System.out.println(""String_Node_Str"" + ctx.channel());
  printMsg(ctx,msg);
  ctx.fireChannelRead(msg);
}","@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  System.out.println(""String_Node_Str"" + ctx.channel());
  printMsg(ctx,msg);
  ReferenceCountUtil.release(msg);
}"
12496,"private void connect(){
  final int port=8080;
  final int pool=2;
  final String host=""String_Node_Str"";
  workerGroup=new NioEventLoopGroup(pool);
  try {
    b.group(workerGroup);
    b.channel(NioSocketChannel.class);
    b.option(ChannelOption.SO_KEEPALIVE,true);
    b.option(ChannelOption.TCP_NODELAY,true);
    b.handler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ch.pipeline().addLast(new MobileAppClientHandler());
      }
    }
);
    final List<ChannelFuture> fs=new ArrayList<ChannelFuture>();
    for (int i=0; i < pool; i++) {
      ChannelFuture f=b.connect(host,port);
      if (f.cause() != null) {
        f.cause().printStackTrace();
        continue;
      }
      fs.add(f);
    }
    for (    ChannelFuture f : fs) {
      if (!f.isDone()) {
        f.get();
      }
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
    workerGroup.shutdownGracefully();
  }
}","private void connect(){
  final int port=8080;
  final int pool=2;
  final String host=""String_Node_Str"";
  workerGroup=new NioEventLoopGroup(pool);
  try {
    b.group(workerGroup);
    b.channel(NioSocketChannel.class);
    b.option(ChannelOption.SO_KEEPALIVE,true);
    b.option(ChannelOption.TCP_NODELAY,true);
    b.handler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ChannelPipeline pipeline=ch.pipeline();
        pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
        pipeline.addLast(""String_Node_Str"",new ByteArrayDecoder());
        pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4,false));
        pipeline.addLast(""String_Node_Str"",new ByteArrayEncoder());
        pipeline.addLast(""String_Node_Str"",new MobileAppClientHandler());
      }
    }
);
    final List<ChannelFuture> fs=new ArrayList<ChannelFuture>();
    for (int i=0; i < pool; i++) {
      ChannelFuture f=b.connect(host,port);
      if (f.cause() != null) {
        f.cause().printStackTrace();
        continue;
      }
      fs.add(f);
    }
    for (    ChannelFuture f : fs) {
      if (!f.isDone()) {
        f.get();
      }
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
    workerGroup.shutdownGracefully();
  }
}"
12497,"/** 
 * 启动推送服务 8080端口
 */
public static void start(Properties prop){
  String actSize=prop.getProperty(""String_Node_Str"",""String_Node_Str"");
  String workerSize=prop.getProperty(""String_Node_Str"",""String_Node_Str"");
  port=Integer.parseInt(prop.getProperty(""String_Node_Str"",""String_Node_Str""));
  EventLoopGroup parentGroup=new NioEventLoopGroup(Integer.parseInt(actSize));
  EventLoopGroup childGroup=new NioEventLoopGroup(Integer.parseInt(workerSize));
  try {
    ServerBootstrap serverBootstrap=new ServerBootstrap();
    serverBootstrap.group(parentGroup,childGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ch.pipeline().addLast(new MobileMessageHandler());
      }
    }
);
    serverBootstrap.option(ChannelOption.SO_KEEPALIVE,true);
    serverBootstrap.option(ChannelOption.TCP_NODELAY,true);
    serverBootstrap.option(ChannelOption.SO_REUSEADDR,true);
    System.out.println(""String_Node_Str"" + port + ""String_Node_Str"");
    ChannelFuture f=serverBootstrap.bind(port).sync();
    f.channel().closeFuture().sync();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    childGroup.shutdownGracefully();
    parentGroup.shutdownGracefully();
  }
}","/** 
 * 启动推送服务 8080端口
 */
public static void start(Properties prop){
  String actSize=prop.getProperty(""String_Node_Str"",""String_Node_Str"");
  String workerSize=prop.getProperty(""String_Node_Str"",""String_Node_Str"");
  port=Integer.parseInt(prop.getProperty(""String_Node_Str"",""String_Node_Str""));
  EventLoopGroup parentGroup=new NioEventLoopGroup(Integer.parseInt(actSize));
  EventLoopGroup childGroup=new NioEventLoopGroup(Integer.parseInt(workerSize));
  try {
    ServerBootstrap serverBootstrap=new ServerBootstrap();
    serverBootstrap.group(parentGroup,childGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ChannelPipeline pipeline=ch.pipeline();
        pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
        pipeline.addLast(""String_Node_Str"",new ByteArrayDecoder());
        pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4,false));
        pipeline.addLast(""String_Node_Str"",new ByteArrayEncoder());
        pipeline.addLast(""String_Node_Str"",new MobileMessageHandler());
      }
    }
);
    serverBootstrap.option(ChannelOption.SO_KEEPALIVE,true);
    serverBootstrap.option(ChannelOption.TCP_NODELAY,true);
    serverBootstrap.option(ChannelOption.SO_REUSEADDR,true);
    System.out.println(""String_Node_Str"" + port + ""String_Node_Str"");
    ChannelFuture f=serverBootstrap.bind(port).sync();
    f.channel().closeFuture().sync();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    childGroup.shutdownGracefully();
    parentGroup.shutdownGracefully();
  }
}"
12498,"@Override public void initChannel(SocketChannel ch) throws Exception {
  ch.pipeline().addLast(new MobileMessageHandler());
}","@Override public void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline pipeline=ch.pipeline();
  pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
  pipeline.addLast(""String_Node_Str"",new ByteArrayDecoder());
  pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4,false));
  pipeline.addLast(""String_Node_Str"",new ByteArrayEncoder());
  pipeline.addLast(""String_Node_Str"",new MobileMessageHandler());
}"
12499,"@Override public Integer call() throws Exception {
  if (message == null) {
    return 0;
  }
  if (message.getClients() == null || message.getClients().size() == 0) {
    List<Client> clients=ClientService.instance.findOfflineByType(this.product.getId(),ClientType.iOS,this.start,this.limit);
    SentProgress progress=new SentProgress(clients.size());
    for (    Client c : clients) {
      APNSKeeper.push(progress,this.product,c,message);
    }
    progress.getCountDownLatch().wait();
    int total=progress.getSuccess().get();
    try {
      PayloadService.instance.updateSendStatus(message,total);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.boradcastMeter.mark(total);
    }
    logger.info(""String_Node_Str"" + total);
    return total;
  }
  return 0;
}","@Override public Integer call() throws Exception {
  if (message == null) {
    return 0;
  }
  if (message.getClients() == null || message.getClients().size() == 0) {
    List<Client> clients=ClientService.instance.findOfflineByType(this.product.getId(),ClientType.iOS,this.start,this.limit);
    SentProgress progress=new SentProgress(clients.size());
    for (    Client c : clients) {
      APNSKeeper.push(progress,this.product,c,message);
    }
    try {
      progress.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    int total=progress.getSuccess().get();
    try {
      PayloadService.instance.updateSendStatus(message,total);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.boradcastMeter.mark(total);
    }
    logger.info(""String_Node_Str"" + total);
    return total;
  }
  return 0;
}"
12500,"@Override public Integer call() throws Exception {
  if (message == null) {
    return 0;
  }
  if (message.getClients() == null || message.getClients().size() == 0) {
    Collection<Integer> cids=ClientKeeper.gets(product.getAppKey());
    int s=start * limit;
    if (cids.size() < limit) {
      limit=cids.size();
    }
    Integer[] temp=cids.toArray(new Integer[0]);
    SentProgress progress=new SentProgress(limit);
    for (int i=0; i < limit; i++) {
      int cid=temp[s + i];
      Connection c=ConnectionKeeper.get(cid);
      if (c != null) {
        c.send(progress,message);
      }
 else {
        progress.incrFailed();
      }
    }
    progress.getCountDownLatch().wait();
    int t0=progress.getSuccess().get();
    try {
      PayloadService.instance.updateSendStatus(message,t0);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    if (t0 > 0) {
      MetricBuilder.pushMeter.mark(t0);
      MetricBuilder.boradcastMeter.mark(t0);
    }
    return t0;
  }
  return 0;
}","@Override public Integer call() throws Exception {
  if (message == null) {
    return 0;
  }
  if (message.getClients() == null || message.getClients().size() == 0) {
    Collection<Integer> cids=ClientKeeper.gets(product.getAppKey());
    int s=start * limit;
    if (cids.size() < limit) {
      limit=cids.size();
    }
    Integer[] temp=cids.toArray(new Integer[0]);
    SentProgress progress=new SentProgress(limit);
    for (int i=0; i < limit; i++) {
      int cid=temp[s + i];
      Connection c=ConnectionKeeper.get(cid);
      if (c != null) {
        c.send(progress,message);
      }
 else {
        progress.incrFailed();
      }
    }
    try {
      progress.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    int t0=progress.getSuccess().get();
    try {
      PayloadService.instance.updateSendStatus(message,t0);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    if (t0 > 0) {
      MetricBuilder.pushMeter.mark(t0);
      MetricBuilder.boradcastMeter.mark(t0);
    }
    return t0;
  }
  return 0;
}"
12501,"@Override public Integer call() throws Exception {
  Payload message=PayloadService.instance.findLatest(product.getId(),userId);
  if (message == null) {
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress progress=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(progress,message);
      }
 else {
        progress.incrFailed();
      }
    }
    try {
      progress.getCountDownLatch().wait();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    int total=progress.getSuccess().get();
    try {
      PayloadService.instance.updateSendStatus(message,total);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    return total;
  }
  return 0;
}","@Override public Integer call() throws Exception {
  Payload message=PayloadService.instance.findLatest(product.getId(),userId);
  if (message == null) {
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress progress=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(progress,message);
      }
 else {
        progress.incrFailed();
      }
    }
    try {
      progress.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    int total=progress.getSuccess().get();
    try {
      PayloadService.instance.updateSendStatus(message,total);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    return total;
  }
  return 0;
}"
12502,"@Override public Integer call() throws Exception {
  if (message == null) {
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress progress=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(progress,message);
      }
 else {
        if (product.getClientTypeid().intValue() != ClientType.iOS) {
          continue;
        }
        Client cc=ClientService.instance.findByUserId(client);
        if (cc == null) {
          logger.warn(""String_Node_Str"" + client);
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(progress,this.product,cc,message);
      }
    }
    try {
      progress.getCountDownLatch().wait();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    int total=progress.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      PayloadService.instance.updateSendStatus(message,total);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    return total;
  }
  return 0;
}","@Override public Integer call() throws Exception {
  if (message == null) {
    return 0;
  }
  if (message.getClients() != null) {
    SentProgress progress=new SentProgress(message.getClients().size());
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getAppKey(),client);
      if (c != null) {
        c.send(progress,message);
      }
 else {
        if (product.getClientTypeid().intValue() != ClientType.iOS) {
          continue;
        }
        Client cc=ClientService.instance.findByUserId(client);
        if (cc == null) {
          logger.warn(""String_Node_Str"" + client);
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(progress,this.product,cc,message);
      }
    }
    try {
      progress.getCountDownLatch().await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    int total=progress.getSuccess().get();
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      PayloadService.instance.updateSendStatus(message,total);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    return total;
  }
  return 0;
}"
12503,"@Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
}","@Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  ctx.flush();
}"
12504,"/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  MetricBuilder.requestMeter.mark();
  ByteBuf b=(ByteBuf)msg;
  byte[] dd=new byte[b.readableBytes()];
  b.readBytes(dd);
  ctx.fireChannelRead(msg);
  final APNSEvent cc;
  try {
    cc=MessageUtils.asT(APNSEvent.class,dd);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
    ack(ctx,null);
    return;
  }
  if (cc.typeId.intValue() == ClientType.Android) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.typeId.intValue() == ClientType.iOS) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.op.intValue() == Commands.GO_ONLINE) {
    ConnectionKeeper.add(cc.appKey,cc.userId,new Connection(ctx.channel()));
    poolTaskExecutor.submit(new OnNewlyAddThread(cc));
    ack(ctx,cc);
  }
 else   if (cc.op.intValue() == Commands.KEEP_ALIVE) {
    ack(ctx,cc);
  }
 else   if (cc.op.intValue() == Commands.PUSH_ACK) {
    ack(ctx,cc);
  }
 else   if (cc.op.intValue() == Commands.GO_OFFLINE) {
    poolTaskExecutor.submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientService.instance.findByUserId(cc.userId);
        if (c0 != null) {
          ClientService.instance.updateOnlineTs(c0.getId());
        }
      }
    }
);
    ctx.close();
  }
}","/** 
 * 读取新消息 LengthFieldBasedFrameDecoder 自动解包
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  MetricBuilder.requestMeter.mark();
  final APNSEvent cc;
  try {
    cc=MessageUtils.asT(APNSEvent.class,(byte[])msg);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
    ack(ctx,null);
    return;
  }
  ReferenceCountUtil.release(msg);
  if (cc.typeId.intValue() == ClientType.Android) {
    MetricBuilder.clientAndroidMeter.mark();
  }
 else   if (cc.typeId.intValue() == ClientType.iOS) {
    MetricBuilder.clientIOSMeter.mark();
  }
  if (cc.op.intValue() == Commands.GO_ONLINE) {
    ConnectionKeeper.add(cc.appKey,cc.userId,new Connection(ctx.channel()));
    poolTaskExecutor.submit(new OnNewlyAddThread(cc));
    ack(ctx,cc);
  }
 else   if (cc.op.intValue() == Commands.KEEP_ALIVE) {
    ack(ctx,cc);
  }
 else   if (cc.op.intValue() == Commands.PUSH_ACK) {
    ack(ctx,cc);
  }
 else   if (cc.op.intValue() == Commands.GO_OFFLINE) {
    poolTaskExecutor.submit(new Runnable(){
      @Override public void run(){
        Client c0=ClientService.instance.findByUserId(cc.userId);
        if (c0 != null) {
          ClientService.instance.updateOnlineTs(c0.getId());
        }
      }
    }
);
    ctx.close();
  }
}"
12505,"/** 
 * 启动推送服务 8080端口
 */
public static void start(Properties prop){
  String actSize=prop.getProperty(""String_Node_Str"",""String_Node_Str"");
  String workerSize=prop.getProperty(""String_Node_Str"",""String_Node_Str"");
  port=Integer.parseInt(prop.getProperty(""String_Node_Str"",""String_Node_Str""));
  EventLoopGroup parentGroup=new NioEventLoopGroup(Integer.parseInt(actSize));
  EventLoopGroup childGroup=new NioEventLoopGroup(Integer.parseInt(workerSize));
  try {
    ServerBootstrap serverBootstrap=new ServerBootstrap();
    serverBootstrap.group(parentGroup,childGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ch.pipeline().addLast(new PublisherConnHandler());
      }
    }
);
    serverBootstrap.option(ChannelOption.SO_KEEPALIVE,true);
    serverBootstrap.option(ChannelOption.TCP_NODELAY,true);
    serverBootstrap.option(ChannelOption.SO_REUSEADDR,true);
    DisruptorContext.instance.start();
    System.out.println(""String_Node_Str"" + port + ""String_Node_Str"");
    ChannelFuture f=serverBootstrap.bind(port).sync();
    f.channel().closeFuture().sync();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    childGroup.shutdownGracefully();
    parentGroup.shutdownGracefully();
    DisruptorContext.instance.stop();
  }
}","/** 
 * 启动推送服务 8080端口
 */
public static void start(Properties prop){
  String actSize=prop.getProperty(""String_Node_Str"",""String_Node_Str"");
  String workerSize=prop.getProperty(""String_Node_Str"",""String_Node_Str"");
  port=Integer.parseInt(prop.getProperty(""String_Node_Str"",""String_Node_Str""));
  EventLoopGroup parentGroup=new NioEventLoopGroup(Integer.parseInt(actSize));
  EventLoopGroup childGroup=new NioEventLoopGroup(Integer.parseInt(workerSize));
  try {
    ServerBootstrap serverBootstrap=new ServerBootstrap();
    serverBootstrap.group(parentGroup,childGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ChannelPipeline pipeline=ch.pipeline();
        pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
        pipeline.addLast(""String_Node_Str"",new ByteArrayDecoder());
        pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4,false));
        pipeline.addLast(""String_Node_Str"",new ByteArrayEncoder());
        pipeline.addLast(""String_Node_Str"",new PublisherConnHandler());
      }
    }
);
    serverBootstrap.option(ChannelOption.SO_KEEPALIVE,true);
    serverBootstrap.option(ChannelOption.TCP_NODELAY,true);
    serverBootstrap.option(ChannelOption.SO_REUSEADDR,true);
    DisruptorContext.instance.start();
    System.out.println(""String_Node_Str"" + port + ""String_Node_Str"");
    ChannelFuture f=serverBootstrap.bind(port).sync();
    f.channel().closeFuture().sync();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    childGroup.shutdownGracefully();
    parentGroup.shutdownGracefully();
    DisruptorContext.instance.stop();
  }
}"
12506,"@Override public void initChannel(SocketChannel ch) throws Exception {
  ch.pipeline().addLast(new PublisherConnHandler());
}","@Override public void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline pipeline=ch.pipeline();
  pipeline.addLast(""String_Node_Str"",new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));
  pipeline.addLast(""String_Node_Str"",new ByteArrayDecoder());
  pipeline.addLast(""String_Node_Str"",new LengthFieldPrepender(4,false));
  pipeline.addLast(""String_Node_Str"",new ByteArrayEncoder());
  pipeline.addLast(""String_Node_Str"",new PublisherConnHandler());
}"
12507,"/** 
 * 读取新消息
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  MetricBuilder.recvMeter.mark();
  ByteBuf b=(ByteBuf)msg;
  byte[] dd=new byte[b.readableBytes()];
  b.readBytes(dd);
  try {
    PayloadMessage message=MessageUtils.asT(PayloadMessage.class,dd);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",message);
    }
    DisruptorContext.producer.push(message);
    ack(ctx,""String_Node_Str"");
  }
 catch (  IOException e) {
    logger.error(e.getMessage(),e);
    ack(ctx,""String_Node_Str"");
  }
 finally {
    ctx.fireChannelRead(msg);
  }
}","/** 
 * 读取新消息
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  logger.info(""String_Node_Str"" + ctx.channel().hashCode());
  MetricBuilder.recvMeter.mark();
  byte[] dd=(byte[])msg;
  try {
    PayloadMessage message=MessageUtils.asT(PayloadMessage.class,dd);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",message);
    }
    DisruptorContext.producer.push(message);
    ack(ctx,""String_Node_Str"");
  }
 catch (  IOException e) {
    logger.error(e.getMessage(),e);
    ack(ctx,""String_Node_Str"");
  }
 finally {
    ctx.fireChannelRead(msg);
  }
}"
12508,"@Override public void run(){
  logger.info(""String_Node_Str"" + this.product);
  int min=Integer.parseInt(this.conf.getProperty(DISPATCHER_INTERVAL,""String_Node_Str""));
  while (!this.stopping) {
    doSinglePush();
    doBroadcastPush();
    try {
      Thread.sleep(min * 1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  logger.info(""String_Node_Str"" + this.product);
}","@Override public void run(){
  logger.info(""String_Node_Str"" + this.product);
  int min=Integer.parseInt(this.conf.getProperty(DISPATCHER_INTERVAL,""String_Node_Str""));
  while (!this.stopping) {
    int total=ClientKeeper.count(product.getKey());
    if (total > 0) {
      doSinglePush();
      doBroadcastPush();
    }
    try {
      Thread.sleep(min * 1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  logger.info(""String_Node_Str"" + this.product);
}"
12509,"@Override public Boolean call() throws Exception {
  Payload message=PayloadService.instance.get(this.messageId);
  if (message == null) {
    return true;
  }
  if (message.getClients() == null || message.getClients().size() == 0) {
    List<Client> clients=ClientService.instance.findOfflineByType(this.product.getId(),ClientType.iOS,this.start,this.limit);
    for (    Client c : clients) {
      this.pushToApple(c,message);
    }
    try {
      PayloadService.instance.addHisotry(message,null,clients.size(),true);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    if (clients.size() > 0) {
      MetricBuilder.pushMeter.mark(clients.size());
      MetricBuilder.boradcastMeter.mark(clients.size());
    }
    logger.info(""String_Node_Str"" + clients.size());
  }
  return true;
}","@Override public Boolean call() throws Exception {
  Payload message=PayloadService.instance.get(this.messageId);
  if (message == null) {
    return true;
  }
  if (message.getClients() == null || message.getClients().size() == 0) {
    List<Client> clients=ClientService.instance.findOfflineByType(this.product.getId(),ClientType.iOS,this.start,this.limit);
    for (    Client c : clients) {
      APNSKeeper.push(this.product,c,message);
    }
    try {
      PayloadService.instance.addHisotry(message,null,clients.size(),true);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    if (clients.size() > 0) {
      MetricBuilder.pushMeter.mark(clients.size());
      MetricBuilder.boradcastMeter.mark(clients.size());
    }
    logger.info(""String_Node_Str"" + clients.size());
  }
  return true;
}"
12510,"@Override public Boolean call() throws Exception {
  Payload message=PayloadService.instance.findLatest(product.getId(),userId);
  if (message == null) {
    return true;
  }
  boolean ok=false;
  if (message.getClients() != null) {
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getKey(),client);
      ok=c.send(message);
    }
    try {
      PayloadService.instance.addHisotry(message,null,message.getClients().size(),ok);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return ok;
}","@Override public Boolean call() throws Exception {
  Payload message=PayloadService.instance.findLatest(product.getId(),userId);
  if (message == null) {
    return true;
  }
  boolean ok=false;
  if (message.getClients() != null) {
    int total=0;
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getKey(),client);
      if (c != null) {
        ok=c.send(message);
        total++;
      }
    }
    try {
      PayloadService.instance.addHisotry(message,null,total,ok);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return ok;
}"
12511,"@Override public Boolean call() throws Exception {
  Payload message=PayloadService.instance.get(this.messageId);
  if (message == null) {
    return true;
  }
  boolean ok=false;
  if (message.getClients() != null) {
    int total=0;
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getKey(),client);
      if (c != null) {
        ok=c.send(message);
        total++;
      }
 else {
        if (product.getClientTypeid().intValue() != ClientType.iOS) {
          continue;
        }
        Client cc=ClientService.instance.findByUserId(client);
        if (cc == null) {
          logger.warn(""String_Node_Str"" + client);
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        this.pushToApple(cc,message);
        total++;
      }
    }
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      PayloadService.instance.addHisotry(message,null,total,ok);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return ok;
}","@Override public Boolean call() throws Exception {
  Payload message=PayloadService.instance.get(this.messageId);
  if (message == null) {
    return true;
  }
  boolean ok=false;
  if (message.getClients() != null) {
    int total=0;
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getKey(),client);
      if (c != null) {
        ok=c.send(message);
        total++;
      }
 else {
        if (product.getClientTypeid().intValue() != ClientType.iOS) {
          continue;
        }
        Client cc=ClientService.instance.findByUserId(client);
        if (cc == null) {
          logger.warn(""String_Node_Str"" + client);
          continue;
        }
        if (!cc.isDevice(ClientType.iOS)) {
          continue;
        }
        if (StringUtils.isBlank(cc.getDeviceToken())) {
          logger.error(""String_Node_Str"" + client);
          continue;
        }
        APNSKeeper.push(this.product,cc,message);
        total++;
      }
    }
    if (total > 0) {
      MetricBuilder.pushMeter.mark(total);
      MetricBuilder.pushSingleMeter.mark(total);
    }
    try {
      PayloadService.instance.addHisotry(message,null,total,ok);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return ok;
}"
12512,"/** 
 * 添加连接
 * @param productId:   Product Id
 * @param token
 * @param conn
 */
public static void add(String productId,String token,Connection conn){
  Integer cid=ClientKeeper.get(productId,token);
  if (cid != null) {
    Connection c=pools.get(cid);
    if (c != null) {
      c.close();
      ServerMetrics.decrConnection();
    }
  }
  cid=conn.getChannel().hashCode();
  ClientKeeper.add(productId,token,cid);
  pools.put(cid,conn);
  ServerMetrics.incrConnection();
}","/** 
 * 添加连接
 * @param productId:   Product Id
 * @param token
 * @param conn
 */
public static void add(String productId,String token,Connection conn){
  Integer cid=ClientKeeper.get(productId,token);
  if (cid != null) {
    Connection c=pools.remove(cid);
    if (c != null) {
      c.close();
      ServerMetrics.decrConnection();
    }
  }
  cid=conn.getChannel().hashCode();
  ClientKeeper.add(productId,token,cid);
  pools.put(cid,conn);
  ServerMetrics.incrConnection();
}"
12513,"/** 
 * 移除所有链接.
 * @param productId
 */
public static void removeAll(String productId){
  int t=0;
  Collection<Integer> cs=ClientKeeper.gets(productId);
  for (  Integer cid : cs) {
    Connection c=pools.get(cid);
    if (c != null) {
      c.close();
      pools.remove(cid);
      t++;
    }
  }
  if (t > 0) {
    ServerMetrics.updateConnection(-1 * t);
    ClientKeeper.unregistry(productId);
  }
}","/** 
 * 移除所有链接.
 * @param productId
 */
public static void removeAll(String productId){
  int t=0;
  Collection<Integer> cs=ClientKeeper.gets(productId);
  for (  Integer cid : cs) {
    Connection c=pools.remove(cid);
    if (c != null) {
      c.close();
      t++;
    }
  }
  if (t > 0) {
    ServerMetrics.updateConnection(-1 * t);
    ClientKeeper.unregistry(productId);
  }
}"
12514,"public boolean send(byte[] msg){
  final ByteBuf data=channel.config().getAllocator().buffer(msg.length);
  data.writeBytes(msg);
  ChannelFuture cf=channel.writeAndFlush(data);
  if (cf.isDone() && cf.cause() != null) {
    ServerMetrics.incrPushTotal(false);
    logger.error(""String_Node_Str"",cf.cause());
    return false;
  }
  long total=ServerMetrics.incrPushTotal(true);
  logger.error(""String_Node_Str"" + total);
  return true;
}","public boolean send(byte[] msg){
  final ByteBuf data=channel.config().getAllocator().buffer(msg.length);
  data.writeBytes(msg);
  ChannelFuture cf=channel.writeAndFlush(data);
  if (cf.isDone() && cf.cause() != null) {
    ServerMetrics.incrPushTotal(false);
    logger.error(""String_Node_Str"",cf.cause());
    return false;
  }
  ReferenceCountUtil.release(data);
  long total=ServerMetrics.incrPushTotal(true);
  logger.error(""String_Node_Str"" + total);
  return true;
}"
12515,"@Override public Boolean call() throws Exception {
  Payload message=PayloadService.instance.get(this.messageId);
  if (message == null) {
    return true;
  }
  if (message.getClients() == null || message.getClients().size() == 0) {
    Collection<Integer> cids=ClientKeeper.gets(product.getKey());
    int s=start * limit;
    if (cids.size() < limit) {
      limit=cids.size();
    }
    Integer[] temp=cids.toArray(new Integer[0]);
    int t0=0;
    for (int i=0; i < limit; i++) {
      int cid=temp[s + i];
      Connection c=ConnectionKeeper.get(cid);
      if (c != null) {
        c.send(message);
        t0++;
      }
    }
    PayloadService.instance.addHisotry(message,null,limit,true);
    MetricBuilder.pushMeter.mark();
    MetricBuilder.boradcastMeter.mark();
  }
  return true;
}","@Override public Boolean call() throws Exception {
  Payload message=PayloadService.instance.get(this.messageId);
  if (message == null) {
    return true;
  }
  if (message.getClients() == null || message.getClients().size() == 0) {
    Collection<Integer> cids=ClientKeeper.gets(product.getKey());
    int s=start * limit;
    if (cids.size() < limit) {
      limit=cids.size();
    }
    Integer[] temp=cids.toArray(new Integer[0]);
    int t0=0;
    for (int i=0; i < limit; i++) {
      int cid=temp[s + i];
      Connection c=ConnectionKeeper.get(cid);
      if (c != null) {
        c.send(message);
        t0++;
      }
    }
    try {
      PayloadService.instance.addHisotry(message,null,limit,true);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    MetricBuilder.pushMeter.mark();
    MetricBuilder.boradcastMeter.mark();
  }
  return true;
}"
12516,"@Override public Boolean call() throws Exception {
  Payload message=PayloadService.instance.findLatest(product.getId(),userId);
  if (message == null) {
    return true;
  }
  boolean ok=false;
  if (message.getClients() != null) {
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getKey(),client);
      ok=c.send(message);
    }
    PayloadService.instance.addHisotry(message,null,message.getClients().size(),ok);
  }
  return ok;
}","@Override public Boolean call() throws Exception {
  Payload message=PayloadService.instance.findLatest(product.getId(),userId);
  if (message == null) {
    return true;
  }
  boolean ok=false;
  if (message.getClients() != null) {
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getKey(),client);
      ok=c.send(message);
    }
    try {
      PayloadService.instance.addHisotry(message,null,message.getClients().size(),ok);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return ok;
}"
12517,"@Override public Boolean call() throws Exception {
  Payload message=PayloadService.instance.get(this.messageId);
  if (message == null) {
    return true;
  }
  boolean ok=false;
  if (message.getClients() != null) {
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getKey(),client);
      ok=c.send(message);
      MetricBuilder.pushMeter.mark();
      MetricBuilder.pushSingleMeter.mark();
    }
    PayloadService.instance.addHisotry(message,null,message.getClients().size(),ok);
  }
  return ok;
}","@Override public Boolean call() throws Exception {
  Payload message=PayloadService.instance.get(this.messageId);
  if (message == null) {
    return true;
  }
  boolean ok=false;
  if (message.getClients() != null) {
    for (    String client : message.getClients()) {
      Connection c=ConnectionKeeper.get(product.getKey(),client);
      ok=c.send(message);
      MetricBuilder.pushMeter.mark();
      MetricBuilder.pushSingleMeter.mark();
    }
    try {
      PayloadService.instance.addHisotry(message,null,message.getClients().size(),ok);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return ok;
}"
12518,"@Override public Boolean call() throws Exception {
  Client client=ClientService.instance.findByUserId(cc.getUserId());
  boolean isnew=false;
  if (client == null) {
    client=new Client();
    Product product=ProductService.instance.findByKey(cc.getAppKey());
    client.setProductId(product.getId());
    client.setUserId(cc.getUserId());
    client.setTypeId(cc.getTypeId());
    client.setDeviceToken(cc.getToken());
    ClientService.instance.add(client);
    isnew=true;
  }
  if (!isnew) {
    Dispatcher dispatcher=DispatcherRunner.instance.get(cc.getAppKey());
    if (dispatcher != null) {
      dispatcher.pushOfflinePayload(cc.getUserId());
    }
    ClientService.instance.updateOnlineTs(client.getId());
  }
  return true;
}","@Override public Boolean call() throws Exception {
  Client client=ClientService.instance.findByUserId(cc.getUserId());
  boolean isnew=false;
  if (client == null) {
    client=new Client();
    Product product=ProductService.instance.findByKey(cc.getAppKey());
    client.setProductId(product.getId());
    client.setUserId(cc.getUserId());
    client.setTypeId(cc.getTypeId());
    client.setDeviceToken(cc.getToken());
    try {
      ClientService.instance.add(client);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    isnew=true;
  }
  if (!isnew) {
    Dispatcher dispatcher=DispatcherRunner.instance.get(cc.getAppKey());
    if (dispatcher != null) {
      dispatcher.pushOfflinePayload(cc.getUserId());
    }
    try {
      ClientService.instance.updateOnlineTs(client.getId());
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return true;
}"
12519,"public Payload findLatest(int productId,String userId){
  String sql=""String_Node_Str"";
  List<Long> list=this.mainJdbc.queryForList(sql,Long.class,productId,userId);
  if (list.size() == 0) {
    return null;
  }
  return this.get(list.get(0));
}","public Payload findLatest(int productId,String userId){
  String sql=""String_Node_Str"";
  List<Long> list=this.mainJdbc.queryForList(sql,Long.class,productId,userId,PayloadStatus.Pending);
  if (list.size() == 0) {
    return null;
  }
  return this.get(list.get(0));
}"
12520,"public void addHisotry(Payload message,String userId,int counting,boolean ok){
  String sql=""String_Node_Str"";
  this.mainJdbc.update(sql,message.getId(),message.getTitle(),message.getProductId(),userId,counting,new Date().getTime() / 1000);
  sql=""String_Node_Str"";
  this.mainJdbc.update(sql,PayloadStatus.Sent,message.getId());
}","public void addHisotry(Payload message,String userId,int counting,boolean ok){
  String sql=""String_Node_Str"";
  this.mainJdbc.update(sql,message.getId(),message.getTitle(),message.getProductId(),userId,counting,new Date().getTime() / 1000);
  sql=""String_Node_Str"";
  this.mainJdbc.update(sql,PayloadStatus.Sent,message.getId());
  sql=""String_Node_Str"";
  this.mainJdbc.update(sql,PayloadStatus.Sent,message.getId());
}"
12521,"/** 
 * @param aClassLoader The class loader to be used. May be <code>null</code> indicating that the default class loader should be used.
 * @return The resources from which the XSD can be read. Never<code>null</code> nor empty.
 */
@Nonnull @Nonempty @ReturnsMutableCopy default List<IReadableResource> getAllXSDResources(@Nullable final ClassLoader aClassLoader){
  return CollectionHelper.newList(getAllXSDPaths(),s -> new ClassPathResource(s,aClassLoader));
}","/** 
 * @param aClassLoader The class loader to be used. May be <code>null</code> indicating that the default class loader should be used.
 * @return The resources from which the XSD can be read. Never<code>null</code> nor empty.
 */
@Nonnull @Nonempty @ReturnsMutableCopy default List<? extends IReadableResource> getAllXSDResources(@Nullable final ClassLoader aClassLoader){
  return CollectionHelper.newList(getAllXSDPaths(),s -> new ClassPathResource(s,aClassLoader));
}"
12522,"@Nonnull @SuppressFBWarnings(""String_Node_Str"") public Schema getSchema(@Nullable final ClassLoader aClassLoader){
  if (m_aSchema == null) {
    final List<IReadableResource> aXSDRes=getAllXSDResources(aClassLoader);
    m_aSchema=XMLSchemaCache.getInstanceOfClassLoader(aClassLoader).getSchema(aXSDRes);
    if (m_aSchema == null)     throw new IllegalStateException(""String_Node_Str"" + aXSDRes + ""String_Node_Str""+ aClassLoader);
  }
  return m_aSchema;
}","@Nonnull @SuppressFBWarnings(""String_Node_Str"") public Schema getSchema(@Nullable final ClassLoader aClassLoader){
  if (m_aSchema == null) {
    final List<? extends IReadableResource> aXSDRes=getAllXSDResources(aClassLoader);
    m_aSchema=XMLSchemaCache.getInstanceOfClassLoader(aClassLoader).getSchema(aXSDRes);
    if (m_aSchema == null)     throw new IllegalStateException(""String_Node_Str"" + aXSDRes + ""String_Node_Str""+ aClassLoader);
  }
  return m_aSchema;
}"
12523,"/** 
 * Constructor
 * @param aClass The JAXB generated class of the root element.
 * @param sXSDPaths The classpath relative paths to the XML Schema.
 */
public UBLDocumentType(@Nonnull final Class<?> aClass,@Nonnull @Nonempty final String... aXSDPaths){
  ValueEnforcer.notNull(aClass,""String_Node_Str"");
  ValueEnforcer.notEmptyNoNullValue(aXSDPaths,""String_Node_Str"");
  final XmlType aXmlType=aClass.getAnnotation(XmlType.class);
  if (aXmlType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  final Package aPackage=aClass.getPackage();
  final XmlSchema aXmlSchema=aPackage.getAnnotation(XmlSchema.class);
  if (aXmlSchema == null)   throw new IllegalArgumentException(""String_Node_Str"" + aPackage.getName() + ""String_Node_Str"");
  String sLocalName=ClassHelper.getClassLocalName(aClass);
  sLocalName=sLocalName.substring(0,sLocalName.length() - ""String_Node_Str"".length());
  m_aClass=aClass;
  m_sLocalName=sLocalName;
  m_sNamespaceURI=aXmlSchema.namespace();
  if (StringHelper.hasNoText(m_sNamespaceURI))   throw new IllegalArgumentException(""String_Node_Str"" + aPackage.getName() + ""String_Node_Str"");
  m_aQName=new QName(m_sNamespaceURI,sLocalName);
  m_aXSDPaths=CollectionHelper.newList(aXSDPaths);
}","/** 
 * Constructor
 * @param aClass The JAXB generated class of the root element.
 * @param sXSDPaths The classpath relative paths to the XML Schema. May neither be <code>null</code> nor empty.
 */
public UBLDocumentType(@Nonnull final Class<?> aClass,@Nonnull @Nonempty final List<String> aXSDPaths){
  ValueEnforcer.notNull(aClass,""String_Node_Str"");
  ValueEnforcer.notEmptyNoNullValue(aXSDPaths,""String_Node_Str"");
  final XmlType aXmlType=aClass.getAnnotation(XmlType.class);
  if (aXmlType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  final Package aPackage=aClass.getPackage();
  final XmlSchema aXmlSchema=aPackage.getAnnotation(XmlSchema.class);
  if (aXmlSchema == null)   throw new IllegalArgumentException(""String_Node_Str"" + aPackage.getName() + ""String_Node_Str"");
  String sLocalName=ClassHelper.getClassLocalName(aClass);
  sLocalName=sLocalName.substring(0,sLocalName.length() - ""String_Node_Str"".length());
  m_aClass=aClass;
  m_sLocalName=sLocalName;
  m_sNamespaceURI=aXmlSchema.namespace();
  if (StringHelper.hasNoText(m_sNamespaceURI))   throw new IllegalArgumentException(""String_Node_Str"" + aPackage.getName() + ""String_Node_Str"");
  m_aQName=new QName(m_sNamespaceURI,sLocalName);
  m_aXSDPaths=CollectionHelper.newList(aXSDPaths);
}"
12524,"protected static void append(@Nonnull final IUBLDocumentType e,@Nonnull final EPhase ePhase,@Nonnull final StringBuilder aSB,@Nonnull final String sBuilderClass,@Nonnull final String sMarshallerClass,@Nonnull final String sEnumName){
  final String sType=ClassHelper.getClassLocalName(e.getImplementationClass());
  final String sName=StringHelper.trimEnd(sType,""String_Node_Str"");
  final String sParam=""String_Node_Str"" + sName;
  final String sReadMethod=""String_Node_Str"" + sName;
  final String sWriteMethod=""String_Node_Str"" + sName;
  final String sValidateMethod=""String_Node_Str"" + sName;
  final String sIsValidMethod=""String_Node_Str"" + sName;
  final String sBuilderMethodName=Character.toLowerCase(sName.charAt(0)) + sName.substring(1);
switch (ePhase) {
case READ:
    aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str"");
  aSB.append(""String_Node_Str"").append(sBuilderClass).append('<').append(sType).append(""String_Node_Str"").append(sBuilderMethodName).append(""String_Node_Str"").append(sBuilderClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
break;
case WRITE:
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sBuilderClass).append('<').append(sType).append(""String_Node_Str"").append(sBuilderMethodName).append(""String_Node_Str"").append(sBuilderClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sEnumName).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sEnumName).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sEnumName).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sEnumName).append(""String_Node_Str"");
break;
case VALIDATE:
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sBuilderClass).append('<').append(sType).append(""String_Node_Str"").append(sBuilderMethodName).append(""String_Node_Str"").append(sBuilderClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sValidateMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sEnumName).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sValidateMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sEnumName).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sIsValidMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sValidateMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sIsValidMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sValidateMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
break;
}
}","protected static void append(@Nonnull final IUBLDocumentType e,@Nonnull final EPhase ePhase,@Nonnull final StringBuilder aSB,@Nonnull final String sBuilderClass,@Nonnull final String sMarshallerClass,@Nonnull final String sEnumName){
  final String sType=ClassHelper.getClassLocalName(e.getImplementationClass());
  final String sName=StringHelper.trimEnd(sType,""String_Node_Str"");
  final String sParam=""String_Node_Str"" + sName;
  final String sReadMethod=""String_Node_Str"" + sName;
  final String sWriteMethod=""String_Node_Str"" + sName;
  final String sValidateMethod=""String_Node_Str"" + sName;
  final String sIsValidMethod=""String_Node_Str"" + sName;
  final String sBuilderMethodName=Character.toLowerCase(sName.charAt(0)) + sName.substring(1);
switch (ePhase) {
case READ:
    aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str"");
  aSB.append(""String_Node_Str"").append(sBuilderClass).append('<').append(sType).append(""String_Node_Str"").append(sBuilderMethodName).append(""String_Node_Str"").append(sBuilderClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sType+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sReadMethod).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
break;
case WRITE:
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sBuilderClass).append('<').append(sType).append(""String_Node_Str"").append(sBuilderMethodName).append(""String_Node_Str"").append(sBuilderClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sEnumName).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sEnumName).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sEnumName).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str""+ sParam+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sWriteMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sEnumName).append(""String_Node_Str"");
break;
case VALIDATE:
aSB.append(""String_Node_Str"" + sName + ""String_Node_Str""+ ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sBuilderClass).append('<').append(sType).append(""String_Node_Str"").append(sBuilderMethodName).append(""String_Node_Str"").append(sBuilderClass).append(""String_Node_Str"").append(sType).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str"").append(sParam).append(""String_Node_Str"" + ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sValidateMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sEnumName).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str"").append(sParam).append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sValidateMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sMarshallerClass).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sEnumName).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str"").append(sParam).append(""String_Node_Str"" + ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sIsValidMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sValidateMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
aSB.append(""String_Node_Str"" + sType + ""String_Node_Str""+ ""String_Node_Str"").append(sParam).append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
aSB.append(""String_Node_Str"").append(sIsValidMethod).append(""String_Node_Str"").append(sType).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"").append(sValidateMethod).append(""String_Node_Str"").append(sParam).append(""String_Node_Str"");
break;
}
}"
12525,"/** 
 * Convert the passed XML node into a domain object.<br> Note: this is the generic API for reading all types of UBL documents. Please refer to   {@link UBL20Reader} for a type-safe API for all supporteddocument types.
 * @param aSource The source object to be converted. May not be <code>null</code>.
 * @param aClassLoader Optional class loader to be used for JAXBContext. May be <code>null</code> to indicate to use the default class loader.
 * @param aDestClass The UBL class of the result type. May not be <code>null</code>.
 * @param aCustomEventHandler An optional custom event handler to be used in unmarshalling. May be <code>null</code>.
 * @return <code>null</code> in case conversion to the specified class failed.See the log output for details.
 */
@Nullable public static <T>T readUBLDocument(@Nonnull final Source aSource,@Nullable final ClassLoader aClassLoader,@Nonnull final Class<T> aDestClass,@Nullable final ValidationEventHandler aCustomEventHandler){
  ValueEnforcer.notNull(aSource,""String_Node_Str"");
  ValueEnforcer.notNull(aDestClass,""String_Node_Str"");
  final Schema aSchema=UBL20DocumentTypes.getSchemaOfImplementationClass(aDestClass,aClassLoader);
  if (aSchema == null) {
    s_aLogger.error(""String_Node_Str"" + aDestClass.getName());
    return null;
  }
  T ret=null;
  try {
    final Unmarshaller aUnmarshaller=createFullUnmarshaller(aDestClass,aClassLoader,aSchema,aCustomEventHandler);
    ret=aUnmarshaller.unmarshal(aSource,aDestClass).getValue();
    if (ret == null)     throw new IllegalStateException(""String_Node_Str"" + aDestClass.getName() + ""String_Node_Str"");
  }
 catch (  final UnmarshalException ex) {
    s_aLogger.error(""String_Node_Str"",ex);
    return null;
  }
catch (  final JAXBException ex) {
    s_aLogger.warn(""String_Node_Str"",ex);
    return null;
  }
  return ret;
}","/** 
 * Convert the passed XML node into a domain object.<br> Note: this is the generic API for reading all types of UBL documents. Please refer to   {@link UBL20Reader} for a type-safe API for all supporteddocument types.
 * @param aSource The source object to be converted. May not be <code>null</code>.
 * @param aClassLoader Optional class loader to be used for JAXBContext. May be <code>null</code> to indicate to use the default class loader.
 * @param aDestClass The UBL class of the result type. May not be <code>null</code>.
 * @param aCustomEventHandler An optional custom event handler to be used in unmarshalling. May be <code>null</code>.
 * @return <code>null</code> in case conversion to the specified class failed.See the log output for details.
 * @param < T > The UBL document implementation type
 */
@Nullable public static <T>T readUBLDocument(@Nonnull final Source aSource,@Nullable final ClassLoader aClassLoader,@Nonnull final Class<T> aDestClass,@Nullable final ValidationEventHandler aCustomEventHandler){
  ValueEnforcer.notNull(aSource,""String_Node_Str"");
  ValueEnforcer.notNull(aDestClass,""String_Node_Str"");
  final Schema aSchema=UBL20DocumentTypes.getSchemaOfImplementationClass(aDestClass,aClassLoader);
  if (aSchema == null) {
    s_aLogger.error(""String_Node_Str"" + aDestClass.getName());
    return null;
  }
  T ret=null;
  try {
    final Unmarshaller aUnmarshaller=createFullUnmarshaller(aDestClass,aClassLoader,aSchema,aCustomEventHandler);
    ret=aUnmarshaller.unmarshal(aSource,aDestClass).getValue();
    if (ret == null)     throw new IllegalStateException(""String_Node_Str"" + aDestClass.getName() + ""String_Node_Str"");
  }
 catch (  final UnmarshalException ex) {
    s_aLogger.error(""String_Node_Str"",ex);
    return null;
  }
catch (  final JAXBException ex) {
    s_aLogger.warn(""String_Node_Str"",ex);
    return null;
  }
  return ret;
}"
12526,"/** 
 * @return The current default validation event handler. May be<code>null</code> to indicate that no global validation event handler is defined, and the default validation handler is used.
 */
@Nullable public static final ValidationEventHandler getDefaultValidationEventHandler(){
  s_aRWLock.readLock().lock();
  try {
    return s_aEventHandler;
  }
  finally {
    s_aRWLock.readLock().unlock();
  }
}","/** 
 * @return The current default validation event handler. May be<code>null</code> to indicate that no global validation event handler is defined, and the default validation handler is used.
 */
@Nullable public static ValidationEventHandler getDefaultValidationEventHandler(){
  return s_aRWLock.readLocked(() -> s_aEventHandler);
}"
12527,"/** 
 * @return The special JAXB namespace context to be used. <code>null</code> bydefault.
 */
@Nullable public static NamespaceContext getDefaultNamespaceContext(){
  s_aRWLock.readLock().lock();
  try {
    return s_aNamespaceContext;
  }
  finally {
    s_aRWLock.readLock().unlock();
  }
}","/** 
 * @return The special JAXB namespace context to be used. <code>null</code> bydefault.
 */
@Nullable public static NamespaceContext getDefaultNamespaceContext(){
  return s_aRWLock.readLocked(() -> s_aNamespaceContext);
}"
12528,"/** 
 * Set the default namespace context (prefix to namespace URL mapping) to be used.
 * @param aNamespaceContext The namespace context to be used by default. May be <code>null</code>.
 */
public static void setDefaultNamespaceContext(@Nullable final NamespaceContext aNamespaceContext){
  s_aRWLock.writeLock().lock();
  try {
    s_aNamespaceContext=aNamespaceContext;
  }
  finally {
    s_aRWLock.writeLock().unlock();
  }
}","/** 
 * Set the default namespace context (prefix to namespace URL mapping) to be used.
 * @param aNamespaceContext The namespace context to be used by default. May be <code>null</code>.
 */
public static void setDefaultNamespaceContext(@Nullable final NamespaceContext aNamespaceContext){
  s_aRWLock.writeLocked(() -> {
    s_aNamespaceContext=aNamespaceContext;
  }
);
}"
12529,"/** 
 * Set a global event handler that should be passed to all read/write actions. If no global validation handler is defined, a default logging event handler is used.
 * @param aEventHandler The new default event handler. May be <code>null</code> to indicate, that the default handler should be used.
 */
public static final void setDefaultValidationEventHandler(@Nullable final ValidationEventHandler aEventHandler){
  s_aRWLock.writeLock().lock();
  try {
    s_aEventHandler=aEventHandler;
  }
  finally {
    s_aRWLock.writeLock().unlock();
  }
}","/** 
 * Set a global event handler that should be passed to all read/write actions. If no global validation handler is defined, a default logging event handler is used.
 * @param aEventHandler The new default event handler. May be <code>null</code> to indicate, that the default handler should be used.
 */
public static void setDefaultValidationEventHandler(@Nullable final ValidationEventHandler aEventHandler){
  s_aRWLock.writeLocked(() -> {
    s_aEventHandler=aEventHandler;
  }
);
}"
12530,"private boolean shouldPerformTransformations(final List<DSSTransform> transforms){
  for (  final DSSTransform transform : transforms) {
    if (!transform.isPerform()) {
      return true;
    }
  }
  return false;
}","private boolean shouldPerformTransformations(final List<DSSTransform> transforms){
  if (transforms != null) {
    for (    final DSSTransform transform : transforms) {
      if (!transform.isPerform()) {
        return true;
      }
    }
  }
  return false;
}"
12531,"public ValidationPolicy(XmlDom xmlDom,URL sourceXSD,HashMap<String,Object> treeResult,Document document){
  this.xmlDom=xmlDom;
  this.treeResult=treeResult;
  this.document=document;
  this.sourceXSD=sourceXSD;
}","public ValidationPolicy(XmlDom xmlDom,URL sourceXSD,Document document){
  this.xmlDom=xmlDom;
  this.document=document;
  this.sourceXSD=sourceXSD;
}"
12532,"/** 
 * @param signatureNode
 * @param exception
 */
private static void notifyException(final XmlNode signatureNode,final Exception exception){
  signatureNode.addChild(NodeName.INDICATION,Indication.INDETERMINATE);
  signatureNode.addChild(NodeName.SUB_INDICATION,""String_Node_Str"");
  signatureNode.addChild(NodeName.INFO,exception.toString());
  LOG.error(exception.getMessage(),exception);
}","/** 
 * @param signatureNode
 * @param exception
 */
private static void notifyException(final XmlNode signatureNode,final Exception exception){
  LOG.error(exception.getMessage(),exception);
  signatureNode.removeChild(NodeName.INDICATION);
  signatureNode.removeChild(NodeName.SUB_INDICATION);
  signatureNode.addChild(NodeName.INDICATION,Indication.INDETERMINATE);
  signatureNode.addChild(NodeName.SUB_INDICATION,SubIndication.UNEXPECTED_ERROR);
  final String message=DSSUtils.getSummaryMessage(exception,SimpleReportBuilder.class);
  signatureNode.addChild(NodeName.INFO,message);
}"
12533,"/** 
 * This method lists all defined secutity providers.
 */
public static void printSecurityProvides(){
  final Provider[] providers=Security.getProviders();
  for (  final Provider provider : providers) {
    System.out.println(""String_Node_Str"" + provider.getName());
    final Set<Provider.Service> services=provider.getServices();
    for (    final Provider.Service service : services) {
      System.out.println(""String_Node_Str"" + service.getAlgorithm() + ""String_Node_Str""+ service.getType()+ ""String_Node_Str""+ service.getClassName());
    }
  }
}","/** 
 * This method lists all defined security providers.
 */
public static void printSecurityProvides(){
  final Provider[] providers=Security.getProviders();
  for (  final Provider provider : providers) {
    System.out.println(""String_Node_Str"" + provider.getName());
    final Set<Provider.Service> services=provider.getServices();
    for (    final Provider.Service service : services) {
      System.out.println(""String_Node_Str"" + service.getAlgorithm() + ""String_Node_Str""+ service.getType()+ ""String_Node_Str""+ service.getClassName());
    }
  }
}"
12534,"/** 
 * Creates XAdES TimeStamp object representation. The time stamp token is obtained from TSP source
 * @param timestampC14nMethod
 * @param digestValue
 * @return
 * @throws eu.europa.ec.markt.dss.exception.DSSException
 */
protected void createXAdESTimeStampType(final TimestampType timestampType,final String timestampC14nMethod,final byte[] digestValue) throws DSSException {
  try {
    final DigestAlgorithm timestampDigestAlgorithm=params.getSignatureTimestampParameters().getDigestAlgorithm();
    if (LOG.isInfoEnabled()) {
      final String encodedDigestValue=DSSUtils.base64Encode(digestValue);
      LOG.info(""String_Node_Str"" + timestampDigestAlgorithm.getName() + ""String_Node_Str""+ timestampC14nMethod+ ""String_Node_Str""+ encodedDigestValue);
    }
    final TimeStampToken timeStampToken=tspSource.getTimeStampResponse(timestampDigestAlgorithm,digestValue);
    final byte[] timeStampTokenBytes=timeStampToken.getEncoded();
    final String signatureTimestampId=""String_Node_Str"" + UUID.randomUUID().toString();
    final String base64EncodedTimeStampToken=DSSUtils.base64Encode(timeStampTokenBytes);
    Element timeStampDom=null;
switch (timestampType) {
case SIGNATURE_TIMESTAMP:
      timeStampDom=DSSXMLUtils.addElement(documentDom,unsignedSignaturePropertiesDom,XAdESNamespaces.XAdES,""String_Node_Str"");
    break;
case VALIDATION_DATA_REFSONLY_TIMESTAMP:
  break;
case VALIDATION_DATA_TIMESTAMP:
timeStampDom=DSSXMLUtils.addElement(documentDom,unsignedSignaturePropertiesDom,XAdESNamespaces.XAdES,""String_Node_Str"");
break;
case ARCHIVE_TIMESTAMP:
timeStampDom=DSSXMLUtils.addElement(documentDom,unsignedSignaturePropertiesDom,XAdESNamespaces.XAdES141,""String_Node_Str"");
break;
case CONTENT_TIMESTAMP:
break;
case ALL_DATA_OBJECTS_TIMESTAMP:
timeStampDom=DSSXMLUtils.addElement(documentDom,signedPropertiesDom,XAdESNamespaces.XAdES,""String_Node_Str"");
break;
case INDIVIDUAL_DATA_OBJECTS_TIMESTAMP:
timeStampDom=DSSXMLUtils.addElement(documentDom,signedPropertiesDom,XAdESNamespaces.XAdES,""String_Node_Str"");
break;
}
timeStampDom.setAttribute(""String_Node_Str"",signatureTimestampId);
incorporateC14nMethod(timeStampDom,timestampC14nMethod);
final Element encapsulatedTimeStampDom=DSSXMLUtils.addElement(documentDom,timeStampDom,XAdESNamespaces.XAdES,""String_Node_Str"");
encapsulatedTimeStampDom.setAttribute(""String_Node_Str"",signatureTimestampId);
DSSXMLUtils.setTextNode(documentDom,encapsulatedTimeStampDom,base64EncodedTimeStampToken);
}
 catch (IOException e) {
throw new DSSException(""String_Node_Str"",e);
}
}","/** 
 * Creates XAdES TimeStamp object representation. The time stamp token is obtained from TSP source
 * @param timestampC14nMethod
 * @param digestValue
 * @return
 * @throws eu.europa.ec.markt.dss.exception.DSSException
 */
protected void createXAdESTimeStampType(final TimestampType timestampType,final String timestampC14nMethod,final byte[] digestValue) throws DSSException {
  try {
    Element timeStampDom=null;
    DigestAlgorithm timestampDigestAlgorithm=null;
switch (timestampType) {
case SIGNATURE_TIMESTAMP:
      timeStampDom=DSSXMLUtils.addElement(documentDom,unsignedSignaturePropertiesDom,XAdESNamespaces.XAdES,""String_Node_Str"");
    timestampDigestAlgorithm=params.getSignatureTimestampParameters().getDigestAlgorithm();
  break;
case VALIDATION_DATA_REFSONLY_TIMESTAMP:
timestampDigestAlgorithm=params.getSignatureTimestampParameters().getDigestAlgorithm();
break;
case VALIDATION_DATA_TIMESTAMP:
timeStampDom=DSSXMLUtils.addElement(documentDom,unsignedSignaturePropertiesDom,XAdESNamespaces.XAdES,""String_Node_Str"");
timestampDigestAlgorithm=params.getSignatureTimestampParameters().getDigestAlgorithm();
break;
case ARCHIVE_TIMESTAMP:
timeStampDom=DSSXMLUtils.addElement(documentDom,unsignedSignaturePropertiesDom,XAdESNamespaces.XAdES141,""String_Node_Str"");
timestampDigestAlgorithm=params.getArchiveTimestampParameters().getDigestAlgorithm();
break;
case CONTENT_TIMESTAMP:
timestampDigestAlgorithm=params.getSignatureTimestampParameters().getDigestAlgorithm();
break;
case ALL_DATA_OBJECTS_TIMESTAMP:
timeStampDom=DSSXMLUtils.addElement(documentDom,signedPropertiesDom,XAdESNamespaces.XAdES,""String_Node_Str"");
timestampDigestAlgorithm=params.getSignatureTimestampParameters().getDigestAlgorithm();
break;
case INDIVIDUAL_DATA_OBJECTS_TIMESTAMP:
timeStampDom=DSSXMLUtils.addElement(documentDom,signedPropertiesDom,XAdESNamespaces.XAdES,""String_Node_Str"");
timestampDigestAlgorithm=params.getSignatureTimestampParameters().getDigestAlgorithm();
break;
}
if (LOG.isInfoEnabled()) {
final String encodedDigestValue=DSSUtils.base64Encode(digestValue);
LOG.info(""String_Node_Str"" + timestampDigestAlgorithm.getName() + ""String_Node_Str""+ timestampC14nMethod+ ""String_Node_Str""+ encodedDigestValue);
}
final TimeStampToken timeStampToken=tspSource.getTimeStampResponse(timestampDigestAlgorithm,digestValue);
final byte[] timeStampTokenBytes=timeStampToken.getEncoded();
final String signatureTimestampId=""String_Node_Str"" + UUID.randomUUID().toString();
final String base64EncodedTimeStampToken=DSSUtils.base64Encode(timeStampTokenBytes);
timeStampDom.setAttribute(""String_Node_Str"",signatureTimestampId);
incorporateC14nMethod(timeStampDom,timestampC14nMethod);
final Element encapsulatedTimeStampDom=DSSXMLUtils.addElement(documentDom,timeStampDom,XAdESNamespaces.XAdES,""String_Node_Str"");
encapsulatedTimeStampDom.setAttribute(""String_Node_Str"",signatureTimestampId);
DSSXMLUtils.setTextNode(documentDom,encapsulatedTimeStampDom,base64EncodedTimeStampToken);
}
 catch (IOException e) {
throw new DSSException(""String_Node_Str"",e);
}
}"
12535,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  ConnectionInfo connectionInfo=((MainActivity)getActivity()).getConnectionInfo();
  mayContinue=true;
  if (!connectionInfo.isHostNameMatching()) {
    mayContinue=false;
    getListView().addFooterView(getActivity().getLayoutInflater().inflate(R.layout.select_invalid_hostname,null),null,false);
  }
 else   try {
    if (connectionInfo.isTrusted()) {
      mayContinue=false;
      getListView().addFooterView(getActivity().getLayoutInflater().inflate(R.layout.select_already_trusted,null),null,false);
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
    mayContinue=false;
  }
  if (mayContinue) {
    TextView tv=new TextView(view.getContext());
    tv.setTextSize(TypedValue.COMPLEX_UNIT_SP,20);
    tv.setText(R.string.select_text);
    tv.setPadding(0,0,0,10);
    getListView().addHeaderView(tv,null,false);
    setListAdapter(adapter);
  }
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  ConnectionInfo connectionInfo=((MainActivity)getActivity()).getConnectionInfo();
  mayContinue=true;
  if (!connectionInfo.isHostNameMatching()) {
    mayContinue=false;
    getListView().addFooterView(getActivity().getLayoutInflater().inflate(R.layout.select_invalid_hostname,null),null,false);
  }
 else {
    try {
      if (connectionInfo.isTrusted()) {
        mayContinue=false;
        getListView().addFooterView(getActivity().getLayoutInflater().inflate(R.layout.select_already_trusted,null),null,false);
      }
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
      mayContinue=false;
    }
  }
  if (mayContinue) {
    TextView tv=new TextView(view.getContext());
    tv.setTextSize(TypedValue.COMPLEX_UNIT_SP,20);
    tv.setText(R.string.select_text);
    tv.setPadding(0,0,0,10);
    getListView().addHeaderView(tv,null,false);
  }
  setListAdapter(adapter);
}"
12536,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  ConnectionInfo connectionInfo=((MainActivity)getActivity()).getConnectionInfo();
  mayContinue=true;
  if (!connectionInfo.isHostNameMatching()) {
    mayContinue=false;
    getListView().addFooterView(getActivity().getLayoutInflater().inflate(R.layout.select_invalid_hostname,null),null,false);
  }
 else   try {
    if (connectionInfo.isTrusted()) {
      mayContinue=false;
      getListView().addFooterView(getActivity().getLayoutInflater().inflate(R.layout.select_already_trusted,null),null,false);
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
    mayContinue=false;
  }
  if (mayContinue) {
    TextView tv=new TextView(view.getContext());
    tv.setTextSize(TypedValue.COMPLEX_UNIT_SP,20);
    tv.setText(R.string.select_text);
    tv.setPadding(0,0,0,10);
    getListView().addHeaderView(tv,null,false);
  }
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  ConnectionInfo connectionInfo=((MainActivity)getActivity()).getConnectionInfo();
  mayContinue=true;
  if (!connectionInfo.isHostNameMatching()) {
    mayContinue=false;
    getListView().addFooterView(getActivity().getLayoutInflater().inflate(R.layout.select_invalid_hostname,null),null,false);
  }
 else   try {
    if (connectionInfo.isTrusted()) {
      mayContinue=false;
      getListView().addFooterView(getActivity().getLayoutInflater().inflate(R.layout.select_already_trusted,null),null,false);
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
    mayContinue=false;
  }
  if (mayContinue) {
    TextView tv=new TextView(view.getContext());
    tv.setTextSize(TypedValue.COMPLEX_UNIT_SP,20);
    tv.setText(R.string.select_text);
    tv.setPadding(0,0,0,10);
    addHeaderToListView(getListView(),tv,null,false);
  }
}"
12537,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  MainActivity main=(MainActivity)getActivity();
  main.onShowFragment(TAG);
  ArrayAdapter<String> adapter=new ArrayAdapter<String>(inflater.getContext(),android.R.layout.simple_list_item_1){
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      TextView v=(TextView)super.getView(position,convertView,parent);
      if (Build.VERSION.SDK_INT >= 17)       v.setCompoundDrawablesRelativeWithIntrinsicBounds(R.drawable.ic_certificate,0,0,0);
 else       v.setCompoundDrawablesWithIntrinsicBounds(R.drawable.ic_certificate,0,0,0);
      v.setPadding(0,10,0,10);
      v.setCompoundDrawablePadding(10);
      return v;
    }
  }
;
  for (  X509Certificate cert : ((MainActivity)getActivity()).getConnectionInfo().getCertificates())   adapter.add(new CertificateInfo(cert).getSubjectName());
  setListAdapter(adapter);
  setHasOptionsMenu(true);
  return super.onCreateView(inflater,container,savedInstanceState);
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  MainActivity main=(MainActivity)getActivity();
  main.onShowFragment(TAG);
  adapter=new ArrayAdapter<String>(inflater.getContext(),android.R.layout.simple_list_item_1){
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      TextView v=(TextView)super.getView(position,convertView,parent);
      if (Build.VERSION.SDK_INT >= 17)       v.setCompoundDrawablesRelativeWithIntrinsicBounds(R.drawable.ic_certificate,0,0,0);
 else       v.setCompoundDrawablesWithIntrinsicBounds(R.drawable.ic_certificate,0,0,0);
      v.setPadding(0,10,0,10);
      v.setCompoundDrawablePadding(10);
      return v;
    }
  }
;
  for (  X509Certificate cert : ((MainActivity)getActivity()).getConnectionInfo().getCertificates())   adapter.add(new CertificateInfo(cert).getSubjectName());
  setHasOptionsMenu(true);
  return super.onCreateView(inflater,container,savedInstanceState);
}"
12538,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  ConnectionInfo connectionInfo=((MainActivity)getActivity()).getConnectionInfo();
  mayContinue=true;
  if (!connectionInfo.isHostNameMatching()) {
    mayContinue=false;
    getListView().addFooterView(getActivity().getLayoutInflater().inflate(R.layout.select_invalid_hostname,null),null,false);
  }
 else   try {
    if (connectionInfo.isTrusted()) {
      mayContinue=false;
      getListView().addFooterView(getActivity().getLayoutInflater().inflate(R.layout.select_already_trusted,null),null,false);
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
    mayContinue=false;
  }
  if (mayContinue) {
    TextView tv=new TextView(view.getContext());
    tv.setTextSize(TypedValue.COMPLEX_UNIT_SP,20);
    tv.setText(R.string.select_text);
    tv.setPadding(0,0,0,10);
    addHeaderToListView(getListView(),tv,null,false);
  }
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  ConnectionInfo connectionInfo=((MainActivity)getActivity()).getConnectionInfo();
  mayContinue=true;
  if (!connectionInfo.isHostNameMatching()) {
    mayContinue=false;
    getListView().addFooterView(getActivity().getLayoutInflater().inflate(R.layout.select_invalid_hostname,null),null,false);
  }
 else   try {
    if (connectionInfo.isTrusted()) {
      mayContinue=false;
      getListView().addFooterView(getActivity().getLayoutInflater().inflate(R.layout.select_already_trusted,null),null,false);
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
    mayContinue=false;
  }
  if (mayContinue) {
    TextView tv=new TextView(view.getContext());
    tv.setTextSize(TypedValue.COMPLEX_UNIT_SP,20);
    tv.setText(R.string.select_text);
    tv.setPadding(0,0,0,10);
    getListView().addHeaderView(tv,null,false);
    setListAdapter(adapter);
  }
}"
12539,"@Override public void randomDisplayTick(IBlockState state,World world,BlockPos pos,Random rand){
  final TileEntity te=world.getTileEntity(pos);
  if (te instanceof CupolaTE) {
    final CupolaTE cupola=(CupolaTE)te;
    if (cupola.isActive()) {
      final float effectX=pos.getX() + 0.5f;
      final float effectY=pos.getY() + 0.5f + rand.nextFloat() * 5.0f / 16.0f;
      final float effectZ=pos.getZ() + 0.5f;
      final float edgeOffset=0.52f;
      final float widthOffset=rand.nextFloat() * 0.6f - 0.3f;
      final IBlockState metadata=world.getBlockState(pos);
      final EnumFacing orientation=(EnumFacing)metadata.getValue(BlockDirectional.FACING);
switch (orientation) {
case SOUTH:
        world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,effectX + widthOffset,effectY,effectZ - edgeOffset,0.0d,0.0d,0.0d);
      world.spawnParticle(EnumParticleTypes.FLAME,effectX + widthOffset,effectY,effectZ - edgeOffset,0.0d,0.0d,0.0d);
    break;
case WEST:
  world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,effectX + edgeOffset,effectY,effectZ + widthOffset,0.0d,0.0d,0.0d);
world.spawnParticle(EnumParticleTypes.FLAME,effectX + edgeOffset,effectY,effectZ + widthOffset,0.0d,0.0d,0.0d);
break;
case NORTH:
world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,effectX + widthOffset,effectY,effectZ + edgeOffset,0.0d,0.0d,0.0d);
world.spawnParticle(EnumParticleTypes.FLAME,effectX + widthOffset,effectY,effectZ + edgeOffset,0.0d,0.0d,0.0d);
break;
case EAST:
world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,effectX - edgeOffset,effectY,effectZ + widthOffset,0.0d,0.0d,0.0d);
world.spawnParticle(EnumParticleTypes.FLAME,effectX - edgeOffset,effectY,effectZ + widthOffset,0.0d,0.0d,0.0d);
}
renderSmokeOnTop(world,pos,rand);
}
}
}","@Override public void randomDisplayTick(IBlockState state,World world,BlockPos pos,Random rand){
  final TileEntity te=world.getTileEntity(pos);
  if (te instanceof CupolaTE) {
    final CupolaTE cupola=(CupolaTE)te;
    if (cupola.isActive()) {
      final float effectX=pos.getX() + 0.5f;
      final float effectY=pos.getY() + 0.5f + rand.nextFloat() * 5.0f / 16.0f;
      final float effectZ=pos.getZ() + 0.5f;
      final float edgeOffset=0.52f;
      final float widthOffset=rand.nextFloat() * 0.6f - 0.3f;
      final IBlockState metadata=world.getBlockState(pos);
      final EnumFacing orientation=(EnumFacing)metadata.getValue(DIRECTION);
switch (orientation) {
case SOUTH:
        world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,effectX + widthOffset,effectY,effectZ - edgeOffset,0.0d,0.0d,0.0d);
      world.spawnParticle(EnumParticleTypes.FLAME,effectX + widthOffset,effectY,effectZ - edgeOffset,0.0d,0.0d,0.0d);
    break;
case WEST:
  world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,effectX + edgeOffset,effectY,effectZ + widthOffset,0.0d,0.0d,0.0d);
world.spawnParticle(EnumParticleTypes.FLAME,effectX + edgeOffset,effectY,effectZ + widthOffset,0.0d,0.0d,0.0d);
break;
case NORTH:
world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,effectX + widthOffset,effectY,effectZ + edgeOffset,0.0d,0.0d,0.0d);
world.spawnParticle(EnumParticleTypes.FLAME,effectX + widthOffset,effectY,effectZ + edgeOffset,0.0d,0.0d,0.0d);
break;
case EAST:
world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL,effectX - edgeOffset,effectY,effectZ + widthOffset,0.0d,0.0d,0.0d);
world.spawnParticle(EnumParticleTypes.FLAME,effectX - edgeOffset,effectY,effectZ + widthOffset,0.0d,0.0d,0.0d);
}
renderSmokeOnTop(world,pos,rand);
}
}
}"
12540,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @Override public ItemStack transferStackInSlot(EntityPlayer player,int slotIndex){
  final Slot slot=(Slot)inventorySlots.get(slotIndex);
  if (slot == null || !slot.getHasStack())   return null;
  final ItemStack slotItemStack=slot.getStack();
  final ItemStack itemStack=slotItemStack.copy();
  if (slotIndex == CupolaTE.OUTPUT) {
    if (mergeItemStack(slotItemStack,CupolaTE.INVENTORY_SIZE,inventorySlots.size(),true))     slot.onSlotChange(slotItemStack,itemStack);
 else     return null;
  }
 else   if (slotIndex > CupolaTE.INPUT_FUEL) {
    final Optional<ItemStack> result1=CraftingManager.INSTANCE.alloyManager.getCupolaResult(slotItemStack,te.getStackInSlot(CupolaTE.INPUT_RIGHT)).getItemStack();
    final Optional<ItemStack> result2=CraftingManager.INSTANCE.alloyManager.getCupolaResult(slotItemStack,te.getStackInSlot(CupolaTE.INPUT_LEFT)).getItemStack();
    if (result1.isPresent() || result2.isPresent()) {
      if (!mergeItemStack(slotItemStack,CupolaTE.INPUT_LEFT,CupolaTE.INPUT_FUEL,false))       return null;
    }
 else     if (TileEntityFurnace.isItemFuel(slotItemStack)) {
      if (!mergeItemStack(slotItemStack,CupolaTE.INPUT_FUEL,CupolaTE.OUTPUT,false))       return null;
    }
 else     if (didTransferStackInStandardSlot(slotIndex,slotItemStack,CupolaTE.INVENTORY_SIZE))     return null;
  }
 else   if (!mergeItemStack(slotItemStack,CupolaTE.INVENTORY_SIZE,inventorySlots.size(),false)) {
    return null;
  }
  if (slotItemStack.stackSize == 0)   slot.putStack(null);
 else   slot.onSlotChanged();
  if (slotItemStack.stackSize == itemStack.stackSize)   return null;
  slot.onPickupFromSlot(player,slotItemStack);
  return itemStack;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @Override public ItemStack transferStackInSlot(EntityPlayer playerIn,int index){
  ItemStack itemstack=null;
  final Slot slot=inventorySlots.get(index);
  if (slot != null && slot.getHasStack()) {
    final ItemStack slotItemStack=slot.getStack();
    final ItemStack itemStack=slotItemStack.copy();
    if (index == CupolaTE.OUTPUT) {
      if (!mergeItemStack(slotItemStack,CupolaTE.INVENTORY_SIZE,inventorySlots.size(),true)) {
        return null;
      }
      slot.onSlotChange(slotItemStack,itemStack);
    }
 else     if (index > CupolaTE.INPUT_FUEL) {
      final IAlloyManager alloyManager=CraftingManager.INSTANCE.alloyManager;
      final Optional<ItemStack> result1=alloyManager.getCupolaResult(slotItemStack,te.getStackInSlot(CupolaTE.INPUT_RIGHT)).getItemStack();
      final Optional<ItemStack> result2=alloyManager.getCupolaResult(slotItemStack,te.getStackInSlot(CupolaTE.INPUT_LEFT)).getItemStack();
      if (result1.isPresent() || result2.isPresent()) {
        if (!mergeItemStack(slotItemStack,CupolaTE.INPUT_LEFT,CupolaTE.INPUT_FUEL,false)) {
          return null;
        }
      }
 else       if (TileEntityFurnace.isItemFuel(slotItemStack)) {
        if (!mergeItemStack(slotItemStack,CupolaTE.INPUT_FUEL,CupolaTE.OUTPUT,false)) {
          return null;
        }
      }
 else       if (didTransferStackInStandardSlot(index,slotItemStack,CupolaTE.INVENTORY_SIZE)) {
        return null;
      }
    }
 else     if (!mergeItemStack(slotItemStack,CupolaTE.INVENTORY_SIZE,inventorySlots.size(),false)) {
      return null;
    }
    if (slotItemStack.stackSize == 0) {
      slot.putStack(null);
    }
 else {
      slot.onSlotChanged();
    }
    if (slotItemStack.stackSize == itemStack.stackSize) {
      return null;
    }
    slot.onPickupFromSlot(playerIn,slotItemStack);
    return itemStack;
  }
  return itemstack;
}"
12541,"private static void registerItemAndOre(Item item){
  GameRegistry.register(item);
  OreDictionary.registerOre(item.getRegistryName().getResourceDomain(),item);
}","private static void registerItemAndOre(Item item){
  GameRegistry.register(item);
  OreDictionary.registerOre(item.getRegistryName().getResourcePath(),item);
}"
12542,"@Override public void initGui(){
  xSize=176;
  ySize=227;
  super.initGui();
  recipeList=Lists.newArrayList();
  for (  final ProjectTableRecipe projectTableRecipe : ProjectTableManager.INSTANCE.getRecipes()) {
    recipeList.add(new ProjectTableRecipeInstance(projectTableRecipe));
  }
  filteredList=Lists.newArrayList(recipeList);
  searchField=new GuiTextField(0,fontRendererObj,guiLeft + 9,guiTop + 9,151,fontRendererObj.FONT_HEIGHT);
  searchField.setMaxStringLength(60);
  searchField.setEnableBackgroundDrawing(false);
  searchField.setVisible(true);
  searchField.setTextColor(16777215);
  searchField.setFocused(true);
  createComponents();
  setRecipeRenderText();
}","@Override public void initGui(){
  xSize=175;
  ySize=227;
  super.initGui();
  xSize=317;
  ySize=227;
  recipeList=Lists.newArrayList();
  for (  final ProjectTableRecipe projectTableRecipe : ProjectTableManager.INSTANCE.getRecipes()) {
    recipeList.add(new ProjectTableRecipeInstance(projectTableRecipe));
  }
  filteredList=Lists.newArrayList(recipeList);
  searchField=new GuiTextField(0,fontRendererObj,guiLeft + 9 - (317 - 175) / 2,guiTop + 9,149,fontRendererObj.FONT_HEIGHT);
  searchField.setMaxStringLength(60);
  searchField.setEnableBackgroundDrawing(false);
  searchField.setVisible(true);
  searchField.setTextColor(16777215);
  searchField.setFocused(true);
  createComponents();
  setRecipeRenderText();
}"
12543,"protected void createComponents(){
  guiRenderer=new GuiRenderer(mc,mc.getTextureManager(),fontRendererObj,itemRender);
  final GuiSubTexture guiBackground=new GuiSubTexture(guiTexture,new Rectangle(0,0,176,227));
  final GuiTexture inactiveHandle=new GuiSubTexture(guiTexture,new Rectangle(176,0,12,15));
  final GuiTexture activeHandle=new GuiSubTexture(guiTexture,new Rectangle(176 + 12,0,12,15));
  final GuiTexture craftableSubtexture=new GuiSubTexture(guiTexture,new Rectangle(0,227,142,23));
  final GuiTexture uncraftableSubtexture=new GuiSubTexture(guiTexture,new Rectangle(0,227 + 23,142,23));
  setRootControl(new TexturedPaneControl(guiRenderer,176,227,guiBackground));
  scrollbarGuiComponent=new ScrollbarControl(guiRenderer,activeHandle,inactiveHandle);
  scrollbarGuiComponent.setLocation(156,24);
  scrollbarGuiComponent.setSize(20,115);
  final ProjectTableRecipeControl templateRecipeControl=new ProjectTableRecipeControl(guiRenderer,craftableSubtexture,uncraftableSubtexture);
  recipeListGuiComponent=new ScrollPaneControl<ProjectTableRecipeInstance,ProjectTableRecipeControl>(guiRenderer,141,23 * 5).setScrollbar(scrollbarGuiComponent).setItemRendererTemplate(templateRecipeControl).setVisibleItemCount(5).setItems(filteredList);
  recipeListGuiComponent.setLocation(8,24);
  addChild(recipeListGuiComponent);
  addChild(scrollbarGuiComponent);
  templateRecipeControl.addOnRecipeCraftingEventListener(new RecipeCraftingEventListener());
  recipeListGuiComponent.addOnFireItemMadeEventListener(new RecipeMadeVisibleEventListener());
  playerInventory.inventoryChanged=false;
}","protected void createComponents(){
  guiRenderer=new GuiRenderer(mc,mc.getTextureManager(),fontRendererObj,itemRender);
  final GuiSubTexture guiBackground=new GuiSubTexture(guiTexture,new Rectangle(0,0,317,227));
  final GuiTexture inactiveHandle=new GuiSubTexture(guiTexture,new Rectangle(318,0,12,15));
  final GuiTexture activeHandle=new GuiSubTexture(guiTexture,new Rectangle(318 + 12,0,12,15));
  final GuiTexture craftableSubtexture=new GuiSubTexture(guiTexture,new Rectangle(0,227,284,23));
  final GuiTexture uncraftableSubtexture=new GuiSubTexture(guiTexture,new Rectangle(0,227 + 23,284,23));
  setRootControl(new TexturedPaneControl(guiRenderer,317,227,guiBackground));
  scrollbarGuiComponent=new ScrollbarControl(guiRenderer,activeHandle,inactiveHandle);
  scrollbarGuiComponent.setLocation(298,24);
  scrollbarGuiComponent.setSize(14,115);
  final ProjectTableRecipeControl templateRecipeControl=new ProjectTableRecipeControl(guiRenderer,craftableSubtexture,uncraftableSubtexture);
  recipeListGuiComponent=new ScrollPaneControl<ProjectTableRecipeInstance,ProjectTableRecipeControl>(guiRenderer,330,23 * 5).setScrollbar(scrollbarGuiComponent).setItemRendererTemplate(templateRecipeControl).setVisibleItemCount(5).setItems(filteredList);
  recipeListGuiComponent.setLocation(8,24);
  addChild(recipeListGuiComponent);
  addChild(scrollbarGuiComponent);
  templateRecipeControl.addOnRecipeCraftingEventListener(new RecipeCraftingEventListener());
  recipeListGuiComponent.addOnFireItemMadeEventListener(new RecipeMadeVisibleEventListener());
  playerInventory.inventoryChanged=false;
}"
12544,"public static ProjectTableRecipe readFromBuffer(PacketBuffer buf){
  try {
    byte inputItemStackCount=buf.readByte();
    List<IIngredient> input=Lists.newArrayList();
    for (int i=0; i < inputItemStackCount; ++i) {
      input.add(readIngredient(buf));
    }
    byte outputItemStackCount=buf.readByte();
    List<ItemStack> output=Lists.newArrayList();
    for (int i=0; i < outputItemStackCount; ++i) {
      output.add(buf.readItemStackFromBuffer());
    }
    final String displayName=ByteBufUtils.readUTF8String(buf);
    return new ProjectTableRecipe(output,displayName,input);
  }
 catch (  IOException e) {
    throw new SteamNSteelException(""String_Node_Str"",e);
  }
}","public static ProjectTableRecipe readFromBuffer(PacketBuffer buf){
  try {
    byte inputItemStackCount=buf.readByte();
    List<IIngredient> input=Lists.newArrayList();
    for (int i=0; i < inputItemStackCount; ++i) {
      input.add(readIngredient(buf));
    }
    byte outputItemStackCount=buf.readByte();
    List<ItemStack> output=Lists.newArrayList();
    for (int i=0; i < outputItemStackCount; ++i) {
      output.add(PacketBufferExtensions.readLargeItemStackFromBuffer(buf));
    }
    final String displayName=ByteBufUtils.readUTF8String(buf);
    return new ProjectTableRecipe(output,displayName,input);
  }
 catch (  IOException e) {
    throw new SteamNSteelException(""String_Node_Str"",e);
  }
}"
12545,"public void writeToBuffer(PacketBuffer buf){
  buf.writeByte(input.size());
  for (  final IIngredient itemStack : input) {
    writeIngredient(itemStack,buf);
  }
  buf.writeByte(output.size());
  for (  final ItemStack itemStack : output) {
    buf.writeItemStackToBuffer(itemStack);
  }
  buf.writeString(displayName);
}","public void writeToBuffer(PacketBuffer buf){
  buf.writeByte(input.size());
  for (  final IIngredient itemStack : input) {
    writeIngredient(itemStack,buf);
  }
  buf.writeByte(output.size());
  for (  final ItemStack itemStack : output) {
    PacketBufferExtensions.writeLargeItemStackToBuffer(buf,itemStack);
  }
  buf.writeString(displayName);
}"
12546,"public ProjectTableContainer(InventoryPlayer playerInventory){
  addPlayerInventory(playerInventory,8,145);
  addSlotToContainer(new ProjectTableCraftingSlot(playerInventory.player,craftMatrix,craftResult,0));
}","public ProjectTableContainer(InventoryPlayer playerInventory){
  addPlayerInventory(playerInventory,8,145);
}"
12547,"@Override public IMessage onMessage(final ProjectTableCraftPacket message,final MessageContext ctx){
  final InventoryPlayer playerInventory=ctx.getServerHandler().playerEntity.inventory;
  final ProjectTableRecipe recipe=message.getRecipe();
  final boolean canCraft=ProjectTableManager.INSTANCE.canCraftRecipe(recipe,playerInventory);
  if (!canCraft) {
    return null;
  }
  IThreadListener mainThread=(WorldServer)ctx.getServerHandler().playerEntity.worldObj;
  mainThread.addScheduledTask(new Runnable(){
    @Override public void run(){
      for (      final IIngredient ingredient : recipe.getInput()) {
        int quantityToConsume=ingredient.getQuantityConsumed();
        for (        final ItemStack itemStack : ingredient.getItemStacks()) {
          quantityToConsume-=playerInventory.clearMatchingItems(itemStack.getItem(),itemStack.getMetadata(),quantityToConsume,itemStack.getTagCompound());
          playerInventory.markDirty();
          if (quantityToConsume <= 0) {
            break;
          }
        }
      }
      for (      final ItemStack itemStack : recipe.getOutput()) {
        final ItemStack copy=itemStack.copy();
        if (!playerInventory.addItemStackToInventory(copy)) {
          ctx.getServerHandler().playerEntity.dropItem(copy,true);
        }
 else {
          playerInventory.markDirty();
        }
      }
    }
  }
);
  return null;
}","@Override public IMessage onMessage(final ProjectTableCraftPacket message,final MessageContext ctx){
  final InventoryPlayer playerInventory=ctx.getServerHandler().playerEntity.inventory;
  final ProjectTableRecipe recipe=message.getRecipe();
  final boolean canCraft=ProjectTableManager.INSTANCE.canCraftRecipe(recipe,playerInventory);
  if (!canCraft) {
    return null;
  }
  IThreadListener mainThread=(WorldServer)ctx.getServerHandler().playerEntity.worldObj;
  mainThread.addScheduledTask(() -> {
    for (    final IIngredient ingredient : recipe.getInput()) {
      int quantityToConsume=ingredient.getQuantityConsumed();
      final ImmutableList<ItemStack> itemStacks=ingredient.getItemStacks();
      for (      final ItemStack itemStack : itemStacks) {
        int metadata=itemStack.getMetadata();
        metadata=metadata == OreDictionary.WILDCARD_VALUE ? -1 : metadata;
        quantityToConsume-=playerInventory.clearMatchingItems(itemStack.getItem(),metadata,quantityToConsume,itemStack.getTagCompound());
        playerInventory.markDirty();
        if (quantityToConsume <= 0) {
          break;
        }
      }
    }
    for (    final ItemStack itemStack : recipe.getOutput()) {
      final ItemStack copy=itemStack.copy();
      if (!playerInventory.addItemStackToInventory(copy)) {
        ctx.getServerHandler().playerEntity.dropItem(copy,true);
      }
 else {
        playerInventory.markDirty();
      }
    }
  }
);
  return null;
}"
12548,"@Override public void serialize(IIngredient ingredient,PacketBuffer buffer){
  if (!(ingredient instanceof ItemStackIngredient))   throw new SteamNSteelException(""String_Node_Str"");
  final ItemStackIngredient itemStackIngredient=(ItemStackIngredient)ingredient;
  buffer.writeItemStackToBuffer(itemStackIngredient.getItemStack());
}","@Override public void serialize(IIngredient ingredient,PacketBuffer buffer){
  if (!(ingredient instanceof ItemStackIngredient))   throw new SteamNSteelException(""String_Node_Str"");
  final ItemStackIngredient itemStackIngredient=(ItemStackIngredient)ingredient;
  PacketBufferExtensions.writeLargeItemStackToBuffer(buffer,itemStackIngredient.getItemStack());
}"
12549,"@Override public IIngredient deserialize(PacketBuffer buffer){
  try {
    return new ItemStackIngredient(buffer.readItemStackFromBuffer());
  }
 catch (  IOException e) {
    throw new SteamNSteelException(e);
  }
}","@Override public IIngredient deserialize(PacketBuffer buffer){
  try {
    return new ItemStackIngredient(PacketBufferExtensions.readLargeItemStackFromBuffer(buffer));
  }
 catch (  IOException e) {
    throw new SteamNSteelException(e);
  }
}"
12550,"@Override public StructureDefinitionBuilder getStructureBuild(){
  final StructureDefinitionBuilder builder=new StructureDefinitionBuilder();
  builder.assignConstructionDef(ImmutableMap.of('c',""String_Node_Str"",'s',""String_Node_Str""));
  builder.assignConstructionBlocks(new String[]{""String_Node_Str""},new String[]{""String_Node_Str""},new String[]{""String_Node_Str""});
  builder.assignToolFormPosition(BlockPosUtil.of(1,1,0));
  builder.setConfiguration(BlockPosUtil.of(0,0,0),new String[]{""String_Node_Str""},new String[]{""String_Node_Str""},new String[]{""String_Node_Str""});
  builder.setCollisionBoxes(new float[]{0.0f,0.0f,0.0f,3.0f,3.0f,1.0f});
  return builder;
}","@Override public StructureDefinitionBuilder getStructureBuild(){
  final StructureDefinitionBuilder builder=new StructureDefinitionBuilder();
  builder.assignConstructionDef(ImmutableMap.of('c',""String_Node_Str"",'s',""String_Node_Str""));
  builder.assignConstructionBlocks(new String[]{""String_Node_Str""},new String[]{""String_Node_Str""},new String[]{""String_Node_Str""});
  builder.assignToolFormPosition(BlockPosUtil.of(1,1,0));
  builder.setConfiguration(BlockPosUtil.of(0,0,0),new String[]{""String_Node_Str""},new String[]{""String_Node_Str""},new String[]{""String_Node_Str""});
  builder.setCollisionBoxes(new float[]{0.0f,0.0f,0.0f,3.0f,0.19f,1.0f},new float[]{0.0f,2.81f,0.0f,3.0f,3.0f,1.0f},new float[]{0.0f,0.0f,0.0f,0.19f,3.0f,1.0f},new float[]{2.81f,0.0f,0.0f,3.0f,3.0f,1.0f},new float[]{0.0f,0.0f,0.0f,0.5f,0.5f,1.0f},new float[]{2.5f,0.0f,0.0f,3.0f,0.5f,1.0f},new float[]{0.0f,2.5f,0.0f,0.5f,3.0f,1.0f},new float[]{2.5f,2.5f,0.0f,3.0f,3.0f,1.0f},new float[]{0.0f,0.0f,0.21f,3.0f,3.0f,0.29f});
  return builder;
}"
12551,"public static void init(){
  GameRegistry.registerBlock(remnantRuinChest,RemnantRuinChestBlock.NAME);
  GameRegistry.registerBlock(craftingStation,CraftingStationBlock.NAME);
  GameRegistry.registerBlock(cupola,CupolaBlock.NAME);
  GameRegistry.registerBlock(structureShape,SteamNSteelStructureShapeBlock.NAME);
  registerStructure(ssBallMill,structureShape,SSBallMillStructure.NAME);
  registerStructure(ssBlastFurnace,structureShape,SSBlastFurnaceStructure.NAME);
  registerStructure(ssBoiler,structureShape,SSBoilerStructure.NAME);
  registerStructure(fanLarge,structureShape,FanLargeStructure.NAME);
  GameRegistry.registerBlock(pipe,PipeBlock.NAME);
  GameRegistry.registerBlock(pipeValve,PipeValveBlock.NAME);
  GameRegistry.registerBlock(pipeValveRedstone,PipeRedstoneValveBlock.NAME);
  GameRegistry.registerBlock(pipeJunction,PipeJunctionBlock.NAME);
  registerBlockAndOre(oreNiter,NiterOre.NAME);
  registerBlockAndOre(oreCopper,CopperOre.NAME);
  registerBlockAndOre(oreSulfur,SulfurOre.NAME);
  registerBlockAndOre(oreTin,TinOre.NAME);
  registerBlockAndOre(oreZinc,ZincOre.NAME);
  registerBlockAndOre(blockBrass,SteamNSteelStorageBlock.BRASS_BLOCK);
  registerBlockAndOre(blockBronze,SteamNSteelStorageBlock.BRONZE_BLOCK);
  registerBlockAndOre(blockCopper,SteamNSteelStorageBlock.COPPER_BLOCK);
  registerBlockAndOre(blockPlotonium,SteamNSteelStorageBlock.PLOTONIUM_BLOCK);
  registerBlockAndOre(blockSteel,SteamNSteelStorageBlock.STEEL_BLOCK);
  registerBlockAndOre(blockTin,SteamNSteelStorageBlock.TIN_BLOCK);
  registerBlockAndOre(blockZinc,SteamNSteelStorageBlock.ZINC_BLOCK);
  GameRegistry.registerBlock(remnantRuinPillar,RemnantRuinPillarBlock.NAME);
  GameRegistry.registerBlock(remnantRuinFloor,RemnantRuinFloorBlock.NAME);
  GameRegistry.registerBlock(remnantRuinWall,RemnantRuinWallBlock.NAME);
  GameRegistry.registerBlock(remnantRuinIronBars,RemnantRuinIronBarsBlockItem.class,RemnantRuinIronBarsBlock.NAME);
  GameRegistry.registerBlock(blockConcrete,ConcreteBlockItem.class,ConcreteBlock.NAME);
  TileEntity.addMapping(RemnantRuinChestTE.class,""String_Node_Str"");
}","public static void init(){
  GameRegistry.registerBlock(remnantRuinChest,RemnantRuinChestBlock.NAME);
  GameRegistry.registerBlock(craftingStation,CraftingStationBlock.NAME);
  GameRegistry.registerBlock(cupola,CupolaBlock.NAME);
  GameRegistry.registerBlock(structureShape,SteamNSteelStructureShapeBlock.NAME);
  GameRegistry.registerBlock(shapeLI,ShapeLIBlock.NAME);
  registerStructure(ssBallMill,shapeLI,SSBallMillStructure.NAME);
  registerStructure(ssBlastFurnace,shapeLI,SSBlastFurnaceStructure.NAME);
  registerStructure(ssBoiler,shapeLI,SSBoilerStructure.NAME);
  registerStructure(fanLarge,structureShape,FanLargeStructure.NAME);
  GameRegistry.registerBlock(pipe,PipeBlock.NAME);
  GameRegistry.registerBlock(pipeValve,PipeValveBlock.NAME);
  GameRegistry.registerBlock(pipeValveRedstone,PipeRedstoneValveBlock.NAME);
  GameRegistry.registerBlock(pipeJunction,PipeJunctionBlock.NAME);
  registerBlockAndOre(oreNiter,NiterOre.NAME);
  registerBlockAndOre(oreCopper,CopperOre.NAME);
  registerBlockAndOre(oreSulfur,SulfurOre.NAME);
  registerBlockAndOre(oreTin,TinOre.NAME);
  registerBlockAndOre(oreZinc,ZincOre.NAME);
  registerBlockAndOre(blockBrass,SteamNSteelStorageBlock.BRASS_BLOCK);
  registerBlockAndOre(blockBronze,SteamNSteelStorageBlock.BRONZE_BLOCK);
  registerBlockAndOre(blockCopper,SteamNSteelStorageBlock.COPPER_BLOCK);
  registerBlockAndOre(blockPlotonium,SteamNSteelStorageBlock.PLOTONIUM_BLOCK);
  registerBlockAndOre(blockSteel,SteamNSteelStorageBlock.STEEL_BLOCK);
  registerBlockAndOre(blockTin,SteamNSteelStorageBlock.TIN_BLOCK);
  registerBlockAndOre(blockZinc,SteamNSteelStorageBlock.ZINC_BLOCK);
  GameRegistry.registerBlock(remnantRuinPillar,RemnantRuinPillarBlock.NAME);
  GameRegistry.registerBlock(remnantRuinFloor,RemnantRuinFloorBlock.NAME);
  GameRegistry.registerBlock(remnantRuinWall,RemnantRuinWallBlock.NAME);
  GameRegistry.registerBlock(remnantRuinIronBars,RemnantRuinIronBarsBlockItem.class,RemnantRuinIronBarsBlock.NAME);
  GameRegistry.registerBlock(blockConcrete,ConcreteBlockItem.class,ConcreteBlock.NAME);
  TileEntity.addMapping(RemnantRuinChestTE.class,""String_Node_Str"");
}"
12552,"public static void registerTileEntities(){
  GameRegistry.registerTileEntity(RemnantRuinChestTE.class,getTEName(RemnantRuinChestBlock.NAME));
  GameRegistry.registerTileEntity(CupolaTE.class,getTEName(CupolaBlock.NAME));
  GameRegistry.registerTileEntity(SteamNSteelStructureShapeTE.class,getTEName(SteamNSteelStructureShapeBlock.NAME));
  GameRegistry.registerTileEntity(BallMillTE.class,getTEName(SSBallMillStructure.NAME));
  GameRegistry.registerTileEntity(LargeFanTE.class,getTEName(FanLargeStructure.NAME));
  GameRegistry.registerTileEntity(BlastFurnaceTE.class,getTEName(SSBlastFurnaceStructure.NAME));
  GameRegistry.registerTileEntity(BoilerTE.class,getTEName(SSBoilerStructure.NAME));
  GameRegistry.registerTileEntity(PipeTE.class,getTEName(PipeBlock.NAME));
  GameRegistry.registerTileEntity(PipeValveTE.class,getTEName(PipeValveBlock.NAME));
  GameRegistry.registerTileEntity(PipeRedstoneValveTE.class,getTEName(PipeRedstoneValveBlock.NAME));
  GameRegistry.registerTileEntity(PipeJunctionTE.class,getTEName(PipeJunctionBlock.NAME));
  GameRegistry.registerTileEntity(RemnantRuinPillarTE.class,getTEName(RemnantRuinPillarBlock.NAME));
}","public static void registerTileEntities(){
  GameRegistry.registerTileEntity(RemnantRuinChestTE.class,getTEName(RemnantRuinChestBlock.NAME));
  GameRegistry.registerTileEntity(CupolaTE.class,getTEName(CupolaBlock.NAME));
  GameRegistry.registerTileEntity(SteamNSteelStructureShapeTE.class,getTEName(SteamNSteelStructureShapeBlock.NAME));
  GameRegistry.registerTileEntity(ShapeLITE.class,getTEName(ShapeLIBlock.NAME));
  GameRegistry.registerTileEntity(BallMillTE.class,getTEName(SSBallMillStructure.NAME));
  GameRegistry.registerTileEntity(LargeFanTE.class,getTEName(FanLargeStructure.NAME));
  GameRegistry.registerTileEntity(BlastFurnaceTE.class,getTEName(SSBlastFurnaceStructure.NAME));
  GameRegistry.registerTileEntity(BoilerTE.class,getTEName(SSBoilerStructure.NAME));
  GameRegistry.registerTileEntity(PipeTE.class,getTEName(PipeBlock.NAME));
  GameRegistry.registerTileEntity(PipeValveTE.class,getTEName(PipeValveBlock.NAME));
  GameRegistry.registerTileEntity(PipeRedstoneValveTE.class,getTEName(PipeRedstoneValveBlock.NAME));
  GameRegistry.registerTileEntity(PipeJunctionTE.class,getTEName(PipeJunctionBlock.NAME));
  GameRegistry.registerTileEntity(RemnantRuinPillarTE.class,getTEName(RemnantRuinPillarBlock.NAME));
}"
12553,"@Override public int[] getSlotsForStructureFace(EnumFacing side,BlockPos local){
  return LOCATION_MATERIAL_INPUT.equals(local) ? slotsMaterialInput : slotsDefault;
}","@Override public int[] getSlotsForStructureFace(EnumFacing side,BlockPos local){
  return globalLocationMaterialInput.equals(local) ? slotsMaterialInput : slotsDefault;
}"
12554,"@Override public boolean canStructureInsertItem(int slot,ItemStack item,EnumFacing side,BlockPos local){
  return isSide(globalDirectionsMaterialInput,side) && local.equals(LOCATION_MATERIAL_INPUT) && isItemValidForSlot(slot,item);
}","@Override public boolean canStructureInsertItem(int slot,ItemStack item,EnumFacing side,BlockPos local){
  return isSide(globalDirectionsMaterialInput,side) && local.equals(globalLocationMaterialInput) && isItemValidForSlot(slot,item);
}"
12555,"public void renderSchematicToSingleChunk(ResourceLocation resource,World world,BlockPos origin,int chunkX,int chunkZ,EnumFacing rotation,boolean flip){
  if (rotation == EnumFacing.DOWN || rotation == EnumFacing.UP) {
    _logger.error(""String_Node_Str"",resource,rotation);
    return;
  }
  SchematicWorld schematic=loadedSchematics.get(resource);
  if (schematic == null) {
    _logger.error(""String_Node_Str"",resource);
    return;
  }
  final int minX=origin.getX();
  final int maxX=minX + schematic.getWidth();
  final int minY=origin.getY();
  final int maxY=minY + schematic.getHeight();
  final int minZ=origin.getZ();
  final int maxZ=minZ + schematic.getLength();
  final int localMinX=minX < (chunkX << 4) ? 0 : (minX & 15);
  final int localMaxX=maxX > ((chunkX << 4) + 15) ? 15 : (maxX & 15);
  final int localMinZ=minZ < (chunkZ << 4) ? 0 : (minZ & 15);
  final int localMaxZ=maxZ > ((chunkZ << 4) + 15) ? 15 : (maxZ & 15);
  Chunk c=world.getChunkFromChunkCoords(chunkX,chunkZ);
  int blockCount=0;
  Block ignore=Blocks.air;
  LinkedList<TileEntity> createdTileEntities=new LinkedList<TileEntity>();
  for (int chunkLocalZ=localMinZ; chunkLocalZ <= localMaxZ; chunkLocalZ++) {
    for (int y=minY; y < maxY; y++) {
      for (int chunkLocalX=localMinX; chunkLocalX <= localMaxX; chunkLocalX++) {
        ++blockCount;
        final int x=chunkLocalX | (chunkX << 4);
        final int z=chunkLocalZ | (chunkZ << 4);
        final int schematicX=x - minX;
        final int schematicY=y - minY;
        final int schematicZ=z - minZ;
        try {
          BlockPos worldCoord=new BlockPos(x,y,z);
          BlockPos schematicCoord=new BlockPos(schematicX,schematicY,schematicZ);
          PreSetBlockEvent event=new PreSetBlockEvent(schematic,world,worldCoord,schematicCoord);
          if (setBlockEventListeners != null) {
            for (            final IPreSetBlockEventListener listener : setBlockEventListeners) {
              listener.preBlockSet(event);
            }
          }
          if (event.blockState != null && c.setBlockState(worldCoord,event.blockState) != null) {
            world.markBlockForUpdate(new BlockPos(x,y,z));
            final NBTTagCompound tileEntityData=schematic.getTileEntity(schematicCoord);
            final Block block=event.blockState.getBlock();
            if (block.hasTileEntity(event.blockState) && tileEntityData != null) {
              TileEntity tileEntity=TileEntity.createAndLoadEntity(tileEntityData);
              c.addTileEntity(new BlockPos(chunkLocalX,y,chunkLocalZ),tileEntity);
              tileEntity.getBlockType();
              try {
                tileEntity.validate();
              }
 catch (              Exception e) {
                _logger.error(String.format(""String_Node_Str"",tileEntity.getClass()),e);
              }
              createdTileEntities.add(tileEntity);
            }
          }
        }
 catch (        Exception e) {
          _logger.error(""String_Node_Str"",e);
        }
      }
    }
  }
  for (  final TileEntity tileEntity : createdTileEntities) {
    for (    ITileEntityLoadedEvent tileEntityHandler : tileEntityLoadedEventListeners) {
      if (tileEntityHandler.onTileEntityAdded(tileEntity)) {
        break;
      }
    }
  }
  c.enqueueRelightChecks();
  c.setChunkModified();
}","public void renderSchematicToSingleChunk(ResourceLocation resource,World world,BlockPos origin,int chunkX,int chunkZ,EnumFacing rotation,boolean flip){
  if (rotation == EnumFacing.DOWN || rotation == EnumFacing.UP) {
    _logger.error(""String_Node_Str"",resource,rotation);
    return;
  }
  SchematicWorld schematic=loadedSchematics.get(resource);
  if (schematic == null) {
    _logger.error(""String_Node_Str"",resource);
    return;
  }
  final int minX=origin.getX();
  final int maxX=minX + schematic.getWidth();
  final int minY=origin.getY();
  final int maxY=minY + schematic.getHeight();
  final int minZ=origin.getZ();
  final int maxZ=minZ + schematic.getLength();
  final int localMinX=minX < (chunkX << 4) ? 0 : (minX & 15);
  final int localMaxX=maxX > ((chunkX << 4) + 15) ? 15 : (maxX & 15);
  final int localMinZ=minZ < (chunkZ << 4) ? 0 : (minZ & 15);
  final int localMaxZ=maxZ > ((chunkZ << 4) + 15) ? 15 : (maxZ & 15);
  Chunk c=world.getChunkFromChunkCoords(chunkX,chunkZ);
  int blockCount=0;
  Block ignore=Blocks.air;
  LinkedList<TileEntity> createdTileEntities=new LinkedList<TileEntity>();
  for (int chunkLocalZ=localMinZ; chunkLocalZ <= localMaxZ; chunkLocalZ++) {
    for (int y=minY; y < maxY; y++) {
      for (int chunkLocalX=localMinX; chunkLocalX <= localMaxX; chunkLocalX++) {
        ++blockCount;
        final int x=chunkLocalX | (chunkX << 4);
        final int z=chunkLocalZ | (chunkZ << 4);
        final int schematicX=x - minX;
        final int schematicY=y - minY;
        final int schematicZ=z - minZ;
        try {
          BlockPos worldCoord=new BlockPos(x,y,z);
          BlockPos schematicCoord=new BlockPos(schematicX,schematicY,schematicZ);
          PreSetBlockEvent event=new PreSetBlockEvent(schematic,world,worldCoord,schematicCoord);
          if (event.blockState != null && setBlockEventListeners != null) {
            for (            final IPreSetBlockEventListener listener : setBlockEventListeners) {
              listener.preBlockSet(event);
            }
          }
          if (event.shouldSetBlock() && event.blockState != null && c.setBlockState(worldCoord,event.blockState) != null) {
            world.markBlockForUpdate(new BlockPos(x,y,z));
            final NBTTagCompound tileEntityData=schematic.getTileEntity(schematicCoord);
            final Block block=event.blockState.getBlock();
            if (block.hasTileEntity(event.blockState) && tileEntityData != null) {
              TileEntity tileEntity=TileEntity.createAndLoadEntity(tileEntityData);
              c.addTileEntity(new BlockPos(chunkLocalX,y,chunkLocalZ),tileEntity);
              tileEntity.getBlockType();
              try {
                tileEntity.validate();
              }
 catch (              Exception e) {
                _logger.error(String.format(""String_Node_Str"",tileEntity.getClass()),e);
              }
              createdTileEntities.add(tileEntity);
            }
          }
        }
 catch (        Exception e) {
          _logger.error(""String_Node_Str"",e);
        }
      }
    }
  }
  for (  final TileEntity tileEntity : createdTileEntities) {
    for (    ITileEntityLoadedEvent tileEntityHandler : tileEntityLoadedEventListeners) {
      if (tileEntityHandler.onTileEntityAdded(tileEntity)) {
        break;
      }
    }
  }
  c.enqueueRelightChecks();
  c.setChunkModified();
}"
12556,"public IBlockState getBlockState(BlockPos pos){
  int x=pos.getX();
  int y=pos.getY();
  int z=pos.getZ();
  if (x < 0 || y < 0 || z < 0 || x >= this.width || y >= this.height || z >= this.length) {
    return null;
  }
  int index=x + (y * length + z) * width;
  int metadata=this.metadata[index];
  final short blockId=this.blocks[index];
  Block block=BLOCK_REGISTRY.getRaw(blockId);
  if (block == null) {
    return null;
  }
  return block.getStateFromMeta(metadata);
}","public IBlockState getBlockState(){
  return blockState;
}"
12557,"public IBlockState getBlockState(BlockPos pos){
  int x=pos.getX();
  int y=pos.getY();
  int z=pos.getZ();
  if (x < 0 || y < 0 || z < 0 || x >= this.width || y >= this.height || z >= this.length) {
    return null;
  }
  int index=x + (y * length + z) * width;
  int metadata=this.metadata[index];
  final short blockId=this.blocks[index];
  Block block=BLOCK_REGISTRY.getObjectById(blockId);
  if (block == null) {
    return null;
  }
  return block.getStateFromMeta(metadata);
}","public IBlockState getBlockState(BlockPos pos){
  int x=pos.getX();
  int y=pos.getY();
  int z=pos.getZ();
  if (x < 0 || y < 0 || z < 0 || x >= this.width || y >= this.height || z >= this.length) {
    return null;
  }
  int index=x + (y * length + z) * width;
  int metadata=this.metadata[index];
  final short blockId=this.blocks[index];
  Block block=BLOCK_REGISTRY.getRaw(blockId);
  if (block == null) {
    return null;
  }
  return block.getStateFromMeta(metadata);
}"
12558,"private void craftRecipe(ProjectTableRecipe recipe){
  boolean canCraft=true;
  for (  final ItemStack recipeInput : recipe.getInput()) {
    boolean itemMatched=false;
    for (    final ItemStack playerItem : usableItems) {
      if (recipeInput.isItemEqual(playerItem)) {
        itemMatched=true;
        if (recipeInput.stackSize > playerItem.stackSize) {
          canCraft=false;
        }
      }
    }
    if (!itemMatched) {
      canCraft=false;
    }
  }
  if (canCraft) {
    Proxies.network.getNetwork().sendToServer(new ProjectTableCraftPacket(recipe));
    processPlayerInventory();
  }
}","private void craftRecipe(ProjectTableRecipe recipe){
  Proxies.network.getNetwork().sendToServer(new ProjectTableCraftPacket(recipe));
}"
12559,"@Override protected void drawGuiContainerBackgroundLayer(float partialTicks,int mouseX,int mouseY){
  super.drawGuiContainerBackgroundLayer(partialTicks,mouseX,mouseY);
  searchField.drawTextBox();
}","@Override protected void drawGuiContainerBackgroundLayer(float partialTicks,int mouseX,int mouseY){
  super.drawGuiContainerBackgroundLayer(partialTicks,mouseX,mouseY);
  searchField.drawTextBox();
  guiRenderer.notifyTextureChanged();
}"
12560,"@Override public void initGui(){
  xSize=176;
  ySize=227;
  super.initGui();
  recipeList=Lists.newArrayList(new ProjectTableRecipe(new ItemStack(ModBlock.blockSteel,1),new ItemStack(ModItem.ingotSteel,15)),new ProjectTableRecipe(new ItemStack(Items.diamond,10),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64)),new ProjectTableRecipe(new ItemStack(Items.diamond,1),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64)),new ProjectTableRecipe(new ItemStack(Items.diamond,1),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64)),new ProjectTableRecipe(new ItemStack(Items.diamond,1),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64)),new ProjectTableRecipe(new ItemStack(Items.diamond,1),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64)),new ProjectTableRecipe(new ItemStack(Items.diamond,1),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64)));
  filteredList=Lists.newArrayList(recipeList);
  searchField=new GuiTextField(0,fontRendererObj,guiLeft + 9,guiTop + 9,151,fontRendererObj.FONT_HEIGHT);
  searchField.setMaxStringLength(60);
  searchField.setEnableBackgroundDrawing(false);
  searchField.setVisible(true);
  searchField.setTextColor(16777215);
  searchField.setFocused(true);
  createComponents();
  processPlayerInventory();
  setRecipeRenderText();
}","@Override public void initGui(){
  xSize=176;
  ySize=227;
  super.initGui();
  recipeList=Lists.newArrayList(new ProjectTableRecipe(new ItemStack(ModBlock.blockSteel,1),new ItemStack(ModItem.ingotSteel,15)),new ProjectTableRecipe(new ItemStack(Items.diamond,10),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64)),new ProjectTableRecipe(new ItemStack(Items.gold_nugget,1),new ItemStack(Blocks.gold_block,64),new ItemStack(Blocks.gold_ore,64),new ItemStack(Blocks.beacon,64),new ItemStack(Blocks.brown_mushroom_block,64)),new ProjectTableRecipe(new ItemStack(Items.diamond,1),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64)),new ProjectTableRecipe(new ItemStack(Items.diamond,1),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64)),new ProjectTableRecipe(new ItemStack(Items.diamond,1),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64)),new ProjectTableRecipe(new ItemStack(Items.diamond,1),new ItemStack(Blocks.dirt,64),new ItemStack(Blocks.dirt,64)));
  filteredList=Lists.newArrayList(recipeList);
  searchField=new GuiTextField(0,fontRendererObj,guiLeft + 9,guiTop + 9,151,fontRendererObj.FONT_HEIGHT);
  searchField.setMaxStringLength(60);
  searchField.setEnableBackgroundDrawing(false);
  searchField.setVisible(true);
  searchField.setTextColor(16777215);
  searchField.setFocused(true);
  createComponents();
  processPlayerInventory();
  setRecipeRenderText();
}"
12561,"protected void createComponents(){
  final GuiRenderer guiRenderer=new GuiRenderer(mc,mc.getTextureManager(),fontRendererObj,itemRender);
  final GuiSubTexture guiBackground=new GuiSubTexture(TEXTURE,new Rectangle(0,0,176,227));
  final GuiTexture inactiveHandle=new GuiSubTexture(TEXTURE,new Rectangle(176,0,12,15));
  final GuiTexture activeHandle=new GuiSubTexture(TEXTURE,new Rectangle(176 + 12,0,12,15));
  final GuiTexture craftableSubtexture=new GuiSubTexture(TEXTURE,new Rectangle(0,227,142,23));
  final GuiTexture uncraftableSubtexture=new GuiSubTexture(TEXTURE,new Rectangle(0,227 + 23,142,23));
  setRootControl(new TexturedPaneControl(guiRenderer,176,227,guiBackground));
  scrollbarGuiComponent=new ScrollbarControl(guiRenderer,activeHandle,inactiveHandle);
  scrollbarGuiComponent.setLocation(156,24);
  scrollbarGuiComponent.setSize(20,115);
  final ProjectTableRecipeControl templateRecipeControl=new ProjectTableRecipeControl(guiRenderer,craftableSubtexture,uncraftableSubtexture);
  recipeListGuiComponent=new ScrollPaneControl<ProjectTableRecipe,ProjectTableRecipeControl>(guiRenderer,141,23 * 5).setScrollbar(scrollbarGuiComponent).setItemRendererTemplate(templateRecipeControl).setVisibleItemCount(5).setItems(filteredList);
  recipeListGuiComponent.setLocation(8,24);
  addChild(recipeListGuiComponent);
  addChild(scrollbarGuiComponent);
  templateRecipeControl.addOnRecipeCraftingEventListener(new RecipeCraftingEventListener());
}","protected void createComponents(){
  guiRenderer=new GuiRenderer(mc,mc.getTextureManager(),fontRendererObj,itemRender);
  final GuiSubTexture guiBackground=new GuiSubTexture(TEXTURE,new Rectangle(0,0,176,227));
  final GuiTexture inactiveHandle=new GuiSubTexture(TEXTURE,new Rectangle(176,0,12,15));
  final GuiTexture activeHandle=new GuiSubTexture(TEXTURE,new Rectangle(176 + 12,0,12,15));
  final GuiTexture craftableSubtexture=new GuiSubTexture(TEXTURE,new Rectangle(0,227,142,23));
  final GuiTexture uncraftableSubtexture=new GuiSubTexture(TEXTURE,new Rectangle(0,227 + 23,142,23));
  setRootControl(new TexturedPaneControl(guiRenderer,176,227,guiBackground));
  scrollbarGuiComponent=new ScrollbarControl(guiRenderer,activeHandle,inactiveHandle);
  scrollbarGuiComponent.setLocation(156,24);
  scrollbarGuiComponent.setSize(20,115);
  final ProjectTableRecipeControl templateRecipeControl=new ProjectTableRecipeControl(guiRenderer,craftableSubtexture,uncraftableSubtexture);
  recipeListGuiComponent=new ScrollPaneControl<ProjectTableRecipe,ProjectTableRecipeControl>(guiRenderer,141,23 * 5).setScrollbar(scrollbarGuiComponent).setItemRendererTemplate(templateRecipeControl).setVisibleItemCount(5).setItems(filteredList);
  recipeListGuiComponent.setLocation(8,24);
  addChild(recipeListGuiComponent);
  addChild(scrollbarGuiComponent);
  templateRecipeControl.addOnRecipeCraftingEventListener(new RecipeCraftingEventListener());
}"
12562,"@Override public void draw(){
  if (recipe == null) {
    return;
  }
  guiRenderer.drawComponentTexture(this,craftableTexture);
  GlStateManager.enableRescaleNormal();
  final ImmutableList<ItemStack> output=recipe.getOutput();
  final ItemStack outputItemStack=output.get(0);
  if (output.size() == 1 && outputItemStack.getItem() != null) {
    RenderHelper.enableGUIStandardItemLighting();
    guiRenderer.renderItem(this,outputItemStack,2,3);
    RenderHelper.disableStandardItemLighting();
    if (outputItemStack.stackSize > 1) {
      final String craftedItemCount=String.format(""String_Node_Str"",outputItemStack.stackSize);
      final int textWidth=guiRenderer.getStringWidth(craftedItemCount);
      GlStateManager.depthFunc(GL11.GL_ALWAYS);
      guiRenderer.drawStringWithShadow(this,craftedItemCount,16 - textWidth + 2,12,16777215);
      GlStateManager.depthFunc(GL11.GL_LEQUAL);
    }
    guiRenderer.drawStringWithShadow(this,recipe.getDisplayName(),2 + 20,8,16777215);
  }
  final int inputItemCount=recipe.getInput().size();
  for (int j=0; j < inputItemCount; ++j) {
    final ItemStack inputItemStack=recipe.getInput().get(j);
    final String requiredItemCount=String.format(""String_Node_Str"",inputItemStack.stackSize);
    final int textWidth=guiRenderer.getStringWidth(requiredItemCount);
    final int border=1;
    final int padding=2;
    final int itemSize=16;
    guiRenderer.renderItem(this,inputItemStack,getBounds().getWidth() - border - (itemSize + padding) * (j + border),padding + border);
    GlStateManager.depthFunc(GL11.GL_ALWAYS);
    guiRenderer.drawStringWithShadow(this,requiredItemCount,getBounds().getWidth() - border - (itemSize + padding) * j - textWidth - border,12,16777215);
    GlStateManager.depthFunc(GL11.GL_LEQUAL);
  }
  GlStateManager.disableRescaleNormal();
}","@Override public void draw(){
  if (recipe == null) {
    return;
  }
  super.draw();
  GlStateManager.enableRescaleNormal();
  final ImmutableList<ItemStack> output=recipe.getOutput();
  final ItemStack outputItemStack=output.get(0);
  if (output.size() == 1 && outputItemStack.getItem() != null) {
    RenderHelper.enableGUIStandardItemLighting();
    guiRenderer.renderItem(this,outputItemStack,2,3);
    RenderHelper.disableStandardItemLighting();
    if (outputItemStack.stackSize > 1) {
      final String craftedItemCount=String.format(""String_Node_Str"",outputItemStack.stackSize);
      final int textWidth=guiRenderer.getStringWidth(craftedItemCount);
      GlStateManager.depthFunc(GL11.GL_ALWAYS);
      guiRenderer.drawStringWithShadow(this,craftedItemCount,16 - textWidth + 2,12,16777215);
      GlStateManager.depthFunc(GL11.GL_LEQUAL);
    }
    guiRenderer.drawStringWithShadow(this,recipe.getDisplayName(),2 + 20,8,16777215);
  }
  final int inputItemCount=recipe.getConsolidatedInput().size();
  for (int j=0; j < inputItemCount; ++j) {
    final ItemStack inputItemStack=recipe.getConsolidatedInput().get(j);
    final String requiredItemCount=String.format(""String_Node_Str"",inputItemStack.stackSize);
    final int textWidth=guiRenderer.getStringWidth(requiredItemCount);
    final int border=1;
    final int padding=2;
    final int itemSize=16;
    guiRenderer.renderItem(this,inputItemStack,getBounds().getWidth() - border - (itemSize + padding) * (j + border),padding + border);
    GlStateManager.depthFunc(GL11.GL_ALWAYS);
    guiRenderer.drawStringWithShadow(this,requiredItemCount,getBounds().getWidth() - border - (itemSize + padding) * j - textWidth - border,12,16777215);
    GlStateManager.depthFunc(GL11.GL_LEQUAL);
  }
  GlStateManager.disableRescaleNormal();
}"
12563,"public ProjectTableRecipeControl(GuiRenderer guiRenderer,GuiTexture craftableTexture,GuiTexture uncraftableTexture){
  super(guiRenderer,new Rectangle(0,0,craftableTexture.getBounds().getWidth(),craftableTexture.getBounds().getHeight()));
  this.craftableTexture=craftableTexture;
  this.uncraftableTexture=uncraftableTexture;
}","public ProjectTableRecipeControl(GuiRenderer guiRenderer,GuiTexture craftableTexture,GuiTexture uncraftableTexture){
  super(guiRenderer,new Rectangle(0,0,craftableTexture.getBounds().getWidth(),craftableTexture.getBounds().getHeight()));
  this.craftableTexture=craftableTexture;
  this.uncraftableTexture=uncraftableTexture;
  setDefaultTexture(craftableTexture);
  setDisabledTexture(uncraftableTexture);
  setHoverTexture(craftableTexture);
  setPressedTexture(uncraftableTexture);
}"
12564,"@Override public IMessage onMessage(ProjectTableCraftPacket message,MessageContext ctx){
  InventoryPlayer playerInventory=ctx.getServerHandler().playerEntity.inventory;
  ProjectTableRecipe recipe=message.getRecipe();
  for (  final ItemStack itemStack : recipe.getInput()) {
    playerInventory.clearMatchingItems(itemStack.getItem(),itemStack.getMetadata(),itemStack.stackSize,itemStack.getTagCompound());
    playerInventory.markDirty();
  }
  for (  final ItemStack itemStack : recipe.getOutput()) {
    ItemStack copy=itemStack.copy();
    if (!playerInventory.addItemStackToInventory(copy)) {
    }
 else {
      playerInventory.markDirty();
    }
  }
  return null;
}","@Override public IMessage onMessage(final ProjectTableCraftPacket message,final MessageContext ctx){
  final InventoryPlayer playerInventory=ctx.getServerHandler().playerEntity.inventory;
  final ProjectTableRecipe recipe=message.getRecipe();
  final List<ItemStack> compactedInventoryItems=getCompactedInventoryItems(playerInventory);
  boolean canCraft=true;
  for (  final ItemStack recipeInput : recipe.getConsolidatedInput()) {
    boolean itemMatched=false;
    for (    final ItemStack playerItem : compactedInventoryItems) {
      if (recipeInput.getItem() == playerItem.getItem() && recipeInput.getMetadata() == playerItem.getMetadata() && ItemStack.areItemStackTagsEqual(recipeInput,playerItem)) {
        itemMatched=true;
        if (recipeInput.stackSize > playerItem.stackSize) {
          canCraft=false;
        }
      }
    }
    if (!itemMatched) {
      canCraft=false;
    }
  }
  if (!canCraft) {
    return null;
  }
  IThreadListener mainThread=(WorldServer)ctx.getServerHandler().playerEntity.worldObj;
  mainThread.addScheduledTask(new Runnable(){
    @Override public void run(){
      for (      final ItemStack itemStack : recipe.getInput()) {
        playerInventory.clearMatchingItems(itemStack.getItem(),itemStack.getMetadata(),itemStack.stackSize,itemStack.getTagCompound());
        playerInventory.markDirty();
      }
      for (      final ItemStack itemStack : recipe.getOutput()) {
        ItemStack copy=itemStack.copy();
        if (!playerInventory.addItemStackToInventory(copy)) {
          ctx.getServerHandler().playerEntity.dropPlayerItemWithRandomChoice(copy,true);
        }
 else {
          playerInventory.markDirty();
        }
      }
    }
  }
);
  return null;
}"
12565,"public void renderSchematicToSingleChunk(ResourceLocation resource,World world,int originX,int originY,int originZ,int chunkX,int chunkZ,ForgeDirection rotation,boolean flip){
  if (rotation == ForgeDirection.DOWN || rotation == ForgeDirection.UP) {
    _logger.error(""String_Node_Str"",resource,rotation);
    return;
  }
  SchematicWorld schematic=loadedSchematics.get(resource);
  if (schematic == null) {
    _logger.error(""String_Node_Str"",resource);
    return;
  }
  _logger.info(String.format(""String_Node_Str"",System.currentTimeMillis(),chunkX,chunkZ));
  final int minX=originX;
  final int maxX=originX + schematic.getWidth();
  final int minY=originY;
  final int maxY=originY + schematic.getHeight();
  final int minZ=originZ;
  final int maxZ=originZ + schematic.getLength();
  final int localMinX=minX < (chunkX << 4) ? 0 : (minX & 15);
  final int localMaxX=maxX > ((chunkX << 4) + 15) ? 15 : (maxX & 15);
  final int localMinZ=minZ < (chunkZ << 4) ? 0 : (minZ & 15);
  final int localMaxZ=maxZ > ((chunkZ << 4) + 15) ? 15 : (maxZ & 15);
  Chunk c=world.getChunkFromChunkCoords(chunkX,chunkZ);
  int blockCount=0;
  Block ignore=Blocks.air;
  LinkedList<TileEntity> createdTileEntities=new LinkedList<TileEntity>();
  for (int chunkLocalZ=localMinZ; chunkLocalZ <= localMaxZ; chunkLocalZ++) {
    for (int y=minY; y < maxY; y++) {
      for (int chunkLocalX=localMinX; chunkLocalX <= localMaxX; chunkLocalX++) {
        ++blockCount;
        final int x=chunkLocalX | (chunkX << 4);
        final int z=chunkLocalZ | (chunkZ << 4);
        final int schematicX=x - minX;
        final int schematicY=y - minY;
        final int schematicZ=z - minZ;
        try {
          WorldBlockCoord worldCoord=new WorldBlockCoord(chunkX << 4 | chunkLocalX,y,chunkZ << 4 | chunkLocalZ);
          WorldBlockCoord schematicCoord=new WorldBlockCoord(schematicX,schematicY,schematicZ);
          PreSetBlockEvent event=new PreSetBlockEvent(schematic,world,worldCoord,schematicCoord);
          if (setBlockEventListeners != null) {
            for (            final IPreSetBlockEventListener listener : setBlockEventListeners) {
              listener.preBlockSet(event);
            }
          }
          if (event.block != null && c.func_150807_a(chunkLocalX,y,chunkLocalZ,event.block,event.metadata)) {
            world.markBlockForUpdate(x,y,z);
            final NBTTagCompound tileEntityData=schematic.getTileEntity(schematicX,schematicY,schematicZ);
            if (event.block.hasTileEntity(event.metadata) && tileEntityData != null) {
              TileEntity tileEntity=TileEntity.createAndLoadEntity(tileEntityData);
              c.func_150812_a(chunkLocalX,y,chunkLocalZ,tileEntity);
              tileEntity.getBlockType();
              try {
                tileEntity.validate();
              }
 catch (              Exception e) {
                _logger.error(String.format(""String_Node_Str"",tileEntity.getClass()),e);
              }
              createdTileEntities.add(tileEntity);
            }
          }
        }
 catch (        Exception e) {
          _logger.error(""String_Node_Str"",e);
        }
      }
    }
  }
  for (  final TileEntity tileEntity : createdTileEntities) {
    for (    ITileEntityLoadedEvent tileEntityHandler : tileEntityLoadedEventListeners) {
      if (tileEntityHandler.onTileEntityAdded(tileEntity)) {
        break;
      }
    }
  }
  c.enqueueRelightChecks();
  c.setChunkModified();
}","public void renderSchematicToSingleChunk(ResourceLocation resource,World world,int originX,int originY,int originZ,int chunkX,int chunkZ,ForgeDirection rotation,boolean flip){
  if (rotation == ForgeDirection.DOWN || rotation == ForgeDirection.UP) {
    _logger.error(""String_Node_Str"",resource,rotation);
    return;
  }
  SchematicWorld schematic=loadedSchematics.get(resource);
  if (schematic == null) {
    _logger.error(""String_Node_Str"",resource);
    return;
  }
  final int minX=originX;
  final int maxX=originX + schematic.getWidth();
  final int minY=originY;
  final int maxY=originY + schematic.getHeight();
  final int minZ=originZ;
  final int maxZ=originZ + schematic.getLength();
  final int localMinX=minX < (chunkX << 4) ? 0 : (minX & 15);
  final int localMaxX=maxX > ((chunkX << 4) + 15) ? 15 : (maxX & 15);
  final int localMinZ=minZ < (chunkZ << 4) ? 0 : (minZ & 15);
  final int localMaxZ=maxZ > ((chunkZ << 4) + 15) ? 15 : (maxZ & 15);
  Chunk c=world.getChunkFromChunkCoords(chunkX,chunkZ);
  int blockCount=0;
  Block ignore=Blocks.air;
  LinkedList<TileEntity> createdTileEntities=new LinkedList<TileEntity>();
  for (int chunkLocalZ=localMinZ; chunkLocalZ <= localMaxZ; chunkLocalZ++) {
    for (int y=minY; y < maxY; y++) {
      for (int chunkLocalX=localMinX; chunkLocalX <= localMaxX; chunkLocalX++) {
        ++blockCount;
        final int x=chunkLocalX | (chunkX << 4);
        final int z=chunkLocalZ | (chunkZ << 4);
        final int schematicX=x - minX;
        final int schematicY=y - minY;
        final int schematicZ=z - minZ;
        try {
          WorldBlockCoord worldCoord=new WorldBlockCoord(chunkX << 4 | chunkLocalX,y,chunkZ << 4 | chunkLocalZ);
          WorldBlockCoord schematicCoord=new WorldBlockCoord(schematicX,schematicY,schematicZ);
          PreSetBlockEvent event=new PreSetBlockEvent(schematic,world,worldCoord,schematicCoord);
          if (setBlockEventListeners != null) {
            for (            final IPreSetBlockEventListener listener : setBlockEventListeners) {
              listener.preBlockSet(event);
            }
          }
          if (event.block != null && c.func_150807_a(chunkLocalX,y,chunkLocalZ,event.block,event.metadata)) {
            world.markBlockForUpdate(x,y,z);
            final NBTTagCompound tileEntityData=schematic.getTileEntity(schematicX,schematicY,schematicZ);
            if (event.block.hasTileEntity(event.metadata) && tileEntityData != null) {
              TileEntity tileEntity=TileEntity.createAndLoadEntity(tileEntityData);
              c.func_150812_a(chunkLocalX,y,chunkLocalZ,tileEntity);
              tileEntity.getBlockType();
              try {
                tileEntity.validate();
              }
 catch (              Exception e) {
                _logger.error(String.format(""String_Node_Str"",tileEntity.getClass()),e);
              }
              createdTileEntities.add(tileEntity);
            }
          }
        }
 catch (        Exception e) {
          _logger.error(""String_Node_Str"",e);
        }
      }
    }
  }
  for (  final TileEntity tileEntity : createdTileEntities) {
    for (    ITileEntityLoadedEvent tileEntityHandler : tileEntityLoadedEventListeners) {
      if (tileEntityHandler.onTileEntityAdded(tileEntity)) {
        break;
      }
    }
  }
  c.enqueueRelightChecks();
  c.setChunkModified();
}"
12566,"public void generate(){
  Logger.info(""String_Node_Str"",intersection.getX(),intersection.getY());
  if (ruin.height == null) {
    Chunk chunk=world.getChunkFromChunkCoords(chunkX,chunkZ);
    ruin.height=chunk.heightMapMinimum - ruin.schematic.heightOffset;
  }
  WorldGen.schematicLoader.renderSchematicToSingleChunk(ruin.schematic.resource,world,intersection.getX(),ruin.height,intersection.getY(),chunkX,chunkZ,ForgeDirection.NORTH,false);
}","public void generate(){
  if (!ruin.hasGenerationStarted()) {
    Logger.info(""String_Node_Str"",ruin.schematic.resource,intersection.getX(),intersection.getY());
    ruin.setGenerationStarted();
  }
  if (ruin.height == null) {
    Chunk chunk=world.getChunkFromChunkCoords(chunkX,chunkZ);
    ruin.height=chunk.heightMapMinimum - ruin.schematic.heightOffset;
  }
  WorldGen.schematicLoader.renderSchematicToSingleChunk(ruin.schematic.resource,world,intersection.getX(),ruin.height,intersection.getY(),chunkX,chunkZ,ForgeDirection.NORTH,false);
}"
12567,"private void registerTESRs(){
  PipeBlock.setRenderType(RenderingRegistry.getNextAvailableRenderId());
  PipeValveBlock.setRenderType(RenderingRegistry.getNextAvailableRenderId());
  PipeRedstoneValveBlock.setRenderType(RenderingRegistry.getNextAvailableRenderId());
  PipeJunctionBlock.setRenderType(RenderingRegistry.getNextAvailableRenderId());
  ClientRegistry.bindTileEntitySpecialRenderer(CupolaTE.class,new CupbolaTESR());
  ClientRegistry.bindTileEntitySpecialRenderer(PipeTE.class,new PipeTESR());
  ClientRegistry.bindTileEntitySpecialRenderer(PipeValveTE.class,new PipeValveTESR());
  ClientRegistry.bindTileEntitySpecialRenderer(PipeRedstoneValveTE.class,new PipeRedstoneValveTESR());
  ClientRegistry.bindTileEntitySpecialRenderer(PipeJunctionTE.class,new PipeJunctionTESR());
  ClientRegistry.bindTileEntitySpecialRenderer(PlotoniumChestTE.class,new PlotoniumChestTESR());
}","private void registerTESRs(){
  PipeBlock.setRenderType(RenderingRegistry.getNextAvailableRenderId());
  PipeValveBlock.setRenderType(RenderingRegistry.getNextAvailableRenderId());
  PipeRedstoneValveBlock.setRenderType(RenderingRegistry.getNextAvailableRenderId());
  PipeJunctionBlock.setRenderType(RenderingRegistry.getNextAvailableRenderId());
  ClientRegistry.bindTileEntitySpecialRenderer(CupolaTE.class,new CupolaTESR());
  ClientRegistry.bindTileEntitySpecialRenderer(PipeTE.class,new PipeTESR());
  ClientRegistry.bindTileEntitySpecialRenderer(PipeValveTE.class,new PipeValveTESR());
  ClientRegistry.bindTileEntitySpecialRenderer(PipeRedstoneValveTE.class,new PipeRedstoneValveTESR());
  ClientRegistry.bindTileEntitySpecialRenderer(PipeJunctionTE.class,new PipeJunctionTESR());
  ClientRegistry.bindTileEntitySpecialRenderer(PlotoniumChestTE.class,new PlotoniumChestTESR());
}"
12568,"@Override protected void registerIcons(ITextureConditionSet textures){
  textures.useTexture(""String_Node_Str"").forCondition(DEFAULT).andCondition(LEFT).andCondition(RIGHT).andCondition(LEFT | RIGHT).andCondition(TOP | BOTTOM).andCondition(featurePlate.getFeatureId()).andCondition(featurePipes.getFeatureId() | FEATURE_EDGE_TOP | FEATURE_EDGE_BOTTOM).andCondition(featurePipes.getFeatureId() | FEATURE_EDGE_TOP | FEATURE_EDGE_BOTTOM| RIGHT).andCondition(featurePipes.getFeatureId() | FEATURE_EDGE_TOP | FEATURE_EDGE_BOTTOM| LEFT).andCondition(featurePipes.getFeatureId() | FEATURE_EDGE_TOP | FEATURE_EDGE_BOTTOM| LEFT| RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featurePipes.getFeatureId() | FEATURE_EDGE_TOP).andCondition(LEFT | featurePipes.getFeatureId() | FEATURE_EDGE_TOP).andCondition(RIGHT | featurePipes.getFeatureId() | FEATURE_EDGE_TOP).andCondition(LEFT | RIGHT | featurePipes.getFeatureId()| FEATURE_EDGE_TOP);
  textures.useTexture(""String_Node_Str"").forCondition(featureVent.getFeatureId()).andCondition(featureVent.getFeatureId() | LEFT).andCondition(featureVent.getFeatureId() | RIGHT).andCondition(featureVent.getFeatureId() | LEFT | RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureScreen.getFeatureId()).andCondition(featureScreen.getFeatureId() | LEFT).andCondition(featureScreen.getFeatureId() | RIGHT).andCondition(featureScreen.getFeatureId() | LEFT | RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureValve.getFeatureId()).andCondition(featureValve.getFeatureId() | LEFT).andCondition(featureValve.getFeatureId() | RIGHT).andCondition(featureValve.getFeatureId() | LEFT | RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureHorizontalMetalTear.getFeatureId() | FEATURE_EDGE_LEFT);
  textures.useTexture(""String_Node_Str"").forCondition(featureHorizontalMetalTear.getFeatureId());
  textures.useTexture(""String_Node_Str"").forCondition(featureHorizontalMetalTear.getFeatureId() | FEATURE_EDGE_RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featurePipes.getFeatureId() | FEATURE_EDGE_BOTTOM).andCondition(LEFT | featurePipes.getFeatureId() | FEATURE_EDGE_BOTTOM).andCondition(RIGHT | featurePipes.getFeatureId() | FEATURE_EDGE_BOTTOM).andCondition(LEFT | RIGHT | featurePipes.getFeatureId()| FEATURE_EDGE_BOTTOM);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_LEFT).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_RIGHT).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_TOP).andCondition(featureCrown.getFeatureId() | TOP | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_BOTTOM).andCondition(featureBase.getFeatureId() | BOTTOM | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_RIGHT | FEATURE_EDGE_BOTTOM).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT| FEATURE_EDGE_BOTTOM).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_RIGHT | FEATURE_PLATE_BL_CORNER).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT| FEATURE_PLATE_BL_CORNER).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT| FEATURE_PLATE_BR_CORNER).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_BOTTOM | FEATURE_PLATE_TR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_RIGHT | FEATURE_EDGE_TOP).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT| FEATURE_EDGE_TOP).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_RIGHT | FEATURE_PLATE_TL_CORNER).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT| FEATURE_PLATE_TL_CORNER).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT| FEATURE_PLATE_TR_CORNER).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_TOP | FEATURE_PLATE_BR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_LEFT | FEATURE_EDGE_BOTTOM).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT| FEATURE_EDGE_BOTTOM).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_LEFT | FEATURE_PLATE_BR_CORNER).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT| FEATURE_PLATE_BR_CORNER).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT| FEATURE_PLATE_BL_CORNER).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_BOTTOM | FEATURE_PLATE_TL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_LEFT | FEATURE_EDGE_TOP).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT| FEATURE_EDGE_TOP).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_LEFT | FEATURE_PLATE_TR_CORNER).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT| FEATURE_PLATE_TL_CORNER).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT| FEATURE_PLATE_TR_CORNER).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_TOP | FEATURE_PLATE_BL_CORNER).andCondition(featurePlate.getFeatureId() | featureCrown.getFeatureId() | TOP| LEFT| RIGHT| FEATURE_EDGE_TOP| FEATURE_PLATE_BL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_PLATE_BR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_PLATE_TR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_PLATE_BL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_PLATE_TL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_PLATE_TL_CORNER | FEATURE_PLATE_BR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_PLATE_BL_CORNER | FEATURE_PLATE_TR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | LEFT).andCondition(featureCrown.getFeatureId() | TOP | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP).andCondition(featureCrown.getFeatureId() | TOP | LEFT| featurePlate.getFeatureId());
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | RIGHT).andCondition(featureCrown.getFeatureId() | TOP | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP).andCondition(featureCrown.getFeatureId() | TOP | RIGHT| featurePlate.getFeatureId());
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | LEFT| RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP).andCondition(featureCrown.getFeatureId() | TOP | featurePlate.getFeatureId()| FEATURE_EDGE_TOP);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | featurePlate.getFeatureId()| FEATURE_EDGE_LEFT| FEATURE_EDGE_TOP);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | featurePlate.getFeatureId()| FEATURE_EDGE_RIGHT| FEATURE_EDGE_TOP);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | LEFT).andCondition(featureBase.getFeatureId() | BOTTOM | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | RIGHT).andCondition(featureBase.getFeatureId() | BOTTOM | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | LEFT| RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM).andCondition(featureBase.getFeatureId() | BOTTOM | featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_LEFT);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_EDGE_LEFT).andCondition(featureCrown.getFeatureId() | TOP | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_PLATE_BL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_EDGE_RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_EDGE_RIGHT).andCondition(featureCrown.getFeatureId() | TOP | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_PLATE_BR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_EDGE_LEFT);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_EDGE_RIGHT).andCondition(featureCrown.getFeatureId() | TOP | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_PLATE_BR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_EDGE_LEFT).andCondition(featureCrown.getFeatureId() | TOP | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_PLATE_BL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_LEFT).andCondition(featureBase.getFeatureId() | BOTTOM | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_PLATE_TL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_LEFT);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_RIGHT).andCondition(featureBase.getFeatureId() | BOTTOM | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_PLATE_TR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_RIGHT).andCondition(featureBase.getFeatureId() | BOTTOM | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_PLATE_TR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_LEFT).andCondition(featureBase.getFeatureId() | BOTTOM | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_PLATE_TL_CORNER);
}","@Override protected void registerIcons(ITextureConditionSet textures){
  textures.useTexture(""String_Node_Str"").forCondition(DEFAULT).andCondition(LEFT).andCondition(RIGHT).andCondition(LEFT | RIGHT).andCondition(TOP | BOTTOM).andCondition(featurePlate.getFeatureId()).andCondition(featurePipes.getFeatureId() | FEATURE_EDGE_TOP | FEATURE_EDGE_BOTTOM).andCondition(featurePipes.getFeatureId() | FEATURE_EDGE_TOP | FEATURE_EDGE_BOTTOM| RIGHT).andCondition(featurePipes.getFeatureId() | FEATURE_EDGE_TOP | FEATURE_EDGE_BOTTOM| LEFT).andCondition(featurePipes.getFeatureId() | FEATURE_EDGE_TOP | FEATURE_EDGE_BOTTOM| LEFT| RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featurePipes.getFeatureId() | FEATURE_EDGE_TOP).andCondition(LEFT | featurePipes.getFeatureId() | FEATURE_EDGE_TOP).andCondition(RIGHT | featurePipes.getFeatureId() | FEATURE_EDGE_TOP).andCondition(LEFT | RIGHT | featurePipes.getFeatureId()| FEATURE_EDGE_TOP);
  textures.useTexture(""String_Node_Str"").forCondition(featureVent.getFeatureId()).andCondition(featureVent.getFeatureId() | LEFT).andCondition(featureVent.getFeatureId() | RIGHT).andCondition(featureVent.getFeatureId() | LEFT | RIGHT).andCondition(featureVent.getFeatureId() | featurePlate.getFeatureId());
  textures.useTexture(""String_Node_Str"").forCondition(featureScreen.getFeatureId()).andCondition(featureScreen.getFeatureId() | LEFT).andCondition(featureScreen.getFeatureId() | RIGHT).andCondition(featureScreen.getFeatureId() | LEFT | RIGHT).andCondition(featureScreen.getFeatureId() | featurePlate.getFeatureId());
  textures.useTexture(""String_Node_Str"").forCondition(featureValve.getFeatureId()).andCondition(featureValve.getFeatureId() | LEFT).andCondition(featureValve.getFeatureId() | RIGHT).andCondition(featureValve.getFeatureId() | LEFT | RIGHT).andCondition(featureValve.getFeatureId() | featurePlate.getFeatureId());
  textures.useTexture(""String_Node_Str"").forCondition(featureHorizontalMetalTear.getFeatureId() | FEATURE_EDGE_LEFT);
  textures.useTexture(""String_Node_Str"").forCondition(featureHorizontalMetalTear.getFeatureId());
  textures.useTexture(""String_Node_Str"").forCondition(featureHorizontalMetalTear.getFeatureId() | FEATURE_EDGE_RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featurePipes.getFeatureId() | FEATURE_EDGE_BOTTOM).andCondition(LEFT | featurePipes.getFeatureId() | FEATURE_EDGE_BOTTOM).andCondition(RIGHT | featurePipes.getFeatureId() | FEATURE_EDGE_BOTTOM).andCondition(LEFT | RIGHT | featurePipes.getFeatureId()| FEATURE_EDGE_BOTTOM);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_LEFT).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_RIGHT).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_TOP).andCondition(featureCrown.getFeatureId() | TOP | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_BOTTOM).andCondition(featureBase.getFeatureId() | BOTTOM | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_RIGHT | FEATURE_EDGE_BOTTOM).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT| FEATURE_EDGE_BOTTOM).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_RIGHT | FEATURE_PLATE_BL_CORNER).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT| FEATURE_PLATE_BL_CORNER).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT| FEATURE_PLATE_BR_CORNER).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_BOTTOM | FEATURE_PLATE_TR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_RIGHT | FEATURE_EDGE_TOP).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT| FEATURE_EDGE_TOP).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_RIGHT | FEATURE_PLATE_TL_CORNER).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT| FEATURE_PLATE_TL_CORNER).andCondition(featurePlate.getFeatureId() | RIGHT | FEATURE_EDGE_RIGHT| FEATURE_PLATE_TR_CORNER).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_TOP | FEATURE_PLATE_BR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_LEFT | FEATURE_EDGE_BOTTOM).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT| FEATURE_EDGE_BOTTOM).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_LEFT | FEATURE_PLATE_BR_CORNER).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT| FEATURE_PLATE_BR_CORNER).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT| FEATURE_PLATE_BL_CORNER).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_BOTTOM | FEATURE_PLATE_TL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_EDGE_LEFT | FEATURE_EDGE_TOP).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT| FEATURE_EDGE_TOP).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_LEFT | FEATURE_PLATE_TR_CORNER).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT| FEATURE_PLATE_TL_CORNER).andCondition(featurePlate.getFeatureId() | LEFT | FEATURE_EDGE_LEFT| FEATURE_PLATE_TR_CORNER).andCondition(featurePlate.getFeatureId() | FEATURE_EDGE_TOP | FEATURE_PLATE_BL_CORNER).andCondition(featurePlate.getFeatureId() | featureCrown.getFeatureId() | TOP| LEFT| RIGHT| FEATURE_EDGE_TOP| FEATURE_PLATE_BL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_PLATE_BR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_PLATE_TR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_PLATE_BL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_PLATE_TL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_PLATE_TL_CORNER | FEATURE_PLATE_BR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featurePlate.getFeatureId() | FEATURE_PLATE_BL_CORNER | FEATURE_PLATE_TR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | LEFT).andCondition(featureCrown.getFeatureId() | TOP | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP).andCondition(featureCrown.getFeatureId() | TOP | LEFT| featurePlate.getFeatureId());
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | RIGHT).andCondition(featureCrown.getFeatureId() | TOP | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP).andCondition(featureCrown.getFeatureId() | TOP | RIGHT| featurePlate.getFeatureId());
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | LEFT| RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP).andCondition(featureCrown.getFeatureId() | TOP | featurePlate.getFeatureId()| FEATURE_EDGE_TOP);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | featurePlate.getFeatureId()| FEATURE_EDGE_LEFT| FEATURE_EDGE_TOP);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | featurePlate.getFeatureId()| FEATURE_EDGE_RIGHT| FEATURE_EDGE_TOP);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | LEFT).andCondition(featureBase.getFeatureId() | BOTTOM | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | RIGHT).andCondition(featureBase.getFeatureId() | BOTTOM | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | LEFT| RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM).andCondition(featureBase.getFeatureId() | BOTTOM | featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_LEFT);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_EDGE_LEFT).andCondition(featureCrown.getFeatureId() | TOP | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_PLATE_BL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_EDGE_RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_EDGE_RIGHT).andCondition(featureCrown.getFeatureId() | TOP | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_PLATE_BR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_EDGE_LEFT);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_EDGE_RIGHT).andCondition(featureCrown.getFeatureId() | TOP | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_PLATE_BR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureCrown.getFeatureId() | TOP | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_EDGE_LEFT).andCondition(featureCrown.getFeatureId() | TOP | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_TOP| FEATURE_PLATE_BL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_LEFT).andCondition(featureBase.getFeatureId() | BOTTOM | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_PLATE_TL_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | LEFT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_RIGHT);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_LEFT);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_RIGHT).andCondition(featureBase.getFeatureId() | BOTTOM | RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_PLATE_TR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_RIGHT).andCondition(featureBase.getFeatureId() | BOTTOM | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_PLATE_TR_CORNER);
  textures.useTexture(""String_Node_Str"").forCondition(featureBase.getFeatureId() | BOTTOM | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_EDGE_LEFT).andCondition(featureBase.getFeatureId() | BOTTOM | LEFT| RIGHT| featurePlate.getFeatureId()| FEATURE_EDGE_BOTTOM| FEATURE_PLATE_TL_CORNER);
}"
12569,"@Override public long getSubProperties(TextureContext context,long currentProperties){
  if (texture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.LEFT,TextureDirection.BELOW)) {
    currentProperties|=ProceduralConnectedTexture.LEFT;
  }
  if (texture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.RIGHT,TextureDirection.BELOW)) {
    currentProperties|=ProceduralConnectedTexture.RIGHT;
  }
  if ((getCrownSplitOpportunity(context.getWorldBlockCoord()) & 14) == 0) {
    currentProperties|=ProceduralConnectedTexture.LEFT;
  }
  if ((getCrownSplitOpportunity(context.getWorldBlockCoord().offset(context.getRightDirection())) & 14) == 0) {
    currentProperties|=ProceduralConnectedTexture.RIGHT;
  }
  return getFeatureId() | (currentProperties & ~ProceduralConnectedTexture.TOP);
}","@Override public long getSubProperties(TextureContext context,long currentProperties){
  if (texture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.LEFT,TextureDirection.BELOW)) {
    currentProperties|=ProceduralConnectedTexture.LEFT;
  }
  if (texture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.RIGHT,TextureDirection.BELOW)) {
    currentProperties|=ProceduralConnectedTexture.RIGHT;
  }
  if ((getCrownSplitOpportunity(context.getWorldBlockCoord()) & 14) == 0) {
    currentProperties|=ProceduralConnectedTexture.LEFT;
  }
  if ((getCrownSplitOpportunity(context.getWorldBlockCoord().offset(context.getRightDirection())) & 14) == 0) {
    currentProperties|=ProceduralConnectedTexture.RIGHT;
  }
  currentProperties|=ProceduralConnectedTexture.BOTTOM;
  return getFeatureId() | (currentProperties & ~ProceduralConnectedTexture.TOP);
}"
12570,"@Override public long getSubProperties(TextureContext context,long currentProperties){
  long subProperties=getFeatureId();
  IProceduralWallFeature leftBlockFeature=ruinWallTexture.getValidFeature(context,getLayer(),TextureDirection.LEFT);
  IProceduralWallFeature rightBlockFeature=ruinWallTexture.getValidFeature(context,getLayer(),TextureDirection.RIGHT);
  IProceduralWallFeature aboveBlockFeature=ruinWallTexture.getValidFeature(context,getLayer(),TextureDirection.ABOVE);
  IProceduralWallFeature belowBlockFeature=ruinWallTexture.getValidFeature(context,getLayer(),TextureDirection.BELOW);
  if (!(leftBlockFeature instanceof PlateRuinWallFeature)) {
    subProperties|=ProceduralConnectedTexture.FEATURE_EDGE_LEFT;
  }
  if (!(rightBlockFeature instanceof PlateRuinWallFeature)) {
    subProperties|=ProceduralConnectedTexture.FEATURE_EDGE_RIGHT;
  }
  if (!(aboveBlockFeature instanceof PlateRuinWallFeature)) {
    subProperties|=ProceduralConnectedTexture.FEATURE_EDGE_TOP;
  }
  if (!(belowBlockFeature instanceof PlateRuinWallFeature)) {
    subProperties|=ProceduralConnectedTexture.FEATURE_EDGE_BOTTOM;
  }
  final long FEATURE_EDGE_TOP_AND_BOTTOM=ProceduralConnectedTexture.FEATURE_EDGE_TOP | ProceduralConnectedTexture.FEATURE_EDGE_BOTTOM;
  final long FEATURE_EDGE_LEFT_AND_RIGHT=ProceduralConnectedTexture.FEATURE_EDGE_LEFT | ProceduralConnectedTexture.FEATURE_EDGE_RIGHT;
  if ((subProperties & FEATURE_EDGE_TOP_AND_BOTTOM) == FEATURE_EDGE_TOP_AND_BOTTOM) {
    return 0;
  }
 else   if ((subProperties & FEATURE_EDGE_LEFT_AND_RIGHT) == FEATURE_EDGE_LEFT_AND_RIGHT) {
    return 0;
  }
  if (aboveBlockFeature instanceof PlateRuinWallFeature && leftBlockFeature instanceof PlateRuinWallFeature) {
    IProceduralWallFeature corner=ruinWallTexture.getValidFeature(context,getLayer(),TextureDirection.ABOVE,TextureDirection.LEFT);
    if (!(corner instanceof PlateRuinWallFeature)) {
      subProperties|=RuinWallTexture.FEATURE_PLATE_TL_CORNER;
    }
  }
  if (aboveBlockFeature instanceof PlateRuinWallFeature && rightBlockFeature instanceof PlateRuinWallFeature) {
    IProceduralWallFeature corner=ruinWallTexture.getValidFeature(context,getLayer(),TextureDirection.ABOVE,TextureDirection.RIGHT);
    if (!(corner instanceof PlateRuinWallFeature)) {
      subProperties|=RuinWallTexture.FEATURE_PLATE_TR_CORNER;
    }
  }
  if (belowBlockFeature instanceof PlateRuinWallFeature && leftBlockFeature instanceof PlateRuinWallFeature) {
    IProceduralWallFeature corner=ruinWallTexture.getValidFeature(context,getLayer(),TextureDirection.BELOW,TextureDirection.LEFT);
    if (!(corner instanceof PlateRuinWallFeature)) {
      subProperties|=RuinWallTexture.FEATURE_PLATE_BL_CORNER;
    }
  }
  if (belowBlockFeature instanceof PlateRuinWallFeature && rightBlockFeature instanceof PlateRuinWallFeature) {
    IProceduralWallFeature corner=ruinWallTexture.getValidFeature(context,getLayer(),TextureDirection.BELOW,TextureDirection.RIGHT);
    if (!(corner instanceof PlateRuinWallFeature)) {
      subProperties|=RuinWallTexture.FEATURE_PLATE_BR_CORNER;
    }
  }
  return subProperties;
}","@Override public long getSubProperties(TextureContext context,long currentProperties){
  long subProperties=getFeatureId();
  boolean isLeftBlockValid=ruinWallTexture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.LEFT) && ruinWallTexture.isFeatureAtCoordCompatibleWith(context,getLayer(),this,TextureDirection.LEFT);
  boolean isRightBlockValid=ruinWallTexture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.RIGHT) && ruinWallTexture.isFeatureAtCoordCompatibleWith(context,getLayer(),this,TextureDirection.RIGHT);
  boolean isAboveBlockValid=ruinWallTexture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.ABOVE) && ruinWallTexture.isFeatureAtCoordCompatibleWith(context,getLayer(),this,TextureDirection.ABOVE);
  boolean isBelowBlockValid=ruinWallTexture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.BELOW) && ruinWallTexture.isFeatureAtCoordCompatibleWith(context,getLayer(),this,TextureDirection.BELOW);
  if (!isLeftBlockValid) {
    subProperties|=ProceduralConnectedTexture.FEATURE_EDGE_LEFT;
  }
  if (!isRightBlockValid) {
    subProperties|=ProceduralConnectedTexture.FEATURE_EDGE_RIGHT;
  }
  if (!isAboveBlockValid) {
    subProperties|=ProceduralConnectedTexture.FEATURE_EDGE_TOP;
  }
  if (!isBelowBlockValid) {
    subProperties|=ProceduralConnectedTexture.FEATURE_EDGE_BOTTOM;
  }
  final long FEATURE_EDGE_TOP_AND_BOTTOM=ProceduralConnectedTexture.FEATURE_EDGE_TOP | ProceduralConnectedTexture.FEATURE_EDGE_BOTTOM;
  final long FEATURE_EDGE_LEFT_AND_RIGHT=ProceduralConnectedTexture.FEATURE_EDGE_LEFT | ProceduralConnectedTexture.FEATURE_EDGE_RIGHT;
  if ((subProperties & FEATURE_EDGE_TOP_AND_BOTTOM) == FEATURE_EDGE_TOP_AND_BOTTOM) {
    return 0;
  }
 else   if ((subProperties & FEATURE_EDGE_LEFT_AND_RIGHT) == FEATURE_EDGE_LEFT_AND_RIGHT) {
    return 0;
  }
  if (isAboveBlockValid && isLeftBlockValid) {
    boolean isCornerValid=ruinWallTexture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.ABOVE,TextureDirection.LEFT) && ruinWallTexture.isFeatureAtCoordCompatibleWith(context,getLayer(),this,TextureDirection.ABOVE,TextureDirection.LEFT);
    if (!isCornerValid) {
      subProperties|=RuinWallTexture.FEATURE_PLATE_TL_CORNER;
    }
  }
  if (isAboveBlockValid && isRightBlockValid) {
    boolean isCornerValid=ruinWallTexture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.ABOVE,TextureDirection.RIGHT) && ruinWallTexture.isFeatureAtCoordCompatibleWith(context,getLayer(),this,TextureDirection.ABOVE,TextureDirection.RIGHT);
    if (!isCornerValid) {
      subProperties|=RuinWallTexture.FEATURE_PLATE_TR_CORNER;
    }
  }
  if (isBelowBlockValid && isLeftBlockValid) {
    boolean isCornerValid=ruinWallTexture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.BELOW,TextureDirection.LEFT) && ruinWallTexture.isFeatureAtCoordCompatibleWith(context,getLayer(),this,TextureDirection.BELOW,TextureDirection.LEFT);
    if (!isCornerValid) {
      subProperties|=RuinWallTexture.FEATURE_PLATE_BL_CORNER;
    }
  }
  if (isBelowBlockValid && isRightBlockValid) {
    boolean isCornerValid=ruinWallTexture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.BELOW,TextureDirection.RIGHT) && ruinWallTexture.isFeatureAtCoordCompatibleWith(context,getLayer(),this,TextureDirection.BELOW,TextureDirection.RIGHT);
    if (!isCornerValid) {
      subProperties|=RuinWallTexture.FEATURE_PLATE_BR_CORNER;
    }
  }
  return subProperties;
}"
12571,"@Override public long getSubProperties(TextureContext context,long currentProperties){
  if (texture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.LEFT,TextureDirection.ABOVE)) {
    currentProperties|=ProceduralConnectedTexture.LEFT;
  }
  if (texture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.RIGHT,TextureDirection.ABOVE)) {
    currentProperties|=ProceduralConnectedTexture.RIGHT;
  }
  if ((getCrownSplitOpportunity(context.getWorldBlockCoord()) & 14) == 0) {
    currentProperties|=ProceduralConnectedTexture.LEFT;
  }
  if ((getCrownSplitOpportunity(context.getWorldBlockCoord().offset(context.getRightDirection())) & 14) == 0) {
    currentProperties|=ProceduralConnectedTexture.RIGHT;
  }
  return getFeatureId() | currentProperties;
}","@Override public long getSubProperties(TextureContext context,long currentProperties){
  if (texture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.LEFT,TextureDirection.ABOVE)) {
    currentProperties|=ProceduralConnectedTexture.LEFT;
  }
  if (texture.isBlockPartOfWallAndUnobstructed(context,TextureDirection.RIGHT,TextureDirection.ABOVE)) {
    currentProperties|=ProceduralConnectedTexture.RIGHT;
  }
  if ((getCrownSplitOpportunity(context.getWorldBlockCoord()) & 14) == 0) {
    currentProperties|=ProceduralConnectedTexture.LEFT;
  }
  if ((getCrownSplitOpportunity(context.getWorldBlockCoord().offset(context.getRightDirection())) & 14) == 0) {
    currentProperties|=ProceduralConnectedTexture.RIGHT;
  }
  currentProperties|=ProceduralConnectedTexture.TOP;
  return getFeatureId() | currentProperties;
}"
12572,"@Override public void registerBlockIcons(IIconRegister iconRegister){
}","@SuppressWarnings(""String_Node_Str"") @Override public void registerBlockIcons(IIconRegister iconRegister){
}"
12573,"@Override public boolean onBlockActivated(World world,int x,int y,int z,EntityPlayer player,int side,float xOffset,float yOffset,float zOffset){
  final TileEntity te=world.getTileEntity(x,y,z);
  if (!world.isRemote && te != null && te instanceof PlotoniumChestTE) {
    player.displayGUIChest((IInventory)te);
    return true;
  }
  return false;
}","@Override public boolean onBlockActivated(World world,int x,int y,int z,EntityPlayer player,int side,float xOffset,float yOffset,float zOffset){
  final TileEntity te=world.getTileEntity(x,y,z);
  if (!player.isSneaking())   if (!world.isRemote && te != null && te instanceof PlotoniumChestTE)   player.displayGUIChest((IInventory)te);
  return true;
}"
12574,"@Override public void breakBlock(World world,int x,int y,int z,Block block,int metadata){
  final PlotoniumChestTE te=(PlotoniumChestTE)world.getTileEntity(x,y,z);
  if (te != null) {
    for (int slotindex=0; slotindex < te.getSizeInventory(); ++slotindex) {
      dropSlotContents(world,x,y,z,te,slotindex);
    }
    world.func_147453_f(x,y,z,block);
  }
  super.breakBlock(world,x,y,z,block,metadata);
}","@Override public void breakBlock(World world,int x,int y,int z,Block block,int metadata){
  final PlotoniumChestTE te=(PlotoniumChestTE)world.getTileEntity(x,y,z);
  if (te != null) {
    dropInventory(world,WorldBlockCoord.of(x,y,z),te);
    world.func_147453_f(x,y,z,block);
  }
  super.breakBlock(world,x,y,z,block,metadata);
}"
12575,"@Override public int getLightValue(IBlockAccess world,int x,int y,int z){
  TileEntity te=world.getTileEntity(x,y,z);
  if (((CupolaTE)te).isSlave()) {
    te=world.getTileEntity(x,y - 1,z);
  }
  if (((CupolaTE)te).isActive())   return 15;
  return super.getLightValue(world,x,y,z);
}","@Override public int getLightValue(IBlockAccess world,int x,int y,int z){
  TileEntity te=world.getTileEntity(x,y,z);
  if (((CupolaTE)te).isSlave()) {
    te=world.getTileEntity(x,y - 1,z);
  }
  if ((te != null) && ((CupolaTE)te).isActive())   return 15;
  return super.getLightValue(world,x,y,z);
}"
12576,"public SteamNSteelItemArmor(ArmorMaterial material,int armorType,int renderIndex,String name){
  super(material,armorType,renderIndex);
  this.setCreativeTab(Reference.CREATIVE_TAB);
  this.setUnlocalizedName(name);
}","SteamNSteelItemArmor(ArmorMaterial material,int armorType,int renderIndex,String name){
  super(material,armorType,renderIndex);
  setCreativeTab(TheMod.CREATIVE_TAB);
  setUnlocalizedName(name);
}"
12577,"@SuppressWarnings(""String_Node_Str"") protected String getUnwrappedUnlocalizedName(String unlocalizedName){
  return unlocalizedName.substring(unlocalizedName.indexOf('.') + 1);
}","private static String getUnwrappedUnlocalizedName(String unlocalizedName){
  return unlocalizedName.substring(unlocalizedName.indexOf('.') + 1);
}"
12578,"private RecipePattern(String firstRow,String secondRow,String thirdRow){
  pattern=ImmutableList.of(firstRow,secondRow,thirdRow);
}","private RecipePattern(String firstRow){
  pattern=ImmutableList.of(firstRow);
}"
12579,"public static RecipePattern of(String firstRow){
  return new RecipePattern(firstRow,""String_Node_Str"",""String_Node_Str"");
}","public static RecipePattern of(String firstRow){
  return new RecipePattern(firstRow);
}"
12580,"@Override public String toString(){
  return Objects.toStringHelper(this).add(""String_Node_Str"",pattern.get(0)).add(""String_Node_Str"",pattern.get(1)).add(""String_Node_Str"",pattern.get(2)).toString();
}","@Override public String toString(){
  final StringBuilder sb=new StringBuilder(CAPACITY);
  sb.append('{');
  boolean appendComma=false;
  for (  final String s : pattern) {
    if (appendComma)     sb.append(""String_Node_Str"");
 else     appendComma=true;
    sb.append('\""');
    sb.append(s);
    sb.append('\""');
  }
  sb.append('}');
  return Objects.toStringHelper(this).addValue(sb).toString();
}"
12581,"protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  String color=null;
  HashMap<String,String> hm=new HashMap<String,String>();
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str"") + ""String_Node_Str"");
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + hm);
  BpmsClientThread t=new BpmsClientThread();
  processId=t.starBusinessProcess(hm);
  System.out.println(""String_Node_Str"");
  response.setCharacterEncoding(""String_Node_Str"");
  response.setContentType(""String_Node_Str"");
  PrintWriter out=response.getWriter();
  String content=""String_Node_Str"";
  if (processId == null) {
    content=getContent(getServletContext().getRealPath(File.separator) + ""String_Node_Str"");
  }
 else {
    content=getContent(getServletContext().getRealPath(File.separator) + ""String_Node_Str"");
    content=content.replace(""String_Node_Str"",processId);
  }
  out.println(content);
}","protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  String color=null;
  HashMap<String,String> hm=new HashMap<String,String>();
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str"") + ""String_Node_Str"");
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  hm.put(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + hm);
  BpmsClientThread t=new BpmsClientThread();
  processId=t.starBusinessProcess(hm);
  System.out.println(""String_Node_Str"");
  response.setCharacterEncoding(""String_Node_Str"");
  response.setContentType(""String_Node_Str"");
  PrintWriter out=response.getWriter();
  String content=""String_Node_Str"";
  if (processId == null) {
    content=getContent(getServletContext().getRealPath(File.separator) + File.separator + ""String_Node_Str"");
  }
 else {
    content=getContent(getServletContext().getRealPath(File.separator) + File.separator + ""String_Node_Str"");
    content=content.replace(""String_Node_Str"",processId);
  }
  out.println(content);
}"
12582,"public void enable(){
  if (!MC.isSingleplayer()) {
    ChatUtils.print(""String_Node_Str"");
    return;
  }
  if (!enabled) {
    ToggleableClippingHelper.getInstance().setEnabled(false);
    reset();
  }
  enabled=true;
}","public void enable(){
  if (!MC.isSingleplayer()) {
    ChatUtils.print(""String_Node_Str"");
    return;
  }
  if (!enabled) {
    clippingEnabled=clippingHelper.isEnabled();
    clippingHelper.setEnabled(false);
    reset();
  }
  enabled=true;
}"
12583,"public void disable(){
  if (enabled) {
    ToggleableClippingHelper.getInstance().setEnabled(true);
  }
  enabled=false;
}","public void disable(){
  if (enabled) {
    clippingHelper.setEnabled(clippingEnabled);
  }
  enabled=false;
}"
12584,"private void modifySettings(){
  ToggleableClippingHelper.getInstance().setEnabled(false);
}","private void modifySettings(){
  clippingEnabled=clippingHelper.isEnabled();
  clippingHelper.setEnabled(false);
}"
12585,"private void restoreSettings(){
  ToggleableClippingHelper.getInstance().setEnabled(true);
}","private void restoreSettings(){
  clippingHelper.setEnabled(clippingEnabled);
}"
12586,"@Test public void testInterceptorMultiThreaded() throws Exception {
  ExecutorService executor=Executors.newFixedThreadPool(5);
  final Queue<Event> processed=new ConcurrentLinkedQueue<Event>();
  for (int i=0; i < 5; i++) {
    executor.submit(new Runnable(){
      @Override public void run(){
        List<Event> eventList=Lists.newArrayList();
        final String EVENT_BASE=""String_Node_Str"";
        for (int i=0; i < 100; i++) {
          eventList.add(EventBuilder.withBody((EVENT_BASE + i).getBytes()));
        }
        processed.addAll(interceptor.intercept(eventList));
      }
    }
);
  }
  Thread.sleep(2000);
  Assert.assertEquals(500,processed.size());
  Set<Integer> counts=Sets.newTreeSet();
  Iterator<Event> iter=processed.iterator();
  while (iter.hasNext()) {
    Event t=iter.next();
    counts.add(Integer.valueOf(t.getHeaders().get(""String_Node_Str"")));
  }
  Assert.assertEquals(500,counts.size());
  Iterator<Integer> counterIter=counts.iterator();
  Integer expected=1;
  while (counterIter.hasNext()) {
    Integer count=counterIter.next();
    Assert.assertEquals(expected++,count);
  }
}","@Test public void testInterceptorMultiThreaded() throws Exception {
  ExecutorService executor=Executors.newFixedThreadPool(5);
  final Queue<Event> processed=new ConcurrentLinkedQueue<Event>();
  for (int i=0; i < 5; i++) {
    executor.submit(new Runnable(){
      @Override public void run(){
        List<Event> eventList=Lists.newArrayList();
        final String EVENT_BASE=""String_Node_Str"";
        for (int i=0; i < 100; i++) {
          eventList.add(EventBuilder.withBody((EVENT_BASE + i).getBytes()));
        }
        processed.addAll(interceptor.intercept(eventList));
      }
    }
);
  }
  Thread.sleep(2000);
  Assert.assertEquals(500,processed.size());
  Set<Integer> counts=Sets.newTreeSet();
  Iterator<Event> iter=processed.iterator();
  while (iter.hasNext()) {
    Event t=iter.next();
    counts.add(Integer.valueOf(t.getHeaders().get(""String_Node_Str"")));
  }
  Assert.assertEquals(500,counts.size());
  Iterator<Integer> counterIter=counts.iterator();
  Integer expected=1;
  while (counterIter.hasNext()) {
    Integer count=counterIter.next();
    Assert.assertEquals((Integer)expected++,count);
  }
}"
12587,"@Override public void configure(Context context){
  awsAccessKeyId=context.getString(""String_Node_Str"");
  Preconditions.checkArgument(awsAccessKeyId != null && !awsAccessKeyId.isEmpty(),""String_Node_Str"");
  awsSecretKey=context.getString(""String_Node_Str"");
  Preconditions.checkArgument(awsSecretKey != null && !awsSecretKey.isEmpty(),""String_Node_Str"");
  bucket=context.getString(""String_Node_Str"");
  Preconditions.checkArgument(bucket != null && !bucket.isEmpty(),""String_Node_Str"");
  endPoint=context.getInteger(""String_Node_Str"");
  Preconditions.checkArgument(endPoint != null && !endPoint.isEmpty(),""String_Node_Str"");
  batchSize=context.getString(""String_Node_Str"",1000);
  objPrefix=context.getString(""String_Node_Str"",""String_Node_Str"");
}","@Override public void configure(Context context){
  awsAccessKeyId=context.getString(""String_Node_Str"");
  Preconditions.checkArgument(awsAccessKeyId != null && !awsAccessKeyId.isEmpty(),""String_Node_Str"");
  awsSecretKey=context.getString(""String_Node_Str"");
  Preconditions.checkArgument(awsSecretKey != null && !awsSecretKey.isEmpty(),""String_Node_Str"");
  bucket=context.getString(""String_Node_Str"");
  Preconditions.checkArgument(bucket != null && !bucket.isEmpty(),""String_Node_Str"");
  endPoint=context.getString(""String_Node_Str"");
  Preconditions.checkArgument(endPoint != null && !endPoint.isEmpty(),""String_Node_Str"");
  batchSize=context.getInteger(""String_Node_Str"",1000);
  objPrefix=context.getString(""String_Node_Str"",""String_Node_Str"");
}"
12588,"/** 
 * Init
 * @param plugin
 * @param fileName
 */
public ConfigAccessor(JavaPlugin plugin,String fileName){
  if (plugin == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.plugin=plugin;
  this.fileName=fileName;
  File dataFolder=plugin.getDataFolder();
  if (dataFolder == null)   throw new IllegalStateException(plugin.lang(""String_Node_Str""));
  this.configFile=new File(plugin.getDataFolder(),fileName);
}","/** 
 * Init
 * @param plugin
 * @param fileName
 */
public ConfigAccessor(JavaPlugin plugin,String fileName){
  if (plugin == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.plugin=plugin;
  this.fileName=fileName;
  File dataFolder=plugin.getDataFolder();
  if (dataFolder == null)   this.configFile=new File(plugin.getDataFolder(),fileName);
}"
12589,"/** 
 * Save changes
 */
public void saveConfig(){
  if (fileConfiguration != null && configFile != null) {
    try {
      getConfig().save(configFile);
    }
 catch (    IOException ex) {
      plugin.getLogger().log(Level.SEVERE,plugin.lang(""String_Node_Str"") + ""String_Node_Str"" + configFile,ex);
    }
  }
}","/** 
 * Save changes
 */
public void saveConfig(){
  if (fileConfiguration != null && configFile != null) {
    try {
      getConfig().save(configFile);
    }
 catch (    IOException ex) {
    }
  }
}"
12590,"public void reloadConfig(){
  fileConfiguration=YamlConfiguration.loadConfiguration(configFile);
  InputStream defConfigStream=plugin.getResource(fileName);
  if (defConfigStream != null) {
    YamlConfiguration defConfig=YamlConfiguration.loadConfiguration(new InputStreamReader(defConfigStream));
    fileConfiguration.setDefaults(defConfig);
  }
}","public void reloadConfig(){
  fileConfiguration=YamlConfiguration.loadConfiguration(configFile);
  InputStream defConfigStream=plugin.getResource(fileName);
  if (defConfigStream != null) {
  }
}"
12591,"public boolean onCommand(CommandSender sender,Command cmd,String label,String[] args){
  if (cmd.getName().equalsIgnoreCase(""String_Node_Str"")) {
    if (args.length == 0) {
      sender.sendMessage(""String_Node_Str"");
      sender.sendMessage(""String_Node_Str"");
      sender.sendMessage(""String_Node_Str"");
      sender.sendMessage(""String_Node_Str"");
      return true;
    }
 else     if ((args.length == 1) && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(""String_Node_Str"" + plugin.getDescription().getName() + ""String_Node_Str""+ plugin.getDescription().getVersion());
      return true;
    }
 else     if ((args.length == 1) && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      Motd=LittleBrother.Motd;
      port=LittleBrother.port;
      sender.sendMessage(""String_Node_Str"" + Motd);
      sender.sendMessage(""String_Node_Str"" + port);
      return true;
    }
 else     if ((args.length == 1) && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(""String_Node_Str"");
      sender.sendMessage(""String_Node_Str"");
      return true;
    }
  }
  return false;
}","public boolean onCommand(CommandSender sender,Command cmd,String label,String[] args){
  if (cmd.getName().equalsIgnoreCase(""String_Node_Str"")) {
    if (args.length == 0) {
      sender.sendMessage(""String_Node_Str"");
      sender.sendMessage(""String_Node_Str"");
      sender.sendMessage(""String_Node_Str"");
      sender.sendMessage(""String_Node_Str"");
      return true;
    }
 else     if ((args.length == 1) && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(""String_Node_Str"" + plugin.getDescription().getName() + ""String_Node_Str""+ plugin.getDescription().getVersion());
      return true;
    }
 else     if ((args.length == 1) && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      Motd=this.plugin.Motd;
      port=this.plugin.port;
      sender.sendMessage(""String_Node_Str"" + Motd);
      sender.sendMessage(""String_Node_Str"" + port);
      return true;
    }
 else     if ((args.length == 1) && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(""String_Node_Str"");
      sender.sendMessage(""String_Node_Str"");
      return true;
    }
  }
  return false;
}"
12592,"public LBCommands(LittleBrother plugin){
  this.plugin=plugin;
}","public LBCommands(LittleBrother plugin){
  this.plugin=plugin;
  this.config=this.plugin.config;
}"
12593,"public void onEnable(){
  this.thread=new ServerThread(getLogger());
  this.config=new ConfigAccessor(this,""String_Node_Str"");
  this.config.saveDefaultConfig();
  getLogger().info(""String_Node_Str"");
  Motd=this.getConfig().getString(""String_Node_Str"");
  port=this.getConfig().getInt(""String_Node_Str"");
  getLogger().info(""String_Node_Str"" + Motd);
  getLogger().info(""String_Node_Str"" + port);
  this.getCommand(""String_Node_Str"").setExecutor(new LBCommands(this));
}","public void onEnable(){
  this.thread=new ServerThread(this,getLogger());
  this.config=new ConfigAccessor(this,""String_Node_Str"");
  this.config.saveDefaultConfig();
  getLogger().info(""String_Node_Str"");
  Motd=this.getConfig().getString(""String_Node_Str"");
  port=this.getConfig().getInt(""String_Node_Str"");
  getLogger().info(""String_Node_Str"" + Motd);
  getLogger().info(""String_Node_Str"" + port);
  this.getCommand(""String_Node_Str"").setExecutor(new LBCommands(this));
}"
12594,"public ServerThread(Logger logger){
  this.logger=logger;
  Motd=LittleBrother.Motd;
  port=LittleBrother.port;
  this.start();
}","public ServerThread(LittleBrother plugin,Logger logger){
  this.plugin=plugin;
  this.logger=logger;
  Motd=plugin.Motd;
  port=plugin.port;
  this.start();
}"
12595,"@Override public void findAllByName(Iterable<String> names,final Predicate<Profile> consumer) throws IOException, InterruptedException {
  final List<String> missing=new ArrayList<String>();
  Predicate<Profile> forwardingConsumer=new Predicate<Profile>(){
    @Override public boolean apply(    Profile profile){
      missing.remove(profile.getName().toLowerCase());
      return consumer.apply(profile);
    }
  }
;
  for (  String name : names) {
    missing.add(name.toLowerCase());
  }
  for (  ProfileService service : services) {
    service.findAllByName(missing,forwardingConsumer);
    if (missing.isEmpty()) {
      break;
    }
  }
}","@Override public void findAllByName(Iterable<String> names,final Predicate<Profile> consumer) throws IOException, InterruptedException {
  final List<String> missing=Collections.synchronizedList(new ArrayList<String>());
  Predicate<Profile> forwardingConsumer=new Predicate<Profile>(){
    @Override public boolean apply(    Profile profile){
      missing.remove(profile.getName().toLowerCase());
      return consumer.apply(profile);
    }
  }
;
  for (  String name : names) {
    missing.add(name.toLowerCase());
  }
  for (  ProfileService service : services) {
    service.findAllByName(new ArrayList<String>(missing),forwardingConsumer);
    if (missing.isEmpty()) {
      break;
    }
  }
}"
12596,"public void streamCompleted(ElementReaderEvent event){
  for (  Class_ c : classList) {
    org.modeldriven.fuml.repository.Class_ clss=null;
    if (!(c instanceof Stereotype)) {
      clss=new org.modeldriven.fuml.repository.model.Class_(c,this.artifact);
    }
 else {
      clss=new org.modeldriven.fuml.repository.model.Stereotype((Stereotype)c,this.artifact);
    }
    Repository.INSTANCE.loadClass(clss);
  }
}","public void streamCompleted(ElementReaderEvent event){
  for (  org.modeldriven.fuml.repository.Class_ c : classList) {
    Repository.INSTANCE.loadClass(c);
  }
}"
12597,"public void elementGraphAssembled(ElementAssemblerResultsEvent event){
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  Iterator<String> ids=event.getSource().getResultsXmiIds().iterator();
  while (ids.hasNext()) {
    String id=ids.next();
    FumlObject fumlObject=event.getSource().lookupResult(id);
    if (fumlObject == null) {
      log.warn(""String_Node_Str"" + id + ""String_Node_Str"");
      continue;
    }
    if (fumlObject instanceof NamedElement)     if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + fumlObject.getClass().getName() + ""String_Node_Str""+ ((NamedElement)fumlObject).qualifiedName+ ""String_Node_Str""+ id+ ""String_Node_Str"");
 else     if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + fumlObject.getClass().getName() + ""String_Node_Str""+ ""String_Node_Str""+ id+ ""String_Node_Str"");
    if (fumlObject instanceof Activity) {
      NamedElement namedElement=(NamedElement)fumlObject;
      Repository.INSTANCE.getMapping().mapElementByName(namedElement,this.artifact);
      Repository.INSTANCE.getMapping().mapElementById(namedElement,this.artifact);
    }
 else     if (fumlObject instanceof Class_ && !(fumlObject instanceof OpaqueBehavior)) {
      Class_ clss=(Class_)fumlObject;
      classList.add(clss);
      if (!(clss instanceof Stereotype)) {
        if (clss.package_ != null) {
          Repository.INSTANCE.getMapping().mapClass(clss,getQualifiedPackageName(clss.package_),artifact);
        }
 else         Repository.INSTANCE.getMapping().mapClass(clss,null,artifact);
      }
 else {
        Stereotype stereotype=(Stereotype)clss;
        if (stereotype.package_ != null)         Repository.INSTANCE.getMapping().mapStereotype(stereotype,getQualifiedPackageName(stereotype.package_),artifact);
 else         Repository.INSTANCE.getMapping().mapStereotype(stereotype,null,artifact);
      }
    }
 else     if (fumlObject instanceof Enumeration) {
      Enumeration enumeration=(Enumeration)fumlObject;
      if (enumeration.package_ != null)       Repository.INSTANCE.getMapping().mapEnumerationExternal(enumeration,getQualifiedPackageName(enumeration.package_),artifact);
 else       Repository.INSTANCE.getMapping().mapEnumerationExternal(enumeration,null,artifact);
    }
 else     if (fumlObject instanceof DataType) {
      if (!(fumlObject instanceof PrimitiveType)) {
        DataType datatype=(DataType)fumlObject;
        if (datatype.package_ != null)         Repository.INSTANCE.getMapping().mapDataType(datatype,getQualifiedPackageName(datatype.package_),artifact);
 else         Repository.INSTANCE.getMapping().mapDataType(datatype,null,artifact);
      }
    }
 else     if (fumlObject instanceof Property) {
      Property property=(Property)fumlObject;
      Repository.INSTANCE.getMapping().mapProperty(property.class_,property,this.artifact);
    }
 else     if (fumlObject instanceof EnumerationLiteral) {
      EnumerationLiteral literal=(EnumerationLiteral)fumlObject;
      Repository.INSTANCE.getMapping().mapEnumerationLiteral(literal,null,artifact);
    }
 else     if (fumlObject instanceof Package) {
      Package pkg=(Package)fumlObject;
      Repository.INSTANCE.getMapping().mapPackage(pkg,null,artifact);
    }
 else     if (fumlObject instanceof NamedElement) {
      NamedElement namedElement=(NamedElement)fumlObject;
      Repository.INSTANCE.getMapping().mapElementByName(namedElement,this.artifact);
      Repository.INSTANCE.getMapping().mapElementById(namedElement,this.artifact);
    }
 else     if (fumlObject instanceof Element) {
      Element element=(Element)fumlObject;
      Repository.INSTANCE.getMapping().mapElementById(element,this.artifact);
    }
 else     if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + fumlObject.getClass().getName());
  }
}","public void elementGraphAssembled(ElementAssemblerResultsEvent event){
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  Iterator<String> ids=event.getSource().getResultsXmiIds().iterator();
  while (ids.hasNext()) {
    String id=ids.next();
    FumlObject fumlObject=event.getSource().lookupResult(id);
    if (fumlObject == null) {
      log.warn(""String_Node_Str"" + id + ""String_Node_Str"");
      continue;
    }
    if (fumlObject instanceof NamedElement)     if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + fumlObject.getClass().getName() + ""String_Node_Str""+ ((NamedElement)fumlObject).qualifiedName+ ""String_Node_Str""+ id+ ""String_Node_Str"");
 else     if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + fumlObject.getClass().getName() + ""String_Node_Str""+ ""String_Node_Str""+ id+ ""String_Node_Str"");
    if (fumlObject instanceof Activity) {
      NamedElement namedElement=(NamedElement)fumlObject;
      Repository.INSTANCE.getMapping().mapElementByName(namedElement,this.artifact);
      Repository.INSTANCE.getMapping().mapElementById(namedElement,this.artifact);
    }
 else     if (fumlObject instanceof Class_ && !(fumlObject instanceof OpaqueBehavior)) {
      Class_ clss=(Class_)fumlObject;
      if (!(clss instanceof Stereotype)) {
        if (clss.package_ != null) {
          this.classList.add(Repository.INSTANCE.getMapping().mapClass(clss,getQualifiedPackageName(clss.package_),artifact));
        }
 else         this.classList.add(Repository.INSTANCE.getMapping().mapClass(clss,null,artifact));
      }
 else {
        Stereotype stereotype=(Stereotype)clss;
        if (stereotype.package_ != null)         this.classList.add(Repository.INSTANCE.getMapping().mapStereotype(stereotype,getQualifiedPackageName(stereotype.package_),artifact));
 else         this.classList.add(Repository.INSTANCE.getMapping().mapStereotype(stereotype,null,artifact));
      }
    }
 else     if (fumlObject instanceof Enumeration) {
      Enumeration enumeration=(Enumeration)fumlObject;
      if (enumeration.package_ != null)       Repository.INSTANCE.getMapping().mapEnumerationExternal(enumeration,getQualifiedPackageName(enumeration.package_),artifact);
 else       Repository.INSTANCE.getMapping().mapEnumerationExternal(enumeration,null,artifact);
    }
 else     if (fumlObject instanceof DataType) {
      if (!(fumlObject instanceof PrimitiveType)) {
        DataType datatype=(DataType)fumlObject;
        if (datatype.package_ != null)         Repository.INSTANCE.getMapping().mapDataType(datatype,getQualifiedPackageName(datatype.package_),artifact);
 else         Repository.INSTANCE.getMapping().mapDataType(datatype,null,artifact);
      }
    }
 else     if (fumlObject instanceof Property) {
      Property property=(Property)fumlObject;
      Repository.INSTANCE.getMapping().mapProperty(property.class_,property,this.artifact);
    }
 else     if (fumlObject instanceof EnumerationLiteral) {
      EnumerationLiteral literal=(EnumerationLiteral)fumlObject;
      Repository.INSTANCE.getMapping().mapEnumerationLiteral(literal,null,artifact);
    }
 else     if (fumlObject instanceof Package) {
      Package pkg=(Package)fumlObject;
      Repository.INSTANCE.getMapping().mapPackage(pkg,null,artifact);
    }
 else     if (fumlObject instanceof NamedElement) {
      NamedElement namedElement=(NamedElement)fumlObject;
      Repository.INSTANCE.getMapping().mapElementByName(namedElement,this.artifact);
      Repository.INSTANCE.getMapping().mapElementById(namedElement,this.artifact);
    }
 else     if (fumlObject instanceof Element) {
      Element element=(Element)fumlObject;
      Repository.INSTANCE.getMapping().mapElementById(element,this.artifact);
    }
 else     if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + fumlObject.getClass().getName());
  }
}"
12598,"public void mapPackageMerge(Package pkg,String sourcePackageXmiId);","public void mapPackageMerge(fUML.Syntax.Classes.Kernel.Package pkg,String sourcePackageXmiId);"
12599,"public void mapDataType(DataType t,String currentPackageName,RepositoryArtifact artifact);","public DataType mapDataType(fUML.Syntax.Classes.Kernel.DataType t,String currentPackageName,RepositoryArtifact artifact);"
12600,"public void mapClass(Class_ clss,String currentPackageName,RepositoryArtifact artifact);","public Class_ mapClass(fUML.Syntax.Classes.Kernel.Class_ clss,String currentPackageName,RepositoryArtifact artifact);"
12601,"public void mapPrimitiveType(PrimitiveType type,String currentPackageName,RepositoryArtifact artifact);","public Classifier mapPrimitiveType(fUML.Syntax.Classes.Kernel.PrimitiveType type,String currentPackageName,RepositoryArtifact artifact);"
12602,"public void mapElementByName(NamedElement element,RepositoryArtifact artifact);","public NamedElement mapElementByName(fUML.Syntax.Classes.Kernel.NamedElement element,RepositoryArtifact artifact);"
12603,"public void mapElementById(Element element,RepositoryArtifact artifact);","public Element mapElementById(fUML.Syntax.Classes.Kernel.Element element,RepositoryArtifact artifact);"
12604,"public void mapStereotype(Stereotype stereotype,String currentPackageName,RepositoryArtifact artifact);","public Stereotype mapStereotype(org.modeldriven.fuml.repository.ext.Stereotype stereotype,String currentPackageName,RepositoryArtifact artifact);"
12605,"public void mapClassifier(Classifier classifier,String currentPackageName,RepositoryArtifact artifact);","public Classifier mapClassifier(fUML.Syntax.Classes.Kernel.Classifier classifier,String currentPackageName,RepositoryArtifact artifact);"
12606,"public void mapEnumerationExternal(Enumeration e,String currentPackageName,RepositoryArtifact artifact);","public Enumeration mapEnumerationExternal(fUML.Syntax.Classes.Kernel.Enumeration e,String currentPackageName,RepositoryArtifact artifact);"
12607,"public void mapEnumerationLiteral(EnumerationLiteral literal,String currentPackageName,RepositoryArtifact artifact);","public EnumerationLiteral mapEnumerationLiteral(fUML.Syntax.Classes.Kernel.EnumerationLiteral literal,String currentPackageName,RepositoryArtifact artifact);"
12608,"public void mapEnumeration(Enumeration e,String currentPackageName,RepositoryArtifact artifact);","public Enumeration mapEnumeration(fUML.Syntax.Classes.Kernel.Enumeration e,String currentPackageName,RepositoryArtifact artifact);"
12609,"public void mapAssociation(Association assoc,String currentPackageName,RepositoryArtifact artifact);","public Association mapAssociation(fUML.Syntax.Classes.Kernel.Association assoc,String currentPackageName,RepositoryArtifact artifact);"
12610,"public void mapProperty(Classifier clss,Property proprty,RepositoryArtifact artifact);","public Property mapProperty(fUML.Syntax.Classes.Kernel.Classifier clss,fUML.Syntax.Classes.Kernel.Property proprty,RepositoryArtifact artifact);"
12611,"public void mapPackage(Package pkg,String currentPackageName,RepositoryArtifact artifact);","public Package mapPackage(fUML.Syntax.Classes.Kernel.Package pkg,String currentPackageName,RepositoryArtifact artifact);"
12612,"public Cookie(){
  cookiePtr=createCookie();
  if (cookiePtr == 0)   throw new OutOfMemoryError();
}","public Cookie(){
  cookiePtr=createCookie();
  if (cookiePtr == 0)   throw new RuntimeException(""String_Node_Str"");
}"
12613,"/** 
 * Registers the splash recipes for the given holywater bottle tier stack. Should only be used once and after the item has been registed
 * @param item The item
 * @param tier The tier
 */
@Deprecated public static void registerSplashRecipes(ItemHolyWaterBottle item,TIER tier){
  ItemStack base=item.setTier(new ItemStack(item),tier);
  Ingredient bottle=new IngredientNBT(base);
  Ingredient g=Ingredient.fromItem(Items.GUNPOWDER);
  ItemStack splash=item.setSplash(base.copy(),true);
  GameRegistry.addShapelessRecipe(new ResourceLocation(""String_Node_Str"" + tier + ""String_Node_Str""),null,splash.copy(),bottle,g);
  ItemStackUtil.grow(splash,1);
  GameRegistry.addShapelessRecipe(new ResourceLocation(""String_Node_Str"" + tier + ""String_Node_Str""),null,splash.copy(),bottle,bottle,g);
  ItemStackUtil.grow(splash,1);
  GameRegistry.addShapelessRecipe(new ResourceLocation(""String_Node_Str"" + tier + ""String_Node_Str""),null,splash.copy(),bottle,bottle,bottle,g);
  ItemStackUtil.grow(splash,1);
  GameRegistry.addShapelessRecipe(new ResourceLocation(""String_Node_Str"" + tier + ""String_Node_Str""),null,splash.copy(),bottle,bottle,bottle,bottle,g);
  ItemStackUtil.grow(splash,1);
  GameRegistry.addShapelessRecipe(new ResourceLocation(""String_Node_Str"" + tier + ""String_Node_Str""),null,splash.copy(),bottle,bottle,bottle,bottle,bottle,g);
}","/** 
 * Registers the splash recipes for the given holy water bottle tier stack. Should only be used once and after the item has been registered
 * @param item The item
 * @param tier The tier
 */
@Deprecated public static void registerSplashRecipes(ItemHolyWaterBottle item,TIER tier){
  ItemStack base=item.setTier(new ItemStack(item),tier);
  Ingredient bottle=new IngredientNBT(base);
  Ingredient g=Ingredient.fromItem(Items.GUNPOWDER);
  ItemStack splash=item.setSplash(base.copy(),true);
  GameRegistry.addShapedRecipe(new ResourceLocation(""String_Node_Str"" + tier + ""String_Node_Str""),null,splash.copy(),""String_Node_Str"",'X',bottle,'Y',g);
  ItemStackUtil.grow(splash,1);
  GameRegistry.addShapedRecipe(new ResourceLocation(""String_Node_Str"" + tier + ""String_Node_Str""),null,splash.copy(),""String_Node_Str"",'X',bottle,'Y',g);
  ItemStackUtil.grow(splash,1);
  GameRegistry.addShapedRecipe(new ResourceLocation(""String_Node_Str"" + tier + ""String_Node_Str""),null,splash.copy(),""String_Node_Str"",""String_Node_Str"",'X',bottle,'Y',g);
  ItemStackUtil.grow(splash,1);
  GameRegistry.addShapedRecipe(new ResourceLocation(""String_Node_Str"" + tier + ""String_Node_Str""),null,splash.copy(),""String_Node_Str"",""String_Node_Str"",'X',bottle,'Y',g);
  ItemStackUtil.grow(splash,1);
  GameRegistry.addShapedRecipe(new ResourceLocation(""String_Node_Str"" + tier + ""String_Node_Str""),null,splash.copy(),""String_Node_Str"",""String_Node_Str"",'X',bottle,'Y',g);
}"
12614,"@Nonnull @Override public ActionResult<ItemStack> onItemRightClick(World worldIn,EntityPlayer playerIn,EnumHand handIn){
  ItemStack stack=playerIn.getHeldItem(handIn);
  if (isSplash(stack)) {
    if (!playerIn.capabilities.isCreativeMode) {
      ItemStackUtil.decr(stack);
    }
    worldIn.playSound(null,playerIn.posX,playerIn.posY,playerIn.posZ,SoundEvents.ENTITY_SPLASH_POTION_THROW,SoundCategory.NEUTRAL,0.5F,0.4F / (itemRand.nextFloat() * 0.4F + 0.8F));
    if (!worldIn.isRemote) {
      EntityThrowableItem entityThrowable=new EntityThrowableItem(worldIn,playerIn);
      entityThrowable.setItem(stack);
      entityThrowable.shoot(playerIn,playerIn.rotationPitch,playerIn.rotationYaw,-20.0F,0.5F,1.0F);
      worldIn.spawnEntity(entityThrowable);
    }
    playerIn.addStat(StatList.getObjectUseStats(this));
    return new ActionResult<>(EnumActionResult.SUCCESS,stack);
  }
  return new ActionResult<>(EnumActionResult.PASS,stack);
}","@Nonnull @Override public ActionResult<ItemStack> onItemRightClick(World worldIn,EntityPlayer playerIn,EnumHand handIn){
  ItemStack stack=playerIn.getHeldItem(handIn);
  if (isSplash(stack)) {
    worldIn.playSound(null,playerIn.posX,playerIn.posY,playerIn.posZ,SoundEvents.ENTITY_SPLASH_POTION_THROW,SoundCategory.NEUTRAL,0.5F,0.4F / (itemRand.nextFloat() * 0.4F + 0.8F));
    if (!worldIn.isRemote) {
      EntityThrowableItem entityThrowable=new EntityThrowableItem(worldIn,playerIn);
      ItemStack throwStack=stack.copy();
      throwStack.setCount(1);
      entityThrowable.setItem(throwStack);
      entityThrowable.shoot(playerIn,playerIn.rotationPitch,playerIn.rotationYaw,-20.0F,0.5F,1.0F);
      worldIn.spawnEntity(entityThrowable);
    }
    playerIn.addStat(StatList.getObjectUseStats(this));
    if (!playerIn.capabilities.isCreativeMode) {
      ItemStackUtil.decr(stack);
    }
    return new ActionResult<>(EnumActionResult.SUCCESS,stack);
  }
  return new ActionResult<>(EnumActionResult.PASS,stack);
}"
12615,"private static Map<ResourceLocation,EntryAbstract> buildItems(){
  Map<ResourceLocation,EntryAbstract> entries=new LinkedHashMap<>();
  String base=""String_Node_Str"";
  new ItemInfoBuilder(ModItems.vampire_fang).build(entries);
  new ItemInfoBuilder(ModItems.human_heart).build(entries);
  new ItemInfoBuilder(ModItems.pure_blood).setFormats(UtilLib.translate(""String_Node_Str"" + ModEntities.VAMPIRE_BARON + ""String_Node_Str"")).build(entries);
  new ItemInfoBuilder(ModItems.vampire_blood_bottle).setFormats(UtilLib.translate(""String_Node_Str"" + ModEntities.BASIC_VAMPIRE_NAME + ""String_Node_Str""),ModItems.stake.getLocalizedName(),UtilLib.translate(""String_Node_Str"" + ModEntities.ADVANCED_VAMPIRE + ""String_Node_Str"")).build(entries);
  new ItemInfoBuilder(ModItems.vampire_book).build(entries);
  new ItemInfoBuilder(new ItemStack(ModItems.blood_bottle,1,ItemBloodBottle.AMOUNT),false).build(entries);
  new ItemInfoBuilder(ModItems.blood_infused_iron_ingot).craftableStacks(ModItems.blood_infused_iron_ingot,WORKBENCH,ModItems.blood_infused_enhanced_iron_ingot,WORKBENCH).build(entries);
  addItemWithTier(ModItems.heart_seeker,WORKBENCH).setLinks(new ResourceLocation(""String_Node_Str""),new ResourceLocation(""String_Node_Str"")).build(entries);
  addItemWithTier(ModItems.heart_striker,WORKBENCH).setLinks(new ResourceLocation(""String_Node_Str""),new ResourceLocation(""String_Node_Str"")).build(entries);
  new ItemInfoBuilder(ModItems.injection).craftableStacks(new ItemStack(ModItems.injection,1,0),WORKBENCH,new ItemStack(ModItems.injection,1,ItemInjection.META_GARLIC),WORKBENCH,new ItemStack(ModItems.injection,1,ItemInjection.META_SANGUINARE),WORKBENCH).build(entries);
  new ItemInfoBuilder(ModItems.hunter_intel).setLinks(new ResourceLocation(""String_Node_Str"")).setFormats(ModBlocks.hunter_table.getLocalizedName()).build(entries);
  new ItemInfoBuilder(ModItems.item_garlic).build(entries);
  new ItemInfoBuilder(ModItems.purified_garlic).setFormats(ModBlocks.garlic_beacon.getLocalizedName()).setLinks(new ResourceLocation(""String_Node_Str"")).craftable(ALCHEMICAL_CAULDRON).build(entries);
  new ItemInfoBuilder(ModItems.pitchfork).craftable(WEAPON_TABLE).build(entries);
  new ItemInfoBuilder(ModItems.stake).setFormats(((int)(Balance.hps.INSTANT_KILL_SKILL_1_MAX_HEALTH_PERC * 100)) + ""String_Node_Str"").craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModItems.basic_crossbow).setFormats(ModItems.crossbow_arrow.getLocalizedName(),ModItems.tech_crossbow_ammo_package.getLocalizedName()).setLinks(new ResourceLocation(""String_Node_Str"")).craftableStacks(ModItems.basic_crossbow,WEAPON_TABLE,ModItems.basic_double_crossbow,WEAPON_TABLE,ModItems.enhanced_crossbow,WEAPON_TABLE,ModItems.enhanced_double_crossbow,WEAPON_TABLE,ModItems.basic_tech_crossbow,WEAPON_TABLE,ModItems.tech_crossbow_ammo_package,WEAPON_TABLE).setName(""String_Node_Str"").customName().build(entries);
  new ItemInfoBuilder(ModItems.crossbow_arrow).craftableStacks(ModItems.crossbow_arrow.getStack(ItemCrossbowArrow.EnumArrowType.NORMAL),WORKBENCH,ModItems.crossbow_arrow.getStack(ItemCrossbowArrow.EnumArrowType.VAMPIRE_KILLER),WEAPON_TABLE,ModItems.crossbow_arrow.getStack(ItemCrossbowArrow.EnumArrowType.SPITFIRE),WEAPON_TABLE).build(entries);
  new ItemInfoBuilder(ModItems.holy_water_bottle).setLinks(new ResourceLocation(""String_Node_Str""),new ResourceLocation(""String_Node_Str"")).setFormats(ModItems.holy_salt_water.getLocalizedName(),ModItems.holy_salt_water.getLocalizedName(),ModItems.holy_salt.getLocalizedName()).craftableStacks(ModItems.holy_salt_water,WORKBENCH).build(entries);
  new ItemInfoBuilder(ModItems.holy_salt).setLinks(new ResourceLocation(""String_Node_Str"")).setFormats(ModItems.pure_salt.getLocalizedName(),ModItems.pure_salt.getLocalizedName(),ModBlocks.alchemical_cauldron.getLocalizedName()).craftableStacks(ModItems.pure_salt,ALCHEMICAL_CAULDRON).build(entries);
  new ItemInfoBuilder(ModItems.item_alchemical_fire).setLinks(new ResourceLocation(""String_Node_Str"")).craftable(ALCHEMICAL_CAULDRON).build(entries);
  addArmorWithTier(entries,""String_Node_Str"",ModItems.armor_of_swiftness_head,ModItems.armor_of_swiftness_chest,ModItems.armor_of_swiftness_legs,ModItems.armor_of_swiftness_feet,WEAPON_TABLE);
  addArmorWithTier(entries,""String_Node_Str"",ModItems.hunter_coat_head,ModItems.hunter_coat_chest,ModItems.hunter_coat_legs,ModItems.hunter_coat_feet,WEAPON_TABLE);
  addArmorWithTier(entries,""String_Node_Str"",ModItems.obsidian_armor_head,ModItems.obsidian_armor_chest,ModItems.obsidian_armor_legs,ModItems.obsidian_armor_feet,WEAPON_TABLE);
  addItemWithTier(ModItems.hunter_axe,WEAPON_TABLE).build(entries);
  links.putAll(entries);
  return entries;
}","private static Map<ResourceLocation,EntryAbstract> buildItems(){
  Map<ResourceLocation,EntryAbstract> entries=new LinkedHashMap<>();
  String base=""String_Node_Str"";
  new ItemInfoBuilder(ModItems.vampire_fang).build(entries);
  new ItemInfoBuilder(ModItems.human_heart).build(entries);
  new ItemInfoBuilder(ModItems.pure_blood).setFormats(UtilLib.translate(""String_Node_Str"" + ModEntities.VAMPIRE_BARON + ""String_Node_Str"")).build(entries);
  new ItemInfoBuilder(ModItems.vampire_blood_bottle).setFormats(UtilLib.translate(""String_Node_Str"" + ModEntities.BASIC_VAMPIRE_NAME + ""String_Node_Str""),ModItems.stake.getLocalizedName(),UtilLib.translate(""String_Node_Str"" + ModEntities.ADVANCED_VAMPIRE + ""String_Node_Str"")).build(entries);
  new ItemInfoBuilder(ModItems.vampire_book).build(entries);
  new ItemInfoBuilder(new ItemStack(ModItems.blood_bottle,1,ItemBloodBottle.AMOUNT),false).build(entries);
  new ItemInfoBuilder(ModItems.blood_infused_iron_ingot).craftableStacks(ModItems.blood_infused_iron_ingot,WORKBENCH,ModItems.blood_infused_enhanced_iron_ingot,WORKBENCH).build(entries);
  addItemWithTier(ModItems.heart_seeker,WORKBENCH).setLinks(new ResourceLocation(""String_Node_Str""),new ResourceLocation(""String_Node_Str"")).build(entries);
  addItemWithTier(ModItems.heart_striker,WORKBENCH).setLinks(new ResourceLocation(""String_Node_Str""),new ResourceLocation(""String_Node_Str"")).build(entries);
  new ItemInfoBuilder(ModItems.injection).craftableStacks(new ItemStack(ModItems.injection,1,0),WORKBENCH,new ItemStack(ModItems.injection,1,ItemInjection.META_GARLIC),WORKBENCH,new ItemStack(ModItems.injection,1,ItemInjection.META_SANGUINARE),WORKBENCH).build(entries);
  new ItemInfoBuilder(ModItems.hunter_intel).setLinks(new ResourceLocation(""String_Node_Str"")).setFormats(ModBlocks.hunter_table.getLocalizedName()).build(entries);
  new ItemInfoBuilder(ModItems.item_garlic).build(entries);
  new ItemInfoBuilder(ModItems.purified_garlic).setFormats(ModBlocks.garlic_beacon.getLocalizedName()).setLinks(new ResourceLocation(""String_Node_Str"")).craftable(ALCHEMICAL_CAULDRON).build(entries);
  new ItemInfoBuilder(ModItems.pitchfork).craftable(WEAPON_TABLE).build(entries);
  new ItemInfoBuilder(ModItems.stake).setFormats(((int)(Balance.hps.INSTANT_KILL_SKILL_1_MAX_HEALTH_PERC * 100)) + ""String_Node_Str"").craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModItems.basic_crossbow).setFormats(ModItems.crossbow_arrow.getLocalizedName(),ModItems.tech_crossbow_ammo_package.getLocalizedName()).setLinks(new ResourceLocation(""String_Node_Str"")).craftableStacks(ModItems.basic_crossbow,WEAPON_TABLE,ModItems.basic_double_crossbow,WEAPON_TABLE,ModItems.enhanced_crossbow,WEAPON_TABLE,ModItems.enhanced_double_crossbow,WEAPON_TABLE,ModItems.basic_tech_crossbow,WEAPON_TABLE,ModItems.tech_crossbow_ammo_package,WEAPON_TABLE).setName(""String_Node_Str"").customName().build(entries);
  new ItemInfoBuilder(ModItems.crossbow_arrow).craftableStacks(ModItems.crossbow_arrow.getStack(ItemCrossbowArrow.EnumArrowType.NORMAL),WORKBENCH,ModItems.crossbow_arrow.getStack(ItemCrossbowArrow.EnumArrowType.VAMPIRE_KILLER),WEAPON_TABLE,ModItems.crossbow_arrow.getStack(ItemCrossbowArrow.EnumArrowType.SPITFIRE),WEAPON_TABLE).build(entries);
  new ItemInfoBuilder(ModItems.holy_water_bottle).setLinks(new ResourceLocation(""String_Node_Str""),new ResourceLocation(""String_Node_Str"")).setFormats(ModItems.holy_salt_water.getLocalizedName(),ModItems.holy_salt_water.getLocalizedName(),ModItems.holy_salt.getLocalizedName()).craftableStacks(ModItems.holy_salt_water,WORKBENCH,ModItems.holy_water_bottle.setTier(ModItems.holy_water_bottle.setSplash(new ItemStack(ModItems.holy_water_bottle),true),IItemWithTier.TIER.NORMAL),WORKBENCH,ModItems.holy_water_bottle.setTier(ModItems.holy_water_bottle.setSplash(new ItemStack(ModItems.holy_water_bottle,5),true),IItemWithTier.TIER.NORMAL),WORKBENCH).build(entries);
  new ItemInfoBuilder(ModItems.holy_salt).setLinks(new ResourceLocation(""String_Node_Str"")).setFormats(ModItems.pure_salt.getLocalizedName(),ModItems.pure_salt.getLocalizedName(),ModBlocks.alchemical_cauldron.getLocalizedName()).craftableStacks(ModItems.pure_salt,ALCHEMICAL_CAULDRON).build(entries);
  new ItemInfoBuilder(ModItems.item_alchemical_fire).setLinks(new ResourceLocation(""String_Node_Str"")).craftable(ALCHEMICAL_CAULDRON).build(entries);
  addArmorWithTier(entries,""String_Node_Str"",ModItems.armor_of_swiftness_head,ModItems.armor_of_swiftness_chest,ModItems.armor_of_swiftness_legs,ModItems.armor_of_swiftness_feet,WEAPON_TABLE);
  addArmorWithTier(entries,""String_Node_Str"",ModItems.hunter_coat_head,ModItems.hunter_coat_chest,ModItems.hunter_coat_legs,ModItems.hunter_coat_feet,WEAPON_TABLE);
  addArmorWithTier(entries,""String_Node_Str"",ModItems.obsidian_armor_head,ModItems.obsidian_armor_chest,ModItems.obsidian_armor_legs,ModItems.obsidian_armor_feet,WEAPON_TABLE);
  addItemWithTier(ModItems.hunter_axe,WEAPON_TABLE).build(entries);
  links.putAll(entries);
  return entries;
}"
12616,"NBTTagCompound writeFullUpdate(NBTTagCompound nbt){
  nbt=writeUpdate(nbt);
  nbt.setInteger(""String_Node_Str"",maxBlood);
  return nbt;
}","NBTTagCompound writeFullUpdate(NBTTagCompound nbt){
  writeUpdate(nbt);
  nbt.setInteger(""String_Node_Str"",maxBlood);
  return nbt;
}"
12617,"@Override public void onContainerClosed(EntityPlayer playerIn){
  super.onContainerClosed(playerIn);
  if (!playerIn.getEntityWorld().isRemote) {
    for (int i=0; i < 1; ++i) {
      ItemStack itemstack=this.tile.removeStackFromSlot(i);
      if (!ItemStackUtil.isEmpty(itemstack)) {
        playerIn.dropItem(itemstack,false);
      }
    }
  }
}","@Override public void onContainerClosed(EntityPlayer playerIn){
  super.onContainerClosed(playerIn);
  if (!playerIn.getEntityWorld().isRemote) {
    for (int i=0; i < this.tile.getSizeInventory(); ++i) {
      ItemStack itemstack=this.tile.removeStackFromSlot(i);
      if (!ItemStackUtil.isEmpty(itemstack)) {
        playerIn.dropItem(itemstack,false);
      }
    }
  }
}"
12618,"public void onContainerClosed(EntityPlayer playerIn){
  super.onContainerClosed(playerIn);
  if (!playerIn.getEntityWorld().isRemote) {
    for (int i=0; i < 4; ++i) {
      ItemStack itemstack=this.inventory.removeStackFromSlot(i);
      if (!ItemStackUtil.isEmpty(itemstack)) {
        playerIn.dropItem(itemstack,false);
      }
    }
  }
}","public void onContainerClosed(EntityPlayer playerIn){
  super.onContainerClosed(playerIn);
  if (!playerIn.getEntityWorld().isRemote) {
    for (int i=0; i < this.inventory.getSizeInventory(); ++i) {
      ItemStack itemstack=this.inventory.removeStackFromSlot(i);
      if (!ItemStackUtil.isEmpty(itemstack)) {
        playerIn.dropItem(itemstack,false);
      }
    }
  }
}"
12619,"@Override public void onContainerClosed(EntityPlayer playerIn){
  super.onContainerClosed(playerIn);
  if (!playerIn.getEntityWorld().isRemote) {
    for (int i=0; i < 3; ++i) {
      ItemStack itemstack=this.tile.removeStackFromSlot(i);
      if (!ItemStackUtil.isEmpty(itemstack)) {
        playerIn.dropItem(itemstack,false);
      }
    }
  }
}","@Override public void onContainerClosed(EntityPlayer playerIn){
  super.onContainerClosed(playerIn);
  if (!playerIn.getEntityWorld().isRemote) {
    for (int i=0; i < tile.getSizeInventory(); ++i) {
      ItemStack itemstack=this.tile.removeStackFromSlot(i);
      if (!ItemStackUtil.isEmpty(itemstack)) {
        playerIn.dropItem(itemstack,false);
      }
    }
  }
}"
12620,"public void onContainerClosed(EntityPlayer playerIn){
  super.onContainerClosed(playerIn);
  if (!this.world.isRemote) {
    for (int i=0; i < 9; ++i) {
      ItemStack itemstack=this.craftMatrix.removeStackFromSlot(i);
      if (!ItemStackUtil.isEmpty(itemstack)) {
        playerIn.dropItem(itemstack,false);
      }
    }
  }
}","public void onContainerClosed(EntityPlayer playerIn){
  super.onContainerClosed(playerIn);
  if (!this.world.isRemote) {
    for (int i=0; i < this.craftMatrix.getSizeInventory(); ++i) {
      ItemStack itemstack=this.craftMatrix.removeStackFromSlot(i);
      if (!ItemStackUtil.isEmpty(itemstack)) {
        playerIn.dropItem(itemstack,false);
      }
    }
  }
}"
12621,"@Override public ItemStack transferStackInSlot(EntityPlayer player,int slot){
  ItemStack stack=ItemStackUtil.getEmptyStack();
  net.minecraft.inventory.Slot slotObject=inventorySlots.get(slot);
  ItemStack stackInSlot;
  if (slotObject != null && !ItemStackUtil.isEmpty(stackInSlot=slotObject.getStack())) {
    stack=stackInSlot.copy();
    if (slot < tile.getSlots().length) {
      if (!this.mergeItemStack(stackInSlot,tile.getSlots().length,tile.getSlots().length + 36,true)) {
        return null;
      }
    }
 else     if (!this.mergeItemStack(stackInSlot,0,tile.getSlots().length,false)) {
      return null;
    }
    if (ItemStackUtil.getCount(stack) == 0) {
      slotObject.putStack(ItemStackUtil.getEmptyStack());
    }
 else {
      slotObject.onSlotChanged();
    }
    if (ItemStackUtil.getCount(stackInSlot) == ItemStackUtil.getCount(stack)) {
      return ItemStackUtil.getEmptyStack();
    }
    slotObject.onTake(player,stackInSlot);
  }
  return stack;
}","@Nonnull @Override public ItemStack transferStackInSlot(EntityPlayer player,int slot){
  ItemStack stack=ItemStackUtil.getEmptyStack();
  net.minecraft.inventory.Slot slotObject=inventorySlots.get(slot);
  ItemStack stackInSlot;
  if (slotObject != null && !ItemStackUtil.isEmpty(stackInSlot=slotObject.getStack())) {
    stack=stackInSlot.copy();
    if (slot < tile.getSlots().length) {
      if (!this.mergeItemStack(stackInSlot,tile.getSlots().length,tile.getSlots().length + 36,true)) {
        return ItemStackUtil.getEmptyStack();
      }
    }
 else     if (!this.mergeItemStack(stackInSlot,0,tile.getSlots().length,false)) {
      return ItemStackUtil.getEmptyStack();
    }
    if (ItemStackUtil.getCount(stack) == 0) {
      slotObject.putStack(ItemStackUtil.getEmptyStack());
    }
 else {
      slotObject.onSlotChanged();
    }
    if (ItemStackUtil.getCount(stackInSlot) == ItemStackUtil.getCount(stack)) {
      return ItemStackUtil.getEmptyStack();
    }
    slotObject.onTake(player,stackInSlot);
  }
  return stack;
}"
12622,"@Nullable public ItemStack transferStackInSlot(EntityPlayer playerIn,int index){
  ItemStack itemstack=ItemStackUtil.getEmptyStack();
  Slot slot=this.inventorySlots.get(index);
  if (slot != null && slot.getHasStack()) {
    ItemStack itemstack1=slot.getStack();
    itemstack=itemstack1.copy();
    if (index >= 0 && index < 4) {
      if (!this.mergeItemStack(itemstack1,3,39,true)) {
        return null;
      }
    }
 else     if (index >= 3 && index < 30) {
      if (!this.mergeItemStack(itemstack1,30,39,false)) {
        return null;
      }
    }
 else     if (index >= 30 && index < 39) {
      if (!this.mergeItemStack(itemstack1,3,30,false)) {
        return null;
      }
    }
 else     if (!this.mergeItemStack(itemstack1,3,39,false)) {
      return null;
    }
    if (ItemStackUtil.isEmpty(itemstack1)) {
      slot.putStack(ItemStackUtil.getEmptyStack());
    }
 else {
      slot.onSlotChanged();
    }
    if (ItemStackUtil.getCount(itemstack) == ItemStackUtil.getCount(itemstack1)) {
      return ItemStackUtil.getEmptyStack();
    }
    slot.onTake(playerIn,itemstack1);
  }
  return itemstack;
}","@Nonnull public ItemStack transferStackInSlot(EntityPlayer playerIn,int index){
  ItemStack itemstack=ItemStackUtil.getEmptyStack();
  Slot slot=this.inventorySlots.get(index);
  if (slot != null && slot.getHasStack()) {
    ItemStack itemstack1=slot.getStack();
    itemstack=itemstack1.copy();
    if (index >= 0 && index < 4) {
      if (!this.mergeItemStack(itemstack1,3,39,true)) {
        return ItemStackUtil.getEmptyStack();
      }
    }
 else     if (index >= 3 && index < 30) {
      if (!this.mergeItemStack(itemstack1,30,39,false)) {
        return ItemStackUtil.getEmptyStack();
      }
    }
 else     if (index >= 30 && index < 39) {
      if (!this.mergeItemStack(itemstack1,3,30,false)) {
        return ItemStackUtil.getEmptyStack();
      }
    }
 else     if (!this.mergeItemStack(itemstack1,3,39,false)) {
      return ItemStackUtil.getEmptyStack();
    }
    if (ItemStackUtil.isEmpty(itemstack1)) {
      slot.putStack(ItemStackUtil.getEmptyStack());
    }
 else {
      slot.onSlotChanged();
    }
    if (ItemStackUtil.getCount(itemstack) == ItemStackUtil.getCount(itemstack1)) {
      return ItemStackUtil.getEmptyStack();
    }
    slot.onTake(playerIn,itemstack1);
  }
  return itemstack;
}"
12623,"@Nullable public ItemStack transferStackInSlot(EntityPlayer playerIn,int index){
  ItemStack itemstack=ItemStackUtil.getEmptyStack();
  Slot slot=this.inventorySlots.get(index);
  if (slot != null && slot.getHasStack()) {
    ItemStack itemstack1=slot.getStack();
    itemstack=itemstack1.copy();
    if (index == 0) {
      if (!this.mergeItemStack(itemstack1,17,53,true)) {
        return null;
      }
      slot.onSlotChange(itemstack1,itemstack);
    }
 else     if (index >= 17 && index < 44) {
      if (!this.mergeItemStack(itemstack1,44,53,false)) {
        return null;
      }
    }
 else     if (index >= 44 && index < 53) {
      if (!this.mergeItemStack(itemstack1,17,44,false)) {
        return null;
      }
    }
 else     if (!this.mergeItemStack(itemstack1,17,53,false)) {
      return null;
    }
    if (ItemStackUtil.isEmpty(itemstack)) {
      slot.putStack(ItemStackUtil.getEmptyStack());
    }
 else {
      slot.onSlotChanged();
    }
    if (ItemStackUtil.getCount(itemstack) == ItemStackUtil.getCount(itemstack1)) {
      return ItemStackUtil.getEmptyStack();
    }
    slot.onTake(playerIn,itemstack1);
  }
  return itemstack;
}","@Nonnull public ItemStack transferStackInSlot(EntityPlayer playerIn,int index){
  ItemStack itemstack=ItemStackUtil.getEmptyStack();
  Slot slot=this.inventorySlots.get(index);
  if (slot != null && slot.getHasStack()) {
    ItemStack itemstack1=slot.getStack();
    itemstack=itemstack1.copy();
    if (index == 0) {
      if (!this.mergeItemStack(itemstack1,17,53,true)) {
        return ItemStackUtil.getEmptyStack();
      }
      slot.onSlotChange(itemstack1,itemstack);
    }
 else     if (index >= 17 && index < 44) {
      if (!this.mergeItemStack(itemstack1,44,53,false)) {
        return ItemStackUtil.getEmptyStack();
      }
    }
 else     if (index >= 44 && index < 53) {
      if (!this.mergeItemStack(itemstack1,17,44,false)) {
        return ItemStackUtil.getEmptyStack();
      }
    }
 else     if (!this.mergeItemStack(itemstack1,17,53,false)) {
      return ItemStackUtil.getEmptyStack();
    }
    if (ItemStackUtil.isEmpty(itemstack)) {
      slot.putStack(ItemStackUtil.getEmptyStack());
    }
 else {
      slot.onSlotChanged();
    }
    if (ItemStackUtil.getCount(itemstack) == ItemStackUtil.getCount(itemstack1)) {
      return ItemStackUtil.getEmptyStack();
    }
    slot.onTake(playerIn,itemstack1);
  }
  return itemstack;
}"
12624,"@SubscribeEvent(priority=EventPriority.HIGHEST) public void onPlayerInteract(PlayerInteractEvent.RightClickBlock event){
  if (Configs.autoConvertGlasBottles) {
    if (event.getWorld().getWorldBorder().contains(event.getPos())) {
      ItemStack stack=event.getItemStack();
      if (!ItemStackUtil.isEmpty(stack) && stack.getItem().equals(Items.GLASS_BOTTLE) && ItemStackUtil.getCount(stack) == 1) {
        Block block=event.getWorld().getBlockState(event.getPos()).getBlock();
        boolean flag=false;
        if (block instanceof IFluidTank) {
          VampirismMod.log.d(""String_Node_Str"",""String_Node_Str"",block.getClass());
          if (ModFluids.blood.equals(((IFluidTank)block).getFluid())) {
            flag=true;
          }
        }
 else         if (block instanceof ITileEntityProvider) {
          TileEntity entity=event.getWorld().getTileEntity(event.getPos());
          if (entity != null && entity.hasCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,event.getFace())) {
            net.minecraftforge.fluids.capability.IFluidHandler fluidHandler=entity.getCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,event.getFace());
            FluidStack drain=fluidHandler.drain(new FluidStack(ModFluids.blood,1000),false);
            if (drain != null && drain.amount >= BloodBottleFluidHandler.MULTIPLIER) {
              flag=true;
            }
          }
          if (flag && block instanceof BlockAltarInspiration) {
            flag=false;
          }
          if (flag && block instanceof BlockBloodContainer) {
            flag=event.getEntityPlayer().isSneaking();
          }
        }
        if (flag) {
          stack.deserializeNBT(new ItemStack(ModItems.bloodBottle).serializeNBT());
        }
      }
    }
  }
}","@SubscribeEvent(priority=EventPriority.HIGHEST) public void onPlayerInteract(PlayerInteractEvent.RightClickBlock event){
  if (event.getWorld().getWorldBorder().contains(event.getPos())) {
    ItemStack heldStack=event.getItemStack();
    if (!ItemStackUtil.isEmpty(heldStack) && ItemStackUtil.getCount(heldStack) == 1) {
      boolean glasBottle=Items.GLASS_BOTTLE.equals(heldStack.getItem());
      boolean bloodBottle=ModItems.bloodBottle.equals(heldStack.getItem());
      if (bloodBottle || (glasBottle && Configs.autoConvertGlasBottles)) {
        Block block=event.getWorld().getBlockState(event.getPos()).getBlock();
        boolean convert=false;
        if (glasBottle && block instanceof ITileEntityProvider) {
          TileEntity entity=event.getWorld().getTileEntity(event.getPos());
          if (entity != null && entity.hasCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,event.getFace())) {
            net.minecraftforge.fluids.capability.IFluidHandler fluidHandler=entity.getCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,event.getFace());
            FluidStack drain=fluidHandler.drain(new FluidStack(ModFluids.blood,1000),false);
            if (drain != null && drain.amount >= BloodBottleFluidHandler.MULTIPLIER) {
              convert=true;
            }
            if (convert && block instanceof BlockAltarInspiration) {
              convert=false;
            }
            if (convert && block instanceof BlockBloodContainer) {
              convert=event.getEntityPlayer().isSneaking();
            }
          }
        }
        if ((bloodBottle || convert) && block instanceof BlockBloodContainer) {
          event.setUseBlock(Event.Result.ALLOW);
        }
        if (convert) {
          heldStack.deserializeNBT(new ItemStack(ModItems.bloodBottle).serializeNBT());
        }
      }
    }
  }
}"
12625,"/** 
 * Checks if the given stack has a   {@link CapabilityFluidHandler#FLUID_HANDLER_CAPABILITY} and contains the required fluid, if so it returns the required Fluid Stack otherwise null.
 * @param stack may be EMPTY
 * @return If nonnull the ItemStack has a {@link CapabilityFluidHandler#FLUID_HANDLER_CAPABILITY} and contains the required (and returned) fluid.
 */
@Nullable FluidStack isValidFluidItem(@Nonnull ItemStack stack);","/** 
 * Checks if the given stack has a   {@link CapabilityFluidHandler#FLUID_HANDLER_ITEM_CAPABILITY} and contains the required fluid, if so it returns the required Fluid Stack otherwise null.
 * @param stack may be EMPTY
 * @return If nonnull the ItemStack has a {@link CapabilityFluidHandler#FLUID_HANDLER_ITEM_CAPABILITY} and contains the required (and returned) fluid.
 */
@Nullable FluidStack isValidFluidItem(@Nonnull ItemStack stack);"
12626,"/** 
 * Used for items without   {@link CapabilityFluidHandler#FLUID_HANDLER_CAPABILITY}
 * @param stack may be EMPTY
 * @return If the given stack contains the required 'liquid' item stack
 */
boolean isValidLiquidItem(@Nonnull ItemStack stack);","/** 
 * Used for items without   {@link CapabilityFluidHandler#FLUID_HANDLER_ITEM_CAPABILITY}
 * @param stack may be EMPTY
 * @return If the given stack contains the required 'liquid' item stack
 */
boolean isValidLiquidItem(@Nonnull ItemStack stack);"
12627,"@Override public boolean onBlockActivated(World worldIn,BlockPos pos,IBlockState state,EntityPlayer playerIn,EnumHand hand,EnumFacing facing,float hitX,float hitY,float hitZ){
  ItemStack stack=playerIn.getHeldItem(hand);
  if (!ItemStackUtil.isEmpty(stack) && !worldIn.isRemote) {
    if (stack.hasCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,null)) {
      TileAltarInspiration tileEntity=(TileAltarInspiration)worldIn.getTileEntity(pos);
      if (!playerIn.isSneaking()) {
        FluidActionResult result=FluidUtil.tryEmptyContainer(stack,tileEntity.getCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,null),Integer.MAX_VALUE,playerIn,true);
        if (result.isSuccess()) {
          playerIn.setHeldItem(hand,result.getResult());
        }
      }
      worldIn.notifyBlockUpdate(pos,state,state,3);
      tileEntity.markDirty();
      return true;
    }
  }
  if (ItemStackUtil.isEmpty(stack)) {
    TileAltarInspiration tileEntity=(TileAltarInspiration)worldIn.getTileEntity(pos);
    tileEntity.startRitual(playerIn);
  }
  return true;
}","@Override public boolean onBlockActivated(World worldIn,BlockPos pos,IBlockState state,EntityPlayer playerIn,EnumHand hand,EnumFacing facing,float hitX,float hitY,float hitZ){
  ItemStack stack=playerIn.getHeldItem(hand);
  if (!ItemStackUtil.isEmpty(stack) && !worldIn.isRemote) {
    if (FluidLib.hasFluidItemCap(stack)) {
      TileAltarInspiration tileEntity=(TileAltarInspiration)worldIn.getTileEntity(pos);
      if (!playerIn.isSneaking()) {
        FluidActionResult result=FluidUtil.tryEmptyContainer(stack,tileEntity.getCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,null),Integer.MAX_VALUE,playerIn,true);
        if (result.isSuccess()) {
          playerIn.setHeldItem(hand,result.getResult());
        }
      }
      worldIn.notifyBlockUpdate(pos,state,state,3);
      tileEntity.markDirty();
      return true;
    }
  }
  if (ItemStackUtil.isEmpty(stack)) {
    TileAltarInspiration tileEntity=(TileAltarInspiration)worldIn.getTileEntity(pos);
    tileEntity.startRitual(playerIn);
  }
  return true;
}"
12628,"@Override public boolean onBlockActivated(World worldIn,BlockPos pos,IBlockState state,EntityPlayer playerIn,EnumHand hand,EnumFacing facing,float hitX,float hitY,float hitZ){
  if (!worldIn.isRemote) {
    ItemStack stack=playerIn.getHeldItem(hand);
    if (!ItemStackUtil.isEmpty(stack) && stack.hasCapability(CapabilityFluidHandler.FLUID_HANDLER_ITEM_CAPABILITY,null)) {
      TileBloodContainer bloodContainer=(TileBloodContainer)worldIn.getTileEntity(pos);
      IFluidHandler source=bloodContainer.getCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,null);
      if (playerIn.isSneaking()) {
        FluidActionResult result=FluidUtil.tryFillContainer(stack,source,Integer.MAX_VALUE,playerIn,true);
        if (result.isSuccess()) {
          playerIn.setHeldItem(hand,result.getResult());
        }
      }
 else {
        FluidActionResult result=FluidUtil.tryEmptyContainer(stack,source,Integer.MAX_VALUE,playerIn,true);
        if (result.isSuccess()) {
          playerIn.setHeldItem(hand,result.getResult());
        }
      }
      worldIn.notifyBlockUpdate(pos,state,state,3);
      bloodContainer.markDirty();
      return true;
    }
  }
  return true;
}","@Override public boolean onBlockActivated(World worldIn,BlockPos pos,IBlockState state,EntityPlayer playerIn,EnumHand hand,EnumFacing facing,float hitX,float hitY,float hitZ){
  if (!worldIn.isRemote) {
    ItemStack stack=playerIn.getHeldItem(hand);
    if (!ItemStackUtil.isEmpty(stack) && FluidLib.hasFluidItemCap(stack)) {
      TileBloodContainer bloodContainer=(TileBloodContainer)worldIn.getTileEntity(pos);
      IFluidHandler source=bloodContainer.getCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,null);
      if (playerIn.isSneaking()) {
        FluidActionResult result=FluidUtil.tryFillContainer(stack,source,Integer.MAX_VALUE,playerIn,true);
        if (result.isSuccess()) {
          playerIn.setHeldItem(hand,result.getResult());
        }
      }
 else {
        FluidActionResult result=FluidUtil.tryEmptyContainer(stack,source,Integer.MAX_VALUE,playerIn,true);
        if (result.isSuccess()) {
          playerIn.setHeldItem(hand,result.getResult());
        }
      }
      worldIn.notifyBlockUpdate(pos,state,state,3);
      bloodContainer.markDirty();
      return true;
    }
  }
  return true;
}"
12629,"@Nullable @Override public FluidStack isValidFluidItem(@Nonnull ItemStack stack){
  if (fluidStack == null)   return null;
  if (stack.hasCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,null)) {
    IFluidHandler handler=stack.getCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,null);
    FluidStack drained=handler.drain(fluidStack,false);
    if (drained == null || !drained.isFluidStackIdentical(fluidStack)) {
      return null;
    }
    return fluidStack.copy();
  }
  return null;
}","@Nullable @Override public FluidStack isValidFluidItem(@Nonnull ItemStack stack){
  if (fluidStack == null)   return null;
  if (FluidLib.hasFluidItemCap(stack)) {
    IFluidHandler handler=FluidLib.getFluidItemCap(stack);
    FluidStack drained=handler.drain(fluidStack,false);
    if (drained == null || !drained.isFluidStackIdentical(fluidStack)) {
      return null;
    }
    return fluidStack.copy();
  }
  return null;
}"
12630,"/** 
 * @return The liquid color of the given stack. -1 if not a (registered) liquid stack
 */
private static int getLiquidColor(ItemStack s){
  if (s != null) {
    if (s.hasCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,null)) {
      IFluidHandler handler=s.getCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,null);
      FluidStack fluid=handler.drain(10000,false);
      if (fluid != null) {
        return getFluidColor(fluid);
      }
    }
  }
  return AlchemicalCauldronCraftingManager.getInstance().getLiquidColor(s);
}","/** 
 * @return The liquid color of the given stack. -1 if not a (registered) liquid stack
 */
private static int getLiquidColor(ItemStack s){
  if (s != null) {
    if (FluidLib.hasFluidItemCap(s)) {
      IFluidHandler handler=FluidLib.getFluidItemCap(s);
      FluidStack fluid=handler.drain(10000,false);
      if (fluid != null) {
        return getFluidColor(fluid);
      }
    }
  }
  return AlchemicalCauldronCraftingManager.getInstance().getLiquidColor(s);
}"
12631,"private void finishCooking(){
  if (canCook()) {
    IAlchemicalCauldronRecipe recipe=AlchemicalCauldronCraftingManager.getInstance().findRecipe(getStackInSlot(SLOT_LIQUID),getStackInSlot(SLOT_INGREDIENT));
    if (!isStackInSlot(SLOT_RESULT)) {
      setInventorySlotContents(SLOT_RESULT,recipe.getOutput().copy());
    }
 else     if (getStackInSlot(SLOT_RESULT).isItemEqual(recipe.getOutput())) {
      ItemStackUtil.grow(getStackInSlot(SLOT_RESULT),ItemStackUtil.getCount(recipe.getOutput()));
    }
    if (recipe.isValidLiquidItem(getStackInSlot(SLOT_LIQUID))) {
      decrStackSize(SLOT_LIQUID,1);
    }
 else {
      ItemStack fluidContainer=getStackInSlot(SLOT_LIQUID);
      FluidStack s=recipe.isValidFluidItem(fluidContainer);
      if (s != null) {
        IFluidHandler handler=fluidContainer.getCapability(CapabilityFluidHandler.FLUID_HANDLER_CAPABILITY,null);
        handler.drain(s,true);
      }
 else {
        VampirismMod.log.w(""String_Node_Str"",""String_Node_Str"",recipe,fluidContainer);
      }
    }
    decrStackSize(SLOT_INGREDIENT,1);
  }
}","private void finishCooking(){
  if (canCook()) {
    IAlchemicalCauldronRecipe recipe=AlchemicalCauldronCraftingManager.getInstance().findRecipe(getStackInSlot(SLOT_LIQUID),getStackInSlot(SLOT_INGREDIENT));
    if (!isStackInSlot(SLOT_RESULT)) {
      setInventorySlotContents(SLOT_RESULT,recipe.getOutput().copy());
    }
 else     if (getStackInSlot(SLOT_RESULT).isItemEqual(recipe.getOutput())) {
      ItemStackUtil.grow(getStackInSlot(SLOT_RESULT),ItemStackUtil.getCount(recipe.getOutput()));
    }
    if (recipe.isValidLiquidItem(getStackInSlot(SLOT_LIQUID))) {
      decrStackSize(SLOT_LIQUID,1);
    }
 else {
      ItemStack fluidContainer=getStackInSlot(SLOT_LIQUID);
      FluidStack s=recipe.isValidFluidItem(fluidContainer);
      if (s != null) {
        IFluidHandler handler=FluidLib.getFluidItemCap(fluidContainer);
        handler.drain(s,true);
      }
 else {
        VampirismMod.log.w(""String_Node_Str"",""String_Node_Str"",recipe,fluidContainer);
      }
    }
    decrStackSize(SLOT_INGREDIENT,1);
  }
}"
12632,"/** 
 * Can be overridden to use other items as arrows. Could cause problems though.
 */
protected boolean isArrow(@Nullable ItemStack stack){
  return !ItemStackUtil.isEmpty(stack) && stack.getItem() instanceof ItemCrossbowArrow;
}","/** 
 * Can be overridden to use other items as arrows. Could cause problems though.
 */
protected boolean isArrow(@Nonnull ItemStack stack){
  return !ItemStackUtil.isEmpty(stack) && stack.getItem() instanceof ItemCrossbowArrow;
}"
12633,"/** 
 * Searches Offhand,Mainhand and the inventory afterwards for arrows
 * @param player
 * @param bowStack The itemstack of the bow
 * @return The itemstack of the arrows or null
 */
protected @Nullable ItemStack findAmmo(EntityPlayer player,ItemStack bowStack){
  if (this.isArrow(player.getHeldItem(EnumHand.OFF_HAND))) {
    return player.getHeldItem(EnumHand.OFF_HAND);
  }
 else   if (this.isArrow(player.getHeldItem(EnumHand.MAIN_HAND))) {
    return player.getHeldItem(EnumHand.MAIN_HAND);
  }
 else {
    for (int i=0; i < player.inventory.getSizeInventory(); ++i) {
      ItemStack itemstack=player.inventory.getStackInSlot(i);
      if (this.isArrow(itemstack)) {
        return itemstack;
      }
    }
    return null;
  }
}","/** 
 * Searches Offhand,Mainhand and the inventory afterwards for arrows
 * @param player
 * @param bowStack The itemstack of the bow
 * @return The itemstack of the arrows or null
 */
protected @Nonnull ItemStack findAmmo(EntityPlayer player,ItemStack bowStack){
  if (this.isArrow(player.getHeldItem(EnumHand.OFF_HAND))) {
    return player.getHeldItem(EnumHand.OFF_HAND);
  }
 else   if (this.isArrow(player.getHeldItem(EnumHand.MAIN_HAND))) {
    return player.getHeldItem(EnumHand.MAIN_HAND);
  }
 else {
    for (int i=0; i < player.inventory.getSizeInventory(); ++i) {
      ItemStack itemstack=player.inventory.getStackInSlot(i);
      if (this.isArrow(itemstack)) {
        return itemstack;
      }
    }
    return ItemStack.EMPTY;
  }
}"
12634,"/** 
 * Checks if stackA contains stackB True if A !=null and B == null
 */
public static boolean doesStackContain(@Nonnull ItemStack stackA,@Nonnull ItemStack stackB){
  return !stackA.isEmpty() && (stackB.isEmpty() || (areStacksEqualIgnoreAmount(stackA,stackB) && stackA.getCount() >= stackB.getCount()));
}","/** 
 * Checks if stackA contains stackB True if A !=null and B == null
 */
public static boolean doesStackContain(@Nonnull ItemStack stackA,@Nonnull ItemStack stackB){
  return (stackB.isEmpty() || !stackA.isEmpty() && (areStacksEqualIgnoreAmount(stackA,stackB) && stackA.getCount() >= stackB.getCount()));
}"
12635,"@Override public void update(){
  boolean wasBurning=isBurning();
  boolean wasCooking=cookTime > 0;
  boolean dirty=false;
  if (wasBurning) {
    burnTime--;
  }
  if (!world.isRemote) {
    if (isBurning() || isStackInSlot(SLOT_LIQUID) && isStackInSlot(SLOT_INGREDIENT) && isStackInSlot(SLOT_FUEL)) {
      if (!isBurning() && canCook()) {
        this.burnTime=TileEntityFurnace.getItemBurnTime(getStackInSlot(SLOT_FUEL));
        if (isBurning()) {
          decrStackSize(SLOT_FUEL,1);
          dirty=true;
        }
        totalBurnTime=burnTime;
      }
      if (isBurning() && this.canCook()) {
        cookTime++;
        if (cookTime >= totalCookTime) {
          cookTime=0;
          this.totalCookTime=getCookTime();
          this.finishCooking();
          dirty=true;
        }
      }
 else {
        cookTime=0;
      }
    }
 else     if (!isBurning() && this.cookTime > 0) {
      this.cookTime=MathHelper.clamp(this.cookTime - 2,0,this.totalCookTime);
    }
    if (wasBurning != this.isBurning()) {
      dirty=true;
    }
 else     if (wasCooking != this.cookTime > 0) {
      dirty=true;
    }
  }
 else {
    if (isCooking() && boilingSound == null && this.world.rand.nextInt(25) == 0) {
      boilingSound=VampLib.proxy.createSoundReference(ModSounds.boiling,SoundCategory.BLOCKS,getPos(),0.015F,7);
      boilingSound.startPlaying();
    }
 else     if (!isCooking() && boilingSound != null) {
      boilingSound.stopPlaying();
      boilingSound=null;
    }
  }
  if (dirty) {
    this.markDirty(true);
  }
}","@Override public void update(){
  boolean wasBurning=isBurning();
  boolean wasCooking=cookTime > 0;
  boolean dirty=false;
  if (wasBurning) {
    burnTime--;
  }
  if (!world.isRemote) {
    if (isBurning() || isStackInSlot(SLOT_LIQUID) && isStackInSlot(SLOT_FUEL)) {
      if (!isBurning() && canCook()) {
        this.burnTime=TileEntityFurnace.getItemBurnTime(getStackInSlot(SLOT_FUEL));
        if (isBurning()) {
          decrStackSize(SLOT_FUEL,1);
          dirty=true;
        }
        totalBurnTime=burnTime;
      }
      if (isBurning() && this.canCook()) {
        cookTime++;
        if (cookTime >= totalCookTime) {
          cookTime=0;
          this.totalCookTime=getCookTime();
          this.finishCooking();
          dirty=true;
        }
      }
 else {
        cookTime=0;
      }
    }
 else     if (!isBurning() && this.cookTime > 0) {
      this.cookTime=MathHelper.clamp(this.cookTime - 2,0,this.totalCookTime);
    }
    if (wasBurning != this.isBurning()) {
      dirty=true;
    }
 else     if (wasCooking != this.cookTime > 0) {
      dirty=true;
    }
  }
 else {
    if (isCooking() && boilingSound == null && this.world.rand.nextInt(25) == 0) {
      boilingSound=VampLib.proxy.createSoundReference(ModSounds.boiling,SoundCategory.BLOCKS,getPos(),0.015F,7);
      boilingSound.startPlaying();
    }
 else     if (!isCooking() && boilingSound != null) {
      boilingSound.stopPlaying();
      boilingSound=null;
    }
  }
  if (dirty) {
    this.markDirty(true);
  }
}"
12636,"private void finishCooking(){
  if (canCook()) {
    IAlchemicalCauldronRecipe recipe=AlchemicalCauldronCraftingManager.getInstance().findRecipe(getStackInSlot(SLOT_LIQUID),getStackInSlot(SLOT_INGREDIENT));
    if (!isStackInSlot(SLOT_RESULT)) {
      setInventorySlotContents(SLOT_RESULT,recipe.getOutput().copy());
    }
 else     if (getStackInSlot(SLOT_RESULT).isItemEqual(recipe.getOutput())) {
      ItemStackUtil.grow(getStackInSlot(SLOT_RESULT),ItemStackUtil.getCount(recipe.getOutput()));
    }
    if (recipe.isValidLiquidItem(getStackInSlot(SLOT_LIQUID))) {
      decrStackSize(SLOT_LIQUID,1);
    }
 else {
      ItemStack fluidContainer=getStackInSlot(SLOT_LIQUID);
      FluidStack s=recipe.isValidFluidItem(fluidContainer);
      if (s != null) {
        IFluidHandler handler=FluidLib.getFluidItemCap(fluidContainer);
        handler.drain(s,true);
      }
 else {
        VampirismMod.log.w(""String_Node_Str"",""String_Node_Str"",recipe,fluidContainer);
      }
    }
    decrStackSize(SLOT_INGREDIENT,1);
  }
}","private void finishCooking(){
  if (canCook()) {
    IAlchemicalCauldronRecipe recipe=AlchemicalCauldronCraftingManager.getInstance().findRecipe(getStackInSlot(SLOT_LIQUID),getStackInSlot(SLOT_INGREDIENT));
    if (!isStackInSlot(SLOT_RESULT)) {
      setInventorySlotContents(SLOT_RESULT,recipe.getOutput().copy());
    }
 else     if (getStackInSlot(SLOT_RESULT).isItemEqual(recipe.getOutput())) {
      ItemStackUtil.grow(getStackInSlot(SLOT_RESULT),ItemStackUtil.getCount(recipe.getOutput()));
    }
    if (recipe.isValidLiquidItem(getStackInSlot(SLOT_LIQUID))) {
      decrStackSize(SLOT_LIQUID,1);
    }
 else {
      ItemStack fluidContainer=getStackInSlot(SLOT_LIQUID);
      FluidStack s=recipe.isValidFluidItem(fluidContainer);
      if (s != null) {
        IFluidHandlerItem handler=(IFluidHandlerItem)FluidLib.getFluidItemCap(fluidContainer);
        handler.drain(s,true);
        setInventorySlotContents(SLOT_LIQUID,handler.getContainer());
      }
 else {
        VampirismMod.log.w(""String_Node_Str"",""String_Node_Str"",recipe,fluidContainer);
      }
    }
    decrStackSize(SLOT_INGREDIENT,1);
  }
}"
12637,"public static boolean doesBlockHaveSolidTopSurface(World worldIn,BlockPos pos){
  return worldIn.getBlockState(pos.down()).isSideSolid(worldIn,pos,EnumFacing.UP) && worldIn.getBlockState(pos).getMaterial().isSolid() && !worldIn.getBlockState(pos.up()).getMaterial().isSolid();
}","public static boolean doesBlockHaveSolidTopSurface(World worldIn,BlockPos pos){
  return worldIn.getBlockState(pos).isSideSolid(worldIn,pos,EnumFacing.UP);
}"
12638,"@Override public EnumActionResult onItemUse(EntityPlayer player,World world,BlockPos targetPos,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  if (side != EnumFacing.UP) {
    return EnumActionResult.FAIL;
  }
  if (world.isRemote)   return EnumActionResult.SUCCESS;
  ItemStack stack=player.getHeldItem(hand);
  IBlockState iblockstate=world.getBlockState(targetPos);
  Block block=iblockstate.getBlock();
  boolean replaceable=block.isReplaceable(world,targetPos);
  BlockPos pos=replaceable ? targetPos : targetPos.up();
  int direction=MathHelper.floor((player.rotationYaw * 4F) / 360F + 0.5D) & 3;
  EnumFacing facing=EnumFacing.getHorizontal(direction);
  BlockPos other=pos.offset(facing);
  boolean other_replaceable=block.isReplaceable(world,other);
  boolean flag1=world.isAirBlock(pos) || replaceable;
  boolean flag2=world.isAirBlock(other) || other_replaceable;
  if (player.canPlayerEdit(pos,side,stack) && player.canPlayerEdit(other,side,stack)) {
    if (flag1 && flag2 && UtilLib.doesBlockHaveSolidTopSurface(world,pos.down())&& UtilLib.doesBlockHaveSolidTopSurface(world,other.down())) {
      IBlockState state1=ModBlocks.medChair.getDefaultState().withProperty(BlockMedChair.PART,BlockMedChair.EnumPart.BOTTOM).withProperty(BlockMedChair.FACING,facing.getOpposite());
      if (world.setBlockState(pos,state1,3)) {
        IBlockState state2=state1.withProperty(BlockMedChair.PART,BlockMedChair.EnumPart.TOP).withProperty(BlockMedChair.FACING,facing.getOpposite());
        world.setBlockState(other,state2,3);
      }
      ItemStackUtil.decr(stack);
      return EnumActionResult.SUCCESS;
    }
  }
  return EnumActionResult.FAIL;
}","@Override public EnumActionResult onItemUse(EntityPlayer player,World world,BlockPos targetPos,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  if (side != EnumFacing.UP) {
    return EnumActionResult.FAIL;
  }
  if (world.isRemote)   return EnumActionResult.SUCCESS;
  ItemStack stack=player.getHeldItem(hand);
  IBlockState iblockstate=world.getBlockState(targetPos);
  Block block=iblockstate.getBlock();
  boolean replaceable=block.isReplaceable(world,targetPos);
  BlockPos pos=replaceable ? targetPos : targetPos.up();
  int direction=MathHelper.floor((player.rotationYaw * 4F) / 360F + 0.5D) & 3;
  EnumFacing facing=EnumFacing.getHorizontal(direction);
  BlockPos otherPos=pos.offset(facing);
  Block otherBlock=world.getBlockState(otherPos).getBlock();
  boolean other_replaceable=otherBlock.isReplaceable(world,otherPos);
  boolean flag1=world.isAirBlock(pos) || replaceable;
  boolean flag2=world.isAirBlock(otherPos) || other_replaceable;
  VampirismMod.log.d(regName,""String_Node_Str"",block,targetPos,replaceable,world.getBlockState(pos).getBlock(),pos,world.isAirBlock(pos));
  VampirismMod.log.d(regName,""String_Node_Str"",facing,otherBlock,otherPos,other_replaceable,world.isAirBlock(otherPos));
  if (player.canPlayerEdit(pos,side,stack) && player.canPlayerEdit(otherPos,side,stack)) {
    VampirismMod.log.d(regName,""String_Node_Str"",flag1,flag2,UtilLib.doesBlockHaveSolidTopSurface(world,pos.down()),UtilLib.doesBlockHaveSolidTopSurface(world,otherPos.down()));
    if (flag1 && flag2 && UtilLib.doesBlockHaveSolidTopSurface(world,pos.down())&& UtilLib.doesBlockHaveSolidTopSurface(world,otherPos.down())) {
      IBlockState state1=ModBlocks.medChair.getDefaultState().withProperty(BlockMedChair.PART,BlockMedChair.EnumPart.BOTTOM).withProperty(BlockMedChair.FACING,facing.getOpposite());
      if (world.setBlockState(pos,state1,3)) {
        IBlockState state2=state1.withProperty(BlockMedChair.PART,BlockMedChair.EnumPart.TOP).withProperty(BlockMedChair.FACING,facing.getOpposite());
        world.setBlockState(otherPos,state2,3);
      }
      ItemStackUtil.decr(stack);
      return EnumActionResult.SUCCESS;
    }
 else {
      VampirismMod.log.d(regName,""String_Node_Str"",world.getBlockState(pos.down()).getBlock(),world.getBlockState(otherPos.down()).getBlock());
    }
  }
 else {
    VampirismMod.log.d(regName,""String_Node_Str"",player.canPlayerEdit(pos,side,stack),player.canPlayerEdit(otherPos,side,stack));
  }
  return EnumActionResult.FAIL;
}"
12639,"private void registerNBTSubtypes(ISubtypeRegistry registry){
  registry.useNbtForSubtypes(ModItems.armorOfSwiftness_boots,ModItems.armorOfSwiftness_chest,ModItems.armorOfSwiftness_helmet,ModItems.armorOfSwiftness_legs);
  registry.useNbtForSubtypes(ModItems.hunterAxe);
  registry.useNbtForSubtypes(ModItems.hunterCoat_boots,ModItems.hunterCoat_chest,ModItems.hunterCoat_helmet,ModItems.hunterCoat_legs);
  registry.useNbtForSubtypes(ModItems.obsidianArmor_boots,ModItems.armorOfSwiftness_chest,ModItems.obsidianArmor_legs,ModItems.obsidianArmor_helmet);
  registry.useNbtForSubtypes(ModItems.holyWaterBottle);
}","private void registerNBTSubtypes(ISubtypeRegistry registry){
  registry.useNbtForSubtypes(ModItems.armorOfSwiftness_boots,ModItems.armorOfSwiftness_chest,ModItems.armorOfSwiftness_helmet,ModItems.armorOfSwiftness_legs);
  registry.useNbtForSubtypes(ModItems.hunterAxe);
  registry.useNbtForSubtypes(ModItems.hunterCoat_boots,ModItems.hunterCoat_chest,ModItems.hunterCoat_helmet,ModItems.hunterCoat_legs);
  registry.useNbtForSubtypes(ModItems.obsidianArmor_boots,ModItems.obsidianArmor_chest,ModItems.obsidianArmor_legs,ModItems.obsidianArmor_helmet);
  registry.useNbtForSubtypes(ModItems.holyWaterBottle);
}"
12640,"@SubscribeEvent public void onPlayerClone(PlayerEvent.Clone event){
  if (event.isWasDeath()) {
    for (int i=0; i < listeners.length; i++) {
      ((IPlayerEventListener)event.getEntity().getCapability(listeners[i],null)).onPlayerClone(event.getOriginal());
    }
  }
}","@SubscribeEvent public void onPlayerClone(PlayerEvent.Clone event){
  for (int i=0; i < listeners.length; i++) {
    ((IPlayerEventListener)event.getEntity().getCapability(listeners[i],null)).onPlayerClone(event.getOriginal(),event.isWasDeath());
  }
}"
12641,void onPlayerClone(EntityPlayer original);,"void onPlayerClone(EntityPlayer original,boolean wasDeath);"
12642,"@Override public void onPlayerClone(EntityPlayer original){
  copyFrom(original);
}","@Override public void onPlayerClone(EntityPlayer original,boolean wasDeath){
  copyFrom(original);
}"
12643,"@SubscribeEvent public void handleInputEvent(InputEvent event){
  KEY keyPressed=getPressedKeyBinding();
  if (keyPressed == KEY.SUCK) {
    RayTraceResult mouseOver=Minecraft.getMinecraft().objectMouseOver;
    if (mouseOver != null && mouseOver.entityHit != null) {
      VampirismMod.dispatcher.sendToServer(new InputEventPacket(InputEventPacket.SUCKBLOOD,""String_Node_Str"" + mouseOver.entityHit.getEntityId()));
    }
  }
 else   if (keyPressed == KEY.ACTION) {
    EntityPlayer player=Minecraft.getMinecraft().thePlayer;
    if (FactionPlayerHandler.get(player).getCurrentFaction() != null) {
      player.openGui(VampirismMod.instance,ModGuiHandler.ID_ACTION,player.worldObj,player.getPosition().getX(),player.getPosition().getY(),player.getPosition().getZ());
    }
  }
 else   if (keyPressed == KEY.SKILL) {
    EntityPlayer player=Minecraft.getMinecraft().thePlayer;
    if (FactionPlayerHandler.get(player).getCurrentFaction() != null) {
      player.openGui(VampirismMod.instance,ModGuiHandler.ID_SKILL,player.worldObj,player.getPosition().getX(),player.getPosition().getY(),player.getPosition().getZ());
    }
  }
 else   if (keyPressed == KEY.VISION) {
    VampirismMod.dispatcher.sendToServer(new InputEventPacket(InputEventPacket.VAMPIRE_VISION_TOGGLE,""String_Node_Str""));
  }
 else   if (keyPressed == KEY.BLOOD_POTION) {
    VampirismMod.dispatcher.sendToServer(new InputEventPacket(InputEventPacket.OPEN_BLOOD_POTION,""String_Node_Str""));
  }
}","@SubscribeEvent public void handleInputEvent(InputEvent event){
  KEY keyPressed=getPressedKeyBinding();
  if (keyPressed == KEY.SUCK) {
    RayTraceResult mouseOver=Minecraft.getMinecraft().objectMouseOver;
    if (mouseOver != null && mouseOver.entityHit != null && !Minecraft.getMinecraft().thePlayer.isSpectator()) {
      VampirismMod.dispatcher.sendToServer(new InputEventPacket(InputEventPacket.SUCKBLOOD,""String_Node_Str"" + mouseOver.entityHit.getEntityId()));
    }
  }
 else   if (keyPressed == KEY.ACTION) {
    EntityPlayer player=Minecraft.getMinecraft().thePlayer;
    if (FactionPlayerHandler.get(player).getCurrentFaction() != null) {
      player.openGui(VampirismMod.instance,ModGuiHandler.ID_ACTION,player.worldObj,player.getPosition().getX(),player.getPosition().getY(),player.getPosition().getZ());
    }
  }
 else   if (keyPressed == KEY.SKILL) {
    EntityPlayer player=Minecraft.getMinecraft().thePlayer;
    if (FactionPlayerHandler.get(player).getCurrentFaction() != null) {
      player.openGui(VampirismMod.instance,ModGuiHandler.ID_SKILL,player.worldObj,player.getPosition().getX(),player.getPosition().getY(),player.getPosition().getZ());
    }
  }
 else   if (keyPressed == KEY.VISION) {
    VampirismMod.dispatcher.sendToServer(new InputEventPacket(InputEventPacket.VAMPIRE_VISION_TOGGLE,""String_Node_Str""));
  }
 else   if (keyPressed == KEY.BLOOD_POTION) {
    VampirismMod.dispatcher.sendToServer(new InputEventPacket(InputEventPacket.OPEN_BLOOD_POTION,""String_Node_Str""));
  }
}"
12644,"@SubscribeEvent public void onRenderCrosshair(RenderGameOverlayEvent.Pre event){
  if (event.getType() != RenderGameOverlayEvent.ElementType.CROSSHAIRS) {
    return;
  }
  RayTraceResult p=Minecraft.getMinecraft().objectMouseOver;
  if (p != null && p.typeOfHit == RayTraceResult.Type.ENTITY && p.entityHit != null) {
    IVampirePlayer player=VampirePlayer.get(mc.thePlayer);
    if (player.getLevel() > 0) {
      Entity entity=p.entityHit;
      IBiteableEntity biteable=null;
      if (entity instanceof EntityCreature) {
        biteable=ExtendedCreature.get((EntityCreature)entity);
      }
 else       if (entity instanceof IBiteableEntity) {
        biteable=(IBiteableEntity)entity;
      }
 else       if (entity instanceof EntityPlayer) {
        biteable=VampirePlayer.get((EntityPlayer)entity);
      }
      if (biteable != null && biteable.canBeBitten(player)) {
        this.mc.getTextureManager().bindTexture(icons);
        int left=event.getResolution().getScaledWidth() / 2 - 8;
        int top=event.getResolution().getScaledHeight() / 2 - 4;
        GL11.glEnable(GL11.GL_BLEND);
        GL11.glColor4f(1F,0F,0F,0.8F);
        drawTexturedModalRect(left,top,27,0,16,16);
        GL11.glColor4f(1F,1F,1F,1F);
        GL11.glDisable(GL11.GL_BLEND);
        event.setCanceled(true);
      }
    }
  }
}","@SubscribeEvent public void onRenderCrosshair(RenderGameOverlayEvent.Pre event){
  if (event.getType() != RenderGameOverlayEvent.ElementType.CROSSHAIRS) {
    return;
  }
  RayTraceResult p=Minecraft.getMinecraft().objectMouseOver;
  if (p != null && p.typeOfHit == RayTraceResult.Type.ENTITY && p.entityHit != null) {
    IVampirePlayer player=VampirePlayer.get(mc.thePlayer);
    if (player.getLevel() > 0 && !mc.thePlayer.isSpectator()) {
      Entity entity=p.entityHit;
      IBiteableEntity biteable=null;
      if (entity instanceof EntityCreature) {
        biteable=ExtendedCreature.get((EntityCreature)entity);
      }
 else       if (entity instanceof IBiteableEntity) {
        biteable=(IBiteableEntity)entity;
      }
 else       if (entity instanceof EntityPlayer) {
        biteable=VampirePlayer.get((EntityPlayer)entity);
      }
      if (biteable != null && biteable.canBeBitten(player)) {
        this.mc.getTextureManager().bindTexture(icons);
        int left=event.getResolution().getScaledWidth() / 2 - 8;
        int top=event.getResolution().getScaledHeight() / 2 - 4;
        GL11.glEnable(GL11.GL_BLEND);
        GL11.glColor4f(1F,0F,0F,0.8F);
        drawTexturedModalRect(left,top,27,0,16,16);
        GL11.glColor4f(1F,1F,1F,1F);
        GL11.glDisable(GL11.GL_BLEND);
        event.setCanceled(true);
      }
    }
  }
}"
12645,"@Override public boolean canBeBitten(IVampire biter){
  return true;
}","@Override public boolean canBeBitten(IVampire biter){
  return !(player.isSpectator() || player.isCreative());
}"
12646,"/** 
 * Checks if the entity can get sundamage at it's current position. It is recommend to cache the value for a few ticks.
 * @param entity
 * @return
 */
public static boolean gettingSundamge(EntityLivingBase entity){
  if (entity.worldObj != null) {
    entity.worldObj.theProfiler.startSection(""String_Node_Str"");
    if (VampirismAPI.sundamageRegistry().getSundamageInDim(entity.worldObj.provider.getDimension())) {
      if (!entity.worldObj.isRaining()) {
        float angle=entity.worldObj.getCelestialAngle(1.0F);
        if (angle > 0.78 || angle < 0.24) {
          BlockPos pos=new BlockPos(entity.posX + 0.5,entity.posY + 0,entity.posZ + 0.5);
          if (entity.worldObj.canBlockSeeSky(pos)) {
            ResourceLocation biomeID=null;
            try {
              biomeID=entity.worldObj.getBiomeGenForCoords(pos).getRegistryName();
              if (VampirismAPI.sundamageRegistry().getSundamageInBiome(biomeID)) {
                entity.worldObj.theProfiler.endSection();
                return true;
              }
            }
 catch (            NullPointerException e) {
            }
          }
        }
      }
    }
    entity.worldObj.theProfiler.endSection();
  }
  return false;
}","/** 
 * Checks if the entity can get sundamage at it's current position. It is recommend to cache the value for a few ticks.
 * @param entity
 * @return
 */
public static boolean gettingSundamge(EntityLivingBase entity){
  if (entity.worldObj != null) {
    entity.worldObj.theProfiler.startSection(""String_Node_Str"");
    if (entity instanceof EntityPlayer && ((EntityPlayer)entity).isSpectator())     return false;
    if (VampirismAPI.sundamageRegistry().getSundamageInDim(entity.worldObj.provider.getDimension())) {
      if (!entity.worldObj.isRaining()) {
        float angle=entity.worldObj.getCelestialAngle(1.0F);
        if (angle > 0.78 || angle < 0.24) {
          BlockPos pos=new BlockPos(entity.posX + 0.5,entity.posY + 0,entity.posZ + 0.5);
          if (entity.worldObj.canBlockSeeSky(pos)) {
            ResourceLocation biomeID=null;
            try {
              biomeID=entity.worldObj.getBiomeGenForCoords(pos).getRegistryName();
              if (VampirismAPI.sundamageRegistry().getSundamageInBiome(biomeID)) {
                entity.worldObj.theProfiler.endSection();
                return true;
              }
            }
 catch (            NullPointerException e) {
            }
          }
        }
      }
    }
    entity.worldObj.theProfiler.endSection();
  }
  return false;
}"
12647,"@Override public Multimap<String,AttributeModifier> getAttributeModifiers(EntityEquipmentSlot equipmentSlot,ItemStack stack){
  Multimap<String,AttributeModifier> multimap=super.getAttributeModifiers(equipmentSlot,stack);
  if (equipmentSlot == this.armorType) {
    TIER tier=getTier(stack);
    multimap.put(SharedMonsterAttributes.MOVEMENT_SPEED.getAttributeUnlocalizedName(),new AttributeModifier(ARMOR_MODIFIERS[equipmentSlot.getIndex()],""String_Node_Str"",getSpeedBoost(tier),2));
  }
  return multimap;
}","@Override public Multimap<String,AttributeModifier> getAttributeModifiers(EntityEquipmentSlot equipmentSlot,ItemStack stack){
  Multimap<String,AttributeModifier> multimap=super.getAttributeModifiers(equipmentSlot,stack);
  if (equipmentSlot == this.armorType) {
    TIER tier=getTier(stack);
    multimap.put(SharedMonsterAttributes.MOVEMENT_SPEED.getAttributeUnlocalizedName(),new AttributeModifier(VAMIRISM_ARMOR_MODIFIER[equipmentSlot.getIndex()],""String_Node_Str"",getSpeedBoost(tier),2));
  }
  return multimap;
}"
12648,"static void buildCategories(){
  VampirismMod.log.d(TAG,""String_Node_Str"");
  long start=System.currentTimeMillis();
  guideBook.addCategory(new CategoryItemStack(buildOverview(),""String_Node_Str"",new ItemStack(ModItems.vampireFang)));
  guideBook.addCategory(new CategoryItemStack(buildVampire(),""String_Node_Str"",new ItemStack(ModItems.bloodBottle,1,ItemBloodBottle.AMOUNT)));
  guideBook.addCategory(new CategoryItemStack(buildHunter(),""String_Node_Str"",new ItemStack(ModItems.humanHeart)));
  guideBook.addCategory(new CategoryItemStack(buildCreatures(),""String_Node_Str"",new ItemStack(Items.SKULL)));
  guideBook.addCategory(new CategoryItemStack(buildWorld(),""String_Node_Str"",new ItemStack(Blocks.GRASS)));
  guideBook.addCategory(new CategoryItemStack(buildItems(),""String_Node_Str"",new ItemStack(Items.APPLE)));
  guideBook.addCategory(new CategoryItemStack(buildBlocks(),""String_Node_Str"",new ItemStack(Blocks.STONE)));
  VampirismMod.log.d(TAG,""String_Node_Str"",System.currentTimeMillis() - start);
}","static void buildCategories(){
  VampirismMod.log.d(TAG,""String_Node_Str"");
  long start=System.currentTimeMillis();
  guideBook.addCategory(new CategoryItemStack(buildOverview(),""String_Node_Str"",new ItemStack(ModItems.vampireFang)));
  guideBook.addCategory(new CategoryItemStack(buildVampire(),""String_Node_Str"",new ItemStack(ModItems.bloodBottle,1,ItemBloodBottle.AMOUNT)));
  guideBook.addCategory(new CategoryItemStack(buildHunter(),""String_Node_Str"",new ItemStack(ModItems.humanHeart)));
  guideBook.addCategory(new CategoryItemStack(buildCreatures(),""String_Node_Str"",new ItemStack(Items.SKULL)));
  guideBook.addCategory(new CategoryItemStack(buildWorld(),""String_Node_Str"",new ItemStack(ModBlocks.cursedEarth)));
  guideBook.addCategory(new CategoryItemStack(buildItems(),""String_Node_Str"",new ItemStack(Items.APPLE)));
  guideBook.addCategory(new CategoryItemStack(buildBlocks(),""String_Node_Str"",new ItemStack(ModBlocks.castleBlock)));
  VampirismMod.log.d(TAG,""String_Node_Str"",System.currentTimeMillis() - start);
}"
12649,"static void initBook(){
  guideBook=new Book();
  guideBook.setTitle(""String_Node_Str"");
  guideBook.setDisplayName(""String_Node_Str"");
  guideBook.setWelcomeMessage(""String_Node_Str"");
  guideBook.setAuthor(""String_Node_Str"");
  guideBook.setColor(Color.getHSBColor(0.5f,0.2f,0.5f));
  guideBook.setRegistryName(REFERENCE.MODID,""String_Node_Str"");
  guideBook.setOutlineTexture(new ResourceLocation(""String_Node_Str"",""String_Node_Str""));
  GameRegistry.register(guideBook);
  if (FMLCommonHandler.instance().getSide() == Side.CLIENT) {
    GuideAPI.setModel(guideBook);
  }
  bookStack=GuideAPI.getStackFromBook(guideBook);
  VampirismMod.log.i(TAG,""String_Node_Str"");
}","static void initBook(){
  guideBook=new Book();
  guideBook.setTitle(""String_Node_Str"");
  guideBook.setDisplayName(""String_Node_Str"");
  guideBook.setWelcomeMessage(""String_Node_Str"");
  guideBook.setAuthor(""String_Node_Str"");
  guideBook.setColor(Color.getHSBColor(0.5f,0.2f,0.5f));
  guideBook.setRegistryName(REFERENCE.MODID,""String_Node_Str"");
  guideBook.setOutlineTexture(new ResourceLocation(""String_Node_Str"",""String_Node_Str""));
  guideBook.setSpawnWithBook(true);
  GameRegistry.register(guideBook);
  if (FMLCommonHandler.instance().getSide() == Side.CLIENT) {
    GuideAPI.setModel(guideBook);
  }
  bookStack=GuideAPI.getStackFromBook(guideBook);
  VampirismMod.log.i(TAG,""String_Node_Str"");
}"
12650,"private static Map<ResourceLocation,EntryAbstract> buildItems(){
  Map<ResourceLocation,EntryAbstract> entries=new LinkedHashMap<>();
  String base=""String_Node_Str"";
  new ItemInfoBuilder(ModItems.vampireFang).build(entries);
  new ItemInfoBuilder(ModItems.humanHeart).build(entries);
  new ItemInfoBuilder(ModItems.injection).craftable(WORKBENCH).craftableStacks(new ItemStack(ModItems.injection,1,0),new ItemStack(ModItems.injection,1,ItemInjection.META_GARLIC),new ItemStack(ModItems.injection,1,ItemInjection.META_SANGUINARE)).build(entries);
  new ItemInfoBuilder(new ItemStack(ModItems.bloodBottle,1,ItemBloodBottle.AMOUNT),false).build(entries);
  new ItemInfoBuilder(ModItems.pureBlood).setFormats(UtilLib.translate(""String_Node_Str"" + ModEntities.VAMPIRE_BARON + ""String_Node_Str"")).build(entries);
  new ItemInfoBuilder(ModItems.hunterIntel).setLinks(new ResourceLocation(""String_Node_Str"")).setFormats(ModBlocks.hunterTable.getLocalizedName()).build(entries);
  new ItemInfoBuilder(ModItems.itemGarlic).build(entries);
  new ItemInfoBuilder(ModItems.pitchfork).craftable(WEAPON_TABLE).build(entries);
  new ItemInfoBuilder(ModItems.vampireBook).build(entries);
  new ItemInfoBuilder(ModItems.vampireBlood).setFormats(UtilLib.translate(""String_Node_Str"" + ModEntities.BASIC_VAMPIRE_NAME + ""String_Node_Str""),ModItems.stake.getLocalizedName(),UtilLib.translate(""String_Node_Str"" + ModEntities.ADVANCED_VAMPIRE + ""String_Node_Str"")).build(entries);
  new ItemInfoBuilder(ModItems.stake).setFormats(((int)(Balance.hps.INSTANT_KILL_SKILL_1_MAX_HEALTH_PERC * 100)) + ""String_Node_Str"").craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModItems.basicCrossbow).setFormats(ModItems.crossbowArrow.getLocalizedName(),ModItems.techCrossbowAmmoPackage.getLocalizedName()).setLinks(new ResourceLocation(""String_Node_Str"")).craftable(WEAPON_TABLE).craftableStacks(ModItems.basicCrossbow,ModItems.basicDoubleCrossbow,ModItems.enhancedCrossbow,ModItems.enhancedDoubleCrossbow,ModItems.basicTechCrossbow,ModItems.techCrossbowAmmoPackage).setName(""String_Node_Str"").customName().build(entries);
  new ItemInfoBuilder(ModItems.crossbowArrow).craftable(WORKBENCH).build(entries);
  addArmorWithTier(entries,""String_Node_Str"",ModItems.armorOfSwiftness_helmet,ModItems.armorOfSwiftness_chest,ModItems.armorOfSwiftness_legs,ModItems.armorOfSwiftness_boots,WEAPON_TABLE);
  addArmorWithTier(entries,""String_Node_Str"",ModItems.hunterCoat_helmet,ModItems.hunterCoat_chest,ModItems.hunterCoat_legs,ModItems.hunterCoat_boots,WEAPON_TABLE);
  addItemWithTier(entries,ModItems.hunterAxe,WEAPON_TABLE);
  links.putAll(entries);
  return entries;
}","private static Map<ResourceLocation,EntryAbstract> buildItems(){
  Map<ResourceLocation,EntryAbstract> entries=new LinkedHashMap<>();
  String base=""String_Node_Str"";
  new ItemInfoBuilder(ModItems.vampireFang).build(entries);
  new ItemInfoBuilder(ModItems.humanHeart).build(entries);
  new ItemInfoBuilder(ModItems.pureBlood).setFormats(UtilLib.translate(""String_Node_Str"" + ModEntities.VAMPIRE_BARON + ""String_Node_Str"")).build(entries);
  new ItemInfoBuilder(ModItems.vampireBlood).setFormats(UtilLib.translate(""String_Node_Str"" + ModEntities.BASIC_VAMPIRE_NAME + ""String_Node_Str""),ModItems.stake.getLocalizedName(),UtilLib.translate(""String_Node_Str"" + ModEntities.ADVANCED_VAMPIRE + ""String_Node_Str"")).build(entries);
  new ItemInfoBuilder(ModItems.vampireBook).build(entries);
  new ItemInfoBuilder(new ItemStack(ModItems.bloodBottle,1,ItemBloodBottle.AMOUNT),false).build(entries);
  new ItemInfoBuilder(ModItems.injection).craftable(WORKBENCH).craftableStacks(new ItemStack(ModItems.injection,1,0),new ItemStack(ModItems.injection,1,ItemInjection.META_GARLIC),new ItemStack(ModItems.injection,1,ItemInjection.META_SANGUINARE)).build(entries);
  new ItemInfoBuilder(ModItems.hunterIntel).setLinks(new ResourceLocation(""String_Node_Str"")).setFormats(ModBlocks.hunterTable.getLocalizedName()).build(entries);
  new ItemInfoBuilder(ModItems.itemGarlic).build(entries);
  new ItemInfoBuilder(ModItems.pitchfork).craftable(WEAPON_TABLE).build(entries);
  new ItemInfoBuilder(ModItems.stake).setFormats(((int)(Balance.hps.INSTANT_KILL_SKILL_1_MAX_HEALTH_PERC * 100)) + ""String_Node_Str"").craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModItems.basicCrossbow).setFormats(ModItems.crossbowArrow.getLocalizedName(),ModItems.techCrossbowAmmoPackage.getLocalizedName()).setLinks(new ResourceLocation(""String_Node_Str"")).craftable(WEAPON_TABLE).craftableStacks(ModItems.basicCrossbow,ModItems.basicDoubleCrossbow,ModItems.enhancedCrossbow,ModItems.enhancedDoubleCrossbow,ModItems.basicTechCrossbow,ModItems.techCrossbowAmmoPackage).setName(""String_Node_Str"").customName().build(entries);
  new ItemInfoBuilder(ModItems.crossbowArrow).craftable(WORKBENCH).build(entries);
  addArmorWithTier(entries,""String_Node_Str"",ModItems.armorOfSwiftness_helmet,ModItems.armorOfSwiftness_chest,ModItems.armorOfSwiftness_legs,ModItems.armorOfSwiftness_boots,WEAPON_TABLE);
  addArmorWithTier(entries,""String_Node_Str"",ModItems.hunterCoat_helmet,ModItems.hunterCoat_chest,ModItems.hunterCoat_legs,ModItems.hunterCoat_boots,WEAPON_TABLE);
  addItemWithTier(entries,ModItems.hunterAxe,WEAPON_TABLE);
  links.putAll(entries);
  return entries;
}"
12651,"private static Map<ResourceLocation,EntryAbstract> buildCreatures(){
  Map<ResourceLocation,EntryAbstract> entries=new LinkedHashMap<>();
  String base=""String_Node_Str"";
  ArrayList<IPage> generalPages=new ArrayList<>();
  generalPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str"")));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(generalPages,base + ""String_Node_Str""));
  ArrayList<IPage> hunterPages=new ArrayList<>();
  hunterPages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  hunterPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",ModItems.humanHeart.getLocalizedName())));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(hunterPages,""String_Node_Str"" + ModEntities.BASIC_HUNTER_NAME + ""String_Node_Str""));
  ArrayList<IPage> vampirePages=new ArrayList<>();
  vampirePages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  vampirePages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",ModItems.vampireFang.getLocalizedName(),ModItems.vampireBlood.getLocalizedName(),ModItems.stake.getLocalizedName())));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(vampirePages,""String_Node_Str"" + ModEntities.BASIC_VAMPIRE_NAME + ""String_Node_Str""));
  ArrayList<IPage> advancedHunterPages=new ArrayList<>();
  advancedHunterPages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  advancedHunterPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str"")));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(advancedHunterPages,""String_Node_Str"" + ModEntities.ADVANCED_HUNTER + ""String_Node_Str""));
  ArrayList<IPage> advancedVampirePages=new ArrayList<>();
  advancedVampirePages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  advancedVampirePages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",ModItems.bloodBottle.getLocalizedName(),ModItems.vampireBlood.getLocalizedName())));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(advancedVampirePages,""String_Node_Str"" + ModEntities.ADVANCED_VAMPIRE + ""String_Node_Str""));
  ArrayList<IPage> vampireBaronPages=new ArrayList<>();
  vampireBaronPages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  vampireBaronPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",ModItems.pureBlood.getLocalizedName())));
  GuideHelper.addLinks(vampireBaronPages,new ResourceLocation(""String_Node_Str""));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(vampireBaronPages,""String_Node_Str"" + ModEntities.VAMPIRE_BARON + ""String_Node_Str""));
  ArrayList<IPage> minionPages=new ArrayList<>();
  minionPages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  minionPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str"")));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(minionPages,""String_Node_Str"" + ModEntities.VAMPIRE_MINION_SAVEABLE_NAME + ""String_Node_Str""));
  ArrayList<IPage> ghostPages=new ArrayList<>();
  ghostPages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  ghostPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str"")));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(ghostPages,""String_Node_Str"" + ModEntities.GHOST_NAME + ""String_Node_Str""));
  links.putAll(entries);
  return entries;
}","private static Map<ResourceLocation,EntryAbstract> buildCreatures(){
  Map<ResourceLocation,EntryAbstract> entries=new LinkedHashMap<>();
  String base=""String_Node_Str"";
  ArrayList<IPage> generalPages=new ArrayList<>();
  generalPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),250));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(generalPages,base + ""String_Node_Str""));
  ArrayList<IPage> hunterPages=new ArrayList<>();
  hunterPages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  hunterPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",ModItems.humanHeart.getLocalizedName())));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(hunterPages,""String_Node_Str"" + ModEntities.BASIC_HUNTER_NAME + ""String_Node_Str""));
  ArrayList<IPage> vampirePages=new ArrayList<>();
  vampirePages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  vampirePages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",ModItems.vampireFang.getLocalizedName(),ModItems.vampireBlood.getLocalizedName(),ModItems.stake.getLocalizedName())));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(vampirePages,""String_Node_Str"" + ModEntities.BASIC_VAMPIRE_NAME + ""String_Node_Str""));
  ArrayList<IPage> advancedHunterPages=new ArrayList<>();
  advancedHunterPages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  advancedHunterPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str"")));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(advancedHunterPages,""String_Node_Str"" + ModEntities.ADVANCED_HUNTER + ""String_Node_Str""));
  ArrayList<IPage> advancedVampirePages=new ArrayList<>();
  advancedVampirePages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  advancedVampirePages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",ModItems.bloodBottle.getLocalizedName(),ModItems.vampireBlood.getLocalizedName())));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(advancedVampirePages,""String_Node_Str"" + ModEntities.ADVANCED_VAMPIRE + ""String_Node_Str""));
  ArrayList<IPage> vampireBaronPages=new ArrayList<>();
  vampireBaronPages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  vampireBaronPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",ModItems.pureBlood.getLocalizedName())));
  GuideHelper.addLinks(vampireBaronPages,new ResourceLocation(""String_Node_Str""));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(vampireBaronPages,""String_Node_Str"" + ModEntities.VAMPIRE_BARON + ""String_Node_Str""));
  ArrayList<IPage> minionPages=new ArrayList<>();
  minionPages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  minionPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str"")));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(minionPages,""String_Node_Str"" + ModEntities.VAMPIRE_MINION_SAVEABLE_NAME + ""String_Node_Str""));
  ArrayList<IPage> ghostPages=new ArrayList<>();
  ghostPages.add(new PageImage(new ResourceLocation(IMAGE_BASE + ""String_Node_Str"")));
  ghostPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str"")));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(ghostPages,""String_Node_Str"" + ModEntities.GHOST_NAME + ""String_Node_Str""));
  links.putAll(entries);
  return entries;
}"
12652,"private static Map<ResourceLocation,EntryAbstract> buildBlocks(){
  Map<ResourceLocation,EntryAbstract> entries=new LinkedHashMap<>();
  String base=""String_Node_Str"";
  new ItemInfoBuilder(ModBlocks.castleBlock).craftable(WORKBENCH).craftableStacks(new ItemStack(ModBlocks.castleBlock,1,0),new ItemStack(ModBlocks.castleBlock,1,1)).build(entries);
  new ItemInfoBuilder(ModBlocks.vampirismFlower).build(entries);
  new ItemInfoBuilder(ModBlocks.altarInfusion).setLinks(new ResourceLocation(""String_Node_Str"")).craftable(WORKBENCH).craftableStacks(new ItemStack(ModBlocks.altarInfusion),new ItemStack(ModBlocks.altarPillar),new ItemStack(ModBlocks.altarTip)).build(entries);
  new ItemInfoBuilder(ModBlocks.hunterTable).setFormats(ModItems.hunterIntel.getLocalizedName()).setLinks(new ResourceLocation(""String_Node_Str""),new ResourceLocation(""String_Node_Str"")).craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModBlocks.churchAltar).build(entries);
  new ItemInfoBuilder(ModBlocks.altarInspiration).setLinks(new ResourceLocation(""String_Node_Str"")).craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModBlocks.weaponTable).craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModBlocks.bloodPotionTable).craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(new ItemStack(ModItems.itemCoffin),true).craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(new ItemStack(ModItems.itemMedChair),true).setFormats((new ItemStack(ModItems.injection,1,1)).getDisplayName(),(new ItemStack(ModItems.injection,1,2)).getDisplayName()).craftable(WORKBENCH).build(entries);
  links.putAll(entries);
  return entries;
}","private static Map<ResourceLocation,EntryAbstract> buildBlocks(){
  Map<ResourceLocation,EntryAbstract> entries=new LinkedHashMap<>();
  String base=""String_Node_Str"";
  new ItemInfoBuilder(ModBlocks.castleBlock).craftable(WORKBENCH).craftableStacks(new ItemStack(ModBlocks.castleBlock,1,0),new ItemStack(ModBlocks.castleBlock,1,1)).build(entries);
  new ItemInfoBuilder(ModBlocks.vampirismFlower).build(entries);
  new ItemInfoBuilder(ModBlocks.bloodContainer).craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModBlocks.altarInspiration).setLinks(new ResourceLocation(""String_Node_Str"")).craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModBlocks.altarInfusion).setLinks(new ResourceLocation(""String_Node_Str"")).craftable(WORKBENCH).craftableStacks(new ItemStack(ModBlocks.altarInfusion),new ItemStack(ModBlocks.altarPillar),new ItemStack(ModBlocks.altarTip)).build(entries);
  new ItemInfoBuilder(new ItemStack(ModItems.itemCoffin),true).craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModBlocks.churchAltar).build(entries);
  new ItemInfoBuilder(new ItemStack(ModItems.itemMedChair),true).setFormats((new ItemStack(ModItems.injection,1,1)).getDisplayName(),(new ItemStack(ModItems.injection,1,2)).getDisplayName()).craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModBlocks.hunterTable).setFormats(ModItems.hunterIntel.getLocalizedName()).setLinks(new ResourceLocation(""String_Node_Str""),new ResourceLocation(""String_Node_Str"")).craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModBlocks.weaponTable).craftable(WORKBENCH).build(entries);
  new ItemInfoBuilder(ModBlocks.bloodPotionTable).craftable(WORKBENCH).build(entries);
  links.putAll(entries);
  return entries;
}"
12653,"private static Map<ResourceLocation,EntryAbstract> buildOverview(){
  Map<ResourceLocation,EntryAbstract> entries=new LinkedHashMap<>();
  String base=""String_Node_Str"";
  List<IPage> introPages=new ArrayList<>();
  introPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),340));
  PageHelper.setPagesToUnicode(introPages);
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(introPages,UtilLib.translate(base + ""String_Node_Str"")));
  List<IPage> gettingStartedPages=new ArrayList<>();
  IPage p=new PageText(UtilLib.translate(base + ""String_Node_Str""));
  p=new PageHolderWithLinks(p).addLink(""String_Node_Str"").addLink(""String_Node_Str"");
  gettingStartedPages.add(p);
  PageHelper.setPagesToUnicode(gettingStartedPages);
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(gettingStartedPages,UtilLib.translate(base + ""String_Node_Str"")));
  List<IPage> configPages=new ArrayList<>();
  configPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),340));
  configPages.addAll(PageHelper.pagesForLongText(GuideHelper.append(base + ""String_Node_Str"",base + ""String_Node_Str""),340));
  configPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),340));
  PageHelper.setPagesToUnicode(configPages);
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(configPages,UtilLib.translate(base + ""String_Node_Str"")));
  List<IPage> troublePages=new ArrayList<>();
  troublePages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),340));
  PageHelper.setPagesToUnicode(troublePages);
  GuideHelper.addLinks(troublePages,new PageHolderWithLinks.URLLink(UtilLib.translate(base + ""String_Node_Str""),URI.create(""String_Node_Str"")));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(troublePages,UtilLib.translate(base + ""String_Node_Str"")));
  List<IPage> devPages=new ArrayList<>();
  devPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),340));
  PageHelper.setPagesToUnicode(devPages);
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(devPages,UtilLib.translate(base + ""String_Node_Str"")));
  List<IPage> supportPages=new ArrayList<>();
  supportPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),300));
  PageHolderWithLinks.URLLink linkPatreon=new PageHolderWithLinks.URLLink(""String_Node_Str"",URI.create(REFERENCE.PATREON_LINK));
  PageHolderWithLinks.URLLink linkCurseForge=new PageHolderWithLinks.URLLink(""String_Node_Str"",URI.create(REFERENCE.CURSEFORGE_LINK));
  GuideHelper.addLinks(supportPages,linkPatreon,linkCurseForge,new ResourceLocation(base + ""String_Node_Str""));
  PageHelper.setPagesToUnicode(supportPages);
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(supportPages,UtilLib.translate(base + ""String_Node_Str"")));
  links.putAll(entries);
  return entries;
}","private static Map<ResourceLocation,EntryAbstract> buildOverview(){
  Map<ResourceLocation,EntryAbstract> entries=new LinkedHashMap<>();
  String base=""String_Node_Str"";
  List<IPage> introPages=new ArrayList<>();
  introPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),340));
  PageHelper.setPagesToUnicode(introPages);
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(introPages,UtilLib.translate(base + ""String_Node_Str"")));
  List<IPage> gettingStartedPages=new ArrayList<>();
  IPage p=new PageText(UtilLib.translate(base + ""String_Node_Str""));
  p=new PageHolderWithLinks(p).addLink(""String_Node_Str"").addLink(""String_Node_Str"");
  gettingStartedPages.add(p);
  PageHelper.setPagesToUnicode(gettingStartedPages);
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(gettingStartedPages,UtilLib.translate(base + ""String_Node_Str"")));
  List<IPage> configPages=new ArrayList<>();
  configPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),340));
  configPages.addAll(PageHelper.pagesForLongText(GuideHelper.append(base + ""String_Node_Str"",base + ""String_Node_Str""),340));
  configPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),340));
  PageHelper.setPagesToUnicode(configPages);
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(configPages,UtilLib.translate(base + ""String_Node_Str"")));
  List<IPage> troublePages=new ArrayList<>();
  troublePages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),340));
  PageHelper.setPagesToUnicode(troublePages);
  GuideHelper.addLinks(troublePages,new PageHolderWithLinks.URLLink(UtilLib.translate(base + ""String_Node_Str""),URI.create(""String_Node_Str"")));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(troublePages,UtilLib.translate(base + ""String_Node_Str"")));
  List<IPage> devPages=new ArrayList<>();
  PageHolderWithLinks.URLLink helpLink=new PageHolderWithLinks.URLLink(""String_Node_Str"",URI.create(""String_Node_Str""));
  devPages.addAll(GuideHelper.addLinks(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),340),helpLink));
  PageHelper.setPagesToUnicode(devPages);
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(devPages,UtilLib.translate(base + ""String_Node_Str"")));
  List<IPage> supportPages=new ArrayList<>();
  supportPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),300));
  PageHolderWithLinks.URLLink linkPatreon=new PageHolderWithLinks.URLLink(""String_Node_Str"",URI.create(REFERENCE.PATREON_LINK));
  PageHolderWithLinks.URLLink linkCurseForge=new PageHolderWithLinks.URLLink(""String_Node_Str"",URI.create(REFERENCE.CURSEFORGE_LINK));
  GuideHelper.addLinks(supportPages,linkPatreon,linkCurseForge,new ResourceLocation(base + ""String_Node_Str""));
  PageHelper.setPagesToUnicode(supportPages);
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(supportPages,UtilLib.translate(base + ""String_Node_Str"")));
  links.putAll(entries);
  return entries;
}"
12654,"private static Map<ResourceLocation,EntryAbstract> buildVampire(){
  Map<ResourceLocation,EntryAbstract> entries=new LinkedHashMap<>();
  String base=""String_Node_Str"";
  List<IPage> gettingStarted=new ArrayList<>();
  gettingStarted.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),300));
  gettingStarted.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),300));
  gettingStarted.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",Keyboard.getKeyName(ModKeys.getKeyCode(ModKeys.KEY.SUCK))),300));
  gettingStarted.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),300));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(gettingStarted,UtilLib.translate(base + ""String_Node_Str"")));
  List<IPage> bloodPages=new ArrayList<>();
  bloodPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",UtilLib.translate(ModItems.bloodBottle.getUnlocalizedName() + ""String_Node_Str""),UtilLib.translate(Items.GLASS_BOTTLE.getUnlocalizedName() + ""String_Node_Str"")),250));
  bloodPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",ModBlocks.bloodContainer.getLocalizedName()),250));
  bloodPages.addAll(GuideHelper.addLinks(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str"")),new PageHolderWithLinks.URLLink(""String_Node_Str"",URI.create(""String_Node_Str""))));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(bloodPages,UtilLib.translate(base + ""String_Node_Str"")));
  VampireLevelingConf levelingConf=VampireLevelingConf.getInstance();
  List<IPage> levelingPages=new ArrayList<>();
  levelingPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),300));
  String altarOfInspiration=""String_Node_Str"" + ModBlocks.altarInspiration.getLocalizedName() + ""String_Node_Str""+ UtilLib.translate(base + ""String_Node_Str"")+ ""String_Node_Str"";
  altarOfInspiration+=UtilLib.translate(base + ""String_Node_Str"") + ""String_Node_Str"";
  altarOfInspiration+=UtilLib.translateFormatted(base + ""String_Node_Str"",levelingConf.getRequiredBloodForAltarInspiration(2),levelingConf.getRequiredBloodForAltarInspiration(3),levelingConf.getRequiredBloodForAltarInspiration(4));
  levelingPages.addAll(GuideHelper.addLinks(PageHelper.pagesForLongText(altarOfInspiration,250),new ResourceLocation(""String_Node_Str"")));
  String altarOfInfusion=""String_Node_Str"" + ModBlocks.altarInfusion.getLocalizedName() + ""String_Node_Str""+ UtilLib.translate(base + ""String_Node_Str"")+ ""String_Node_Str"";
  altarOfInfusion+=UtilLib.translateFormatted(base + ""String_Node_Str"",ModBlocks.altarInfusion.getLocalizedName(),ModBlocks.altarPillar.getLocalizedName(),ModBlocks.altarTip.getLocalizedName());
  levelingPages.addAll(GuideHelper.addLinks(PageHelper.pagesForLongText(altarOfInfusion,300),new ResourceLocation(""String_Node_Str"")));
  String blocks=""String_Node_Str"";
  for (  BlockAltarPillar.EnumPillarType t : BlockAltarPillar.EnumPillarType.values()) {
    if (t == BlockAltarPillar.EnumPillarType.NONE)     continue;
    blocks+=t.fillerBlock.getLocalizedName() + ""String_Node_Str"" + t.getValue()+ ""String_Node_Str"";
  }
  levelingPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",blocks),250));
  String items=UtilLib.translate(ModItems.humanHeart.getUnlocalizedName() + ""String_Node_Str"") + ""String_Node_Str"" + UtilLib.translate(ModItems.pureBlood.getUnlocalizedName() + ""String_Node_Str"")+ ""String_Node_Str""+ UtilLib.translate(ModItems.vampireBook.getUnlocalizedName() + ""String_Node_Str"");
  levelingPages.addAll(GuideHelper.addLinks(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",items),300),new ResourceLocation(""String_Node_Str""),new ResourceLocation(""String_Node_Str""),new ResourceLocation(""String_Node_Str"")));
  PageTable.Builder requirementsBuilder=new PageTable.Builder(5);
  requirementsBuilder.addUnlocLine(""String_Node_Str"",base + ""String_Node_Str"",ModItems.pureBlood.getUnlocalizedName() + ""String_Node_Str"",base + ""String_Node_Str"",base + ""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.setHeadline(UtilLib.translate(base + ""String_Node_Str""));
  PageHolderWithLinks requirementTable=new PageHolderWithLinks(requirementsBuilder.build());
  requirementTable.addLink(new ResourceLocation(""String_Node_Str""));
  requirementTable.addLink(new ResourceLocation(""String_Node_Str""));
  requirementTable.addLink(new ResourceLocation(""String_Node_Str""));
  levelingPages.add(requirementTable);
  levelingPages.add(new PageTextImage(UtilLib.translate(base + ""String_Node_Str""),new ResourceLocation(IMAGE_BASE + ""String_Node_Str""),false));
  levelingPages.add(new PageTextImage(UtilLib.translate(base + ""String_Node_Str""),new ResourceLocation(IMAGE_BASE + ""String_Node_Str""),false));
  levelingPages.add(new PageTextImage(UtilLib.translate(base + ""String_Node_Str""),new ResourceLocation(IMAGE_BASE + ""String_Node_Str""),false));
  levelingPages.add(new PageTextImage(UtilLib.translate(base + ""String_Node_Str""),new ResourceLocation(IMAGE_BASE + ""String_Node_Str""),false));
  levelingPages.add(new PageTextImage(UtilLib.translate(base + ""String_Node_Str""),new ResourceLocation(IMAGE_BASE + ""String_Node_Str""),false));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(levelingPages,base + ""String_Node_Str""));
  List<IPage> skillPages=new ArrayList<>();
  skillPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",Keyboard.getKeyName(ModKeys.getKeyCode(ModKeys.KEY.SKILL))),300));
  skillPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",Keyboard.getKeyName(ModKeys.getKeyCode(ModKeys.KEY.ACTION))),300));
  skillPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),300));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(skillPages,base + ""String_Node_Str""));
  List<IPage> unvampirePages=new ArrayList<>();
  unvampirePages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",ModBlocks.churchAltar.getLocalizedName()),300));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(unvampirePages,base + ""String_Node_Str""));
  links.putAll(entries);
  return entries;
}","private static Map<ResourceLocation,EntryAbstract> buildVampire(){
  Map<ResourceLocation,EntryAbstract> entries=new LinkedHashMap<>();
  String base=""String_Node_Str"";
  List<IPage> gettingStarted=new ArrayList<>();
  gettingStarted.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),300));
  gettingStarted.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),300));
  gettingStarted.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",Keyboard.getKeyName(ModKeys.getKeyCode(ModKeys.KEY.SUCK))),300));
  gettingStarted.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),300));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(gettingStarted,UtilLib.translate(base + ""String_Node_Str"")));
  List<IPage> bloodPages=new ArrayList<>();
  bloodPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",UtilLib.translate(ModItems.bloodBottle.getUnlocalizedName() + ""String_Node_Str""),UtilLib.translate(Items.GLASS_BOTTLE.getUnlocalizedName() + ""String_Node_Str"")),250));
  bloodPages.addAll(GuideHelper.addLinks(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",ModBlocks.bloodContainer.getLocalizedName()),250),new ResourceLocation(""String_Node_Str"")));
  bloodPages.addAll(GuideHelper.addLinks(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str"")),new PageHolderWithLinks.URLLink(""String_Node_Str"",URI.create(""String_Node_Str""))));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(bloodPages,UtilLib.translate(base + ""String_Node_Str"")));
  VampireLevelingConf levelingConf=VampireLevelingConf.getInstance();
  List<IPage> levelingPages=new ArrayList<>();
  levelingPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),300));
  String altarOfInspiration=""String_Node_Str"" + ModBlocks.altarInspiration.getLocalizedName() + ""String_Node_Str""+ UtilLib.translate(base + ""String_Node_Str"")+ ""String_Node_Str"";
  altarOfInspiration+=UtilLib.translate(base + ""String_Node_Str"") + ""String_Node_Str"";
  altarOfInspiration+=UtilLib.translateFormatted(base + ""String_Node_Str"",levelingConf.getRequiredBloodForAltarInspiration(2),levelingConf.getRequiredBloodForAltarInspiration(3),levelingConf.getRequiredBloodForAltarInspiration(4));
  levelingPages.addAll(GuideHelper.addLinks(PageHelper.pagesForLongText(altarOfInspiration,250),new ResourceLocation(""String_Node_Str"")));
  String altarOfInfusion=""String_Node_Str"" + ModBlocks.altarInfusion.getLocalizedName() + ""String_Node_Str""+ UtilLib.translate(base + ""String_Node_Str"")+ ""String_Node_Str"";
  altarOfInfusion+=UtilLib.translateFormatted(base + ""String_Node_Str"",ModBlocks.altarInfusion.getLocalizedName(),ModBlocks.altarPillar.getLocalizedName(),ModBlocks.altarTip.getLocalizedName());
  levelingPages.addAll(GuideHelper.addLinks(PageHelper.pagesForLongText(altarOfInfusion,300),new ResourceLocation(""String_Node_Str"")));
  String blocks=""String_Node_Str"";
  for (  BlockAltarPillar.EnumPillarType t : BlockAltarPillar.EnumPillarType.values()) {
    if (t == BlockAltarPillar.EnumPillarType.NONE)     continue;
    blocks+=t.fillerBlock.getLocalizedName() + ""String_Node_Str"" + t.getValue()+ ""String_Node_Str"";
  }
  levelingPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",blocks),250));
  String items=UtilLib.translate(ModItems.humanHeart.getUnlocalizedName() + ""String_Node_Str"") + ""String_Node_Str"" + UtilLib.translate(ModItems.pureBlood.getUnlocalizedName() + ""String_Node_Str"")+ ""String_Node_Str""+ UtilLib.translate(ModItems.vampireBook.getUnlocalizedName() + ""String_Node_Str"");
  levelingPages.addAll(GuideHelper.addLinks(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",items),300),new ResourceLocation(""String_Node_Str""),new ResourceLocation(""String_Node_Str""),new ResourceLocation(""String_Node_Str"")));
  PageTable.Builder requirementsBuilder=new PageTable.Builder(5);
  requirementsBuilder.addUnlocLine(""String_Node_Str"",base + ""String_Node_Str"",ModItems.pureBlood.getUnlocalizedName() + ""String_Node_Str"",base + ""String_Node_Str"",base + ""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.addLine(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  requirementsBuilder.setHeadline(UtilLib.translate(base + ""String_Node_Str""));
  PageHolderWithLinks requirementTable=new PageHolderWithLinks(requirementsBuilder.build());
  requirementTable.addLink(new ResourceLocation(""String_Node_Str""));
  requirementTable.addLink(new ResourceLocation(""String_Node_Str""));
  requirementTable.addLink(new ResourceLocation(""String_Node_Str""));
  levelingPages.add(requirementTable);
  levelingPages.add(new PageTextImage(UtilLib.translate(base + ""String_Node_Str""),new ResourceLocation(IMAGE_BASE + ""String_Node_Str""),false));
  levelingPages.add(new PageTextImage(UtilLib.translate(base + ""String_Node_Str""),new ResourceLocation(IMAGE_BASE + ""String_Node_Str""),false));
  levelingPages.add(new PageTextImage(UtilLib.translate(base + ""String_Node_Str""),new ResourceLocation(IMAGE_BASE + ""String_Node_Str""),false));
  levelingPages.add(new PageTextImage(UtilLib.translate(base + ""String_Node_Str""),new ResourceLocation(IMAGE_BASE + ""String_Node_Str""),false));
  levelingPages.add(new PageTextImage(UtilLib.translate(base + ""String_Node_Str""),new ResourceLocation(IMAGE_BASE + ""String_Node_Str""),false));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(levelingPages,base + ""String_Node_Str""));
  List<IPage> skillPages=new ArrayList<>();
  skillPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",Keyboard.getKeyName(ModKeys.getKeyCode(ModKeys.KEY.SKILL))),300));
  skillPages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",Keyboard.getKeyName(ModKeys.getKeyCode(ModKeys.KEY.ACTION))),300));
  skillPages.addAll(PageHelper.pagesForLongText(UtilLib.translate(base + ""String_Node_Str""),300));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(skillPages,base + ""String_Node_Str""));
  List<IPage> unvampirePages=new ArrayList<>();
  unvampirePages.addAll(PageHelper.pagesForLongText(UtilLib.translateFormatted(base + ""String_Node_Str"",ModBlocks.churchAltar.getLocalizedName()),300));
  entries.put(new ResourceLocation(base + ""String_Node_Str""),new EntryText(unvampirePages,base + ""String_Node_Str""));
  links.putAll(entries);
  return entries;
}"
12655,"@Override public void onLeftClicked(Book book,CategoryAbstract category,EntryAbstract entry,int mouseX,int mouseY,EntityPlayer player,GuiEntry guiEntry){
  if (mouseX > guiEntry.guiLeft + guiEntry.xSize) {
    for (int i=0; i < links.size(); i++) {
      if (GuiHelper.isMouseBetween(mouseX,mouseY,guiEntry.guiLeft + guiEntry.xSize,guiEntry.guiTop + 10 + 20 * i,links.get(i).width,20)) {
        links.get(i).onClicked(book,category,entry,player,guiEntry.bookStack,guiEntry.pageNumber);
        return;
      }
    }
  }
  page.onLeftClicked(book,category,entry,mouseX,mouseY,player,guiEntry);
}","@Override public void onLeftClicked(Book book,CategoryAbstract category,EntryAbstract entry,int mouseX,int mouseY,EntityPlayer player,GuiEntry guiEntry){
  if (mouseX > guiEntry.guiLeft + guiEntry.xSize) {
    long lastClock=System.currentTimeMillis() / 4;
    if (lastClock != lastLinkClick) {
      lastLinkClick=lastClock;
      for (int i=0; i < links.size(); i++) {
        if (GuiHelper.isMouseBetween(mouseX,mouseY,guiEntry.guiLeft + guiEntry.xSize,guiEntry.guiTop + 10 + 20 * i,links.get(i).width,20)) {
          links.get(i).onClicked(book,category,entry,player,guiEntry.bookStack,guiEntry.pageNumber);
          return;
        }
      }
    }
  }
  page.onLeftClicked(book,category,entry,mouseX,mouseY,player,guiEntry);
}"
12656,"private static void init(FMLInitializationEvent event){
  Set<Biome> allBiomes=Biome.EXPLORATION_BIOMES_LIST;
  allBiomes.remove(Biomes.HELL);
  allBiomes.remove(Biomes.SKY);
  Set<Biome> zombieBiomes=Sets.newHashSet();
  zombieBiomes.addAll(allBiomes);
  Iterator<Biome> iterator=zombieBiomes.iterator();
  while (iterator.hasNext()) {
    Biome b=iterator.next();
    if (b != null) {
      if (!b.getBiomeClass().getName().startsWith(""String_Node_Str"") && !b.getBiomeClass().getName().startsWith(""String_Node_Str"")) {
        Iterator<Biome.SpawnListEntry> iterator2=b.getSpawnableList(EnumCreatureType.MONSTER).iterator();
        boolean zombie=false;
        while (iterator2.hasNext()) {
          if (iterator2.next().entityClass.equals(EntityZombie.class)) {
            zombie=true;
            break;
          }
        }
        if (!zombie) {
          VampirismMod.log.d(""String_Node_Str"",""String_Node_Str"",b);
          iterator.remove();
        }
      }
    }
  }
  registerEntity(EntityBlindingBat.class,BLINDING_BAT_NAME,EntityLiving.SpawnPlacementType.IN_AIR,false);
  registerEntity(EntityGhost.class,GHOST_NAME,EntityLiving.SpawnPlacementType.ON_GROUND,true);
  registerEntity(EntityConvertedCreature.class,CONVERTED_CREATURE,EntityLiving.SpawnPlacementType.ON_GROUND,false);
  registerEntity(EntityConvertedSheep.class,CONVERTED_SHEEP,EntityLiving.SpawnPlacementType.ON_GROUND,false);
  registerEntity(EntityBasicHunter.class,BASIC_HUNTER_NAME,EntityLiving.SpawnPlacementType.ON_GROUND,true);
  registerEntity(EntityBasicVampire.class,BASIC_VAMPIRE_NAME,EntityLiving.SpawnPlacementType.ON_GROUND,Balance.mobProps.VAMPIRE_SPAWN_CHANCE,1,2,EnumCreatureType.MONSTER,zombieBiomes.toArray(new Biome[zombieBiomes.size()]));
  registerEntity(EntityHunterTrainer.class,HUNTER_TRAINER,EntityLiving.SpawnPlacementType.ON_GROUND,true);
  registerEntity(EntityAdvancedHunter.class,ADVANCED_HUNTER,EntityLiving.SpawnPlacementType.ON_GROUND,true);
  registerEntity(EntityVampireBaron.class,VAMPIRE_BARON,EntityLiving.SpawnPlacementType.ON_GROUND,true);
  registerEntity(EntityVampireMinionSaveable.class,VAMPIRE_MINION_SAVEABLE_NAME,EntityLiving.SpawnPlacementType.ON_GROUND,false);
  registerEntity(EntityDummyBittenAnimal.class,DUMMY_CREATURE,EntityLiving.SpawnPlacementType.ON_GROUND,false);
  registerEntity(EntityAdvancedVampire.class,ADVANCED_VAMPIRE,EntityLiving.SpawnPlacementType.ON_GROUND,Balance.mobProps.ADVANCED_VAMPIRE_SPAWN_PROBE,1,1,EnumCreatureType.MONSTER,zombieBiomes.toArray(new Biome[zombieBiomes.size()]));
  registerEntity(EntityConvertedVillager.class,CONVERTED_VILLAGER,EntityLiving.SpawnPlacementType.ON_GROUND,false);
  registerEntity(EntityHunterVillager.class,HUNTER_VILLAGER,EntityLiving.SpawnPlacementType.ON_GROUND,false);
  registerEntity(EntityCrossbowArrow.class,CROSSBOW_ARROW,EntityLiving.SpawnPlacementType.IN_AIR,false);
  registerConvertibles();
}","private static void init(FMLInitializationEvent event){
  Set<Biome> allBiomes=Biome.EXPLORATION_BIOMES_LIST;
  Set<Biome> zombieBiomes=Sets.newHashSet();
  zombieBiomes.addAll(allBiomes);
  zombieBiomes.remove(Biomes.MUSHROOM_ISLAND);
  zombieBiomes.remove(Biomes.MUSHROOM_ISLAND_SHORE);
  zombieBiomes.remove(Biomes.HELL);
  zombieBiomes.remove(Biomes.SKY);
  Iterator<Biome> iterator=zombieBiomes.iterator();
  while (iterator.hasNext()) {
    Biome b=iterator.next();
    if (b != null) {
      if (!b.getBiomeClass().getName().startsWith(""String_Node_Str"") && !b.getBiomeClass().getName().startsWith(""String_Node_Str"")) {
        Iterator<Biome.SpawnListEntry> iterator2=b.getSpawnableList(EnumCreatureType.MONSTER).iterator();
        boolean zombie=false;
        while (iterator2.hasNext()) {
          if (iterator2.next().entityClass.equals(EntityZombie.class)) {
            zombie=true;
            break;
          }
        }
        if (!zombie) {
          VampirismMod.log.d(""String_Node_Str"",""String_Node_Str"",b);
          iterator.remove();
        }
      }
    }
  }
  registerEntity(EntityBlindingBat.class,BLINDING_BAT_NAME,EntityLiving.SpawnPlacementType.IN_AIR,false);
  registerEntity(EntityGhost.class,GHOST_NAME,EntityLiving.SpawnPlacementType.ON_GROUND,true);
  registerEntity(EntityConvertedCreature.class,CONVERTED_CREATURE,EntityLiving.SpawnPlacementType.ON_GROUND,false);
  registerEntity(EntityConvertedSheep.class,CONVERTED_SHEEP,EntityLiving.SpawnPlacementType.ON_GROUND,false);
  registerEntity(EntityBasicHunter.class,BASIC_HUNTER_NAME,EntityLiving.SpawnPlacementType.ON_GROUND,true);
  registerEntity(EntityBasicVampire.class,BASIC_VAMPIRE_NAME,EntityLiving.SpawnPlacementType.ON_GROUND,Balance.mobProps.VAMPIRE_SPAWN_CHANCE,1,2,EnumCreatureType.MONSTER,zombieBiomes.toArray(new Biome[zombieBiomes.size()]));
  registerEntity(EntityHunterTrainer.class,HUNTER_TRAINER,EntityLiving.SpawnPlacementType.ON_GROUND,true);
  registerEntity(EntityAdvancedHunter.class,ADVANCED_HUNTER,EntityLiving.SpawnPlacementType.ON_GROUND,true);
  registerEntity(EntityVampireBaron.class,VAMPIRE_BARON,EntityLiving.SpawnPlacementType.ON_GROUND,true);
  registerEntity(EntityVampireMinionSaveable.class,VAMPIRE_MINION_SAVEABLE_NAME,EntityLiving.SpawnPlacementType.ON_GROUND,false);
  registerEntity(EntityDummyBittenAnimal.class,DUMMY_CREATURE,EntityLiving.SpawnPlacementType.ON_GROUND,false);
  registerEntity(EntityAdvancedVampire.class,ADVANCED_VAMPIRE,EntityLiving.SpawnPlacementType.ON_GROUND,Balance.mobProps.ADVANCED_VAMPIRE_SPAWN_PROBE,1,1,EnumCreatureType.MONSTER,zombieBiomes.toArray(new Biome[zombieBiomes.size()]));
  registerEntity(EntityConvertedVillager.class,CONVERTED_VILLAGER,EntityLiving.SpawnPlacementType.ON_GROUND,false);
  registerEntity(EntityHunterVillager.class,HUNTER_VILLAGER,EntityLiving.SpawnPlacementType.ON_GROUND,false);
  registerEntity(EntityCrossbowArrow.class,CROSSBOW_ARROW,EntityLiving.SpawnPlacementType.IN_AIR,false);
  registerConvertibles();
}"
12657,"/** 
 * Registers the entity and add a spawn entry for it
 * @param clazz
 * @param name
 * @param probe
 * @param min
 * @param max
 * @param type
 * @param biomes
 */
private static void registerEntity(Class<? extends EntityLiving> clazz,String name,EntityLiving.SpawnPlacementType placementType,int probe,int min,int max,EnumCreatureType type,Biome... biomes){
  registerEntity(clazz,name,placementType,true);
  VampirismMod.log.d(""String_Node_Str"",""String_Node_Str"" + probe);
  EntityRegistry.addSpawn(clazz,probe,min,max,type,biomes);
}","/** 
 * Registers the entity and add a spawn entry for it
 * @param clazz
 * @param name
 * @param probe
 * @param min
 * @param max
 * @param type
 * @param biomes
 */
private static void registerEntity(Class<? extends EntityLiving> clazz,String name,EntityLiving.SpawnPlacementType placementType,int probe,int min,int max,EnumCreatureType type,Biome... biomes){
  registerEntity(clazz,name,placementType,true);
  EntityRegistry.addSpawn(clazz,probe,min,max,type,biomes);
}"
12658,"@Mod.EventHandler public void init(FMLInitializationEvent event){
  versionInfo=VersionChecker.executeVersionCheck(REFERENCE.VERSION_UPDATE_FILE,REFERENCE.VERSION.equals(""String_Node_Str"") ? ""String_Node_Str"" : REFERENCE.VERSION);
  ModEventHandler eventHandler=new ModEventHandler();
  MinecraftForge.EVENT_BUS.register(eventHandler);
  MinecraftForge.TERRAIN_GEN_BUS.register(eventHandler);
  MinecraftForge.EVENT_BUS.register(new ModPlayerEventHandler());
  MinecraftForge.EVENT_BUS.register(new ModEntityEventHandler());
  GameRegistry.registerWorldGenerator(new VampirismWorldGen(),1000);
  HelperRegistry.registerPlayerEventReceivingCapability(VampirePlayer.CAP,VampirePlayer.class);
  HelperRegistry.registerPlayerEventReceivingCapability(HunterPlayer.CAP,HunterPlayer.class);
  HelperRegistry.registerSyncableEntityCapability(ExtendedCreature.CAP,REFERENCE.EXTENDED_CREATURE_KEY,ExtendedCreature.class);
  HelperRegistry.registerSyncablePlayerCapability(VampirePlayer.CAP,REFERENCE.VAMPIRE_PLAYER_KEY,VampirePlayer.class);
  HelperRegistry.registerSyncablePlayerCapability(HunterPlayer.CAP,REFERENCE.HUNTER_PLAYER_KEY,HunterPlayer.class);
  HelperRegistry.registerSyncablePlayerCapability(FactionPlayerHandler.CAP,REFERENCE.FACTION_PLAYER_HANDLER_KEY,FactionPlayerHandler.class);
  Achievements.registerAchievement();
  SupporterManager.getInstance().initAsync();
  BloodPotions.register();
  proxy.onInitStep(IInitListener.Step.INIT,event);
  modCompatLoader.onInitStep(IInitListener.Step.INIT,event);
}","@Mod.EventHandler public void init(FMLInitializationEvent event){
  versionInfo=VersionChecker.executeVersionCheck(REFERENCE.VERSION_UPDATE_FILE,""String_Node_Str"".equals(REFERENCE.VERSION) ? ""String_Node_Str"" : REFERENCE.VERSION);
  ModEventHandler eventHandler=new ModEventHandler();
  MinecraftForge.EVENT_BUS.register(eventHandler);
  MinecraftForge.TERRAIN_GEN_BUS.register(eventHandler);
  MinecraftForge.EVENT_BUS.register(new ModPlayerEventHandler());
  MinecraftForge.EVENT_BUS.register(new ModEntityEventHandler());
  GameRegistry.registerWorldGenerator(new VampirismWorldGen(),1000);
  HelperRegistry.registerPlayerEventReceivingCapability(VampirePlayer.CAP,VampirePlayer.class);
  HelperRegistry.registerPlayerEventReceivingCapability(HunterPlayer.CAP,HunterPlayer.class);
  HelperRegistry.registerSyncableEntityCapability(ExtendedCreature.CAP,REFERENCE.EXTENDED_CREATURE_KEY,ExtendedCreature.class);
  HelperRegistry.registerSyncablePlayerCapability(VampirePlayer.CAP,REFERENCE.VAMPIRE_PLAYER_KEY,VampirePlayer.class);
  HelperRegistry.registerSyncablePlayerCapability(HunterPlayer.CAP,REFERENCE.HUNTER_PLAYER_KEY,HunterPlayer.class);
  HelperRegistry.registerSyncablePlayerCapability(FactionPlayerHandler.CAP,REFERENCE.FACTION_PLAYER_HANDLER_KEY,FactionPlayerHandler.class);
  Achievements.registerAchievement();
  SupporterManager.getInstance().initAsync();
  BloodPotions.register();
  proxy.onInitStep(IInitListener.Step.INIT,event);
  modCompatLoader.onInitStep(IInitListener.Step.INIT,event);
}"
12659,"/** 
 * Join the given faction and set the faction level to 1. Only successful if   {@link IFactionPlayerHandler#canJoin(IPlayableFaction)}
 * @param faction
 */
void joinFaction(IPlayableFaction faction);","/** 
 * Join the given faction and set the faction level to 1. Only successful if   {@link IFactionPlayerHandler#canJoin(IPlayableFaction)}
 * @param faction
 */
void joinFaction(@Nonnull IPlayableFaction faction);"
12660,"/** 
 * Set the level for a faction. Only works if the player already is in the given faction. Use   {@link IFactionPlayerHandler#joinFaction(IPlayableFaction)} to join a faction first or {@link IFactionPlayerHandler#setFactionAndLevel(IPlayableFaction,int)} if you are sure what you do
 * @param faction
 * @param level
 * @return If successful
 */
boolean setFactionLevel(IPlayableFaction faction,int level);","/** 
 * Set the level for a faction. Only works if the player already is in the given faction. Use   {@link IFactionPlayerHandler#joinFaction(IPlayableFaction)} to join a faction first or {@link IFactionPlayerHandler#setFactionAndLevel(IPlayableFaction,int)} if you are sure what you do
 * @param faction
 * @param level
 * @return If successful
 */
boolean setFactionLevel(@Nonnull IPlayableFaction faction,int level);"
12661,"public SkillEvent(IPlayableFaction faction){
  this.faction=faction;
}","private SkillEvent(IPlayableFaction faction){
  this.faction=faction;
}"
12662,"public AddSkills(IPlayableFaction faction,List<ISkill> skills){
  super(faction);
  this.skills=skills;
}","AddSkills(IPlayableFaction faction,List<ISkill> skills){
  super(faction);
  this.skills=skills;
}"
12663,"public static EnumFlowerType getType(int meta){
  if (meta >= TYPE_FOR_META.length) {
    meta=0;
  }
  return TYPE_FOR_META[meta];
}","public static EnumFlowerType getType(int meta){
  if (meta >= TYPE_FOR_META.length) {
    return TYPE_FOR_META[0];
  }
  return TYPE_FOR_META[meta];
}"
12664,"public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case PRE_INIT:
    preInit();
  break;
}
}","public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case PRE_INIT:
    preInit();
  break;
default :
}
}"
12665,"public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case PRE_INIT:
    registerBlocks();
  registerTiles();
break;
case INIT:
registerCraftingRecipes();
}
}","public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case PRE_INIT:
    registerBlocks();
  registerTiles();
break;
case INIT:
registerCraftingRecipes();
break;
default :
}
}"
12666,"public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case PRE_INIT:
    preInit((FMLPreInitializationEvent)event);
  break;
case INIT:
init((FMLInitializationEvent)event);
break;
}
}","public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case PRE_INIT:
    preInit((FMLPreInitializationEvent)event);
  break;
case INIT:
init((FMLInitializationEvent)event);
break;
default :
}
}"
12667,"public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case PRE_INIT:
    preInit((FMLPreInitializationEvent)event);
  break;
}
}","public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case PRE_INIT:
    preInit((FMLPreInitializationEvent)event);
  break;
default :
}
}"
12668,"public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case PRE_INIT:
    preInit((FMLPreInitializationEvent)event);
  break;
}
}","public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case PRE_INIT:
    preInit((FMLPreInitializationEvent)event);
  break;
default :
}
}"
12669,"public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case PRE_INIT:
    registerSounds();
  break;
}
}","public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case PRE_INIT:
    registerSounds();
  break;
default :
}
}"
12670,"public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case INIT:
    registerCreationHandlers();
  registerPieces();
break;
}
}","public static void onInitStep(IInitListener.Step step,FMLStateEvent event){
switch (step) {
case INIT:
    registerCreationHandlers();
  registerPieces();
break;
default :
}
}"
12671,"@SuppressWarnings(""String_Node_Str"") public static ICapabilityProvider createNewCapability(final EntityCreature creature){
  return new ICapabilitySerializable<NBTTagCompound>(){
    IExtendedCreatureVampirism inst=new ExtendedCreature(creature);
    @Override public void deserializeNBT(    NBTTagCompound nbt){
      CAP.getStorage().readNBT(CAP,inst,null,nbt);
    }
    @Override public <T>T getCapability(    Capability<T> capability,    EnumFacing facing){
      return CAP.equals(capability) ? CAP.<T>cast(inst) : null;
    }
    @Override public boolean hasCapability(    Capability<?> capability,    EnumFacing facing){
      return capability == CAP;
    }
    @Override public NBTTagCompound serializeNBT(){
      return (NBTTagCompound)CAP.getStorage().writeNBT(CAP,inst,null);
    }
  }
;
}","@SuppressWarnings(""String_Node_Str"") public static ICapabilityProvider createNewCapability(final EntityCreature creature){
  return new ICapabilitySerializable<NBTTagCompound>(){
    IExtendedCreatureVampirism inst=new ExtendedCreature(creature);
    @Override public void deserializeNBT(    NBTTagCompound nbt){
      CAP.getStorage().readNBT(CAP,inst,null,nbt);
    }
    @Override public <T>T getCapability(    Capability<T> capability,    EnumFacing facing){
      return CAP.equals(capability) ? CAP.<T>cast(inst) : null;
    }
    @Override public boolean hasCapability(    Capability<?> capability,    EnumFacing facing){
      return CAP.equals(capability);
    }
    @Override public NBTTagCompound serializeNBT(){
      return (NBTTagCompound)CAP.getStorage().writeNBT(CAP,inst,null);
    }
  }
;
}"
12672,"@Override public boolean hasCapability(Capability<?> capability,EnumFacing facing){
  return capability == CAP;
}","@Override public boolean hasCapability(Capability<?> capability,EnumFacing facing){
  return CAP.equals(capability);
}"
12673,"@Override public void joinFaction(IPlayableFaction faction){
  if (canJoin(faction)) {
    setFactionAndLevel(faction,1);
  }
}","@Override public void joinFaction(@Nonnull IPlayableFaction faction){
  if (canJoin(faction)) {
    setFactionAndLevel(faction,1);
  }
}"
12674,"@Override public boolean setFactionLevel(IPlayableFaction faction,int level){
  if (faction == currentFaction) {
    return setFactionAndLevel(faction,level);
  }
  return false;
}","@Override public boolean setFactionLevel(@Nonnull IPlayableFaction faction,int level){
  return faction.equals(currentFaction) && setFactionAndLevel(faction,level);
}"
12675,"@Override public boolean isInFaction(@Nullable IPlayableFaction f){
  return currentFaction == f;
}","@Override public boolean isInFaction(@Nullable IPlayableFaction f){
  return Objects.equals(currentFaction,f);
}"
12676,"@Override public boolean setFactionAndLevel(IPlayableFaction faction,int level){
  IPlayableFaction old=currentFaction;
  int oldLevel=currentLevel;
  if (currentFaction != null && (currentFaction != faction || level == 0)) {
    if (!currentFaction.getPlayerCapability(player).canLeaveFaction()) {
      VampirismMod.log.i(TAG,""String_Node_Str"",currentFaction.getKey());
      return false;
    }
  }
  if (faction == null) {
    currentFaction=null;
    currentLevel=0;
  }
 else {
    if (level < 0 || level > faction.getHighestReachableLevel()) {
      VampirismMod.log.w(TAG,""String_Node_Str"",level,faction.getKey());
      return false;
    }
    currentFaction=faction;
    currentLevel=level;
  }
  if (currentFaction == null)   currentLevel=0;
 else   if (currentLevel == 0)   currentFaction=null;
  notifyFaction(old,oldLevel);
  sync(old != currentFaction);
  return true;
}","@Override public boolean setFactionAndLevel(IPlayableFaction faction,int level){
  IPlayableFaction old=currentFaction;
  int oldLevel=currentLevel;
  if (currentFaction != null && (!currentFaction.equals(faction) || level == 0)) {
    if (!currentFaction.getPlayerCapability(player).canLeaveFaction()) {
      VampirismMod.log.i(TAG,""String_Node_Str"",currentFaction.getKey());
      return false;
    }
  }
  if (faction == null) {
    currentFaction=null;
    currentLevel=0;
  }
 else {
    if (level < 0 || level > faction.getHighestReachableLevel()) {
      VampirismMod.log.w(TAG,""String_Node_Str"",level,faction.getKey());
      return false;
    }
    currentFaction=faction;
    currentLevel=level;
  }
  if (currentFaction == null)   currentLevel=0;
 else   if (currentLevel == 0)   currentFaction=null;
  notifyFaction(old,oldLevel);
  sync(!Objects.equals(old,currentFaction));
  return true;
}"
12677,"/** 
 * Notify faction about changes.  {@link FactionPlayerHandler#currentFaction} and {@link FactionPlayerHandler#currentLevel} will be used as the new ones
 * @param oldFaction
 * @param oldLevel
 */
private void notifyFaction(IPlayableFaction oldFaction,int oldLevel){
  if (oldFaction != currentFaction && oldFaction != null) {
    VampirismMod.log.d(TAG,""String_Node_Str"",oldFaction.getKey());
    oldFaction.getPlayerCapability(player).onLevelChanged(0,oldLevel);
  }
  if (currentFaction != null) {
    VampirismMod.log.d(TAG,""String_Node_Str"",currentFaction,currentLevel);
    currentFaction.getPlayerCapability(player).onLevelChanged(currentLevel,oldFaction == currentFaction ? oldLevel : 0);
  }
  if (currentFaction != oldFaction) {
    onChangedFaction();
  }
}","/** 
 * Notify faction about changes.  {@link FactionPlayerHandler#currentFaction} and {@link FactionPlayerHandler#currentLevel} will be used as the new ones
 * @param oldFaction
 * @param oldLevel
 */
private void notifyFaction(IPlayableFaction oldFaction,int oldLevel){
  if (oldFaction != null && !oldFaction.equals(currentFaction)) {
    VampirismMod.log.d(TAG,""String_Node_Str"",oldFaction.getKey());
    oldFaction.getPlayerCapability(player).onLevelChanged(0,oldLevel);
  }
  if (currentFaction != null) {
    VampirismMod.log.d(TAG,""String_Node_Str"",currentFaction,currentLevel);
    currentFaction.getPlayerCapability(player).onLevelChanged(currentLevel,oldFaction == currentFaction ? oldLevel : 0);
  }
  if (!Objects.equals(currentFaction,oldFaction)) {
    onChangedFaction();
  }
}"
12678,"@Override public EnumActionResult onItemUse(ItemStack stack,EntityPlayer player,World world,BlockPos pos,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  if (side != EnumFacing.UP) {
    return EnumActionResult.FAIL;
  }
  if (world.isRemote)   return EnumActionResult.PASS;
  IBlockState iblockstate=world.getBlockState(pos);
  Block block=iblockstate.getBlock();
  boolean replaceable=block.isReplaceable(world,pos);
  if (!replaceable) {
    pos=pos.up();
  }
  int direction=MathHelper.floor_double((player.rotationYaw * 4F) / 360F + 0.5D) & 3;
  EnumFacing facing=EnumFacing.getHorizontal(direction);
  BlockPos other=pos.offset(facing);
  boolean other_replaceable=block.isReplaceable(world,other);
  boolean flag1=world.isAirBlock(pos) || replaceable;
  boolean flag2=world.isAirBlock(other) || other_replaceable;
  if (player.canPlayerEdit(pos,side,stack) && player.canPlayerEdit(other,side,stack)) {
    if (flag1 && flag2 && UtilLib.doesBlockHaveSolidTopSurface(world,pos.down())&& UtilLib.doesBlockHaveSolidTopSurface(world,other.down())) {
      IBlockState state1=ModBlocks.coffin.getDefaultState().withProperty(BlockCoffin.OCCUPIED,Boolean.FALSE).withProperty(BlockCoffin.PART,BlockCoffin.EnumPartType.FOOT).withProperty(BlockCoffin.FACING,facing);
      if (world.setBlockState(pos,state1,3)) {
        IBlockState state2=state1.withProperty(BlockCoffin.PART,BlockCoffin.EnumPartType.HEAD).withProperty(BlockCoffin.FACING,facing);
        world.setBlockState(other,state2,3);
      }
      --stack.stackSize;
      return EnumActionResult.SUCCESS;
    }
  }
  return EnumActionResult.FAIL;
}","@Override public EnumActionResult onItemUse(ItemStack stack,EntityPlayer player,World world,BlockPos targetPos,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  if (side != EnumFacing.UP) {
    return EnumActionResult.FAIL;
  }
  if (world.isRemote)   return EnumActionResult.PASS;
  IBlockState iblockstate=world.getBlockState(targetPos);
  Block block=iblockstate.getBlock();
  boolean replaceable=block.isReplaceable(world,targetPos);
  BlockPos pos=replaceable ? targetPos : targetPos.up();
  int direction=MathHelper.floor_double((player.rotationYaw * 4F) / 360F + 0.5D) & 3;
  EnumFacing facing=EnumFacing.getHorizontal(direction);
  BlockPos other=pos.offset(facing);
  boolean other_replaceable=block.isReplaceable(world,other);
  boolean flag1=world.isAirBlock(pos) || replaceable;
  boolean flag2=world.isAirBlock(other) || other_replaceable;
  if (player.canPlayerEdit(pos,side,stack) && player.canPlayerEdit(other,side,stack)) {
    if (flag1 && flag2 && UtilLib.doesBlockHaveSolidTopSurface(world,pos.down())&& UtilLib.doesBlockHaveSolidTopSurface(world,other.down())) {
      IBlockState state1=ModBlocks.coffin.getDefaultState().withProperty(BlockCoffin.OCCUPIED,Boolean.FALSE).withProperty(BlockCoffin.PART,BlockCoffin.EnumPartType.FOOT).withProperty(BlockCoffin.FACING,facing);
      if (world.setBlockState(pos,state1,3)) {
        IBlockState state2=state1.withProperty(BlockCoffin.PART,BlockCoffin.EnumPartType.HEAD).withProperty(BlockCoffin.FACING,facing);
        world.setBlockState(other,state2,3);
      }
      --stack.stackSize;
      return EnumActionResult.SUCCESS;
    }
  }
  return EnumActionResult.FAIL;
}"
12679,"@Override public EnumActionResult onItemUse(ItemStack stack,EntityPlayer player,World world,BlockPos pos,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  if (side != EnumFacing.UP) {
    return EnumActionResult.FAIL;
  }
  if (world.isRemote)   return EnumActionResult.SUCCESS;
  IBlockState iblockstate=world.getBlockState(pos);
  Block block=iblockstate.getBlock();
  boolean replaceable=block.isReplaceable(world,pos);
  if (!replaceable) {
    pos=pos.up();
  }
  int direction=MathHelper.floor_double((player.rotationYaw * 4F) / 360F + 0.5D) & 3;
  EnumFacing facing=EnumFacing.getHorizontal(direction);
  BlockPos other=pos.offset(facing);
  boolean other_replaceable=block.isReplaceable(world,other);
  boolean flag1=world.isAirBlock(pos) || replaceable;
  boolean flag2=world.isAirBlock(other) || other_replaceable;
  if (player.canPlayerEdit(pos,side,stack) && player.canPlayerEdit(other,side,stack)) {
    VampirismMod.log.t(""String_Node_Str"",flag1,flag2,UtilLib.doesBlockHaveSolidTopSurface(world,pos.down()),UtilLib.doesBlockHaveSolidTopSurface(world,other.down()));
    if (flag1 && flag2 && UtilLib.doesBlockHaveSolidTopSurface(world,pos.down())&& UtilLib.doesBlockHaveSolidTopSurface(world,other.down())) {
      IBlockState state1=ModBlocks.medChair.getDefaultState().withProperty(BlockMedChair.PART,BlockMedChair.EnumPart.BOTTOM).withProperty(BlockMedChair.FACING,facing.getOpposite());
      if (world.setBlockState(pos,state1,3)) {
        IBlockState state2=state1.withProperty(BlockMedChair.PART,BlockMedChair.EnumPart.TOP).withProperty(BlockMedChair.FACING,facing.getOpposite());
        world.setBlockState(other,state2,3);
      }
      --stack.stackSize;
      return EnumActionResult.SUCCESS;
    }
  }
  return EnumActionResult.FAIL;
}","@Override public EnumActionResult onItemUse(ItemStack stack,EntityPlayer player,World world,BlockPos targetPos,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  if (side != EnumFacing.UP) {
    return EnumActionResult.FAIL;
  }
  if (world.isRemote)   return EnumActionResult.SUCCESS;
  IBlockState iblockstate=world.getBlockState(targetPos);
  Block block=iblockstate.getBlock();
  boolean replaceable=block.isReplaceable(world,targetPos);
  BlockPos pos=replaceable ? targetPos : targetPos.up();
  int direction=MathHelper.floor_double((player.rotationYaw * 4F) / 360F + 0.5D) & 3;
  EnumFacing facing=EnumFacing.getHorizontal(direction);
  BlockPos other=pos.offset(facing);
  boolean other_replaceable=block.isReplaceable(world,other);
  boolean flag1=world.isAirBlock(pos) || replaceable;
  boolean flag2=world.isAirBlock(other) || other_replaceable;
  if (player.canPlayerEdit(pos,side,stack) && player.canPlayerEdit(other,side,stack)) {
    VampirismMod.log.t(""String_Node_Str"",flag1,flag2,UtilLib.doesBlockHaveSolidTopSurface(world,pos.down()),UtilLib.doesBlockHaveSolidTopSurface(world,other.down()));
    if (flag1 && flag2 && UtilLib.doesBlockHaveSolidTopSurface(world,pos.down())&& UtilLib.doesBlockHaveSolidTopSurface(world,other.down())) {
      IBlockState state1=ModBlocks.medChair.getDefaultState().withProperty(BlockMedChair.PART,BlockMedChair.EnumPart.BOTTOM).withProperty(BlockMedChair.FACING,facing.getOpposite());
      if (world.setBlockState(pos,state1,3)) {
        IBlockState state2=state1.withProperty(BlockMedChair.PART,BlockMedChair.EnumPart.TOP).withProperty(BlockMedChair.FACING,facing.getOpposite());
        world.setBlockState(other,state2,3);
      }
      --stack.stackSize;
      return EnumActionResult.SUCCESS;
    }
  }
  return EnumActionResult.FAIL;
}"
12680,"/** 
 * @return If the crossbow can shoot without an arrow in the players inventory
 */
protected boolean isCrossbowInfinite(ItemStack stack,EntityPlayer player){
  int enchant=net.minecraft.enchantment.EnchantmentHelper.getEnchantmentLevel(net.minecraft.init.Enchantments.INFINITY,stack);
  return enchant > 0;
}","/** 
 * @return If the crossbow can shoot without an arrow in the players inventory
 */
protected boolean isCrossbowInfinite(ItemStack stack,EntityPlayer player){
  int enchant=EnchantmentHelper.getEnchantmentLevel(net.minecraft.init.Enchantments.INFINITY,stack);
  return enchant > 0;
}"
12681,"@Override public IMessage handleServerMessage(EntityPlayer player,InputEventPacket message,MessageContext ctx){
  if (message.action == null)   return null;
  IFactionPlayer factionPlayer=FactionPlayerHandler.get(player).getCurrentFactionPlayer();
  if (message.action.equals(SUCKBLOOD)) {
    int id=0;
    try {
      id=Integer.parseInt(message.param);
    }
 catch (    NumberFormatException e) {
      VampirismMod.log.e(TAG,e,""String_Node_Str"",message.action);
    }
    if (id != 0) {
      VampirePlayer.get(player).biteEntity(id);
    }
  }
 else   if (message.action.equals(TOGGLEACTION)) {
    int id=-1;
    try {
      id=Integer.parseInt(message.param);
    }
 catch (    NumberFormatException e) {
      VampirismMod.log.e(TAG,e,""String_Node_Str"",message.action);
    }
    if (id != -1) {
      if (factionPlayer != null) {
        IActionHandler actionHandler=VampirismAPI.getFactionPlayerHandler(player).getCurrentFactionPlayer().getActionHandler();
        IAction action=((ActionHandler)actionHandler).getActionFromId(id);
        if (action != null) {
          IAction.PERM r=VampirePlayer.get(player).getActionHandler().toggleAction(action);
switch (r) {
case NOT_UNLOCKED:
            player.addChatMessage(new TextComponentTranslation(""String_Node_Str""));
          break;
case DISABLED:
        player.addChatMessage(new TextComponentTranslation(""String_Node_Str""));
      break;
case COOLDOWN:
    player.addChatMessage(new TextComponentTranslation(""String_Node_Str""));
  break;
}
}
 else {
VampirismMod.log.e(TAG,""String_Node_Str"",id);
}
}
 else {
VampirismMod.log.e(TAG,""String_Node_Str"",player,id);
}
}
}
 else if (message.action.equals(UNLOCKSKILL)) {
if (factionPlayer != null) {
ISkill skill=VampirismAPI.skillRegistry().getSkill(factionPlayer.getFaction(),message.param);
if (skill != null) {
ISkillHandler skillHandler=factionPlayer.getSkillHandler();
ISkillHandler.Result result=skillHandler.canSkillBeEnabled(skill);
if (result == ISkillHandler.Result.OK) {
skillHandler.enableSkill(skill);
if (factionPlayer instanceof ISyncable.ISyncableEntityCapabilityInst && skillHandler instanceof SkillHandler) {
NBTTagCompound sync=new NBTTagCompound();
((SkillHandler)skillHandler).writeUpdateForClient(sync);
HelperLib.sync((ISyncable.ISyncableEntityCapabilityInst)factionPlayer,sync,factionPlayer.getRepresentingPlayer(),false);
}
}
 else {
VampirismMod.log.w(TAG,""String_Node_Str"",skill,player,result);
}
}
 else {
VampirismMod.log.w(TAG,""String_Node_Str"",message.param,player);
}
}
 else {
VampirismMod.log.e(TAG,""String_Node_Str"");
}
}
 else if (message.action.equals(RESETSKILL)) {
if (factionPlayer != null) {
ISkillHandler skillHandler=factionPlayer.getSkillHandler();
skillHandler.resetSkills();
if (factionPlayer instanceof ISyncable.ISyncableEntityCapabilityInst && skillHandler instanceof SkillHandler) {
NBTTagCompound sync=new NBTTagCompound();
((SkillHandler)skillHandler).writeUpdateForClient(sync);
HelperLib.sync((ISyncable.ISyncableEntityCapabilityInst)factionPlayer,sync,factionPlayer.getRepresentingPlayer(),false);
}
}
 else {
VampirismMod.log.e(TAG,""String_Node_Str"");
}
}
 else if (message.action.equals(TRAINERLEVELUP)) {
if (player.openContainer instanceof HunterTrainerContainer) {
((HunterTrainerContainer)player.openContainer).onLevelupClicked();
}
}
 else if (message.action.equals(REVERTBACK)) {
FactionPlayerHandler.get(player).setFactionAndLevel(null,0);
VampirismMod.log.d(TAG,""String_Node_Str"",player);
player.attackEntityFrom(DamageSource.magic,1000);
}
 else if (message.action.equals(WAKEUP)) {
VampirePlayer.get(player).wakeUpPlayer(false,true,true);
}
 else if (message.action.equals(VAMPIRE_VISION_TOGGLE)) {
VampirePlayer.get(player).switchVision();
}
 else if (message.action.equals(CRAFT_BLOOD_POTION)) {
if (player.openContainer != null && player.openContainer instanceof BloodPotionTableContainer) {
((BloodPotionTableContainer)player.openContainer).onCraftingClicked();
}
}
 else if (message.action.equals(OPEN_BLOOD_POTION)) {
IHunterPlayer hunter=HunterPlayer.get(player);
if (hunter.getLevel() > 0) {
if (hunter.getSkillHandler().isSkillEnabled(HunterSkills.bloodPotion_portableCrafting)) {
player.openGui(VampirismMod.instance,ModGuiHandler.ID_BLOOD_POTION_TABLE,player.worldObj,player.getPosition().getX(),player.getPosition().getY(),player.getPosition().getZ());
}
 else {
player.addChatComponentMessage(new TextComponentTranslation(""String_Node_Str"",new TextComponentTranslation(HunterSkills.bloodPotion_portableCrafting.getUnlocalizedName())));
}
}
 else {
player.addChatComponentMessage(new TextComponentTranslation(""String_Node_Str"",new TextComponentTranslation(VReference.HUNTER_FACTION.getUnlocalizedName())));
}
}
return null;
}","@Override public IMessage handleServerMessage(EntityPlayer player,InputEventPacket message,MessageContext ctx){
  if (message.action == null)   return null;
  IFactionPlayer factionPlayer=FactionPlayerHandler.get(player).getCurrentFactionPlayer();
  if (message.action.equals(SUCKBLOOD)) {
    int id=0;
    try {
      id=Integer.parseInt(message.param);
    }
 catch (    NumberFormatException e) {
      VampirismMod.log.e(TAG,e,""String_Node_Str"",message.action);
    }
    if (id != 0) {
      VampirePlayer.get(player).biteEntity(id);
    }
  }
 else   if (message.action.equals(TOGGLEACTION)) {
    int id=-1;
    try {
      id=Integer.parseInt(message.param);
    }
 catch (    NumberFormatException e) {
      VampirismMod.log.e(TAG,e,""String_Node_Str"",message.action);
    }
    if (id != -1) {
      if (factionPlayer != null) {
        IActionHandler actionHandler=VampirismAPI.getFactionPlayerHandler(player).getCurrentFactionPlayer().getActionHandler();
        IAction action=((ActionHandler)actionHandler).getActionFromId(id);
        if (action != null) {
          IAction.PERM r=VampirePlayer.get(player).getActionHandler().toggleAction(action);
switch (r) {
case NOT_UNLOCKED:
            player.addChatMessage(new TextComponentTranslation(""String_Node_Str""));
          break;
case DISABLED:
        player.addChatMessage(new TextComponentTranslation(""String_Node_Str""));
      break;
case COOLDOWN:
    player.addChatMessage(new TextComponentTranslation(""String_Node_Str""));
  break;
default :
}
}
 else {
VampirismMod.log.e(TAG,""String_Node_Str"",id);
}
}
 else {
VampirismMod.log.e(TAG,""String_Node_Str"",player,id);
}
}
}
 else if (message.action.equals(UNLOCKSKILL)) {
if (factionPlayer != null) {
ISkill skill=VampirismAPI.skillRegistry().getSkill(factionPlayer.getFaction(),message.param);
if (skill != null) {
ISkillHandler skillHandler=factionPlayer.getSkillHandler();
ISkillHandler.Result result=skillHandler.canSkillBeEnabled(skill);
if (result == ISkillHandler.Result.OK) {
skillHandler.enableSkill(skill);
if (factionPlayer instanceof ISyncable.ISyncableEntityCapabilityInst && skillHandler instanceof SkillHandler) {
NBTTagCompound sync=new NBTTagCompound();
((SkillHandler)skillHandler).writeUpdateForClient(sync);
HelperLib.sync((ISyncable.ISyncableEntityCapabilityInst)factionPlayer,sync,factionPlayer.getRepresentingPlayer(),false);
}
}
 else {
VampirismMod.log.w(TAG,""String_Node_Str"",skill,player,result);
}
}
 else {
VampirismMod.log.w(TAG,""String_Node_Str"",message.param,player);
}
}
 else {
VampirismMod.log.e(TAG,""String_Node_Str"");
}
}
 else if (message.action.equals(RESETSKILL)) {
if (factionPlayer != null) {
ISkillHandler skillHandler=factionPlayer.getSkillHandler();
skillHandler.resetSkills();
if (factionPlayer instanceof ISyncable.ISyncableEntityCapabilityInst && skillHandler instanceof SkillHandler) {
NBTTagCompound sync=new NBTTagCompound();
((SkillHandler)skillHandler).writeUpdateForClient(sync);
HelperLib.sync((ISyncable.ISyncableEntityCapabilityInst)factionPlayer,sync,factionPlayer.getRepresentingPlayer(),false);
}
}
 else {
VampirismMod.log.e(TAG,""String_Node_Str"");
}
}
 else if (message.action.equals(TRAINERLEVELUP)) {
if (player.openContainer instanceof HunterTrainerContainer) {
((HunterTrainerContainer)player.openContainer).onLevelupClicked();
}
}
 else if (message.action.equals(REVERTBACK)) {
FactionPlayerHandler.get(player).setFactionAndLevel(null,0);
VampirismMod.log.d(TAG,""String_Node_Str"",player);
player.attackEntityFrom(DamageSource.magic,1000);
}
 else if (message.action.equals(WAKEUP)) {
VampirePlayer.get(player).wakeUpPlayer(false,true,true);
}
 else if (message.action.equals(VAMPIRE_VISION_TOGGLE)) {
VampirePlayer.get(player).switchVision();
}
 else if (message.action.equals(CRAFT_BLOOD_POTION)) {
if (player.openContainer != null && player.openContainer instanceof BloodPotionTableContainer) {
((BloodPotionTableContainer)player.openContainer).onCraftingClicked();
}
}
 else if (message.action.equals(OPEN_BLOOD_POTION)) {
IHunterPlayer hunter=HunterPlayer.get(player);
if (hunter.getLevel() > 0) {
if (hunter.getSkillHandler().isSkillEnabled(HunterSkills.bloodPotion_portableCrafting)) {
player.openGui(VampirismMod.instance,ModGuiHandler.ID_BLOOD_POTION_TABLE,player.worldObj,player.getPosition().getX(),player.getPosition().getY(),player.getPosition().getZ());
}
 else {
player.addChatComponentMessage(new TextComponentTranslation(""String_Node_Str"",new TextComponentTranslation(HunterSkills.bloodPotion_portableCrafting.getUnlocalizedName())));
}
}
 else {
player.addChatComponentMessage(new TextComponentTranslation(""String_Node_Str"",new TextComponentTranslation(VReference.HUNTER_FACTION.getUnlocalizedName())));
}
}
return null;
}"
12682,"public int[] getItemRequirementsForTrainer(int targetLevel){
  if (!isLevelValidForTrainer(targetLevel)) {
    throw new IllegalArgumentException(""String_Node_Str"" + targetLevel);
  }
switch (targetLevel) {
case 5:
    return new int[]{5,0};
case 6:
  return new int[]{10,0};
case 7:
return new int[]{15,0};
case 8:
return new int[]{40,0};
case 9:
return new int[]{20,10};
case 10:
return new int[]{20,20};
case 11:
return new int[]{20,10};
case 12:
return new int[]{30,10};
case 13:
return new int[]{40,20};
case 14:
return new int[]{40,40};
}
return null;
}","public int[] getItemRequirementsForTrainer(int targetLevel){
  if (!isLevelValidForTrainer(targetLevel)) {
    throw new IllegalArgumentException(""String_Node_Str"" + targetLevel);
  }
switch (targetLevel) {
case 5:
    return new int[]{5,0};
case 6:
  return new int[]{10,0};
case 7:
return new int[]{15,0};
case 8:
return new int[]{40,0};
case 9:
return new int[]{20,10};
case 10:
return new int[]{20,20};
case 11:
return new int[]{20,10};
case 12:
return new int[]{30,10};
case 13:
return new int[]{40,20};
case 14:
return new int[]{40,40};
default :
VampirismMod.log.w(""String_Node_Str"",""String_Node_Str"");
}
return null;
}"
12683,"@SuppressWarnings(""String_Node_Str"") public static ICapabilityProvider createNewCapability(final EntityPlayer player){
  return new ICapabilitySerializable<NBTTagCompound>(){
    IHunterPlayer inst=new HunterPlayer(player);
    @Override public void deserializeNBT(    NBTTagCompound nbt){
      CAP.getStorage().readNBT(CAP,inst,null,nbt);
    }
    @Override public <T>T getCapability(    Capability<T> capability,    EnumFacing facing){
      return capability == CAP ? (T)(inst) : null;
    }
    @Override public boolean hasCapability(    Capability<?> capability,    EnumFacing facing){
      return capability == CAP;
    }
    @Override public NBTTagCompound serializeNBT(){
      return (NBTTagCompound)CAP.getStorage().writeNBT(CAP,inst,null);
    }
  }
;
}","@SuppressWarnings(""String_Node_Str"") public static ICapabilityProvider createNewCapability(final EntityPlayer player){
  return new ICapabilitySerializable<NBTTagCompound>(){
    IHunterPlayer inst=new HunterPlayer(player);
    @Override public void deserializeNBT(    NBTTagCompound nbt){
      CAP.getStorage().readNBT(CAP,inst,null,nbt);
    }
    @Override public <T>T getCapability(    Capability<T> capability,    EnumFacing facing){
      return capability == CAP ? CAP.<T>cast(inst) : null;
    }
    @Override public boolean hasCapability(    Capability<?> capability,    EnumFacing facing){
      return CAP.equals(capability);
    }
    @Override public NBTTagCompound serializeNBT(){
      return (NBTTagCompound)CAP.getStorage().writeNBT(CAP,inst,null);
    }
  }
;
}"
12684,"@Override public <T>T getCapability(Capability<T> capability,EnumFacing facing){
  return capability == CAP ? (T)(inst) : null;
}","@Override public <T>T getCapability(Capability<T> capability,EnumFacing facing){
  return capability == CAP ? CAP.<T>cast(inst) : null;
}"
12685,"@Override public boolean hasCapability(Capability<?> capability,EnumFacing facing){
  return capability == CAP;
}","@Override public boolean hasCapability(Capability<?> capability,EnumFacing facing){
  return CAP.equals(capability);
}"
12686,"@Override public EntityPlayer.SleepResult trySleep(BlockPos bedLocation){
  if (!player.worldObj.isRemote) {
    if (player.isPlayerSleeping() || !player.isEntityAlive()) {
      return EntityPlayer.SleepResult.OTHER_PROBLEM;
    }
    if (!player.worldObj.provider.isSurfaceWorld()) {
      return EntityPlayer.SleepResult.NOT_POSSIBLE_HERE;
    }
    if (!player.worldObj.isDaytime()) {
      return EntityPlayer.SleepResult.NOT_POSSIBLE_NOW;
    }
    if (Math.abs(player.posX - (double)bedLocation.getX()) > 3.0D || Math.abs(player.posY - (double)bedLocation.getY()) > 2.0D || Math.abs(player.posZ - (double)bedLocation.getZ()) > 3.0D) {
      return EntityPlayer.SleepResult.TOO_FAR_AWAY;
    }
    double d0=8.0D;
    double d1=5.0D;
    List<EntityMob> list=player.worldObj.getEntitiesWithinAABB(EntityMob.class,new AxisAlignedBB((double)bedLocation.getX() - d0,(double)bedLocation.getY() - d1,(double)bedLocation.getZ() - d0,(double)bedLocation.getX() + d0,(double)bedLocation.getY() + d1,(double)bedLocation.getZ() + d0));
    if (!list.isEmpty()) {
      return EntityPlayer.SleepResult.NOT_SAFE;
    }
  }
  if (player.isRiding()) {
    player.dismountRidingEntity();
  }
  if (!setEntitySize(0.2F,0.2F))   return EntityPlayer.SleepResult.OTHER_PROBLEM;
  IBlockState state=null;
  if (player.worldObj.isBlockLoaded(bedLocation))   state=player.worldObj.getBlockState(bedLocation);
  if (state != null && state.getBlock().isBed(state,player.worldObj,bedLocation,player)) {
    EnumFacing enumfacing=state.getBlock().getBedDirection(state,player.worldObj,bedLocation);
    float f=0.5F;
    float f1=0.5F;
switch (enumfacing) {
case SOUTH:
      f1=0.9F;
    break;
case NORTH:
  f1=0.1F;
break;
case WEST:
f=0.1F;
break;
case EAST:
f=0.9F;
}
try {
Method mSetSize=ReflectionHelper.findMethod(EntityPlayer.class,player,new String[]{""String_Node_Str"",SRGNAMES.EntityPlayer_setRenderOffsetForSleep},EnumFacing.class);
mSetSize.invoke(player,enumfacing);
}
 catch (Exception e) {
VampirismMod.log.e(TAG,e,""String_Node_Str"");
return EntityPlayer.SleepResult.OTHER_PROBLEM;
}
player.setPosition((double)((float)bedLocation.getX() + f),(double)((float)bedLocation.getY() + 0.6875F),(double)((float)bedLocation.getZ() + f1));
}
 else {
player.setPosition((double)((float)bedLocation.getX() + 0.5F),(double)((float)bedLocation.getY() + 0.6875F),(double)((float)bedLocation.getZ() + 0.5F));
}
sleepTimer=0;
sleepingInCoffin=true;
player.noClip=true;
player.playerLocation=bedLocation;
player.motionX=player.motionZ=player.motionY=0.0D;
if (!player.worldObj.isRemote) {
DaySleepHelper.updateAllPlayersSleeping(player.worldObj);
}
if (player instanceof EntityPlayerMP) {
EntityPlayerMP playerMP=(EntityPlayerMP)player;
Packet<?> packet=new SPacketUseBed(player,bedLocation);
playerMP.getServerWorld().getEntityTracker().sendToAllTrackingEntity(playerMP,packet);
playerMP.connection.setPlayerLocation(player.posX,player.posY,player.posZ,player.rotationYaw,player.rotationPitch);
playerMP.connection.sendPacket(packet);
}
return EntityPlayer.SleepResult.OK;
}","@Override public EntityPlayer.SleepResult trySleep(BlockPos bedLocation){
  if (!player.worldObj.isRemote) {
    if (player.isPlayerSleeping() || !player.isEntityAlive()) {
      return EntityPlayer.SleepResult.OTHER_PROBLEM;
    }
    if (!player.worldObj.provider.isSurfaceWorld()) {
      return EntityPlayer.SleepResult.NOT_POSSIBLE_HERE;
    }
    if (!player.worldObj.isDaytime()) {
      return EntityPlayer.SleepResult.NOT_POSSIBLE_NOW;
    }
    if (Math.abs(player.posX - (double)bedLocation.getX()) > 3.0D || Math.abs(player.posY - (double)bedLocation.getY()) > 2.0D || Math.abs(player.posZ - (double)bedLocation.getZ()) > 3.0D) {
      return EntityPlayer.SleepResult.TOO_FAR_AWAY;
    }
    double d0=8.0D;
    double d1=5.0D;
    List<EntityMob> list=player.worldObj.getEntitiesWithinAABB(EntityMob.class,new AxisAlignedBB((double)bedLocation.getX() - d0,(double)bedLocation.getY() - d1,(double)bedLocation.getZ() - d0,(double)bedLocation.getX() + d0,(double)bedLocation.getY() + d1,(double)bedLocation.getZ() + d0));
    if (!list.isEmpty()) {
      return EntityPlayer.SleepResult.NOT_SAFE;
    }
  }
  if (player.isRiding()) {
    player.dismountRidingEntity();
  }
  if (!setEntitySize(0.2F,0.2F))   return EntityPlayer.SleepResult.OTHER_PROBLEM;
  IBlockState state=null;
  if (player.worldObj.isBlockLoaded(bedLocation))   state=player.worldObj.getBlockState(bedLocation);
  if (state != null && state.getBlock().isBed(state,player.worldObj,bedLocation,player)) {
    EnumFacing enumfacing=state.getBlock().getBedDirection(state,player.worldObj,bedLocation);
    float f=0.5F;
    float f1=0.5F;
switch (enumfacing) {
case SOUTH:
      f1=0.9F;
    break;
case NORTH:
  f1=0.1F;
break;
case WEST:
f=0.1F;
break;
case EAST:
f=0.9F;
break;
default :
}
try {
Method mSetSize=ReflectionHelper.findMethod(EntityPlayer.class,player,new String[]{""String_Node_Str"",SRGNAMES.EntityPlayer_setRenderOffsetForSleep},EnumFacing.class);
mSetSize.invoke(player,enumfacing);
}
 catch (Exception e) {
VampirismMod.log.e(TAG,e,""String_Node_Str"");
return EntityPlayer.SleepResult.OTHER_PROBLEM;
}
player.setPosition((double)((float)bedLocation.getX() + f),(double)((float)bedLocation.getY() + 0.6875F),(double)((float)bedLocation.getZ() + f1));
}
 else {
player.setPosition((double)((float)bedLocation.getX() + 0.5F),(double)((float)bedLocation.getY() + 0.6875F),(double)((float)bedLocation.getZ() + 0.5F));
}
sleepTimer=0;
sleepingInCoffin=true;
player.noClip=true;
player.playerLocation=bedLocation;
player.motionX=player.motionZ=player.motionY=0.0D;
if (!player.worldObj.isRemote) {
DaySleepHelper.updateAllPlayersSleeping(player.worldObj);
}
if (player instanceof EntityPlayerMP) {
EntityPlayerMP playerMP=(EntityPlayerMP)player;
Packet<?> packet=new SPacketUseBed(player,bedLocation);
playerMP.getServerWorld().getEntityTracker().sendToAllTrackingEntity(playerMP,packet);
playerMP.connection.setPlayerLocation(player.posX,player.posY,player.posZ,player.rotationYaw,player.rotationPitch);
playerMP.connection.sendPacket(packet);
}
return EntityPlayer.SleepResult.OK;
}"
12687,"@Override public void unUnlockVision(@Nonnull IVampireVision vision){
  if (activatedVision == vision) {
    activateVision(null);
  }
  unlockedVisions.remove(vision);
}","@Override public void unUnlockVision(@Nonnull IVampireVision vision){
  if (vision.equals(activatedVision)) {
    activateVision(null);
  }
  unlockedVisions.remove(vision);
}"
12688,"@Override public boolean hasCapability(Capability<?> capability,EnumFacing facing){
  return capability == CAP;
}","@Override public boolean hasCapability(Capability<?> capability,EnumFacing facing){
  return CAP.equals(capability);
}"
12689,"@SuppressWarnings(""String_Node_Str"") public static ICapabilityProvider createNewCapability(final EntityPlayer player){
  return new ICapabilitySerializable<NBTTagCompound>(){
    IVampirePlayer inst=new VampirePlayer(player);
    @Override public void deserializeNBT(    NBTTagCompound nbt){
      CAP.getStorage().readNBT(CAP,inst,null,nbt);
    }
    @Override public <T>T getCapability(    Capability<T> capability,    EnumFacing facing){
      return CAP.equals(capability) ? CAP.<T>cast(inst) : null;
    }
    @Override public boolean hasCapability(    Capability<?> capability,    EnumFacing facing){
      return capability == CAP;
    }
    @Override public NBTTagCompound serializeNBT(){
      return (NBTTagCompound)CAP.getStorage().writeNBT(CAP,inst,null);
    }
  }
;
}","@SuppressWarnings(""String_Node_Str"") public static ICapabilityProvider createNewCapability(final EntityPlayer player){
  return new ICapabilitySerializable<NBTTagCompound>(){
    IVampirePlayer inst=new VampirePlayer(player);
    @Override public void deserializeNBT(    NBTTagCompound nbt){
      CAP.getStorage().readNBT(CAP,inst,null,nbt);
    }
    @Override public <T>T getCapability(    Capability<T> capability,    EnumFacing facing){
      return CAP.equals(capability) ? CAP.<T>cast(inst) : null;
    }
    @Override public boolean hasCapability(    Capability<?> capability,    EnumFacing facing){
      return CAP.equals(capability);
    }
    @Override public NBTTagCompound serializeNBT(){
      return (NBTTagCompound)CAP.getStorage().writeNBT(CAP,inst,null);
    }
  }
;
}"
12690,"@Override public void activateVision(@Nullable IVampireVision vision){
  if (vision != null && !isRemote() && ((GeneralRegistryImpl)VampirismAPI.vampireVisionRegistry()).getIdOfVision(vision) == -1) {
    throw new IllegalArgumentException(""String_Node_Str"" + vision);
  }
  if (activatedVision != vision) {
    if (activatedVision != null) {
      activatedVision.onDeactivated(this);
    }
    activatedVision=vision;
    if (vision != null) {
      vision.onActivated(this);
    }
    if (!isRemote()) {
      NBTTagCompound nbt=new NBTTagCompound();
      nbt.setInteger(KEY_VISION,activatedVision == null ? -1 : ((GeneralRegistryImpl)VampirismAPI.vampireVisionRegistry()).getIdOfVision(activatedVision));
      this.sync(nbt,false);
    }
  }
}","@Override public void activateVision(@Nullable IVampireVision vision){
  if (vision != null && !isRemote() && ((GeneralRegistryImpl)VampirismAPI.vampireVisionRegistry()).getIdOfVision(vision) == -1) {
    throw new IllegalArgumentException(""String_Node_Str"" + vision);
  }
  if (!Objects.equals(activatedVision,vision)) {
    if (activatedVision != null) {
      activatedVision.onDeactivated(this);
    }
    activatedVision=vision;
    if (vision != null) {
      vision.onActivated(this);
    }
    if (!isRemote()) {
      NBTTagCompound nbt=new NBTTagCompound();
      nbt.setInteger(KEY_VISION,activatedVision == null ? -1 : ((GeneralRegistryImpl)VampirismAPI.vampireVisionRegistry()).getIdOfVision(activatedVision));
      this.sync(nbt,false);
    }
  }
}"
12691,"private boolean checkItemRequirements(EntityPlayer player){
  int newLevel=targetLevel;
  ItemStack missing=null;
switch (newLevel) {
case 5:
    missing=checkAndRemoveItems(0,0,5,0);
  break;
case 6:
missing=checkAndRemoveItems(0,1,0,0);
break;
case 7:
missing=checkAndRemoveItems(0,1,5,0);
break;
case 8:
missing=checkAndRemoveItems(1,1,0,0);
break;
case 9:
missing=checkAndRemoveItems(1,1,5,0);
break;
case 10:
missing=checkAndRemoveItems(2,1,5,0);
break;
case 11:
missing=checkAndRemoveItems(2,1,10,0);
break;
case 12:
missing=checkAndRemoveItems(3,1,10,0);
break;
case 13:
missing=checkAndRemoveItems(3,2,0,0);
break;
case 14:
missing=checkAndRemoveItems(4,2,0,0);
break;
}
if (missing != null) {
ITextComponent item=missing.getItem().equals(ModItems.pureBlood) ? ModItems.pureBlood.getDisplayName(missing) : new TextComponentTranslation(missing.getUnlocalizedName() + ""String_Node_Str"");
ITextComponent main=new TextComponentTranslation(""String_Node_Str"",missing.stackSize,item);
player.addChatComponentMessage(main);
return false;
}
return true;
}","private boolean checkItemRequirements(EntityPlayer player){
  int newLevel=targetLevel;
  ItemStack missing=null;
switch (newLevel) {
case 5:
    missing=checkAndRemoveItems(0,0,5,0);
  break;
case 6:
missing=checkAndRemoveItems(0,1,0,0);
break;
case 7:
missing=checkAndRemoveItems(0,1,5,0);
break;
case 8:
missing=checkAndRemoveItems(1,1,0,0);
break;
case 9:
missing=checkAndRemoveItems(1,1,5,0);
break;
case 10:
missing=checkAndRemoveItems(2,1,5,0);
break;
case 11:
missing=checkAndRemoveItems(2,1,10,0);
break;
case 12:
missing=checkAndRemoveItems(3,1,10,0);
break;
case 13:
missing=checkAndRemoveItems(3,2,0,0);
break;
case 14:
missing=checkAndRemoveItems(4,2,0,0);
break;
default :
VampirismMod.log.w(TAG,""String_Node_Str"",newLevel);
}
if (missing != null) {
ITextComponent item=missing.getItem().equals(ModItems.pureBlood) ? ModItems.pureBlood.getDisplayName(missing) : new TextComponentTranslation(missing.getUnlocalizedName() + ""String_Node_Str"");
ITextComponent main=new TextComponentTranslation(""String_Node_Str"",missing.stackSize,item);
player.addChatComponentMessage(main);
return false;
}
return true;
}"
12692,"public static boolean placeAt(World world,BlockPos pos,EnumFacing dir,boolean force,boolean spawner){
  int x=pos.getX();
  int y=pos.getY();
  int z=pos.getZ();
  int x1=x + (dir == EnumFacing.SOUTH ? 1 : (dir == EnumFacing.NORTH ? -1 : 0));
  int z1=z + (dir == EnumFacing.WEST ? 1 : (dir == EnumFacing.EAST ? -1 : 0));
  int x2=x + (dir == EnumFacing.WEST ? -1 : (dir == EnumFacing.NORTH ? -1 : 1));
  int z2=z + (dir == EnumFacing.SOUTH || dir == EnumFacing.WEST ? 1 : -1);
  int x3=x + (dir == EnumFacing.WEST ? -1 : (dir == EnumFacing.EAST ? 1 : 0));
  int z3=z + (dir == EnumFacing.SOUTH ? 1 : (dir == EnumFacing.NORTH ? -1 : 0));
  Block tent=ModBlocks.tent;
  Block main=ModBlocks.tentMain;
  if (force || canPlaceAt(tent,world,x,y,z) && canPlaceAt(tent,world,x1,y,z1) && canPlaceAt(tent,world,x2,y,z2)&& canPlaceAt(tent,world,x3,y,z3)) {
    boolean flag=world.setBlockState(pos,main.getDefaultState().withProperty(BlockTent.FACING,dir.getOpposite()),3);
    if (flag) {
      world.setBlockState(new BlockPos(x1,y,z1),tent.getDefaultState().withProperty(BlockTent.FACING,dir).withProperty(BlockTent.POSITION,1),3);
      world.setBlockState(new BlockPos(x2,y,z2),tent.getDefaultState().withProperty(BlockTent.FACING,dir).withProperty(BlockTent.POSITION,2),3);
      world.setBlockState(new BlockPos(x3,y,z3),tent.getDefaultState().withProperty(BlockTent.FACING,dir.getOpposite()).withProperty(BlockTent.POSITION,3),3);
      if (spawner)       ((TileTent)world.getTileEntity(pos)).setSpawn(true);
      return true;
    }
  }
  return false;
}","public static boolean placeAt(World world,BlockPos pos,EnumFacing dir,boolean force,boolean spawner){
  int x=pos.getX();
  int y=pos.getY();
  int z=pos.getZ();
  int x1=x + (dir == EnumFacing.SOUTH ? 1 : (dir == EnumFacing.NORTH ? -1 : 0));
  int z1=z + (dir == EnumFacing.WEST ? 1 : (dir == EnumFacing.EAST ? -1 : 0));
  int x2=x + (dir == EnumFacing.WEST ? -1 : (dir == EnumFacing.NORTH ? -1 : 1));
  int z2=z + (dir == EnumFacing.SOUTH || dir == EnumFacing.WEST ? 1 : -1);
  int x3=x + (dir == EnumFacing.WEST ? -1 : (dir == EnumFacing.EAST ? 1 : 0));
  int z3=z + (dir == EnumFacing.SOUTH ? 1 : (dir == EnumFacing.NORTH ? -1 : 0));
  Block tent=ModBlocks.tent;
  Block main=ModBlocks.tentMain;
  if (force || canPlaceAt(tent,world,x,y,z) && canPlaceAt(tent,world,x1,y,z1) && canPlaceAt(tent,world,x2,y,z2)&& canPlaceAt(tent,world,x3,y,z3)) {
    boolean flag=world.setBlockState(pos,main.getDefaultState().withProperty(BlockTent.FACING,dir.getOpposite()),3);
    if (flag) {
      world.setBlockState(new BlockPos(x1,y,z1),tent.getDefaultState().withProperty(BlockTent.FACING,dir).withProperty(BlockTent.POSITION,1),3);
      world.setBlockState(new BlockPos(x2,y,z2),tent.getDefaultState().withProperty(BlockTent.FACING,dir).withProperty(BlockTent.POSITION,2),3);
      world.setBlockState(new BlockPos(x3,y,z3),tent.getDefaultState().withProperty(BlockTent.FACING,dir.getOpposite()).withProperty(BlockTent.POSITION,3),3);
      if (spawner) {
        TileEntity tile=world.getTileEntity(pos);
        if (tile instanceof TileTent) {
          ((TileTent)tile).setSpawn(true);
        }
      }
      return true;
    }
  }
  return false;
}"
12693,"private boolean checkGroundAndPos(World worldIn,BlockPos position,IBlockState ground){
  if (worldIn.getBlockState(position).getMaterial().isLiquid())   return false;
  Material m=worldIn.getBlockState(position.down()).getMaterial();
  if (m.isLiquid())   return false;
  if (ground != null && m.isReplaceable()) {
    worldIn.setBlockState(position.down(),ground);
    return true;
  }
  return worldIn.isSideSolid(position.down(),EnumFacing.UP,false);
}","private boolean checkGroundAndPos(World worldIn,BlockPos position,IBlockState ground){
  if (worldIn.getBlockState(position).getMaterial().isLiquid())   return false;
  IBlockState b=worldIn.getBlockState(position.down());
  if (b.getMaterial().isLiquid() || b.getBlock() instanceof IFluidBlock)   return false;
  if (ground != null && b.getMaterial().isReplaceable()) {
    worldIn.setBlockState(position.down(),ground);
    return true;
  }
  return worldIn.isSideSolid(position.down(),EnumFacing.UP,false);
}"
12694,"private boolean placeTent(World worldIn,Random rand,BlockPos position,EnumFacing facing){
  IBlockState ground=worldIn.getBlockState(position.down());
  if (ground.getBlock().isSideSolid(ground,worldIn,position.down(),EnumFacing.UP)) {
    BlockPos tl=worldIn.getHeight(position.offset(facing).offset(facing.rotateYCCW()));
    BlockPos bl=worldIn.getHeight(position.offset(facing.rotateYCCW()));
    BlockPos tr=worldIn.getHeight(position.offset(facing));
    if (Math.abs(tl.getY() - position.getY()) < 2 && Math.abs(bl.getY() - position.getY()) < 2 && Math.abs(tr.getY() - position.getY()) < 2) {
      tl=new BlockPos(tl.getX(),position.getY(),tl.getZ());
      bl=new BlockPos(bl.getX(),position.getY(),bl.getZ());
      tr=new BlockPos(tr.getX(),position.getY(),tr.getZ());
      if (!checkGroundAndPos(worldIn,tl,ground))       return false;
      if (!checkGroundAndPos(worldIn,bl,ground))       return false;
      if (!checkGroundAndPos(worldIn,tr,ground))       return false;
      ItemTent.placeAt(worldIn,position,facing,true,true);
      BlockPos entrance1=position.offset(facing.getOpposite());
      BlockPos entrance2=position.offset(facing.getOpposite()).offset(facing.rotateYCCW());
      worldIn.setBlockToAir(entrance1);
      worldIn.setBlockToAir(entrance2);
      if (rand.nextInt(3) == 0) {
        this.setBlockAndNotifyAdequately(worldIn,worldIn.getHeight(entrance1.offset(facing.getOpposite())),Blocks.CRAFTING_TABLE.getDefaultState());
      }
      if (rand.nextInt(3) == 0) {
        this.setBlockAndNotifyAdequately(worldIn,worldIn.getHeight(entrance2.offset(facing.getOpposite())),Blocks.TORCH.getDefaultState());
      }
    }
    return true;
  }
  return false;
}","private boolean placeTent(World worldIn,Random rand,BlockPos position,EnumFacing facing){
  IBlockState ground=worldIn.getBlockState(position.down());
  if (ground.getBlock().isSideSolid(ground,worldIn,position.down(),EnumFacing.UP)) {
    BlockPos tl=worldIn.getHeight(position.offset(facing).offset(facing.rotateYCCW()));
    BlockPos bl=worldIn.getHeight(position.offset(facing.rotateYCCW()));
    BlockPos tr=worldIn.getHeight(position.offset(facing));
    if (Math.abs(tl.getY() - position.getY()) < 2 && Math.abs(bl.getY() - position.getY()) < 2 && Math.abs(tr.getY() - position.getY()) < 2) {
      tl=new BlockPos(tl.getX(),position.getY(),tl.getZ());
      bl=new BlockPos(bl.getX(),position.getY(),bl.getZ());
      tr=new BlockPos(tr.getX(),position.getY(),tr.getZ());
      if (!checkGroundAndPos(worldIn,tl,ground))       return false;
      if (!checkGroundAndPos(worldIn,bl,ground))       return false;
      if (!checkGroundAndPos(worldIn,tr,ground))       return false;
      ItemTent.placeAt(worldIn,position,facing,true,true);
      BlockPos entrance1=position.offset(facing.getOpposite());
      BlockPos entrance2=position.offset(facing.getOpposite()).offset(facing.rotateYCCW());
      worldIn.setBlockToAir(entrance1);
      worldIn.setBlockToAir(entrance2);
      if (rand.nextInt(3) == 0) {
        this.setBlockAndNotifyAdequately(worldIn,worldIn.getHeight(entrance1.offset(facing.getOpposite())),Blocks.CRAFTING_TABLE.getDefaultState());
      }
      if (rand.nextInt(3) == 0) {
        this.setBlockAndNotifyAdequately(worldIn,worldIn.getHeight(entrance2.offset(facing.getOpposite())),Blocks.TORCH.getDefaultState());
      }
      return true;
    }
  }
  return false;
}"
12695,"@Override public boolean onBlockActivated(World worldIn,BlockPos pos,IBlockState state,EntityPlayer playerIn,EnumHand hand,@Nullable ItemStack heldItem,EnumFacing side,float hitX,float hitY,float hitZ){
  if (canUse(playerIn))   playerIn.openGui(VampirismMod.instance,ModGuiHandler.ID_BLOOD_POTION_TABLE,worldIn,pos.getX(),pos.getY(),pos.getZ());
 else {
    playerIn.addChatComponentMessage(new TextComponentTranslation(""String_Node_Str"" + regName + ""String_Node_Str""));
  }
  return true;
}","@Override public boolean onBlockActivated(World worldIn,BlockPos pos,IBlockState state,EntityPlayer playerIn,EnumHand hand,@Nullable ItemStack heldItem,EnumFacing side,float hitX,float hitY,float hitZ){
  if (!worldIn.isRemote) {
    if (canUse(playerIn))     playerIn.openGui(VampirismMod.instance,ModGuiHandler.ID_BLOOD_POTION_TABLE,worldIn,pos.getX(),pos.getY(),pos.getZ());
 else {
      playerIn.addChatComponentMessage(new TextComponentTranslation(""String_Node_Str"" + regName + ""String_Node_Str""));
    }
  }
  return true;
}"
12696,"private static void preInit(FMLPreInitializationEvent event){
  thirst=register(new PotionThirst(""String_Node_Str"",true,859494));
  sanguinare=register(new PotionSanguinare(""String_Node_Str"",false,0x6A0888));
  saturation=register(new VampirismPotion(""String_Node_Str"",false,0xDCFF00));
  sunscreen=register(new VampirismPotion(""String_Node_Str"",false,0xFFF100));
  sunscreen.registerPotionAttributeModifier(VReference.sunDamage,""String_Node_Str"",-0.3,2);
  disguiseAsVampire=register(new VampirismPotion(""String_Node_Str"",false,0x999900));
}","private static void preInit(FMLPreInitializationEvent event){
  thirst=register(new PotionThirst(""String_Node_Str"",true,859494));
  fakeNightVisionPotion=register(new FakeNightVisionPotion());
  sanguinare=register(new PotionSanguinare(""String_Node_Str"",false,0x6A0888));
  saturation=register(new VampirismPotion(""String_Node_Str"",false,0xDCFF00));
  sunscreen=register(new VampirismPotion(""String_Node_Str"",false,0xFFF100));
  sunscreen.registerPotionAttributeModifier(VReference.sunDamage,""String_Node_Str"",-0.3,2);
  disguiseAsVampire=register(new VampirismPotion(""String_Node_Str"",false,0x999900));
}"
12697,"@SubscribeEvent public void onEntityUpdate(LivingEvent.LivingUpdateEvent event){
  if (event.getEntity() instanceof EntityCreature) {
    ExtendedCreature.get((EntityCreature)event.getEntity()).onUpdate();
  }
  if (!event.getEntity().worldObj.isRemote && event.getEntity() instanceof EntityPlayer) {
    EntityPlayer player=(EntityPlayer)event.getEntity();
    if (player.openContainer instanceof BloodPotionTableContainer) {
      ((BloodPotionTableContainer)player.openContainer).tick();
    }
  }
}","@SubscribeEvent public void onEntityUpdate(LivingEvent.LivingUpdateEvent event){
  if (event.getEntity() instanceof EntityCreature) {
    ExtendedCreature.get((EntityCreature)event.getEntity()).onUpdate();
  }
  if (!event.getEntity().worldObj.isRemote && event.getEntity() instanceof EntityPlayer) {
    EntityPlayer player=(EntityPlayer)event.getEntity();
    if (player.openContainer instanceof BloodPotionTableContainer) {
      ((BloodPotionTableContainer)player.openContainer).tick();
    }
  }
  PotionEffect vanillaNightVision=null;
  if (FakeNightVisionPotion.vanillaInstance != null && (vanillaNightVision=event.getEntityLiving().getActivePotionEffect(FakeNightVisionPotion.vanillaInstance)) != null) {
    event.getEntityLiving().removePotionEffect(FakeNightVisionPotion.vanillaInstance);
    event.getEntityLiving().addPotionEffect(new PotionEffect(ModPotions.fakeNightVisionPotion,vanillaNightVision.getDuration(),vanillaNightVision.getAmplifier(),vanillaNightVision.getIsAmbient(),vanillaNightVision.doesShowParticles()));
    VampirismMod.log.d(""String_Node_Str"",""String_Node_Str"");
  }
}"
12698,"/** 
 * Notify faction about changes.  {@link FactionPlayerHandler#currentFaction} and {@link FactionPlayerHandler#currentLevel} will be used as the new ones
 * @param oldFaction
 * @param oldLevel
 */
private void notifyFaction(IPlayableFaction oldFaction,int oldLevel){
  if (oldFaction != null && !oldFaction.equals(currentFaction)) {
    VampirismMod.log.d(TAG,""String_Node_Str"",oldFaction.getKey());
    oldFaction.getPlayerCapability(player).onLevelChanged(0,oldLevel);
  }
  if (currentFaction != null) {
    VampirismMod.log.d(TAG,""String_Node_Str"",currentFaction,currentLevel);
    currentFaction.getPlayerCapability(player).onLevelChanged(currentLevel,oldFaction == currentFaction ? oldLevel : 0);
  }
  if (!Objects.equals(currentFaction,oldFaction)) {
    onChangedFaction();
  }
}","/** 
 * Notify faction about changes.  {@link FactionPlayerHandler#currentFaction} and {@link FactionPlayerHandler#currentLevel} will be used as the new ones
 * @param oldFaction
 * @param oldLevel
 */
private void notifyFaction(IPlayableFaction oldFaction,int oldLevel){
  if (oldFaction != null && !oldFaction.equals(currentFaction)) {
    VampirismMod.log.d(TAG,""String_Node_Str"",oldFaction.getKey());
    oldFaction.getPlayerCapability(player).onLevelChanged(0,oldLevel);
  }
  if (currentFaction != null) {
    VampirismMod.log.d(TAG,""String_Node_Str"",currentFaction,currentLevel);
    currentFaction.getPlayerCapability(player).onLevelChanged(currentLevel,Objects.equals(oldFaction,currentFaction) ? oldLevel : 0);
  }
  if (!Objects.equals(currentFaction,oldFaction)) {
    onChangedFaction();
  }
}"
12699,"/** 
 * Called via a player living update event every tick serverside while the container is opened.
 */
public void tick(){
  if (craftingTimer > 0) {
    craftingTimer--;
    if (craftingTimer == 0) {
      onCraftingTimerFinished();
    }
  }
}","/** 
 * Called via a player living update event every tick serverside while the container is opened.
 */
public void tick(){
  if (craftingTimer > 0) {
    craftingTimer--;
    if (craftingTimer == 0) {
      onCraftingTimerFinished();
    }
 else     if (craftingTimer % 5 == 0) {
      if (!areRequirementsMet()) {
        craftingTimer=0;
      }
    }
  }
}"
12700,"public ItemBloodPotion(){
  super(regName);
  this.setMaxDamage(1);
  this.setCreativeTab(null);
}","public ItemBloodPotion(){
  super(regName);
  this.setMaxDamage(1);
  this.setMaxStackSize(1);
  this.setCreativeTab(null);
}"
12701,"@Override public void onLevelChanged(int old,int level){
  if (!isRemote()) {
    LevelAttributeModifier.applyModifier(player,SharedMonsterAttributes.ATTACK_DAMAGE,""String_Node_Str"",getLevel(),Balance.hp.STRENGTH_LCAP,Balance.hp.STRENGTH_MAX_MOD,Balance.hp.STRENGTH_TYPE);
    actionHandler.resetTimers();
    if (level > 0) {
      if (player instanceof EntityPlayerMP && ((EntityPlayerMP)player).connection != null) {
        player.addStat(Achievements.becomingAHunter,1);
      }
      if (old == 0) {
        skillHandler.enableRootSkill();
      }
    }
  }
}","@Override public void onLevelChanged(int level,int oldLevel){
  if (!isRemote()) {
    LevelAttributeModifier.applyModifier(player,SharedMonsterAttributes.ATTACK_DAMAGE,""String_Node_Str"",getLevel(),Balance.hp.STRENGTH_LCAP,Balance.hp.STRENGTH_MAX_MOD,Balance.hp.STRENGTH_TYPE);
    actionHandler.resetTimers();
    if (level > 0) {
      if (player instanceof EntityPlayerMP && ((EntityPlayerMP)player).connection != null) {
        player.addStat(Achievements.becomingAHunter,1);
      }
      if (oldLevel == 0) {
        skillHandler.enableRootSkill();
      }
    }
  }
}"
12702,"@Override public void onUpdate(){
  int level=getLevel();
  if (!isRemote()) {
    if (level > 0) {
      boolean sync=false;
      boolean syncToAll=false;
      NBTTagCompound syncPacket=new NBTTagCompound();
      if (actionHandler.updateActions()) {
        sync=true;
        syncToAll=true;
        actionHandler.writeUpdateForClient(syncPacket);
      }
      if (sync) {
        sync(syncPacket,syncToAll);
      }
    }
  }
 else {
    if (level > 0) {
      actionHandler.updateActions();
    }
  }
}","@Override public void onUpdate(){
  int level=getLevel();
  if (!isRemote()) {
    if (level > 0) {
      boolean sync=false;
      boolean syncToAll=false;
      NBTTagCompound syncPacket=new NBTTagCompound();
      if (actionHandler.updateActions()) {
        sync=true;
        syncToAll=true;
        actionHandler.writeUpdateForClient(syncPacket);
      }
      if (skillHandler.isDirty()) {
        sync=true;
        skillHandler.writeUpdateForClient(syncPacket);
      }
      if (sync) {
        sync(syncPacket,syncToAll);
      }
    }
  }
 else {
    if (level > 0) {
      actionHandler.updateActions();
    }
  }
}"
12703,"@Override public void onUpdate(IVampirePlayer player){
  if (player.getRepresentingPlayer().ticksExisted % 50 == 8 && player.getRepresentingPlayer().getActivePotionEffect(MobEffects.NIGHT_VISION) == null) {
    player.getRepresentingPlayer().addPotionEffect(new FakeNightVisionPotionEffect());
  }
}","@Override public void onUpdate(IVampirePlayer player){
  if (player.getRepresentingPlayer().ticksExisted % 50 == 8) {
    PotionEffect effect=player.getRepresentingPlayer().getActivePotionEffect(MobEffects.NIGHT_VISION);
    if (!(effect instanceof FakeNightVisionPotionEffect)) {
      player.getRepresentingPlayer().removeActivePotionEffect(MobEffects.NIGHT_VISION);
      effect=null;
    }
    if (effect == null) {
      player.getRepresentingPlayer().addPotionEffect(new FakeNightVisionPotionEffect());
    }
  }
}"
12704,"/** 
 * Replace the night vision potion in   {@link MobEffects} by the fake version.Checks if it is enabled in the configs first
 */
public static void replaceNightVision(){
  if (!Configs.disable_replaceVanillaNightVision) {
    VampirismMod.log.d(""String_Node_Str"",""String_Node_Str"",MobEffects.NIGHT_VISION.getClass());
    try {
      Field field=ReflectionHelper.findField(MobEffects.class,""String_Node_Str"",SRGNAMES.MobEffects_nightVision);
      field.setAccessible(true);
      Field modifierField=Field.class.getDeclaredField(""String_Node_Str"");
      modifierField.setAccessible(true);
      modifierField.setInt(field,field.getModifiers() & ~Modifier.FINAL);
      field.set(null,instance);
    }
 catch (    ReflectionHelper.UnableToFindFieldException e) {
      VampirismMod.log.e(""String_Node_Str"",e,""String_Node_Str"");
    }
catch (    IllegalAccessException e) {
      VampirismMod.log.e(""String_Node_Str"",e,""String_Node_Str"");
    }
catch (    NoSuchFieldException e) {
      VampirismMod.log.e(""String_Node_Str"",e,""String_Node_Str"");
    }
  }
}","/** 
 * Replace the night vision potion in   {@link MobEffects} by the fake version.Checks if it is enabled in the configs first
 */
public static void replaceNightVision(){
  if (!Configs.disable_replaceVanillaNightVision && !(MobEffects.NIGHT_VISION instanceof FakeNightVisionPotion)) {
    VampirismMod.log.d(""String_Node_Str"",""String_Node_Str"",MobEffects.NIGHT_VISION.getClass());
    try {
      vanillaInstance=MobEffects.NIGHT_VISION;
      Field field=ReflectionHelper.findField(MobEffects.class,""String_Node_Str"",SRGNAMES.MobEffects_nightVision);
      field.setAccessible(true);
      Field modifierField=Field.class.getDeclaredField(""String_Node_Str"");
      modifierField.setAccessible(true);
      modifierField.setInt(field,field.getModifiers() & ~Modifier.FINAL);
      field.set(null,ModPotions.fakeNightVisionPotion);
    }
 catch (    ReflectionHelper.UnableToFindFieldException e) {
      VampirismMod.log.e(""String_Node_Str"",e,""String_Node_Str"");
    }
catch (    IllegalAccessException e) {
      VampirismMod.log.e(""String_Node_Str"",e,""String_Node_Str"");
    }
catch (    NoSuchFieldException e) {
      VampirismMod.log.e(""String_Node_Str"",e,""String_Node_Str"");
    }
  }
}"
12705,"protected FakeNightVisionPotion(){
  super(false,2039713);
  setIconIndex(4,1);
  setPotionName(""String_Node_Str"");
}","public FakeNightVisionPotion(){
  super(false,2039713);
  setIconIndex(4,1);
  setPotionName(""String_Node_Str"");
  this.setRegistryName(REFERENCE.MODID,""String_Node_Str"");
}"
12706,"/** 
 * Adds a tooltip to the given blood potion itemstack
 */
public static void addTooltip(ItemStack stack,List<String> tooltip,IHunterPlayer player){
  ISkillHandler<IHunterPlayer> skillHandler=player.getSkillHandler();
  List<ConfiguredEffect> effects=stack.hasTagCompound() ? readEffectsFromNBT(stack.getTagCompound()) : Lists.<ConfiguredEffect>newArrayList();
  Random identifyRandom=null;
  if (skillHandler.isSkillEnabled(HunterSkills.bloodPotion_identifySome)) {
    NBTTagCompound nbt=stack.hasTagCompound() ? stack.getTagCompound() : new NBTTagCompound();
    int seed;
    if (nbt.hasKey(""String_Node_Str"")) {
      seed=nbt.getInteger(""String_Node_Str"");
    }
 else {
      seed=stack.hashCode();
      nbt.setInteger(""String_Node_Str"",seed);
      stack.setTagCompound(nbt);
    }
    identifyRandom=new Random(seed);
  }
  for (  ConfiguredEffect effect : effects) {
    String text;
    if (identifyRandom != null && identifyRandom.nextBoolean()) {
      text=effect.getEffect().getLocName(effect.properties);
    }
 else {
      text=UtilLib.translateToLocal(""String_Node_Str"");
    }
    if (skillHandler.isSkillEnabled(HunterSkills.bloodPotion_goodOrBad)) {
      if (effect.getEffect().isBad()) {
        text=TextFormatting.DARK_RED + text;
      }
 else {
        text=TextFormatting.DARK_GREEN + text;
      }
    }
    tooltip.add(text);
  }
}","/** 
 * Adds a tooltip to the given blood potion itemstack
 */
public static void addTooltip(ItemStack stack,List<String> tooltip,IHunterPlayer player){
  ISkillHandler<IHunterPlayer> skillHandler=player.getSkillHandler();
  List<ConfiguredEffect> effects=stack.hasTagCompound() ? readEffectsFromNBT(stack.getTagCompound()) : Lists.<ConfiguredEffect>newArrayList();
  Random identifyRandom=null;
  if (skillHandler.isSkillEnabled(HunterSkills.bloodPotion_identifySome)) {
    NBTTagCompound nbt=stack.hasTagCompound() ? stack.getTagCompound() : new NBTTagCompound();
    int seed;
    if (nbt.hasKey(""String_Node_Str"")) {
      seed=nbt.getInteger(""String_Node_Str"");
    }
 else {
      seed=stack.hashCode();
    }
    identifyRandom=new Random(seed);
  }
  for (  ConfiguredEffect effect : effects) {
    String text;
    if (identifyRandom != null && identifyRandom.nextBoolean()) {
      text=effect.getEffect().getLocName(effect.properties);
    }
 else {
      text=UtilLib.translateToLocal(""String_Node_Str"");
    }
    if (skillHandler.isSkillEnabled(HunterSkills.bloodPotion_goodOrBad)) {
      if (effect.getEffect().isBad()) {
        text=TextFormatting.DARK_RED + text;
      }
 else {
        text=TextFormatting.DARK_GREEN + text;
      }
    }
    tooltip.add(text);
  }
}"
12707,"/** 
 * Write the given effects to the potion stack's nbt
 */
private static void addEffects(ItemStack stack,List<ConfiguredEffect> effects){
  NBTTagCompound nbt=stack.hasTagCompound() ? stack.getTagCompound() : new NBTTagCompound();
  NBTTagCompound effectTag=new NBTTagCompound();
  for (  ConfiguredEffect effect : effects) {
    effectTag.setTag(effect.getEffect().getId(),effect.getProperties());
  }
  nbt.setTag(""String_Node_Str"",effectTag);
  stack.setTagCompound(nbt);
}","/** 
 * Write the given effects to the potion stack's nbt
 */
private static void addEffects(ItemStack stack,List<ConfiguredEffect> effects){
  NBTTagCompound nbt=stack.hasTagCompound() ? stack.getTagCompound() : new NBTTagCompound();
  NBTTagCompound effectTag=new NBTTagCompound();
  for (  ConfiguredEffect effect : effects) {
    effectTag.setTag(effect.getEffect().getId(),effect.getProperties());
  }
  nbt.setTag(""String_Node_Str"",effectTag);
  if (!nbt.hasKey(""String_Node_Str"")) {
    int seed=stack.hashCode();
    nbt.setInteger(""String_Node_Str"",seed);
  }
  stack.setTagCompound(nbt);
}"
12708,"/** 
 * Selects a random selection to the given potion stack considering the crafters hunter skills as well as the extra item
 */
public static void chooseAndAddEffects(@Nonnull ItemStack stack,@Nonnull IHunterPlayer crafter,@Nullable ItemStack extraItem){
  List<ConfiguredEffect> effects=Lists.newArrayList();
  IBloodPotionRegistry registry=VampirismAPI.bloodPotionRegistry();
  Random rnd=crafter.getRepresentingPlayer().getRNG();
  ISkillHandler<IHunterPlayer> skillHandler=crafter.getSkillHandler();
  int good=rnd.nextInt(2) + 1;
  if (rnd.nextInt(10) == 0)   good=3;
  int bad;
  int badReductions=0;
  if (skillHandler.isSkillEnabled(HunterSkills.bloodPotion_lessBad))   badReductions++;
  if (skillHandler.isSkillEnabled(HunterSkills.bloodPotion_lessBad2))   badReductions++;
  if (badReductions == 1) {
    bad=rnd.nextInt(10) == 0 ? 2 : 1;
  }
 else   if (badReductions == 2) {
    bad=rnd.nextInt(2);
  }
 else {
    bad=(rnd.nextInt(10) == 0) ? 3 : rnd.nextInt(2) + 1;
  }
  int extra=0;
  for (int i=0; i < good + bad + extra; i++) {
    IBloodPotionEffect effect=registry.getRandomEffect(extraItem,i >= good + extra,rnd);
    boolean valid=true;
    for (    ConfiguredEffect effect1 : effects) {
      if (!effect1.getEffect().canCoexist(effect)) {
        extra=Math.min(good + 1,5);
        valid=false;
      }
    }
    if (valid)     effects.add(new ConfiguredEffect(effect,effect.getRandomProperties(rnd)));
  }
  addEffects(stack,effects);
}","/** 
 * Selects a random selection to the given potion stack considering the crafters hunter skills as well as the extra item
 */
public static void chooseAndAddEffects(@Nonnull ItemStack stack,@Nonnull IHunterPlayer crafter,@Nullable ItemStack extraItem){
  List<ConfiguredEffect> effects=Lists.newArrayList();
  IBloodPotionRegistry registry=VampirismAPI.bloodPotionRegistry();
  Random rnd=crafter.getRepresentingPlayer().getRNG();
  ISkillHandler<IHunterPlayer> skillHandler=crafter.getSkillHandler();
  int good=rnd.nextInt(2) + 1;
  if (rnd.nextInt(10) == 0)   good=3;
  int bad;
  int badReductions=0;
  if (skillHandler.isSkillEnabled(HunterSkills.bloodPotion_lessBad))   badReductions++;
  if (skillHandler.isSkillEnabled(HunterSkills.bloodPotion_lessBad2))   badReductions++;
  if (badReductions == 1) {
    bad=rnd.nextInt(10) == 0 ? 2 : 1;
  }
 else   if (badReductions == 2) {
    bad=rnd.nextInt(2);
  }
 else {
    bad=(rnd.nextInt(10) == 0) ? 3 : rnd.nextInt(2) + 1;
  }
  int extra=0;
  for (int i=0; i < good + bad + extra; i++) {
    IBloodPotionEffect effect=registry.getRandomEffect(extraItem,i >= good + extra,rnd);
    boolean valid=true;
    for (    ConfiguredEffect effect1 : effects) {
      if (!effect1.getEffect().canCoexist(effect)) {
        extra=Math.min(extra + 1,5);
        valid=false;
      }
    }
    if (valid)     effects.add(new ConfiguredEffect(effect,effect.getRandomProperties(rnd)));
  }
  addEffects(stack,effects);
}"
12709,"/** 
 * Called when the entity is spawned in a castle as lord
 */
public void makeCastleLord(@NonNull CastlePositionData.Position pos){
  Logger.d(TAG,""String_Node_Str"");
  ChunkCoordIntPair lc=pos.getLowerMainCastle();
  ChunkCoordIntPair uc=pos.getUpperMainCastle();
  this.setHome(AxisAlignedBB.getBoundingBox(lc.chunkXPos << 4,pos.getHeight() - 1,lc.chunkZPos << 4,(uc.chunkXPos << 4) + 15,pos.getHeight() + 5,(uc.chunkZPos << 4) + 15));
}","/** 
 * Called when the entity is spawned in a castle as lord
 */
public void makeCastleLord(@NonNull CastlePositionData.Position pos){
  Logger.d(TAG,""String_Node_Str"");
  ChunkCoordIntPair lc=pos.getLowerMainCastle();
  ChunkCoordIntPair uc=pos.getUpperMainCastle();
  if (lc == null || uc == null) {
    Logger.w(TAG,""String_Node_Str"",pos);
    return;
  }
  this.setHome(AxisAlignedBB.getBoundingBox(lc.chunkXPos << 4,pos.getHeight() - 1,lc.chunkZPos << 4,(uc.chunkXPos << 4) + 15,pos.getHeight() + 5,(uc.chunkZPos << 4) + 15));
}"
12710,"/** 
 * Should be called for every biome. Generates and optimizes positions if they was not generated before. Also (pre) generates the castle stuff when the given chunk is within a position
 * @param world
 * @param chunkX
 * @param chunkZ
 * @param rnd
 * @param castleWorld Whether it is the castle dimension or the overworld
 */
public void checkBiome(World world,int chunkX,int chunkZ,Random rnd,boolean castleWorld){
  CastlePositionData data=CastlePositionData.get(world);
  if (!data.checked) {
    if (castleWorld) {
      CastlePositionData.Position p=new CastlePositionData.Position(0,0);
      p.setSize(6,6);
      p.setDraculasDim();
      p.setHeight(ChunkProviderCastle.MAX_Y_HEIGHT + 1);
      data.positions.add(p);
    }
 else {
      data.positions.addAll(this.findPositions(world,rnd));
      if (data.positions.size() > 0) {
        ListIterator<CastlePositionData.Position> iterator=data.positions.listIterator();
        while (iterator.hasNext()) {
          CastlePositionData.Position pos=iterator.next();
          CastlePositionData.Position pos2=this.optimizePosition(pos,world,rnd);
          if (pos2 == null) {
            Logger.d(TAG,""String_Node_Str"",pos);
            iterator.remove();
          }
 else           if (!pos2.equals(pos)) {
            pos=pos2;
            iterator.set(pos2);
          }
        }
      }
      if (data.positions.size() == 0) {
        Logger.w(TAG,""String_Node_Str"");
        if (world.provider.dimensionId == 0) {
          VampirismMod.vampireCastleFail=true;
        }
      }
    }
    data.checked=true;
    data.markDirty();
  }
  if (data.positions.size() == 0 && data.fullyGeneratedPositions.size() == 0) {
    if (world.getBiomeGenForCoords((chunkX << 4) + 8,(chunkZ << 4) + 8) instanceof BiomeVampireForest) {
      CastlePositionData.Position pos=new CastlePositionData.Position(chunkX,chunkZ);
      pos=this.optimizePosition(pos,world,rnd);
      if (pos != null) {
        data.positions.add(pos);
        data.markDirty();
        VampirismMod.vampireCastleFail=false;
        Logger.i(TAG,""String_Node_Str"");
      }
    }
  }
  if (data.positions.size() > 0) {
    for (    CastlePositionData.Position p : data.positions) {
      if (p.isChunkInPosition(chunkX,chunkZ)) {
        if (!p.hasTiles()) {
          preGeneratePosition(p,world);
          data.markDirty();
        }
        String s=p.getTileAt(chunkX - p.chunkXPos,chunkZ - p.chunkZPos);
        String[] param=s.split(""String_Node_Str"");
        int height=p.getHeight();
        if (height == -1) {
          height=getAverageHeight(world.getChunkFromChunkCoords(chunkX,chunkZ));
          p.setHeight(height);
        }
        for (int i=(chunkX << 4); i < (chunkX << 4) + 16; i++) {
          for (int j=(chunkZ << 4); j < (chunkZ << 4) + 16; j++) {
            for (int k=height; k < height + 20; k++) {
              world.setBlockToAir(i,k,j);
            }
          }
        }
        for (int i=(chunkX << 4); i < (chunkX << 4) + 16; i++) {
          for (int j=(chunkZ << 4); j < (chunkZ << 4) + 16; j++) {
            for (int k=height - 1; k > height - 10; k--) {
              world.setBlock(i,k,j,ModBlocks.cursedEarth);
            }
          }
        }
        for (int i=0; i < param.length; i+=2) {
          int rotation=Integer.parseInt(param[i]);
          BuildingTile tile=tileMap.get(param[i + 1]);
          if (tile != null) {
            tile.build(chunkX,chunkZ,world,height,rotation);
          }
        }
        p.markGenerated(chunkX,chunkZ);
        data.markDirty();
        break;
      }
    }
  }
}","/** 
 * Should be called for every biome. Generates and optimizes positions if they was not generated before. Also (pre) generates the castle stuff when the given chunk is within a position
 * @param world
 * @param chunkX
 * @param chunkZ
 * @param rnd
 * @param castleWorld Whether it is the castle dimension or the overworld
 */
public void checkBiome(World world,int chunkX,int chunkZ,Random rnd,boolean castleWorld){
  CastlePositionData data=CastlePositionData.get(world);
  if (!data.checked) {
    if (castleWorld) {
      CastlePositionData.Position p=new CastlePositionData.Position(0,0);
      p.setSize(6,6);
      p.setDraculasDim();
      p.setHeight(ChunkProviderCastle.MAX_Y_HEIGHT + 1);
      data.positions.add(p);
    }
 else {
      data.positions.addAll(this.findPositions(world,rnd));
      if (data.positions.size() > 0) {
        ListIterator<CastlePositionData.Position> iterator=data.positions.listIterator();
        while (iterator.hasNext()) {
          CastlePositionData.Position pos=iterator.next();
          CastlePositionData.Position pos2=this.optimizePosition(pos,world,rnd);
          if (pos2 == null) {
            Logger.d(TAG,""String_Node_Str"",pos);
            iterator.remove();
          }
 else           if (!pos2.equals(pos)) {
            pos=pos2;
            iterator.set(pos2);
          }
        }
      }
      if (data.positions.size() == 0) {
        Logger.w(TAG,""String_Node_Str"");
        if (world.provider.dimensionId == 0) {
          VampirismMod.vampireCastleFail=true;
        }
      }
    }
    data.checked=true;
    data.markDirty();
  }
  if (data.positions.size() == 0 && data.fullyGeneratedPositions.size() == 0) {
    if (world.getBiomeGenForCoords((chunkX << 4) + 8,(chunkZ << 4) + 8) instanceof BiomeVampireForest) {
      CastlePositionData.Position pos=new CastlePositionData.Position(chunkX,chunkZ);
      pos=this.optimizePosition(pos,world,rnd);
      if (pos != null) {
        data.positions.add(pos);
        data.markDirty();
        VampirismMod.vampireCastleFail=false;
        Logger.i(TAG,""String_Node_Str"");
      }
    }
  }
  if (data.positions.size() > 0) {
    for (    CastlePositionData.Position p : data.positions) {
      if (p.isChunkInPosition(chunkX,chunkZ)) {
        if (!p.hasTiles()) {
          preGeneratePosition(p,world);
          data.markDirty();
        }
        String s=p.getTileAt(chunkX - p.chunkXPos,chunkZ - p.chunkZPos);
        String[] param=s.split(""String_Node_Str"");
        int height=p.getHeight();
        if (height == -1) {
          height=getAverageHeight(world.getChunkFromChunkCoords(chunkX,chunkZ));
          p.setHeight(height);
        }
        for (int i=(chunkX << 4); i < (chunkX << 4) + 16; i++) {
          for (int j=(chunkZ << 4); j < (chunkZ << 4) + 16; j++) {
            for (int k=height; k < height + 20; k++) {
              world.setBlockToAir(i,k,j);
            }
          }
        }
        for (int i=(chunkX << 4); i < (chunkX << 4) + 16; i++) {
          for (int j=(chunkZ << 4); j < (chunkZ << 4) + 16; j++) {
            for (int k=height - 1; k > height - 10; k--) {
              world.setBlock(i,k,j,ModBlocks.cursedEarth);
            }
          }
        }
        for (int i=0; i < param.length; i+=2) {
          int rotation=Integer.parseInt(param[i]);
          BuildingTile tile=tileMap.get(param[i + 1]);
          if (tile != null) {
            tile.build(chunkX,chunkZ,world,height,rotation);
          }
 else {
            Logger.w(TAG,""String_Node_Str"",param[i + 1]);
          }
        }
        p.markGenerated(chunkX,chunkZ);
        data.markDirty();
        break;
      }
    }
  }
}"
12711,"/** 
 * Loads all tiles from the jar
 */
public static void loadTiles(){
  Gson gson=new GsonBuilder().setPrettyPrinting().registerTypeAdapterFactory(ModdedEnumTypeAdapter.ENUM_FACTORY).create();
  tileMap=new HashMap<String,BuildingTile>();
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
}","/** 
 * Loads all tiles from the jar
 */
public static void loadTiles(){
  Gson gson=new GsonBuilder().setPrettyPrinting().registerTypeAdapterFactory(ModdedEnumTypeAdapter.ENUM_FACTORY).create();
  tileMap=new HashMap<String,BuildingTile>();
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
  loadTile(""String_Node_Str"",gson,tileMap);
}"
12712,"@SubscribeEvent public void onEntityJoinWorld(EntityJoinWorldEvent event){
  if (event.entity instanceof EntityPlayer) {
    if (event.entity.worldObj.isRemote) {
      VampirismMod.modChannel.sendToServer(new RequestEntityUpdatePacket(event.entity));
    }
 else {
      VampirePlayer.onPlayerJoinWorld((EntityPlayer)event.entity);
    }
  }
}","@SubscribeEvent public void onEntityJoinWorld(EntityJoinWorldEvent event){
  if (event.entity instanceof EntityPlayer) {
    if (event.entity.worldObj.isRemote || event.entity instanceof EntityClientPlayerMP) {
      VampirismMod.modChannel.sendToServer(new RequestEntityUpdatePacket(event.entity));
    }
 else {
      VampirePlayer.onPlayerJoinWorld((EntityPlayer)event.entity);
    }
  }
}"
12713,"@SubscribeEvent public void onLivingUpdate(LivingUpdateEvent event){
  if (event.entity instanceof EntityPlayer) {
    VampirePlayer.get((EntityPlayer)event.entity).onUpdate();
    ;
  }
}","@SubscribeEvent public void onLivingUpdate(LivingUpdateEvent event){
  if (event.entity instanceof EntityPlayer) {
    VampirePlayer.get((EntityPlayer)event.entity).onUpdate();
  }
}"
12714,"@Override public void onLivingUpdate(){
  this.isJumping=false;
  if (this.entityToAttack != null) {
    if (this.rand.nextInt(300) == 0) {
      this.faceEntity(this.entityToAttack,100.0F,100.0F);
    }
  }
  if (!this.worldObj.isRemote && this.isEntityAlive()) {
    if (disappearDelay > 0) {
      if (--disappearDelay == 1) {
        this.teleportAway();
      }
    }
    if (this.isInWater() || this.handleLavaMovement()) {
      this.teleportRandomly();
    }
    if (this.ticksExisted % 60 == 0) {
      if (damageCounter > 30) {
        if (this.teleportRandomly()) {
          damageCounter=0;
        }
 else {
        }
      }
 else {
        damageCounter=0;
      }
    }
    if (this.entityToAttack != null) {
      if (this.entityToAttack instanceof EntityPlayer) {
        if (getMinionHandler().getMinionCount() < 4 && rand.nextInt(80) == 0) {
          EntitySaveableVampireMinion entity=(EntitySaveableVampireMinion)Helper.spawnEntityBehindEntity((EntityLivingBase)this.entityToAttack,REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME);
          if (entity != null) {
            entity.setLord(this);
            entity.addPotionEffect(new PotionEffect(Potion.damageBoost.id,20000,2));
            minionInHomeDist(entity);
          }
        }
      }
    }
    if (this.ticksExisted % 100 == 0 && this.hasHome() && this.getMinionHandler().getMinionCount() < 1) {
      EntityVampireMinion minion=(EntityVampireMinion)Helper.spawnEntityInWorld(worldObj,castle,REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME,3);
      if (minion != null) {
        minion.setLord(this);
        minion.addPotionEffect(new PotionEffect(Potion.resistance.id,20000,3));
      }
    }
  }
  if (this.getHealth() > DraculaAIHeal.THRESHOLD * 2 && BALANCE.MOBPROP.DRACULA_REGENERATE_SECS >= 0 && this.ticksExisted % (BALANCE.MOBPROP.DRACULA_REGENERATE_SECS * 20) == 0 && (this.getLastAttackerTime() == 0 || this.getLastAttackerTime() - ticksExisted > 100)) {
    this.heal(5F);
  }
  super.onLivingUpdate();
  BossStatus.setBossStatus(this,true);
}","@Override public void onLivingUpdate(){
  this.isJumping=false;
  if (this.entityToAttack != null) {
    if (this.rand.nextInt(300) == 0) {
      this.faceEntity(this.entityToAttack,100.0F,100.0F);
    }
  }
  if (!this.worldObj.isRemote && this.isEntityAlive()) {
    if (disappearDelay > 0) {
      if (--disappearDelay == 1) {
        this.teleportAway();
      }
    }
    if (teleportDelay > 0) {
      teleportDelay--;
    }
    if (this.isInWater() || this.handleLavaMovement()) {
      this.teleportRandomly();
    }
    if (this.ticksExisted % 60 == 0) {
      if (damageCounter > 30) {
        if (this.teleportRandomly()) {
          damageCounter=0;
        }
 else {
        }
      }
 else {
        damageCounter=0;
      }
    }
    if (this.entityToAttack != null) {
      if (this.entityToAttack instanceof EntityPlayer) {
        if (getMinionHandler().getMinionCount() < 4 && rand.nextInt(80) == 0) {
          EntitySaveableVampireMinion entity=(EntitySaveableVampireMinion)Helper.spawnEntityBehindEntity((EntityLivingBase)this.entityToAttack,REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME);
          if (entity != null) {
            entity.setLord(this);
            entity.addPotionEffect(new PotionEffect(Potion.damageBoost.id,20000,2));
            minionInHomeDist(entity);
          }
        }
      }
    }
    if (this.ticksExisted % 100 == 0 && this.hasHome() && this.getMinionHandler().getMinionCount() < 1) {
      EntityVampireMinion minion=(EntityVampireMinion)Helper.spawnEntityInWorld(worldObj,castle,REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME,3);
      if (minion != null) {
        minion.setLord(this);
        minion.addPotionEffect(new PotionEffect(Potion.resistance.id,20000,3));
      }
    }
  }
  if (this.getHealth() > DraculaAIHeal.THRESHOLD * 2 && BALANCE.MOBPROP.DRACULA_REGENERATE_SECS >= 0 && this.ticksExisted % (BALANCE.MOBPROP.DRACULA_REGENERATE_SECS * 20) == 0 && (this.getLastAttackerTime() == 0 || this.getLastAttackerTime() - ticksExisted > 100)) {
    this.heal(5F);
  }
  super.onLivingUpdate();
  BossStatus.setBossStatus(this,true);
}"
12715,"/** 
 * Teleports dracula randomly 
 */
private boolean teleportRandomly(){
  double d0=this.posX + (this.rand.nextDouble() - 0.5D) * maxTeleportDistanceX;
  double d1=this.posY + (this.rand.nextInt((int)(maxTeleportDistanceY * 1.5)) - maxTeleportDistanceY * 0.5D);
  double d2=this.posZ + (this.rand.nextDouble() - 0.5D) * maxTeleportDistanceZ;
  if (this.isWithinHomeDistance(MathHelper.floor_double(d0),MathHelper.floor_double(d1),MathHelper.floor_double(d2))) {
    if (Helper.teleportTo(this,d0,d1,d2,true)) {
      if (rand.nextInt(10) == 0) {
        this.addPotionEffect(new PotionEffect(Potion.invisibility.id,60));
        this.addPotionEffect(new PotionEffect(Potion.regeneration.id,60,2));
        this.addPotionEffect(new PotionEffect(Potion.moveSlowdown.id,60,2));
        summonBats();
      }
      return true;
    }
  }
  if (rand.nextBoolean()) {
    this.teleportRandomly();
  }
  return false;
}","/** 
 * Teleports dracula randomly 
 */
private boolean teleportRandomly(){
  if (teleportDelay > 0)   return false;
  double d0=this.posX + (this.rand.nextDouble() - 0.5D) * maxTeleportDistanceX;
  double d1=this.posY + (this.rand.nextInt((int)(maxTeleportDistanceY * 1.5)) - maxTeleportDistanceY * 0.5D);
  double d2=this.posZ + (this.rand.nextDouble() - 0.5D) * maxTeleportDistanceZ;
  if (this.isWithinHomeDistance(MathHelper.floor_double(d0),MathHelper.floor_double(d1),MathHelper.floor_double(d2))) {
    if (Helper.teleportTo(this,d0,d1,d2,true)) {
      if (rand.nextInt(10) == 0) {
        this.addPotionEffect(new PotionEffect(Potion.invisibility.id,60));
        this.addPotionEffect(new PotionEffect(Potion.regeneration.id,60,2));
        this.addPotionEffect(new PotionEffect(Potion.moveSlowdown.id,60,2));
        summonBats();
      }
      teleportDelay=TELEPORT_DELAY;
      return true;
    }
  }
  if (rand.nextBoolean()) {
    this.teleportRandomly();
  }
  return false;
}"
12716,"@Override public void onDeath(DamageSource s){
  if (this.recentlyHit > 0 && this.worldObj.getGameRules().getGameRuleBooleanValue(""String_Node_Str"")) {
    if (level > 0 && level < 6) {
      this.entityDropItem(new ItemStack(ModItems.pureBlood,1,level - 1),0.3F);
    }
 else     if (level > 5) {
      this.entityDropItem(new ItemStack(ModItems.pureBlood,1,4),0.3F);
    }
  }
}","@Override public void onDeath(DamageSource s){
  super.onDeath(s);
  if (this.recentlyHit > 0 && this.worldObj.getGameRules().getGameRuleBooleanValue(""String_Node_Str"")) {
    if (level > 0 && level < 6) {
      this.entityDropItem(new ItemStack(ModItems.pureBlood,1,level - 1),0.3F);
    }
 else     if (level > 5) {
      this.entityDropItem(new ItemStack(ModItems.pureBlood,1,4),0.3F);
    }
  }
}"
12717,"@Override public void onKillEntity(EntityLivingBase entity){
  super.onKillEntity(entity);
  if (entity instanceof EntityPlayer) {
    if (this.getLord() != null && this.getLord() instanceof EntityDracula) {
      ((EntityDracula)this.getLord()).restoreOnPlayerKill((EntityPlayer)entity);
    }
  }
}","@Override public void onKillEntity(EntityLivingBase entity){
  super.onKillEntity(entity);
  if (entity instanceof EntityPlayer) {
    if (this.getLord() != null && this.getLord() instanceof EntityDracula) {
      ((EntityDracula)this.getLord()).restoreOnPlayerKill((EntityPlayer)entity);
    }
  }
 else {
    if (this.getLord() != null && this.getLord() instanceof EntityVampireBaron) {
      ((EntityVampireBaron)this.getLord()).onKillEntity(entity);
    }
  }
}"
12718,"@Override public boolean canBeUsedBy(VampirePlayer vampire,EntityPlayer player){
  return !vampire.isSkillActive(Skills.batMode) && !vampire.isVampireLord();
}","@Override public boolean canBeUsedBy(VampirePlayer vampire,EntityPlayer player){
  return !vampire.isSkillActive(Skills.batMode);
}"
12719,"/** 
 * Generates entities
 * @param world World
 * @param random Random
 * @param x xCoord
 * @param z ZCoord
 */
private void addEntities(World world,Random random,int x,int z){
  try {
    int y=world.getHeightValue(x,z);
    Village v=world.villageCollectionObj.findNearestVillage(x,y,z,0);
    if (v == null) {
      return;
    }
    VillageVampire vv=VillageVampireData.get(world).getVillageVampire(v);
    if (vv == null)     return;
    int spawnedHunter=world.getEntitiesWithinAABB(EntityVampireHunter.class,vv.getBoundingBox()).size();
    for (    Entity e : Helper.spawnEntityInVillage(v,random.nextInt(3) - spawnedHunter,REFERENCE.ENTITY.VAMPIRE_HUNTER_NAME,world)) {
      ((EntityVampireHunter)e).setHomeArea(v.getCenter().posX,v.getCenter().posY,v.getCenter().posZ,v.getVillageRadius());
    }
  }
 catch (  Exception e) {
    return;
  }
}","/** 
 * Generates entities
 * @param world World
 * @param random Random
 * @param x xCoord
 * @param z ZCoord
 */
private void addEntities(World world,Random random,int x,int z){
  if (world.provider.terrainType == WorldType.FLAT)   return;
  try {
    int y=world.getHeightValue(x,z);
    Village v=world.villageCollectionObj.findNearestVillage(x,y,z,0);
    if (v == null) {
      return;
    }
    VillageVampire vv=VillageVampireData.get(world).getVillageVampire(v);
    if (vv == null)     return;
    int spawnedHunter=world.getEntitiesWithinAABB(EntityVampireHunter.class,vv.getBoundingBox()).size();
    for (    Entity e : Helper.spawnEntityInVillage(v,random.nextInt(3) - spawnedHunter,REFERENCE.ENTITY.VAMPIRE_HUNTER_NAME,world)) {
      ((EntityVampireHunter)e).setHomeArea(v.getCenter().posX,v.getCenter().posY,v.getCenter().posZ,v.getVillageRadius());
    }
  }
 catch (  Exception e) {
    return;
  }
}"
12720,"@Override public void registerEntitys(){
  BiomeGenBase[] allBiomes=BiomeGenBase.getBiomeGenArray();
  allBiomes=allBiomes.clone();
  allBiomes[9]=null;
  allBiomes[8]=null;
  BiomeGenBase[] allBiomesNoVampire=allBiomes.clone();
  int vId=ModBiomes.biomeVampireForest.biomeID;
  if (vId > 0 && vId < allBiomes.length) {
    allBiomesNoVampire[vId]=null;
  }
  BiomeGenBase[] biomes=Iterators.toArray(Iterators.filter(Iterators.forArray(allBiomes),Predicates.notNull()),BiomeGenBase.class);
  allBiomesNoVampire=Iterators.toArray(Iterators.filter(Iterators.forArray(allBiomesNoVampire),Predicates.notNull()),BiomeGenBase.class);
  registerEntity(EntityVampireHunter.class,REFERENCE.ENTITY.VAMPIRE_HUNTER_NAME,BALANCE.VAMPIRE_HUNTER_SPAWN_PROBE,1,2,EnumCreatureType.creature,allBiomesNoVampire);
  registerEntity(EntityVampire.class,REFERENCE.ENTITY.VAMPIRE_NAME,BALANCE.VAMPIRE_SPAWN_PROBE,1,3,EnumCreatureType.monster,allBiomesNoVampire);
  registerEntity(EntityVampireBaron.class,REFERENCE.ENTITY.VAMPIRE_BARON,true);
  EntityList.stringToClassMapping.put(""String_Node_Str"",EntityVampireBaron.class);
  registerEntity(EntitySaveableVampireMinion.class,REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME,false);
  registerEntity(EntityRemoteVampireMinion.class,REFERENCE.ENTITY.VAMPIRE_MINION_REMOTE_NAME,false);
  registerEntity(EntityDeadMob.class,REFERENCE.ENTITY.DEAD_MOB_NAME,false);
  registerEntity(EntityDracula.class,REFERENCE.ENTITY.DRACULA_NAME,false);
  registerEntity(EntityGhost.class,REFERENCE.ENTITY.GHOST_NAME,true);
  registerEntity(EntityBlindingBat.class,REFERENCE.ENTITY.BLINDING_BAT_NAME,false);
  registerEntity(EntityDummyBittenAnimal.class,REFERENCE.ENTITY.DUMMY_CREATURE,false);
  registerEntity(EntityPortalGuard.class,REFERENCE.ENTITY.PORTAL_GUARD,true);
  Item item=new ItemSpawnEgg(spawnableEntityNames);
  GameRegistry.registerItem(item,ItemSpawnEgg.name);
  OreDictionary.registerOre(""String_Node_Str"",item);
}","@Override public void registerEntitys(){
  BiomeGenBase[] allBiomes=BiomeGenBase.getBiomeGenArray();
  allBiomes=Arrays.copyOf(allBiomes,allBiomes.length);
  allBiomes[9]=null;
  allBiomes[8]=null;
  BiomeGenBase[] allBiomesNoVampire=Arrays.copyOf(allBiomes,allBiomes.length);
  int vId=ModBiomes.biomeVampireForest.biomeID;
  if (vId > 0 && vId < allBiomes.length) {
    allBiomesNoVampire[vId]=null;
  }
  BiomeGenBase[] biomes=Iterators.toArray(Iterators.filter(Iterators.forArray(allBiomes),Predicates.notNull()),BiomeGenBase.class);
  allBiomesNoVampire=Iterators.toArray(Iterators.filter(Iterators.forArray(allBiomesNoVampire),Predicates.notNull()),BiomeGenBase.class);
  Logger.t(ArrayUtils.toString(allBiomesNoVampire));
  registerEntity(EntityVampireHunter.class,REFERENCE.ENTITY.VAMPIRE_HUNTER_NAME,BALANCE.VAMPIRE_HUNTER_SPAWN_PROBE,1,2,EnumCreatureType.monster,allBiomesNoVampire);
  registerEntity(EntityVampire.class,REFERENCE.ENTITY.VAMPIRE_NAME,BALANCE.VAMPIRE_SPAWN_PROBE,1,3,EnumCreatureType.monster,allBiomesNoVampire);
  registerEntity(EntityVampireBaron.class,REFERENCE.ENTITY.VAMPIRE_BARON,true);
  EntityList.stringToClassMapping.put(""String_Node_Str"",EntityVampireBaron.class);
  registerEntity(EntitySaveableVampireMinion.class,REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME,false);
  registerEntity(EntityRemoteVampireMinion.class,REFERENCE.ENTITY.VAMPIRE_MINION_REMOTE_NAME,false);
  registerEntity(EntityDeadMob.class,REFERENCE.ENTITY.DEAD_MOB_NAME,false);
  registerEntity(EntityDracula.class,REFERENCE.ENTITY.DRACULA_NAME,false);
  registerEntity(EntityGhost.class,REFERENCE.ENTITY.GHOST_NAME,true);
  registerEntity(EntityBlindingBat.class,REFERENCE.ENTITY.BLINDING_BAT_NAME,false);
  registerEntity(EntityDummyBittenAnimal.class,REFERENCE.ENTITY.DUMMY_CREATURE,false);
  registerEntity(EntityPortalGuard.class,REFERENCE.ENTITY.PORTAL_GUARD,true);
  Item item=new ItemSpawnEgg(spawnableEntityNames);
  GameRegistry.registerItem(item,ItemSpawnEgg.name);
  OreDictionary.registerOre(""String_Node_Str"",item);
}"
12721,"public TestCommand(){
  aliases.add(""String_Node_Str"");
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      vampire.setLevel(REFERENCE.HIGHEST_REACHABLE_LEVEL);
      VampireLordData.get(player.worldObj).makeLord(player);
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      if (player instanceof EntityPlayerMP) {
        if (player.dimension != VampirismMod.castleDimensionId) {
          ((EntityPlayerMP)player).mcServer.getConfigurationManager().transferPlayerToDimension(((EntityPlayerMP)player),VampirismMod.castleDimensionId,new TeleporterCastle(MinecraftServer.getServer().worldServerForDimension(VampirismMod.castleDimensionId)));
        }
        return;
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      if (param.length < 1)       return;
      int id=Integer.parseInt(param[0]);
      int amount=10;
      if (param.length > 1) {
        amount=Integer.parseInt(param[1]);
      }
      NBTTagCompound nbt=new NBTTagCompound();
      nbt.setInteger(""String_Node_Str"",player.getEntityId());
      IMessage m=new SpawnCustomParticlePacket(id,player.posX,player.posY,player.posZ,amount,nbt);
      VampirismMod.modChannel.sendToAll(m);
      return;
    }
    @Override public String getCommandUsage(    ICommandSender var1){
      return this.getCommandName() + ""String_Node_Str"";
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      List l=player.worldObj.getEntitiesWithinAABBExcludingEntity(player,player.boundingBox.expand(3,2,3));
      for (      Object o : l) {
        if (o instanceof EntityCreature) {
          sendMessage(sender,o.getClass().getName());
        }
 else {
          sendMessage(sender,""String_Node_Str"" + o.getClass().getName());
        }
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      List l=player.worldObj.getEntitiesWithinAABBExcludingEntity(player,player.boundingBox.expand(6,6,6));
      for (      Object o : l) {
        if (o instanceof EntityDracula) {
          sendMessage(sender,o.toString());
        }
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      MovingObjectPosition pos=Helper.getPlayerLookingSpot(player,0);
      if (pos != null && MovingObjectPosition.MovingObjectType.BLOCK.equals(pos.typeOfHit)) {
        sendMessage(sender,""String_Node_Str"" + player.worldObj.getBlock(pos.blockX,pos.blockY,pos.blockZ) + ""String_Node_Str""+ player.worldObj.getBlockMetadata(pos.blockX,pos.blockY,pos.blockZ));
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      MovingObjectPosition pos=Helper.getPlayerLookingSpot(player,0);
      if (pos != null && MovingObjectPosition.MovingObjectType.BLOCK.equals(pos.typeOfHit)) {
        Block b=player.worldObj.getBlock(pos.blockX,pos.blockY,pos.blockZ);
        if (b instanceof BlockBloodAltar1) {
          TileEntityBloodAltar1 altar1=(TileEntityBloodAltar1)player.worldObj.getTileEntity(pos.blockX,pos.blockY,pos.blockZ);
          altar1.makeInfinite();
        }
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      MovingObjectPosition pos=Helper.getPlayerLookingSpot(player,0);
      if (pos != null && MovingObjectPosition.MovingObjectType.BLOCK.equals(pos.typeOfHit)) {
        Block b=player.worldObj.getBlock(pos.blockX,pos.blockY,pos.blockZ);
        if (b instanceof BlockCoffin) {
          ((BlockCoffin)b).setCoffinOccupied(player.worldObj,pos.blockX,pos.blockY,pos.blockZ,null,true);
          TileEntity t=player.worldObj.getTileEntity(pos.blockX,pos.blockY,pos.blockZ);
          t.markDirty();
        }
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
}","public TestCommand(){
  aliases.add(""String_Node_Str"");
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      vampire.setLevel(REFERENCE.HIGHEST_REACHABLE_LEVEL);
      VampireLordData.get(player.worldObj).makeLord(player);
      MinecraftServer.getServer().getConfigurationManager().sendChatMsg(new ChatComponentText(sender.getCommandSenderName() + ""String_Node_Str""));
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      if (player instanceof EntityPlayerMP) {
        if (player.dimension != VampirismMod.castleDimensionId) {
          ((EntityPlayerMP)player).mcServer.getConfigurationManager().transferPlayerToDimension(((EntityPlayerMP)player),VampirismMod.castleDimensionId,new TeleporterCastle(MinecraftServer.getServer().worldServerForDimension(VampirismMod.castleDimensionId)));
        }
        return;
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      if (param.length < 1)       return;
      int id=Integer.parseInt(param[0]);
      int amount=10;
      if (param.length > 1) {
        amount=Integer.parseInt(param[1]);
      }
      NBTTagCompound nbt=new NBTTagCompound();
      nbt.setInteger(""String_Node_Str"",player.getEntityId());
      IMessage m=new SpawnCustomParticlePacket(id,player.posX,player.posY,player.posZ,amount,nbt);
      VampirismMod.modChannel.sendToAll(m);
      return;
    }
    @Override public String getCommandUsage(    ICommandSender var1){
      return this.getCommandName() + ""String_Node_Str"";
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      List l=player.worldObj.getEntitiesWithinAABBExcludingEntity(player,player.boundingBox.expand(3,2,3));
      for (      Object o : l) {
        if (o instanceof EntityCreature) {
          sendMessage(sender,o.getClass().getName());
        }
 else {
          sendMessage(sender,""String_Node_Str"" + o.getClass().getName());
        }
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      List l=player.worldObj.getEntitiesWithinAABBExcludingEntity(player,player.boundingBox.expand(3,2,3));
      for (      Object o : l) {
        if (o instanceof EntityLivingBase) {
          boolean flag=Helper.canReallySee((EntityLivingBase)o,player,false);
          sendMessage(sender,""String_Node_Str"" + flag);
          return;
        }
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      List l=player.worldObj.getEntitiesWithinAABBExcludingEntity(player,player.boundingBox.expand(6,6,6));
      for (      Object o : l) {
        if (o instanceof EntityDracula) {
          sendMessage(sender,o.toString());
        }
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      MovingObjectPosition pos=Helper.getPlayerLookingSpot(player,0);
      if (pos != null && MovingObjectPosition.MovingObjectType.BLOCK.equals(pos.typeOfHit)) {
        sendMessage(sender,""String_Node_Str"" + player.worldObj.getBlock(pos.blockX,pos.blockY,pos.blockZ) + ""String_Node_Str""+ player.worldObj.getBlockMetadata(pos.blockX,pos.blockY,pos.blockZ));
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      MovingObjectPosition pos=Helper.getPlayerLookingSpot(player,0);
      if (pos != null && MovingObjectPosition.MovingObjectType.BLOCK.equals(pos.typeOfHit)) {
        Block b=player.worldObj.getBlock(pos.blockX,pos.blockY,pos.blockZ);
        if (b instanceof BlockBloodAltar1) {
          TileEntityBloodAltar1 altar1=(TileEntityBloodAltar1)player.worldObj.getTileEntity(pos.blockX,pos.blockY,pos.blockZ);
          altar1.makeInfinite();
        }
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
  addSub(new TestSubCommand(){
    @Override protected void processCommand(    ICommandSender sender,    EntityPlayer player,    VampirePlayer vampire,    String[] param){
      MovingObjectPosition pos=Helper.getPlayerLookingSpot(player,0);
      if (pos != null && MovingObjectPosition.MovingObjectType.BLOCK.equals(pos.typeOfHit)) {
        Block b=player.worldObj.getBlock(pos.blockX,pos.blockY,pos.blockZ);
        if (b instanceof BlockCoffin) {
          ((BlockCoffin)b).setCoffinOccupied(player.worldObj,pos.blockX,pos.blockY,pos.blockZ,null,true);
          TileEntity t=player.worldObj.getTileEntity(pos.blockX,pos.blockY,pos.blockZ);
          t.markDirty();
        }
      }
    }
    @Override public String getCommandName(){
      return ""String_Node_Str"";
    }
  }
);
}"
12722,"@Override public void processCommand(ICommandSender sender,String[] param){
  if (param != null && param.length == 1 && sender instanceof EntityPlayer) {
    try {
      VampirePlayer.get((EntityPlayer)sender).setLevel(Integer.parseInt(param[0]));
      return;
    }
 catch (    NumberFormatException e) {
    }
  }
  super.processCommand(sender,param);
}","@Override public void processCommand(ICommandSender sender,String[] param){
  if (param != null && param.length == 1 && sender instanceof EntityPlayer) {
    try {
      VampirePlayer.get((EntityPlayer)sender).setLevel(Integer.parseInt(param[0]));
      MinecraftServer.getServer().getConfigurationManager().sendChatMsg(new ChatComponentText(sender.getCommandSenderName() + ""String_Node_Str"" + VampirePlayer.get((EntityPlayer)sender).getLevel()));
      return;
    }
 catch (    NumberFormatException e) {
    }
  }
  super.processCommand(sender,param);
}"
12723,"@SuppressWarnings(""String_Node_Str"") public BiomeVampireForest(int id){
  super(id);
  this.spawnableCreatureList.clear();
  this.spawnableMonsterList.clear();
  this.spawnableWaterCreatureList.clear();
  this.spawnableMonsterList.add(new SpawnListEntry(EntityGhost.class,10,3,5));
  this.spawnableMonsterList.add(new SpawnListEntry(EntityVampireBaron.class,1,1,1));
  this.spawnableMonsterList.add(new SpawnListEntry(EntityBlindingBat.class,1,4,8));
  this.spawnableMonsterList.add(new SpawnListEntry(EntityVampire.class,10,2,4));
  this.spawnableCreatureList.add(new BiomeGenBase.SpawnListEntry(EntityDummyBittenAnimal.class,10,2,4));
  this.topBlock=ModBlocks.cursedEarth;
  this.fillerBlock=ModBlocks.cursedEarth;
  this.theBiomeDecorator.treesPerChunk=5;
  this.theBiomeDecorator.grassPerChunk=4;
  this.theBiomeDecorator.deadBushPerChunk=4;
  this.worldGeneratorTrees=new WorldGenTrees(false,4,1,0,false);
  this.flowers.clear();
  this.addFlower(ModBlocks.vampireFlower,1,10);
  this.canSpawnLightningBolt();
  this.waterColorMultiplier=0xFF2505;
}","@SuppressWarnings(""String_Node_Str"") public BiomeVampireForest(int id){
  super(id);
  this.spawnableCreatureList.clear();
  this.spawnableMonsterList.clear();
  this.spawnableWaterCreatureList.clear();
  this.spawnableMonsterList.add(new SpawnListEntry(EntityGhost.class,10,2,3));
  this.spawnableMonsterList.add(new SpawnListEntry(EntityVampireBaron.class,1,1,1));
  this.spawnableMonsterList.add(new SpawnListEntry(EntityBlindingBat.class,3,4,8));
  this.spawnableMonsterList.add(new SpawnListEntry(EntityVampire.class,10,2,3));
  this.spawnableCreatureList.add(new BiomeGenBase.SpawnListEntry(EntityDummyBittenAnimal.class,10,3,5));
  this.topBlock=ModBlocks.cursedEarth;
  this.fillerBlock=ModBlocks.cursedEarth;
  this.theBiomeDecorator.treesPerChunk=5;
  this.theBiomeDecorator.grassPerChunk=4;
  this.theBiomeDecorator.deadBushPerChunk=4;
  this.worldGeneratorTrees=new WorldGenTrees(false,4,1,0,false);
  this.flowers.clear();
  this.addFlower(ModBlocks.vampireFlower,1,10);
  this.canSpawnLightningBolt();
  this.waterColorMultiplier=0xFF2505;
}"
12724,"@Override public void actionPerformed(GuiButton button){
  if (button.id == 0) {
    GuiEntry e=new GuiEntry(book,category,from,player,bookStack);
    e.pageNumber=fromPage;
    Minecraft.getMinecraft().displayGuiScreen(e);
  }
 else {
    super.actionPerformed(button);
  }
}","@SideOnly(Side.CLIENT) @Override public void actionPerformed(GuiButton button){
  if (button.id == 0) {
    GuiEntry e=new GuiEntry(book,category,from,player,bookStack);
    e.pageNumber=fromPage;
    Minecraft.getMinecraft().displayGuiScreen(e);
  }
 else {
    super.actionPerformed(button);
  }
}"
12725,"public static ResourceLocation getTexture(int i){
switch (i) {
case 0:
    return texture1;
case 1:
  return texture2;
case 2:
return texture3;
}
return texture;
}","public static ResourceLocation getTexture(int i){
switch (i) {
case 0:
    return texture1;
case 1:
  return texture2;
case 2:
return texture3;
case 3:
return texture4;
}
return texture;
}"
12726,"@Override protected ResourceLocation getEntityTexture(Entity entity){
  int i=entity.getEntityId() % 4;
  return getTexture(i);
}","@Override protected ResourceLocation getEntityTexture(Entity entity){
  int i=entity.getEntityId() % 5;
  return getTexture(i);
}"
12727,"@Override public void onLivingUpdate(){
  this.isJumping=false;
  if (this.entityToAttack != null) {
    if (this.rand.nextInt(300) == 0) {
      this.faceEntity(this.entityToAttack,100.0F,100.0F);
    }
  }
  if (!this.worldObj.isRemote && this.isEntityAlive()) {
    if (disappearDelay > 0) {
      if (--disappearDelay == 1) {
        this.teleportAway();
      }
    }
    if (teleportDelay > 0) {
      teleportDelay--;
    }
    if (this.isInWater() || this.handleLavaMovement()) {
      this.teleportRandomly();
    }
    if (this.ticksExisted % 60 == 0) {
      if (damageCounter > 30) {
        if (this.teleportRandomly()) {
          damageCounter=0;
        }
 else {
        }
      }
 else {
        damageCounter=0;
      }
    }
    if (this.entityToAttack != null) {
      if (this.entityToAttack instanceof EntityPlayer) {
        if (getMinionHandler().getMinionCount() < 4 && rand.nextInt(80) == 0) {
          EntitySaveableVampireMinion entity=(EntitySaveableVampireMinion)Helper.spawnEntityBehindEntity((EntityLivingBase)this.entityToAttack,REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME);
          if (entity != null) {
            entity.setLord(this);
            entity.addPotionEffect(new PotionEffect(Potion.damageBoost.id,20000,2));
            minionInHomeDist(entity);
          }
        }
      }
    }
    if (this.ticksExisted % 100 == 0 && this.hasHome() && this.getMinionHandler().getMinionCount() < 1) {
      EntityVampireMinion minion=(EntityVampireMinion)Helper.spawnEntityInWorld(worldObj,castle,REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME,3);
      if (minion != null) {
        minion.setLord(this);
        minion.addPotionEffect(new PotionEffect(Potion.resistance.id,20000,3));
      }
    }
  }
  if (this.getHealth() > DraculaAIHeal.THRESHOLD * 2 && BALANCE.MOBPROP.DRACULA_REGENERATE_SECS >= 0 && this.ticksExisted % (BALANCE.MOBPROP.DRACULA_REGENERATE_SECS * 20) == 0 && (this.getLastAttackerTime() == 0 || this.getLastAttackerTime() - ticksExisted > 100)) {
    this.heal(5F);
  }
  super.onLivingUpdate();
  BossStatus.setBossStatus(this,true);
}","@Override public void onLivingUpdate(){
  this.isJumping=false;
  if (this.entityToAttack != null) {
    if (this.rand.nextInt(300) == 0) {
      this.faceEntity(this.entityToAttack,100.0F,100.0F);
    }
  }
  if (!this.worldObj.isRemote && this.isEntityAlive()) {
    if (disappearDelay > 0) {
      if (--disappearDelay == 1) {
        this.teleportAway();
      }
    }
    if (teleportDelay > 0) {
      teleportDelay--;
    }
    if (this.isInWater() || this.handleLavaMovement()) {
      this.teleportRandomly();
    }
    if (this.ticksExisted % 60 == 0) {
      if (damageCounter > 30) {
        if (this.teleportRandomly()) {
          damageCounter=0;
        }
 else {
        }
      }
 else {
        damageCounter=0;
      }
    }
    if (this.entityToAttack != null) {
      if (this.entityToAttack instanceof EntityPlayer) {
        if (getMinionHandler().getMinionCount() < 4 && rand.nextInt(80) == 0) {
          EntitySaveableVampireMinion entity=(EntitySaveableVampireMinion)Helper.spawnEntityBehindEntity((EntityLivingBase)this.entityToAttack,REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME);
          if (entity != null) {
            entity.setLord(this);
            entity.addPotionEffect(new PotionEffect(Potion.damageBoost.id,20000,2));
            minionInHomeDist(entity);
          }
        }
      }
    }
    if (this.ticksExisted % 100 == 0 && this.hasHome() && this.getMinionHandler().getMinionCount() < 1) {
      EntityVampireMinion minion=(EntityVampireMinion)Helper.spawnEntityInWorld(worldObj,castle,REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME,3);
      if (minion != null) {
        minion.setLord(this);
        minion.addPotionEffect(new PotionEffect(Potion.resistance.id,20000,3));
      }
    }
  }
  if (this.getHealth() > DraculaAIHeal.THRESHOLD * 2 && BALANCE.MOBPROP.DRACULA_REGENERATE_SECS >= 0 && this.ticksExisted % (BALANCE.MOBPROP.DRACULA_REGENERATE_SECS * 20) == 0 && (this.getLastAttackerTime() == 0 || this.getLastAttackerTime() - ticksExisted > 100)) {
    this.heal(5F);
  }
  if (!this.worldObj.isRemote && this.isGettingSundamage()) {
    this.makeDisappear();
  }
  super.onLivingUpdate();
}"
12728,"@Override public void onLivingUpdate(){
  if (!prevAttacking && this.getAttackTarget() != null) {
    prevAttacking=true;
    this.applyEntityAttributes(true);
  }
  if (prevAttacking && this.getAttackTarget() == null) {
    prevAttacking=false;
    this.applyEntityAttributes(false);
  }
  if (!worldObj.isRemote && shouldSpawnMinion()) {
    int i=0;
    if (this.recentlyHit > 0) {
      i=this.rand.nextInt(3);
    }
    IMinion m=null;
    if (i == 1) {
      EntityLiving e=(EntityLiving)EntityList.createEntityByName(REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME,this.worldObj);
      e.copyLocationAndAnglesFrom(this);
      worldObj.spawnEntityInWorld(e);
      m=(IMinion)e;
    }
 else     if (i == 2 && this.getAttackTarget() != null) {
      m=(IMinion)Helper.spawnEntityBehindEntity(this.getAttackTarget(),REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME);
    }
    if (m == null) {
      m=(IMinion)Helper.spawnEntityInWorld(worldObj,this.boundingBox.expand(19,4,19),REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME,3);
    }
    if (m != null) {
      m.setLord(this);
    }
  }
  if (!this.worldObj.isRemote && VampirismMod.isSunDamageTime(this.worldObj)) {
    if (this.worldObj.canBlockSeeTheSky(MathHelper.floor_double(this.posX),MathHelper.floor_double(this.posY),MathHelper.floor_double(this.posZ))) {
      this.teleportAway();
    }
  }
  super.onLivingUpdate();
}","@Override public void onLivingUpdate(){
  if (!prevAttacking && this.getAttackTarget() != null) {
    prevAttacking=true;
    this.applyEntityAttributes(true);
  }
  if (prevAttacking && this.getAttackTarget() == null) {
    prevAttacking=false;
    this.applyEntityAttributes(false);
  }
  if (!worldObj.isRemote && shouldSpawnMinion()) {
    int i=0;
    if (this.recentlyHit > 0) {
      i=this.rand.nextInt(3);
    }
    IMinion m=null;
    if (i == 1) {
      EntityLiving e=(EntityLiving)EntityList.createEntityByName(REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME,this.worldObj);
      e.copyLocationAndAnglesFrom(this);
      worldObj.spawnEntityInWorld(e);
      m=(IMinion)e;
    }
 else     if (i == 2 && this.getAttackTarget() != null) {
      m=(IMinion)Helper.spawnEntityBehindEntity(this.getAttackTarget(),REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME);
    }
    if (m == null) {
      m=(IMinion)Helper.spawnEntityInWorld(worldObj,this.boundingBox.expand(19,4,19),REFERENCE.ENTITY.VAMPIRE_MINION_SAVEABLE_NAME,3);
    }
    if (m != null) {
      m.setLord(this);
    }
  }
  if (!this.worldObj.isRemote && this.isGettingSundamage()) {
    if (this.worldObj.canBlockSeeTheSky(MathHelper.floor_double(this.posX),MathHelper.floor_double(this.posY),MathHelper.floor_double(this.posZ))) {
      this.teleportAway();
    }
  }
  super.onLivingUpdate();
}"
12729,"@Override public boolean getCanSpawnHere(){
  int i=MathHelper.floor_double(this.boundingBox.minY);
  if (i < 60)   return false;
  CastlePositionData data=CastlePositionData.get(worldObj);
  if (!data.isPosAt(MathHelper.floor_double(posX),MathHelper.floor_double(posZ))) {
    return false;
  }
  return super.getCanSpawnHere();
}","@Override public boolean getCanSpawnHere(){
  int i=MathHelper.floor_double(this.boundingBox.minY);
  if (i < 60)   return false;
  CastlePositionData data=CastlePositionData.get(worldObj);
  if (data.isPosAt(MathHelper.floor_double(posX),MathHelper.floor_double(posZ))) {
    return false;
  }
  return super.getCanSpawnHere();
}"
12730,"/** 
 * Called every LivingEntityUpdate, returns immediately if level =0;
 */
public void onUpdate(){
  if (this.sleepingCoffin && player.isPlayerSleeping()) {
    if (!player.worldObj.isRemote)     player.motionY=0;
 else     if (player.posY > Math.floor(player.posY) + 0.2)     player.motionY=-0.05;
 else     player.motionY=0;
  }
  if (getLevel() <= 0) {
    PotionEffect sang=player.getActivePotionEffect(ModPotion.sanguinare);
    if (sang != null) {
      if (sang.getDuration() == 1) {
        this.levelUp();
        player.addPotionEffect(new PotionEffect(ModPotion.saturation.id,300,2));
        player.addPotionEffect(new PotionEffect(Potion.resistance.id,300));
      }
    }
    return;
  }
  this.bloodStats.onUpdate();
  this.minionHandler.checkMinions();
  if (!player.worldObj.isRemote) {
    if (gettingSundamage()) {
      handleSunDamage();
    }
 else {
      if (ticksInSun > 0) {
        ticksInSun--;
      }
    }
    if (player.isPotionActive(ModPotion.sanguinare.id)) {
      player.removePotionEffect(ModPotion.sanguinare.id);
    }
    if (sleepingCoffin && !this.player.worldObj.isDaytime()) {
      this.wakeUpPlayer(true,false,true,true);
    }
  }
 else {
    if (gettingSundamage()) {
      if (ticksInSun < 101) {
        ticksInSun++;
      }
    }
 else {
      if (ticksInSun > 0) {
        ticksInSun--;
      }
    }
  }
  for (int i=0; i < skillTimer.length; i++) {
    int t=skillTimer[i];
    if (t != 0) {
      if (t < 0) {
        skillTimer[i]=++t;
      }
 else {
        skillTimer[i]=--t;
        ILastingSkill s=(ILastingSkill)Skills.getSkill(i);
        if (t == 0) {
          skillTimer[i]=-s.getCooldown();
          if (!isRemote()) {
            s.onDeactivated(this,player);
            dirty=true;
          }
        }
 else {
          if (s.onUpdate(this,player)) {
            skillTimer[i]=1;
          }
        }
      }
    }
  }
  if (!player.worldObj.isRemote && vampireLord) {
    if (getLevel() < REFERENCE.HIGHEST_REACHABLE_LEVEL) {
      VampireLordData.get(player.worldObj).makeNoLord(player,""String_Node_Str"");
    }
  }
  if (batTransformed != this.isSkillActive(Skills.batMode)) {
    batTransformed=!batTransformed;
    VampirismMod.proxy.setPlayerBat(player,batTransformed);
  }
  if (minionTarget != null && !minionTarget.isEntityAlive()) {
    minionTarget=null;
  }
  if (dirty && !player.worldObj.isRemote) {
    this.sync(true);
    dirty=false;
  }
}","/** 
 * Called every LivingEntityUpdate, returns immediately if level =0;
 */
public void onUpdate(){
  if (this.sleepingCoffin && player.isPlayerSleeping()) {
    if (!player.worldObj.isRemote)     player.motionY=0;
 else     if (player.posY > Math.floor(player.posY) + 0.2)     player.motionY=-0.05;
 else     player.motionY=0;
  }
  if (getLevel() <= 0) {
    PotionEffect sang=player.getActivePotionEffect(ModPotion.sanguinare);
    if (sang != null) {
      if (sang.getDuration() == 1) {
        this.levelUp();
        player.addPotionEffect(new PotionEffect(ModPotion.saturation.id,300,2));
        player.addPotionEffect(new PotionEffect(Potion.resistance.id,300));
      }
    }
    return;
  }
  this.bloodStats.onUpdate();
  this.minionHandler.checkMinions();
  if (!player.worldObj.isRemote) {
    if (gettingSundamage()) {
      handleSunDamage();
    }
 else {
      if (ticksInSun > 0) {
        ticksInSun--;
      }
    }
    if (biteCooldown > 0)     biteCooldown--;
    if (player.isPotionActive(ModPotion.sanguinare.id)) {
      player.removePotionEffect(ModPotion.sanguinare.id);
    }
    if (sleepingCoffin && !this.player.worldObj.isDaytime()) {
      this.wakeUpPlayer(true,false,true,true);
    }
  }
 else {
    if (gettingSundamage()) {
      if (ticksInSun < 101) {
        ticksInSun++;
      }
    }
 else {
      if (ticksInSun > 0) {
        ticksInSun--;
      }
    }
  }
  for (int i=0; i < skillTimer.length; i++) {
    int t=skillTimer[i];
    if (t != 0) {
      if (t < 0) {
        skillTimer[i]=++t;
      }
 else {
        skillTimer[i]=--t;
        ILastingSkill s=(ILastingSkill)Skills.getSkill(i);
        if (t == 0) {
          skillTimer[i]=-s.getCooldown();
          if (!isRemote()) {
            s.onDeactivated(this,player);
            dirty=true;
          }
        }
 else {
          if (s.onUpdate(this,player)) {
            skillTimer[i]=1;
          }
        }
      }
    }
  }
  if (!player.worldObj.isRemote && vampireLord) {
    if (getLevel() < REFERENCE.HIGHEST_REACHABLE_LEVEL) {
      VampireLordData.get(player.worldObj).makeNoLord(player,""String_Node_Str"");
    }
  }
  if (batTransformed != this.isSkillActive(Skills.batMode)) {
    batTransformed=!batTransformed;
    VampirismMod.proxy.setPlayerBat(player,batTransformed);
  }
  if (minionTarget != null && !minionTarget.isEntityAlive()) {
    minionTarget=null;
  }
  if (dirty && !player.worldObj.isRemote) {
    this.sync(true);
    dirty=false;
  }
}"
12731,"@Override public void loadTexture(IResourceManager resManager) throws IOException {
  this.deleteGlTexture();
  InputStream inputstream=null;
  InputStream inputstreamOverlay=null;
  try {
    BufferedImage image=null;
    IResource iresource=null;
    if (this.textureLocation.getResourcePath().contains(""String_Node_Str"")) {
      File f=getSkinFile(this.textureLocation);
      if (f.isFile()) {
        image=ImageIO.read(f);
      }
 else {
        Logger.w(TAG,""String_Node_Str"" + this.textureLocation + ""String_Node_Str""+ f);
        iresource=resManager.getResource(AbstractClientPlayer.locationStevePng);
        inputstream=iresource.getInputStream();
        image=ImageIO.read(inputstream);
      }
    }
 else {
      iresource=resManager.getResource(this.textureLocation);
      inputstream=iresource.getInputStream();
      image=ImageIO.read(inputstream);
    }
    try {
      IResource iresource_overlay=resManager.getResource(this.overlayLocation);
      inputstreamOverlay=iresource_overlay.getInputStream();
      Image overlay=ImageIO.read(inputstreamOverlay);
      int w=image.getWidth();
      int h=image.getHeight();
      if (w != overlay.getWidth(null)) {
        overlay=overlay.getScaledInstance(w,-1,Image.SCALE_SMOOTH);
      }
      if (h == overlay.getHeight(null)) {
        BufferedImage combined=new BufferedImage(w,h,BufferedImage.TYPE_INT_ARGB);
        Graphics g=combined.getGraphics();
        g.drawImage(image,0,0,null);
        g.drawImage(overlay,0,0,null);
        image=combined;
      }
 else {
        Logger.w(TAG,""String_Node_Str"" + overlayLocation + ""String_Node_Str""+ textureLocation);
      }
    }
 catch (    Exception e) {
      Logger.e(TAG,""String_Node_Str"" + overlayLocation + ""String_Node_Str""+ textureLocation,e);
    }
    boolean flag=false;
    boolean flag1=false;
    if (iresource != null && iresource.hasMetadata()) {
      try {
        TextureMetadataSection texturemetadatasection=(TextureMetadataSection)iresource.getMetadata(""String_Node_Str"");
        if (texturemetadatasection != null) {
          flag=texturemetadatasection.getTextureBlur();
          flag1=texturemetadatasection.getTextureClamp();
        }
      }
 catch (      RuntimeException runtimeexception) {
        Logger.e(TAG,""String_Node_Str"" + this.textureLocation,runtimeexception);
      }
    }
    TextureUtil.uploadTextureImageAllocate(this.getGlTextureId(),image,flag,flag1);
  }
  finally {
    if (inputstream != null) {
      inputstream.close();
    }
    if (inputstreamOverlay != null) {
      inputstreamOverlay.close();
    }
  }
}","@Override public void loadTexture(IResourceManager resManager) throws IOException {
  this.deleteGlTexture();
  InputStream inputstream=null;
  InputStream inputstreamOverlay=null;
  try {
    BufferedImage image=null;
    IResource iresource=null;
    if (this.textureLocation.getResourcePath().contains(""String_Node_Str"")) {
      File f=getSkinFile(this.textureLocation);
      if (f.isFile()) {
        image=ImageIO.read(f);
      }
 else {
        Logger.w(TAG,""String_Node_Str"" + this.textureLocation + ""String_Node_Str""+ f);
        iresource=resManager.getResource(AbstractClientPlayer.locationStevePng);
        inputstream=iresource.getInputStream();
        image=ImageIO.read(inputstream);
      }
    }
 else {
      iresource=resManager.getResource(this.textureLocation);
      inputstream=iresource.getInputStream();
      image=ImageIO.read(inputstream);
    }
    try {
      IResource iresource_overlay=resManager.getResource(this.overlayLocation);
      inputstreamOverlay=iresource_overlay.getInputStream();
      Image overlay=ImageIO.read(inputstreamOverlay);
      int w=image.getWidth();
      int h=image.getHeight();
      if (w != overlay.getWidth(null)) {
        overlay=overlay.getScaledInstance(w,-1,Image.SCALE_SMOOTH);
      }
      int oh=overlay.getHeight(null);
      if (h == oh || h == oh * 2) {
        BufferedImage combined=new BufferedImage(w,oh,BufferedImage.TYPE_INT_ARGB);
        Graphics g=combined.getGraphics();
        g.drawImage(image,0,0,null);
        g.drawImage(overlay,0,0,null);
        image=combined;
      }
 else {
        Logger.w(TAG,""String_Node_Str"" + overlayLocation + ""String_Node_Str""+ textureLocation);
      }
    }
 catch (    Exception e) {
      Logger.e(TAG,e,""String_Node_Str"" + overlayLocation + ""String_Node_Str""+ textureLocation);
    }
    boolean flag=false;
    boolean flag1=false;
    if (iresource != null && iresource.hasMetadata()) {
      try {
        TextureMetadataSection texturemetadatasection=(TextureMetadataSection)iresource.getMetadata(""String_Node_Str"");
        if (texturemetadatasection != null) {
          flag=texturemetadatasection.getTextureBlur();
          flag1=texturemetadatasection.getTextureClamp();
        }
      }
 catch (      RuntimeException runtimeexception) {
        Logger.e(TAG,""String_Node_Str"" + this.textureLocation,runtimeexception);
      }
    }
    TextureUtil.uploadTextureImageAllocate(this.getGlTextureId(),image,flag,flag1);
  }
  finally {
    if (inputstream != null) {
      inputstream.close();
    }
    if (inputstreamOverlay != null) {
      inputstreamOverlay.close();
    }
  }
}"
12732,"@Override public ResourceLocation checkVampireTexture(Entity entity,ResourceLocation loc){
  if (entity instanceof AbstractClientPlayer) {
    if (Configs.modify_vampire_player_texture && VampirePlayer.get((EntityPlayer)entity).getLevel() > 0) {
      ResourceLocation vamp=new ResourceLocation(""String_Node_Str"" + loc.hashCode());
      TextureHelper.createVampireTexture((EntityLivingBase)entity,loc,vamp);
      return vamp;
    }
  }
 else   if (entity instanceof EntityCreature) {
    if (VampireMob.get((EntityCreature)entity).isVampire()) {
      ResourceLocation vamp=new ResourceLocation(""String_Node_Str"" + loc.hashCode());
      TextureHelper.createVampireTexture((EntityLiving)entity,loc,vamp);
      return vamp;
    }
  }
  return loc;
}","@Override public ResourceLocation checkVampireTexture(Entity entity,ResourceLocation loc){
  if (entity instanceof AbstractClientPlayer) {
    if (Configs.modify_vampire_player_texture && VampirePlayer.get((EntityPlayer)entity).getLevel() > 0) {
      ResourceLocation vamp=new ResourceLocation(""String_Node_Str"" + loc.getResourcePath());
      TextureHelper.createVampireTexture((EntityLivingBase)entity,loc,vamp);
      return vamp;
    }
  }
 else   if (entity instanceof EntityCreature) {
    if (VampireMob.get((EntityCreature)entity).isVampire()) {
      ResourceLocation vamp=new ResourceLocation(""String_Node_Str"" + loc.getResourceDomain() + ""String_Node_Str""+ loc.getResourcePath());
      TextureHelper.createVampireTexture((EntityLiving)entity,loc,vamp);
      return vamp;
    }
  }
  return loc;
}"
12733,"/** 
 * Returns whether the EntityAIBase should begin execution.
 */
@Override public boolean shouldExecute(){
  boss=minion.getLord();
  if (boss == null) {
    return false;
  }
 else {
    double d0=this.boss.getTheDistanceSquared(minion.getRepresentingEntity());
    return d0 >= MINDIST && d0 <= MAXDIST;
  }
}","/** 
 * Returns whether the EntityAIBase should begin execution.
 */
@Override public boolean shouldExecute(){
  boss=minion.getLord();
  if (boss == null) {
    return false;
  }
 else {
    double d0=this.boss.getTheDistanceSquared(minion.getRepresentingEntity());
    return d0 >= MINDIST;
  }
}"
12734,"/** 
 * Returns whether an in-progress EntityAIBase should continue executing
 */
@Override public boolean continueExecuting(){
  if (!this.boss.isTheEntityAlive()) {
    boss=null;
    return false;
  }
 else {
    double d0=this.boss.getTheDistanceSquared(minion.getRepresentingEntity());
    return d0 >= MINDIST && d0 <= MAXDIST;
  }
}","/** 
 * Returns whether an in-progress EntityAIBase should continue executing
 */
@Override public boolean continueExecuting(){
  if (!this.boss.isTheEntityAlive()) {
    boss=null;
    return false;
  }
 else {
    double d0=this.boss.getTheDistanceSquared(minion.getRepresentingEntity());
    return d0 >= MINDIST;
  }
}"
12735,"@Override public boolean isEntityApplicable(Entity entity){
  IMinion m=MinionHelper.getMinionFromEntity(entity);
  if (selectPlayer) {
    if (entity instanceof EntityPlayer)     return true;
    if (MinionHelper.isLordSafe(m,minion.getLord())) {
      return false;
    }
  }
 else {
    if (entity instanceof EntityPlayer)     return false;
    if (MinionHelper.isLordPlayer(m))     return false;
  }
  if (excludeVampires) {
    IMinionLord l=minion.getLord();
    if (l != null && l instanceof VampirePlayer && ((VampirePlayer)l).isVampireLord()) {
      return true;
    }
    return false;
  }
  return targetClass.isAssignableFrom(entity.getClass());
}","@Override public boolean isEntityApplicable(Entity entity){
  IMinion m=MinionHelper.getMinionFromEntity(entity);
  if (selectPlayer) {
    if (MinionHelper.isLordSafe(m,minion.getLord())) {
      return false;
    }
    if (entity instanceof EntityPlayer)     return true;
  }
 else {
    if (entity instanceof EntityPlayer)     return false;
    if (MinionHelper.isLordPlayer(m))     return false;
  }
  if (excludeVampires) {
    if (entity instanceof EntityVampire) {
      IMinionLord l=minion.getLord();
      if (l != null && l instanceof VampirePlayer && ((VampirePlayer)l).isVampireLord()) {
        return true;
      }
      return false;
    }
  }
  return targetClass.isAssignableFrom(entity.getClass());
}"
12736,"/** 
 * Returns a new IEntitySelector for minion AI target tasks
 * @param minion The minion which the selector will be given
 * @param targetClass Class the target should have or extend.
 * @param selectPlayer If players and their minions should be selected as well. You do not need to set targetClass to EntityPlayer or any subclass of it.
 * @param excludeVampires If vampire npc should be excluded. Does not exclude vampires if the minions lord is a vampire lord
 * @return
 */
public static IEntitySelector getEntitySelectorForMinion(final IMinion minion,final Class<? extends Entity> targetClass,final boolean selectPlayer,final boolean excludeVampires){
  return new IEntitySelector(){
    @Override public boolean isEntityApplicable(    Entity entity){
      IMinion m=MinionHelper.getMinionFromEntity(entity);
      if (selectPlayer) {
        if (entity instanceof EntityPlayer)         return true;
        if (MinionHelper.isLordSafe(m,minion.getLord())) {
          return false;
        }
      }
 else {
        if (entity instanceof EntityPlayer)         return false;
        if (MinionHelper.isLordPlayer(m))         return false;
      }
      if (excludeVampires) {
        IMinionLord l=minion.getLord();
        if (l != null && l instanceof VampirePlayer && ((VampirePlayer)l).isVampireLord()) {
          return true;
        }
        return false;
      }
      return targetClass.isAssignableFrom(entity.getClass());
    }
  }
;
}","/** 
 * Returns a new IEntitySelector for minion AI target tasks
 * @param minion The minion which the selector will be given
 * @param targetClass Class the target should have or extend.
 * @param selectPlayer If players and their minions should be selected as well. You do not need to set targetClass to EntityPlayer or any subclass of it.
 * @param excludeVampires If vampire npc should be excluded. Does not exclude vampires if the minions lord is a vampire lord
 * @return
 */
public static IEntitySelector getEntitySelectorForMinion(final IMinion minion,final Class<? extends Entity> targetClass,final boolean selectPlayer,final boolean excludeVampires){
  return new IEntitySelector(){
    @Override public boolean isEntityApplicable(    Entity entity){
      IMinion m=MinionHelper.getMinionFromEntity(entity);
      if (selectPlayer) {
        if (MinionHelper.isLordSafe(m,minion.getLord())) {
          return false;
        }
        if (entity instanceof EntityPlayer)         return true;
      }
 else {
        if (entity instanceof EntityPlayer)         return false;
        if (MinionHelper.isLordPlayer(m))         return false;
      }
      if (excludeVampires) {
        if (entity instanceof EntityVampire) {
          IMinionLord l=minion.getLord();
          if (l != null && l instanceof VampirePlayer && ((VampirePlayer)l).isVampireLord()) {
            return true;
          }
          return false;
        }
      }
      return targetClass.isAssignableFrom(entity.getClass());
    }
  }
;
}"
12737,"public void loadMinions(NBTTagList list){
  if (list == null || list.tagCount() == 0) {
    Logger.d(TAG,""String_Node_Str"");
    return;
  }
  Logger.d(TAG,""String_Node_Str"" + list.tagCount() + ""String_Node_Str"");
  loadedMinions=new ArrayList<IMinion>();
  for (int i=0; i < list.tagCount(); i++) {
    NBTTagCompound nbttagcompound=list.getCompoundTagAt(i);
    Entity entity=EntityList.createEntityFromNBT(nbttagcompound,lord.getRepresentingEntity().worldObj);
    if (entity != null && entity instanceof IMinion) {
      entity.posY=entity.posY + entity.height;
      loadedMinions.add((IMinion)entity);
      Logger.d(TAG,""String_Node_Str"");
    }
 else {
      Logger.d(TAG,""String_Node_Str"");
    }
  }
}","public void loadMinions(NBTTagList list){
  if (list == null || list.tagCount() == 0) {
    Logger.d(TAG,""String_Node_Str"");
    return;
  }
  loadedMinions=new ArrayList<IMinion>();
  for (int i=0; i < list.tagCount(); i++) {
    NBTTagCompound nbttagcompound=list.getCompoundTagAt(i);
    Entity entity=EntityList.createEntityFromNBT(nbttagcompound,lord.getRepresentingEntity().worldObj);
    if (entity != null && entity instanceof IMinion) {
      entity.posY=entity.posY + entity.height;
      loadedMinions.add((IMinion)entity);
      Logger.d(TAG,""String_Node_Str"");
    }
 else {
      Logger.d(TAG,""String_Node_Str"");
    }
  }
}"
12738,"public void onCallActivated(int i){
  Logger.d(TAG,""String_Node_Str"",i);
switch (i) {
case 1:
    this.lastRemoteMinionComebackCall=System.currentTimeMillis();
  break;
case 2:
minionHandler.notifyCall(Call.DEFEND_LORD);
break;
case 3:
minionHandler.notifyCall(Call.ATTACK_NON_PLAYER);
break;
case 4:
minionHandler.notifyCall(Call.ATTACK);
break;
case 5:
minionHandler.notifyCall(Call.FOLLOW);
break;
default :
}
}","public void onCallActivated(int i){
  Logger.d(TAG,""String_Node_Str"",i);
switch (i) {
case 1:
    this.lastRemoteMinionComebackCall=System.currentTimeMillis();
  break;
case 2:
minionHandler.notifyCall(Call.DEFEND_LORD);
for (VampireMob m : MinionHelper.getNearMobMinions(this,20)) {
m.activateMinionCommand(m.getCommand(0));
}
break;
case 3:
minionHandler.notifyCall(Call.ATTACK_NON_PLAYER);
break;
case 4:
minionHandler.notifyCall(Call.ATTACK);
break;
case 5:
minionHandler.notifyCall(Call.FOLLOW);
for (VampireMob m : MinionHelper.getNearMobMinions(this,20)) {
m.activateMinionCommand(m.getCommand(1));
}
break;
default :
}
}"
12739,"@Override public EntityLivingBase getMinionTarget(){
  if (this.minionTarget != null) {
    return minionTarget;
  }
  return player.getLastAttacker();
}","@Override public EntityLivingBase getMinionTarget(){
  if (this.minionTarget != null) {
    return minionTarget;
  }
  if (player.getLastAttackerTime() < player.ticksExisted + 200) {
    return player.getLastAttacker();
  }
  return null;
}"
12740,"private void renderBloodVisionFog(int ticks){
  if (ticks < 1 || ticks > BLOOD_VISION_FADE_TICKS)   return;
  float f=((float)BLOOD_VISION_FADE_TICKS) / (float)ticks;
  GL11.glPushMatrix();
  GL11.glFog(GL11.GL_FOG_COLOR,this.setFogColorBuffer(0,1,0,1.0F));
  GL11.glFogi(GL11.GL_FOG_MODE,GL11.GL_LINEAR);
  GL11.glFogf(GL11.GL_FOG_START,4.0F * f);
  GL11.glFogf(GL11.GL_FOG_END,5.5F * f);
  GL11.glNormal3f(0.0F,-1.0F,0.0F);
  GL11.glColor4f(1F,1F,1F,1.0F);
  GL11.glFogf(GL11.GL_FOG_DENSITY,1.0F);
  GL11.glPopMatrix();
}","private void renderBloodVisionFog(int ticks){
  if (ticks < 1 || ticks > BLOOD_VISION_FADE_TICKS)   return;
  float f=((float)BLOOD_VISION_FADE_TICKS) / (float)ticks;
  GL11.glPushMatrix();
  boolean fog=GL11.glIsEnabled(GL11.GL_FOG);
  if (!fog)   GL11.glEnable(GL11.GL_FOG);
  GL11.glFog(GL11.GL_FOG_COLOR,this.setFogColorBuffer(0,1,0,1.0F));
  GL11.glFogi(GL11.GL_FOG_MODE,GL11.GL_LINEAR);
  GL11.glFogf(GL11.GL_FOG_START,4.0F * f);
  GL11.glFogf(GL11.GL_FOG_END,5.5F * f);
  GL11.glNormal3f(0.0F,-1.0F,0.0F);
  GL11.glColor4f(1F,1F,1F,1.0F);
  GL11.glFogf(GL11.GL_FOG_DENSITY,1.0F);
  if (!fog)   GL11.glDisable(GL11.GL_FOG);
  GL11.glPopMatrix();
}"
12741,"@SubscribeEvent public void dye(PlayerInteractEvent e){
  ItemStack i=null;
  if (e.entity instanceof EntityPlayer && e.entity.isSneaking() && e.action == Action.RIGHT_CLICK_BLOCK && (i=((EntityPlayer)e.entity).inventory.getCurrentItem()) != null && i.getItem() instanceof ItemDye) {
    ((TileEntityCoffin)e.world.getTileEntity(e.x,e.y,e.z)).changeColor(i.getItemDamage());
  }
}","@SubscribeEvent public void dye(PlayerInteractEvent e){
  ItemStack i=null;
  if (e.entity instanceof EntityPlayer && e.entity.isSneaking() && e.action == Action.RIGHT_CLICK_BLOCK && (i=((EntityPlayer)e.entity).inventory.getCurrentItem()) != null && i.getItem() instanceof ItemDye) {
    ((TileEntityCoffin)e.world.getTileEntity(e.x,e.y,e.z)).getPrimaryTileEntity().changeColor(i.getItemDamage());
  }
}"
12742,"@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float scale){
  TileEntityCoffin tile=(TileEntityCoffin)te;
  if ((te.getBlockMetadata() & (-8)) == 0) {
    return;
  }
  boolean occupied=(te.getBlockMetadata() & 4) != 0;
  Logger.i(""String_Node_Str"",""String_Node_Str"",tile.getPrimaryTileEntity() == tile);
  if (!occupied && tile.lidPos > 0)   tile.lidPos--;
 else   if (occupied && tile.lidPos < maxLidPos)   tile.lidPos++;
  GL11.glPushMatrix();
  GL11.glTranslatef((float)x + 0.5F,(float)y + 1.5F,(float)z + 0.5F);
  int color=Math.min(tile.color,15);
  bindTexture(textures[color]);
  GL11.glPushMatrix();
  adjustRotatePivotViaMeta(te.getWorldObj(),te.xCoord,te.yCoord,te.zCoord);
  GL11.glRotatef(180F,0.0F,0.0F,1.0F);
  model.rotateLid(calcLidAngle(tile.lidPos));
  model.render(null,0.0F,0.0F,-0.1F,0.0F,0.0F,0.0625F);
  GL11.glPopMatrix();
  GL11.glPopMatrix();
}","@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float scale){
  TileEntityCoffin tile=(TileEntityCoffin)te;
  if ((te.getBlockMetadata() & (-8)) == 0)   return;
  boolean occupied=(te.getBlockMetadata() & 4) != 0;
  if (!occupied && tile.lidPos > 0)   tile.lidPos--;
 else   if (occupied && tile.lidPos < maxLidPos)   tile.lidPos++;
  GL11.glPushMatrix();
  GL11.glTranslatef((float)x + 0.5F,(float)y + 1.5F,(float)z + 0.5F);
  int color=Math.min(tile.color,15);
  bindTexture(textures[color]);
  GL11.glPushMatrix();
  adjustRotatePivotViaMeta(te.getWorldObj(),te.xCoord,te.yCoord,te.zCoord);
  GL11.glRotatef(180F,0.0F,0.0F,1.0F);
  model.rotateLid(calcLidAngle(tile.lidPos));
  model.render(null,0.0F,0.0F,-0.1F,0.0F,0.0F,0.0625F);
  GL11.glPopMatrix();
  GL11.glPopMatrix();
}"
12743,"@SubscribeEvent public void dye(PlayerInteractEvent e){
  ItemStack i=null;
  if (e.entityPlayer.isSneaking() && e.action == Action.RIGHT_CLICK_BLOCK && e.world.getBlock(e.x,e.y,e.z).equals(ModBlocks.coffin) && (i=(e.entityPlayer).inventory.getCurrentItem()) != null && i.getItem() instanceof ItemDye) {
    int color=i.getItemDamage();
    TileEntityCoffin t=(TileEntityCoffin)e.world.getTileEntity(e.x,e.y,e.z);
    if (t == null)     return;
    t=t.getPrimaryTileEntity();
    if (t == null)     return;
    t.changeColor(color);
    e.useBlock=Result.DENY;
    e.useItem=Result.DENY;
    if (!e.entityPlayer.capabilities.isCreativeMode) {
      i.stackSize--;
    }
  }
}","@SubscribeEvent public void dye(PlayerInteractEvent e){
  if (e.world.isRemote)   return;
  ItemStack i=null;
  if (e.entityPlayer.isSneaking() && e.action == Action.RIGHT_CLICK_BLOCK && e.world.getBlock(e.x,e.y,e.z).equals(ModBlocks.coffin) && (i=(e.entityPlayer).inventory.getCurrentItem()) != null && i.getItem() instanceof ItemDye) {
    int color=i.getItemDamage();
    TileEntityCoffin t=(TileEntityCoffin)e.world.getTileEntity(e.x,e.y,e.z);
    if (t == null)     return;
    t=t.getPrimaryTileEntity();
    if (t == null)     return;
    t.changeColor(color);
    e.useBlock=Result.DENY;
    e.useItem=Result.DENY;
    if (!e.entityPlayer.capabilities.isCreativeMode) {
      i.stackSize--;
    }
  }
}"
12744,"@Override public void updateEntity(){
  if ((this.getBlockMetadata() & 8) == 0)   return;
  if (!this.worldObj.isRemote && (occupied != ((this.getBlockMetadata() & 4) != 0))) {
    occupied=!occupied;
    needsAnimation=true;
    markDirty();
  }
 else   BlockBed.func_149979_a(worldObj,xCoord,yCoord,zCoord,occupied);
}","@Override public void updateEntity(){
  if ((this.getBlockMetadata() & -8) == 0)   return;
  if (!this.worldObj.isRemote && (occupied != ((this.getBlockMetadata() & 4) != 0))) {
    occupied=!occupied;
    needsAnimation=true;
    markDirty();
  }
 else   BlockBed.func_149979_a(worldObj,xCoord,yCoord,zCoord,occupied);
}"
12745,"public void changeColor(int color){
  this.color=color;
  needsAnimation=false;
  markDirty();
}","public void changeColor(int color){
  Logger.i(""String_Node_Str"",""String_Node_Str"",this.color,color,this.toString());
  this.color=color;
  needsAnimation=false;
  markDirty();
}"
12746,"public TileEntityCoffin getPrimaryTileEntity(){
  if ((this.worldObj.getBlockMetadata(this.otherX,this.yCoord,this.zCoord) & -8) == 0)   return (TileEntityCoffin)worldObj.getTileEntity(otherX,otherY,otherZ);
  return this;
}","public TileEntityCoffin getPrimaryTileEntity(){
  if ((this.getBlockMetadata() & -8) == 0)   return (TileEntityCoffin)worldObj.getTileEntity(otherX,otherY,otherZ);
  return this;
}"
12747,"public RendererCoffin(){
  model=new ModelCoffin();
  for (int i=0; i < colors.length; i++) {
    Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",colors[i],i));
    textures[i]=new ResourceLocation(REFERENCE.MODID + ""String_Node_Str"" + colors[i]+ ""String_Node_Str"");
  }
}","public RendererCoffin(){
  model=new ModelCoffin();
  for (int i=0; i < colors.length; i++) {
    textures[i]=new ResourceLocation(REFERENCE.MODID + ""String_Node_Str"" + colors[i]+ ""String_Node_Str"");
  }
}"
12748,"@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float scale){
  TileEntityCoffin tile=(TileEntityCoffin)te;
  if (te instanceof TileEntityCoffin)   if ((te.getBlockMetadata() & (-8)) == 0) {
    return;
  }
  boolean occupied=(te.getBlockMetadata() & 4) != 0;
  if (!occupied && tile.lidPos > 0)   tile.lidPos--;
 else   if (occupied && tile.lidPos < maxLidPos)   tile.lidPos++;
  GL11.glPushMatrix();
  GL11.glTranslatef((float)x + 0.5F,(float)y + 1.5F,(float)z + 0.5F);
  bindTexture(textures[((TileEntityCoffin)te).color]);
  GL11.glPushMatrix();
  adjustRotatePivotViaMeta(te.getWorldObj(),te.xCoord,te.yCoord,te.zCoord);
  GL11.glRotatef(180F,0.0F,0.0F,1.0F);
  model.rotateLid(calcLidAngle(tile.lidPos));
  model.render(null,0.0F,0.0F,-0.1F,0.0F,0.0F,0.0625F);
  GL11.glPopMatrix();
  GL11.glPopMatrix();
}","@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float scale){
  TileEntityCoffin tile=(TileEntityCoffin)te;
  if ((te.getBlockMetadata() & (-8)) == 0) {
    return;
  }
  boolean occupied=(te.getBlockMetadata() & 4) != 0;
  Logger.i(""String_Node_Str"",""String_Node_Str"",tile.getPrimaryTileEntity() == tile);
  if (!occupied && tile.lidPos > 0)   tile.lidPos--;
 else   if (occupied && tile.lidPos < maxLidPos)   tile.lidPos++;
  GL11.glPushMatrix();
  GL11.glTranslatef((float)x + 0.5F,(float)y + 1.5F,(float)z + 0.5F);
  int color=Math.min(tile.color,15);
  bindTexture(textures[color]);
  GL11.glPushMatrix();
  adjustRotatePivotViaMeta(te.getWorldObj(),te.xCoord,te.yCoord,te.zCoord);
  GL11.glRotatef(180F,0.0F,0.0F,1.0F);
  model.rotateLid(calcLidAngle(tile.lidPos));
  model.render(null,0.0F,0.0F,-0.1F,0.0F,0.0F,0.0625F);
  GL11.glPopMatrix();
  GL11.glPopMatrix();
}"
12749,"@Override public void registerSubscriptions(){
  MinecraftForge.EVENT_BUS.register(new VampirePlayerEventHandler());
  MinecraftForge.EVENT_BUS.register(new VampireEntityEventHandler());
  MinecraftForge.EVENT_BUS.register(new de.teamlapen.vampirism.block.BlockCoffin());
  MinecraftForge.EVENT_BUS.register(this);
  FMLCommonHandler.instance().bus().register(this);
}","@Override public void registerSubscriptions(){
  MinecraftForge.EVENT_BUS.register(new VampirePlayerEventHandler());
  MinecraftForge.EVENT_BUS.register(new VampireEntityEventHandler());
  MinecraftForge.EVENT_BUS.register(this);
  FMLCommonHandler.instance().bus().register(this);
}"
12750,"public TileEntityCoffin getPrimaryTileEntity(){
  if ((this.worldObj.getBlockMetadata(this.otherX,this.yCoord,this.zCoord) & -8) != 0)   return (TileEntityCoffin)worldObj.getTileEntity(otherX,otherY,otherZ);
  return this;
}","public TileEntityCoffin getPrimaryTileEntity(){
  if ((this.worldObj.getBlockMetadata(this.otherX,this.yCoord,this.zCoord) & -8) == 0)   return (TileEntityCoffin)worldObj.getTileEntity(otherX,otherY,otherZ);
  return this;
}"
12751,"@Override public boolean onBlockActivated(World world,int x,int y,int z,EntityPlayer player,int par4,float f1,float f2,float f3){
  if (world.isRemote) {
    return true;
  }
 else {
    if ((world.getBlockMetadata(x,y,z) & -8) == 0) {
      TileEntityCoffin te=(TileEntityCoffin)world.getTileEntity(x,y,z);
      x=te.otherX;
      y=te.otherY;
      z=te.otherZ;
    }
    if (world.provider.canRespawnHere() && world.getBiomeGenForCoords(x,z) != BiomeGenBase.hell) {
      if ((world.getBlockMetadata(x,y,z) & 4) != 0) {
        player.addChatComponentMessage(new ChatComponentTranslation(""String_Node_Str"",new Object[0]));
        return true;
      }
      EntityPlayer.EnumStatus enumstatus=VampirePlayer.get(player).sleepInCoffinAt(x,y,z);
      if (enumstatus == EntityPlayer.EnumStatus.OK) {
        setBedOccupied(world,x,y,z,player,true);
        return true;
      }
 else {
        if (enumstatus == EntityPlayer.EnumStatus.NOT_POSSIBLE_NOW) {
          player.addChatComponentMessage(new ChatComponentTranslation(""String_Node_Str"",new Object[0]));
        }
 else         if (enumstatus == EntityPlayer.EnumStatus.NOT_SAFE) {
          player.addChatComponentMessage(new ChatComponentTranslation(""String_Node_Str"",new Object[0]));
        }
        return true;
      }
    }
 else {
      double d2=x + 0.5D;
      double d0=y + 0.5D;
      double d1=z + 0.5D;
      world.setBlockToAir(x,y,z);
      if (world.getBlock(x,y,z) == this) {
        world.setBlockToAir(x,y,z);
        d2=(d2 + x + 0.5D) / 2.0D;
        d0=(d0 + y + 0.5D) / 2.0D;
        d1=(d1 + z + 0.5D) / 2.0D;
      }
      world.newExplosion((Entity)null,x + 0.5F,y + 0.5F,z + 0.5F,5.0F,true,true);
      return true;
    }
  }
}","@Override public boolean onBlockActivated(World world,int x,int y,int z,EntityPlayer player,int par4,float f1,float f2,float f3){
  if (world.isRemote) {
    return true;
  }
 else {
    if ((world.getBlockMetadata(x,y,z) & -8) == 0) {
      TileEntityCoffin te=(TileEntityCoffin)world.getTileEntity(x,y,z);
      x=te.otherX;
      y=te.otherY;
      z=te.otherZ;
    }
    if (world.provider.canRespawnHere() && world.getBiomeGenForCoords(x,z) != BiomeGenBase.hell) {
      if ((world.getBlockMetadata(x,y,z) & 4) != 0) {
        player.addChatComponentMessage(new ChatComponentTranslation(""String_Node_Str"",new Object[0]));
        return true;
      }
      EntityPlayer.EnumStatus enumstatus=VampirePlayer.get(player).sleepInCoffinAt(x,y,z);
      if (enumstatus == EntityPlayer.EnumStatus.OK) {
        setBedOccupied(world,x,y,z,player,true);
        ((TileEntityCoffin)world.getTileEntity(x,y,z)).markDirty();
        return true;
      }
 else {
        if (enumstatus == EntityPlayer.EnumStatus.NOT_POSSIBLE_NOW) {
          player.addChatComponentMessage(new ChatComponentTranslation(""String_Node_Str"",new Object[0]));
        }
 else         if (enumstatus == EntityPlayer.EnumStatus.NOT_SAFE) {
          player.addChatComponentMessage(new ChatComponentTranslation(""String_Node_Str"",new Object[0]));
        }
        return true;
      }
    }
 else {
      double d2=x + 0.5D;
      double d0=y + 0.5D;
      double d1=z + 0.5D;
      world.setBlockToAir(x,y,z);
      if (world.getBlock(x,y,z) == this) {
        world.setBlockToAir(x,y,z);
        d2=(d2 + x + 0.5D) / 2.0D;
        d0=(d0 + y + 0.5D) / 2.0D;
        d1=(d1 + z + 0.5D) / 2.0D;
      }
      world.newExplosion((Entity)null,x + 0.5F,y + 0.5F,z + 0.5F,5.0F,true,true);
      return true;
    }
  }
}"
12752,"@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float scale){
  if (te instanceof TileEntityCoffin)   if ((te.getWorldObj().getBlockMetadata(te.xCoord,te.yCoord,te.zCoord) & (-8)) == 0) {
    return;
  }
  boolean occupied=(te.getWorldObj().getBlockMetadata(te.xCoord,te.yCoord,te.zCoord) & 4) != 0;
  if (!occupied && lidPosition > 0)   lidPosition--;
 else   if (occupied && lidPosition < maxLidPos)   lidPosition++;
  GL11.glPushMatrix();
  GL11.glTranslatef((float)x + 0.5F,(float)y + 1.5F,(float)z + 0.5F);
  bindTexture(texture);
  GL11.glPushMatrix();
  adjustRotatePivotViaMeta(te.getWorldObj(),te.xCoord,te.yCoord,te.zCoord);
  GL11.glRotatef(180F,0.0F,0.0F,1.0F);
  model.rotateLid(calcLidAngle(lidPosition));
  model.render(null,0.0F,0.0F,-0.1F,0.0F,0.0F,0.0625F);
  GL11.glPopMatrix();
  GL11.glPopMatrix();
}","@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float scale){
  if (te instanceof TileEntityCoffin)   if ((te.getWorldObj().getBlockMetadata(te.xCoord,te.yCoord,te.zCoord) & (-8)) == 0) {
    return;
  }
  boolean occupied=(te.getWorldObj().getBlockMetadata(te.xCoord,te.yCoord,te.zCoord) & 4) != 0;
  if (!occupied && lidPosition > 0)   lidPosition--;
 else   if (occupied && lidPosition < maxLidPos)   lidPosition++;
  Logger.i(""String_Node_Str"",""String_Node_Str"" + lidPosition + ""String_Node_Str""+ occupied);
  GL11.glPushMatrix();
  GL11.glTranslatef((float)x + 0.5F,(float)y + 1.5F,(float)z + 0.5F);
  bindTexture(texture);
  GL11.glPushMatrix();
  adjustRotatePivotViaMeta(te.getWorldObj(),te.xCoord,te.yCoord,te.zCoord);
  GL11.glRotatef(180F,0.0F,0.0F,1.0F);
  model.rotateLid(calcLidAngle(lidPosition));
  model.render(null,0.0F,0.0F,-0.1F,0.0F,0.0F,0.0625F);
  GL11.glPopMatrix();
  GL11.glPopMatrix();
}"
12753,"private void wakeSleepingPlayer(World world,int x,int y,int z){
  if (world.isRemote)   return;
  WorldServer w=(WorldServer)world;
  for (int i=0; i < w.playerEntities.size(); i++) {
    EntityPlayer p=((EntityPlayer)w.playerEntities.get(i));
    if (p.isPlayerSleeping()) {
      Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",p.playerLocation.posX,p.playerLocation.posY,p.playerLocation.posZ));
      if (p.playerLocation.posX == x && p.playerLocation.posY == y && p.playerLocation.posZ == z) {
        VampirePlayer.get(p).sleepingCoffin=false;
      }
    }
  }
}","private void wakeSleepingPlayer(World world,int x,int y,int z){
  if (world.isRemote)   return;
  WorldServer w=(WorldServer)world;
  for (int i=0; i < w.playerEntities.size(); i++) {
    EntityPlayer p=((EntityPlayer)w.playerEntities.get(i));
    if (p.isPlayerSleeping()) {
      Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",p.playerLocation.posX,p.playerLocation.posY,p.playerLocation.posZ));
      if (p.playerLocation.posX == x && p.playerLocation.posY == y && p.playerLocation.posZ == z) {
        VampirePlayer.get(p).wakeUpPlayer(false,true,false,false);
      }
    }
  }
}"
12754,"public static boolean shouldWakePlayer(EntityPlayer p,boolean p1,boolean p2,boolean p3){
  if (p.worldObj.isRemote)   return true;
  Throwable t=new Throwable();
  if (t.getStackTrace()[2].toString().startsWith(""String_Node_Str"")) {
    Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",VampirePlayer.get(p).toString(),p.isPlayerSleeping()));
    VampirePlayer.get(p).sleepingCoffin=false;
    ((EntityPlayerMP)p).wakeUpPlayer(p1,p2,p3);
    return true;
  }
  if (VampirePlayer.get(p) != null && VampirePlayer.get(p).sleepingCoffin) {
    return false;
  }
  Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",p.worldObj.isRemote));
  return true;
}","public static boolean shouldWakePlayer(EntityPlayer p,boolean p1,boolean p2,boolean p3){
  if (p.worldObj.isRemote)   return true;
  Throwable t=new Throwable();
  if (t.getStackTrace()[2].toString().startsWith(""String_Node_Str"")) {
    Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",VampirePlayer.get(p).toString(),p.isPlayerSleeping()));
    VampirePlayer.get(p).wakeUpPlayer(false,p1,p2,p3);
    return true;
  }
  if (VampirePlayer.get(p) != null && VampirePlayer.get(p).sleepingCoffin) {
    return false;
  }
  Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",p.worldObj.isRemote));
  return true;
}"
12755,"/** 
 * puts player to sleep on specified coffin if possible
 */
public EntityPlayer.EnumStatus sleepInCoffinAt(int x,int y,int z){
  Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",x,y,z,this.isRemote()));
  if (!this.player.worldObj.isRemote) {
    if (this.sleepingCoffin || !this.isTheEntityAlive()) {
      return EntityPlayer.EnumStatus.OTHER_PROBLEM;
    }
    if (!this.player.worldObj.provider.isSurfaceWorld()) {
      return EntityPlayer.EnumStatus.NOT_POSSIBLE_HERE;
    }
    if (!this.player.worldObj.isDaytime()) {
      return EntityPlayer.EnumStatus.NOT_POSSIBLE_NOW;
    }
    if (Math.abs(this.player.posX - x) > 3.0D || Math.abs(this.player.posY - y) > 2.0D || Math.abs(this.player.posZ - z) > 3.0D) {
      return EntityPlayer.EnumStatus.TOO_FAR_AWAY;
    }
    double d0=8.0D;
    double d1=5.0D;
    List list=this.player.worldObj.getEntitiesWithinAABB(EntityMob.class,AxisAlignedBB.getBoundingBox(x - d0,y - d1,z - d0,x + d0,y + d1,z + d0));
    if (!list.isEmpty()) {
      return EntityPlayer.EnumStatus.NOT_SAFE;
    }
  }
  if (this.player.isRiding()) {
    this.player.mountEntity((Entity)null);
  }
  Helper.Reflection.callMethod(Entity.class,this.player,Helper.Obfuscation.getPosNames(""String_Node_Str""),new Class[]{float.class,float.class},new Object[]{0.2F,0.2F});
  this.player.yOffset=0.2F;
  if (this.player.worldObj.blockExists(x,y,z)) {
    int direction=((BlockCoffin)player.worldObj.getBlock(x,y,z)).getDirection(player.worldObj,x,y,z);
    float xOffset=0.5F;
    float zOffset=0.5F;
    float yOffset=0.5F;
switch (direction) {
case 0:
      zOffset=1.8F;
    break;
case 3:
  xOffset=1.8F;
break;
case 2:
zOffset=-0.8F;
break;
case 1:
xOffset=-0.8F;
}
this.func_71013_b(direction);
this.player.setPosition(x + xOffset,y + yOffset,z + zOffset);
Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",xOffset,yOffset,zOffset));
}
 else {
this.player.setPosition(x + 0.5F,y + 0.9375F,z + 0.5F);
Logger.i(""String_Node_Str"",""String_Node_Str"");
}
S0APacketUseBed s0apacketusebed=new S0APacketUseBed(((EntityPlayerMP)this.player),x,y,z);
((EntityPlayerMP)this.player).getServerForPlayer().getEntityTracker().func_151247_a(((EntityPlayerMP)this.player),s0apacketusebed);
((EntityPlayerMP)this.player).playerNetServerHandler.setPlayerLocation(((EntityPlayerMP)this.player).posX,((EntityPlayerMP)this.player).posY,((EntityPlayerMP)this.player).posZ,((EntityPlayerMP)this.player).rotationYaw,((EntityPlayerMP)this.player).rotationPitch);
((EntityPlayerMP)this.player).playerNetServerHandler.sendPacket(s0apacketusebed);
Helper.Reflection.setPrivateField(EntityPlayer.class,this.player,true,Helper.Obfuscation.getPosNames(""String_Node_Str""));
this.sleepingCoffin=true;
Logger.i(""String_Node_Str"",""String_Node_Str"" + this.sleepingCoffin);
Helper.Reflection.setPrivateField(EntityPlayer.class,this.player,0,Helper.Obfuscation.getPosNames(""String_Node_Str""));
this.player.playerLocation=new ChunkCoordinates(x,y,z);
this.player.motionX=this.player.motionZ=this.player.motionY=0.0D;
if (!this.player.worldObj.isRemote) {
this.player.worldObj.updateAllPlayersSleepingFlag();
}
VampirePlayer.get(player).sync(true);
return EntityPlayer.EnumStatus.OK;
}","/** 
 * puts player to sleep on specified coffin if possible
 */
public EntityPlayer.EnumStatus sleepInCoffinAt(int x,int y,int z){
  Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",x,y,z,this.isRemote()));
  if (!this.player.worldObj.isRemote) {
    if (this.sleepingCoffin || !this.isTheEntityAlive()) {
      Logger.w(TAG,""String_Node_Str"");
      return EntityPlayer.EnumStatus.OTHER_PROBLEM;
    }
    if (!this.player.worldObj.provider.isSurfaceWorld()) {
      Logger.w(TAG,""String_Node_Str"");
      return EntityPlayer.EnumStatus.NOT_POSSIBLE_HERE;
    }
    if (!this.player.worldObj.isDaytime()) {
      return EntityPlayer.EnumStatus.NOT_POSSIBLE_NOW;
    }
    if (Math.abs(this.player.posX - x) > 3.0D || Math.abs(this.player.posY - y) > 2.0D || Math.abs(this.player.posZ - z) > 3.0D) {
      Logger.w(TAG,""String_Node_Str"");
      return EntityPlayer.EnumStatus.TOO_FAR_AWAY;
    }
    double d0=8.0D;
    double d1=5.0D;
    List list=this.player.worldObj.getEntitiesWithinAABB(EntityMob.class,AxisAlignedBB.getBoundingBox(x - d0,y - d1,z - d0,x + d0,y + d1,z + d0));
    if (!list.isEmpty()) {
      return EntityPlayer.EnumStatus.NOT_SAFE;
    }
  }
  if (this.player.isRiding()) {
    this.player.mountEntity((Entity)null);
  }
  Helper.Reflection.callMethod(Entity.class,this.player,Helper.Obfuscation.getPosNames(""String_Node_Str""),new Class[]{float.class,float.class},new Object[]{0.2F,0.2F});
  this.player.yOffset=0.2F;
  if (this.player.worldObj.blockExists(x,y,z)) {
    int direction=((BlockCoffin)player.worldObj.getBlock(x,y,z)).getDirection(player.worldObj,x,y,z);
    float xOffset=0.5F;
    float zOffset=0.5F;
    float yOffset=0.5F;
switch (direction) {
case 0:
      zOffset=1.8F;
    break;
case 3:
  xOffset=1.8F;
break;
case 2:
zOffset=-0.8F;
break;
case 1:
xOffset=-0.8F;
}
this.func_71013_b(direction);
this.player.setPosition(x + xOffset,y + yOffset,z + zOffset);
Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",xOffset,yOffset,zOffset));
}
 else {
this.player.setPosition(x + 0.5F,y + 0.9375F,z + 0.5F);
Logger.i(""String_Node_Str"",""String_Node_Str"");
}
S0APacketUseBed s0apacketusebed=new S0APacketUseBed(((EntityPlayerMP)this.player),x,y,z);
((EntityPlayerMP)this.player).getServerForPlayer().getEntityTracker().func_151247_a(((EntityPlayerMP)this.player),s0apacketusebed);
((EntityPlayerMP)this.player).playerNetServerHandler.setPlayerLocation(((EntityPlayerMP)this.player).posX,((EntityPlayerMP)this.player).posY,((EntityPlayerMP)this.player).posZ,((EntityPlayerMP)this.player).rotationYaw,((EntityPlayerMP)this.player).rotationPitch);
((EntityPlayerMP)this.player).playerNetServerHandler.sendPacket(s0apacketusebed);
Helper.Reflection.setPrivateField(EntityPlayer.class,this.player,true,Helper.Obfuscation.getPosNames(""String_Node_Str""));
this.sleepingCoffin=true;
Logger.i(""String_Node_Str"",""String_Node_Str"" + this.sleepingCoffin);
Helper.Reflection.setPrivateField(EntityPlayer.class,this.player,0,Helper.Obfuscation.getPosNames(""String_Node_Str""));
this.player.playerLocation=new ChunkCoordinates(x,y,z);
this.player.motionX=this.player.motionZ=this.player.motionY=0.0D;
if (!this.player.worldObj.isRemote) {
this.player.worldObj.updateAllPlayersSleepingFlag();
}
VampirePlayer.get(player).sync(true);
return EntityPlayer.EnumStatus.OK;
}"
12756,"private void writeNBT(NBTTagCompound nbt){
  nbt.setInteger(""String_Node_Str"",bloodTimer);
  nbt.setFloat(""String_Node_Str"",bloodExhaustionLevel);
  nbt.setFloat(""String_Node_Str"",bloodSaturationLevel);
  nbt.setBoolean(""String_Node_Str"",sleepingCoffin);
}","private void writeNBT(NBTTagCompound nbt){
  nbt.setInteger(""String_Node_Str"",bloodTimer);
  nbt.setFloat(""String_Node_Str"",bloodExhaustionLevel);
  nbt.setFloat(""String_Node_Str"",bloodSaturationLevel);
}"
12757,"private void readNBT(NBTTagCompound nbt){
  if (nbt.hasKey(""String_Node_Str"")) {
    bloodTimer=nbt.getInteger(""String_Node_Str"");
    bloodExhaustionLevel=nbt.getFloat(""String_Node_Str"");
    bloodSaturationLevel=nbt.getFloat(""String_Node_Str"");
  }
  if (nbt.hasKey(""String_Node_Str""))   sleepingCoffin=nbt.getBoolean(""String_Node_Str"");
}","private void readNBT(NBTTagCompound nbt){
  if (nbt.hasKey(""String_Node_Str"")) {
    bloodTimer=nbt.getInteger(""String_Node_Str"");
    bloodExhaustionLevel=nbt.getFloat(""String_Node_Str"");
    bloodSaturationLevel=nbt.getFloat(""String_Node_Str"");
  }
}"
12758,"public boolean onEntityAttacked(DamageSource source,float amount){
  if (source.getEntity() instanceof DefaultVampire && getLevel() == 0) {
    if (player.worldObj.rand.nextInt(BALANCE.VAMPIRE_PLAYER_SANGUINARE_PROB * 4) == 0) {
      if (!player.isPotionActive(ModPotion.sanguinare)) {
        player.addPotionEffect(new PotionEffect(ModPotion.sanguinare.id,BALANCE.VAMPIRE_PLAYER_SANGUINARE_DURATION * 20));
      }
    }
  }
  if (source.getEntity() instanceof EntityLivingBase && getLevel() > 0) {
    this.minionTarget=(EntityLivingBase)source.getEntity();
    return false;
  }
  if (DamageSource.fall.equals(source) && !this.skipFallDamageReduction) {
    float i=amount - (getLevel() / 3) - 1;
    if (i > 0) {
      this.skipFallDamageReduction=true;
      player.attackEntityFrom(DamageSource.fall,i);
      this.skipFallDamageReduction=false;
    }
    return true;
  }
  return false;
}","/** 
 * If this returns true, the damage is skipped
 * @param source
 * @param amount
 * @return
 */
public boolean onEntityAttacked(DamageSource source,float amount){
  if (source.getEntity() instanceof DefaultVampire && getLevel() == 0) {
    if (player.worldObj.rand.nextInt(BALANCE.VAMPIRE_PLAYER_SANGUINARE_PROB * 4) == 0) {
      if (!player.isPotionActive(ModPotion.sanguinare)) {
        player.addPotionEffect(new PotionEffect(ModPotion.sanguinare.id,BALANCE.VAMPIRE_PLAYER_SANGUINARE_DURATION * 20));
      }
    }
  }
  if (source.getEntity() instanceof EntityLivingBase && getLevel() > 0) {
    this.minionTarget=(EntityLivingBase)source.getEntity();
    return false;
  }
  if (DamageSource.fall.equals(source) && !this.skipFallDamageReduction) {
    float i=amount - (getLevel() / 3) - 1;
    if (i > 0) {
      this.skipFallDamageReduction=true;
      player.attackEntityFrom(DamageSource.fall,i);
      this.skipFallDamageReduction=false;
    }
    return true;
  }
  Logger.i(TAG,""String_Node_Str"" + this.sleepingCoffin + ""String_Node_Str""+ player.isPlayerSleeping());
  if (sleepingCoffin && !player.isEntityInvulnerable() && !(player.capabilities.disableDamage && !source.canHarmInCreative())) {
    this.wakeUpPlayer(false,true,false,false);
  }
  return false;
}"
12759,"/** 
 * Called every LivingEntityUpdate, returns immediately if level =0;
 */
public void onUpdate(){
  if (this.sleepingCoffin && player.isPlayerSleeping()) {
    if (player.worldObj.isRemote)     Logger.i(""String_Node_Str"",""String_Node_Str"" + player.posY);
    if (!player.worldObj.isRemote)     player.motionY=0;
 else     if (player.posY > Math.floor(player.posY) + 0.2)     player.motionY=-0.05;
 else     player.motionY=0;
  }
  if (getLevel() <= 0) {
    PotionEffect sang=player.getActivePotionEffect(ModPotion.sanguinare);
    if (sang != null) {
      if (sang.getDuration() == 1) {
        this.levelUp();
        player.addPotionEffect(new PotionEffect(ModPotion.saturation.id,300,2));
        player.addPotionEffect(new PotionEffect(Potion.resistance.id,300));
      }
    }
    return;
  }
  this.bloodStats.onUpdate();
  this.minionHandler.checkMinions();
  if (!player.worldObj.isRemote) {
    if (gettingSundamage()) {
      handleSunDamage();
    }
 else {
      if (ticksInSun > 0) {
        ticksInSun--;
      }
    }
    if (player.isPotionActive(ModPotion.sanguinare.id)) {
      player.removePotionEffect(ModPotion.sanguinare.id);
    }
    if (sleepingCoffin && !this.player.worldObj.isDaytime()) {
      Logger.i(""String_Node_Str"",""String_Node_Str"" + sleepingCoffin);
      sleepingCoffin=false;
      this.sync(true);
      this.player.wakeUpPlayer(false,true,true);
    }
  }
 else {
    if (gettingSundamage()) {
      ticksInSun++;
    }
 else {
      if (ticksInSun > 0) {
        ticksInSun--;
      }
    }
  }
  for (int i=0; i < skillTimer.length; i++) {
    int t=skillTimer[i];
    if (t != 0) {
      if (t < 0) {
        skillTimer[i]=++t;
      }
 else {
        skillTimer[i]=--t;
        ILastingSkill s=(ILastingSkill)Skills.getSkill(i);
        if (t == 0) {
          skillTimer[i]=-s.getCooldown();
          if (!isRemote()) {
            s.onDeactivated(this,player);
            dirty=true;
          }
        }
 else {
          if (s.onUpdate(this,player)) {
            skillTimer[i]=1;
          }
        }
      }
    }
  }
  if (batTransformed != this.isSkillActive(Skills.batMode)) {
    batTransformed=!batTransformed;
    VampirismMod.proxy.setPlayerBat(player,batTransformed);
  }
  if (minionTarget != null && !minionTarget.isEntityAlive()) {
    minionTarget=null;
  }
  if (dirty == true) {
    this.sync(true);
    dirty=false;
  }
}","/** 
 * Called every LivingEntityUpdate, returns immediately if level =0;
 */
public void onUpdate(){
  if (this.sleepingCoffin && player.isPlayerSleeping()) {
    if (player.worldObj.isRemote)     Logger.i(""String_Node_Str"",""String_Node_Str"" + player.posY);
    if (!player.worldObj.isRemote)     player.motionY=0;
 else     if (player.posY > Math.floor(player.posY) + 0.2)     player.motionY=-0.05;
 else     player.motionY=0;
  }
  if (getLevel() <= 0) {
    PotionEffect sang=player.getActivePotionEffect(ModPotion.sanguinare);
    if (sang != null) {
      if (sang.getDuration() == 1) {
        this.levelUp();
        player.addPotionEffect(new PotionEffect(ModPotion.saturation.id,300,2));
        player.addPotionEffect(new PotionEffect(Potion.resistance.id,300));
      }
    }
    return;
  }
  this.bloodStats.onUpdate();
  this.minionHandler.checkMinions();
  if (!player.worldObj.isRemote) {
    if (gettingSundamage()) {
      handleSunDamage();
    }
 else {
      if (ticksInSun > 0) {
        ticksInSun--;
      }
    }
    if (player.isPotionActive(ModPotion.sanguinare.id)) {
      player.removePotionEffect(ModPotion.sanguinare.id);
    }
    if (sleepingCoffin && !this.player.worldObj.isDaytime()) {
      Logger.i(""String_Node_Str"",""String_Node_Str"" + sleepingCoffin);
      this.wakeUpPlayer(true,false,true,true);
    }
  }
 else {
    if (gettingSundamage()) {
      ticksInSun++;
    }
 else {
      if (ticksInSun > 0) {
        ticksInSun--;
      }
    }
  }
  for (int i=0; i < skillTimer.length; i++) {
    int t=skillTimer[i];
    if (t != 0) {
      if (t < 0) {
        skillTimer[i]=++t;
      }
 else {
        skillTimer[i]=--t;
        ILastingSkill s=(ILastingSkill)Skills.getSkill(i);
        if (t == 0) {
          skillTimer[i]=-s.getCooldown();
          if (!isRemote()) {
            s.onDeactivated(this,player);
            dirty=true;
          }
        }
 else {
          if (s.onUpdate(this,player)) {
            skillTimer[i]=1;
          }
        }
      }
    }
  }
  if (batTransformed != this.isSkillActive(Skills.batMode)) {
    batTransformed=!batTransformed;
    VampirismMod.proxy.setPlayerBat(player,batTransformed);
  }
  if (minionTarget != null && !minionTarget.isEntityAlive()) {
    minionTarget=null;
  }
  if (dirty == true) {
    this.sync(true);
    dirty=false;
  }
}"
12760,"@SubscribeEvent public void onServerTick(TickEvent.ServerTickEvent event){
  WorldServer server=MinecraftServer.getServer().worldServerForDimension(0);
  if (server.areAllPlayersAsleep()) {
    Logger.i(""String_Node_Str"",""String_Node_Str"");
    long i=server.getWorldTime() + 24000L;
    server.setWorldTime(i - i % 24000L - 11000L);
    wakeAllPlayers(server);
  }
}","@SubscribeEvent public void onServerTick(TickEvent.ServerTickEvent event){
  WorldServer server=MinecraftServer.getServer().worldServerForDimension(0);
  if (server.areAllPlayersAsleep()) {
    Logger.i(""String_Node_Str"",""String_Node_Str"");
    if (server.playerEntities.size() > 0) {
      if (VampirePlayer.get(((EntityPlayer)server.playerEntities.get(0))).sleepingCoffin) {
        Logger.i(""String_Node_Str"",""String_Node_Str"");
        long i=server.getWorldTime() + 24000L;
        server.setWorldTime(i - i % 24000L - 11000L);
        wakeAllPlayers(server);
      }
 else {
        Logger.i(""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
}"
12761,"private void wakeAllPlayers(WorldServer server){
  this.allPlayersSleepingCoffin=false;
  Iterator iterator=server.playerEntities.iterator();
  while (iterator.hasNext()) {
    EntityPlayerMP p=(EntityPlayerMP)iterator.next();
    VampirePlayer.get(p).sleepingCoffin=false;
    VampirePlayer.get(p).sync(true);
    p.wakeUpPlayer(false,false,true);
  }
}","private void wakeAllPlayers(WorldServer server){
  Iterator iterator=server.playerEntities.iterator();
  while (iterator.hasNext()) {
    EntityPlayerMP p=(EntityPlayerMP)iterator.next();
    VampirePlayer.get(p).wakeUpPlayer(true,false,false,true);
  }
}"
12762,"@Override public boolean onBlockActivated(World world,int x,int y,int z,EntityPlayer player,int par4,float f1,float f2,float f3){
  if (world.isRemote) {
    return true;
  }
 else {
    if ((world.getBlockMetadata(x,y,z) & -8) == 0) {
      TileEntityCoffin te=(TileEntityCoffin)world.getTileEntity(x,y,z);
      x=te.otherX;
      y=te.otherY;
      z=te.otherZ;
    }
    if (world.provider.canRespawnHere() && world.getBiomeGenForCoords(x,z) != BiomeGenBase.hell) {
      if ((world.getBlockMetadata(x,y,z) & 4) != 0) {
        player.addChatComponentMessage(new ChatComponentTranslation(""String_Node_Str"",new Object[0]));
        return true;
      }
      EntityPlayer.EnumStatus enumstatus=VampirePlayer.get(player).sleepInCoffinAt(x,y,z);
      if (enumstatus == EntityPlayer.EnumStatus.OK) {
        setBedOccupied(world,x,y,z,player,true);
        ((TileEntityCoffin)world.getTileEntity(x,y,z)).markDirty();
        return true;
      }
 else {
        if (enumstatus == EntityPlayer.EnumStatus.NOT_POSSIBLE_NOW) {
          player.addChatComponentMessage(new ChatComponentTranslation(""String_Node_Str"",new Object[0]));
        }
 else         if (enumstatus == EntityPlayer.EnumStatus.NOT_SAFE) {
          player.addChatComponentMessage(new ChatComponentTranslation(""String_Node_Str"",new Object[0]));
        }
        return true;
      }
    }
 else {
      double d2=x + 0.5D;
      double d0=y + 0.5D;
      double d1=z + 0.5D;
      world.setBlockToAir(x,y,z);
      if (world.getBlock(x,y,z) == this) {
        world.setBlockToAir(x,y,z);
        d2=(d2 + x + 0.5D) / 2.0D;
        d0=(d0 + y + 0.5D) / 2.0D;
        d1=(d1 + z + 0.5D) / 2.0D;
      }
      world.newExplosion((Entity)null,x + 0.5F,y + 0.5F,z + 0.5F,5.0F,true,true);
      return true;
    }
  }
}","@Override public boolean onBlockActivated(World world,int x,int y,int z,EntityPlayer player,int par4,float f1,float f2,float f3){
  Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",x,y,z,world.isRemote,world.getBlockMetadata(x,y,z)));
  if (world.isRemote) {
    return true;
  }
 else {
    if ((world.getBlockMetadata(x,y,z) & -8) == 0) {
      TileEntityCoffin te=(TileEntityCoffin)world.getTileEntity(x,y,z);
      x=te.otherX;
      y=te.otherY;
      z=te.otherZ;
    }
    if (world.provider.canRespawnHere() && world.getBiomeGenForCoords(x,z) != BiomeGenBase.hell) {
      if ((world.getBlockMetadata(x,y,z) & 4) != 0) {
        player.addChatComponentMessage(new ChatComponentTranslation(""String_Node_Str"",new Object[0]));
        return true;
      }
      EntityPlayer.EnumStatus enumstatus=VampirePlayer.get(player).sleepInCoffinAt(x,y,z);
      if (enumstatus == EntityPlayer.EnumStatus.OK) {
        setCoffinOccupied(world,x,y,z,player,true);
        Logger.i(""String_Node_Str"",String.format(""String_Node_Str"",x,y,z,world.isRemote,world.getBlockMetadata(x,y,z)));
        return true;
      }
 else {
        if (enumstatus == EntityPlayer.EnumStatus.NOT_POSSIBLE_NOW) {
          player.addChatComponentMessage(new ChatComponentTranslation(""String_Node_Str"",new Object[0]));
        }
 else         if (enumstatus == EntityPlayer.EnumStatus.NOT_SAFE) {
          player.addChatComponentMessage(new ChatComponentTranslation(""String_Node_Str"",new Object[0]));
        }
        return true;
      }
    }
 else {
      double d2=x + 0.5D;
      double d0=y + 0.5D;
      double d1=z + 0.5D;
      world.setBlockToAir(x,y,z);
      if (world.getBlock(x,y,z) == this) {
        world.setBlockToAir(x,y,z);
        d2=(d2 + x + 0.5D) / 2.0D;
        d0=(d0 + y + 0.5D) / 2.0D;
        d1=(d1 + z + 0.5D) / 2.0D;
      }
      world.newExplosion((Entity)null,x + 0.5F,y + 0.5F,z + 0.5F,5.0F,true,true);
      return true;
    }
  }
}"
12763,"@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float scale){
  if (te instanceof TileEntityCoffin)   if ((te.getWorldObj().getBlockMetadata(te.xCoord,te.yCoord,te.zCoord) & (-8)) == 0) {
    return;
  }
  boolean occupied=(te.getWorldObj().getBlockMetadata(te.xCoord,te.yCoord,te.zCoord) & 4) != 0;
  if (!occupied && lidPosition > 0)   lidPosition--;
 else   if (occupied && lidPosition < maxLidPos)   lidPosition++;
  Logger.i(""String_Node_Str"",""String_Node_Str"" + lidPosition + ""String_Node_Str""+ occupied);
  GL11.glPushMatrix();
  GL11.glTranslatef((float)x + 0.5F,(float)y + 1.5F,(float)z + 0.5F);
  bindTexture(texture);
  GL11.glPushMatrix();
  adjustRotatePivotViaMeta(te.getWorldObj(),te.xCoord,te.yCoord,te.zCoord);
  GL11.glRotatef(180F,0.0F,0.0F,1.0F);
  model.rotateLid(calcLidAngle(lidPosition));
  model.render(null,0.0F,0.0F,-0.1F,0.0F,0.0F,0.0625F);
  GL11.glPopMatrix();
  GL11.glPopMatrix();
}","@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float scale){
  TileEntityCoffin tile=(TileEntityCoffin)te;
  if (te instanceof TileEntityCoffin)   if ((te.getBlockMetadata() & (-8)) == 0) {
    return;
  }
  boolean occupied=(te.getBlockMetadata() & 4) != 0;
  if (!occupied && tile.lidPos > 0)   tile.lidPos--;
 else   if (occupied && tile.lidPos < maxLidPos)   tile.lidPos++;
  GL11.glPushMatrix();
  GL11.glTranslatef((float)x + 0.5F,(float)y + 1.5F,(float)z + 0.5F);
  bindTexture(texture);
  GL11.glPushMatrix();
  adjustRotatePivotViaMeta(te.getWorldObj(),te.xCoord,te.yCoord,te.zCoord);
  GL11.glRotatef(180F,0.0F,0.0F,1.0F);
  model.rotateLid(calcLidAngle(tile.lidPos));
  model.render(null,0.0F,0.0F,-0.1F,0.0F,0.0F,0.0625F);
  GL11.glPopMatrix();
  GL11.glPopMatrix();
}"
12764,"public void readFromNBT(NBTTagCompound par1NBTTagCompound){
  super.readFromNBT(par1NBTTagCompound);
  this.otherX=par1NBTTagCompound.getInteger(""String_Node_Str"");
  this.otherY=par1NBTTagCompound.getInteger(""String_Node_Str"");
  this.otherZ=par1NBTTagCompound.getInteger(""String_Node_Str"");
}","public void readFromNBT(NBTTagCompound par1NBTTagCompound){
  super.readFromNBT(par1NBTTagCompound);
  this.otherX=par1NBTTagCompound.getInteger(""String_Node_Str"");
  this.otherY=par1NBTTagCompound.getInteger(""String_Node_Str"");
  this.otherZ=par1NBTTagCompound.getInteger(""String_Node_Str"");
  this.occupied=par1NBTTagCompound.getBoolean(""String_Node_Str"");
}"
12765,"public void writeToNBT(NBTTagCompound par1NBTTagCompound){
  super.writeToNBT(par1NBTTagCompound);
  par1NBTTagCompound.setInteger(""String_Node_Str"",otherX);
  par1NBTTagCompound.setInteger(""String_Node_Str"",otherY);
  par1NBTTagCompound.setInteger(""String_Node_Str"",otherZ);
}","public void writeToNBT(NBTTagCompound par1NBTTagCompound){
  super.writeToNBT(par1NBTTagCompound);
  par1NBTTagCompound.setInteger(""String_Node_Str"",otherX);
  par1NBTTagCompound.setInteger(""String_Node_Str"",otherY);
  par1NBTTagCompound.setInteger(""String_Node_Str"",otherZ);
  par1NBTTagCompound.setBoolean(""String_Node_Str"",occupied);
}"
12766,"public byte[] applyPatch(String name,byte[] basicClass,boolean obfuscated){
  String iPAMethodName=""String_Node_Str"";
  if (obfuscated) {
    iPAMethodName=METHOD_IPA_NOTCH;
  }
 else {
    iPAMethodName=METHOD_IPA;
  }
  ClassNode classNode=new ClassNode();
  ClassReader classReader=new ClassReader(basicClass);
  classReader.accept(classNode,0);
  Iterator<MethodNode> methods=classNode.methods.iterator();
  while (methods.hasNext()) {
    MethodNode m=methods.next();
    if (m.name.equals(iPAMethodName) && m.desc.equals(""String_Node_Str"" + CLASS_POTION_SRG + ""String_Node_Str"")) {
      Logger.i(TAG,""String_Node_Str"");
      InsnList toIn=new InsnList();
      toIn.add(new VarInsnNode(Opcodes.ALOAD,0));
      toIn.add(new VarInsnNode(Opcodes.ALOAD,1));
      toIn.add(new MethodInsnNode(Opcodes.INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + CLASS_POTION_SRG + ""String_Node_Str"",false));
      LabelNode l1=new LabelNode();
      toIn.add(new JumpInsnNode(Opcodes.IFEQ,l1));
      LabelNode l2=new LabelNode();
      toIn.add(l2);
      toIn.add(new InsnNode(Opcodes.ICONST_1));
      toIn.add(new InsnNode(Opcodes.IRETURN));
      toIn.add(l1);
      toIn.add(new FrameNode(Opcodes.F_SAME,0,null,0,null));
      m.instructions.insert(toIn);
      Logger.i(TAG,""String_Node_Str"");
      break;
    }
  }
  ClassWriter writer=new ClassWriter(ClassWriter.COMPUTE_MAXS);
  classNode.accept(writer);
  return writer.toByteArray();
}","public byte[] applyPatch(String name,byte[] basicClass,boolean obfuscated){
  String iPAMethodName=""String_Node_Str"";
  if (obfuscated) {
    iPAMethodName=METHOD_IPA_MCP;
  }
 else {
    iPAMethodName=METHOD_IPA;
  }
  String gAPMethodName=""String_Node_Str"";
  if (obfuscated) {
    gAPMethodName=METHOD_GAP_MCP;
  }
 else {
    gAPMethodName=METHOD_GAP;
  }
  ClassNode classNode=new ClassNode();
  ClassReader classReader=new ClassReader(basicClass);
  classReader.accept(classNode,0);
  Iterator<MethodNode> methods=classNode.methods.iterator();
  while (methods.hasNext()) {
    MethodNode m=methods.next();
    if (m.name.equals(iPAMethodName) && m.desc.equals(""String_Node_Str"" + CLASS_POTION_SRG + ""String_Node_Str"")) {
      Logger.i(TAG,""String_Node_Str"");
      InsnList toIn=new InsnList();
      toIn.add(new VarInsnNode(Opcodes.ALOAD,0));
      toIn.add(new VarInsnNode(Opcodes.ALOAD,1));
      toIn.add(new MethodInsnNode(Opcodes.INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + CLASS_POTION_SRG + ""String_Node_Str"",false));
      LabelNode l1=new LabelNode();
      toIn.add(new JumpInsnNode(Opcodes.IFEQ,l1));
      LabelNode l2=new LabelNode();
      toIn.add(l2);
      toIn.add(new InsnNode(Opcodes.ICONST_1));
      toIn.add(new InsnNode(Opcodes.IRETURN));
      toIn.add(l1);
      toIn.add(new FrameNode(Opcodes.F_SAME,0,null,0,null));
      m.instructions.insert(toIn);
      Logger.i(TAG,""String_Node_Str"");
    }
 else     if (m.name.equals(gAPMethodName)) {
      Logger.i(TAG,""String_Node_Str"");
      InsnList toIn=new InsnList();
      LabelNode l0=new LabelNode();
      toIn.add(l0);
      toIn.add(new VarInsnNode(Opcodes.ALOAD,0));
      toIn.add(new VarInsnNode(Opcodes.ALOAD,1));
      toIn.add(new MethodInsnNode(Opcodes.INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + CLASS_POTION_SRG + ""String_Node_Str"",false));
      LabelNode l1=new LabelNode();
      toIn.add(new JumpInsnNode(Opcodes.IFEQ,l1));
      LabelNode l2=new LabelNode();
      toIn.add(l2);
      toIn.add(new MethodInsnNode(Opcodes.INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + CLASS_POTIONEFFECT_SRG + ""String_Node_Str"",false));
      toIn.add(new InsnNode(Opcodes.ARETURN));
      toIn.add(l1);
      m.instructions.insert(toIn);
      Logger.i(TAG,""String_Node_Str"");
    }
  }
  ClassWriter writer=new ClassWriter(ClassWriter.COMPUTE_MAXS);
  classNode.accept(writer);
  return writer.toByteArray();
}"
12767,"/** 
 * Called every LivingEntityUpdate, returns immediately if level =0;
 */
public void onUpdate(){
  if (getLevel() <= 0) {
    PotionEffect sang=player.getActivePotionEffect(ModPotion.sanguinare);
    if (sang != null) {
      if (sang.getDuration() == 1) {
        this.levelUp();
        player.addPotionEffect(new PotionEffect(ModPotion.saturation.id,300,2));
        player.addPotionEffect(new PotionEffect(Potion.resistance.id,300));
      }
    }
    return;
  }
  this.bloodStats.onUpdate();
  if (!player.worldObj.isRemote) {
    if (gettingSundamage() && player.worldObj.rand.nextInt(40) == 10) {
      float dmg=BALANCE.getVampireSunDamage(getLevel());
      if (player.isPotionActive(ModPotion.sunscreen)) {
        dmg=dmg / 2;
      }
      player.attackEntityFrom(VampirismMod.sunDamage,dmg);
    }
    if (player.isPotionActive(ModPotion.sanguinare.id)) {
      player.removePotionEffect(ModPotion.sanguinare.id);
    }
    if (this.player.isPlayerSleeping()) {
      Helper.Reflection.setPrivateField(EntityPlayer.class,this.player,this.player.getSleepTimer() + 1,Helper.Obfuscation.getPosNames(""String_Node_Str""));
    }
    if (this.player.getSleepTimer() > 100) {
      Helper.Reflection.setPrivateField(EntityPlayer.class,this.player,100,Helper.Obfuscation.getPosNames(""String_Node_Str""));
    }
    if (!this.player.worldObj.isRemote) {
      if (!this.player.worldObj.isDaytime()) {
        this.player.wakeUpPlayer(false,true,true);
      }
    }
  }
  for (int i=0; i < skillTimer.length; i++) {
    int t=skillTimer[i];
    if (t != 0) {
      if (t < 0) {
        skillTimer[i]=++t;
      }
 else {
        skillTimer[i]=--t;
        ILastingSkill s=(ILastingSkill)Skills.getSkill(i);
        if (t == 0) {
          skillTimer[i]=-s.getCooldown();
          if (!isRemote()) {
            s.onDeactivated(this,player);
            dirty=true;
          }
        }
 else {
          if (s.onUpdate(this,player)) {
            skillTimer[i]=1;
          }
        }
      }
    }
  }
  if (batTransformed != this.isSkillActive(Skills.batMode)) {
    batTransformed=!batTransformed;
    VampirismMod.proxy.setPlayerBat(player,batTransformed);
  }
  if (minionTarget != null && !minionTarget.isEntityAlive()) {
    minionTarget=null;
  }
  if (dirty == true) {
    this.sync(true);
    dirty=false;
  }
}","/** 
 * Called every LivingEntityUpdate, returns immediately if level =0;
 */
public void onUpdate(){
  if (getLevel() <= 0) {
    PotionEffect sang=player.getActivePotionEffect(ModPotion.sanguinare);
    if (sang != null) {
      if (sang.getDuration() == 1) {
        this.levelUp();
        player.addPotionEffect(new PotionEffect(ModPotion.saturation.id,300,2));
        player.addPotionEffect(new PotionEffect(Potion.resistance.id,300));
      }
    }
    return;
  }
  this.bloodStats.onUpdate();
  if (!player.worldObj.isRemote) {
    if (gettingSundamage() && player.worldObj.rand.nextInt(40) == 10) {
      float dmg=BALANCE.getVampireSunDamage(getLevel());
      if (player.isPotionActive(ModPotion.sunscreen)) {
        dmg=dmg / 2;
      }
      player.attackEntityFrom(VampirismMod.sunDamage,dmg);
    }
    if (player.isPotionActive(ModPotion.sanguinare.id)) {
      player.removePotionEffect(ModPotion.sanguinare.id);
    }
    if (!this.player.worldObj.isDaytime()) {
      sleepingCoffin=false;
    }
  }
  for (int i=0; i < skillTimer.length; i++) {
    int t=skillTimer[i];
    if (t != 0) {
      if (t < 0) {
        skillTimer[i]=++t;
      }
 else {
        skillTimer[i]=--t;
        ILastingSkill s=(ILastingSkill)Skills.getSkill(i);
        if (t == 0) {
          skillTimer[i]=-s.getCooldown();
          if (!isRemote()) {
            s.onDeactivated(this,player);
            dirty=true;
          }
        }
 else {
          if (s.onUpdate(this,player)) {
            skillTimer[i]=1;
          }
        }
      }
    }
  }
  if (batTransformed != this.isSkillActive(Skills.batMode)) {
    batTransformed=!batTransformed;
    VampirismMod.proxy.setPlayerBat(player,batTransformed);
  }
  if (minionTarget != null && !minionTarget.isEntityAlive()) {
    minionTarget=null;
  }
  if (dirty == true) {
    this.sync(true);
    dirty=false;
  }
}"
12768,"public void onDeath(DamageSource source){
  if (BALANCE.VAMPIRE_PLAYER_LOOSE_LEVEL && source.damageType.equals(""String_Node_Str"") && source instanceof EntityDamageSource) {
    Entity src=source.getEntity();
    if (src instanceof EntityVampireHunter) {
      looseLevel();
      this.setVampireLord(false);
    }
    if (src instanceof EntityVampire || (src instanceof IMinion && ((IMinion)src).getLord() instanceof EntityLiving)) {
      EntityLiving old;
      if (src instanceof IMinion) {
        old=(EntityLiving)((IMinion)src).getLord();
      }
 else {
        old=(EntityLiving)src;
      }
      EntityDracula dracula=(EntityDracula)EntityList.createEntityByName(REFERENCE.ENTITY.DRACULA_NAME,old.worldObj);
      dracula.copyLocationAndAnglesFrom(old);
      dracula.makeDisappear();
      old.worldObj.spawnEntityInWorld(dracula);
      old.setDead();
      this.setVampireLord(false);
    }
  }
  for (int i=0; i < skillTimer.length; i++) {
    if (skillTimer[i] > 0) {
      skillTimer[i]=-Skills.getSkill(i).getCooldown();
      ((ILastingSkill)Skills.getSkill(i)).onDeactivated(this,player);
    }
  }
}","public void onDeath(DamageSource source){
  if (BALANCE.VAMPIRE_PLAYER_LOOSE_LEVEL && source.damageType.equals(""String_Node_Str"") && source instanceof EntityDamageSource) {
    Entity src=source.getEntity();
    if (src instanceof EntityVampireHunter) {
      looseLevel();
      this.setVampireLord(false);
    }
    if (isVampireLord() && src instanceof EntityVampire || (src instanceof IMinion && ((IMinion)src).getLord() instanceof EntityLiving)) {
      EntityLiving old;
      if (src instanceof IMinion) {
        old=(EntityLiving)((IMinion)src).getLord();
      }
 else {
        old=(EntityLiving)src;
      }
      EntityDracula dracula=(EntityDracula)EntityList.createEntityByName(REFERENCE.ENTITY.DRACULA_NAME,old.worldObj);
      dracula.copyLocationAndAnglesFrom(old);
      dracula.makeDisappear();
      old.worldObj.spawnEntityInWorld(dracula);
      old.setDead();
      this.setVampireLord(false);
    }
  }
  for (int i=0; i < skillTimer.length; i++) {
    if (skillTimer[i] > 0) {
      skillTimer[i]=-Skills.getSkill(i).getCooldown();
      ((ILastingSkill)Skills.getSkill(i)).onDeactivated(this,player);
    }
  }
}"
12769,"@Override public void registerEntitys(){
  int entityId=0;
  BiomeGenBase[] allBiomes=BiomeGenBase.getBiomeGenArray();
  allBiomes[9]=null;
  allBiomes[8]=null;
  BiomeGenBase[] biomes=Iterators.toArray(Iterators.filter(Iterators.forArray(allBiomes),Predicates.notNull()),BiomeGenBase.class);
  registerEntity(EntityVampireHunter.class,REFERENCE.ENTITY.VAMPIRE_HUNTER_NAME,BALANCE.VAMPIRE_HUNTER_SPAWN_PROBE,1,2,EnumCreatureType.creature,biomes);
  registerEntity(EntityVampire.class,REFERENCE.ENTITY.VAMPIRE_NAME,BALANCE.VAMPIRE_SPAWN_PROBE,1,3,EnumCreatureType.monster,biomes);
  registerEntity(EntityVampireLord.class,REFERENCE.ENTITY.VAMPIRE_LORD_NAME,BALANCE.VAMPIRE_LORD_SPAWN_PROBE,1,1,EnumCreatureType.monster,ModBiomes.biomeVampireForest);
  registerEntity(EntityVampireMinion.class,REFERENCE.ENTITY.VAMPIRE_MINION_NAME,false);
  registerEntity(EntityDeadMob.class,REFERENCE.ENTITY.DEAD_MOB_NAME,false);
  registerEntity(EntityGhost.class,REFERENCE.ENTITY.GHOST_NAME,5,1,2,EnumCreatureType.monster,ModBiomes.biomeVampireForest);
}","@Override public void registerEntitys(){
  int entityId=0;
  BiomeGenBase[] allBiomes=BiomeGenBase.getBiomeGenArray();
  allBiomes[9]=null;
  allBiomes[8]=null;
  BiomeGenBase[] biomes=Iterators.toArray(Iterators.filter(Iterators.forArray(allBiomes),Predicates.notNull()),BiomeGenBase.class);
  registerEntity(EntityVampireHunter.class,REFERENCE.ENTITY.VAMPIRE_HUNTER_NAME,BALANCE.VAMPIRE_HUNTER_SPAWN_PROBE,1,2,EnumCreatureType.creature,biomes);
  registerEntity(EntityVampire.class,REFERENCE.ENTITY.VAMPIRE_NAME,BALANCE.VAMPIRE_SPAWN_PROBE,1,3,EnumCreatureType.monster,biomes);
  registerEntity(EntityVampireLord.class,REFERENCE.ENTITY.VAMPIRE_LORD_NAME,BALANCE.VAMPIRE_LORD_SPAWN_PROBE,1,1,EnumCreatureType.monster,ModBiomes.biomeVampireForest);
  registerEntity(EntityVampireMinion.class,REFERENCE.ENTITY.VAMPIRE_MINION_NAME,false);
  registerEntity(EntityDeadMob.class,REFERENCE.ENTITY.DEAD_MOB_NAME,false);
  registerEntity(EntityDracula.class,REFERENCE.ENTITY.DRACULA_NAME,false);
  registerEntity(EntityGhost.class,REFERENCE.ENTITY.GHOST_NAME,5,1,2,EnumCreatureType.monster,ModBiomes.biomeVampireForest);
}"
12770,"@SubscribeEvent public void onEntityJoinWorld(EntityJoinWorldEvent event){
  if (!event.entity.worldObj.isRemote && event.entity instanceof IAdjustableLevel) {
    IAdjustableLevel e=(IAdjustableLevel)event.entity;
    if (e.getLevel() == 0) {
      Difficulty d=DifficultyCalculator.getLocalDifficulty(event.world,event.entity.posX,event.entity.posZ,10);
      if (d.isZero()) {
        d=DifficultyCalculator.getWorldDifficulty(event.entity.worldObj);
      }
      int l=e.suggestLevel(d);
      if (l > e.getMaxLevel()) {
        l=e.getMaxLevel();
      }
 else       if (l < 1) {
        if (event.entity.worldObj.rand.nextBoolean()) {
          event.setCanceled(true);
        }
        l=1;
      }
      e.setLevel(l);
    }
  }
  if (event.world.isRemote) {
    if (event.entity instanceof ISyncable || event.entity instanceof EntityCreature) {
      VampirismMod.modChannel.sendToServer(new RequestEntityUpdatePacket(event.entity));
    }
  }
  if (event.entity instanceof EntityVampireHunter) {
    EntityVampireHunter e=(EntityVampireHunter)event.entity;
    if (e.isLookingForHome() == false)     return;
    Village v=event.world.villageCollectionObj.findNearestVillage(MathHelper.floor_double(e.posX),MathHelper.floor_double(e.posY),MathHelper.floor_double(e.posZ),20);
    if (v != null) {
      int r=v.getVillageRadius();
      AxisAlignedBB box=AxisAlignedBB.getBoundingBox(v.getCenter().posX - r,0,v.getCenter().posZ - r,v.getCenter().posX + r,event.world.getActualHeight(),v.getCenter().posZ + r);
      ChunkCoordinates cc=v.getCenter();
      e.setHomeArea(cc.posX,cc.posY,cc.posZ,r);
    }
  }
 else   if (event.entity instanceof EntityIronGolem) {
    EntityIronGolem golem=(EntityIronGolem)event.entity;
    EntityAITasks targetTasks=golem.targetTasks;
    if (targetTasks == null) {
      Logger.w(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      for (      Object o : targetTasks.taskEntries) {
        EntityAIBase t=((EntityAITasks.EntityAITaskEntry)o).action;
        if (t instanceof EntityAINearestAttackableTarget) {
          targetTasks.removeTask(t);
          targetTasks.addTask(3,new EntityAINearestAttackableTarget(golem,EntityLiving.class,0,false,true,new IEntitySelector(){
            @Override public boolean isEntityApplicable(            Entity entity){
              if (entity instanceof IMob && !(entity instanceof EntityVampireHunter)) {
                return true;
              }
              return false;
            }
          }
));
          break;
        }
      }
    }
  }
 else   if (event.entity instanceof EntityCreeper) {
    EntityCreeper creeper=(EntityCreeper)event.entity;
    EntityAITasks tasks=creeper.tasks;
    if (tasks == null) {
      Logger.w(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      tasks.addTask(3,new EntityAIAvoidVampirePlayer(creeper,12.0F,1.0D,1.2D,BALANCE.VAMPIRE_PLAYER_CREEPER_AVOID_LEVEL));
    }
  }
}","@SubscribeEvent public void onEntityJoinWorld(EntityJoinWorldEvent event){
  if (!event.entity.worldObj.isRemote && event.entity instanceof IAdjustableLevel) {
    IAdjustableLevel e=(IAdjustableLevel)event.entity;
    if (e.getLevel() == 0) {
      Difficulty d=DifficultyCalculator.getLocalDifficulty(event.world,event.entity.posX,event.entity.posZ,10);
      if (d.isZero()) {
        d=DifficultyCalculator.getWorldDifficulty(event.entity.worldObj);
      }
      int l=e.suggestLevel(d);
      if (l > e.getMaxLevel()) {
        l=e.getMaxLevel();
      }
 else       if (l < 1) {
        if (event.entity.worldObj.rand.nextBoolean()) {
          event.setCanceled(true);
        }
        l=1;
      }
      e.setLevel(l);
    }
  }
  if (event.world.isRemote) {
    if (event.entity instanceof ISyncable || event.entity instanceof EntityCreature) {
      VampirismMod.modChannel.sendToServer(new RequestEntityUpdatePacket(event.entity));
    }
  }
  if (event.entity instanceof EntityVampireHunter) {
    EntityVampireHunter e=(EntityVampireHunter)event.entity;
    if (e.isLookingForHome() == false)     return;
    if (event.world.villageCollectionObj != null) {
      Village v=event.world.villageCollectionObj.findNearestVillage(MathHelper.floor_double(e.posX),MathHelper.floor_double(e.posY),MathHelper.floor_double(e.posZ),20);
      if (v != null) {
        int r=v.getVillageRadius();
        AxisAlignedBB box=AxisAlignedBB.getBoundingBox(v.getCenter().posX - r,0,v.getCenter().posZ - r,v.getCenter().posX + r,event.world.getActualHeight(),v.getCenter().posZ + r);
        ChunkCoordinates cc=v.getCenter();
        e.setHomeArea(cc.posX,cc.posY,cc.posZ,r);
      }
    }
  }
 else   if (event.entity instanceof EntityIronGolem) {
    EntityIronGolem golem=(EntityIronGolem)event.entity;
    EntityAITasks targetTasks=golem.targetTasks;
    if (targetTasks == null) {
      Logger.w(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      for (      Object o : targetTasks.taskEntries) {
        EntityAIBase t=((EntityAITasks.EntityAITaskEntry)o).action;
        if (t instanceof EntityAINearestAttackableTarget) {
          targetTasks.removeTask(t);
          targetTasks.addTask(3,new EntityAINearestAttackableTarget(golem,EntityLiving.class,0,false,true,new IEntitySelector(){
            @Override public boolean isEntityApplicable(            Entity entity){
              if (entity instanceof IMob && !(entity instanceof EntityVampireHunter)) {
                return true;
              }
              return false;
            }
          }
));
          break;
        }
      }
    }
  }
 else   if (event.entity instanceof EntityCreeper) {
    EntityCreeper creeper=(EntityCreeper)event.entity;
    EntityAITasks tasks=creeper.tasks;
    if (tasks == null) {
      Logger.w(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      tasks.addTask(3,new EntityAIAvoidVampirePlayer(creeper,12.0F,1.0D,1.2D,BALANCE.VAMPIRE_PLAYER_CREEPER_AVOID_LEVEL));
    }
  }
}"
12771,"@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float par5){
  TileEntityBloodAltarTier4 te4=(TileEntityBloodAltarTier4)te;
  GL11.glPushMatrix();
  GL11.glTranslatef((float)x + 0.5F,(float)y + 1.5F,(float)z + 0.5F);
  bindTexture(texture);
  GL11.glPushMatrix();
  adjustRotatePivotViaMeta(te.getWorldObj(),te.xCoord,te.yCoord,te.zCoord);
  GL11.glRotatef(180F,0.0F,0.0F,1.0F);
  model.render(null,0.0F,0.0F,-0.1F,0.0F,0.0F,0.0625F);
  GL11.glPopMatrix();
  GL11.glPopMatrix();
  PHASE phase=te4.getPhase();
  if (phase == PHASE.BEAM1 || phase == PHASE.BEAM2) {
    x+=0.5;
    y+=3;
    z+=0.5;
    double cX=te.xCoord + 0.5;
    double cY=te.yCoord + 3;
    double cZ=te.zCoord + 0.5;
    try {
      ChunkCoordinates[] tips=te4.getTips();
      for (int i=0; i < tips.length; i++) {
        this.renderBeam(x,y,z,cX,cY,cZ,tips[i].posX + 0.5,tips[i].posY + 0.5,tips[i].posZ + 0.5,te4.getRunningTick() + par5,false);
      }
      if (phase == PHASE.BEAM2) {
        EntityPlayer p=te4.getPlayer();
        if (p != null) {
          this.renderBeam(0,-0.5,0,p.posX,p.posY,p.posZ,cX,cY + 0.2,cZ,-(te4.getRunningTick() + par5),true);
        }
      }
    }
 catch (    NullPointerException e) {
    }
  }
}","@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float par5){
  TileEntityBloodAltarTier4 te4=(TileEntityBloodAltarTier4)te;
  GL11.glPushMatrix();
  GL11.glTranslatef((float)x + 0.5F,(float)y + 1.5F,(float)z + 0.5F);
  bindTexture(texture);
  GL11.glPushMatrix();
  adjustRotatePivotViaMeta(te.getWorldObj(),te.xCoord,te.yCoord,te.zCoord);
  GL11.glRotatef(180F,0.0F,0.0F,1.0F);
  model.render(null,0.0F,0.0F,-0.1F,0.0F,0.0F,0.0625F);
  GL11.glPopMatrix();
  GL11.glPopMatrix();
  PHASE phase=te4.getPhase();
  if (phase == PHASE.BEAM1 || phase == PHASE.BEAM2) {
    x+=0.5;
    y+=3;
    z+=0.5;
    double cX=te.xCoord + 0.5;
    double cY=te.yCoord + 3;
    double cZ=te.zCoord + 0.5;
    try {
      ChunkCoordinates[] tips=te4.getTips();
      for (int i=0; i < tips.length; i++) {
        this.renderBeam(x,y,z,cX,cY,cZ,tips[i].posX + 0.5,tips[i].posY + 0.5,tips[i].posZ + 0.5,te4.getRunningTick() + par5,false);
      }
      if (phase == PHASE.BEAM2) {
        EntityPlayer p=te4.getPlayer();
        if (p != null) {
          double rX=0, rZ=0;
          double rY=-0.3;
          double playerY=p.posY;
          if (!p.equals(Minecraft.getMinecraft().thePlayer)) {
            Entity e=Minecraft.getMinecraft().thePlayer;
            rX+=p.posX - e.posX;
            rY+=p.posY - e.posY + 1.5D;
            rZ+=p.posZ - e.posZ;
            playerY+=1.5D;
          }
          this.renderBeam(rX,rY,rZ,p.posX,playerY,p.posZ,cX,cY + 0.2,cZ,-(te4.getRunningTick() + par5),true);
        }
      }
    }
 catch (    NullPointerException e) {
    }
  }
}"
12772,"@Override public boolean generate(World world,Random rand,int x,int y,int z){
  if (!LocationIsValidSpawn(world,x,y,z) || !LocationIsValidSpawn(world,x + 2,y,z) || !LocationIsValidSpawn(world,x + 2,y,z + 2)|| !LocationIsValidSpawn(world,x,y,z + 2))   return false;
  Logger.i(""String_Node_Str"",""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ z);
  world.setBlock(x + 0,y + 0,z + 0,Blocks.obsidian,0,3);
  world.setBlock(x + 1,y + 0,z + 0,Blocks.obsidian,0,3);
  world.setBlock(x + 2,y + 0,z + 0,Blocks.obsidian,0,3);
  world.setBlock(x + 0,y + 0,z + 1,Blocks.obsidian,0,3);
  world.setBlock(x + 1,y + 0,z + 1,Blocks.obsidian,0,3);
  world.setBlock(x + 2,y + 0,z + 1,Blocks.obsidian,0,3);
  world.setBlock(x + 0,y + 0,z + 2,Blocks.obsidian,0,3);
  world.setBlock(x + 1,y + 0,z + 2,Blocks.obsidian,0,3);
  world.setBlock(x + 2,y + 0,z + 2,Blocks.obsidian,0,3);
  world.setBlock(x + 0,y + 1,z + 0,Blocks.air,0,3);
  world.setBlock(x + 1,y + 1,z + 0,Blocks.air,0,3);
  world.setBlock(x + 2,y + 1,z + 0,Blocks.air,0,3);
  world.setBlock(x + 0,y + 1,z + 1,Blocks.air,0,3);
  world.setBlock(x + 1,y + 1,z + 1,ModBlocks.bloodAltar,1,3);
  world.setBlock(x + 2,y + 1,z + 1,Blocks.air,0,3);
  world.setBlock(x + 0,y + 1,z + 2,Blocks.air,0,3);
  world.setBlock(x + 1,y + 1,z + 2,Blocks.air,0,3);
  world.setBlock(x + 2,y + 1,z + 2,Blocks.air,0,3);
  return true;
}","@Override public boolean generate(World world,Random rand,int x,int y,int z){
  if (!locationIsValidSpawn(world,x,y,z) || !locationIsValidSpawn(world,x + 2,y,z) || !locationIsValidSpawn(world,x + 2,y,z + 2)|| !locationIsValidSpawn(world,x,y,z + 2))   return false;
  Logger.i(""String_Node_Str"",""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ z);
  world.setBlock(x + 0,y + 0,z + 0,Blocks.obsidian,0,3);
  world.setBlock(x + 1,y + 0,z + 0,Blocks.obsidian,0,3);
  world.setBlock(x + 2,y + 0,z + 0,Blocks.obsidian,0,3);
  world.setBlock(x + 0,y + 0,z + 1,Blocks.obsidian,0,3);
  world.setBlock(x + 1,y + 0,z + 1,Blocks.obsidian,0,3);
  world.setBlock(x + 2,y + 0,z + 1,Blocks.obsidian,0,3);
  world.setBlock(x + 0,y + 0,z + 2,Blocks.obsidian,0,3);
  world.setBlock(x + 1,y + 0,z + 2,Blocks.obsidian,0,3);
  world.setBlock(x + 2,y + 0,z + 2,Blocks.obsidian,0,3);
  world.setBlock(x + 0,y + 1,z + 0,Blocks.air,0,3);
  world.setBlock(x + 1,y + 1,z + 0,Blocks.air,0,3);
  world.setBlock(x + 2,y + 1,z + 0,Blocks.air,0,3);
  world.setBlock(x + 0,y + 1,z + 1,Blocks.air,0,3);
  world.setBlock(x + 1,y + 1,z + 1,ModBlocks.bloodAltar,1,3);
  world.setBlock(x + 2,y + 1,z + 1,Blocks.air,0,3);
  world.setBlock(x + 0,y + 1,z + 2,Blocks.air,0,3);
  world.setBlock(x + 1,y + 1,z + 2,Blocks.air,0,3);
  world.setBlock(x + 2,y + 1,z + 2,Blocks.air,0,3);
  return true;
}"
12773,"@Override public void onLivingUpdate(){
  if (!this.worldObj.isRemote) {
    if (boss == null) {
      if (bossId != null) {
        lookForBoss();
      }
      if (boss == null) {
        lookForBossTimer++;
      }
      if (lookForBossTimer > MAX_SEARCH_TIME) {
        this.attackEntityFrom(DamageSource.generic,5);
      }
    }
 else     if (!boss.isEntityAlive()) {
      boss=null;
      bossId=null;
    }
 else     if (boss.getDistanceSquared(this) > 1000) {
      if (this.rand.nextInt(80) == 0) {
        this.attackEntityFrom(DamageSource.generic,3);
      }
    }
  }
  super.onLivingUpdate();
}","@Override public void onLivingUpdate(){
  if (!this.worldObj.isRemote) {
    if (boss == null) {
      if (bossId != null) {
        lookForBoss();
      }
      if (boss == null) {
        lookForBossTimer++;
      }
      if (lookForBossTimer > MAX_SEARCH_TIME) {
        this.attackEntityFrom(DamageSource.generic,5);
      }
    }
 else     if (!boss.isTheEntityAlive()) {
      boss=null;
      bossId=null;
    }
 else     if (boss.getTheDistanceSquared(this) > 1000) {
      if (this.rand.nextInt(80) == 0) {
        this.attackEntityFrom(DamageSource.generic,3);
      }
    }
  }
  super.onLivingUpdate();
}"
12774,"@Override public void setLord(IMinionLord b){
  if (!b.equals(boss)) {
    this.setBossId(b.getPersistentID());
    boss=b;
  }
}","@Override public void setLord(IMinionLord b){
  if (!b.equals(boss)) {
    this.setBossId(b.getThePersistentID());
    boss=b;
  }
}"
12775,"@Override public void loadPartialUpdate(NBTTagCompound nbt){
  if (nbt.hasKey(""String_Node_Str"")) {
    Entity e=worldObj.getEntityByID(nbt.getInteger(""String_Node_Str""));
    if (e instanceof EntityPlayer) {
      this.boss=VampirePlayer.get((EntityPlayer)e);
    }
 else     if (e instanceof IMinionLord) {
      this.boss=(IMinionLord)e;
    }
 else {
      Logger.w(""String_Node_Str"",""String_Node_Str"" + nbt.getInteger(""String_Node_Str"") + ""String_Node_Str""+ e+ ""String_Node_Str"");
      return;
    }
    this.bossId=this.boss.getPersistentID();
  }
}","@Override public void loadPartialUpdate(NBTTagCompound nbt){
  if (nbt.hasKey(""String_Node_Str"")) {
    Entity e=worldObj.getEntityByID(nbt.getInteger(""String_Node_Str""));
    if (e instanceof EntityPlayer) {
      this.boss=VampirePlayer.get((EntityPlayer)e);
    }
 else     if (e instanceof IMinionLord) {
      this.boss=(IMinionLord)e;
    }
 else {
      Logger.w(""String_Node_Str"",""String_Node_Str"" + nbt.getInteger(""String_Node_Str"") + ""String_Node_Str""+ e+ ""String_Node_Str"");
      return;
    }
    this.bossId=this.boss.getThePersistentID();
  }
}"
12776,"/** 
 * Returns whether the EntityAIBase should begin execution.
 */
@Override public boolean shouldExecute(){
  boss=((IMinion)entity).getLord();
  if (boss == null) {
    return false;
  }
 else {
    double d0=this.boss.getDistanceSquared(entity);
    return d0 >= MINDIST && d0 <= MAXDIST;
  }
}","/** 
 * Returns whether the EntityAIBase should begin execution.
 */
@Override public boolean shouldExecute(){
  boss=((IMinion)entity).getLord();
  if (boss == null) {
    return false;
  }
 else {
    double d0=this.boss.getTheDistanceSquared(entity);
    return d0 >= MINDIST && d0 <= MAXDIST;
  }
}"
12777,"/** 
 * Returns whether an in-progress EntityAIBase should continue executing
 */
@Override public boolean continueExecuting(){
  if (!this.boss.isEntityAlive()) {
    boss=null;
    return false;
  }
 else {
    double d0=this.boss.getDistanceSquared(entity);
    return d0 >= MINDIST && d0 <= MAXDIST;
  }
}","/** 
 * Returns whether an in-progress EntityAIBase should continue executing
 */
@Override public boolean continueExecuting(){
  if (!this.boss.isTheEntityAlive()) {
    boss=null;
    return false;
  }
 else {
    double d0=this.boss.getTheDistanceSquared(entity);
    return d0 >= MINDIST && d0 <= MAXDIST;
  }
}"
12778,"/** 
 * puts player to sleep on specified coffin if possible
 */
public EntityPlayer.EnumStatus sleepInCoffinAt(int x,int y,int z){
  PlayerSleepInBedEvent event=new PlayerSleepInBedEvent(this.player,x,y,z);
  MinecraftForge.EVENT_BUS.post(event);
  if (event.result != null) {
    return event.result;
  }
  if (!this.player.worldObj.isRemote) {
    if (this.sleepingCoffin || !this.isEntityAlive()) {
      return EntityPlayer.EnumStatus.OTHER_PROBLEM;
    }
    if (!this.player.worldObj.provider.isSurfaceWorld()) {
      return EntityPlayer.EnumStatus.NOT_POSSIBLE_HERE;
    }
    if (!this.player.worldObj.isDaytime()) {
      return EntityPlayer.EnumStatus.NOT_POSSIBLE_NOW;
    }
    if (Math.abs(this.player.posX - (double)x) > 3.0D || Math.abs(this.player.posY - (double)y) > 2.0D || Math.abs(this.player.posZ - (double)z) > 3.0D) {
      return EntityPlayer.EnumStatus.TOO_FAR_AWAY;
    }
    double d0=8.0D;
    double d1=5.0D;
    List list=this.player.worldObj.getEntitiesWithinAABB(EntityMob.class,AxisAlignedBB.getBoundingBox((double)x - d0,(double)y - d1,(double)z - d0,(double)x + d0,(double)y + d1,(double)z + d0));
    if (!list.isEmpty()) {
      return EntityPlayer.EnumStatus.NOT_SAFE;
    }
  }
  if (this.player.isRiding()) {
    this.player.mountEntity((Entity)null);
  }
  Helper.Reflection.callMethod(Entity.class,this.player,Helper.Obfuscation.getPosNames(""String_Node_Str""),new Class[]{float.class,float.class},new Object[]{0.2F,0.2F});
  this.player.yOffset=0.2F;
  if (this.player.worldObj.blockExists(x,y,z)) {
    int direction=((BlockCoffin)player.worldObj.getBlock(x,y,z)).getDirection(player.worldObj,x,y,z);
    float f1=0.5F;
    float f=0.5F;
switch (direction) {
case 0:
      f=0.9F;
    break;
case 1:
  f1=0.1F;
break;
case 2:
f=0.1F;
break;
case 3:
f1=0.9F;
}
this.func_71013_b(direction);
this.player.setPosition((double)((float)x + f1),(double)((float)y + 0.9375F),(double)((float)z + f));
}
 else {
this.player.setPosition((double)((float)x + 0.5F),(double)((float)y + 0.9375F),(double)((float)z + 0.5F));
}
this.sleepingCoffin=true;
this.sleeptimerCoffin=0;
this.player.playerLocation=new ChunkCoordinates(x,y,z);
this.player.motionX=this.player.motionZ=this.player.motionY=0.0D;
if (!this.player.worldObj.isRemote) {
}
return EntityPlayer.EnumStatus.OK;
}","/** 
 * puts player to sleep on specified coffin if possible
 */
public EntityPlayer.EnumStatus sleepInCoffinAt(int x,int y,int z){
  PlayerSleepInBedEvent event=new PlayerSleepInBedEvent(this.player,x,y,z);
  MinecraftForge.EVENT_BUS.post(event);
  if (event.result != null) {
    return event.result;
  }
  if (!this.player.worldObj.isRemote) {
    if (this.sleepingCoffin || !this.isTheEntityAlive()) {
      return EntityPlayer.EnumStatus.OTHER_PROBLEM;
    }
    if (!this.player.worldObj.provider.isSurfaceWorld()) {
      return EntityPlayer.EnumStatus.NOT_POSSIBLE_HERE;
    }
    if (!this.player.worldObj.isDaytime()) {
      return EntityPlayer.EnumStatus.NOT_POSSIBLE_NOW;
    }
    if (Math.abs(this.player.posX - (double)x) > 3.0D || Math.abs(this.player.posY - (double)y) > 2.0D || Math.abs(this.player.posZ - (double)z) > 3.0D) {
      return EntityPlayer.EnumStatus.TOO_FAR_AWAY;
    }
    double d0=8.0D;
    double d1=5.0D;
    List list=this.player.worldObj.getEntitiesWithinAABB(EntityMob.class,AxisAlignedBB.getBoundingBox((double)x - d0,(double)y - d1,(double)z - d0,(double)x + d0,(double)y + d1,(double)z + d0));
    if (!list.isEmpty()) {
      return EntityPlayer.EnumStatus.NOT_SAFE;
    }
  }
  if (this.player.isRiding()) {
    this.player.mountEntity((Entity)null);
  }
  Helper.Reflection.callMethod(Entity.class,this.player,Helper.Obfuscation.getPosNames(""String_Node_Str""),new Class[]{float.class,float.class},new Object[]{0.2F,0.2F});
  this.player.yOffset=0.2F;
  if (this.player.worldObj.blockExists(x,y,z)) {
    int direction=((BlockCoffin)player.worldObj.getBlock(x,y,z)).getDirection(player.worldObj,x,y,z);
    float f1=0.5F;
    float f=0.5F;
switch (direction) {
case 0:
      f=0.9F;
    break;
case 1:
  f1=0.1F;
break;
case 2:
f=0.1F;
break;
case 3:
f1=0.9F;
}
this.func_71013_b(direction);
this.player.setPosition((double)((float)x + f1),(double)((float)y + 0.9375F),(double)((float)z + f));
}
 else {
this.player.setPosition((double)((float)x + 0.5F),(double)((float)y + 0.9375F),(double)((float)z + 0.5F));
}
this.sleepingCoffin=true;
this.sleeptimerCoffin=0;
this.player.playerLocation=new ChunkCoordinates(x,y,z);
this.player.motionX=this.player.motionZ=this.player.motionY=0.0D;
if (!this.player.worldObj.isRemote) {
}
return EntityPlayer.EnumStatus.OK;
}"
12779,"/** 
 * puts player to sleep on specified bed if possible
 */
public EntityPlayer.EnumStatus sleepInCoffinAt(int p_71018_1_,int p_71018_2_,int p_71018_3_){
  PlayerSleepInBedEvent event=new PlayerSleepInBedEvent(this.player,p_71018_1_,p_71018_2_,p_71018_3_);
  MinecraftForge.EVENT_BUS.post(event);
  if (event.result != null) {
    return event.result;
  }
  if (!this.player.worldObj.isRemote) {
    if (this.player.isPlayerSleeping() || !this.isEntityAlive()) {
      return EntityPlayer.EnumStatus.OTHER_PROBLEM;
    }
    if (!this.player.worldObj.provider.isSurfaceWorld()) {
      return EntityPlayer.EnumStatus.NOT_POSSIBLE_HERE;
    }
    if (!this.player.worldObj.isDaytime()) {
      return EntityPlayer.EnumStatus.NOT_POSSIBLE_NOW;
    }
    if (Math.abs(this.player.posX - (double)p_71018_1_) > 3.0D || Math.abs(this.player.posY - (double)p_71018_2_) > 2.0D || Math.abs(this.player.posZ - (double)p_71018_3_) > 3.0D) {
      return EntityPlayer.EnumStatus.TOO_FAR_AWAY;
    }
    double d0=8.0D;
    double d1=5.0D;
    List list=this.player.worldObj.getEntitiesWithinAABB(EntityMob.class,AxisAlignedBB.getBoundingBox((double)p_71018_1_ - d0,(double)p_71018_2_ - d1,(double)p_71018_3_ - d0,(double)p_71018_1_ + d0,(double)p_71018_2_ + d1,(double)p_71018_3_ + d0));
    if (!list.isEmpty()) {
      return EntityPlayer.EnumStatus.NOT_SAFE;
    }
  }
  if (this.player.isRiding()) {
    this.player.mountEntity((Entity)null);
  }
  Helper.Reflection.callMethod(this.player,Helper.Obfuscation.getPosNames(""String_Node_Str""),new Class[]{Float.class,Float.class},new Object[]{0.2F,0.2F});
  this.player.yOffset=0.2F;
  if (this.player.worldObj.blockExists(p_71018_1_,p_71018_2_,p_71018_3_)) {
    int l=player.worldObj.getBlock(p_71018_1_,p_71018_2_,p_71018_3_).getBedDirection(player.worldObj,p_71018_1_,p_71018_2_,p_71018_3_);
    float f1=0.5F;
    float f=0.5F;
switch (l) {
case 0:
      f=0.9F;
    break;
case 1:
  f1=0.1F;
break;
case 2:
f=0.1F;
break;
case 3:
f1=0.9F;
}
this.func_71013_b(l);
this.player.setPosition((double)((float)p_71018_1_ + f1),(double)((float)p_71018_2_ + 0.9375F),(double)((float)p_71018_3_ + f));
}
 else {
this.player.setPosition((double)((float)p_71018_1_ + 0.5F),(double)((float)p_71018_2_ + 0.9375F),(double)((float)p_71018_3_ + 0.5F));
}
Helper.Reflection.setPrivateField(EntityPlayer.class,this.player,true,Helper.Obfuscation.getPosNames(""String_Node_Str""));
Helper.Reflection.setPrivateField(EntityPlayer.class,this.player,0,Helper.Obfuscation.getPosNames(""String_Node_Str""));
this.player.playerLocation=new ChunkCoordinates(p_71018_1_,p_71018_2_,p_71018_3_);
this.player.motionX=this.player.motionZ=this.player.motionY=0.0D;
if (!this.player.worldObj.isRemote) {
this.player.worldObj.updateAllPlayersSleepingFlag();
}
return EntityPlayer.EnumStatus.OK;
}","/** 
 * puts player to sleep on specified bed if possible
 */
public EntityPlayer.EnumStatus sleepInCoffinAt(int p_71018_1_,int p_71018_2_,int p_71018_3_){
  PlayerSleepInBedEvent event=new PlayerSleepInBedEvent(this.player,p_71018_1_,p_71018_2_,p_71018_3_);
  MinecraftForge.EVENT_BUS.post(event);
  if (event.result != null) {
    return event.result;
  }
  if (!this.player.worldObj.isRemote) {
    if (this.player.isPlayerSleeping() || !this.isEntityAlive()) {
      return EntityPlayer.EnumStatus.OTHER_PROBLEM;
    }
    if (!this.player.worldObj.provider.isSurfaceWorld()) {
      return EntityPlayer.EnumStatus.NOT_POSSIBLE_HERE;
    }
    if (!this.player.worldObj.isDaytime()) {
      return EntityPlayer.EnumStatus.NOT_POSSIBLE_NOW;
    }
    if (Math.abs(this.player.posX - (double)p_71018_1_) > 3.0D || Math.abs(this.player.posY - (double)p_71018_2_) > 2.0D || Math.abs(this.player.posZ - (double)p_71018_3_) > 3.0D) {
      return EntityPlayer.EnumStatus.TOO_FAR_AWAY;
    }
    double d0=8.0D;
    double d1=5.0D;
    List list=this.player.worldObj.getEntitiesWithinAABB(EntityMob.class,AxisAlignedBB.getBoundingBox((double)p_71018_1_ - d0,(double)p_71018_2_ - d1,(double)p_71018_3_ - d0,(double)p_71018_1_ + d0,(double)p_71018_2_ + d1,(double)p_71018_3_ + d0));
    if (!list.isEmpty()) {
      return EntityPlayer.EnumStatus.NOT_SAFE;
    }
  }
  if (this.player.isRiding()) {
    this.player.mountEntity((Entity)null);
  }
  Helper.Reflection.callMethod(Entity.class,this.player,Helper.Obfuscation.getPosNames(""String_Node_Str""),new Class[]{float.class,float.class},new Object[]{0.2F,0.2F});
  this.player.yOffset=0.2F;
  if (this.player.worldObj.blockExists(p_71018_1_,p_71018_2_,p_71018_3_)) {
    int l=player.worldObj.getBlock(p_71018_1_,p_71018_2_,p_71018_3_).getBedDirection(player.worldObj,p_71018_1_,p_71018_2_,p_71018_3_);
    float f1=0.5F;
    float f=0.5F;
switch (l) {
case 0:
      f=0.9F;
    break;
case 1:
  f1=0.1F;
break;
case 2:
f=0.1F;
break;
case 3:
f1=0.9F;
}
this.func_71013_b(l);
this.player.setPosition((double)((float)p_71018_1_ + f1),(double)((float)p_71018_2_ + 0.9375F),(double)((float)p_71018_3_ + f));
}
 else {
this.player.setPosition((double)((float)p_71018_1_ + 0.5F),(double)((float)p_71018_2_ + 0.9375F),(double)((float)p_71018_3_ + 0.5F));
}
Helper.Reflection.setPrivateField(EntityPlayer.class,this.player,true,Helper.Obfuscation.getPosNames(""String_Node_Str""));
Helper.Reflection.setPrivateField(EntityPlayer.class,this.player,0,Helper.Obfuscation.getPosNames(""String_Node_Str""));
this.player.playerLocation=new ChunkCoordinates(p_71018_1_,p_71018_2_,p_71018_3_);
this.player.motionX=this.player.motionZ=this.player.motionY=0.0D;
if (!this.player.worldObj.isRemote) {
this.player.worldObj.updateAllPlayersSleepingFlag();
}
return EntityPlayer.EnumStatus.OK;
}"
12780,"public static final void fillMap(){
  add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","public static final void fillMap(){
  add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}"
12781,"@Override public void render(Entity entity,float f,float f1,float f2,float f3,float f4,float f5){
  super.render(entity,f,f1,f2,f3,f4,f5);
  setRotationAngles(f,f1,f2,f3,f4,f5,entity);
  hatTop.render(f5);
  hatRim.render(f5);
  axeShaft.render(f5);
  axeBlade1.render(f5);
  axeBlade2.render(f5);
  stake.render(f5);
}","@Override public void render(Entity entity,float f,float f1,float f2,float f3,float f4,float f5){
  super.render(entity,f,f1,f2,f3,f4,f5);
  setRotationAngles(f,f1,f2,f3,f4,f5,entity);
  hatTop.render(f5);
  hatRim.render(f5);
  if (renderWeapons) {
    axeShaft.render(f5);
    axeBlade1.render(f5);
    axeBlade2.render(f5);
    stake.render(f5);
  }
}"
12782,"@Override public IMessage onMessage(UpdateVampirePlayerPacket message,MessageContext ctx){
  VampirePlayer.get(Minecraft.getMinecraft().thePlayer).loadSyncUpdate(message.level,message.timers);
  return null;
}","@Override public IMessage onMessage(UpdateVampirePlayerPacket message,MessageContext ctx){
  VampirePlayer.get(VampirismMod.proxy.getSPPlayer()).loadSyncUpdate(message.level,message.timers);
  return null;
}"
12783,"/** 
 * Sets the vampire lords level and updates his nametag
 * @param l
 * @param sync whether to sync the level with the client or not
 */
public void setLevel(int l,boolean sync){
  if (l > 0 && l != level) {
    this.level=l;
    this.setCustomNameTag(I18n.format(""String_Node_Str"" + REFERENCE.ENTITY.VAMPIRE_LORD_NAME + ""String_Node_Str"",new Object[0]) + ""String_Node_Str"" + I18n.format(""String_Node_Str"",new Object[0])+ ""String_Node_Str""+ level);
    if (sync && !this.worldObj.isRemote) {
      NBTTagCompound nbt=new NBTTagCompound();
      nbt.setInteger(""String_Node_Str"",level);
      Helper.sendPacketToPlayersAround(new UpdateEntityPacket(this,nbt),this);
    }
  }
}","/** 
 * Sets the vampire lords level and updates his nametag
 * @param l
 * @param sync whether to sync the level with the client or not
 */
public void setLevel(int l,boolean sync){
  if (l > 0 && l != level) {
    this.level=l;
    if (sync && !this.worldObj.isRemote) {
      NBTTagCompound nbt=new NBTTagCompound();
      nbt.setInteger(""String_Node_Str"",level);
      Helper.sendPacketToPlayersAround(new UpdateEntityPacket(this,nbt),this);
    }
  }
}"
12784,"@Override public void registerSubscriptions(){
}","@Override public void registerSubscriptions(){
  super.registerSubscriptions();
}"
12785,"@SubscribeEvent public void onEntityJoinWorld(EntityJoinWorldEvent event){
  if (event.entity instanceof EntityVampireHunter) {
    EntityVampireHunter e=(EntityVampireHunter)event.entity;
    if (e.isLookingForHome() == false)     return;
    Village v=event.world.villageCollectionObj.findNearestVillage(MathHelper.floor_double(e.posX),MathHelper.floor_double(e.posY),MathHelper.floor_double(e.posZ),20);
    if (v != null) {
      int r=v.getVillageRadius();
      AxisAlignedBB box=AxisAlignedBB.getBoundingBox(v.getCenter().posX - r,0,v.getCenter().posZ - r,v.getCenter().posX + r,event.world.getActualHeight(),v.getCenter().posZ + r);
      ChunkCoordinates cc=v.getCenter();
      e.setHomeArea(cc.posX,cc.posY,cc.posZ,r);
      e.setFoundHome();
    }
  }
 else   if (event.entity instanceof EntityIronGolem) {
    EntityIronGolem golem=(EntityIronGolem)event.entity;
    EntityAITasks targetTasks=(EntityAITasks)Helper.Reflection.getPrivateFinalField(EntityLiving.class,golem,""String_Node_Str"");
    if (targetTasks == null) {
      Logger.w(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      for (      Object o : targetTasks.taskEntries) {
        EntityAIBase t=((EntityAITasks.EntityAITaskEntry)o).action;
        if (t instanceof EntityAINearestAttackableTarget) {
          targetTasks.removeTask(t);
          targetTasks.addTask(3,new EntityAINearestAttackableTarget(golem,EntityLiving.class,0,false,true,new IEntitySelector(){
            @Override public boolean isEntityApplicable(            Entity entity){
              if (entity instanceof IMob && !(entity instanceof EntityVampireHunter)) {
                return true;
              }
              return false;
            }
          }
));
          break;
        }
      }
    }
  }
 else   if (event.entity instanceof EntityCreeper) {
    EntityCreeper creeper=(EntityCreeper)event.entity;
    EntityAITasks tasks=(EntityAITasks)Helper.Reflection.getPrivateFinalField(EntityLiving.class,creeper,""String_Node_Str"");
    if (tasks == null) {
      Logger.w(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      tasks.addTask(3,new EntityAIAvoidVampirePlayer(creeper,12.0F,1.0D,1.2D,BALANCE.VAMPIRE_PLAYER_CREEPER_AVOID_LEVEL));
    }
  }
}","@SubscribeEvent public void onEntityJoinWorld(EntityJoinWorldEvent event){
  if (event.entity instanceof EntityVampireHunter) {
    EntityVampireHunter e=(EntityVampireHunter)event.entity;
    if (e.isLookingForHome() == false)     return;
    Village v=event.world.villageCollectionObj.findNearestVillage(MathHelper.floor_double(e.posX),MathHelper.floor_double(e.posY),MathHelper.floor_double(e.posZ),20);
    if (v != null) {
      int r=v.getVillageRadius();
      AxisAlignedBB box=AxisAlignedBB.getBoundingBox(v.getCenter().posX - r,0,v.getCenter().posZ - r,v.getCenter().posX + r,event.world.getActualHeight(),v.getCenter().posZ + r);
      ChunkCoordinates cc=v.getCenter();
      e.setHomeArea(cc.posX,cc.posY,cc.posZ,r);
      e.setFoundHome();
    }
  }
 else   if (event.entity instanceof EntityIronGolem) {
    EntityIronGolem golem=(EntityIronGolem)event.entity;
    EntityAITasks targetTasks=(EntityAITasks)Helper.Reflection.getPrivateFinalField(EntityLiving.class,golem,""String_Node_Str"");
    if (targetTasks == null) {
      Logger.w(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      for (      Object o : targetTasks.taskEntries) {
        EntityAIBase t=((EntityAITasks.EntityAITaskEntry)o).action;
        if (t instanceof EntityAINearestAttackableTarget) {
          targetTasks.removeTask(t);
          targetTasks.addTask(3,new EntityAINearestAttackableTarget(golem,EntityLiving.class,0,false,true,new IEntitySelector(){
            @Override public boolean isEntityApplicable(            Entity entity){
              if (entity instanceof IMob && !(entity instanceof EntityVampireHunter)) {
                return true;
              }
              return false;
            }
          }
));
          break;
        }
      }
    }
  }
 else   if (event.entity instanceof EntityCreeper) {
    EntityCreeper creeper=(EntityCreeper)event.entity;
    EntityAITasks tasks=(EntityAITasks)Helper.Reflection.getPrivateFinalField(EntityLiving.class,(EntityLiving)creeper,""String_Node_Str"");
    if (tasks == null) {
      Logger.w(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      tasks.addTask(3,new EntityAIAvoidVampirePlayer(creeper,12.0F,1.0D,1.2D,BALANCE.VAMPIRE_PLAYER_CREEPER_AVOID_LEVEL));
    }
  }
}"
12786,"private void addAITasks(){
  EntityAITasks tasks=(EntityAITasks)Helper.Reflection.getPrivateFinalField(EntityLiving.class,entity,""String_Node_Str"");
  tasks.addTask(1,new EntityAIAttackOnCollide(entity,EntityPlayer.class,1.0D,false));
  tasks.addTask(1,new EntityAIAttackOnCollide(entity,EntityVampireHunter.class,1.0D,true));
  EntityAITasks targetTasks=(EntityAITasks)Helper.Reflection.getPrivateFinalField(EntityLiving.class,entity,""String_Node_Str"");
  targetTasks.addTask(3,new EntityAINearestAttackableTarget(entity,EntityPlayer.class,0,true,false,new IEntitySelector(){
    @Override public boolean isEntityApplicable(    Entity entity){
      if (entity instanceof EntityPlayer) {
        return VampirePlayer.get((EntityPlayer)entity).getLevel() <= 0;
      }
      return false;
    }
  }
));
  targetTasks.addTask(3,new EntityAINearestAttackableTarget(entity,EntityVampireHunter.class,0,true));
}","private void addAITasks(){
  EntityAITasks tasks=(EntityAITasks)Helper.Reflection.getPrivateFinalField(EntityLiving.class,(EntityLiving)entity,""String_Node_Str"");
  tasks.addTask(1,new EntityAIAttackOnCollide(entity,EntityPlayer.class,1.0D,false));
  tasks.addTask(1,new EntityAIAttackOnCollide(entity,EntityVampireHunter.class,1.0D,true));
  EntityAITasks targetTasks=(EntityAITasks)Helper.Reflection.getPrivateFinalField(EntityLiving.class,entity,""String_Node_Str"");
  targetTasks.addTask(3,new EntityAINearestAttackableTarget(entity,EntityPlayer.class,0,true,false,new IEntitySelector(){
    @Override public boolean isEntityApplicable(    Entity entity){
      if (entity instanceof EntityPlayer) {
        return VampirePlayer.get((EntityPlayer)entity).getLevel() <= 0;
      }
      return false;
    }
  }
));
  targetTasks.addTask(3,new EntityAINearestAttackableTarget(entity,EntityVampireHunter.class,0,true));
}"
12787,"@Override public IMessage onMessage(SpawnParticlePacket message,MessageContext ctx){
  if (message.type.equals(""String_Node_Str"")) {
    Class[] paramtype=new Class[]{ItemStack.class,Integer.TYPE};
    ItemStack is=new ItemStack(Item.getItemById(260));
    Helper.Reflection.callMethod(EntityPlayer.class,Minecraft.getMinecraft().thePlayer,""String_Node_Str"",paramtype,new Object[]{is,message.amount});
    return null;
  }
  WorldClient world=Minecraft.getMinecraft().theWorld;
  world.spawnParticle(message.type,message.x,message.y,message.z,message.velX,message.velY,message.velZ);
  for (int i=1; i < message.amount; i++) {
    Random ran=world.rand;
    double x=message.x + (ran.nextGaussian());
    double y=message.y + (ran.nextGaussian());
    double z=message.z + (ran.nextGaussian());
    world.spawnParticle(message.type,x,y,z,ran.nextDouble(),ran.nextGaussian(),ran.nextGaussian());
  }
  return null;
}","@Override public IMessage onMessage(SpawnParticlePacket message,MessageContext ctx){
  if (message.type.equals(""String_Node_Str"")) {
    Class[] paramtype=new Class[]{ItemStack.class,Integer.TYPE};
    ItemStack is=new ItemStack(Item.getItemById(260));
    Helper.Reflection.callMethod(EntityPlayer.class,(EntityPlayer)Minecraft.getMinecraft().thePlayer,""String_Node_Str"",paramtype,new Object[]{is,message.amount});
    return null;
  }
  WorldClient world=Minecraft.getMinecraft().theWorld;
  world.spawnParticle(message.type,message.x,message.y,message.z,message.velX,message.velY,message.velZ);
  for (int i=1; i < message.amount; i++) {
    Random ran=world.rand;
    double x=message.x + (ran.nextGaussian());
    double y=message.y + (ran.nextGaussian());
    double z=message.z + (ran.nextGaussian());
    world.spawnParticle(message.type,x,y,z,ran.nextDouble(),ran.nextGaussian(),ran.nextGaussian());
  }
  return null;
}"
12788,"@Override public void processCommand(ICommandSender sender,String[] param){
  if (sender instanceof EntityPlayer) {
    EntityPlayer p=(EntityPlayer)sender;
    if (param.length > 0) {
      try {
        VampirePlayer.get(p).setLevel(Integer.parseInt(param[0]));
      }
 catch (      NumberFormatException e) {
        Logger.e(""String_Node_Str"",param[0] + ""String_Node_Str"");
      }
    }
 else {
      VampirePlayer.get(p).levelUp();
    }
    if (VampirePlayer.get(p).getLevel() == 1) {
      sendMessage(sender,""String_Node_Str"");
    }
  }
}","@Override public void processCommand(ICommandSender sender,String[] param){
  if (sender instanceof EntityPlayer) {
    EntityPlayer p=(EntityPlayer)sender;
    sendMessage(sender,""String_Node_Str"" + p.worldObj.isDaytime());
    if (param.length > 0) {
      try {
        VampirePlayer.get(p).setLevel(Integer.parseInt(param[0]));
      }
 catch (      NumberFormatException e) {
        Logger.e(""String_Node_Str"",param[0] + ""String_Node_Str"");
      }
    }
 else {
      VampirePlayer.get(p).levelUp();
    }
    if (VampirePlayer.get(p).getLevel() == 1) {
      sendMessage(sender,""String_Node_Str"");
    }
  }
}"
12789,"/** 
 * Code for the vampirism ritual to start
 * @param player Player who started the ritual and will become a vampire
 * @param itemStack The sword's ItemStack that is going to be consumed
 */
public void startVampirismRitual(EntityPlayer player,ItemStack itemStack){
  Logger.i(TAG,""String_Node_Str"");
  player.inventory.consumeInventoryItem(itemStack.getItem());
  setOccupied(true,player);
  List entityList=getWorldObj().loadedEntityList;
  ArrayList<EntityVillager> list=getVillagersInRadius(entityList,DISTANCE_AROUND_ALTAR);
  for (  EntityVillager v : list) {
    for (int i=0; i < LIGHTNINGBOLT_AMOUNT; i++)     getWorldObj().addWeatherEffect(new EntityLightningBolt(getWorldObj(),v.posX,v.posY,v.posZ));
  }
  if (!Minecraft.getMinecraft().theWorld.isDaytime() && ((ItemVampiresFear)itemStack.getItem()).getBlood(itemStack) >= BALANCE.NEEDED_BLOOD && list.size() >= BALANCE.LEVELING.R1_VILLAGERS) {
    VampirePlayer vp=VampirePlayer.get(player);
    if (vp.getLevel() == 0) {
      vp.levelUp();
    }
    Logger.i(TAG,""String_Node_Str"");
  }
 else {
    Logger.i(TAG,""String_Node_Str"");
  }
}","/** 
 * Code for the vampirism ritual to start
 * @param player Player who started the ritual and will become a vampire
 * @param itemStack The sword's ItemStack that is going to be consumed
 */
public void startVampirismRitual(EntityPlayer player,ItemStack itemStack){
  Logger.i(TAG,""String_Node_Str"");
  Logger.i(""String_Node_Str"",itemStack.toString());
  player.inventory.consumeInventoryItem(itemStack.getItem());
  setOccupied(true,player);
  List entityList=getWorldObj().loadedEntityList;
  ArrayList<EntityVillager> list=getVillagersInRadius(entityList,DISTANCE_AROUND_ALTAR);
  for (  EntityVillager v : list) {
    for (int i=0; i < LIGHTNINGBOLT_AMOUNT; i++)     getWorldObj().addWeatherEffect(new EntityLightningBolt(getWorldObj(),v.posX,v.posY,v.posZ));
  }
  if (!(this.worldObj.isDaytime()) && ItemVampiresFear.getBlood(itemStack) >= BALANCE.NEEDED_BLOOD && list.size() >= BALANCE.LEVELING.R1_VILLAGERS) {
    VampirePlayer vp=VampirePlayer.get(player);
    if (vp.getLevel() == 0) {
      vp.levelUp();
    }
    Logger.i(TAG,""String_Node_Str"");
  }
 else {
    itemStack.stackSize=1;
    Logger.i(""String_Node_Str"",itemStack.toString());
    EntityItem entityitem=new EntityItem(this.worldObj,this.xCoord,this.yCoord + 1,this.zCoord,itemStack);
    entityitem.delayBeforeCanPickup=10;
    Logger.i(""String_Node_Str"",entityitem.toString());
    this.worldObj.spawnEntityInWorld(entityitem);
    this.setOccupied(false,player);
    Logger.i(TAG,""String_Node_Str"" + (!this.worldObj.isDaytime()) + ""String_Node_Str""+ ItemVampiresFear.getBlood(itemStack)+ ""String_Node_Str""+ list.size());
  }
}"
12790,"public FlyingBloodParticle(World world,double posX,double posY,double posZ,NBTTagCompound data){
  super(world,posX,posY,posZ,0D,0D,0D);
  Logger.i(""String_Node_Str"",""String_Node_Str"" + posX + ""String_Node_Str""+ posY+ ""String_Node_Str""+ posZ);
  entity=world.getEntityByID(data.getInteger(""String_Node_Str""));
  if (entity == null) {
    Logger.e(TAG,""String_Node_Str"" + data.getInteger(""String_Node_Str"") + ""String_Node_Str"");
    throw new NullPointerException(""String_Node_Str"");
  }
  this.particleRed=1.0F;
  this.particleBlue=this.particleGreen=0.0F;
  this.noClip=true;
  this.particleMaxAge=MAX_AGE;
  this.setParticleTextureIndex(65);
  this.motionX=(this.worldObj.rand.nextDouble() - 0.5);
  this.motionY=(this.worldObj.rand.nextDouble() + 0.2);
  this.motionZ=(this.worldObj.rand.nextDouble() - 0.5);
  this.onUpdate();
}","public FlyingBloodParticle(double posX,double posY,double posZ,NBTTagCompound data){
  super(Minecraft.getMinecraft().theWorld,posX,posY,posZ,0D,0D,0D);
  Logger.i(""String_Node_Str"",""String_Node_Str"" + posX + ""String_Node_Str""+ posY+ ""String_Node_Str""+ posZ);
  entity=this.worldObj.getEntityByID(data.getInteger(""String_Node_Str""));
  if (entity == null) {
    Logger.e(TAG,""String_Node_Str"" + data.getInteger(""String_Node_Str"") + ""String_Node_Str"");
    throw new NullPointerException(""String_Node_Str"");
  }
  this.particleRed=1.0F;
  this.particleBlue=this.particleGreen=0.0F;
  this.noClip=true;
  this.particleMaxAge=MAX_AGE;
  this.setParticleTextureIndex(65);
  this.motionX=(this.worldObj.rand.nextDouble() - 0.5);
  this.motionY=(this.worldObj.rand.nextDouble() + 0.2);
  this.motionZ=(this.worldObj.rand.nextDouble() - 0.5);
  this.onUpdate();
}"
12791,"@Override public IMessage onMessage(SpawnCustomParticlePacket message,MessageContext ctx){
  try {
switch (message.data.getInteger(""String_Node_Str"")) {
case 0:
      for (int i=0; i < message.amount; i++) {
        EntityFX p=new FlyingBloodParticle(Minecraft.getMinecraft().theWorld,message.posX,message.posY,message.posZ,message.data);
        Minecraft.getMinecraft().effectRenderer.addEffect(p);
      }
    break;
default :
  Logger.w(""String_Node_Str"",""String_Node_Str"" + message.data.getInteger(""String_Node_Str"") + ""String_Node_Str"");
return null;
}
}
 catch (Exception e) {
Logger.e(""String_Node_Str"",""String_Node_Str"",e);
}
return null;
}","@Override public IMessage onMessage(SpawnCustomParticlePacket message,MessageContext ctx){
  try {
switch (message.data.getInteger(""String_Node_Str"")) {
case 0:
      for (int i=0; i < message.amount; i++) {
        FlyingBloodParticle.addParticle(new FlyingBloodParticle(message.posX,message.posY,message.posZ,message.data));
      }
    break;
default :
  Logger.w(""String_Node_Str"",""String_Node_Str"" + message.data.getInteger(""String_Node_Str"") + ""String_Node_Str"");
return null;
}
}
 catch (Exception e) {
Logger.e(""String_Node_Str"",""String_Node_Str"",e);
}
return null;
}"
12792,"@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float scale){
  TileEntityBloodAltarTier2 te2=(TileEntityBloodAltarTier2)te;
  model.setBloodLevel((int)StrictMath.ceil(te2.getBloodAmount() / te2.getMaxBlood() * 15));
  GL11.glPushMatrix();
  GL11.glTranslatef((float)x + 0.5F,(float)y + 1.5F,(float)z + 0.5F);
  bindTexture(texture);
  GL11.glPushMatrix();
  adjustRotatePivotViaMeta(te.getWorldObj(),te.xCoord,te.yCoord,te.zCoord);
  GL11.glRotatef(180F,0.0F,0.0F,1.0F);
  model.render(null,0.0F,0.0F,-0.1F,0.0F,0.0F,0.0625F);
  GL11.glPopMatrix();
  GL11.glPopMatrix();
}","@Override public void renderTileEntityAt(TileEntity te,double x,double y,double z,float scale){
  TileEntityBloodAltarTier2 te2=(TileEntityBloodAltarTier2)te;
  model.setBloodLevel((int)StrictMath.ceil(((float)te2.getBloodAmount()) / te2.getMaxBlood() * 15));
  GL11.glPushMatrix();
  GL11.glTranslatef((float)x + 0.5F,(float)y + 1.5F,(float)z + 0.5F);
  bindTexture(texture);
  GL11.glPushMatrix();
  adjustRotatePivotViaMeta(te.getWorldObj(),te.xCoord,te.yCoord,te.zCoord);
  GL11.glRotatef(180F,0.0F,0.0F,1.0F);
  model.render(null,0.0F,0.0F,-0.1F,0.0F,0.0F,0.0625F);
  GL11.glPopMatrix();
  GL11.glPopMatrix();
}"
12793,"public void registerEntitys(){
  int id=0;
  EntityRegistry.registerModEntity(EntityVampireHunter.class,""String_Node_Str"",id,VampirismMod.instance,80,1,true);
  EntityRegistry.addSpawn(EntityVampireHunter.class,2,0,1,EnumCreatureType.monster,BiomeGenBase.stoneBeach,BiomeGenBase.desert);
  id++;
  EntityRegistry.registerModEntity(EntityVampire.class,""String_Node_Str"",id,VampirismMod.instance,80,1,true);
  EntityRegistry.addSpawn(EntityVampire.class,2,0,1,EnumCreatureType.monster,BiomeGenBase.stoneBeach,BiomeGenBase.desert);
  id++;
}","public void registerEntitys(){
  int id=0;
  BiomeGenBase[] allBiomes=Iterators.toArray(Iterators.filter(Iterators.forArray(BiomeGenBase.getBiomeGenArray()),Predicates.notNull()),BiomeGenBase.class);
  EntityRegistry.registerModEntity(EntityVampireHunter.class,""String_Node_Str"",id,VampirismMod.instance,80,1,true);
  EntityRegistry.addSpawn(EntityVampireHunter.class,2,0,1,EnumCreatureType.monster,allBiomes);
  id++;
  EntityRegistry.registerModEntity(EntityVampire.class,""String_Node_Str"",id,VampirismMod.instance,80,1,true);
  EntityRegistry.addSpawn(EntityVampire.class,2,0,1,EnumCreatureType.monster,allBiomes);
  id++;
}"
12794,"public UpdateIssueParams notifiedUserIds(List<Long> notifiedUserIds){
  if (notifiedUserIds == null) {
    parameters.add(new NameValuePair(""String_Node_Str"",""String_Node_Str""));
  }
 else {
    for (    Long notifiedUserId : notifiedUserIds) {
      parameters.add(new NameValuePair(""String_Node_Str"",notifiedUserId.toString()));
    }
  }
  return this;
}","public UpdateIssueParams notifiedUserIds(List<Long> notifiedUserIds){
  for (  Long notifiedUserId : notifiedUserIds) {
    parameters.add(new NameValuePair(""String_Node_Str"",notifiedUserId.toString()));
  }
  return this;
}"
12795,"public UpdateIssueParams attachmentIds(List<Long> attachmentIds){
  if (attachmentIds == null) {
    parameters.add(new NameValuePair(""String_Node_Str"",""String_Node_Str""));
  }
 else {
    for (    Long attachmentId : attachmentIds) {
      parameters.add(new NameValuePair(""String_Node_Str"",attachmentId.toString()));
    }
  }
  return this;
}","public UpdateIssueParams attachmentIds(List<Long> attachmentIds){
  for (  Long attachmentId : attachmentIds) {
    parameters.add(new NameValuePair(""String_Node_Str"",attachmentId.toString()));
  }
  return this;
}"
12796,"@Test public void createParamEmptySetTest() throws UnsupportedEncodingException {
  UpdateIssueParams params=new UpdateIssueParams(1000000001l);
  params.resolution(null).assigneeId(0).dueDate(null).startDate(null).categoryIds(null).versionIds(null).milestoneIds(null).estimatedHours(null).actualHours(null).notifiedUserIds(null).attachmentIds(null);
  List<NameValuePair> parameters=params.getParamList();
  assertEquals(11,parameters.size());
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
}","@Test public void createParamEmptySetTest() throws UnsupportedEncodingException {
  UpdateIssueParams params=new UpdateIssueParams(1000000001l);
  params.resolution(null).assigneeId(0).dueDate(null).startDate(null).categoryIds(null).versionIds(null).milestoneIds(null).estimatedHours(null).actualHours(null);
  List<NameValuePair> parameters=params.getParamList();
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
  assertEquals(true,existsOneKeyValue(parameters,""String_Node_Str"",""String_Node_Str""));
}"
12797,"public UpdateIssueParams resolution(Issue.ResolutionType resolutionType){
  parameters.add(new NameValuePair(""String_Node_Str"",String.valueOf(resolutionType.getIntValue())));
  return this;
}","public UpdateIssueParams resolution(Issue.ResolutionType resolutionType){
  if (resolutionType == null) {
    parameters.add(new NameValuePair(""String_Node_Str"",""String_Node_Str""));
  }
 else {
    parameters.add(new NameValuePair(""String_Node_Str"",String.valueOf(resolutionType.getIntValue())));
  }
  return this;
}"
12798,"private static void initalize(){
  initialized=true;
  font=new int[256][8];
  Thread fontLoader=new Thread(() -> {
    InputStream in=ClassLoader.getSystemResourceAsStream(""String_Node_Str"");
    Image image=new Image(in);
    PixelReader reader=image.getPixelReader();
    for (int i=0; i < 256; i++) {
      int x=(i >> 4) * 13 + 2;
      int y=(i & 15) * 13 + 4;
      for (int j=0; j < 8; j++) {
        int row=0;
        for (int k=0; k < 7; k++) {
          Color color=reader.getColor((7 - k) + x,j + y);
          boolean on=color.getRed() != 0;
          row=(row << 1) | (on ? 0 : 1);
        }
        font[i][j]=row;
      }
    }
  }
);
  fontLoader.start();
}","private static void initalize(){
  initialized=true;
  font=new int[256][8];
  Thread fontLoader=new Thread(() -> {
    InputStream in=Font.class.getClassLoader().getResourceAsStream(""String_Node_Str"");
    Image image=new Image(in);
    PixelReader reader=image.getPixelReader();
    for (int i=0; i < 256; i++) {
      int x=(i >> 4) * 13 + 2;
      int y=(i & 15) * 13 + 4;
      for (int j=0; j < 8; j++) {
        int row=0;
        for (int k=0; k < 7; k++) {
          Color color=reader.getColor((7 - k) + x,j + y);
          boolean on=color.getRed() != 0;
          row=(row << 1) | (on ? 0 : 1);
        }
        font[i][j]=row;
      }
    }
  }
);
  fontLoader.start();
}"
12799,"public void run(){
  RAM memory=Emulator.computer.memory;
  Emulator.computer.pause();
  int pos=memory.readWordRaw(startingAddressPointer);
  for (  Line line : lines) {
    int nextPos=pos + line.getLength() + 1;
    memory.write(pos++,(byte)(nextPos & 0x0ff),false,true);
    memory.write(pos++,(byte)(nextPos >> 8 & 0x0ff),false,true);
    memory.write(pos++,(byte)(line.getNumber() & 0x0ff),false,true);
    memory.write(pos++,(byte)(line.getNumber() >> 8 & 0x0ff),false,true);
    boolean isFirst=true;
    for (    Command command : line.getCommands()) {
      if (!isFirst) {
        memory.write(pos++,(byte)':',false,true);
      }
      isFirst=false;
      for (      Command.ByteOrToken part : command.parts) {
        memory.write(pos++,part.getByte(),false,true);
      }
    }
    memory.write(pos++,(byte)0,false,true);
  }
  memory.write(pos++,(byte)0,false,true);
  memory.write(pos++,(byte)0,false,true);
  memory.write(pos++,(byte)0,false,true);
  memory.write(pos++,(byte)0,false,true);
  Emulator.computer.resume();
}","public void run(){
  RAM memory=Emulator.computer.memory;
  Emulator.computer.pause();
  int pos=memory.readWordRaw(startingAddressPointer);
  for (  Line line : lines) {
    int nextPos=pos + line.getLength() + 1;
    memory.writeWord(pos,nextPos,false,true);
    pos+=2;
    memory.writeWord(pos,line.getNumber(),false,true);
    pos+=2;
    boolean isFirst=true;
    for (    Command command : line.getCommands()) {
      if (!isFirst) {
        memory.write(pos++,(byte)':',false,true);
      }
      isFirst=false;
      for (      Command.ByteOrToken part : command.parts) {
        memory.write(pos++,part.getByte(),false,true);
      }
    }
    memory.write(pos++,(byte)0,false,true);
  }
  memory.write(pos++,(byte)0,false,true);
  memory.write(pos++,(byte)0,false,true);
  memory.write(pos++,(byte)0,false,true);
  memory.write(pos++,(byte)0,false,true);
  clearVariables(pos);
  Emulator.computer.resume();
}"
12800,"public static ApplesoftProgram fromString(String programSource){
  ApplesoftProgram program=new ApplesoftProgram();
  for (  String line : programSource.split(""String_Node_Str"")) {
    if (line.trim().isEmpty())     continue;
    program.lines.add(Line.fromString(line));
  }
  for (int i=0; i < program.lines.size(); i++) {
    if (i > 0) {
      program.lines.get(i).setPrevious(program.lines.get(i - 1));
    }
    if (i < program.lines.size() - 1) {
      program.lines.get(i).setNext(program.lines.get(i + 1));
    }
  }
  return program;
}","public static ApplesoftProgram fromString(String programSource){
  ApplesoftProgram program=new ApplesoftProgram();
  for (  String line : programSource.split(""String_Node_Str"")) {
    if (line.trim().isEmpty()) {
      continue;
    }
    program.lines.add(Line.fromString(line));
  }
  for (int i=0; i < program.lines.size(); i++) {
    if (i > 0) {
      program.lines.get(i).setPrevious(program.lines.get(i - 1));
    }
    if (i < program.lines.size() - 1) {
      program.lines.get(i).setNext(program.lines.get(i + 1));
    }
  }
  return program;
}"
12801,"private void invokeAcme(File sourceFile,File workingDirectory) throws ClassNotFoundException, SecurityException, NoSuchMethodException, IOException {
  String oldPath=System.getProperty(""String_Node_Str"");
  redirectSystemOutput();
  try {
    compiledAsset=File.createTempFile(sourceFile.getName(),""String_Node_Str"",sourceFile.getParentFile());
    System.setProperty(""String_Node_Str"",workingDirectory.getAbsolutePath());
    AcmeCrossAssembler acme=new AcmeCrossAssembler();
    String[] params={""String_Node_Str"",compiledAsset.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",sourceFile.getAbsolutePath()};
    int status=acme.run(""String_Node_Str"",params);
    successful=status == 0;
    if (!successful) {
      compiledAsset.delete();
      compiledAsset=null;
    }
  }
  finally {
    restoreSystemOutput();
    System.setProperty(""String_Node_Str"",oldPath);
  }
  rawOutput.add(""String_Node_Str"");
  extractOutput(baosErr.toString());
  rawOutput.add(""String_Node_Str"");
  rawOutput.add(""String_Node_Str"");
  rawOutput.add(""String_Node_Str"");
  extractOutput(baosOut.toString());
}","private void invokeAcme(File sourceFile,File workingDirectory) throws ClassNotFoundException, SecurityException, NoSuchMethodException, IOException {
  String oldPath=System.getProperty(""String_Node_Str"");
  redirectSystemOutput();
  try {
    compiledAsset=File.createTempFile(sourceFile.getName(),""String_Node_Str"",sourceFile.getParentFile());
    System.setProperty(""String_Node_Str"",workingDirectory.getAbsolutePath());
    AcmeCrossAssembler acme=new AcmeCrossAssembler();
    String[] params={""String_Node_Str"",normalizeWindowsPath(compiledAsset.getAbsolutePath()),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",normalizeWindowsPath(sourceFile.getAbsolutePath())};
    int status=acme.run(""String_Node_Str"",params);
    successful=status == 0;
    if (!successful) {
      compiledAsset.delete();
      compiledAsset=null;
    }
  }
  finally {
    restoreSystemOutput();
    System.setProperty(""String_Node_Str"",oldPath);
  }
  rawOutput.add(""String_Node_Str"");
  extractOutput(baosErr.toString());
  rawOutput.add(""String_Node_Str"");
  rawOutput.add(""String_Node_Str"");
  rawOutput.add(""String_Node_Str"");
  extractOutput(baosOut.toString());
}"
12802,"public void execute(){
  lastResult=getHandler().compile(this);
  manageCompileResult(lastResult);
  if (lastResult.isSuccessful()) {
    getHandler().execute(lastResult);
  }
 else {
    getHandler().clean(lastResult);
  }
}","public void execute(){
  lastResult=getHandler().compile(this);
  manageCompileResult(lastResult);
  if (lastResult.isSuccessful()) {
    getHandler().execute(lastResult);
  }
 else {
    lastResult.getOtherMessages().forEach(System.err::println);
    getHandler().clean(lastResult);
  }
}"
12803,"private boolean isConfigDifferent(){
  boolean changed=false;
  AudioFormat newAf=getAudioFormat();
  changed|=(af == null || !newAf.matches(af));
  if (oldPreferredMixer == null) {
    changed|=preferredMixer.getValue() != null;
  }
 else {
    changed|=!oldPreferredMixer.matches(preferredMixer.getValue());
  }
  oldPreferredMixer=preferredMixer.getValue();
  return changed;
}","private boolean isConfigDifferent(){
  boolean changed=false;
  AudioFormat newAf=getAudioFormat();
  changed|=(af == null || !newAf.matches(af));
  if (oldPreferredMixer == null) {
    changed|=preferredMixer.getValue() != null;
  }
 else {
    changed|=!oldPreferredMixer.matches(Pattern.quote(preferredMixer.getValue()));
  }
  oldPreferredMixer=preferredMixer.getValue();
  return changed;
}"
12804,"public static void runFile(File binary){
  String fileName=binary.getName().toLowerCase();
  try {
    if (fileName.contains(""String_Node_Str"")) {
      String addressStr=fileName.substring(fileName.length() - 4);
      int address=Integer.parseInt(addressStr,16);
      brun(binary,address);
    }
 else     if (fileName.contains(""String_Node_Str"")) {
      gripe(""String_Node_Str"");
    }
  }
 catch (  NumberFormatException|IOException ex) {
  }
  Emulator.computer.getCpu().resume();
}","@InvokableAction(name=""String_Node_Str"",category=""String_Node_Str"",description=""String_Node_Str"",alternatives=""String_Node_Str"",defaultKeyMapping=""String_Node_Str"") public static void runFile(){
  Emulator.computer.pause();
  FileChooser select=new FileChooser();
  File binary=select.showOpenDialog(JaceApplication.getApplication().primaryStage);
  if (binary == null) {
    Emulator.computer.resume();
    return;
  }
  runFileNamed(binary);
}"
12805,"@Override public void reconfigure(){
  unregisterListeners();
  if (disk1 != null && !disk1.isEmpty()) {
    try {
      MediaEntry entry=MediaCache.getMediaFromFile(new File(disk1));
      drive1.insertMedia(entry,entry.files.get(0));
      disk1=null;
    }
 catch (    IOException ex) {
      Logger.getLogger(CardMassStorage.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  if (disk2 != null && !disk2.isEmpty()) {
    try {
      MediaEntry entry=MediaCache.getMediaFromFile(new File(disk2));
      drive2.insertMedia(entry,entry.files.get(0));
      disk2=null;
    }
 catch (    IOException ex) {
      Logger.getLogger(CardMassStorage.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  if (computer.getCpu() != null) {
    int pc=computer.getCpu().getProgramCounter();
    if (drive1.getCurrentDisk() != null && getSlot() == 7 && (pc >= 0x0c65e && pc <= 0x0c66F)) {
      currentDrive=drive1;
      EmulatorUILogic.simulateCtrlAppleReset();
    }
  }
  registerListeners();
}","@Override public void reconfigure(){
  unregisterListeners();
  if (disk1 != null && !disk1.isEmpty()) {
    try {
      MediaEntry entry=MediaCache.getMediaFromFile(new File(disk1));
      disk1=null;
      drive1.insertMedia(entry,entry.files.get(0));
    }
 catch (    IOException ex) {
      Logger.getLogger(CardMassStorage.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  if (disk2 != null && !disk2.isEmpty()) {
    try {
      MediaEntry entry=MediaCache.getMediaFromFile(new File(disk2));
      disk2=null;
      drive2.insertMedia(entry,entry.files.get(0));
    }
 catch (    IOException ex) {
      Logger.getLogger(CardMassStorage.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  if (computer.getCpu() != null) {
    int pc=computer.getCpu().getProgramCounter();
    if (drive1.getCurrentDisk() != null && getSlot() == 7 && (pc >= 0x0c65e && pc <= 0x0c66F)) {
      currentDrive=drive1;
      EmulatorUILogic.simulateCtrlAppleReset();
    }
  }
  registerListeners();
}"
12806,"@Override public void clearState(){
  A=0x0ff;
  X=0x0ff;
  Y=0x0ff;
  C=1;
  interruptSignalled=false;
  Z=true;
  I=true;
  D=true;
  B=true;
  V=true;
  N=true;
  STACK=0xff;
}","@Override public void clearState(){
  A=0x0ff;
  X=0x0ff;
  Y=0x0ff;
  C=1;
  interruptSignalled=false;
  Z=true;
  I=true;
  D=true;
  B=true;
  V=true;
  N=true;
  STACK=0xff;
  setWaitCycles(0);
}"
12807,"@Test public void testAdditionNonDecimal(){
  cpu.A=0;
  cpu.D=false;
  cpu.C=0;
  assemble(""String_Node_Str"");
  assertEquals(""String_Node_Str"",0,cpu.A);
  cpu.tick();
  assertEquals(""String_Node_Str"",1,cpu.A);
  assertFalse(""String_Node_Str"",cpu.Z);
}","@Test public void testAdditionNonDecimal(){
  cpu.A=0;
  cpu.D=false;
  cpu.C=0;
  assemble(""String_Node_Str"");
  assertEquals(""String_Node_Str"",1,cpu.A);
  assertFalse(""String_Node_Str"",cpu.Z);
}"
12808,"@Before public void setup(){
  cpu.suspend();
  for (int i=0; i < 1024; i++) {
    ram.write(i,(byte)0,false,false);
  }
  cpu.setProgramCounter(0);
  cpu.setWaitCycles(0);
  cpu.clearState();
}","@Before public void setup(){
  cpu.suspend();
  cpu.clearState();
}"
12809,"private void assemble(String code){
  HeadlessProgram program=new HeadlessProgram(Program.DocumentType.assembly);
  program.setValue(""String_Node_Str"" + code + ""String_Node_Str"");
  program.execute();
}","private void assemble(String code){
  assembleAt(code,0x0300);
}"
12810,"@Override public T getValue(){
  if (currentValue != null || allowNull()) {
    return currentValue;
  }
 else {
    Iterator<? extends T> i=getSelections().keySet().iterator();
    return i.next();
  }
}","@Override public T getValue(){
  if (currentValue != null || allowNull()) {
    return currentValue;
  }
 else {
    Iterator<? extends T> i=getSelections().keySet().iterator();
    if (i.hasNext()) {
      return i.next();
    }
 else {
      return null;
    }
  }
}"
12811,"@Override public void run(){
  try {
    SourceDataLine out=computer.mixer.getLine(this);
    int[] leftBuffer=new int[BUFFER_LENGTH];
    int[] rightBuffer=new int[BUFFER_LENGTH];
    int frameSize=out.getFormat().getFrameSize();
    byte[] buffer=new byte[BUFFER_LENGTH * frameSize];
    System.out.println(""String_Node_Str"");
    int bytesPerSample=frameSize / 2;
    buildMixerTable();
    ticksBeteenPlayback=(int)((Motherboard.SPEED * BUFFER_LENGTH) / SAMPLE_RATE);
    ticksSinceLastPlayback=0;
    int zeroSamples=0;
    setRun(true);
    while (isRunning()) {
      computer.getMotherboard().requestSpeed(this);
      playSound(leftBuffer,rightBuffer);
      int p=0;
      for (int idx=0; idx < BUFFER_LENGTH; idx++) {
        int sampleL=leftBuffer[idx];
        int sampleR=rightBuffer[idx];
        if (sampleL == 0 && sampleR == 0) {
          zeroSamples++;
        }
 else {
          zeroSamples=0;
        }
        for (int shift=SoundMixer.BITS - 8, index=0; shift >= 0; shift-=8, index++) {
          buffer[p + index]=(byte)(sampleR >> shift);
          buffer[p + index + bytesPerSample]=(byte)(sampleL >> shift);
        }
        p+=frameSize;
      }
      try {
        timerSync.lock();
        ticksSinceLastPlayback-=ticksBeteenPlayback;
      }
  finally {
        timerSync.unlock();
      }
      out.write(buffer,0,buffer.length);
      if (zeroSamples >= MAX_IDLE_SAMPLES) {
        zeroSamples=0;
        pause=true;
        computer.getMotherboard().cancelSpeedRequest(this);
        while (pause && isRunning()) {
          try {
            Thread.sleep(50);
            timerSync.lock();
            playbackFinished.signalAll();
          }
 catch (          InterruptedException ex) {
            return;
          }
catch (          IllegalMonitorStateException ex) {
          }
 finally {
            try {
              timerSync.unlock();
            }
 catch (            IllegalMonitorStateException ex) {
            }
          }
        }
      }
      try {
        timerSync.lock();
        playbackFinished.signalAll();
        while (isRunning() && ticksSinceLastPlayback < ticksBeteenPlayback) {
          cpuCountReached.await();
        }
      }
 catch (      InterruptedException ex) {
      }
 finally {
        timerSync.unlock();
      }
    }
  }
 catch (  LineUnavailableException ex) {
    Logger.getLogger(CardMockingboard.class.getName()).log(Level.SEVERE,null,ex);
  }
 finally {
    computer.getMotherboard().cancelSpeedRequest(this);
    System.out.println(""String_Node_Str"");
    computer.mixer.returnLine(this);
  }
}","@Override public void run(){
  try {
    SourceDataLine out=computer.mixer.getLine(this);
    int[] leftBuffer=new int[BUFFER_LENGTH];
    int[] rightBuffer=new int[BUFFER_LENGTH];
    int frameSize=out.getFormat().getFrameSize();
    byte[] buffer=new byte[BUFFER_LENGTH * frameSize];
    System.out.println(""String_Node_Str"");
    int bytesPerSample=frameSize / 2;
    buildMixerTable();
    ticksBeteenPlayback=(int)((Motherboard.SPEED * BUFFER_LENGTH) / SAMPLE_RATE);
    ticksSinceLastPlayback=0;
    int zeroSamples=0;
    setRun(true);
    while (isRunning()) {
      while (!computer.isRunning()) {
        Thread.sleep(500);
      }
      computer.getMotherboard().requestSpeed(this);
      playSound(leftBuffer,rightBuffer);
      int p=0;
      for (int idx=0; idx < BUFFER_LENGTH; idx++) {
        int sampleL=leftBuffer[idx];
        int sampleR=rightBuffer[idx];
        if (sampleL == 0 && sampleR == 0) {
          zeroSamples++;
        }
 else {
          zeroSamples=0;
        }
        for (int shift=SoundMixer.BITS - 8, index=0; shift >= 0; shift-=8, index++) {
          buffer[p + index]=(byte)(sampleR >> shift);
          buffer[p + index + bytesPerSample]=(byte)(sampleL >> shift);
        }
        p+=frameSize;
      }
      try {
        timerSync.lock();
        ticksSinceLastPlayback-=ticksBeteenPlayback;
      }
  finally {
        timerSync.unlock();
      }
      out.write(buffer,0,buffer.length);
      if (zeroSamples >= MAX_IDLE_SAMPLES) {
        zeroSamples=0;
        pause=true;
        computer.getMotherboard().cancelSpeedRequest(this);
        while (pause && isRunning()) {
          try {
            Thread.sleep(50);
            timerSync.lock();
            playbackFinished.signalAll();
          }
 catch (          InterruptedException ex) {
            return;
          }
catch (          IllegalMonitorStateException ex) {
          }
 finally {
            try {
              timerSync.unlock();
            }
 catch (            IllegalMonitorStateException ex) {
            }
          }
        }
      }
      try {
        timerSync.lock();
        playbackFinished.signalAll();
        while (isRunning() && ticksSinceLastPlayback < ticksBeteenPlayback) {
          cpuCountReached.await();
        }
      }
 catch (      InterruptedException ex) {
      }
 finally {
        timerSync.unlock();
      }
    }
  }
 catch (  LineUnavailableException ex) {
    Logger.getLogger(CardMockingboard.class.getName()).log(Level.SEVERE,null,ex);
  }
catch (  InterruptedException ex) {
    Logger.getLogger(CardMockingboard.class.getName()).log(Level.SEVERE,null,ex);
  }
 finally {
    computer.getMotherboard().cancelSpeedRequest(this);
    System.out.println(""String_Node_Str"");
    computer.mixer.returnLine(this);
  }
}"
12812,"public int readRegister(int reg){
  Register r=Register.fromInt(reg);
switch (r) {
case ORB:
    if (dataDirectionB == 0x0ff)     break;
  return receiveOutputB() & (dataDirectionB ^ 0x0ff);
case ORA:
case ORAH:
if (dataDirectionA == 0x0ff) break;
return receiveOutputA() & (dataDirectionA ^ 0x0ff);
case DDRB:
return dataDirectionB;
case DDRA:
return dataDirectionA;
case T1CL:
timer1IRQ=false;
timer1counter-=8;
return timer1counter & 0x0ff;
case T1CH:
timer1counter-=8;
return (timer1counter & 0x0ff00) >> 8;
case T1LL:
return timer1latch & 0x0ff;
case T1LH:
return (timer1latch & 0x0ff00) >> 8;
case T2CL:
timer2IRQ=false;
return timer2counter & 0x0ff;
case T2CH:
return (timer2counter & 0x0ff00) >> 8;
case SR:
return 0;
case ACR:
if (timer1freerun) return 64;
return 0;
case PCR:
break;
case IFR:
int val=0;
if (timer1IRQ) val|=64;
if (timer2IRQ) val|=32;
if (val != 0) val|=128;
return val;
case IER:
val=128;
if (timer1interruptEnabled) val|=64;
if (timer2interruptEnabled) val|=32;
return val;
}
return 0;
}","public int readRegister(int reg){
  Register r=Register.fromInt(reg);
switch (r) {
case ORB:
    if (dataDirectionB == 0x0ff) {
      break;
    }
  return receiveOutputB() & (dataDirectionB ^ 0x0ff);
case ORA:
case ORAH:
if (dataDirectionA == 0x0ff) {
  break;
}
return receiveOutputA() & (dataDirectionA ^ 0x0ff);
case DDRB:
return dataDirectionB;
case DDRA:
return dataDirectionA;
case T1CL:
timer1IRQ=false;
return timer1counter & 0x0ff;
case T1CH:
return (timer1counter & 0x0ff00) >> 8;
case T1LL:
return timer1latch & 0x0ff;
case T1LH:
return (timer1latch & 0x0ff00) >> 8;
case T2CL:
timer2IRQ=false;
return timer2counter & 0x0ff;
case T2CH:
return (timer2counter & 0x0ff00) >> 8;
case SR:
return 0;
case ACR:
if (timer1freerun) {
return 64;
}
return 0;
case PCR:
break;
case IFR:
int val=0;
if (timer1IRQ) {
val|=64;
}
if (timer2IRQ) {
val|=32;
}
if (val != 0) {
val|=128;
}
return val;
case IER:
val=128;
if (timer1interruptEnabled) {
val|=64;
}
if (timer2interruptEnabled) {
val|=32;
}
return val;
}
return 0;
}"
12813,"@Override public void tick(){
  if (timer1running) {
    timer1counter--;
    if (timer1counter < 0) {
      timer1counter=timer1latch;
      if (!timer1freerun)       timer1running=false;
      if (timer1interruptEnabled) {
        timer1IRQ=true;
        computer.getCpu().generateInterrupt();
      }
    }
  }
  if (timer2running) {
    timer2counter--;
    if (timer2counter < 0) {
      timer2running=false;
      timer2counter=timer2latch;
      if (timer2interruptEnabled) {
        timer2IRQ=true;
        computer.getCpu().generateInterrupt();
      }
    }
  }
  if (!timer1running && !timer2running)   setRun(false);
}","@Override public void tick(){
  if (timer1running) {
    timer1counter--;
    if (timer1counter < 0) {
      timer1counter=timer1latch;
      if (!timer1freerun) {
        timer1running=false;
      }
      if (timer1interruptEnabled) {
        timer1IRQ=true;
        computer.getCpu().generateInterrupt();
      }
    }
  }
  if (timer2running) {
    timer2counter--;
    if (timer2counter < 0) {
      timer2running=false;
      timer2counter=timer2latch;
      if (timer2interruptEnabled) {
        timer2IRQ=true;
        computer.getCpu().generateInterrupt();
      }
    }
  }
  if (!timer1running && !timer2running) {
    setRun(false);
  }
}"
12814,"public void writeRegister(int reg,int value){
  value&=0x0ff;
  Register r=Register.fromInt(reg);
switch (r) {
case ORB:
    if (dataDirectionB == 0)     break;
  value=value & dataDirectionB;
sendOutputB(value);
break;
case ORA:
if (dataDirectionA == 0) break;
value=value & dataDirectionA;
sendOutputA(value);
break;
case DDRB:
dataDirectionB=value;
break;
case DDRA:
dataDirectionA=value;
break;
case T1CL:
case T1LL:
timer1latch=(timer1latch & 0x0ff00) | value;
break;
case T1CH:
timer1latch=(timer1latch & 0x0ff) | (value << 8);
timer1IRQ=false;
timer1counter=timer1latch;
timer1running=true;
setRun(true);
break;
case T1LH:
timer1latch=(timer1latch & 0x0ff) | (value << 8);
timer1IRQ=false;
break;
case T2CL:
timer2latch=(timer2latch & 0x0ff00) | value;
break;
case T2CH:
timer2latch=(timer2latch & 0x0ff) | (value << 8);
timer2IRQ=false;
timer2counter=timer2latch;
timer2running=true;
setRun(true);
break;
case SR:
break;
case ACR:
timer1freerun=(value & 64) != 0;
if (timer1freerun) timer1running=true;
break;
case PCR:
break;
case IFR:
if ((value & 64) != 0) timer1IRQ=false;
if ((value & 32) != 0) timer2IRQ=false;
break;
case IER:
boolean enable=(value & 128) != 0;
if ((value & 64) != 0) timer1interruptEnabled=enable;
if ((value & 32) != 0) timer2interruptEnabled=enable;
break;
default :
}
}","public void writeRegister(int reg,int val){
  int value=val & 0x0ff;
  Register r=Register.fromInt(reg);
switch (r) {
case ORB:
    if (dataDirectionB == 0) {
      break;
    }
  sendOutputB(value & dataDirectionB);
break;
case ORA:
if (dataDirectionA == 0) {
break;
}
sendOutputA(value & dataDirectionA);
break;
case DDRB:
dataDirectionB=value;
break;
case DDRA:
dataDirectionA=value;
break;
case T1CL:
case T1LL:
timer1latch=(timer1latch & 0x0ff00) | value;
break;
case T1CH:
timer1latch=(timer1latch & 0x0ff) | (value << 8);
timer1IRQ=false;
timer1counter=timer1latch;
timer1running=true;
setRun(true);
break;
case T1LH:
timer1latch=(timer1latch & 0x0ff) | (value << 8);
timer1IRQ=false;
break;
case T2CL:
timer2latch=(timer2latch & 0x0ff00) | value;
break;
case T2CH:
timer2latch=(timer2latch & 0x0ff) | (value << 8);
timer2IRQ=false;
timer2counter=timer2latch;
timer2running=true;
setRun(true);
break;
case SR:
break;
case ACR:
timer1freerun=(value & 64) != 0;
if (timer1freerun) {
timer1running=true;
setRun(true);
}
break;
case PCR:
break;
case IFR:
if ((value & 64) != 0) {
timer1IRQ=false;
}
if ((value & 32) != 0) {
timer2IRQ=false;
}
break;
case IER:
boolean enable=(value & 128) != 0;
if ((value & 64) != 0) {
timer1interruptEnabled=enable;
}
if ((value & 32) != 0) {
timer2interruptEnabled=enable;
}
break;
default :
}
}"
12815,"public R6522(Computer computer){
  super(computer);
}","public R6522(Computer computer){
  super(computer);
  timer1freerun=true;
  timer1running=true;
  timer1latch=0x1fff;
  timer1interruptEnabled=false;
  setRun(true);
}"
12816,"static public Register fromInt(int i){
  for (  Register r : Register.values()) {
    if (r.val == i)     return r;
  }
  return null;
}","static public Register fromInt(int i){
  for (  Register r : Register.values()) {
    if (r.val == i) {
      return r;
    }
  }
  return null;
}"
12817,"public void setRate(int clock,int sample_rate){
  sampleRate=sample_rate;
  this.clock=clock;
  cyclesPerSample=clock / sampleRate;
}","public void setRate(int clock,int sample_rate){
  sampleRate=sample_rate == 0 ? 44100 : sample_rate;
  this.clock=clock;
  cyclesPerSample=clock / sampleRate;
}"
12818,"@Override public void readBlock(int block,byte[] buffer) throws IOException {
  int dataBlocks=(int)((getPhysicalFile().length() + ProdosVirtualDisk.BLOCK_SIZE - 1) / ProdosVirtualDisk.BLOCK_SIZE);
  int treeBlocks=(((dataBlocks * 2) + (ProdosVirtualDisk.BLOCK_SIZE - 2)) / ProdosVirtualDisk.BLOCK_SIZE);
  if (treeBlocks > 1) {
    treeBlocks++;
  }
switch (this.getType()) {
case SEEDLING:
    readFile(buffer,0);
  break;
case SAPLING:
if (block > 0) {
  readFile(buffer,(block - 1));
}
 else {
  generateIndex(buffer,0,dataBlocks);
}
break;
case TREE:
if (block == 0) {
generateIndex(buffer,1,treeBlocks);
}
 else if (block <= treeBlocks) {
int start=treeBlocks + ((block - 1) * 256);
int end=treeBlocks + dataBlocks;
generateIndex(buffer,start,end);
}
 else {
readFile(buffer,(block - treeBlocks - 1));
}
break;
}
}","@Override public void readBlock(int block,byte[] buffer) throws IOException {
  int dataBlocks=(int)((getPhysicalFile().length() + ProdosVirtualDisk.BLOCK_SIZE - 1) / ProdosVirtualDisk.BLOCK_SIZE);
  int treeBlocks=(((dataBlocks * 2) + (ProdosVirtualDisk.BLOCK_SIZE - 2)) / ProdosVirtualDisk.BLOCK_SIZE);
  if (treeBlocks > 1) {
    treeBlocks++;
  }
switch (this.getType()) {
case SEEDLING:
    readFile(buffer,0);
  break;
case SAPLING:
if (block > 0) {
  readFile(buffer,(block - 1));
}
 else {
  generateIndex(buffer,1,treeBlocks + dataBlocks);
}
break;
case TREE:
if (block == 0) {
generateIndex(buffer,1,treeBlocks);
}
 else if (block <= treeBlocks) {
int start=treeBlocks + ((block - 1) * 256);
int end=treeBlocks + dataBlocks;
generateIndex(buffer,start,end);
}
 else {
readFile(buffer,(block - treeBlocks - 1));
}
break;
}
}"
12819,"protected void displayDoubleLores(WritableImage screen,int xOffset,int y,int rowAddress){
  int c1=((RAM128k)computer.getMemory()).getAuxVideoMemory().readByte(rowAddress + xOffset) & 0x0FF;
  int c2=((RAM128k)computer.getMemory()).getMainMemory().readByte(rowAddress + xOffset) & 0x0FF;
  if ((y & 7) < 4) {
    c1&=15;
    c2&=15;
  }
 else {
    c1>>=4;
    c2>>=4;
  }
  PixelWriter writer=screen.getPixelWriter();
  Color color=Palette.color[c1];
  int xx=xOffset * 7;
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  color=Palette.color[c2];
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
}","protected void displayDoubleLores(WritableImage screen,int xOffset,int y,int rowAddress){
  int c1=((RAM128k)computer.getMemory()).getAuxVideoMemory().readByte(rowAddress + xOffset) & 0x0FF;
  int c2=((RAM128k)computer.getMemory()).getMainMemory().readByte(rowAddress + xOffset) & 0x0FF;
  if ((y & 7) < 4) {
    c1&=15;
    c2&=15;
  }
 else {
    c1>>=4;
    c2>>=4;
  }
  PixelWriter writer=screen.getPixelWriter();
  Color color=Palette.color[FLIP_NYBBLE[c1]];
  int xx=xOffset * 14;
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  color=Palette.color[c2];
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
}"
12820,"protected void showDhgr(WritableImage screen,int xOffset,int y,int dhgrWord){
  int xx=xOffset * 7;
  PixelWriter writer=screen.getPixelWriter();
  try {
    for (int i=0; i < 7; i++) {
      Color color=Palette.color[FLIP_NYBBLE[dhgrWord & 15]];
      writer.setColor(xx++,y,color);
      writer.setColor(xx++,y,color);
      writer.setColor(xx++,y,color);
      writer.setColor(xx++,y,color);
      dhgrWord>>=4;
    }
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
    Logger.getLogger(getClass().getName()).warning(""String_Node_Str"");
  }
}","protected void showDhgr(WritableImage screen,int xOffset,int y,int dhgrWord){
  PixelWriter writer=screen.getPixelWriter();
  try {
    for (int i=0; i < 7; i++) {
      Color color;
      if (!dhgrMode && hiresMode) {
        color=Palette.color[dhgrWord & 15];
      }
 else {
        color=Palette.color[FLIP_NYBBLE[dhgrWord & 15]];
      }
      writer.setColor(xOffset++,y,color);
      writer.setColor(xOffset++,y,color);
      writer.setColor(xOffset++,y,color);
      writer.setColor(xOffset++,y,color);
      dhgrWord>>=4;
    }
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
    Logger.getLogger(getClass().getName()).warning(""String_Node_Str"");
  }
}"
12821,"protected void displayLores(WritableImage screen,int xOffset,int y,int rowAddress){
  int c1=((RAM128k)computer.getMemory()).getMainMemory().readByte(rowAddress + xOffset) & 0x0FF;
  if ((y & 7) < 4) {
    c1&=15;
  }
 else {
    c1>>=4;
  }
  Color color=Palette.color[c1];
  PixelWriter writer=screen.getPixelWriter();
  int xx=xOffset * 7;
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
}","protected void displayLores(WritableImage screen,int xOffset,int y,int rowAddress){
  int c1=((RAM128k)computer.getMemory()).getMainMemory().readByte(rowAddress + xOffset) & 0x0FF;
  if ((y & 7) < 4) {
    c1&=15;
  }
 else {
    c1>>=4;
  }
  Color color=Palette.color[c1];
  PixelWriter writer=screen.getPixelWriter();
  int xx=xOffset * 14;
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
  writer.setColor(xx++,y,color);
}"
12822,"protected void showBW(WritableImage screen,int xOffset,int y,int dhgrWord){
  int xx=xOffset * 7;
  PixelWriter writer=screen.getPixelWriter();
  for (int i=0; i < 28; i++) {
    writer.setColor(xx++,y,(dhgrWord & 1) == 1 ? WHITE : BLACK);
    dhgrWord>>=1;
  }
}","protected void showBW(WritableImage screen,int xOffset,int y,int dhgrWord){
  int xx=xOffset;
  PixelWriter writer=screen.getPixelWriter();
  for (int i=0; i < 28; i++) {
    if (xx < 560) {
      writer.setColor(xx++,y,(dhgrWord & 1) == 1 ? WHITE : BLACK);
    }
    dhgrWord>>=1;
  }
}"
12823,"private File getDraggedFile(List<File> files){
  if (files == null || files.isEmpty()) {
    return null;
  }
  for (  File f : files) {
    if (f.isFile())     return f;
  }
  return null;
}","private File getDraggedFile(List<File> files){
  if (files == null || files.isEmpty()) {
    return null;
  }
  for (  File f : files) {
    if (f.exists())     return f;
  }
  return null;
}"
12824,"private void generateTimestamp(byte[] buffer,int offset,long date){
  Calendar c=Calendar.getInstance();
  c.setTimeInMillis(date);
  buffer[offset + 0]=0;
  buffer[offset + 1]=0;
  buffer[offset + 2]=0;
  buffer[offset + 3]=0;
}","private void generateTimestamp(byte[] buffer,int offset,long date){
  Calendar c=Calendar.getInstance();
  c.setTimeInMillis(date);
  buffer[offset + 1]=(byte)(((c.get(Calendar.YEAR) - 2000) << 1) | ((c.get(Calendar.MONTH) + 1) >> 3));
  buffer[offset + 0]=(byte)(((((c.get(Calendar.MONTH) + 1) & 7) << 5) | c.get(Calendar.DAY_OF_MONTH)) & 0x0ff);
  buffer[offset + 3]=(byte)c.get(Calendar.HOUR_OF_DAY);
  buffer[offset + 2]=(byte)c.get(Calendar.MINUTE);
}"
12825,"@Override public boolean accept(File file){
  if (file.getName().endsWith(""String_Node_Str""))   return false;
  char c=file.getName().charAt(0);
  if (c == '.' || c == '~') {
    return false;
  }
  return !file.isHidden();
}","@Override public boolean accept(File file){
  if (file.getName().endsWith(""String_Node_Str"")) {
    return false;
  }
  char c=file.getName().charAt(0);
  if (c == '.' || c == '~') {
    return false;
  }
  return !file.isHidden();
}"
12826,"@Override public void readBlock(int block,byte[] buffer) throws IOException {
  checkFile();
  if (block == 0) {
    generateHeader(buffer);
    for (int i=0; i < 12 && i < children.size(); i++)     generateFileEntry(buffer,4 + (i + 1) * FILE_ENTRY_SIZE,i);
  }
 else {
    int start=(block * 13) - 1;
    int end=start + 13;
    int offset=4;
    for (int i=start; i < end && i < children.size(); i++) {
      generateFileEntry(buffer,offset,i);
      offset+=FILE_ENTRY_SIZE;
    }
  }
}","@Override public void readBlock(int block,byte[] buffer) throws IOException {
  checkFile();
  if (block == 0) {
    generateHeader(buffer);
    for (int i=0; i < 12 && i < children.size(); i++) {
      generateFileEntry(buffer,4 + (i + 1) * FILE_ENTRY_SIZE,i);
    }
  }
 else {
    int start=(block * 13) - 1;
    int end=start + 13;
    int offset=4;
    for (int i=start; i < end && i < children.size(); i++) {
      generateFileEntry(buffer,offset,i);
      offset+=FILE_ENTRY_SIZE;
    }
  }
}"
12827,"/** 
 * Generate the directory header found in the base block of a directory
 * @param buffer where to write data
 */
@SuppressWarnings(""String_Node_Str"") private void generateHeader(byte[] buffer){
  generateWord(buffer,0,0);
  int nextBlock=0;
  if (!additionalNodes.isEmpty())   nextBlock=additionalNodes.get(0).baseBlock;
  generateWord(buffer,0x02,nextBlock);
  buffer[4]=(byte)((baseBlock == 0x02 ? 0x0f0 : 0x0E0) + getName().length());
  generateName(buffer,5,this);
  for (int i=0x014; i <= 0x01b; i++)   buffer[i]=0;
  generateTimestamp(buffer,0x01c,getPhysicalFile().lastModified());
  buffer[0x020]=0x019;
  buffer[0x021]=0x000;
  buffer[0x022]=0x03;
  buffer[0x023]=(byte)FILE_ENTRY_SIZE;
  buffer[0x024]=(byte)0x0d;
  generateWord(buffer,0x025,children.size());
  generateWord(buffer,0x027,ownerFilesystem.freespaceBitmap.baseBlock);
  generateWord(buffer,0x029,ownerFilesystem.MAX_BLOCK);
}","/** 
 * Generate the directory header found in the base block of a directory
 * @param buffer where to write data
 */
@SuppressWarnings(""String_Node_Str"") private void generateHeader(byte[] buffer){
  generateWord(buffer,0,0);
  int nextBlock=0;
  if (!additionalNodes.isEmpty()) {
    nextBlock=additionalNodes.get(0).baseBlock;
  }
  generateWord(buffer,0x02,nextBlock);
  buffer[4]=(byte)((baseBlock == 0x02 ? 0x0f0 : 0x0E0) + getName().length());
  generateName(buffer,5,this);
  for (int i=0x014; i <= 0x01b; i++) {
    buffer[i]=0;
  }
  generateTimestamp(buffer,0x01c,getPhysicalFile().lastModified());
  buffer[0x020]=0x019;
  buffer[0x021]=0x000;
  buffer[0x022]=0x03;
  buffer[0x023]=(byte)FILE_ENTRY_SIZE;
  buffer[0x024]=(byte)0x0d;
  generateWord(buffer,0x025,children.size());
  generateWord(buffer,0x027,ownerFilesystem.freespaceBitmap.baseBlock);
  generateWord(buffer,0x029,ownerFilesystem.MAX_BLOCK);
}"
12828,"/** 
 * Generate the entry of a directory
 * @param buffer where to write data
 * @param offset starting offset in buffer to write
 * @param fileNumber number of file (indexed in Children array) to write
 */
private void generateFileEntry(byte[] buffer,int offset,int fileNumber) throws IOException {
  DiskNode child=children.get(fileNumber);
  buffer[offset]=(byte)((child.getType().code << 4) + child.getName().length());
  generateName(buffer,offset + 1,child);
  buffer[offset + 0x010]=(byte)((child instanceof DirectoryNode) ? 0x0f : ((FileNode)child).fileType);
  generateWord(buffer,offset + 0x011,child.getBaseBlock());
  generateWord(buffer,offset + 0x013,1 + child.additionalNodes.size());
  int length=((int)child.physicalFile.length()) & 0x0ffffff;
  generateWord(buffer,offset + 0x015,length & 0x0ffff);
  buffer[offset + 0x017]=(byte)((length >> 16) & 0x0ff);
  generateTimestamp(buffer,offset + 0x018,child.physicalFile.lastModified());
  buffer[offset + 0x01c]=0x19;
  buffer[offset + 0x01d]=0;
  buffer[offset + 0x01e]=(byte)0x0ff;
  if (child instanceof FileNode)   generateWord(buffer,offset + 0x01f,((FileNode)child).loadAddress);
  generateTimestamp(buffer,offset + 0x021,child.physicalFile.lastModified());
  generateWord(buffer,offset + 0x025,getBaseBlock());
}","/** 
 * Generate the entry of a directory
 * @param buffer where to write data
 * @param offset starting offset in buffer to write
 * @param fileNumber number of file (indexed in Children array) to write
 */
private void generateFileEntry(byte[] buffer,int offset,int fileNumber) throws IOException {
  DiskNode child=children.get(fileNumber);
  child.allocate();
  buffer[offset]=(byte)((child.getType().code << 4) + child.getName().length());
  generateName(buffer,offset + 1,child);
  buffer[offset + 0x010]=(byte)((child instanceof DirectoryNode) ? 0x0f : ((FileNode)child).fileType);
  generateWord(buffer,offset + 0x011,child.getBaseBlock());
  generateWord(buffer,offset + 0x013,child.additionalNodes.size());
  int length=((int)child.physicalFile.length()) & 0x0ffffff;
  generateWord(buffer,offset + 0x015,length & 0x0ffff);
  buffer[offset + 0x017]=(byte)((length >> 16) & 0x0ff);
  generateTimestamp(buffer,offset + 0x018,child.physicalFile.lastModified());
  buffer[offset + 0x01c]=0x19;
  buffer[offset + 0x01d]=0;
  buffer[offset + 0x01e]=(byte)0x001;
  if (child instanceof FileNode) {
    generateWord(buffer,offset + 0x01f,((FileNode)child).loadAddress);
  }
  generateTimestamp(buffer,offset + 0x021,child.physicalFile.lastModified());
  generateWord(buffer,offset + 0x025,getBaseBlock());
}"
12829,"public void refresh(){
  ownerFilesystem.deallocateEntry(this);
  doRefresh();
  allocationTime=System.currentTimeMillis();
  allocated=true;
  ownerFilesystem.allocateEntry(this);
}","public void refresh() throws IOException {
  ownerFilesystem.deallocateEntry(this);
  doRefresh();
  allocationTime=System.currentTimeMillis();
  allocated=true;
  ownerFilesystem.allocateEntry(this);
}"
12830,"@Override public void setName(String name){
  String[] parts=name.split(""String_Node_Str"");
  FileType t=null;
  int offset=0;
  if (parts.length > 1) {
    String extension=parts[parts.length - 1].toUpperCase();
    String[] extParts=extension.split(""String_Node_Str"");
    if (extParts.length == 2) {
      offset=Integer.parseInt(extParts[1],16);
      extension=extParts[0];
    }
    try {
      t=FileType.valueOf(extension);
    }
 catch (    IllegalArgumentException ex) {
      System.out.println(""String_Node_Str"" + extension + ""String_Node_Str"");
    }
    name=""String_Node_Str"";
    for (int i=0; i < parts.length - 1; i++) {
      name+=(i > 0 ? ""String_Node_Str"" + parts[i] : parts[i]);
    }
    if (extParts[extParts.length - 1].equals(""String_Node_Str"")) {
      name+=""String_Node_Str"";
    }
  }
  if (t == null) {
    t=FileType.UNKNOWN;
  }
  if (offset == 0) {
    offset=t.defaultLoadAddress;
  }
  fileType=t.code;
  loadAddress=offset;
  super.setName(name);
}","@Override public void setName(String name){
  String[] parts=name.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"");
  FileType t=FileType.UNKNOWN;
  int offset=0;
  String prodosName=name;
  if (parts.length > 1) {
    String extension=parts[parts.length - 1].toUpperCase();
    String[] extParts=extension.split(""String_Node_Str"");
    if (extParts.length == 2) {
      offset=Integer.parseInt(extParts[1],16);
      extension=extParts[0];
    }
    try {
      t=FileType.valueOf(extension);
    }
 catch (    IllegalArgumentException ex) {
      System.out.println(""String_Node_Str"" + extension + ""String_Node_Str"");
    }
    prodosName=""String_Node_Str"";
    for (int i=0; i < parts.length - 1; i++) {
      prodosName+=(i > 0 ? ""String_Node_Str"" + parts[i] : parts[i]);
    }
    if (extParts[extParts.length - 1].equals(""String_Node_Str"")) {
      prodosName+=""String_Node_Str"";
    }
  }
  if (offset == 0) {
    offset=t.defaultLoadAddress;
  }
  fileType=t.code;
  loadAddress=offset;
  super.setName(prodosName);
}"
12831,"@Override public void readBlock(int block,byte[] buffer) throws IOException {
switch (this.getType()) {
case SEEDLING:
    readFile(buffer,0);
  break;
case SAPLING:
if (block > 0) {
  readFile(buffer,(block - 1));
}
 else {
  generateIndex(buffer,0,256);
}
break;
case TREE:
int dataBlocks=(int)((getPhysicalFile().length() / ProdosVirtualDisk.BLOCK_SIZE) + 1);
int treeBlocks=(dataBlocks / 256);
if (block == 0) {
generateIndex(buffer,0,treeBlocks);
}
 else if (block < treeBlocks) {
int start=treeBlocks + (block - 1 * 256);
int end=Math.min(start + 256,treeBlocks);
generateIndex(buffer,treeBlocks,end);
}
 else {
readFile(buffer,(block - treeBlocks));
}
break;
}
}","@Override public void readBlock(int block,byte[] buffer) throws IOException {
  int dataBlocks=(int)((getPhysicalFile().length() + ProdosVirtualDisk.BLOCK_SIZE - 1) / ProdosVirtualDisk.BLOCK_SIZE);
  int treeBlocks=(((dataBlocks * 2) + (ProdosVirtualDisk.BLOCK_SIZE - 2)) / ProdosVirtualDisk.BLOCK_SIZE);
  if (treeBlocks > 1)   treeBlocks++;
switch (this.getType()) {
case SEEDLING:
    readFile(buffer,0);
  break;
case SAPLING:
if (block > 0) {
  readFile(buffer,(block - 1));
}
 else {
  generateIndex(buffer,0,dataBlocks);
}
break;
case TREE:
if (block == 0) {
System.out.println(""String_Node_Str"" + getName());
generateIndex(buffer,1,treeBlocks);
}
 else if (block <= treeBlocks) {
System.out.println(""String_Node_Str"" + block + ""String_Node_Str""+ getName());
int start=treeBlocks + ((block - 1) * 256);
int end=treeBlocks + dataBlocks;
generateIndex(buffer,start,end);
}
 else {
readFile(buffer,(block - treeBlocks - 1));
}
break;
}
}"
12832,"private void generateIndex(byte[] buffer,int indexStart,int indexLimit){
  int pos=0;
  for (int i=indexStart; pos < 256 && i < indexLimit && i < additionalNodes.size(); i++, pos++) {
    buffer[pos]=(byte)(additionalNodes.get(i).baseBlock & 0x0ff);
    buffer[pos + 256]=(byte)((additionalNodes.get(i).baseBlock >> 8) & 0x0ff);
  }
}","private void generateIndex(byte[] buffer,int indexStart,int indexLimit){
  System.out.println(""String_Node_Str"");
  Arrays.fill(buffer,(byte)0);
  for (int i=indexStart, count=0; count < 256 && i < indexLimit && i < additionalNodes.size(); i++, count++) {
    int base=additionalNodes.get(i).baseBlock;
    System.out.print(Integer.toHexString(base) + ""String_Node_Str"");
    buffer[count]=(byte)(base & 0x0ff);
    buffer[count + 256]=(byte)(base >> 8);
  }
  System.out.println();
  for (int i=0; i < 256; i++) {
    System.out.printf(""String_Node_Str"",buffer[i] & 0x0ff);
  }
  System.out.println();
  for (int i=256; i < 512; i++) {
    System.out.printf(""String_Node_Str"",buffer[i] & 0x0ff);
  }
  System.out.println();
}"
12833,"@Override public EntryType getType(){
  long fileSize=getPhysicalFile().length();
  if (fileSize <= SEEDLING_MAX_SIZE) {
    setType(EntryType.SEEDLING);
    return EntryType.SEEDLING;
  }
 else   if (fileSize <= SAPLING_MAX_SIZE) {
    setType(EntryType.SAPLING);
    return EntryType.SAPLING;
  }
  setType(EntryType.TREE);
  return EntryType.TREE;
}","@Override public EntryType getType(){
  long fileSize=getPhysicalFile().length();
  if (fileSize <= SEEDLING_MAX_SIZE) {
    setType(EntryType.SEEDLING);
    return EntryType.SEEDLING;
  }
 else   if (fileSize <= SAPLING_MAX_SIZE) {
    setType(EntryType.SAPLING);
    return EntryType.SAPLING;
  }
 else {
    setType(EntryType.TREE);
    return EntryType.TREE;
  }
}"
12834,"@Override public void doAllocate() throws IOException {
  int dataBlocks=(int)((getPhysicalFile().length() / ProdosVirtualDisk.BLOCK_SIZE) + 1);
  int treeBlocks;
  if (dataBlocks > 1 && dataBlocks < 257) {
    treeBlocks=1;
  }
 else {
    treeBlocks=1 + (dataBlocks / 256);
  }
  for (int i=1; i < dataBlocks + treeBlocks; i++) {
    SubNode subNode=new SubNode(i,this);
  }
}","@Override public void doAllocate() throws IOException {
  int dataBlocks=(int)((getPhysicalFile().length() + ProdosVirtualDisk.BLOCK_SIZE - 1) / ProdosVirtualDisk.BLOCK_SIZE);
  int treeBlocks=(((dataBlocks * 2) + (ProdosVirtualDisk.BLOCK_SIZE - 2)) / ProdosVirtualDisk.BLOCK_SIZE);
  if (treeBlocks > 1)   treeBlocks++;
  System.out.println(""String_Node_Str"" + (dataBlocks + treeBlocks) + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ dataBlocks+ ""String_Node_Str""+ treeBlocks);
  for (int i=0; i < dataBlocks + treeBlocks; i++) {
    new SubNode(i,this);
  }
  setBaseBlock(additionalNodes.get(0).getBaseBlock());
}"
12835,"public FileNode(ProdosVirtualDisk ownerFilesystem,File file) throws IOException {
  setOwnerFilesystem(ownerFilesystem);
  setPhysicalFile(file);
}","public FileNode(ProdosVirtualDisk ownerFilesystem,File file) throws IOException {
  setOwnerFilesystem(ownerFilesystem);
  setPhysicalFile(file);
  setName(file.getName());
}"
12836,"private void init(ProdosVirtualDisk ownerFilesystem,File physicalFile,boolean root) throws IOException {
  isRoot=root;
  setPhysicalFile(physicalFile);
  setType(EntryType.SUBDIRECTORY);
  setName(physicalFile.getName());
}","private void init(ProdosVirtualDisk ownerFilesystem,File physicalFile,boolean root) throws IOException {
  isRoot=root;
  directoryEntries=new ArrayList<>();
  setPhysicalFile(physicalFile);
  setType(EntryType.SUBDIRECTORY);
  setName(physicalFile.getName());
  allocate();
}"
12837,"private void generatePointers(byte[] buffer,int prevBlock,int nextBlock){
  generateWord(buffer,0,prevBlock);
  generateWord(buffer,0x02,nextBlock);
}","private void generatePointers(byte[] buffer,int sequence){
  DiskNode prev=getNodeSequence(sequence - 1);
  DiskNode next=getNodeSequence(sequence + 1);
  generateWord(buffer,0,prev != null ? prev.getBaseBlock() : 0);
  generateWord(buffer,0x02,next != null ? next.getBaseBlock() : 0);
}"
12838,"private void generateName(byte[] buffer,int offset,DiskNode node){
  for (int i=0; i < node.getName().length(); i++) {
    buffer[offset + i]=(byte)node.getName().charAt(i);
  }
}","private void generateName(byte[] buffer,int offset,DiskNode node){
  for (int i=0; i < node.getName().length() && i < 15; i++) {
    buffer[offset + i]=(byte)node.getName().charAt(i);
  }
}"
12839,"@Override public void readBlock(int block,byte[] buffer) throws IOException {
  Arrays.fill(buffer,(byte)0);
  checkFile();
  if (block == 0) {
    generateHeader(buffer);
    for (int i=0; i < 12 && i < children.size(); i++) {
      generateFileEntry(buffer,4 + (i + 1) * FILE_ENTRY_SIZE,i);
    }
  }
 else {
    generatePointers(buffer,getNodeSequence(block - 1).getBaseBlock(),getNodeSequence(block + 1) != null ? getNodeSequence(block + 1).getBaseBlock() : 0);
    int start=(block * 13) - 1;
    int end=start + 13;
    int offset=4;
    for (int i=start; i < end && i < children.size(); i++) {
      generateFileEntry(buffer,offset,i);
      offset+=FILE_ENTRY_SIZE;
    }
  }
}","@Override public void readBlock(int block,byte[] buffer) throws IOException {
  checkFile();
  int start=0;
  int end=0;
  int offset=4;
  generatePointers(buffer,block);
  if (block == 0) {
    generateHeader(buffer);
    offset+=FILE_ENTRY_SIZE;
    end=ENTRIES_PER_BLOCK - 1;
  }
 else {
    start=(block * ENTRIES_PER_BLOCK) - 1;
    end=start + ENTRIES_PER_BLOCK;
  }
  for (int i=start; i < end && i < directoryEntries.size(); i++, offset+=FILE_ENTRY_SIZE) {
    generateFileEntry(buffer,offset,i);
  }
}"
12840,"/** 
 * Generate the directory header found in the base block of a directory
 * @param buffer where to write data
 */
@SuppressWarnings(""String_Node_Str"") private void generateHeader(byte[] buffer){
  generatePointers(buffer,0,getNodeSequence(1) == null ? 0 : getNodeSequence(1).getBaseBlock());
  buffer[4]=(byte)((isRoot ? 0x0F0 : 0x0E0) | getName().length());
  generateName(buffer,5,this);
  for (int i=0x014; i <= 0x01b; i++) {
    buffer[i]=0;
  }
  if (!isRoot) {
    buffer[0x014]=0x075;
  }
  generateTimestamp(buffer,0x01c,getPhysicalFile().lastModified());
  buffer[0x020]=0x019;
  buffer[0x021]=0x000;
  buffer[0x022]=0x03;
  buffer[0x023]=(byte)FILE_ENTRY_SIZE;
  buffer[0x024]=(byte)0x0d;
  generateWord(buffer,0x025,children.size());
  if (isRoot) {
    generateWord(buffer,0x027,ownerFilesystem.freespaceBitmap.getBaseBlock());
    generateWord(buffer,0x029,ownerFilesystem.MAX_BLOCK);
  }
 else {
    generateWord(buffer,0x027,getParent().getBaseBlock());
    buffer[0x029]=(byte)(getParent().getChildren().indexOf(this) + 1);
    buffer[0x02a]=0x027;
  }
}","/** 
 * Generate the directory header found in the base block of a directory
 * @param buffer where to write data
 */
@SuppressWarnings(""String_Node_Str"") private void generateHeader(byte[] buffer){
  buffer[4]=(byte)((isRoot ? 0x0F0 : 0x0E0) | getName().length());
  generateName(buffer,5,this);
  if (!isRoot) {
    buffer[0x014]=0x075;
    buffer[0x015]=PRODOS_VERSION;
    buffer[0x017]=STANDARD_PERMISSIONS;
    buffer[0x018]=FILE_ENTRY_SIZE;
    buffer[0x019]=ENTRIES_PER_BLOCK;
  }
  generateTimestamp(buffer,0x01c,getPhysicalFile().lastModified());
  buffer[0x020]=PRODOS_VERSION;
  buffer[0x021]=0x000;
  buffer[0x022]=STANDARD_PERMISSIONS;
  buffer[0x023]=(byte)FILE_ENTRY_SIZE;
  buffer[0x024]=(byte)ENTRIES_PER_BLOCK;
  generateWord(buffer,0x025,directoryEntries.size() + 1);
  if (isRoot) {
    generateWord(buffer,0x027,ownerFilesystem.freespaceBitmap.getBaseBlock());
    generateWord(buffer,0x029,ownerFilesystem.MAX_BLOCK);
  }
 else {
    int indexInParent=getParent().getChildren().indexOf(this) + 2;
    int parentBlock=getParent().getNodeSequence(indexInParent / ENTRIES_PER_BLOCK).getBaseBlock();
    generateWord(buffer,0x027,parentBlock);
    buffer[0x029]=(byte)(indexInParent % ENTRIES_PER_BLOCK);
    buffer[0x02a]=(byte)FILE_ENTRY_SIZE;
  }
}"
12841,"@Override public void doAllocate() throws IOException {
  File[] files=physicalFile.listFiles(this);
  int numEntries=files.length;
  int numBlocks=1 + numEntries / 13;
  for (int i=1; i < numBlocks; i++) {
    new SubNode(i,this,getOwnerFilesystem().getNextFreeBlock());
  }
  for (  File f : files) {
    addFile(f);
  }
  Collections.sort(children,(  DiskNode o1,  DiskNode o2) -> o1.getName().compareTo(o2.getName()));
}","@Override public void doAllocate() throws IOException {
  for (int i=1; i < getBlockCount(); i++) {
    if (isRoot) {
      new SubNode(i,this,getOwnerFilesystem().getNextFreeBlock(3));
    }
 else {
      new SubNode(i,this);
    }
  }
  for (  File f : physicalFile.listFiles()) {
    addFile(f);
  }
  Collections.sort(children,(  DiskNode o1,  DiskNode o2) -> o1.getName().compareTo(o2.getName()));
}"
12842,"/** 
 * Generate the entry of a directory
 * @param buffer where to write data
 * @param offset starting offset in buffer to write
 * @param fileNumber number of file (indexed in Children array) to write
 */
private void generateFileEntry(byte[] buffer,int offset,int fileNumber) throws IOException {
  DiskNode child=children.get(fileNumber);
  buffer[offset]=(byte)((child.getType().code << 4) + child.getName().length());
  generateName(buffer,offset + 1,child);
  buffer[offset + 0x010]=(byte)((child instanceof DirectoryNode) ? 0x0f : ((FileNode)child).fileType);
  generateWord(buffer,offset + 0x011,child.getBaseBlock());
  generateWord(buffer,offset + 0x013,child.additionalNodes.size());
  int length=((int)child.physicalFile.length()) & 0x0ffffff;
  generateWord(buffer,offset + 0x015,length & 0x0ffff);
  buffer[offset + 0x017]=(byte)((length >> 16) & 0x0ff);
  generateTimestamp(buffer,offset + 0x018,child.physicalFile.lastModified());
  buffer[offset + 0x01c]=0x19;
  buffer[offset + 0x01d]=0;
  buffer[offset + 0x01e]=(byte)0x001;
  if (child instanceof FileNode) {
    generateWord(buffer,offset + 0x01f,((FileNode)child).loadAddress);
  }
  generateTimestamp(buffer,offset + 0x021,child.physicalFile.lastModified());
  generateWord(buffer,offset + 0x025,getBaseBlock());
}","/** 
 * Generate the entry of a directory
 * @param buffer where to write data
 * @param offset starting offset in buffer to write
 * @param fileNumber number of file (indexed in Children array) to write
 */
private void generateFileEntry(byte[] buffer,int offset,int fileNumber) throws IOException {
  DiskNode child=directoryEntries.get(fileNumber);
  buffer[offset]=(byte)((child.getType().code << 4) | child.getName().length());
  generateName(buffer,offset + 1,child);
  buffer[offset + 0x010]=(byte)((child instanceof DirectoryNode) ? 0x0f : ((FileNode)child).fileType);
  generateWord(buffer,offset + 0x011,child.getBaseBlock());
  generateWord(buffer,offset + 0x013,child.additionalNodes.size() + 1);
  int length=child.getLength();
  length&=0x0ffffff;
  generateWord(buffer,offset + 0x015,length & 0x0ffff);
  buffer[offset + 0x017]=(byte)((length >> 16) & 0x0ff);
  generateTimestamp(buffer,offset + 0x018,child.physicalFile.lastModified());
  buffer[offset + 0x01c]=PRODOS_VERSION;
  buffer[offset + 0x01d]=0;
  buffer[offset + 0x01e]=STANDARD_PERMISSIONS;
  if (child instanceof FileNode) {
    generateWord(buffer,offset + 0x01f,((FileNode)child).loadAddress);
  }
  generateTimestamp(buffer,offset + 0x021,child.physicalFile.lastModified());
  generateWord(buffer,offset + 0x025,getBaseBlock());
}"
12843,"private void addFile(File file){
  try {
    if (file.isDirectory()) {
      addChild(new DirectoryNode(getOwnerFilesystem(),file,false));
    }
 else {
      addChild(new FileNode(getOwnerFilesystem(),file));
    }
  }
 catch (  IOException ex) {
    Logger.getLogger(DirectoryNode.class.getName()).log(Level.SEVERE,null,ex);
  }
}","private void addFile(File file){
  if (!hasChildNamed(file.getName())) {
    try {
      if (file.isDirectory()) {
        addFileEntry(new DirectoryNode(getOwnerFilesystem(),file,false));
      }
 else {
        addFileEntry(new FileNode(getOwnerFilesystem(),file));
      }
    }
 catch (    IOException ex) {
      Logger.getLogger(DirectoryNode.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
}"
12844,"@Override public boolean checkFile() throws IOException {
  boolean success=true;
  if (!super.checkFile()) {
    return false;
  }
  HashSet<String> realFiles=new HashSet<>();
  File[] realFileList=physicalFile.listFiles(this);
  for (  File f : realFileList) {
    realFiles.add(f.getName());
  }
  for (Iterator<DiskNode> i=getChildren().iterator(); i.hasNext(); ) {
    DiskNode node=i.next();
    if (realFiles.contains(node.getPhysicalFile().getName())) {
      realFiles.remove(node.getPhysicalFile().getName());
    }
 else {
      i.remove();
      success=false;
    }
    if (node.isAllocated()) {
      if (!(node instanceof DirectoryNode) && !node.checkFile()) {
        success=false;
      }
    }
  }
  if (!realFiles.isEmpty()) {
    success=false;
    realFiles.stream().forEach((fileName) -> {
      addFile(new File(physicalFile,fileName));
    }
);
  }
  return success;
}","@Override public boolean checkFile() throws IOException {
  boolean success=true;
  if (!allocated) {
    allocate();
  }
 else {
    try {
      if (!super.checkFile()) {
        return false;
      }
      HashSet<String> realFiles=new HashSet<>();
      File[] realFileList=physicalFile.listFiles(this);
      for (      File f : realFileList) {
        realFiles.add(f.getName());
      }
      for (Iterator<DiskNode> i=directoryEntries.iterator(); i.hasNext(); ) {
        DiskNode node=i.next();
        if (realFiles.contains(node.getPhysicalFile().getName())) {
          realFiles.remove(node.getPhysicalFile().getName());
        }
 else {
          i.remove();
          success=false;
        }
        if (node.isAllocated()) {
          if (!(node instanceof DirectoryNode) && !node.checkFile()) {
            success=false;
          }
        }
      }
      if (!realFiles.isEmpty()) {
        success=false;
        realFiles.stream().forEach((fileName) -> {
          addFile(new File(physicalFile,fileName));
        }
);
      }
    }
 catch (    IOException ex) {
      return false;
    }
  }
  return success;
}"
12845,"@Override public final void reconfigure(){
  boolean restart=pause();
  super.reconfigure();
  RAM128k currentMemory=(RAM128k)getMemory();
  if (currentMemory != null && ramCard.getValue() != null && !(currentMemory.getClass().equals(ramCard.getValue()))) {
    try {
      RAM128k newMemory=(RAM128k)ramCard.getValue().getConstructor(Computer.class).newInstance(this);
      newMemory.copyFrom(currentMemory);
      setMemory(newMemory);
    }
 catch (    InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException|NoSuchMethodException|SecurityException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  if (getMemory() == null) {
    try {
      currentMemory=(RAM128k)ramCard.getValue().getConstructor(Computer.class).newInstance(this);
    }
 catch (    InstantiationException|IllegalAccessException|NoSuchMethodException|SecurityException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
catch (    IllegalArgumentException|InvocationTargetException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
    try {
      setMemory(currentMemory);
      for (      SoftSwitches s : SoftSwitches.values()) {
        s.getSwitch().register(this);
      }
    }
 catch (    Throwable ex) {
    }
  }
  currentMemory.reconfigure();
  if (motherboard != null) {
    if (joy1enabled) {
      if (joystick1 == null) {
        joystick1=new Joystick(0,this);
        motherboard.miscDevices.add(joystick1);
        joystick1.attach();
      }
    }
 else     if (joystick1 != null) {
      joystick1.detach();
      motherboard.miscDevices.remove(joystick1);
      joystick1=null;
    }
    if (joy2enabled) {
      if (joystick2 == null) {
        joystick2=new Joystick(1,this);
        motherboard.miscDevices.add(joystick2);
        joystick2.attach();
      }
    }
 else     if (joystick2 != null) {
      joystick2.detach();
      motherboard.miscDevices.remove(joystick2);
      joystick2=null;
    }
    if (clockEnabled) {
      if (clock == null) {
        clock=new NoSlotClock(this);
        motherboard.miscDevices.add(clock);
        clock.attach();
      }
    }
 else     if (clock != null) {
      motherboard.miscDevices.remove(clock);
      clock.detach();
      clock=null;
    }
  }
  try {
    if (useConsoleProbe) {
      probe.init(this);
    }
 else {
      probe.shutdown();
    }
    if (useDebugRom) {
      loadRom(""String_Node_Str"");
    }
 else {
      loadRom(""String_Node_Str"");
    }
    if (getVideo() == null || getVideo().getClass() != videoRenderer.getValue()) {
      if (getVideo() != null) {
        getVideo().suspend();
      }
      try {
        setVideo((Video)videoRenderer.getValue().getConstructor(Computer.class).newInstance(this));
        getVideo().configureVideoMode();
        getVideo().reconfigure();
        Emulator.resizeVideo();
        getVideo().resume();
      }
 catch (      InstantiationException|IllegalAccessException ex) {
        Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
      }
catch (      NoSuchMethodException|SecurityException|IllegalArgumentException|InvocationTargetException ex) {
        Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
    try {
      insertCard(card1.getValue(),1);
      insertCard(card2.getValue(),2);
      insertCard(card3.getValue(),3);
      insertCard(card4.getValue(),4);
      insertCard(card5.getValue(),5);
      insertCard(card6.getValue(),6);
      insertCard(card7.getValue(),7);
    }
 catch (    NoSuchMethodException|IllegalArgumentException|InvocationTargetException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
    if (enableHints) {
      enableHints();
    }
 else {
      disableHints();
    }
    getMemory().configureActiveMemory();
    if (cheatEngine.getValue() == null) {
      if (activeCheatEngine != null) {
        activeCheatEngine.detach();
      }
      activeCheatEngine=null;
    }
 else {
      boolean startCheats=true;
      if (activeCheatEngine != null) {
        if (activeCheatEngine.getClass().equals(cheatEngine.getValue())) {
          startCheats=false;
        }
 else {
          activeCheatEngine.detach();
          activeCheatEngine=null;
        }
      }
      if (startCheats) {
        try {
          activeCheatEngine=(Cheats)cheatEngine.getValue().newInstance();
        }
 catch (        InstantiationException|IllegalAccessException ex) {
          Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
        }
        activeCheatEngine.attach();
      }
    }
  }
 catch (  IOException ex) {
    Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
  }
  if (restart) {
    resume();
  }
}","@Override public final void reconfigure(){
  boolean restart=pause();
  super.reconfigure();
  RAM128k currentMemory=(RAM128k)getMemory();
  if (currentMemory != null && ramCard.getValue() != null && !(currentMemory.getClass().equals(ramCard.getValue()))) {
    try {
      RAM128k newMemory=(RAM128k)ramCard.getValue().getConstructor(Computer.class).newInstance(this);
      newMemory.copyFrom(currentMemory);
      setMemory(newMemory);
    }
 catch (    InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException|NoSuchMethodException|SecurityException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  if (getMemory() == null) {
    try {
      currentMemory=(RAM128k)ramCard.getValue().getConstructor(Computer.class).newInstance(this);
    }
 catch (    InstantiationException|IllegalAccessException|NoSuchMethodException|SecurityException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
catch (    IllegalArgumentException|InvocationTargetException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
    try {
      setMemory(currentMemory);
      for (      SoftSwitches s : SoftSwitches.values()) {
        s.getSwitch().register(this);
      }
    }
 catch (    Throwable ex) {
    }
  }
  currentMemory.reconfigure();
  if (motherboard != null) {
    if (joy1enabled) {
      if (joystick1 == null) {
        joystick1=new Joystick(0,this);
        motherboard.miscDevices.add(joystick1);
        joystick1.attach();
      }
    }
 else     if (joystick1 != null) {
      joystick1.detach();
      motherboard.miscDevices.remove(joystick1);
      joystick1=null;
    }
    if (joy2enabled) {
      if (joystick2 == null) {
        joystick2=new Joystick(1,this);
        motherboard.miscDevices.add(joystick2);
        joystick2.attach();
      }
    }
 else     if (joystick2 != null) {
      joystick2.detach();
      motherboard.miscDevices.remove(joystick2);
      joystick2=null;
    }
    if (clockEnabled) {
      if (clock == null) {
        clock=new NoSlotClock(this);
        motherboard.miscDevices.add(clock);
        clock.attach();
      }
    }
 else     if (clock != null) {
      motherboard.miscDevices.remove(clock);
      clock.detach();
      clock=null;
    }
  }
  try {
    if (useConsoleProbe) {
      probe.init(this);
    }
 else {
      probe.shutdown();
    }
    if (useDebugRom) {
      loadRom(""String_Node_Str"");
    }
 else {
      loadRom(""String_Node_Str"");
    }
    if (getVideo() == null || getVideo().getClass() != videoRenderer.getValue()) {
      if (getVideo() != null) {
        getVideo().suspend();
      }
      try {
        setVideo((Video)videoRenderer.getValue().getConstructor(Computer.class).newInstance(this));
        getVideo().configureVideoMode();
        getVideo().reconfigure();
        Emulator.resizeVideo();
        getVideo().resume();
      }
 catch (      InstantiationException|IllegalAccessException ex) {
        Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
      }
catch (      NoSuchMethodException|SecurityException|IllegalArgumentException|InvocationTargetException ex) {
        Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
    try {
      insertCard(card1.getValue(),1);
      insertCard(card2.getValue(),2);
      insertCard(card3.getValue(),3);
      insertCard(card4.getValue(),4);
      insertCard(card5.getValue(),5);
      insertCard(card6.getValue(),6);
      insertCard(card7.getValue(),7);
    }
 catch (    NoSuchMethodException|IllegalArgumentException|InvocationTargetException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
    if (enableHints) {
      enableHints();
    }
 else {
      disableHints();
    }
    getMemory().configureActiveMemory();
    if (cheatEngine.getValue() == null) {
      if (activeCheatEngine != null) {
        activeCheatEngine.detach();
      }
      activeCheatEngine=null;
    }
 else {
      boolean startCheats=true;
      if (activeCheatEngine != null) {
        if (activeCheatEngine.getClass().equals(cheatEngine.getValue())) {
          startCheats=false;
        }
 else {
          activeCheatEngine.detach();
          activeCheatEngine=null;
        }
      }
      if (startCheats) {
        try {
          activeCheatEngine=(Cheats)cheatEngine.getValue().getConstructor(Computer.class).newInstance(this);
        }
 catch (        InstantiationException|IllegalAccessException|NoSuchMethodException|SecurityException|IllegalArgumentException|InvocationTargetException ex) {
          Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
        }
        activeCheatEngine.attach();
      }
    }
  }
 catch (  IOException ex) {
    Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
  }
  if (restart) {
    resume();
  }
}"
12846,"private void reinitMotherboard(){
  if (motherboard != null && motherboard.isRunning()) {
    motherboard.suspend();
  }
  motherboard=new Motherboard(this);
  motherboard.reconfigure();
}","private void reinitMotherboard(){
  if (motherboard != null && motherboard.isRunning()) {
    motherboard.suspend();
  }
  motherboard=new Motherboard(this,motherboard);
  reconfigure();
  motherboard.reconfigure();
}"
12847,"public void resume(){
  setRun(true);
}","public void resume(){
  setRun(true);
  waitCycles=0;
}"
12848,"/** 
 * Creates a new instance of Motherboard
 * @param computer
 */
public Motherboard(Computer computer){
  super(computer);
}","/** 
 * Creates a new instance of Motherboard
 * @param computer
 * @param oldMotherboard
 */
public Motherboard(Computer computer,Motherboard oldMotherboard){
  super(computer);
  if (oldMotherboard != null) {
    miscDevices.addAll(oldMotherboard.miscDevices);
    speaker=oldMotherboard.speaker;
  }
}"
12849,"@Override protected void doEvent(RAMEvent e){
  setRun(true);
  readJoystick();
  xSwitch.setState(true);
  x=10 + joyX * 11;
  ySwitch.setState(true);
  y=10 + joyY * 11;
  e.setNewValue(computer.getVideo().getFloatingBus());
}","@Override protected void doEvent(RAMEvent e){
  readJoystick();
  xSwitch.setState(true);
  x=10 + joyX * 11;
  ySwitch.setState(true);
  y=10 + joyY * 11;
  e.setNewValue(computer.getVideo().getFloatingBus());
  resume();
}"
12850,"@Override void registerListeners(){
  if (repulsiveHack) {
    addCheat(RAMEvent.TYPE.WRITE,this::repulsiveBehavior,0x1508,0x1518);
  }
  if (featherFall) {
    addCheat(RAMEvent.TYPE.WRITE,this::featherFallBehavior,PLAYER_Y);
    bypassCode(0x6bb3,0x6bb4);
  }
  if (moonJump) {
    addCheat(RAMEvent.TYPE.WRITE,this::moonJumpBehavior,Y_VELOCITY);
  }
  if (infiniteLives) {
    forceValue(LIVES,11);
  }
  if (scoreHack) {
    forceValue(0x90,SCORE);
    forceValue(0x09,SCORE + 1);
    forceValue(0x13,SCORE + 2);
  }
  if (snakeCharmer) {
    bypassCode(0x07963,0x07964);
  }
  if (mouseHack) {
    EmulatorUILogic.addMouseListener(listener);
  }
 else {
    EmulatorUILogic.removeMouseListener(listener);
  }
}","@Override void registerListeners(){
}"
12851,"static TOKEN findMatch(String search,int start){
  for (  TOKEN t : values()) {
    int i=start;
    boolean found=true;
    for (int j=0; j < t.toString().length() && j + i < search.length(); j++) {
      while (search.charAt(j + i) == ' ') {
        i++;
      }
      if (i + j >= search.length() || (search.charAt(i + j) != t.toString().charAt(j))) {
        found=false;
        break;
      }
    }
    if (found) {
      return t;
    }
  }
  return null;
}","static TOKEN findMatch(String search,int start){
  for (  TOKEN t : values()) {
    int i=start;
    boolean found=true;
    for (int j=0; j < t.toString().length(); j++) {
      while (i + j < search.length() && search.charAt(j + i) == ' ') {
        i++;
      }
      if (i + j >= search.length() || (search.charAt(i + j) != t.toString().charAt(j))) {
        found=false;
        break;
      }
    }
    if (found) {
      return t;
    }
  }
  return null;
}"
12852,"static Line fromString(String lineString){
  Line l=new Line();
  boolean inString=false;
  boolean hasLineNumber=false;
  boolean isComment=false;
  Command currentCommand=new Command();
  l.commands.add(currentCommand);
  l.length=4;
  lineString=lineString.trim();
  String upperLineString=lineString.toUpperCase();
  for (int i=0; i < lineString.length(); i++) {
    if (!hasLineNumber) {
      int lineNumber=0;
      for (; i < lineString.length() && isDigit(lineString.charAt(i)); i++) {
        lineNumber=lineNumber * 10 + lineString.charAt(i) - '0';
      }
      i--;
      l.setNumber(lineNumber);
      hasLineNumber=true;
    }
 else     if (inString || isComment) {
      if (!isComment && lineString.charAt(i) == '""') {
        inString=false;
      }
      currentCommand.parts.add(new Command.ByteOrToken((byte)lineString.charAt(i)));
      l.length++;
    }
 else     if (lineString.charAt(i) == '""') {
      inString=true;
      currentCommand.parts.add(new Command.ByteOrToken((byte)lineString.charAt(i)));
      l.length++;
    }
 else     if (lineString.charAt(i) == STATEMENT_BREAK) {
      currentCommand=new Command();
      l.commands.add(currentCommand);
      l.length++;
    }
 else     if (lineString.charAt(i) == '?') {
      Command.ByteOrToken part=new Command.ByteOrToken(TOKEN.PRINT);
      currentCommand.parts.add(part);
      l.length++;
    }
 else {
      TOKEN match=Command.TOKEN.findMatch(upperLineString,i);
      if (match != null) {
        if (match == TOKEN.REM) {
          isComment=true;
        }
        Command.ByteOrToken part=new Command.ByteOrToken(match);
        currentCommand.parts.add(part);
        for (int j=0; j + i <= match.toString().length(); j++) {
          while (lineString.charAt(i + j) == ' ') {
            i++;
          }
        }
        i+=match.toString().length() - 1;
        if (isComment) {
          while (i + 1 < lineString.length() && lineString.charAt(i + 1) == ' ') {
            i++;
          }
        }
        l.length++;
      }
 else {
        if (lineString.charAt(i) != ' ') {
          currentCommand.parts.add(new Command.ByteOrToken((byte)upperLineString.charAt(i)));
          l.length++;
        }
      }
    }
  }
  return l;
}","static Line fromString(String lineString){
  Line l=new Line();
  boolean inString=false;
  boolean hasLineNumber=false;
  boolean isComment=false;
  Command currentCommand=new Command();
  l.commands.add(currentCommand);
  l.length=4;
  String upperLineString=lineString.toUpperCase();
  for (int i=0; i < lineString.length(); i++) {
    if (!hasLineNumber) {
      int lineNumber=0;
      for (; i < lineString.length() && isDigit(lineString.charAt(i)); i++) {
        lineNumber=lineNumber * 10 + lineString.charAt(i) - '0';
      }
      i--;
      l.setNumber(lineNumber);
      hasLineNumber=true;
    }
 else     if (inString || isComment) {
      if (!isComment && lineString.charAt(i) == '""') {
        inString=false;
      }
      currentCommand.parts.add(new Command.ByteOrToken((byte)lineString.charAt(i)));
      l.length++;
    }
 else     if (lineString.charAt(i) == '""') {
      inString=true;
      currentCommand.parts.add(new Command.ByteOrToken((byte)lineString.charAt(i)));
      l.length++;
    }
 else     if (lineString.charAt(i) == STATEMENT_BREAK) {
      currentCommand=new Command();
      l.commands.add(currentCommand);
      l.length++;
    }
 else     if (lineString.charAt(i) == '?') {
      Command.ByteOrToken part=new Command.ByteOrToken(TOKEN.PRINT);
      currentCommand.parts.add(part);
      l.length++;
    }
 else     if (lineString.charAt(i) == ' ') {
      continue;
    }
 else {
      TOKEN match=Command.TOKEN.findMatch(upperLineString,i);
      if (match != null) {
        Command.ByteOrToken part=new Command.ByteOrToken(match);
        currentCommand.parts.add(part);
        if (match == TOKEN.REM || match == TOKEN.DATA) {
          isComment=true;
        }
        for (int j=0; j < match.toString().length(); j++, i++) {
          while (i < lineString.length() && lineString.charAt(i) == ' ') {
            i++;
          }
        }
        if (!isComment) {
          i--;
        }
        l.length++;
      }
 else {
        if (lineString.charAt(i) != ' ') {
          currentCommand.parts.add(new Command.ByteOrToken((byte)upperLineString.charAt(i)));
          l.length++;
        }
      }
    }
  }
  return l;
}"
12853,"public static void registerInvokableAction(InvokableAction action,Object owner,Method method,String code){
  boolean isStatic=Modifier.isStatic(method.getModifiers());
  registerKeyHandler(new KeyHandler(code){
    @Override public boolean handleKeyUp(    KeyEvent e){
      if (!action.notifyOnRelease()) {
        return false;
      }
      Object returnValue=null;
      try {
        if (method.getParameterCount() > 0) {
          returnValue=method.invoke(isStatic ? null : owner,false);
        }
 else {
          returnValue=method.invoke(isStatic ? null : owner);
        }
      }
 catch (      IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
        Logger.getLogger(Keyboard.class.getName()).log(Level.SEVERE,null,ex);
      }
      if (returnValue != null) {
        return (Boolean)returnValue;
      }
      return action.consumeKeyEvent();
    }
    @Override public boolean handleKeyDown(    KeyEvent e){
      Object returnValue=null;
      try {
        if (method.getParameterCount() > 0) {
          returnValue=method.invoke(isStatic ? null : owner,true);
        }
 else {
          returnValue=method.invoke(isStatic ? null : owner);
        }
      }
 catch (      IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
        Logger.getLogger(Keyboard.class.getName()).log(Level.SEVERE,null,ex);
      }
      if (returnValue != null) {
        return (Boolean)returnValue;
      }
      return action.consumeKeyEvent();
    }
  }
,owner);
}","public static void registerInvokableAction(InvokableAction action,Object owner,Method method,String code){
  boolean isStatic=Modifier.isStatic(method.getModifiers());
  registerKeyHandler(new KeyHandler(code){
    @Override public boolean handleKeyUp(    KeyEvent e){
      if (action == null || !action.notifyOnRelease()) {
        return false;
      }
      Object returnValue=null;
      try {
        if (method.getParameterCount() > 0) {
          returnValue=method.invoke(isStatic ? null : owner,false);
        }
 else {
          returnValue=method.invoke(isStatic ? null : owner);
        }
      }
 catch (      IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
        Logger.getLogger(Keyboard.class.getName()).log(Level.SEVERE,null,ex);
      }
      if (returnValue != null) {
        return (Boolean)returnValue;
      }
      return action.consumeKeyEvent();
    }
    @Override public boolean handleKeyDown(    KeyEvent e){
      Object returnValue=null;
      try {
        if (method.getParameterCount() > 0) {
          returnValue=method.invoke(isStatic ? null : owner,true);
        }
 else {
          returnValue=method.invoke(isStatic ? null : owner);
        }
      }
 catch (      IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
        Logger.getLogger(Keyboard.class.getName()).log(Level.SEVERE,null,ex);
      }
      if (returnValue != null) {
        return (Boolean)returnValue;
      }
      return action != null ? action.consumeKeyEvent() : null;
    }
  }
,owner);
}"
12854,"@Override public boolean handleKeyDown(KeyEvent e){
  Object returnValue=null;
  try {
    if (method.getParameterCount() > 0) {
      returnValue=method.invoke(isStatic ? null : owner,true);
    }
 else {
      returnValue=method.invoke(isStatic ? null : owner);
    }
  }
 catch (  IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
    Logger.getLogger(Keyboard.class.getName()).log(Level.SEVERE,null,ex);
  }
  if (returnValue != null) {
    return (Boolean)returnValue;
  }
  return action.consumeKeyEvent();
}","@Override public boolean handleKeyDown(KeyEvent e){
  Object returnValue=null;
  try {
    if (method.getParameterCount() > 0) {
      returnValue=method.invoke(isStatic ? null : owner,true);
    }
 else {
      returnValue=method.invoke(isStatic ? null : owner);
    }
  }
 catch (  IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
    Logger.getLogger(Keyboard.class.getName()).log(Level.SEVERE,null,ex);
  }
  if (returnValue != null) {
    return (Boolean)returnValue;
  }
  return action != null ? action.consumeKeyEvent() : null;
}"
12855,"@Override public boolean handleKeyUp(KeyEvent e){
  if (!action.notifyOnRelease()) {
    return false;
  }
  Object returnValue=null;
  try {
    if (method.getParameterCount() > 0) {
      returnValue=method.invoke(isStatic ? null : owner,false);
    }
 else {
      returnValue=method.invoke(isStatic ? null : owner);
    }
  }
 catch (  IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
    Logger.getLogger(Keyboard.class.getName()).log(Level.SEVERE,null,ex);
  }
  if (returnValue != null) {
    return (Boolean)returnValue;
  }
  return action.consumeKeyEvent();
}","@Override public boolean handleKeyUp(KeyEvent e){
  if (action == null || !action.notifyOnRelease()) {
    return false;
  }
  Object returnValue=null;
  try {
    if (method.getParameterCount() > 0) {
      returnValue=method.invoke(isStatic ? null : owner,false);
    }
 else {
      returnValue=method.invoke(isStatic ? null : owner);
    }
  }
 catch (  IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
    Logger.getLogger(Keyboard.class.getName()).log(Level.SEVERE,null,ex);
  }
  if (returnValue != null) {
    return (Boolean)returnValue;
  }
  return action.consumeKeyEvent();
}"
12856,"private static void applyConfigTree(ConfigNode newRoot,ConfigNode oldRoot){
  if (oldRoot == null || newRoot == null) {
    return;
  }
  oldRoot.settings=newRoot.settings;
  oldRoot.hotkeys=newRoot.hotkeys;
  if (oldRoot.subject != null) {
    doApply(oldRoot);
    buildTree(oldRoot,new HashSet());
  }
  newRoot.getChildren().stream().forEach((child) -> {
    String childName=child.toString();
    applyConfigTree(child,oldRoot.findChild(childName));
  }
);
}","private static void applyConfigTree(ConfigNode newRoot,ConfigNode oldRoot){
  if (oldRoot == null || newRoot == null) {
    return;
  }
  oldRoot.settings=newRoot.settings;
  oldRoot.hotkeys=newRoot.hotkeys;
  if (oldRoot.subject != null) {
    doApply(oldRoot);
    buildTree(oldRoot,new HashSet());
  }
  newRoot.getChildren().stream().forEach((child) -> {
    String childName=child.toString();
    ConfigNode oldChild=oldRoot.findChild(childName);
    if (oldChild == null) {
      oldChild=oldRoot.findChild(child.id);
    }
    applyConfigTree(child,oldChild);
  }
);
}"
12857,"@Override public void resume(){
synchronized (this) {
    if (!isRunning()) {
      super.resume();
      RECV_IRQ_ENABLED=false;
      TRANS_IRQ_ENABLED=false;
      IRQ_TRIGGERED=false;
      try {
        socket=new ServerSocket(IP_PORT);
        socket.setReuseAddress(true);
        socket.setSoTimeout(0);
        listenThread=new Thread(this::socketMonitor);
        listenThread.setDaemon(false);
        listenThread.setName(""String_Node_Str"" + getSlot());
        listenThread.start();
      }
 catch (      IOException ex) {
        suspend();
        Logger.getLogger(CardSSC.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  }
}","@Override public void resume(){
synchronized (this) {
    if (!isRunning()) {
      super.resume();
      RECV_IRQ_ENABLED=false;
      TRANS_IRQ_ENABLED=false;
      IRQ_TRIGGERED=false;
      listenThread=new Thread(this::socketMonitor);
      listenThread.setDaemon(false);
      listenThread.setName(""String_Node_Str"" + getSlot());
      listenThread.start();
    }
  }
}"
12858,"public void socketMonitor(){
  while (socket != null && !socket.isClosed()) {
    try {
      Logger.getLogger(CardSSC.class.getName()).log(Level.INFO,""String_Node_Str"" + getSlot() + ""String_Node_Str""+ IP_PORT,(Throwable)null);
      while ((clientSocket=socket.accept()) != null) {
        socketInput=new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        clientConnected();
        clientSocket.setTcpNoDelay(true);
        while (isConnected()) {
          try {
            Thread.sleep(10);
            if (socketInput.ready()) {
              newInputAvailable=true;
            }
          }
 catch (          InterruptedException ex) {
          }
        }
        clientDisconnected();
        hangUp();
        socketInput=null;
      }
    }
 catch (    SocketTimeoutException ex) {
    }
catch (    IOException ex) {
      Logger.getLogger(CardSSC.class.getName()).log(Level.FINE,null,ex);
    }
  }
  socket=null;
}","public void socketMonitor(){
  try {
    socket=new ServerSocket(IP_PORT);
    socket.setReuseAddress(true);
    socket.setSoTimeout(0);
  }
 catch (  IOException ex) {
    Logger.getLogger(CardSSC.class.getName()).log(Level.SEVERE,null,ex);
    suspend();
    return;
  }
  while (socket != null && !socket.isClosed()) {
    try {
      Logger.getLogger(CardSSC.class.getName()).log(Level.INFO,""String_Node_Str"" + getSlot() + ""String_Node_Str""+ IP_PORT,(Throwable)null);
      while ((clientSocket=socket.accept()) != null) {
        socketInput=new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        clientConnected();
        clientSocket.setTcpNoDelay(true);
        while (isConnected()) {
          try {
            Thread.sleep(10);
            if (socketInput.ready()) {
              newInputAvailable=true;
            }
          }
 catch (          InterruptedException ex) {
          }
        }
        clientDisconnected();
        hangUp();
        socketInput=null;
      }
    }
 catch (    SocketTimeoutException ex) {
    }
catch (    IOException ex) {
      Logger.getLogger(CardSSC.class.getName()).log(Level.FINE,null,ex);
    }
  }
  socket=null;
}"
12859,"@Override public void tick(){
  setFloatingBus(computer.getMemory().readRaw(scannerAddress + x));
  if (hPeriod > 0) {
    hPeriod--;
    if (hPeriod == 0) {
      x=-1;
      setScannerLocation(currentWriter.getYOffset(y));
    }
  }
 else {
    if (!isVblank) {
      draw();
    }
    if (x >= APPLE_CYCLES_PER_LINE - 1) {
      int yy=y + hblankOffsetY;
      if (yy < 0) {
        yy+=APPLE_SCREEN_LINES;
      }
      if (yy >= APPLE_SCREEN_LINES) {
        yy-=(TOTAL_LINES - APPLE_SCREEN_LINES);
      }
      setScannerLocation(currentWriter.getYOffset(yy) + hblankOffsetX + (yy < 64 ? 128 : 0));
      x=-1;
      if (!isVblank) {
        if (lineDirty) {
          screenDirty=true;
          currentWriter.clearDirty(y);
        }
        hblankStart(video,y,lineDirty);
        lineDirty=false;
        forceRedrawRowCount--;
      }
      hPeriod=HBLANK;
      y++;
      if (y >= APPLE_SCREEN_LINES) {
        if (!isVblank) {
          y=APPLE_SCREEN_LINES - (TOTAL_LINES - APPLE_SCREEN_LINES);
          isVblank=true;
          vblankStart();
          computer.getMotherboard().vblankStart();
        }
 else {
          y=0;
          isVblank=false;
          vblankEnd();
          computer.getMotherboard().vblankEnd();
        }
      }
    }
  }
  x++;
}","@Override public void tick(){
  setFloatingBus(computer.getMemory().readRaw(scannerAddress + x));
  if (hPeriod > 0) {
    hPeriod--;
    if (hPeriod == 0) {
      x=-1;
      setScannerLocation(currentWriter.getYOffset(y));
    }
  }
 else {
    if (!isVblank && x < (APPLE_CYCLES_PER_LINE - 1)) {
      draw();
    }
    if (x >= APPLE_CYCLES_PER_LINE - 1) {
      int yy=y + hblankOffsetY;
      if (yy < 0) {
        yy+=APPLE_SCREEN_LINES;
      }
      if (yy >= APPLE_SCREEN_LINES) {
        yy-=(TOTAL_LINES - APPLE_SCREEN_LINES);
      }
      setScannerLocation(currentWriter.getYOffset(yy) + hblankOffsetX + (yy < 64 ? 128 : 0));
      x=-1;
      if (!isVblank) {
        if (lineDirty) {
          screenDirty=true;
          currentWriter.clearDirty(y);
        }
        hblankStart(video,y,lineDirty);
        lineDirty=false;
        forceRedrawRowCount--;
      }
      hPeriod=HBLANK;
      y++;
      if (y >= APPLE_SCREEN_LINES) {
        if (!isVblank) {
          y=APPLE_SCREEN_LINES - (TOTAL_LINES - APPLE_SCREEN_LINES);
          isVblank=true;
          vblankStart();
          computer.getMotherboard().vblankStart();
        }
 else {
          y=0;
          isVblank=false;
          vblankEnd();
          computer.getMotherboard().vblankEnd();
        }
      }
    }
  }
  x++;
}"
12860,"public void removeMouseListener(EventHandler<MouseEvent> handler){
  appleScreen.removeEventHandler(MouseEvent.MOUSE_MOVED,handler);
  appleScreen.removeEventHandler(MouseEvent.MOUSE_PRESSED,handler);
  appleScreen.removeEventHandler(MouseEvent.MOUSE_RELEASED,handler);
}","public void removeMouseListener(EventHandler<MouseEvent> handler){
  appleScreen.removeEventHandler(MouseEvent.ANY,handler);
}"
12861,"public void addMouseListener(EventHandler<MouseEvent> handler){
  appleScreen.addEventHandler(MouseEvent.MOUSE_MOVED,handler);
  appleScreen.addEventHandler(MouseEvent.MOUSE_PRESSED,handler);
  appleScreen.addEventHandler(MouseEvent.MOUSE_RELEASED,handler);
}","public void addMouseListener(EventHandler<MouseEvent> handler){
  appleScreen.addEventHandler(MouseEvent.ANY,handler);
}"
12862,"private void processMouseEvent(MouseEvent event){
  if (event.getEventType() == MouseEvent.MOUSE_MOVED) {
    Node source=(Node)event.getSource();
    updateLocation(event.getSceneX(),event.getSceneY(),source.getBoundsInLocal());
    event.consume();
  }
 else   if (event.getEventType() == MouseEvent.MOUSE_PRESSED) {
    mousePressed(event);
    event.consume();
  }
 else   if (event.getEventType() == MouseEvent.MOUSE_RELEASED) {
    mouseReleased(event);
    event.consume();
  }
}","private void processMouseEvent(MouseEvent event){
  if (event.getEventType() == MouseEvent.MOUSE_MOVED || event.getEventType() == MouseEvent.MOUSE_DRAGGED) {
    Node source=(Node)event.getSource();
    updateLocation(event.getSceneX(),event.getSceneY(),source.getBoundsInLocal());
    event.consume();
  }
  if (event.getEventType() == MouseEvent.MOUSE_PRESSED || event.getEventType() == MouseEvent.MOUSE_DRAGGED) {
    mousePressed(event);
    event.consume();
  }
 else   if (event.getEventType() == MouseEvent.MOUSE_RELEASED) {
    mouseReleased(event);
    event.consume();
  }
}"
12863,"private void insertCard(Class<? extends Card> type,int slot) throws NoSuchMethodException, IllegalArgumentException, InvocationTargetException {
  if (getMemory().getCard(slot) != null) {
    if (getMemory().getCard(slot).getClass().equals(type)) {
      return;
    }
    getMemory().removeCard(slot);
  }
  if (type != null) {
    try {
      Card card=type.getConstructor(Computer.class).newInstance(this);
      getMemory().addCard(card,slot);
    }
 catch (    InstantiationException|IllegalAccessException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
}","private void insertCard(Class<? extends Card> type,int slot) throws NoSuchMethodException, IllegalArgumentException, InvocationTargetException {
  if (getMemory().getCard(slot).isPresent()) {
    if (getMemory().getCard(slot).get().getClass().equals(type)) {
      return;
    }
    getMemory().removeCard(slot);
  }
  if (type != null) {
    try {
      Card card=type.getConstructor(Computer.class).newInstance(this);
      getMemory().addCard(card,slot);
    }
 catch (    InstantiationException|IllegalAccessException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
}"
12864,"private void putChild(String childName,ConfigNode newChild){
  removeChild(childName);
  int index=0;
  for (  ConfigNode node : children) {
    int compare=node.toString().compareToIgnoreCase(childName);
    if (compare >= 0) {
      break;
    }
 else {
      index++;
    }
  }
  children.add(index,newChild);
}","private void putChild(String id,ConfigNode newChild){
  removeChild(id);
  int index=0;
  for (  ConfigNode node : children) {
    int compare=node.toString().compareToIgnoreCase(id);
    if (compare >= 0) {
      break;
    }
 else {
      index++;
    }
  }
  children.add(index,newChild);
}"
12865,"private static void buildTree(ConfigNode node,Set visited){
  if (node.subject == null) {
    return;
  }
  for (  Method m : node.subject.getClass().getMethods()) {
    if (!m.isAnnotationPresent(InvokableAction.class)) {
      continue;
    }
    InvokableAction action=m.getDeclaredAnnotation(InvokableAction.class);
    node.hotkeys.put(m.getName(),action.defaultKeyMapping());
  }
  for (  Field f : node.subject.getClass().getFields()) {
    System.out.println(""String_Node_Str"" + f.getName());
    try {
      Object o=f.get(node.subject);
      if (visited.contains(o)) {
        continue;
      }
      visited.add(o);
      if (f.isAnnotationPresent(ConfigurableField.class)) {
        if (o != null && ISelection.class.isAssignableFrom(o.getClass())) {
          ISelection selection=(ISelection)o;
          node.setRawFieldValue(f.getName(),(Serializable)selection.getSelections().get(selection.getValue()));
        }
 else {
          node.setRawFieldValue(f.getName(),(Serializable)o);
        }
        continue;
      }
 else       if (o == null) {
        continue;
      }
      if (o instanceof Reconfigurable) {
        Reconfigurable r=(Reconfigurable)o;
        ConfigNode child=node.findChild(f.getName());
        if (child == null || !child.subject.equals(o)) {
          child=new ConfigNode(node,r);
          node.putChild(f.getName(),child);
        }
        buildTree(child,visited);
      }
 else       if (o.getClass().isArray()) {
        String fieldName=f.getName();
        Class type=o.getClass().getComponentType();
        System.out.println(""String_Node_Str"" + node.subject.getShortName() + ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ type.toGenericString());
        List<Reconfigurable> children=new ArrayList<>();
        if (!Reconfigurable.class.isAssignableFrom(type)) {
          System.out.println(""String_Node_Str"" + type.getName() + ""String_Node_Str"");
          if (Optional.class.isAssignableFrom(type)) {
            Type genericTypes=f.getGenericType();
            System.out.println(""String_Node_Str"" + genericTypes.getTypeName() + ""String_Node_Str""+ genericTypes.getClass().getName());
            if (genericTypes instanceof GenericArrayType) {
              GenericArrayType aType=(GenericArrayType)genericTypes;
              ParameterizedType pType=(ParameterizedType)aType.getGenericComponentType();
              if (pType.getActualTypeArguments().length != 1) {
                continue;
              }
              Type genericType=pType.getActualTypeArguments()[0];
              if (!Reconfigurable.class.isAssignableFrom((Class)genericType)) {
                continue;
              }
            }
 else {
              continue;
            }
            for (            Optional<Reconfigurable> child : (Optional<Reconfigurable>[])o) {
              if (child.isPresent()) {
                children.add(child.get());
              }
 else {
                children.add(null);
              }
            }
          }
        }
 else {
          children=Arrays.asList((Reconfigurable[])o);
        }
        for (int i=0; i < children.size(); i++) {
          Reconfigurable child=children.get(i);
          String childName=fieldName + i;
          if (child == null) {
            node.removeChild(childName);
            continue;
          }
          ConfigNode grandchild=node.findChild(childName);
          if (grandchild == null || !grandchild.subject.equals(child)) {
            grandchild=new ConfigNode(node,child);
            node.putChild(childName,grandchild);
          }
          buildTree(grandchild,visited);
        }
      }
    }
 catch (    IllegalArgumentException|IllegalAccessException ex) {
      Logger.getLogger(Configuration.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
}","private static void buildTree(ConfigNode node,Set visited){
  if (node.subject == null) {
    return;
  }
  for (  Method m : node.subject.getClass().getMethods()) {
    if (!m.isAnnotationPresent(InvokableAction.class)) {
      continue;
    }
    InvokableAction action=m.getDeclaredAnnotation(InvokableAction.class);
    node.hotkeys.put(m.getName(),action.defaultKeyMapping());
  }
  for (  Field f : node.subject.getClass().getFields()) {
    try {
      Object o=f.get(node.subject);
      if (!f.getType().isPrimitive() && visited.contains(o)) {
        continue;
      }
      visited.add(o);
      if (f.isAnnotationPresent(ConfigurableField.class)) {
        if (o != null && ISelection.class.isAssignableFrom(o.getClass())) {
          ISelection selection=(ISelection)o;
          node.setRawFieldValue(f.getName(),(Serializable)selection.getSelections().get(selection.getValue()));
        }
 else {
          node.setRawFieldValue(f.getName(),(Serializable)o);
        }
        continue;
      }
 else       if (o == null) {
        continue;
      }
      if (o instanceof Reconfigurable) {
        Reconfigurable r=(Reconfigurable)o;
        ConfigNode child=node.findChild(r.getName());
        if (child == null || !child.subject.equals(o)) {
          child=new ConfigNode(node,r);
          node.putChild(f.getName(),child);
        }
        buildTree(child,visited);
      }
 else       if (o.getClass().isArray()) {
        String fieldName=f.getName();
        Class type=o.getClass().getComponentType();
        List<Reconfigurable> children=new ArrayList<>();
        if (!Reconfigurable.class.isAssignableFrom(type)) {
          if (Optional.class.isAssignableFrom(type)) {
            Type genericTypes=f.getGenericType();
            if (genericTypes instanceof GenericArrayType) {
              GenericArrayType aType=(GenericArrayType)genericTypes;
              ParameterizedType pType=(ParameterizedType)aType.getGenericComponentType();
              if (pType.getActualTypeArguments().length != 1) {
                continue;
              }
              Type genericType=pType.getActualTypeArguments()[0];
              if (!Reconfigurable.class.isAssignableFrom((Class)genericType)) {
                continue;
              }
            }
 else {
              continue;
            }
            for (            Optional<Reconfigurable> child : (Optional<Reconfigurable>[])o) {
              if (child.isPresent()) {
                children.add(child.get());
              }
 else {
                children.add(null);
              }
            }
          }
        }
 else {
          children=Arrays.asList((Reconfigurable[])o);
        }
        for (int i=0; i < children.size(); i++) {
          Reconfigurable child=children.get(i);
          String childId=fieldName + i;
          if (child == null) {
            node.removeChild(childId);
            continue;
          }
          ConfigNode grandchild=node.findChild(childId);
          if (grandchild == null || !grandchild.subject.equals(child)) {
            grandchild=new ConfigNode(node,child,childId);
            node.putChild(childId,grandchild);
          }
          buildTree(grandchild,visited);
        }
      }
    }
 catch (    IllegalArgumentException|IllegalAccessException ex) {
      Logger.getLogger(Configuration.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
}"
12866,"public ConfigNode(ConfigNode parent,Reconfigurable subject){
  super();
  this.subject=subject;
  this.children=getChildren();
  this.parent=parent;
  if (this.parent != null) {
    this.root=this.parent.root != null ? this.parent.root : this.parent;
  }
  setValue(toString());
}","public ConfigNode(ConfigNode parent,Reconfigurable subject,String id){
  super();
  this.id=id;
  this.name=subject.getName();
  this.subject=subject;
  this.children=getChildren();
  this.parent=parent;
  if (this.parent != null) {
    this.root=this.parent.root != null ? this.parent.root : this.parent;
  }
  setValue(toString());
}"
12867,"@InvokableAction(name=""String_Node_Str"",description=""String_Node_Str"",category=""String_Node_Str"",alternatives=""String_Node_Str"",defaultKeyMapping=""String_Node_Str"") public static void loadSettings(){
{
    boolean successful=false;
    ObjectInputStream ois=null;
    FileInputStream fis=null;
    try {
      ois=new ObjectInputStream(new FileInputStream(getSettingsFile()));
      ConfigNode newRoot=(ConfigNode)ois.readObject();
      applyConfigTree(newRoot,BASE);
      successful=true;
    }
 catch (    FileNotFoundException ex) {
    }
catch (    ClassNotFoundException|IOException ex) {
      Logger.getLogger(Configuration.class.getName()).log(Level.SEVERE,null,ex);
    }
 finally {
      try {
        if (ois != null) {
          ois.close();
        }
        if (!successful) {
          applySettings(BASE);
        }
      }
 catch (      IOException ex) {
        Logger.getLogger(Configuration.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  }
}","@InvokableAction(name=""String_Node_Str"",description=""String_Node_Str"",category=""String_Node_Str"",alternatives=""String_Node_Str"",defaultKeyMapping=""String_Node_Str"") public static void loadSettings(){
{
    boolean successful=false;
    ObjectInputStream ois=null;
    try {
      ois=new ObjectInputStream(new FileInputStream(getSettingsFile()));
      ConfigNode newRoot=(ConfigNode)ois.readObject();
      applyConfigTree(newRoot,BASE);
      successful=true;
    }
 catch (    FileNotFoundException ex) {
    }
catch (    ClassNotFoundException|IOException ex) {
      Logger.getLogger(Configuration.class.getName()).log(Level.SEVERE,null,ex);
    }
 finally {
      try {
        if (ois != null) {
          ois.close();
        }
        if (!successful) {
          applySettings(BASE);
        }
      }
 catch (      IOException ex) {
        Logger.getLogger(Configuration.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  }
}"
12868,"private ConfigNode findChild(String childName){
  for (  ConfigNode node : children) {
    if (childName.equalsIgnoreCase(node.toString())) {
      return node;
    }
  }
  return null;
}","private ConfigNode findChild(String id){
  for (  ConfigNode node : children) {
    if (id.equalsIgnoreCase(node.id)) {
      return node;
    }
  }
  return null;
}"
12869,"@Override public String toString(){
  if (subject == null) {
    return ""String_Node_Str"";
  }
  return subject.getName();
}","@Override public String toString(){
  return name;
}"
12870,"public void addCard(Card c,int slot){
  cards[slot]=Optional.of(c);
  c.setSlot(slot);
  c.attach();
}","public void addCard(Card c,int slot){
  removeCard(slot);
  cards[slot]=Optional.of(c);
  c.setSlot(slot);
  c.attach();
}"
12871,"@Override public final void reconfigure(){
  boolean restart=pause();
  super.reconfigure();
  RAM128k currentMemory=(RAM128k)getMemory();
  if (currentMemory != null && !(currentMemory.getClass().equals(ramCard.getValue()))) {
    try {
      RAM128k newMemory=(RAM128k)ramCard.getValue().newInstance();
      newMemory.copyFrom(currentMemory);
      setMemory(newMemory);
    }
 catch (    InstantiationException|IllegalAccessException ex) {
    }
  }
  if (getMemory() == null) {
    try {
      currentMemory=(RAM128k)ramCard.getValue().newInstance();
    }
 catch (    InstantiationException|IllegalAccessException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
    try {
      setMemory(currentMemory);
      for (      SoftSwitches s : SoftSwitches.values()) {
        s.getSwitch().register(this);
      }
    }
 catch (    Throwable ex) {
    }
  }
  currentMemory.reconfigure();
  try {
    if (useConsoleProbe) {
      probe.init(this);
    }
 else {
      probe.shutdown();
    }
    if (useDebugRom) {
      loadRom(""String_Node_Str"");
    }
 else {
      loadRom(""String_Node_Str"");
    }
    if (getVideo() == null || getVideo().getClass() != videoRenderer.getValue()) {
      Graphics g=null;
      if (getVideo() != null) {
        getVideo().suspend();
        g=getVideo().getScreen();
      }
      try {
        setVideo((Video)videoRenderer.getValue().newInstance());
        getVideo().configureVideoMode();
        getVideo().reconfigure();
        getVideo().setScreen(g);
        Emulator.resizeVideo();
        getVideo().resume();
      }
 catch (      InstantiationException|IllegalAccessException ex) {
        Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
    try {
      insertCard(card1.getValue(),1);
      insertCard(card2.getValue(),2);
      insertCard(card3.getValue(),3);
      insertCard(card4.getValue(),4);
      insertCard(card5.getValue(),5);
      insertCard(card6.getValue(),6);
      insertCard(card7.getValue(),7);
    }
 catch (    NoSuchMethodException|IllegalArgumentException|InvocationTargetException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
    if (enableHints) {
      enableHints();
    }
 else {
      disableHints();
    }
    getMemory().configureActiveMemory();
    if (cheatEngine.getValue() == null) {
      if (activeCheatEngine != null) {
        activeCheatEngine.detach();
      }
      activeCheatEngine=null;
    }
 else {
      boolean startCheats=true;
      if (activeCheatEngine != null) {
        if (activeCheatEngine.getClass().equals(cheatEngine.getValue())) {
          startCheats=false;
        }
 else {
          activeCheatEngine.detach();
          activeCheatEngine=null;
        }
      }
      if (startCheats) {
        try {
          activeCheatEngine=(Cheats)cheatEngine.getValue().newInstance();
        }
 catch (        InstantiationException|IllegalAccessException ex) {
          Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
        }
        activeCheatEngine.attach();
      }
    }
  }
 catch (  IOException ex) {
    Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
  }
  if (restart) {
    resume();
  }
}","@Override public final void reconfigure(){
  boolean restart=pause();
  super.reconfigure();
  RAM128k currentMemory=(RAM128k)getMemory();
  if (currentMemory != null && !(currentMemory.getClass().equals(ramCard.getValue()))) {
    try {
      RAM128k newMemory=(RAM128k)ramCard.getValue().getConstructor(Computer.class).newInstance(this);
      newMemory.copyFrom(currentMemory);
      setMemory(newMemory);
    }
 catch (    InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException|NoSuchMethodException|SecurityException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
  }
  if (getMemory() == null) {
    try {
      currentMemory=(RAM128k)ramCard.getValue().getConstructor(Computer.class).newInstance(this);
    }
 catch (    InstantiationException|IllegalAccessException|NoSuchMethodException|SecurityException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
catch (    IllegalArgumentException|InvocationTargetException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
    try {
      setMemory(currentMemory);
      for (      SoftSwitches s : SoftSwitches.values()) {
        s.getSwitch().register(this);
      }
    }
 catch (    Throwable ex) {
    }
  }
  currentMemory.reconfigure();
  try {
    if (useConsoleProbe) {
      probe.init(this);
    }
 else {
      probe.shutdown();
    }
    if (useDebugRom) {
      loadRom(""String_Node_Str"");
    }
 else {
      loadRom(""String_Node_Str"");
    }
    if (getVideo() == null || getVideo().getClass() != videoRenderer.getValue()) {
      Graphics g=null;
      if (getVideo() != null) {
        getVideo().suspend();
        g=getVideo().getScreen();
      }
      try {
        setVideo((Video)videoRenderer.getValue().getConstructor(Computer.class).newInstance(this));
        getVideo().configureVideoMode();
        getVideo().reconfigure();
        getVideo().setScreen(g);
        Emulator.resizeVideo();
        getVideo().resume();
      }
 catch (      InstantiationException|IllegalAccessException ex) {
        Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
      }
catch (      NoSuchMethodException|SecurityException|IllegalArgumentException|InvocationTargetException ex) {
        Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
    try {
      insertCard(card1.getValue(),1);
      insertCard(card2.getValue(),2);
      insertCard(card3.getValue(),3);
      insertCard(card4.getValue(),4);
      insertCard(card5.getValue(),5);
      insertCard(card6.getValue(),6);
      insertCard(card7.getValue(),7);
    }
 catch (    NoSuchMethodException|IllegalArgumentException|InvocationTargetException ex) {
      Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
    }
    if (enableHints) {
      enableHints();
    }
 else {
      disableHints();
    }
    getMemory().configureActiveMemory();
    if (cheatEngine.getValue() == null) {
      if (activeCheatEngine != null) {
        activeCheatEngine.detach();
      }
      activeCheatEngine=null;
    }
 else {
      boolean startCheats=true;
      if (activeCheatEngine != null) {
        if (activeCheatEngine.getClass().equals(cheatEngine.getValue())) {
          startCheats=false;
        }
 else {
          activeCheatEngine.detach();
          activeCheatEngine=null;
        }
      }
      if (startCheats) {
        try {
          activeCheatEngine=(Cheats)cheatEngine.getValue().newInstance();
        }
 catch (        InstantiationException|IllegalAccessException ex) {
          Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
        }
        activeCheatEngine.attach();
      }
    }
  }
 catch (  IOException ex) {
    Logger.getLogger(Apple2e.class.getName()).log(Level.SEVERE,null,ex);
  }
  if (restart) {
    resume();
  }
}"
12872,"/** 
 * Return the serialField tags in this FieldDoc item.
 * @return an array of <tt>SerialFieldTag</tt> objects containingall  {@code @serialField} tags.
 */
SerialFieldTag[] serialFieldTags();","/** 
 * Return the serialField tags in this FieldDoc item.
 * @return an array of {@code SerialFieldTag} objects containingall  {@code @serialField} tags.
 */
SerialFieldTag[] serialFieldTags();"
12873,"/** 
 * Tests whether this method overrides another. The overridden method may be one declared in a superclass or a superinterface (unlike   {@link #overriddenMethod()}). <p> When a non-abstract method overrides an abstract one, it is also said to <i>implement</i> the other.
 * @param meth  the other method to examine
 * @return <tt>true</tt> if this method overrides the other
 * @since 1.5
 */
boolean overrides(MethodDoc meth);","/** 
 * Tests whether this method overrides another. The overridden method may be one declared in a superclass or a superinterface (unlike   {@link #overriddenMethod()}). <p> When a non-abstract method overrides an abstract one, it is also said to <i>implement</i> the other.
 * @param meth  the other method to examine
 * @return {@code true} if this method overrides the other
 * @since 1.5
 */
boolean overrides(MethodDoc meth);"
12874,"/** 
 * Return the kind of this tag. For most tags,  {@code kind() == name()}; the following table lists those cases where there is more than one tag of a given kind: <table border=""1"" cellpadding=""4"" cellspacing=""0"" summary=""related tags""> <tr><th>  {@code kind()  }</th>  <th>  {@code name()      }</th></tr> <tr><td>  {@code @throws }</td>  <td>  {@code @throws     }</td></tr> <tr><td>  {@code @throws }</td>  <td>  {@code @exception  }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @see        }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @link       }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @linkplain  }</td></tr> <tr><td>  {@code @serial }</td>  <td>  {@code @serial     }</td></tr> <tr><td>  {@code @serial }</td>  <td>  {@code @serialData }</td></tr> </table>
 * @return the kind of this tag.
 */
String kind();","/** 
 * Return the kind of this tag. For most tags,  {@code kind() == name()}; the following table lists those cases where there is more than one tag of a given kind: <table border=""1""> <caption>Related Tags</caption> <tr><th>  {@code kind()  }</th>  <th>  {@code name()      }</th></tr> <tr><td>  {@code @throws }</td>  <td>  {@code @throws     }</td></tr> <tr><td>  {@code @throws }</td>  <td>  {@code @exception  }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @see        }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @link       }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @linkplain  }</td></tr> <tr><td>  {@code @serial }</td>  <td>  {@code @serial     }</td></tr> <tr><td>  {@code @serial }</td>  <td>  {@code @serialData }</td></tr> </table>
 * @return the kind of this tag.
 */
String kind();"
12875,"/** 
 * Create and return the default parameter map for this  {@code ExecutionControlProvider}. The map can optionally be modified; Modified or unmodified it can be passed to  {@link #generate(jdk.jshell.spi.ExecutionEnv,java.util.Map) }. <table summary=""Parameters""> <tr> <th>Parameter</th> <th>Description</th> <th>Constant Field</th> </tr> <tr> <td>remoteAgent</td> <td>the remote agent to launch</td> <td>  {@link #PARAM_REMOTE_AGENT}</td> </tr> <tr> <td>timeout</td> <td>milliseconds before connect timeout</td> <td>  {@link #PARAM_TIMEOUT}</td> </tr> <tr> <td>launch</td> <td>""true"" for JDI controlled launch</td> <td>  {@link #PARAM_LAUNCH}</td> </tr> <tr> <td>hostname</td> <td>connect to the named of the local host ("""" for discovered)</td> <td>  {@link #PARAM_HOST_NAME}</td> </tr> </table>
 * @return the default parameter map
 */
@Override public Map<String,String> defaultParameters(){
  Map<String,String> dp=new HashMap<>();
  dp.put(PARAM_REMOTE_AGENT,RemoteExecutionControl.class.getName());
  dp.put(PARAM_TIMEOUT,""String_Node_Str"" + DEFAULT_TIMEOUT);
  dp.put(PARAM_HOST_NAME,""String_Node_Str"");
  dp.put(PARAM_LAUNCH,""String_Node_Str"");
  return dp;
}","/** 
 * Create and return the default parameter map for this  {@code ExecutionControlProvider}. The map can optionally be modified; Modified or unmodified it can be passed to  {@link #generate(jdk.jshell.spi.ExecutionEnv,java.util.Map) }. <table> <caption>Parameters</caption> <tr> <th>Parameter</th> <th>Description</th> <th>Constant Field</th> </tr> <tr> <td>remoteAgent</td> <td>the remote agent to launch</td> <td>  {@link #PARAM_REMOTE_AGENT}</td> </tr> <tr> <td>timeout</td> <td>milliseconds before connect timeout</td> <td>  {@link #PARAM_TIMEOUT}</td> </tr> <tr> <td>launch</td> <td>""true"" for JDI controlled launch</td> <td>  {@link #PARAM_LAUNCH}</td> </tr> <tr> <td>hostname</td> <td>connect to the named of the local host ("""" for discovered)</td> <td>  {@link #PARAM_HOST_NAME}</td> </tr> </table>
 * @return the default parameter map
 */
@Override public Map<String,String> defaultParameters(){
  Map<String,String> dp=new HashMap<>();
  dp.put(PARAM_REMOTE_AGENT,RemoteExecutionControl.class.getName());
  dp.put(PARAM_TIMEOUT,""String_Node_Str"" + DEFAULT_TIMEOUT);
  dp.put(PARAM_HOST_NAME,""String_Node_Str"");
  dp.put(PARAM_LAUNCH,""String_Node_Str"");
  return dp;
}"
12876,"/** 
 * Returns the fields, methods, constructors, and member types that are directly declared in this class or interface. This includes any   {@linkplain Elements.Origin#MANDATED mandated} elements such as the (implicit) default constructorand the implicit  {@code values} and {@code valueOf} methods ofan enum type.
 * @apiNote As a particular instance of the {@linkplain javax.lang.model.element general accuracy requirements} and theordering behavior required of this interface, the list of enclosed elements will be returned in the natural order for the originating source of information about the type.  For example, if the information about the type is originating from a source file, the elements will be returned in source code order. (However, in that case the the ordering of elements, such as a default constructor, is not specified.)
 * @return the enclosed elements in proper order, or an empty list if none
 * @jls 8.8.9 Default Constructor
 * @jls 8.9.3 Enum Members
 */
@Override List<? extends Element> getEnclosedElements();","/** 
 * Returns the fields, methods, constructors, and member types that are directly declared in this class or interface. This includes any   {@linkplain Elements.Origin#MANDATED mandated} elements such as the (implicit) default constructorand the implicit  {@code values} and {@code valueOf} methods ofan enum type.
 * @apiNote As a particular instance of the {@linkplain javax.lang.model.element general accuracy requirements} and theordering behavior required of this interface, the list of enclosed elements will be returned in the natural order for the originating source of information about the type.  For example, if the information about the type is originating from a source file, the elements will be returned in source code order. (However, in that case the the ordering of  {@linkplain Elements.Origin#MANDATED implicitly declared} elements, such asdefault constructors, is not specified.)
 * @return the enclosed elements in proper order, or an empty list if none
 * @jls 8.8.9 Default Constructor
 * @jls 8.9.3 Enum Members
 */
@Override List<? extends Element> getEnclosedElements();"
12877,"/** 
 * If the processor class is annotated with   {@link SupportedAnnotationTypes}, return an unmodifiable set with the same set of strings as the annotation.  If the class is not so annotated, an empty set is returned. If the   {@link ProcessingEvironment#getSourceVersion sourceversion} does not support modules, in other words if it is lessthan or equal to  {@link SourceVersion#RELEASE_8 RELEASE_8}, then any leading   {@link Processor#getSupportedAnnotationTypes module prefixes} are stripped from the names.
 * @return the names of the annotation types supported by thisprocessor, or an empty set if none
 */
public Set<String> getSupportedAnnotationTypes(){
  SupportedAnnotationTypes sat=this.getClass().getAnnotation(SupportedAnnotationTypes.class);
  boolean initialized=isInitialized();
  if (sat == null) {
    if (initialized)     processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,""String_Node_Str"" + ""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str"");
    return Collections.emptySet();
  }
 else {
    boolean stripModulePrefixes=initialized && processingEnv.getSourceVersion().compareTo(SourceVersion.RELEASE_8) <= 0;
    return arrayToSet(sat.value(),stripModulePrefixes);
  }
}","/** 
 * If the processor class is annotated with   {@link SupportedAnnotationTypes}, return an unmodifiable set with the same set of strings as the annotation.  If the class is not so annotated, an empty set is returned. If the   {@link ProcessingEnvironment#getSourceVersion sourceversion} does not support modules, in other words if it is lessthan or equal to  {@link SourceVersion#RELEASE_8 RELEASE_8}, then any leading   {@link Processor#getSupportedAnnotationTypes module prefixes} are stripped from the names.
 * @return the names of the annotation types supported by thisprocessor, or an empty set if none
 */
public Set<String> getSupportedAnnotationTypes(){
  SupportedAnnotationTypes sat=this.getClass().getAnnotation(SupportedAnnotationTypes.class);
  boolean initialized=isInitialized();
  if (sat == null) {
    if (initialized)     processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,""String_Node_Str"" + ""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str"");
    return Collections.emptySet();
  }
 else {
    boolean stripModulePrefixes=initialized && processingEnv.getSourceVersion().compareTo(SourceVersion.RELEASE_8) <= 0;
    return arrayToSet(sat.value(),stripModulePrefixes);
  }
}"
12878,"/** 
 * Returns the names of the annotation types supported by this processor.  An element of the result may be the canonical (fully qualified) name of a supported annotation type. Alternately it may be of the form &quot;<code><i>name</i>.*</code>&quot; representing the set of all annotation types with canonical names beginning with &quot;<code><i>name.</i></code>&quot;. In either of those cases, the name of the annotation type can be optionally preceded by a module name followed by a   {@code ""/""} character. For example, if a processor supports {@code ""a.B""}, this can include multiple annotation types named   {@code a.B} which reside in different modules. To only support {@code a.B} in the {@code Foo} module, instead use {@code ""Foo/a.B""}. If a module name is included, only an annotation in that module is matched. In particular, if a module name is given in an environment where modules are not supported, such as an annotation processing environment configured for a   {@linkplain javax.annotation.processing.ProcessingEnvironment#getSourceVersion source version} without modules, then the annotation types witha module name do <em>not</em> match. Finally,  {@code ""*""} by itself represents the set of allannotation types, including the empty set.  Note that a processor should not claim  {@code ""*""} unless it is actuallyprocessing all files; claiming unnecessary annotations may cause a performance slowdown in some environments. <p>Each string returned in the set must be accepted by the following grammar: <blockquote> <dl> <dt><i>SupportedAnnotationTypeString:</i> <dd><i>ModulePrefix</i><sub><i>opt</i></sub> <i>TypeName</i> <i>DotStar</i><sub><i>opt</i></sub> <dd><code>*</code> <dt><i>ModulePrefix:</i> <dd><i>TypeName</i> <code>/</code> <dt><i>DotStar:</i> <dd><code>.</code> <code>*</code> </dl> </blockquote> where <i>TypeName</i> is as defined in <cite>The Java&trade; Language Specification</cite>.
 * @apiNote When running in an environment which supports modules,processors are encouraged to include the module prefix when describing their supported annotation types. The method  {@link AbstractProcessor.getSupportedAnnotationTypes AbstractProcessor.getSupportedAnnotationTypes} provides supportfor stripping off the module prefix when running in an environment without modules.
 * @return the names of the annotation types supported by this processor
 * @see javax.annotation.processing.SupportedAnnotationTypes
 * @jls 3.8 Identifiers
 * @jls 6.5.5 Meaning of Type Names
 */
Set<String> getSupportedAnnotationTypes();","/** 
 * Returns the names of the annotation types supported by this processor.  An element of the result may be the canonical (fully qualified) name of a supported annotation type. Alternately it may be of the form &quot;<code><i>name</i>.*</code>&quot; representing the set of all annotation types with canonical names beginning with &quot;<code><i>name.</i></code>&quot;. In either of those cases, the name of the annotation type can be optionally preceded by a module name followed by a   {@code ""/""} character. For example, if a processor supports {@code ""a.B""}, this can include multiple annotation types named   {@code a.B} which reside in different modules. To only support {@code a.B} in the {@code Foo} module, instead use {@code ""Foo/a.B""}. If a module name is included, only an annotation in that module is matched. In particular, if a module name is given in an environment where modules are not supported, such as an annotation processing environment configured for a   {@linkplain javax.annotation.processing.ProcessingEnvironment#getSourceVersion source version} without modules, then the annotation types witha module name do <em>not</em> match. Finally,  {@code ""*""} by itself represents the set of allannotation types, including the empty set.  Note that a processor should not claim  {@code ""*""} unless it is actuallyprocessing all files; claiming unnecessary annotations may cause a performance slowdown in some environments. <p>Each string returned in the set must be accepted by the following grammar: <blockquote> <dl> <dt><i>SupportedAnnotationTypeString:</i> <dd><i>ModulePrefix</i><sub><i>opt</i></sub> <i>TypeName</i> <i>DotStar</i><sub><i>opt</i></sub> <dd><code>*</code> <dt><i>ModulePrefix:</i> <dd><i>TypeName</i> <code>/</code> <dt><i>DotStar:</i> <dd><code>.</code> <code>*</code> </dl> </blockquote> where <i>TypeName</i> is as defined in <cite>The Java&trade; Language Specification</cite>.
 * @apiNote When running in an environment which supports modules,processors are encouraged to include the module prefix when describing their supported annotation types. The method  {@link AbstractProcessor#getSupportedAnnotationTypes AbstractProcessor.getSupportedAnnotationTypes} provides supportfor stripping off the module prefix when running in an environment without modules.
 * @return the names of the annotation types supported by this processor
 * @see javax.annotation.processing.SupportedAnnotationTypes
 * @jls 3.8 Identifiers
 * @jls 6.5.5 Meaning of Type Names
 */
Set<String> getSupportedAnnotationTypes();"
12879,"@Override public void visitRequires(JCRequires tree){
  if (tree.directive != null) {
    chk.checkDeprecated(tree.moduleName.pos(),msym,tree.directive.module);
    msym.directives=msym.directives.prepend(tree.directive);
  }
}","@Override public void visitRequires(JCRequires tree){
  if (tree.directive != null && allModules().contains(tree.directive.module)) {
    chk.checkDeprecated(tree.moduleName.pos(),msym,tree.directive.module);
    msym.directives=msym.directives.prepend(tree.directive);
  }
}"
12880,"private void completeModule(ModuleSymbol msym){
  if (inInitModules) {
    msym.completer=sym -> completeModule(msym);
    return;
  }
  if ((msym.flags_field & Flags.AUTOMATIC_MODULE) != 0) {
    completeAutomaticModule(msym);
  }
  Assert.checkNonNull(msym.requires);
  initAddReads();
  msym.requires=msym.requires.appendList(List.from(addReads.getOrDefault(msym,Collections.emptySet())));
  List<RequiresDirective> requires=msym.requires;
  List<RequiresDirective> previous=null;
  while (requires.nonEmpty()) {
    if (!allModules().contains(requires.head.module)) {
      Env<AttrContext> env=typeEnvs.get(msym);
      if (env != null) {
        JavaFileObject origSource=log.useSource(env.toplevel.sourcefile);
        try {
          log.error(env.tree,Errors.ModuleNotFound(requires.head.module));
        }
  finally {
          log.useSource(origSource);
        }
      }
 else {
        Assert.check((msym.flags() & Flags.AUTOMATIC_MODULE) == 0);
      }
      if (previous != null) {
        previous.tail=requires.tail;
      }
 else {
        msym.requires.tail=requires.tail;
      }
    }
 else {
      previous=requires;
    }
    requires=requires.tail;
  }
  Set<ModuleSymbol> readable=new LinkedHashSet<>();
  Set<ModuleSymbol> requiresTransitive=new HashSet<>();
  for (  RequiresDirective d : msym.requires) {
    d.module.complete();
    readable.add(d.module);
    Set<ModuleSymbol> s=retrieveRequiresTransitive(d.module);
    Assert.checkNonNull(s,() -> ""String_Node_Str"" + d.module);
    readable.addAll(s);
    if (d.flags.contains(RequiresFlag.TRANSITIVE)) {
      requiresTransitive.add(d.module);
      requiresTransitive.addAll(s);
    }
  }
  requiresTransitiveCache.put(msym,requiresTransitive);
  initVisiblePackages(msym,readable);
  for (  ExportsDirective d : msym.exports) {
    if (d.packge != null) {
      d.packge.modle=msym;
    }
  }
}","private void completeModule(ModuleSymbol msym){
  if (inInitModules) {
    msym.completer=sym -> completeModule(msym);
    return;
  }
  if ((msym.flags_field & Flags.AUTOMATIC_MODULE) != 0) {
    completeAutomaticModule(msym);
  }
  Assert.checkNonNull(msym.requires);
  initAddReads();
  msym.requires=msym.requires.appendList(List.from(addReads.getOrDefault(msym,Collections.emptySet())));
  List<RequiresDirective> requires=msym.requires;
  while (requires.nonEmpty()) {
    if (!allModules().contains(requires.head.module)) {
      Env<AttrContext> env=typeEnvs.get(msym);
      if (env != null) {
        JavaFileObject origSource=log.useSource(env.toplevel.sourcefile);
        try {
          log.error(env.tree,Errors.ModuleNotFound(requires.head.module));
        }
  finally {
          log.useSource(origSource);
        }
      }
 else {
        Assert.check((msym.flags() & Flags.AUTOMATIC_MODULE) == 0);
      }
      msym.requires=List.filter(msym.requires,requires.head);
    }
    requires=requires.tail;
  }
  Set<ModuleSymbol> readable=new LinkedHashSet<>();
  Set<ModuleSymbol> requiresTransitive=new HashSet<>();
  for (  RequiresDirective d : msym.requires) {
    d.module.complete();
    readable.add(d.module);
    Set<ModuleSymbol> s=retrieveRequiresTransitive(d.module);
    Assert.checkNonNull(s,() -> ""String_Node_Str"" + d.module);
    readable.addAll(s);
    if (d.flags.contains(RequiresFlag.TRANSITIVE)) {
      requiresTransitive.add(d.module);
      requiresTransitive.addAll(s);
    }
  }
  requiresTransitiveCache.put(msym,requiresTransitive);
  initVisiblePackages(msym,readable);
  for (  ExportsDirective d : msym.exports) {
    if (d.packge != null) {
      d.packge.modle=msym;
    }
  }
}"
12881,"/** 
 * Returns the module of an element.  The module of a module is itself. If there is no module for the element, null is returned. One situation where there is no module for an element is if the environment does not include modules, such as an annotation processing environment configured for a   {@linkplain ProcessingEnvironment#getSourceVersion source version} without modules.      
 * @param type the element being examined
 * @return the module of an element
 * @since 9
 */
ModuleElement getModuleOf(Element type);","/** 
 * Returns the module of an element.  The module of a module is itself. If there is no module for the element, null is returned. One situation where there is no module for an element is if the environment does not include modules, such as an annotation processing environment configured for a   {@linkplain javax.annotation.processing.ProcessingEnvironment#getSourceVersion source version} without modules.
 * @param type the element being examined
 * @return the module of an element
 * @since 9
 */
ModuleElement getModuleOf(Element type);"
12882,"/** 
 * Returns a module element given its fully qualified name. If the named module cannot be found, null is returned. One situation where a module cannot be found is if the environment does not include modules, such as an annotation processing environment configured for a   {@linkplain ProcessingEnvironment#getSourceVersion source version} without modules.      
 * @param name  the name
 * @return the named module element, or {@code null} if it cannot be found
 * @since 9
 */
ModuleElement getModuleElement(CharSequence name);","/** 
 * Returns a module element given its fully qualified name. If the named module cannot be found, null is returned. One situation where a module cannot be found is if the environment does not include modules, such as an annotation processing environment configured for a   {@linkplain javax.annotation.processing.ProcessingEnvironment#getSourceVersion source version} without modules.
 * @param name  the name
 * @return the named module element, or {@code null} if it cannot be found
 * @since 9
 */
ModuleElement getModuleElement(CharSequence name);"
12883,"CaInfo scan(String s){
  try {
    Scanner scanner=scannerFactory.newScanner(s,false);
    Matched in=new Matched(scanner);
    Parser parser=new Parser(in,proc,s);
    Completeness stat=parser.parseUnit();
    int endPos=stat == Completeness.UNKNOWN ? s.length() : in.prevCT.endPos;
    return new CaInfo(stat,endPos);
  }
 catch (  SyntaxException ex) {
    return new CaInfo(error(),s.length());
  }
}","CaInfo scan(String s){
  try {
    Parser parser=new Parser(() -> new Matched(scannerFactory.newScanner(s,false)),() -> proc.taskFactory.new ParseTask(s));
    Completeness stat=parser.parseUnit();
    int endPos=stat == Completeness.UNKNOWN ? s.length() : parser.endPos();
    return new CaInfo(stat,endPos);
  }
 catch (  SyntaxException ex) {
    return new CaInfo(error(),s.length());
  }
}"
12884,"/** 
 * @return the next scanner token
 */
private CT nextCT(){
  TK prevTK=currentCT.kind;
  while (true) {
    db(""String_Node_Str"");
    CT ct;
switch (current.kind) {
case EOF:
      db(""String_Node_Str"");
    if (stack.isEmpty()) {
      ct=new CT(EOF,current);
    }
 else {
      TokenKind unmatched=stack.pop().kind;
      stack.clear();
      ct=new CT(UNMATCHED,current,""String_Node_Str"" + unmatched);
    }
  break;
case LPAREN:
case LBRACE:
case LBRACKET:
stack.push(advance());
prevTK=SEMI;
continue;
case RPAREN:
ct=match(PARENS,TokenKind.LPAREN);
break;
case RBRACE:
ct=match(BRACES,TokenKind.LBRACE);
break;
case RBRACKET:
ct=match(BRACKETS,TokenKind.LBRACKET);
break;
default :
ct=new CT(TK.tokenKindToTK(current.kind),advance());
break;
}
if (ct.kind.isStart() && !prevTK.isOkToTerminate()) {
return new CT(ERROR,current,""String_Node_Str"" + prevTK + ""String_Node_Str""+ ct.kind+ ""String_Node_Str"");
}
if (stack.isEmpty() || ct.kind.isError()) {
return ct;
}
prevTK=ct.kind;
}
}","/** 
 * @return the next scanner token
 */
private CT nextCT(){
  TK prevTK=currentCT.kind;
  while (true) {
    db(""String_Node_Str"");
    CT ct;
switch (current.kind) {
case EOF:
      db(""String_Node_Str"");
    if (stack.isEmpty()) {
      ct=new CT(EOF,current);
    }
 else {
      TokenKind unmatched=stack.pop().kind;
      stack.clear();
      ct=new CT(UNMATCHED,current,""String_Node_Str"" + unmatched);
    }
  break;
case LPAREN:
case LBRACE:
case LBRACKET:
stack.push(advance());
prevTK=SEMI;
continue;
case RPAREN:
ct=match(PARENS,TokenKind.LPAREN);
break;
case RBRACE:
ct=match(BRACES,TokenKind.LBRACE);
break;
case RBRACKET:
ct=match(BRACKETS,TokenKind.LBRACKET);
break;
default :
ct=new CT(TK.tokenKindToTK(prevTK,current.kind),advance());
break;
}
if (ct.kind.isStart() && !prevTK.isOkToTerminate()) {
return new CT(ERROR,current,""String_Node_Str"" + prevTK + ""String_Node_Str""+ ct.kind+ ""String_Node_Str"");
}
if (stack.isEmpty() || ct.kind.isError()) {
return ct;
}
prevTK=ct.kind;
}
}"
12885,"private static TK tokenKindToTK(TokenKind kind){
  TK tk=tokenKindToTKMap.get(kind);
  if (tk == null) {
    System.err.printf(""String_Node_Str"",TK.class.getCanonicalName(),TokenKind.class.getCanonicalName(),kind);
    throw new InternalError(""String_Node_Str"" + kind);
  }
  return tk;
}","private static TK tokenKindToTK(TK prev,TokenKind kind){
  TK tk=tokenKindToTKMap.get(kind);
  if (tk == null) {
    System.err.printf(""String_Node_Str"",TK.class.getCanonicalName(),TokenKind.class.getCanonicalName(),kind);
    throw new InternalError(""String_Node_Str"" + kind);
  }
  return tk.mapping != null ? tk.mapping.apply(prev) : tk;
}"
12886,"public Completeness disambiguateDeclarationVsExpression(){
  ParseTask pt=proc.taskFactory.new ParseTask(scannedInput);
  List<? extends Tree> units=pt.units();
  if (units.isEmpty()) {
    return error();
  }
  Tree unitTree=units.get(0);
switch (unitTree.getKind()) {
case EXPRESSION_STATEMENT:
    return parseExpressionOptionalSemi();
case LABELED_STATEMENT:
  if (shouldAbort(IDENTIFIER))   return checkResult;
if (shouldAbort(COLON)) return checkResult;
return parseStatement();
case VARIABLE:
case IMPORT:
case CLASS:
case ENUM:
case ANNOTATION_TYPE:
case INTERFACE:
case METHOD:
return parseDeclaration();
default :
return error();
}
}","public Completeness disambiguateDeclarationVsExpression(){
  ParseTask pt=parseFactory.get();
  List<? extends Tree> units=pt.units();
  if (units.isEmpty()) {
    return error();
  }
  Tree unitTree=units.get(0);
switch (unitTree.getKind()) {
case EXPRESSION_STATEMENT:
    return parseExpressionOptionalSemi();
case LABELED_STATEMENT:
  if (shouldAbort(IDENTIFIER))   return checkResult;
if (shouldAbort(COLON)) return checkResult;
return parseStatement();
case VARIABLE:
case IMPORT:
case CLASS:
case ENUM:
case ANNOTATION_TYPE:
case INTERFACE:
case METHOD:
return parseDeclaration();
default :
return error();
}
}"
12887,"public Completeness parseDeclaration(){
  boolean isImport=token.kind == IMPORT;
  while (token.kind.isDeclaration()) {
    nextToken();
  }
switch (token.kind) {
case EQ:
    nextToken();
  if (token.kind == BRACES) {
    nextToken();
    return lastly(SEMI);
  }
return parseExpressionStatement();
case BRACES:
case SEMI:
nextToken();
return Completeness.COMPLETE;
case UNMATCHED:
nextToken();
return Completeness.DEFINITELY_INCOMPLETE;
case EOF:
switch (in.prevCT.kind) {
case BRACES:
case SEMI:
return Completeness.COMPLETE;
case IDENTIFIER:
case BRACKETS:
return Completeness.COMPLETE_WITH_SEMI;
case STAR:
if (isImport) {
return Completeness.COMPLETE_WITH_SEMI;
}
 else {
return Completeness.DEFINITELY_INCOMPLETE;
}
default :
return Completeness.DEFINITELY_INCOMPLETE;
}
default :
return error();
}
}","public Completeness parseDeclaration(){
  boolean isImport=token.kind == IMPORT;
  while (token.kind.isDeclaration()) {
    nextToken();
  }
switch (token.kind) {
case EQ:
    nextToken();
  if (token.kind == BRACES) {
    nextToken();
    return lastly(SEMI);
  }
return parseExpressionStatement();
case BRACES:
case SEMI:
nextToken();
return Completeness.COMPLETE;
case UNMATCHED:
nextToken();
return Completeness.DEFINITELY_INCOMPLETE;
case EOF:
switch (in.prevCT.kind) {
case BRACES:
case SEMI:
return Completeness.COMPLETE;
case IDENTIFIER:
case BRACKETS:
return Completeness.COMPLETE_WITH_SEMI;
case DOTSTAR:
if (isImport) {
return Completeness.COMPLETE_WITH_SEMI;
}
 else {
return Completeness.UNKNOWN;
}
default :
return Completeness.DEFINITELY_INCOMPLETE;
}
default :
return error();
}
}"
12888,"Parser(Matched in,JShell proc,String scannedInput){
  this.in=in;
  nextToken();
  this.proc=proc;
  this.scannedInput=scannedInput;
}","Parser(Supplier<Matched> matchedFactory,Supplier<ParseTask> parseFactory){
  this.matchedFactory=matchedFactory;
  this.parseFactory=parseFactory;
  resetInput();
}"
12889,"void TK(TokenKind tokenKind,int b){
  this.tokenKind=tokenKind;
  this.belongs=b;
}","void TK(TokenKind tokenKind,int b){
  this.tokenKind=tokenKind;
  this.belongs=b;
  this.mapping=null;
}"
12890,"/** 
 * Generate an indy method call to the meta factory
 */
private JCExpression makeMetafactoryIndyCall(TranslationContext<?> context,int refKind,Symbol refSym,List<JCExpression> indy_args){
  JCFunctionalExpression tree=context.tree;
  MethodSymbol samSym=(MethodSymbol)types.findDescriptorSymbol(tree.type.tsym);
  List<Object> staticArgs=List.<Object>of(typeToMethodType(samSym.type),new Pool.MethodHandle(refKind,refSym,types),typeToMethodType(tree.getDescriptorType(types)));
  ListBuffer<Type> indy_args_types=new ListBuffer<>();
  for (  JCExpression arg : indy_args) {
    indy_args_types.append(arg.type);
  }
  MethodType indyType=new MethodType(indy_args_types.toList(),tree.type,List.<Type>nil(),syms.methodClass);
  Name metafactoryName=context.needsAltMetafactory() ? names.altMetafactory : names.metafactory;
  if (context.needsAltMetafactory()) {
    ListBuffer<Object> markers=new ListBuffer<>();
    for (    Type t : tree.targets.tail) {
      if (t.tsym != syms.serializableType.tsym) {
        markers.append(t.tsym);
      }
    }
    int flags=context.isSerializable() ? FLAG_SERIALIZABLE : 0;
    boolean hasMarkers=markers.nonEmpty();
    boolean hasBridges=context.bridges.nonEmpty();
    if (hasMarkers) {
      flags|=FLAG_MARKERS;
    }
    if (hasBridges) {
      flags|=FLAG_BRIDGES;
    }
    staticArgs=staticArgs.append(flags);
    if (hasMarkers) {
      staticArgs=staticArgs.append(markers.length());
      staticArgs=staticArgs.appendList(markers.toList());
    }
    if (hasBridges) {
      staticArgs=staticArgs.append(context.bridges.length() - 1);
      for (      Symbol s : context.bridges) {
        Type s_erasure=s.erasure(types);
        if (!types.isSameType(s_erasure,samSym.erasure(types))) {
          staticArgs=staticArgs.append(s.erasure(types));
        }
      }
    }
    if (context.isSerializable()) {
      int prevPos=make.pos;
      try {
        make.at(kInfo.clazz);
        addDeserializationCase(refKind,refSym,tree.type,samSym,tree,staticArgs,indyType);
      }
  finally {
        make.at(prevPos);
      }
    }
  }
  return makeIndyCall(tree,syms.lambdaMetafactory,metafactoryName,staticArgs,indyType,indy_args,samSym.name);
}","/** 
 * Generate an indy method call to the meta factory
 */
private JCExpression makeMetafactoryIndyCall(TranslationContext<?> context,int refKind,Symbol refSym,List<JCExpression> indy_args){
  JCFunctionalExpression tree=context.tree;
  MethodSymbol samSym=(MethodSymbol)types.findDescriptorSymbol(tree.type.tsym);
  List<Object> staticArgs=List.<Object>of(typeToMethodType(samSym.type),new Pool.MethodHandle(refKind,refSym,types),typeToMethodType(tree.getDescriptorType(types)));
  ListBuffer<Type> indy_args_types=new ListBuffer<>();
  for (  JCExpression arg : indy_args) {
    indy_args_types.append(arg.type);
  }
  MethodType indyType=new MethodType(indy_args_types.toList(),tree.type,List.<Type>nil(),syms.methodClass);
  Name metafactoryName=context.needsAltMetafactory() ? names.altMetafactory : names.metafactory;
  if (context.needsAltMetafactory()) {
    ListBuffer<Object> markers=new ListBuffer<>();
    for (    Type t : tree.targets.tail) {
      if (t.tsym != syms.serializableType.tsym) {
        markers.append(t.tsym);
      }
    }
    int flags=context.isSerializable() ? FLAG_SERIALIZABLE : 0;
    boolean hasMarkers=markers.nonEmpty();
    boolean hasBridges=context.bridges.nonEmpty();
    if (hasMarkers) {
      flags|=FLAG_MARKERS;
    }
    if (hasBridges) {
      flags|=FLAG_BRIDGES;
    }
    staticArgs=staticArgs.append(flags);
    if (hasMarkers) {
      staticArgs=staticArgs.append(markers.length());
      staticArgs=staticArgs.appendList(markers.toList());
    }
    if (hasBridges) {
      staticArgs=staticArgs.append(context.bridges.length() - 1);
      for (      Symbol s : context.bridges) {
        Type s_erasure=s.erasure(types);
        if (!types.isSameType(s_erasure,samSym.erasure(types))) {
          staticArgs=staticArgs.append(s.erasure(types));
        }
      }
    }
    if (context.isSerializable()) {
      addDeserializationCase(refKind,refSym,tree.type,samSym,tree,staticArgs,indyType);
    }
  }
  return makeIndyCall(tree,syms.lambdaMetafactory,metafactoryName,staticArgs,indyType,indy_args,samSym.name);
}"
12891,"private JCBlock makeLambdaExpressionBody(JCExpression expr,JCMethodDecl lambdaMethodDecl){
  Type restype=lambdaMethodDecl.type.getReturnType();
  boolean isLambda_void=expr.type.hasTag(VOID);
  boolean isTarget_void=restype.hasTag(VOID);
  boolean isTarget_Void=types.isSameType(restype,types.boxedClass(syms.voidType).type);
  int prevPos=make.pos;
  try {
    if (isTarget_void) {
      JCStatement stat=make.at(expr).Exec(expr);
      return make.Block(0,List.<JCStatement>of(stat));
    }
 else     if (isLambda_void && isTarget_Void) {
      ListBuffer<JCStatement> stats=new ListBuffer<>();
      stats.append(make.at(expr).Exec(expr));
      stats.append(make.Return(make.Literal(BOT,null).setType(syms.botType)));
      return make.Block(0,stats.toList());
    }
 else {
      JCExpression retExpr=transTypes.coerce(attrEnv,expr,restype);
      return make.at(retExpr).Block(0,List.<JCStatement>of(make.Return(retExpr)));
    }
  }
  finally {
    make.at(prevPos);
  }
}","private JCBlock makeLambdaExpressionBody(JCExpression expr,JCMethodDecl lambdaMethodDecl){
  Type restype=lambdaMethodDecl.type.getReturnType();
  boolean isLambda_void=expr.type.hasTag(VOID);
  boolean isTarget_void=restype.hasTag(VOID);
  boolean isTarget_Void=types.isSameType(restype,types.boxedClass(syms.voidType).type);
  if (isTarget_void) {
    JCStatement stat=make.Exec(expr);
    return make.Block(0,List.<JCStatement>of(stat));
  }
 else   if (isLambda_void && isTarget_Void) {
    ListBuffer<JCStatement> stats=new ListBuffer<>();
    stats.append(make.Exec(expr));
    stats.append(make.Return(make.Literal(BOT,null).setType(syms.botType)));
    return make.Block(0,stats.toList());
  }
 else {
    JCExpression retExpr=transTypes.coerce(attrEnv,expr,restype);
    return make.at(retExpr).Block(0,List.<JCStatement>of(make.Return(retExpr)));
  }
}"
12892,"private KlassInfo(JCClassDecl clazz){
  this.clazz=clazz;
  appendedMethodList=new ListBuffer<>();
  deserializeCases=new HashMap<String,ListBuffer<JCStatement>>();
  MethodType type=new MethodType(List.of(syms.serializedLambdaType),syms.objectType,List.<Type>nil(),syms.methodClass);
  deserMethodSym=makePrivateSyntheticMethod(STATIC,names.deserializeLambda,type,clazz.sym);
  deserParamSym=new VarSymbol(FINAL,names.fromString(""String_Node_Str""),syms.serializedLambdaType,deserMethodSym);
}","private KlassInfo(Symbol kSym){
  appendedMethodList=new ListBuffer<>();
  deserializeCases=new HashMap<String,ListBuffer<JCStatement>>();
  MethodType type=new MethodType(List.of(syms.serializedLambdaType),syms.objectType,List.<Type>nil(),syms.methodClass);
  deserMethodSym=makePrivateSyntheticMethod(STATIC,names.deserializeLambda,type,kSym);
  deserParamSym=new VarSymbol(FINAL,names.fromString(""String_Node_Str""),syms.serializedLambdaType,deserMethodSym);
}"
12893,"/** 
 * Returns the names of the annotation types supported by this processor.  An element of the result may be the canonical (fully qualified) name of a supported annotation type. Alternately it may be of the form &quot;<tt><i>name</i>.*</tt>&quot; representing the set of all annotation types with canonical names beginning with &quot;<tt><i>name.</i></tt>&quot;.  Finally,   {@code ""*""} by itself represents the set of all annotation types,including the empty set.  Note that a processor should not claim  {@code ""*""} unless it is actually processing all files;claiming unnecessary annotations may cause a performance slowdown in some environments. <p>Each string returned in the set must be accepted by the following grammar: <blockquote> <dl> <dt><i>SupportedAnnotationTypeString:</i> <dd><i>TypeName</i> <i>DotStar</i><sub><i>opt</i></sub> <dd><tt>*</tt> <p> <dt><i>DotStar:</i> <dd><tt>.</tt> <tt>*</tt> </dl> </blockquote> where <i>TypeName</i> is as defined in <cite>The Java&trade; Language Specification</cite>.
 * @return the names of the annotation types supported by this processor
 * @see javax.annotation.processing.SupportedAnnotationTypes
 * @jls 3.8 Identifiers
 * @jls 6.5.5 Meaning of Type Names
 */
Set<String> getSupportedAnnotationTypes();","/** 
 * Returns the names of the annotation types supported by this processor.  An element of the result may be the canonical (fully qualified) name of a supported annotation type. Alternately it may be of the form &quot;<tt><i>name</i>.*</tt>&quot; representing the set of all annotation types with canonical names beginning with &quot;<tt><i>name.</i></tt>&quot;.  Finally,   {@code ""*""} by itself represents the set of all annotation types,including the empty set.  Note that a processor should not claim  {@code ""*""} unless it is actually processing all files;claiming unnecessary annotations may cause a performance slowdown in some environments. <p>Each string returned in the set must be accepted by the following grammar: <blockquote> <dl> <dt><i>SupportedAnnotationTypeString:</i> <dd><i>TypeName</i> <i>DotStar</i><sub><i>opt</i></sub> <dd><tt>*</tt> <dt><i>DotStar:</i> <dd><tt>.</tt> <tt>*</tt> </dl> </blockquote> where <i>TypeName</i> is as defined in <cite>The Java&trade; Language Specification</cite>.
 * @return the names of the annotation types supported by this processor
 * @see javax.annotation.processing.SupportedAnnotationTypes
 * @jls 3.8 Identifiers
 * @jls 6.5.5 Meaning of Type Names
 */
Set<String> getSupportedAnnotationTypes();"
12894,"/** 
 * Returns the options recognized by this processor.  An implementation of the processing tool must provide a way to pass processor-specific options distinctly from options passed to the tool itself, see   {@link ProcessingEnvironment#getOptions getOptions}. <p>Each string returned in the set must be a period separated sequence of   {@linkplain javax.lang.model.SourceVersion#isIdentifier identifiers}: <blockquote> <dl> <dt><i>SupportedOptionString:</i> <dd><i>Identifiers</i> <p> <dt><i>Identifiers:</i> <dd> <i>Identifier</i> <dd> <i>Identifier</i>   {@code .} <i>Identifiers</i><p> <dt><i>Identifier:</i> <dd>Syntactic identifier, including keywords and literals </dl> </blockquote> <p> A tool might use this information to determine if any options provided by a user are unrecognized by any processor, in which case it may wish to report a warning.
 * @return the options recognized by this processor or anempty collection if none
 * @see javax.annotation.processing.SupportedOptions
 */
Set<String> getSupportedOptions();","/** 
 * Returns the options recognized by this processor.  An implementation of the processing tool must provide a way to pass processor-specific options distinctly from options passed to the tool itself, see   {@link ProcessingEnvironment#getOptions getOptions}. <p>Each string returned in the set must be a period separated sequence of   {@linkplain javax.lang.model.SourceVersion#isIdentifier identifiers}: <blockquote> <dl> <dt><i>SupportedOptionString:</i> <dd><i>Identifiers</i> <dt><i>Identifiers:</i> <dd> <i>Identifier</i> <dd> <i>Identifier</i>   {@code .} <i>Identifiers</i><dt><i>Identifier:</i> <dd>Syntactic identifier, including keywords and literals </dl> </blockquote> <p> A tool might use this information to determine if any options provided by a user are unrecognized by any processor, in which case it may wish to report a warning.
 * @return the options recognized by this processor or anempty collection if none
 * @see javax.annotation.processing.SupportedOptions
 */
Set<String> getSupportedOptions();"
12895,"/** 
 * Return the kind of this tag. similar or synonymous tags.  For most tags, <code>kind()&nbsp;==&nbsp;name()</code>; the following table lists those cases where there is more than one tag of a given kind: <p> <table border=""1"" cellpadding=""4"" cellspacing=""0""> <tr><th><tt> kind()  </tt></th>  <th><tt> name()      </tt></th></tr> <tr><td><tt> @throws </tt></td>  <td><tt> @throws     </tt></td></tr> <tr><td><tt> @throws </tt></td>  <td><tt> @exception  </tt></td></tr> <tr><td><tt> @see    </tt></td>  <td><tt> @see        </tt></td></tr> <tr><td><tt> @see    </tt></td>  <td><tt> @link       </tt></td></tr> <tr><td><tt> @see    </tt></td>  <td><tt> @linkplain  </tt></td></tr> <tr><td><tt> @serial </tt></td>  <td><tt> @serial     </tt></td></tr> <tr><td><tt> @serial </tt></td>  <td><tt> @serialData </tt></td></tr> </table>
 */
String kind();","/** 
 * Return the kind of this tag. For most tags, <code>kind()&nbsp;==&nbsp;name()</code>; the following table lists those cases where there is more than one tag of a given kind: <p> <table border=""1"" cellpadding=""4"" cellspacing=""0"" summary=""related tags""> <tr><th>  {@code kind()  }</th>  <th>  {@code name()      }</th></tr> <tr><td>  {@code @throws }</td>  <td>  {@code @throws     }</td></tr> <tr><td>  {@code @throws }</td>  <td>  {@code @exception  }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @see        }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @link       }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @linkplain  }</td></tr> <tr><td>  {@code @serial }</td>  <td>  {@code @serial     }</td></tr> <tr><td>  {@code @serial }</td>  <td>  {@code @serialData }</td></tr> </table>
 * @return the kind of this tag.
 */
String kind();"
12896,"/** 
 * Return the name of this tag.  The name is the string starting with ""@"" that is used in a doc comment, such as <code>@return</code>.  For inline tags, such as <code>{&#064;link}</code>, the curly brackets are not part of the name, so in this example the name would be simply <code>@link</code>.
 */
String name();","/** 
 * Return the name of this tag.  The name is the string starting with ""@"" that is used in a doc comment, such as <code>@return</code>.  For inline tags, such as <code>{&#064;link}</code>, the curly brackets are not part of the name, so in this example the name would be simply <code>@link</code>.
 * @return the name of this tag
 */
String name();"
12897,"/** 
 * Return the containing   {@link Doc} of this Tag element.
 */
Doc holder();","/** 
 * Return the containing   {@link Doc} of this Tag element.
 * @return the containing {@link Doc} of this Tag element
 */
Doc holder();"
12898,"/** 
 * Return the text of this tag, that is, portion beyond tag name.
 */
String text();","/** 
 * Return the text of this tag, that is, the portion beyond tag name.
 * @return the text of this tag
 */
String text();"
12899,"BasicLookupHelper(Name name,Type site,List<Type> argtypes,List<Type> typeargtypes){
  super(name,site,argtypes,typeargtypes,MethodResolutionPhase.VARARITY);
}","BasicLookupHelper(Name name,Type site,List<Type> argtypes,List<Type> typeargtypes,MethodResolutionPhase maxPhase){
  super(name,site,argtypes,typeargtypes,maxPhase);
}"
12900,"/** 
 * Select the best method for a call site among two choices.
 * @param env              The current environment.
 * @param site             The original type from where theselection takes place.
 * @param argtypes         The invocation's value arguments,
 * @param typeargtypes     The invocation's type arguments,
 * @param sym              Proposed new best match.
 * @param bestSoFar        Previously found best match.
 * @param allowBoxing Allow boxing conversions of arguments.
 * @param useVarargs Box trailing arguments into an array for varargs.
 */
@SuppressWarnings(""String_Node_Str"") Symbol selectBest(Env<AttrContext> env,Type site,List<Type> argtypes,List<Type> typeargtypes,Symbol sym,Symbol bestSoFar,boolean allowBoxing,boolean useVarargs,boolean operator){
  if (sym.kind == ERR || !sym.isInheritedIn(site.tsym,types)) {
    return bestSoFar;
  }
 else   if (useVarargs && (sym.flags() & VARARGS) == 0) {
    return bestSoFar.kind >= ERRONEOUS ? new BadVarargsMethod((ResolveError)bestSoFar) : bestSoFar;
  }
  Assert.check(sym.kind < AMBIGUOUS);
  try {
    Type mt=rawInstantiate(env,site,sym,null,argtypes,typeargtypes,allowBoxing,useVarargs,types.noWarnings);
    if (!operator)     currentResolutionContext.addApplicableCandidate(sym,mt);
  }
 catch (  InapplicableMethodException ex) {
    if (!operator)     currentResolutionContext.addInapplicableCandidate(sym,ex.getDiagnostic());
switch (bestSoFar.kind) {
case ABSENT_MTH:
      return new InapplicableSymbolError(currentResolutionContext);
case WRONG_MTH:
    if (operator)     return bestSoFar;
  bestSoFar=new InapplicableSymbolsError(currentResolutionContext);
default :
return bestSoFar;
}
}
if (!isAccessible(env,site,sym)) {
return (bestSoFar.kind == ABSENT_MTH) ? new AccessError(env,site,sym) : bestSoFar;
}
return (bestSoFar.kind > AMBIGUOUS) ? sym : mostSpecific(argtypes,sym,bestSoFar,env,site,allowBoxing && operator,useVarargs);
}","/** 
 * Select the best method for a call site among two choices.
 * @param env              The current environment.
 * @param site             The original type from where theselection takes place.
 * @param argtypes         The invocation's value arguments,
 * @param typeargtypes     The invocation's type arguments,
 * @param sym              Proposed new best match.
 * @param bestSoFar        Previously found best match.
 * @param allowBoxing Allow boxing conversions of arguments.
 * @param useVarargs Box trailing arguments into an array for varargs.
 */
@SuppressWarnings(""String_Node_Str"") Symbol selectBest(Env<AttrContext> env,Type site,List<Type> argtypes,List<Type> typeargtypes,Symbol sym,Symbol bestSoFar,boolean allowBoxing,boolean useVarargs,boolean operator){
  if (sym.kind == ERR || !sym.isInheritedIn(site.tsym,types)) {
    return bestSoFar;
  }
 else   if (useVarargs && (sym.flags() & VARARGS) == 0) {
    return bestSoFar.kind >= ERRONEOUS ? new BadVarargsMethod((ResolveError)bestSoFar) : bestSoFar;
  }
  Assert.check(sym.kind < AMBIGUOUS);
  try {
    Type mt=rawInstantiate(env,site,sym,null,argtypes,typeargtypes,allowBoxing,useVarargs,types.noWarnings);
    if (!operator || verboseResolutionMode.contains(VerboseResolutionMode.PREDEF))     currentResolutionContext.addApplicableCandidate(sym,mt);
  }
 catch (  InapplicableMethodException ex) {
    if (!operator)     currentResolutionContext.addInapplicableCandidate(sym,ex.getDiagnostic());
switch (bestSoFar.kind) {
case ABSENT_MTH:
      return new InapplicableSymbolError(currentResolutionContext);
case WRONG_MTH:
    if (operator)     return bestSoFar;
  bestSoFar=new InapplicableSymbolsError(currentResolutionContext);
default :
return bestSoFar;
}
}
if (!isAccessible(env,site,sym)) {
return (bestSoFar.kind == ABSENT_MTH) ? new AccessError(env,site,sym) : bestSoFar;
}
return (bestSoFar.kind > AMBIGUOUS) ? sym : mostSpecific(argtypes,sym,bestSoFar,env,site,allowBoxing && operator,useVarargs);
}"
12901,"/** 
 * Resolve operator.
 * @param pos       The position to use for error reporting.
 * @param optag     The tag of the operation tree.
 * @param env       The environment current at the operation.
 * @param argtypes  The types of the operands.
 */
Symbol resolveOperator(DiagnosticPosition pos,JCTree.Tag optag,Env<AttrContext> env,List<Type> argtypes){
  MethodResolutionContext prevResolutionContext=currentResolutionContext;
  try {
    currentResolutionContext=new MethodResolutionContext();
    Name name=treeinfo.operatorName(optag);
    env.info.pendingResolutionPhase=currentResolutionContext.step=BASIC;
    Symbol sym=findMethod(env,syms.predefClass.type,name,argtypes,null,false,false,true);
    if (boxingEnabled && sym.kind >= WRONG_MTHS)     env.info.pendingResolutionPhase=currentResolutionContext.step=BOX;
    sym=findMethod(env,syms.predefClass.type,name,argtypes,null,true,false,true);
    return accessMethod(sym,pos,env.enclClass.sym.type,name,false,argtypes,null);
  }
  finally {
    currentResolutionContext=prevResolutionContext;
  }
}","/** 
 * Resolve operator.
 * @param pos       The position to use for error reporting.
 * @param optag     The tag of the operation tree.
 * @param env       The environment current at the operation.
 * @param argtypes  The types of the operands.
 */
Symbol resolveOperator(DiagnosticPosition pos,JCTree.Tag optag,Env<AttrContext> env,List<Type> argtypes){
  MethodResolutionContext prevResolutionContext=currentResolutionContext;
  try {
    currentResolutionContext=new MethodResolutionContext();
    Name name=treeinfo.operatorName(optag);
    return lookupMethod(env,pos,syms.predefClass,currentResolutionContext,new BasicLookupHelper(name,syms.predefClass.type,argtypes,null,BOX){
      @Override Symbol lookup(      Env<AttrContext> env,      MethodResolutionPhase phase){
        return findMethod(env,site,name,argtypes,typeargtypes,phase.isBoxingRequired(),phase.isVarargsRequired(),true);
      }
      @Override Symbol access(      Env<AttrContext> env,      DiagnosticPosition pos,      Symbol location,      Symbol sym){
        return accessMethod(sym,pos,env.enclClass.sym.type,name,false,argtypes,null);
      }
    }
);
  }
  finally {
    currentResolutionContext=prevResolutionContext;
  }
}"
12902,"String computeKey(Element e){
  StringBuilder buf=new StringBuilder();
  while (e != null) {
    buf.append(e.toString());
    e=e.getEnclosingElement();
  }
  buf.append(jfo.getName());
  return buf.toString();
}","String computeKey(Element e){
  StringBuilder buf=new StringBuilder();
  if (predefTranslationMap.containsKey(e.getSimpleName().toString())) {
    buf.append(""String_Node_Str"");
    String replacedName=predefTranslationMap.get(e.getSimpleName().toString());
    buf.append(e.toString().replace(e.getSimpleName().toString(),replacedName));
  }
 else   if (e.getSimpleName().toString().startsWith(""String_Node_Str"")) {
    buf.append(""String_Node_Str"");
    buf.append(e.toString());
  }
 else {
    while (e != null) {
      buf.append(e.toString());
      e=e.getEnclosingElement();
    }
    buf.append(jfo.getName());
  }
  return buf.toString();
}"
12903,"protected ResolveHarness(JavaFileObject jfo){
  this.jfo=jfo;
  this.diagProcessors=new DiagnosticProcessor[]{new VerboseResolutionNoteProcessor(),new VerboseDeferredInferenceNoteProcessor(),new ErrorProcessor()};
}","protected ResolveHarness(JavaFileObject jfo){
  this.jfo=jfo;
  this.diagProcessors=new DiagnosticProcessor[]{new VerboseResolutionNoteProcessor(),new VerboseDeferredInferenceNoteProcessor(),new ErrorProcessor()};
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
}"
12904,"/** 
 * Convenience method equivalent to   {@code v.scan(e, null)}.
 * @return the result of scanning {@code e}.
 */
public final R scan(Element e){
  return scan(e,null);
}","/** 
 * Convenience method equivalent to   {@code v.scan(e, null)}.
 * @param e the element to scan
 * @return the result of scanning {@code e}.
 */
public final R scan(Element e){
  return scan(e,null);
}"
12905,"/** 
 * Return a name with the same sequence of characters as the argument.
 * @param cs the character sequence to return as a name
 */
Name getName(CharSequence cs);","/** 
 * Return a name with the same sequence of characters as the argument.
 * @param cs the character sequence to return as a name
 * @return a name with the same sequence of characters as the argument
 */
Name getName(CharSequence cs);"
12906,"/** 
 * Returns the element corresponding to a type. The type may be a   {@code DeclaredType} or {@code TypeVariable}. Returns   {@code null} if the type is not one with acorresponding element.
 * @return the element corresponding to the given type
 */
Element asElement(TypeMirror t);","/** 
 * Returns the element corresponding to a type. The type may be a   {@code DeclaredType} or {@code TypeVariable}. Returns   {@code null} if the type is not one with acorresponding element.
 * @param t the type to map to an element
 * @return the element corresponding to the given type
 */
Element asElement(TypeMirror t);"
12907,"private static List<Archive> init(){
  List<Archive> result=new ArrayList<Archive>();
  String javaHome=System.getProperty(""String_Node_Str"");
  List<File> files=new ArrayList<File>();
  File jre=new File(javaHome,""String_Node_Str"");
  File lib=new File(javaHome,""String_Node_Str"");
  try {
    if (jre.exists() && jre.isDirectory()) {
      result.addAll(addJarFiles(new File(jre,""String_Node_Str"")));
      result.addAll(addJarFiles(lib));
    }
 else     if (lib.exists() && lib.isDirectory()) {
      File classes=new File(javaHome,""String_Node_Str"");
      if (classes.exists() && classes.isDirectory()) {
        result.add(new Archive(classes,ClassFileReader.newInstance(classes)));
      }
      result.addAll(addJarFiles(lib));
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + javaHome + ""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  return result;
}","private static List<Archive> init(){
  List<Archive> result=new ArrayList<Archive>();
  String javaHome=System.getProperty(""String_Node_Str"");
  File jre=new File(javaHome,""String_Node_Str"");
  File lib=new File(javaHome,""String_Node_Str"");
  try {
    if (jre.exists() && jre.isDirectory()) {
      result.addAll(addJarFiles(new File(jre,""String_Node_Str"")));
      result.addAll(addJarFiles(lib));
    }
 else     if (lib.exists() && lib.isDirectory()) {
      File classes=new File(javaHome,""String_Node_Str"");
      if (classes.exists() && classes.isDirectory()) {
        result.add(new Archive(classes,ClassFileReader.newInstance(classes)));
      }
      result.addAll(addJarFiles(lib));
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + javaHome + ""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  return result;
}"
12908,"/** 
 * Scan the arguments for -i -x -xf -if followed by the option -src, -sourcepath, -modulepath or -classpath and produce a map of all the files to referenced for that particular option. Store the found sources and the found modules in the supplied maps.
 */
private boolean findFiles(String[] args,String option,Set<String> suffixes,Map<String,Source> found_files,Map<String,Module> found_modules,Module current_module,boolean inLinksrc) throws ProblemException, ProblemException {
  Set<File> roots=new HashSet<File>();
  List<String> includes=new LinkedList<String>();
  List<String> excludes=new LinkedList<String>();
  List<String> excludefiles=new LinkedList<String>();
  List<String> includefiles=new LinkedList<String>();
  List<String> moduleinfo=new LinkedList<String>();
  moduleinfo.add(""String_Node_Str"");
  for (int i=0; i < args.length; ++i) {
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String incl=args[i + 1];
      checkPattern(incl);
      includes.add(incl);
    }
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String excl=args[i + 1];
      checkPattern(excl);
      excludes.add(excl);
    }
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String exclf=args[i + 1];
      checkFilePattern(exclf);
      exclf=Util.normalizeDriveLetter(exclf);
      excludefiles.add(fixupSeparator(exclf));
    }
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String inclf=args[i + 1];
      checkFilePattern(inclf);
      inclf=Util.normalizeDriveLetter(inclf);
      includefiles.add(fixupSeparator(inclf));
    }
    if (args[i].equals(option)) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"" + option);
      }
      String[] root_dirs=args[i + 1].split(File.pathSeparator);
      for (      String r : root_dirs) {
        File root=new File(r);
        if (!root.isDirectory()) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str"");
        }
        try {
          root=root.getCanonicalFile();
        }
 catch (        IOException e) {
          throw new ProblemException(""String_Node_Str"" + e);
        }
        if (roots.contains(root)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option);
        }
        if (roots.equals(bin_dir)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option+ ""String_Node_Str"");
        }
        if (roots.equals(gensrc_dir)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option+ ""String_Node_Str"");
        }
        if (roots.equals(header_dir)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option+ ""String_Node_Str"");
        }
        roots.add(root);
        Source.scanRoot(root,suffixes,excludes,includes,excludefiles,includefiles,found_files,found_modules,current_module,findBooleanOption(args,""String_Node_Str""),false,inLinksrc);
      }
    }
    if (args[i].equals(""String_Node_Str"") || args[i].equals(""String_Node_Str"") || args[i].equals(""String_Node_Str"")|| args[i].equals(""String_Node_Str"")|| args[i].equals(""String_Node_Str"")) {
      includes=new LinkedList<String>();
      excludes=new LinkedList<String>();
      excludefiles=new LinkedList<String>();
      includefiles=new LinkedList<String>();
    }
  }
  return true;
}","/** 
 * Scan the arguments for -i -x -xf -if followed by the option -src, -sourcepath, -modulepath or -classpath and produce a map of all the files to referenced for that particular option. Store the found sources and the found modules in the supplied maps.
 */
private boolean findFiles(String[] args,String option,Set<String> suffixes,Map<String,Source> found_files,Map<String,Module> found_modules,Module current_module,boolean inLinksrc) throws ProblemException, ProblemException {
  Set<File> roots=new HashSet<File>();
  List<String> includes=new LinkedList<String>();
  List<String> excludes=new LinkedList<String>();
  List<String> excludefiles=new LinkedList<String>();
  List<String> includefiles=new LinkedList<String>();
  List<String> moduleinfo=new LinkedList<String>();
  moduleinfo.add(""String_Node_Str"");
  for (int i=0; i < args.length; ++i) {
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String incl=args[i + 1];
      checkPattern(incl);
      includes.add(incl);
    }
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String excl=args[i + 1];
      checkPattern(excl);
      excludes.add(excl);
    }
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String exclf=args[i + 1];
      checkFilePattern(exclf);
      exclf=Util.normalizeDriveLetter(exclf);
      excludefiles.add(fixupSeparator(exclf));
    }
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String inclf=args[i + 1];
      checkFilePattern(inclf);
      inclf=Util.normalizeDriveLetter(inclf);
      includefiles.add(fixupSeparator(inclf));
    }
    if (args[i].equals(option)) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"" + option);
      }
      String[] root_dirs=args[i + 1].split(File.pathSeparator);
      for (      String r : root_dirs) {
        File root=new File(r);
        if (!root.isDirectory()) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str"");
        }
        try {
          root=root.getCanonicalFile();
        }
 catch (        IOException e) {
          throw new ProblemException(""String_Node_Str"" + e);
        }
        if (roots.contains(root)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option);
        }
        if (root.equals(bin_dir)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option+ ""String_Node_Str"");
        }
        if (root.equals(gensrc_dir)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option+ ""String_Node_Str"");
        }
        if (root.equals(header_dir)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option+ ""String_Node_Str"");
        }
        roots.add(root);
        Source.scanRoot(root,suffixes,excludes,includes,excludefiles,includefiles,found_files,found_modules,current_module,findBooleanOption(args,""String_Node_Str""),false,inLinksrc);
      }
    }
    if (args[i].equals(""String_Node_Str"") || args[i].equals(""String_Node_Str"") || args[i].equals(""String_Node_Str"")|| args[i].equals(""String_Node_Str"")|| args[i].equals(""String_Node_Str"")) {
      includes=new LinkedList<String>();
      excludes=new LinkedList<String>();
      excludefiles=new LinkedList<String>();
      includefiles=new LinkedList<String>();
    }
  }
  return true;
}"
12909,"public int go(String[] args,PrintStream out,PrintStream err){
  try {
    if (args.length == 0 || findJavaSourceFiles(args) || findAtFile(args) || null == Util.findServerSettings(args)) {
      printHelp();
      return 0;
    }
    Log.setLogLevel(findLogLevel(args),out,err);
    String server_settings=Util.findServerSettings(args);
    args=verifyImplicitOption(args);
    args=addSrcBeforeDirectories(args);
    checkSrcOption(args);
    bin_dir=findDirectoryOption(args,""String_Node_Str"",""String_Node_Str"",true,false,true);
    gensrc_dir=findDirectoryOption(args,""String_Node_Str"",""String_Node_Str"",false,false,true);
    header_dir=findDirectoryOption(args,""String_Node_Str"",""String_Node_Str"",false,false,true);
    makefile_source_list=findFileOption(args,""String_Node_Str"",""String_Node_Str"",false);
    javac_state=JavacState.load(args,bin_dir,gensrc_dir,header_dir,findBooleanOption(args,""String_Node_Str""),out,err);
    suffix_rules=javac_state.getJavaSuffixRule();
    findTranslateOptions(args,suffix_rules);
    if (suffix_rules.keySet().size() > 1 && gensrc_dir == null) {
      Log.error(""String_Node_Str"");
      return -1;
    }
    findCopyOptions(args,suffix_rules);
    Map<String,Module> modules=new HashMap<String,Module>();
    Module current_module=new Module(""String_Node_Str"",""String_Node_Str"");
    modules.put(""String_Node_Str"",current_module);
    Map<String,Source> sources=new HashMap<String,Source>();
    findFiles(args,""String_Node_Str"",suffix_rules.keySet(),sources,modules,current_module,false);
    if (sources.isEmpty()) {
      Log.error(""String_Node_Str"");
      return -1;
    }
    Map<String,Source> sources_to_link_to=new HashMap<String,Source>();
    rewriteOptions(args,""String_Node_Str"",""String_Node_Str"");
    findFiles(args,""String_Node_Str"",Util.set(""String_Node_Str""),sources_to_link_to,modules,current_module,true);
    Map<String,Source> classes_to_link_to=new HashMap<String,Source>();
    Map<String,Source> modules_to_link_to=new HashMap<String,Source>();
    javac_state.now().collectPackagesSourcesAndArtifacts(modules);
    javac_state.now().checkInternalState(""String_Node_Str"",false,sources);
    javac_state.now().checkInternalState(""String_Node_Str"",true,sources_to_link_to);
    javac_state.setVisibleSources(sources_to_link_to);
    javac_state.checkSourceStatus(false);
    javac_state.findAllArtifacts();
    if (!findBooleanOption(args,""String_Node_Str"")) {
      javac_state.removeUnidentifiedArtifacts();
    }
    javac_state.taintPackagesThatMissArtifacts();
    javac_state.deleteClassArtifactsInTaintedPackages();
    javac_state.performCopying(bin_dir,suffix_rules);
    javac_state.performTranslation(gensrc_dir,suffix_rules);
    Map<String,Source> generated_sources=new HashMap<String,Source>();
    Source.scanRoot(gensrc_dir,Util.set(""String_Node_Str""),null,null,null,null,generated_sources,modules,current_module,false,true,false);
    javac_state.now().collectPackagesSourcesAndArtifacts(modules);
    javac_state.checkSourceStatus(true);
    javac_state.compareWithMakefileList(makefile_source_list);
    boolean again;
    Set<String> recently_compiled=new HashSet<String>();
    boolean[] rc=new boolean[1];
    do {
      javac_state.deleteClassArtifactsInTaintedPackages();
      again=javac_state.performJavaCompilations(bin_dir,server_settings,args,recently_compiled,rc);
      if (!rc[0])       break;
    }
 while (again);
    if (rc[0]) {
      javac_state.save();
      javac_state.now().collectArtifacts(modules);
      javac_state.removeSuperfluousArtifacts(recently_compiled);
    }
    return rc[0] ? 0 : -1;
  }
 catch (  ProblemException e) {
    Log.error(e.getMessage());
    return -1;
  }
catch (  Exception e) {
    e.printStackTrace(err);
    return -1;
  }
}","public int go(String[] args,PrintStream out,PrintStream err){
  try {
    if (args.length == 0 || findJavaSourceFiles(args) || findAtFile(args) || null == Util.findServerSettings(args)) {
      printHelp();
      return 0;
    }
    Log.setLogLevel(findLogLevel(args),out,err);
    String server_settings=Util.findServerSettings(args);
    args=verifyImplicitOption(args);
    args=addSrcBeforeDirectories(args);
    checkSrcOption(args);
    bin_dir=findDirectoryOption(args,""String_Node_Str"",""String_Node_Str"",true,false,true);
    gensrc_dir=findDirectoryOption(args,""String_Node_Str"",""String_Node_Str"",false,false,true);
    header_dir=findDirectoryOption(args,""String_Node_Str"",""String_Node_Str"",false,false,true);
    makefile_source_list=findFileOption(args,""String_Node_Str"",""String_Node_Str"",false);
    javac_state=JavacState.load(args,bin_dir,gensrc_dir,header_dir,findBooleanOption(args,""String_Node_Str""),out,err);
    suffix_rules=javac_state.getJavaSuffixRule();
    findTranslateOptions(args,suffix_rules);
    if (suffix_rules.keySet().size() > 1 && gensrc_dir == null) {
      Log.error(""String_Node_Str"");
      return -1;
    }
    findCopyOptions(args,suffix_rules);
    Map<String,Module> modules=new HashMap<String,Module>();
    Module current_module=new Module(""String_Node_Str"",""String_Node_Str"");
    modules.put(""String_Node_Str"",current_module);
    Map<String,Source> sources=new HashMap<String,Source>();
    findFiles(args,""String_Node_Str"",suffix_rules.keySet(),sources,modules,current_module,false);
    if (sources.isEmpty()) {
      Log.error(""String_Node_Str"");
      return -1;
    }
    Map<String,Source> sources_to_link_to=new HashMap<String,Source>();
    rewriteOptions(args,""String_Node_Str"",""String_Node_Str"");
    findFiles(args,""String_Node_Str"",Util.set(""String_Node_Str""),sources_to_link_to,modules,current_module,true);
    javac_state.now().collectPackagesSourcesAndArtifacts(modules);
    javac_state.now().checkInternalState(""String_Node_Str"",false,sources);
    javac_state.now().checkInternalState(""String_Node_Str"",true,sources_to_link_to);
    javac_state.setVisibleSources(sources_to_link_to);
    javac_state.checkSourceStatus(false);
    javac_state.findAllArtifacts();
    if (!findBooleanOption(args,""String_Node_Str"")) {
      javac_state.removeUnidentifiedArtifacts();
    }
    javac_state.taintPackagesThatMissArtifacts();
    javac_state.deleteClassArtifactsInTaintedPackages();
    javac_state.performCopying(bin_dir,suffix_rules);
    javac_state.performTranslation(gensrc_dir,suffix_rules);
    Map<String,Source> generated_sources=new HashMap<String,Source>();
    Source.scanRoot(gensrc_dir,Util.set(""String_Node_Str""),null,null,null,null,generated_sources,modules,current_module,false,true,false);
    javac_state.now().collectPackagesSourcesAndArtifacts(modules);
    javac_state.checkSourceStatus(true);
    javac_state.compareWithMakefileList(makefile_source_list);
    boolean again;
    Set<String> recently_compiled=new HashSet<String>();
    boolean[] rc=new boolean[1];
    do {
      javac_state.deleteClassArtifactsInTaintedPackages();
      again=javac_state.performJavaCompilations(bin_dir,server_settings,args,recently_compiled,rc);
      if (!rc[0])       break;
    }
 while (again);
    if (rc[0]) {
      javac_state.save();
      javac_state.now().collectArtifacts(modules);
      javac_state.removeSuperfluousArtifacts(recently_compiled);
    }
    return rc[0] ? 0 : -1;
  }
 catch (  ProblemException e) {
    Log.error(e.getMessage());
    return -1;
  }
catch (  Exception e) {
    e.printStackTrace(err);
    return -1;
  }
}"
12910,"@Override public Symbol access(Name name,TypeSymbol location){
  return types.createErrorType(name,location,syms.errSymbol.type).tsym;
}","@Override protected Symbol access(Name name,TypeSymbol location){
  return ambiguousSyms.last();
}"
12911,"Symbol mostSpecific(List<Type> argtypes,Symbol m1,Symbol m2,Env<AttrContext> env,final Type site,boolean allowBoxing,boolean useVarargs){
switch (m2.kind) {
case MTH:
    if (m1 == m2)     return m1;
  boolean m1SignatureMoreSpecific=signatureMoreSpecific(argtypes,env,site,m1,m2,allowBoxing,useVarargs);
boolean m2SignatureMoreSpecific=signatureMoreSpecific(argtypes,env,site,m2,m1,allowBoxing,useVarargs);
if (m1SignatureMoreSpecific && m2SignatureMoreSpecific) {
Type mt1=types.memberType(site,m1);
Type mt2=types.memberType(site,m2);
if (!types.overrideEquivalent(mt1,mt2)) return ambiguityError(m1,m2);
if ((m1.flags() & BRIDGE) != (m2.flags() & BRIDGE)) return ((m1.flags() & BRIDGE) != 0) ? m2 : m1;
TypeSymbol m1Owner=(TypeSymbol)m1.owner;
TypeSymbol m2Owner=(TypeSymbol)m2.owner;
if (types.asSuper(m1Owner.type,m2Owner) != null && ((m1.owner.flags_field & INTERFACE) == 0 || (m2.owner.flags_field & INTERFACE) != 0) && m1.overrides(m2,m1Owner,types,false)) return m1;
if (types.asSuper(m2Owner.type,m1Owner) != null && ((m2.owner.flags_field & INTERFACE) == 0 || (m1.owner.flags_field & INTERFACE) != 0) && m2.overrides(m1,m2Owner,types,false)) return m2;
boolean m1Abstract=(m1.flags() & ABSTRACT) != 0;
boolean m2Abstract=(m2.flags() & ABSTRACT) != 0;
if (m1Abstract && !m2Abstract) return m2;
if (m2Abstract && !m1Abstract) return m1;
if (!m1Abstract && !m2Abstract) return ambiguityError(m1,m2);
if (!types.isSameTypes(m1.erasure(types).getParameterTypes(),m2.erasure(types).getParameterTypes())) return ambiguityError(m1,m2);
Type mst=mostSpecificReturnType(mt1,mt2);
if (mst == null) {
  return ambiguityError(m1,m2);
}
Symbol mostSpecific=mst == mt1 ? m1 : m2;
List<Type> allThrown=chk.intersect(mt1.getThrownTypes(),mt2.getThrownTypes());
Type newSig=types.createMethodTypeWithThrown(mostSpecific.type,allThrown);
MethodSymbol result=new MethodSymbol(mostSpecific.flags(),mostSpecific.name,newSig,mostSpecific.owner){
  @Override public MethodSymbol implementation(  TypeSymbol origin,  Types types,  boolean checkResult){
    if (origin == site.tsym)     return this;
 else     return super.implementation(origin,types,checkResult);
  }
}
;
return result;
}
if (m1SignatureMoreSpecific) return m1;
if (m2SignatureMoreSpecific) return m2;
return ambiguityError(m1,m2);
case AMBIGUOUS:
AmbiguityError e=(AmbiguityError)m2;
Symbol err1=mostSpecific(argtypes,m1,e.sym,env,site,allowBoxing,useVarargs);
Symbol err2=mostSpecific(argtypes,m1,e.sym2,env,site,allowBoxing,useVarargs);
if (err1 == err2) return err1;
if (err1 == e.sym && err2 == e.sym2) return m2;
if (err1 instanceof AmbiguityError && err2 instanceof AmbiguityError && ((AmbiguityError)err1).sym == ((AmbiguityError)err2).sym) return ambiguityError(m1,m2);
 else return ambiguityError(err1,err2);
default :
throw new AssertionError();
}
}","Symbol mostSpecific(List<Type> argtypes,Symbol m1,Symbol m2,Env<AttrContext> env,final Type site,boolean allowBoxing,boolean useVarargs){
switch (m2.kind) {
case MTH:
    if (m1 == m2)     return m1;
  boolean m1SignatureMoreSpecific=signatureMoreSpecific(argtypes,env,site,m1,m2,allowBoxing,useVarargs);
boolean m2SignatureMoreSpecific=signatureMoreSpecific(argtypes,env,site,m2,m1,allowBoxing,useVarargs);
if (m1SignatureMoreSpecific && m2SignatureMoreSpecific) {
Type mt1=types.memberType(site,m1);
Type mt2=types.memberType(site,m2);
if (!types.overrideEquivalent(mt1,mt2)) return ambiguityError(m1,m2);
if ((m1.flags() & BRIDGE) != (m2.flags() & BRIDGE)) return ((m1.flags() & BRIDGE) != 0) ? m2 : m1;
TypeSymbol m1Owner=(TypeSymbol)m1.owner;
TypeSymbol m2Owner=(TypeSymbol)m2.owner;
if (types.asSuper(m1Owner.type,m2Owner) != null && ((m1.owner.flags_field & INTERFACE) == 0 || (m2.owner.flags_field & INTERFACE) != 0) && m1.overrides(m2,m1Owner,types,false)) return m1;
if (types.asSuper(m2Owner.type,m1Owner) != null && ((m2.owner.flags_field & INTERFACE) == 0 || (m1.owner.flags_field & INTERFACE) != 0) && m2.overrides(m1,m2Owner,types,false)) return m2;
boolean m1Abstract=(m1.flags() & ABSTRACT) != 0;
boolean m2Abstract=(m2.flags() & ABSTRACT) != 0;
if (m1Abstract && !m2Abstract) return m2;
if (m2Abstract && !m1Abstract) return m1;
return ambiguityError(m1,m2);
}
if (m1SignatureMoreSpecific) return m1;
if (m2SignatureMoreSpecific) return m2;
return ambiguityError(m1,m2);
case AMBIGUOUS:
AmbiguityError e=(AmbiguityError)m2;
for (Symbol s : e.ambiguousSyms) {
if (mostSpecific(argtypes,m1,s,env,site,allowBoxing,useVarargs) != m1) {
return e.addAmbiguousSymbol(m1);
}
}
return m1;
default :
throw new AssertionError();
}
}"
12912,"AmbiguityError(Symbol sym1,Symbol sym2){
  super(AMBIGUOUS,sym1,""String_Node_Str"");
  this.sym2=sym2;
}","AmbiguityError(Symbol sym1,Symbol sym2){
  super(AMBIGUOUS,""String_Node_Str"");
  ambiguousSyms=flatten(sym2).appendList(flatten(sym1));
}"
12913,"@Override JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,DiagnosticPosition pos,Symbol location,Type site,Name name,List<Type> argtypes,List<Type> typeargtypes){
  AmbiguityError pair=this;
  while (true) {
    if (pair.sym.kind == AMBIGUOUS)     pair=(AmbiguityError)pair.sym;
 else     if (pair.sym2.kind == AMBIGUOUS)     pair=(AmbiguityError)pair.sym2;
 else     break;
  }
  Name sname=pair.sym.name;
  if (sname == names.init)   sname=pair.sym.owner.name;
  return diags.create(dkind,log.currentSource(),pos,""String_Node_Str"",sname,kindName(pair.sym),pair.sym,pair.sym.location(site,types),kindName(pair.sym2),pair.sym2,pair.sym2.location(site,types));
}","@Override JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,DiagnosticPosition pos,Symbol location,Type site,Name name,List<Type> argtypes,List<Type> typeargtypes){
  List<Symbol> diagSyms=ambiguousSyms.reverse();
  Symbol s1=diagSyms.head;
  Symbol s2=diagSyms.tail.head;
  Name sname=s1.name;
  if (sname == names.init)   sname=s1.owner.name;
  return diags.create(dkind,log.currentSource(),pos,""String_Node_Str"",sname,kindName(s1),s1,s1.location(site,types),kindName(s2),s2,s2.location(site,types));
}"
12914,"@Override public boolean exists(){
  return false;
}","@Override public boolean exists(){
  return true;
}"
12915,"/** 
 * Construct the SplitIndexWriter. Uses path to this file and relative path from this file.
 * @param path       Path to the file which is getting generated.
 * @param filename   Name of the file which is getting genrated.
 * @param relpath    Relative path from this file to the current directory.
 * @param indexbuilder Unicode based Index from {@link IndexBuilder}
 */
public SplitIndexWriter(ConfigurationImpl configuration,DocPath path,IndexBuilder indexbuilder,int prev,int next) throws IOException {
  super(configuration,path,indexbuilder);
  this.prev=prev;
  this.next=next;
}","/** 
 * Construct the SplitIndexWriter. Uses path to this file and relative path from this file.
 * @param path       Path to the file which is getting generated.
 * @param indexbuilder Unicode based Index from {@link IndexBuilder}
 */
public SplitIndexWriter(ConfigurationImpl configuration,DocPath path,IndexBuilder indexbuilder,int prev,int next) throws IOException {
  super(configuration,path,indexbuilder);
  this.prev=prev;
  this.next=next;
}"
12916,"/** 
 * Constructor.
 * @param path The directory path to be created for this fileor null if none to be created.
 * @param filename File Name to which the PrintWriter willdo the Output.
 * @exception IOException Exception raised by the FileWriter is passed onto next level.
 * @exception UnsupportedEncodingException Exception raised by theOutputStreamWriter is passed on to next level.
 */
public HtmlWriter(Configuration configuration,DocPath path) throws IOException, UnsupportedEncodingException {
  writer=Util.genWriter(configuration,path);
  this.configuration=configuration;
  this.memberDetailsListPrinted=false;
  packageTableHeader=new String[]{configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str"")};
  useTableSummary=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""));
  modifierTypeHeader=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str""));
  overviewLabel=getResource(""String_Node_Str"");
  defaultPackageLabel=new RawHtml(DocletConstants.DEFAULT_PACKAGE_NAME);
  packageLabel=getResource(""String_Node_Str"");
  useLabel=getResource(""String_Node_Str"");
  prevLabel=getResource(""String_Node_Str"");
  nextLabel=getResource(""String_Node_Str"");
  prevclassLabel=getResource(""String_Node_Str"");
  nextclassLabel=getResource(""String_Node_Str"");
  summaryLabel=getResource(""String_Node_Str"");
  detailLabel=getResource(""String_Node_Str"");
  framesLabel=getResource(""String_Node_Str"");
  noframesLabel=getResource(""String_Node_Str"");
  treeLabel=getResource(""String_Node_Str"");
  classLabel=getResource(""String_Node_Str"");
  deprecatedLabel=getResource(""String_Node_Str"");
  deprecatedPhrase=getResource(""String_Node_Str"");
  allclassesLabel=getResource(""String_Node_Str"");
  indexLabel=getResource(""String_Node_Str"");
  helpLabel=getResource(""String_Node_Str"");
  seeLabel=getResource(""String_Node_Str"");
  descriptionLabel=getResource(""String_Node_Str"");
  prevpackageLabel=getResource(""String_Node_Str"");
  nextpackageLabel=getResource(""String_Node_Str"");
  packagesLabel=getResource(""String_Node_Str"");
  methodDetailsLabel=getResource(""String_Node_Str"");
  annotationTypeDetailsLabel=getResource(""String_Node_Str"");
  fieldDetailsLabel=getResource(""String_Node_Str"");
  constructorDetailsLabel=getResource(""String_Node_Str"");
  enumConstantsDetailsLabel=getResource(""String_Node_Str"");
  specifiedByLabel=getResource(""String_Node_Str"");
  overridesLabel=getResource(""String_Node_Str"");
  descfrmClassLabel=getResource(""String_Node_Str"");
  descfrmInterfaceLabel=getResource(""String_Node_Str"");
}","/** 
 * Constructor.
 * @param path The directory path to be created for this fileor null if none to be created.
 * @exception IOException Exception raised by the FileWriter is passed onto next level.
 * @exception UnsupportedEncodingException Exception raised by theOutputStreamWriter is passed on to next level.
 */
public HtmlWriter(Configuration configuration,DocPath path) throws IOException, UnsupportedEncodingException {
  writer=Util.genWriter(configuration,path);
  this.configuration=configuration;
  this.memberDetailsListPrinted=false;
  packageTableHeader=new String[]{configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str"")};
  useTableSummary=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""));
  modifierTypeHeader=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str""));
  overviewLabel=getResource(""String_Node_Str"");
  defaultPackageLabel=new RawHtml(DocletConstants.DEFAULT_PACKAGE_NAME);
  packageLabel=getResource(""String_Node_Str"");
  useLabel=getResource(""String_Node_Str"");
  prevLabel=getResource(""String_Node_Str"");
  nextLabel=getResource(""String_Node_Str"");
  prevclassLabel=getResource(""String_Node_Str"");
  nextclassLabel=getResource(""String_Node_Str"");
  summaryLabel=getResource(""String_Node_Str"");
  detailLabel=getResource(""String_Node_Str"");
  framesLabel=getResource(""String_Node_Str"");
  noframesLabel=getResource(""String_Node_Str"");
  treeLabel=getResource(""String_Node_Str"");
  classLabel=getResource(""String_Node_Str"");
  deprecatedLabel=getResource(""String_Node_Str"");
  deprecatedPhrase=getResource(""String_Node_Str"");
  allclassesLabel=getResource(""String_Node_Str"");
  indexLabel=getResource(""String_Node_Str"");
  helpLabel=getResource(""String_Node_Str"");
  seeLabel=getResource(""String_Node_Str"");
  descriptionLabel=getResource(""String_Node_Str"");
  prevpackageLabel=getResource(""String_Node_Str"");
  nextpackageLabel=getResource(""String_Node_Str"");
  packagesLabel=getResource(""String_Node_Str"");
  methodDetailsLabel=getResource(""String_Node_Str"");
  annotationTypeDetailsLabel=getResource(""String_Node_Str"");
  fieldDetailsLabel=getResource(""String_Node_Str"");
  constructorDetailsLabel=getResource(""String_Node_Str"");
  enumConstantsDetailsLabel=getResource(""String_Node_Str"");
  specifiedByLabel=getResource(""String_Node_Str"");
  overridesLabel=getResource(""String_Node_Str"");
  descfrmClassLabel=getResource(""String_Node_Str"");
  descfrmInterfaceLabel=getResource(""String_Node_Str"");
}"
12917,"/** 
 * @inheritDoc 
 */
@Override public int hashCode(){
  return path.hashCode();
}","/** 
 * {@inheritDoc} 
 */
@Override public int hashCode(){
  return path.hashCode();
}"
12918,"/** 
 * @inheritDoc 
 */
@Override public boolean equals(Object other){
  return (other instanceof DocPath) && path.equals(((DocPath)other).path);
}","/** 
 * {@inheritDoc} 
 */
@Override public boolean equals(Object other){
  return (other instanceof DocPath) && path.equals(((DocPath)other).path);
}"
12919,"/** 
 * Find the specified directory in the source path.
 * @param name Name of the directory to be searched for in the source path.
 * @return File Return the directory if found else return null.
 */
public File getDirectory(DocPath p){
  for (int i=0; i < sourcePath.length; i++) {
    File directoryNeeded=new File(sourcePath[i],p.getPath());
    if (directoryNeeded.isDirectory()) {
      return directoryNeeded;
    }
  }
  return null;
}","/** 
 * Find the specified directory in the source path.
 * @param p Name of the directory to be searched for in the source path.
 * @return File Return the directory if found else return null.
 */
public File getDirectory(DocPath p){
  for (int i=0; i < sourcePath.length; i++) {
    File directoryNeeded=new File(sourcePath[i],p.getPath());
    if (directoryNeeded.isDirectory()) {
      return directoryNeeded;
    }
  }
  return null;
}"
12920,"/** 
 * Create the directory path for the file to be generated, construct FileOutputStream and OutputStreamWriter depending upon docencoding.
 * @param path The directory path to be created for this file.
 * @param filename File Name to which the PrintWriter will do the Output.
 * @param docencoding Encoding to be used for this file.
 * @exception IOException Exception raised by the FileWriter is passed onto next level.
 * @exception UnsupportedEncodingException Exception raised by theOutputStreamWriter is passed on to next level.
 * @return Writer Writer for the file getting generated.
 * @see java.io.FileOutputStream
 * @see java.io.OutputStreamWriter
 */
public static Writer genWriter(Configuration configuration,DocPath path) throws IOException, UnsupportedEncodingException {
  File file=path.resolveAgainst(configuration.destDirName);
  createDirectory(configuration,file.getParentFile());
  FileOutputStream fos=new FileOutputStream(file);
  if (configuration.docencoding == null) {
    return new BufferedWriter(new OutputStreamWriter(fos));
  }
 else {
    return new BufferedWriter(new OutputStreamWriter(fos,configuration.docencoding));
  }
}","/** 
 * Create the directory path for the file to be generated, construct FileOutputStream and OutputStreamWriter depending upon docencoding.
 * @param path The directory path to be created for this file.
 * @exception IOException Exception raised by the FileWriter is passed onto next level.
 * @exception UnsupportedEncodingException Exception raised by theOutputStreamWriter is passed on to next level.
 * @return Writer Writer for the file getting generated.
 * @see java.io.FileOutputStream
 * @see java.io.OutputStreamWriter
 */
public static Writer genWriter(Configuration configuration,DocPath path) throws IOException, UnsupportedEncodingException {
  File file=path.resolveAgainst(configuration.destDirName);
  createDirectory(configuration,file.getParentFile());
  FileOutputStream fos=new FileOutputStream(file);
  if (configuration.docencoding == null) {
    return new BufferedWriter(new OutputStreamWriter(fos));
  }
 else {
    return new BufferedWriter(new OutputStreamWriter(fos,configuration.docencoding));
  }
}"
12921,"/** 
 * Given a path string create all the directories in the path. For example, if the path string is ""java/applet"", the method will create directory ""java"" and then ""java/applet"" if they don't exist. The file separator string ""/"" is platform dependent system property.
 * @param path Directory path string.
 */
public static void createDirectory(Configuration configuration,File dir){
  if (dir == null) {
    return;
  }
  if (dir.exists()) {
    return;
  }
 else {
    if (dir.mkdirs()) {
      return;
    }
 else {
      configuration.message.error(""String_Node_Str"",dir.getPath());
      throw new DocletAbortException();
    }
  }
}","/** 
 * Given a path string create all the directories in the path. For example, if the path string is ""java/applet"", the method will create directory ""java"" and then ""java/applet"" if they don't exist. The file separator string ""/"" is platform dependent system property.
 * @param dir Directory path string.
 */
public static void createDirectory(Configuration configuration,File dir){
  if (dir == null) {
    return;
  }
  if (dir.exists()) {
    return;
  }
 else {
    if (dir.mkdirs()) {
      return;
    }
 else {
      configuration.message.error(""String_Node_Str"",dir.getPath());
      throw new DocletAbortException();
    }
  }
}"
12922,"public Iterator<TypeSymbol> iterator(){
  return new Iterator<TypeSymbol>(){
    List<TypeSymbol> seen=List.nil();
    TypeSymbol currentSym=getSymbol(intype);
    public boolean hasNext(){
      return currentSym != null;
    }
    public TypeSymbol next(){
      TypeSymbol prevSym=currentSym;
      currentSym=getSymbol(types.supertype(currentSym.type));
      return prevSym;
    }
    public void remove(){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    TypeSymbol getSymbol(    Type intype){
      if (intype.tag != CLASS && intype.tag != TYPEVAR) {
        return null;
      }
      while (intype.tag == TYPEVAR)       intype=intype.getUpperBound();
      if (seen.contains(intype.tsym)) {
        return null;
      }
      seen=seen.prepend(intype.tsym);
      return intype.tsym;
    }
  }
;
}","public Iterator<TypeSymbol> iterator(){
  return new Iterator<TypeSymbol>(){
    List<TypeSymbol> seen=List.nil();
    TypeSymbol currentSym=symbolFor(intype);
    TypeSymbol prevSym=null;
    public boolean hasNext(){
      if (currentSym == syms.noSymbol) {
        currentSym=symbolFor(types.supertype(prevSym.type));
      }
      return currentSym != null;
    }
    public TypeSymbol next(){
      prevSym=currentSym;
      currentSym=syms.noSymbol;
      Assert.check(prevSym != null || prevSym != syms.noSymbol);
      return prevSym;
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
    TypeSymbol symbolFor(    Type t){
      if (t.tag != CLASS && t.tag != TYPEVAR) {
        return null;
      }
      while (t.tag == TYPEVAR)       t=t.getUpperBound();
      if (seen.contains(t.tsym)) {
        return null;
      }
      seen=seen.prepend(t.tsym);
      return t.tsym;
    }
  }
;
}"
12923,"public boolean hasNext(){
  return currentSym != null;
}","public boolean hasNext(){
  if (currentSym == syms.noSymbol) {
    currentSym=symbolFor(types.supertype(prevSym.type));
  }
  return currentSym != null;
}"
12924,"public TypeSymbol next(){
  TypeSymbol prevSym=currentSym;
  currentSym=getSymbol(types.supertype(currentSym.type));
  return prevSym;
}","public TypeSymbol next(){
  prevSym=currentSym;
  currentSym=syms.noSymbol;
  Assert.check(prevSym != null || prevSym != syms.noSymbol);
  return prevSym;
}"
12925,"public void remove(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","public void remove(){
  throw new UnsupportedOperationException();
}"
12926,"/** 
 * Return an Iterable object to scan the superclasses of a given type. It's crucial that the scan is done lazily, as we don't want to accidentally access more supertypes than strictly needed (as this could trigger completion errors if some of the not-needed supertypes are missing/ill-formed).
 */
Iterable<TypeSymbol> superclasses(final Type intype){
  return new Iterable<TypeSymbol>(){
    public Iterator<TypeSymbol> iterator(){
      return new Iterator<TypeSymbol>(){
        List<TypeSymbol> seen=List.nil();
        TypeSymbol currentSym=getSymbol(intype);
        public boolean hasNext(){
          return currentSym != null;
        }
        public TypeSymbol next(){
          TypeSymbol prevSym=currentSym;
          currentSym=getSymbol(types.supertype(currentSym.type));
          return prevSym;
        }
        public void remove(){
          throw new UnsupportedOperationException(""String_Node_Str"");
        }
        TypeSymbol getSymbol(        Type intype){
          if (intype.tag != CLASS && intype.tag != TYPEVAR) {
            return null;
          }
          while (intype.tag == TYPEVAR)           intype=intype.getUpperBound();
          if (seen.contains(intype.tsym)) {
            return null;
          }
          seen=seen.prepend(intype.tsym);
          return intype.tsym;
        }
      }
;
    }
  }
;
}","/** 
 * Return an Iterable object to scan the superclasses of a given type. It's crucial that the scan is done lazily, as we don't want to accidentally access more supertypes than strictly needed (as this could trigger completion errors if some of the not-needed supertypes are missing/ill-formed).
 */
Iterable<TypeSymbol> superclasses(final Type intype){
  return new Iterable<TypeSymbol>(){
    public Iterator<TypeSymbol> iterator(){
      return new Iterator<TypeSymbol>(){
        List<TypeSymbol> seen=List.nil();
        TypeSymbol currentSym=symbolFor(intype);
        TypeSymbol prevSym=null;
        public boolean hasNext(){
          if (currentSym == syms.noSymbol) {
            currentSym=symbolFor(types.supertype(prevSym.type));
          }
          return currentSym != null;
        }
        public TypeSymbol next(){
          prevSym=currentSym;
          currentSym=syms.noSymbol;
          Assert.check(prevSym != null || prevSym != syms.noSymbol);
          return prevSym;
        }
        public void remove(){
          throw new UnsupportedOperationException();
        }
        TypeSymbol symbolFor(        Type t){
          if (t.tag != CLASS && t.tag != TYPEVAR) {
            return null;
          }
          while (t.tag == TYPEVAR)           t=t.getUpperBound();
          if (seen.contains(t.tsym)) {
            return null;
          }
          seen=seen.prepend(t.tsym);
          return t.tsym;
        }
      }
;
    }
  }
;
}"
12927,"private Symbol findMethod(Env<AttrContext> env,Type site,Name name,List<Type> argtypes,List<Type> typeargtypes,Type intype,Symbol bestSoFar,boolean allowBoxing,boolean useVarargs,boolean operator){
  boolean abstractOk=true;
  List<Type> itypes=List.nil();
  for (  TypeSymbol s : superclasses(intype)) {
    bestSoFar=lookupMethod(env,site,name,argtypes,typeargtypes,s.members(),bestSoFar,allowBoxing,useVarargs,operator,true);
    abstractOk&=excludeAbstractsFilter.accepts(s);
    if (abstractOk) {
      for (      Type itype : types.interfaces(s.type)) {
        itypes=types.union(types.closure(itype),itypes);
      }
    }
    if (name == names.init)     break;
  }
  Symbol concrete=bestSoFar.kind < ERR && (bestSoFar.flags() & ABSTRACT) == 0 ? bestSoFar : methodNotFound;
  if (name != names.init) {
    for (    Type itype : itypes) {
      if (!itype.isInterface())       continue;
      bestSoFar=lookupMethod(env,site,name,argtypes,typeargtypes,itype.tsym.members(),bestSoFar,allowBoxing,useVarargs,operator,true);
      if (concrete != bestSoFar && concrete.kind < ERR && bestSoFar.kind < ERR && types.isSubSignature(concrete.type,bestSoFar.type)) {
        bestSoFar=concrete;
      }
    }
  }
  return bestSoFar;
}","private Symbol findMethod(Env<AttrContext> env,Type site,Name name,List<Type> argtypes,List<Type> typeargtypes,Type intype,Symbol bestSoFar,boolean allowBoxing,boolean useVarargs,boolean operator){
  boolean abstractOk=true;
  List<Type> itypes=List.nil();
  for (  TypeSymbol s : superclasses(intype)) {
    bestSoFar=lookupMethod(env,site,name,argtypes,typeargtypes,s.members(),bestSoFar,allowBoxing,useVarargs,operator,true);
    abstractOk&=(s.flags() & (ABSTRACT | INTERFACE | ENUM)) != 0;
    if (abstractOk) {
      for (      Type itype : types.interfaces(s.type)) {
        itypes=types.union(types.closure(itype),itypes);
      }
    }
    if (name == names.init)     break;
  }
  Symbol concrete=bestSoFar.kind < ERR && (bestSoFar.flags() & ABSTRACT) == 0 ? bestSoFar : methodNotFound;
  if (name != names.init) {
    for (    Type itype : itypes) {
      if (!itype.isInterface())       continue;
      bestSoFar=lookupMethod(env,site,name,argtypes,typeargtypes,itype.tsym.members(),bestSoFar,allowBoxing,useVarargs,operator,true);
      if (concrete != bestSoFar && concrete.kind < ERR && bestSoFar.kind < ERR && types.isSubSignature(concrete.type,bestSoFar.type)) {
        bestSoFar=concrete;
      }
    }
  }
  return bestSoFar;
}"
12928,"public boolean accepts(Name n){
  return n == names.init;
}","public boolean accepts(Name n){
  return n == n.table.names.init;
}"
12929,"public MethodHandle(int refKind,Symbol refSym,Names names){
  this.refKind=refKind;
  this.refSym=refSym;
  this.names=names;
  checkConsistent();
}","public MethodHandle(int refKind,Symbol refSym){
  this.refKind=refKind;
  this.refSym=refSym;
  checkConsistent();
}"
12930,"public Names(Context context){
  Options options=Options.instance(context);
  table=createTable(options);
  asterisk=fromString(""String_Node_Str"");
  comma=fromString(""String_Node_Str"");
  empty=fromString(""String_Node_Str"");
  hyphen=fromString(""String_Node_Str"");
  one=fromString(""String_Node_Str"");
  period=fromString(""String_Node_Str"");
  semicolon=fromString(""String_Node_Str"");
  slash=fromString(""String_Node_Str"");
  slashequals=fromString(""String_Node_Str"");
  _class=fromString(""String_Node_Str"");
  _default=fromString(""String_Node_Str"");
  _super=fromString(""String_Node_Str"");
  _this=fromString(""String_Node_Str"");
  _name=fromString(""String_Node_Str"");
  addSuppressed=fromString(""String_Node_Str"");
  any=fromString(""String_Node_Str"");
  append=fromString(""String_Node_Str"");
  clinit=fromString(""String_Node_Str"");
  clone=fromString(""String_Node_Str"");
  close=fromString(""String_Node_Str"");
  compareTo=fromString(""String_Node_Str"");
  desiredAssertionStatus=fromString(""String_Node_Str"");
  equals=fromString(""String_Node_Str"");
  error=fromString(""String_Node_Str"");
  family=fromString(""String_Node_Str"");
  finalize=fromString(""String_Node_Str"");
  forName=fromString(""String_Node_Str"");
  getClass=fromString(""String_Node_Str"");
  getClassLoader=fromString(""String_Node_Str"");
  getComponentType=fromString(""String_Node_Str"");
  getDeclaringClass=fromString(""String_Node_Str"");
  getMessage=fromString(""String_Node_Str"");
  hasNext=fromString(""String_Node_Str"");
  hashCode=fromString(""String_Node_Str"");
  init=fromString(""String_Node_Str"");
  initCause=fromString(""String_Node_Str"");
  iterator=fromString(""String_Node_Str"");
  length=fromString(""String_Node_Str"");
  next=fromString(""String_Node_Str"");
  ordinal=fromString(""String_Node_Str"");
  serialVersionUID=fromString(""String_Node_Str"");
  toString=fromString(""String_Node_Str"");
  value=fromString(""String_Node_Str"");
  valueOf=fromString(""String_Node_Str"");
  values=fromString(""String_Node_Str"");
  java_io_Serializable=fromString(""String_Node_Str"");
  java_lang_AutoCloseable=fromString(""String_Node_Str"");
  java_lang_Class=fromString(""String_Node_Str"");
  java_lang_Cloneable=fromString(""String_Node_Str"");
  java_lang_Enum=fromString(""String_Node_Str"");
  java_lang_Object=fromString(""String_Node_Str"");
  java_lang_invoke_MethodHandle=fromString(""String_Node_Str"");
  Array=fromString(""String_Node_Str"");
  Bound=fromString(""String_Node_Str"");
  Method=fromString(""String_Node_Str"");
  java_lang=fromString(""String_Node_Str"");
  Annotation=fromString(""String_Node_Str"");
  AnnotationDefault=fromString(""String_Node_Str"");
  Bridge=fromString(""String_Node_Str"");
  CharacterRangeTable=fromString(""String_Node_Str"");
  Code=fromString(""String_Node_Str"");
  CompilationID=fromString(""String_Node_Str"");
  ConstantValue=fromString(""String_Node_Str"");
  Deprecated=fromString(""String_Node_Str"");
  EnclosingMethod=fromString(""String_Node_Str"");
  Enum=fromString(""String_Node_Str"");
  Exceptions=fromString(""String_Node_Str"");
  InnerClasses=fromString(""String_Node_Str"");
  LineNumberTable=fromString(""String_Node_Str"");
  LocalVariableTable=fromString(""String_Node_Str"");
  LocalVariableTypeTable=fromString(""String_Node_Str"");
  RuntimeInvisibleAnnotations=fromString(""String_Node_Str"");
  RuntimeInvisibleParameterAnnotations=fromString(""String_Node_Str"");
  RuntimeInvisibleTypeAnnotations=fromString(""String_Node_Str"");
  RuntimeVisibleAnnotations=fromString(""String_Node_Str"");
  RuntimeVisibleParameterAnnotations=fromString(""String_Node_Str"");
  RuntimeVisibleTypeAnnotations=fromString(""String_Node_Str"");
  Signature=fromString(""String_Node_Str"");
  SourceFile=fromString(""String_Node_Str"");
  SourceID=fromString(""String_Node_Str"");
  StackMap=fromString(""String_Node_Str"");
  StackMapTable=fromString(""String_Node_Str"");
  Synthetic=fromString(""String_Node_Str"");
  Value=fromString(""String_Node_Str"");
  Varargs=fromString(""String_Node_Str"");
  ANNOTATION_TYPE=fromString(""String_Node_Str"");
  CONSTRUCTOR=fromString(""String_Node_Str"");
  FIELD=fromString(""String_Node_Str"");
  LOCAL_VARIABLE=fromString(""String_Node_Str"");
  METHOD=fromString(""String_Node_Str"");
  PACKAGE=fromString(""String_Node_Str"");
  PARAMETER=fromString(""String_Node_Str"");
  TYPE=fromString(""String_Node_Str"");
  TYPE_PARAMETER=fromString(""String_Node_Str"");
  TYPE_USE=fromString(""String_Node_Str"");
  CLASS=fromString(""String_Node_Str"");
  RUNTIME=fromString(""String_Node_Str"");
  SOURCE=fromString(""String_Node_Str"");
  T=fromString(""String_Node_Str"");
  deprecated=fromString(""String_Node_Str"");
  ex=fromString(""String_Node_Str"");
  package_info=fromString(""String_Node_Str"");
  BootstrapMethods=fromString(""String_Node_Str"");
}","public Names(Context context){
  Options options=Options.instance(context);
  table=createTable(options);
  asterisk=fromString(""String_Node_Str"");
  comma=fromString(""String_Node_Str"");
  empty=fromString(""String_Node_Str"");
  hyphen=fromString(""String_Node_Str"");
  one=fromString(""String_Node_Str"");
  period=fromString(""String_Node_Str"");
  semicolon=fromString(""String_Node_Str"");
  slash=fromString(""String_Node_Str"");
  slashequals=fromString(""String_Node_Str"");
  _class=fromString(""String_Node_Str"");
  _default=fromString(""String_Node_Str"");
  _super=fromString(""String_Node_Str"");
  _this=fromString(""String_Node_Str"");
  _name=fromString(""String_Node_Str"");
  addSuppressed=fromString(""String_Node_Str"");
  any=fromString(""String_Node_Str"");
  append=fromString(""String_Node_Str"");
  clinit=fromString(""String_Node_Str"");
  clone=fromString(""String_Node_Str"");
  close=fromString(""String_Node_Str"");
  compareTo=fromString(""String_Node_Str"");
  desiredAssertionStatus=fromString(""String_Node_Str"");
  equals=fromString(""String_Node_Str"");
  error=fromString(""String_Node_Str"");
  family=fromString(""String_Node_Str"");
  finalize=fromString(""String_Node_Str"");
  forName=fromString(""String_Node_Str"");
  getClass=fromString(""String_Node_Str"");
  getClassLoader=fromString(""String_Node_Str"");
  getComponentType=fromString(""String_Node_Str"");
  getDeclaringClass=fromString(""String_Node_Str"");
  getMessage=fromString(""String_Node_Str"");
  hasNext=fromString(""String_Node_Str"");
  hashCode=fromString(""String_Node_Str"");
  init=fromString(""String_Node_Str"");
  initCause=fromString(""String_Node_Str"");
  iterator=fromString(""String_Node_Str"");
  length=fromString(""String_Node_Str"");
  next=fromString(""String_Node_Str"");
  ordinal=fromString(""String_Node_Str"");
  serialVersionUID=fromString(""String_Node_Str"");
  toString=fromString(""String_Node_Str"");
  value=fromString(""String_Node_Str"");
  valueOf=fromString(""String_Node_Str"");
  values=fromString(""String_Node_Str"");
  java_io_Serializable=fromString(""String_Node_Str"");
  java_lang_AutoCloseable=fromString(""String_Node_Str"");
  java_lang_Class=fromString(""String_Node_Str"");
  java_lang_Cloneable=fromString(""String_Node_Str"");
  java_lang_Enum=fromString(""String_Node_Str"");
  java_lang_Object=fromString(""String_Node_Str"");
  java_lang_invoke_MethodHandle=fromString(""String_Node_Str"");
  Array=fromString(""String_Node_Str"");
  Bound=fromString(""String_Node_Str"");
  Method=fromString(""String_Node_Str"");
  java_lang=fromString(""String_Node_Str"");
  Annotation=fromString(""String_Node_Str"");
  AnnotationDefault=fromString(""String_Node_Str"");
  BootstrapMethods=fromString(""String_Node_Str"");
  Bridge=fromString(""String_Node_Str"");
  CharacterRangeTable=fromString(""String_Node_Str"");
  Code=fromString(""String_Node_Str"");
  CompilationID=fromString(""String_Node_Str"");
  ConstantValue=fromString(""String_Node_Str"");
  Deprecated=fromString(""String_Node_Str"");
  EnclosingMethod=fromString(""String_Node_Str"");
  Enum=fromString(""String_Node_Str"");
  Exceptions=fromString(""String_Node_Str"");
  InnerClasses=fromString(""String_Node_Str"");
  LineNumberTable=fromString(""String_Node_Str"");
  LocalVariableTable=fromString(""String_Node_Str"");
  LocalVariableTypeTable=fromString(""String_Node_Str"");
  RuntimeInvisibleAnnotations=fromString(""String_Node_Str"");
  RuntimeInvisibleParameterAnnotations=fromString(""String_Node_Str"");
  RuntimeInvisibleTypeAnnotations=fromString(""String_Node_Str"");
  RuntimeVisibleAnnotations=fromString(""String_Node_Str"");
  RuntimeVisibleParameterAnnotations=fromString(""String_Node_Str"");
  RuntimeVisibleTypeAnnotations=fromString(""String_Node_Str"");
  Signature=fromString(""String_Node_Str"");
  SourceFile=fromString(""String_Node_Str"");
  SourceID=fromString(""String_Node_Str"");
  StackMap=fromString(""String_Node_Str"");
  StackMapTable=fromString(""String_Node_Str"");
  Synthetic=fromString(""String_Node_Str"");
  Value=fromString(""String_Node_Str"");
  Varargs=fromString(""String_Node_Str"");
  ANNOTATION_TYPE=fromString(""String_Node_Str"");
  CONSTRUCTOR=fromString(""String_Node_Str"");
  FIELD=fromString(""String_Node_Str"");
  LOCAL_VARIABLE=fromString(""String_Node_Str"");
  METHOD=fromString(""String_Node_Str"");
  PACKAGE=fromString(""String_Node_Str"");
  PARAMETER=fromString(""String_Node_Str"");
  TYPE=fromString(""String_Node_Str"");
  TYPE_PARAMETER=fromString(""String_Node_Str"");
  TYPE_USE=fromString(""String_Node_Str"");
  CLASS=fromString(""String_Node_Str"");
  RUNTIME=fromString(""String_Node_Str"");
  SOURCE=fromString(""String_Node_Str"");
  T=fromString(""String_Node_Str"");
  deprecated=fromString(""String_Node_Str"");
  ex=fromString(""String_Node_Str"");
  package_info=fromString(""String_Node_Str"");
}"
12931,"/** 
 * Return the kind of this tag. similar or synonymous tags.  For most tags, <code>kind()&nbsp;==&nbsp;name()</code>; the following table lists those cases where there is more than one tag of a given kind: <p> <table border=""1"" cellpadding=""4"" cellspacing=""0""> <tr><th><tt> kind()  </th>  <th><tt> name()      </th></tr> <tr><td><tt> @throws </td>  <td><tt> @throws     </td></tr> <tr><td><tt> @throws </td>  <td><tt> @exception  </td></tr> <tr><td><tt> @see    </td>  <td><tt> @see        </td></tr> <tr><td><tt> @see    </td>  <td><tt> @link       </td></tr> <tr><td><tt> @see    </td>  <td><tt> @linkplain  </td></tr> <tr><td><tt> @serial </td>  <td><tt> @serial     </td></tr> <tr><td><tt> @serial </td>  <td><tt> @serialData </td></tr> </table>
 */
String kind();","/** 
 * Return the kind of this tag. similar or synonymous tags.  For most tags, <code>kind()&nbsp;==&nbsp;name()</code>; the following table lists those cases where there is more than one tag of a given kind: <p> <table border=""1"" cellpadding=""4"" cellspacing=""0""> <tr><th><tt> kind()  </tt></th>  <th><tt> name()      </tt></th></tr> <tr><td><tt> @throws </tt></td>  <td><tt> @throws     </tt></td></tr> <tr><td><tt> @throws </tt></td>  <td><tt> @exception  </tt></td></tr> <tr><td><tt> @see    </tt></td>  <td><tt> @see        </tt></td></tr> <tr><td><tt> @see    </tt></td>  <td><tt> @link       </tt></td></tr> <tr><td><tt> @see    </tt></td>  <td><tt> @linkplain  </tt></td></tr> <tr><td><tt> @serial </tt></td>  <td><tt> @serial     </tt></td></tr> <tr><td><tt> @serial </tt></td>  <td><tt> @serialData </tt></td></tr> </table>
 */
String kind();"
12932,"/** 
 * Get the ClassFile object for a specified class.
 * @param className the name of the class to be returned.
 * @return the ClassFile for the given class
 * @throws Dependencies #ClassFileNotFoundException if the classfile cannot be found
 */
public ClassFile getClassFile(String className) throws ClassFileNotFoundException ;","/** 
 * Get the ClassFile object for a specified class.
 * @param className the name of the class to be returned.
 * @return the ClassFile for the given class
 * @throws Dependencies.ClassFileNotFoundException if the classfile cannot befound
 */
public ClassFile getClassFile(String className) throws ClassFileNotFoundException ;"
12933,"/** 
 * See   {@link Kind#LOCAL_UBYTE}. 
 */
R visitLocalAndValue(Instruction instr,int index,int value,P p);","/** 
 * See   {@link Kind#LOCAL_BYTE}. 
 */
R visitLocalAndValue(Instruction instr,int index,int value,P p);"
12934,"/** 
 * Add all the parameters for the executable member.
 * @param member the member to write parameters for.
 * @param includeAnnotations true if annotation information needs to be added.
 * @param tree the content tree to which the parameters information will be added.
 */
protected void addParameters(ExecutableMemberDoc member,boolean includeAnnotations,Content htmltree){
  htmltree.addContent(""String_Node_Str"");
  Parameter[] params=member.parameters();
  String indent=makeSpace(writer.displayLength);
  if (configuration().linksource) {
    indent+=makeSpace(member.name().length());
  }
  int paramstart;
  for (paramstart=0; paramstart < params.length; paramstart++) {
    Parameter param=params[paramstart];
    if (!param.name().startsWith(""String_Node_Str"")) {
      if (includeAnnotations) {
        boolean foundAnnotations=writer.addAnnotationInfo(indent.length(),member,param,htmltree);
        if (foundAnnotations) {
          htmltree.addContent(DocletConstants.NL);
          htmltree.addContent(indent);
        }
      }
      addParam(member,param,(paramstart == params.length - 1) && member.isVarArgs(),htmltree);
      break;
    }
  }
  for (int i=paramstart + 1; i < params.length; i++) {
    htmltree.addContent(""String_Node_Str"");
    htmltree.addContent(DocletConstants.NL);
    htmltree.addContent(indent);
    if (includeAnnotations) {
      boolean foundAnnotations=writer.addAnnotationInfo(indent.length(),member,params[i],htmltree);
      if (foundAnnotations) {
        htmltree.addContent(DocletConstants.NL);
        htmltree.addContent(indent);
      }
    }
    addParam(member,params[i],(i == params.length - 1) && member.isVarArgs(),htmltree);
  }
  htmltree.addContent(""String_Node_Str"");
}","/** 
 * Add all the parameters for the executable member.
 * @param member the member to write parameters for.
 * @param includeAnnotations true if annotation information needs to be added.
 * @param htmltree the content tree to which the parameters information will be added.
 */
protected void addParameters(ExecutableMemberDoc member,boolean includeAnnotations,Content htmltree){
  htmltree.addContent(""String_Node_Str"");
  Parameter[] params=member.parameters();
  String indent=makeSpace(writer.displayLength);
  if (configuration().linksource) {
    indent+=makeSpace(member.name().length());
  }
  int paramstart;
  for (paramstart=0; paramstart < params.length; paramstart++) {
    Parameter param=params[paramstart];
    if (!param.name().startsWith(""String_Node_Str"")) {
      if (includeAnnotations) {
        boolean foundAnnotations=writer.addAnnotationInfo(indent.length(),member,param,htmltree);
        if (foundAnnotations) {
          htmltree.addContent(DocletConstants.NL);
          htmltree.addContent(indent);
        }
      }
      addParam(member,param,(paramstart == params.length - 1) && member.isVarArgs(),htmltree);
      break;
    }
  }
  for (int i=paramstart + 1; i < params.length; i++) {
    htmltree.addContent(""String_Node_Str"");
    htmltree.addContent(DocletConstants.NL);
    htmltree.addContent(indent);
    if (includeAnnotations) {
      boolean foundAnnotations=writer.addAnnotationInfo(indent.length(),member,params[i],htmltree);
      if (foundAnnotations) {
        htmltree.addContent(DocletConstants.NL);
        htmltree.addContent(indent);
      }
    }
    addParam(member,params[i],(i == params.length - 1) && member.isVarArgs(),htmltree);
  }
  htmltree.addContent(""String_Node_Str"");
}"
12935,"/** 
 * Add the inherited summary link for the member.
 * @param classDoc the classDoc that we should link to
 * @param member the member being linked to
 * @param linksTree the content tree to which the link will be added
 */
protected void addInheritedSummaryLink(ClassDoc cd,ProgramElementDoc member,Content linksTree){
  linksTree.addContent(new RawHtml(writer.getDocLink(LinkInfoImpl.CONTEXT_MEMBER,cd,(MemberDoc)member,member.name(),false)));
}","/** 
 * Add the inherited summary link for the member.
 * @param cd the classDoc that we should link to
 * @param member the member being linked to
 * @param linksTree the content tree to which the link will be added
 */
protected void addInheritedSummaryLink(ClassDoc cd,ProgramElementDoc member,Content linksTree){
  linksTree.addContent(new RawHtml(writer.getDocLink(LinkInfoImpl.CONTEXT_MEMBER,cd,(MemberDoc)member,member.name(),false)));
}"
12936,"/** 
 * Add the summary link for the member.
 * @param context the id of the context where the link will be printed
 * @param classDoc the classDoc that we should link to
 * @param member the member being linked to
 * @param tdSummary the content tree to which the link will be added
 */
protected void addSummaryLink(int context,ClassDoc cd,ProgramElementDoc member,Content tdSummary){
  ExecutableMemberDoc emd=(ExecutableMemberDoc)member;
  String name=emd.name();
  Content strong=HtmlTree.STRONG(new RawHtml(writer.getDocLink(context,cd,(MemberDoc)emd,name,false)));
  Content code=HtmlTree.CODE(strong);
  writer.displayLength=name.length();
  addParameters(emd,false,code);
  tdSummary.addContent(code);
}","/** 
 * Add the summary link for the member.
 * @param context the id of the context where the link will be printed
 * @param cd the classDoc that we should link to
 * @param member the member being linked to
 * @param tdSummary the content tree to which the link will be added
 */
protected void addSummaryLink(int context,ClassDoc cd,ProgramElementDoc member,Content tdSummary){
  ExecutableMemberDoc emd=(ExecutableMemberDoc)member;
  String name=emd.name();
  Content strong=HtmlTree.STRONG(new RawHtml(writer.getDocLink(context,cd,(MemberDoc)emd,name,false)));
  Content code=HtmlTree.CODE(strong);
  writer.displayLength=name.length();
  addParameters(emd,false,code);
  tdSummary.addContent(code);
}"
12937,"/** 
 * Add the comment for the given member.
 * @param member the member being documented.
 * @param contentTree the content tree to which the comment will be added.
 */
protected void addComment(ProgramElementDoc member,Content htmltree){
  if (member.inlineTags().length > 0) {
    writer.addInlineComment(member,htmltree);
  }
}","/** 
 * Add the comment for the given member.
 * @param member the member being documented.
 * @param htmltree the content tree to which the comment will be added.
 */
protected void addComment(ProgramElementDoc member,Content htmltree){
  if (member.inlineTags().length > 0) {
    writer.addInlineComment(member,htmltree);
  }
}"
12938,"/** 
 * Constructor. Initialises resource for the  {@link com.sun.tools.doclets.MessageRetriever}.
 */
private ConfigurationImpl(){
  standardmessage=new MessageRetriever(this,""String_Node_Str"");
}","/** 
 * Constructor. Initializes resource for the  {@link com.sun.tools.doclets.internal.toolkit.util.MessageRetriever MessageRetriever}.
 */
private ConfigurationImpl(){
  standardmessage=new MessageRetriever(this,""String_Node_Str"");
}"
12939,"/** 
 * Add the anchor.
 * @param builder the deprecated list builder
 * @param type the type of list being documented
 * @param contentTree the content tree to which the anchor will be added
 */
private void addAnchor(DeprecatedAPIListBuilder builder,int type,Content htmlTree){
  if (builder.hasDocumentation(type)) {
    htmlTree.addContent(getMarkerAnchor(ANCHORS[type]));
  }
}","/** 
 * Add the anchor.
 * @param builder the deprecated list builder
 * @param type the type of list being documented
 * @param htmlTree the content tree to which the anchor will be added
 */
private void addAnchor(DeprecatedAPIListBuilder builder,int type,Content htmlTree){
  if (builder.hasDocumentation(type)) {
    htmlTree.addContent(getMarkerAnchor(ANCHORS[type]));
  }
}"
12940,"/** 
 * Returns a package name label.
 * @param parsedName the package name
 * @return the package name content
 */
public Content getPackageLabel(String packageName){
  return new StringContent(packageName);
}","/** 
 * Returns a package name label.
 * @param packageName the package name
 * @return the package name content
 */
public Content getPackageLabel(String packageName){
  return new StringContent(packageName);
}"
12941,"/** 
 * Add the member header.
 * @param fieldsType the class document to be listed
 * @param fieldTypeStr the string for the filed type to be documented
 * @param fieldDimensions the dimensions of the field string to be added
 * @param firldName name of the field to be added
 * @param contentTree the content tree to which the member header will be added
 */
public void addMemberHeader(ClassDoc fieldType,String fieldTypeStr,String fieldDimensions,String fieldName,Content contentTree){
  Content nameContent=new RawHtml(fieldName);
  Content heading=HtmlTree.HEADING(HtmlConstants.MEMBER_HEADING,nameContent);
  contentTree.addContent(heading);
  Content pre=new HtmlTree(HtmlTag.PRE);
  if (fieldType == null) {
    pre.addContent(fieldTypeStr);
  }
 else {
    Content fieldContent=new RawHtml(writer.getLink(new LinkInfoImpl(LinkInfoImpl.CONTEXT_SERIAL_MEMBER,fieldType)));
    pre.addContent(fieldContent);
  }
  pre.addContent(fieldDimensions + ""String_Node_Str"");
  pre.addContent(fieldName);
  contentTree.addContent(pre);
}","/** 
 * Add the member header.
 * @param fieldType the class document to be listed
 * @param fieldTypeStr the string for the field type to be documented
 * @param fieldDimensions the dimensions of the field string to be added
 * @param fieldName name of the field to be added
 * @param contentTree the content tree to which the member header will be added
 */
public void addMemberHeader(ClassDoc fieldType,String fieldTypeStr,String fieldDimensions,String fieldName,Content contentTree){
  Content nameContent=new RawHtml(fieldName);
  Content heading=HtmlTree.HEADING(HtmlConstants.MEMBER_HEADING,nameContent);
  contentTree.addContent(heading);
  Content pre=new HtmlTree(HtmlTag.PRE);
  if (fieldType == null) {
    pre.addContent(fieldTypeStr);
  }
 else {
    Content fieldContent=new RawHtml(writer.getLink(new LinkInfoImpl(LinkInfoImpl.CONTEXT_SERIAL_MEMBER,fieldType)));
    pre.addContent(fieldContent);
  }
  pre.addContent(fieldDimensions + ""String_Node_Str"");
  pre.addContent(fieldName);
  contentTree.addContent(pre);
}"
12942,"/** 
 * Return path to the given file name in the given package. So if the name passed is ""Object.html"" and the name of the package is ""java.lang"", and if the relative path is ""../.."" then returned string will be ""../../java/lang/Object.html""
 * @param linkInfo the information about the link.
 * @param fileName the file name, to which path string is.
 */
private String pathString(LinkInfoImpl linkInfo){
  if (linkInfo.context == LinkInfoImpl.PACKAGE_FRAME) {
    return linkInfo.classDoc.name() + ""String_Node_Str"";
  }
  StringBuffer buf=new StringBuffer(m_writer.relativePath);
  buf.append(DirectoryManager.getPathToPackage(linkInfo.classDoc.containingPackage(),linkInfo.classDoc.name() + ""String_Node_Str""));
  return buf.toString();
}","/** 
 * Return path to the given file name in the given package. So if the name passed is ""Object.html"" and the name of the package is ""java.lang"", and if the relative path is ""../.."" then returned string will be ""../../java/lang/Object.html""
 * @param linkInfo the information about the link.
 */
private String pathString(LinkInfoImpl linkInfo){
  if (linkInfo.context == LinkInfoImpl.PACKAGE_FRAME) {
    return linkInfo.classDoc.name() + ""String_Node_Str"";
  }
  StringBuffer buf=new StringBuffer(m_writer.relativePath);
  buf.append(DirectoryManager.getPathToPackage(linkInfo.classDoc.containingPackage(),linkInfo.classDoc.name() + ""String_Node_Str""));
  return buf.toString();
}"
12943,"/** 
 * Adds the lower navigation bar and the bottom text (from the -bottom option) at the bottom of page.
 * @param the documentation tree to which the navigation bar footer will be added
 */
protected void addNavigationBarFooter(Content body){
  addNavLinks(false,body);
  addBottom(body);
}","/** 
 * Adds the lower navigation bar and the bottom text (from the -bottom option) at the bottom of page.
 * @param body the documentation tree to which the navigation bar footer will be added
 */
protected void addNavigationBarFooter(Content body){
  addNavLinks(false,body);
  addBottom(body);
}"
12944,"/** 
 * Constructor.
 * @param path The directory path to be created for this fileor null if none to be created.
 * @param filename File Name to which the PrintWriter willdo the Output.
 * @param docencoding Encoding to be used for this file.
 * @exception IOException Exception raised by the FileWriter is passed onto next level.
 * @exception UnSupportedEncodingException Exception raised by theOutputStreamWriter is passed on to next level.
 */
public HtmlWriter(Configuration configuration,String path,String filename,String docencoding) throws IOException, UnsupportedEncodingException {
  super(Util.genWriter(configuration,path,filename,docencoding));
  this.configuration=configuration;
  htmlFilename=filename;
  this.memberDetailsListPrinted=false;
  packageTableHeader=new String[]{configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str"")};
  useTableSummary=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""));
  modifierTypeHeader=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str""));
  overviewLabel=getResource(""String_Node_Str"");
  defaultPackageLabel=new RawHtml(DocletConstants.DEFAULT_PACKAGE_NAME);
  packageLabel=getResource(""String_Node_Str"");
  useLabel=getResource(""String_Node_Str"");
  prevLabel=getResource(""String_Node_Str"");
  nextLabel=getResource(""String_Node_Str"");
  prevclassLabel=getResource(""String_Node_Str"");
  nextclassLabel=getResource(""String_Node_Str"");
  summaryLabel=getResource(""String_Node_Str"");
  detailLabel=getResource(""String_Node_Str"");
  framesLabel=getResource(""String_Node_Str"");
  noframesLabel=getResource(""String_Node_Str"");
  treeLabel=getResource(""String_Node_Str"");
  classLabel=getResource(""String_Node_Str"");
  deprecatedLabel=getResource(""String_Node_Str"");
  deprecatedPhrase=getResource(""String_Node_Str"");
  allclassesLabel=getResource(""String_Node_Str"");
  indexLabel=getResource(""String_Node_Str"");
  helpLabel=getResource(""String_Node_Str"");
  seeLabel=getResource(""String_Node_Str"");
  descriptionLabel=getResource(""String_Node_Str"");
  prevpackageLabel=getResource(""String_Node_Str"");
  nextpackageLabel=getResource(""String_Node_Str"");
  packagesLabel=getResource(""String_Node_Str"");
  methodDetailsLabel=getResource(""String_Node_Str"");
  annotationTypeDetailsLabel=getResource(""String_Node_Str"");
  fieldDetailsLabel=getResource(""String_Node_Str"");
  constructorDetailsLabel=getResource(""String_Node_Str"");
  enumConstantsDetailsLabel=getResource(""String_Node_Str"");
  specifiedByLabel=getResource(""String_Node_Str"");
  overridesLabel=getResource(""String_Node_Str"");
  descfrmClassLabel=getResource(""String_Node_Str"");
  descfrmInterfaceLabel=getResource(""String_Node_Str"");
}","/** 
 * Constructor.
 * @param path The directory path to be created for this fileor null if none to be created.
 * @param filename File Name to which the PrintWriter willdo the Output.
 * @param docencoding Encoding to be used for this file.
 * @exception IOException Exception raised by the FileWriter is passed onto next level.
 * @exception UnsupportedEncodingException Exception raised by theOutputStreamWriter is passed on to next level.
 */
public HtmlWriter(Configuration configuration,String path,String filename,String docencoding) throws IOException, UnsupportedEncodingException {
  super(Util.genWriter(configuration,path,filename,docencoding));
  this.configuration=configuration;
  htmlFilename=filename;
  this.memberDetailsListPrinted=false;
  packageTableHeader=new String[]{configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str"")};
  useTableSummary=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""));
  modifierTypeHeader=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str""));
  overviewLabel=getResource(""String_Node_Str"");
  defaultPackageLabel=new RawHtml(DocletConstants.DEFAULT_PACKAGE_NAME);
  packageLabel=getResource(""String_Node_Str"");
  useLabel=getResource(""String_Node_Str"");
  prevLabel=getResource(""String_Node_Str"");
  nextLabel=getResource(""String_Node_Str"");
  prevclassLabel=getResource(""String_Node_Str"");
  nextclassLabel=getResource(""String_Node_Str"");
  summaryLabel=getResource(""String_Node_Str"");
  detailLabel=getResource(""String_Node_Str"");
  framesLabel=getResource(""String_Node_Str"");
  noframesLabel=getResource(""String_Node_Str"");
  treeLabel=getResource(""String_Node_Str"");
  classLabel=getResource(""String_Node_Str"");
  deprecatedLabel=getResource(""String_Node_Str"");
  deprecatedPhrase=getResource(""String_Node_Str"");
  allclassesLabel=getResource(""String_Node_Str"");
  indexLabel=getResource(""String_Node_Str"");
  helpLabel=getResource(""String_Node_Str"");
  seeLabel=getResource(""String_Node_Str"");
  descriptionLabel=getResource(""String_Node_Str"");
  prevpackageLabel=getResource(""String_Node_Str"");
  nextpackageLabel=getResource(""String_Node_Str"");
  packagesLabel=getResource(""String_Node_Str"");
  methodDetailsLabel=getResource(""String_Node_Str"");
  annotationTypeDetailsLabel=getResource(""String_Node_Str"");
  fieldDetailsLabel=getResource(""String_Node_Str"");
  constructorDetailsLabel=getResource(""String_Node_Str"");
  enumConstantsDetailsLabel=getResource(""String_Node_Str"");
  specifiedByLabel=getResource(""String_Node_Str"");
  overridesLabel=getResource(""String_Node_Str"");
  descfrmClassLabel=getResource(""String_Node_Str"");
  descfrmInterfaceLabel=getResource(""String_Node_Str"");
}"
12945,"/** 
 * Get the enum constants documentation tree header.
 * @param enumConstant the enum constant being documented
 * @param enumConstantDetailsTree the content tree representing enum constant details
 * @return content tree for the enum constant documentation header
 */
public Content getEnumConstantsTreeHeader(FieldDoc enumConstant,Content enumConstantsDetailsTree);","/** 
 * Get the enum constants documentation tree header.
 * @param enumConstant the enum constant being documented
 * @param enumConstantsDetailsTree the content tree representing enum constant details
 * @return content tree for the enum constant documentation header
 */
public Content getEnumConstantsTreeHeader(FieldDoc enumConstant,Content enumConstantsDetailsTree);"
12946,"/** 
 * Return the list of visible constant fields for the given classdoc.
 * @param cd the classdoc to examine.
 * @return the list of visible constant fields for the given classdoc.
 */
protected List<FieldDoc> members(){
  List<ProgramElementDoc> l=visibleMemberMapFields.getLeafClassMembers(configuration);
  l.addAll(visibleMemberMapEnumConst.getLeafClassMembers(configuration));
  Iterator<ProgramElementDoc> iter;
  if (l != null) {
    iter=l.iterator();
  }
 else {
    return null;
  }
  List<FieldDoc> inclList=new LinkedList<FieldDoc>();
  FieldDoc member;
  while (iter.hasNext()) {
    member=(FieldDoc)iter.next();
    if (member.constantValue() != null) {
      inclList.add(member);
    }
  }
  return inclList;
}","/** 
 * Return the list of visible constant fields for the given classdoc.
 * @return the list of visible constant fields for the given classdoc.
 */
protected List<FieldDoc> members(){
  List<ProgramElementDoc> l=visibleMemberMapFields.getLeafClassMembers(configuration);
  l.addAll(visibleMemberMapEnumConst.getLeafClassMembers(configuration));
  Iterator<ProgramElementDoc> iter;
  if (l != null) {
    iter=l.iterator();
  }
 else {
    return null;
  }
  List<FieldDoc> inclList=new LinkedList<FieldDoc>();
  FieldDoc member;
  while (iter.hasNext()) {
    member=(FieldDoc)iter.next();
    if (member.constantValue() != null) {
      inclList.add(member);
    }
  }
  return inclList;
}"
12947,"/** 
 * Returns a list of methods that will be documented for the given class. This information can be used for doclet specific documentation generation.
 * @param classDoc the {@link ClassDoc} we want to check.
 * @param type the type of members to return.
 * @return a list of methods that will be documented.
 * @see VisibleMemberMap
 */
public List<ProgramElementDoc> members(int type){
  return visibleMemberMaps[type].getLeafClassMembers(configuration);
}","/** 
 * Returns a list of methods that will be documented for the given class. This information can be used for doclet specific documentation generation.
 * @param type the type of members to return.
 * @return a list of methods that will be documented.
 * @see VisibleMemberMap
 */
public List<ProgramElementDoc> members(int type){
  return visibleMemberMaps[type].getLeafClassMembers(configuration);
}"
12948,"/** 
 * Given an array of <code>Tag</code>s representing this custom tag, return its string representation.  Print a warning for param tags that do not map to parameters.  Print a warning for param tags that are duplicated.
 * @param paramTags the array of <code>ParamTag</code>s to convert.
 * @param writer the TagletWriter that will write this tag.
 * @param alreadyDocumented the set of exceptions that have alreadybeen documented.
 * @param rankMap a {@link java.util.Map} which holds orderinginformation about the parameters.
 * @param nameMap a {@link java.util.Map} which holds a mappingof a rank of a parameter to its name.  This is used to ensure that the right name is used when parameter documentation is inherited.
 * @return the TagletOutput representation of this <code>Tag</code>.
 */
private TagletOutput processParamTags(boolean isNonTypeParams,ParamTag[] paramTags,Map<String,String> rankMap,TagletWriter writer,Set<String> alreadyDocumented){
  TagletOutput result=writer.getOutputInstance();
  if (paramTags.length > 0) {
    for (int i=0; i < paramTags.length; ++i) {
      ParamTag pt=paramTags[i];
      String paramName=isNonTypeParams ? pt.parameterName() : ""String_Node_Str"" + pt.parameterName() + ""String_Node_Str"";
      if (!rankMap.containsKey(pt.parameterName())) {
        writer.getMsgRetriever().warning(pt.position(),isNonTypeParams ? ""String_Node_Str"" : ""String_Node_Str"",paramName);
      }
      String rank=rankMap.get(pt.parameterName());
      if (rank != null && alreadyDocumented.contains(rank)) {
        writer.getMsgRetriever().warning(pt.position(),isNonTypeParams ? ""String_Node_Str"" : ""String_Node_Str"",paramName);
      }
      result.appendOutput(processParamTag(isNonTypeParams,writer,pt,pt.parameterName(),alreadyDocumented.size() == 0));
      alreadyDocumented.add(rank);
    }
  }
  return result;
}","/** 
 * Given an array of <code>Tag</code>s representing this custom tag, return its string representation.  Print a warning for param tags that do not map to parameters.  Print a warning for param tags that are duplicated.
 * @param paramTags the array of <code>ParamTag</code>s to convert.
 * @param writer the TagletWriter that will write this tag.
 * @param alreadyDocumented the set of exceptions that have alreadybeen documented.
 * @param rankMap a {@link java.util.Map} which holds orderinginformation about the parameters.
 * @param rankMap a {@link java.util.Map} which holds a mappingof a rank of a parameter to its name.  This is used to ensure that the right name is used when parameter documentation is inherited.
 * @return the TagletOutput representation of this <code>Tag</code>.
 */
private TagletOutput processParamTags(boolean isNonTypeParams,ParamTag[] paramTags,Map<String,String> rankMap,TagletWriter writer,Set<String> alreadyDocumented){
  TagletOutput result=writer.getOutputInstance();
  if (paramTags.length > 0) {
    for (int i=0; i < paramTags.length; ++i) {
      ParamTag pt=paramTags[i];
      String paramName=isNonTypeParams ? pt.parameterName() : ""String_Node_Str"" + pt.parameterName() + ""String_Node_Str"";
      if (!rankMap.containsKey(pt.parameterName())) {
        writer.getMsgRetriever().warning(pt.position(),isNonTypeParams ? ""String_Node_Str"" : ""String_Node_Str"",paramName);
      }
      String rank=rankMap.get(pt.parameterName());
      if (rank != null && alreadyDocumented.contains(rank)) {
        writer.getMsgRetriever().warning(pt.position(),isNonTypeParams ? ""String_Node_Str"" : ""String_Node_Str"",paramName);
      }
      result.appendOutput(processParamTag(isNonTypeParams,writer,pt,pt.parameterName(),alreadyDocumented.size() == 0));
      alreadyDocumented.add(rank);
    }
  }
  return result;
}"
12949,"/** 
 * Given an array of <code>ParamTag</code>s,return its string representation. Try to inherit the param tags that are missing.
 * @param doc               the doc that holds the param tags.
 * @param writer            the TagletWriter that will write this tag.
 * @param formalParameters  The array of parmeters (from type or executablemember) to check.
 * @return the TagletOutput representation of these <code>ParamTag</code>s.
 */
private TagletOutput getTagletOutput(boolean isNonTypeParams,Doc holder,TagletWriter writer,Object[] formalParameters,ParamTag[] paramTags){
  TagletOutput result=writer.getOutputInstance();
  Set<String> alreadyDocumented=new HashSet<String>();
  if (paramTags.length > 0) {
    result.appendOutput(processParamTags(isNonTypeParams,paramTags,getRankMap(formalParameters),writer,alreadyDocumented));
  }
  if (alreadyDocumented.size() != formalParameters.length) {
    result.appendOutput(getInheritedTagletOutput(isNonTypeParams,holder,writer,formalParameters,alreadyDocumented));
  }
  return result;
}","/** 
 * Given an array of <code>ParamTag</code>s,return its string representation. Try to inherit the param tags that are missing.
 * @param holder            the doc that holds the param tags.
 * @param writer            the TagletWriter that will write this tag.
 * @param formalParameters  The array of parmeters (from type or executablemember) to check.
 * @return the TagletOutput representation of these <code>ParamTag</code>s.
 */
private TagletOutput getTagletOutput(boolean isNonTypeParams,Doc holder,TagletWriter writer,Object[] formalParameters,ParamTag[] paramTags){
  TagletOutput result=writer.getOutputInstance();
  Set<String> alreadyDocumented=new HashSet<String>();
  if (paramTags.length > 0) {
    result.appendOutput(processParamTags(isNonTypeParams,paramTags,getRankMap(formalParameters),writer,alreadyDocumented));
  }
  if (alreadyDocumented.size() != formalParameters.length) {
    result.appendOutput(getInheritedTagletOutput(isNonTypeParams,holder,writer,formalParameters,alreadyDocumented));
  }
  return result;
}"
12950,"/** 
 * Given the name of the field, return the corresponding FieldDoc.
 * @param config the current configuration of the doclet.
 * @param tag the value tag.
 * @param name the name of the field to search for.  The name should be in<qualified class name>#<field name> format. If the class name is omitted, it is assumed that the field is in the current class.
 * @return the corresponding FieldDoc. If the name is null or empty string,return field that the value tag was used in.
 * @throws DocletAbortException if the value tag does not specify a name toa value field and it is not used within the comments of a valid field.
 */
private FieldDoc getFieldDoc(Configuration config,Tag tag,String name){
  if (name == null || name.length() == 0) {
    if (tag.holder() instanceof FieldDoc) {
      return (FieldDoc)tag.holder();
    }
 else {
      throw new DocletAbortException();
    }
  }
  StringTokenizer st=new StringTokenizer(name,""String_Node_Str"");
  String memberName=null;
  ClassDoc cd=null;
  if (st.countTokens() == 1) {
    Doc holder=tag.holder();
    if (holder instanceof MemberDoc) {
      cd=((MemberDoc)holder).containingClass();
    }
 else     if (holder instanceof ClassDoc) {
      cd=(ClassDoc)holder;
    }
    memberName=st.nextToken();
  }
 else {
    cd=config.root.classNamed(st.nextToken());
    memberName=st.nextToken();
  }
  if (cd == null) {
    return null;
  }
  FieldDoc[] fields=cd.fields();
  for (int i=0; i < fields.length; i++) {
    if (fields[i].name().equals(memberName)) {
      return fields[i];
    }
  }
  return null;
}","/** 
 * Given the name of the field, return the corresponding FieldDoc.
 * @param config the current configuration of the doclet.
 * @param tag the value tag.
 * @param name the name of the field to search for.  The name should be in{@code <qualified class name>#<field name>} format. If the class name is omitted,it is assumed that the field is in the current class.
 * @return the corresponding FieldDoc. If the name is null or empty string,return field that the value tag was used in.
 * @throws DocletAbortException if the value tag does not specify a name toa value field and it is not used within the comments of a valid field.
 */
private FieldDoc getFieldDoc(Configuration config,Tag tag,String name){
  if (name == null || name.length() == 0) {
    if (tag.holder() instanceof FieldDoc) {
      return (FieldDoc)tag.holder();
    }
 else {
      throw new DocletAbortException();
    }
  }
  StringTokenizer st=new StringTokenizer(name,""String_Node_Str"");
  String memberName=null;
  ClassDoc cd=null;
  if (st.countTokens() == 1) {
    Doc holder=tag.holder();
    if (holder instanceof MemberDoc) {
      cd=((MemberDoc)holder).containingClass();
    }
 else     if (holder instanceof ClassDoc) {
      cd=(ClassDoc)holder;
    }
    memberName=st.nextToken();
  }
 else {
    cd=config.root.classNamed(st.nextToken());
    memberName=st.nextToken();
  }
  if (cd == null) {
    return null;
  }
  FieldDoc[] fields=cd.fields();
  for (int i=0; i < fields.length; i++) {
    if (fields[i].name().equals(memberName)) {
      return fields[i];
    }
  }
  return null;
}"
12951,"/** 
 * Return the list of deprecated Doc objects of a given type.
 * @param the constant representing the type of list being returned.
 */
public List<Doc> getList(int type){
  return deprecatedLists.get(type);
}","/** 
 * Return the list of deprecated Doc objects of a given type.
 * @param type the constant representing the type of list being returned.
 */
public List<Doc> getList(int type){
  return deprecatedLists.get(type);
}"
12952,"/** 
 * Get the Extern Item object associated with this package name.
 * @param pkgname Package name.
 */
private Item findPackageItem(String pkgName){
  if (packageToItemMap == null) {
    return null;
  }
  return packageToItemMap.get(pkgName);
}","/** 
 * Get the Extern Item object associated with this package name.
 * @param pkgName Package name.
 */
private Item findPackageItem(String pkgName){
  if (packageToItemMap == null) {
    return null;
  }
  return packageToItemMap.get(pkgName);
}"
12953,"/** 
 * Constructor to build a Extern Item object and map it with the package name. If the same package name is found in the map, then the first mapped Item object or offline location will be retained.
 * @param packagename Package name found in the ""package-list"" file.
 * @param path        URL or Directory path from where the ""package-list""file is picked.
 * @param relative    True if path is URL, false if directory path.
 */
Item(String packageName,String path,boolean relative){
  this.packageName=packageName;
  this.path=path;
  this.relative=relative;
  if (packageToItemMap == null) {
    packageToItemMap=new HashMap<String,Item>();
  }
  if (!packageToItemMap.containsKey(packageName)) {
    packageToItemMap.put(packageName,this);
  }
}","/** 
 * Constructor to build a Extern Item object and map it with the package name. If the same package name is found in the map, then the first mapped Item object or offline location will be retained.
 * @param packageName Package name found in the ""package-list"" file.
 * @param path        URL or Directory path from where the ""package-list""file is picked.
 * @param relative    True if path is URL, false if directory path.
 */
Item(String packageName,String path,boolean relative){
  this.packageName=packageName;
  this.path=path;
  this.relative=relative;
  if (packageToItemMap == null) {
    packageToItemMap=new HashMap<String,Item>();
  }
  if (!packageToItemMap.containsKey(packageName)) {
    packageToItemMap.put(packageName,this);
  }
}"
12954,"/** 
 * Return the package private members inherited by the class.  Only return if parent is package private and not documented.
 * @param configuation the current configuration of the doclet.
 * @return the package private members inherited by the class.
 */
private List<ProgramElementDoc> getInheritedPackagePrivateMethods(Configuration configuration){
  List<ProgramElementDoc> results=new ArrayList<ProgramElementDoc>();
  for (Iterator<ClassDoc> iter=visibleClasses.iterator(); iter.hasNext(); ) {
    ClassDoc currentClass=iter.next();
    if (currentClass != classdoc && currentClass.isPackagePrivate() && !Util.isLinkable(currentClass,configuration)) {
      results.addAll(getMembersFor(currentClass));
    }
  }
  return results;
}","/** 
 * Return the package private members inherited by the class.  Only return if parent is package private and not documented.
 * @param configuration the current configuration of the doclet.
 * @return the package private members inherited by the class.
 */
private List<ProgramElementDoc> getInheritedPackagePrivateMethods(Configuration configuration){
  List<ProgramElementDoc> results=new ArrayList<ProgramElementDoc>();
  for (Iterator<ClassDoc> iter=visibleClasses.iterator(); iter.hasNext(); ) {
    ClassDoc currentClass=iter.next();
    if (currentClass != classdoc && currentClass.isPackagePrivate() && !Util.isLinkable(currentClass,configuration)) {
      results.addAll(getMembersFor(currentClass));
    }
  }
  return results;
}"
12955,"/** 
 * Return the visible members of the class being mapped.  Also append at the end of the list members that are inherited by inaccessible parents. We document these members in the child because the parent is not documented.
 * @param configuation the current configuration of the doclet.
 */
public List<ProgramElementDoc> getLeafClassMembers(Configuration configuration){
  List<ProgramElementDoc> result=getMembersFor(classdoc);
  result.addAll(getInheritedPackagePrivateMethods(configuration));
  return result;
}","/** 
 * Return the visible members of the class being mapped.  Also append at the end of the list members that are inherited by inaccessible parents. We document these members in the child because the parent is not documented.
 * @param configuration the current configuration of the doclet.
 */
public List<ProgramElementDoc> getLeafClassMembers(Configuration configuration){
  List<ProgramElementDoc> result=getMembersFor(classdoc);
  result.addAll(getInheritedPackagePrivateMethods(configuration));
  return result;
}"
12956,"/** 
 * Configure the set of diagnostic parts that should be displayed by the formatter.
 * @param options options to set
 */
public void setVisible(Set<DiagnosticPart> visibleParts);","/** 
 * Configure the set of diagnostic parts that should be displayed by the formatter.
 * @param visibleParts the parts to be set
 */
public void setVisible(Set<DiagnosticPart> visibleParts);"
12957,"/** 
 * Constructor used by service provider mechanism.  The recommended way to obtain an instance of this class is by using   {@link #create} or theservice provider mechanism.
 * @see javax.tools.JavaCompilerTool
 * @see javax.tools.ToolProvider
 * @see #create
 */
@Deprecated public JavacTool(){
}","/** 
 * Constructor used by service provider mechanism.  The recommended way to obtain an instance of this class is by using   {@link #create} or theservice provider mechanism.
 * @see javax.tools.JavaCompiler
 * @see javax.tools.ToolProvider
 * @see #create
 */
@Deprecated public JavacTool(){
}"
12958,"/** 
 * Return the first sentence of the comment as an array of tags. Includes inline tags (i.e. {&#64link <i>reference</i>} tags)  but not block tags. Each section of plain text is represented as a   {@link Tag}of   {@linkplain Tag#kind() kind} ""Text"".Inline tags are represented as a  {@link SeeTag} of kind ""@see""and name ""@link"". <p> If the locale is English language, the first sentence is determined by the rules described in the Java Language Specification (first version): &quot;This sentence ends at the first period that is followed by a blank, tab, or line terminator or at the first tagline.&quot;, in addition a line will be terminated by block HTML tags: &lt;p&gt;  &lt;/p&gt;  &lt;h1&gt; &lt;h2&gt;  &lt;h3&gt; &lt;h4&gt;  &lt;h5&gt;  &lt;h6&gt; &lt;hr&gt;  &lt;pre&gt;  or &lt;/pre&gt;. If the locale is not English, the sentence end will be determined by {@link BreakIterator#getSentenceInstance(Locale)}.
 * @return an array of {@link Tag}s representing the first sentence of the comment
 */
Tag[] firstSentenceTags();","/** 
 * Return the first sentence of the comment as an array of tags. Includes inline tags (i.e. {&#64;link <i>reference</i>} tags)  but not block tags. Each section of plain text is represented as a   {@link Tag}of   {@linkplain Tag#kind() kind} ""Text"".Inline tags are represented as a  {@link SeeTag} of kind ""@see""and name ""@link"". <p> If the locale is English language, the first sentence is determined by the rules described in the Java Language Specification (first version): &quot;This sentence ends at the first period that is followed by a blank, tab, or line terminator or at the first tagline.&quot;, in addition a line will be terminated by block HTML tags: &lt;p&gt;  &lt;/p&gt;  &lt;h1&gt; &lt;h2&gt;  &lt;h3&gt; &lt;h4&gt;  &lt;h5&gt;  &lt;h6&gt; &lt;hr&gt;  &lt;pre&gt;  or &lt;/pre&gt;. If the locale is not English, the sentence end will be determined by {@link BreakIterator#getSentenceInstance(Locale)}.
 * @return an array of {@link Tag}s representing the first sentence of the comment
 */
Tag[] firstSentenceTags();"
12959,"/** 
 * Return comment as an array of tags. Includes inline tags (i.e. {&#64link <i>reference</i>} tags)  but not block tags. Each section of plain text is represented as a   {@link Tag}of   {@linkplain Tag#kind() kind} ""Text"".Inline tags are represented as a  {@link SeeTag} of kind ""@see""and name ""@link"".
 * @return an array of {@link Tag}s representing the comment
 */
Tag[] inlineTags();","/** 
 * Return comment as an array of tags. Includes inline tags (i.e. {&#64;link <i>reference</i>} tags)  but not block tags. Each section of plain text is represented as a   {@link Tag}of   {@linkplain Tag#kind() kind} ""Text"".Inline tags are represented as a  {@link SeeTag} of kind ""@see""and name ""@link"".
 * @return an array of {@link Tag}s representing the comment
 */
Tag[] inlineTags();"
12960,"/** 
 * Return the param tags in this method, excluding the type parameter tags.
 * @return an array of ParamTag containing all <code>&#64param</code> tagscorresponding to the parameters of this method.
 */
ParamTag[] paramTags();","/** 
 * Return the param tags in this method, excluding the type parameter tags.
 * @return an array of ParamTag containing all <code>&#64;param</code> tagscorresponding to the parameters of this method.
 */
ParamTag[] paramTags();"
12961,"/** 
 * Return the type parameter tags in this method.
 * @return an array of ParamTag containing all <code>&#64param</code> tagscorresponding to the type parameters of this method.
 * @since 1.5
 */
ParamTag[] typeParamTags();","/** 
 * Return the type parameter tags in this method.
 * @return an array of ParamTag containing all <code>&#64;param</code> tagscorresponding to the type parameters of this method.
 * @since 1.5
 */
ParamTag[] typeParamTags();"
12962,"/** 
 * Return the throws tags in this method.
 * @return an array of ThrowTag containing all <code>&#64exception</code>and <code>&#64throws</code> tags.
 */
ThrowsTag[] throwsTags();","/** 
 * Return the throws tags in this method.
 * @return an array of ThrowTag containing all <code>&#64;exception</code>and <code>&#64;throws</code> tags.
 */
ThrowsTag[] throwsTags();"
12963,"/** 
 * Return the first sentence of the comment as an array of tags. Includes inline tags (i.e. {&#64link <i>reference</i>} tags)  but not block tags. Each section of plain text is represented as a   {@link Tag}of kind ""Text"". Inline tags are represented as a   {@link SeeTag} of kind ""@link"".If the locale is English language, the first sentence is determined by the rules described in the Java Language Specification (first version): &quot;This sentence ends at the first period that is followed by a blank, tab, or line terminator or at the first tagline.&quot;, in addition a line will be terminated by paragraph and section terminating HTML tags: &lt;p&gt;  &lt;/p&gt;  &lt;h1&gt; &lt;h2&gt;  &lt;h3&gt; &lt;h4&gt;  &lt;h5&gt;  &lt;h6&gt; &lt;hr&gt;  &lt;pre&gt;  or &lt;/pre&gt;. If the locale is not English, the sentence end will be determined by {@link BreakIterator#getSentenceInstance(Locale)}.
 * @return an array of {@link Tag} objects representing thefirst sentence of the comment
 */
Tag[] firstSentenceTags();","/** 
 * Return the first sentence of the comment as an array of tags. Includes inline tags (i.e. {&#64;link <i>reference</i>} tags)  but not block tags. Each section of plain text is represented as a   {@link Tag}of kind ""Text"". Inline tags are represented as a   {@link SeeTag} of kind ""@link"".If the locale is English language, the first sentence is determined by the rules described in the Java Language Specification (first version): &quot;This sentence ends at the first period that is followed by a blank, tab, or line terminator or at the first tagline.&quot;, in addition a line will be terminated by paragraph and section terminating HTML tags: &lt;p&gt;  &lt;/p&gt;  &lt;h1&gt; &lt;h2&gt;  &lt;h3&gt; &lt;h4&gt;  &lt;h5&gt;  &lt;h6&gt; &lt;hr&gt;  &lt;pre&gt;  or &lt;/pre&gt;. If the locale is not English, the sentence end will be determined by {@link BreakIterator#getSentenceInstance(Locale)}.
 * @return an array of {@link Tag} objects representing thefirst sentence of the comment
 */
Tag[] firstSentenceTags();"
12964,"/** 
 * Find the start position of a line.
 * @param line line number (beginning at 1)
 * @return     position of first character in line
 * @throws IndexOutOfBoundsException if <tt>lineNumber < 1</tt> if <tt>lineNumber > no. of lines</tt>
 */
long getStartPosition(long line);","/** 
 * Find the start position of a line.
 * @param line line number (beginning at 1)
 * @return     position of first character in line
 * @throws IndexOutOfBoundsException if  {@code lineNumber < 1}if   {@code lineNumber > no. of lines}
 */
long getStartPosition(long line);"
12965,"/** 
 * Print the heading in Html &lt;H2> format.
 * @param str The Header string.
 */
public void printIndexHeading(String str){
  h2();
  print(str);
  h2End();
}","/** 
 * Print the heading in Html   {@literal <H2>} format.
 * @param str The Header string.
 */
public void printIndexHeading(String str){
  h2();
  print(str);
  h2End();
}"
12966,"/** 
 * Suppose a piece of documentation has a relative link.  When you copy that documetation to another place such as the index or class-use page, that relative link will no longer work.  We should redirect those links so that they will work again. <p> Here is the algorithm used to fix the link: <p> &lt;relative link&gt; => docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; <p> For example, suppose com.sun.javadoc.RootDoc has this link: &lt;a href=""package-summary.html""&gt;The package Page&lt;/a&gt; <p> If this link appeared in the index, we would redirect the link like this: &lt;a href=""./com/sun/javadoc/package-summary.html""&gt;The package Page&lt;/a&gt;
 * @param doc the Doc object whose documentation is being written.
 * @param text the text being written.
 * @return the text, with all the relative links redirected to work.
 */
private String redirectRelativeLinks(Doc doc,String text){
  if (doc == null || shouldNotRedirectRelativeLinks()) {
    return text;
  }
  String redirectPathFromRoot;
  if (doc instanceof ClassDoc) {
    redirectPathFromRoot=DirectoryManager.getDirectoryPath(((ClassDoc)doc).containingPackage());
  }
 else   if (doc instanceof MemberDoc) {
    redirectPathFromRoot=DirectoryManager.getDirectoryPath(((MemberDoc)doc).containingPackage());
  }
 else   if (doc instanceof PackageDoc) {
    redirectPathFromRoot=DirectoryManager.getDirectoryPath((PackageDoc)doc);
  }
 else {
    return text;
  }
  if (!redirectPathFromRoot.endsWith(DirectoryManager.URL_FILE_SEPARATOR)) {
    redirectPathFromRoot+=DirectoryManager.URL_FILE_SEPARATOR;
  }
  int end, begin=text.toLowerCase().indexOf(""String_Node_Str"");
  if (begin >= 0) {
    StringBuffer textBuff=new StringBuffer(text);
    while (begin >= 0) {
      if (textBuff.length() > begin + 2 && !Character.isWhitespace(textBuff.charAt(begin + 2))) {
        begin=textBuff.toString().toLowerCase().indexOf(""String_Node_Str"",begin + 1);
        continue;
      }
      begin=textBuff.indexOf(""String_Node_Str"",begin) + 1;
      end=textBuff.indexOf(""String_Node_Str"",begin + 1);
      if (begin == 0) {
        configuration.root.printWarning(doc.position(),configuration.getText(""String_Node_Str"",text));
        break;
      }
      if (end == -1) {
        break;
      }
      if (textBuff.substring(begin,end).indexOf(""String_Node_Str"") != -1) {
        begin=textBuff.indexOf(""String_Node_Str"",begin) + 1;
        end=textBuff.indexOf(""String_Node_Str"",begin + 1);
        if (begin == 0 || end == -1) {
          break;
        }
      }
      String relativeLink=textBuff.substring(begin,end);
      if (!(relativeLink.toLowerCase().startsWith(""String_Node_Str"") || relativeLink.toLowerCase().startsWith(""String_Node_Str"") || relativeLink.toLowerCase().startsWith(""String_Node_Str"")|| relativeLink.toLowerCase().startsWith(""String_Node_Str""))) {
        relativeLink=""String_Node_Str"" + (new DocRootTaglet()).getName() + ""String_Node_Str""+ redirectPathFromRoot+ relativeLink;
        textBuff.replace(begin,end,relativeLink);
      }
      begin=textBuff.toString().toLowerCase().indexOf(""String_Node_Str"",begin + 1);
    }
    return textBuff.toString();
  }
  return text;
}","/** 
 * Suppose a piece of documentation has a relative link.  When you copy that documetation to another place such as the index or class-use page, that relative link will no longer work.  We should redirect those links so that they will work again. <p> Here is the algorithm used to fix the link: <p>  {@literal <relative link> => docRoot + <relative path to file> + <relative link> }<p> For example, suppose com.sun.javadoc.RootDoc has this link:  {@literal <a href=""package-summary.html"">The package Page</a> }<p> If this link appeared in the index, we would redirect the link like this:  {@literal <a href=""./com/sun/javadoc/package-summary.html"">The package Page</a>}
 * @param doc the Doc object whose documentation is being written.
 * @param text the text being written.
 * @return the text, with all the relative links redirected to work.
 */
private String redirectRelativeLinks(Doc doc,String text){
  if (doc == null || shouldNotRedirectRelativeLinks()) {
    return text;
  }
  String redirectPathFromRoot;
  if (doc instanceof ClassDoc) {
    redirectPathFromRoot=DirectoryManager.getDirectoryPath(((ClassDoc)doc).containingPackage());
  }
 else   if (doc instanceof MemberDoc) {
    redirectPathFromRoot=DirectoryManager.getDirectoryPath(((MemberDoc)doc).containingPackage());
  }
 else   if (doc instanceof PackageDoc) {
    redirectPathFromRoot=DirectoryManager.getDirectoryPath((PackageDoc)doc);
  }
 else {
    return text;
  }
  if (!redirectPathFromRoot.endsWith(DirectoryManager.URL_FILE_SEPARATOR)) {
    redirectPathFromRoot+=DirectoryManager.URL_FILE_SEPARATOR;
  }
  int end, begin=text.toLowerCase().indexOf(""String_Node_Str"");
  if (begin >= 0) {
    StringBuffer textBuff=new StringBuffer(text);
    while (begin >= 0) {
      if (textBuff.length() > begin + 2 && !Character.isWhitespace(textBuff.charAt(begin + 2))) {
        begin=textBuff.toString().toLowerCase().indexOf(""String_Node_Str"",begin + 1);
        continue;
      }
      begin=textBuff.indexOf(""String_Node_Str"",begin) + 1;
      end=textBuff.indexOf(""String_Node_Str"",begin + 1);
      if (begin == 0) {
        configuration.root.printWarning(doc.position(),configuration.getText(""String_Node_Str"",text));
        break;
      }
      if (end == -1) {
        break;
      }
      if (textBuff.substring(begin,end).indexOf(""String_Node_Str"") != -1) {
        begin=textBuff.indexOf(""String_Node_Str"",begin) + 1;
        end=textBuff.indexOf(""String_Node_Str"",begin + 1);
        if (begin == 0 || end == -1) {
          break;
        }
      }
      String relativeLink=textBuff.substring(begin,end);
      if (!(relativeLink.toLowerCase().startsWith(""String_Node_Str"") || relativeLink.toLowerCase().startsWith(""String_Node_Str"") || relativeLink.toLowerCase().startsWith(""String_Node_Str"")|| relativeLink.toLowerCase().startsWith(""String_Node_Str""))) {
        relativeLink=""String_Node_Str"" + (new DocRootTaglet()).getName() + ""String_Node_Str""+ redirectPathFromRoot+ relativeLink;
        textBuff.replace(begin,end,relativeLink);
      }
      begin=textBuff.toString().toLowerCase().indexOf(""String_Node_Str"",begin + 1);
    }
    return textBuff.toString();
  }
  return text;
}"
12967,"/** 
 * Handles the &lt;ClassDoc> tag.
 * @param node the XML element that specifies which components to document
 * @param contentTree the content tree to which the documentation will be added
 */
public void buildClassDoc(XMLNode node,Content contentTree) throws Exception {
  String key;
  if (isInterface) {
    key=""String_Node_Str"";
  }
 else   if (isEnum) {
    key=""String_Node_Str"";
  }
 else {
    key=""String_Node_Str"";
  }
  contentTree=writer.getHeader(configuration.getText(key) + ""String_Node_Str"" + classDoc.name());
  Content classContentTree=writer.getClassContentHeader();
  buildChildren(node,classContentTree);
  contentTree.addContent(classContentTree);
  writer.addFooter(contentTree);
  writer.printDocument(contentTree);
  writer.close();
  copyDocFiles();
}","/** 
 * Handles the   {@literal <ClassDoc>} tag.
 * @param node the XML element that specifies which components to document
 * @param contentTree the content tree to which the documentation will be added
 */
public void buildClassDoc(XMLNode node,Content contentTree) throws Exception {
  String key;
  if (isInterface) {
    key=""String_Node_Str"";
  }
 else   if (isEnum) {
    key=""String_Node_Str"";
  }
 else {
    key=""String_Node_Str"";
  }
  contentTree=writer.getHeader(configuration.getText(key) + ""String_Node_Str"" + classDoc.name());
  Content classContentTree=writer.getClassContentHeader();
  buildChildren(node,classContentTree);
  contentTree.addContent(classContentTree);
  writer.addFooter(contentTree);
  writer.printDocument(contentTree);
  writer.close();
  copyDocFiles();
}"
12968,"/** 
 * Enter a binary operation, as above but with two opcodes, which get encoded as (opcode1 << ByteCodeTags.preShift) + opcode2.
 * @param opcode1     First opcode.
 * @param opcode2     Second opcode.
 */
private void enterBinop(String name,Type left,Type right,Type res,int opcode1,int opcode2){
  enterBinop(name,left,right,res,(opcode1 << ByteCodes.preShift) | opcode2);
}","/** 
 * Enter a binary operation, as above but with two opcodes, which get encoded as  {@code (opcode1 << ByteCodeTags.preShift) + opcode2 }.
 * @param opcode1     First opcode.
 * @param opcode2     Second opcode.
 */
private void enterBinop(String name,Type left,Type right,Type res,int opcode1,int opcode2){
  enterBinop(name,left,right,res,(opcode1 << ByteCodes.preShift) | opcode2);
}"
12969,"/** 
 * A statement of the form <pre> for ( T v : arrayexpr ) stmt; </pre> (where arrayexpr is of an array type) gets translated to <pre> for ( { arraytype #arr = arrayexpr; int #len = array.length; int #i = 0; }; #i < #len; i$++ ) { T v = arr$[#i]; stmt; } </pre> where #arr, #len, and #i are freshly named synthetic local variables.
 */
private void visitArrayForeachLoop(JCEnhancedForLoop tree){
  make_at(tree.expr.pos());
  VarSymbol arraycache=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),tree.expr.type,currentMethodSym);
  JCStatement arraycachedef=make.VarDef(arraycache,tree.expr);
  VarSymbol lencache=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),syms.intType,currentMethodSym);
  JCStatement lencachedef=make.VarDef(lencache,make.Select(make.Ident(arraycache),syms.lengthVar));
  VarSymbol index=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),syms.intType,currentMethodSym);
  JCVariableDecl indexdef=make.VarDef(index,make.Literal(INT,0));
  indexdef.init.type=indexdef.type=syms.intType.constType(0);
  List<JCStatement> loopinit=List.of(arraycachedef,lencachedef,indexdef);
  JCBinary cond=makeBinary(LT,make.Ident(index),make.Ident(lencache));
  JCExpressionStatement step=make.Exec(makeUnary(PREINC,make.Ident(index)));
  Type elemtype=types.elemtype(tree.expr.type);
  JCExpression loopvarinit=make.Indexed(make.Ident(arraycache),make.Ident(index)).setType(elemtype);
  JCVariableDecl loopvardef=(JCVariableDecl)make.VarDef(tree.var.mods,tree.var.name,tree.var.vartype,loopvarinit).setType(tree.var.type);
  loopvardef.sym=tree.var.sym;
  JCBlock body=make.Block(0,List.of(loopvardef,tree.body));
  result=translate(make.ForLoop(loopinit,cond,List.of(step),body));
  patchTargets(body,tree,result);
}","/** 
 * A statement of the form <pre> for ( T v : arrayexpr ) stmt; </pre> (where arrayexpr is of an array type) gets translated to <pre>  {@code}for (  arraytype #arr = arrayexpr; int #len = array.length; int #i = 0; }; #i < #len; i$++ ) { T v = arr$[#i]; stmt; } }</pre> where #arr, #len, and #i are freshly named synthetic local variables.
 */
private void visitArrayForeachLoop(JCEnhancedForLoop tree){
  make_at(tree.expr.pos());
  VarSymbol arraycache=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),tree.expr.type,currentMethodSym);
  JCStatement arraycachedef=make.VarDef(arraycache,tree.expr);
  VarSymbol lencache=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),syms.intType,currentMethodSym);
  JCStatement lencachedef=make.VarDef(lencache,make.Select(make.Ident(arraycache),syms.lengthVar));
  VarSymbol index=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),syms.intType,currentMethodSym);
  JCVariableDecl indexdef=make.VarDef(index,make.Literal(INT,0));
  indexdef.init.type=indexdef.type=syms.intType.constType(0);
  List<JCStatement> loopinit=List.of(arraycachedef,lencachedef,indexdef);
  JCBinary cond=makeBinary(LT,make.Ident(index),make.Ident(lencache));
  JCExpressionStatement step=make.Exec(makeUnary(PREINC,make.Ident(index)));
  Type elemtype=types.elemtype(tree.expr.type);
  JCExpression loopvarinit=make.Indexed(make.Ident(arraycache),make.Ident(index)).setType(elemtype);
  JCVariableDecl loopvardef=(JCVariableDecl)make.VarDef(tree.var.mods,tree.var.name,tree.var.vartype,loopvarinit).setType(tree.var.type);
  loopvardef.sym=tree.var.sym;
  JCBlock body=make.Block(0,List.of(loopvardef,tree.body));
  result=translate(make.ForLoop(loopinit,cond,List.of(step),body));
  patchTargets(body,tree,result);
}"
12970,"/** 
 * Construct a tree that represents the closest outer instance <C.this> such that the given symbol is a member of C.
 * @param pos           The source code position to be used for the tree.
 * @param sym           The accessed symbol.
 * @param preciseMatch  should we accept a type that is a subtype ofsym's owner, even if it doesn't contain sym due to hiding, overriding, or non-inheritance due to protection?
 */
JCExpression makeOwnerThis(DiagnosticPosition pos,Symbol sym,boolean preciseMatch){
  Symbol c=sym.owner;
  if (preciseMatch ? sym.isMemberOf(currentClass,types) : currentClass.isSubClass(sym.owner,types)) {
    return make.at(pos).This(c.erasure(types));
  }
 else {
    return makeOwnerThisN(pos,sym,preciseMatch);
  }
}","/** 
 * Construct a tree that represents the closest outer instance  {@code C.this} such that the given symbol is a member of C.
 * @param pos           The source code position to be used for the tree.
 * @param sym           The accessed symbol.
 * @param preciseMatch  should we accept a type that is a subtype ofsym's owner, even if it doesn't contain sym due to hiding, overriding, or non-inheritance due to protection?
 */
JCExpression makeOwnerThis(DiagnosticPosition pos,Symbol sym,boolean preciseMatch){
  Symbol c=sym.owner;
  if (preciseMatch ? sym.isMemberOf(currentClass,types) : currentClass.isSubClass(sym.owner,types)) {
    return make.at(pos).This(c.erasure(types));
  }
 else {
    return makeOwnerThisN(pos,sym,preciseMatch);
  }
}"
12971,"/** 
 * Construct a tree that represents the outer instance <C.this>. Never pick the current `this'.
 * @param pos           The source code position to be used for the tree.
 * @param c             The qualifier class.
 */
JCExpression makeOuterThis(DiagnosticPosition pos,TypeSymbol c){
  List<VarSymbol> ots=outerThisStack;
  if (ots.isEmpty()) {
    log.error(pos,""String_Node_Str"",c);
    Assert.error();
    return makeNull();
  }
  VarSymbol ot=ots.head;
  JCExpression tree=access(make.at(pos).Ident(ot));
  TypeSymbol otc=ot.type.tsym;
  while (otc != c) {
    do {
      ots=ots.tail;
      if (ots.isEmpty()) {
        log.error(pos,""String_Node_Str"",c);
        Assert.error();
        return tree;
      }
      ot=ots.head;
    }
 while (ot.owner != otc);
    if (otc.owner.kind != PCK && !otc.hasOuterInstance()) {
      chk.earlyRefError(pos,c);
      Assert.error();
      return makeNull();
    }
    tree=access(make.at(pos).Select(tree,ot));
    otc=ot.type.tsym;
  }
  return tree;
}","/** 
 * Construct a tree that represents the outer instance  {@code C.this}. Never pick the current `this'.
 * @param pos           The source code position to be used for the tree.
 * @param c             The qualifier class.
 */
JCExpression makeOuterThis(DiagnosticPosition pos,TypeSymbol c){
  List<VarSymbol> ots=outerThisStack;
  if (ots.isEmpty()) {
    log.error(pos,""String_Node_Str"",c);
    Assert.error();
    return makeNull();
  }
  VarSymbol ot=ots.head;
  JCExpression tree=access(make.at(pos).Ident(ot));
  TypeSymbol otc=ot.type.tsym;
  while (otc != c) {
    do {
      ots=ots.tail;
      if (ots.isEmpty()) {
        log.error(pos,""String_Node_Str"",c);
        Assert.error();
        return tree;
      }
      ot=ots.head;
    }
 while (ot.owner != otc);
    if (otc.owner.kind != PCK && !otc.hasOuterInstance()) {
      chk.earlyRefError(pos,c);
      Assert.error();
      return makeNull();
    }
    tree=access(make.at(pos).Select(tree,ot));
    otc=ot.type.tsym;
  }
  return tree;
}"
12972,"/** 
 * Return tree simulating the assignment <this.this$n = this$n>.
 */
JCStatement initOuterThis(int pos){
  VarSymbol rhs=outerThisStack.head;
  Assert.check(rhs.owner.kind == MTH);
  VarSymbol lhs=outerThisStack.tail.head;
  Assert.check(rhs.owner.owner == lhs.owner);
  make.at(pos);
  return make.Exec(make.Assign(make.Select(make.This(lhs.owner.erasure(types)),lhs),make.Ident(rhs)).setType(lhs.erasure(types)));
}","/** 
 * Return tree simulating the assignment   {@code this.this$n = this$n}.
 */
JCStatement initOuterThis(int pos){
  VarSymbol rhs=outerThisStack.head;
  Assert.check(rhs.owner.kind == MTH);
  VarSymbol lhs=outerThisStack.tail.head;
  Assert.check(rhs.owner.owner == lhs.owner);
  make.at(pos);
  return make.Exec(make.Assign(make.Select(make.This(lhs.owner.erasure(types)),lhs),make.Ident(rhs)).setType(lhs.erasure(types)));
}"
12973,"/** 
 * Construct a tree simulating the expression <C.this>.
 * @param pos           The source code position to be used for the tree.
 * @param c             The qualifier class.
 */
JCExpression makeThis(DiagnosticPosition pos,TypeSymbol c){
  if (currentClass == c) {
    return make.at(pos).This(c.erasure(types));
  }
 else {
    return makeOuterThis(pos,c);
  }
}","/** 
 * Construct a tree simulating the expression   {@code C.this}.
 * @param pos           The source code position to be used for the tree.
 * @param c             The qualifier class.
 */
JCExpression makeThis(DiagnosticPosition pos,TypeSymbol c){
  if (currentClass == c) {
    return make.at(pos).This(c.erasure(types));
  }
 else {
    return makeOuterThis(pos,c);
  }
}"
12974,"/** 
 * A statement of the form <pre> for ( T v : coll ) stmt ; </pre> (where coll implements Iterable<? extends T>) gets translated to <pre> for ( Iterator<? extends T> #i = coll.iterator(); #i.hasNext(); ) { T v = (T) #i.next(); stmt; } </pre> where #i is a freshly named synthetic local variable.
 */
private void visitIterableForeachLoop(JCEnhancedForLoop tree){
  make_at(tree.expr.pos());
  Type iteratorTarget=syms.objectType;
  Type iterableType=types.asSuper(types.upperBound(tree.expr.type),syms.iterableType.tsym);
  if (iterableType.getTypeArguments().nonEmpty())   iteratorTarget=types.erasure(iterableType.getTypeArguments().head);
  Type eType=tree.expr.type;
  tree.expr.type=types.erasure(eType);
  if (eType.tag == TYPEVAR && eType.getUpperBound().isCompound())   tree.expr=make.TypeCast(types.erasure(iterableType),tree.expr);
  Symbol iterator=lookupMethod(tree.expr.pos(),names.iterator,types.erasure(syms.iterableType),List.<Type>nil());
  VarSymbol itvar=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),types.erasure(iterator.type.getReturnType()),currentMethodSym);
  JCStatement init=make.VarDef(itvar,make.App(make.Select(tree.expr,iterator)));
  Symbol hasNext=lookupMethod(tree.expr.pos(),names.hasNext,itvar.type,List.<Type>nil());
  JCMethodInvocation cond=make.App(make.Select(make.Ident(itvar),hasNext));
  Symbol next=lookupMethod(tree.expr.pos(),names.next,itvar.type,List.<Type>nil());
  JCExpression vardefinit=make.App(make.Select(make.Ident(itvar),next));
  if (tree.var.type.isPrimitive())   vardefinit=make.TypeCast(types.upperBound(iteratorTarget),vardefinit);
 else   vardefinit=make.TypeCast(tree.var.type,vardefinit);
  JCVariableDecl indexDef=(JCVariableDecl)make.VarDef(tree.var.mods,tree.var.name,tree.var.vartype,vardefinit).setType(tree.var.type);
  indexDef.sym=tree.var.sym;
  JCBlock body=make.Block(0,List.of(indexDef,tree.body));
  body.endpos=TreeInfo.endPos(tree.body);
  result=translate(make.ForLoop(List.of(init),cond,List.<JCExpressionStatement>nil(),body));
  patchTargets(body,tree,result);
}","/** 
 * A statement of the form <pre> for ( T v : coll ) stmt ; </pre> (where coll implements   {@code Iterable<? extends T>}) gets translated to <pre>  {@code}for ( Iterator<? extends T> #i = coll.iterator(); #i.hasNext(); )  T v = (T) #i.next(); stmt; } }</pre> where #i is a freshly named synthetic local variable.
 */
private void visitIterableForeachLoop(JCEnhancedForLoop tree){
  make_at(tree.expr.pos());
  Type iteratorTarget=syms.objectType;
  Type iterableType=types.asSuper(types.upperBound(tree.expr.type),syms.iterableType.tsym);
  if (iterableType.getTypeArguments().nonEmpty())   iteratorTarget=types.erasure(iterableType.getTypeArguments().head);
  Type eType=tree.expr.type;
  tree.expr.type=types.erasure(eType);
  if (eType.tag == TYPEVAR && eType.getUpperBound().isCompound())   tree.expr=make.TypeCast(types.erasure(iterableType),tree.expr);
  Symbol iterator=lookupMethod(tree.expr.pos(),names.iterator,types.erasure(syms.iterableType),List.<Type>nil());
  VarSymbol itvar=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),types.erasure(iterator.type.getReturnType()),currentMethodSym);
  JCStatement init=make.VarDef(itvar,make.App(make.Select(tree.expr,iterator)));
  Symbol hasNext=lookupMethod(tree.expr.pos(),names.hasNext,itvar.type,List.<Type>nil());
  JCMethodInvocation cond=make.App(make.Select(make.Ident(itvar),hasNext));
  Symbol next=lookupMethod(tree.expr.pos(),names.next,itvar.type,List.<Type>nil());
  JCExpression vardefinit=make.App(make.Select(make.Ident(itvar),next));
  if (tree.var.type.isPrimitive())   vardefinit=make.TypeCast(types.upperBound(iteratorTarget),vardefinit);
 else   vardefinit=make.TypeCast(tree.var.type,vardefinit);
  JCVariableDecl indexDef=(JCVariableDecl)make.VarDef(tree.var.mods,tree.var.name,tree.var.vartype,vardefinit).setType(tree.var.type);
  indexDef.sym=tree.var.sym;
  JCBlock body=make.Block(0,List.of(indexDef,tree.body));
  body.endpos=TreeInfo.endPos(tree.body);
  result=translate(make.ForLoop(List.of(init),cond,List.<JCExpressionStatement>nil(),body));
  patchTargets(body,tree,result);
}"
12975,"/** 
 * Return tree simulating the assignment <this.name = name>, where name is the name of a free variable.
 */
JCStatement initField(int pos,Name name){
  Scope.Entry e=proxies.lookup(name);
  Symbol rhs=e.sym;
  Assert.check(rhs.owner.kind == MTH);
  Symbol lhs=e.next().sym;
  Assert.check(rhs.owner.owner == lhs.owner);
  make.at(pos);
  return make.Exec(make.Assign(make.Select(make.This(lhs.owner.erasure(types)),lhs),make.Ident(rhs)).setType(lhs.erasure(types)));
}","/** 
 * Return tree simulating the assignment   {@code this.name = name}, where name is the name of a free variable.
 */
JCStatement initField(int pos,Name name){
  Scope.Entry e=proxies.lookup(name);
  Symbol rhs=e.sym;
  Assert.check(rhs.owner.kind == MTH);
  Symbol lhs=e.next().sym;
  Assert.check(rhs.owner.owner == lhs.owner);
  make.at(pos);
  return make.Exec(make.Assign(make.Select(make.This(lhs.owner.erasure(types)),lhs),make.Ident(rhs)).setType(lhs.erasure(types)));
}"
12976,"/** 
 * A name designates an operator if it consists of a non-empty sequence of operator symbols +-~!/*%&|^<>=
 */
boolean isOperator(Name name){
  int i=0;
  while (i < name.getByteLength() && ""String_Node_Str"".indexOf(name.getByteAt(i)) >= 0)   i++;
  return i > 0 && i == name.getByteLength();
}","/** 
 * A name designates an operator if it consists of a non-empty sequence of operator symbols   {@literal +-~!/*%&|^<>= }
 */
boolean isOperator(Name name){
  int i=0;
  while (i < name.getByteLength() && ""String_Node_Str"".indexOf(name.getByteAt(i)) >= 0)   i++;
  return i > 0 && i == name.getByteLength();
}"
12977,"/** 
 * This method scans all the constructor symbol in a given class scope - assuming that the original scope contains a constructor of the kind: Foo(X x, Y y), where X,Y are class type-variables declared in Foo, a method check is executed against the modified constructor type: <X,Y>Foo<X,Y>(X x, Y y). This is crucial in order to enable diamond inference. The inferred return type of the synthetic constructor IS the inferred type for the diamond operator.
 */
private Symbol findDiamond(Env<AttrContext> env,Type site,List<Type> argtypes,List<Type> typeargtypes,boolean allowBoxing,boolean useVarargs){
  Symbol bestSoFar=methodNotFound;
  for (Scope.Entry e=site.tsym.members().lookup(names.init); e.scope != null; e=e.next()) {
    if (e.sym.kind == MTH && (e.sym.flags_field & SYNTHETIC) == 0) {
      List<Type> oldParams=e.sym.type.tag == FORALL ? ((ForAll)e.sym.type).tvars : List.<Type>nil();
      Type constrType=new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),types.createMethodTypeWithReturn(e.sym.type.asMethodType(),site));
      bestSoFar=selectBest(env,site,argtypes,typeargtypes,new MethodSymbol(e.sym.flags(),names.init,constrType,site.tsym),bestSoFar,allowBoxing,useVarargs,false);
    }
  }
  return bestSoFar;
}","/** 
 * This method scans all the constructor symbol in a given class scope - assuming that the original scope contains a constructor of the kind:  {@code Foo(X x, Y y)}, where X,Y are class type-variables declared in Foo, a method check is executed against the modified constructor type:  {@code <X,Y>Foo<X,Y>(X x, Y y)}. This is crucial in order to enable diamond inference. The inferred return type of the synthetic constructor IS the inferred type for the diamond operator.
 */
private Symbol findDiamond(Env<AttrContext> env,Type site,List<Type> argtypes,List<Type> typeargtypes,boolean allowBoxing,boolean useVarargs){
  Symbol bestSoFar=methodNotFound;
  for (Scope.Entry e=site.tsym.members().lookup(names.init); e.scope != null; e=e.next()) {
    if (e.sym.kind == MTH && (e.sym.flags_field & SYNTHETIC) == 0) {
      List<Type> oldParams=e.sym.type.tag == FORALL ? ((ForAll)e.sym.type).tvars : List.<Type>nil();
      Type constrType=new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),types.createMethodTypeWithReturn(e.sym.type.asMethodType(),site));
      bestSoFar=selectBest(env,site,argtypes,typeargtypes,new MethodSymbol(e.sym.flags(),names.init,constrType,site.tsym),bestSoFar,allowBoxing,useVarargs,false);
    }
  }
  return bestSoFar;
}"
12978,"/** 
 * Source file positions in CRT are integers in the format: line-number << LINESHIFT + column-number
 */
private int encodePosition(int pos,Position.LineMap lineMap,Log log){
  int line=lineMap.getLineNumber(pos);
  int col=lineMap.getColumnNumber(pos);
  int new_pos=Position.encodePosition(line,col);
  if (crtDebug) {
    System.out.println(""String_Node_Str"" + line + ""String_Node_Str""+ col+ ""String_Node_Str""+ new_pos);
  }
  if (new_pos == Position.NOPOS)   log.warning(pos,""String_Node_Str"",line);
  return new_pos;
}","/** 
 * Source file positions in CRT are integers in the format:  {@literal line-number << LINESHIFT + column-number }
 */
private int encodePosition(int pos,Position.LineMap lineMap,Log log){
  int line=lineMap.getLineNumber(pos);
  int col=lineMap.getColumnNumber(pos);
  int new_pos=Position.encodePosition(line,col);
  if (crtDebug) {
    System.out.println(""String_Node_Str"" + line + ""String_Node_Str""+ col+ ""String_Node_Str""+ new_pos);
  }
  if (new_pos == Position.NOPOS)   log.warning(pos,""String_Node_Str"",line);
  return new_pos;
}"
12979,"public Log make(){
  return Bark.instance(context);
}","public Log make(Context c){
  return Bark.instance(c);
}"
12980,"/** 
 * Preregisters factories to create and use a Bark object for use as both a Log and a Bark.
 */
public static void preRegister(final Context context){
  context.put(barkKey,new Context.Factory<Bark>(){
    public Bark make(){
      return new Bark(context);
    }
  }
);
  context.put(Log.logKey,new Context.Factory<Log>(){
    public Log make(){
      return Bark.instance(context);
    }
  }
);
}","/** 
 * Preregisters factories to create and use a Bark object for use as both a Log and a Bark.
 */
public static void preRegister(Context context){
  context.put(barkKey,new Context.Factory<Bark>(){
    public Bark make(    Context c){
      return new Bark(c);
    }
  }
);
  context.put(Log.logKey,new Context.Factory<Log>(){
    public Log make(    Context c){
      return Bark.instance(c);
    }
  }
);
}"
12981,"/** 
 * Register that a compilation is about to start.
 */
void beginContext(final Context context){
  if (compilationInProgress)   throw new IllegalStateException(""String_Node_Str"");
  compilationInProgress=true;
  final JavaFileManager givenFileManager=context.get(JavaFileManager.class);
  context.put(JavaFileManager.class,(JavaFileManager)null);
  context.put(JavaFileManager.class,new Context.Factory<JavaFileManager>(){
    public JavaFileManager make(){
      if (givenFileManager != null) {
        context.put(JavaFileManager.class,givenFileManager);
        return givenFileManager;
      }
 else {
        return new JavacFileManager(context,true,null);
      }
    }
  }
);
}","/** 
 * Register that a compilation is about to start.
 */
void beginContext(Context context){
  if (compilationInProgress)   throw new IllegalStateException(""String_Node_Str"");
  compilationInProgress=true;
  final JavaFileManager givenFileManager=context.get(JavaFileManager.class);
  context.put(JavaFileManager.class,(JavaFileManager)null);
  context.put(JavaFileManager.class,new Context.Factory<JavaFileManager>(){
    public JavaFileManager make(    Context c){
      if (givenFileManager != null) {
        c.put(JavaFileManager.class,givenFileManager);
        return givenFileManager;
      }
 else {
        return new JavacFileManager(c,true,null);
      }
    }
  }
);
}"
12982,"public JavaFileManager make(){
  if (givenFileManager != null) {
    context.put(JavaFileManager.class,givenFileManager);
    return givenFileManager;
  }
 else {
    return new JavacFileManager(context,true,null);
  }
}","public JavaFileManager make(Context c){
  if (givenFileManager != null) {
    c.put(JavaFileManager.class,givenFileManager);
    return givenFileManager;
  }
 else {
    return new JavacFileManager(c,true,null);
  }
}"
12983,"public FSInfo make(){
  FSInfo instance=new CacheFSInfo();
  context.put(FSInfo.class,instance);
  return instance;
}","public FSInfo make(Context c){
  FSInfo instance=new CacheFSInfo();
  c.put(FSInfo.class,instance);
  return instance;
}"
12984,"/** 
 * Register a Context.Factory to create a singleton CacheFSInfo.
 */
public static void preRegister(final Context context){
  context.put(FSInfo.class,new Context.Factory<FSInfo>(){
    public FSInfo make(){
      FSInfo instance=new CacheFSInfo();
      context.put(FSInfo.class,instance);
      return instance;
    }
  }
);
}","/** 
 * Register a Context.Factory to create a CacheFSInfo.
 */
public static void preRegister(Context context){
  context.put(FSInfo.class,new Context.Factory<FSInfo>(){
    public FSInfo make(    Context c){
      FSInfo instance=new CacheFSInfo();
      c.put(FSInfo.class,instance);
      return instance;
    }
  }
);
}"
12985,"/** 
 * Register a Context.Factory to create a JavacFileManager.
 */
public static void preRegister(final Context context){
  context.put(JavaFileManager.class,new Context.Factory<JavaFileManager>(){
    public JavaFileManager make(){
      return new JavacFileManager(context,true,null);
    }
  }
);
}","/** 
 * Register a Context.Factory to create a JavacFileManager.
 */
public static void preRegister(Context context){
  context.put(JavaFileManager.class,new Context.Factory<JavaFileManager>(){
    public JavaFileManager make(    Context c){
      return new JavacFileManager(c,true,null);
    }
  }
);
}"
12986,"public JavaFileManager make(){
  return new JavacFileManager(context,true,null);
}","public JavaFileManager make(Context c){
  return new JavacFileManager(c,true,null);
}"
12987,"/** 
 * Construct a new compiler using a shared context.
 */
public JavaCompiler(final Context context){
  this.context=context;
  context.put(compilerKey,this);
  if (context.get(JavaFileManager.class) == null)   JavacFileManager.preRegister(context);
  names=Names.instance(context);
  log=Log.instance(context);
  diagFactory=JCDiagnostic.Factory.instance(context);
  reader=ClassReader.instance(context);
  make=TreeMaker.instance(context);
  writer=ClassWriter.instance(context);
  enter=Enter.instance(context);
  todo=Todo.instance(context);
  fileManager=context.get(JavaFileManager.class);
  parserFactory=ParserFactory.instance(context);
  try {
    syms=Symtab.instance(context);
  }
 catch (  CompletionFailure ex) {
    log.error(""String_Node_Str"",ex.sym,ex.getDetailValue());
    if (ex instanceof ClassReader.BadClassFile)     throw new Abort();
  }
  source=Source.instance(context);
  attr=Attr.instance(context);
  chk=Check.instance(context);
  gen=Gen.instance(context);
  flow=Flow.instance(context);
  transTypes=TransTypes.instance(context);
  lower=Lower.instance(context);
  annotate=Annotate.instance(context);
  types=Types.instance(context);
  taskListener=context.get(TaskListener.class);
  reader.sourceCompleter=this;
  Options options=Options.instance(context);
  verbose=options.isSet(VERBOSE);
  sourceOutput=options.isSet(PRINTSOURCE);
  stubOutput=options.isSet(""String_Node_Str"");
  relax=options.isSet(""String_Node_Str"");
  printFlat=options.isSet(""String_Node_Str"");
  attrParseOnly=options.isSet(""String_Node_Str"");
  encoding=options.get(ENCODING);
  lineDebugInfo=options.isUnset(G_CUSTOM) || options.isSet(G_CUSTOM,""String_Node_Str"");
  genEndPos=options.isSet(XJCOV) || context.get(DiagnosticListener.class) != null;
  devVerbose=options.isSet(""String_Node_Str"");
  processPcks=options.isSet(""String_Node_Str"");
  werror=options.isSet(WERROR);
  if (source.compareTo(Source.DEFAULT) < 0) {
    if (options.isUnset(XLINT_CUSTOM,""String_Node_Str"" + LintCategory.OPTIONS.option)) {
      if (fileManager instanceof BaseFileManager) {
        if (((BaseFileManager)fileManager).isDefaultBootClassPath())         log.warning(LintCategory.OPTIONS,""String_Node_Str"",source.name);
      }
    }
  }
  verboseCompilePolicy=options.isSet(""String_Node_Str"");
  if (attrParseOnly)   compilePolicy=CompilePolicy.ATTR_ONLY;
 else   compilePolicy=CompilePolicy.decode(options.get(""String_Node_Str""));
  implicitSourcePolicy=ImplicitSourcePolicy.decode(options.get(""String_Node_Str""));
  completionFailureName=options.isSet(""String_Node_Str"") ? names.fromString(options.get(""String_Node_Str"")) : null;
  shouldStopPolicy=options.isSet(""String_Node_Str"") ? CompileState.valueOf(options.get(""String_Node_Str"")) : null;
  if (options.isUnset(""String_Node_Str""))   log.setDiagnosticFormatter(RichDiagnosticFormatter.instance(context));
}","/** 
 * Construct a new compiler using a shared context.
 */
public JavaCompiler(Context context){
  this.context=context;
  context.put(compilerKey,this);
  if (context.get(JavaFileManager.class) == null)   JavacFileManager.preRegister(context);
  names=Names.instance(context);
  log=Log.instance(context);
  diagFactory=JCDiagnostic.Factory.instance(context);
  reader=ClassReader.instance(context);
  make=TreeMaker.instance(context);
  writer=ClassWriter.instance(context);
  enter=Enter.instance(context);
  todo=Todo.instance(context);
  fileManager=context.get(JavaFileManager.class);
  parserFactory=ParserFactory.instance(context);
  try {
    syms=Symtab.instance(context);
  }
 catch (  CompletionFailure ex) {
    log.error(""String_Node_Str"",ex.sym,ex.getDetailValue());
    if (ex instanceof ClassReader.BadClassFile)     throw new Abort();
  }
  source=Source.instance(context);
  attr=Attr.instance(context);
  chk=Check.instance(context);
  gen=Gen.instance(context);
  flow=Flow.instance(context);
  transTypes=TransTypes.instance(context);
  lower=Lower.instance(context);
  annotate=Annotate.instance(context);
  types=Types.instance(context);
  taskListener=context.get(TaskListener.class);
  reader.sourceCompleter=this;
  Options options=Options.instance(context);
  verbose=options.isSet(VERBOSE);
  sourceOutput=options.isSet(PRINTSOURCE);
  stubOutput=options.isSet(""String_Node_Str"");
  relax=options.isSet(""String_Node_Str"");
  printFlat=options.isSet(""String_Node_Str"");
  attrParseOnly=options.isSet(""String_Node_Str"");
  encoding=options.get(ENCODING);
  lineDebugInfo=options.isUnset(G_CUSTOM) || options.isSet(G_CUSTOM,""String_Node_Str"");
  genEndPos=options.isSet(XJCOV) || context.get(DiagnosticListener.class) != null;
  devVerbose=options.isSet(""String_Node_Str"");
  processPcks=options.isSet(""String_Node_Str"");
  werror=options.isSet(WERROR);
  if (source.compareTo(Source.DEFAULT) < 0) {
    if (options.isUnset(XLINT_CUSTOM,""String_Node_Str"" + LintCategory.OPTIONS.option)) {
      if (fileManager instanceof BaseFileManager) {
        if (((BaseFileManager)fileManager).isDefaultBootClassPath())         log.warning(LintCategory.OPTIONS,""String_Node_Str"",source.name);
      }
    }
  }
  verboseCompilePolicy=options.isSet(""String_Node_Str"");
  if (attrParseOnly)   compilePolicy=CompilePolicy.ATTR_ONLY;
 else   compilePolicy=CompilePolicy.decode(options.get(""String_Node_Str""));
  implicitSourcePolicy=ImplicitSourcePolicy.decode(options.get(""String_Node_Str""));
  completionFailureName=options.isSet(""String_Node_Str"") ? names.fromString(options.get(""String_Node_Str"")) : null;
  shouldStopPolicy=options.isSet(""String_Node_Str"") ? CompileState.valueOf(options.get(""String_Node_Str"")) : null;
  if (options.isUnset(""String_Node_Str""))   log.setDiagnosticFormatter(RichDiagnosticFormatter.instance(context));
}"
12988,"/** 
 * Get the context for the next round of processing. Important values are propogated from round to round; other values are implicitly reset.
 */
private Context nextContext(){
  Context next=new Context();
  Options options=Options.instance(context);
  Assert.checkNonNull(options);
  next.put(Options.optionsKey,options);
  PrintWriter out=context.get(Log.outKey);
  Assert.checkNonNull(out);
  next.put(Log.outKey,out);
  final boolean shareNames=true;
  if (shareNames) {
    Names names=Names.instance(context);
    Assert.checkNonNull(names);
    next.put(Names.namesKey,names);
  }
  DiagnosticListener<?> dl=context.get(DiagnosticListener.class);
  if (dl != null)   next.put(DiagnosticListener.class,dl);
  TaskListener tl=context.get(TaskListener.class);
  if (tl != null)   next.put(TaskListener.class,tl);
  FSInfo fsInfo=context.get(FSInfo.class);
  if (fsInfo != null)   next.put(FSInfo.class,fsInfo);
  JavaFileManager jfm=context.get(JavaFileManager.class);
  Assert.checkNonNull(jfm);
  next.put(JavaFileManager.class,jfm);
  if (jfm instanceof JavacFileManager) {
    ((JavacFileManager)jfm).setContext(next);
  }
  Names names=Names.instance(context);
  Assert.checkNonNull(names);
  next.put(Names.namesKey,names);
  Keywords keywords=Keywords.instance(context);
  Assert.checkNonNull(keywords);
  next.put(Keywords.keywordsKey,keywords);
  JavaCompiler oldCompiler=JavaCompiler.instance(context);
  JavaCompiler nextCompiler=JavaCompiler.instance(next);
  nextCompiler.initRound(oldCompiler);
  filer.newRound(next);
  messager.newRound(next);
  elementUtils.setContext(next);
  typeUtils.setContext(next);
  JavacTaskImpl task=context.get(JavacTaskImpl.class);
  if (task != null) {
    next.put(JavacTaskImpl.class,task);
    task.updateContext(next);
  }
  JavacTrees trees=context.get(JavacTrees.class);
  if (trees != null) {
    next.put(JavacTrees.class,trees);
    trees.updateContext(next);
  }
  context.clear();
  return next;
}","/** 
 * Get the context for the next round of processing. Important values are propogated from round to round; other values are implicitly reset.
 */
private Context nextContext(){
  Context next=new Context(context);
  Options options=Options.instance(context);
  Assert.checkNonNull(options);
  next.put(Options.optionsKey,options);
  PrintWriter out=context.get(Log.outKey);
  Assert.checkNonNull(out);
  next.put(Log.outKey,out);
  final boolean shareNames=true;
  if (shareNames) {
    Names names=Names.instance(context);
    Assert.checkNonNull(names);
    next.put(Names.namesKey,names);
  }
  DiagnosticListener<?> dl=context.get(DiagnosticListener.class);
  if (dl != null)   next.put(DiagnosticListener.class,dl);
  TaskListener tl=context.get(TaskListener.class);
  if (tl != null)   next.put(TaskListener.class,tl);
  FSInfo fsInfo=context.get(FSInfo.class);
  if (fsInfo != null)   next.put(FSInfo.class,fsInfo);
  JavaFileManager jfm=context.get(JavaFileManager.class);
  Assert.checkNonNull(jfm);
  next.put(JavaFileManager.class,jfm);
  if (jfm instanceof JavacFileManager) {
    ((JavacFileManager)jfm).setContext(next);
  }
  Names names=Names.instance(context);
  Assert.checkNonNull(names);
  next.put(Names.namesKey,names);
  Keywords keywords=Keywords.instance(context);
  Assert.checkNonNull(keywords);
  next.put(Keywords.keywordsKey,keywords);
  JavaCompiler oldCompiler=JavaCompiler.instance(context);
  JavaCompiler nextCompiler=JavaCompiler.instance(next);
  nextCompiler.initRound(oldCompiler);
  filer.newRound(next);
  messager.newRound(next);
  elementUtils.setContext(next);
  typeUtils.setContext(next);
  JavacTaskImpl task=context.get(JavacTaskImpl.class);
  if (task != null) {
    next.put(JavacTaskImpl.class,task);
    task.updateContext(next);
  }
  JavacTrees trees=context.get(JavacTrees.class);
  if (trees != null) {
    next.put(JavacTrees.class,trees);
    trees.updateContext(next);
  }
  context.clear();
  return next;
}"
12989,"public Context(){
}","public Context(Context prev){
  kt.putAll(prev.kt);
  ft.putAll(prev.ft);
  ht.putAll(prev.ft);
}"
12990,"public void clear(){
  ht=null;
  kt=null;
}","public void clear(){
  ht=null;
  kt=null;
  ft=null;
}"
12991,T make();,T make(Context c);
12992,"public ClassReader make(){
  return new JavadocClassReader(context);
}","public ClassReader make(Context c){
  return new JavadocClassReader(c);
}"
12993,"public static void preRegister(final Context context){
  context.put(classReaderKey,new Context.Factory<ClassReader>(){
    public ClassReader make(){
      return new JavadocClassReader(context);
    }
  }
);
}","public static void preRegister(Context context){
  context.put(classReaderKey,new Context.Factory<ClassReader>(){
    public ClassReader make(    Context c){
      return new JavadocClassReader(c);
    }
  }
);
}"
12994,"public Enter make(){
  return new JavadocEnter(context);
}","public Enter make(Context c){
  return new JavadocEnter(c);
}"
12995,"public static void preRegister(final Context context){
  context.put(enterKey,new Context.Factory<Enter>(){
    public Enter make(){
      return new JavadocEnter(context);
    }
  }
);
}","public static void preRegister(Context context){
  context.put(enterKey,new Context.Factory<Enter>(){
    public Enter make(    Context c){
      return new JavadocEnter(c);
    }
  }
);
}"
12996,"public MemberEnter make(){
  return new JavadocMemberEnter(context);
}","public MemberEnter make(Context c){
  return new JavadocMemberEnter(c);
}"
12997,"public static void preRegister(final Context context){
  context.put(memberEnterKey,new Context.Factory<MemberEnter>(){
    public MemberEnter make(){
      return new JavadocMemberEnter(context);
    }
  }
);
}","public static void preRegister(Context context){
  context.put(memberEnterKey,new Context.Factory<MemberEnter>(){
    public MemberEnter make(    Context c){
      return new JavadocMemberEnter(c);
    }
  }
);
}"
12998,"public Todo make(){
  return new JavadocTodo(context);
}","public Todo make(Context c){
  return new JavadocTodo(c);
}"
12999,"public static void preRegister(final Context context){
  context.put(todoKey,new Context.Factory<Todo>(){
    public Todo make(){
      return new JavadocTodo(context);
    }
  }
);
}","public static void preRegister(Context context){
  context.put(todoKey,new Context.Factory<Todo>(){
    public Todo make(    Context c){
      return new JavadocTodo(c);
    }
  }
);
}"
13000,"public Log make(){
  return new Messager(context,programName,errWriter,warnWriter,noticeWriter);
}","public Log make(Context c){
  return new Messager(c,programName,errWriter,warnWriter,noticeWriter);
}"
