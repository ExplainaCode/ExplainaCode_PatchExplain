record_number,buggy_code,fixed_code
87001,"public static void main(String[] args) throws IOException, InterruptedException, ParseException {
  CommandLineParser parser=new PosixParser();
  CommandLine cmd=null;
  try {
    cmd=parser.parse(options,args);
  }
 catch (  ParseException parseExcep) {
    System.err.println(parseExcep);
    printUsage();
    System.exit(1);
  }
  String host=cmd.getOptionValue(HOST_OPT_LONG);
  int port=defaultPort;
  String portNum=cmd.getOptionValue(PORT_OPT_LONG);
  if (portNum != null) {
    try {
      port=Integer.parseInt(portNum);
    }
 catch (    NumberFormatException e) {
      throw new ParseException(""String_Node_Str"");
    }
  }
  String username=cmd.getOptionValue(USERNAME_OPT_LONG);
  String password=cmd.getOptionValue(PASSWORD_OPT_LONG);
  NodeProbe probe=null;
  try {
    probe=new NodeProbe(host,port,username,password);
  }
 catch (  IOException ioe) {
    System.err.println(""String_Node_Str"");
    ioe.printStackTrace();
    System.exit(3);
  }
  if (cmd.getArgs().length < 1) {
    System.err.println(""String_Node_Str"");
    printUsage();
    System.exit(1);
  }
  NodeCmd nodeCmd=new NodeCmd(probe);
  String[] arguments=cmd.getArgs();
  String cmdName=arguments[0];
  if (cmdName.equals(""String_Node_Str"")) {
    nodeCmd.printRing(System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    nodeCmd.printInfo(System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    if (arguments.length > 1)     probe.forceTableCleanup(arguments[1]);
 else     probe.forceTableCleanup();
  }
 else   if (cmdName.equals(""String_Node_Str"") || cmdName.equals(""String_Node_Str"")) {
    if (arguments.length == 1) {
      if (cmdName.equals(""String_Node_Str""))       probe.forceTableCompaction();
 else       probe.forceTableCleanup();
    }
 else {
      String[] columnFamilies=new String[cmd.getArgs().length - 2];
      for (int i=0; i < columnFamilies.length; i++) {
        columnFamilies[i]=cmd.getArgs()[i + 2];
      }
      if (cmdName.equals(""String_Node_Str"")) {
        probe.forceTableCompaction(arguments[1],columnFamilies);
      }
 else {
        probe.forceTableCleanup(arguments[1],columnFamilies);
      }
    }
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    nodeCmd.printColumnFamilyStats(System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.decommission();
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.loadBalance();
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    if (arguments.length <= 1) {
      System.err.println(""String_Node_Str"");
    }
    probe.move(arguments[1]);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    if (arguments.length <= 1) {
      System.err.println(""String_Node_Str"");
    }
    probe.removeToken(arguments[1]);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    String snapshotName=""String_Node_Str"";
    if (arguments.length > 1) {
      snapshotName=arguments[1];
    }
    probe.takeSnapshot(snapshotName);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.clearSnapshot();
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    nodeCmd.printThreadPoolStats(System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    System.out.println(probe.gossipInfo());
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.gossipStop();
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.gossipStart();
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.gossipPurgePersistent();
  }
 else   if (cmdName.equals(""String_Node_Str"") || cmdName.equals(""String_Node_Str"")) {
    if (cmd.getArgs().length < 2) {
      System.err.println(""String_Node_Str"");
      printUsage();
      System.exit(1);
    }
    String[] columnFamilies=new String[cmd.getArgs().length - 2];
    for (int i=0; i < columnFamilies.length; i++) {
      columnFamilies[i]=cmd.getArgs()[i + 2];
    }
    if (cmdName.equals(""String_Node_Str""))     probe.forceTableFlush(cmd.getArgs()[1],columnFamilies);
 else     probe.forceTableRepair(cmd.getArgs()[1],columnFamilies);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    try {
      probe.drain();
    }
 catch (    ExecutionException ee) {
      System.err.println(""String_Node_Str"");
      ee.printStackTrace();
      System.exit(3);
    }
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    if (cmd.getArgs().length != 5) {
      System.err.println(""String_Node_Str"");
    }
    String tableName=cmd.getArgs()[1];
    String cfName=cmd.getArgs()[2];
    int keyCacheCapacity=Integer.valueOf(cmd.getArgs()[3]);
    int rowCacheCapacity=Integer.valueOf(cmd.getArgs()[4]);
    probe.setCacheCapacities(tableName,cfName,keyCacheCapacity,rowCacheCapacity);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.getCompactionThreshold(System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    if (arguments.length < 2) {
      System.err.println(""String_Node_Str"");
      printUsage();
      System.exit(1);
    }
    int minthreshold=Integer.parseInt(arguments[1]);
    int maxthreshold;
    if (arguments.length > 2) {
      maxthreshold=Integer.parseInt(arguments[2]);
    }
 else {
      maxthreshold=probe.getMaxCompactionThreshold();
    }
    if (minthreshold > maxthreshold) {
      System.err.println(""String_Node_Str"");
      printUsage();
      System.exit(1);
    }
    if (minthreshold < 2 && maxthreshold != 0) {
      System.err.println(""String_Node_Str"");
      printUsage();
      System.exit(1);
    }
    probe.setCompactionThreshold(minthreshold,maxthreshold);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    String otherHost=arguments.length > 1 ? arguments[1] : null;
    nodeCmd.printStreamInfo(otherHost == null ? null : InetAddress.getByName(otherHost),System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    String otherHost=arguments[1];
    probe.cancelStreamOut(host);
    System.out.println(""String_Node_Str"" + otherHost + ""String_Node_Str"");
    nodeCmd.printStreamInfo(otherHost == null ? null : InetAddress.getByName(otherHost),System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    String mbits=arguments[1];
    probe.setStreamingInMBits(Integer.parseInt(mbits));
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    if (arguments.length < 3) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
    nodeCmd.printCfHistograms(arguments[1],arguments[2],System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.completeBootstrap();
  }
 else {
    System.err.println(""String_Node_Str"" + cmdName + ""String_Node_Str"");
    printUsage();
    System.exit(1);
  }
  System.exit(0);
}","public static void main(String[] args) throws IOException, InterruptedException, ParseException {
  CommandLineParser parser=new PosixParser();
  CommandLine cmd=null;
  try {
    cmd=parser.parse(options,args);
  }
 catch (  ParseException parseExcep) {
    System.err.println(parseExcep);
    printUsage();
    System.exit(1);
  }
  String host=cmd.getOptionValue(HOST_OPT_LONG);
  int port=defaultPort;
  String portNum=cmd.getOptionValue(PORT_OPT_LONG);
  if (portNum != null) {
    try {
      port=Integer.parseInt(portNum);
    }
 catch (    NumberFormatException e) {
      throw new ParseException(""String_Node_Str"");
    }
  }
  String username=cmd.getOptionValue(USERNAME_OPT_LONG);
  String password=cmd.getOptionValue(PASSWORD_OPT_LONG);
  NodeProbe probe=null;
  try {
    probe=new NodeProbe(host,port,username,password);
  }
 catch (  IOException ioe) {
    System.err.println(""String_Node_Str"");
    ioe.printStackTrace();
    System.exit(3);
  }
  if (cmd.getArgs().length < 1) {
    System.err.println(""String_Node_Str"");
    printUsage();
    System.exit(1);
  }
  NodeCmd nodeCmd=new NodeCmd(probe);
  String[] arguments=cmd.getArgs();
  String cmdName=arguments[0];
  if (cmdName.equals(""String_Node_Str"")) {
    nodeCmd.printRing(System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    nodeCmd.printInfo(System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    if (arguments.length > 1)     probe.forceTableCleanup(arguments[1]);
 else     probe.forceTableCleanup();
  }
 else   if (cmdName.equals(""String_Node_Str"") || cmdName.equals(""String_Node_Str"")) {
    if (arguments.length == 1) {
      if (cmdName.equals(""String_Node_Str""))       probe.forceTableCompaction();
 else       probe.forceTableCleanup();
    }
 else {
      String[] columnFamilies=new String[cmd.getArgs().length - 2];
      for (int i=0; i < columnFamilies.length; i++) {
        columnFamilies[i]=cmd.getArgs()[i + 2];
      }
      if (cmdName.equals(""String_Node_Str"")) {
        probe.forceTableCompaction(arguments[1],columnFamilies);
      }
 else {
        probe.forceTableCleanup(arguments[1],columnFamilies);
      }
    }
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    nodeCmd.printColumnFamilyStats(System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.decommission();
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.loadBalance();
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    if (arguments.length <= 1) {
      System.err.println(""String_Node_Str"");
    }
    probe.move(arguments[1]);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    if (arguments.length <= 1) {
      System.err.println(""String_Node_Str"");
    }
    probe.removeToken(arguments[1]);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    String snapshotName=""String_Node_Str"";
    if (arguments.length > 1) {
      snapshotName=arguments[1];
    }
    probe.takeSnapshot(snapshotName);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.clearSnapshot();
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    nodeCmd.printThreadPoolStats(System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    System.out.println(probe.gossipInfo());
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.gossipStop();
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.gossipStart();
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.gossipPurgePersistent();
  }
 else   if (cmdName.equals(""String_Node_Str"") || cmdName.equals(""String_Node_Str"")) {
    if (cmd.getArgs().length < 2) {
      System.err.println(""String_Node_Str"");
      printUsage();
      System.exit(1);
    }
    String[] columnFamilies=new String[cmd.getArgs().length - 2];
    for (int i=0; i < columnFamilies.length; i++) {
      columnFamilies[i]=cmd.getArgs()[i + 2];
    }
    if (cmdName.equals(""String_Node_Str""))     probe.forceTableFlush(cmd.getArgs()[1],columnFamilies);
 else     probe.forceTableRepair(cmd.getArgs()[1],columnFamilies);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    try {
      probe.drain();
    }
 catch (    ExecutionException ee) {
      System.err.println(""String_Node_Str"");
      ee.printStackTrace();
      System.exit(3);
    }
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    if (cmd.getArgs().length != 5) {
      System.err.println(""String_Node_Str"");
    }
    String tableName=cmd.getArgs()[1];
    String cfName=cmd.getArgs()[2];
    int keyCacheCapacity=Integer.valueOf(cmd.getArgs()[3]);
    int rowCacheCapacity=Integer.valueOf(cmd.getArgs()[4]);
    probe.setCacheCapacities(tableName,cfName,keyCacheCapacity,rowCacheCapacity);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.getCompactionThreshold(System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    if (arguments.length < 2) {
      System.err.println(""String_Node_Str"");
      printUsage();
      System.exit(1);
    }
    int minthreshold=Integer.parseInt(arguments[1]);
    int maxthreshold;
    if (arguments.length > 2) {
      maxthreshold=Integer.parseInt(arguments[2]);
    }
 else {
      maxthreshold=probe.getMaxCompactionThreshold();
    }
    if (minthreshold > maxthreshold) {
      System.err.println(""String_Node_Str"");
      printUsage();
      System.exit(1);
    }
    if (minthreshold < 2 && maxthreshold != 0) {
      System.err.println(""String_Node_Str"");
      printUsage();
      System.exit(1);
    }
    probe.setCompactionThreshold(minthreshold,maxthreshold);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    String otherHost=arguments.length > 1 ? arguments[1] : null;
    nodeCmd.printStreamInfo(otherHost == null ? null : InetAddress.getByName(otherHost),System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    String otherHost=arguments[1];
    probe.cancelStreamOut(otherHost);
    System.out.println(""String_Node_Str"" + otherHost + ""String_Node_Str"");
    nodeCmd.printStreamInfo(otherHost == null ? null : InetAddress.getByName(otherHost),System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    String mbits=arguments[1];
    probe.setStreamingInMBits(Integer.parseInt(mbits));
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    if (arguments.length < 3) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
    nodeCmd.printCfHistograms(arguments[1],arguments[2],System.out);
  }
 else   if (cmdName.equals(""String_Node_Str"")) {
    probe.completeBootstrap();
  }
 else {
    System.err.println(""String_Node_Str"" + cmdName + ""String_Node_Str"");
    printUsage();
    System.exit(1);
  }
  System.exit(0);
}"
87002,"@Override public void onJoin(InetAddress endpoint,EndPointState epState){
  ApplicationState stateDC=epState.getApplicationState(APPSTATE_DC);
  ApplicationState stateRack=epState.getApplicationState(APPSTATE_RACK);
  String[] location=new String[2];
  location[0]=getDatacenter(endpoint);
  location[1]=getRack(endpoint);
  if (stateDC != null)   location[0]=stateDC.getValue();
  if (stateRack != null)   location[1]=stateRack.getValue();
  if (location[0] == null || location[1] == null) {
    logger.error(""String_Node_Str"" + endpoint + ""String_Node_Str"");
    blockFromJoin(endpoint,epState);
    return;
  }
  if (DatabaseDescriptor.getAllowedLocations() != null && !DatabaseDescriptor.getAllowedLocations().contains(location[0] + ""String_Node_Str"" + location[1])) {
    logger.error(""String_Node_Str"" + endpoint + ""String_Node_Str""+ location[0]+ ""String_Node_Str""+ location[1]+ ""String_Node_Str"");
    blockFromJoin(endpoint,epState);
    return;
  }
  putEndpoints(Collections.singletonMap(endpoint,location));
}","@Override public void onJoin(InetAddress endpoint,EndPointState epState){
  ApplicationState stateDC=epState.getApplicationState(APPSTATE_DC);
  ApplicationState stateRack=epState.getApplicationState(APPSTATE_RACK);
  String[] location=new String[2];
  if (stateDC != null)   location[0]=stateDC.getValue();
  if (stateRack != null)   location[1]=stateRack.getValue();
  if (location[0] == null || location[1] == null) {
    location[0]=getDatacenter(endpoint);
    location[1]=getRack(endpoint);
  }
  if (location[0] == null || location[1] == null) {
    logger.error(""String_Node_Str"" + endpoint + ""String_Node_Str"");
    blockFromJoin(endpoint,epState);
    return;
  }
  if (DatabaseDescriptor.getAllowedLocations() != null && !DatabaseDescriptor.getAllowedLocations().contains(location[0] + ""String_Node_Str"" + location[1])) {
    logger.error(""String_Node_Str"" + endpoint + ""String_Node_Str""+ location[0]+ ""String_Node_Str""+ location[1]+ ""String_Node_Str"");
    blockFromJoin(endpoint,epState);
    return;
  }
  putEndpoints(Collections.singletonMap(endpoint,location));
}"
87003,"/** 
 * @param token either 111.222.333.444 or token string value
 * @return
 */
private InetAddress tokenToEndpoint(String token){
  if (token.matches(""String_Node_Str"")) {
    try {
      InetAddress ip=InetAddress.getByName(token);
      return ip;
    }
 catch (    UnknownHostException e) {
    }
  }
  Token<?> hintToken=StorageService.getPartitioner().getTokenFactory().fromString(token);
  InetAddress endPoint=StorageService.instance.getTokenMetadata().getEndPoint(hintToken);
  return endPoint;
}","/** 
 * @param token either 111.222.333.444 or token string value
 * @return
 */
private InetAddress tokenToEndpoint(String token){
  if (token.matches(""String_Node_Str"")) {
    try {
      InetAddress ip=InetAddress.getByName(token);
      return ip;
    }
 catch (    UnknownHostException e) {
    }
  }
  Token<?> hintToken=StorageService.getPartitioner().getTokenFactory().fromString(token);
  InetAddress endPoint=StorageService.instance.getTokenMetadata().getEndPointHint(hintToken);
  return endPoint;
}"
87004,"private void sync(){
  Collection<Deque<HintLogSegment>> values=segments.values();
  for (  Deque<HintLogSegment> deque : values) {
    HintLogSegment last=deque.peekLast();
    if (last != null)     try {
      last.sync();
      if (last.length() >= SEGMENT_SIZE) {
        last.close();
        getEndpointSegments(last.getToken()).add(new HintLogSegment(last.getToken()));
      }
      if ((deque.size() > 1 || !last.isEmpty()) && HINT_DELIVERY_ON_SYNC) {
        InetAddress endp=tokenToEndpoint(last.getToken());
        if (FailureDetector.instance.isAlive(endp)) {
          HintedHandOffManager.instance().deliverHints(endp);
        }
 else         if (endp == null || !Gossiper.instance.isKnownEndpoint(endp)) {
          logger.info(""String_Node_Str"" + last.getToken() + ""String_Node_Str"");
          for (          HintLogSegment hintLogSegment : deque) {
            hintLogSegment.close();
            hintLogSegment.delete();
          }
          deque.clear();
          deque.add(new HintLogSegment(last.getToken()));
        }
      }
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + last,e);
    }
  }
}","private void sync(){
  Collection<Deque<HintLogSegment>> values=segments.values();
  for (  Deque<HintLogSegment> deque : values) {
    HintLogSegment last=deque.peekLast();
    if (last != null)     try {
      last.sync();
      if (last.length() >= SEGMENT_SIZE) {
        last.close();
        getEndpointSegments(last.getToken()).add(new HintLogSegment(last.getToken()));
      }
      if ((deque.size() > 1 || !last.isEmpty()) && HINT_DELIVERY_ON_SYNC) {
        InetAddress endp=tokenToEndpoint(last.getToken());
        if (endp != null && FailureDetector.instance.isAlive(endp)) {
          HintedHandOffManager.instance().deliverHints(endp);
        }
 else         if (endp == null || !Gossiper.instance.isKnownEndpoint(endp)) {
          logger.info(""String_Node_Str"" + last.getToken() + ""String_Node_Str"");
          for (          HintLogSegment hintLogSegment : deque) {
            hintLogSegment.close();
            hintLogSegment.delete();
          }
          deque.clear();
          deque.add(new HintLogSegment(last.getToken()));
        }
      }
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + last,e);
    }
  }
}"
87005,"private String endpointToToken(InetAddress endpoint){
  Token<?> token=StorageService.instance.getTokenMetadata().getToken(endpoint);
  return StorageService.instance.getPartitioner().getTokenFactory().toString(token);
}","private String endpointToToken(InetAddress endpoint){
  Token<?> token=StorageService.instance.getTokenMetadata().getTokenHint(endpoint);
  return StorageService.instance.getPartitioner().getTokenFactory().toString(token);
}"
87006,"@Override protected void deliverHintsToEndpoint(InetAddress endPoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException {
  queuedDeliveries.remove(endPoint);
  if (logger_.isDebugEnabled())   logger_.debug(""String_Node_Str"" + endPoint.getHostAddress());
  if (!FailureDetector.instance.isAlive(endPoint)) {
    logger_.info(""String_Node_Str"" + endPoint.getHostAddress() + ""String_Node_Str"");
    return;
  }
  long started=System.currentTimeMillis();
  long counter=0;
  Iterator<byte[]> hintsToDeliver=HintLog.instance().getHintsToDeliver(endPoint);
  String throttleRaw=System.getProperty(""String_Node_Str"");
  int throttle=throttleRaw == null ? 0 : Integer.valueOf(throttleRaw);
  if (hintsToDeliver.hasNext())   logger_.info(""String_Node_Str"" + endPoint.getHostAddress());
  HINT_DELIVERY:   while (hintsToDeliver.hasNext()) {
    byte[] rm=hintsToDeliver.next();
    while (!deliverHint(endPoint,rm)) {
      try {
        Thread.sleep(DatabaseDescriptor.getRpcTimeout());
      }
 catch (      InterruptedException e) {
        break HINT_DELIVERY;
      }
      if (!FailureDetector.instance.isAlive(endPoint)) {
        logger_.info(""String_Node_Str"" + endPoint.getHostAddress() + ""String_Node_Str"");
        break HINT_DELIVERY;
      }
    }
    hintsToDeliver.remove();
    counter++;
    if (throttle > 0) {
      try {
        Thread.sleep(throttle);
      }
 catch (      InterruptedException e) {
        throw new AssertionError(e);
      }
    }
  }
  if (counter > 0)   logger_.info(""String_Node_Str"" + endPoint.getHostAddress() + ""String_Node_Str""+ counter+ ""String_Node_Str""+ (System.currentTimeMillis() - started) / 1000 + ""String_Node_Str"");
 else   logger_.info(""String_Node_Str"" + endPoint.getHostAddress() + ""String_Node_Str""+ (System.currentTimeMillis() - started) / 1000 + ""String_Node_Str"");
}","@Override protected void deliverHintsToEndpoint(InetAddress endPoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException {
  queuedDeliveries.remove(endPoint);
  if (logger_.isDebugEnabled())   logger_.debug(""String_Node_Str"" + endPoint.getHostAddress());
  if (!FailureDetector.instance.isAlive(endPoint)) {
    logger_.info(""String_Node_Str"" + endPoint.getHostAddress() + ""String_Node_Str"");
    return;
  }
  if (!StorageService.instance.getTokenMetadata().isMember(endPoint)) {
    return;
  }
  long started=System.currentTimeMillis();
  long counter=0;
  Iterator<byte[]> hintsToDeliver=HintLog.instance().getHintsToDeliver(endPoint);
  String throttleRaw=System.getProperty(""String_Node_Str"");
  int throttle=throttleRaw == null ? 0 : Integer.valueOf(throttleRaw);
  if (hintsToDeliver.hasNext())   logger_.info(""String_Node_Str"" + endPoint.getHostAddress());
  HINT_DELIVERY:   while (hintsToDeliver.hasNext()) {
    byte[] rm=hintsToDeliver.next();
    while (!deliverHint(endPoint,rm)) {
      try {
        Thread.sleep(DatabaseDescriptor.getRpcTimeout());
      }
 catch (      InterruptedException e) {
        break HINT_DELIVERY;
      }
      if (!FailureDetector.instance.isAlive(endPoint)) {
        logger_.info(""String_Node_Str"" + endPoint.getHostAddress() + ""String_Node_Str"");
        break HINT_DELIVERY;
      }
    }
    hintsToDeliver.remove();
    counter++;
    if (throttle > 0) {
      try {
        Thread.sleep(throttle);
      }
 catch (      InterruptedException e) {
        throw new AssertionError(e);
      }
    }
  }
  if (counter > 0)   logger_.info(""String_Node_Str"" + endPoint.getHostAddress() + ""String_Node_Str""+ counter+ ""String_Node_Str""+ (System.currentTimeMillis() - started) / 1000 + ""String_Node_Str"");
 else   logger_.info(""String_Node_Str"" + endPoint.getHostAddress() + ""String_Node_Str""+ (System.currentTimeMillis() - started) / 1000 + ""String_Node_Str"");
}"
87007,"protected ArrayList<InetAddress> doCalculateEndpoints(Token keyToken,TokenMetadata metadata,String table){
  int replicas=DatabaseDescriptor.getReplicationFactor(table);
  ArrayList<InetAddress> endpoints=new ArrayList<InetAddress>(replicas);
  do {
    List<Token> tokens=getReplicaTokens(keyToken,metadata,endpoints.size());
    if (tokens.isEmpty())     return endpoints;
    String keyTokenString=keyToken.toString();
    int domain=Integer.parseInt(keyTokenString.substring(0,2),16) & 0xFF;
    Iterator<Token> iter=TokenMetadata.ringIterator(tokens,keyToken,false);
    do {
      InetAddress endPoint=metadata.getEndPoint(iter.next());
      if (endpoints.contains(endPoint))       endpoints.add(metadata.getEndPoint(iter.next()));
 else       endpoints.add(endPoint);
    }
 while (endpoints.size() < replicas && domain == shuffle(domain));
    domain=shuffle(domain);
    keyToken=odklPartitioner.toStringToken(domain,keyTokenString);
  }
 while (endpoints.size() < replicas);
  return endpoints;
}","protected ArrayList<InetAddress> doCalculateEndpoints(Token keyToken,TokenMetadata metadata,String table){
  int replicas=DatabaseDescriptor.getReplicationFactor(table);
  ArrayList<InetAddress> endpoints=new ArrayList<InetAddress>(replicas);
  do {
    List<Token> tokens=getReplicaTokens(keyToken,metadata,endpoints.size());
    if (tokens.isEmpty())     return endpoints;
    String keyTokenString=keyToken.toString();
    int domain=keyTokenDomain(keyTokenString);
    Iterator<Token> iter=TokenMetadata.ringIterator(tokens,keyToken,false);
    do {
      InetAddress endPoint=metadata.getEndPoint(iter.next());
      if (endpoints.contains(endPoint))       endpoints.add(metadata.getEndPoint(iter.next()));
 else       endpoints.add(endPoint);
    }
 while (endpoints.size() < replicas && domain == shuffle(domain));
    domain=shuffle(domain);
    keyToken=odklPartitioner.toStringToken(domain,keyTokenString);
  }
 while (endpoints.size() < replicas);
  return endpoints;
}"
87008,"/** 
 * Overriden here to have more performant impl
 */
public Collection<InetAddress> getWriteEndpoints(Token token,String table,Collection<InetAddress> naturalEndpoints){
  if (tokenMetadata_.getPendingRanges(table).isEmpty())   return naturalEndpoints;
  Collection<InetAddress> pending=tokenMetadata_.getPendingRanges(table).get(toRange(Integer.parseInt(keyToken(token).toString(),16)));
  if (pending == null || pending.isEmpty())   return naturalEndpoints;
  List<InetAddress> endpoints=new ArrayList<InetAddress>(naturalEndpoints.size() + pending.size());
  endpoints.addAll(naturalEndpoints);
  endpoints.addAll(pending);
  return endpoints;
}","/** 
 * Overriden here to have more performant impl
 */
public Collection<InetAddress> getWriteEndpoints(Token token,String table,Collection<InetAddress> naturalEndpoints){
  if (tokenMetadata_.getPendingRanges(table).isEmpty())   return naturalEndpoints;
  Collection<InetAddress> pending=tokenMetadata_.getPendingRanges(table).get(toRange(keyTokenDomain(keyToken(token).toString())));
  if (pending == null || pending.isEmpty())   return naturalEndpoints;
  List<InetAddress> endpoints=new ArrayList<InetAddress>(naturalEndpoints.size() + pending.size());
  endpoints.addAll(naturalEndpoints);
  endpoints.addAll(pending);
  return endpoints;
}"
87009,"protected ArrayList<InetAddress> doCalculateEndpoints(Token keyToken,TokenMetadata metadata,String table){
  int replicas=DatabaseDescriptor.getReplicationFactor(table);
  ArrayList<InetAddress> endpoints=new ArrayList<InetAddress>(replicas);
  List<Token> tokens=metadata.sortedTokens();
  if (tokens.isEmpty())   return endpoints;
  String[] racks=ringRacks(metadata,tokens).toArray(new String[replicas]);
  StringToken[] rackDomain=new StringToken[replicas];
  int domain=Integer.parseInt(keyToken.toString().substring(0,2),16) & 0xFF;
  int rackIndex=domain % replicas;
  for (int i=0; i < racks.length; i++) {
    rackDomain[i]=odklPartitioner.toStringToken(domain,keyToken.toString());
    domain=shuffle(domain);
  }
  do {
    String rack=racks[rackIndex];
    tokens=getReplicaTokens(metadata,rack);
    keyToken=rackDomain[rackIndex];
    Token t=TokenMetadata.firstToken(tokens,keyToken);
    InetAddress endPoint=metadata.getEndPoint(t);
    endpoints.add(endPoint);
    rackIndex=(rackIndex + 1) % replicas;
  }
 while (endpoints.size() < replicas);
  return endpoints;
}","protected ArrayList<InetAddress> doCalculateEndpoints(Token keyToken,TokenMetadata metadata,String table){
}"
87010,"/** 
 */
public GossipNetworkTopologySnith(){
  if (DatabaseDescriptor.getAllowedLocations() == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 */
public GossipNetworkTopologySnith(){
  if (DatabaseDescriptor.getAllowedLocations() == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  putEndpoints(Collections.singletonMap(FBUtilities.getLocalAddress(),DatabaseDescriptor.getLocation().split(""String_Node_Str"")));
}"
87011,"void put(String key,byte[] buffer) throws IOException {
  if (isThresholdViolated()) {
    lock.lock();
    try {
      if (!isFrozen) {
        isFrozen=true;
        cfs.submitFlush(this);
        cfs.switchBinaryMemtable(key,buffer);
      }
 else {
        cfs.applyBinary(key,buffer);
      }
    }
  finally {
      lock.unlock();
    }
  }
 else {
    resolve(key,buffer);
  }
}","void put(String key,byte[] buffer){
  if (isThresholdViolated()) {
    lock.lock();
    try {
      if (!isFrozen) {
        isFrozen=true;
        cfs.submitFlush(this);
        cfs.switchBinaryMemtable(key,buffer);
      }
 else {
        cfs.applyBinary(key,buffer);
      }
    }
  finally {
      lock.unlock();
    }
  }
 else {
    resolve(key,buffer);
  }
}"
87012,"/** 
 * get a list of columns starting from a given column, in a specified order. only the latest version of a column is returned.
 * @return null if there is no data and no tombstones; otherwise a ColumnFamily
 */
public ColumnFamily getColumnFamily(QueryFilter filter,int gcBefore) throws IOException {
}","/** 
 * get a list of columns starting from a given column, in a specified order. only the latest version of a column is returned.
 * @return null if there is no data and no tombstones; otherwise a ColumnFamily
 */
public ColumnFamily getColumnFamily(QueryFilter filter,int gcBefore){
}"
87013,"private ColumnFamily getTopLevelColumns(QueryFilter filter,int gcBefore) throws IOException {
  List<ColumnIterator> iterators=new ArrayList<ColumnIterator>();
  try {
    final ColumnFamily returnCF;
    ColumnIterator iter;
    Table.flusherLock.readLock().lock();
    try {
      iter=filter.getMemColumnIterator(memtable_,getComparator());
      returnCF=iter.getColumnFamily();
    }
  finally {
      Table.flusherLock.readLock().unlock();
    }
    iterators.add(iter);
    for (    Memtable memtable : getMemtablesPendingFlush()) {
      iter=filter.getMemColumnIterator(memtable,getComparator());
      returnCF.delete(iter.getColumnFamily());
      iterators.add(iter);
    }
    for (    SSTableReader sstable : ssTables_) {
      iter=filter.getSSTableColumnIterator(sstable);
      if (iter.getColumnFamily() != null) {
        returnCF.delete(iter.getColumnFamily());
        iterators.add(iter);
      }
    }
    Comparator<IColumn> comparator=filter.getColumnComparator(getComparator());
    Iterator collated=IteratorUtils.collatedIterator(comparator,iterators);
    filter.collectCollatedColumns(returnCF,collated,gcBefore);
    return removeDeleted(returnCF,gcBefore);
  }
  finally {
    for (    ColumnIterator ci : iterators) {
      try {
        ci.close();
      }
 catch (      Throwable th) {
        logger_.error(""String_Node_Str"" + ci,th);
      }
    }
  }
}","private ColumnFamily getTopLevelColumns(QueryFilter filter,int gcBefore){
  List<ColumnIterator> iterators=new ArrayList<ColumnIterator>();
  try {
    final ColumnFamily returnCF;
    ColumnIterator iter;
    Table.flusherLock.readLock().lock();
    try {
      iter=filter.getMemColumnIterator(memtable_,getComparator());
      returnCF=iter.getColumnFamily();
    }
  finally {
      Table.flusherLock.readLock().unlock();
    }
    iterators.add(iter);
    for (    Memtable memtable : getMemtablesPendingFlush()) {
      iter=filter.getMemColumnIterator(memtable,getComparator());
      returnCF.delete(iter.getColumnFamily());
      iterators.add(iter);
    }
    for (    SSTableReader sstable : ssTables_) {
      iter=filter.getSSTableColumnIterator(sstable);
      if (iter.getColumnFamily() != null) {
        returnCF.delete(iter.getColumnFamily());
        iterators.add(iter);
      }
    }
    Comparator<IColumn> comparator=filter.getColumnComparator(getComparator());
    Iterator collated=IteratorUtils.collatedIterator(comparator,iterators);
    filter.collectCollatedColumns(returnCF,collated,gcBefore);
    return removeDeleted(returnCF,gcBefore);
  }
 catch (  IOException e) {
    throw new FSReadError(e);
  }
 finally {
    for (    ColumnIterator ci : iterators) {
      try {
        ci.close();
      }
 catch (      Throwable th) {
        logger_.error(""String_Node_Str"" + ci,th);
      }
    }
  }
}"
87014,"void applyBinary(String key,byte[] buffer) throws IOException {
  long start=System.nanoTime();
  binaryMemtable_.get().put(key,buffer);
  writeStats_.addNano(System.nanoTime() - start);
}","void applyBinary(String key,byte[] buffer){
  long start=System.nanoTime();
  binaryMemtable_.get().put(key,buffer);
  writeStats_.addNano(System.nanoTime() - start);
}"
87015,"/** 
 * @param super_column
 * @param range: either a Bounds, which includes start key, or a Range, which does not.
 * @param keyMax maximum number of keys to process, regardless of startKey/finishKey
 * @param sliceRange may be null if columnNames is specified. specifies contiguous columns to return in what order.
 * @param columnNames may be null if sliceRange is specified. specifies which columns to return in what order.      @return list of key->list<column> tuples.
 * @throws IOException
 * @throws ExecutionException
 * @throws InterruptedException
 */
public RangeSliceReply getRangeSlice(byte[] super_column,final AbstractBounds range,int keyMax,SliceRange sliceRange,List<byte[]> columnNames) throws IOException, ExecutionException, InterruptedException {
}","/** 
 * @param super_column
 * @param range: either a Bounds, which includes start key, or a Range, which does not.
 * @param keyMax maximum number of keys to process, regardless of startKey/finishKey
 * @param sliceRange may be null if columnNames is specified. specifies contiguous columns to return in what order.
 * @param columnNames may be null if sliceRange is specified. specifies which columns to return in what order.      @return list of key->list<column> tuples.
 * @throws ExecutionException
 * @throws InterruptedException
 */
public RangeSliceReply getRangeSlice(byte[] super_column,final AbstractBounds range,int keyMax,SliceRange sliceRange,List<byte[]> columnNames) throws ExecutionException, InterruptedException {
}"
87016,"public void forceBlockingFlush() throws IOException, ExecutionException, InterruptedException {
  Future<?> future=forceFlush();
  if (future != null)   future.get();
}","public void forceBlockingFlush() throws ExecutionException, InterruptedException {
  Future<?> future=forceFlush();
  if (future != null)   future.get();
}"
87017,"public void forceFlushIfExpired() throws IOException, ExecutionException, InterruptedException {
  if (memtable_.isExpired())   forceBlockingFlush();
}","public void forceFlushIfExpired() throws ExecutionException, InterruptedException {
  if (memtable_.isExpired())   forceBlockingFlush();
}"
87018,"public Table getTable(){
  try {
    return Table.open(table_);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public Table getTable(){
  try {
    return Table.open(table_);
  }
 catch (  IOException e) {
    throw new FSReadError(e);
  }
}"
87019,"private ColumnFamily cacheRow(String key) throws IOException {
  ColumnFamily cached;
  if ((cached=ssTables_.getRowCache().get(key)) == null) {
    cached=getTopLevelColumns(new IdentityQueryFilter(key,new QueryPath(columnFamily_)),Integer.MIN_VALUE);
    if (cached == null)     return null;
    ssTables_.getRowCache().put(key,cached);
  }
  return cached;
}","private ColumnFamily cacheRow(String key){
  ColumnFamily cached;
  if ((cached=ssTables_.getRowCache().get(key)) == null) {
    cached=getTopLevelColumns(new IdentityQueryFilter(key,new QueryPath(columnFamily_)),Integer.MIN_VALUE);
    if (cached == null)     return null;
    ssTables_.getRowCache().put(key,cached);
  }
  return cached;
}"
87020,"/** 
 * flush the given memtable and swap in a new one for its CFS, if it hasn't been frozen already.  threadsafe. 
 */
Future<?> maybeSwitchMemtable(Memtable oldMemtable,final boolean writeCommitLog) throws IOException {
  Table.flusherLock.writeLock().lock();
  try {
    if (oldMemtable.isFrozen()) {
      return null;
    }
    oldMemtable.freeze();
    final Future<CommitLogContext> ctx=writeCommitLog ? CommitLog.instance().getContext() : null;
    final Condition condition=submitFlush(oldMemtable);
    memtable_=new Memtable(this);
    return postFlushExecutor.submit(new WrappedRunnable(){
      public void runMayThrow() throws InterruptedException, IOException {
        condition.await();
        if (writeCommitLog) {
          try {
            CommitLogContext ctxValue=ctx.get();
            logger_.info(columnFamily_ + ""String_Node_Str"" + ctxValue);
            CommitLog.instance().discardCompletedSegments(table_,columnFamily_,ctxValue);
          }
 catch (          ExecutionException e) {
            throw new RuntimeException(e);
          }
        }
      }
    }
);
  }
  finally {
    Table.flusherLock.writeLock().unlock();
    if (memtableSwitchCount == Integer.MAX_VALUE) {
      memtableSwitchCount=0;
    }
    memtableSwitchCount++;
  }
}","/** 
 * flush the given memtable and swap in a new one for its CFS, if it hasn't been frozen already.  threadsafe. 
 */
Future<?> maybeSwitchMemtable(Memtable oldMemtable,final boolean writeCommitLog){
  Table.flusherLock.writeLock().lock();
  try {
    if (oldMemtable.isFrozen()) {
      return null;
    }
    oldMemtable.freeze();
    final Future<CommitLogContext> ctx=writeCommitLog ? CommitLog.instance().getContext() : null;
    final Condition condition=submitFlush(oldMemtable);
    memtable_=new Memtable(this);
    return postFlushExecutor.submit(new WrappedRunnable(){
      public void runMayThrow() throws InterruptedException, IOException {
        condition.await();
        if (writeCommitLog) {
          try {
            CommitLogContext ctxValue=ctx.get();
            logger_.info(columnFamily_ + ""String_Node_Str"" + ctxValue);
            CommitLog.instance().discardCompletedSegments(table_,columnFamily_,ctxValue);
          }
 catch (          ExecutionException e) {
            throw new RuntimeException(e);
          }
        }
      }
    }
);
  }
  finally {
    Table.flusherLock.writeLock().unlock();
    if (memtableSwitchCount == Integer.MAX_VALUE) {
      memtableSwitchCount=0;
    }
    memtableSwitchCount++;
  }
}"
87021,"void switchBinaryMemtable(String key,byte[] buffer) throws IOException {
  binaryMemtable_.set(new BinaryMemtable(this));
  binaryMemtable_.get().put(key,buffer);
}","void switchBinaryMemtable(String key,byte[] buffer){
  binaryMemtable_.set(new BinaryMemtable(this));
  binaryMemtable_.get().put(key,buffer);
}"
87022,"public void initRowCache(){
  String msgSuffix=String.format(""String_Node_Str"",columnFamily_,table_);
  int rowCacheSavePeriodInSeconds=DatabaseDescriptor.getTableMetaData(table_).get(columnFamily_).rowCacheSavePeriodInSeconds;
  int keyCacheSavePeriodInSeconds=DatabaseDescriptor.getTableMetaData(table_).get(columnFamily_).keyCacheSavePeriodInSeconds;
  long start=System.currentTimeMillis();
  try {
    for (    String key : readSavedCache(DatabaseDescriptor.getSerializedRowCachePath(table_,columnFamily_),true))     cacheRow(key);
  }
 catch (  IOException ioe) {
    logger_.warn(""String_Node_Str"" + msgSuffix,ioe);
  }
  if (ssTables_.getRowCache().getSize() > 0)   logger_.info(String.format(""String_Node_Str"",System.currentTimeMillis() - start,ssTables_.getRowCache().getSize(),msgSuffix));
  rowCacheWriteTask=new WrappedRunnable(){
    protected void runMayThrow() throws IOException {
      ssTables_.saveRowCache();
    }
  }
;
  if (rowCacheSavePeriodInSeconds > 0) {
    cacheSavingExecutor.scheduleWithFixedDelay(rowCacheWriteTask,rowCacheSavePeriodInSeconds,rowCacheSavePeriodInSeconds,TimeUnit.SECONDS);
  }
  keyCacheWriteTask=new WrappedRunnable(){
    protected void runMayThrow() throws IOException {
      ssTables_.saveKeyCache();
    }
  }
;
  if (keyCacheSavePeriodInSeconds > 0) {
    cacheSavingExecutor.scheduleWithFixedDelay(keyCacheWriteTask,keyCacheSavePeriodInSeconds,keyCacheSavePeriodInSeconds,TimeUnit.SECONDS);
  }
}","public void initRowCache(){
  String msgSuffix=String.format(""String_Node_Str"",columnFamily_,table_);
  int rowCacheSavePeriodInSeconds=DatabaseDescriptor.getTableMetaData(table_).get(columnFamily_).rowCacheSavePeriodInSeconds;
  int keyCacheSavePeriodInSeconds=DatabaseDescriptor.getTableMetaData(table_).get(columnFamily_).keyCacheSavePeriodInSeconds;
  long start=System.currentTimeMillis();
  for (  String key : readSavedCache(DatabaseDescriptor.getSerializedRowCachePath(table_,columnFamily_),true)) {
    cacheRow(key);
  }
  if (ssTables_.getRowCache().getSize() > 0)   logger_.info(String.format(""String_Node_Str"",System.currentTimeMillis() - start,ssTables_.getRowCache().getSize(),msgSuffix));
  rowCacheWriteTask=new WrappedRunnable(){
    protected void runMayThrow() throws IOException {
      ssTables_.saveRowCache();
    }
  }
;
  if (rowCacheSavePeriodInSeconds > 0) {
    cacheSavingExecutor.scheduleWithFixedDelay(rowCacheWriteTask,rowCacheSavePeriodInSeconds,rowCacheSavePeriodInSeconds,TimeUnit.SECONDS);
  }
  keyCacheWriteTask=new WrappedRunnable(){
    protected void runMayThrow() throws IOException {
      ssTables_.saveKeyCache();
    }
  }
;
  if (keyCacheSavePeriodInSeconds > 0) {
    cacheSavingExecutor.scheduleWithFixedDelay(keyCacheWriteTask,keyCacheSavePeriodInSeconds,keyCacheSavePeriodInSeconds,TimeUnit.SECONDS);
  }
}"
87023,"/** 
 * @param range: either a Bounds, which includes start key, or a Range, which does not.
 * @param maxResults
 * @return list of keys between startWith and stopAtTODO refactor better.  this is just getKeyRange w/o the deletion check, for the benefit of range_slice.  still opens one randomaccessfile per key, which sucks.  something like compactioniterator would be better.
 */
private void getKeyRange(List<String> keys,final AbstractBounds range,int maxResults) throws IOException, ExecutionException, InterruptedException {
}","/** 
 * @param range: either a Bounds, which includes start key, or a Range, which does not.
 * @param maxResults
 * @return list of keys between startWith and stopAtTODO refactor better.  this is just getKeyRange w/o the deletion check, for the benefit of range_slice.  still opens one randomaccessfile per key, which sucks.  something like compactioniterator would be better.
 */
private void getKeyRange(List<String> keys,final AbstractBounds range,int maxResults) throws ExecutionException, InterruptedException {
}"
87024,"void replaceCompactedSSTables(Collection<SSTableReader> sstables,Iterable<SSTableReader> replacements) throws IOException {
  ssTables_.replace(sstables,replacements);
}","void replaceCompactedSSTables(Collection<SSTableReader> sstables,Iterable<SSTableReader> replacements){
  ssTables_.replace(sstables,replacements);
}"
87025,"public Future<?> forceFlush() throws IOException {
  if (memtable_.isClean())   return null;
  return maybeSwitchMemtable(memtable_,true);
}","public Future<?> forceFlush(){
  if (memtable_.isClean())   return null;
  return maybeSwitchMemtable(memtable_,true);
}"
87026,"/** 
 * Given a column family this, function creates an in-memory structure that represents the column index for the column family, and subsequently writes it to disk.
 * @param columnFamily Column family to create index for
 * @param dos data output stream
 * @param skipBloom true to skip bloom filter write for this column family when not needed (if columnBloom mode is activated, for example, or. say, you dont have SSTableNamesIterator queries)
 * @throws IOException
 */
public static void serialize(ColumnFamily columnFamily,DataOutput dos,boolean skipBloom){
  Collection<IColumn> columns=columnFamily.getSortedColumns();
  try {
    if (skipBloom) {
      dos.writeInt(0);
    }
 else {
      BloomFilter bf=createColumnBloomFilter(columns);
      BloomFilterSerializer serializer=(BloomFilterSerializer)BloomFilter.serializer();
      dos.writeInt((int)serializer.serializeSize(bf));
      serializer.serialize(bf,dos);
    }
    doIndexing(columnFamily.getComparator(),columns,dos);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Given a column family this, function creates an in-memory structure that represents the column index for the column family, and subsequently writes it to disk.
 * @param columnFamily Column family to create index for
 * @param dos data output stream
 * @param skipBloom true to skip bloom filter write for this column family when not needed (if columnBloom mode is activated, for example, or. say, you dont have SSTableNamesIterator queries)
 * @throws IOException
 */
public static void serialize(ColumnFamily columnFamily,DataOutput dos,boolean skipBloom){
  Collection<IColumn> columns=columnFamily.getSortedColumns();
  try {
    if (skipBloom) {
      dos.writeInt(0);
    }
 else {
      BloomFilter bf=createColumnBloomFilter(columns);
      BloomFilterSerializer serializer=(BloomFilterSerializer)BloomFilter.serializer();
      dos.writeInt((int)serializer.serializeSize(bf));
      serializer.serialize(bf,dos);
    }
    doIndexing(columnFamily.getComparator(),columns,dos);
  }
 catch (  IOException e) {
    throw new FSWriteError(e);
  }
}"
87027,"private SSTableReader writeSortedContents() throws IOException {
  logger.info(""String_Node_Str"" + this);
  SSTableWriter writer=new SSTableWriter(cfs.getFlushPath(),columnFamilies.size(),StorageService.getPartitioner());
  boolean bloomColumns=writer.getBloomFilterWriter().isBloomColumns();
  BloomFilterWriter bloomFilterWriter=writer.getBloomFilterWriter();
  if (bloomColumns)   bloomFilterWriter.setEstimatedColumnCount(getCurrentOperations());
  DataOutputBuffer buffer=new DataOutputBuffer();
  for (  Map.Entry<DecoratedKey,ColumnFamily> entry : columnFamilies.entrySet()) {
    buffer.reset();
    ColumnFamily.serializer().serializeWithIndexes(entry.getValue(),buffer,bloomColumns);
    writer.append(entry.getKey(),buffer);
    if (bloomColumns)     bloomFilterWriter.add(entry.getKey(),entry.getValue());
  }
  SSTableReader ssTable=writer.closeAndOpenReader();
  logger.info(String.format(""String_Node_Str"",ssTable.getFilename(),new File(ssTable.getFilename()).length()));
  return ssTable;
}","private SSTableReader writeSortedContents(){
  try {
    logger.info(""String_Node_Str"" + this);
    SSTableWriter writer=new SSTableWriter(cfs.getFlushPath(),columnFamilies.size(),StorageService.getPartitioner());
    boolean bloomColumns=writer.getBloomFilterWriter().isBloomColumns();
    BloomFilterWriter bloomFilterWriter=writer.getBloomFilterWriter();
    if (bloomColumns)     bloomFilterWriter.setEstimatedColumnCount(getCurrentOperations());
    DataOutputBuffer buffer=new DataOutputBuffer();
    for (    Map.Entry<DecoratedKey,ColumnFamily> entry : columnFamilies.entrySet()) {
      buffer.reset();
      ColumnFamily.serializer().serializeWithIndexes(entry.getValue(),buffer,bloomColumns);
      writer.append(entry.getKey(),buffer);
      if (bloomColumns)       bloomFilterWriter.add(entry.getKey(),entry.getValue());
    }
    SSTableReader ssTable=writer.closeAndOpenReader();
    logger.info(String.format(""String_Node_Str"",ssTable.getFilename(),new File(ssTable.getFilename()).length()));
    return ssTable;
  }
 catch (  IOException e) {
    throw new FSWriteError(e);
  }
}"
87028,"private void reBuffer() throws IOException {
  flush();
  bufferOffset=current;
  if (bufferOffset >= channel.size()) {
    validBufferBytes=0;
    return;
  }
  if (bufferOffset < minBufferOffset)   minBufferOffset=bufferOffset;
  channel.position(bufferOffset);
  int read=0;
  while (read < buffer.length) {
    int n=super.read(buffer,read,buffer.length - read);
    if (n < 0)     break;
    read+=n;
  }
  validBufferBytes=read;
  bytesSinceCacheFlush+=read;
  if (skipCache && bytesSinceCacheFlush >= MAX_BYTES_IN_PAGE_CACHE) {
    CLibrary.trySkipCache(this.fd,(int)minBufferOffset,0);
    bytesSinceCacheFlush=0;
    minBufferOffset=Long.MAX_VALUE;
  }
}","private void reBuffer() throws IOException {
  flush();
  resetBuffer();
  if (bufferOffset >= channel.size())   return;
  if (bufferOffset < minBufferOffset)   minBufferOffset=bufferOffset;
  channel.position(bufferOffset);
  int read=0;
  while (read < buffer.length) {
    int n=super.read(buffer,read,buffer.length - read);
    if (n < 0)     break;
    read+=n;
  }
  validBufferBytes=read;
  bytesSinceCacheFlush+=read;
  if (skipCache && bytesSinceCacheFlush >= MAX_BYTES_IN_PAGE_CACHE) {
    CLibrary.trySkipCache(this.fd,(int)minBufferOffset,0);
    bytesSinceCacheFlush=0;
    minBufferOffset=Long.MAX_VALUE;
  }
}"
87029,"public void sync() throws IOException {
  if (syncNeeded) {
    flush();
    channel.force(true);
    if (skipCache) {
      CLibrary.trySkipCache(this.fd,0,0);
      minBufferOffset=Long.MAX_VALUE;
      bytesSinceCacheFlush=0;
    }
    syncNeeded=false;
  }
}","/** 
 * Flush (flush()) whatever writes are pending, and block until the data has been persistently committed (fsync()).
 */
public void sync() throws IOException {
  if (syncNeeded) {
    flush();
    channel.force(true);
    if (skipCache) {
      CLibrary.trySkipCache(this.fd,0,0);
      minBufferOffset=Long.MAX_VALUE;
      bytesSinceCacheFlush=0;
    }
    syncNeeded=false;
  }
}"
87030,"public void flush() throws IOException {
  if (isDirty) {
    if (channel.position() != bufferOffset)     channel.position(bufferOffset);
    super.write(buffer,0,validBufferBytes);
    if (skipCache) {
      bytesSinceCacheFlush+=validBufferBytes;
      if (bufferOffset < minBufferOffset)       minBufferOffset=bufferOffset;
      if (bytesSinceCacheFlush >= MAX_BYTES_IN_PAGE_CACHE) {
        CLibrary.trySkipCache(this.fd,(int)minBufferOffset,0);
        minBufferOffset=bufferOffset;
        bytesSinceCacheFlush=0;
      }
    }
    isDirty=false;
  }
}","/** 
 * If we are dirty, flush dirty contents to the operating system. Does not imply fsync(). Currently, for implementation reasons, this also invalidates the buffer.
 */
public void flush() throws IOException {
  if (isDirty) {
    if (channel.position() != bufferOffset)     channel.position(bufferOffset);
    super.write(buffer,0,validBufferBytes);
    if (skipCache) {
      bytesSinceCacheFlush+=validBufferBytes;
      if (bufferOffset < minBufferOffset)       minBufferOffset=bufferOffset;
      if (bytesSinceCacheFlush >= MAX_BYTES_IN_PAGE_CACHE) {
        CLibrary.trySkipCache(this.fd,(int)minBufferOffset,0);
        minBufferOffset=bufferOffset;
        bytesSinceCacheFlush=0;
      }
    }
    resetBuffer();
    isDirty=false;
  }
}"
87031,"private String createForeignKeyForTable(final ColumnMetaData columnMetaData,final int counter){
  final TableMetaData tableMetaData=columnMetaData.getTableMetaData();
  final String schemaPrefix=""String_Node_Str"".equals(_targetSchema) ? ""String_Node_Str"" : _targetSchema + ""String_Node_Str"";
  final ColumnMetaData referencedColumn=columnMetaData.getReferencedColumn();
  final String tablename=_caseConversionMode.convert(tableMetaData.getTableName());
  final StringBuilder builder=new StringBuilder(""String_Node_Str"" + schemaPrefix + tablename+ ""String_Node_Str"");
  final String foreignkeyName=tablename + ""String_Node_Str"" + _caseConversionMode.convert(columnMetaData.getColumnName())+ ""String_Node_Str""+ _caseConversionMode.convert(referencedColumn.getColumnName());
  builder.append(""String_Node_Str"" + (foreignkeyName.length() > 55 ? foreignkeyName.substring(0,55) : foreignkeyName) + ""String_Node_Str""+ counter);
  builder.append(""String_Node_Str"" + _caseConversionMode.convert(columnMetaData.getColumnName()) + ""String_Node_Str""+ schemaPrefix+ _caseConversionMode.convert(referencedColumn.getTableMetaData().getTableName())+ ""String_Node_Str""+ _caseConversionMode.convert(referencedColumn.getColumnName())+ ""String_Node_Str"");
  return builder.toString();
}","private String createForeignKeyForTable(final ColumnMetaData columnMetaData,final int counter){
  final TableMetaData tableMetaData=columnMetaData.getTableMetaData();
  final String schemaPrefix=""String_Node_Str"".equals(_targetSchema) ? ""String_Node_Str"" : _targetSchema + ""String_Node_Str"";
  final ColumnMetaData referencedColumn=columnMetaData.getReferencedColumn();
  final String tablename=_caseConversionMode.convert(tableMetaData.getTableName());
  final StringBuilder builder=new StringBuilder(""String_Node_Str"" + schemaPrefix + tablename+ ""String_Node_Str"");
  builder.append(""String_Node_Str"" + tablename + ""String_Node_Str""+ _caseConversionMode.convert(columnMetaData.getColumnName())+ ""String_Node_Str""+ _caseConversionMode.convert(referencedColumn.getColumnName())+ ""String_Node_Str""+ counter);
  builder.append(""String_Node_Str"" + _caseConversionMode.convert(columnMetaData.getColumnName()) + ""String_Node_Str""+ schemaPrefix+ _caseConversionMode.convert(referencedColumn.getTableMetaData().getTableName())+ ""String_Node_Str""+ _caseConversionMode.convert(referencedColumn.getColumnName())+ ""String_Node_Str"");
  return builder.toString();
}"
87032,"private String createForeignKeyForTable(final ColumnMetaData columnMetaData,int counter){
  final TableMetaData tableMetaData=columnMetaData.getTableMetaData();
  final String schemaPrefix=""String_Node_Str"".equals(_targetSchema) ? ""String_Node_Str"" : _targetSchema + ""String_Node_Str"";
  final ColumnMetaData referencedColumn=columnMetaData.getReferencedColumn();
  final String tablename=_caseConversionMode.convert(tableMetaData.getTableName());
  final StringBuilder builder=new StringBuilder(""String_Node_Str"" + schemaPrefix + tablename+ ""String_Node_Str"");
  final String foreignkeyName=tablename + ""String_Node_Str"" + _caseConversionMode.convert(columnMetaData.getColumnName())+ ""String_Node_Str""+ _caseConversionMode.convert(referencedColumn.getColumnName());
  builder.append(""String_Node_Str"" + (foreignkeyName.length() > 55 ? foreignkeyName.substring(0,55) : foreignkeyName) + ""String_Node_Str""+ counter++);
  builder.append(""String_Node_Str"" + _caseConversionMode.convert(columnMetaData.getColumnName()) + ""String_Node_Str""+ schemaPrefix+ _caseConversionMode.convert(referencedColumn.getTableMetaData().getTableName())+ ""String_Node_Str""+ _caseConversionMode.convert(referencedColumn.getColumnName())+ ""String_Node_Str"");
  return builder.toString();
}","private String createForeignKeyForTable(final ColumnMetaData columnMetaData,final int counter){
  final TableMetaData tableMetaData=columnMetaData.getTableMetaData();
  final String schemaPrefix=""String_Node_Str"".equals(_targetSchema) ? ""String_Node_Str"" : _targetSchema + ""String_Node_Str"";
  final ColumnMetaData referencedColumn=columnMetaData.getReferencedColumn();
  final String tablename=_caseConversionMode.convert(tableMetaData.getTableName());
  final StringBuilder builder=new StringBuilder(""String_Node_Str"" + schemaPrefix + tablename+ ""String_Node_Str"");
  final String foreignkeyName=tablename + ""String_Node_Str"" + _caseConversionMode.convert(columnMetaData.getColumnName())+ ""String_Node_Str""+ _caseConversionMode.convert(referencedColumn.getColumnName());
  builder.append(""String_Node_Str"" + (foreignkeyName.length() > 55 ? foreignkeyName.substring(0,55) : foreignkeyName) + ""String_Node_Str""+ counter);
  builder.append(""String_Node_Str"" + _caseConversionMode.convert(columnMetaData.getColumnName()) + ""String_Node_Str""+ schemaPrefix+ _caseConversionMode.convert(referencedColumn.getTableMetaData().getTableName())+ ""String_Node_Str""+ _caseConversionMode.convert(referencedColumn.getColumnName())+ ""String_Node_Str"");
  return builder.toString();
}"
87033,"public List<String> createForeignKeyStatements() throws SQLException {
  final List<String> result=new ArrayList<String>();
  for (  final TableMetaData tableMetaData : _sourceDatabaseMetaData.getTableMetaData()) {
    final int counter=1;
    final List<ColumnMetaData> columns=tableMetaData.getColumnMetaData();
    for (    final ColumnMetaData columnMetaData : columns) {
      if (columnMetaData.getReferencedColumn() != null) {
        result.add(createForeignKeyForTable(columnMetaData,counter));
      }
    }
  }
  return result;
}","public List<String> createForeignKeyStatements() throws SQLException {
  final List<String> result=new ArrayList<String>();
  for (  final TableMetaData tableMetaData : _sourceDatabaseMetaData.getTableMetaData()) {
    int counter=1;
    final List<ColumnMetaData> columns=tableMetaData.getColumnMetaData();
    for (    final ColumnMetaData columnMetaData : columns) {
      if (columnMetaData.getReferencedColumn() != null) {
        result.add(createForeignKeyForTable(columnMetaData,counter++));
      }
    }
  }
  return result;
}"
87034,"public List<String> createIndexStatements() throws SQLException {
  final List<String> result=new ArrayList<String>();
  for (  final TableMetaData tableMetaData : _sourceDatabaseMetaData.getTableMetaData()) {
    final int counter=1;
    final List<IndexMetaData> indexes=tableMetaData.getIndexes();
    for (    final IndexMetaData indexMetaData : indexes) {
      result.add(createIndexesForTable(indexMetaData,counter));
    }
  }
  return result;
}","public List<String> createIndexStatements() throws SQLException {
  final List<String> result=new ArrayList<String>();
  for (  final TableMetaData tableMetaData : _sourceDatabaseMetaData.getTableMetaData()) {
    int counter=1;
    final List<IndexMetaData> indexes=tableMetaData.getIndexes();
    for (    final IndexMetaData indexMetaData : indexes) {
      result.add(createIndexesForTable(indexMetaData,counter++));
    }
  }
  return result;
}"
87035,"private String createPrimaryKeyStatement(final TableMetaData tableMetaData,final List<ColumnMetaData> primaryKeyColumns,int counter){
  final String tableName=_caseConversionMode.convert(tableMetaData.getTableName());
  final StringBuilder builder=new StringBuilder(""String_Node_Str"" + (""String_Node_Str"".equals(_targetSchema) ? ""String_Node_Str"" : _targetSchema + ""String_Node_Str"") + tableName+ ""String_Node_Str""+ tableName+ ""String_Node_Str""+ counter+++ ""String_Node_Str"");
  for (  final ColumnMetaData columnMetaData : primaryKeyColumns) {
    builder.append(_caseConversionMode.convert(columnMetaData.getColumnName()) + ""String_Node_Str"");
  }
  builder.setLength(builder.length() - 2);
  builder.append(""String_Node_Str"");
  return builder.toString();
}","private String createPrimaryKeyStatement(final TableMetaData tableMetaData,final List<ColumnMetaData> primaryKeyColumns,final int counter){
  final String tableName=_caseConversionMode.convert(tableMetaData.getTableName());
  final StringBuilder builder=new StringBuilder(""String_Node_Str"" + (""String_Node_Str"".equals(_targetSchema) ? ""String_Node_Str"" : _targetSchema + ""String_Node_Str"") + tableName+ ""String_Node_Str""+ tableName+ ""String_Node_Str""+ counter+ ""String_Node_Str"");
  for (  final ColumnMetaData columnMetaData : primaryKeyColumns) {
    builder.append(_caseConversionMode.convert(columnMetaData.getColumnName()) + ""String_Node_Str"");
  }
  builder.setLength(builder.length() - 2);
  builder.append(""String_Node_Str"");
  return builder.toString();
}"
87036,"public List<String> createPrimaryKeyStatements() throws SQLException {
  final List<String> result=new ArrayList<String>();
  for (  final TableMetaData tableMetaData : _sourceDatabaseMetaData.getTableMetaData()) {
    final int counter=1;
    final List<ColumnMetaData> primaryKeyColumns=tableMetaData.getPrimaryKeyColumns();
    if (!primaryKeyColumns.isEmpty()) {
      result.add(createPrimaryKeyStatement(tableMetaData,primaryKeyColumns,counter));
    }
  }
  return result;
}","public List<String> createPrimaryKeyStatements() throws SQLException {
  final List<String> result=new ArrayList<String>();
  for (  final TableMetaData tableMetaData : _sourceDatabaseMetaData.getTableMetaData()) {
    int counter=1;
    final List<ColumnMetaData> primaryKeyColumns=tableMetaData.getPrimaryKeyColumns();
    if (!primaryKeyColumns.isEmpty()) {
      result.add(createPrimaryKeyStatement(tableMetaData,primaryKeyColumns,counter++));
    }
  }
  return result;
}"
87037,"private String createIndexesForTable(final IndexMetaData indexMetaData,int counter){
  final TableMetaData tableMetaData=indexMetaData.getTableMetaData();
  final String schemaPrefix=""String_Node_Str"".equals(_targetSchema) ? ""String_Node_Str"" : _targetSchema + ""String_Node_Str"";
  final String unique=indexMetaData.isUnique() ? ""String_Node_Str"" : ""String_Node_Str"";
  final StringBuilder builder=new StringBuilder(""String_Node_Str"" + unique + ""String_Node_Str""+ _caseConversionMode.convert(indexMetaData.getIndexName())+ ""String_Node_Str""+ _caseConversionMode.convert(tableMetaData.getTableName())+ ""String_Node_Str""+ counter+++ ""String_Node_Str""+ schemaPrefix+ _caseConversionMode.convert(tableMetaData.getTableName())+ ""String_Node_Str"");
  for (final Iterator<ColumnMetaData> iterator=indexMetaData.getColumnMetaData().iterator(); iterator.hasNext(); ) {
    final ColumnMetaData columnMetaData=iterator.next();
    builder.append(_caseConversionMode.convert(columnMetaData.getColumnName()));
    if (iterator.hasNext()) {
      builder.append(""String_Node_Str"");
    }
  }
  builder.append(""String_Node_Str"");
  return builder.toString();
}","private String createIndexesForTable(final IndexMetaData indexMetaData,final int counter){
  final TableMetaData tableMetaData=indexMetaData.getTableMetaData();
  final String schemaPrefix=""String_Node_Str"".equals(_targetSchema) ? ""String_Node_Str"" : _targetSchema + ""String_Node_Str"";
  final String unique=indexMetaData.isUnique() ? ""String_Node_Str"" : ""String_Node_Str"";
  final StringBuilder builder=new StringBuilder(""String_Node_Str"" + unique + ""String_Node_Str""+ _caseConversionMode.convert(indexMetaData.getIndexName())+ ""String_Node_Str""+ _caseConversionMode.convert(tableMetaData.getTableName())+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ schemaPrefix+ _caseConversionMode.convert(tableMetaData.getTableName())+ ""String_Node_Str"");
  for (final Iterator<ColumnMetaData> iterator=indexMetaData.getColumnMetaData().iterator(); iterator.hasNext(); ) {
    final ColumnMetaData columnMetaData=iterator.next();
    builder.append(_caseConversionMode.convert(columnMetaData.getColumnName()));
    if (iterator.hasNext()) {
      builder.append(""String_Node_Str"");
    }
  }
  builder.append(""String_Node_Str"");
  return builder.toString();
}"
87038,"@Override public String toString(){
  return _tableMetaData.getTableName() + ""String_Node_Str"" + getReferencedTables()+ ""String_Node_Str""+ getReferencedByTables();
}","private static String toString(final List<TableNode> referencedTables){
  List<String> result=new ArrayList<String>();
  for (  TableNode tableNode : referencedTables) {
    result.add(tableNode.getTableMetaData().getTableName());
  }
  return result.toString();
}"
87039,"public void addDroppedColumn(final String targetTableName,final String sourceColumName){
}","public DroppingColumnMapper addDroppedColumn(final String targetTableName,final String sourceColumName){
}"
87040,"private void checkTableData(final String sourceConnectorId,final Connection sourceConnection,final SourceDatabaseConfiguration sourceConfiguration,final TableMetaData sourceTableMetaData,final String targetConnectorId,final Connection targetConnection,final SourceDatabaseConfiguration targetConfiguration,final TableMetaData targetTableMetaData,final int numberOfCheckData) throws SQLException {
  final String tableName1=_connectorRepository.getConnectorHint(sourceConnectorId,TableNameMapper.class).getValue().mapTableName(sourceTableMetaData);
  final String tableName2=_connectorRepository.getConnectorHint(targetConnectorId,TableNameMapper.class).getValue().mapTableName(targetTableMetaData);
  final CommonColumnTypeResolverTool commonColumnTypeResolver=new CommonColumnTypeResolverTool(_connectorRepository);
  final ColumnNameMapper sourceColumnNameMapper=_connectorRepository.getConnectorHint(sourceConnectorId,ColumnNameMapper.class).getValue();
  final ColumnNameMapper targetColumnNameMapper=_connectorRepository.getConnectorHint(targetConnectorId,ColumnNameMapper.class).getValue();
  if (sourceTableMetaData.getRowCount() != targetTableMetaData.getRowCount()) {
    throw new UnequalNumberOfRowsException(""String_Node_Str"" + tableName1 + ""String_Node_Str""+ sourceTableMetaData.getRowCount()+ ""String_Node_Str""+ tableName2+ ""String_Node_Str""+ targetTableMetaData.getRowCount());
  }
  LOG.info(""String_Node_Str"" + tableName1 + ""String_Node_Str""+ tableName2+ ""String_Node_Str"");
  final PreparedStatement selectStatement1=new SelectStatementCreator(_connectorRepository,sourceConnectorId).createSelectStatement(tableName1,sourceTableMetaData,sourceConnection);
  selectStatement1.setFetchSize(numberOfCheckData);
  sourceConfiguration.beforeSelect(sourceConnection,sourceConnectorId,sourceTableMetaData);
  final ResultSet resultSet1=selectStatement1.executeQuery();
  sourceConfiguration.afterSelect(sourceConnection,sourceConnectorId,sourceTableMetaData);
  final PreparedStatement selectStatement2=new SelectStatementCreator(_connectorRepository,targetConnectorId).createMappedSelectStatement(sourceTableMetaData,tableName2,targetTableMetaData,targetConnection,sourceConnectorId);
  selectStatement2.setFetchSize(numberOfCheckData);
  targetConfiguration.beforeSelect(targetConnection,targetConnectorId,targetTableMetaData);
  final ResultSet resultSet2=selectStatement2.executeQuery();
  targetConfiguration.afterSelect(targetConnection,targetConnectorId,targetTableMetaData);
  final List<ColumnMetaData> orderedSourceColumns=ColumnOrderHint.getSortedColumns(_connectorRepository,sourceConnectorId,sourceTableMetaData);
  final ColumnMapper columnMapper=_connectorRepository.getConnectorHint(targetConnectorId,ColumnMapper.class).getValue();
  int rowIndex=1;
  try {
    while (resultSet1.next() && resultSet2.next() && rowIndex <= numberOfCheckData) {
      for (int columnIndex=1; columnIndex <= orderedSourceColumns.size(); columnIndex++) {
        final ColumnMetaData sourceColumn=orderedSourceColumns.get(columnIndex - 1);
        final ColumnMapperResult mapping=columnMapper.map(sourceColumn,targetTableMetaData);
        for (        final ColumnMetaData columnMetaData2 : mapping.getColumns()) {
          final ColumnTypeMapping columnTypeMapping=commonColumnTypeResolver.getCommonColumnTypeMapping(sourceConnectorId,sourceColumn,targetConnectorId,columnMetaData2);
          final String columnName1=sourceColumnNameMapper.mapColumnName(sourceColumn);
          final String columnName2=targetColumnNameMapper.mapColumnName(columnMetaData2);
          if (columnTypeMapping == null) {
            throw new IncompatibleColumnsException(tableName1 + ""String_Node_Str"" + columnName1+ ""String_Node_Str""+ sourceColumn.getColumnTypeName()+ ""String_Node_Str""+ columnName2+ ""String_Node_Str""+ columnMetaData2.getColumnTypeName());
          }
          final ColumnType sourceColumnType=columnTypeMapping.getSourceColumnType();
          Object data1=sourceColumnType.getValue(resultSet1,columnIndex);
          data1=columnTypeMapping.getColumnDataMapper().map(sourceColumn,columnMetaData2,data1);
          Object data2=columnTypeMapping.getTargetColumnType().getValue(resultSet2,columnIndex);
switch (sourceColumnType) {
case CLASS_STRING:
            final ConnectorInfo connectionInfo1=_connectorRepository.getConnectionInfo(sourceConnectorId);
          final ConnectorInfo connectionInfo2=_connectorRepository.getConnectionInfo(targetConnectorId);
        if (DatabaseType.POSTGRESQL.equals(connectionInfo1.getDatabaseType()) || DatabaseType.POSTGRESQL.equals(connectionInfo2.getDatabaseType())) {
          data1=trim((String)data1);
          data2=trim((String)data2);
        }
      break;
case CLASS_BLOB:
    final Blob blob1=(Blob)data1;
  final Blob blob2=(Blob)data2;
data1=createStringFromBlob(blob1);
data2=createStringFromBlob(blob2);
break;
}
if ((data1 == null && data2 != null) || (data1 != null && data2 == null)) {
throw createIncompatibleDataException(tableName1,rowIndex,sourceColumnType,columnName1,data1,data2);
}
 else if (data1 != null && data2 != null && !data1.equals(data2)) {
throw createIncompatibleDataException(tableName1,rowIndex,sourceColumnType,columnName1,data1,data2);
}
}
}
rowIndex++;
}
}
  finally {
try {
resultSet1.close();
selectStatement1.close();
resultSet2.close();
selectStatement2.close();
}
 catch (final Exception e) {
}
}
LOG.info(""String_Node_Str"" + tableName1 + ""String_Node_Str""+ tableName2+ ""String_Node_Str"");
}","private void checkTableData(final String sourceConnectorId,final Connection sourceConnection,final SourceDatabaseConfiguration sourceConfiguration,final TableMetaData sourceTableMetaData,final String targetConnectorId,final Connection targetConnection,final SourceDatabaseConfiguration targetConfiguration,final TableMetaData targetTableMetaData,final int numberOfCheckData) throws SQLException {
  final String tableName1=_connectorRepository.getConnectorHint(sourceConnectorId,TableNameMapper.class).getValue().mapTableName(sourceTableMetaData);
  final String tableName2=_connectorRepository.getConnectorHint(targetConnectorId,TableNameMapper.class).getValue().mapTableName(targetTableMetaData);
  final CommonColumnTypeResolverTool commonColumnTypeResolver=new CommonColumnTypeResolverTool(_connectorRepository);
  final ColumnNameMapper sourceColumnNameMapper=_connectorRepository.getConnectorHint(sourceConnectorId,ColumnNameMapper.class).getValue();
  final ColumnNameMapper targetColumnNameMapper=_connectorRepository.getConnectorHint(targetConnectorId,ColumnNameMapper.class).getValue();
  if (sourceTableMetaData.getRowCount() != targetTableMetaData.getRowCount()) {
    throw new UnequalNumberOfRowsException(""String_Node_Str"" + tableName1 + ""String_Node_Str""+ sourceTableMetaData.getRowCount()+ ""String_Node_Str""+ tableName2+ ""String_Node_Str""+ targetTableMetaData.getRowCount());
  }
  LOG.info(""String_Node_Str"" + tableName1 + ""String_Node_Str""+ tableName2+ ""String_Node_Str"");
  final PreparedStatement selectStatement1=new SelectStatementCreator(_connectorRepository,sourceConnectorId).createSelectStatement(tableName1,sourceTableMetaData,sourceConnection);
  selectStatement1.setFetchSize(numberOfCheckData);
  sourceConfiguration.beforeSelect(sourceConnection,sourceConnectorId,sourceTableMetaData);
  final ResultSet resultSet1=selectStatement1.executeQuery();
  sourceConfiguration.afterSelect(sourceConnection,sourceConnectorId,sourceTableMetaData);
  final PreparedStatement selectStatement2=new SelectStatementCreator(_connectorRepository,targetConnectorId).createMappedSelectStatement(sourceTableMetaData,tableName2,targetTableMetaData,targetConnection,sourceConnectorId);
  selectStatement2.setFetchSize(numberOfCheckData);
  targetConfiguration.beforeSelect(targetConnection,targetConnectorId,targetTableMetaData);
  final ResultSet resultSet2=selectStatement2.executeQuery();
  targetConfiguration.afterSelect(targetConnection,targetConnectorId,targetTableMetaData);
  final List<ColumnMetaData> orderedSourceColumns=ColumnOrderHint.getSortedColumns(_connectorRepository,sourceConnectorId,sourceTableMetaData);
  final ColumnMapper columnMapper=_connectorRepository.getConnectorHint(targetConnectorId,ColumnMapper.class).getValue();
  int rowIndex=1;
  try {
    while (resultSet1.next() && resultSet2.next() && rowIndex <= numberOfCheckData) {
      int targetColumnIndex=1;
      for (int sourceColumnIndex=1; sourceColumnIndex <= orderedSourceColumns.size(); sourceColumnIndex++) {
        final ColumnMetaData sourceColumn=orderedSourceColumns.get(sourceColumnIndex - 1);
        final ColumnMapperResult mapping=columnMapper.map(sourceColumn,targetTableMetaData);
        for (        final ColumnMetaData columnMetaData2 : mapping.getColumns()) {
          final ColumnTypeMapping columnTypeMapping=commonColumnTypeResolver.getCommonColumnTypeMapping(sourceConnectorId,sourceColumn,targetConnectorId,columnMetaData2);
          final String columnName1=sourceColumnNameMapper.mapColumnName(sourceColumn);
          final String columnName2=targetColumnNameMapper.mapColumnName(columnMetaData2);
          if (columnTypeMapping == null) {
            throw new IncompatibleColumnsException(tableName1 + ""String_Node_Str"" + columnName1+ ""String_Node_Str""+ sourceColumn.getColumnTypeName()+ ""String_Node_Str""+ columnName2+ ""String_Node_Str""+ columnMetaData2.getColumnTypeName());
          }
          final ColumnType sourceColumnType=columnTypeMapping.getSourceColumnType();
          Object data1=sourceColumnType.getValue(resultSet1,sourceColumnIndex);
          data1=columnTypeMapping.getColumnDataMapper().map(sourceColumn,columnMetaData2,data1);
          Object data2=columnTypeMapping.getTargetColumnType().getValue(resultSet2,targetColumnIndex);
switch (sourceColumnType) {
case CLASS_STRING:
            final ConnectorInfo connectionInfo1=_connectorRepository.getConnectionInfo(sourceConnectorId);
          final ConnectorInfo connectionInfo2=_connectorRepository.getConnectionInfo(targetConnectorId);
        if (DatabaseType.POSTGRESQL.equals(connectionInfo1.getDatabaseType()) || DatabaseType.POSTGRESQL.equals(connectionInfo2.getDatabaseType())) {
          data1=trim((String)data1);
          data2=trim((String)data2);
        }
      break;
case CLASS_BLOB:
    final Blob blob1=(Blob)data1;
  final Blob blob2=(Blob)data2;
data1=createStringFromBlob(blob1);
data2=createStringFromBlob(blob2);
break;
default :
break;
}
if ((data1 == null && data2 != null) || (data1 != null && data2 == null)) {
throw createIncompatibleDataException(tableName1,rowIndex,sourceColumnType,columnName1,data1,data2);
}
 else if (data1 != null && data2 != null && !data1.equals(data2)) {
throw createIncompatibleDataException(tableName1,rowIndex,sourceColumnType,columnName1,data1,data2);
}
}
targetColumnIndex+=mapping.getColumns().size();
}
rowIndex++;
}
}
  finally {
try {
resultSet1.close();
selectStatement1.close();
resultSet2.close();
selectStatement2.close();
}
 catch (final Exception e) {
}
}
LOG.info(""String_Node_Str"" + tableName1 + ""String_Node_Str""+ tableName2+ ""String_Node_Str"");
}"
87041,"/** 
 * Create SELECT statement in the target table to retrieve data from the mapped columns. I.e., since the target table configuration may be different, the SELECT statement may be different. This is needed to check data compatibility with the   {@link CheckEqualTableDataTool}
 */
public PreparedStatement createMappedSelectStatement(final TableMetaData sourceTableMetaData,final String tableName,final TableMetaData targetTableMetaData,final Connection connection,final String sourceConnectorId) throws SQLException {
  final List<ColumnMetaData> columns=getMappedTargetColumns(sourceTableMetaData,targetTableMetaData,sourceConnectorId);
  final String sql=createSQL(tableName,targetTableMetaData,columns);
  return connection.prepareStatement(sql);
}","/** 
 * Create SELECT statement in the target table to retrieve data from the mapped columns. I.e., since the target table configuration may be different, the SELECT statement may be different. This is needed to check data compatibility with the  {@link CheckEqualTableDataTool}
 */
public PreparedStatement createMappedSelectStatement(final TableMetaData sourceTableMetaData,final String tableName,final TableMetaData targetTableMetaData,final Connection connection,final String sourceConnectorId) throws SQLException {
  final List<ColumnMetaData> columns=getMappedTargetColumns(sourceTableMetaData,targetTableMetaData,sourceConnectorId);
  final String sql=createSQL(tableName,targetTableMetaData,columns);
  return connection.prepareStatement(sql);
}"
87042,"/** 
 * Create SELECT statement in the spource table to retrieve data from the configured source columns.
 */
public PreparedStatement createSelectStatement(final String tableName,final TableMetaData tableMetaData,final Connection connection) throws SQLException {
  final List<ColumnMetaData> columns=ColumnOrderHint.getSortedColumns(_connectorRepository,_connectorId,tableMetaData);
  final String sql=createSQL(tableName,tableMetaData,columns);
  LOG.debug(""String_Node_Str"" + sql);
  return connection.prepareStatement(sql);
}","/** 
 * Create SELECT statement in the source table to retrieve data from the configured source columns.
 */
public PreparedStatement createSelectStatement(final String tableName,final TableMetaData tableMetaData,final Connection connection) throws SQLException {
  final List<ColumnMetaData> columns=ColumnOrderHint.getSortedColumns(_connectorRepository,_connectorId,tableMetaData);
  final String sql=createSQL(tableName,tableMetaData,columns);
  LOG.debug(""String_Node_Str"" + sql);
  return connection.prepareStatement(sql);
}"
87043,"public void fillInsertStatementFromResultSet(final String sourceConnectorId,final TableMetaData sourceTableMetaData,final String targetConnectorId,final TableMetaData targetTableMetaData,final TargetDatabaseConfiguration targetDatabaseConfiguration,final Connection targetConnection,final ResultSet rs,final PreparedStatement insertStatement,final int numberOfRowsPerBatch,final boolean useMultipleValuesClauses) throws SQLException {
  final CommonColumnTypeResolverTool commonColumnTypeResolver=new CommonColumnTypeResolverTool(_connectorRepository);
  final List<ColumnMetaData> sourceColumns=ColumnOrderHint.getSortedColumns(_connectorRepository,sourceConnectorId,sourceTableMetaData);
  final ColumnMapper columnMapper=_connectorRepository.getConnectorHint(targetConnectorId,ColumnMapper.class).getValue();
  final DatabaseType targetDatabaseType=targetTableMetaData.getDatabaseMetaData().getDatabaseType();
  int currentIndex=1;
  int dataItemsCount=0;
  for (int currentRow=0; currentRow < numberOfRowsPerBatch; currentRow++) {
    final boolean ok=rs.next();
    if (!ok) {
      throw new MissingDataException(""String_Node_Str"" + currentRow + ""String_Node_Str""+ numberOfRowsPerBatch);
    }
    targetDatabaseConfiguration.beforeNewRow(targetConnection,targetConnectorId,targetTableMetaData);
    for (int columnIndex=1; columnIndex <= sourceColumns.size(); columnIndex++) {
      final ColumnMetaData columnMetaData1=sourceColumns.get(columnIndex - 1);
      final ColumnMapperResult mapping=columnMapper.map(columnMetaData1,targetTableMetaData);
      for (      final ColumnMetaData columnMetaData2 : mapping.getColumns()) {
        final ColumnTypeMapping columnTypeMapping=findMapping(sourceConnectorId,targetConnectorId,commonColumnTypeResolver,columnMetaData1,columnMetaData2);
        Object value=columnTypeMapping.getSourceColumnType().getValue(rs,columnIndex);
        value=columnTypeMapping.getColumnDataMapper().map(columnMetaData1,columnMetaData2,value);
        columnTypeMapping.getTargetColumnType().setValue(insertStatement,currentIndex++,value,targetDatabaseType,columnMetaData2.getColumnType());
        dataItemsCount++;
      }
    }
    if (!useMultipleValuesClauses) {
      insertStatement.addBatch();
      currentIndex=1;
    }
    targetDatabaseConfiguration.afterNewRow(targetConnection,targetConnectorId,targetTableMetaData);
  }
  if (useMultipleValuesClauses) {
    insertStatement.addBatch();
  }
  LOG.debug(""String_Node_Str"" + dataItemsCount);
}","public void fillInsertStatementFromResultSet(final String sourceConnectorId,final TableMetaData sourceTableMetaData,final String targetConnectorId,final TableMetaData targetTableMetaData,final TargetDatabaseConfiguration targetDatabaseConfiguration,final Connection targetConnection,final ResultSet rs,final PreparedStatement insertStatement,final int numberOfRowsPerBatch,final boolean useMultipleValuesClauses) throws SQLException {
  final CommonColumnTypeResolverTool commonColumnTypeResolver=new CommonColumnTypeResolverTool(_connectorRepository);
  final List<ColumnMetaData> sourceColumns=ColumnOrderHint.getSortedColumns(_connectorRepository,sourceConnectorId,sourceTableMetaData);
  final ColumnMapper columnMapper=_connectorRepository.getConnectorHint(targetConnectorId,ColumnMapper.class).getValue();
  final DatabaseType targetDatabaseType=targetTableMetaData.getDatabaseMetaData().getDatabaseType();
  int targetColumnIndex=1;
  int dataItemsCount=0;
  for (int currentRow=0; currentRow < numberOfRowsPerBatch; currentRow++) {
    final boolean ok=rs.next();
    if (!ok) {
      throw new MissingDataException(""String_Node_Str"" + currentRow + ""String_Node_Str""+ numberOfRowsPerBatch);
    }
    targetDatabaseConfiguration.beforeNewRow(targetConnection,targetConnectorId,targetTableMetaData);
    for (int columnIndex=1; columnIndex <= sourceColumns.size(); columnIndex++) {
      final ColumnMetaData columnMetaData1=sourceColumns.get(columnIndex - 1);
      final ColumnMapperResult mapping=columnMapper.map(columnMetaData1,targetTableMetaData);
      if (mapping.getColumns().isEmpty()) {
        if (mapping.isEmptyColumnListOk()) {
          rs.getObject(columnIndex);
        }
 else {
          throw new IncompatibleColumnsException(""String_Node_Str"" + targetTableMetaData + ""String_Node_Str""+ columnMetaData1+ ""String_Node_Str"");
        }
      }
      for (      final ColumnMetaData columnMetaData2 : mapping.getColumns()) {
        final ColumnTypeMapping columnTypeMapping=findMapping(sourceConnectorId,targetConnectorId,commonColumnTypeResolver,columnMetaData1,columnMetaData2);
        Object value=columnTypeMapping.getSourceColumnType().getValue(rs,columnIndex);
        value=columnTypeMapping.getColumnDataMapper().map(columnMetaData1,columnMetaData2,value);
        columnTypeMapping.getTargetColumnType().setValue(insertStatement,targetColumnIndex++,value,targetDatabaseType,columnMetaData2.getColumnType());
        dataItemsCount++;
      }
    }
    if (!useMultipleValuesClauses) {
      insertStatement.addBatch();
      targetColumnIndex=1;
    }
    targetDatabaseConfiguration.afterNewRow(targetConnection,targetConnectorId,targetTableMetaData);
  }
  if (useMultipleValuesClauses) {
    insertStatement.addBatch();
  }
  LOG.debug(""String_Node_Str"" + dataItemsCount);
}"
87044,"/** 
 * Compares this to another object.
 * @param otherRepository The other Repository to which this is compared.
 * @return true if it is the same object, otherwise false
 */
public boolean equals(Repository otherRepository){
  return name.equals(otherRepository.getName());
}","/** 
 * Compares this to another object.
 * @param otherRepository The other Repository to which this is compared.
 * @return true if it is the same object, otherwise false
 */
public boolean equals(Repository otherRepository){
  return name == null ? otherRepository.getName() == null : name.equals(otherRepository.getName());
}"
87045,"/** 
 * @param args User specified arguments.
 */
public void run(String[] args){
  try {
    ArgumentParser jsap=new ArgumentParser();
    jsap.addStringOption(ARGS_INPUT_FILE,ARGS_INPUT_FILE_SHORTFLAG,ARGS_INPUT_FILE_LONGFLAG,""String_Node_Str"");
    jsap.addStringOption(ARGS_OUTPUT_FILE,ARGS_OUTPUT_FILE_SHORTFLAG,ARGS_OUTPUT_FILE_LONGFLAG,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_HELP,ARGS_HELP_SHORTFLAG,ARGS_HELP,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_VERBOSE_HELP,null,ARGS_VERBOSE_HELP,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_VERSION,ARGS_VERSION_SHORTFLAG,ARGS_VERSION,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_NAME,null,ARGS_NAME,""String_Node_Str"");
    jsap.addListOption(ARGS_GROUPS,null,ARGS_GROUPS,""String_Node_Str"");
    jsap.addListOption(ARGS_USERS,null,ARGS_USERS,""String_Node_Str"");
    jsap.addStringOption(ARGS_REPOS,null,ARGS_REPOS,""String_Node_Str"");
    jsap.addStringOption(ARGS_PATH,null,ARGS_PATH,""String_Node_Str"");
    jsap.addStringOption(ARGS_USER,null,ARGS_USER,""String_Node_Str"");
    jsap.addStringOption(ARGS_GROUP,null,ARGS_GROUP,""String_Node_Str"");
    jsap.addStringOption(ARGS_ACCESS,null,ARGS_ACCESS,""String_Node_Str"");
    jsap.addStringOption(ARGS_NEW_NAME,null,ARGS_NEW_NAME,""String_Node_Str"");
    jsap.addStringOption(ARGS_NEW_REPOS,null,ARGS_NEW_REPOS,""String_Node_Str"");
    jsap.addStringOption(ARGS_NEW_PATH,null,ARGS_NEW_PATH,""String_Node_Str"");
    jsap.addStringOption(ARGS_NEW_USER,null,ARGS_NEW_USER,""String_Node_Str"");
    jsap.addStringOption(ARGS_NEW_GROUP,null,ARGS_NEW_GROUP,""String_Node_Str"");
    jsap.addStringOption(ARGS_NEW_ACCESS,null,ARGS_NEW_ACCESS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_CLONE_USER,null,ARGS_CLONE_USER,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_RENAME_USER,null,ARGS_RENAME_USER,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_DELETE_USER,null,ARGS_DELETE_USER,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_ADD_GROUPS,null,ARGS_ADD_GROUPS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_COUNT_USERS,null,ARGS_COUNT_USERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_USERS,null,ARGS_GET_USERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_REMOVE_GROUPS,null,ARGS_REMOVE_GROUPS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_USER_GROUPS,null,ARGS_GET_USER_GROUPS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_USER_RULES,null,ARGS_GET_USER_RULES,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_ADD_GROUP,null,ARGS_ADD_GROUP,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_CLONE_GROUP,null,ARGS_CLONE_GROUP,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_RENAME_GROUP,null,ARGS_RENAME_GROUP,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_DELETE_GROUP,null,ARGS_DELETE_GROUP,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_ADD_MEMBERS,null,ARGS_ADD_MEMBERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_REMOVE_MEMBERS,null,ARGS_REMOVE_MEMBERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_COUNT_GROUPS,null,ARGS_COUNT_GROUPS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_GROUPS,null,ARGS_GET_GROUPS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_GROUP_MEMBERS,null,ARGS_GET_GROUP_MEMBERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_GROUP_GROUP_MEMBERS,null,ARGS_GET_GROUP_GROUP_MEMBERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_GROUP_USER_MEMBERS,null,ARGS_GET_GROUP_USER_MEMBERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_GROUP_RULES,null,ARGS_GET_GROUP_RULES,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_RENAME_REPOS,null,ARGS_RENAME_REPOS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_DELETE_REPOS,null,ARGS_DELETE_REPOS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_COUNT_REPOS,null,ARGS_COUNT_REPOS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_REPOS,null,ARGS_GET_REPOS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_REPOS_RULES,null,ARGS_GET_REPOS_RULES,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_ADD_RULE,null,ARGS_ADD_RULE,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_EDIT_RULE,null,ARGS_EDIT_RULE,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_DELETE_RULE,null,ARGS_DELETE_RULE,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_COUNT_RULES,null,ARGS_COUNT_RULES,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_RULES,null,ARGS_GET_RULES,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_STATISTICS_REPORT,null,ARGS_STATISTICS_REPORT,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_SUMMARY_REPORT,null,ARGS_SUMMARY_REPORT,""String_Node_Str"");
    JSAPResult config=jsap.parse(args);
    if (!config.success()) {
      System.err.println();
      System.err.println(ResourceUtil.getString(""String_Node_Str""));
      System.err.println();
      System.exit(1);
    }
    executeCommands(jsap,config);
  }
 catch (  JSAPException e) {
    System.err.println();
    System.err.println(ResourceUtil.getString(""String_Node_Str""));
    System.err.println();
  }
}","/** 
 * @param args User specified arguments.
 */
public void run(String[] args){
  try {
    ArgumentParser jsap=new ArgumentParser();
    jsap.addStringOption(ARGS_INPUT_FILE,ARGS_INPUT_FILE_SHORTFLAG,ARGS_INPUT_FILE_LONGFLAG,""String_Node_Str"");
    jsap.addStringOption(ARGS_OUTPUT_FILE,ARGS_OUTPUT_FILE_SHORTFLAG,ARGS_OUTPUT_FILE_LONGFLAG,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_HELP,ARGS_HELP_SHORTFLAG,ARGS_HELP,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_VERBOSE_HELP,null,ARGS_VERBOSE_HELP,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_VERSION,ARGS_VERSION_SHORTFLAG,ARGS_VERSION,""String_Node_Str"");
    jsap.addListOption(ARGS_GROUPS,null,ARGS_GROUPS,""String_Node_Str"");
    jsap.addListOption(ARGS_USERS,null,ARGS_USERS,""String_Node_Str"");
    jsap.addStringOption(ARGS_REPOS,null,ARGS_REPOS,""String_Node_Str"");
    jsap.addStringOption(ARGS_PATH,null,ARGS_PATH,""String_Node_Str"");
    jsap.addStringOption(ARGS_USER,null,ARGS_USER,""String_Node_Str"");
    jsap.addStringOption(ARGS_GROUP,null,ARGS_GROUP,""String_Node_Str"");
    jsap.addStringOption(ARGS_ACCESS,null,ARGS_ACCESS,""String_Node_Str"");
    jsap.addStringOption(ARGS_NAME,null,ARGS_NAME,""String_Node_Str"");
    jsap.addStringOption(ARGS_NEW_NAME,null,ARGS_NEW_NAME,""String_Node_Str"");
    jsap.addStringOption(ARGS_NEW_REPOS,null,ARGS_NEW_REPOS,""String_Node_Str"");
    jsap.addStringOption(ARGS_NEW_PATH,null,ARGS_NEW_PATH,""String_Node_Str"");
    jsap.addStringOption(ARGS_NEW_USER,null,ARGS_NEW_USER,""String_Node_Str"");
    jsap.addStringOption(ARGS_NEW_GROUP,null,ARGS_NEW_GROUP,""String_Node_Str"");
    jsap.addStringOption(ARGS_NEW_ACCESS,null,ARGS_NEW_ACCESS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_CLONE_USER,null,ARGS_CLONE_USER,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_RENAME_USER,null,ARGS_RENAME_USER,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_DELETE_USER,null,ARGS_DELETE_USER,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_ADD_GROUPS,null,ARGS_ADD_GROUPS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_COUNT_USERS,null,ARGS_COUNT_USERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_USERS,null,ARGS_GET_USERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_REMOVE_GROUPS,null,ARGS_REMOVE_GROUPS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_USER_GROUPS,null,ARGS_GET_USER_GROUPS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_USER_RULES,null,ARGS_GET_USER_RULES,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_ADD_GROUP,null,ARGS_ADD_GROUP,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_CLONE_GROUP,null,ARGS_CLONE_GROUP,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_RENAME_GROUP,null,ARGS_RENAME_GROUP,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_DELETE_GROUP,null,ARGS_DELETE_GROUP,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_ADD_MEMBERS,null,ARGS_ADD_MEMBERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_REMOVE_MEMBERS,null,ARGS_REMOVE_MEMBERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_COUNT_GROUPS,null,ARGS_COUNT_GROUPS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_GROUPS,null,ARGS_GET_GROUPS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_GROUP_MEMBERS,null,ARGS_GET_GROUP_MEMBERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_GROUP_GROUP_MEMBERS,null,ARGS_GET_GROUP_GROUP_MEMBERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_GROUP_USER_MEMBERS,null,ARGS_GET_GROUP_USER_MEMBERS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_GROUP_RULES,null,ARGS_GET_GROUP_RULES,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_RENAME_REPOS,null,ARGS_RENAME_REPOS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_DELETE_REPOS,null,ARGS_DELETE_REPOS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_COUNT_REPOS,null,ARGS_COUNT_REPOS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_REPOS,null,ARGS_GET_REPOS,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_REPOS_RULES,null,ARGS_GET_REPOS_RULES,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_ADD_RULE,null,ARGS_ADD_RULE,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_EDIT_RULE,null,ARGS_EDIT_RULE,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_DELETE_RULE,null,ARGS_DELETE_RULE,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_COUNT_RULES,null,ARGS_COUNT_RULES,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_GET_RULES,null,ARGS_GET_RULES,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_STATISTICS_REPORT,null,ARGS_STATISTICS_REPORT,""String_Node_Str"");
    jsap.addSwitchOption(ARGS_SUMMARY_REPORT,null,ARGS_SUMMARY_REPORT,""String_Node_Str"");
    JSAPResult config=jsap.parse(args);
    if (!config.success()) {
      System.err.println();
      System.err.println(ResourceUtil.getString(""String_Node_Str""));
      System.err.println();
      System.exit(1);
    }
    executeCommands(jsap,config);
  }
 catch (  JSAPException e) {
    System.err.println();
    System.err.println(ResourceUtil.getString(""String_Node_Str""));
    System.err.println();
  }
}"
87046,"/** 
 * Calculates hashCode value of this group.
 * @return Hashcode of this object
 */
@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + (name == null ? 0 : name.hashCode());
  return result;
}","/** 
 * Calculates hashCode value of this group.
 * @return Hashcode of this object
 */
@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + (getName() == null ? 0 : getName().hashCode());
  return result;
}"
87047,"/** 
 * Compares this object with the provided AuthzGroup object for equality.
 * @param object Object to compare
 * @return True if this object matches the provided object, otherwise false
 */
@Override public boolean equals(final Object object){
  if (this == object) {
    return true;
  }
  if (object == null) {
    return false;
  }
  if (getClass() != object.getClass()) {
    return false;
  }
  final AuthzGroupImpl other=(AuthzGroupImpl)object;
  if (name == null) {
    if (other.name != null) {
      return false;
    }
  }
 else   if (!name.equals(other.name)) {
    return false;
  }
  return true;
}","/** 
 * Compares this object with the provided AuthzGroup object for equality.
 * @param object Object to compare
 * @return True if this object matches the provided object, otherwise false
 */
@Override public boolean equals(final Object object){
  if (this == object) {
    return true;
  }
  if (object == null) {
    return false;
  }
  if (getClass() != object.getClass()) {
    return false;
  }
  final AuthzGroupImpl other=(AuthzGroupImpl)object;
  if (getName() == null) {
    if (other.getName() != null) {
      return false;
    }
  }
 else   if (!getName().equals(other.getName())) {
    return false;
  }
  return true;
}"
87048,"/** 
 * Creates a string representation of this group.
 * @return String representation of this group
 */
@Override public String toString(){
  final ToStringBuilder toStringBuilder=new ToStringBuilder(this);
  toStringBuilder.append(""String_Node_Str"",name);
  return toStringBuilder.toString();
}","/** 
 * Creates a string representation of this group.
 * @return String representation of this group
 */
@Override public String toString(){
  final ToStringBuilder toStringBuilder=new ToStringBuilder(this);
  toStringBuilder.append(""String_Node_Str"",getName());
  return toStringBuilder.toString();
}"
87049,"/** 
 * Adds access rule to collection access rules.
 * @param accessRule Access rule to add to collection
 * @return True if access rule added
 * @throws AuthzAccessRuleAlreadyAppliedException If the access rule is already applied to the member
 */
protected boolean addAccessRule(final AuthzAccessRule accessRule) throws AuthzAccessRuleAlreadyAppliedException {
  LOGGER.debug(""String_Node_Str"",accessRule);
  Preconditions.checkNotNull(accessRule,""String_Node_Str"");
  if (accessRules.contains(accessRule)) {
    LOGGER.error(""String_Node_Str"");
    throw new AuthzAccessRuleAlreadyAppliedException();
  }
  if (accessRules.add(accessRule)) {
    Collections.sort(accessRules);
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Adds access rule to collection access rules.
 * @param accessRule Access rule to add to collection
 * @return True if access rule added
 * @throws AuthzAccessRuleAlreadyAppliedException If the access rule is already applied to the member
 */
protected final boolean addAccessRule(final AuthzAccessRule accessRule) throws AuthzAccessRuleAlreadyAppliedException {
  LOGGER.debug(""String_Node_Str"",accessRule);
  Preconditions.checkNotNull(accessRule,""String_Node_Str"");
  if (accessRules.contains(accessRule)) {
    LOGGER.error(""String_Node_Str"");
    throw new AuthzAccessRuleAlreadyAppliedException();
  }
  if (accessRules.add(accessRule)) {
    Collections.sort(accessRules);
    return true;
  }
 else {
    return false;
  }
}"
87050,"/** 
 * Calculates hashCode value of this user.
 * @return Hashcode of this object
 */
@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + (alias == null ? 0 : alias.hashCode());
  result=prime * result + (name == null ? 0 : name.hashCode());
  return result;
}","/** 
 * Calculates hashCode value of this user.
 * @return Hashcode of this object
 */
@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + (alias == null ? 0 : alias.hashCode());
  result=prime * result + (getName() == null ? 0 : getName().hashCode());
  return result;
}"
87051,"/** 
 * Compares this object with the provided AuthzUser object for equality.
 * @param object Object to compare
 */
@Override public boolean equals(final Object object){
  if (this == object) {
    return true;
  }
  if (object == null) {
    return false;
  }
  if (getClass() != object.getClass()) {
    return false;
  }
  final AuthzUserImpl other=(AuthzUserImpl)object;
  if (alias == null) {
    if (other.alias != null) {
      return false;
    }
  }
 else   if (!alias.equals(other.alias)) {
    return false;
  }
  if (name == null) {
    if (other.name != null) {
      return false;
    }
  }
 else   if (!name.equals(other.name)) {
    return false;
  }
  return true;
}","/** 
 * Compares this object with the provided AuthzUser object for equality.
 * @param object Object to compare
 */
@Override public boolean equals(final Object object){
  if (this == object) {
    return true;
  }
  if (object == null) {
    return false;
  }
  if (getClass() != object.getClass()) {
    return false;
  }
  final AuthzUserImpl other=(AuthzUserImpl)object;
  if (alias == null) {
    if (other.alias != null) {
      return false;
    }
  }
 else   if (!alias.equals(other.alias)) {
    return false;
  }
  if (getName() == null) {
    if (other.getName() != null) {
      return false;
    }
  }
 else   if (!getName().equals(other.getName())) {
    return false;
  }
  return true;
}"
87052,"/** 
 * Creates a string representation of this user.
 * @return String representation of this user
 */
@Override public String toString(){
  final ToStringBuilder toStringBuilder=new ToStringBuilder(this);
  toStringBuilder.append(""String_Node_Str"",name).append(""String_Node_Str"",alias);
  return toStringBuilder.toString();
}","/** 
 * Creates a string representation of this user.
 * @return String representation of this user
 */
@Override public String toString(){
  final ToStringBuilder toStringBuilder=new ToStringBuilder(this);
  toStringBuilder.append(""String_Node_Str"",getName()).append(""String_Node_Str"",alias);
  return toStringBuilder.toString();
}"
87053,"/** 
 * Change Membership action handler. Displays ChangeMembership dialog.
 */
private void changeMembership(){
  Object[] selectedItems=getUsersPane().getUserList().getSelectedValues();
  if (selectedItems.length == 0) {
    displayWarning(ResourceUtil.getString(""String_Node_Str""));
  }
 else {
    User selectedUser=null;
    for (int i=0; i < selectedItems.length; i++) {
      Message message=new Message();
      JDialog dialog=new ChangeMembershipDialog((User)selectedItems[i],message);
      DialogUtil.center(this,dialog);
      dialog.setVisible(true);
      if (message.getState() == Message.SUCCESS) {
        selectedUser=(User)message.getUserObject();
      }
 else       if (message.getUserObject() == null) {
        selectedUser=(User)selectedItems[i];
      }
      if (message.getState() == Message.CANCEL) {
        break;
      }
    }
    refreshUserList(selectedUser);
    refreshAccessRuleTree(null);
  }
  updateTitle();
}","/** 
 * Change Membership action handler. Displays ChangeMembership dialog.
 */
private void changeMembership(){
  Object[] selectedItems=getUsersPane().getUserList().getSelectedValues();
  if (selectedItems.length == 0) {
    displayWarning(ResourceUtil.getString(""String_Node_Str""));
  }
 else {
    User selectedUser=null;
    for (int i=0; i < selectedItems.length; i++) {
      Message message=new Message();
      JDialog dialog=new ChangeMembershipDialog((User)selectedItems[i],message);
      DialogUtil.center(this,dialog);
      dialog.setVisible(true);
      if (message.getState() == Message.SUCCESS) {
        selectedUser=(User)message.getUserObject();
      }
 else       if (message.getUserObject() == null) {
        selectedUser=(User)selectedItems[i];
      }
      if (message.getState() == Message.CANCEL) {
        break;
      }
    }
    refreshUserList(selectedUser);
    refreshGroupDetails();
    refreshAccessRuleTree(null);
  }
  updateTitle();
}"
87054,"public AccessRule editAccessRule() throws ApplicationException {
  Repository repository=(Repository)getRepositoryComboBox().getSelectedItem();
  String pathString=(String)getPathTextField().getText();
  String levelOfAccess=null;
  Group group=null;
  User user=null;
  Validator.validateNotEmptyString(ResourceUtil.getString(""String_Node_Str""),pathString);
  if (getReadWriteRadioButton().isSelected()) {
    levelOfAccess=Constants.ACCESS_LEVEL_READWRITE;
  }
 else   if (getReadOnlyRadioButton().isSelected()) {
    levelOfAccess=Constants.ACCESS_LEVEL_READONLY;
  }
 else {
    levelOfAccess=Constants.ACCESS_LEVEL_DENY_ACCESS;
  }
  if (getGroupRadioButton().isSelected()) {
    group=(Group)getGroupComboBox().getSelectedItem();
    Validator.validateNotNull(ResourceUtil.getString(""String_Node_Str""),group);
  }
 else   if (getUserRadioButton().isSelected()) {
    user=(User)getUserComboBox().getSelectedItem();
    Validator.validateNotNull(ResourceUtil.getString(""String_Node_Str""),user);
  }
 else   if (getAllUsersRadioButton().isSelected()) {
    user=Document.addUser(""String_Node_Str"");
  }
  if (group != null) {
    AccessRule foundRule=Document.findGroupAccessRule(repository,pathString,group);
    if (foundRule == null || accessRule == foundRule) {
      accessRule.getPath().removeAccessRule(accessRule);
      accessRule.setPath(Document.addPath(repository,pathString));
      accessRule.getPath().addAccessRule(accessRule);
      accessRule.setGroup(group);
      accessRule.setUser(null);
      accessRule.setLevel(levelOfAccess);
    }
 else {
      throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
    }
  }
 else   if (user != null) {
    AccessRule foundRule=Document.findUserAccessRule(repository,pathString,user);
    if (foundRule == null || accessRule == foundRule) {
      accessRule.getPath().removeAccessRule(accessRule);
      accessRule.setPath(Document.addPath(repository,pathString));
      accessRule.getPath().addAccessRule(accessRule);
      accessRule.setGroup(null);
      accessRule.setUser(user);
      accessRule.setLevel(levelOfAccess);
    }
 else {
      throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
    }
  }
 else {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  return accessRule;
}","public AccessRule editAccessRule() throws ApplicationException {
  Repository repository=(Repository)getRepositoryComboBox().getSelectedItem();
  String pathString=(String)getPathTextField().getText();
  String levelOfAccess=null;
  Group group=null;
  User user=null;
  Validator.validateNotEmptyString(ResourceUtil.getString(""String_Node_Str""),pathString);
  if (getReadWriteRadioButton().isSelected()) {
    levelOfAccess=Constants.ACCESS_LEVEL_READWRITE;
  }
 else   if (getReadOnlyRadioButton().isSelected()) {
    levelOfAccess=Constants.ACCESS_LEVEL_READONLY;
  }
 else {
    levelOfAccess=Constants.ACCESS_LEVEL_DENY_ACCESS;
  }
  if (getGroupRadioButton().isSelected()) {
    group=(Group)getGroupComboBox().getSelectedItem();
    Validator.validateNotNull(ResourceUtil.getString(""String_Node_Str""),group);
  }
 else   if (getUserRadioButton().isSelected()) {
    user=(User)getUserComboBox().getSelectedItem();
    Validator.validateNotNull(ResourceUtil.getString(""String_Node_Str""),user);
  }
 else   if (getAllUsersRadioButton().isSelected()) {
    user=Document.addUser(""String_Node_Str"");
  }
  if (group != null) {
    AccessRule foundRule=Document.findGroupAccessRule(repository,pathString,group);
    if (foundRule == null || accessRule == foundRule) {
      accessRule.getPath().removeAccessRule(accessRule);
      accessRule.setPath(Document.addPath(repository,pathString));
      accessRule.getPath().addAccessRule(accessRule);
      accessRule.setGroup(group);
      group.addAccessRule(accessRule);
      if (accessRule.getUser() != null) {
        accessRule.getUser().removeAccessRule(accessRule);
      }
      accessRule.setUser(null);
      accessRule.setLevel(levelOfAccess);
    }
 else {
      throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
    }
  }
 else   if (user != null) {
    AccessRule foundRule=Document.findUserAccessRule(repository,pathString,user);
    if (foundRule == null || accessRule == foundRule) {
      accessRule.getPath().removeAccessRule(accessRule);
      accessRule.setPath(Document.addPath(repository,pathString));
      accessRule.getPath().addAccessRule(accessRule);
      if (accessRule.getGroup() != null) {
        accessRule.getGroup().removeAccessRule(accessRule);
      }
      accessRule.setGroup(null);
      accessRule.setUser(user);
      user.addAccessRule(accessRule);
      accessRule.setLevel(levelOfAccess);
    }
 else {
      throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
    }
  }
 else {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  return accessRule;
}"
87055,"/** 
 * This method initializes groupRadioButton.
 * @return javax.swing.JRadioButton
 */
private JRadioButton getGroupRadioButton(){
  if (groupRadioButton == null) {
    groupRadioButton=new JRadioButton();
    groupRadioButton.addActionListener(this);
    groupRadioButton.setActionCommand(GROUP_ACTION);
    groupRadioButton.setText(ResourceUtil.getString(type + ""String_Node_Str""));
    groupRadioButton.setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
    if (accessRule != null && accessRule.getGroup() != null) {
      groupRadioButton.setSelected(true);
    }
 else {
      groupRadioButton.setSelected(true);
    }
  }
  return groupRadioButton;
}","/** 
 * This method initializes groupRadioButton.
 * @return javax.swing.JRadioButton
 */
private JRadioButton getGroupRadioButton(){
  if (groupRadioButton == null) {
    groupRadioButton=new JRadioButton();
    groupRadioButton.addActionListener(this);
    groupRadioButton.setActionCommand(GROUP_ACTION);
    groupRadioButton.setText(ResourceUtil.getString(type + ""String_Node_Str""));
    groupRadioButton.setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
    if (accessRule != null) {
      if (accessRule.getGroup() != null) {
        groupRadioButton.setSelected(true);
      }
    }
 else {
      groupRadioButton.setSelected(true);
    }
  }
  return groupRadioButton;
}"
87056,"/** 
 * Edit access rule handler.
 */
private void editAccessRule(){
  if (getAccessRulesPane().getAccessRulesTable().getSelectedRowCount() < 1) {
    displayWarning(ResourceUtil.getString(""String_Node_Str""));
  }
 else {
    try {
      DefaultMutableTreeNode node=(DefaultMutableTreeNode)getAccessRulesPane().getAccessRulesTree().getLastSelectedPathComponent();
      if (node == null) {
        return;
      }
      JTable accessRulesTable=getAccessRulesPane().getAccessRulesTable();
      Object userObject=node.getUserObject();
      DefaultTableModel tableModel=(DefaultTableModel)accessRulesTable.getModel();
      int selectedRow=accessRulesTable.convertRowIndexToModel(accessRulesTable.getSelectedRow());
      AccessRule accessRule=null;
      if (userObject instanceof Repository) {
        Repository repository=(Repository)userObject;
        Path path=(Path)tableModel.getValueAt(selectedRow,0);
        Object object=tableModel.getValueAt(selectedRow,1);
        if (object instanceof Group) {
          accessRule=Document.findGroupAccessRule(repository,path.getPath(),(Group)object);
        }
 else         if (object instanceof User) {
          accessRule=Document.findUserAccessRule(repository,path.getPath(),(User)object);
        }
      }
 else       if (userObject instanceof Path) {
        Path path=(Path)userObject;
        Object object=tableModel.getValueAt(selectedRow,0);
        if (object instanceof Group) {
          accessRule=Document.findGroupAccessRule(path.getRepository(),path.getPath(),(Group)object);
        }
 else         if (object instanceof User) {
          accessRule=Document.findUserAccessRule(path.getRepository(),path.getPath(),(User)object);
        }
      }
 else {
        Repository repository=(Repository)tableModel.getValueAt(selectedRow,0);
        Path path=(Path)tableModel.getValueAt(selectedRow,1);
        Object object=tableModel.getValueAt(selectedRow,2);
        if (object instanceof Group) {
          accessRule=Document.findGroupAccessRule(repository,path.getPath(),(Group)object);
        }
 else         if (object instanceof User) {
          accessRule=Document.findUserAccessRule(repository,path.getPath(),(User)object);
        }
      }
      Message message=new Message();
      JDialog dialog=new EditAccessRuleDialog(accessRule,message);
      DialogUtil.center(this,dialog);
      dialog.setVisible(true);
      if (message.getState() == Message.SUCCESS) {
        Document.setUnsavedChanges();
        refreshUserDetails();
        refreshGroupDetails();
        refreshAccessRuleTree(null);
      }
    }
 catch (    ApplicationException ae) {
      displayError(ResourceUtil.getString(""String_Node_Str""));
    }
  }
  updateTitle();
}","/** 
 * Edit access rule handler.
 */
private void editAccessRule(){
  if (getAccessRulesPane().getAccessRulesTable().getSelectedRowCount() < 1) {
    displayWarning(ResourceUtil.getString(""String_Node_Str""));
  }
 else {
    try {
      DefaultMutableTreeNode node=(DefaultMutableTreeNode)getAccessRulesPane().getAccessRulesTree().getLastSelectedPathComponent();
      if (node == null) {
        return;
      }
      JTable accessRulesTable=getAccessRulesPane().getAccessRulesTable();
      Object userObject=node.getUserObject();
      DefaultTableModel tableModel=(DefaultTableModel)accessRulesTable.getModel();
      int selectedRow=accessRulesTable.convertRowIndexToModel(accessRulesTable.getSelectedRow());
      AccessRule accessRule=null;
      if (userObject instanceof Repository) {
        Repository repository=(Repository)userObject;
        Path path=(Path)tableModel.getValueAt(selectedRow,0);
        Object object=tableModel.getValueAt(selectedRow,1);
        if (object instanceof Group) {
          accessRule=Document.findGroupAccessRule(repository,path.getPath(),(Group)object);
        }
 else         if (object instanceof User) {
          accessRule=Document.findUserAccessRule(repository,path.getPath(),(User)object);
        }
      }
 else       if (userObject instanceof Path) {
        Path path=(Path)userObject;
        Object object=tableModel.getValueAt(selectedRow,0);
        if (object instanceof Group) {
          accessRule=Document.findGroupAccessRule(path.getRepository(),path.getPath(),(Group)object);
        }
 else         if (object instanceof User) {
          accessRule=Document.findUserAccessRule(path.getRepository(),path.getPath(),(User)object);
        }
      }
 else {
        Repository repository=(Repository)tableModel.getValueAt(selectedRow,0);
        Path path=(Path)tableModel.getValueAt(selectedRow,1);
        Object object=tableModel.getValueAt(selectedRow,2);
        if (object instanceof Group) {
          accessRule=Document.findGroupAccessRule(repository,path.getPath(),(Group)object);
        }
 else         if (object instanceof User) {
          accessRule=Document.findUserAccessRule(repository,path.getPath(),(User)object);
        }
      }
      if (accessRule == null) {
        displayError(ResourceUtil.getString(""String_Node_Str""));
      }
 else {
        Message message=new Message();
        Path path=accessRule.getPath();
        JDialog dialog=new EditAccessRuleDialog(accessRule,message);
        DialogUtil.center(this,dialog);
        dialog.setVisible(true);
        if (message.getState() == Message.SUCCESS) {
          Document.setUnsavedChanges();
          refreshUserDetails();
          refreshGroupDetails();
          if (accessRule.getPath().equals(path)) {
            refreshAccessRuleTree(path);
          }
 else {
            refreshAccessRuleTree(null);
          }
        }
      }
    }
 catch (    ApplicationException ae) {
      displayError(ResourceUtil.getString(""String_Node_Str""));
    }
  }
  updateTitle();
}"
87057,"private void renameUser(String userName) throws ApplicationException {
  validateUserName(userName);
  User existingUser=document.findUser(userName);
  if (existingUser == null || existingUser == user) {
    message.setUserObject(document.renameUser(existingUser,userName));
    message.setState(Message.SUCCESS);
    dispose();
  }
 else {
    displayError(ResourceUtil.getFormattedString(type + ""String_Node_Str"",userName));
  }
}","private void renameUser(String userName) throws ApplicationException {
  validateUserName(userName);
  User existingUser=document.findUser(userName);
  if (existingUser == null || existingUser == user) {
    message.setUserObject(document.renameUser(user,userName));
    message.setState(Message.SUCCESS);
    dispose();
  }
 else {
    displayError(ResourceUtil.getFormattedString(type + ""String_Node_Str"",userName));
  }
}"
87058,"private void renameGroup(String groupName) throws ApplicationException {
  validateGroupName(groupName);
  Group existingGroup=document.findGroup(groupName);
  if (existingGroup == null || existingGroup == group) {
    message.setUserObject(document.renameGroup(existingGroup,groupName));
    message.setState(Message.SUCCESS);
    dispose();
  }
 else {
    displayError(ResourceUtil.getFormattedString(type + ""String_Node_Str"",groupName));
  }
}","private void renameGroup(String groupName) throws ApplicationException {
  validateGroupName(groupName);
  Group existingGroup=document.findGroup(groupName);
  if (existingGroup == null || existingGroup == group) {
    message.setUserObject(document.renameGroup(group,groupName));
    message.setState(Message.SUCCESS);
    dispose();
  }
 else {
    displayError(ResourceUtil.getFormattedString(type + ""String_Node_Str"",groupName));
  }
}"
87059,"/** 
 * Add/Remove Members action handler. Displays AddRemoveMembers dialog.
 */
private void addRemoveMembers(){
  Object[] selectedItems=getGroupsPane().getGroupList().getSelectedValues();
  if (selectedItems.length == 0) {
    displayWarning(ResourceUtil.getString(""String_Node_Str""));
  }
 else {
    Group selectedGroup=null;
    for (int i=0; i < selectedItems.length; i++) {
      Message message=new Message();
      JDialog dialog=new AddRemoveMembersDialog((Group)selectedItems[i],message);
      DialogUtil.center(this,dialog);
      dialog.setVisible(true);
      if (message.getState() == Message.SUCCESS) {
        selectedGroup=(Group)message.getUserObject();
      }
 else       if (message.getUserObject() == null) {
        selectedGroup=(Group)selectedItems[i];
      }
      if (message.getState() == Message.CANCEL) {
        break;
      }
    }
    refreshGroupList(selectedGroup);
    refreshAccessRuleTree(null);
  }
  updateTitle();
}","/** 
 * Add/Remove Members action handler. Displays AddRemoveMembers dialog.
 */
private void addRemoveMembers(){
  Object[] selectedItems=getGroupsPane().getGroupList().getSelectedValues();
  if (selectedItems.length == 0) {
    displayWarning(ResourceUtil.getString(""String_Node_Str""));
  }
 else {
    Group selectedGroup=null;
    for (int i=0; i < selectedItems.length; i++) {
      Message message=new Message();
      JDialog dialog=new AddRemoveMembersDialog((Group)selectedItems[i],message);
      DialogUtil.center(this,dialog);
      dialog.setVisible(true);
      if (message.getState() == Message.SUCCESS) {
        selectedGroup=(Group)message.getUserObject();
      }
 else       if (message.getUserObject() == null) {
        selectedGroup=(Group)selectedItems[i];
      }
      if (message.getState() == Message.CANCEL) {
        break;
      }
    }
    refreshUserDetails();
    refreshGroupList(selectedGroup);
    refreshAccessRuleTree(null);
  }
  updateTitle();
}"
87060,"/** 
 * ActionPerformed event handler.
 */
public void actionPerformed(ActionEvent e){
  if (e.getActionCommand().equals(Constants.ASSIGN_ACTION)) {
    assign();
  }
 else   if (e.getActionCommand().equals(Constants.UNASSIGN_ACTION)) {
    unassign();
  }
 else   if (e.getActionCommand().equals(Constants.SAVE_ACTION)) {
    try {
      Document.changeUserMembership(user,memberOf);
      message.setUserObject(user);
      message.setState(Message.SUCCESS);
      dispose();
    }
 catch (    Exception ex) {
      displayError(ex.getMessage());
    }
  }
 else   if (e.getActionCommand().equals(""String_Node_Str"")) {
    message.setState(Message.CANCEL);
    dispose();
  }
}","/** 
 * ActionPerformed event handler.
 */
public void actionPerformed(ActionEvent e){
  if (e.getActionCommand().equals(Constants.ASSIGN_ACTION)) {
    assign();
  }
 else   if (e.getActionCommand().equals(Constants.UNASSIGN_ACTION)) {
    unassign();
  }
 else   if (e.getActionCommand().equals(Constants.SAVE_ACTION)) {
    try {
      Document.changeUserMembership(user,memberOf);
      message.setUserObject(user);
      message.setState(Message.SUCCESS);
      dispose();
    }
 catch (    Exception ex) {
      displayError(ex.getMessage());
    }
  }
 else   if (e.getActionCommand().equals(Constants.CANCEL_ACTION)) {
    message.setState(Message.CANCEL);
    dispose();
  }
}"
87061,"/** 
 * KeyPressed event handler.
 * @param event KeyEvent object.
 */
public void keyPressed(KeyEvent event){
  int code=event.getKeyCode();
  if (code == KeyEvent.VK_SPACE) {
    if (event.getComponent() == getMemberList()) {
      unassignMembers();
    }
 else     if (event.getComponent() == getNonMemberList()) {
      assignMembers();
    }
  }
}","/** 
 * KeyPressed event handler.
 * @param event KeyEvent object.
 */
public void keyPressed(KeyEvent event){
  int code=event.getKeyCode();
  if (code == KeyEvent.VK_SPACE) {
    if (event.getComponent() == getMemberList()) {
      unassignMembers();
    }
 else     if (event.getComponent() == getNonMemberList()) {
      assignMembers();
    }
  }
 else {
    super.keyPressed(event);
  }
}"
87062,"/** 
 * KeyPressed event handler.
 * @param event KeyEvent object.
 */
public void keyPressed(KeyEvent event){
  int code=event.getKeyCode();
  if (code == KeyEvent.VK_SPACE) {
    if (event.getComponent() == getMemberOfList()) {
      unassign();
    }
 else     if (event.getComponent() == getNotMemberOfList()) {
      assign();
    }
  }
}","/** 
 * KeyPressed event handler.
 * @param event KeyEvent object.
 */
public void keyPressed(KeyEvent event){
  int code=event.getKeyCode();
  if (code == KeyEvent.VK_SPACE) {
    if (event.getComponent() == getMemberOfList()) {
      unassign();
    }
 else     if (event.getComponent() == getNotMemberOfList()) {
      assign();
    }
  }
 else {
    super.keyPressed(event);
  }
}"
87063,"/** 
 * Parses a single line in the authz file.
 * @param lineNumber Number of the line being processed.
 * @param line Content of the line.
 * @throws ParserException
 * @throws ApplicationException
 */
private static void parseLine(int lineNumber,String line) throws ParserException, ApplicationException {
switch (line.charAt(0)) {
case '#':
    break;
case '[':
  if (line.equals(""String_Node_Str"")) {
    if (currentState != STATE_START) {
      throw ParserException.generateException(lineNumber,ResourceUtil.getString(""String_Node_Str""));
    }
    currentState=STATE_PROCESS_GROUPS;
  }
 else   if (line.indexOf(':') == -1) {
    currentState=STATE_PROCESS_SERVER_RULES;
    String path=line.substring(1,line.length() - 1).trim();
    if (Document.findServerPath(path) != null) {
      throw ParserException.generateException(lineNumber,ResourceUtil.getFormattedString(""String_Node_Str"",path));
    }
    try {
      currentPath=Document.addPath(null,path);
    }
 catch (    ApplicationException ae) {
      throw ParserException.generateException(lineNumber,ae.getMessage());
    }
  }
 else   if (line.indexOf(':') >= 0) {
    currentState=STATE_PROCESS_RULES;
    int index=line.indexOf(':');
    String repository=line.substring(1,index).trim();
    String path=line.substring(index + 1,line.length() - 1).trim();
    Repository repositoryObject=null;
    try {
      repositoryObject=Document.addRepository(repository);
    }
 catch (    ApplicationException ae) {
      throw ParserException.generateException(lineNumber,ae.getMessage());
    }
    if (Document.findPath(repositoryObject,path) != null) {
      Object[] args=new Object[2];
      args[0]=path;
      args[1]=repository;
      throw ParserException.generateException(lineNumber,ResourceUtil.getFormattedString(""String_Node_Str"",args));
    }
    try {
      currentPath=Document.addPath(repositoryObject,path);
    }
 catch (    ApplicationException ae) {
      throw ParserException.generateException(lineNumber,ae.getMessage());
    }
  }
 else {
    throw ParserException.generateException(lineNumber,ResourceUtil.getString(""String_Node_Str""));
  }
break;
case '@':
if (currentState == STATE_PROCESS_RULES || currentState == STATE_PROCESS_SERVER_RULES) {
int index=line.indexOf('=');
String group=line.substring(1,index).trim();
String level=line.substring(index + 1).trim();
if (Document.findGroup(group) == null) {
  throw ParserException.generateException(lineNumber,ResourceUtil.getFormattedString(""String_Node_Str"",group));
}
try {
  Document.addAccessRuleForGroup(currentPath,group,level);
}
 catch (ApplicationException ae) {
  throw ParserException.generateException(lineNumber,ae.getMessage());
}
}
 else {
throw ParserException.generateException(lineNumber,ResourceUtil.getString(""String_Node_Str""));
}
break;
default :
if (currentState == STATE_PROCESS_GROUPS) {
int index=line.indexOf('=');
if (index == -1) {
throw ParserException.generateException(lineNumber,ResourceUtil.getString(""String_Node_Str""));
}
String name=line.substring(0,index).trim();
String members=line.substring(index + 1).trim();
StringTokenizer tokens=new StringTokenizer(members,""String_Node_Str"");
int memberCount=tokens.countTokens();
List<String> groupMembers=new ArrayList<String>();
List<String> userMembers=new ArrayList<String>();
for (int i=0; i < memberCount; i++) {
String member=tokens.nextToken();
if (member.charAt(0) == '@') {
groupMembers.add(member.substring(1,member.length()));
}
 else {
userMembers.add(member);
}
}
if (Document.findGroup(name) != null) {
throw ParserException.generateException(lineNumber,ResourceUtil.getFormattedString(""String_Node_Str"",name));
}
try {
Document.addGroupByName(name,groupMembers,userMembers);
}
 catch (ApplicationException ae) {
throw ParserException.generateException(lineNumber,ae.getMessage());
}
}
 else if (currentState == STATE_PROCESS_RULES || currentState == STATE_PROCESS_SERVER_RULES) {
int index=line.indexOf('=');
String user=line.substring(0,index).trim();
String level=line.substring(index + 1).trim();
try {
Document.addAccessRuleForUser(currentPath,user,level);
}
 catch (ApplicationException ae) {
throw ParserException.generateException(lineNumber,ae.getMessage());
}
}
break;
}
}","/** 
 * Parses a single line in the authz file.
 * @param lineNumber Number of the line being processed.
 * @param line Content of the line.
 * @throws ParserException
 * @throws ApplicationException
 */
private static void parseLine(int lineNumber,String line) throws ParserException, ApplicationException {
switch (line.charAt(0)) {
case '#':
    break;
case '[':
  if (line.equals(""String_Node_Str"")) {
    if (currentState != STATE_START) {
      throw ParserException.generateException(lineNumber,ResourceUtil.getString(""String_Node_Str""));
    }
    currentState=STATE_PROCESS_GROUPS;
  }
 else   if (line.indexOf(':') == -1) {
    currentState=STATE_PROCESS_SERVER_RULES;
    String path=line.substring(1,line.length() - 1).trim();
    if (Document.findServerPath(path) != null) {
      throw ParserException.generateException(lineNumber,ResourceUtil.getFormattedString(""String_Node_Str"",path));
    }
    try {
      currentPath=Document.addPath(null,path);
    }
 catch (    ApplicationException ae) {
      throw ParserException.generateException(lineNumber,ae.getMessage());
    }
  }
 else   if (line.indexOf(':') >= 0) {
    currentState=STATE_PROCESS_RULES;
    int index=line.indexOf(':');
    String repository=line.substring(1,index).trim();
    String path=line.substring(index + 1,line.length() - 1).trim();
    Repository repositoryObject=null;
    try {
      repositoryObject=Document.addRepository(repository);
    }
 catch (    ApplicationException ae) {
      throw ParserException.generateException(lineNumber,ae.getMessage());
    }
    if (Document.findPath(repositoryObject,path) != null) {
      Object[] args=new Object[2];
      args[0]=path;
      args[1]=repository;
      throw ParserException.generateException(lineNumber,ResourceUtil.getFormattedString(""String_Node_Str"",args));
    }
    try {
      currentPath=Document.addPath(repositoryObject,path);
    }
 catch (    ApplicationException ae) {
      throw ParserException.generateException(lineNumber,ae.getMessage());
    }
  }
 else {
    throw ParserException.generateException(lineNumber,ResourceUtil.getString(""String_Node_Str""));
  }
break;
case '@':
if (currentState == STATE_PROCESS_RULES || currentState == STATE_PROCESS_SERVER_RULES) {
int index=line.indexOf('=');
String group=line.substring(1,index).trim();
String level=line.substring(index + 1).trim();
if (Document.findGroup(group) == null) {
  throw ParserException.generateException(lineNumber,ResourceUtil.getFormattedString(""String_Node_Str"",group));
}
try {
  Document.addAccessRuleForGroup(currentPath,group,level);
}
 catch (ApplicationException ae) {
  throw ParserException.generateException(lineNumber,ae.getMessage());
}
}
 else {
throw ParserException.generateException(lineNumber,ResourceUtil.getString(""String_Node_Str""));
}
break;
default :
if (currentState == STATE_PROCESS_GROUPS) {
int index=line.indexOf('=');
if (index == -1) {
throw ParserException.generateException(lineNumber,ResourceUtil.getString(""String_Node_Str""));
}
String name=line.substring(0,index).trim();
String members=line.substring(index + 1).trim();
StringTokenizer tokens=new StringTokenizer(members,""String_Node_Str"");
int memberCount=tokens.countTokens();
List<String> groupMembers=new ArrayList<String>();
List<String> userMembers=new ArrayList<String>();
for (int i=0; i < memberCount; i++) {
String member=tokens.nextToken();
if (member.charAt(0) == '@') {
groupMembers.add(member.substring(1,member.length()));
}
 else {
userMembers.add(member);
}
}
Group existingGroup=Document.findGroup(name);
if (existingGroup == null) {
try {
Document.addGroupByName(name,groupMembers,userMembers);
}
 catch (ApplicationException ae) {
throw ParserException.generateException(lineNumber,ae.getMessage());
}
}
 else {
if (existingGroup.getGroupMembers().isEmpty() && existingGroup.getUserMembers().isEmpty()) {
Document.addMembersByName(existingGroup,groupMembers,userMembers);
}
 else {
throw ParserException.generateException(lineNumber,ResourceUtil.getFormattedString(""String_Node_Str"",name));
}
}
}
 else if (currentState == STATE_PROCESS_RULES || currentState == STATE_PROCESS_SERVER_RULES) {
int index=line.indexOf('=');
String user=line.substring(0,index).trim();
String level=line.substring(index + 1).trim();
try {
Document.addAccessRuleForUser(currentPath,user,level);
}
 catch (ApplicationException ae) {
throw ParserException.generateException(lineNumber,ae.getMessage());
}
}
break;
}
}"
87064,"/** 
 * Adds a new Group if one by the same name doesn't already exist. If an existing group exists it will be returned intact.
 * @param groupName Name of the Group.
 * @param groupMembers Group members of the new Group.
 * @param userMembers User members of the new Group.
 * @return Newly created or found Group.
 * @throws ApplicationException
 */
public static Group addGroupByName(String groupName,List<String> groupMemberNames,List<String> userMemberNames) throws ApplicationException {
  Validator.validateGroupName(groupName);
  Group group=findGroup(groupName);
  if (group == null) {
    List<Group> groupMemberList=new ArrayList<Group>();
    List<User> userMemberList=new ArrayList<User>();
    group=new Group(groupName,groupMemberList,userMemberList);
    if (groupMemberNames != null) {
      for (      String groupMemberName : groupMemberNames) {
        Group member=addGroup(groupMemberName);
        member.addGroup(group);
        groupMemberList.add(member);
      }
    }
    if (userMemberNames != null) {
      for (      String userMemberName : userMemberNames) {
        User member=addUser(userMemberName);
        member.addGroup(group);
        userMemberList.add(member);
      }
    }
    groups.add(group);
  }
  setUnsavedChanges();
  return group;
}","/** 
 * Adds a new Group if one by the same name doesn't already exist. If an existing group exists it will be returned intact.
 * @param groupName Name of the Group.
 * @param groupMembers Group members of the new Group.
 * @param userMembers User members of the new Group.
 * @return Newly created or found Group.
 * @throws ApplicationException
 */
public static Group addGroupByName(String groupName,List<String> groupMemberNames,List<String> userMemberNames) throws ApplicationException {
  Validator.validateGroupName(groupName);
  Group group=findGroup(groupName);
  if (group == null) {
    group=new Group(groupName);
    addMembersByName(group,groupMemberNames,userMemberNames);
    groups.add(group);
  }
  setUnsavedChanges();
  return group;
}"
87065,"/** 
 * Add user to groups.
 * @param userName Name of user
 * @param groupNames List of groups
 * @throws ApplicationException Error occurred
 */
private static void addGroups(String userName,String[] groupNames) throws ApplicationException {
  if (userName == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (groupNames == null || groupNames.length < 1) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  User user=Document.findUser(userName);
  if (user == null) {
    throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",userName));
  }
  for (  String groupName : groupNames) {
    Group group=Document.findGroup(groupName);
    if (group == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",groupName));
    }
    user.addGroup(group);
  }
}","/** 
 * Add user to groups.
 * @param userName Name of user
 * @param groupNames List of groups
 * @throws ApplicationException Error occurred
 */
private static void addGroups(String userName,String[] groupNames) throws ApplicationException {
  if (userName == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (groupNames == null || groupNames.length < 1) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  User user=Document.findUser(userName);
  if (user == null) {
    user=Document.addUser(userName);
  }
  for (  String groupName : groupNames) {
    Group group=Document.findGroup(groupName);
    if (group == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",groupName));
    }
    user.addGroup(group);
    group.addUserMember(user);
  }
}"
87066,"/** 
 * Processes command line arguments and initiates command execution.
 * @param args User specified arguments.
 */
private static void processArguments(String[] args){
  JSAP jsap=new JSAP();
  try {
    FlaggedOption opt;
    Switch swtch;
    opt=new FlaggedOption(Constants.ARGS_INPUT_FILE).setStringParser(JSAP.STRING_PARSER).setShortFlag(Constants.ARGS_INPUT_FILE_SHORTFLAG).setLongFlag(Constants.ARGS_INPUT_FILE_LONGFLAG);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_OUTPUT_FILE).setStringParser(JSAP.STRING_PARSER).setShortFlag(Constants.ARGS_OUTPUT_FILE_SHORTFLAG).setLongFlag(Constants.ARGS_OUTPUT_FILE_LONGFLAG);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_HELP).setShortFlag(Constants.ARGS_HELP_SHORTFLAG).setLongFlag(Constants.ARGS_HELP);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_VERBOSE_HELP).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_VERBOSE_HELP);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_VERSION).setShortFlag(Constants.ARGS_VERSION_SHORTFLAG).setLongFlag(Constants.ARGS_VERSION);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NAME).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NAME);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_GROUPS).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GROUPS).setList(true).setListSeparator(',');
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_USERS).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_USERS).setList(true).setListSeparator(',');
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_REPOS).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_REPOS);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_PATH).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_PATH);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_USER).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_USER);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_GROUP).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GROUP);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_ACCESS).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_ACCESS);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NEW_NAME).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NEW_NAME);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NEW_REPOS).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NEW_REPOS);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NEW_PATH).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NEW_PATH);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NEW_USER).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NEW_USER);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NEW_GROUP).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NEW_GROUP);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NEW_ACCESS).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NEW_ACCESS);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_CLONE_USER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_CLONE_USER);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_EDIT_USER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_EDIT_USER);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_DELETE_USER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_DELETE_USER);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_ADD_GROUPS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_ADD_GROUPS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_COUNT_USERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_COUNT_USERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_USERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_USERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_REMOVE_GROUPS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_REMOVE_GROUPS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_USER_GROUPS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_USER_GROUPS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_USER_RULES).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_USER_RULES);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_ADD_GROUP).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_ADD_GROUP);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_CLONE_GROUP).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_CLONE_GROUP);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_EDIT_GROUP).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_EDIT_GROUP);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_DELETE_GROUP).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_DELETE_GROUP);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_ADD_MEMBERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_ADD_MEMBERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_REMOVE_MEMBERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_REMOVE_MEMBERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_COUNT_GROUPS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_COUNT_GROUPS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_GROUPS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_GROUPS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_GROUP_MEMBERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_GROUP_MEMBERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_GROUP_GROUP_MEMBERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_GROUP_GROUP_MEMBERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_GROUP_USER_MEMBERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_GROUP_USER_MEMBERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_GROUP_RULES).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_GROUP_RULES);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_EDIT_REPOS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_EDIT_REPOS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_DELETE_REPOS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_DELETE_REPOS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_COUNT_REPOS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_COUNT_REPOS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_REPOS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_REPOS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_REPOS_RULES).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_REPOS_RULES);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_ADD_RULE).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_ADD_RULE);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_EDIT_RULE).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_EDIT_RULE);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_DELETE_RULE).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_DELETE_RULE);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_COUNT_RULES).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_COUNT_RULES);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_RULES).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_RULES);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_STATISTICS_REPORT).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_STATISTICS_REPORT);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_SUMMARY_REPORT).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_SUMMARY_REPORT);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    JSAPResult config=jsap.parse(args);
    if (!config.success()) {
      System.err.println();
      System.err.println(ResourceUtil.getString(""String_Node_Str""));
      System.exit(1);
    }
    executeCommands(jsap,config);
  }
 catch (  JSAPException e) {
    e.printStackTrace();
  }
}","/** 
 * Processes command line arguments and initiates command execution.
 * @param args User specified arguments.
 */
private static void processArguments(String[] args){
  JSAP jsap=new JSAP();
  try {
    FlaggedOption opt;
    Switch swtch;
    opt=new FlaggedOption(Constants.ARGS_INPUT_FILE).setStringParser(JSAP.STRING_PARSER).setShortFlag(Constants.ARGS_INPUT_FILE_SHORTFLAG).setLongFlag(Constants.ARGS_INPUT_FILE_LONGFLAG);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_OUTPUT_FILE).setStringParser(JSAP.STRING_PARSER).setShortFlag(Constants.ARGS_OUTPUT_FILE_SHORTFLAG).setLongFlag(Constants.ARGS_OUTPUT_FILE_LONGFLAG);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_HELP).setShortFlag(Constants.ARGS_HELP_SHORTFLAG).setLongFlag(Constants.ARGS_HELP);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_VERBOSE_HELP).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_VERBOSE_HELP);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_VERSION).setShortFlag(Constants.ARGS_VERSION_SHORTFLAG).setLongFlag(Constants.ARGS_VERSION);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NAME).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NAME);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_GROUPS).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GROUPS).setList(true).setListSeparator(',');
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_USERS).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_USERS).setList(true).setListSeparator(',');
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_REPOS).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_REPOS);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_PATH).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_PATH);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_USER).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_USER);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_GROUP).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GROUP);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_ACCESS).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_ACCESS);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NEW_NAME).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NEW_NAME);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NEW_REPOS).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NEW_REPOS);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NEW_PATH).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NEW_PATH);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NEW_USER).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NEW_USER);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NEW_GROUP).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NEW_GROUP);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    opt=new FlaggedOption(Constants.ARGS_NEW_ACCESS).setStringParser(JSAP.STRING_PARSER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_NEW_ACCESS);
    jsap.registerParameter(opt.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_CLONE_USER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_CLONE_USER);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_EDIT_USER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_EDIT_USER);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_DELETE_USER).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_DELETE_USER);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_ADD_GROUPS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_ADD_GROUPS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_COUNT_USERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_COUNT_USERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_USERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_USERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_REMOVE_GROUPS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_REMOVE_GROUPS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_USER_GROUPS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_USER_GROUPS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_USER_RULES).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_USER_RULES);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_ADD_GROUP).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_ADD_GROUP);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_CLONE_GROUP).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_CLONE_GROUP);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_EDIT_GROUP).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_EDIT_GROUP);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_DELETE_GROUP).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_DELETE_GROUP);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_ADD_MEMBERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_ADD_MEMBERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_REMOVE_MEMBERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_REMOVE_MEMBERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_COUNT_GROUPS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_COUNT_GROUPS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_GROUPS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_GROUPS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_GROUP_MEMBERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_GROUP_MEMBERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_GROUP_GROUP_MEMBERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_GROUP_GROUP_MEMBERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_GROUP_USER_MEMBERS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_GROUP_USER_MEMBERS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_GROUP_RULES).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_GROUP_RULES);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_EDIT_REPOS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_EDIT_REPOS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_DELETE_REPOS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_DELETE_REPOS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_COUNT_REPOS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_COUNT_REPOS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_REPOS).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_REPOS);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_REPOS_RULES).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_REPOS_RULES);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_ADD_RULE).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_ADD_RULE);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_EDIT_RULE).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_EDIT_RULE);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_DELETE_RULE).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_DELETE_RULE);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_COUNT_RULES).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_COUNT_RULES);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_GET_RULES).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_GET_RULES);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_STATISTICS_REPORT).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_STATISTICS_REPORT);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    swtch=new Switch(Constants.ARGS_SUMMARY_REPORT).setShortFlag(JSAP.NO_SHORTFLAG).setLongFlag(Constants.ARGS_SUMMARY_REPORT);
    jsap.registerParameter(swtch.setHelp(ResourceUtil.getString(""String_Node_Str"")));
    JSAPResult config=jsap.parse(args);
    if (!config.success()) {
      System.err.println();
      System.err.println(ResourceUtil.getString(""String_Node_Str""));
      System.err.println();
      System.exit(1);
    }
    executeCommands(jsap,config);
  }
 catch (  JSAPException e) {
    e.printStackTrace();
  }
}"
87067,"/** 
 * Removes user from groups.
 * @param userName Name of user
 * @param groupNames List of groups
 * @throws ApplicationException Error occurred
 */
private static void removeGroups(String userName,String[] groupNames) throws ApplicationException {
  if (userName == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (groupNames == null || groupNames.length < 1) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  User user=Document.findUser(userName);
  if (user == null) {
    throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",userName));
  }
  for (  String groupName : groupNames) {
    Group group=Document.findGroup(groupName);
    if (group == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",groupName));
    }
    user.removeGroup(group);
  }
}","/** 
 * Removes user from groups.
 * @param userName Name of user
 * @param groupNames List of groups
 * @throws ApplicationException Error occurred
 */
private static void removeGroups(String userName,String[] groupNames) throws ApplicationException {
  if (userName == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (groupNames == null || groupNames.length < 1) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  User user=Document.findUser(userName);
  if (user == null) {
    throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",userName));
  }
  for (  String groupName : groupNames) {
    Group group=Document.findGroup(groupName);
    if (group == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",groupName));
    }
    user.removeGroup(group);
    group.removeUserMember(user);
  }
}"
87068,"/** 
 * Executes commands specified as application arguments parsed by JSAP. Output is directed to System.out by default or to an output file if one is specified.  Application help, verbose help and version commands are processed  immediately. All remaining arguments are ignored. If neither of these commands are specified then the arguments are checked for an input file directive. If no input file was specified then input is pulled from System.in. Finally, all remaining commands are executed against the specified input stream.
 * @param jsap JSAP results
 * @param config JSAP configuration
 */
private static void executeCommands(JSAP jsap,JSAPResult config){
  PrintStream out=null;
  try {
    if (config.getString(Constants.ARGS_OUTPUT_FILE) != null) {
      out=openOutputFile(config.getString(Constants.ARGS_OUTPUT_FILE));
    }
 else {
      out=System.out;
    }
    if (config.getBoolean(Constants.ARGS_HELP)) {
      displayUsage(out,jsap);
      System.exit(0);
    }
 else     if (config.getBoolean(Constants.ARGS_VERBOSE_HELP)) {
      displayVerboseHelp(out,jsap);
      System.exit(0);
    }
 else     if (config.getBoolean(Constants.ARGS_VERSION)) {
      displayVersion(out);
      System.exit(0);
    }
    if (config.getString(Constants.ARGS_INPUT_FILE) == null) {
      FileParser.parse(System.in);
    }
 else {
      FileParser.parse(new File(config.getString(Constants.ARGS_INPUT_FILE)));
    }
    if (config.getBoolean(Constants.ARGS_STATISTICS_REPORT)) {
      GenericReport report=new StatisticsReport();
      out.print(report.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_SUMMARY_REPORT)) {
      GenericReport report=new SummaryReport();
      out.print(report.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_CLONE_USER)) {
      cloneUser(config.getString(Constants.ARGS_NAME),config.getString(Constants.ARGS_NEW_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_EDIT_USER)) {
      editUser(config.getString(Constants.ARGS_NAME),config.getString(Constants.ARGS_NEW_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_DELETE_USER)) {
      deleteUser(config.getString(Constants.ARGS_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_ADD_GROUPS)) {
      addGroups(config.getString(Constants.ARGS_NAME),config.getStringArray(Constants.ARGS_GROUPS));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_REMOVE_GROUPS)) {
      removeGroups(config.getString(Constants.ARGS_NAME),config.getStringArray(Constants.ARGS_GROUPS));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_COUNT_USERS)) {
      countUsers(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_USERS)) {
      getUsers(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_USER_GROUPS)) {
      getUserGroups(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_GET_USER_RULES)) {
      getUserRules(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_ADD_GROUP)) {
      addGroup(config.getString(Constants.ARGS_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_CLONE_GROUP)) {
      cloneGroup(config.getString(Constants.ARGS_NAME),config.getString(Constants.ARGS_NEW_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_EDIT_GROUP)) {
      editGroup(config.getString(Constants.ARGS_NAME),config.getString(Constants.ARGS_NEW_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_DELETE_GROUP)) {
      deleteGroup(config.getString(Constants.ARGS_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_ADD_MEMBERS)) {
      addMembers(config.getString(Constants.ARGS_NAME),config.getStringArray(Constants.ARGS_USERS),config.getStringArray(Constants.ARGS_GROUPS));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_REMOVE_MEMBERS)) {
      removeMembers(config.getString(Constants.ARGS_NAME),config.getStringArray(Constants.ARGS_USERS),config.getStringArray(Constants.ARGS_GROUPS));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_COUNT_GROUPS)) {
      countGroups(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_GROUPS)) {
      getGroups(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_GROUP_MEMBERS)) {
      getGroupMembers(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_GET_GROUP_GROUP_MEMBERS)) {
      getGroupGroupMembers(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_GET_GROUP_USER_MEMBERS)) {
      getGroupUserMembers(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_GET_GROUP_RULES)) {
      getGroupRules(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_EDIT_REPOS)) {
      editRepository(config.getString(Constants.ARGS_NAME),config.getString(Constants.ARGS_NEW_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_DELETE_REPOS)) {
      deleteRepository(config.getString(Constants.ARGS_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_COUNT_REPOS)) {
      countRepositories(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_REPOS)) {
      getRepositories(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_REPOS_RULES)) {
      getRepositoryRules(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_ADD_RULE)) {
      addRule(config.getString(Constants.ARGS_REPOS),config.getString(Constants.ARGS_PATH),config.getString(Constants.ARGS_USER),config.getString(Constants.ARGS_GROUP),config.getString(Constants.ARGS_ACCESS));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_EDIT_RULE)) {
      editRule(config.getString(Constants.ARGS_REPOS),config.getString(Constants.ARGS_PATH),config.getString(Constants.ARGS_USER),config.getString(Constants.ARGS_GROUP),config.getString(Constants.ARGS_NEW_REPOS),config.getString(Constants.ARGS_NEW_PATH),config.getString(Constants.ARGS_NEW_USER),config.getString(Constants.ARGS_NEW_GROUP),config.getString(Constants.ARGS_NEW_ACCESS));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_DELETE_RULE)) {
      deleteRule(config.getString(Constants.ARGS_REPOS),config.getString(Constants.ARGS_PATH),config.getString(Constants.ARGS_USER),config.getString(Constants.ARGS_GROUP));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_COUNT_RULES)) {
      countRules(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_RULES)) {
      getRules(out);
    }
    if (config.getString(Constants.ARGS_OUTPUT_FILE) != null) {
      out.close();
      out=null;
    }
  }
 catch (  Exception e) {
    System.err.println(e.getMessage());
    System.exit(1);
  }
}","/** 
 * Executes commands specified as application arguments parsed by JSAP. Output is directed to System.out by default or to an output file if one is specified.  Application help, verbose help and version commands are processed  immediately. All remaining arguments are ignored. If neither of these commands are specified then the arguments are checked for an input file directive. If no input file was specified then input is pulled from System.in. Finally, all remaining commands are executed against the specified input stream.
 * @param jsap JSAP results
 * @param config JSAP configuration
 */
private static void executeCommands(JSAP jsap,JSAPResult config){
  PrintStream out=System.out;
  try {
    if (config.getBoolean(Constants.ARGS_HELP)) {
      displayUsage(out,jsap);
      System.exit(0);
    }
 else     if (config.getBoolean(Constants.ARGS_VERBOSE_HELP)) {
      displayVerboseHelp(out,jsap);
      System.exit(0);
    }
 else     if (config.getBoolean(Constants.ARGS_VERSION)) {
      displayVersion(out);
      System.exit(0);
    }
    if (config.getString(Constants.ARGS_INPUT_FILE) == null) {
      FileParser.parse(System.in);
    }
 else {
      FileParser.parse(new File(config.getString(Constants.ARGS_INPUT_FILE)));
    }
    if (config.getString(Constants.ARGS_OUTPUT_FILE) != null) {
      out=openOutputFile(config.getString(Constants.ARGS_OUTPUT_FILE));
    }
    if (config.getBoolean(Constants.ARGS_STATISTICS_REPORT)) {
      GenericReport report=new StatisticsReport();
      out.print(report.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_SUMMARY_REPORT)) {
      GenericReport report=new SummaryReport();
      out.print(report.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_CLONE_USER)) {
      cloneUser(config.getString(Constants.ARGS_NAME),config.getString(Constants.ARGS_NEW_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_EDIT_USER)) {
      editUser(config.getString(Constants.ARGS_NAME),config.getString(Constants.ARGS_NEW_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_DELETE_USER)) {
      deleteUser(config.getString(Constants.ARGS_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_ADD_GROUPS)) {
      addGroups(config.getString(Constants.ARGS_NAME),config.getStringArray(Constants.ARGS_GROUPS));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_REMOVE_GROUPS)) {
      removeGroups(config.getString(Constants.ARGS_NAME),config.getStringArray(Constants.ARGS_GROUPS));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_COUNT_USERS)) {
      countUsers(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_USERS)) {
      getUsers(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_USER_GROUPS)) {
      getUserGroups(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_GET_USER_RULES)) {
      getUserRules(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_ADD_GROUP)) {
      addGroup(config.getString(Constants.ARGS_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_CLONE_GROUP)) {
      cloneGroup(config.getString(Constants.ARGS_NAME),config.getString(Constants.ARGS_NEW_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_EDIT_GROUP)) {
      editGroup(config.getString(Constants.ARGS_NAME),config.getString(Constants.ARGS_NEW_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_DELETE_GROUP)) {
      deleteGroup(config.getString(Constants.ARGS_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_ADD_MEMBERS)) {
      addMembers(config.getString(Constants.ARGS_NAME),config.getStringArray(Constants.ARGS_USERS),config.getStringArray(Constants.ARGS_GROUPS));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_REMOVE_MEMBERS)) {
      removeMembers(config.getString(Constants.ARGS_NAME),config.getStringArray(Constants.ARGS_USERS),config.getStringArray(Constants.ARGS_GROUPS));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_COUNT_GROUPS)) {
      countGroups(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_GROUPS)) {
      getGroups(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_GROUP_MEMBERS)) {
      getGroupMembers(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_GET_GROUP_GROUP_MEMBERS)) {
      getGroupGroupMembers(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_GET_GROUP_USER_MEMBERS)) {
      getGroupUserMembers(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_GET_GROUP_RULES)) {
      getGroupRules(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_EDIT_REPOS)) {
      editRepository(config.getString(Constants.ARGS_NAME),config.getString(Constants.ARGS_NEW_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_DELETE_REPOS)) {
      deleteRepository(config.getString(Constants.ARGS_NAME));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_COUNT_REPOS)) {
      countRepositories(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_REPOS)) {
      getRepositories(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_REPOS_RULES)) {
      getRepositoryRules(out,config.getString(Constants.ARGS_NAME));
    }
 else     if (config.getBoolean(Constants.ARGS_ADD_RULE)) {
      addRule(config.getString(Constants.ARGS_REPOS),config.getString(Constants.ARGS_PATH),config.getString(Constants.ARGS_USER),config.getString(Constants.ARGS_GROUP),config.getString(Constants.ARGS_ACCESS));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_EDIT_RULE)) {
      editRule(config.getString(Constants.ARGS_REPOS),config.getString(Constants.ARGS_PATH),config.getString(Constants.ARGS_USER),config.getString(Constants.ARGS_GROUP),config.getString(Constants.ARGS_NEW_REPOS),config.getString(Constants.ARGS_NEW_PATH),config.getString(Constants.ARGS_NEW_USER),config.getString(Constants.ARGS_NEW_GROUP),config.getString(Constants.ARGS_NEW_ACCESS));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_DELETE_RULE)) {
      deleteRule(config.getString(Constants.ARGS_REPOS),config.getString(Constants.ARGS_PATH),config.getString(Constants.ARGS_USER),config.getString(Constants.ARGS_GROUP));
      out.print(FileGenerator.generate());
    }
 else     if (config.getBoolean(Constants.ARGS_COUNT_RULES)) {
      countRules(out);
    }
 else     if (config.getBoolean(Constants.ARGS_GET_RULES)) {
      getRules(out);
    }
    if (config.getString(Constants.ARGS_OUTPUT_FILE) != null) {
      out.close();
      out=null;
    }
  }
 catch (  Exception e) {
    System.err.println(e.getMessage());
    System.exit(1);
  }
}"
87069,"/** 
 * Edits an existing access rule. Either user or group name, but not both  must be specified. Arguments prefixed with ""new"" indicate new values for the access rule. Multiple changes may be specified at once.
 * @param repositoryName Repository name
 * @param path Relative path string
 * @param userName User name
 * @param groupName Group name
 * @param newRepositoryName New repository name
 * @param newPathString New relative path string
 * @param newUserName New user name
 * @param newGroupName New group name
 * @param newAccess New access level
 * @throws ApplicationException Error occurred
 */
private static void editRule(String repositoryName,String path,String userName,String groupName,String newRepositoryName,String newPathString,String newUserName,String newGroupName,String newAccess) throws ApplicationException {
  if (path == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (userName == null && groupName == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (userName != null && groupName != null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (newUserName != null && newGroupName != null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  AccessRule rule=null;
  if (userName == null) {
    User user=Document.findUser(userName);
    if (user == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",userName));
    }
    Repository repository=null;
    if (repositoryName != null) {
      repository=Document.findRepository(repositoryName);
      if (repository == null) {
        throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",repositoryName));
      }
    }
    rule=Document.findUserAccessRule(repository,path,user);
    if (rule == null) {
      throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
    }
  }
 else   if (groupName == null) {
    Group group=Document.findGroup(groupName);
    if (group == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",groupName));
    }
    Repository repository=null;
    if (repositoryName != null) {
      repository=Document.findRepository(repositoryName);
      if (repository == null) {
        throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",repositoryName));
      }
    }
    rule=Document.findGroupAccessRule(repository,path,group);
    if (rule == null) {
      throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
    }
  }
 else {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (newRepositoryName != null) {
    Repository newRepository=Document.findRepository(newRepositoryName);
    if (newRepository == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",repositoryName));
    }
    rule.getPath().setRepository(newRepository);
  }
  if (newPathString != null) {
    Path newPath=Document.addPath(rule.getPath().getRepository(),newPathString);
    rule.setPath(newPath);
  }
  if (newUserName != null) {
    User newUser=Document.addUser(newUserName);
    if (newUser == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",userName));
    }
    rule.setUser(newUser);
    rule.setGroup(null);
  }
  if (newGroupName != null) {
    Group newGroup=Document.findGroup(newGroupName);
    if (newGroup == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",groupName));
    }
    rule.setUser(null);
    rule.setGroup(newGroup);
  }
  if (newAccess != null) {
    String newAccessLevel=(newAccess.equals(Constants.ACCESS_LEVEL_NONE)) ? Constants.ACCESS_LEVEL_DENY_ACCESS : newAccess;
    rule.setLevel(newAccessLevel);
  }
}","/** 
 * Edits an existing access rule. Either user or group name, but not both  must be specified. Arguments prefixed with ""new"" indicate new values for the access rule. Multiple changes may be specified at once.
 * @param repositoryName Repository name
 * @param path Relative path string
 * @param userName User name
 * @param groupName Group name
 * @param newRepositoryName New repository name
 * @param newPathString New relative path string
 * @param newUserName New user name
 * @param newGroupName New group name
 * @param newAccess New access level
 * @throws ApplicationException Error occurred
 */
private static void editRule(String repositoryName,String path,String userName,String groupName,String newRepositoryName,String newPathString,String newUserName,String newGroupName,String newAccess) throws ApplicationException {
  if (path == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (userName == null && groupName == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (userName != null && groupName != null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (newUserName != null && newGroupName != null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  AccessRule rule=null;
  if (userName != null) {
    User user=Document.findUser(userName);
    if (user == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",userName));
    }
    Repository repository=null;
    if (repositoryName != null) {
      repository=Document.findRepository(repositoryName);
      if (repository == null) {
        throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",repositoryName));
      }
    }
    rule=Document.findUserAccessRule(repository,path,user);
    if (rule == null) {
      throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
    }
  }
 else   if (groupName != null) {
    Group group=Document.findGroup(groupName);
    if (group == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",groupName));
    }
    Repository repository=null;
    if (repositoryName != null) {
      repository=Document.findRepository(repositoryName);
      if (repository == null) {
        throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",repositoryName));
      }
    }
    rule=Document.findGroupAccessRule(repository,path,group);
    if (rule == null) {
      throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
    }
  }
 else {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (newRepositoryName != null) {
    Repository newRepository=Document.findRepository(newRepositoryName);
    if (newRepository == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",repositoryName));
    }
    rule.getPath().setRepository(newRepository);
  }
  if (newPathString != null) {
    Path newPath=Document.addPath(rule.getPath().getRepository(),newPathString);
    rule.setPath(newPath);
  }
  if (newUserName != null) {
    User newUser=Document.addUser(newUserName);
    if (newUser == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",userName));
    }
    rule.setUser(newUser);
    rule.setGroup(null);
  }
  if (newGroupName != null) {
    Group newGroup=Document.findGroup(newGroupName);
    if (newGroup == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",groupName));
    }
    rule.setUser(null);
    rule.setGroup(newGroup);
  }
  if (newAccess != null) {
    String newAccessLevel=(newAccess.equals(Constants.ACCESS_LEVEL_NONE)) ? Constants.ACCESS_LEVEL_DENY_ACCESS : newAccess;
    rule.setLevel(newAccessLevel);
  }
}"
87070,"/** 
 * Add new user and/or group members to an existing group. New user and  group members may be added at the same time. At least one user or group name is required.
 * @param groupName Group name to be updated
 * @param userNames User names of new members
 * @param groupNames Group names of new members
 * @throws ApplicationException Error occurred
 */
private static void addMembers(String groupName,String[] userNames,String[] groupNames) throws ApplicationException {
  if (groupName == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if ((userNames == null || userNames.length < 1) && (groupNames == null || groupNames.length < 1)) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  Group group=Document.findGroup(groupName);
  if (group == null) {
    throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",groupName));
  }
  for (  String memberUserName : userNames) {
    User memberUser=Document.findUser(memberUserName);
    if (memberUser == null) {
      memberUser=Document.addUser(memberUserName);
    }
    group.addUserMember(memberUser);
  }
  for (  String memberGroupName : groupNames) {
    Group memberGroup=Document.findGroup(memberGroupName);
    if (memberGroup == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",groupName));
    }
    group.addGroupMember(memberGroup);
  }
}","/** 
 * Add new user and/or group members to an existing group. New user and  group members may be added at the same time. At least one user or group name is required.
 * @param groupName Group name to be updated
 * @param userNames User names of new members
 * @param groupNames Group names of new members
 * @throws ApplicationException Error occurred
 */
private static void addMembers(String groupName,String[] userNames,String[] groupNames) throws ApplicationException {
  if (groupName == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if ((userNames == null || userNames.length < 1) && (groupNames == null || groupNames.length < 1)) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  Group group=Document.findGroup(groupName);
  if (group == null) {
    throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",groupName));
  }
  for (  String memberUserName : userNames) {
    User memberUser=Document.findUser(memberUserName);
    if (memberUser == null) {
      memberUser=Document.addUser(memberUserName);
    }
    group.addUserMember(memberUser);
  }
  for (  String memberGroupName : groupNames) {
    Group memberGroup=Document.findGroup(memberGroupName);
    if (memberGroup == null) {
      throw new ApplicationException(ResourceUtil.getFormattedString(""String_Node_Str"",memberGroupName));
    }
    group.addGroupMember(memberGroup);
  }
}"
87071,"/** 
 * Add a new access rule. Either user or group name, but not both must be  specified. All other arguments are required.
 * @param repositoryName Repository name
 * @param path Relative path string
 * @param userName User name
 * @param groupName Group name
 * @param access Access level
 * @throws ApplicationException Error occurred
 */
private static void addRule(String repositoryName,String path,String userName,String groupName,String access) throws ApplicationException {
  if (path == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (userName == null && groupName == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (userName != null && groupName != null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (access == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  access=access.equals(Constants.ACCESS_LEVEL_NONE) ? Constants.ACCESS_LEVEL_DENY_ACCESS : access;
  if (userName != null) {
    if (repositoryName == null) {
      Document.addServerAccessRuleForUser(userName,access);
    }
 else {
      Document.addAccessRuleForUser(Document.addRepository(repositoryName),path,Document.addUser(userName),access);
    }
  }
 else   if (groupName != null) {
    if (repositoryName == null) {
      Document.addServerAccessRuleForGroup(groupName,access);
    }
 else {
      Document.addAccessRuleForGroup(Document.addRepository(repositoryName),path,Document.addGroup(groupName,null,null),access);
    }
  }
 else {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
}","/** 
 * Add a new access rule. Either user or group name, but not both must be  specified. All other arguments are required.
 * @param repositoryName Repository name
 * @param path Relative path string
 * @param userName User name
 * @param groupName Group name
 * @param access Access level
 * @throws ApplicationException Error occurred
 */
private static void addRule(String repositoryName,String path,String userName,String groupName,String access) throws ApplicationException {
  if (path == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (userName == null && groupName == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (userName != null && groupName != null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  if (access == null) {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
  access=access.equals(Constants.ACCESS_LEVEL_NONE) ? Constants.ACCESS_LEVEL_DENY_ACCESS : access;
  if (userName != null) {
    if (repositoryName == null) {
      Document.addAccessRuleForUser(null,path,Document.addUser(userName),access);
    }
 else {
      Document.addAccessRuleForUser(Document.addRepository(repositoryName),path,Document.addUser(userName),access);
    }
  }
 else   if (groupName != null) {
    if (repositoryName == null) {
      Document.addAccessRuleForGroup(null,path,Document.addGroup(groupName,null,null),access);
    }
 else {
      Document.addAccessRuleForGroup(Document.addRepository(repositoryName),path,Document.addGroup(groupName,null,null),access);
    }
  }
 else {
    throw new ApplicationException(ResourceUtil.getString(""String_Node_Str""));
  }
}"
87072,"/** 
 * This method initializes fileToolBar
 * @return javax.swing.JToolBar
 */
private JToolBar getActionToolBar(){
  if (actionToolBar == null) {
    actionToolBar=new JToolBar();
    actionToolBar.setFloatable(true);
    actionToolBar.add(getAddUserToolbarButton());
    actionToolBar.add(getAddGroupToolbarButton());
    actionToolBar.add(getAddAccessRuleButton());
    actionToolBar.add(getPreviewToolbarButton());
  }
  return actionToolBar;
}","/** 
 * This method initializes fileToolBar
 * @return javax.swing.JToolBar
 */
private JToolBar getActionToolBar(){
  if (actionToolBar == null) {
    actionToolBar=new JToolBar();
    actionToolBar.setFloatable(false);
    actionToolBar.add(getNewToolbarButton());
    actionToolBar.add(getOpenToolbarButton());
    actionToolBar.add(getSaveToolbarButton());
    actionToolBar.add(getSaveAsToolbarButton());
    actionToolBar.add(getAddUserToolbarButton());
    actionToolBar.add(getAddGroupToolbarButton());
    actionToolBar.add(getAddAccessRuleButton());
    actionToolBar.add(getPreviewToolbarButton());
  }
  return actionToolBar;
}"
87073,"/** 
 * Create a new ZAliasedName given it's full name.
 * @param fullname The full name: [[schema.]table.]column
 * @param form The name form (FORM_TABLE or FORM_COLUMN)
 */
public ZAliasedName(final String fullname,final int form){
  this.formColumn=form;
  this.strform=new String(fullname);
  final StringTokenizer st=new StringTokenizer(fullname,""String_Node_Str"");
switch (st.countTokens()) {
case ZAliasedName.MAGIC_NUMBER_1:
    if (form == ZAliasedName.FORM_TABLE) {
      this.table=new String(st.nextToken());
    }
 else {
      this.column=new String(st.nextToken());
    }
  break;
case ZAliasedName.MAGIC_NUMBER_2:
if (form == ZAliasedName.FORM_TABLE) {
  this.schema=new String(st.nextToken());
  this.table=new String(st.nextToken());
}
 else {
  this.table=new String(st.nextToken());
  this.column=new String(st.nextToken());
}
break;
case ZAliasedName.MAGIC_NUMBER_3:
default :
this.schema=new String(st.nextToken());
this.table=new String(st.nextToken());
this.column=new String(st.nextToken());
break;
}
this.schema=this.postProcess(this.schema);
this.table=this.postProcess(this.table);
this.column=this.postProcess(this.column);
}","/** 
 * Create a new ZAliasedName given it's full name.
 * @param fullname The full name: [[schema.]table.]column
 * @param form The name form (FORM_TABLE or FORM_COLUMN)
 */
public ZAliasedName(final String fullname,final int form){
  this.formColumn=form;
  this.strform=new String(fullname);
  final StringTokenizer st=new StringTokenizer(fullname,""String_Node_Str"");
switch (st.countTokens()) {
case ZAliasedName.MAGIC_NUMBER_1:
    if (form == ZAliasedName.FORM_TABLE) {
      this.table=new String(st.nextToken());
    }
 else {
      this.column=new String(st.nextToken());
    }
  break;
case ZAliasedName.MAGIC_NUMBER_2:
if (form == ZAliasedName.FORM_TABLE) {
  this.schema=new String(st.nextToken());
  this.table=new String(st.nextToken());
}
 else {
  this.table=new String(st.nextToken());
  this.column=new String(st.nextToken());
}
break;
case ZAliasedName.MAGIC_NUMBER_3:
default :
this.schema=new String(st.nextToken());
this.table=new String(st.nextToken());
this.column=new String(st.nextToken());
break;
}
if (this.schema != null) {
this.schema=this.postProcess(this.schema);
}
if (this.table != null) {
this.table=this.postProcess(this.table);
}
if (this.column != null) {
this.column=this.postProcess(this.column);
}
}"
87074,"/** 
 * Post process.
 * @param val the value.
 * @return the trimmed query
 */
private String postProcess(final String val){
  String result=null;
  if (val == null) {
    result=null;
  }
  if (val.indexOf(ZAliasedName.LEFT_BRACE) >= 0) {
    result=val.substring(val.lastIndexOf(ZAliasedName.LEFT_BRACE) + 1);
  }
  if (val.indexOf(ZAliasedName.RIGHT_BRACE) >= 0) {
    result=val.substring(0,val.indexOf(ZAliasedName.RIGHT_BRACE));
  }
  return result.trim();
}","/** 
 * Post process.
 * @param val the value.
 * @return the trimmed query
 */
private String postProcess(final String val){
  String result=null;
  if (val == null) {
    result=null;
  }
  if (val.indexOf(ZAliasedName.LEFT_BRACE) >= 0) {
    result=val.substring(val.lastIndexOf(ZAliasedName.LEFT_BRACE) + 1);
  }
  if (val.indexOf(ZAliasedName.RIGHT_BRACE) >= 0) {
    result=val.substring(0,val.indexOf(ZAliasedName.RIGHT_BRACE));
  }
  if (result == null && val != null) {
    result=val;
  }
  return result.trim();
}"
87075,"/** 
 * Get the aggregate call.
 * @param c the call string.
 * @return the aggregate call.
 */
public static String getAggregateCall(final String c){
  final int pos=c.indexOf('(');
  String result;
  if (pos <= 0) {
    result=null;
  }
  final String call=c.substring(0,pos);
  if (ZUtils.isAggregate(call)) {
    result=call.trim();
  }
 else {
    result=null;
  }
  return result;
}","/** 
 * Get the aggregate call.
 * @param c the call string.
 * @return the aggregate call.
 */
public static String getAggregateCall(final String c){
  final int pos=c.indexOf('(');
  String result;
  if (pos <= 0) {
    result=null;
  }
 else {
    final String call=c.substring(0,pos);
    if (ZUtils.isAggregate(call)) {
      result=call.trim();
    }
 else {
      result=null;
    }
  }
  if (result == null && c != null) {
    result=c;
  }
  return result;
}"
87076,"/** 
 * Return the name of the attribute corresponding to the index.
 * @param index integer giving the index of the attribute
 * @return a String
 */
public final String getAttName(final int index){
  String getAttributeName;
  try {
    getAttributeName=(String)this.attributes.elementAt(index);
  }
 catch (  final ArrayIndexOutOfBoundsException e) {
    getAttributeName=null;
  }
  return getAttributeName;
}","/** 
 * Return the name of the attribute corresponding to the index.
 * @param index integer giving the index of the attribute
 * @return a String
 */
public String getAttName(final int index){
  String getAttributeName;
  try {
    getAttributeName=(String)this.attributes.elementAt(index);
  }
 catch (  final ArrayIndexOutOfBoundsException e) {
    getAttributeName=null;
  }
  return getAttributeName;
}"
87077,"/** 
 * Return the value of the attribute whith the given name.
 * @param name the name of the attribute.
 * @return an Object (null if name is not an existing attribute)
 */
public final Object getAttValue(final String name){
  boolean exist=false;
  if (name != null) {
    exist=this.searchTable.containsKey(name);
  }
  Object getAttributeValue;
  if (exist) {
    final int index=((Integer)this.searchTable.get(name)).intValue();
    getAttributeValue=this.values.elementAt(index);
  }
 else {
    getAttributeValue=null;
  }
  return getAttributeValue;
}","/** 
 * Return the value of the attribute whith the given name.
 * @param name the name of the attribute.
 * @return an Object (null if name is not an existing attribute)
 */
public Object getAttValue(final String name){
  boolean exist=false;
  if (name != null) {
    exist=this.searchTable.containsKey(name);
  }
  Object getAttributeValue;
  if (exist) {
    final int index=((Integer)this.searchTable.get(name)).intValue();
    getAttributeValue=this.values.elementAt(index);
  }
 else {
    getAttributeValue=null;
  }
  return getAttributeValue;
}"
87078,"public void generateJSON(Class clazz){
  Field[] SMClasses=getAllFields(clazz);
  searchForSMClasses(clazz,SMClasses);
}","public void generateJSON(Class clazz){
  Field[] SMClasses=getAllFields(clazz);
  searchForClasses(clazz,SMClasses);
}"
87079,"public ClassConverter(Class clazz,String location){
  System.out.println();
  this.listOfFields=getAllFields(clazz);
  this.location=location;
  searchForSMClasses(clazz,this.listOfFields);
}","public ClassConverter(Class clazz,String location){
  this.fields=getAllFields(clazz);
  this.location=location;
  searchForClasses(clazz,this.fields);
}"
87080,"public void dump(){
  if (!log.isDebugEnabled())   return;
  StringBuilder sb=new StringBuilder();
  for (  RemoteAddress address : channels.keySet()) {
    sb.append(""String_Node_Str"");
    sb.append(address.toString());
    for (    Integer i : channels.get(address)) {
      sb.append(""String_Node_Str"");
      sb.append(i);
      sb.append(""String_Node_Str"");
      if (isChannelIdle.get(i))       sb.append(""String_Node_Str"");
 else       sb.append(""String_Node_Str"");
    }
  }
  log.debug(sb.toString());
}","public void dump(){
  if (!log.isDebugEnabled())   return;
  StringBuilder sb=new StringBuilder();
synchronized (channels) {
    for (    RemoteAddress address : channels.keySet()) {
      sb.append(""String_Node_Str"");
      sb.append(address.toString());
      for (      Integer i : channels.get(address)) {
        sb.append(""String_Node_Str"");
        sb.append(i);
        sb.append(""String_Node_Str"");
        if (isChannelIdle.get(i))         sb.append(""String_Node_Str"");
 else         sb.append(""String_Node_Str"");
      }
    }
  }
  log.debug(sb.toString());
}"
87081,"private ChannelFutureListener getMITMChannelFutureListener(){
  return new ChannelFutureListener(){
    public void operationComplete(    final ChannelFuture inboundFuture){
      log.debug(""String_Node_Str"",inboundFuture.getChannel().getId());
      final ChannelPipeline pipe=inboundFuture.getChannel().getPipeline();
      pipe.getChannel().setReadable(false);
      while (pipe.getFirst() != null)       pipe.removeFirst();
      SSLEngine engine=context.createSSLEngine();
      engine.setUseClientMode(false);
      NextProtoNego.put(engine,new SimpleServerProvider());
      if (log.isDebugEnabled())       NextProtoNego.debug=true;
      pipe.addLast(""String_Node_Str"",new SslHandler(engine));
      pipe.addLast(""String_Node_Str"",new HttpOrSpdyDecoder(new HttpProxyHandler()));
      pipe.getChannel().setReadable(true);
    }
  }
;
}","private ChannelFutureListener getMITMChannelFutureListener(){
  return new ChannelFutureListener(){
    public void operationComplete(    final ChannelFuture inboundFuture){
      log.debug(""String_Node_Str"",inboundFuture.getChannel().getId());
      final ChannelPipeline pipe=inboundFuture.getChannel().getPipeline();
      while (pipe.getFirst() != null)       pipe.removeFirst();
      SSLEngine engine=context.createSSLEngine();
      engine.setUseClientMode(false);
      NextProtoNego.put(engine,new SimpleServerProvider());
      if (log.isDebugEnabled())       NextProtoNego.debug=true;
      pipe.addLast(""String_Node_Str"",new SslHandler(engine));
      pipe.addLast(""String_Node_Str"",new HttpOrSpdyDecoder(new HttpProxyHandler()));
      pipe.getChannel().setReadable(true);
    }
  }
;
}"
87082,"private ChannelFutureListener getPassthroughChannelFutureListener(final Channel outboundChannel){
  return new ChannelFutureListener(){
    public void operationComplete(    ChannelFuture inboundFuture){
      log.debug(""String_Node_Str"",inboundFuture.getChannel().getId());
      final Channel inboundChannel=inboundFuture.getChannel();
      inboundChannel.setReadable(false);
      while (inboundChannel.getPipeline().getFirst() != null)       inboundChannel.getPipeline().removeFirst();
      inboundChannel.getPipeline().addLast(""String_Node_Str"",new PassthroughHandler(outboundChannel));
      inboundChannel.setReadable(true);
    }
  }
;
}","private ChannelFutureListener getPassthroughChannelFutureListener(final Channel outboundChannel){
  return new ChannelFutureListener(){
    public void operationComplete(    ChannelFuture inboundFuture){
      log.debug(""String_Node_Str"",inboundFuture.getChannel().getId());
      final Channel inboundChannel=inboundFuture.getChannel();
      while (inboundChannel.getPipeline().getFirst() != null)       inboundChannel.getPipeline().removeFirst();
      inboundChannel.getPipeline().addLast(""String_Node_Str"",new PassthroughHandler(outboundChannel));
      inboundChannel.setReadable(true);
    }
  }
;
}"
87083,"@Override public void messageReceived(final ChannelHandlerContext ctx,final MessageEvent e) throws Exception {
  final HttpRequest request=(HttpRequest)e.getMessage();
  if (request.getMethod().equals(HttpMethod.CONNECT)) {
    log.info(""String_Node_Str"",e.getChannel().getId(),request.getUri());
    log.debug(""String_Node_Str"",e.getChannel().getId(),request.toString());
    RemoteAddress address=RemoteAddress.parseRequest(request);
    if (context != null && address.getPort() == 443)     address=new RemoteAddress(address.getHost(),80);
    final ChannelPipelineFactory factory=getPipelineFactory(e.getChannel());
    final ChannelFuture outboundFuture=OutboundChannelPool.getInstance().getNewChannelFuture(address,factory);
    outboundFuture.addListener(new ChannelFutureListener(){
      public void operationComplete(      final ChannelFuture outboundFuture){
        log.info(""String_Node_Str"",e.getChannel().getId());
        final ChannelFuture inboundFuture=ctx.getChannel().write(getHttpResponseOk());
        if (context == null) {
          inboundFuture.addListener(getPassthroughChannelFutureListener(outboundFuture.getChannel()));
        }
 else {
          inboundFuture.addListener(getMITMChannelFutureListener());
          OutboundChannelPool.getInstance().setChannelIdle(outboundFuture);
        }
      }
    }
);
  }
 else {
    ctx.sendUpstream(e);
  }
}","@Override public void messageReceived(final ChannelHandlerContext ctx,final MessageEvent e) throws Exception {
  final HttpRequest request=(HttpRequest)e.getMessage();
  if (request.getMethod().equals(HttpMethod.CONNECT)) {
    log.info(""String_Node_Str"",e.getChannel().getId(),request.getUri());
    log.debug(""String_Node_Str"",e.getChannel().getId(),request.toString());
    RemoteAddress address=RemoteAddress.parseRequest(request);
    if (context != null && address.getPort() == 443)     address=new RemoteAddress(address.getHost(),80);
    final ChannelPipelineFactory factory=getPipelineFactory(e.getChannel());
    final ChannelFuture outboundFuture=OutboundChannelPool.getInstance().getNewChannelFuture(address,factory);
    outboundFuture.addListener(new ChannelFutureListener(){
      public void operationComplete(      final ChannelFuture outboundFuture){
        log.info(""String_Node_Str"",e.getChannel().getId());
        ctx.getChannel().setReadable(false);
        final ChannelFuture inboundFuture=ctx.getChannel().write(getHttpResponseOk());
        if (context == null) {
          inboundFuture.addListener(getPassthroughChannelFutureListener(outboundFuture.getChannel()));
        }
 else {
          inboundFuture.addListener(getMITMChannelFutureListener());
          OutboundChannelPool.getInstance().setChannelIdle(outboundFuture);
        }
      }
    }
);
  }
 else {
    ctx.sendUpstream(e);
  }
}"
87084,"public void operationComplete(ChannelFuture inboundFuture){
  log.debug(""String_Node_Str"",inboundFuture.getChannel().getId());
  final Channel inboundChannel=inboundFuture.getChannel();
  inboundChannel.setReadable(false);
  while (inboundChannel.getPipeline().getFirst() != null)   inboundChannel.getPipeline().removeFirst();
  inboundChannel.getPipeline().addLast(""String_Node_Str"",new PassthroughHandler(outboundChannel));
  inboundChannel.setReadable(true);
}","public void operationComplete(ChannelFuture inboundFuture){
  log.debug(""String_Node_Str"",inboundFuture.getChannel().getId());
  final Channel inboundChannel=inboundFuture.getChannel();
  while (inboundChannel.getPipeline().getFirst() != null)   inboundChannel.getPipeline().removeFirst();
  inboundChannel.getPipeline().addLast(""String_Node_Str"",new PassthroughHandler(outboundChannel));
  inboundChannel.setReadable(true);
}"
87085,"@Override public void messageReceived(final ChannelHandlerContext ctx,final MessageEvent e){
  final HttpRequest request=(HttpRequest)e.getMessage();
  final RemoteAddress address=RemoteAddress.parseRequest(request);
  log.info(""String_Node_Str"",e.getChannel().getId(),address + request.getUri());
  log.debug(request.toString());
  HttpHeaders.setKeepAlive(request,true);
  final ChannelPipelineFactory factory=new HttpPipelineFactory();
  final ChannelFuture outboundFuture=OutboundChannelPool.getInstance().getIdleOrNewChannelFuture(address,factory);
  log.info(""String_Node_Str"",e.getChannel().getId(),outboundFuture.getChannel().getId());
  final HttpPluginHandler outboundHandler=outboundFuture.getChannel().getPipeline().get(HttpPluginHandler.class);
  outboundHandler.setResponsePlugins(PluginProvider.getInstance().getResponsePlugins(request));
  outboundHandler.setResponseListener(new HttpResponseListener(){
    @Override public void responseReceived(    final HttpResponse response){
      log.info(""String_Node_Str"",e.getChannel().getId(),response.getStatus());
      if (e.getChannel().isConnected())       e.getChannel().write(response);
 else       log.info(""String_Node_Str"",e.getChannel().getId());
    }
  }
);
  outboundFuture.addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    final ChannelFuture future){
      log.info(""String_Node_Str"",future.getChannel().getId(),address + request.getUri());
      future.getChannel().write(request);
    }
  }
);
}","@Override public void messageReceived(final ChannelHandlerContext ctx,final MessageEvent e){
  final HttpRequest request=(HttpRequest)e.getMessage();
  final RemoteAddress address=RemoteAddress.parseRequest(request);
  log.info(""String_Node_Str"",e.getChannel().getId(),address + request.getUri());
  log.debug(request.toString());
  HttpHeaders.setKeepAlive(request,true);
  final ChannelPipelineFactory factory=new HttpPipelineFactory();
  final ChannelFuture outboundFuture=OutboundChannelPool.getInstance().getIdleOrNewChannelFuture(address,factory);
  log.info(""String_Node_Str"",e.getChannel().getId(),outboundFuture.getChannel().getId());
  final HttpPluginHandler outboundHandler=outboundFuture.getChannel().getPipeline().get(HttpPluginHandler.class);
  outboundHandler.setResponsePlugins(PluginProvider.getInstance().getResponsePlugins(request));
  outboundHandler.setResponseListener(new HttpResponseListener(){
    @Override public void responseReceived(    final HttpResponse response){
      log.info(""String_Node_Str"",e.getChannel().getId(),response.getStatus());
      if (e.getChannel().isConnected()) {
        if (request.getHeader(""String_Node_Str"") != null)         response.setHeader(""String_Node_Str"",request.getHeader(""String_Node_Str""));
        e.getChannel().write(response);
      }
 else       log.info(""String_Node_Str"",e.getChannel().getId());
    }
  }
);
  outboundFuture.addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    final ChannelFuture future){
      log.info(""String_Node_Str"",future.getChannel().getId(),address + request.getUri());
      future.getChannel().write(request);
    }
  }
);
}"
87086,"@Override public void responseReceived(final HttpResponse response){
  log.info(""String_Node_Str"",e.getChannel().getId(),response.getStatus());
  if (e.getChannel().isConnected())   e.getChannel().write(response);
 else   log.info(""String_Node_Str"",e.getChannel().getId());
}","@Override public void responseReceived(final HttpResponse response){
  log.info(""String_Node_Str"",e.getChannel().getId(),response.getStatus());
  if (e.getChannel().isConnected()) {
    if (request.getHeader(""String_Node_Str"") != null)     response.setHeader(""String_Node_Str"",request.getHeader(""String_Node_Str""));
    e.getChannel().write(response);
  }
 else   log.info(""String_Node_Str"",e.getChannel().getId());
}"
87087,"public void handleUpstream(ChannelHandlerContext ctx,ChannelEvent e) throws Exception {
  final SslHandler sslHandler=ctx.getPipeline().get(SslHandler.class);
  final SimpleServerProvider provider=(SimpleServerProvider)NextProtoNego.get(sslHandler.getEngine());
  final String protocol=provider.getSelectedProtocol();
  if (protocol != null)   log.debug(""String_Node_Str"",protocol);
  if (SPDY_2.equals(protocol)) {
    ChannelPipeline pipeline=ctx.getPipeline();
    pipeline.addLast(""String_Node_Str"",new SpdyFrameDecoder());
    pipeline.addLast(""String_Node_Str"",new SpdyFrameEncoder());
    pipeline.addLast(""String_Node_Str"",new SpdySessionHandler(true));
    pipeline.addLast(""String_Node_Str"",new SpdyHttpEncoder());
    pipeline.addLast(""String_Node_Str"",new SpdyHttpDecoder(2 * 1024 * 1024));
    pipeline.addLast(""String_Node_Str"",handler);
    pipeline.remove(this);
    ctx.sendUpstream(e);
  }
 else   if (HTTP_1_1.equals(protocol)) {
    ChannelPipeline pipeline=ctx.getPipeline();
    pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
    pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
    pipeline.addLast(""String_Node_Str"",handler);
    pipeline.remove(this);
    ctx.sendUpstream(e);
  }
 else {
  }
}","public void handleUpstream(ChannelHandlerContext ctx,ChannelEvent e) throws Exception {
  final SslHandler sslHandler=ctx.getPipeline().get(SslHandler.class);
  final SimpleServerProvider provider=(SimpleServerProvider)NextProtoNego.get(sslHandler.getEngine());
  final String protocol=provider.getSelectedProtocol();
  if (protocol != null)   log.debug(""String_Node_Str"",protocol);
  if (SPDY_2.equals(protocol)) {
    ChannelPipeline pipeline=ctx.getPipeline();
    pipeline.addLast(""String_Node_Str"",new SpdyFrameDecoder());
    pipeline.addLast(""String_Node_Str"",new SpdyFrameEncoder());
    pipeline.addLast(""String_Node_Str"",new SpdySessionHandler(true));
    pipeline.addLast(""String_Node_Str"",new SpdyHttpEncoder());
    pipeline.addLast(""String_Node_Str"",new SpdyHttpDecoder(2 * 1024 * 1024));
    pipeline.addLast(""String_Node_Str"",new HttpProxyRequestDecoder());
    pipeline.addLast(""String_Node_Str"",handler);
    pipeline.remove(this);
    ctx.sendUpstream(e);
  }
 else   if (HTTP_1_1.equals(protocol)) {
    ChannelPipeline pipeline=ctx.getPipeline();
    pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
    pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
    pipeline.addLast(""String_Node_Str"",new HttpProxyRequestDecoder());
    pipeline.addLast(""String_Node_Str"",handler);
    pipeline.remove(this);
    ctx.sendUpstream(e);
  }
 else {
  }
}"
87088,"private ChannelPipelineFactoryFactory getHttpChannelPipelineFactoryFactory(final HttpRequest request,final Channel inboundChannel){
  return new ChannelPipelineFactoryFactory(){
    public ChannelPipelineFactory getChannelPipelineFactory(){
      List<ResponsePlugin> responsePlugins=PluginProvider.getInstance().getResponsePlugins(request);
      ChannelHandler outboundHandler=new org.jlange.proxy.outbound.HttpHandler(inboundChannel,responsePlugins);
      return new HttpPipelineFactory(outboundHandler);
    }
  }
;
}","private ChannelPipelineFactoryFactory getHttpChannelPipelineFactoryFactory(final HttpRequest request,final Channel inboundChannel){
  return new ChannelPipelineFactoryFactory(){
    public ChannelPipelineFactory getChannelPipelineFactory(){
      List<ResponsePlugin> responsePlugins=PluginProvider.getInstance().getResponsePlugins(request);
      ChannelFutureListener messageReceived=outboundChannelPool.setConnectionIdle(request);
      ChannelHandler outboundHandler=new org.jlange.proxy.outbound.HttpHandler(inboundChannel,responsePlugins,messageReceived);
      return new HttpPipelineFactory(outboundHandler);
    }
  }
;
}"
87089,"public ChannelPipelineFactory getChannelPipelineFactory(){
  List<ResponsePlugin> responsePlugins=PluginProvider.getInstance().getResponsePlugins(request);
  ChannelHandler outboundHandler=new org.jlange.proxy.outbound.HttpHandler(inboundChannel,responsePlugins);
  return new HttpPipelineFactory(outboundHandler);
}","public ChannelPipelineFactory getChannelPipelineFactory(){
  List<ResponsePlugin> responsePlugins=PluginProvider.getInstance().getResponsePlugins(request);
  ChannelFutureListener messageReceived=outboundChannelPool.setConnectionIdle(request);
  ChannelHandler outboundHandler=new org.jlange.proxy.outbound.HttpHandler(inboundChannel,responsePlugins,messageReceived);
  return new HttpPipelineFactory(outboundHandler);
}"
87090,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.change_picture);
  if (!started) {
    started=true;
    Intent cameraIntent=new Intent(this,CameraActivity.class);
    startActivityForResult(cameraIntent,TAKE_PICTURE);
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.change_picture);
  if (!started) {
    started=true;
    Intent cameraIntent=new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    fileUri=Util.getOutputMediaFileUri(Util.MEDIA_TYPE_IMAGE);
    cameraIntent.putExtra(MediaStore.EXTRA_OUTPUT,fileUri);
    startActivityForResult(cameraIntent,TAKE_PICTURE);
  }
}"
87091,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == TAKE_PICTURE) {
    if (resultCode == Activity.RESULT_OK) {
      started=true;
      fileUri=data.getData();
      rotation=Util.getRotationDegrees(fileUri.getPath());
      ImageView imageView=(ImageView)findViewById(R.id.image1);
      imageView.setImageBitmap(Util.decodeSampledBitmapFromFile(fileUri.getPath(),200,200,rotation));
    }
 else {
      finish();
    }
  }
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == TAKE_PICTURE) {
    if (resultCode == Activity.RESULT_OK) {
      started=true;
      rotation=Util.getRotationDegrees(fileUri.getPath());
      ImageView imageView=(ImageView)findViewById(R.id.image1);
      imageView.setImageBitmap(Util.decodeSampledBitmapFromFile(fileUri.getPath(),200,200,rotation));
    }
 else {
      finish();
    }
  }
}"
87092,"protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.share_photo);
  Display display=getWindowManager().getDefaultDisplay();
  screenWidth=(int)(display.getWidth() * 0.95);
  margin=(int)((display.getWidth() - screenWidth) / 2);
  btnSelectGroup=(Button)findViewById(R.id.groups_spinner);
  comment=(EditText)findViewById(R.id.edit_message);
  imageView=(ImageView)findViewById(R.id.image1);
  LayoutParams params=(LayoutParams)imageView.getLayoutParams();
  params.width=screenWidth;
  params.height=screenWidth;
  params.setMargins(0,margin,0,margin);
  imageView.setLayoutParams(params);
  locationImg=(ImageView)findViewById(R.id.img_location_ok);
  locationTxt=(TextView)findViewById(R.id.txt_location);
  imageLoader=ImageLoader.getInstance();
  mLocationManager=(LocationManager)getSystemService(Context.LOCATION_SERVICE);
  final boolean gpsEnabled=mLocationManager.isProviderEnabled(LocationManager.GPS_PROVIDER);
  if (!gpsEnabled) {
    Util.createGpsDisabledAlert(this);
  }
  Intent intent=getIntent();
  if (intent.getType() != null && intent.getType().indexOf(""String_Node_Str"") != -1) {
    fileUri=(Uri)intent.getParcelableExtra(Intent.EXTRA_STREAM);
    if (fileUri != null) {
      String path=Util.getRealPathFromURI(this,fileUri);
      fileUri=Uri.parse(path);
      rotation=Util.getRotationDegrees(fileUri.getPath());
      imageView.setImageBitmap(Util.decodeSampledBitmapFromFile(path,screenWidth,screenWidth,rotation));
      setupGps();
    }
  }
 else {
    if (fileUri == null) {
      Intent cameraIntent=new Intent(this,CameraActivity.class);
      startActivityForResult(cameraIntent,TAKE_PICTURE);
    }
  }
}","protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.share_photo);
  Display display=getWindowManager().getDefaultDisplay();
  screenWidth=(int)(display.getWidth() * 0.95);
  margin=(int)((display.getWidth() - screenWidth) / 2);
  btnSelectGroup=(Button)findViewById(R.id.groups_spinner);
  comment=(EditText)findViewById(R.id.edit_message);
  imageView=(ImageView)findViewById(R.id.image1);
  LayoutParams params=(LayoutParams)imageView.getLayoutParams();
  params.width=screenWidth;
  params.height=screenWidth;
  params.setMargins(0,margin,0,margin);
  imageView.setLayoutParams(params);
  locationImg=(ImageView)findViewById(R.id.img_location_ok);
  locationTxt=(TextView)findViewById(R.id.txt_location);
  imageLoader=ImageLoader.getInstance();
  mLocationManager=(LocationManager)getSystemService(Context.LOCATION_SERVICE);
  final boolean gpsEnabled=mLocationManager.isProviderEnabled(LocationManager.GPS_PROVIDER);
  if (!gpsEnabled) {
    Util.createGpsDisabledAlert(this);
  }
  Intent intent=getIntent();
  if (intent.getType() != null && intent.getType().indexOf(""String_Node_Str"") != -1) {
    fileUri=(Uri)intent.getParcelableExtra(Intent.EXTRA_STREAM);
    if (fileUri != null) {
      String path=Util.getRealPathFromURI(this,fileUri);
      fileUri=Uri.parse(path);
      rotation=Util.getRotationDegrees(fileUri.getPath());
      imageView.setImageBitmap(Util.decodeSampledBitmapFromFile(path,screenWidth,screenWidth,rotation));
      setupGps();
    }
  }
 else {
    Intent cameraIntent=new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    fileUri=Util.getOutputMediaFileUri(Util.MEDIA_TYPE_IMAGE);
    cameraIntent.putExtra(MediaStore.EXTRA_OUTPUT,fileUri);
    startActivityForResult(cameraIntent,TAKE_PICTURE);
  }
}"
87093,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == CODE_CREATE_GROUP && resultCode == RESULT_OK) {
    newGroupName=data.getStringExtra(""String_Node_Str"");
    Toast.makeText(this,""String_Node_Str"" + newGroupName + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
  }
 else   if (requestCode == CODE_SELECT_GROUP) {
    if (resultCode == RESULT_OK) {
      gid=data.getLongExtra(""String_Node_Str"",0);
      String groupName=data.getStringExtra(""String_Node_Str"");
      btnSelectGroup.setText(groupName);
      btnSelectGroup.setCompoundDrawablesWithIntrinsicBounds(R.drawable.btn_check_buttonless_on,0,0,0);
    }
 else {
      gid=0;
      btnSelectGroup.setText(R.string.select_group);
      btnSelectGroup.setCompoundDrawablesWithIntrinsicBounds(0,0,0,0);
    }
  }
 else   if (requestCode == CODE_LOCATION) {
    if (resultCode == RESULT_OK) {
      mLocationManager.removeUpdates(listener);
      if (gpsLocation == null)       gpsLocation=new Location(LocationManager.GPS_PROVIDER);
      gpsLocation.setLatitude(data.getDoubleExtra(""String_Node_Str"",0d));
      gpsLocation.setLongitude(data.getDoubleExtra(""String_Node_Str"",0d));
      if (gpsLocation.getLatitude() != 0 && gpsLocation.getLongitude() != 0) {
        locationTxt.setText(R.string.share_location_manual);
        locationImg.setImageDrawable(getResources().getDrawable(R.drawable.button_ok));
      }
    }
 else {
      setupGps();
    }
  }
 else   if (requestCode == TAKE_PICTURE && resultCode == Activity.RESULT_OK) {
    fileUri=data.getData();
    rotation=Util.getRotationDegrees(fileUri.getPath());
    imageView.setImageBitmap(Util.decodeSampledBitmapFromFile(fileUri.getPath(),screenWidth,screenWidth,rotation));
    setupGps();
  }
 else   if (resultCode == RESULT_CANCELED) {
    finish();
  }
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == CODE_CREATE_GROUP && resultCode == RESULT_OK) {
    newGroupName=data.getStringExtra(""String_Node_Str"");
    Toast.makeText(this,""String_Node_Str"" + newGroupName + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
  }
 else   if (requestCode == CODE_SELECT_GROUP) {
    if (resultCode == RESULT_OK) {
      gid=data.getLongExtra(""String_Node_Str"",0);
      String groupName=data.getStringExtra(""String_Node_Str"");
      btnSelectGroup.setText(groupName);
      btnSelectGroup.setCompoundDrawablesWithIntrinsicBounds(R.drawable.btn_check_buttonless_on,0,0,0);
    }
 else {
      gid=0;
      btnSelectGroup.setText(R.string.select_group);
      btnSelectGroup.setCompoundDrawablesWithIntrinsicBounds(0,0,0,0);
    }
  }
 else   if (requestCode == CODE_LOCATION) {
    if (resultCode == RESULT_OK) {
      mLocationManager.removeUpdates(listener);
      if (gpsLocation == null)       gpsLocation=new Location(LocationManager.GPS_PROVIDER);
      gpsLocation.setLatitude(data.getDoubleExtra(""String_Node_Str"",0d));
      gpsLocation.setLongitude(data.getDoubleExtra(""String_Node_Str"",0d));
      if (gpsLocation.getLatitude() != 0 && gpsLocation.getLongitude() != 0) {
        locationTxt.setText(R.string.share_location_manual);
        locationImg.setImageDrawable(getResources().getDrawable(R.drawable.button_ok));
      }
    }
 else {
      setupGps();
    }
  }
 else   if (requestCode == TAKE_PICTURE) {
    if (resultCode == Activity.RESULT_OK) {
      rotation=Util.getRotationDegrees(fileUri.getPath());
      imageView.setImageBitmap(Util.decodeSampledBitmapFromFile(fileUri.getPath(),screenWidth,screenWidth,rotation));
      setupGps();
    }
 else {
      Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      finish();
    }
  }
 else   if (resultCode == RESULT_CANCELED) {
    finish();
  }
}"
87094,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.change_picture);
  Intent intent=getIntent();
  id=intent.getLongExtra(""String_Node_Str"",0);
  if (fileUri == null) {
    Intent cameraIntent=new Intent(this,CameraActivity.class);
    startActivityForResult(cameraIntent,TAKE_PICTURE);
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.change_picture);
  Intent intent=getIntent();
  id=intent.getLongExtra(""String_Node_Str"",0);
  if (fileUri == null) {
    Intent cameraIntent=new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    fileUri=Util.getOutputMediaFileUri(Util.MEDIA_TYPE_IMAGE);
    cameraIntent.putExtra(MediaStore.EXTRA_OUTPUT,fileUri);
    startActivityForResult(cameraIntent,TAKE_PICTURE);
  }
}"
87095,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == TAKE_PICTURE) {
    if (resultCode == Activity.RESULT_OK) {
      fileUri=data.getData();
      rotation=Util.getRotationDegrees(fileUri.getPath());
      ImageView imageView=(ImageView)findViewById(R.id.image1);
      imageView.setImageBitmap(Util.decodeSampledBitmapFromFile(fileUri.getPath(),200,200,rotation));
    }
 else {
      finish();
    }
  }
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == TAKE_PICTURE) {
    if (resultCode == Activity.RESULT_OK) {
      rotation=Util.getRotationDegrees(fileUri.getPath());
      ImageView imageView=(ImageView)findViewById(R.id.image1);
      imageView.setImageBitmap(Util.decodeSampledBitmapFromFile(fileUri.getPath(),200,200,rotation));
    }
 else {
      finish();
    }
  }
}"
87096,"@Override public void addPlayerToWorld(Player player){
  world.d((net.minecraft.server.Entity)((CanaryPlayer)player).getHandle());
}","@Override public void addPlayerToWorld(Player player){
  world.d(((CanaryPlayer)player).getHandle());
}"
87097,"@Override public void removePlayerFromWorld(Player player){
  world.f((net.minecraft.server.Entity)((CanaryPlayer)player).getHandle());
}","@Override public void removePlayerFromWorld(Player player){
  world.f(((CanaryPlayer)player).getHandle());
}"
87098,"@Override public void makeLightningBolt(Position position){
  world.c(new EntityLightningBolt(world,(int)position.getX(),(int)position.getY(),(int)position.getZ()));
}","@Override public void makeLightningBolt(Position position){
  world.c(new EntityLightningBolt(world,position.getX(),position.getY(),position.getZ()));
}"
87099,"@Override public Block getBlockAt(Position position){
  return getBlockAt((int)position.getX(),(int)position.getY(),(int)position.getZ());
}","@Override public Block getBlockAt(Position position){
  return getBlockAt(position.getBlockX(),position.getBlockY(),position.getBlockZ());
}"
87100,"@Override public long getTimePlayed(){
  if (getNBT() != null && getNBT().containsKey(""String_Node_Str"")) {
    return getNBT().getInt(""String_Node_Str"");
  }
  return 0;
}","@Override public long getTimePlayed(){
  if (getNBT() != null && getNBT().containsKey(""String_Node_Str"")) {
    return getNBT().getLong(""String_Node_Str"");
  }
  return 0;
}"
87101,"/** 
 * Create a new Server Wrapper
 * @param server the MinecraftServer instance
 */
public CanaryServer(MinecraftServer server){
  if (this.server == null) {
    this.server=server;
    addSynchronousTask(new TPSTracker(this));
  }
}","/** 
 * Create a new Server Wrapper
 * @param server the MinecraftServer instance
 */
public CanaryServer(MinecraftServer server){
  this.server=server;
  addSynchronousTask(new TPSTracker(this));
}"
87102,"public boolean matchesMatrix(CraftingMatrix matrix){
  if (matrix instanceof CanaryPlayerCraftingMatrix) {
    if (getHandle().a(((CanaryPlayerCraftingMatrix)matrix).getHandle(),null)) {
      return true;
    }
  }
 else   if (matrix instanceof CanaryWorkbench) {
    if (getHandle().a(((CanaryWorkbench)matrix).getInventory(),null)) {
      return true;
    }
  }
  return false;
}","public boolean matchesMatrix(CraftingMatrix matrix){
  if (matrix instanceof CanaryPlayerCraftingMatrix) {
    if (getHandle().a(((CanaryPlayerCraftingMatrix)matrix).getHandle(),((CanaryWorld)Canary.getServer().getDefaultWorld()).getHandle())) {
      return true;
    }
  }
 else   if (matrix instanceof CanaryWorkbench) {
    if (getHandle().a(((CanaryWorkbench)matrix).getInventory(),((CanaryWorld)Canary.getServer().getDefaultWorld()).getHandle())) {
      return true;
    }
  }
  return false;
}"
87103,"@Override public void setRotation(float rotation){
  entity.A=rotation;
}","@Override public void setRotation(float rotation){
  entity.B=rotation;
}"
87104,"@Override public void setPitch(float pitch){
  entity.B=pitch;
}","@Override public void setPitch(float pitch){
  entity.A=pitch;
}"
87105,"/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  return String.format(""String_Node_Str"",getID(),getName());
}","/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  return String.format(""String_Node_Str"",getFqName(),getID(),getName());
}"
87106,"@Override public void l_(){
  super.c();
  super.l_();
  if (!this.M) {
    try {
      getNPC().update();
    }
 catch (    Exception ex) {
    }
  }
}","@Override public void l_(){
  super.l_();
  if (!this.M) {
    getNPC().update();
  }
  this.H();
}"
87107,"public EntityNonPlayableCharacter(String name,Location location){
  super(((CanaryWorld)location.getWorld()).getHandle(),name);
  this.a(location.getX(),location.getY(),location.getZ(),location.getRotation(),location.getPitch());
  this.entity=new CanaryNonPlayableCharacter(this);
}","public EntityNonPlayableCharacter(String name,Location location){
  super(((CanaryWorld)location.getWorld()).getHandle(),name);
  this.b(location.getX(),location.getY(),location.getZ(),location.getRotation(),location.getPitch());
  this.i(1.0F);
  this.entity=new CanaryNonPlayableCharacter(this);
}"
87108,"public void x(){
  this.aD=this.aE;
  super.x();
  this.q.C.a(""String_Node_Str"");
  if (this.R() && this.S()) {
    DamageHook hook=(DamageHook)new DamageHook(null,entity,new CanaryDamageSource(DamageSource.d),1).call();
    if (!hook.isCanceled()) {
      this.a((((CanaryDamageSource)hook.getDamageSource()).getHandle()),hook.getDamageDealt());
    }
  }
  if (this.E() || this.q.I) {
    this.A();
  }
  boolean flag0=this instanceof EntityPlayer && ((EntityPlayer)this).bG.a;
  if (this.R() && this.a(Material.h)) {
    if (!this.ay() && !this.i(Potion.o.H) && !flag0) {
      this.g(this.h(this.aj()));
      if (this.aj() == -20) {
        this.g(0);
        DamageHook hook=(DamageHook)new DamageHook(null,entity,new CanaryDamageSource(DamageSource.e),2).call();
        if (!hook.isCanceled()) {
          for (int i0=0; i0 < 8; ++i0) {
            float f0=this.ab.nextFloat() - this.ab.nextFloat();
            float f1=this.ab.nextFloat() - this.ab.nextFloat();
            float f2=this.ab.nextFloat() - this.ab.nextFloat();
            this.q.a(""String_Node_Str"",this.u + (double)f0,this.v + (double)f1,this.w + (double)f2,this.x,this.y,this.z);
          }
          this.a((((CanaryDamageSource)hook.getDamageSource()).getHandle()),hook.getDamageDealt());
        }
      }
      this.A();
      if (!this.q.I && this.ae() && this.o instanceof EntityLivingBase) {
        this.a((Entity)null);
      }
    }
 else {
      this.g(300);
    }
    this.aJ=this.aK;
    if (this.aC > 0) {
      --this.aC;
    }
    if (this.ay > 0) {
      --this.ay;
    }
    if (this.af > 0) {
      --this.af;
    }
    if (this.aJ() <= 0.0F) {
      this.az();
    }
    if (this.aT > 0) {
      --this.aT;
    }
 else {
      this.aS=null;
    }
    if (this.bn != null && !this.bn.R()) {
      this.bn=null;
    }
    if (this.i != null) {
      if (!this.i.R()) {
        this.b((EntityLivingBase)null);
      }
 else       if (this.j > 0) {
        --this.j;
      }
 else {
        this.b((EntityLivingBase)null);
      }
    }
    this.aF();
    this.aZ=this.aY;
    this.aO=this.aN;
    this.aQ=this.aP;
    this.C=this.A;
    this.D=this.B;
    this.q.C.b();
  }
}","public void x(){
  this.aD=this.aE;
  super.x();
  this.q.C.a(""String_Node_Str"");
  if (this.R() && this.S()) {
    DamageHook hook=(DamageHook)new DamageHook(null,entity,new CanaryDamageSource(DamageSource.d),1).call();
    if (!hook.isCanceled()) {
      this.a((((CanaryDamageSource)hook.getDamageSource()).getHandle()),hook.getDamageDealt());
    }
  }
  if (this.E() || this.q.I) {
    this.A();
  }
  boolean flag0=this instanceof EntityPlayer && ((EntityPlayer)this).bG.a;
  if (this.R() && this.a(Material.h)) {
    if (!this.ay() && !this.i(Potion.o.H) && !flag0) {
      this.g(this.h(this.aj()));
      if (this.aj() == -20) {
        this.g(0);
        DamageHook hook=(DamageHook)new DamageHook(null,entity,new CanaryDamageSource(DamageSource.e),2).call();
        if (!hook.isCanceled()) {
          for (int i0=0; i0 < 8; ++i0) {
            float f0=this.ab.nextFloat() - this.ab.nextFloat();
            float f1=this.ab.nextFloat() - this.ab.nextFloat();
            float f2=this.ab.nextFloat() - this.ab.nextFloat();
            this.q.a(""String_Node_Str"",this.u + (double)f0,this.v + (double)f1,this.w + (double)f2,this.x,this.y,this.z);
          }
          this.a((((CanaryDamageSource)hook.getDamageSource()).getHandle()),hook.getDamageDealt());
        }
      }
    }
    this.A();
    if (!this.q.I && this.ae() && this.o instanceof EntityLivingBase) {
      this.a((Entity)null);
    }
  }
 else {
    this.g(300);
  }
  this.aJ=this.aK;
  if (this.aC > 0) {
    --this.aC;
  }
  if (this.ay > 0) {
    --this.ay;
  }
  if (this.af > 0) {
    --this.af;
  }
  if (this.aJ() <= 0.0F) {
    this.az();
  }
  if (this.aT > 0) {
    --this.aT;
  }
 else {
    this.aS=null;
  }
  if (this.bn != null && !this.bn.R()) {
    this.bn=null;
  }
  if (this.i != null) {
    if (!this.i.R()) {
      this.b((EntityLivingBase)null);
    }
 else     if (this.j > 0) {
      --this.j;
    }
 else {
      this.b((EntityLivingBase)null);
    }
  }
  this.aF();
  this.aZ=this.aY;
  this.aO=this.aN;
  this.aQ=this.aP;
  this.C=this.A;
  this.D=this.B;
  this.q.C.b();
}"
87109,"public void c(String s0){
  DisconnectionHook hook=new DisconnectionHook(serverHandler.getUser(),s0,EnumChatFormatting.o + this.c.ax() + ""String_Node_Str"");
  Canary.hooks().callHook(hook);
  if (!this.b) {
    this.c.k();
    this.b(new Packet255KickDisconnect(s0));
    this.a.d();
    if (!hook.isHidden()) {
      this.d.ad().a((Packet)(new Packet3Chat(hook.getLeaveMessage())));
    }
    this.d.ad().e(this.c);
    this.b=true;
  }
}","public void c(String s0){
  DisconnectionHook hook=new DisconnectionHook(serverHandler.getUser(),s0,EnumChatFormatting.o + this.c.ax() + ""String_Node_Str"");
  Canary.hooks().callHook(hook);
  if (!this.b) {
    this.c.k();
    this.b(new Packet255KickDisconnect(s0));
    this.a.d();
    if (!hook.isHidden()) {
      this.d.ad().a((Packet)(new Packet3Chat(hook.getLeaveMessage())));
    }
    this.d.ad().e(this.c);
    this.b=true;
    Canary.channels().unregisterClientAll(serverHandler);
  }
}"
87110,"void update(){
synchronized (behaviors) {
    for (    NPCBehavior behavior : behaviors) {
      try {
        if (!getHandle().M) {
          behavior.onUpdate();
        }
      }
 catch (      Exception ex) {
        Canary.logWarning(""String_Node_Str"" + behavior.getClass().getSimpleName() + ""String_Node_Str""+ this.getName());
        Canary.logStackTrace(""String_Node_Str"",ex);
      }
    }
  }
}","void update(){
  try {
synchronized (behaviors) {
      for (      NPCBehavior behavior : behaviors) {
        try {
          if (!getHandle().M) {
            behavior.onUpdate();
          }
        }
 catch (        Exception ex) {
          Canary.logWarning(""String_Node_Str"" + behavior.getClass().getSimpleName() + ""String_Node_Str""+ this.getName());
          Canary.logStackTrace(""String_Node_Str"",ex);
        }
      }
    }
  }
 catch (  Exception ex) {
    Canary.logWarning(""String_Node_Str"" + this.getName());
    Canary.logStackTrace(""String_Node_Str"",ex);
  }
}"
87111,"void clicked(Player player){
synchronized (behaviors) {
    for (    NPCBehavior behavior : behaviors) {
      try {
        if (!getHandle().M) {
          behavior.onClicked(player);
        }
      }
 catch (      Exception ex) {
        Canary.logWarning(""String_Node_Str"" + behavior.getClass().getSimpleName() + ""String_Node_Str""+ this.getName());
        Canary.logStackTrace(""String_Node_Str"",ex);
      }
    }
  }
}","void clicked(Player player){
  try {
synchronized (behaviors) {
      for (      NPCBehavior behavior : behaviors) {
        try {
          if (!getHandle().M) {
            behavior.onClicked(player);
          }
        }
 catch (        Exception ex) {
          Canary.logWarning(""String_Node_Str"" + behavior.getClass().getSimpleName() + ""String_Node_Str""+ this.getName());
          Canary.logStackTrace(""String_Node_Str"",ex);
        }
      }
    }
  }
 catch (  Exception ex) {
    Canary.logWarning(""String_Node_Str"" + this.getName());
    Canary.logStackTrace(""String_Node_Str"",ex);
  }
}"
87112,"@Override public void w(){
  super.w();
  ((CanaryNonPlayableCharacter)entity).destoryed();
}","@Override public void w(){
  super.w();
  ((CanaryNonPlayableCharacter)entity).destroyed();
}"
87113,"/** 
 * {@inheritDoc}
 */
@Override public void setCanSwim(boolean bool){
  nav.e(true);
}","/** 
 * {@inheritDoc}
 */
@Override public void setCanSwim(boolean bool){
  nav.e(bool);
}"
87114,"/** 
 * {@inheritDoc}
 */
@Override public void disableWaterPathing(){
  nav.a(false);
}","/** 
 * {@inheritDoc}
 */
@Override @Deprecated public void disableWaterPathing(){
  nav.a(false);
}"
87115,"/** 
 * {@inheritDoc}
 */
@Override public void enableWaterPathing(){
  nav.a(true);
}","/** 
 * {@inheritDoc}
 */
@Override @Deprecated public void enableWaterPathing(){
  nav.a(true);
}"
87116,"public Chunk(World world,byte[] abyte,int i0,int i1){
  this(world,i0,i1);
  int i2=abyte.length / 256;
  for (int i3=0; i3 < 16; ++i3) {
    for (int i4=0; i4 < 16; ++i4) {
      for (int i5=0; i5 < i2; ++i5) {
        byte b0=abyte[i3 << 11 | i4 << 7 | i5];
        if (b0 != 0) {
          int i6=i5 >> 4;
          if (this.r[i6] == null) {
            this.r[i6]=new ExtendedBlockStorage(i6 << 4,!world.t.f);
          }
          this.r[i6].a(i3,i5 & 15,i4,b0);
        }
      }
    }
  }
  canaryChunk=new CanaryChunk(this);
}","public Chunk(World world,byte[] abyte,int i0,int i1){
  this(world,i0,i1);
  int i2=abyte.length / 256;
  for (int i3=0; i3 < 16; ++i3) {
    for (int i4=0; i4 < 16; ++i4) {
      for (int i5=0; i5 < i2; ++i5) {
        byte b0=abyte[i3 << 11 | i4 << 7 | i5];
        if (b0 != 0) {
          int i6=i5 >> 4;
          if (this.r[i6] == null) {
            this.r[i6]=new ExtendedBlockStorage(i6 << 4,!world.t.f);
          }
          this.r[i6].a(i3,i5 & 15,i4,b0);
        }
      }
    }
  }
}"
87117,"/** 
 * {@inheritDoc}
 */
@Override public String getTextOnLine(int line){
  if (line > 0 && line < 3) {
    return getTileEntity().a[line];
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public String getTextOnLine(int line){
  if (line >= 0 && line <= 3) {
    return getTileEntity().a[line];
  }
  return null;
}"
87118,"/** 
 * {@inheritDoc}
 */
@Override public void setTextOnLine(String text,int line){
  if (line > 0 && line < 3) {
    getTileEntity().a[line]=text;
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void setTextOnLine(String text,int line){
  if (line >= 0 && line <= 3) {
    getTileEntity().a[line]=text;
  }
}"
87119,"@Override public String getPrefix(){
  if (prefix != null) {
    return Colors.MARKER + prefix;
  }
 else   if (group.getPrefix() != null) {
    return Colors.MARKER + group.getPrefix();
  }
 else {
    return Colors.WHITE;
  }
}","@Override public String getPrefix(){
  if (prefix != null) {
    if (prefix.contains(Colors.MARKER)) {
      return prefix;
    }
    return Colors.MARKER + prefix;
  }
 else   if (group.getPrefix() != null) {
    return Colors.MARKER + group.getPrefix();
  }
 else {
    return Colors.WHITE;
  }
}"
87120,"@Override public void chat(String message){
  if (message.length() > 100) {
    kick(""String_Node_Str"");
  }
  message=message.trim();
  Matcher m=badChatPattern.matcher(message);
  String out=message;
  if (m.find() && !this.canIgnoreRestrictions()) {
    out=message.replaceAll(m.group(),""String_Node_Str"");
  }
  message=out;
  if (message.startsWith(""String_Node_Str"")) {
    executeCommand(message.split(""String_Node_Str""));
  }
 else {
    if (isMuted()) {
      notice(""String_Node_Str"");
    }
 else {
      String format=""String_Node_Str"" + Colors.WHITE + ""String_Node_Str"";
      String prefix=getPrefix();
      ArrayList<Player> receivers=Canary.getServer().getPlayerList();
      ChatHook hook=new ChatHook(this,prefix,message,format,receivers);
      Canary.hooks().callHook(hook);
      if (hook.isCanceled()) {
        return;
      }
      receivers=hook.getReceiverList();
      String formattedMessage=hook.getFormat().replace(""String_Node_Str"",hook.getPrefix()).replace(""String_Node_Str"",getName()).replace(""String_Node_Str"",getGroup().getName());
      for (      Player player : receivers) {
        if ((formattedMessage.length() - 8 + hook.getMessage().length()) >= 100) {
          player.sendMessage(formattedMessage.replace(""String_Node_Str"",""String_Node_Str""));
          player.sendMessage(hook.getMessage());
        }
 else {
          player.sendMessage(formattedMessage.replace(""String_Node_Str"",hook.getMessage()));
        }
      }
      Canary.logInfo(TextFormat.removeFormatting(formattedMessage.replace(""String_Node_Str"",hook.getMessage())));
    }
  }
}","@Override public void chat(String message){
  if (message.length() > 100) {
    kick(""String_Node_Str"");
  }
  message=message.trim();
  Matcher m=badChatPattern.matcher(message);
  String out=message;
  if (m.find() && !this.canIgnoreRestrictions()) {
    out=message.replaceAll(m.group(),""String_Node_Str"");
  }
  message=out;
  if (message.startsWith(""String_Node_Str"")) {
    executeCommand(message.split(""String_Node_Str""));
  }
 else {
    if (isMuted()) {
      notice(""String_Node_Str"");
    }
 else {
      ArrayList<Player> receivers=Canary.getServer().getPlayerList();
      ChatHook hook=new ChatHook(this,getPrefix(),message,""String_Node_Str"" + Colors.WHITE + ""String_Node_Str"",receivers);
      Canary.hooks().callHook(hook);
      if (hook.isCanceled()) {
        return;
      }
      receivers=hook.getReceiverList();
      String formattedMessage=hook.getFormat().replace(""String_Node_Str"",hook.getPrefix()).replace(""String_Node_Str"",getName()).replace(""String_Node_Str"",getGroup().getName());
      for (      Player player : receivers) {
        if ((formattedMessage.length() - 8 + hook.getMessage().length()) >= 100) {
          player.sendMessage(formattedMessage.replace(""String_Node_Str"",""String_Node_Str""));
          player.sendMessage(hook.getMessage());
        }
 else {
          player.sendMessage(formattedMessage.replace(""String_Node_Str"",hook.getMessage()));
        }
      }
      Canary.logInfo(TextFormat.removeFormatting(formattedMessage.replace(""String_Node_Str"",hook.getMessage())));
    }
  }
}"
87121,"@Override public int getWeight(){
  return handle.b();
}","@Override public int getWeight(){
  return handle.c();
}"
87122,"@Override public int getMinEnchantmentLevel(){
  return handle.c();
}","@Override public int getMinEnchantmentLevel(){
  return handle.d();
}"
87123,"@Override public int getMaxEnchantmentLevel(){
  return handle.a();
}","@Override public int getMaxEnchantmentLevel(){
  return handle.b();
}"
87124,"@Override public void handleCommand(String[] command){
  handler.getUser().executeCommand(command);
}","@Override public void handleCommand(String[] command){
  getUser().executeCommand(command);
}"
87125,"@Override public Player getUser(){
  return handler.getUser();
}","@Override public Player getUser(){
  return handler.c.getPlayer();
}"
87126,"@Override public void sendMessage(String messgage){
  handler.sendMessage(messgage);
}","@Override public void sendMessage(String message){
  getUser().sendMessage(message);
}"
87127,"@Override public void handleChat(Packet chatPacket){
  if (chatPacket.getPacketId() != 3) {
    return;
  }
  handler.playerChat((net.minecraft.server.Packet3Chat)((CanaryPacket)chatPacket).getPacket());
}","@Override public void handleChat(Packet chatPacket){
  if (chatPacket.getPacketId() != 3) {
    return;
  }
  handler.a((net.minecraft.server.Packet3Chat)((CanaryPacket)chatPacket).getPacket());
}"
87128,"@Override public int getPacketId(){
  return packet.b();
}","@Override public int getPacketId(){
  return packet.n();
}"
87129,"@Override public ArrayList<Player> getManagedPlayers(){
  ArrayList<Player> players=new ArrayList<Player>();
  for (  net.minecraft.server.EntityPlayerMP player : pm.managedPlayers) {
    players.add(player.getPlayer());
  }
  return players;
}","@Override public ArrayList<Player> getManagedPlayers(){
  ArrayList<Player> players=new ArrayList<Player>();
  for (  net.minecraft.server.EntityPlayerMP player : pm.getManagedPlayers()) {
    players.add(player.getPlayer());
  }
  return players;
}"
87130,"@Override public int getMaxTrackingDistance(){
  return pm.c();
}","@Override public int getMaxTrackingDistance(){
  return net.minecraft.server.PlayerManager.a(pm.getPlayerViewRadius());
}"
87131,"/** 
 * {@inheritDoc}
 */
@Override public int getMaxPlayers(){
  return Configuration.getNetConfig().getMaxPlayers();
}","/** 
 * {@inheritDoc}
 */
@Override public int getMaxPlayers(){
  return Configuration.getServerConfig().getMaxPlayers();
}"
87132,"/** 
 * The canary Bootstrap process
 * @param args
 */
public static void main(String[] args){
  Main.args=args;
  initBird();
  try {
    OMinecraftServer.main(args);
  }
 catch (  Throwable t) {
    Logman.logStackTrace(""String_Node_Str"",t);
  }
}","/** 
 * The canary Bootstrap process
 * @param args
 */
public static void main(String[] args){
  initBird();
  try {
    OMinecraftServer.main(args);
  }
 catch (  Throwable t) {
    Logman.logStackTrace(""String_Node_Str"",t);
  }
}"
87133,"@Override public void consoleCommand(String command,Player player){
  ConsoleCommandHook hook=(ConsoleCommandHook)Canary.hooks().callCancelableHook(new ConsoleCommandHook(player,command));
  if (hook.isCanceled()) {
    return;
  }
  String[] args=command.split(""String_Node_Str"");
  CanaryCommand toExecute=CanaryCommand.fromString(args[0].replace(""String_Node_Str"",""String_Node_Str""));
  if (toExecute != null) {
    toExecute.execute(null,args);
  }
 else {
    server.a(command,((CanaryPlayer)player).getHandle().a);
  }
  Logman.logInfo(player.getName() + ""String_Node_Str"" + command);
}","@Override public boolean consoleCommand(String command,Player player){
  ConsoleCommandHook hook=(ConsoleCommandHook)Canary.hooks().callCancelableHook(new ConsoleCommandHook(player,command));
  if (hook.isCanceled()) {
    return true;
  }
  String[] args=command.split(""String_Node_Str"");
  CanaryCommand toExecute=CanaryCommand.fromString(args[0].replace(""String_Node_Str"",""String_Node_Str""));
  if (toExecute != null) {
    return toExecute.execute(null,args);
  }
 else {
    server.a(command,((CanaryPlayer)player).getHandle().a);
    return false;
  }
}"
87134,"@Override public void actionPerformed(ActionEvent var1){
  String var2=this.a.getText().trim();
  if (var2.length() > 0) {
    OServerGUI.a(this.b).a(var2,this.b);
  }
  this.a.setText(""String_Node_Str"");
}","@Override public void actionPerformed(ActionEvent var1){
  String var2=this.a.getText().trim();
  if (var2.length() > 0 && Canary.instance() != null) {
    Canary.getServer().consoleCommand(var2);
  }
  this.a.setText(""String_Node_Str"");
}"
87135,"private void u(){
  a.info(""String_Node_Str"");
  for (int var1=0; var1 < this.e.length; ++var1) {
    OWorldServer var2=this.e[var1];
    try {
      var2.a(true,(OIProgressUpdate)null);
    }
 catch (    IOException e1) {
      e1.printStackTrace();
    }
    var2.A();
  }
}","private void u(){
  a.info(""String_Node_Str"");
  for (int var1=0; var1 < this.e.length; ++var1) {
    OWorldServer var2=this.e[var1];
    try {
      var2.a(true,(OIProgressUpdate)null);
    }
 catch (    IOException e1) {
      e1.printStackTrace();
    }
  }
}"
87136,"@Override public void consoleCommand(String command,IPlayer player){
}","public void consoleCommand(String command,IPlayer player){
}"
87137,"@Override public void setTimer(String uniqueName,int time){
}","public void setTimer(String uniqueName,int time){
}"
87138,"@Override public boolean isTimerExpired(String uniqueName){
  return false;
}","public boolean isTimerExpired(String uniqueName){
  return false;
}"
87139,"public void e(){
  OThreadedFileIOBase.a.a();
  ORegionFileCache.a();
}","public void e(){
  System.out.println(""String_Node_Str"");
  try {
    OThreadedFileIOBase.a.a();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  ORegionFileCache.a();
}"
87140,"public void a(){
  this.e=true;
  while (this.c != this.d) {
    try {
      Thread.sleep(10L);
    }
 catch (    InterruptedException e1) {
      e1.printStackTrace();
    }
  }
  this.e=false;
}","public void a() throws InterruptedException {
  this.e=true;
  while (this.c != this.d) {
    Thread.sleep(10L);
  }
  this.e=false;
}"
87141,"private OThreadedFileIOBase(){
  super();
  Thread var1=new Thread(this,""String_Node_Str"");
  var1.setPriority(1);
  var1.start();
}","private OThreadedFileIOBase(){
  super();
  b=Collections.synchronizedList(new ArrayList());
  Thread var1=new Thread(this,""String_Node_Str"");
  var1.setPriority(1);
  var1.start();
}"
87142,"public void run(){
  this.b();
}","public void run(){
  while (true) {
    this.b();
  }
}"
87143,"/** 
 * Update internal state and forward to token
 * @param toState
 */
void transitionTo(State toState){
  token.setStateName(toState.getName());
  token.setTimeEntered(currentDateService.getNow());
}","/** 
 * Update internal state and forward to token
 * @param toState
 */
void transitionTo(Transition transition){
  State toState=transition.getToState();
  token.setStateName(toState.getName());
  token.setTimeEntered(currentDateService.getNow());
  for (  ActionHandler handler : transition.getOnTransitionHandlers()) {
    handler.process(this);
  }
}"
87144,"/** 
 * Scan for triggers on the current state. This is recursive, so if a transition occurs it will scan again, and so forth. Because of the likelihood of infinite recursion, this implements a maximum number of auto transitions - see MAX_TRANSITIONS
 */
public boolean scan(){
  log.debug(""String_Node_Str"");
  int cnt=0;
  boolean didTransition=false;
  while (_scan()) {
    didTransition=true;
    if (cnt++ > MAX_TRANSITIONS)     throw new RuntimeException(""String_Node_Str"" + cnt + ""String_Node_Str"");
  }
  return didTransition;
}","/** 
 * Scan for triggers on the current state. This is recursive, so if a transition occurs it will scan again, and so forth. Because of the likelihood of infinite recursion, this implements a maximum number of auto transitions - see MAX_TRANSITIONS
 */
public boolean scan(){
  log.debug(""String_Node_Str"");
  int cnt=0;
  boolean didTransition=false;
  while (_scan()) {
    didTransition=true;
    if (cnt++ > MAX_TRANSITIONS) {
      throw new RuntimeException(""String_Node_Str"" + cnt + ""String_Node_Str"");
    }
  }
  return didTransition;
}"
87145,"void executeTransition(Transition transition){
  log.debug(""String_Node_Str"" + transition.getFromState().getName() + ""String_Node_Str""+ transition.getToState().getName());
  fireOnExit(transition.getFromState());
  transitionTo(transition.getToState());
  fireOnEnter(transition.getToState());
  if (transition.getToState().getInterval() != null) {
    if (timerService != null) {
      timerService.registerTimer(this);
    }
  }
 else {
    if (timerService != null) {
      timerService.unRegisterTimer(this);
    }
  }
  scan();
}","void executeTransition(Transition transition){
  log.info(""String_Node_Str"" + transition.getFromState().getName() + ""String_Node_Str""+ transition.getToState().getName());
  fireOnExit(transition.getFromState());
  transitionTo(transition);
  fireOnEnter(transition.getToState());
  if (transition.getToState().getInterval() != null) {
    if (timerService != null) {
      timerService.registerTimer(this);
    }
  }
 else {
    if (timerService != null) {
      timerService.unRegisterTimer(this);
    }
  }
  scan();
}"
87146,"private boolean _scan(){
  boolean didTransition=false;
  State state=getCurrentState();
  if (state == null) {
    state=process.getStartState();
    token.setStateName(state.getName());
    System.out.println(""String_Node_Str"" + token.getStateName());
    System.out.println(""String_Node_Str"" + getCurrentState().getName());
    didTransition=true;
  }
  System.out.println(""String_Node_Str"" + state.getTransitions().size());
  for (  Transition t : state.getTransitions()) {
    System.out.println(""String_Node_Str"" + t.getName());
    if (evalAndTransition(t,false)) {
      System.out.println(""String_Node_Str"" + token.getStateName());
      return true;
    }
  }
  return didTransition;
}","private boolean _scan(){
  boolean didTransition=false;
  State state=getCurrentState();
  if (state == null) {
    state=process.getStartState();
    token.setStateName(state.getName());
    log.info(""String_Node_Str"" + token.getStateName());
    didTransition=true;
  }
  for (  Transition t : state.getTransitions()) {
    if (evalAndTransition(t,false)) {
      log.info(""String_Node_Str"" + token.getStateName());
      return true;
    }
  }
  return didTransition;
}"
87147,"/** 
 * @param org
 * @param name
 * @param groupDao
 * @param numUsers
 * @param session
 * @param emailSender
 * @param registrationMode = eg ""o"" = open
 * @return
 * @throws HibernateException
 */
public Group checkCreateGroup(Organisation org,String name,int numUsers,Session session,Profile emailSender,String registrationMode) throws HibernateException {
  Group g=Group.findGroup(org,name,session);
  if (g == null) {
    g=new Group();
    g.setOrganisation(org);
    g.setName(name);
    g.setCreatedDate(new Date());
    g.setModifiedDate(new Date());
    g.setRegistrationMode(registrationMode);
    session.save(g);
    for (int i=0; i < numUsers; i++) {
      String pname=name + i;
      Profile p=checkCreateUser(pname,""String_Node_Str"",session,org,emailSender);
      p.addToGroup(g,org,session);
    }
  }
  return g;
}","/** 
 * @param org
 * @param name
 * @param groupDao
 * @param numUsers
 * @param session
 * @param emailSender
 * @param registrationMode = eg ""o"" = open
 * @return
 * @throws HibernateException
 */
public Group checkCreateGroup(Organisation org,String name,int numUsers,Session session,Profile emailSender,String registrationMode) throws HibernateException {
  Group g=Group.findGroup(org,name,session);
  if (g == null) {
    g=new Group();
    g.setOrganisation(org);
    g.setName(name);
    g.setCreatedDate(new Date());
    g.setModifiedDate(new Date());
    g.setRegistrationMode(registrationMode);
    if (org.getGroups() == null) {
      org.setGroups(new ArrayList<Group>());
    }
    org.getGroups().add(g);
    session.save(g);
    for (int i=0; i < numUsers; i++) {
      String pname=name + i;
      Profile p=checkCreateUser(pname,""String_Node_Str"",session,org,emailSender);
      p.addToGroup(g,org,session);
    }
  }
  return g;
}"
87148,"@Override public void init(SpliffyResourceFactory resourceFactory,AppConfig config) throws Exception {
  smtpPort=config.getInt(""String_Node_Str"");
  Properties props=new Properties();
  String hostName=config.getContext().get(CurrentRootFolderService.class).getPrimaryDomain();
  props.setProperty(ConfigurationMBean.PARAM_HOSTNAME,hostName);
  aspirinConfiguration=new Configuration(props);
  batchEmailService=new BatchEmailService();
  groupEmailService=new GroupEmailService(batchEmailService);
  config.getContext().put(groupEmailService);
  securityManager=resourceFactory.getSecurityManager();
  mailResourceFactory=new MiltonCloudMailResourceFactory(resourceFactory);
  this.currentDateService=config.getContext().get(CurrentDateService.class);
  queueStore=new EmailItemQueueStore(resourceFactory.getSessionManager(),aspirinConfiguration,listenerManager,currentDateService);
  StandardMessageFactory smf=new StandardMessageFactoryImpl();
  mailStore=new EmailItemMailStore(resourceFactory.getSessionManager(),smf);
  mailFilter=new MCMailFilter(resourceFactory.getSessionManager(),config.getContext());
  resourceFactory.getApplicationManager().getEmailTriggerTypes().add(new SubscriptionEventTriggerType());
  MailServerBuilder mailServerBuilder=new MailServerBuilder();
  mailServerBuilder.setListenerManager(listenerManager);
  mailServerBuilder.setAspirinConfiguration(aspirinConfiguration);
  mailServerBuilder.setMailResourceFactory(mailResourceFactory);
  mailServerBuilder.setEnablePop(false);
  mailServerBuilder.setEnableMsa(false);
  mailServerBuilder.setSmtpPort(smtpPort);
  mailServerBuilder.setMailStore(mailStore);
  mailServerBuilder.setQueueStore(queueStore);
  List<Filter> filters=new ArrayList<>();
  filters.add(mailFilter);
  mailServerBuilder.setFilters(Collections.unmodifiableList(filters));
  mailServer=mailServerBuilder.build();
  mailStore.setAspirinInternal(mailServerBuilder.getAspirinInternal());
  mailServer.start();
  eventManager=config.getContext().get(EventManager.class);
  eventManager.registerEventListener(this,SubscriptionEvent.class);
  asynchProcessor=config.getContext().get(AsynchProcessor.class);
}","@Override public void init(SpliffyResourceFactory resourceFactory,AppConfig config) throws Exception {
  smtpPort=config.getInt(""String_Node_Str"");
  Properties props=new Properties();
  String hostName=config.getContext().get(CurrentRootFolderService.class).getPrimaryDomain();
  props.setProperty(ConfigurationMBean.PARAM_HOSTNAME,hostName);
  aspirinConfiguration=new Configuration(props);
  batchEmailService=new BatchEmailService();
  groupEmailService=new GroupEmailService(batchEmailService);
  config.getContext().put(groupEmailService);
  securityManager=resourceFactory.getSecurityManager();
  mailResourceFactory=new MiltonCloudMailResourceFactory(resourceFactory);
  this.currentDateService=config.getContext().get(CurrentDateService.class);
  queueStore=new EmailItemQueueStore(resourceFactory.getSessionManager(),aspirinConfiguration,listenerManager,currentDateService);
  StandardMessageFactory smf=new StandardMessageFactoryImpl();
  mailStore=new EmailItemMailStore(resourceFactory.getSessionManager(),smf);
  mailFilter=new MCMailFilter(resourceFactory.getSessionManager(),config.getContext());
  emailTriggerService=new EmailTriggerService(batchEmailService);
  config.getContext().put(emailTriggerService);
  resourceFactory.getApplicationManager().getEmailTriggerTypes().add(new SubscriptionEventTriggerType());
  MailServerBuilder mailServerBuilder=new MailServerBuilder();
  mailServerBuilder.setListenerManager(listenerManager);
  mailServerBuilder.setAspirinConfiguration(aspirinConfiguration);
  mailServerBuilder.setMailResourceFactory(mailResourceFactory);
  mailServerBuilder.setEnablePop(false);
  mailServerBuilder.setEnableMsa(false);
  mailServerBuilder.setSmtpPort(smtpPort);
  mailServerBuilder.setMailStore(mailStore);
  mailServerBuilder.setQueueStore(queueStore);
  List<Filter> filters=new ArrayList<>();
  filters.add(mailFilter);
  mailServerBuilder.setFilters(Collections.unmodifiableList(filters));
  mailServer=mailServerBuilder.build();
  mailStore.setAspirinInternal(mailServerBuilder.getAspirinInternal());
  mailServer.start();
  eventManager=config.getContext().get(EventManager.class);
  eventManager.registerEventListener(this,TriggerEvent.class);
  asynchProcessor=config.getContext().get(AsynchProcessor.class);
}"
87149,"@Override public void doProcess(io.milton.context.Context context){
  log.info(""String_Node_Str"" + jobId);
  Session session=SessionManager.session();
  Transaction tx=session.beginTransaction();
  try {
    context.get(EmailTriggerService.class).send(jobId,sourceEntityIds,session);
  }
 catch (  Exception e) {
    tx.rollback();
    log.error(""String_Node_Str"" + jobId,e);
  }
}","@Override public void doProcess(io.milton.context.Context context){
  log.info(""String_Node_Str"" + jobId);
  Session session=SessionManager.session();
  Transaction tx=session.beginTransaction();
  try {
    EmailTriggerService emailTriggerService=context.get(EmailTriggerService.class);
    if (emailTriggerService == null) {
      throw new RuntimeException(""String_Node_Str"" + EmailTriggerService.class + ""String_Node_Str"");
    }
    emailTriggerService.send(jobId,sourceEntityIds,session);
    tx.commit();
  }
 catch (  Exception e) {
    tx.rollback();
    log.error(""String_Node_Str"" + jobId,e);
  }
}"
87150,"@Override public void setSendingResult(QueueInfo qi){
  final Session session=sessionManager.open();
  Transaction tx=session.beginTransaction();
  try {
    Long id=Long.parseLong(qi.getMailid());
    EmailItem i=(EmailItem)session.get(EmailItem.class,id);
    if (i == null) {
      return;
    }
    log.info(""String_Node_Str"" + i.getRecipientAddress() + ""String_Node_Str""+ i.getNumAttempts()+ ""String_Node_Str""+ i.getId());
    log.info(""String_Node_Str"" + qi.getResultInfo() + ""String_Node_Str""+ qi.getState());
    EmailSendAttempt a=new EmailSendAttempt();
    a.setEmailItem(i);
    a.setStatus(qi.getResultInfo());
    a.setStatusDate(currentDateService.getNow());
    session.save(a);
    i.setSendStatusDate(currentDateService.getNow());
    String sStatus=qi.getResultInfo();
    Integer status=SmtpUtils.getStatusCode(sStatus);
    if (status != null && (status >= 200 || status < 300)) {
      System.out.println(""String_Node_Str"");
      i.setSendStatus(""String_Node_Str"");
    }
 else {
      long tm=currentDateService.getNow().getTime();
      tm=tm + retryIntervalMs;
      Date retryDate=new Date(tm);
      int attempts=0;
      if (i.getNumAttempts() != null) {
        attempts=i.getNumAttempts();
      }
      if (attempts >= maxAttempts) {
        i.setSendStatus(""String_Node_Str"");
        log.warn(""String_Node_Str"" + attempts + ""String_Node_Str""+ i.getId());
      }
 else {
        attempts++;
        i.setNextAttempt(retryDate);
        i.setNumAttempts(attempts);
        i.setSendStatus(""String_Node_Str"");
        log.warn(""String_Node_Str"" + attempts + ""String_Node_Str""+ i.getId());
      }
    }
    session.save(i);
    log.info(""String_Node_Str"");
    BaseEmailJob job=i.getJob();
    if (job != null) {
      log.info(""String_Node_Str"");
      job.accept(new AbstractEmailJobVisitor(){
        @Override public void visit(        GroupEmailJob r){
          Date now=currentDateService.getNow();
          r.checkStatus(now,session);
        }
      }
);
    }
 else {
      log.info(""String_Node_Str"");
    }
    tx.commit();
  }
  finally {
    sessionManager.close();
  }
}","@Override public void setSendingResult(QueueInfo qi){
  final Session session=sessionManager.open();
  Transaction tx=session.beginTransaction();
  try {
    Long id=Long.parseLong(qi.getMailid());
    EmailItem i=(EmailItem)session.get(EmailItem.class,id);
    if (i == null) {
      return;
    }
    log.info(""String_Node_Str"" + i.getRecipientAddress() + ""String_Node_Str""+ i.getNumAttempts()+ ""String_Node_Str""+ i.getId());
    log.info(""String_Node_Str"" + qi.getResultInfo() + ""String_Node_Str""+ qi.getState());
    EmailSendAttempt a=new EmailSendAttempt();
    a.setEmailItem(i);
    a.setStatus(qi.getResultInfo());
    a.setStatusDate(currentDateService.getNow());
    session.save(a);
    i.setSendStatusDate(currentDateService.getNow());
    String sStatus=qi.getResultInfo();
    Integer status=SmtpUtils.getStatusCode(sStatus);
    if (status != null && (status >= 200 || status < 300)) {
      log.info(""String_Node_Str"" + status + ""String_Node_Str""+ sStatus);
      i.setSendStatus(""String_Node_Str"");
    }
 else {
      long tm=currentDateService.getNow().getTime();
      tm=tm + retryIntervalMs;
      Date retryDate=new Date(tm);
      int attempts=0;
      if (i.getNumAttempts() != null) {
        attempts=i.getNumAttempts();
      }
      if (attempts >= maxAttempts) {
        i.setSendStatus(""String_Node_Str"");
        log.warn(""String_Node_Str"" + attempts + ""String_Node_Str""+ i.getId());
      }
 else {
        attempts++;
        i.setNextAttempt(retryDate);
        i.setNumAttempts(attempts);
        i.setSendStatus(""String_Node_Str"");
        log.warn(""String_Node_Str"" + attempts + ""String_Node_Str""+ i.getId());
      }
    }
    session.save(i);
    log.info(""String_Node_Str"");
    BaseEmailJob job=i.getJob();
    if (job != null) {
      log.info(""String_Node_Str"");
      job.accept(new AbstractEmailJobVisitor(){
        @Override public void visit(        GroupEmailJob r){
          Date now=currentDateService.getNow();
          r.checkStatus(now,session);
        }
      }
);
    }
 else {
      log.info(""String_Node_Str"");
    }
    tx.commit();
  }
  finally {
    sessionManager.close();
  }
}"
87151,"@Override public RunInstancesResponse runInstances(RunInstances runInstances){
  try {
    RunInstancesRequestVCloud vCloudRequest=mappingService.getRunInstancesRequest(runInstances);
    RunInstancesResponseVCloud vCloudResponse=vCloudService.runInstances(vCloudRequest);
    DescribeInstancesInfoType describeInstancesInfoType=new DescribeInstancesInfoType().withItems(new DescribeInstancesItemType().withInstanceId(MappingUtils.vmUrnToInstanceId(vCloudResponse.getVmId())));
    DescribeInstancesResponse describeInstancesResponse=describeInstances(new DescribeInstances().withInstancesSet(describeInstancesInfoType));
    return mappingService.getRunInstancesResponse(describeInstancesResponse);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new EC2ServiceException(InternalError,e.getMessage() != null ? e.getMessage() : ""String_Node_Str"");
  }
}","@Override public RunInstancesResponse runInstances(RunInstances runInstances){
  try {
    RunInstancesRequestVCloud vCloudRequest=mappingService.getRunInstancesRequest(runInstances);
    RunInstancesResponseVCloud vCloudResponse=vCloudService.runInstances(vCloudRequest);
    DescribeInstancesInfoType describeInstancesInfoType=new DescribeInstancesInfoType();
    describeInstancesInfoType.withNewItems().withInstanceId(MappingUtils.vmUrnToInstanceId(vCloudResponse.getVmId()));
    RunInstancesResponse response=mappingService.getRunInstancesResponse(vCloudRequest,vCloudResponse);
    response.withGroupSet().withNewItems().withGroupId(""String_Node_Str"");
    return response;
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new EC2ServiceException(InternalError,e.getMessage() != null ? e.getMessage() : ""String_Node_Str"");
  }
}"
87152,RunInstancesResponse getRunInstancesResponse(DescribeInstancesResponse describeInstancesResponse);,"RunInstancesResponse getRunInstancesResponse(RunInstancesRequestVCloud runInstancesRequestVCloud,RunInstancesResponseVCloud runInstancesResponseVCloud);"
87153,"@Override public String apply(DescribeRegionsSetItemType in){
  return in.getRegionName();
}","@Override public boolean apply(Vm in){
  return in.getId().equals(runInstancesResponse.getVmId());
}"
87154,"@Override public RunInstancesResponse getRunInstancesResponse(DescribeInstancesResponse describeInstancesResponse){
  return new RunInstancesResponse().withRequestId(UUID.randomUUID().toString()).withOwnerId(vCloudService.getVCloudDirectorApi().getCurrentSession().getUser()).withInstancesSet(new RunningInstancesSetType().withItems(describeInstancesResponse.getReservationSet().getItems().get(0).getInstancesSet().getItems()));
}","@Override public RunInstancesResponse getRunInstancesResponse(final RunInstancesRequestVCloud runInstancesRequest,final RunInstancesResponseVCloud runInstancesResponse){
  RunInstancesResponse response=new RunInstancesResponse();
  response.withReservationId(""String_Node_Str"" + UUID.randomUUID().toString()).withOwnerId(vCloudService.getVCloudDirectorApi().getCurrentSession().getUser());
  String region=vCloudService.getVdcName();
  Vdc vdc=vCloudService.getVDC(region);
  ImmutableSet<Vm> vms=FluentIterable.from(vdc.getResourceEntities()).filter(typeEquals(VAPP)).transform(new Function<Reference,VApp>(){
    @Override public VApp apply(    Reference in){
      return vCloudService.getVCloudDirectorApi().getVAppApi().get(in.getHref());
    }
  }
).filter(Predicates.notNull()).transformAndConcat(new Function<VApp,Iterable<Vm>>(){
    @Override public Iterable<Vm> apply(    VApp in){
      if (null != in.getChildren() && null != in.getChildren().getVms()) {
        return in.getChildren().getVms();
      }
      return ImmutableSet.of();
    }
  }
).filter(new Predicate<Vm>(){
    @Override public boolean apply(    Vm in){
      return in.getId().equals(runInstancesResponse.getVmId());
    }
  }
).toImmutableSet();
  VmApi vmApi=vCloudService.getVCloudDirectorApi().getVmApi();
  Vm newvm=Iterables.getOnlyElement(vms);
  String vmId=newvm.getId();
  log.info(vmId);
  Set<String> addresses=getIpsFromVm(newvm);
  OperatingSystemSection operatingSystemSection=vmApi.getOperatingSystemSection(vmId);
  ResourceTagSetType tags=new ResourceTagSetType();
  Set<Map.Entry<String,String>> vmMeta=vmApi.getMetadataApi(vmId).get().entrySet();
  for (  Map.Entry<String,String> resourceTag : vmMeta) {
    tags.withNewItems().withKey(resourceTag.getKey()).withValue(resourceTag.getValue());
  }
  response.withInstancesSet().withNewItems().withAmiLaunchIndex(""String_Node_Str"").withTagSet(tags).withKeyName(runInstancesRequest.getKeyName()).withBlockDeviceMapping(new InstanceBlockDeviceMappingResponseType()).withDnsName(newvm.getName()).withEbsOptimized(Boolean.TRUE).withHypervisor(""String_Node_Str"").withImageId(MappingUtils.vAppTemplateUrnToImageId(runInstancesRequest.getvAppTemplateId())).withInstanceId(MappingUtils.vmUrnToInstanceId(vmId)).withInstanceState(MappingUtils.vCloudStatusToEc2Status(newvm.getStatus())).withInstanceType(""String_Node_Str"").withIpAddress(tryFind(addresses,not(InetAddresses2.IsPrivateIPAddress.INSTANCE)).orNull()).withPlacement(new PlacementResponseType().withAvailabilityZone(vdc.getName() + ""String_Node_Str"")).withPrivateIpAddress(tryFind(addresses,InetAddresses2.IsPrivateIPAddress.INSTANCE).orNull()).withVirtualizationType(""String_Node_Str"").withMonitoring(new InstanceMonitoringStateType().withState(""String_Node_Str"")).withArchitecture(operatingSystemSection.getOsType());
  return response;
}"
87155,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.parish_search);
  filterText=(EditText)findViewById(R.id.search_parishes);
  filterText.addTextChangedListener(filterTextWatcher);
  filterText.setOnFocusChangeListener(new View.OnFocusChangeListener(){
    @Override public void onFocusChange(    View view,    boolean hasFocus){
      if (!hasFocus) {
        hideKeyboard();
      }
    }
  }
);
  parishData=new ParishData(getApplicationContext());
  parishes=parishData.getAllParishes();
  adapter=new ParishAdapter(this,R.layout.parish_search_row,getParishNameArrayList());
  setListAdapter(adapter);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.parish_search);
  filterText=(EditText)findViewById(R.id.search_parishes);
  filterText.addTextChangedListener(filterTextWatcher);
  filterText.setOnFocusChangeListener(new View.OnFocusChangeListener(){
    @Override public void onFocusChange(    View view,    boolean hasFocus){
      if (!hasFocus) {
        hideKeyboard();
      }
    }
  }
);
  parishData=new ParishData(getApplicationContext());
  adapter=new ParishAdapter(this,R.layout.parish_search_row,parishData.getAllParishes());
  setListAdapter(adapter);
}"
87156,"public ParishAdapter(Context context,int textViewResourceId,String[] objects){
  super(context,textViewResourceId,objects);
}","public ParishAdapter(Context context,int textViewResourceId,List<Parish> parishList){
  super(context,textViewResourceId,parishList);
  parishes=parishList;
}"
87157,"@Override public View getView(int position,View convertView,ViewGroup parent){
  LayoutInflater inflater=getLayoutInflater();
  View row=inflater.inflate(R.layout.parish_search_row,parent,false);
  TextView name=(TextView)row.findViewById(R.id.parish_name);
  name.setText(parishes.get(position).getName());
  name.setTag(parishes.get(position).getParishID());
  TextView address=(TextView)row.findViewById(R.id.parish_city);
  address.setText(parishes.get(position).getCity() + ""String_Node_Str"" + parishes.get(position).getState());
  return row;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  View row=convertView;
  if (row == null) {
    LayoutInflater inflater=getLayoutInflater();
    row=inflater.inflate(R.layout.parish_search_row,parent,false);
  }
  if (getItem(position) != null) {
    parish=getItem(position);
  }
 else {
    parish=parishes.get(position);
  }
  TextView name=(TextView)row.findViewById(R.id.parish_name);
  name.setText(parish.getName());
  name.setTag(parish.getParishID());
  TextView address=(TextView)row.findViewById(R.id.parish_city);
  address.setText(parish.getCity() + ""String_Node_Str"" + parish.getState());
  return row;
}"
87158,"void syncFromTemplate(AbstractProject template,AbstractProject implementation) throws IOException {
  if (implementation == null || !(implementation instanceof BuildableItemWithBuildWrappers) || !(implementation instanceof Describable) || template == null || !(template instanceof BuildableItemWithBuildWrappers) || !(template instanceof Describable)) {
    return;
  }
  ImplementationBuildWrapper implementationBuildWrapper=this;
  Map<Pattern,String> propertiesMap=getPropertiesMap(template,implementation,implementationBuildWrapper);
  String oldDescription=implementation.getDescription();
  boolean oldDisabled=implementation.isDisabled();
  XmlFile implementationXmlFile=replaceConfig(template,implementation,propertiesMap);
  refreshAndSave(template,implementationBuildWrapper,implementationXmlFile,oldDescription,oldDisabled);
}","void syncFromTemplate(AbstractProject template,AbstractProject implementation) throws IOException {
  if (implementation == null || !(implementation instanceof BuildableItemWithBuildWrappers) || !(implementation instanceof Describable) || template == null || !(template instanceof BuildableItemWithBuildWrappers) || !(template instanceof Describable)) {
    return;
  }
  ImplementationBuildWrapper implementationBuildWrapper=this;
  TemplateBuildWrapper templateBuildWrapper=BuildWrapperUtils.findBuildWrapper(TemplateBuildWrapper.class,template);
  if (templateBuildWrapper == null) {
    return;
  }
  Map<Pattern,String> propertiesMap=getPropertiesMap(template,implementation,implementationBuildWrapper);
  String oldDescription=implementation.getDescription();
  boolean oldDisabled=implementation.isDisabled();
  XmlFile implementationXmlFile=replaceConfig(template,implementation,propertiesMap);
  refreshAndSave(template,implementationBuildWrapper,implementationXmlFile,oldDescription,oldDisabled);
}"
87159,"@Test public void post() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  TransportImpl myTransport=new TransportImpl(null);
  myClient.init(myTransport);
  FailureDetector myFd=_tport1.getFD();
  FDUtil.ensureFD(myFd);
  ByteBuffer myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(55);
  Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
  myClient.send(new Envelope(myProp),_tport1.getLocalAddress());
  VoteOutcome myEv=myClient.getNext(10000);
  Assert.assertFalse((myEv == null));
  Assert.assertTrue(myEv.getResult() == VoteOutcome.Reason.VALUE);
  AcceptorLearner myAl=_node2.getAcceptorLearner();
  Common myCommon=_node2.getCore().getCommon();
  Collect myCollect=new Collect(myAl.getLowWatermark().getSeqNum() + 1,myAl.getLeaderRndNum());
  myClient.send(myCollect,_tport2.getLocalAddress());
  Thread.sleep(5000);
  Assert.assertTrue(myAl.getStats().getIgnoredCollectsCount() == 1);
}","@Test public void post() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  TransportImpl myTransport=new TransportImpl(null);
  myClient.init(myTransport);
  FailureDetector myFd=_tport1.getFD();
  FDUtil.ensureFD(myFd);
  ByteBuffer myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(55);
  Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
  myClient.send(new Envelope(myProp),_tport1.getLocalAddress());
  VoteOutcome myEv=myClient.getNext(10000);
  Assert.assertFalse((myEv == null));
  Assert.assertTrue(myEv.getResult() == VoteOutcome.Reason.VALUE);
  AcceptorLearner myAl=_node2.getAcceptorLearner();
  Common myCommon=_node2.getCore().getCommon();
  Collect myCollect=new Collect(myAl.getLowWatermark().getSeqNum() + 1,myAl.getLeaderRndNum() + 1);
  myClient.send(myCollect,_tport2.getLocalAddress());
  Thread.sleep(5000);
  Assert.assertTrue(myAl.getStats().getIgnoredCollectsCount() == 1);
}"
87160,"void shutdown(){
  _nodeSet.shutdown();
  _transportFactory.stop();
}","void shutdown() throws Exception {
  _nodeSet.shutdown();
  _transportFactory.stop();
}"
87161,"public void checkpoint() throws Exception {
  _checkpointer.checkpoint(_dispatcher);
}","public void checkpoint() throws Exception {
  _config.setHandle(_checkpointer.checkpoint(_dispatcher));
}"
87162,"NodeAdminImpl(OrderedMemoryTransport aTransport,Config aConfig,Environment anEnv){
  _config=aConfig;
  _env=anEnv;
  _transport=aTransport;
  _dispatcher=new ServerDispatcher(_config._loggerFactory.getLogger(),this);
  try {
    _dispatcher.init(_transport);
  }
 catch (  Exception anE) {
    throw new RuntimeException(""String_Node_Str"",anE);
  }
}","NodeAdminImpl(OrderedMemoryTransport aTransport,Config aConfig,Environment anEnv){
  _config=aConfig;
  _env=anEnv;
  _transport=aTransport;
  _dispatcher=new ServerDispatcher(_config._loggerFactory.getLogger(),_config.getHandle(),this,false);
  try {
    _dispatcher.init(_transport);
  }
 catch (  Exception anE) {
    throw new RuntimeException(""String_Node_Str"",anE);
  }
}"
87163,"public NodeAdmin.Memento terminate(NodeAdmin anAdmin){
  _nodes.remove(anAdmin);
  return anAdmin.terminate();
}","public NodeAdmin.Memento terminate(NodeAdmin anAdmin) throws Exception {
  _nodes.remove(anAdmin);
  return anAdmin.terminate();
}"
87164,"void shutdown(){
  for (  NodeAdmin myNA : _nodes)   myNA.terminate();
}","void shutdown() throws Exception {
  for (  NodeAdmin myNA : _nodes)   myNA.terminate();
}"
87165,"@Override public Permuter.Restoration<OrderedMemoryNetwork.Context> apply(OrderedMemoryNetwork.Context aContext,RandomGenerator aGen){
  Environment myEnv=aContext._transport.getEnv();
  for (  NodeAdmin myAdmin : myEnv.getNodes().getKillableNodes()) {
    if ((!myAdmin.getTransport().getLocalAddress().equals(aContext._packet.getSource())) && (_deadCount.compareAndSet(0,1))) {
      int myRebirthTicks=aGen.nextInt(501) + 500;
      NodeAdmin.Memento myMemento=myEnv.getNodes().terminate(myAdmin);
      if (myMemento != null) {
        Grave myGrave=new Grave(myMemento,myRebirthTicks);
        OrderedMemoryTransportImpl._logger.info(""String_Node_Str"" + myGrave.getId() + ""String_Node_Str""+ myMemento+ ""String_Node_Str""+ myRebirthTicks+ ""String_Node_Str""+ (_deadCount.get())+ ""String_Node_Str"");
        return myGrave;
      }
 else {
        _deadCount.decrementAndGet();
      }
    }
  }
  return (c) -> true;
}","@Override public Permuter.Restoration<OrderedMemoryNetwork.Context> apply(OrderedMemoryNetwork.Context aContext,RandomGenerator aGen){
  Environment myEnv=aContext._transport.getEnv();
  for (  NodeAdmin myAdmin : myEnv.getNodes().getKillableNodes()) {
    if ((!myAdmin.getTransport().getLocalAddress().equals(aContext._packet.getSource())) && (_deadCount.compareAndSet(0,1))) {
      int myRebirthTicks=aGen.nextInt(501) + 500;
      NodeAdmin.Memento myMemento=null;
      try {
        myMemento=myEnv.getNodes().terminate(myAdmin);
      }
 catch (      Exception anE) {
        OrderedMemoryTransportImpl._logger.error(""String_Node_Str"",anE);
      }
      if (myMemento != null) {
        Grave myGrave=new Grave(myMemento,myRebirthTicks);
        OrderedMemoryTransportImpl._logger.info(""String_Node_Str"" + myGrave.getId() + ""String_Node_Str""+ myMemento+ ""String_Node_Str""+ myRebirthTicks+ ""String_Node_Str""+ (_deadCount.get())+ ""String_Node_Str"");
        return myGrave;
      }
 else {
        _deadCount.decrementAndGet();
      }
    }
  }
  return (c) -> true;
}"
87166,"public void OrderedMemoryNetwork(Environment anEnv){
  _env=anEnv;
  _broadcastAddr=new InetSocketAddress(org.dancres.paxos.impl.net.Utils.getBroadcastAddress(),255);
  Thread myDispatcher=new Thread(this);
  myDispatcher.setDaemon(true);
  myDispatcher.start();
  _permuter=new Permuter<>(_env.getRng().nextLong());
  if (_env.isSimulating())   _permuter.add(new PacketDrop()).add(new MachineBlip());
}","public OrderedMemoryNetwork(Environment anEnv){
  _env=anEnv;
  _broadcastAddr=new InetSocketAddress(org.dancres.paxos.impl.net.Utils.getBroadcastAddress(),255);
  Thread myDispatcher=new Thread(this);
  myDispatcher.setDaemon(true);
  myDispatcher.start();
  _permuter=new Permuter<>(_env.getRng().nextLong());
  if (_env.isSimulating())   _permuter.add(new PacketDrop()).add(new MachineBlip());
}"
87167,"EnvironmentImpl(long aSeed,long aCycles,boolean doCalibrate,long aCkptCycle,boolean inMemory) throws Exception {
  _ckptCycle=aCkptCycle;
  _isLive=!doCalibrate;
  _maxCycles=aCycles;
  _baseRng=new Random(aSeed);
  _factory=new OrderedMemoryNetwork(this);
  _nodeFactory=(  InetSocketAddress aLocalAddr,  InetSocketAddress aBroadcastAddr,  OrderedMemoryNetwork aNetwork,  MessageBasedFailureDetector anFD,  Object aContext) -> {
    NodeAdminImpl myNode=new NodeAdminImpl(aLocalAddr,aBroadcastAddr,aNetwork,anFD,(NodeAdminImpl.Config)aContext,EnvironmentImpl.this);
    return new OrderedMemoryNetwork.Factory.Constructed(myNode.getTransport(),myNode);
  }
;
  Deque<NodeAdmin> myNodes=new LinkedList<>();
  for (int i=0; i < 5; i++) {
    LogStorageFactory myFactory=(!inMemory) ? new HowlLoggerFactory(BASEDIR,i) : new MemoryLoggerFactory();
    OrderedMemoryNetwork.Factory.Constructed myResult=addNodeAdmin(Utils.getTestAddress(),new NodeAdminImpl.Config(i,myFactory));
    myNodes.add((NodeAdmin)myResult.getAdditional());
  }
  _nodeSet=new NodeSet(myNodes);
}","EnvironmentImpl(long aSeed,long aCycles,boolean doCalibrate,long aCkptCycle,boolean inMemory) throws Exception {
  _ckptCycle=aCkptCycle;
  _isLive=!doCalibrate;
  _maxCycles=aCycles;
  _baseRng=new Random(aSeed);
  _factory=new OrderedMemoryNetwork(this);
  _nodeFactory=(  InetSocketAddress aLocalAddr,  InetSocketAddress aBroadcastAddr,  OrderedMemoryNetwork aNetwork,  MessageBasedFailureDetector anFD,  Object aContext) -> {
    NodeAdminImpl myNode=new NodeAdminImpl(aLocalAddr,aBroadcastAddr,aNetwork,anFD,(NodeAdminImpl.Config)aContext,EnvironmentImpl.this);
    return new OrderedMemoryNetwork.Factory.Constructed(myNode.getTransport(),myNode);
  }
;
  Deque<NodeAdmin> myNodes=new LinkedList<>();
  for (int i=0; i < 5; i++) {
    LogStorageFactory myFactory=(!inMemory) ? new HowlLoggerFactory(BASEDIR,i) : new MemoryLoggerFactory();
    OrderedMemoryNetwork.Factory.Constructed myResult=addNodeAdmin(Utils.getTestAddress(),new NodeAdminImpl.Config(i,myFactory));
    myNodes.add((NodeAdmin)myResult.getAdditional());
  }
  _nodeSet.init(myNodes);
}"
87168,"NodeSet(Deque<NodeAdmin> aNodes){
  _currentLeader=aNodes.getFirst();
  _nodes.addAll(aNodes);
}","NodeSet(){
}"
87169,"private void awaken(Environment anEnv){
  OrderedMemoryTransportImpl._logger.info(""String_Node_Str"" + _id + ""String_Node_Str""+ _dna.get()+ ""String_Node_Str"");
  NodeAdmin.Memento myDna=_dna.getAndSet(null);
  if (myDna != null)   anEnv.addNodeAdmin(myDna);
}","private void awaken(Environment anEnv){
  OrderedMemoryTransportImpl._logger.info(""String_Node_Str"" + _id + ""String_Node_Str""+ _dna.get()+ ""String_Node_Str"");
  NodeAdmin.Memento myDna=_dna.getAndSet(null);
  if (myDna != null)   anEnv.addNodeAdmin(myDna);
  _deadCount.decrementAndGet();
}"
87170,"@Before public void init() throws Exception {
  FileSystem.deleteDirectory(new File(_node1Log));
  FileSystem.deleteDirectory(new File(_node2Log));
  FileSystem.deleteDirectory(new File(_node3Log));
  _node1=new ServerDispatcher(new HowlLogger(_node1Log));
  _node2=new ServerDispatcher(new HowlLogger(_node2Log));
  _tport1=new DropTransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new DropTransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  FileSystem.deleteDirectory(new File(_node1Log));
  FileSystem.deleteDirectory(new File(_node2Log));
  FileSystem.deleteDirectory(new File(_node3Log));
  _node1=new ServerDispatcher(new HowlLogger(_node1Log),Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(new HowlLogger(_node2Log),Listener.NULL_LISTENER);
  _tport1=new DropTransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new DropTransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87171,"@Test public void post() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  TransportImpl myTransport=new TransportImpl(null);
  myClient.init(myTransport);
  FDUtil.ensureFD(_tport1.getFD());
  FDUtil.ensureFD(_tport2.getFD());
  System.err.println(""String_Node_Str"");
  for (int i=0; i < 5; i++) {
    ByteBuffer myBuffer=ByteBuffer.allocate(4);
    myBuffer.putInt(i);
    Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
    myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
    VoteOutcome myEv=myClient.getNext(10000);
    Assert.assertFalse((myEv == null));
    Assert.assertTrue(myEv.getResult() == VoteOutcome.Reason.VALUE);
    Assert.assertTrue(myEv.getSeqNum() == i);
  }
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  _node3=new ServerDispatcher(new HowlLogger(_node3Log));
  _tport3=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node3.init(_tport3);
  _node3.getAcceptorLearner().setRecoveryGracePeriod(5000);
  FDUtil.ensureFD(_tport3.getFD());
  System.err.println(""String_Node_Str"");
  ByteBuffer myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(67);
  Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
  myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
  VoteOutcome myOutcome=myClient.getNext(10000);
  System.err.println(""String_Node_Str"");
  Thread.sleep(15000);
  Assert.assertTrue(_node2.getAcceptorLearner().getLowWatermark().getSeqNum() != _node3.getAcceptorLearner().getLowWatermark().getSeqNum());
  Assert.assertFalse(_node3.getCore().getCommon().getNodeState().test(NodeState.State.RECOVERING));
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  myTransport.terminate();
}","@Test public void post() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  TransportImpl myTransport=new TransportImpl(null);
  myClient.init(myTransport);
  FDUtil.ensureFD(_tport1.getFD());
  FDUtil.ensureFD(_tport2.getFD());
  System.err.println(""String_Node_Str"");
  for (int i=0; i < 5; i++) {
    ByteBuffer myBuffer=ByteBuffer.allocate(4);
    myBuffer.putInt(i);
    Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
    myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
    VoteOutcome myEv=myClient.getNext(10000);
    Assert.assertFalse((myEv == null));
    Assert.assertTrue(myEv.getResult() == VoteOutcome.Reason.VALUE);
    Assert.assertTrue(myEv.getSeqNum() == i);
  }
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  _node3=new ServerDispatcher(new HowlLogger(_node3Log),Listener.NULL_LISTENER);
  _tport3=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node3.init(_tport3);
  _node3.getAcceptorLearner().setRecoveryGracePeriod(5000);
  FDUtil.ensureFD(_tport3.getFD());
  System.err.println(""String_Node_Str"");
  ByteBuffer myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(67);
  Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
  myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
  VoteOutcome myOutcome=myClient.getNext(10000);
  System.err.println(""String_Node_Str"");
  Thread.sleep(15000);
  Assert.assertTrue(_node2.getAcceptorLearner().getLowWatermark().getSeqNum() != _node3.getAcceptorLearner().getLowWatermark().getSeqNum());
  Assert.assertFalse(_node3.getCore().getCommon().getNodeState().test(NodeState.State.RECOVERING));
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  myTransport.terminate();
}"
87172,"@Before public void init() throws Exception {
  FileSystem.deleteDirectory(new File(_node1Log));
  FileSystem.deleteDirectory(new File(_node2Log));
  FileSystem.deleteDirectory(new File(_node3Log));
  _node1=new ServerDispatcher(new HowlLogger(_node1Log));
  _node2=new ServerDispatcher(new HowlLogger(_node2Log));
  _tport1=new OODTransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new OODTransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  FileSystem.deleteDirectory(new File(_node1Log));
  FileSystem.deleteDirectory(new File(_node2Log));
  FileSystem.deleteDirectory(new File(_node3Log));
  _node1=new ServerDispatcher(new HowlLogger(_node1Log),org.dancres.paxos.Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(new HowlLogger(_node2Log),org.dancres.paxos.Listener.NULL_LISTENER);
  _tport1=new OODTransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new OODTransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87173,"@Test public void post() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  TransportImpl myTransport=new TransportImpl(null);
  myClient.init(myTransport);
  FDUtil.ensureFD(_tport1.getFD());
  FDUtil.ensureFD(_tport2.getFD());
  System.err.println(""String_Node_Str"");
  for (int i=0; i < 5; i++) {
    ByteBuffer myBuffer=ByteBuffer.allocate(4);
    myBuffer.putInt(i);
    Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
    myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
    VoteOutcome myEv=myClient.getNext(10000);
    Assert.assertFalse((myEv == null));
    Assert.assertTrue(myEv.getResult() == VoteOutcome.Reason.VALUE);
    Assert.assertTrue(myEv.getSeqNum() == i);
  }
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  Listener myListener=new Listener();
  _node3=new ServerDispatcher(new HowlLogger(_node3Log));
  _tport3=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node3.init(_tport3);
  _node3.add(myListener);
  FDUtil.ensureFD(_tport3.getFD());
  System.err.println(""String_Node_Str"");
  ByteBuffer myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(67);
  Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
  myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
  VoteOutcome myOutcome=myClient.getNext(10000);
  System.err.println(""String_Node_Str"");
  Thread.sleep(5000);
  Assert.assertTrue(myListener.didOOD());
  boolean isInactive=false;
  try {
    _node3.getCore().submit(myProp,anOutcome -> {
    }
);
  }
 catch (  InactiveException anIE) {
    isInactive=true;
  }
  Assert.assertTrue(isInactive);
  boolean stateChecked=false;
  try {
    _node3.getCore().newCheckpoint();
  }
 catch (  IllegalStateException anISE) {
    stateChecked=true;
  }
  Assert.assertTrue(stateChecked);
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  myTransport.terminate();
}","@Test public void post() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  TransportImpl myTransport=new TransportImpl(null);
  myClient.init(myTransport);
  FDUtil.ensureFD(_tport1.getFD());
  FDUtil.ensureFD(_tport2.getFD());
  System.err.println(""String_Node_Str"");
  for (int i=0; i < 5; i++) {
    ByteBuffer myBuffer=ByteBuffer.allocate(4);
    myBuffer.putInt(i);
    Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
    myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
    VoteOutcome myEv=myClient.getNext(10000);
    Assert.assertFalse((myEv == null));
    Assert.assertTrue(myEv.getResult() == VoteOutcome.Reason.VALUE);
    Assert.assertTrue(myEv.getSeqNum() == i);
  }
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  Listener myListener=new Listener();
  _node3=new ServerDispatcher(new HowlLogger(_node3Log),org.dancres.paxos.Listener.NULL_LISTENER);
  _tport3=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node3.init(_tport3);
  _node3.add(myListener);
  FDUtil.ensureFD(_tport3.getFD());
  System.err.println(""String_Node_Str"");
  ByteBuffer myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(67);
  Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
  myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
  VoteOutcome myOutcome=myClient.getNext(10000);
  System.err.println(""String_Node_Str"");
  Thread.sleep(5000);
  Assert.assertTrue(myListener.didOOD());
  boolean isInactive=false;
  try {
    _node3.getCore().submit(myProp,anOutcome -> {
    }
);
  }
 catch (  InactiveException anIE) {
    isInactive=true;
  }
  Assert.assertTrue(isInactive);
  boolean stateChecked=false;
  try {
    _node3.getCore().newCheckpoint();
  }
 catch (  IllegalStateException anISE) {
    stateChecked=true;
  }
  Assert.assertTrue(stateChecked);
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  myTransport.terminate();
}"
87174,"@Before public void init() throws Exception {
  FileSystem.deleteDirectory(new File(_node1Log));
  FileSystem.deleteDirectory(new File(_node2Log));
  FileSystem.deleteDirectory(new File(_node3Log));
  _node1=new ServerDispatcher(new HowlLogger(_node1Log));
  _node2=new ServerDispatcher(new HowlLogger(_node2Log));
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  FileSystem.deleteDirectory(new File(_node1Log));
  FileSystem.deleteDirectory(new File(_node2Log));
  FileSystem.deleteDirectory(new File(_node3Log));
  _node1=new ServerDispatcher(new HowlLogger(_node1Log),Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(new HowlLogger(_node2Log),Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87175,"@Test public void post() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  TransportImpl myTransport=new TransportImpl(null);
  myClient.init(myTransport);
  FDUtil.ensureFD(_tport1.getFD());
  FDUtil.ensureFD(_tport2.getFD());
  System.err.println(""String_Node_Str"");
  for (int i=0; i < 5; i++) {
    ByteBuffer myBuffer=ByteBuffer.allocate(4);
    myBuffer.putInt(i);
    Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
    myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
    VoteOutcome myEv=myClient.getNext(10000);
    Assert.assertFalse((myEv == null));
    Assert.assertTrue(myEv.getResult() == VoteOutcome.Reason.VALUE);
    Assert.assertTrue(myEv.getSeqNum() == i);
  }
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  _node3=new ServerDispatcher(new HowlLogger(_node3Log));
  _tport3=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node3.init(_tport3);
  _node3.getAcceptorLearner().setRecoveryGracePeriod(1000);
  FDUtil.ensureFD(_tport3.getFD());
  System.err.println(""String_Node_Str"");
  ByteBuffer myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(67);
  Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
  myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
  VoteOutcome myMsg=myClient.getNext(10000);
  myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(69);
  Proposal myProp2=new Proposal(""String_Node_Str"",myBuffer.array());
  System.err.println(""String_Node_Str"");
  myClient.send(new Envelope(myProp2),_tport2.getLocalAddress());
  myClient.getNext(10000);
  System.err.println(""String_Node_Str"");
  Thread.sleep(5000);
  Assert.assertTrue(_node2.getAcceptorLearner().getLowWatermark().getSeqNum() == _node3.getAcceptorLearner().getLowWatermark().getSeqNum());
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  myTransport.terminate();
}","@Test public void post() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  TransportImpl myTransport=new TransportImpl(null);
  myClient.init(myTransport);
  FDUtil.ensureFD(_tport1.getFD());
  FDUtil.ensureFD(_tport2.getFD());
  System.err.println(""String_Node_Str"");
  for (int i=0; i < 5; i++) {
    ByteBuffer myBuffer=ByteBuffer.allocate(4);
    myBuffer.putInt(i);
    Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
    myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
    VoteOutcome myEv=myClient.getNext(10000);
    Assert.assertFalse((myEv == null));
    Assert.assertTrue(myEv.getResult() == VoteOutcome.Reason.VALUE);
    Assert.assertTrue(myEv.getSeqNum() == i);
  }
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  _node3=new ServerDispatcher(new HowlLogger(_node3Log),Listener.NULL_LISTENER);
  _tport3=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node3.init(_tport3);
  _node3.getAcceptorLearner().setRecoveryGracePeriod(1000);
  FDUtil.ensureFD(_tport3.getFD());
  System.err.println(""String_Node_Str"");
  ByteBuffer myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(67);
  Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
  myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
  VoteOutcome myMsg=myClient.getNext(10000);
  myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(69);
  Proposal myProp2=new Proposal(""String_Node_Str"",myBuffer.array());
  System.err.println(""String_Node_Str"");
  myClient.send(new Envelope(myProp2),_tport2.getLocalAddress());
  myClient.getNext(10000);
  System.err.println(""String_Node_Str"");
  Thread.sleep(5000);
  Assert.assertTrue(_node2.getAcceptorLearner().getLowWatermark().getSeqNum() == _node3.getAcceptorLearner().getLowWatermark().getSeqNum());
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  myTransport.terminate();
}"
87176,"@Before public void init() throws Exception {
  FileSystem.deleteDirectory(new File(_node1Log));
  FileSystem.deleteDirectory(new File(_node2Log));
  FileSystem.deleteDirectory(new File(_node3Log));
  _node1=new ServerDispatcher(new HowlLogger(_node1Log));
  _node2=new ServerDispatcher(new HowlLogger(_node2Log));
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  FileSystem.deleteDirectory(new File(_node1Log));
  FileSystem.deleteDirectory(new File(_node2Log));
  FileSystem.deleteDirectory(new File(_node3Log));
  _node1=new ServerDispatcher(new HowlLogger(_node1Log),Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(new HowlLogger(_node2Log),Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87177,"@Test public void intro() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  TransportImpl myTransport=new TransportImpl(null);
  myClient.init(myTransport);
  FDUtil.ensureFD(_tport1.getFD());
  FDUtil.ensureFD(_tport2.getFD());
  _tport1.getFD().pin(_tport1.getFD().getMembers().getMembers().keySet());
  _tport2.getFD().pin(_tport2.getFD().getMembers().getMembers().keySet());
  for (int i=0; i < 5; i++) {
    ByteBuffer myBuffer=ByteBuffer.allocate(4);
    myBuffer.putInt(i);
    Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
    myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
    VoteOutcome myEv=myClient.getNext(10000);
    Assert.assertFalse((myEv == null));
    Assert.assertTrue(myEv.getResult() == VoteOutcome.Reason.VALUE);
    Assert.assertTrue(myEv.getSeqNum() == i);
  }
  Thread.sleep(2000);
  _node3=new ServerDispatcher(new HowlLogger(_node3Log));
  _tport3=new TransportImpl(new FailureDetectorImpl(5000));
  _node3.init(_tport3);
  _node3.getAcceptorLearner().setRecoveryGracePeriod(1000);
  Assert.assertFalse(FDUtil.testFD(_tport3.getFD(),10000));
  Assert.assertFalse(_tport3.getFD().isMember(_tport3.getLocalAddress()));
  ByteBuffer myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(67);
  Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
  myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
  VoteOutcome myMsg=myClient.getNext(10000);
  Thread.sleep(5000);
  Assert.assertTrue(_node2.getAcceptorLearner().getLowWatermark().getSeqNum() == _node3.getAcceptorLearner().getLowWatermark().getSeqNum());
  Assert.assertEquals(1,_node3.getAcceptorLearner().getStats().getRecoveryCycles());
  Assert.assertFalse(_tport3.getFD().isMember(_tport3.getLocalAddress()));
  Assert.assertFalse(_tport2.getFD().isMember(_tport3.getLocalAddress()));
  myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
  myClient.getNext(10000);
  Thread.sleep(2000);
  Assert.assertTrue(_node2.getAcceptorLearner().getLowWatermark().getSeqNum() == _node3.getAcceptorLearner().getLowWatermark().getSeqNum());
  Assert.assertEquals(1,_node3.getAcceptorLearner().getStats().getRecoveryCycles());
  Assert.assertEquals(0,_node3.getAcceptorLearner().getStats().getActiveAccepts());
  Collection<InetSocketAddress> myNewMembers=new LinkedList<>();
  myNewMembers.addAll(_tport2.getFD().getMembers().getMembers().keySet());
  myNewMembers.add(_tport3.getLocalAddress());
  Assert.assertTrue(_node2.getCore().updateMembership(myNewMembers));
  Thread.sleep(2000);
  Assert.assertTrue(_tport3.getFD().isMember(_tport3.getLocalAddress()));
  myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
  myClient.getNext(10000);
  Thread.sleep(2000);
  Assert.assertTrue(_node2.getAcceptorLearner().getLowWatermark().getSeqNum() == _node3.getAcceptorLearner().getLowWatermark().getSeqNum());
  Assert.assertEquals(1,_node3.getAcceptorLearner().getStats().getRecoveryCycles());
  Assert.assertEquals(1,_node3.getAcceptorLearner().getStats().getActiveAccepts());
  myTransport.terminate();
}","@Test public void intro() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  TransportImpl myTransport=new TransportImpl(null);
  myClient.init(myTransport);
  FDUtil.ensureFD(_tport1.getFD());
  FDUtil.ensureFD(_tport2.getFD());
  _tport1.getFD().pin(_tport1.getFD().getMembers().getMembers().keySet());
  _tport2.getFD().pin(_tport2.getFD().getMembers().getMembers().keySet());
  for (int i=0; i < 5; i++) {
    ByteBuffer myBuffer=ByteBuffer.allocate(4);
    myBuffer.putInt(i);
    Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
    myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
    VoteOutcome myEv=myClient.getNext(10000);
    Assert.assertFalse((myEv == null));
    Assert.assertTrue(myEv.getResult() == VoteOutcome.Reason.VALUE);
    Assert.assertTrue(myEv.getSeqNum() == i);
  }
  Thread.sleep(2000);
  _node3=new ServerDispatcher(new HowlLogger(_node3Log),Listener.NULL_LISTENER);
  _tport3=new TransportImpl(new FailureDetectorImpl(5000));
  _node3.init(_tport3);
  _node3.getAcceptorLearner().setRecoveryGracePeriod(1000);
  Assert.assertFalse(FDUtil.testFD(_tport3.getFD(),10000));
  Assert.assertFalse(_tport3.getFD().isMember(_tport3.getLocalAddress()));
  ByteBuffer myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(67);
  Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
  myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
  VoteOutcome myMsg=myClient.getNext(10000);
  Thread.sleep(5000);
  Assert.assertTrue(_node2.getAcceptorLearner().getLowWatermark().getSeqNum() == _node3.getAcceptorLearner().getLowWatermark().getSeqNum());
  Assert.assertEquals(1,_node3.getAcceptorLearner().getStats().getRecoveryCycles());
  Assert.assertFalse(_tport3.getFD().isMember(_tport3.getLocalAddress()));
  Assert.assertFalse(_tport2.getFD().isMember(_tport3.getLocalAddress()));
  myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
  myClient.getNext(10000);
  Thread.sleep(2000);
  Assert.assertTrue(_node2.getAcceptorLearner().getLowWatermark().getSeqNum() == _node3.getAcceptorLearner().getLowWatermark().getSeqNum());
  Assert.assertEquals(1,_node3.getAcceptorLearner().getStats().getRecoveryCycles());
  Assert.assertEquals(0,_node3.getAcceptorLearner().getStats().getActiveAccepts());
  Collection<InetSocketAddress> myNewMembers=new LinkedList<>();
  myNewMembers.addAll(_tport2.getFD().getMembers().getMembers().keySet());
  myNewMembers.add(_tport3.getLocalAddress());
  Assert.assertTrue(_node2.getCore().updateMembership(myNewMembers));
  Thread.sleep(2000);
  Assert.assertTrue(_tport3.getFD().isMember(_tport3.getLocalAddress()));
  myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
  myClient.getNext(10000);
  Thread.sleep(2000);
  Assert.assertTrue(_node2.getAcceptorLearner().getLowWatermark().getSeqNum() == _node3.getAcceptorLearner().getLowWatermark().getSeqNum());
  Assert.assertEquals(1,_node3.getAcceptorLearner().getStats().getRecoveryCycles());
  Assert.assertEquals(1,_node3.getAcceptorLearner().getStats().getActiveAccepts());
  myTransport.terminate();
}"
87178,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new DroppingTransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new DroppingTransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87179,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000),""String_Node_Str"".getBytes());
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000),""String_Node_Str"".getBytes());
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000),""String_Node_Str"".getBytes());
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000),""String_Node_Str"".getBytes());
  _node2.init(_tport2);
}"
87180,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87181,"@Before public void init() throws Exception {
  FileSystem.deleteDirectory(new File(_node1Log));
  FileSystem.deleteDirectory(new File(_node2Log));
  _node1=new ServerDispatcher(new HowlLogger(_node1Log));
  _node2=new ServerDispatcher(new HowlLogger(_node2Log));
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  FileSystem.deleteDirectory(new File(_node1Log));
  FileSystem.deleteDirectory(new File(_node2Log));
  _node1=new ServerDispatcher(new HowlLogger(_node1Log),Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(new HowlLogger(_node2Log),Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87182,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87183,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _tport2.filterTx(new LastDropper());
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _tport2.filterTx(new LastDropper());
  _node2.init(_tport2);
}"
87184,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87185,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87186,"@Before public void init() throws Exception {
  FileSystem.deleteDirectory(new File(_node1Log));
  FileSystem.deleteDirectory(new File(_node2Log));
  FileSystem.deleteDirectory(new File(_node3Log));
  Leader.LeaseDuration.set(10000);
  _node1=new ServerDispatcher(new HowlLogger(_node1Log),true);
  _node2=new ServerDispatcher(new HowlLogger(_node2Log),true);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  FileSystem.deleteDirectory(new File(_node1Log));
  FileSystem.deleteDirectory(new File(_node2Log));
  FileSystem.deleteDirectory(new File(_node3Log));
  Leader.LeaseDuration.set(10000);
  _node1=new ServerDispatcher(new HowlLogger(_node1Log),Listener.NULL_LISTENER,true);
  _node2=new ServerDispatcher(new HowlLogger(_node2Log),Listener.NULL_LISTENER,true);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87187,"@Test public void post() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  TransportImpl myTransport=new TransportImpl(null);
  myClient.init(myTransport);
  FDUtil.ensureFD(_tport1.getFD());
  FDUtil.ensureFD(_tport2.getFD());
  System.err.println(""String_Node_Str"");
  for (int i=0; i < 5; i++) {
    ByteBuffer myBuffer=ByteBuffer.allocate(4);
    myBuffer.putInt(i);
    Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
    myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
    VoteOutcome myEv=myClient.getNext(10000);
    Assert.assertFalse((myEv == null));
    Assert.assertTrue(myEv.getResult() == VoteOutcome.Reason.VALUE);
    Assert.assertTrue(myEv.getSeqNum() == i);
  }
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  _node3=new ServerDispatcher(new HowlLogger(_node3Log),true);
  _tport3=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node3.init(_tport3);
  _node3.getAcceptorLearner().setRecoveryGracePeriod(1000);
  FDUtil.ensureFD(_tport3.getFD());
  System.err.println(""String_Node_Str"");
  Thread.sleep(Leader.LeaseDuration.get() + 1000);
  ByteBuffer myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(67);
  Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
  myClient.send(new Envelope(myProp),_tport3.getLocalAddress());
  VoteOutcome myMsg=myClient.getNext(10000);
  Assert.assertEquals(VoteOutcome.Reason.OTHER_LEADER,myMsg.getResult());
  myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(69);
  Proposal myProp2=new Proposal(""String_Node_Str"",myBuffer.array());
  System.err.println(""String_Node_Str"");
  myClient.send(new Envelope(myProp2),_tport3.getLocalAddress());
  myMsg=myClient.getNext(10000);
  Assert.assertTrue((VoteOutcome.Reason.VALUE == myMsg.getResult()) || (VoteOutcome.Reason.VOTE_TIMEOUT == myMsg.getResult()));
  System.err.println(""String_Node_Str"");
  Thread.sleep(10000);
  Assert.assertEquals(""String_Node_Str"",_node2.getAcceptorLearner().getLowWatermark().getSeqNum(),_node3.getAcceptorLearner().getLowWatermark().getSeqNum());
  System.err.println(""String_Node_Str"");
  myTransport.terminate();
}","@Test public void post() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  TransportImpl myTransport=new TransportImpl(null);
  myClient.init(myTransport);
  FDUtil.ensureFD(_tport1.getFD());
  FDUtil.ensureFD(_tport2.getFD());
  System.err.println(""String_Node_Str"");
  for (int i=0; i < 5; i++) {
    ByteBuffer myBuffer=ByteBuffer.allocate(4);
    myBuffer.putInt(i);
    Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
    myClient.send(new Envelope(myProp),_tport2.getLocalAddress());
    VoteOutcome myEv=myClient.getNext(10000);
    Assert.assertFalse((myEv == null));
    Assert.assertTrue(myEv.getResult() == VoteOutcome.Reason.VALUE);
    Assert.assertTrue(myEv.getSeqNum() == i);
  }
  Thread.sleep(5000);
  System.err.println(""String_Node_Str"");
  _node3=new ServerDispatcher(new HowlLogger(_node3Log),Listener.NULL_LISTENER,true);
  _tport3=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node3.init(_tport3);
  _node3.getAcceptorLearner().setRecoveryGracePeriod(1000);
  FDUtil.ensureFD(_tport3.getFD());
  System.err.println(""String_Node_Str"");
  Thread.sleep(Leader.LeaseDuration.get() + 1000);
  ByteBuffer myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(67);
  Proposal myProp=new Proposal(""String_Node_Str"",myBuffer.array());
  myClient.send(new Envelope(myProp),_tport3.getLocalAddress());
  VoteOutcome myMsg=myClient.getNext(10000);
  Assert.assertEquals(VoteOutcome.Reason.OTHER_LEADER,myMsg.getResult());
  myBuffer=ByteBuffer.allocate(4);
  myBuffer.putInt(69);
  Proposal myProp2=new Proposal(""String_Node_Str"",myBuffer.array());
  System.err.println(""String_Node_Str"");
  myClient.send(new Envelope(myProp2),_tport3.getLocalAddress());
  myMsg=myClient.getNext(10000);
  Assert.assertTrue((VoteOutcome.Reason.VALUE == myMsg.getResult()) || (VoteOutcome.Reason.VOTE_TIMEOUT == myMsg.getResult()));
  System.err.println(""String_Node_Str"");
  Thread.sleep(10000);
  Assert.assertEquals(""String_Node_Str"",_node2.getAcceptorLearner().getLowWatermark().getSeqNum(),_node3.getAcceptorLearner().getLowWatermark().getSeqNum());
  System.err.println(""String_Node_Str"");
  myTransport.terminate();
}"
87188,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new DroppingTransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new DroppingTransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87189,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _fd1=new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN);
  _tport1=new TransportImpl(_fd1);
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _fd1=new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN);
  _tport1=new TransportImpl(_fd1);
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87190,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87191,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87192,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node2.init(_tport2);
}"
87193,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _tport2.filterRx(new Dropping());
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _tport2.filterRx(new Dropping());
  _node2.init(_tport2);
}"
87194,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _node2=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _tport2.filterRx(new Dropping());
  _node2.init(_tport2);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _node2=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
  _tport2=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _tport2.filterRx(new Dropping());
  _node2.init(_tport2);
}"
87195,"@Before public void init() throws Exception {
  _node1=new ServerDispatcher();
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
}","@Before public void init() throws Exception {
  _node1=new ServerDispatcher(Listener.NULL_LISTENER);
  _tport1=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN));
  _node1.init(_tport1);
}"
87196,"@Test public void pin() throws Exception {
  _tport1.getFD().pin(FailureDetectorImpl.OPEN_PIN);
  _tport2.getFD().pin(FailureDetectorImpl.OPEN_PIN);
  FDUtil.ensureFD(_tport1.getFD());
  FDUtil.ensureFD(_tport2.getFD());
  Assert.assertTrue(_tport1.getFD().getMembers().getMembers().size() == 2);
  Assert.assertTrue(_tport2.getFD().getMembers().getMembers().size() == 2);
  Collection<InetSocketAddress> myMembers=_tport1.getFD().getMembers().getMembers().keySet();
  _tport1.getFD().pin(myMembers);
  _tport2.getFD().pin(myMembers);
  TransportImpl myTport=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN),""String_Node_Str"".getBytes());
  myTport.getFD().pin(FailureDetectorImpl.OPEN_PIN);
  Assembly myAssembly=myTport.getFD().barrier(3).get(10000,TimeUnit.MILLISECONDS);
  Assert.assertNotNull(myAssembly);
  Assert.assertTrue(_tport1.getFD().getMembers().getMembers().size() == 2);
  Assert.assertTrue(_tport2.getFD().getMembers().getMembers().size() == 2);
  Assert.assertFalse(_tport1.getFD().getMembers().getMembers().containsValue(""String_Node_Str""));
  Assert.assertFalse(_tport2.getFD().getMembers().getMembers().containsValue(""String_Node_Str""));
  myTport.terminate();
}","@Test public void pin() throws Exception {
  _tport1.getFD().pin(FailureDetectorImpl.OPEN_PIN);
  _tport2.getFD().pin(FailureDetectorImpl.OPEN_PIN);
  FDUtil.ensureFD(_tport1.getFD());
  FDUtil.ensureFD(_tport2.getFD());
  Assert.assertTrue(_tport1.getFD().getMembers().getMembers().size() == 2);
  Assert.assertTrue(_tport2.getFD().getMembers().getMembers().size() == 2);
  Collection<InetSocketAddress> myMembers=_tport1.getFD().getMembers().getMembers().keySet();
  _tport1.getFD().pin(myMembers);
  _tport2.getFD().pin(myMembers);
  TransportImpl myTport=new TransportImpl(new FailureDetectorImpl(5000,FailureDetectorImpl.OPEN_PIN),""String_Node_Str"".getBytes());
  myTport.getFD().pin(FailureDetectorImpl.OPEN_PIN);
  Assembly myAssembly=myTport.getFD().barrier(3).get(10000,TimeUnit.MILLISECONDS);
  Assert.assertNotNull(myAssembly);
  Assert.assertTrue(_tport1.getFD().getMembers().getMembers().size() == 2);
  Assert.assertTrue(_tport2.getFD().getMembers().getMembers().size() == 2);
  for (  FailureDetector.MetaData c : _tport1.getFD().getMembers().getMembers().values()) {
    System.err.println(""String_Node_Str"" + new String(c.getData()));
  }
  Assert.assertFalse(_tport1.getFD().getMembers().getMembers().values().stream().map(m -> new String(m.getData())).collect(Collectors.toSet()).contains(""String_Node_Str""));
  Assert.assertFalse(_tport2.getFD().getMembers().getMembers().values().stream().map(m -> new String(m.getData())).collect(Collectors.toSet()).contains(""String_Node_Str""));
  myTport.terminate();
}"
87197,"Instance nextInstance(long aPause){
  long myExpiry=(aPause == 0) ? Long.MAX_VALUE : System.currentTimeMillis() + aPause;
synchronized (_inflight) {
    if (!_amLeader) {
      while (_inflight.size() > 0) {
        long myPause=myExpiry - System.currentTimeMillis();
        if (myPause < 1)         return null;
        try {
          _inflight.wait(myPause);
        }
 catch (        InterruptedException anIE) {
        }
      }
      for (      Listener anL : _listeners)       anL.inFlight();
      return new NextInstance((_amLeader) ? Leader.State.BEGIN : Leader.State.COLLECT,chooseNext(),_nextRnd);
    }
 else {
      while (_inflight.size() >= _maxInflight) {
        long myPause=myExpiry - System.currentTimeMillis();
        if (myPause < 1)         return null;
        try {
          _inflight.wait(myPause);
        }
 catch (        InterruptedException anIE) {
        }
      }
      if (_inflight.size() == 1)       for (      Listener anL : _listeners)       anL.inFlight();
      return new NextInstance((_amLeader) ? Leader.State.BEGIN : Leader.State.COLLECT,chooseNext(),_nextRnd);
    }
  }
}","Instance nextInstance(long aPause){
  long myExpiry=(aPause == 0) ? Long.MAX_VALUE : System.currentTimeMillis() + aPause;
synchronized (_inflight) {
    if (!_amLeader) {
      while (_inflight.size() > 0) {
        long myPause=myExpiry - System.currentTimeMillis();
        if (myPause < 1)         return null;
        try {
          _inflight.wait(myPause);
        }
 catch (        InterruptedException anIE) {
        }
      }
      for (      Listener anL : _listeners)       anL.inFlight();
      return new NextInstance((_amLeader) ? Leader.State.BEGIN : Leader.State.COLLECT,chooseNext(),_nextRnd);
    }
 else {
      while (_inflight.size() >= _maxInflight) {
        long myPause=myExpiry - System.currentTimeMillis();
        if (myPause < 1)         return null;
        try {
          _inflight.wait(myPause);
        }
 catch (        InterruptedException anIE) {
        }
      }
      NextInstance myNext=new NextInstance((_amLeader) ? Leader.State.BEGIN : Leader.State.COLLECT,chooseNext(),_nextRnd);
      if (_inflight.size() == 1)       for (      Listener anL : _listeners)       anL.inFlight();
      return myNext;
    }
  }
}"
87198,"/** 
 * @param aTimeout the time in milliseconds to wait for the outcome of a negative number indicating no wait
 */
public VoteOutcome getNext(long aTimeout){
synchronized (this) {
    while (_queue.isEmpty()) {
      try {
        if (aTimeout >= 0)         wait(aTimeout);
 else         return null;
      }
 catch (      InterruptedException anIE) {
      }
    }
    return _queue.remove(0);
  }
}","/** 
 * @param aTimeout the time in milliseconds to wait for the outcome of a negative number indicating no wait
 */
public VoteOutcome getNext(long aTimeout){
  long myStartTime=System.currentTimeMillis();
synchronized (this) {
    while (_queue.isEmpty()) {
      try {
        long myCurrent=System.currentTimeMillis();
        if ((aTimeout >= 0) && (myCurrent < myStartTime + aTimeout)) {
          wait(myStartTime + aTimeout - myCurrent);
        }
 else {
          return null;
        }
      }
 catch (      InterruptedException anIE) {
      }
    }
    return _queue.remove(0);
  }
}"
87199,"public OrderedMemoryNetwork.OrderedMemoryTransport newTransport(InetSocketAddress aLocalAddr,InetSocketAddress aBroadcastAddr,OrderedMemoryNetwork aNetwork,MessageBasedFailureDetector anFD,Object aContext){
  NodeAdminImpl myTp=new NodeAdminImpl(aLocalAddr,aBroadcastAddr,aNetwork,anFD,(NodeAdminImpl.Config)aContext,EnvironmentImpl.this);
  _nodes.add(myTp);
  return myTp.getTransport();
}","public Constructed newTransport(InetSocketAddress aLocalAddr,InetSocketAddress aBroadcastAddr,OrderedMemoryNetwork aNetwork,MessageBasedFailureDetector anFD,Object aContext){
  NodeAdminImpl myNode=new NodeAdminImpl(aLocalAddr,aBroadcastAddr,aNetwork,anFD,(NodeAdminImpl.Config)aContext,EnvironmentImpl.this);
  return new Constructed(myNode.getTransport(),myNode);
}"
87200,"EnvironmentImpl(long aSeed,long aCycles,boolean doCalibrate,long aCkptCycle,boolean inMemory) throws Exception {
  _ckptCycle=aCkptCycle;
  _isLive=!doCalibrate;
  _maxCycles=aCycles;
  _baseRng=new Random(aSeed);
  _factory=new OrderedMemoryNetwork();
  _isStorage=!inMemory;
  _decisionMaker=(_isLive) ? new RandomFailureDecider(this) : new PassiveDecider();
  _nodeFactory=new OrderedMemoryNetwork.Factory(){
    public OrderedMemoryNetwork.OrderedMemoryTransport newTransport(    InetSocketAddress aLocalAddr,    InetSocketAddress aBroadcastAddr,    OrderedMemoryNetwork aNetwork,    MessageBasedFailureDetector anFD,    Object aContext){
      NodeAdminImpl myTp=new NodeAdminImpl(aLocalAddr,aBroadcastAddr,aNetwork,anFD,(NodeAdminImpl.Config)aContext,EnvironmentImpl.this);
      _nodes.add(myTp);
      return myTp.getTransport();
    }
  }
;
  for (int i=0; i < 5; i++) {
    LogStorageFactory myFactory=(_isStorage) ? new HowlLoggerFactory(BASEDIR,i) : new MemoryLoggerFactory();
    addNodeAdmin(Utils.getTestAddress(),new NodeAdminImpl.Config(i,myFactory));
  }
  _currentLeader=_nodes.getFirst();
}","EnvironmentImpl(long aSeed,long aCycles,boolean doCalibrate,long aCkptCycle,boolean inMemory) throws Exception {
  _ckptCycle=aCkptCycle;
  _isLive=!doCalibrate;
  _maxCycles=aCycles;
  _baseRng=new Random(aSeed);
  _factory=new OrderedMemoryNetwork();
  _isStorage=!inMemory;
  _decisionMaker=(_isLive) ? new RandomFailureDecider(this) : new PassiveDecider();
  _nodeFactory=new OrderedMemoryNetwork.Factory(){
    public Constructed newTransport(    InetSocketAddress aLocalAddr,    InetSocketAddress aBroadcastAddr,    OrderedMemoryNetwork aNetwork,    MessageBasedFailureDetector anFD,    Object aContext){
      NodeAdminImpl myNode=new NodeAdminImpl(aLocalAddr,aBroadcastAddr,aNetwork,anFD,(NodeAdminImpl.Config)aContext,EnvironmentImpl.this);
      return new Constructed(myNode.getTransport(),myNode);
    }
  }
;
  Deque<NodeAdmin> myNodes=new LinkedList<>();
  for (int i=0; i < 5; i++) {
    LogStorageFactory myFactory=(_isStorage) ? new HowlLoggerFactory(BASEDIR,i) : new MemoryLoggerFactory();
    OrderedMemoryNetwork.Factory.Constructed myResult=addNodeAdmin(Utils.getTestAddress(),new NodeAdminImpl.Config(i,myFactory));
    myNodes.add((NodeAdmin)myResult.getAdditional());
  }
  _currentLeader=myNodes.getFirst();
  _nodes.addAll(myNodes);
}"
87201,"private void run() throws Exception {
  long myProgressTarget=(long)(getSettleCycles() * 0.75);
  long mySuccesses=0;
  ClientDispatcher myClient=new ClientDispatcher();
  Transport myTransport=_env.getFactory().newTransport(null,null,Utils.getTestAddress(),null);
  myTransport.routeTo(myClient);
  myClient.init(myTransport);
  cycle(myClient,_env.getMaxCycles());
  if (_env.isLive()) {
    _logger.info(""String_Node_Str"");
    _env.settle();
    mySuccesses=cycle(myClient,getSettleCycles());
  }
  myTransport.terminate();
  _env.terminate();
  _logger.info(""String_Node_Str"" + _env.getDropCount());
  _logger.info(""String_Node_Str"" + _env.getRxCount());
  _logger.info(""String_Node_Str"" + _env.getTxCount());
  _logger.info(""String_Node_Str"" + _env.getTempDeathCount());
  if (_env.isLive()) {
    _logger.info(""String_Node_Str"" + myProgressTarget + ""String_Node_Str""+ mySuccesses);
    if (!(mySuccesses > myProgressTarget))     throw new Exception(""String_Node_Str"");
    if (!_env.validate())     throw new IllegalStateException(""String_Node_Str"");
  }
}","private void run() throws Exception {
  long myProgressTarget=(long)(getSettleCycles() * 0.75);
  long mySuccesses=0;
  ClientDispatcher myClient=new ClientDispatcher();
  OrderedMemoryNetwork.Factory.Constructed myResult=_env.getFactory().newTransport(null,null,Utils.getTestAddress(),null);
  myResult.getTransport().routeTo(myClient);
  myClient.init(myResult.getTransport());
  cycle(myClient,_env.getMaxCycles());
  if (_env.isLive()) {
    _logger.info(""String_Node_Str"");
    _env.settle();
    mySuccesses=cycle(myClient,getSettleCycles());
  }
  myResult.getTransport().terminate();
  _env.terminate();
  _logger.info(""String_Node_Str"" + _env.getDropCount());
  _logger.info(""String_Node_Str"" + _env.getRxCount());
  _logger.info(""String_Node_Str"" + _env.getTxCount());
  _logger.info(""String_Node_Str"" + _env.getTempDeathCount());
  if (_env.isLive()) {
    _logger.info(""String_Node_Str"" + myProgressTarget + ""String_Node_Str""+ mySuccesses);
    if (!(mySuccesses > myProgressTarget))     throw new Exception(""String_Node_Str"");
    if (!_env.validate())     throw new IllegalStateException(""String_Node_Str"");
  }
}"
87202,"public void addNodeAdmin(NodeAdmin.Memento aMemento){
  addNodeAdmin(aMemento.getAddress(),(NodeAdminImpl.Config)aMemento.getContext());
}","public void addNodeAdmin(NodeAdmin.Memento aMemento){
  OrderedMemoryNetwork.Factory.Constructed myResult=addNodeAdmin(aMemento.getAddress(),(NodeAdminImpl.Config)aMemento.getContext());
  _nodes.add((NodeAdmin)myResult.getAdditional());
}"
87203,"public Transport newTransport(Factory aFactory,MessageBasedFailureDetector anFD,InetSocketAddress anAddr,Object aContext){
  OrderedMemoryTransport myTrans=(aFactory == null) ? _factory.newTransport(anAddr,_broadcastAddr,this,anFD,aContext) : aFactory.newTransport(anAddr,_broadcastAddr,this,anFD,aContext);
  _transports.put(anAddr,myTrans);
  return myTrans;
}","public Factory.Constructed newTransport(Factory aFactory,MessageBasedFailureDetector anFD,InetSocketAddress anAddr,Object aContext){
  Factory.Constructed myResult=(aFactory == null) ? _factory.newTransport(anAddr,_broadcastAddr,this,anFD,aContext) : aFactory.newTransport(anAddr,_broadcastAddr,this,anFD,aContext);
  _transports.put(anAddr,myResult.getTransport());
  return myResult;
}"
87204,"private void expired(){
synchronized (this) {
    _logger.debug(toString() + ""String_Node_Str"");
switch (_stateMachine.getCurrentState()) {
case SUCCESS:
{
        ++_tries;
        if (_tries < MAX_TRIES) {
          cancelInteraction();
          process(_messages);
          _messages.clear();
        }
 else {
          error(VoteOutcome.Reason.VOTE_TIMEOUT);
        }
        break;
      }
case EXIT:
case ABORT:
case SHUTDOWN:
{
      break;
    }
default :
{
    error(VoteOutcome.Reason.VOTE_TIMEOUT);
    break;
  }
}
}
}","private void expired(){
synchronized (this) {
    _logger.debug(toString() + ""String_Node_Str"");
switch (_stateMachine.getCurrentState()) {
case SUCCESS:
{
        ++_tries;
        if (_tries < MAX_TRIES) {
          cancelInteraction();
          process(_messages.values());
          _messages.clear();
        }
 else {
          error(VoteOutcome.Reason.VOTE_TIMEOUT);
        }
        break;
      }
case EXIT:
case ABORT:
case SHUTDOWN:
{
      break;
    }
default :
{
    error(VoteOutcome.Reason.VOTE_TIMEOUT);
    break;
  }
}
}
}"
87205,"/** 
 * Do actions for the state we are now in.  Essentially, we're always one state ahead of the participants thus we process the result of a Collect in the BEGIN state which means we expect Last or OldRound and in LEARNED state we expect ACCEPT or OLDROUND
 */
private void process(List<Transport.Packet> aMessages){
switch (_stateMachine.getCurrentState()) {
case SHUTDOWN:
{
      _logger.debug(toString() + ""String_Node_Str"");
      if (_interactionAlarm != null)       cancelInteraction();
      return;
    }
case ABORT:
{
    _logger.debug(toString() + ""String_Node_Str"" + _outcomes);
    if (_interactionAlarm != null)     cancelInteraction();
    reportOutcome();
    return;
  }
case EXIT:
{
  _logger.debug(toString() + ""String_Node_Str"" + _outcomes);
  reportOutcome();
  return;
}
case SUBMITTED:
{
if (!_membership.couldComplete()) {
  error(VoteOutcome.Reason.BAD_MEMBERSHIP);
}
 else if (!_common.amMember()) {
  error(VoteOutcome.Reason.NOT_MEMBER);
}
 else {
  _stateMachine.transition(_startState);
  process(NO_MESSAGES);
}
break;
}
case COLLECT:
{
emit(new Collect(_seqNum,_rndNumber));
_stateMachine.transition(State.BEGIN);
break;
}
case BEGIN:
{
if (goneBad(aMessages)) return;
Transport.Packet myLast=null;
for (Transport.Packet p : aMessages) {
Last myNewLast=(Last)p.getMessage();
if (!myNewLast.getConsolidatedValue().equals(Proposal.NO_VALUE)) {
if (myLast == null) myLast=p;
 else if (myNewLast.getRndNumber() > ((Last)myLast.getMessage()).getRndNumber()) {
  myLast=p;
}
}
}
if ((myLast != null) && (!((Last)myLast.getMessage()).getConsolidatedValue().equals(_prop))) {
VoteOutcome myOutcome=new VoteOutcome(VoteOutcome.Reason.OTHER_VALUE,_seqNum,_rndNumber,_prop,myLast.getSource());
_outcomes.add(myOutcome);
_prop=((Last)myLast.getMessage()).getConsolidatedValue();
}
emit(new Begin(_seqNum,_rndNumber,_prop));
_stateMachine.transition(State.SUCCESS);
break;
}
case SUCCESS:
{
if (goneBad(aMessages)) return;
if (aMessages.size() >= _common.getTransport().getFD().getMajority()) {
successful(VoteOutcome.Reason.VALUE);
}
 else {
emit(new Begin(_seqNum,_rndNumber,_prop));
}
break;
}
default :
throw new Error(""String_Node_Str"" + _stateMachine.getCurrentState());
}
}","/** 
 * Do actions for the state we are now in.  Essentially, we're always one state ahead of the participants thus we process the result of a Collect in the BEGIN state which means we expect Last or OldRound and in LEARNED state we expect ACCEPT or OLDROUND
 */
private void process(Collection<Transport.Packet> aMessages){
switch (_stateMachine.getCurrentState()) {
case SHUTDOWN:
{
      _logger.debug(toString() + ""String_Node_Str"");
      if (_interactionAlarm != null)       cancelInteraction();
      return;
    }
case ABORT:
{
    _logger.debug(toString() + ""String_Node_Str"" + _outcomes);
    if (_interactionAlarm != null)     cancelInteraction();
    reportOutcome();
    return;
  }
case EXIT:
{
  _logger.debug(toString() + ""String_Node_Str"" + _outcomes);
  reportOutcome();
  return;
}
case SUBMITTED:
{
if (!_membership.couldComplete()) {
  error(VoteOutcome.Reason.BAD_MEMBERSHIP);
}
 else if (!_common.amMember()) {
  error(VoteOutcome.Reason.NOT_MEMBER);
}
 else {
  _stateMachine.transition(_startState);
  process(NO_MESSAGES);
}
break;
}
case COLLECT:
{
emit(new Collect(_seqNum,_rndNumber));
_stateMachine.transition(State.BEGIN);
break;
}
case BEGIN:
{
if (goneBad(aMessages)) return;
Transport.Packet myLast=null;
for (Transport.Packet p : aMessages) {
Last myNewLast=(Last)p.getMessage();
if (!myNewLast.getConsolidatedValue().equals(Proposal.NO_VALUE)) {
if (myLast == null) myLast=p;
 else if (myNewLast.getRndNumber() > ((Last)myLast.getMessage()).getRndNumber()) {
  myLast=p;
}
}
}
if ((myLast != null) && (!((Last)myLast.getMessage()).getConsolidatedValue().equals(_prop))) {
VoteOutcome myOutcome=new VoteOutcome(VoteOutcome.Reason.OTHER_VALUE,_seqNum,_rndNumber,_prop,myLast.getSource());
_outcomes.add(myOutcome);
_prop=((Last)myLast.getMessage()).getConsolidatedValue();
}
emit(new Begin(_seqNum,_rndNumber,_prop));
_stateMachine.transition(State.SUCCESS);
break;
}
case SUCCESS:
{
if (goneBad(aMessages)) return;
if (aMessages.size() >= _common.getTransport().getFD().getMajority()) {
successful(VoteOutcome.Reason.VALUE);
}
 else {
emit(new Begin(_seqNum,_rndNumber,_prop));
}
break;
}
default :
throw new Error(""String_Node_Str"" + _stateMachine.getCurrentState());
}
}"
87206,"private boolean goneBad(List<Transport.Packet> aMessages){
  OldRound myOld=null;
  for (  Transport.Packet aPacket : aMessages) {
    PaxosMessage myMessage=aPacket.getMessage();
    if (myMessage.getType() == PaxosMessage.Types.OLDROUND) {
      OldRound myTempOld=(OldRound)myMessage;
      if ((myOld == null) || (myTempOld.getLastRound() > myOld.getLastRound()))       myOld=myTempOld;
    }
  }
  if (myOld != null) {
    oldRound(myOld);
    return true;
  }
 else   return false;
}","private boolean goneBad(Collection<Transport.Packet> aMessages){
  OldRound myOld=null;
  for (  Transport.Packet aPacket : aMessages) {
    PaxosMessage myMessage=aPacket.getMessage();
    if (myMessage.getType() == PaxosMessage.Types.OLDROUND) {
      OldRound myTempOld=(OldRound)myMessage;
      if ((myOld == null) || (myTempOld.getLastRound() > myOld.getLastRound()))       myOld=myTempOld;
    }
  }
  if (myOld != null) {
    oldRound(myOld);
    return true;
  }
 else   return false;
}"
87207,"/** 
 * @return number of successful cycles in the run
 */
private long cycle(ClientDispatcher aClient,long aCycles){
  long mySuccessCount=0;
  while (_env.getDoneOps() < aCycles) {
    ByteBuffer myBuffer=ByteBuffer.allocate(8);
    myBuffer.putLong(_env.getDoneOps());
    Proposal myProposal=new Proposal(""String_Node_Str"",myBuffer.array());
    aClient.send(new Envelope(myProposal),_env.getCurrentLeader().getTransport().getLocalAddress());
    VoteOutcome myEv=aClient.getNext(10000);
    if (myEv.getResult() == VoteOutcome.Reason.OTHER_LEADER) {
      _env.updateLeader(myEv.getLeader());
    }
 else     if (myEv.getResult() == VoteOutcome.Reason.VALUE) {
      mySuccessCount++;
    }
    _env.doneOp();
  }
  return mySuccessCount;
}","/** 
 * @return number of successful cycles in the run
 */
private long cycle(ClientDispatcher aClient,long aCycles){
  long mySuccessCount=0;
  long myEndCycles=_env.getDoneOps() + aCycles;
  while (_env.getDoneOps() < myEndCycles) {
    ByteBuffer myBuffer=ByteBuffer.allocate(8);
    myBuffer.putLong(_env.getDoneOps());
    Proposal myProposal=new Proposal(""String_Node_Str"",myBuffer.array());
    aClient.send(new Envelope(myProposal),_env.getCurrentLeader().getTransport().getLocalAddress());
    VoteOutcome myEv=aClient.getNext(10000);
    if (myEv.getResult() == VoteOutcome.Reason.OTHER_LEADER) {
      _env.updateLeader(myEv.getLeader());
    }
 else     if (myEv.getResult() == VoteOutcome.Reason.VALUE) {
      mySuccessCount++;
    }
    _env.doneOp();
  }
  return mySuccessCount;
}"
87208,"/** 
 * Examine a received   {@link PaxosMessage} and update liveness information as appropriate.
 */
public void processMessage(Packet aPacket){
  PaxosMessage myMessage=aPacket.getMessage();
  if (myMessage.getType() == Operations.HEARTBEAT) {
    MetaDataImpl myLast;
    final Heartbeat myHeartbeat=(Heartbeat)myMessage;
    final InetSocketAddress myNodeId=aPacket.getSource();
    if ((_pinned != null) && (!_pinned.contains(myNodeId)))     return;
    for (; ; ) {
      myLast=_lastHeartbeats.get(myNodeId);
      if (myLast == null) {
        if (_lastHeartbeats.putIfAbsent(myNodeId,new MetaDataImpl(System.currentTimeMillis(),myHeartbeat.getMetaData())) == null)         break;
      }
 else {
        if (_lastHeartbeats.replace(myNodeId,myLast,new MetaDataImpl(System.currentTimeMillis(),myHeartbeat.getMetaData())))         break;
      }
    }
    if (_futures.size() != 0) {
      Membership myMembership=new MembershipImpl(new HashMap<InetSocketAddress,MetaData>(_lastHeartbeats));
      Iterator<FutureImpl> myFutures=_futures.iterator();
      while (myFutures.hasNext()) {
        FutureImpl myFuture=myFutures.next();
        myFuture.offer(myMembership);
      }
    }
  }
}","/** 
 * Examine a received   {@link PaxosMessage} and update liveness information as appropriate.
 */
public void processMessage(Packet aPacket){
  PaxosMessage myMessage=aPacket.getMessage();
  if (myMessage.getType() == Operations.HEARTBEAT) {
    MetaDataImpl myLast;
    final Heartbeat myHeartbeat=(Heartbeat)myMessage;
    final InetSocketAddress myNodeId=aPacket.getSource();
    if ((_pinned == null) || ((_pinned != null) && (!_pinned.contains(myNodeId))))     return;
    for (; ; ) {
      myLast=_lastHeartbeats.get(myNodeId);
      if (myLast == null) {
        if (_lastHeartbeats.putIfAbsent(myNodeId,new MetaDataImpl(System.currentTimeMillis(),myHeartbeat.getMetaData())) == null)         break;
      }
 else {
        if (_lastHeartbeats.replace(myNodeId,myLast,new MetaDataImpl(System.currentTimeMillis(),myHeartbeat.getMetaData())))         break;
      }
    }
    if (_futures.size() != 0) {
      Membership myMembership=new MembershipImpl(new HashMap<InetSocketAddress,MetaData>(_lastHeartbeats));
      Iterator<FutureImpl> myFutures=_futures.iterator();
      while (myFutures.hasNext()) {
        FutureImpl myFuture=myFutures.next();
        myFuture.offer(myMembership);
      }
    }
  }
}"
87209,"public static void main(String[] anArgs) throws Exception {
  Args myArgs=CliFactory.parseArguments(Args.class,anArgs);
  LongTerm myLT=new LongTerm(myArgs.getSeed(),myArgs.getCycles(),myArgs.isCalibrate(),myArgs.getCkptCycle());
  long myStart=System.currentTimeMillis();
  myLT.run();
  double myDuration=(System.currentTimeMillis() - myStart) / 1000.0;
  if (myArgs.isCalibrate()) {
    System.out.println(""String_Node_Str"" + myArgs.getCycles() + ""String_Node_Str""+ myDuration+ ""String_Node_Str"");
    double myOpsPerSec=myDuration / myArgs.getCycles();
    double myOpsHour=myOpsPerSec * 60 * 60;
    System.out.println(""String_Node_Str"" + myOpsPerSec + ""String_Node_Str""+ myOpsHour);
  }
 else {
    System.out.println(""String_Node_Str"" + (myArgs.getCycles() + myLT.getSettleCycles()) + ""String_Node_Str""+ myDuration+ ""String_Node_Str"");
  }
}","public static void main(String[] anArgs) throws Exception {
  Args myArgs=CliFactory.parseArguments(Args.class,anArgs);
  LongTerm myLT=new LongTerm(myArgs.getSeed(),myArgs.getCycles(),myArgs.isCalibrate(),myArgs.getCkptCycle());
  long myStart=System.currentTimeMillis();
  myLT.run();
  double myDuration=(System.currentTimeMillis() - myStart) / 1000.0;
  if (myArgs.isCalibrate()) {
    System.out.println(""String_Node_Str"" + myArgs.getCycles() + ""String_Node_Str""+ myDuration+ ""String_Node_Str"");
    double myOpsPerSec=myArgs.getCycles() / myDuration;
    double myOpsHour=myOpsPerSec * 60 * 60;
    System.out.println(""String_Node_Str"" + myOpsPerSec + ""String_Node_Str""+ myOpsHour);
  }
 else {
    System.out.println(""String_Node_Str"" + (myArgs.getCycles() + myLT.getSettleCycles()) + ""String_Node_Str""+ myDuration+ ""String_Node_Str"");
  }
}"
87210,"public void processMessage(Transport.Packet aPacket){
  if (guard())   return;
  try {
    if (_common.getNodeState().test(NodeState.State.OUT_OF_DATE)) {
      return;
    }
    PaxosMessage myMessage=aPacket.getMessage();
    long mySeqNum=myMessage.getSeqNum();
    if (_common.getNodeState().test(NodeState.State.RECOVERING)) {
switch (myMessage.getType()) {
case Operations.NEED:
{
          _logger.debug(""String_Node_Str"" + aPacket);
          process(aPacket,new ReplayWriter(0),new LiveSender());
          return;
        }
case Operations.OUTOFDATE:
{
synchronized (this) {
          completedRecovery();
          _common.getNodeState().set(NodeState.State.OUT_OF_DATE);
        }
        signal(new StateEvent(StateEvent.Reason.OUT_OF_DATE,mySeqNum,_common.getLeaderRndNum(),new Proposal(),aPacket.getSource()));
        return;
      }
  }
}
final Writer myWriter=new LiveWriter();
int myProcessed;
_sorter.add(aPacket);
do {
  myProcessed=_sorter.process(_common.getLowWatermark().getSeqNum(),new PacketSorter.PacketProcessor(){
    public void consume(    Transport.Packet aPacket){
      boolean myRecoveryInProgress=_common.getNodeState().test(NodeState.State.RECOVERING);
      Sender mySender=((myRecoveryInProgress) || (!_common.amMember())) ? new RecoverySender() : new LiveSender();
      process(aPacket,myWriter,mySender);
      if (myRecoveryInProgress) {
        if ((_common.getLowWatermark().getSeqNum() == _recoveryWindow.get().getMaxSeq()) && (_common.getNodeState().testAndSet(NodeState.State.RECOVERING,NodeState.State.ACTIVE))) {
          _common.resetLeaderAction();
          completedRecovery();
        }
      }
    }
    public boolean recover(    Need aNeed){
      boolean myResult=_common.getNodeState().testAndSet(NodeState.State.ACTIVE,NodeState.State.RECOVERING);
      if (myResult) {
        _recoveryWindow.set(aNeed);
        _cachedBegins.clear();
        _acceptLedgers.clear();
        _logger.debug(AcceptorLearner.this.toString() + ""String_Node_Str"" + Long.toHexString(_common.getLowWatermark().getSeqNum()));
        if (_common.getLastCollect().getMessage().getSeqNum() > aNeed.getMinSeq()) {
          _logger.warn(AcceptorLearner.this.toString() + ""String_Node_Str"" + _common.getLastCollect().getMessage()+ ""String_Node_Str""+ aNeed);
          _common.clearLeadership();
        }
        InetSocketAddress myNeedTarget=_common.getTransport().getFD().getRandomMember(_common.getTransport().getLocalAddress());
        if (myNeedTarget != null)         new LiveSender().send(aNeed,myNeedTarget);
        reschedule();
      }
      return myResult;
    }
  }
);
}
 while (myProcessed != 0);
}
  finally {
unguard();
}
}","public void processMessage(Transport.Packet aPacket){
  if (guard())   return;
  try {
    if (_common.getNodeState().test(NodeState.State.OUT_OF_DATE)) {
      return;
    }
    PaxosMessage myMessage=aPacket.getMessage();
    long mySeqNum=myMessage.getSeqNum();
    if (_common.getNodeState().test(NodeState.State.RECOVERING)) {
switch (myMessage.getType()) {
case Operations.NEED:
{
          _logger.debug(""String_Node_Str"" + aPacket);
          process(aPacket,new ReplayWriter(0),new LiveSender());
          return;
        }
case Operations.OUTOFDATE:
{
synchronized (this) {
          completedRecovery();
          _common.getNodeState().set(NodeState.State.OUT_OF_DATE);
        }
        signal(new StateEvent(StateEvent.Reason.OUT_OF_DATE,mySeqNum,_common.getLeaderRndNum(),new Proposal(),aPacket.getSource()));
        return;
      }
  }
}
final Writer myWriter=new LiveWriter();
int myProcessed;
_sorter.add(aPacket);
do {
  myProcessed=_sorter.process(_common.getLowWatermark().getSeqNum(),new PacketSorter.PacketProcessor(){
    public void consume(    Transport.Packet aPacket){
      boolean myRecoveryInProgress=_common.getNodeState().test(NodeState.State.RECOVERING);
      Sender mySender=((myRecoveryInProgress) || (!_common.amMember())) ? new RecoverySender() : new LiveSender();
      process(aPacket,myWriter,mySender);
      if (myRecoveryInProgress) {
        if ((_common.getLowWatermark().getSeqNum() == _recoveryWindow.get().getMaxSeq()) && (_common.getNodeState().testAndSet(NodeState.State.RECOVERING,NodeState.State.ACTIVE))) {
          _common.resetLeaderAction();
          completedRecovery();
        }
      }
    }
    public boolean recover(    Need aNeed,    InetSocketAddress aSourceAddr){
      boolean myResult=_common.getNodeState().testAndSet(NodeState.State.ACTIVE,NodeState.State.RECOVERING);
      if (myResult) {
        _recoveryWindow.set(aNeed);
        _cachedBegins.clear();
        _acceptLedgers.clear();
        _logger.debug(AcceptorLearner.this.toString() + ""String_Node_Str"" + Long.toHexString(_common.getLowWatermark().getSeqNum()));
        if (_common.getLastCollect().getMessage().getSeqNum() > aNeed.getMinSeq()) {
          _logger.warn(AcceptorLearner.this.toString() + ""String_Node_Str"" + _common.getLastCollect().getMessage()+ ""String_Node_Str""+ aNeed);
          _common.clearLeadership();
        }
        InetSocketAddress myNeedTarget=_common.getTransport().getFD().getRandomMember(_common.getTransport().getLocalAddress());
        if (myNeedTarget != null)         new LiveSender().send(aNeed,myNeedTarget);
 else         new LiveSender().send(aNeed,aSourceAddr);
        reschedule();
      }
      return myResult;
    }
  }
);
}
 while (myProcessed != 0);
}
  finally {
unguard();
}
}"
87211,"public boolean recover(Need aNeed){
  boolean myResult=_common.getNodeState().testAndSet(NodeState.State.ACTIVE,NodeState.State.RECOVERING);
  if (myResult) {
    _recoveryWindow.set(aNeed);
    _cachedBegins.clear();
    _acceptLedgers.clear();
    _logger.debug(AcceptorLearner.this.toString() + ""String_Node_Str"" + Long.toHexString(_common.getLowWatermark().getSeqNum()));
    if (_common.getLastCollect().getMessage().getSeqNum() > aNeed.getMinSeq()) {
      _logger.warn(AcceptorLearner.this.toString() + ""String_Node_Str"" + _common.getLastCollect().getMessage()+ ""String_Node_Str""+ aNeed);
      _common.clearLeadership();
    }
    InetSocketAddress myNeedTarget=_common.getTransport().getFD().getRandomMember(_common.getTransport().getLocalAddress());
    if (myNeedTarget != null)     new LiveSender().send(aNeed,myNeedTarget);
    reschedule();
  }
  return myResult;
}","public boolean recover(Need aNeed,InetSocketAddress aSourceAddr){
  boolean myResult=_common.getNodeState().testAndSet(NodeState.State.ACTIVE,NodeState.State.RECOVERING);
  if (myResult) {
    _recoveryWindow.set(aNeed);
    _cachedBegins.clear();
    _acceptLedgers.clear();
    _logger.debug(AcceptorLearner.this.toString() + ""String_Node_Str"" + Long.toHexString(_common.getLowWatermark().getSeqNum()));
    if (_common.getLastCollect().getMessage().getSeqNum() > aNeed.getMinSeq()) {
      _logger.warn(AcceptorLearner.this.toString() + ""String_Node_Str"" + _common.getLastCollect().getMessage()+ ""String_Node_Str""+ aNeed);
      _common.clearLeadership();
    }
    InetSocketAddress myNeedTarget=_common.getTransport().getFD().getRandomMember(_common.getTransport().getLocalAddress());
    if (myNeedTarget != null)     new LiveSender().send(aNeed,myNeedTarget);
 else     new LiveSender().send(aNeed,aSourceAddr);
    reschedule();
  }
  return myResult;
}"
87212,"/** 
 * @param aLowWatermark the current low watermark - sorter will use this to identify packets that potentiallycould be consumed.
 * @param aProcessor the processor that will be used to process any packets identified as acceptable or performrecovery. Recovery should do an atomic test and set to see if it wins the recovery race and act accordingly.
 * @return the number of packets processed
 */
int process(long aLowWatermark,PacketProcessor aProcessor){
  List<Transport.Packet> myConsumables=new LinkedList<>();
synchronized (this) {
    Iterator<Map.Entry<Long,List<Transport.Packet>>> mySeqsAndPkts=_packets.entrySet().iterator();
    while (mySeqsAndPkts.hasNext()) {
      Map.Entry<Long,List<Transport.Packet>> mySeqAndPkt=mySeqsAndPkts.next();
      if (mySeqAndPkt.getKey() <= (aLowWatermark + 1)) {
        myConsumables.addAll(_packets.get(mySeqAndPkt.getKey()));
        mySeqsAndPkts.remove();
      }
    }
  }
  if ((myConsumables.size() == 0) && (_packets.size() != 0)) {
    SortedSet<Long> myAllSeqs=new TreeSet<>(_packets.keySet());
    Long myLastSeq=myAllSeqs.last();
    if (myLastSeq > (aLowWatermark + MAX_INFLIGHT))     if (aProcessor.recover(new Need(aLowWatermark,myAllSeqs.last() - 1))) {
synchronized (this) {
        List<Transport.Packet> myLastPackets=_packets.get(myLastSeq);
        _packets.clear();
        _packets.put(myLastSeq,myLastPackets);
      }
    }
    return 0;
  }
 else {
    for (    Transport.Packet p : myConsumables)     aProcessor.consume(p);
    return myConsumables.size();
  }
}","/** 
 * @param aLowWatermark the current low watermark - sorter will use this to identify packets that potentiallycould be consumed.
 * @param aProcessor the processor that will be used to process any packets identified as acceptable or performrecovery. Recovery should do an atomic test and set to see if it wins the recovery race and act accordingly.
 * @return the number of packets processed
 */
int process(long aLowWatermark,PacketProcessor aProcessor){
  List<Transport.Packet> myConsumables=new LinkedList<>();
synchronized (this) {
    Iterator<Map.Entry<Long,List<Transport.Packet>>> mySeqsAndPkts=_packets.entrySet().iterator();
    while (mySeqsAndPkts.hasNext()) {
      Map.Entry<Long,List<Transport.Packet>> mySeqAndPkt=mySeqsAndPkts.next();
      if (mySeqAndPkt.getKey() <= (aLowWatermark + 1)) {
        myConsumables.addAll(_packets.get(mySeqAndPkt.getKey()));
        mySeqsAndPkts.remove();
      }
    }
  }
  if ((myConsumables.size() == 0) && (_packets.size() != 0)) {
    SortedSet<Long> myAllSeqs=new TreeSet<>(_packets.keySet());
    Long myLastSeq=myAllSeqs.last();
    if (myLastSeq > (aLowWatermark + MAX_INFLIGHT)) {
      InetSocketAddress myTriggerAddr=_packets.get(myLastSeq).get(0).getSource();
      if (aProcessor.recover(new Need(aLowWatermark,myAllSeqs.last() - 1),myTriggerAddr)) {
synchronized (this) {
          List<Transport.Packet> myLastPackets=_packets.get(myLastSeq);
          _packets.clear();
          _packets.put(myLastSeq,myLastPackets);
        }
      }
    }
    return 0;
  }
 else {
    for (    Transport.Packet p : myConsumables)     aProcessor.consume(p);
    return myConsumables.size();
  }
}"
87213,"/** 
 * @param aNeed
 * @return true if the transition to recovery was successful
 */
boolean recover(Need aNeed);","/** 
 * @param aNeed
 * @param aSourceAddr the node that originated the packet triggering recovery
 * @return true if the transition to recovery was successful
 */
boolean recover(Need aNeed,InetSocketAddress aSourceAddr);"
87214,"public boolean recover(Need aNeed){
  _recoveryRequested=true;
  return _recoveryReturn;
}","public boolean recover(Need aNeed,InetSocketAddress aTriggeringSource){
  _recoveryRequested=true;
  return _recoveryReturn;
}"
87215,"public void change(FailureDetector aDetector,FailureDetector.State aState){
  if (aState.equals(FailureDetector.State.PINNED)) {
    _logger.debug(""String_Node_Str"");
    _hb=_fd.newHeartbeater(TransportImpl.this,_meta);
    _hb.start();
  }
}","public void change(FailureDetector aDetector,FailureDetector.State aState){
  if ((aState.equals(FailureDetector.State.PINNED)) && (_hb == null)) {
    _logger.debug(""String_Node_Str"");
    _hb=_fd.newHeartbeater(TransportImpl.this,_meta);
    _hb.start();
  }
}"
87216,"public void run(){
  while (!isStopping()) {
    _transport.send(_transport.getPickler().newPacket(new Heartbeat(_metaData)),_transport.getBroadcastAddress());
    try {
      Thread.sleep(_pulseRate);
    }
 catch (    InterruptedException e) {
    }
  }
}","public void run(){
  while (!isStopping()) {
    try {
      _transport.send(_transport.getPickler().newPacket(new Heartbeat(_metaData)),_transport.getBroadcastAddress());
    }
 catch (    Throwable aT) {
    }
    try {
      Thread.sleep(_pulseRate);
    }
 catch (    InterruptedException e) {
    }
  }
}"
87217,"/** 
 * Return a random member that the FD believes is live, excluding the local address specified
 * @param aLocal the address of the node to exclude from the result
 */
public InetSocketAddress getRandomMember(InetSocketAddress aLocal);","/** 
 * @param aLocal the address of the node to exclude from the result
 * @return a random member that the FD believes is live, excluding the local address specified or <code>null</code>if there are no suitable candidates.
 */
public InetSocketAddress getRandomMember(InetSocketAddress aLocal);"
87218,"public void processMessage(Transport.Packet aPacket){
  if (guard())   return;
  try {
    if (_common.testState(Constants.FSMStates.OUT_OF_DATE)) {
      return;
    }
    PaxosMessage myMessage=aPacket.getMessage();
    long mySeqNum=myMessage.getSeqNum();
    if (_common.testState(Constants.FSMStates.RECOVERING)) {
switch (myMessage.getType()) {
case Operations.NEED:
{
          _logger.debug(""String_Node_Str"" + aPacket);
          process(aPacket,new ReplayWriter(0),new LiveSender());
          return;
        }
case Operations.OUTOFDATE:
{
synchronized (this) {
          completedRecovery();
          _common.setState(Constants.FSMStates.OUT_OF_DATE);
        }
        signal(new StateEvent(StateEvent.Reason.OUT_OF_DATE,mySeqNum,_common.getLeaderRndNum(),new Proposal(),aPacket.getSource()));
        return;
      }
  }
}
final Writer myWriter=new LiveWriter();
int myProcessed;
_sorter.add(aPacket);
do {
  myProcessed=_sorter.process(_common.getLowWatermark().getSeqNum(),new PacketSorter.PacketProcessor(){
    public void consume(    Transport.Packet aPacket){
      boolean myRecoveryInProgress=_common.testState(Constants.FSMStates.RECOVERING);
      Sender mySender=(myRecoveryInProgress) ? new RecoverySender() : new LiveSender();
      process(aPacket,myWriter,mySender);
      if (myRecoveryInProgress) {
        if ((_common.getLowWatermark().getSeqNum() == _recoveryWindow.get().getMaxSeq()) && (_common.testAndSetState(Constants.FSMStates.RECOVERING,Constants.FSMStates.ACTIVE))) {
          _common.resetLeaderAction();
          completedRecovery();
        }
      }
    }
    public boolean recover(    Need aNeed){
      boolean myResult=_common.testAndSetState(Constants.FSMStates.ACTIVE,Constants.FSMStates.RECOVERING);
      if (myResult) {
        _recoveryWindow.set(aNeed);
        _cachedBegins.clear();
        _acceptLedgers.clear();
        _logger.debug(AcceptorLearner.this.toString() + ""String_Node_Str"" + Long.toHexString(_common.getLowWatermark().getSeqNum()));
        if (_common.getLastCollect().getMessage().getSeqNum() > aNeed.getMinSeq()) {
          _logger.warn(AcceptorLearner.this.toString() + ""String_Node_Str"" + _common.getLastCollect().getMessage()+ ""String_Node_Str""+ aNeed);
          _common.clearLeadership();
        }
        new LiveSender().send(aNeed,_common.getTransport().getFD().getRandomMember(_common.getTransport().getLocalAddress()));
        reschedule();
      }
      return myResult;
    }
  }
);
}
 while (myProcessed != 0);
}
  finally {
unguard();
}
}","public void processMessage(Transport.Packet aPacket){
  if (guard())   return;
  try {
    if (_common.testState(Constants.FSMStates.OUT_OF_DATE)) {
      return;
    }
    PaxosMessage myMessage=aPacket.getMessage();
    long mySeqNum=myMessage.getSeqNum();
    if (_common.testState(Constants.FSMStates.RECOVERING)) {
switch (myMessage.getType()) {
case Operations.NEED:
{
          _logger.debug(""String_Node_Str"" + aPacket);
          process(aPacket,new ReplayWriter(0),new LiveSender());
          return;
        }
case Operations.OUTOFDATE:
{
synchronized (this) {
          completedRecovery();
          _common.setState(Constants.FSMStates.OUT_OF_DATE);
        }
        signal(new StateEvent(StateEvent.Reason.OUT_OF_DATE,mySeqNum,_common.getLeaderRndNum(),new Proposal(),aPacket.getSource()));
        return;
      }
  }
}
final Writer myWriter=new LiveWriter();
int myProcessed;
_sorter.add(aPacket);
do {
  myProcessed=_sorter.process(_common.getLowWatermark().getSeqNum(),new PacketSorter.PacketProcessor(){
    public void consume(    Transport.Packet aPacket){
      boolean myRecoveryInProgress=_common.testState(Constants.FSMStates.RECOVERING);
      Sender mySender=(myRecoveryInProgress) ? new RecoverySender() : new LiveSender();
      process(aPacket,myWriter,mySender);
      if (myRecoveryInProgress) {
        if ((_common.getLowWatermark().getSeqNum() == _recoveryWindow.get().getMaxSeq()) && (_common.testAndSetState(Constants.FSMStates.RECOVERING,Constants.FSMStates.ACTIVE))) {
          _common.resetLeaderAction();
          completedRecovery();
        }
      }
    }
    public boolean recover(    Need aNeed){
      boolean myResult=_common.testAndSetState(Constants.FSMStates.ACTIVE,Constants.FSMStates.RECOVERING);
      if (myResult) {
        _recoveryWindow.set(aNeed);
        _cachedBegins.clear();
        _acceptLedgers.clear();
        _logger.debug(AcceptorLearner.this.toString() + ""String_Node_Str"" + Long.toHexString(_common.getLowWatermark().getSeqNum()));
        if (_common.getLastCollect().getMessage().getSeqNum() > aNeed.getMinSeq()) {
          _logger.warn(AcceptorLearner.this.toString() + ""String_Node_Str"" + _common.getLastCollect().getMessage()+ ""String_Node_Str""+ aNeed);
          _common.clearLeadership();
        }
        InetSocketAddress myNeedTarget=_common.getTransport().getFD().getRandomMember(_common.getTransport().getLocalAddress());
        if (myNeedTarget != null)         new LiveSender().send(aNeed,myNeedTarget);
        reschedule();
      }
      return myResult;
    }
  }
);
}
 while (myProcessed != 0);
}
  finally {
unguard();
}
}"
87219,"public boolean recover(Need aNeed){
  boolean myResult=_common.testAndSetState(Constants.FSMStates.ACTIVE,Constants.FSMStates.RECOVERING);
  if (myResult) {
    _recoveryWindow.set(aNeed);
    _cachedBegins.clear();
    _acceptLedgers.clear();
    _logger.debug(AcceptorLearner.this.toString() + ""String_Node_Str"" + Long.toHexString(_common.getLowWatermark().getSeqNum()));
    if (_common.getLastCollect().getMessage().getSeqNum() > aNeed.getMinSeq()) {
      _logger.warn(AcceptorLearner.this.toString() + ""String_Node_Str"" + _common.getLastCollect().getMessage()+ ""String_Node_Str""+ aNeed);
      _common.clearLeadership();
    }
    new LiveSender().send(aNeed,_common.getTransport().getFD().getRandomMember(_common.getTransport().getLocalAddress()));
    reschedule();
  }
  return myResult;
}","public boolean recover(Need aNeed){
  boolean myResult=_common.testAndSetState(Constants.FSMStates.ACTIVE,Constants.FSMStates.RECOVERING);
  if (myResult) {
    _recoveryWindow.set(aNeed);
    _cachedBegins.clear();
    _acceptLedgers.clear();
    _logger.debug(AcceptorLearner.this.toString() + ""String_Node_Str"" + Long.toHexString(_common.getLowWatermark().getSeqNum()));
    if (_common.getLastCollect().getMessage().getSeqNum() > aNeed.getMinSeq()) {
      _logger.warn(AcceptorLearner.this.toString() + ""String_Node_Str"" + _common.getLastCollect().getMessage()+ ""String_Node_Str""+ aNeed);
      _common.clearLeadership();
    }
    InetSocketAddress myNeedTarget=_common.getTransport().getFD().getRandomMember(_common.getTransport().getLocalAddress());
    if (myNeedTarget != null)     new LiveSender().send(aNeed,myNeedTarget);
    reschedule();
  }
  return myResult;
}"
87220,"public InetSocketAddress getRandomMember(InetSocketAddress aLocalAddress){
  LinkedList<InetSocketAddress> myMembers=new LinkedList<>(_lastHeartbeats.keySet());
  myMembers.remove(aLocalAddress);
  return myMembers.get(_random.nextInt(myMembers.size()));
}","public InetSocketAddress getRandomMember(InetSocketAddress aLocalAddress){
  LinkedList<InetSocketAddress> myMembers=new LinkedList<>(_lastHeartbeats.keySet());
  myMembers.remove(aLocalAddress);
  if (myMembers.size() > 0)   return myMembers.get(_random.nextInt(myMembers.size()));
 else   return null;
}"
87221,"/** 
 * Determines whether a sufficient number of accepts can be tallied against the specified begin.
 * @param aBegin
 * @return A Learned to be logged if there are sufficient accepts, <code>null</code> otherwise.
 */
Learned tally(Begin aBegin,int aMajority){
synchronized (this) {
    int myAcceptTally=0;
    if (_ledger.size() < aMajority)     return null;
    for (    Transport.Packet myAcc : _ledger)     if (((Accept)myAcc.getMessage()).getRndNumber() == aBegin.getRndNumber())     ++myAcceptTally;
    if (myAcceptTally >= aMajority)     return new Learned(aBegin.getSeqNum(),aBegin.getRndNumber());
 else     return null;
  }
}","/** 
 * Determines whether a sufficient number of accepts can be tallied against the specified begin.
 * @param aBegin
 * @return A Learned to be logged if there are sufficient accepts, <code>null</code> otherwise.
 */
Learned tally(Begin aBegin,int aMajority){
synchronized (this) {
    int myAcceptTally=0;
    if (_ledger.size() < aMajority)     return null;
    for (    Transport.Packet myAcc : _ledger)     if (((Accept)myAcc.getMessage()).getRndNumber() == aBegin.getRndNumber())     ++myAcceptTally;
    if (myAcceptTally >= aMajority) {
      _logger.debug(""String_Node_Str"" + _ledger + ""String_Node_Str""+ aMajority);
      return new Learned(aBegin.getSeqNum(),aBegin.getRndNumber());
    }
 else     return null;
  }
}"
87222,"public boolean equals(Object anObject){
  if (anObject instanceof Accept) {
    Accept myOther=(Accept)anObject;
    return (_seqNum == myOther._seqNum) && (_rndNumber == myOther._seqNum);
  }
  return false;
}","public boolean equals(Object anObject){
  if (anObject instanceof Accept) {
    Accept myOther=(Accept)anObject;
    return (_seqNum == myOther._seqNum) && (_rndNumber == myOther._rndNumber);
  }
  return false;
}"
87223,"public boolean equals(Object anObject){
  if (anObject instanceof FakePacket) {
    FakePacket myPacket=(FakePacket)anObject;
    return ((myPacket._address == _address) && (myPacket._message.equals(_message)));
  }
  return false;
}","public boolean equals(Object anObject){
  if (anObject instanceof FakePacket) {
    FakePacket myPacket=(FakePacket)anObject;
    return ((myPacket._address.equals(_address)) && (myPacket._message.equals(_message)));
  }
  return false;
}"
87224,"public boolean equals(Object anObject){
  if (anObject instanceof PacketImpl) {
    PacketImpl myPacket=(PacketImpl)anObject;
    return ((myPacket._source == _source) && (myPacket._msg.equals(_msg)));
  }
  return false;
}","public boolean equals(Object anObject){
  if (anObject instanceof PacketImpl) {
    PacketImpl myPacket=(PacketImpl)anObject;
    return ((myPacket._source.equals(_source)) && (myPacket._msg.equals(_msg)));
  }
  return false;
}"
87225,"public boolean equals(Object anObject){
  if (anObject instanceof FakePacket) {
    FakePacket myPacket=(FakePacket)anObject;
    return ((myPacket._address == _address) && (myPacket._message.equals(_message)));
  }
  return false;
}","public boolean equals(Object anObject){
  if (anObject instanceof FakePacket) {
    FakePacket myPacket=(FakePacket)anObject;
    return ((myPacket._address.equals(_address)) && (myPacket._message.equals(_message)));
  }
  return false;
}"
87226,"public boolean equals(Object anObject){
  if (anObject instanceof PacketImpl) {
    PacketImpl myPacket=(PacketImpl)anObject;
    return ((myPacket._source == _source) && (myPacket._msg.equals(_msg)));
  }
  return false;
}","public boolean equals(Object anObject){
  if (anObject instanceof PacketImpl) {
    PacketImpl myPacket=(PacketImpl)anObject;
    return ((myPacket._source.equals(_source)) && (myPacket._msg.equals(_msg)));
  }
  return false;
}"
87227,"/** 
 * Utility method to manage the lifecycle of creating an accept ledger.
 * @param anAccept
 * @return the newly or previously created ledger for the specified sequence number.
 */
private List<Accept> getAndCreateAcceptLedger(Accept anAccept){
  Long mySeqNum=anAccept.getSeqNum();
  List<Accept> myAccepts=_acceptLedgers.get(mySeqNum);
  if (myAccepts == null) {
    List<Accept> myInitial=new CopyOnWriteArrayList<>();
    List<Accept> myResult=_acceptLedgers.put(mySeqNum,myInitial);
    myAccepts=((myResult == null) ? myInitial : myResult);
  }
  return myAccepts;
}","/** 
 * Utility method to manage the lifecycle of creating an accept ledger.
 * @param anAccept
 * @return the newly or previously created ledger for the specified sequence number.
 */
private Set<Transport.Packet> getAndCreateAcceptLedger(Transport.Packet anAccept){
  Long mySeqNum=anAccept.getMessage().getSeqNum();
  Set<Transport.Packet> myAccepts=_acceptLedgers.get(mySeqNum);
  if (myAccepts == null) {
    Set<Transport.Packet> myInitial=new HashSet<>();
    Set<Transport.Packet> myResult=_acceptLedgers.put(mySeqNum,myInitial);
    myAccepts=((myResult == null) ? myInitial : myResult);
  }
  return myAccepts;
}"
87228,"/** 
 * Remove any accepts in the ledger not appropriate for the passed begin. We must tally only those accepts that match the round and sequence number of this begin. All others should be flushed.
 * @param aBegin
 */
private void purgeAcceptLedger(Begin aBegin){
  List<Accept> myAccepts=_acceptLedgers.get(aBegin.getSeqNum());
  if (myAccepts == null)   return;
  Iterator<Accept> myAccs=myAccepts.iterator();
  while (myAccs.hasNext()) {
    Accept myAcc=myAccs.next();
    if (myAcc.getRndNumber() != aBegin.getRndNumber())     myAccs.remove();
  }
}","/** 
 * Remove any accepts in the ledger not appropriate for the passed begin. We must tally only those accepts that match the round and sequence number of this begin. All others should be flushed.
 * @param aBegin
 */
private void purgeAcceptLedger(Begin aBegin){
  Set<Transport.Packet> myAccepts=_acceptLedgers.get(aBegin.getSeqNum());
  if (myAccepts == null)   return;
  Iterator<Transport.Packet> myAccs=myAccepts.iterator();
  while (myAccs.hasNext()) {
    Transport.Packet myAcc=myAccs.next();
    if (((Accept)myAcc.getMessage()).getRndNumber() != aBegin.getRndNumber())     myAccs.remove();
  }
}"
87229,"/** 
 * Determines whether a sufficient number of accepts can be tallied against the specified begin.
 * @param aBegin
 * @return A Learned packet to be logged if there are sufficient accepts, <code>null</code> otherwise.
 */
private Transport.Packet tallyAccepts(Begin aBegin){
  int myAcceptTally=0;
  List<Accept> myAccepts=_acceptLedgers.get(aBegin.getSeqNum());
  if (myAccepts == null)   return null;
  for (  Accept myAcc : myAccepts)   if (myAcc.getRndNumber() == aBegin.getRndNumber())   ++myAcceptTally;
  if (myAcceptTally >= _common.getTransport().getFD().getMajority()) {
    _logger.trace(toString() + ""String_Node_Str"");
    return _common.getTransport().getPickler().newPacket(new Learned(aBegin.getSeqNum(),aBegin.getRndNumber()));
  }
 else   return null;
}","/** 
 * Determines whether a sufficient number of accepts can be tallied against the specified begin.
 * @param aBegin
 * @return A Learned packet to be logged if there are sufficient accepts, <code>null</code> otherwise.
 */
private Transport.Packet tallyAccepts(Begin aBegin){
  int myAcceptTally=0;
  Set<Transport.Packet> myAccepts=_acceptLedgers.get(aBegin.getSeqNum());
  if (myAccepts == null)   return null;
  for (  Transport.Packet myAcc : myAccepts)   if (((Accept)myAcc.getMessage()).getRndNumber() == aBegin.getRndNumber())   ++myAcceptTally;
  if (myAcceptTally >= _common.getTransport().getFD().getMajority()) {
    _logger.trace(toString() + ""String_Node_Str"");
    return _common.getTransport().getPickler().newPacket(new Learned(aBegin.getSeqNum(),aBegin.getRndNumber()));
  }
 else   return null;
}"
87230,"private void run() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  Transport myTransport=_env._factory.newTransport(null);
  myTransport.routeTo(myClient);
  myClient.init(myTransport);
  long opsSinceCkpt=0;
  if (!_env._calibrate) {
  }
  while (_env._opCount < _env._maxCycles) {
    ByteBuffer myBuffer=ByteBuffer.allocate(8);
    myBuffer.putLong(_env._opCount);
    Proposal myProposal=new Proposal(""String_Node_Str"",myBuffer.array());
    myClient.send(new Envelope(myProposal),_env._currentLeader.getLocalAddress());
    VoteOutcome myEv=myClient.getNext(10000);
    ++opsSinceCkpt;
    if (myEv.getResult() == VoteOutcome.Reason.OTHER_LEADER) {
      _env.updateLeader(myEv.getLeader());
    }
 else     if (myEv.getResult() == VoteOutcome.Reason.VALUE) {
      if (opsSinceCkpt >= _env._ckptCycle) {
        _env.checkpoint();
        opsSinceCkpt=0;
      }
    }
    _env._opCount++;
  }
  _env.terminate();
  _env._factory.stop();
}","private void run() throws Exception {
  ClientDispatcher myClient=new ClientDispatcher();
  Transport myTransport=_env._factory.newTransport(null);
  myTransport.routeTo(myClient);
  myClient.init(myTransport);
  long opsSinceCkpt=0;
  if (!_env._calibrate) {
  }
  while (_env._opCount < _env._maxCycles) {
    ByteBuffer myBuffer=ByteBuffer.allocate(8);
    myBuffer.putLong(_env._opCount);
    Proposal myProposal=new Proposal(""String_Node_Str"",myBuffer.array());
    myClient.send(new Envelope(myProposal),_env._currentLeader.getLocalAddress());
    VoteOutcome myEv=myClient.getNext(10000);
    ++opsSinceCkpt;
    if (myEv.getResult() == VoteOutcome.Reason.OTHER_LEADER) {
      _env.updateLeader(myEv.getLeader());
    }
 else     if (myEv.getResult() == VoteOutcome.Reason.VALUE) {
      if (opsSinceCkpt >= _env._ckptCycle) {
        _env.checkpoint();
        opsSinceCkpt=0;
      }
    }
    _env._opCount++;
  }
  myTransport.terminate();
  _env.terminate();
  _env._factory.stop();
}"
87231,"public static void main(String[] anArgs) throws Exception {
  Args myArgs=CliFactory.parseArguments(Args.class,anArgs);
  long myStart=System.currentTimeMillis();
  new LongTerm(myArgs.getSeed(),myArgs.getCycles(),myArgs.isCalibrate(),myArgs.getCkptCycle()).run();
  double myDuration=(System.currentTimeMillis() - myStart) / 1000.0;
  System.out.println(""String_Node_Str"" + myArgs.getCycles() + ""String_Node_Str""+ myDuration+ ""String_Node_Str"");
  if (myArgs.isCalibrate()) {
    double myOpsPerSec=myDuration / myArgs.getCycles();
    double myOpsHour=myOpsPerSec * 60 * 60;
    System.out.println(""String_Node_Str"" + myOpsPerSec + ""String_Node_Str""+ myOpsHour);
  }
}","public static void main(String[] anArgs) throws Exception {
  Args myArgs=CliFactory.parseArguments(Args.class,anArgs);
  LongTerm myLT=new LongTerm(myArgs.getSeed(),myArgs.getCycles(),myArgs.isCalibrate(),myArgs.getCkptCycle());
  long myStart=System.currentTimeMillis();
  myLT.run();
  double myDuration=(System.currentTimeMillis() - myStart) / 1000.0;
  System.out.println(""String_Node_Str"" + myArgs.getCycles() + ""String_Node_Str""+ myDuration+ ""String_Node_Str"");
  if (myArgs.isCalibrate()) {
    double myOpsPerSec=myDuration / myArgs.getCycles();
    double myOpsHour=myOpsPerSec * 60 * 60;
    System.out.println(""String_Node_Str"" + myOpsPerSec + ""String_Node_Str""+ myOpsHour);
  }
}"
87232,"private void expired(){
  _logger.info(toString() + ""String_Node_Str"");
synchronized (this) {
    if (_stateMachine.getCurrentState().equals(State.SUCCESS)) {
      ++_tries;
      if (_tries < MAX_TRIES) {
        cancelInteraction();
        process(_messages);
        _messages.clear();
        return;
      }
    }
    error(VoteOutcome.Reason.VOTE_TIMEOUT);
  }
}","private void expired(){
synchronized (this) {
    _logger.info(toString() + ""String_Node_Str"");
switch (_stateMachine.getCurrentState()) {
case SUCCESS:
{
        ++_tries;
        if (_tries < MAX_TRIES) {
          cancelInteraction();
          process(_messages);
          _messages.clear();
        }
 else {
          error(VoteOutcome.Reason.VOTE_TIMEOUT);
        }
        break;
      }
case EXIT:
case ABORT:
case SHUTDOWN:
{
      break;
    }
default :
{
    error(VoteOutcome.Reason.VOTE_TIMEOUT);
    break;
  }
}
}
}"
87233,"void resetLeaderAction(){
synchronized (this) {
    _lastLeaderActionTime=0;
  }
}","void resetLeaderAction(){
  _lastLeaderActionTime.set(0);
}"
87234,"void clearLeadership(){
  _lastCollect.set(new FakePacket(Collect.INITIAL));
  _lastLeaderActionTime=0;
}","void clearLeadership(){
  _lastCollect.set(new FakePacket(Collect.INITIAL));
  resetLeaderAction();
}"
87235,"/** 
 * @return <code>true</code> if the collect is either from the existingleader, or there is no leader or there's been nothing heard from the current leader within DEFAULT_LEASE milliseconds else <code>false</code>
 */
boolean amAccepting(Transport.Packet aCollect){
  long myCurrentTime=System.currentTimeMillis();
  if (((Collect)_lastCollect.get().getMessage()).isInitial()) {
    _logger.debug(""String_Node_Str"");
    return true;
  }
 else {
    if (_leaderUtils.sameLeader(aCollect,_lastCollect.get())) {
      _logger.debug(""String_Node_Str"");
      return true;
    }
 else     _logger.debug(""String_Node_Str"" + myCurrentTime + ""String_Node_Str""+ _lastLeaderActionTime+ ""String_Node_Str""+ Constants.getLeaderLeaseDuration()+ ""String_Node_Str""+ (myCurrentTime > _lastLeaderActionTime + Constants.getLeaderLeaseDuration()));
    return (myCurrentTime > _lastLeaderActionTime + Constants.getLeaderLeaseDuration());
  }
}","/** 
 * @return <code>true</code> if the collect is either from the existingleader, or there is no leader or there's been nothing heard from the current leader within DEFAULT_LEASE milliseconds else <code>false</code>
 */
boolean amAccepting(Transport.Packet aCollect){
  long myCurrentTime=System.currentTimeMillis();
  if (((Collect)_lastCollect.get().getMessage()).isInitial()) {
    _logger.debug(""String_Node_Str"");
    return true;
  }
 else {
    if (_leaderUtils.sameLeader(aCollect,_lastCollect.get())) {
      _logger.debug(""String_Node_Str"");
      return true;
    }
 else     _logger.debug(""String_Node_Str"" + myCurrentTime + ""String_Node_Str""+ _lastLeaderActionTime.get()+ ""String_Node_Str""+ Constants.getLeaderLeaseDuration()+ ""String_Node_Str""+ (myCurrentTime > _lastLeaderActionTime.get() + Constants.getLeaderLeaseDuration()));
    return (myCurrentTime > _lastLeaderActionTime.get() + Constants.getLeaderLeaseDuration());
  }
}"
87236,"void leaderAction(){
synchronized (this) {
    _lastLeaderActionTime=System.currentTimeMillis();
  }
}","void leaderAction(){
  _lastLeaderActionTime.set(System.currentTimeMillis());
}"
87237,"private Leader constructFollowing(){
switch (_outcomes.getLast().getResult()) {
case VoteOutcome.Reason.DECISION:
{
      return new Leader(_common,_factory,_outcomes.getLast().getSeqNum() + 1,_outcomes.getLast().getRndNumber(),State.BEGIN);
    }
case VoteOutcome.Reason.OTHER_LEADER:
{
    return new Leader(_common,_factory,_outcomes.getLast().getSeqNum() + 1,_outcomes.getLast().getRndNumber() + 1,State.BEGIN);
  }
case VoteOutcome.Reason.BAD_MEMBERSHIP:
case VoteOutcome.Reason.VOTE_TIMEOUT:
{
  return new Leader(_common,_factory,_outcomes.getLast().getSeqNum(),_outcomes.getLast().getRndNumber(),State.COLLECT);
}
default :
throw new IllegalStateException(""String_Node_Str"");
}
}","private Leader constructFollowing(){
switch (_outcomes.getLast().getResult()) {
case VoteOutcome.Reason.DECISION:
{
      return new Leader(_common,_factory,_outcomes.getLast().getSeqNum() + 1,_outcomes.getLast().getRndNumber(),State.BEGIN);
    }
case VoteOutcome.Reason.OTHER_LEADER:
{
    return new Leader(_common,_factory,_outcomes.getLast().getSeqNum() + 1,_outcomes.getLast().getRndNumber() + 1,State.COLLECT);
  }
case VoteOutcome.Reason.BAD_MEMBERSHIP:
case VoteOutcome.Reason.VOTE_TIMEOUT:
{
  return new Leader(_common,_factory,_outcomes.getLast().getSeqNum(),_outcomes.getLast().getRndNumber(),State.COLLECT);
}
default :
throw new IllegalStateException(""String_Node_Str"");
}
}"
87238,"long install(AcceptorLearner.Watermark aLow){
  if (!aLow.equals(AcceptorLearner.Watermark.INITIAL)) {
    _lowSeqNumWatermark=aLow;
    return _lowSeqNumWatermark.getSeqNum();
  }
  return -1;
}","long install(AcceptorLearner.Watermark aLow){
synchronized (this) {
    _lowSeqNumWatermark=aLow;
    return _lowSeqNumWatermark.getSeqNum();
  }
}"
87239,"private PaxosMessage constructLast(long aSeqNum){
  Watermark myLow=_common.getRecoveryTrigger().getLowWatermark();
  Begin myState;
  try {
    if ((myLow.equals(Watermark.INITIAL)) || (aSeqNum <= myLow.getSeqNum())) {
      myState=new StateFinder(aSeqNum,0).getState();
    }
 else     myState=new StateFinder(aSeqNum,myLow.getLogOffset()).getState();
  }
 catch (  Exception anE) {
    _logger.error(""String_Node_Str"" + ""String_Node_Str"" + _common.getTransport().getLocalAddress(),anE);
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + _common.getTransport().getLocalAddress(),anE);
  }
  if (myState != null) {
    return new Last(aSeqNum,myLow.getSeqNum(),myState.getRndNumber(),myState.getConsolidatedValue());
  }
 else {
    if (aSeqNum <= myLow.getSeqNum())     return new OldRound(aSeqNum,_common.getLeaderAddress(),_common.getLeaderRndNum());
 else     return new Last(aSeqNum,myLow.getSeqNum(),Long.MIN_VALUE,Proposal.NO_VALUE);
  }
}","/** 
 * @todo BUG: If the leader is out of date, it couldn't currently recover from the OLD_ROUND message becauseit doesn't contain an up-to-date sequence number.
 */
private PaxosMessage constructLast(long aSeqNum){
  Watermark myLow=_common.getRecoveryTrigger().getLowWatermark();
  Begin myState;
  try {
    if ((myLow.equals(Watermark.INITIAL)) || (aSeqNum <= myLow.getSeqNum())) {
      myState=new StateFinder(aSeqNum,0).getState();
    }
 else     myState=new StateFinder(aSeqNum,myLow.getLogOffset()).getState();
  }
 catch (  Exception anE) {
    _logger.error(""String_Node_Str"" + ""String_Node_Str"" + _common.getTransport().getLocalAddress(),anE);
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + _common.getTransport().getLocalAddress(),anE);
  }
  if (myState != null) {
    return new Last(aSeqNum,myLow.getSeqNum(),myState.getRndNumber(),myState.getConsolidatedValue());
  }
 else {
    if (aSeqNum <= myLow.getSeqNum())     return new OldRound(aSeqNum,_common.getLeaderAddress(),_common.getLeaderRndNum());
 else     return new Last(aSeqNum,myLow.getSeqNum(),Long.MIN_VALUE,Proposal.NO_VALUE);
  }
}"
87240,"/** 
 * Get the next leader in the chain. Will block until the current leader has reached a stable outcome.
 */
Leader nextLeader(){
synchronized (this) {
    while (!isDone()) {
      try {
        wait();
      }
 catch (      InterruptedException anIE) {
      }
    }
    long mySeqNum=_common.getRecoveryTrigger().getLowWatermark().getSeqNum() + 1;
    long myRndNum=_common.getLeaderRndNum() + 1;
    State myState=State.COLLECT;
switch (_outcomes.getLast().getResult()) {
case VoteOutcome.Reason.DECISION:
{
        myState=State.BEGIN;
        mySeqNum=_outcomes.getLast().getSeqNum() + 1;
        myRndNum=_outcomes.getLast().getRndNumber();
        break;
      }
case VoteOutcome.Reason.OTHER_LEADER:
{
      mySeqNum=_outcomes.getLast().getSeqNum() + 1;
      myRndNum=_outcomes.getLast().getRndNumber() + 1;
      break;
    }
default :
  throw new IllegalStateException(""String_Node_Str"");
}
return new Leader(_common,_factory,mySeqNum,myRndNum,myState);
}
}","/** 
 * Get the next leader in the chain. Will block until the current leader has reached a stable outcome.
 */
Leader nextLeader(){
synchronized (this) {
    while (!isDone()) {
      try {
        wait();
      }
 catch (      InterruptedException anIE) {
      }
    }
switch (_outcomes.getLast().getResult()) {
case VoteOutcome.Reason.DECISION:
{
        return new Leader(_common,_factory,_outcomes.getLast().getSeqNum() + 1,_outcomes.getLast().getRndNumber(),State.BEGIN);
      }
case VoteOutcome.Reason.OTHER_LEADER:
{
      return new Leader(_common,_factory,_outcomes.getLast().getSeqNum() + 1,_outcomes.getLast().getRndNumber() + 1,State.BEGIN);
    }
case VoteOutcome.Reason.BAD_MEMBERSHIP:
case VoteOutcome.Reason.VOTE_TIMEOUT:
{
    return new Leader(_common,_factory,_outcomes.getLast().getSeqNum(),_outcomes.getLast().getRndNumber(),State.COLLECT);
  }
default :
throw new IllegalStateException(""String_Node_Str"");
}
}
}"
87241,"public boolean routeable(Instance anInstance){
  return ((_lastRound >= anInstance.getRound()) && ((anInstance.getState().equals(Instance.State.BEGIN)) || (anInstance.getState().equals(Instance.State.SUCCESS))));
}","/** 
 * OldRound always indicates a leader is not in charge regardless of sequence number, thus it needn't be attached to a specific sequence number and thus OldRound can contain most recent successful sequence number not the original
 */
public boolean routeable(Instance anInstance){
  return ((_lastRound >= anInstance.getRound()) && ((anInstance.getState().equals(Instance.State.BEGIN)) || (anInstance.getState().equals(Instance.State.SUCCESS))));
}"
87242,"public long getSeqNum(){
  return _seqNum;
}","/** 
 * Sequence number is always the last one completed (the AL low watermark).
 */
public long getSeqNum(){
  return _seqNum;
}"
87243,"/** 
 * @todo BUG: If the leader is out of date, it couldn't currently recover from the OLD_ROUND message becauseit doesn't contain an up-to-date sequence number.
 */
private PaxosMessage constructLast(long aSeqNum){
  Watermark myLow=_common.getRecoveryTrigger().getLowWatermark();
  Begin myState;
  try {
    if ((myLow.equals(Watermark.INITIAL)) || (aSeqNum <= myLow.getSeqNum())) {
      myState=new StateFinder(aSeqNum,0).getState();
    }
 else     myState=new StateFinder(aSeqNum,myLow.getLogOffset()).getState();
  }
 catch (  Exception anE) {
    _logger.error(""String_Node_Str"" + ""String_Node_Str"" + _common.getTransport().getLocalAddress(),anE);
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + _common.getTransport().getLocalAddress(),anE);
  }
  if (myState != null) {
    return new Last(aSeqNum,myLow.getSeqNum(),myState.getRndNumber(),myState.getConsolidatedValue());
  }
 else {
    if (aSeqNum <= myLow.getSeqNum())     return new OldRound(aSeqNum,_common.getLeaderAddress(),_common.getLeaderRndNum());
 else     return new Last(aSeqNum,myLow.getSeqNum(),Long.MIN_VALUE,Proposal.NO_VALUE);
  }
}","private PaxosMessage constructLast(long aSeqNum){
  Watermark myLow=_common.getRecoveryTrigger().getLowWatermark();
  Begin myState;
  try {
    if ((myLow.equals(Watermark.INITIAL)) || (aSeqNum <= myLow.getSeqNum())) {
      myState=new StateFinder(aSeqNum,0).getState();
    }
 else     myState=new StateFinder(aSeqNum,myLow.getLogOffset()).getState();
  }
 catch (  Exception anE) {
    _logger.error(""String_Node_Str"" + ""String_Node_Str"" + _common.getTransport().getLocalAddress(),anE);
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + _common.getTransport().getLocalAddress(),anE);
  }
  if (myState != null) {
    return new Last(aSeqNum,myLow.getSeqNum(),myState.getRndNumber(),myState.getConsolidatedValue());
  }
 else {
    if (aSeqNum <= myLow.getSeqNum())     return new OldRound(myLow.getSeqNum(),_common.getLeaderAddress(),_common.getLeaderRndNum());
 else     return new Last(aSeqNum,myLow.getSeqNum(),Long.MIN_VALUE,Proposal.NO_VALUE);
  }
}"
87244,"public void terminate(){
  guard();
  _isStopping.set(true);
synchronized (this) {
    for (    Dispatcher d : _dispatcher)     try {
      d.terminate();
    }
 catch (    Exception anE) {
      _logger.warn(""String_Node_Str"",anE);
    }
  }
}","public void terminate(){
  guard();
  _isStopping.set(true);
  _factory.destroy(this);
synchronized (this) {
    for (    Dispatcher d : _dispatcher)     try {
      d.terminate();
    }
 catch (    Exception anE) {
      _logger.warn(""String_Node_Str"",anE);
    }
  }
}"
87245,"public void messageReceived(Transport.Packet aPacket){
  if ((_common.testState(Common.FSMStates.OUT_OF_DATE)) || (_common.testState(Common.FSMStates.SHUTDOWN)))   return;
  PaxosMessage myMessage=aPacket.getMessage();
  long mySeqNum=myMessage.getSeqNum();
  Writer myWriter=new LiveWriter();
  if (_common.testState(Common.FSMStates.RECOVERING)) {
switch (myMessage.getType()) {
case Operations.NEED:
      return;
case Operations.OUTOFDATE:
{
synchronized (this) {
        completedRecovery();
        _common.setState(Common.FSMStates.OUT_OF_DATE);
      }
      _common.signal(new VoteOutcome(VoteOutcome.Reason.OUT_OF_DATE,mySeqNum,_common.getLeaderRndNum(),new Proposal(),aPacket.getSource()));
      return;
    }
}
}
boolean myRecoveryInProgress=_common.testState(Common.FSMStates.RECOVERING);
Need myWindow=_common.getRecoveryTrigger().shouldRecover(myMessage.getSeqNum(),_localAddress);
int mySeqNumPosition=(myRecoveryInProgress) ? _recoveryWindow.get().relativeToWindow(mySeqNum) : Integer.MIN_VALUE;
Sender mySender=(myRecoveryInProgress) ? new RecoverySender() : new LiveSender();
if ((!myRecoveryInProgress) && (myWindow != null)) {
synchronized (this) {
  _packetBuffer.clear();
  try {
    _packetBuffer.put(aPacket);
  }
 catch (  InterruptedException anIE) {
    _logger.error(""String_Node_Str"",anIE);
    throw new RuntimeException(""String_Node_Str"",anIE);
  }
  mySender.send(myWindow,_common.getFD().getRandomMember(_localAddress));
  _common.setState(Common.FSMStates.RECOVERING);
  _recoveryWindow.set(myWindow);
  reschedule();
}
}
if ((myRecoveryInProgress) && (mySeqNumPosition == 1)) {
try {
  _packetBuffer.put(aPacket);
}
 catch (InterruptedException anIE) {
  _logger.error(""String_Node_Str"",anIE);
  throw new RuntimeException(""String_Node_Str"",anIE);
}
}
if (((myRecoveryInProgress) && (mySeqNumPosition == 0)) || ((!myRecoveryInProgress) && (myWindow == null))) {
process(aPacket,myWriter,mySender);
if (myRecoveryInProgress) {
  if (_common.getRecoveryTrigger().getLowWatermark().getSeqNum() == _recoveryWindow.get().getMaxSeq()) {
synchronized (this) {
      for (      Transport.Packet myReplayPacket : _packetBuffer) {
        if (_common.getRecoveryTrigger().shouldRecover(myReplayPacket.getMessage().getSeqNum(),_localAddress) != null)         break;
        process(myReplayPacket,myWriter,mySender);
      }
      completedRecovery();
      _common.testAndSetState(Common.FSMStates.RECOVERING,Common.FSMStates.ACTIVE);
    }
  }
}
}
}","public void messageReceived(Transport.Packet aPacket){
  if ((_common.testState(Common.FSMStates.OUT_OF_DATE)) || (_common.testState(Common.FSMStates.SHUTDOWN)))   return;
  PaxosMessage myMessage=aPacket.getMessage();
  long mySeqNum=myMessage.getSeqNum();
  Writer myWriter=new LiveWriter();
  if (_common.testState(Common.FSMStates.RECOVERING)) {
switch (myMessage.getType()) {
case Operations.NEED:
      return;
case Operations.OUTOFDATE:
{
synchronized (this) {
        completedRecovery();
        _common.setState(Common.FSMStates.OUT_OF_DATE);
      }
      _common.signal(new VoteOutcome(VoteOutcome.Reason.OUT_OF_DATE,mySeqNum,_common.getLeaderRndNum(),new Proposal(),aPacket.getSource()));
      return;
    }
}
}
boolean myRecoveryInProgress=_common.testState(Common.FSMStates.RECOVERING);
Need myWindow=_common.getRecoveryTrigger().shouldRecover(myMessage.getSeqNum(),_localAddress);
int mySeqNumPosition=(myRecoveryInProgress) ? _recoveryWindow.get().relativeToWindow(mySeqNum) : Integer.MIN_VALUE;
Sender mySender=(myRecoveryInProgress) ? new RecoverySender() : new LiveSender();
boolean myMisfire=false;
if ((!myRecoveryInProgress) && (myWindow != null)) {
boolean madeRecoveryTransition=false;
synchronized (_packetBuffer) {
  madeRecoveryTransition=_common.testAndSetState(Common.FSMStates.ACTIVE,Common.FSMStates.RECOVERING);
  if (madeRecoveryTransition) {
    _packetBuffer.clear();
    try {
      _packetBuffer.put(aPacket);
    }
 catch (    InterruptedException anIE) {
      _logger.error(""String_Node_Str"",anIE);
      throw new RuntimeException(""String_Node_Str"",anIE);
    }
    _recoveryWindow.set(myWindow);
  }
}
if (madeRecoveryTransition) {
  mySender.send(myWindow,_common.getFD().getRandomMember(_localAddress));
  reschedule();
}
 else {
  myMisfire=true;
}
}
if ((myRecoveryInProgress) && (mySeqNumPosition == 1)) {
synchronized (_packetBuffer) {
  if (_common.testState(Common.FSMStates.RECOVERING)) {
    try {
      _packetBuffer.put(aPacket);
    }
 catch (    InterruptedException anIE) {
      _logger.error(""String_Node_Str"",anIE);
      throw new RuntimeException(""String_Node_Str"",anIE);
    }
  }
 else {
    myMisfire=true;
  }
}
}
if (((myRecoveryInProgress) && (mySeqNumPosition == 0)) || ((!myRecoveryInProgress) && (myWindow == null))) {
process(aPacket,myWriter,mySender);
if (myRecoveryInProgress) {
  if (_common.getRecoveryTrigger().getLowWatermark().getSeqNum() == _recoveryWindow.get().getMaxSeq()) {
synchronized (_packetBuffer) {
      if (_common.testState(Common.FSMStates.RECOVERING)) {
        for (        Transport.Packet myReplayPacket : _packetBuffer) {
          if (_common.getRecoveryTrigger().shouldRecover(myReplayPacket.getMessage().getSeqNum(),_localAddress) != null)           break;
          process(myReplayPacket,myWriter,mySender);
        }
        completedRecovery();
        _common.testAndSetState(Common.FSMStates.RECOVERING,Common.FSMStates.ACTIVE);
      }
 else {
        myMisfire=true;
      }
    }
  }
}
}
if (myMisfire) messageReceived(aPacket);
}"
87246,"public Map<InetSocketAddress,MetaData> getMemberMap(){
  Map myActives=new HashMap<InetSocketAddress,MetaData>();
synchronized (this) {
    new HashMap<InetSocketAddress,MetaData>(_lastHeartbeats);
  }
  return myActives;
}","public Map<InetSocketAddress,MetaData> getMemberMap(){
  Map myActives;
synchronized (this) {
    myActives=new HashMap<InetSocketAddress,MetaData>(_lastHeartbeats);
  }
  return myActives;
}"
87247,"@Test public void post() throws Exception {
  ensureFD(_node1.getCommon().getPrivateFD());
  ensureFD(_node2.getCommon().getPrivateFD());
  assert(_node1.getCommon().getFD().getMemberMap().size() == 2);
  assert(_node2.getCommon().getFD().getMemberMap().size() == 2);
  Map<InetSocketAddress,FailureDetector.MetaData> myMembers=_node1.getCommon().getFD().getMemberMap();
  Iterator<Map.Entry<InetSocketAddress,FailureDetector.MetaData>> myMemberIt=myMembers.entrySet().iterator();
  while (myMemberIt.hasNext()) {
    Map.Entry<InetSocketAddress,FailureDetector.MetaData> myEntry=myMemberIt.next();
    if (myEntry.getKey().equals(_tport1.getLocalAddress())) {
      assert(""String_Node_Str"".equals(new String(myEntry.getValue().getData())));
    }
 else     if (myEntry.getKey().equals(_tport2.getLocalAddress())) {
      assert(""String_Node_Str"".equals(new String(myEntry.getValue().getData())));
    }
 else {
      Assert.fail();
    }
  }
}","@Test public void post() throws Exception {
  ensureFD(_node1.getCommon().getPrivateFD());
  ensureFD(_node2.getCommon().getPrivateFD());
  Assert.assertTrue(_node1.getCommon().getFD().getMemberMap().size() == 2);
  Assert.assertTrue(_node2.getCommon().getFD().getMemberMap().size() == 2);
  Map<InetSocketAddress,FailureDetector.MetaData> myMembers=_node1.getCommon().getFD().getMemberMap();
  Iterator<Map.Entry<InetSocketAddress,FailureDetector.MetaData>> myMemberIt=myMembers.entrySet().iterator();
  while (myMemberIt.hasNext()) {
    Map.Entry<InetSocketAddress,FailureDetector.MetaData> myEntry=myMemberIt.next();
    if (myEntry.getKey().equals(_tport1.getLocalAddress())) {
      Assert.assertTrue(""String_Node_Str"".equals(new String(myEntry.getValue().getData())));
    }
 else     if (myEntry.getKey().equals(_tport2.getLocalAddress())) {
      Assert.assertTrue(""String_Node_Str"".equals(new String(myEntry.getValue().getData())));
    }
 else {
      Assert.fail();
    }
  }
}"
87248,"/** 
 * When an AL is out of date, call this method to bring it back into sync from a remotely sourced checkpoint.
 * @param aHandle obtained from the remote checkpoint.
 * @throws Exception
 */
public void bringUpToDate(CheckpointHandle aHandle) throws Exception {
  if (!isOutOfDate())   throw new IllegalStateException(""String_Node_Str"");
  if (!(aHandle instanceof ALCheckpointHandle))   throw new IllegalArgumentException(""String_Node_Str"" + aHandle);
  ALCheckpointHandle myHandle=(ALCheckpointHandle)aHandle;
  if (myHandle.equals(CheckpointHandle.NO_CHECKPOINT))   throw new IllegalArgumentException(""String_Node_Str"" + myHandle);
synchronized (this) {
    installCheckpoint(myHandle);
    _storage.mark(myHandle.getLowWatermark().getLogOffset(),true);
    _outOfDate=null;
    _recoveryWindow=null;
    _packetBuffer.clear();
    _cachedBegins.clear();
    _lastLeaderActionTime=System.currentTimeMillis();
  }
}","/** 
 * When an AL is out of date, call this method to bring it back into sync from a remotely sourced checkpoint.
 * @param aHandle obtained from the remote checkpoint.
 * @throws Exception
 */
public void bringUpToDate(CheckpointHandle aHandle) throws Exception {
  if (!isOutOfDate())   throw new IllegalStateException(""String_Node_Str"");
  if (!(aHandle instanceof ALCheckpointHandle))   throw new IllegalArgumentException(""String_Node_Str"" + aHandle);
  ALCheckpointHandle myHandle=(ALCheckpointHandle)aHandle;
  if (myHandle.equals(CheckpointHandle.NO_CHECKPOINT))   throw new IllegalArgumentException(""String_Node_Str"" + myHandle);
synchronized (this) {
    installCheckpoint(myHandle);
    _storage.mark(write(myHandle.getLastCollect(),false),true);
    _outOfDate=null;
    _recoveryWindow=null;
    _packetBuffer.clear();
    _cachedBegins.clear();
    _lastLeaderActionTime=System.currentTimeMillis();
  }
}"
87249,"public void allReceived(){
  cancelInteraction();
synchronized (this) {
    _tries=0;
    process();
  }
}","public void allReceived(){
synchronized (this) {
    cancelInteraction();
    _tries=0;
    process();
  }
}"
87250,"private void expired(){
  _logger.info(this + ""String_Node_Str"");
synchronized (this) {
    if (canRetry()) {
      ++_tries;
      if (_tries < MAX_TRIES) {
        process();
        return;
      }
    }
    error(Event.Reason.VOTE_TIMEOUT);
  }
}","private void expired(){
  _logger.info(this + ""String_Node_Str"");
synchronized (this) {
    if (canRetry()) {
      ++_tries;
      if (_tries < MAX_TRIES) {
        cancelInteraction();
        process();
        return;
      }
    }
    error(Event.Reason.VOTE_TIMEOUT);
  }
}"
87251,"public void shutdown(){
  _watchdog.cancel();
}","public void shutdown(){
synchronized (this) {
    _watchdog.cancel();
    if (_membership != null)     _membership.dispose();
    _currentState=States.ABORT;
  }
}"
87252,"static MessageValidator getValidator(int aLeaderState){
switch (aLeaderState) {
case BEGIN:
    return _beginValidator;
case SUCCESS:
  return _successValidator;
default :
throw new RuntimeException(""String_Node_Str"" + aLeaderState);
}
}","static MessageValidator getValidator(int aLeaderState){
switch (aLeaderState) {
case BEGIN:
    return _beginValidator;
case SUCCESS:
  return _successValidator;
default :
{
  _logger.warn(""String_Node_Str"" + aLeaderState);
  return _nullValidator;
}
}
}"
87253,"/** 
 * Do actions for the state we are now in.  Essentially, we're always one state ahead of the participants thus we process the result of a Collect in the BEGIN state which means we expect Last or OldRound and in SUCCESS state we expect ACCEPT or OLDROUND
 * @todo Increment round number via heartbeats every so often - see note below about jittering collects.
 */
private void process(){
switch (_state) {
case ABORT:
{
      assert(_queue.size() != 0);
      _logger.info(this + ""String_Node_Str"" + _event,new RuntimeException());
      _messages.clear();
      if (_membership != null)       _membership.dispose();
      while (_queue.size() > 0) {
        _al.signal(new Event(_event.getResult(),_event.getSeqNum(),_queue.remove(0),_al.getLastCollect().getNodeId()));
      }
      return;
    }
case EXIT:
{
    assert(_queue.size() != 0);
    _logger.info(this + ""String_Node_Str"" + _event);
    _messages.clear();
    _queue.remove(0);
    if (_membership != null)     _membership.dispose();
    if (_queue.size() > 0) {
      _logger.info(this + ""String_Node_Str"" + _queue.get(0));
      _state=SUBMITTED;
      process();
    }
 else {
      _heartbeatAlarm=new TimerTask(){
        public void run(){
          _logger.info(this + ""String_Node_Str"" + System.currentTimeMillis());
          submit(AcceptorLearner.HEARTBEAT);
        }
      }
;
      _watchdog.schedule(_heartbeatAlarm,calculateLeaderRefresh());
    }
    return;
  }
case SUBMITTED:
{
  assert(_queue.size() != 0);
  _tries=0;
  _membership=_detector.getMembers(this);
  _logger.info(this + ""String_Node_Str"" + _membership.getSize()+ ""String_Node_Str"");
  _state=COLLECT;
  process();
  break;
}
case COLLECT:
{
assert(_queue.size() != 0);
if (_heartbeatAlarm != null) {
  _heartbeatAlarm.cancel();
  _watchdog.purge();
}
Collect myLastCollect=_al.getLastCollect();
if (myLastCollect.isInitial()) {
  _logger.info(this + ""String_Node_Str"");
  _rndNumber=0;
}
 else {
  InetSocketAddress myOtherLeader=myLastCollect.getNodeId();
  boolean isUs=myOtherLeader.equals(_transport.getLocalAddress());
  if (!isUs) {
    _logger.info(this + ""String_Node_Str"");
    if (_detector.isLive(myOtherLeader)) {
      _logger.info(this + ""String_Node_Str"");
      error(Event.Reason.OTHER_LEADER,myOtherLeader);
      return;
    }
 else {
      _logger.info(this + ""String_Node_Str"");
      if (_rndNumber <= myLastCollect.getRndNumber())       _rndNumber=myLastCollect.getRndNumber() + 1;
    }
  }
 else {
    if (_lastSuccessfulRndNumber == myLastCollect.getRndNumber()) {
      _logger.info(this + ""String_Node_Str"");
      updateSeqNum();
      _state=BEGIN;
      process();
      return;
    }
  }
}
updateSeqNum();
_state=BEGIN;
emit(new Collect(_seqNum,_rndNumber,_transport.getLocalAddress()));
break;
}
case BEGIN:
{
assert(_queue.size() != 0);
long myMaxProposal=-1;
Proposal myValue=null;
for (PaxosMessage m : _messages) {
Last myLast=(Last)m;
if (!myLast.getConsolidatedValue().equals(LogStorage.NO_VALUE)) {
  if (myLast.getRndNumber() > myMaxProposal) {
    myValue=myLast.getConsolidatedValue();
    myMaxProposal=myLast.getRndNumber();
  }
}
}
if ((myValue != null) && (!myValue.equals(_queue.get(0)))) _queue.add(myValue);
_state=SUCCESS;
emit(new Begin(_seqNum,_rndNumber,_queue.get(0),_transport.getLocalAddress()));
break;
}
case SUCCESS:
{
assert(_queue.size() != 0);
if (_messages.size() >= _detector.getMajority()) {
emit(new Success(_seqNum,_rndNumber,_transport.getLocalAddress()));
cancelInteraction();
_lastSuccessfulRndNumber=_rndNumber;
successful(Event.Reason.DECISION);
}
 else {
emit(new Begin(_seqNum,_rndNumber,_queue.get(0),_transport.getLocalAddress()));
}
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + _state);
}
}","/** 
 * Do actions for the state we are now in.  Essentially, we're always one state ahead of the participants thus we process the result of a Collect in the BEGIN state which means we expect Last or OldRound and in SUCCESS state we expect ACCEPT or OLDROUND
 * @todo Increment round number via heartbeats every so often - see note below about jittering collects.
 */
private void process(){
switch (_state) {
case ABORT:
{
      assert(_queue.size() != 0);
      _logger.info(this + ""String_Node_Str"" + _event,new RuntimeException());
      _messages.clear();
      if (_membership != null)       _membership.dispose();
      cancelInteraction();
      while (_queue.size() > 0) {
        _al.signal(new Event(_event.getResult(),_event.getSeqNum(),_queue.remove(0),_al.getLastCollect().getNodeId()));
      }
      return;
    }
case EXIT:
{
    assert(_queue.size() != 0);
    _logger.info(this + ""String_Node_Str"" + _event);
    _messages.clear();
    _queue.remove(0);
    if (_membership != null)     _membership.dispose();
    if (_queue.size() > 0) {
      _logger.info(this + ""String_Node_Str"" + _queue.get(0));
      _state=SUBMITTED;
      process();
    }
 else {
      _heartbeatAlarm=new TimerTask(){
        public void run(){
          _logger.info(this + ""String_Node_Str"" + System.currentTimeMillis());
          submit(AcceptorLearner.HEARTBEAT);
        }
      }
;
      _watchdog.schedule(_heartbeatAlarm,calculateLeaderRefresh());
    }
    return;
  }
case SUBMITTED:
{
  assert(_queue.size() != 0);
  _tries=0;
  _membership=_detector.getMembers(this);
  _logger.info(this + ""String_Node_Str"" + _membership.getSize()+ ""String_Node_Str"");
  _state=COLLECT;
  process();
  break;
}
case COLLECT:
{
assert(_queue.size() != 0);
if (_heartbeatAlarm != null) {
  _heartbeatAlarm.cancel();
  _watchdog.purge();
}
Collect myLastCollect=_al.getLastCollect();
if (myLastCollect.isInitial()) {
  _logger.info(this + ""String_Node_Str"");
  _rndNumber=0;
}
 else {
  InetSocketAddress myOtherLeader=myLastCollect.getNodeId();
  boolean isUs=myOtherLeader.equals(_transport.getLocalAddress());
  if (!isUs) {
    _logger.info(this + ""String_Node_Str"");
    if (_detector.isLive(myOtherLeader)) {
      _logger.info(this + ""String_Node_Str"");
      error(Event.Reason.OTHER_LEADER,myOtherLeader);
      return;
    }
 else {
      _logger.info(this + ""String_Node_Str"");
      if (_rndNumber <= myLastCollect.getRndNumber())       _rndNumber=myLastCollect.getRndNumber() + 1;
    }
  }
 else {
    if (_lastSuccessfulRndNumber == myLastCollect.getRndNumber()) {
      _logger.info(this + ""String_Node_Str"");
      updateSeqNum();
      _state=BEGIN;
      process();
      return;
    }
  }
}
updateSeqNum();
_state=BEGIN;
emit(new Collect(_seqNum,_rndNumber,_transport.getLocalAddress()));
break;
}
case BEGIN:
{
assert(_queue.size() != 0);
long myMaxProposal=-1;
Proposal myValue=null;
for (PaxosMessage m : _messages) {
Last myLast=(Last)m;
if (!myLast.getConsolidatedValue().equals(LogStorage.NO_VALUE)) {
  if (myLast.getRndNumber() > myMaxProposal) {
    myValue=myLast.getConsolidatedValue();
    myMaxProposal=myLast.getRndNumber();
  }
}
}
if ((myValue != null) && (!myValue.equals(_queue.get(0)))) _queue.add(myValue);
_state=SUCCESS;
emit(new Begin(_seqNum,_rndNumber,_queue.get(0),_transport.getLocalAddress()));
break;
}
case SUCCESS:
{
assert(_queue.size() != 0);
if (_messages.size() >= _detector.getMajority()) {
emit(new Success(_seqNum,_rndNumber,_transport.getLocalAddress()));
cancelInteraction();
_lastSuccessfulRndNumber=_rndNumber;
successful(Event.Reason.DECISION);
}
 else {
emit(new Begin(_seqNum,_rndNumber,_queue.get(0),_transport.getLocalAddress()));
}
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + _state);
}
}"
87254,"/** 
 * @todo If we get ABORT, we could try a new round from scratch or make the client re-submit or .....
 */
public void abort(){
  _logger.info(this + ""String_Node_Str"");
  cancelInteraction();
synchronized (this) {
    error(Event.Reason.BAD_MEMBERSHIP);
  }
}","/** 
 * @todo If we get ABORT, we could try a new round from scratch or make the client re-submit or .....
 */
public void abort(){
  _logger.info(this + ""String_Node_Str"");
synchronized (this) {
    error(Event.Reason.BAD_MEMBERSHIP);
  }
}"
87255,"public boolean equals(Object anObject){
  if (anObject instanceof Proposal) {
    Proposal myOther=(Proposal)anObject;
    if (myOther.getSize() == getSize()) {
      for (      Map.Entry<String,byte[]> kv : _values.entrySet()) {
        byte[] myOtherVal=myOther.get(kv.getKey());
        if ((myOtherVal == null) || (!compare(myOtherVal,kv.getValue())))         break;
      }
      return true;
    }
  }
  return false;
}","public boolean equals(Object anObject){
  if (anObject instanceof Proposal) {
    Proposal myOther=(Proposal)anObject;
    if (myOther.getSize() == getSize()) {
      for (      Map.Entry<String,byte[]> kv : _values.entrySet()) {
        byte[] myOtherVal=myOther.get(kv.getKey());
        if ((myOtherVal == null) || (!compare(myOtherVal,kv.getValue())))         return false;
      }
      return true;
    }
  }
  return false;
}"
87256,"public void put(String aKey,byte[] aValue){
  _values.put(aKey,aValue);
}","public Proposal put(String aKey,byte[] aValue){
  _values.put(aKey,aValue);
  return this;
}"
87257,"public boolean sameLeader(Collect aCollect){
  return ((_rndNumber == aCollect._rndNumber) && (_nodeId.equals(aCollect._nodeId)));
}","public boolean sameLeader(Collect aCollect){
  return ((_rndNumber >= aCollect._rndNumber) && (_nodeId.equals(aCollect._nodeId)));
}"
87258,"/** 
 * Do actions for the state we are now in.  Essentially, we're always one state ahead of the participants thus we process the result of a Collect in the BEGIN state which means we expect Last or OldRound and in SUCCESS state we expect ACCEPT or OLDROUND
 * @todo Increment round number via heartbeats every so often - see note below about jittering collects.
 */
private void process(){
switch (_state) {
case ABORT:
{
      assert(_queue.size() != 0);
      _logger.info(this + ""String_Node_Str"" + _event,new RuntimeException());
      _messages.clear();
      if (_membership != null)       _membership.dispose();
      while (_queue.size() > 0) {
        _al.signal(new Event(_event.getResult(),_event.getSeqNum(),_queue.remove(0)));
      }
      return;
    }
case EXIT:
{
    assert(_queue.size() != 0);
    _logger.info(this + ""String_Node_Str"" + _event);
    _messages.clear();
    _queue.remove(0);
    if (_membership != null)     _membership.dispose();
    if (_queue.size() > 0) {
      _logger.info(this + ""String_Node_Str"" + _queue.get(0));
      _state=SUBMITTED;
      process();
    }
 else {
      _heartbeatAlarm=new TimerTask(){
        public void run(){
          _logger.info(this + ""String_Node_Str"" + System.currentTimeMillis());
          submit(AcceptorLearner.HEARTBEAT);
        }
      }
;
      _watchdog.schedule(_heartbeatAlarm,calculateLeaderRefresh());
    }
    return;
  }
case SUBMITTED:
{
  assert(_queue.size() != 0);
  _tries=0;
  _membership=_detector.getMembers(this);
  _logger.info(this + ""String_Node_Str"" + _membership.getSize()+ ""String_Node_Str"");
  _state=COLLECT;
  process();
  break;
}
case COLLECT:
{
assert(_queue.size() != 0);
if (_heartbeatAlarm != null) _heartbeatAlarm.cancel();
Collect myLastCollect=_al.getLastCollect();
if (myLastCollect.isInitial()) {
  _logger.info(this + ""String_Node_Str"");
  _rndNumber=myLastCollect.getRndNumber() + 1;
}
 else {
  InetSocketAddress myOtherLeader=myLastCollect.getNodeId();
  boolean isUs=myOtherLeader.equals(_transport.getLocalAddress());
  if (!isUs) {
    _logger.info(this + ""String_Node_Str"");
    if (_detector.isLive(myOtherLeader)) {
      _logger.info(this + ""String_Node_Str"");
      error(Event.Reason.OTHER_LEADER,myOtherLeader);
      return;
    }
 else {
      _logger.info(this + ""String_Node_Str"");
      if (_rndNumber <= myLastCollect.getRndNumber())       _rndNumber=myLastCollect.getRndNumber() + 1;
    }
  }
}
if (_seqNum == AcceptorLearner.UNKNOWN_SEQ) _seqNum=0;
 else _seqNum=_seqNum + 1;
_state=BEGIN;
emit(new Collect(_seqNum,_rndNumber,_transport.getLocalAddress()));
break;
}
case BEGIN:
{
assert(_queue.size() != 0);
long myMaxProposal=-1;
ConsolidatedValue myValue=null;
for (PaxosMessage m : _messages) {
Last myLast=(Last)m;
if (!myLast.getConsolidatedValue().equals(LogStorage.NO_VALUE)) {
  if (myLast.getRndNumber() > myMaxProposal)   myValue=myLast.getConsolidatedValue();
}
}
if ((myValue != null) && (!myValue.equals(_queue.get(0)))) _queue.add(myValue);
_state=SUCCESS;
emit(new Begin(_seqNum,_rndNumber,_queue.get(0),_transport.getLocalAddress()));
break;
}
case SUCCESS:
{
assert(_queue.size() != 0);
if (_messages.size() >= _detector.getMajority()) {
_state=COMMITTED;
emit(new Success(_seqNum,_rndNumber,_queue.get(0),_transport.getLocalAddress()));
}
 else {
emit(new Begin(_seqNum,_rndNumber,_queue.get(0),_transport.getLocalAddress()));
}
break;
}
case COMMITTED:
{
assert(_queue.size() != 0);
if (_messages.size() >= _detector.getMajority()) {
successful(Event.Reason.DECISION,null);
}
 else {
emit(new Success(_seqNum,_rndNumber,_queue.get(0),_transport.getLocalAddress()));
}
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + _state);
}
}","/** 
 * Do actions for the state we are now in.  Essentially, we're always one state ahead of the participants thus we process the result of a Collect in the BEGIN state which means we expect Last or OldRound and in SUCCESS state we expect ACCEPT or OLDROUND
 * @todo Increment round number via heartbeats every so often - see note below about jittering collects.
 */
private void process(){
switch (_state) {
case ABORT:
{
      assert(_queue.size() != 0);
      _logger.info(this + ""String_Node_Str"" + _event,new RuntimeException());
      _messages.clear();
      if (_membership != null)       _membership.dispose();
      while (_queue.size() > 0) {
        _al.signal(new Event(_event.getResult(),_event.getSeqNum(),_queue.remove(0)));
      }
      return;
    }
case EXIT:
{
    assert(_queue.size() != 0);
    _logger.info(this + ""String_Node_Str"" + _event);
    _messages.clear();
    _queue.remove(0);
    if (_membership != null)     _membership.dispose();
    if (_queue.size() > 0) {
      _logger.info(this + ""String_Node_Str"" + _queue.get(0));
      _state=SUBMITTED;
      process();
    }
 else {
      _heartbeatAlarm=new TimerTask(){
        public void run(){
          _logger.info(this + ""String_Node_Str"" + System.currentTimeMillis());
          submit(AcceptorLearner.HEARTBEAT);
        }
      }
;
      _watchdog.schedule(_heartbeatAlarm,calculateLeaderRefresh());
    }
    return;
  }
case SUBMITTED:
{
  assert(_queue.size() != 0);
  _tries=0;
  _membership=_detector.getMembers(this);
  _logger.info(this + ""String_Node_Str"" + _membership.getSize()+ ""String_Node_Str"");
  _state=COLLECT;
  process();
  break;
}
case COLLECT:
{
assert(_queue.size() != 0);
if (_heartbeatAlarm != null) _heartbeatAlarm.cancel();
Collect myLastCollect=_al.getLastCollect();
if (myLastCollect.isInitial()) {
  _logger.info(this + ""String_Node_Str"");
  _rndNumber=myLastCollect.getRndNumber() + 1;
}
 else {
  InetSocketAddress myOtherLeader=myLastCollect.getNodeId();
  boolean isUs=myOtherLeader.equals(_transport.getLocalAddress());
  if (!isUs) {
    _logger.info(this + ""String_Node_Str"");
    if (_detector.isLive(myOtherLeader)) {
      _logger.info(this + ""String_Node_Str"");
      error(Event.Reason.OTHER_LEADER,myOtherLeader);
      return;
    }
 else {
      _logger.info(this + ""String_Node_Str"");
      if (_rndNumber <= myLastCollect.getRndNumber())       _rndNumber=myLastCollect.getRndNumber() + 1;
    }
  }
}
if (_seqNum == AcceptorLearner.UNKNOWN_SEQ) _seqNum=0;
 else _seqNum=_seqNum + 1;
_state=BEGIN;
emit(new Collect(_seqNum,_rndNumber,_transport.getLocalAddress()));
break;
}
case BEGIN:
{
assert(_queue.size() != 0);
long myMaxProposal=-1;
ConsolidatedValue myValue=null;
for (PaxosMessage m : _messages) {
Last myLast=(Last)m;
if (!myLast.getConsolidatedValue().equals(LogStorage.NO_VALUE)) {
  if (myLast.getRndNumber() > myMaxProposal) {
    myValue=myLast.getConsolidatedValue();
    myMaxProposal=myLast.getRndNumber();
  }
}
}
if ((myValue != null) && (!myValue.equals(_queue.get(0)))) _queue.add(myValue);
_state=SUCCESS;
emit(new Begin(_seqNum,_rndNumber,_queue.get(0),_transport.getLocalAddress()));
break;
}
case SUCCESS:
{
assert(_queue.size() != 0);
if (_messages.size() >= _detector.getMajority()) {
_state=COMMITTED;
emit(new Success(_seqNum,_rndNumber,_queue.get(0),_transport.getLocalAddress()));
}
 else {
emit(new Begin(_seqNum,_rndNumber,_queue.get(0),_transport.getLocalAddress()));
}
break;
}
case COMMITTED:
{
assert(_queue.size() != 0);
if (_messages.size() >= _detector.getMajority()) {
successful(Event.Reason.DECISION,null);
}
 else {
emit(new Success(_seqNum,_rndNumber,_queue.get(0),_transport.getLocalAddress()));
}
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + _state);
}
}"
87259,"@Test public void test() throws Exception {
  HowlLogger myLogger=new HowlLogger(DIRECTORY);
  TransportImpl myTransport=new TransportImpl(_nodeId,_broadcastId);
  AcceptorLearner myAl=new AcceptorLearner(myLogger,new NullFailureDetector(),myTransport,0);
  Assert.assertFalse(myAl.isRecovering());
  long myRndNum=1;
  long mySeqNum=0;
  myAl.messageReceived(new Collect(mySeqNum,myRndNum,_nodeId));
  PaxosMessage myResponse=myTransport.getNextMsg();
  Assert.assertTrue(myResponse.getType() == Operations.LAST);
  byte[] myData=new byte[]{1};
  ConsolidatedValue myValue=new ConsolidatedValue(myData,HANDBACK);
  myAl.messageReceived(new Begin(mySeqNum,myRndNum,myValue,_nodeId));
  myResponse=myTransport.getNextMsg();
  Assert.assertTrue(myResponse.getType() == Operations.ACCEPT);
  myAl.messageReceived(new Success(mySeqNum,myRndNum + 1,myValue,_nodeId));
  myResponse=myTransport.getNextMsg();
  Assert.assertTrue(myResponse.getType() == Operations.ACK);
  myAl.messageReceived(new Collect(mySeqNum + 5,myRndNum + 2,_nodeId));
  Assert.assertTrue(myAl.isRecovering());
  Need myNeed=(Need)myTransport.getNextMsg();
  Assert.assertEquals(myNeed.getNodeId(),myTransport.getLocalAddress());
  Assert.assertEquals(myNeed.getMinSeq(),0);
  Assert.assertEquals(myNeed.getMaxSeq(),mySeqNum + 4);
  myAl.close();
}","@Test public void test() throws Exception {
  HowlLogger myLogger=new HowlLogger(DIRECTORY);
  TransportImpl myTransport=new TransportImpl(_nodeId,_broadcastId);
  AcceptorLearner myAl=new AcceptorLearner(myLogger,new NullFailureDetector(),myTransport,0);
  Assert.assertFalse(myAl.isRecovering());
  long myRndNum=1;
  long mySeqNum=0;
  myAl.messageReceived(new Collect(mySeqNum,myRndNum,_nodeId));
  PaxosMessage myResponse=myTransport.getNextMsg();
  Assert.assertTrue(myResponse.getType() == Operations.LAST);
  byte[] myData=new byte[]{1};
  ConsolidatedValue myValue=new ConsolidatedValue(myData,HANDBACK);
  myAl.messageReceived(new Begin(mySeqNum,myRndNum,myValue,_nodeId));
  myResponse=myTransport.getNextMsg();
  Assert.assertTrue(myResponse.getType() == Operations.ACCEPT);
  myAl.messageReceived(new Success(mySeqNum,myRndNum,myValue,_nodeId));
  myResponse=myTransport.getNextMsg();
  Assert.assertTrue(myResponse.getType() == Operations.ACK);
  myAl.messageReceived(new Collect(mySeqNum + 5,myRndNum + 2,_nodeId));
  Assert.assertTrue(myAl.isRecovering());
  Need myNeed=(Need)myTransport.getNextMsg();
  Assert.assertEquals(myNeed.getNodeId(),myTransport.getLocalAddress());
  Assert.assertEquals(myNeed.getMinSeq(),0);
  Assert.assertEquals(myNeed.getMaxSeq(),mySeqNum + 4);
  myAl.close();
}"
87260,"public long getNodeId(){
  return 0;
}","public long getNodeId(){
  return _nodeId;
}"
87261,"public void send(PaxosMessage aMessage,NodeId anAddress){
  PaxosMessage myMessage;
switch (aMessage.getType()) {
case Operations.COLLECT:
case Operations.BEGIN:
case Operations.SUCCESS:
{
      myMessage=new ProposerHeader(aMessage,_addr.getPort());
      break;
    }
default :
{
    myMessage=aMessage;
    break;
  }
}
IoSession mySession=(IoSession)_sessions.get(anAddress);
if (mySession != null) {
try {
  ConnectFuture connFuture=_unicastConnector.connect(NodeId.toAddress(anAddress));
  connFuture.awaitUninterruptibly();
  IoSession myNewSession=connFuture.getSession();
  mySession=_sessions.putIfAbsent(anAddress,myNewSession);
  if (mySession == null)   mySession=myNewSession;
 else {
    myNewSession.close();
  }
}
 catch (Exception anE) {
  throw new RuntimeException(""String_Node_Str"",anE);
}
}
mySession.write(myMessage);
}","public void send(PaxosMessage aMessage,NodeId anAddress){
  PaxosMessage myMessage;
switch (aMessage.getType()) {
case Operations.COLLECT:
case Operations.BEGIN:
case Operations.SUCCESS:
{
      myMessage=new ProposerHeader(aMessage,_addr.getPort());
      break;
    }
default :
{
    myMessage=aMessage;
    break;
  }
}
IoSession mySession=(IoSession)_sessions.get(anAddress);
if (mySession == null) {
try {
  ConnectFuture connFuture=_unicastConnector.connect(NodeId.toAddress(anAddress));
  connFuture.awaitUninterruptibly();
  IoSession myNewSession=connFuture.getSession();
  mySession=_sessions.putIfAbsent(anAddress,myNewSession);
  if (mySession == null)   mySession=myNewSession;
 else {
    myNewSession.close();
  }
}
 catch (Exception anE) {
  throw new RuntimeException(""String_Node_Str"",anE);
}
}
mySession.write(myMessage);
}"
87262,"/** 
 * @param aMessage is an OldRound message received from some other node
 */
private void oldRound(PaxosMessage aMessage){
  failed();
  OldRound myOldRound=(OldRound)aMessage;
  NodeId myCompetingNodeId=NodeId.from(myOldRound.getNodeId());
  updateRndNumber(myOldRound);
  if (myCompetingNodeId.leads(_nodeId)) {
    _logger.info(""String_Node_Str"" + myCompetingNodeId + ""String_Node_Str""+ _nodeId);
    error(Event.Reason.OTHER_LEADER,myCompetingNodeId);
    return;
  }
  _stage=COLLECT;
  process();
}","/** 
 * @todo Fixup the leader conflict behaviour. Right now we'd keep trying and falling down a hole as anotherleader will hold the lease and we'll get silence. But a client potentially resubmits to us because it still thinks we should be leader. We potentially have to check with our on AccepterLearner as to whether it thinks there is another leader (factoring in heartbeat activity) and if there is, redirect the client to  that. Otherwise we could try to become leader. This would allow us to ignore the ""superior node"" conflict as either clients think we are superior or some other node is and if each time either leader fails the clients need to re-check for a new leader (or we could tell them in the failure message) we'll settle eventually. Note we'll have to review the leader checking tests.
 * @param aMessage is an OldRound message received from some other node
 */
private void oldRound(PaxosMessage aMessage){
  failed();
  OldRound myOldRound=(OldRound)aMessage;
  NodeId myCompetingNodeId=NodeId.from(myOldRound.getNodeId());
  updateRndNumber(myOldRound);
  if (myCompetingNodeId.leads(_nodeId)) {
    _logger.info(""String_Node_Str"" + myCompetingNodeId + ""String_Node_Str""+ _nodeId);
    error(Event.Reason.OTHER_LEADER,myCompetingNodeId);
    return;
  }
  _stage=COLLECT;
  process();
}"
87263,"public PaxosMessage process(PaxosMessage aMessage){
  long myCurrentTime=System.currentTimeMillis();
  long mySeqNum=aMessage.getSeqNum();
  _logger.info(""String_Node_Str"" + mySeqNum + ""String_Node_Str""+ aMessage);
switch (aMessage.getType()) {
case Operations.COLLECT:
{
      Collect myCollect=(Collect)aMessage;
      if (!amAccepting(myCollect,myCurrentTime)) {
        _ignoredCollects.incrementAndGet();
        _logger.info(""String_Node_Str"" + myCollect + ""String_Node_Str""+ getIgnoredCollectsCount());
        return null;
      }
      Collect myOld=supercedes(myCollect);
      if (myOld != null) {
        updateLastActionTime(myCurrentTime);
        return new Last(mySeqNum,getLowWatermark(),getHighWatermark(),myOld.getRndNumber(),getStorage().get(mySeqNum));
      }
 else {
        Collect myLastCollect=getLastCollect();
        return new OldRound(mySeqNum,myLastCollect.getNodeId(),myLastCollect.getRndNumber());
      }
    }
case Operations.BEGIN:
{
    Begin myBegin=(Begin)aMessage;
    if (originates(myBegin)) {
      updateLastActionTime(myCurrentTime);
      updateHighWatermark(myBegin.getSeqNum());
      return new Accept(mySeqNum,getLastCollect().getRndNumber());
    }
 else     if (precedes(myBegin)) {
      Collect myLastCollect=getLastCollect();
      return new OldRound(mySeqNum,myLastCollect.getNodeId(),myLastCollect.getRndNumber());
    }
 else {
      _logger.info(""String_Node_Str"" + mySeqNum + ""String_Node_Str""+ myBegin.getRndNumber()+ ""String_Node_Str"");
    }
  }
case Operations.SUCCESS:
{
  Success mySuccess=(Success)aMessage;
  _logger.info(""String_Node_Str"" + mySuccess.getSeqNum());
  getStorage().put(mySeqNum,mySuccess.getValue());
  updateLastActionTime(myCurrentTime);
  updateLowWatermark(mySuccess.getSeqNum());
  updateHighWatermark(mySuccess.getSeqNum());
  signal(new Completion(Reasons.OK,mySuccess.getSeqNum(),mySuccess.getValue()));
  return new Ack(mySuccess.getSeqNum());
}
default :
throw new RuntimeException(""String_Node_Str"");
}
}","public PaxosMessage process(PaxosMessage aMessage){
  long myCurrentTime=System.currentTimeMillis();
  long mySeqNum=aMessage.getSeqNum();
  _logger.info(""String_Node_Str"" + mySeqNum + ""String_Node_Str""+ aMessage);
switch (aMessage.getType()) {
case Operations.COLLECT:
{
      Collect myCollect=(Collect)aMessage;
      if (!amAccepting(myCollect,myCurrentTime)) {
        _ignoredCollects.incrementAndGet();
        _logger.info(""String_Node_Str"" + myCollect + ""String_Node_Str""+ getIgnoredCollectsCount());
        return null;
      }
      Collect myOld=supercedes(myCollect);
      if (myOld != null) {
        updateLastActionTime(myCurrentTime);
        return new Last(mySeqNum,getLowWatermark(),getHighWatermark(),myOld.getRndNumber(),getStorage().get(mySeqNum));
      }
 else {
        Collect myLastCollect=getLastCollect();
        return new OldRound(mySeqNum,myLastCollect.getNodeId(),myLastCollect.getRndNumber());
      }
    }
case Operations.BEGIN:
{
    Begin myBegin=(Begin)aMessage;
    if (originates(myBegin)) {
      updateLastActionTime(myCurrentTime);
      updateHighWatermark(myBegin.getSeqNum());
      return new Accept(mySeqNum,getLastCollect().getRndNumber());
    }
 else     if (precedes(myBegin)) {
      Collect myLastCollect=getLastCollect();
      return new OldRound(mySeqNum,myLastCollect.getNodeId(),myLastCollect.getRndNumber());
    }
 else {
      _logger.info(""String_Node_Str"" + mySeqNum + ""String_Node_Str""+ myBegin.getRndNumber()+ ""String_Node_Str"");
    }
  }
case Operations.SUCCESS:
{
  Success mySuccess=(Success)aMessage;
  _logger.info(""String_Node_Str"" + mySuccess.getSeqNum());
  updateLastActionTime(myCurrentTime);
  updateLowWatermark(mySuccess.getSeqNum());
  updateHighWatermark(mySuccess.getSeqNum());
  Completion myCompletion=new Completion(Reasons.OK,mySuccess.getSeqNum(),mySuccess.getValue());
  if (notHeartbeat(myCompletion.getValue())) {
    getStorage().put(mySeqNum,mySuccess.getValue());
    signal(myCompletion);
  }
 else {
    _receivedHeartbeats.incrementAndGet();
    _logger.info(""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str""+ getHeartbeatCount());
  }
  return new Ack(mySuccess.getSeqNum());
}
default :
throw new RuntimeException(""String_Node_Str"");
}
}"
87264,"public void allReceived(){
  _activeAlarm.cancel();
synchronized (this) {
    process();
  }
}","public void allReceived(){
  _interactionAlarm.cancel();
synchronized (this) {
    process();
  }
}"
87265,"/** 
 * Do actions for the state we are now in.  Essentially, we're always one state ahead of the participants thus we process the result of a Collect in the BEGIN state which means we expect Last or OldRound and in SUCCESS state we expect ACCEPT or OLDROUND
 */
private void process(){
switch (_stage) {
case ABORT:
case EXIT:
{
      _logger.info(""String_Node_Str"" + _completion);
      if (_membership != null)       _membership.dispose();
      if (_stage != EXIT) {
        _al.signal(_completion);
      }
      return;
    }
case SUBMITTED:
{
    _membership=_detector.getMembers(this);
    _logger.info(""String_Node_Str"" + Long.toHexString(_seqNum) + ""String_Node_Str""+ _membership.getSize()+ ""String_Node_Str"");
    _stage=COLLECT;
    process();
    break;
  }
case COLLECT:
{
  if ((!isLeader()) && (!isRecovery())) {
    Collect myLastCollect=_al.getLastCollect();
    if (!myLastCollect.isInitial()) {
      NodeId myOtherLeader=NodeId.from(myLastCollect.getNodeId());
      if (_detector.isLive(myOtherLeader)) {
        error(Reasons.OTHER_LEADER,myOtherLeader);
      }
    }
    updateRndNumber(myLastCollect.getRndNumber());
    _seqNum=_al.getLowWatermark();
    if (_seqNum == LogStorage.EMPTY_LOG)     _seqNum=0;
    _stage=RECOVER;
    emitCollect();
  }
 else   if (isRecovery()) {
    ++_seqNum;
    if (_seqNum > _highWatermark) {
      notRecovery();
      amLeader();
      _logger.info(""String_Node_Str"");
      _value=_clientOp.getConsolidatedValue();
      _stage=BEGIN;
      process();
    }
 else {
      _value=LogStorage.NO_VALUE;
      _stage=BEGIN;
      emitCollect();
    }
  }
 else   if (isLeader()) {
    _logger.info(""String_Node_Str"");
    _value=_clientOp.getConsolidatedValue();
    ++_seqNum;
    _stage=BEGIN;
    process();
  }
  break;
}
case RECOVER:
{
long myMinSeq=-1;
long myMaxSeq=-1;
Iterator<PaxosMessage> myMessages=_messages.iterator();
while (myMessages.hasNext()) {
  PaxosMessage myMessage=myMessages.next();
  if (myMessage.getType() == Operations.OLDROUND) {
    oldRound(myMessage);
    return;
  }
 else {
    Last myLast=(Last)myMessage;
    long myLow=myLast.getLowWatermark();
    long myHigh=myLast.getHighWatermark();
    if (myLow != LogStorage.EMPTY_LOG) {
      if (myLow < myMinSeq)       myMinSeq=myLow;
    }
    if (myHigh != LogStorage.EMPTY_LOG) {
      if (myHigh > myMaxSeq) {
        myMaxSeq=myHigh;
      }
    }
  }
}
amRecovery();
_lowWatermark=myMinSeq;
_highWatermark=myMaxSeq;
if (_lowWatermark == -1) _seqNum=-1;
 else _seqNum=_lowWatermark - 1;
_logger.info(""String_Node_Str"" + _lowWatermark + ""String_Node_Str""+ _highWatermark+ ""String_Node_Str""+ _seqNum+ ""String_Node_Str"");
_stage=COLLECT;
process();
break;
}
case BEGIN:
{
byte[] myValue=_value;
if (!isLeader()) {
long myMaxRound=0;
Iterator<PaxosMessage> myMessages=_messages.iterator();
while (myMessages.hasNext()) {
  PaxosMessage myMessage=myMessages.next();
  if (myMessage.getType() == Operations.OLDROUND) {
    oldRound(myMessage);
    return;
  }
 else {
    Last myLast=(Last)myMessage;
    if (myLast.getRndNumber() > myMaxRound) {
      myMaxRound=myLast.getRndNumber();
      myValue=myLast.getValue();
    }
  }
}
}
_value=myValue;
emitBegin();
_stage=SUCCESS;
break;
}
case SUCCESS:
{
int myAcceptCount=0;
Iterator<PaxosMessage> myMessages=_messages.iterator();
while (myMessages.hasNext()) {
PaxosMessage myMessage=myMessages.next();
if (myMessage.getType() == Operations.OLDROUND) {
oldRound(myMessage);
return;
}
 else {
myAcceptCount++;
}
}
if (myAcceptCount >= _membership.getMajority()) {
emitSuccess();
_stage=COMMITTED;
}
 else {
emitBegin();
_stage=SUCCESS;
}
break;
}
case COMMITTED:
{
if (_messages.size() >= _membership.getMajority()) {
successful(Reasons.OK,null);
}
 else {
emitSuccess();
_stage=COMMITTED;
}
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + _stage);
}
}","/** 
 * Do actions for the state we are now in.  Essentially, we're always one state ahead of the participants thus we process the result of a Collect in the BEGIN state which means we expect Last or OldRound and in SUCCESS state we expect ACCEPT or OLDROUND
 */
private void process(){
switch (_stage) {
case ABORT:
{
      _logger.info(""String_Node_Str"" + _completion);
      if (_membership != null)       _membership.dispose();
      _al.signal(_completion);
      return;
    }
case EXIT:
{
    _logger.info(""String_Node_Str"" + _completion);
    if (_membership != null)     _membership.dispose();
    if (isRecovery()) {
      _stage=SUBMITTED;
      process();
    }
 else {
      _heartbeatAlarm=new HeartbeatTask();
      _watchdog.schedule(_heartbeatAlarm,calculateLeaderRefresh());
    }
    return;
  }
case SUBMITTED:
{
  _membership=_detector.getMembers(this);
  _logger.info(""String_Node_Str"" + Long.toHexString(_seqNum) + ""String_Node_Str""+ _membership.getSize()+ ""String_Node_Str"");
  _stage=COLLECT;
  process();
  break;
}
case COLLECT:
{
if ((!isLeader()) && (!isRecovery())) {
  _logger.info(""String_Node_Str"");
  Collect myLastCollect=_al.getLastCollect();
  if (!myLastCollect.isInitial()) {
    NodeId myOtherLeader=NodeId.from(myLastCollect.getNodeId());
    if (_detector.isLive(myOtherLeader)) {
      error(Reasons.OTHER_LEADER,myOtherLeader);
    }
  }
  _logger.info(""String_Node_Str"");
  updateRndNumber(myLastCollect.getRndNumber());
  _seqNum=_al.getLowWatermark();
  if (_seqNum == LogStorage.EMPTY_LOG)   _seqNum=0;
  _stage=RECOVER;
  emitCollect();
}
 else if (isRecovery()) {
  ++_seqNum;
  if (_seqNum > _highWatermark) {
    notRecovery();
    amLeader();
    _logger.info(""String_Node_Str"");
    _value=_clientOp.getConsolidatedValue();
    _stage=BEGIN;
    process();
  }
 else {
    _value=LogStorage.NO_VALUE;
    _stage=BEGIN;
    emitCollect();
  }
}
 else if (isLeader()) {
  _logger.info(""String_Node_Str"");
  _value=_clientOp.getConsolidatedValue();
  ++_seqNum;
  _stage=BEGIN;
  process();
}
break;
}
case RECOVER:
{
long myMinSeq=-1;
long myMaxSeq=-1;
Iterator<PaxosMessage> myMessages=_messages.iterator();
while (myMessages.hasNext()) {
PaxosMessage myMessage=myMessages.next();
if (myMessage.getType() == Operations.OLDROUND) {
  oldRound(myMessage);
  return;
}
 else {
  Last myLast=(Last)myMessage;
  long myLow=myLast.getLowWatermark();
  long myHigh=myLast.getHighWatermark();
  if (myLow != LogStorage.EMPTY_LOG) {
    if (myLow < myMinSeq)     myMinSeq=myLow;
  }
  if (myHigh != LogStorage.EMPTY_LOG) {
    if (myHigh > myMaxSeq) {
      myMaxSeq=myHigh;
    }
  }
}
}
amRecovery();
_lowWatermark=myMinSeq;
_highWatermark=myMaxSeq;
if (_lowWatermark == -1) _seqNum=-1;
 else _seqNum=_lowWatermark - 1;
_logger.info(""String_Node_Str"" + _lowWatermark + ""String_Node_Str""+ _highWatermark+ ""String_Node_Str""+ _seqNum+ ""String_Node_Str"");
_stage=COLLECT;
process();
break;
}
case BEGIN:
{
byte[] myValue=_value;
if (!isLeader()) {
long myMaxRound=0;
Iterator<PaxosMessage> myMessages=_messages.iterator();
while (myMessages.hasNext()) {
PaxosMessage myMessage=myMessages.next();
if (myMessage.getType() == Operations.OLDROUND) {
  oldRound(myMessage);
  return;
}
 else {
  Last myLast=(Last)myMessage;
  if (myLast.getRndNumber() > myMaxRound) {
    myMaxRound=myLast.getRndNumber();
    myValue=myLast.getValue();
  }
}
}
}
_value=myValue;
emitBegin();
_stage=SUCCESS;
break;
}
case SUCCESS:
{
int myAcceptCount=0;
Iterator<PaxosMessage> myMessages=_messages.iterator();
while (myMessages.hasNext()) {
PaxosMessage myMessage=myMessages.next();
if (myMessage.getType() == Operations.OLDROUND) {
oldRound(myMessage);
return;
}
 else {
myAcceptCount++;
}
}
if (myAcceptCount >= _membership.getMajority()) {
emitSuccess();
_stage=COMMITTED;
}
 else {
emitBegin();
_stage=SUCCESS;
}
break;
}
case COMMITTED:
{
if (_messages.size() >= _membership.getMajority()) {
successful(Reasons.OK,null);
}
 else {
emitSuccess();
_stage=COMMITTED;
}
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + _stage);
}
}"
87266,"/** 
 * @todo If we get ABORT, we could try a new round from scratch or make the client re-submit or .....
 */
public void abort(){
  _logger.info(""String_Node_Str"" + Long.toHexString(_seqNum));
  _activeAlarm.cancel();
synchronized (this) {
    failed();
    error(Reasons.BAD_MEMBERSHIP,null);
  }
}","/** 
 * @todo If we get ABORT, we could try a new round from scratch or make the client re-submit or .....
 */
public void abort(){
  _logger.info(""String_Node_Str"" + Long.toHexString(_seqNum));
  _interactionAlarm.cancel();
synchronized (this) {
    failed();
    error(Reasons.BAD_MEMBERSHIP,null);
  }
}"
87267,"private void startInteraction(){
  _activeAlarm=new Alarm();
  _watchdog.schedule(_activeAlarm,_watchdogTimeout);
  _membership.startInteraction();
}","private void startInteraction(){
  _interactionAlarm=new InteractionAlarm();
  _watchdog.schedule(_interactionAlarm,_watchdogTimeout);
  _membership.startInteraction();
}"
87268,"/** 
 * Do actions for the state we are now in.  Essentially, we're always one state ahead of the participants thus we process the result of a Collect in the BEGIN state which means we expect Last or OldRound and in SUCCESS state we expect ACCEPT or OLDROUND
 * @todo Check Last messages to compute minimum low and maximum high watermarks, then use them to perform recovery
 * @todo Ensure during recovery that BEGIN doesn't screw up the sequence number - perhaps during recovery prevent BEGIN from doingsequence number increments
 * @todo Handle all cases in SUCCEESS e.g. we don't properly process/wait for all Acks
 */
private void process(){
switch (_stage) {
case ABORT:
case EXIT:
{
      _logger.info(""String_Node_Str"" + Long.toHexString(_seqNum) + ""String_Node_Str""+ (_stage == EXIT));
      if (_stage == EXIT) {
        _transport.send(new Ack(_seqNum),_clientAddress);
      }
 else {
        _transport.send(new Fail(_seqNum,_reason),_clientAddress);
      }
      _membership.dispose();
      signalListeners();
      return;
    }
case COLLECT:
{
    _value=_clientPost.getValue();
    if (isLeader()) {
      _logger.info(""String_Node_Str"");
      _stage=BEGIN;
      process();
    }
 else {
      collect();
      _stage=BEGIN;
    }
    break;
  }
case BEGIN:
{
  byte[] myValue=_value;
  if (!isLeader()) {
    long myMaxRound=0;
    Iterator<PaxosMessage> myMessages=_messages.iterator();
    while (myMessages.hasNext()) {
      PaxosMessage myMessage=myMessages.next();
      if (myMessage.getType() == Operations.OLDROUND) {
        oldRound(myMessage);
        return;
      }
 else {
        Last myLast=(Last)myMessage;
        if (myLast.getRndNumber() > myMaxRound) {
          myMaxRound=myLast.getRndNumber();
          myValue=myLast.getValue();
        }
      }
    }
  }
  amLeader();
  _value=myValue;
  if (_seqNum == LogStorage.EMPTY_LOG) {
    _seqNum=-1;
  }
  begin();
  _stage=SUCCESS;
  break;
}
case SUCCESS:
{
int myAcceptCount=0;
Iterator<PaxosMessage> myMessages=_messages.iterator();
while (myMessages.hasNext()) {
  PaxosMessage myMessage=myMessages.next();
  if (myMessage.getType() == Operations.OLDROUND) {
    oldRound(myMessage);
    return;
  }
 else {
    myAcceptCount++;
  }
}
if (myAcceptCount >= _membership.getMajority()) {
  success();
  _stage=EXIT;
}
 else {
  begin();
  _stage=SUCCESS;
}
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + _stage);
}
}","/** 
 * Do actions for the state we are now in.  Essentially, we're always one state ahead of the participants thus we process the result of a Collect in the BEGIN state which means we expect Last or OldRound and in SUCCESS state we expect ACCEPT or OLDROUND
 * @todo Check Last messages to compute minimum low and maximum high watermarks, then use them to perform recovery
 * @todo Ensure during recovery that BEGIN doesn't screw up the sequence number - perhaps during recovery prevent BEGIN from doingsequence number increments
 * @todo Handle all cases in SUCCEESS e.g. we don't properly process/wait for all Acks
 */
private void process(){
switch (_stage) {
case ABORT:
case EXIT:
{
      _logger.info(""String_Node_Str"" + Long.toHexString(_seqNum) + ""String_Node_Str""+ (_stage == EXIT));
      if (_stage == EXIT) {
        _transport.send(new Ack(_seqNum),_clientAddress);
      }
 else {
        _transport.send(new Fail(_seqNum,_reason),_clientAddress);
      }
      _membership.dispose();
      signalListeners();
      return;
    }
case COLLECT:
{
    _value=_clientPost.getValue();
    if (_seqNum == LogStorage.EMPTY_LOG) {
      _seqNum=0;
    }
 else {
      ++_seqNum;
    }
    if (isLeader()) {
      _logger.info(""String_Node_Str"");
      _stage=BEGIN;
      process();
    }
 else {
      collect();
      _stage=BEGIN;
    }
    break;
  }
case BEGIN:
{
  byte[] myValue=_value;
  if (!isLeader()) {
    long myMaxRound=0;
    Iterator<PaxosMessage> myMessages=_messages.iterator();
    while (myMessages.hasNext()) {
      PaxosMessage myMessage=myMessages.next();
      if (myMessage.getType() == Operations.OLDROUND) {
        oldRound(myMessage);
        return;
      }
 else {
        Last myLast=(Last)myMessage;
        if (myLast.getRndNumber() > myMaxRound) {
          myMaxRound=myLast.getRndNumber();
          myValue=myLast.getValue();
        }
      }
    }
  }
  amLeader();
  _value=myValue;
  begin();
  _stage=SUCCESS;
  break;
}
case SUCCESS:
{
int myAcceptCount=0;
Iterator<PaxosMessage> myMessages=_messages.iterator();
while (myMessages.hasNext()) {
  PaxosMessage myMessage=myMessages.next();
  if (myMessage.getType() == Operations.OLDROUND) {
    oldRound(myMessage);
    return;
  }
 else {
    myAcceptCount++;
  }
}
if (myAcceptCount >= _membership.getMajority()) {
  success();
  _stage=EXIT;
}
 else {
  begin();
  _stage=SUCCESS;
}
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + _stage);
}
}"
87269,"private void begin(){
  _messages.clear();
  PaxosMessage myMessage=new Begin(++_seqNum,getRndNumber(),_nodeId,_value);
  startInteraction();
  _logger.info(""String_Node_Str"" + Long.toHexString(_seqNum));
  _transport.send(myMessage,Address.BROADCAST);
}","private void begin(){
  _messages.clear();
  PaxosMessage myMessage=new Begin(_seqNum,getRndNumber(),_nodeId,_value);
  startInteraction();
  _logger.info(""String_Node_Str"" + Long.toHexString(_seqNum));
  _transport.send(myMessage,Address.BROADCAST);
}"
87270,"/** 
 * @param aMessage is an OldRound message received from some other node
 */
private void oldRound(PaxosMessage aMessage){
  OldRound myOldRound=(OldRound)aMessage;
  long myCompetingNodeId=myOldRound.getNodeId();
  if (myCompetingNodeId > _nodeId) {
    _logger.info(""String_Node_Str"" + Long.toHexString(myCompetingNodeId) + ""String_Node_Str""+ Long.toHexString(_nodeId));
    notLeader();
    _stage=ABORT;
    _reason=Reasons.OTHER_LEADER;
    process();
    return;
  }
  updateRndNumber(myOldRound);
  _stage=COLLECT;
  collect();
}","/** 
 * @todo We may get oldround after we've sent begin and got some accepts, in such a case we need collect to know that wewere interrupted and the client value has already been submitted and thus doesn't need to be re-run post recovery. Note that any competing leader will first do a collect to increment the round number, it will not yet have proposed a value for a sequence number. Thus if we've received an accept from some node, it has yet to see the new leader and when it does see the leader will return the value we've proposed together with our round number.  Further if we've reached acceptance with our round number, ultimately our value will be used as recovery dictates the value from the highest previous round for a sequence number will be used by the leader.  We have one issue where some acceptor/learner did accept but we didn't get the message and thus can't tell the client value was processed.  What to do?
 * @param aMessage is an OldRound message received from some other node
 */
private void oldRound(PaxosMessage aMessage){
  OldRound myOldRound=(OldRound)aMessage;
  long myCompetingNodeId=myOldRound.getNodeId();
  notLeader();
  if (myCompetingNodeId > _nodeId) {
    _logger.info(""String_Node_Str"" + Long.toHexString(myCompetingNodeId) + ""String_Node_Str""+ Long.toHexString(_nodeId));
    _stage=ABORT;
    _reason=Reasons.OTHER_LEADER;
    process();
    return;
  }
  updateRndNumber(myOldRound);
  _stage=COLLECT;
  process();
}"
87271,"/** 
 * Do actions for the state we are now in.  Essentially, we're always one state ahead of the participants thus we process the result of a Collect in the BEGIN state which means we expect Last or OldRound and in SUCCESS state we expect ACCEPT or OLDROUND
 * @todo Check Last messages to compute minimum low and maximum high watermarks, then use them to perform recovery
 */
private void process(){
switch (_stage) {
case ABORT:
case EXIT:
{
      _logger.info(""String_Node_Str"" + _seqNum + ""String_Node_Str""+ (_stage == EXIT));
      _membership.dispose();
      if (_stage == EXIT) {
        _transport.send(new Ack(_seqNum),_clientAddress);
      }
 else {
        _transport.send(new Fail(_seqNum,_reason),_clientAddress);
      }
      signalListeners();
      return;
    }
case COLLECT:
{
    collect();
    break;
  }
case BEGIN:
{
  byte[] myValue=_value;
  if (!isLeader()) {
    long myMaxRound=0;
    Iterator<PaxosMessage> myMessages=_messages.iterator();
    while (myMessages.hasNext()) {
      PaxosMessage myMessage=myMessages.next();
      if (myMessage.getType() == Operations.OLDROUND) {
        oldRound(myMessage);
        return;
      }
 else {
        Last myLast=(Last)myMessage;
        if (myLast.getRndNumber() > myMaxRound) {
          myMaxRound=myLast.getRndNumber();
          myValue=myLast.getValue();
        }
      }
    }
  }
  amLeader();
  _value=myValue;
  if (_seqNum == LogStorage.EMPTY_LOG) {
    _seqNum=-1;
  }
  begin();
  break;
}
case SUCCESS:
{
int myAcceptCount=0;
Iterator<PaxosMessage> myMessages=_messages.iterator();
while (myMessages.hasNext()) {
  PaxosMessage myMessage=myMessages.next();
  if (myMessage.getType() == Operations.OLDROUND) {
    oldRound(myMessage);
    return;
  }
 else {
    myAcceptCount++;
  }
}
if (myAcceptCount >= _membership.getMajority()) {
  success();
}
 else {
  _stage=BEGIN;
  begin();
}
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + _stage);
}
}","/** 
 * Do actions for the state we are now in.  Essentially, we're always one state ahead of the participants thus we process the result of a Collect in the BEGIN state which means we expect Last or OldRound and in SUCCESS state we expect ACCEPT or OLDROUND
 * @todo Check Last messages to compute minimum low and maximum high watermarks, then use them to perform recovery
 * @todo Ensure during recovery that BEGIN doesn't screw up the sequence number - perhaps during recovery prevent BEGIN from doingsequence number increments
 * @todo Handle all cases in SUCCEESS e.g. we don't properly process/wait for all Acks
 */
private void process(){
switch (_stage) {
case ABORT:
case EXIT:
{
      _logger.info(""String_Node_Str"" + _seqNum + ""String_Node_Str""+ (_stage == EXIT));
      _membership.dispose();
      if (_stage == EXIT) {
        _transport.send(new Ack(_seqNum),_clientAddress);
      }
 else {
        _transport.send(new Fail(_seqNum,_reason),_clientAddress);
      }
      signalListeners();
      return;
    }
case COLLECT:
{
    collect();
    _stage=BEGIN;
    break;
  }
case BEGIN:
{
  byte[] myValue=_value;
  if (!isLeader()) {
    long myMaxRound=0;
    Iterator<PaxosMessage> myMessages=_messages.iterator();
    while (myMessages.hasNext()) {
      PaxosMessage myMessage=myMessages.next();
      if (myMessage.getType() == Operations.OLDROUND) {
        oldRound(myMessage);
        return;
      }
 else {
        Last myLast=(Last)myMessage;
        if (myLast.getRndNumber() > myMaxRound) {
          myMaxRound=myLast.getRndNumber();
          myValue=myLast.getValue();
        }
      }
    }
  }
  amLeader();
  _value=myValue;
  if (_seqNum == LogStorage.EMPTY_LOG) {
    _seqNum=-1;
  }
  begin();
  _stage=SUCCESS;
  break;
}
case SUCCESS:
{
int myAcceptCount=0;
Iterator<PaxosMessage> myMessages=_messages.iterator();
while (myMessages.hasNext()) {
  PaxosMessage myMessage=myMessages.next();
  if (myMessage.getType() == Operations.OLDROUND) {
    oldRound(myMessage);
    return;
  }
 else {
    myAcceptCount++;
  }
}
if (myAcceptCount >= _membership.getMajority()) {
  success();
  _stage=EXIT;
}
 else {
  begin();
  _stage=SUCCESS;
}
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + _stage);
}
}"
87272,"public void allReceived(){
  _activeAlarm.cancel();
synchronized (this) {
    _stage++;
    process();
  }
}","public void allReceived(){
  _activeAlarm.cancel();
synchronized (this) {
    process();
  }
}"
87273,"/** 
 * @param aMessage to process
 * @param aSenderAddress at which the sender of this message can be found
 */
public void process(PaxosMessage aMessage,Address aSenderAddress){
switch (aMessage.getType()) {
case Operations.POST:
{
      _logger.info(""String_Node_Str"");
      LeaderImpl myLeader=_state.newLeader(_transport,aSenderAddress);
      myLeader.messageReceived(aMessage,aSenderAddress);
      break;
    }
case Operations.LAST:
case Operations.ACCEPT:
case Operations.ACK:
{
    LeaderImpl myLeader=_state.getLeader(aMessage.getSeqNum());
    if (myLeader != null)     myLeader.messageReceived(aMessage,aSenderAddress);
 else {
      _logger.warn(""String_Node_Str"" + aMessage);
    }
    break;
  }
default :
throw new RuntimeException(""String_Node_Str"" + aMessage.getType());
}
}","/** 
 * @param aMessage to process
 * @param aSenderAddress at which the sender of this message can be found
 */
public void process(PaxosMessage aMessage,Address aSenderAddress){
switch (aMessage.getType()) {
case Operations.POST:
{
      _logger.info(""String_Node_Str"");
      LeaderImpl myLeader=_state.newLeader(_transport,aSenderAddress);
      myLeader.messageReceived(aMessage,aSenderAddress);
      break;
    }
case Operations.OLDROUND:
case Operations.LAST:
case Operations.ACCEPT:
case Operations.ACK:
{
    LeaderImpl myLeader=_state.getLeader(aMessage.getSeqNum());
    if (myLeader != null)     myLeader.messageReceived(aMessage,aSenderAddress);
 else {
      _logger.warn(""String_Node_Str"" + aMessage);
    }
    break;
  }
default :
throw new RuntimeException(""String_Node_Str"" + aMessage.getType());
}
}"
87274,"public void walkBackward(){
  listener.onStopWalkBackward(this);
  states.add(PlayerState.WALK_BACKWARD);
}","public void walkBackward(){
  listener.onWalkBackward(this);
  states.add(PlayerState.WALK_BACKWARD);
}"
87275,"public void update(long now){
  if (!activeWindow.isLoaded()) {
    return;
  }
 else   if (needReload) {
    fastReload();
  }
  if (Configuration.getInstance().isLanguageChanged()) {
    guiEvents.add(GUIEvent.LANGUAGE_CHANGED);
    Configuration.getInstance().setLanguageChanged(false);
  }
  if (Configuration.getInstance().isThemeChanged()) {
    guiEvents.add(GUIEvent.THEME_CHANGED);
    Configuration.getInstance().setThemeChanged(false);
  }
  superEvent=GUIEvent.NONE;
  List<View> components=new CopyOnWriteArrayList<View>(activeWindow.getViews());
  Context application=activeWindow.getApplication();
  components.add(application);
  updateEffects(now);
  updateApplication(application,now);
  updateActiveWindow(now);
  updateGui(components);
  updateMouse(components);
  keyboard.update(now);
  JoystickLoader.getInstance().update(now);
  if (enableFullScreen) {
    enableFullScreen=false;
    superEvent=GUIEvent.ENABLE_FULL_SCREEN;
  }
  if (disableFullScreen) {
    disableFullScreen=false;
    superEvent=GUIEvent.DISABLE_FULL_SCREEN;
  }
}","public void update(long now){
  if (!activeWindow.isLoaded()) {
    return;
  }
 else   if (needReload) {
    fastReload();
  }
  if (Configuration.getInstance().isLanguageChanged()) {
    guiEvents.add(GUIEvent.LANGUAGE_CHANGED);
    Configuration.getInstance().setLanguageChanged(false);
  }
  if (Configuration.getInstance().isThemeChanged()) {
    guiEvents.add(GUIEvent.THEME_CHANGED);
    Configuration.getInstance().setThemeChanged(false);
  }
  superEvent=GUIEvent.NONE;
  List<View> components=new CopyOnWriteArrayList<View>(activeWindow.getViews());
  Context application=activeWindow.getApplication();
  components.add(application);
  updateEffects(now);
  updateApplication(application,now);
  updateActiveWindow(now);
  updateGui(components,guiEvents);
  updateMouse(components);
  keyboard.update(now);
  JoystickLoader.getInstance().update(now);
  if (enableFullScreen) {
    enableFullScreen=false;
    superEvent=GUIEvent.ENABLE_FULL_SCREEN;
  }
  if (disableFullScreen) {
    disableFullScreen=false;
    superEvent=GUIEvent.DISABLE_FULL_SCREEN;
  }
}"
87276,"private GUIEvent updateMouse(View component,PointerEvent event){
  if (!component.isVisible()) {
    return GUIEvent.NONE;
  }
  if (component.onMouse(event)) {
    if (!component.isMouseOver()) {
      component.setMouseOver(true);
      setMouseOver(component);
    }
  }
 else {
    if (component.isMouseOver()) {
      component.setMouseOver(false);
      resetMouseOver();
    }
  }
  GUIEvent result=component.updateMouse(event);
  if (result != GUIEvent.NONE && result != null) {
    updateEvent(component,result);
    return result;
  }
  for (  View child : component.getViews()) {
    child.setOffset(component.getX(),component.getY());
    updateMouse(child,event);
    child.setOffset(-component.getX(),-component.getY());
  }
  return GUIEvent.NONE;
}","private GUIEvent updateMouse(View component,PointerEvent event){
  if (!component.isVisible()) {
    return GUIEvent.NONE;
  }
  if (component.isMouseOver()) {
    if (component != mouseOver) {
      setMouseOver(component);
    }
  }
 else   if (component == mouseOver) {
    resetMouseOver();
  }
  GUIEvent result=component.updateMouse(event);
  if (result != GUIEvent.NONE && result != null) {
    updateEvent(component,result);
    return result;
  }
  for (  View child : component.getViews()) {
    child.setOffset(component.getX(),component.getY());
    updateMouse(child,event);
    child.setOffset(-component.getX(),-component.getY());
  }
  return GUIEvent.NONE;
}"
87277,"private void updateGui(List<View> components){
  for (  GUIEvent event : guiEvents) {
    for (    View component : components) {
      updateGuiComponent(component,event);
    }
  }
  guiEvents.clear();
}","private void updateGui(List<View> components,List<GUIEvent> guiEvents){
  for (  GUIEvent event : guiEvents) {
    for (    View component : components) {
      updateGuiComponent(component,event);
    }
  }
  guiEvents.clear();
}"
87278,"public void draw(Graphic g){
  if (locked || needReload)   return;
  drawWindow(g,activeWindow);
  drawEffects(g);
  if (drawCursor) {
    mouse.draw(g);
  }
}","public void draw(Graphic g){
  if (locked || needReload)   return;
  drawWindow(g,activeWindow);
  drawGlobalEffects(g);
  if (drawCursor) {
    mouse.draw(g);
  }
}"
87279,"private void drawView(View component,Graphic g){
  if (component.isVisible()) {
    component.draw(g);
    List<View> components=new CopyOnWriteArrayList<View>(component.getViews());
    for (    View child : components) {
      child.setOffset(component.getX(),component.getY());
      drawView(child,g);
      child.setOffset(-component.getX(),-component.getY());
    }
  }
}","private void drawView(View component,Graphic g){
  component.draw(g);
  if (!component.getViews().isEmpty()) {
    List<View> components=new CopyOnWriteArrayList<View>(component.getViews());
    for (    View child : components) {
      child.setOffset(component.getX(),component.getY());
      drawView(child,g);
      child.setOffset(-component.getX(),-component.getY());
    }
  }
}"
87280,"public HIDController(InputListener listener){
  mouse=new Mouse(0,0);
  keyboard=new Keyboard(listener);
  keyboard.reset();
  joystick=JoystickLoader.getInstance();
  joystick.setListener(listener);
}","public HIDController(InputKeyListener listener){
  mouse=new Mouse(0,0);
  keyboard=new Keyboard(listener);
  keyboard.reset();
  joystick=JoystickLoader.getInstance();
  joystick.setListener(listener);
}"
87281,"public Keyboard(InputListener listener){
  super();
  this.listener=listener;
}","public Keyboard(InputKeyListener listener){
  super();
  this.listener=listener;
}"
87282,"public void setListener(InputListener listener){
  this.listener=listener;
}","public void setListener(InputKeyListener listener){
  this.listener=listener;
}"
87283,"public InputListener getListener(){
  return listener;
}","public InputKeyListener getListener(){
  return listener;
}"
87284,"public boolean nextFrame(){
  if ((currentFrame < frames - 1) && (currentFrame >= 0)) {
    currentFrame+=inc;
  }
 else {
    if (once) {
      visible=false;
      lockOnce=true;
      setFrame(currentFrame);
    }
 else {
      currentFrame=0;
    }
    return false;
  }
  if (!stopped) {
    setFrame(currentFrame);
  }
  return true;
}","public boolean nextFrame(){
  boolean hasNextFrame=true;
  if ((currentFrame < frames - 1) && (currentFrame >= 0)) {
    currentFrame+=inc;
  }
 else {
    if (once) {
      visible=false;
      lockOnce=true;
    }
 else {
      currentFrame=0;
    }
    hasNextFrame=false;
  }
  if (!stopped) {
    setFrame(currentFrame);
  }
  return hasNextFrame;
}"
87285,"public void loadApplication(){
  window.setLoaded(false);
  loader=new Loader();
  updater=new Updater();
  Future<?> future=loadExecutor.submit(loader);
  try {
    future.get();
  }
 catch (  ExecutionException e) {
    Throwable cause=e.getCause();
    cause.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  loadExecutor.scheduleAtFixedRate(updater,0,10,TimeUnit.MILLISECONDS);
}","public void loadApplication(){
  loadExecutor=Executors.newScheduledThreadPool(2);
  window.setLoaded(false);
  loader=new Loader();
  updater=new Updater();
  future=loadExecutor.submit(loader);
  loadExecutor.scheduleAtFixedRate(updater,0,UPDATE_INTERVAL,TimeUnit.MILLISECONDS);
}"
87286,"public void run(){
  if (!called) {
    if (!window.isLoaded()) {
      loadApplication.setText(application.getLoadingPhrase(),application.getLoading());
    }
  }
 else {
    window.setApplication(application);
    window.setLoaded(true);
  }
}","public void run(){
  if (!called) {
    if (!window.isLoaded()) {
      loadApplication.setText(application.getLoadingPhrase(),application.getLoading());
    }
  }
 else {
    try {
      future.get();
    }
 catch (    ExecutionException e) {
      Throwable cause=e.getCause();
      cause.printStackTrace();
    }
catch (    InterruptedException e) {
      e.printStackTrace();
    }
    window.setApplication(application);
    window.setLoaded(true);
    loadExecutor.shutdownNow();
  }
}"
87287,"public void loadApplication(){
  window.setLoaded(false);
  loader=new Loader();
  updater=new Updater();
  loadExecutor.submit(loader);
  loadExecutor.scheduleAtFixedRate(updater,0,10,TimeUnit.MILLISECONDS);
}","public void loadApplication(){
  window.setLoaded(false);
  loader=new Loader();
  updater=new Updater();
  Future<?> future=loadExecutor.submit(loader);
  try {
    future.get();
  }
 catch (  ExecutionException e) {
    Throwable cause=e.getCause();
    cause.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  loadExecutor.scheduleAtFixedRate(updater,0,10,TimeUnit.MILLISECONDS);
}"
87288,"/** 
 * @param buffer
 */
public void igualaImagem(BufferedImage buffer){
  buffer=new BufferedImage((int)w,(int)h,BufferedImage.TYPE_INT_ARGB);
  buffer.getGraphics().drawImage(buffer,0,0,null);
  w=buffer.getWidth();
  h=buffer.getHeight();
  resetImage();
}","/** 
 * @param buffer
 */
public void igualaImagem(BufferedImage buffer){
  this.buffer=new BufferedImage((int)w,(int)h,BufferedImage.TYPE_INT_ARGB);
  this.buffer.getGraphics().drawImage(buffer,0,0,null);
  w=buffer.getWidth();
  h=buffer.getHeight();
  resetImage();
}"
87289,"public void update(long now){
  if (Configuration.getInstance().isLanguageChanged()) {
    guiEvents.add(GUIEvent.LANGUAGE_CHANGED);
    Configuration.getInstance().setLanguageChanged(false);
  }
  if (Configuration.getInstance().isThemeChanged()) {
    guiEvents.add(GUIEvent.THEME_CHANGED);
    Configuration.getInstance().setThemeChanged(false);
  }
  superEvent=GUIEvent.NONE;
  List<View> components=new CopyOnWriteArrayList<View>(activeWindow.getViews());
  Context application=activeWindow.getApplication();
  components.add(application);
  application.update(getTimeNow());
  updateActiveWindow();
  updateGui(components);
  updateMouse(components);
  keyboard.update(now);
  JoystickLoader.getInstance().update(now);
  if (enableFullScreen) {
    enableFullScreen=false;
    superEvent=GUIEvent.ENABLE_FULL_SCREEN;
  }
  if (disableFullScreen) {
    disableFullScreen=false;
    superEvent=GUIEvent.DISABLE_FULL_SCREEN;
  }
}","public void update(long now){
  if (!activeWindow.isLoaded()) {
    return;
  }
  if (Configuration.getInstance().isLanguageChanged()) {
    guiEvents.add(GUIEvent.LANGUAGE_CHANGED);
    Configuration.getInstance().setLanguageChanged(false);
  }
  if (Configuration.getInstance().isThemeChanged()) {
    guiEvents.add(GUIEvent.THEME_CHANGED);
    Configuration.getInstance().setThemeChanged(false);
  }
  superEvent=GUIEvent.NONE;
  List<View> components=new CopyOnWriteArrayList<View>(activeWindow.getViews());
  Context application=activeWindow.getApplication();
  components.add(application);
  application.update(getTimeNow());
  updateActiveWindow();
  updateGui(components);
  updateMouse(components);
  keyboard.update(now);
  JoystickLoader.getInstance().update(now);
  if (enableFullScreen) {
    enableFullScreen=false;
    superEvent=GUIEvent.ENABLE_FULL_SCREEN;
  }
  if (disableFullScreen) {
    disableFullScreen=false;
    superEvent=GUIEvent.DISABLE_FULL_SCREEN;
  }
}"
87290,"public FadeOutAnimation(Layer target,long time){
  super(target,time);
  startValue=0;
  endValue=255;
}","public FadeOutAnimation(Layer target,long time){
  super(target,time);
  startValue=255;
  endValue=0;
}"
87291,"private Method getMethod(Class<?> cls,String methodName,Class<?>[] classes){
  for (  Method method : cls.getMethods()) {
    if (method.getName().equals(methodName)) {
      if (method.getParameterTypes().length == classes.length) {
        for (int i=0; i < classes.length; i++) {
          Class<?> clazz=method.getParameterTypes()[i];
          if (clazz.isPrimitive()) {
            String name=classes[i].getSimpleName().toLowerCase();
            String parameterName=method.getParameterTypes()[i].getName();
            if (!name.startsWith(parameterName)) {
              return null;
            }
          }
 else {
            if (!classes[i].getName().equals(method.getParameterTypes()[i].getComponentType())) {
              return null;
            }
          }
        }
        return method;
      }
    }
  }
  return null;
}","private Method getMethod(Class<?> cls,String methodName,Class<?>[] classes){
  for (  Method method : cls.getMethods()) {
    if (method.getName().equals(methodName)) {
      if (method.getParameterTypes().length == classes.length) {
        for (int i=0; i < classes.length; i++) {
          Class<?> clazz=method.getParameterTypes()[i];
          if (clazz.isPrimitive()) {
            String name=classes[i].getSimpleName().toLowerCase();
            String parameterName=method.getParameterTypes()[i].getName();
            if (!name.startsWith(parameterName)) {
              return null;
            }
          }
 else {
            Class<?> typ=method.getParameterTypes()[i].getComponentType();
            if (typ != null) {
              if (!classes[i].getName().equals(typ.getName())) {
                return null;
              }
            }
          }
        }
        return method;
      }
    }
  }
  return null;
}"
87292,"public void gerencia(){
  if (Configuration.getInstance().isLanguageChanged()) {
    guiEvents.add(GUIEvent.LANGUAGE_CHANGED);
    Configuration.getInstance().setLanguageChanged(false);
  }
  if (Configuration.getInstance().isThemeChanged()) {
    guiEvents.add(GUIEvent.THEME_CHANGED);
    Configuration.getInstance().setThemeChanged(false);
  }
  superEvent=GUIEvent.NONE;
  List<View> components=new CopyOnWriteArrayList<View>(activeWindow.getApplication().getViews());
  components.addAll(activeWindow.getViews());
  updateActiveWindow();
  updateGui(components);
  updateMouse(components);
  updateKeyboard();
  if (JoystickLoader.getInstance().isStarted()) {
    updateJoystick();
  }
  if (enableFullScreen) {
    enableFullScreen=false;
    superEvent=GUIEvent.ENABLE_FULL_SCREEN;
  }
  if (disableFullScreen) {
    disableFullScreen=false;
    superEvent=GUIEvent.DISABLE_FULL_SCREEN;
  }
}","public void gerencia(){
  if (Configuration.getInstance().isLanguageChanged()) {
    guiEvents.add(GUIEvent.LANGUAGE_CHANGED);
    Configuration.getInstance().setLanguageChanged(false);
  }
  if (Configuration.getInstance().isThemeChanged()) {
    guiEvents.add(GUIEvent.THEME_CHANGED);
    Configuration.getInstance().setThemeChanged(false);
  }
  superEvent=GUIEvent.NONE;
  List<View> components=new CopyOnWriteArrayList<View>(activeWindow.getViews());
  components.add(activeWindow.getApplication());
  updateActiveWindow();
  updateGui(components);
  updateMouse(components);
  updateKeyboard();
  if (JoystickLoader.getInstance().isStarted()) {
    updateJoystick();
  }
  if (enableFullScreen) {
    enableFullScreen=false;
    superEvent=GUIEvent.ENABLE_FULL_SCREEN;
  }
  if (disableFullScreen) {
    disableFullScreen=false;
    superEvent=GUIEvent.DISABLE_FULL_SCREEN;
  }
}"
87293,"private void updateKeyboardEvents(KeyEvent event){
  if (event.isKeyDown(KeyEvent.TSK_ALT_DIREITA) || event.isKeyDown(KeyEvent.TSK_ALT_ESQUERDA)) {
    alt=true;
  }
 else   if (event.isKeyUp(KeyEvent.TSK_ALT_DIREITA) || event.isKeyUp(KeyEvent.TSK_ALT_ESQUERDA)) {
    alt=false;
  }
  if (event.isKeyDown(KeyEvent.TSK_ENTER)) {
    enter=true;
  }
 else   if (event.isKeyUp(KeyEvent.TSK_ENTER)) {
    enter=false;
  }
  if (event.isKeyDown(KeyEvent.TSK_ESC)) {
    esc=true;
  }
 else   if (event.isKeyUp(KeyEvent.TSK_ESC)) {
    esc=false;
  }
  if (alt && enter) {
    alt=false;
    enter=false;
    enableFullScreen=true;
  }
  if (esc) {
    esc=false;
    if (fullScreenEnable) {
      disableFullScreen=true;
    }
  }
}","private void updateKeyboardEvents(KeyEvent event){
  if (event.isKeyDown(KeyEvent.TSK_ALT_DIREITA) || event.isKeyDown(KeyEvent.TSK_ALT_ESQUERDA)) {
    alt=true;
  }
 else   if (event.isKeyUp(KeyEvent.TSK_ALT_DIREITA) || event.isKeyUp(KeyEvent.TSK_ALT_ESQUERDA)) {
    alt=false;
  }
  if (event.isKeyDown(KeyEvent.TSK_ENTER)) {
    enter=true;
  }
 else   if (event.isKeyUp(KeyEvent.TSK_ENTER)) {
    enter=false;
  }
  if (event.isKeyDown(KeyEvent.TSK_ESC)) {
    esc=true;
  }
 else   if (event.isKeyUp(KeyEvent.TSK_ESC)) {
    esc=false;
  }
  if (alt && enter) {
    alt=false;
    enter=false;
    if (!fullScreenEnable) {
      enableFullScreen=true;
    }
  }
  if (esc) {
    esc=false;
    if (fullScreenEnable) {
      disableFullScreen=true;
    }
  }
}"
87294,"public void disableFullScreen(){
  telaCheia.dispose();
  telaCheia=null;
  innerCore.fullScreenEnable=false;
}","public void disableFullScreen(){
  telaCheia.dispose();
  innerCore.fullScreenEnable=false;
}"
87295,"private VolatileImage createBackBuffer(int largura,int altura,int transparency){
  return configuration.createCompatibleVolatileImage(largura,altura,transparency);
}","private VolatileImage createBackBuffer(int width,int height,int transparency){
  return configuration.createCompatibleVolatileImage(width,height,transparency);
}"
87296,"public void draw(BufferedImage volatileImage){
  int y=offsetY;
  BufferedImage resized=new BufferedImage(w,h,BufferedImage.TYPE_INT_RGB);
  Graphics2D g=resized.createGraphics();
  g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
  g.drawImage(volatileImage,0,y,w,h,0,0,volatileImage.getWidth(),y + volatileImage.getHeight(),null);
  g.dispose();
  getGraphics().drawImage(resized,0,0,null);
}","public void draw(BufferedImage volatileImage){
  int y=offsetY;
  BufferedImage resized=new BufferedImage(w,h,BufferedImage.TYPE_INT_RGB);
  Graphics2D g=resized.createGraphics();
  g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
  g.drawImage(volatileImage,0,y,w,h,0,0,volatileImage.getWidth(),y + volatileImage.getHeight(),null);
  g.dispose();
  getGraphics().drawImage(resized,0,0,null);
}"
87297,"public FullScreenWindow(EngineCore core){
  super(new Frame());
  Dimension ss=Toolkit.getDefaultToolkit().getScreenSize();
  this.core=core;
  setBounds(0,0,ss.width,ss.height);
  w=ss.width;
  h=ss.height;
  int wfactor=ss.width / 16;
  utilHeight=9 * wfactor;
  offsetY=(ss.height - utilHeight) / 2;
  hideCursor();
  setVisible(true);
  setAlwaysOnTop(true);
  setListeners();
}","public FullScreenWindow(EngineCore core){
  super(new Frame());
  Dimension ss=Toolkit.getDefaultToolkit().getScreenSize();
  this.core=core;
  setBounds(0,0,ss.width,ss.height);
  w=ss.width;
  h=ss.height;
  int wfactor=ss.width / 16;
  utilHeight=9 * wfactor;
  offsetY=(ss.height - utilHeight) / 2;
  core.hideCursor();
  setVisible(true);
  setAlwaysOnTop(true);
  setListeners();
}"
87298,"private void updateKeyboardEvents(KeyEvent event){
  if (event.isKeyDown(KeyEvent.TSK_ALT_DIREITA) || event.isKeyDown(KeyEvent.TSK_ALT_ESQUERDA)) {
    alt=true;
  }
 else   if (event.isKeyUp(KeyEvent.TSK_ALT_DIREITA) || event.isKeyUp(KeyEvent.TSK_ALT_ESQUERDA)) {
    alt=false;
  }
  if (event.isKeyDown(KeyEvent.TSK_ENTER)) {
    enter=true;
  }
 else   if (event.isKeyUp(KeyEvent.TSK_ENTER)) {
    enter=false;
  }
  if (event.isKeyDown(KeyEvent.TSK_ESC)) {
    esc=true;
  }
 else   if (event.isKeyUp(KeyEvent.TSK_ESC)) {
    esc=false;
  }
  if (alt && enter) {
    alt=false;
    enter=false;
    enableFullScreen=true;
  }
  if (esc) {
    esc=false;
    disableFullScreen=true;
  }
}","private void updateKeyboardEvents(KeyEvent event){
  if (event.isKeyDown(KeyEvent.TSK_ALT_DIREITA) || event.isKeyDown(KeyEvent.TSK_ALT_ESQUERDA)) {
    alt=true;
  }
 else   if (event.isKeyUp(KeyEvent.TSK_ALT_DIREITA) || event.isKeyUp(KeyEvent.TSK_ALT_ESQUERDA)) {
    alt=false;
  }
  if (event.isKeyDown(KeyEvent.TSK_ENTER)) {
    enter=true;
  }
 else   if (event.isKeyUp(KeyEvent.TSK_ENTER)) {
    enter=false;
  }
  if (event.isKeyDown(KeyEvent.TSK_ESC)) {
    esc=true;
  }
 else   if (event.isKeyUp(KeyEvent.TSK_ESC)) {
    esc=false;
  }
  if (alt && enter) {
    alt=false;
    enter=false;
    enableFullScreen=true;
  }
  if (esc) {
    esc=false;
    if (fullScreenEnable) {
      disableFullScreen=true;
    }
  }
}"
87299,"/** 
 * @param point
 * @param radius
 */
public void drawCircle(Ponto2D point,int radius){
  screen.drawOval((int)point.getX() - radius,(int)point.getY() - radius,radius * 2,radius * 2);
}","/** 
 * @param point
 * @param radius
 */
public void drawCircle(Point2D point,int radius){
  screen.drawOval((int)point.getX() - radius,(int)point.getY() - radius,radius * 2,radius * 2);
}"
87300,"/** 
 * @param p
 * @param q
 */
public void drawLine(Ponto2D p,Ponto2D q){
  screen.drawLine((int)p.getX(),(int)p.getY(),(int)q.getX(),(int)q.getY());
}","/** 
 * @param p
 * @param q
 */
public void drawLine(Point2D p,Point2D q){
  screen.drawLine((int)p.getX(),(int)p.getY(),(int)q.getX(),(int)q.getY());
}"
87301,"/** 
 * @param point
 * @param radius
 */
public void fillCircle(Ponto2D point,int radius){
  screen.fillOval((int)point.getX() - radius,(int)point.getY() - radius,radius * 2,radius * 2);
}","/** 
 * @param point
 * @param radius
 */
public void fillCircle(Point2D point,int radius){
  screen.fillOval((int)point.getX() - radius,(int)point.getY() - radius,radius * 2,radius * 2);
}"
87302,"private void initLoaders(){
  core.addLoader(ImageLoader.getInstance());
  core.addLoader(FontLoader.getInstance());
  core.initDefault();
}","private void initLoaders(){
  addLoader(ImageLoader.getInstance());
  addLoader(FontLoader.getInstance());
  core.setLoaders(loaders);
  core.initDefault();
}"
87303,"protected void addLoader(Loader loader){
  core.addLoader(loader);
}","protected void addLoader(Loader loader){
  loaders.add(loader);
}"
87304,"private void initLoaders(){
  core.addLoader(ImageLoader.getInstance());
  core.addLoader(FontLoader.getInstance());
  core.initDefault();
}","private void initLoaders(){
  addLoader(ImageLoader.getInstance());
  addLoader(FontLoader.getInstance());
  core.setLoaders(loaders);
  core.initDefault();
}"
87305,"protected void addLoader(Loader loader){
  core.addLoader(loader);
}","protected void addLoader(Loader loader){
  loaders.add(loader);
}"
87306,"private Method getMethod(Class<?> cls,String methodName,Class<?>[] classes){
  for (  Method method : cls.getMethods()) {
    if (method.getName().equals(methodName)) {
      if (method.getParameterTypes().length == classes.length) {
        for (int i=0; i < classes.length; i++) {
          Class<?> clazz=method.getParameterTypes()[i];
          if (clazz.isPrimitive()) {
            String name=classes[i].getSimpleName().toLowerCase();
            String parameterName=method.getParameterTypes()[i].getName();
            if (!name.equals(parameterName)) {
              return null;
            }
          }
 else {
            if (!classes[i].getName().equals(method.getParameterTypes()[i].getComponentType())) {
              return null;
            }
          }
        }
        return method;
      }
    }
  }
  return null;
}","private Method getMethod(Class<?> cls,String methodName,Class<?>[] classes){
  for (  Method method : cls.getMethods()) {
    if (method.getName().equals(methodName)) {
      if (method.getParameterTypes().length == classes.length) {
        for (int i=0; i < classes.length; i++) {
          Class<?> clazz=method.getParameterTypes()[i];
          if (clazz.isPrimitive()) {
            String name=classes[i].getSimpleName().toLowerCase();
            String parameterName=method.getParameterTypes()[i].getName();
            if (!name.startsWith(parameterName)) {
              return null;
            }
          }
 else {
            if (!classes[i].getName().equals(method.getParameterTypes()[i].getComponentType())) {
              return null;
            }
          }
        }
        return method;
      }
    }
  }
  return null;
}"
87307,"private void updateForcedEvents(List<GUIEvent> guiEvents){
  for (  GUIEvent event : guiEvents) {
    updateForcedEvent(event);
  }
}","private void updateForcedEvents(List<GUIEvent> guiEvents){
  for (  GUIEvent event : guiEvents) {
    updateForcedEvent(event);
  }
  guiEvents.clear();
}"
87308,"@Override public void update(GUIEvent event){
  if (event == GUIEvent.WINDOW_CLOSE) {
    close();
  }
}","@Override public void update(GUIEvent event){
  if (event == GUIEvent.APPLICATION_CHANGED) {
    changeApplication();
  }
  if (event == GUIEvent.WINDOW_CLOSE) {
    close();
  }
}"
87309,"private void gerenciaEvento(GUIComponent componente,GUIEvent lastEvent){
switch (lastEvent) {
case GAIN_FOCUS:
    if (focus != null) {
      focus.update(GUIEvent.LOST_FOCUS);
    }
  focus=componente;
break;
case LOST_FOCUS:
if (componente == focus) {
}
break;
case MOUSE_OVER:
if (!mouseOver) {
mouseOver=true;
mouseOverClickable=true;
}
break;
case MOUSE_OVER_WITH_FOCUS:
break;
case NEXT_COMPONENT:
System.out.println(""String_Node_Str"");
componente.update(GUIEvent.LOST_FOCUS);
break;
case WINDOW_CLOSE:
requestClose((Window)componente);
break;
case APPLICATION_CHANGED:
activeWindow.changeApplication(activeWindow.getApplication().getReturnApplication());
break;
default :
if (componente.isMouseOver()) {
componente.update(GUIEvent.MOUSE_OUT);
}
break;
}
componente.setLastEvent(lastEvent);
componente.update(lastEvent);
componente.executeAction(lastEvent);
}","private void gerenciaEvento(GUIComponent componente,GUIEvent lastEvent){
switch (lastEvent) {
case GAIN_FOCUS:
    if (focus != null) {
      focus.update(GUIEvent.LOST_FOCUS);
    }
  focus=componente;
break;
case LOST_FOCUS:
if (componente == focus) {
focus=null;
}
break;
case MOUSE_OVER:
if (!mouseOver) {
mouseOver=true;
mouseOverClickable=true;
}
break;
case MOUSE_OVER_WITH_FOCUS:
break;
case NEXT_COMPONENT:
System.out.println(""String_Node_Str"");
componente.update(GUIEvent.LOST_FOCUS);
break;
case WINDOW_CLOSE:
requestClose((Window)componente);
break;
case APPLICATION_CHANGED:
activeWindow.changeApplication(activeWindow.getApplication().getReturnApplication());
break;
default :
if (componente.isMouseOver()) {
componente.update(GUIEvent.MOUSE_OUT);
}
break;
}
componente.setLastEvent(lastEvent);
componente.update(lastEvent);
componente.executeAction(lastEvent);
}"
87310,"private void createProtocolTable(){
  TableModel tm=new AbstractTableModel(){
    public int getRowCount(){
      return 1 + _patterns.size();
    }
    public int getColumnCount(){
      return 2 + _responses.size();
    }
    private int getErrors(    int trial){
      int errors=0;
      for (int i=0, n=_patterns.size(); i < n; ++i) {
        if (_responses.get(trial).get(i).equals(_patterns.get(i).getSecond())) {
        }
 else {
          errors+=1;
        }
      }
      return errors;
    }
    public Object getValueAt(    int row,    int column){
      if (column == 0) {
        if (row == _patterns.size()) {
          return ""String_Node_Str"";
        }
 else {
          return _patterns.get(row).getFirst();
        }
      }
 else       if (column == 1) {
        if (row == _patterns.size()) {
          return ""String_Node_Str"";
        }
 else {
          return _patterns.get(row).getSecond();
        }
      }
 else {
        if (row == _patterns.size()) {
          return ""String_Node_Str"" + getErrors(column - 2);
        }
 else {
          return _responses.get(column - 2).get(row).toString();
        }
      }
    }
    public String getColumnName(    int column){
      if (column == 0) {
        return ""String_Node_Str"";
      }
 else       if (column == 1) {
        return ""String_Node_Str"";
      }
 else {
        return ""String_Node_Str"" + (column - 1);
      }
    }
    public void fireTableStructureChanged(){
      super.fireTableStructureChanged();
      _protocolHorizontalBar.setValue(_protocolHorizontalBar.getMaximum());
    }
  }
;
  _protocol=new JTable(tm);
  _protocol.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
}","private void createProtocolTable(){
  TableModel tm=new AbstractTableModel(){
    public int getRowCount(){
      return 1 + _patterns.size();
    }
    public int getColumnCount(){
      return 2 + _responses.size();
    }
    private int getErrors(    int trial){
      int errors=0;
      for (int i=0, n=_patterns.size(); i < n; ++i) {
        ListPattern target=_responses.get(trial).get(i).clone();
        ListPattern response=_patterns.get(i).getSecond().clone();
        target.setNotFinished();
        response.setNotFinished();
        if (response.equals(target)) {
        }
 else {
          errors+=1;
        }
      }
      return errors;
    }
    public Object getValueAt(    int row,    int column){
      if (column == 0) {
        if (row == _patterns.size()) {
          return ""String_Node_Str"";
        }
 else {
          return _patterns.get(row).getFirst();
        }
      }
 else       if (column == 1) {
        if (row == _patterns.size()) {
          return ""String_Node_Str"";
        }
 else {
          return _patterns.get(row).getSecond();
        }
      }
 else {
        if (row == _patterns.size()) {
          return ""String_Node_Str"" + getErrors(column - 2);
        }
 else {
          return _responses.get(column - 2).get(row).toString();
        }
      }
    }
    public String getColumnName(    int column){
      if (column == 0) {
        return ""String_Node_Str"";
      }
 else       if (column == 1) {
        return ""String_Node_Str"";
      }
 else {
        return ""String_Node_Str"" + (column - 1);
      }
    }
    public void fireTableStructureChanged(){
      super.fireTableStructureChanged();
      _protocolHorizontalBar.setValue(_protocolHorizontalBar.getMaximum());
    }
  }
;
  _protocol=new JTable(tm);
  _protocol.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
}"
87311,"private int getErrors(int trial){
  int errors=0;
  for (int i=0, n=_patterns.size(); i < n; ++i) {
    if (_responses.get(trial).get(i).equals(_patterns.get(i).getSecond())) {
    }
 else {
      errors+=1;
    }
  }
  return errors;
}","private int getErrors(int trial){
  int errors=0;
  for (int i=0, n=_patterns.size(); i < n; ++i) {
    ListPattern target=_responses.get(trial).get(i).clone();
    ListPattern response=_patterns.get(i).getSecond().clone();
    target.setNotFinished();
    response.setNotFinished();
    if (response.equals(target)) {
    }
 else {
      errors+=1;
    }
  }
  return errors;
}"
87312,"/** 
 * Try to move eye using LTM heuristic, return true if: -- square suggested by first child yields a piece which  allows model to follow a test link.
 */
private boolean ltmHeuristic(){
  if (_visualStm.getCount() >= 1) {
    List<Link> hypothesisChildren=_visualStm.getItem(0).getChildren();
    if (hypothesisChildren.isEmpty())     return false;
    ListPattern test=hypothesisChildren.get(0).getTest();
    if (test.isEmpty())     return false;
    Pattern first=test.getItem(0);
    if (first instanceof ItemSquarePattern) {
      ItemSquarePattern ios=(ItemSquarePattern)first;
      _fixationX=ios.getColumn() - 1;
      _fixationY=ios.getRow() - 1;
      for (      Link link : hypothesisChildren) {
        if (link.getTest().size() == 1) {
          if (link.getTest().getItem(0) instanceof ItemSquarePattern) {
            ItemSquarePattern testIos=(ItemSquarePattern)link.getTest().getItem(0);
            if (testIos.getColumn() - 1 == _fixationX && testIos.getRow() - 1 == _fixationY && testIos.getItem().equals(_currentScene.getItem(_fixationY,_fixationX))) {
              _visualStm.replaceHypothesis(link.getChildNode());
              _lastHeuristic=1;
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}","/** 
 * Try to move eye using LTM heuristic, return true if: -- square suggested by first child yields a piece which  allows model to follow a test link.
 */
private boolean ltmHeuristic(){
  if (_visualStm.getCount() >= 1) {
    List<Link> hypothesisChildren=_visualStm.getItem(0).getChildren();
    if (hypothesisChildren.isEmpty())     return false;
    ListPattern test=hypothesisChildren.get(0).getTest();
    if (test.isEmpty())     return false;
    Pattern first=test.getItem(0);
    if (first instanceof ItemSquarePattern) {
      ItemSquarePattern ios=(ItemSquarePattern)first;
      _fixationX=ios.getColumn() - 1;
      _fixationY=ios.getRow() - 1;
      for (      Link link : hypothesisChildren) {
        if (link.getTest().size() == 1) {
          if (link.getTest().getItem(0) instanceof ItemSquarePattern) {
            ItemSquarePattern testIos=(ItemSquarePattern)link.getTest().getItem(0);
            if (testIos.getColumn() - 1 == _fixationX && testIos.getRow() - 1 == _fixationY && testIos.getItem().equals(_currentScene.getItem(_fixationY,_fixationX))) {
              _visualStm.replaceHypothesis(link.getChildNode());
              _lastHeuristic=1;
              _fixationsX.add(_fixationX);
              _fixationsY.add(_fixationY);
              _fixationsType.add(_lastHeuristic);
              addFixation(new Fixation(_lastHeuristic,_fixationX,_fixationY));
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}"
87313,"@Test public void testPieceTypes(){
  ItemSquarePattern ios1=new ItemSquarePattern(""String_Node_Str"",1,1);
  ItemSquarePattern ios2=new ItemSquarePattern(""String_Node_Str"",2,2);
  ItemSquarePattern ios3=new ItemSquarePattern(""String_Node_Str"",2,2);
  ItemSquarePattern ios4=new ItemSquarePattern(""String_Node_Str"",2,7);
  ItemSquarePattern ios5=new ItemSquarePattern(""String_Node_Str"",2,7);
  assertFalse(ChessDomain.isBigPiece(ios1));
  assertTrue(ChessDomain.isBigPiece(ios2));
  assertFalse(ChessDomain.isOffensivePiece(ios1));
  assertFalse(ChessDomain.isOffensivePiece(ios2));
  assertTrue(ChessDomain.isOffensivePiece(ios3));
  assertTrue(ChessDomain.isOffensivePiece(ios4));
  assertFalse(ChessDomain.isOffensivePiece(ios5));
  ListPattern lp=new ListPattern();
  for (  ItemSquarePattern pat : (new ItemSquarePattern[]{ios1,ios2,ios3,ios4,ios5})) {
    lp.add(pat);
  }
  assertEquals(2,ChessDomain.getSalientPieces(lp,true).size());
  assertEquals(4,ChessDomain.getSalientPieces(lp,false).size());
  ListPattern lp2=new ListPattern();
  for (  ItemSquarePattern pat : (new ItemSquarePattern[]{new ItemSquarePattern(""String_Node_Str"",2,3),new ItemSquarePattern(""String_Node_Str"",4,2),new ItemSquarePattern(""String_Node_Str"",2,3)})) {
    lp2.add(pat);
  }
  ListPattern sorted=(new ChessDomain()).normalise(lp2);
  assertEquals(3,sorted.size());
}","@Test public void testPieceTypes(){
  ItemSquarePattern ios1=new ItemSquarePattern(""String_Node_Str"",1,1);
  ItemSquarePattern ios2=new ItemSquarePattern(""String_Node_Str"",2,2);
  ItemSquarePattern ios3=new ItemSquarePattern(""String_Node_Str"",2,2);
  ItemSquarePattern ios4=new ItemSquarePattern(""String_Node_Str"",2,7);
  ItemSquarePattern ios5=new ItemSquarePattern(""String_Node_Str"",2,7);
  assertFalse(ChessDomain.isBigPiece(ios1));
  assertTrue(ChessDomain.isBigPiece(ios2));
  assertFalse(ChessDomain.isOffensivePiece(ios1));
  assertFalse(ChessDomain.isOffensivePiece(ios2));
  assertTrue(ChessDomain.isOffensivePiece(ios3));
  assertTrue(ChessDomain.isOffensivePiece(ios4));
  assertFalse(ChessDomain.isOffensivePiece(ios5));
  ListPattern lp=new ListPattern();
  for (  ItemSquarePattern pat : (new ItemSquarePattern[]{ios1,ios2,ios3,ios4,ios5})) {
    lp.add(pat);
  }
  assertEquals(2,ChessDomain.getSalientPieces(lp,true).size());
  assertEquals(4,ChessDomain.getSalientPieces(lp,false).size());
  ListPattern lp2=new ListPattern();
  for (  ItemSquarePattern pat : (new ItemSquarePattern[]{new ItemSquarePattern(""String_Node_Str"",2,3),new ItemSquarePattern(""String_Node_Str"",4,2),new ItemSquarePattern(""String_Node_Str"",2,3)})) {
    lp2.add(pat);
  }
  assertEquals(3,lp2.size());
  assertEquals(""String_Node_Str"",((ItemSquarePattern)lp2.getItem(0)).getItem());
  assertEquals(""String_Node_Str"",((ItemSquarePattern)lp2.getItem(1)).getItem());
  assertEquals(""String_Node_Str"",((ItemSquarePattern)lp2.getItem(2)).getItem());
  ListPattern sorted=(new ChessDomain()).normalise(lp2);
  assertEquals(3,sorted.size());
  assertEquals(""String_Node_Str"",((ItemSquarePattern)sorted.getItem(0)).getItem());
  assertEquals(""String_Node_Str"",((ItemSquarePattern)sorted.getItem(1)).getItem());
  assertEquals(""String_Node_Str"",((ItemSquarePattern)sorted.getItem(2)).getItem());
}"
87314,"public void learnLateralLinks(Chrest model){
  if (_items.size() >= 2) {
    _items.get(1).setFollowedBy(_items.get(0));
    model.advanceClock(model.getAddLinkTime());
  }
}","public void learnLateralLinks(Chrest model){
  if (_items.size() >= 2 && _items.get(1).getFollowedBy() != _items.get(0)) {
    _items.get(1).setFollowedBy(_items.get(0));
    model.advanceClock(model.getAddLinkTime());
  }
}"
87315,"/** 
 * Discrimination learning extends the LTM network by adding new  nodes.
 */
Node discriminate(Chrest model,ListPattern pattern){
  ListPattern newInformation=pattern.remove(_contents);
  if (newInformation.isEmpty()) {
    if (newInformation.isFinished()) {
      return addTest(model,newInformation);
    }
 else {
      return this;
    }
  }
  Node retrievedChunk=model.recognise(newInformation);
  if (retrievedChunk == model.getLtmByModality(pattern)) {
    return model.getLtmByModality(newInformation).learnPrimitive(model,newInformation.getFirstItem());
  }
 else   if (retrievedChunk.getImage().isEmpty()) {
    return retrievedChunk.familiarise(model,newInformation);
  }
 else   if (retrievedChunk.getImage().matches(newInformation)) {
    return addTest(model,retrievedChunk.getImage());
  }
 else {
    ListPattern firstItem=newInformation.getFirstItem();
    firstItem.setNotFinished();
    return addTest(model,firstItem);
  }
}","/** 
 * Discrimination learning extends the LTM network by adding new  nodes.
 */
Node discriminate(Chrest model,ListPattern pattern){
  ListPattern newInformation=pattern.remove(_contents);
  if (newInformation.isEmpty()) {
    if (newInformation.isFinished()) {
      return addTest(model,newInformation);
    }
 else {
      return this;
    }
  }
  Node retrievedChunk=model.recognise(newInformation);
  if (retrievedChunk == model.getLtmByModality(pattern)) {
    return model.getLtmByModality(newInformation).learnPrimitive(model,newInformation.getFirstItem());
  }
 else   if (retrievedChunk.getImage().isEmpty()) {
    return retrievedChunk.familiarise(model,newInformation);
  }
 else   if (retrievedChunk.getImage().matches(newInformation)) {
    ListPattern testPattern=retrievedChunk.getImage().clone();
    testPattern.setNotFinished();
    return addTest(model,testPattern);
  }
 else {
    ListPattern firstItem=newInformation.getFirstItem();
    firstItem.setNotFinished();
    return addTest(model,firstItem);
  }
}"
87316,"private List<ListPattern> readItems(BufferedReader input) throws IOException {
  List<ListPattern> items=new ArrayList<ListPattern>();
  String line=input.readLine();
  while (line != null) {
    ListPattern pattern=Pattern.makeVisualList(line.trim().split(""String_Node_Str""));
    pattern.setFinished();
    items.add(pattern);
    line=input.readLine();
  }
  return items;
}","private List<ListPattern> readItems(BufferedReader input,boolean verbal) throws IOException {
  List<ListPattern> items=new ArrayList<ListPattern>();
  String line=input.readLine();
  while (line != null) {
    ListPattern pattern;
    if (verbal) {
      pattern=Pattern.makeVerbalList(line.trim().split(""String_Node_Str""));
    }
 else {
      pattern=Pattern.makeVisualList(line.trim().split(""String_Node_Str""));
    }
    pattern.setFinished();
    items.add(pattern);
    line=input.readLine();
  }
  return items;
}"
87317,"private List<PairedPattern> readPairedItems(BufferedReader input,boolean secondVerbal) throws IOException {
  List<PairedPattern> items=new ArrayList<PairedPattern>();
  String line=input.readLine();
  while (line != null) {
    String[] pair=line.split(""String_Node_Str"");
    if (pair.length != 2)     throw new IOException();
    ListPattern pat1=Pattern.makeVisualList(pair[0].trim().split(""String_Node_Str""));
    pat1.setFinished();
    ListPattern pat2;
    if (secondVerbal) {
      pat2=Pattern.makeVerbalList(pair[1].trim().split(""String_Node_Str""));
    }
 else {
      pat2=Pattern.makeVisualList(pair[1].trim().split(""String_Node_Str""));
    }
    pat2.setFinished();
    items.add(new PairedPattern(pat1,pat2));
    line=input.readLine();
  }
  return items;
}","private List<PairedPattern> readPairedItems(BufferedReader input,boolean categorisation) throws IOException {
  List<PairedPattern> items=new ArrayList<PairedPattern>();
  String line=input.readLine();
  while (line != null) {
    String[] pair=line.split(""String_Node_Str"");
    if (pair.length != 2)     throw new IOException();
    ListPattern pat1;
    if (categorisation) {
      pat1=Pattern.makeVisualList(pair[0].trim().split(""String_Node_Str""));
    }
 else {
      pat1=Pattern.makeVerbalList(pair[0].trim().split(""String_Node_Str""));
    }
    pat1.setFinished();
    ListPattern pat2=Pattern.makeVerbalList(pair[1].trim().split(""String_Node_Str""));
    pat2.setFinished();
    items.add(new PairedPattern(pat1,pat2));
    line=input.readLine();
  }
  return items;
}"
87318,"/** 
 * Try to move eye using LTM heuristic, return true if: -- square suggested by first child yields a piece which  allows model to follow a test link.
 */
private boolean ltmHeuristic(){
  if (_visualStm.getCount() >= 1) {
    List<Link> hypothesisChildren=_visualStm.getItem(0).getChildren();
    if (hypothesisChildren.isEmpty())     return false;
    ListPattern test=hypothesisChildren.get(0).getTest();
    if (test.isEmpty())     return false;
    Pattern first=test.getItem(0);
    if (first instanceof ItemSquarePattern) {
      ItemSquarePattern ios=(ItemSquarePattern)first;
      _fixationX=ios.getColumn();
      _fixationY=ios.getRow();
      for (      Link link : hypothesisChildren) {
        if (link.getTest().size() == 1) {
          if (link.getTest().getItem(0) instanceof ItemSquarePattern) {
            ItemSquarePattern testIos=(ItemSquarePattern)link.getTest().getItem(0);
            if (testIos.getColumn() == _fixationX && testIos.getRow() == _fixationY && testIos.getItem().equals(_currentScene.getItem(_fixationY,_fixationX))) {
              _visualStm.replaceHypothesis(link.getChildNode());
              _lastHeuristic=1;
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}","/** 
 * Try to move eye using LTM heuristic, return true if: -- square suggested by first child yields a piece which  allows model to follow a test link.
 */
private boolean ltmHeuristic(){
  if (_visualStm.getCount() >= 1) {
    List<Link> hypothesisChildren=_visualStm.getItem(0).getChildren();
    if (hypothesisChildren.isEmpty())     return false;
    ListPattern test=hypothesisChildren.get(0).getTest();
    if (test.isEmpty())     return false;
    Pattern first=test.getItem(0);
    if (first instanceof ItemSquarePattern) {
      ItemSquarePattern ios=(ItemSquarePattern)first;
      _fixationX=ios.getColumn() - 1;
      _fixationY=ios.getRow() - 1;
      for (      Link link : hypothesisChildren) {
        if (link.getTest().size() == 1) {
          if (link.getTest().getItem(0) instanceof ItemSquarePattern) {
            ItemSquarePattern testIos=(ItemSquarePattern)link.getTest().getItem(0);
            if (testIos.getColumn() - 1 == _fixationX && testIos.getRow() - 1 == _fixationY && testIos.getItem().equals(_currentScene.getItem(_fixationY,_fixationX))) {
              _visualStm.replaceHypothesis(link.getChildNode());
              _lastHeuristic=1;
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}"
87319,"/** 
 * Try to move eye to random item in periphery.
 */
private boolean randomItemHeuristic(){
  for (int i=0; i < 10; ++i) {
    int xDisplacement=_random.nextInt(_fieldOfView * 2 + 1) - _fieldOfView;
    int yDisplacement=_random.nextInt(_fieldOfView * 2 + 1) - _fieldOfView;
    if (!_currentScene.isEmpty(_fixationY + yDisplacement,_fixationX + xDisplacement)) {
      _fixationX+=xDisplacement;
      _fixationY+=yDisplacement;
      _lastHeuristic=2;
      return true;
    }
  }
  return false;
}","/** 
 * Try to move eye to random item in periphery.
 */
private boolean randomItemHeuristic(){
  for (int i=0; i < 10; ++i) {
    int xDisplacement=_random.nextInt(_fieldOfView * 2 + 1) - _fieldOfView;
    int yDisplacement=_random.nextInt(_fieldOfView * 2 + 1) - _fieldOfView;
    if (!_currentScene.isEmpty(_fixationY + yDisplacement,_fixationX + xDisplacement) && _fixationX < _currentScene.getWidth() && _fixationY < _currentScene.getHeight()) {
      _fixationX+=xDisplacement;
      _fixationY+=yDisplacement;
      _lastHeuristic=2;
      return true;
    }
  }
  return false;
}"
87320,"public void paint(Graphics g){
  super.paint(g);
  Graphics2D g2=(Graphics2D)g;
  int fov=2;
  g2.setBackground(Color.WHITE);
  g2.clearRect(0,0,_maxX,_maxY);
  for (int i=0; i <= _scene.getHeight(); ++i) {
    g2.drawLine(offsetX,offsetY + scale * i,offsetX + scale * _scene.getWidth(),offsetY + scale * i);
  }
  for (int i=0; i <= _scene.getWidth(); ++i) {
    g2.drawLine(offsetX + scale * i,offsetY,offsetX + scale * i,offsetY + scale * _scene.getHeight());
  }
  for (int i=0; i < _scene.getHeight(); ++i) {
    g2.drawString(""String_Node_Str"" + (i + 1),offsetX + scale * (_scene.getWidth() + 1),offsetY + scale * (i + 1) - 5);
  }
  for (int i=0; i < _scene.getWidth(); ++i) {
    g2.drawString(""String_Node_Str"" + (i + 1),offsetX + scale * i + 5,offsetY + scale * (_scene.getHeight() + 1));
  }
  for (int i=0; i < _scene.getHeight(); ++i) {
    for (int j=0; j < _scene.getWidth(); ++j) {
      if (!_scene.isEmpty(i,j)) {
        g2.drawString(_scene.getItem(i,j),offsetX + 5 + scale * j,offsetY + scale - 5 + scale * i);
      }
    }
  }
  int prevX=-1;
  int prevY=-1;
  if (_showFixations) {
    for (    Fixation fixation : _fixations) {
      g2.setColor(Color.BLUE);
      g2.setStroke(new BasicStroke(2));
      int nextX=offsetX + scale * fixation.getX() - 2;
      int nextY=offsetY + scale * fixation.getY() - 2;
      if (prevX == -1 && prevY == -1) {
        ;
      }
 else {
        g2.drawLine(prevX,prevY,nextX,nextY);
      }
      g2.drawOval(nextX,nextY,scale - 4,scale - 4);
    }
  }
}","public void paint(Graphics g){
  super.paint(g);
  Graphics2D g2=(Graphics2D)g;
  int fov=2;
  g2.setBackground(Color.WHITE);
  g2.clearRect(0,0,_maxX,_maxY);
  for (int i=0; i <= _scene.getHeight(); ++i) {
    g2.drawLine(offsetX,offsetY + scale * i,offsetX + scale * _scene.getWidth(),offsetY + scale * i);
  }
  for (int i=0; i <= _scene.getWidth(); ++i) {
    g2.drawLine(offsetX + scale * i,offsetY,offsetX + scale * i,offsetY + scale * _scene.getHeight());
  }
  for (int i=0; i < _scene.getHeight(); ++i) {
    g2.drawString(""String_Node_Str"" + (i + 1),offsetX + scale * (_scene.getWidth() + 1),offsetY + scale * (i + 1) - 5);
  }
  for (int i=0; i < _scene.getWidth(); ++i) {
    g2.drawString(""String_Node_Str"" + (i + 1),offsetX + scale * i + 5,offsetY + scale * (_scene.getHeight() + 1));
  }
  for (int i=0; i < _scene.getHeight(); ++i) {
    for (int j=0; j < _scene.getWidth(); ++j) {
      if (!_scene.isEmpty(i,j)) {
        g2.drawString(_scene.getItem(i,j),offsetX + 5 + scale * j,offsetY + scale - 5 + scale * i);
      }
    }
  }
  int prevX=-1;
  int prevY=-1;
  if (_showFixations) {
    for (    Fixation fixation : _fixations) {
      g2.setColor(Color.BLUE);
      g2.setStroke(new BasicStroke(2));
      int nextX=offsetX + scale * fixation.getX() + 5;
      int nextY=offsetY + scale * fixation.getY() + 5;
      if (prevX == -1 && prevY == -1) {
        ;
      }
 else {
        g2.drawLine(prevX,prevY,nextX + 5,nextY + 5);
      }
      g2.drawOval(nextX,nextY,scale - 10,scale - 10);
      prevX=nextX + 5;
      prevY=nextY + 5;
    }
  }
}"
87321,"/** 
 * Retrieve all items within given row +/- size, column +/- size TODO: Convert this to use a circular field of view.
 */
public ListPattern getItems(int row,int column,int size){
  ListPattern items=new ListPattern();
  for (int i=column - size; i <= column + size; ++i) {
    if (i >= 0 && i < _height) {
      for (int j=row - size; j <= row + size; ++j) {
        if (j >= 0 && j < _width) {
          if (!_scene[i][j].equals(""String_Node_Str"")) {
            items.add(new ItemSquarePattern(_scene[i][j],i,j));
          }
        }
      }
    }
  }
  return items;
}","/** 
 * Retrieve all items within given row +/- size, column +/- size TODO: Convert this to use a circular field of view.
 */
public ListPattern getItems(int startRow,int startColumn,int size){
  ListPattern items=new ListPattern();
  for (int col=startColumn - size; col <= startColumn + size; ++col) {
    if (col >= 0 && col < _width) {
      for (int row=startRow - size; row <= startRow + size; ++row) {
        if (row >= 0 && row < _height) {
          if (!_scene[row][col].equals(""String_Node_Str"")) {
            items.add(new ItemSquarePattern(_scene[row][col],col + 1,row + 1));
          }
        }
      }
    }
  }
  return items;
}"
87322,"AboutAction(Shell parent){
  super(""String_Node_Str"",new ImageIcon(jchrest.gui.Shell.class.getResource(""String_Node_Str"")));
  _parent=parent;
}","AboutAction(Shell parent){
  super(""String_Node_Str"");
  _parent=parent;
}"
87323,"ModelPropertiesAction(Shell parent){
  super(""String_Node_Str"",new ImageIcon(jchrest.gui.Shell.class.getResource(""String_Node_Str"")));
  _parent=parent;
}","ModelPropertiesAction(Shell parent){
  super(""String_Node_Str"");
  _parent=parent;
}"
87324,"LoadDataAction(Shell parent){
  super(""String_Node_Str"",new ImageIcon(jchrest.gui.Shell.class.getResource(""String_Node_Str"")));
  _parent=parent;
}","LoadDataAction(Shell parent){
  super(""String_Node_Str"");
  _parent=parent;
}"
87325,"SaveModelAction(Shell parent){
  super(""String_Node_Str"",new ImageIcon(jchrest.gui.Shell.class.getResource(""String_Node_Str"")));
  _parent=parent;
}","SaveModelAction(Shell parent){
  super(""String_Node_Str"");
  _parent=parent;
}"
87326,"LoadModelAction(Shell parent){
  super(""String_Node_Str"",new ImageIcon(jchrest.gui.Shell.class.getResource(""String_Node_Str"")));
  _parent=parent;
}","LoadModelAction(Shell parent){
  super(""String_Node_Str"");
  _parent=parent;
}"
87327,"/** 
 * Read an item-on-square pattern from given reader object.  Assumes that column/row cannot be -1.
 */
public static ItemSquarePattern readPattern(BufferedReader reader) throws ParsingErrorException {
  int column=-1;
  int row=-1;
  String item=null;
  FileUtilities.acceptOpenTag(reader,""String_Node_Str"");
  while (!FileUtilities.checkCloseTag(reader,""String_Node_Str"")) {
    if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
      item=FileUtilities.readStringInTag(reader,""String_Node_Str"");
    }
 else     if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
      column=FileUtilities.readIntInTag(reader,""String_Node_Str"");
    }
 else     if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
      row=FileUtilities.readIntInTag(reader,""String_Node_Str"");
    }
 else {
      throw new ParsingErrorException();
    }
  }
  FileUtilities.acceptCloseTag(reader,""String_Node_Str"");
  int number=FileUtilities.readIntInTag(reader,""String_Node_Str"");
  if (item == null || column == -1 || row == -1) {
    throw new ParsingErrorException();
  }
  return new ItemSquarePattern(item,column,row);
}","/** 
 * Read an item-on-square pattern from given reader object.  Assumes that column/row cannot be -1.
 */
public static ItemSquarePattern readPattern(BufferedReader reader) throws ParsingErrorException {
  int column=-1;
  int row=-1;
  String item=null;
  FileUtilities.acceptOpenTag(reader,""String_Node_Str"");
  while (!FileUtilities.checkCloseTag(reader,""String_Node_Str"")) {
    if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
      item=FileUtilities.readStringInTag(reader,""String_Node_Str"");
    }
 else     if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
      column=FileUtilities.readIntInTag(reader,""String_Node_Str"");
    }
 else     if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
      row=FileUtilities.readIntInTag(reader,""String_Node_Str"");
    }
 else {
      throw new ParsingErrorException();
    }
  }
  FileUtilities.acceptCloseTag(reader,""String_Node_Str"");
  if (item == null || column == -1 || row == -1) {
    throw new ParsingErrorException();
  }
  return new ItemSquarePattern(item,column,row);
}"
87328,"/** 
 * Try to move eye using LTM heuristic, return true if: -- square suggested by first child yields a piece which  allows model to follow a test link.
 */
private boolean ltmHeuristic(){
  if (_visualStm.getCount() >= 1) {
    List<Link> hypothesisChildren=_visualStm.getItem(0).getChildren();
    if (hypothesisChildren.isEmpty())     return false;
    ListPattern test=hypothesisChildren.get(0).getTest();
    if (test.isEmpty())     return false;
    Pattern first=test.getItem(0);
    if (first instanceof ItemSquarePattern) {
      ItemSquarePattern ios=(ItemSquarePattern)first;
      _fixationX=ios.getColumn();
      _fixationY=ios.getRow();
      for (      Link link : hypothesisChildren) {
        if (_currentScene.getItem(_fixationY,_fixationX).equals(link.getTest())) {
          _visualStm.replaceHypothesis(link.getChildNode());
          _lastHeuristic=1;
          return true;
        }
      }
    }
  }
  return false;
}","/** 
 * Try to move eye using LTM heuristic, return true if: -- square suggested by first child yields a piece which  allows model to follow a test link.
 */
private boolean ltmHeuristic(){
  if (_visualStm.getCount() >= 1) {
    List<Link> hypothesisChildren=_visualStm.getItem(0).getChildren();
    if (hypothesisChildren.isEmpty())     return false;
    ListPattern test=hypothesisChildren.get(0).getTest();
    if (test.isEmpty())     return false;
    Pattern first=test.getItem(0);
    if (first instanceof ItemSquarePattern) {
      ItemSquarePattern ios=(ItemSquarePattern)first;
      _fixationX=ios.getColumn();
      _fixationY=ios.getRow();
      for (      Link link : hypothesisChildren) {
        if (link.getTest().size() == 1) {
          if (link.getTest().getItem(0) instanceof ItemSquarePattern) {
            ItemSquarePattern testIos=(ItemSquarePattern)link.getTest().getItem(0);
            if (testIos.getColumn() == _fixationX && testIos.getRow() == _fixationY && testIos.getItem().equals(_currentScene.getItem(_fixationY,_fixationX))) {
              _visualStm.replaceHypothesis(link.getChildNode());
              _lastHeuristic=1;
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}"
87329,"private JMenu createModelMenu(){
  JMenu menu=new JMenu(""String_Node_Str"");
  menu.add(new ClearModelAction(this));
  menu.add(new ModelPropertiesAction(this));
  menu.add(new JSeparator());
  menu.add(new ModelInformationAction(this));
  menu.add(new ViewModelAction(this));
  return menu;
}","private JMenu createModelMenu(){
  JMenu menu=new JMenu(""String_Node_Str"");
  menu.add(new ClearModelAction(this));
  menu.add(new LoadModelAction(this));
  menu.add(new SaveModelAction(this));
  menu.add(new ModelPropertiesAction(this));
  menu.add(new JSeparator());
  menu.add(new ModelInformationAction(this));
  menu.add(new ViewModelAction(this));
  return menu;
}"
87330,"/** 
 * Two ItemSquarePatterns only match if they are the same.
 */
public boolean matches(Pattern givenPattern){
  if (!(givenPattern instanceof ItemSquarePattern))   return false;
  return this.equals(givenPattern);
}","/** 
 * Two ItemSquarePatterns only match if they are the same.
 */
public boolean matches(Pattern givenPattern){
  if (!(givenPattern instanceof ItemSquarePattern))   return false;
  return this.equalPrimitive((ItemSquarePattern)givenPattern);
}"
87331,"/** 
 * Used in constructing instances by   {@link Pattern} class.Add pattern to list, unless the pattern is 'finished'.
 */
public void add(Pattern pattern){
  if (!_finished) {
    _list.add(pattern);
  }
}","/** 
 * Used in constructing instances by   {@link Pattern} class.Add pattern to list, unless the pattern is 'finished'.
 */
public void add(PrimitivePattern pattern){
  if (!_finished) {
    _list.add(pattern);
  }
}"
87332,"/** 
 * Write a description of the list pattern to the given Writer object.
 */
public void writePattern(Writer writer) throws IOException {
  FileUtilities.writeOpenTag(writer,""String_Node_Str"");
  FileUtilities.writeOpenTag(writer,""String_Node_Str"");
  for (  Pattern pattern : _list) {
    pattern.writePattern(writer);
  }
  FileUtilities.writeCloseTag(writer,""String_Node_Str"");
  FileUtilities.writeTaggedString(writer,""String_Node_Str"",_modality.toString());
  FileUtilities.writeTaggedBoolean(writer,""String_Node_Str"",_finished);
  FileUtilities.writeCloseTag(writer,""String_Node_Str"");
}","/** 
 * Write a description of the list pattern to the given Writer object.
 */
public void writePattern(Writer writer) throws IOException {
  FileUtilities.writeOpenTag(writer,""String_Node_Str"");
  FileUtilities.writeOpenTag(writer,""String_Node_Str"");
  for (  PrimitivePattern pattern : _list) {
    pattern.writePattern(writer);
  }
  FileUtilities.writeCloseTag(writer,""String_Node_Str"");
  FileUtilities.writeTaggedString(writer,""String_Node_Str"",_modality.toString());
  FileUtilities.writeTaggedBoolean(writer,""String_Node_Str"",_finished);
  FileUtilities.writeCloseTag(writer,""String_Node_Str"");
}"
87333,"/** 
 * Retrieve the indexed item from the list pattern. There is no check on the validity of the index.
 */
public Pattern getItem(int index){
  return _list.get(index);
}","/** 
 * Retrieve the indexed item from the list pattern. There is no check on the validity of the index.
 */
public PrimitivePattern getItem(int index){
  return _list.get(index);
}"
87334,"/** 
 * Two patterns match if they are both ListPatterns and this ListPattern contains a subset of the given pattern. 
 */
public boolean matches(Pattern givenPattern){
  if (!(givenPattern instanceof ListPattern))   return false;
  ListPattern pattern=(ListPattern)givenPattern;
  if (_modality != pattern._modality)   return false;
  if (isFinished()) {
    if (size() != pattern.size())     return false;
    if (!pattern.isFinished())     return false;
  }
 else {
    if (size() > pattern.size())     return false;
  }
  for (int i=0, n=size(); i < n; ++i) {
    if (!pattern.getItem(i).equals(getItem(i))) {
      return false;
    }
  }
  return true;
}","/** 
 * Two patterns match if they are both ListPatterns and this ListPattern contains a subset of the given pattern. 
 */
public boolean matches(Pattern givenPattern){
  if (!(givenPattern instanceof ListPattern))   return false;
  ListPattern pattern=(ListPattern)givenPattern;
  if (_modality != pattern._modality)   return false;
  if (isFinished()) {
    if (size() != pattern.size())     return false;
    if (!pattern.isFinished())     return false;
  }
 else {
    if (size() > pattern.size())     return false;
  }
  for (int i=0, n=size(); i < n; ++i) {
    if (!pattern.getItem(i).equalPrimitive(getItem(i))) {
      return false;
    }
  }
  return true;
}"
87335,"public ListPattern(Modality modality){
  _list=new ArrayList<Pattern>();
  _modality=modality;
  _finished=false;
}","public ListPattern(Modality modality){
  _list=new ArrayList<PrimitivePattern>();
  _modality=modality;
  _finished=false;
}"
87336,"/** 
 * Return a new ListPattern forming the parts of this pattern without  the matching elements of the given pattern. 
 */
public ListPattern remove(ListPattern pattern){
  ListPattern result=new ListPattern(_modality);
  int i=0;
  boolean takingItems=false;
  while (i < size()) {
    if (takingItems) {
      result.add(getItem(i));
    }
 else     if (i < pattern.size() && pattern.getItem(i).equals(getItem(i))) {
      ;
    }
 else {
      takingItems=true;
      result.add(getItem(i));
    }
    i+=1;
  }
  if (isFinished() && !(result.isEmpty() && pattern.isFinished())) {
    result.setFinished();
  }
  return result;
}","/** 
 * Return a new ListPattern forming the parts of this pattern without  the matching elements of the given pattern. 
 */
public ListPattern remove(ListPattern pattern){
  ListPattern result=new ListPattern(_modality);
  int i=0;
  boolean takingItems=false;
  while (i < size()) {
    if (takingItems) {
      result.add(getItem(i));
    }
 else     if (i < pattern.size() && pattern.getItem(i).equalPrimitive(getItem(i))) {
      ;
    }
 else {
      takingItems=true;
      result.add(getItem(i));
    }
    i+=1;
  }
  if (isFinished() && !(result.isEmpty() && pattern.isFinished())) {
    result.setFinished();
  }
  return result;
}"
87337,"/** 
 * Two patterns are equal if they contain the same items.
 */
public boolean equals(ListPattern pattern){
  if (_modality != pattern._modality)   return false;
  if (size() != pattern.size())   return false;
  for (int i=0, n=size(); i < n; ++i) {
    if (!pattern.getItem(i).equals(getItem(i))) {
      return false;
    }
  }
  return _finished == pattern.isFinished();
}","/** 
 * Two patterns are equal if they contain the same items.
 */
public boolean equals(ListPattern pattern){
  if (_modality != pattern._modality)   return false;
  if (size() != pattern.size())   return false;
  for (int i=0, n=size(); i < n; ++i) {
    if (!pattern.getItem(i).equalPrimitive(getItem(i))) {
      return false;
    }
  }
  return _finished == pattern.isFinished();
}"
87338,"/** 
 * Construct a copy of this pattern, so that it can be modified  without affecting the original.
 */
public ListPattern clone(){
  ListPattern result=new ListPattern(_modality);
  for (  Pattern pattern : _list) {
    result.add(pattern);
  }
  if (isFinished()) {
    result.setFinished();
  }
  return result;
}","/** 
 * Construct a copy of this pattern, so that it can be modified  without affecting the original.
 */
public ListPattern clone(){
  ListPattern result=new ListPattern(_modality);
  for (  PrimitivePattern pattern : _list) {
    result.add(pattern);
  }
  if (isFinished()) {
    result.setFinished();
  }
  return result;
}"
87339,"/** 
 * Render the list pattern as a string.
 */
public String toString(){
  String result=""String_Node_Str"";
  for (  Pattern pattern : _list) {
    result+=pattern.toString() + ""String_Node_Str"";
  }
  if (_finished)   result+=""String_Node_Str"";
  return result + ""String_Node_Str"";
}","/** 
 * Render the list pattern as a string.
 */
public String toString(){
  String result=""String_Node_Str"";
  for (  PrimitivePattern pattern : _list) {
    result+=pattern.toString() + ""String_Node_Str"";
  }
  if (_finished)   result+=""String_Node_Str"";
  return result + ""String_Node_Str"";
}"
87340,"/** 
 * Retrieve a description of list pattern from given Writer object, and create it.
 */
public static ListPattern readPattern(BufferedReader reader) throws ParsingErrorException {
  boolean finished=false;
  Modality modality=Modality.VISUAL;
  List<Pattern> items=new ArrayList<Pattern>();
  FileUtilities.acceptOpenTag(reader,""String_Node_Str"");
  while (!FileUtilities.checkCloseTag(reader,""String_Node_Str"")) {
    if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
      FileUtilities.acceptOpenTag(reader,""String_Node_Str"");
      while (!FileUtilities.checkCloseTag(reader,""String_Node_Str"")) {
        if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
          items.add(StringPattern.readPattern(reader));
        }
 else         if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
          items.add(NumberPattern.readPattern(reader));
        }
 else         if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
          items.add(ItemSquarePattern.readPattern(reader));
        }
 else {
          throw new ParsingErrorException(""String_Node_Str"");
        }
      }
      FileUtilities.acceptCloseTag(reader,""String_Node_Str"");
    }
 else     if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
      String mode=FileUtilities.readStringInTag(reader,""String_Node_Str"");
      if (mode.equals(""String_Node_Str"")) {
        modality=Modality.VISUAL;
      }
 else       if (mode.equals(""String_Node_Str"")) {
        modality=Modality.VERBAL;
      }
 else {
        modality=Modality.ACTION;
      }
    }
 else     if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
      finished=FileUtilities.readBooleanInTag(reader,""String_Node_Str"");
    }
 else {
      throw new ParsingErrorException();
    }
  }
  FileUtilities.acceptCloseTag(reader,""String_Node_Str"");
  ListPattern pattern=new ListPattern(modality);
  for (  Pattern pat : items) {
    pattern.add(pat);
  }
  if (finished)   pattern.setFinished();
  return pattern;
}","/** 
 * Retrieve a description of list pattern from given Writer object, and create it.
 */
public static ListPattern readPattern(BufferedReader reader) throws ParsingErrorException {
  boolean finished=false;
  Modality modality=Modality.VISUAL;
  List<PrimitivePattern> items=new ArrayList<PrimitivePattern>();
  FileUtilities.acceptOpenTag(reader,""String_Node_Str"");
  while (!FileUtilities.checkCloseTag(reader,""String_Node_Str"")) {
    if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
      FileUtilities.acceptOpenTag(reader,""String_Node_Str"");
      while (!FileUtilities.checkCloseTag(reader,""String_Node_Str"")) {
        if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
          items.add(StringPattern.readPattern(reader));
        }
 else         if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
          items.add(NumberPattern.readPattern(reader));
        }
 else         if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
          items.add(ItemSquarePattern.readPattern(reader));
        }
 else {
          throw new ParsingErrorException(""String_Node_Str"");
        }
      }
      FileUtilities.acceptCloseTag(reader,""String_Node_Str"");
    }
 else     if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
      String mode=FileUtilities.readStringInTag(reader,""String_Node_Str"");
      if (mode.equals(""String_Node_Str"")) {
        modality=Modality.VISUAL;
      }
 else       if (mode.equals(""String_Node_Str"")) {
        modality=Modality.VERBAL;
      }
 else {
        modality=Modality.ACTION;
      }
    }
 else     if (FileUtilities.checkOpenTag(reader,""String_Node_Str"")) {
      finished=FileUtilities.readBooleanInTag(reader,""String_Node_Str"");
    }
 else {
      throw new ParsingErrorException();
    }
  }
  FileUtilities.acceptCloseTag(reader,""String_Node_Str"");
  ListPattern pattern=new ListPattern(modality);
  for (  PrimitivePattern pat : items) {
    pattern.add(pat);
  }
  if (finished)   pattern.setFinished();
  return pattern;
}"
87341,"/** 
 * Return a new ListPattern formed from the contents of this list pattern and  the given PrimitivePattern appended to it.
 */
public ListPattern append(PrimitivePattern pattern){
  ListPattern result=new ListPattern(_modality);
  for (  Pattern item : _list) {
    result.add(item);
  }
  result.add(pattern);
  return result;
}","/** 
 * Return a new ListPattern formed from the contents of this list pattern and  the given PrimitivePattern appended to it.
 */
public ListPattern append(PrimitivePattern pattern){
  ListPattern result=new ListPattern(_modality);
  for (  PrimitivePattern item : _list) {
    result.add(item);
  }
  result.add(pattern);
  return result;
}"
87342,"@Test public void simpleLearning1(){
  _model1.recogniseAndLearn(_list1);
  assertEquals(1,_model1.getLtmByModality(_list1).getChildren().size());
  Link firstChild=_model1.getLtmByModality(_list1).getChildren().get(0);
  assertFalse(_emptyList.equals(firstChild.getChildNode().getContents()));
  assertTrue(firstChild.getTest().equals(_prim1Test));
  assertTrue(firstChild.getChildNode().getContents().equals(_prim1Test));
  assertTrue(firstChild.getChildNode().getImage().equals(_prim1));
}","public void simpleLearning1(ListPattern list,ListPattern emptyList,ListPattern prim,ListPattern primTest){
  _model1.recogniseAndLearn(list);
  assertEquals(1,_model1.getLtmByModality(list).getChildren().size());
  Link firstChild=_model1.getLtmByModality(list).getChildren().get(0);
  assertFalse(emptyList.equals(firstChild.getChildNode().getContents()));
  assertTrue(firstChild.getTest().equals(primTest));
  assertTrue(firstChild.getChildNode().getContents().equals(primTest));
  assertTrue(firstChild.getChildNode().getImage().equals(prim));
}"
87343,"@Before public void setupModels(){
  _model1=new Chrest();
  _model2=new Chrest();
  _list1=Pattern.makeVisualList(new int[]{1,2,3,4});
  _list1.setFinished();
  _list2=Pattern.makeVisualList(new int[]{3,4});
  _list2.setFinished();
  _list3=Pattern.makeVisualList(new int[]{1,2});
  _list3.setFinished();
  _list3Test=_list3.clone();
  _list3Test.setNotFinished();
  _list4=Pattern.makeVisualList(new int[]{1});
  _prim1=Pattern.makeVisualList(new int[]{1});
  _prim1.setFinished();
  _prim1Test=_prim1.clone();
  _prim1Test.setNotFinished();
  _prim2=Pattern.makeVisualList(new int[]{2});
  _prim2.setFinished();
  _emptyList=Pattern.makeVisualList(new int[]{});
}","@Before public void setupModels(){
  _model1=new Chrest();
  _model2=new Chrest();
  _list1=Pattern.makeVisualList(new int[]{1,2,3,4});
  _list1.setFinished();
  _list2=Pattern.makeVisualList(new int[]{3,4});
  _list2.setFinished();
  _list3=Pattern.makeVisualList(new int[]{1,2});
  _list3.setFinished();
  _list3Test=_list3.clone();
  _list3Test.setNotFinished();
  _list4=Pattern.makeVisualList(new int[]{1});
  _prim1=Pattern.makeVisualList(new int[]{1});
  _prim1.setFinished();
  _prim1Test=_prim1.clone();
  _prim1Test.setNotFinished();
  _prim2=Pattern.makeVisualList(new int[]{2});
  _prim2.setFinished();
  _emptyList=Pattern.makeVisualList(new int[]{});
  _iosList1=new ListPattern();
  _iosList1.add(new ItemSquarePattern(""String_Node_Str"",1,2));
  _iosList1.add(new ItemSquarePattern(""String_Node_Str"",2,2));
  _iosList1.add(new ItemSquarePattern(""String_Node_Str"",3,2));
  _iosList1.add(new ItemSquarePattern(""String_Node_Str"",4,2));
  _emptyIosList=new ListPattern();
  _iosPrim1=new ListPattern();
  _iosPrim1.add(new ItemSquarePattern(""String_Node_Str"",1,2));
  _iosPrim1.setFinished();
  _iosPrim1Test=_iosPrim1.clone();
  _iosPrim1Test.setNotFinished();
}"
87344,"@Test public void testListPatternEquality(){
  assertFalse(Pattern.makeVisualList(new int[]{}).equals(Pattern.makeVerbalList(new int[]{})));
  assertTrue(_list1.equals(Pattern.makeVisualList(new int[]{1,2,3,4})));
  assertFalse(_list1.equals(Pattern.makeVisualList(new int[]{1,2,3})));
  assertFalse(_list1.equals(Pattern.makeVisualList(new int[]{1,2,3,4,5})));
  assertFalse(_list1.equals(Pattern.makeVisualList(new int[]{1,2,4,5})));
  assertFalse(_list1.equals(_list2));
  ListPattern list1Copy=Pattern.makeVisualList(new int[]{1,2,3,4});
  list1Copy.setFinished();
  assertFalse(_list1.equals(list1Copy));
  _list1.setFinished();
  assertTrue(_list1.equals(list1Copy));
}","@Test public void testListPatternEquality(){
  assertFalse(Pattern.makeVisualList(new int[]{}).equals(Pattern.makeVerbalList(new int[]{})));
  assertTrue(_list1.equals(Pattern.makeVisualList(new int[]{1,2,3,4})));
  assertFalse(_list1.equals(Pattern.makeVisualList(new int[]{1,2,3})));
  assertFalse(_list1.equals(Pattern.makeVisualList(new int[]{1,2,3,4,5})));
  assertFalse(_list1.equals(Pattern.makeVisualList(new int[]{1,2,4,5})));
  assertFalse(_list1.equals(_list2));
  ListPattern list1Copy=Pattern.makeVisualList(new int[]{1,2,3,4});
  list1Copy.setFinished();
  assertFalse(_list1.equals(list1Copy));
  _list1.setFinished();
  assertTrue(_list1.equals(list1Copy));
  ListPattern iosList1=new ListPattern();
  iosList1.add(_ios1);
  ListPattern iosList2=new ListPattern();
  iosList2.add(_ios2);
  ListPattern iosList3=new ListPattern();
  iosList3.add(_ios1a);
  assertTrue(iosList1.equals(iosList3));
  assertFalse(iosList1.equals(iosList2));
}"
87345,"@Test public void testNumberMatches(){
  assertTrue(_number1.equals(NumberPattern.create(1)));
  assertFalse(_number1.equals(_number2));
  assertTrue(_number1.matches(NumberPattern.create(1)));
  assertFalse(_number1.matches(_number2));
}","@Test public void testNumberMatches(){
  assertTrue(_number1.equalPrimitive(NumberPattern.create(1)));
  assertFalse(_number1.equalPrimitive(_number2));
  assertTrue(_number1.matches(NumberPattern.create(1)));
  assertFalse(_number1.matches(_number2));
}"
87346,"@Before public void setupExamples(){
  _number1=Pattern.makeNumber(1);
  _number2=Pattern.makeNumber(2);
  _string1=Pattern.makeString(""String_Node_Str"");
  _string2=Pattern.makeString(""String_Node_Str"");
  _list1=Pattern.makeVisualList(new int[]{1,2,3,4});
  _list2=Pattern.makeVisualList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  _list3=Pattern.makeVisualList(new int[]{1,2,3});
}","@Before public void setupExamples(){
  _number1=Pattern.makeNumber(1);
  _number2=Pattern.makeNumber(2);
  _string1=Pattern.makeString(""String_Node_Str"");
  _string2=Pattern.makeString(""String_Node_Str"");
  _ios1=new ItemSquarePattern(""String_Node_Str"",2,3);
  _ios1a=new ItemSquarePattern(""String_Node_Str"",2,3);
  _ios2=new ItemSquarePattern(""String_Node_Str"",2,3);
  _list1=Pattern.makeVisualList(new int[]{1,2,3,4});
  _list2=Pattern.makeVisualList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  _list3=Pattern.makeVisualList(new int[]{1,2,3});
}"
87347,"@Test public void testStringMatches(){
  assertTrue(_string1.equals(StringPattern.create(""String_Node_Str"")));
  assertFalse(_string1.equals(_string2));
  assertTrue(_string1.matches(StringPattern.create(""String_Node_Str"")));
  assertFalse(_string1.matches(_string2));
}","@Test public void testStringMatches(){
  assertTrue(_string1.equalPrimitive(StringPattern.create(""String_Node_Str"")));
  assertFalse(_string1.equalPrimitive(_string2));
  assertTrue(_string1.matches(StringPattern.create(""String_Node_Str"")));
  assertFalse(_string1.matches(_string2));
}"
87348,"/** 
 * Familiarisation learning extends the image in a node by adding new  information from the given pattern.
 */
Node familiarise(Chrest model,ListPattern pattern){
  ListPattern newInformation=pattern.remove(_image);
  if (newInformation.isEmpty()) {
    if (newInformation.isFinished()) {
      _image.setFinished();
    }
  }
 else {
    Node retrievedChunk=model.recognise(newInformation);
    if (retrievedChunk == model.getLtmByModality(pattern)) {
      return model.getLtmByModality(pattern).learnPrimitive(model,newInformation.getFirstItem());
    }
 else     if (retrievedChunk.getImage().isEmpty()) {
      ListPattern primitive=newInformation.getFirstItem();
      retrievedChunk=model.recognise(primitive);
      if (retrievedChunk == model.getLtmByModality(pattern)) {
        return model.getLtmByModality(pattern).learnPrimitive(model,primitive);
      }
 else {
        ListPattern toadd=primitive.clone();
        toadd.setNotFinished();
        _image=_image.append(toadd);
        model.advanceClock(model.getFamiliarisationTime());
      }
    }
 else     if (retrievedChunk.getImage().matches(newInformation)) {
      ListPattern toadd=retrievedChunk.getImage().clone();
      toadd.setNotFinished();
      _image=_image.append(toadd);
      model.advanceClock(model.getFamiliarisationTime());
    }
 else {
      ListPattern primitive=newInformation.getFirstItem();
      retrievedChunk=model.recognise(primitive);
      if (retrievedChunk == model.getLtmByModality(pattern)) {
        return model.getLtmByModality(pattern).learnPrimitive(model,primitive);
      }
 else {
        ListPattern toadd=primitive.clone();
        toadd.setNotFinished();
        _image=_image.append(toadd);
        model.advanceClock(model.getFamiliarisationTime());
      }
    }
  }
  return this;
}","/** 
 * Familiarisation learning extends the image in a node by adding new  information from the given pattern.
 */
Node familiarise(Chrest model,ListPattern pattern){
  ListPattern newInformation=pattern.remove(_image);
  if (newInformation.isEmpty()) {
    if (newInformation.isFinished()) {
      _image=_image.clone();
      _image.setFinished();
    }
  }
 else {
    Node retrievedChunk=model.recognise(newInformation);
    if (retrievedChunk == model.getLtmByModality(pattern)) {
      return model.getLtmByModality(pattern).learnPrimitive(model,newInformation.getFirstItem());
    }
 else     if (retrievedChunk.getImage().isEmpty()) {
      ListPattern primitive=newInformation.getFirstItem();
      retrievedChunk=model.recognise(primitive);
      if (retrievedChunk == model.getLtmByModality(pattern)) {
        return model.getLtmByModality(pattern).learnPrimitive(model,primitive);
      }
 else {
        ListPattern toadd=primitive.clone();
        toadd.setNotFinished();
        _image=_image.append(toadd);
        model.advanceClock(model.getFamiliarisationTime());
      }
    }
 else     if (retrievedChunk.getImage().matches(newInformation)) {
      ListPattern toadd=retrievedChunk.getImage().clone();
      toadd.setNotFinished();
      _image=_image.append(toadd);
      model.advanceClock(model.getFamiliarisationTime());
    }
 else {
      ListPattern primitive=newInformation.getFirstItem();
      retrievedChunk=model.recognise(primitive);
      if (retrievedChunk == model.getLtmByModality(pattern)) {
        return model.getLtmByModality(pattern).learnPrimitive(model,primitive);
      }
 else {
        ListPattern toadd=primitive.clone();
        toadd.setNotFinished();
        _image=_image.append(toadd);
        model.advanceClock(model.getFamiliarisationTime());
      }
    }
  }
  return this;
}"
87349,"/** 
 * Kicks off an asynchronous scraping job and returns a proxy object. This proxy is only for added convenience of monitoring/cancelling the job. The listener you pass as a parameter does all this and more already.
 * @param request The scraping request, built in accordance with http://usebobik.com/api/docs#func_ref
 * @param listener An object encapsulating various useful callbacks
 * @return proxy to monitor/abort the scraping job
 * @throws BobikException thrown on all Bobik-specific errors
 * @throws IOException thrown on network problems
 * @throws JSONException not common, thrown on surprise JSON parsing errors
 * @throws ExecutionException not common, thrown if there's a client-level error during the scheduling of threads
 * @throws InterruptedException not common, thrown if there's a client-level error during the scheduling of threads
 */
public Job scrape(JSONObject request,final JobListener listener) throws BobikException, IOException, JSONException, ExecutionException, InterruptedException {
  JSONObject job_submission=callAPI(request,""String_Node_Str"");
  final long startTime=System.currentTimeMillis();
  final String job_id=getJobIdOrFail(job_submission);
  final Job job=new Job(){
    private JSONObject scraped_data=null;
    private Future<Object> job_waiter=null;
    private int estimated_completion_time_ms=-1;
    private boolean cancelled=false;
    private JSONObject getStatusRequestObj(    boolean download_results) throws BobikException, JSONException {
      JSONObject progress_check=new JSONObject();
      progress_check.accumulate(BobikConstants.JOB_TOKEN_LABEL,id());
      progress_check.accumulate(BobikConstants.SKIP_DATA_TOKEN_LABEL,!download_results);
      return progress_check;
    }
    @Override public String id(){
      return job_id;
    }
    @Override public float getProgress() throws BobikException {
      try {
        JSONObject status_check=callAPI(getStatusRequestObj(false),""String_Node_Str"");
        processErrors(status_check,listener);
        float progress=(float)status_check.getDouble(BobikConstants.PROGRESS_JSON_LABEL);
        estimated_completion_time_ms=status_check.getInt(BobikConstants.ESTIMATED_TIME_REMAINING_TOKEN_LABEL);
        listener.onProgress(progress);
        if (progress == 1.0)         fetchScrapedData();
        return progress;
      }
 catch (      Exception e) {
        e.printStackTrace();
        throw new BobikException(e);
      }
    }
    protected void fetchScrapedData() throws BobikException {
      try {
        JSONObject job_data=callAPI(getStatusRequestObj(true),""String_Node_Str"");
        processErrors(job_data,listener);
        scraped_data=job_data.getJSONObject(BobikConstants.RESULTS_TOKEN_LABEL);
      }
 catch (      Exception e) {
        e.printStackTrace();
        throw new BobikException(e);
      }
      listener.onSuccess(scraped_data);
    }
    @Override public boolean cancel(    boolean b){
      try {
        String url=""String_Node_Str"" + id() + ""String_Node_Str"";
        doHttp(url,""String_Node_Str"",new JSONObject());
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      cancelled=true;
      return true;
    }
    @Override public boolean isCancelled(){
      return cancelled;
    }
    @Override public boolean isDone(){
      try {
        return cancelled || scraped_data != null || getProgress() == 1.0;
      }
 catch (      BobikException e) {
        e.printStackTrace();
        return false;
      }
    }
    @Override public JSONObject get() throws InterruptedException, ExecutionException {
      try {
        waitForCompletion();
      }
 catch (      Exception e) {
        throw new ExecutionException(e);
      }
      return scraped_data;
    }
    @Override public JSONObject get(    long l,    TimeUnit timeUnit) throws InterruptedException, ExecutionException, TimeoutException {
      return get();
    }
    private boolean checkTimer() throws BobikException {
      if (System.currentTimeMillis() - startTime > timeoutMs)       throw new BobikException(""String_Node_Str"" + timeoutMs + ""String_Node_Str"");
      return true;
    }
    @Override public void waitForCompletion() throws BobikException {
      if (job_waiter == null) {
        job_waiter=runners.submit(new Callable<Object>(){
          @Override public Object call() throws Exception {
            while (checkTimer() && getProgress() != 1.0) {
              try {
                Thread.sleep(estimated_completion_time_ms);
              }
 catch (              InterruptedException e) {
                e.printStackTrace();
                new BobikException(e);
              }
            }
            return null;
          }
        }
);
      }
      try {
        job_waiter.get();
      }
 catch (      Exception e) {
        e.printStackTrace();
        new BobikException(e);
      }
    }
  }
;
  listener.init(job);
  processErrors(job_submission,listener);
  return job;
}","/** 
 * Kicks off an asynchronous scraping job and returns a proxy object. This proxy is only for added convenience of monitoring/cancelling the job. The listener you pass as a parameter does all this and more already.
 * @param request The scraping request, built in accordance with http://usebobik.com/api/docs#func_ref
 * @param listener An object encapsulating various useful callbacks
 * @return proxy to monitor/abort the scraping job
 * @throws BobikException thrown on all Bobik-specific errors
 * @throws IOException thrown on network problems
 * @throws JSONException not common, thrown on surprise JSON parsing errors
 * @throws ExecutionException not common, thrown if there's a client-level error during the scheduling of threads
 * @throws InterruptedException not common, thrown if there's a client-level error during the scheduling of threads
 */
public Job scrape(JSONObject request,final JobListener listener) throws BobikException, IOException, JSONException, ExecutionException, InterruptedException {
  JSONObject job_submission=callAPI(request,""String_Node_Str"");
  processErrors(job_submission,listener);
  final long startTime=System.currentTimeMillis();
  final String job_id=getJobIdOrFail(job_submission);
  final Job job=new Job(){
    private JSONObject scraped_data=null;
    private Future<Object> job_waiter=null;
    private int estimated_completion_time_ms=-1;
    private boolean cancelled=false;
    private JSONObject getStatusRequestObj(    boolean download_results) throws BobikException, JSONException {
      JSONObject progress_check=new JSONObject();
      progress_check.accumulate(BobikConstants.JOB_TOKEN_LABEL,id());
      progress_check.accumulate(BobikConstants.SKIP_DATA_TOKEN_LABEL,!download_results);
      return progress_check;
    }
    @Override public String id(){
      return job_id;
    }
    @Override public float getProgress() throws BobikException {
      try {
        JSONObject status_check=callAPI(getStatusRequestObj(false),""String_Node_Str"");
        processErrors(status_check,listener);
        float progress=(float)status_check.getDouble(BobikConstants.PROGRESS_JSON_LABEL);
        estimated_completion_time_ms=status_check.getInt(BobikConstants.ESTIMATED_TIME_REMAINING_TOKEN_LABEL);
        listener.onProgress(progress);
        if (progress == 1.0)         fetchScrapedData();
        return progress;
      }
 catch (      Exception e) {
        e.printStackTrace();
        throw new BobikException(e);
      }
    }
    protected void fetchScrapedData() throws BobikException {
      try {
        JSONObject job_data=callAPI(getStatusRequestObj(true),""String_Node_Str"");
        processErrors(job_data,listener);
        scraped_data=job_data.getJSONObject(BobikConstants.RESULTS_TOKEN_LABEL);
      }
 catch (      Exception e) {
        e.printStackTrace();
        throw new BobikException(e);
      }
      listener.onSuccess(scraped_data);
    }
    @Override public boolean cancel(    boolean b){
      try {
        String url=""String_Node_Str"" + id() + ""String_Node_Str"";
        doHttp(url,""String_Node_Str"",new JSONObject());
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      cancelled=true;
      return true;
    }
    @Override public boolean isCancelled(){
      return cancelled;
    }
    @Override public boolean isDone(){
      try {
        return cancelled || scraped_data != null || getProgress() == 1.0;
      }
 catch (      BobikException e) {
        e.printStackTrace();
        return false;
      }
    }
    @Override public JSONObject get() throws InterruptedException, ExecutionException {
      try {
        waitForCompletion();
      }
 catch (      Exception e) {
        throw new ExecutionException(e);
      }
      return scraped_data;
    }
    @Override public JSONObject get(    long l,    TimeUnit timeUnit) throws InterruptedException, ExecutionException, TimeoutException {
      return get();
    }
    private boolean checkTimer() throws BobikException {
      if (System.currentTimeMillis() - startTime > timeoutMs)       throw new BobikException(""String_Node_Str"" + timeoutMs + ""String_Node_Str"");
      return true;
    }
    @Override public void waitForCompletion() throws BobikException {
      if (job_waiter == null) {
        job_waiter=runners.submit(new Callable<Object>(){
          @Override public Object call() throws Exception {
            while (checkTimer() && getProgress() != 1.0) {
              try {
                Thread.sleep(estimated_completion_time_ms);
              }
 catch (              InterruptedException e) {
                e.printStackTrace();
                new BobikException(e);
              }
            }
            return null;
          }
        }
);
      }
      try {
        job_waiter.get();
      }
 catch (      Exception e) {
        e.printStackTrace();
        new BobikException(e);
      }
    }
  }
;
  listener.init(job);
  processErrors(job_submission,listener);
  return job;
}"
87350,"/** 
 * Called to Extract errors from a Bobik response and pass them on to user's listener
 * @param bobikResponse
 * @param listener
 * @throws BobikException not common, thrown on surprise parse errors
 */
protected void processErrors(JSONObject bobikResponse,JobListener listener) throws JSONException {
  JSONArray errors;
  try {
    errors=bobikResponse.getJSONArray(BobikConstants.ERROR_TOKEN_LABEL);
  }
 catch (  JSONException e) {
    return;
  }
  if (errors != null && errors.length() > 0) {
    Collection<String> messages=new ArrayList<String>(errors.length());
    for (int i=0; i < errors.length(); i++)     messages.add(errors.getString(i));
    listener.onErrors(messages);
  }
}","/** 
 * Called to extract errors from a Bobik response and pass them on to user's listener
 * @param bobikResponse
 * @param listener
 * @throws BobikException not common, thrown on surprise parse errors
 */
protected void processErrors(JSONObject bobikResponse,JobListener listener) throws JSONException {
  try {
    JSONArray errors=bobikResponse.getJSONArray(BobikConstants.ERROR_TOKEN_LABEL);
    if (errors != null && errors.length() > 0) {
      Collection<String> messages=new ArrayList<String>(errors.length());
      for (int i=0; i < errors.length(); i++)       messages.add(errors.getString(i));
      listener.onErrors(messages);
    }
  }
 catch (  JSONException e) {
    return;
  }
}"
87351,"/** 
 * Returns true if the failure represents one where a retry should occur.
 * @param failure the exception to examine if retry is necessary.
 * @return true if retry is necessary.
 */
public static boolean isRetryException(final Throwable failure){
  return isServerUnavailable(failure) || isUnableToLockRow(failure);
}","/** 
 * Returns true if the failure represents one where a retry should occur.
 * @param failure the exception to examine if retry is necessary.
 * @return true if retry is necessary.
 */
public static boolean isRetryException(final Throwable failure){
  return isServerUnavailable(failure) || isUnableToLockRow(failure) || isServiceUnavailable(failure);
}"
87352,"/** 
 * This constructor sets the sessionMgr to use, the type of web service and the class of the web service being used.
 * @param sessionMgr     manages our sessions with SFDC.
 * @param webServiceType the type of web service being used.
 * @throws IllegalArgumentException if sessionMgr, webServiceType or serviceClass are null.
 */
public SalesforceWebServicePortInvoker(final SessionMgr sessionMgr,final WebServiceTypeEnum webServiceType){
  this.sessionMgr=IntegrityUtil.ensure(sessionMgr,""String_Node_Str"");
  this.webServiceType=IntegrityUtil.ensure(webServiceType,""String_Node_Str"");
}","/** 
 * This constructor sets the sessionMgr to use, the type of web service and the class of the web service being used.
 * @param < P >
 * @param sessionMgr     manages our sessions with SFDC.
 * @param webServiceType the type of web service being used.
 * @throws IllegalArgumentException if sessionMgr, webServiceType or serviceClass are null.
 */
public <P>SalesforceWebServicePortInvoker(final WebService<P> service,final SessionMgr sessionMgr,final WebServiceTypeEnum webServiceType){
  this.sessionMgr=IntegrityUtil.ensure(sessionMgr,""String_Node_Str"");
  this.webServiceType=IntegrityUtil.ensure(webServiceType,""String_Node_Str"");
  this.port=new AtomicReference(SalesforceWebServiceUtil.createPort(sessionMgr.getSession(),webServiceType,service));
}"
87353,"/** 
 * When an exception happens on call, this method will handle the exception.
 * @param callFailure the exception that arose when calling SFDC.
 * @param method      the method being called when the failure arose.
 * @param session     the session being used when calling SFDC.
 * @throws Throwable if the exception cannot be handled.
 */
protected void handleException(final Throwable callFailure,final Method method,final Session session) throws Throwable {
  if (ExceptionUtil.isReloginException(callFailure)) {
    getLogger().log(Level.INFO,""String_Node_Str"",method.getName());
    getSessionMgr().resetSession(session);
  }
 else   if (ExceptionUtil.isRetryException(callFailure)) {
    getLogger().log(Level.WARNING,""String_Node_Str"",new Object[]{method.getName(),callFailure.getLocalizedMessage()});
    pause(new byte[0]);
  }
 else {
    getLogger().log(Level.FINE,""String_Node_Str"",new Object[]{method.getName(),callFailure.getLocalizedMessage()});
    throw callFailure;
  }
}","/** 
 * When an exception happens on call, this method will handle the exception.
 * @param callFailure the exception that arose when calling SFDC.
 * @param method      the method being called when the failure arose.
 * @param session     the session being used when calling SFDC.
 * @throws Throwable if the exception cannot be handled.
 */
protected void handleException(final Throwable callFailure,final WebService webService,final Object proxy,final Method method,final Session session,final int totalCalls) throws Throwable {
  if (ExceptionUtil.isReloginException(callFailure)) {
    getLogger().log(Level.INFO,""String_Node_Str"",new Object[]{method.getName(),totalCalls});
    getSessionMgr().resetSession(session);
    port.set(SalesforceWebServiceUtil.createPort(session,getWebServiceType(),webService));
  }
 else   if (ExceptionUtil.isRetryException(callFailure)) {
    getLogger().log(Level.WARNING,""String_Node_Str"",new Object[]{method.getName(),totalCalls});
    pause(new byte[0],totalCalls);
  }
 else {
    getLogger().log(Level.FINE,""String_Node_Str"" + method.getName() + ""String_Node_Str"",callFailure);
    throw callFailure;
  }
}"
87354,"/** 
 * {@inheritDoc}
 */
@Override public Object invoke(final WebService webService,final Object proxy,final Method method,final Object[] args) throws Throwable {
  int totalCalls=0;
  getLogger().log(Level.FINE,""String_Node_Str"",method.getName());
  Session session=null;
  while (isCallable(totalCalls++)) {
    try {
      session=getSessionMgr().getSession();
      return method.invoke(SalesforceWebServiceUtil.createPort(session,getWebServiceType(),webService),args);
    }
 catch (    final Exception callFailure) {
      handleException(callFailure,method,session);
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public Object invoke(final WebService webService,final Object proxy,final Method method,final Object[] args) throws Throwable {
  int totalCalls=0;
  getLogger().log(Level.FINE,""String_Node_Str"",method.getName());
  Session session=null;
  while (isCallable(totalCalls++)) {
    try {
      session=getSessionMgr().getSession();
      final Object retVal=method.invoke(port.get(),args);
      return retVal;
    }
 catch (    final Exception callFailure) {
      handleException(callFailure,webService,proxy,method,session,totalCalls);
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}"
87355,"/** 
 * Pauses execution.
 */
void pause(final Object lock){
  try {
    getLogger().log(Level.INFO,""String_Node_Str"");
synchronized (lock) {
      lock.wait(DEFAULT_PAUSE_TIME);
    }
  }
 catch (  final InterruptedException ex) {
    getLogger().log(Level.WARNING,""String_Node_Str"",ex);
  }
}","/** 
 * Pauses execution.
 */
void pause(final Object lock,final int totalCalls){
  try {
    final long waitTime=RANDOM_PAUSE.nextInt(DEFAULT_PAUSE_TIME);
    getLogger().log(Level.INFO,""String_Node_Str"",new Object[]{waitTime,totalCalls});
synchronized (lock) {
      lock.wait(waitTime);
    }
  }
 catch (  final InterruptedException ex) {
    getLogger().log(Level.WARNING,""String_Node_Str"",ex);
  }
}"
87356,"/** 
 * Create a port usind data from the sessionMgr.
 * @param < P >            the type of web service endpoint.
 * @param sessionMgr     contains a session which contains a loginResult, containing a session id to use for SFDC.
 * @param webServiceType the type of web service.
 * @param service        the web service.
 * @return a usable port.
 */
public static <P>P createPort(final SessionMgr sessionMgr,final WebServiceTypeEnum webServiceType,final WebService<P> service){
  return createPort(sessionMgr.getSession(),webServiceType,service);
}","/** 
 * Create a port usind data from the sessionMgr.
 * @param < P >            the type of web service endpoint.
 * @param sessionMgr     contains a session which contains a loginResult, containing a session id to use for SFDC.
 * @param webServiceType the type of web service.
 * @param service        the web service.
 * @return a usable port.
 */
public static <P>P createPort(final SessionMgr sessionMgr,final WebServiceTypeEnum webServiceType,final WebService<P> service){
  service.getPort();
  return createPort(sessionMgr.getSession(),webServiceType,service);
}"
87357,"/** 
 * Create a proxied port. This manages auto login and retries when calling SFDC.
 * @param < P >            the type of web service endpoint.
 * @param sessionMgr     will be used to create sessions for SFDC calls.
 * @param webServiceType the type of web service being used.
 * @param service        the web service.
 * @return a usable port.
 */
public static <P>P createProxyPort(final SessionMgr sessionMgr,final WebServiceTypeEnum webServiceType,final WebService<P> service){
  return new WebServiceInvocationDecorator<>(service,new SalesforceWebServicePortInvoker(sessionMgr,webServiceType)).getPort();
}","/** 
 * Create a proxied port. This manages auto login and retries when calling SFDC.
 * @param < P >            the type of web service endpoint.
 * @param sessionMgr     will be used to create sessions for SFDC calls.
 * @param webServiceType the type of web service being used.
 * @param service        the web service.
 * @return a usable port.
 */
public static <P>P createProxyPort(final SessionMgr sessionMgr,final WebServiceTypeEnum webServiceType,final WebService<P> service){
  service.getPort();
  return new WebServiceInvocationDecorator<>(service,new SalesforceWebServicePortInvoker(service,sessionMgr,webServiceType)).getPort();
}"
87358,"@Override public String getLocation(final OverlayWidget overlayWidget,final String languageIso,final boolean childrenIncluded){
  if (overlayWidget == null)   return null;
  final List<OverlayWidget> path=overlayWidget.getParentOverlayWidgets();
  path.add(overlayWidget);
  final StringBuilder location=new StringBuilder();
  final String splitter=getSplitter(languageIso);
  for (  final OverlayWidget aw : path) {
    final Collection<Class<? extends OverlayWidget>> filtered=Collections2.filter(hiddenAmendableWidgets,new Predicate<Class<? extends OverlayWidget>>(){
      @Override public boolean apply(      Class<? extends OverlayWidget> input){
        return !ClassUtils.isAssignableFrom(input.getClass(),aw.getClass());
      }
    }
);
    if (!filtered.contains(aw.getClass()) || showAmendableWidgets.contains(aw.getClass())) {
      if (aw.getParentOverlayWidget() == null) {
        location.append(getRootNotation(aw,languageIso));
      }
 else {
        if (aw.getParentOverlayWidget().getType().equalsIgnoreCase(aw.getType())) {
          location.append(getSubNotation(aw,languageIso));
        }
 else {
          location.append(getNotation(aw,languageIso));
        }
        final String num=getNum(aw,languageIso,false);
        if (num != null && !(""String_Node_Str"".equals(num.trim()))) {
          location.append(""String_Node_Str"").append(num);
        }
 else         if (path.indexOf(aw) == path.size() - 1) {
          location.append(""String_Node_Str"").append(aw.getTypeIndex() + 1);
        }
        if (aw.isIntroducedByAnAmendment())         location.append(""String_Node_Str"").append(getNewNotation(languageIso));
      }
      location.append(splitter);
    }
    if (hideUnderLayingAmendableWidgets.contains(aw.getClass())) {
      break;
    }
  }
  final String locationString=location.toString().endsWith(splitter) ? location.substring(0,location.length() - splitter.length()) : location.toString();
  return locationString.trim();
}","@Override public String getLocation(final OverlayWidget overlayWidget,final String languageIso,final boolean childrenIncluded){
  if (overlayWidget == null)   return null;
  final List<OverlayWidget> path=overlayWidget.getParentOverlayWidgets();
  path.add(overlayWidget);
  final StringBuilder location=new StringBuilder();
  final String splitter=getSplitter(languageIso);
  for (  final OverlayWidget aw : path) {
    final Collection<Class<? extends OverlayWidget>> filtered=Collections2.filter(hiddenAmendableWidgets,new Predicate<Class<? extends OverlayWidget>>(){
      @Override public boolean apply(      Class<? extends OverlayWidget> input){
        return !ClassUtils.isAssignableFrom(input.getClass(),aw.getClass());
      }
    }
);
    if (!filtered.contains(aw.getClass()) || showAmendableWidgets.contains(aw.getClass())) {
      if (aw.getParentOverlayWidget() == null) {
        location.append(getRootNotation(aw,languageIso));
      }
 else {
        if (aw.getParentOverlayWidget().getType().equalsIgnoreCase(aw.getType())) {
          location.append(getSubNotation(aw,languageIso));
        }
 else {
          location.append(getNotation(aw,languageIso));
        }
        final String num=getNum(aw,languageIso,false);
        if (num != null && !(""String_Node_Str"".equals(num.trim()))) {
          location.append(""String_Node_Str"").append(num);
        }
 else {
          location.append(""String_Node_Str"").append(aw.getTypeIndex() + 1);
        }
        if (aw.isIntroducedByAnAmendment())         location.append(""String_Node_Str"").append(getNewNotation(languageIso));
      }
      location.append(splitter);
    }
    if (hideUnderLayingAmendableWidgets.contains(aw.getClass())) {
      break;
    }
  }
  final String locationString=location.toString().endsWith(splitter) ? location.substring(0,location.length() - splitter.length()) : location.toString();
  return locationString.trim();
}"
87359,"/** 
 * Guesses the   {@link Format}based on the literal index provided for this element.
 * @return the type
 */
private Format guessFormat(Element element){
  String literalIndex=getLiteralIndex(element);
  if (literalIndex != null) {
    literalIndex=TextUtils.stripTags(literalIndex.trim(),false);
    if (literalIndex.toLowerCase().startsWith(getType(element))) {
      return Format.ELEMENT;
    }
    if (literalIndex.startsWith(""String_Node_Str""))     return Format.DOUBLE_BRACKET;
    if (literalIndex.endsWith(""String_Node_Str""))     return Format.POINT;
    if (literalIndex.endsWith(""String_Node_Str""))     return Format.BRACKET;
  }
  return Format.NONE;
}","/** 
 * Guesses the   {@link Format}based on the literal index provided for this element.
 * @return the type
 */
private Format guessFormat(Element element){
  String literalIndex=getLiteralIndex(element);
  if (literalIndex != null) {
    literalIndex=TextUtils.stripTags(literalIndex.trim(),false);
    final String type=getType(element);
    if (type != null && literalIndex.toLowerCase().startsWith(type)) {
      return Format.ELEMENT;
    }
    if (literalIndex.startsWith(""String_Node_Str""))     return Format.DOUBLE_BRACKET;
    if (literalIndex.endsWith(""String_Node_Str""))     return Format.POINT;
    if (literalIndex.endsWith(""String_Node_Str""))     return Format.BRACKET;
  }
  return Format.NONE;
}"
87360,"@Override public void setOrigin(OverlayWidgetOrigin origin){
  this.origin=origin;
  if (overlayStrategy != null) {
    overlayStrategy.setOrigin(getOverlayElement(),origin.name());
  }
}","@Override public void setOrigin(OverlayWidgetOrigin origin){
  this.origin=origin;
  if (overlayStrategy != null) {
    overlayStrategy.setOrigin(getElement(),origin.name());
  }
}"
87361,"/** 
 * Similar   {@link #select(String,org.nsesa.editor.gwt.core.client.ui.overlay.document.OverlayWidget)}, but using recursion.
 * @param split an array of expression parts
 * @param root  the root node
 * @param found a list of {@link OverlayWidget}s to store the matching nodes in
 */
public void select(final String[] split,final OverlayWidget root,final List<OverlayWidget> found){
  if (split != null && split.length > 0) {
    final String expression=split[0];
    for (    final Matcher matcher : MATCHERS) {
      if (matcher.applicable(expression)) {
        if (matcher.matches(expression,root)) {
          if (split.length == 1) {
            found.add(root);
          }
          for (          final OverlayWidget child : root.getChildOverlayWidgets()) {
            final List<String> copy=Arrays.asList(split).subList(1,split.length);
            final String[] tail=copy.toArray(new String[copy.size()]);
            select(tail,child,found);
          }
          break;
        }
      }
    }
  }
}","/** 
 * Similar   {@link #select(String,org.nsesa.editor.gwt.core.client.ui.overlay.document.OverlayWidget)}, but using recursion.
 * @param split         an array of expression parts
 * @param overlayWidget the root node
 * @param found         a list of {@link OverlayWidget}s to store the matching nodes in
 */
public void select(final String[] split,final OverlayWidget overlayWidget,final List<OverlayWidget> found){
  if (split != null && split.length > 0) {
    final String expression=split[0];
    for (    final Matcher matcher : MATCHERS) {
      if (matcher.applicable(expression)) {
        if (matcher.matches(expression,overlayWidget)) {
          if (split.length == 1) {
            found.add(overlayWidget);
          }
 else {
            for (            final OverlayWidget child : overlayWidget.getChildOverlayWidgets()) {
              final List<String> copy=Arrays.asList(split).subList(1,split.length);
              final String[] tail=copy.toArray(new String[copy.size()]);
              select(tail,child,found);
            }
          }
          break;
        }
      }
    }
  }
}"
87362,"public void retrieveRevisions(){
  comparisonProvider.getRevisions(new AsyncCallback<List<RevisionDTO>>(){
    @Override public void onFailure(    Throwable caught){
      clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
    }
    @Override public void onSuccess(    List<RevisionDTO> result){
      view.setAvailableRevisions(result);
      if (result.size() > 1) {
        retrieveRevisionContent(result.get(1).getRevisionID(),result.get(0).getRevisionID());
      }
 else {
        retrieveRevisionContent(result.get(0).getRevisionID(),result.get(0).getRevisionID());
      }
    }
  }
);
}","public void retrieveRevisions(){
  revisionA=null;
  revisionB=null;
  comparisonProvider.getRevisions(new AsyncCallback<List<RevisionDTO>>(){
    @Override public void onFailure(    Throwable caught){
      clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
    }
    @Override public void onSuccess(    List<RevisionDTO> result){
      view.setAvailableRevisions(result);
      if (result.size() > 1) {
        retrieveRevisionContent(result.get(1).getRevisionID(),result.get(0).getRevisionID());
      }
 else {
        retrieveRevisionContent(result.get(0).getRevisionID(),result.get(0).getRevisionID());
      }
    }
  }
);
}"
87363,"/** 
 * Registers the listeners for events that are being fired by the deadline tracker.
 */
private void registerListeners(){
  deadlinePassedEventHandlerRegistration=documentEventBus.addHandler(DeadlinePassedEvent.TYPE,new DeadlinePassedEventHandler(){
    @Override public void onEvent(    DeadlinePassedEvent event){
      if (event.getDocumentController() == documentController) {
        view.setPastStyle();
        view.setDeadline(getFormattedDeadline());
      }
    }
  }
);
  hour24DeadlineEventHandlerRegistration=documentEventBus.addHandler(Deadline24HourEvent.TYPE,new Deadline24HourEventHandler(){
    @Override public void onEvent(    Deadline24HourEvent event){
      if (event.getDocumentController() == documentController) {
        view.set24HourStyle();
        view.setDeadline(getFormattedDeadline());
      }
    }
  }
);
  hour1DeadlineEventHandlerRegistration=documentEventBus.addHandler(Deadline1HourEvent.TYPE,new Deadline1HourEventHandler(){
    @Override public void onEvent(    Deadline1HourEvent event){
      if (event.getDocumentController() == documentController) {
        view.set1HourStyle();
        view.setDeadline(getFormattedDeadline());
      }
    }
  }
);
}","/** 
 * Registers the listeners for events that are being fired by the deadline tracker.
 */
private void registerListeners(){
  deadlinePassedEventHandlerRegistration=documentEventBus.addHandler(DeadlinePassedEvent.TYPE,new DeadlinePassedEventHandler(){
    @Override public void onEvent(    DeadlinePassedEvent event){
      if (event.getDocumentController() == documentController) {
        view.setPastStyle();
        view.setDeadline(getFormattedDeadlineMessage());
      }
    }
  }
);
  hour24DeadlineEventHandlerRegistration=documentEventBus.addHandler(Deadline24HourEvent.TYPE,new Deadline24HourEventHandler(){
    @Override public void onEvent(    Deadline24HourEvent event){
      if (event.getDocumentController() == documentController) {
        view.set24HourStyle();
        view.setDeadline(getFormattedDeadlineMessage());
      }
    }
  }
);
  hour1DeadlineEventHandlerRegistration=documentEventBus.addHandler(Deadline1HourEvent.TYPE,new Deadline1HourEventHandler(){
    @Override public void onEvent(    Deadline1HourEvent event){
      if (event.getDocumentController() == documentController) {
        view.set1HourStyle();
        view.setDeadline(getFormattedDeadlineMessage());
      }
    }
  }
);
}"
87364,"@Override public void onEvent(Deadline1HourEvent event){
  if (event.getDocumentController() == documentController) {
    view.set1HourStyle();
    view.setDeadline(getFormattedDeadline());
  }
}","@Override public void onEvent(Deadline1HourEvent event){
  if (event.getDocumentController() == documentController) {
    view.set1HourStyle();
    view.setDeadline(getFormattedDeadlineMessage());
  }
}"
87365,"/** 
 * Sets a new deadline and schedules the timers to fire accordingly.
 * @param deadline the deadline.
 */
public void setDeadline(Date deadline){
  timer24hour.cancel();
  timer1hour.cancel();
  timer0hour.cancel();
  if (deadline != null) {
    final Date aDayBeforeTheDeadline=new Date(deadline.getTime());
    aDayBeforeTheDeadline.setHours(aDayBeforeTheDeadline.getHours() - 24);
    final Date anHourBeforeTheDeadline=new Date(deadline.getTime());
    anHourBeforeTheDeadline.setHours(anHourBeforeTheDeadline.getHours() - 1);
    final Date now=new Date();
    if (now.before(deadline)) {
      if (now.before(aDayBeforeTheDeadline)) {
        timer24hour.cancel();
        long diff=aDayBeforeTheDeadline.getTime() - now.getTime();
        final long diffHours=diff / (1000 * 60 * 60);
        LOG.info(""String_Node_Str"" + diffHours + ""String_Node_Str"");
        if (diffHours < 24 * 3) {
          try {
            timer24hour.schedule((int)diff + (60 * 1000));
          }
 catch (          Exception exception) {
            LOG.log(Level.FINER,""String_Node_Str"" + exception.getMessage(),exception);
          }
        }
      }
      if (now.before(anHourBeforeTheDeadline)) {
        timer1hour.cancel();
        long diff=anHourBeforeTheDeadline.getTime() - now.getTime();
        final long diffMinutes=diff / (1000 * 60);
        LOG.info(""String_Node_Str"" + diffMinutes + ""String_Node_Str"");
        if (diffMinutes < 3 * 24 * 60) {
          try {
            timer1hour.schedule((int)diff + (60 * 1000));
          }
 catch (          Exception exception) {
            LOG.log(Level.FINER,""String_Node_Str"" + exception.getMessage(),exception);
          }
        }
      }
      timer0hour.cancel();
      long diff=deadline.getTime() - now.getTime();
      final long diffMinutes=diff / (1000 * 60);
      LOG.info(""String_Node_Str"" + diffMinutes + ""String_Node_Str"");
      if (diffMinutes < 3 * 24 * 60) {
        try {
          timer0hour.schedule((int)diff + (60 * 1000));
        }
 catch (        Exception exception) {
          LOG.log(Level.FINER,""String_Node_Str"" + exception.getMessage(),exception);
        }
      }
    }
    if (now.before(deadline)) {
      if (now.after(anHourBeforeTheDeadline)) {
        timer1hour.run();
      }
 else       if (now.after(aDayBeforeTheDeadline)) {
        timer24hour.run();
      }
    }
 else {
      timer0hour.run();
    }
  }
}","/** 
 * Sets a new deadline and schedules the timers to fire accordingly.
 * @param deadline the deadline.
 */
public void setDeadline(Date deadline){
  timer24hour.cancel();
  timer1hour.cancel();
  timer0hour.cancel();
  if (deadline != null) {
    final Date aDayBeforeTheDeadline=new Date(deadline.getTime());
    aDayBeforeTheDeadline.setHours(aDayBeforeTheDeadline.getHours() - 24);
    final Date anHourBeforeTheDeadline=new Date(deadline.getTime());
    anHourBeforeTheDeadline.setHours(anHourBeforeTheDeadline.getHours() - 1);
    final Date now=getNow();
    if (now.before(deadline)) {
      if (now.before(aDayBeforeTheDeadline)) {
        timer24hour.cancel();
        long diff=aDayBeforeTheDeadline.getTime() - now.getTime();
        final long diffHours=diff / (1000 * 60 * 60);
        LOG.info(""String_Node_Str"" + diffHours + ""String_Node_Str"");
        if (diffHours < 24 * 3) {
          try {
            timer24hour.schedule((int)diff + (60 * 1000));
          }
 catch (          Exception exception) {
            LOG.log(Level.FINER,""String_Node_Str"" + exception.getMessage(),exception);
          }
        }
      }
      if (now.before(anHourBeforeTheDeadline)) {
        timer1hour.cancel();
        long diff=anHourBeforeTheDeadline.getTime() - now.getTime();
        final long diffMinutes=diff / (1000 * 60);
        LOG.info(""String_Node_Str"" + diffMinutes + ""String_Node_Str"");
        if (diffMinutes < 3 * 24 * 60) {
          try {
            timer1hour.schedule((int)diff + (60 * 1000));
          }
 catch (          Exception exception) {
            LOG.log(Level.FINER,""String_Node_Str"" + exception.getMessage(),exception);
          }
        }
      }
      timer0hour.cancel();
      long diff=deadline.getTime() - now.getTime();
      final long diffMinutes=diff / (1000 * 60);
      LOG.info(""String_Node_Str"" + diffMinutes + ""String_Node_Str"");
      if (diffMinutes < 3 * 24 * 60) {
        try {
          timer0hour.schedule((int)diff + (60 * 1000));
        }
 catch (        Exception exception) {
          LOG.log(Level.FINER,""String_Node_Str"" + exception.getMessage(),exception);
        }
      }
    }
    if (now.before(deadline)) {
      if (now.after(aDayBeforeTheDeadline)) {
        timer24hour.run();
      }
 else       if (now.after(anHourBeforeTheDeadline)) {
        timer1hour.run();
      }
    }
 else {
      timer0hour.run();
    }
  }
}"
87366,"/** 
 * Merge an amendment container DTO from the backend into the current list of amendment controllers.
 * @param toMerge the amendment container DTOs to merge
 */
protected void mergeAmendmentContainerDTOs(AmendmentContainerDTO... toMerge){
  if (toMerge != null) {
    final ClientFactory clientFactory=documentController.getClientFactory();
    for (    final AmendmentContainerDTO amendmentContainerDTO : toMerge) {
      final AmendmentController amendmentController=documentController.getInjector().getAmendmentController();
      amendmentController.setModel(amendmentContainerDTO);
      amendmentController.setDocumentController(documentController);
      int indexOfOlderRevision=-1;
      int counter=0;
      for (      final AmendmentController ac : amendmentControllers) {
        if (amendmentController.getModel().getId().equals(ac.getModel().getId())) {
          indexOfOlderRevision=counter;
          break;
        }
        counter++;
      }
      if (indexOfOlderRevision != -1) {
        final AmendmentController removed=amendmentControllers.remove(indexOfOlderRevision);
        amendmentControllers.add(indexOfOlderRevision,amendmentController);
        if (!removed.getDocumentController().equals(amendmentController.getDocumentController())) {
          throw new RuntimeException(""String_Node_Str"");
        }
        LOG.info(""String_Node_Str"" + removed + ""String_Node_Str""+ amendmentController);
        documentEventBus.fireEvent(new AmendmentContainerUpdatedEvent(removed,amendmentController));
      }
 else {
        amendmentControllers.add(amendmentController);
        LOG.info(""String_Node_Str"" + amendmentController);
        documentEventBus.fireEvent(new AmendmentContainerInjectEvent(toMerge));
      }
      documentEventBus.fireEvent(new AmendmentContainerSavedEvent(amendmentController));
    }
    documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionSaveSuccessful(toMerge.length)));
  }
}","/** 
 * Merge an amendment container DTO from the backend into the current list of amendment controllers.
 * @param toMerge the amendment container DTOs to merge
 */
protected void mergeAmendmentContainerDTOs(AmendmentContainerDTO... toMerge){
  if (toMerge != null) {
    final ClientFactory clientFactory=documentController.getClientFactory();
    for (    final AmendmentContainerDTO amendmentContainerDTO : toMerge) {
      final AmendmentController amendmentController=createAmendmentController(amendmentContainerDTO);
      int indexOfOlderRevision=-1;
      int counter=0;
      for (      final AmendmentController ac : amendmentControllers) {
        if (amendmentController.getModel().getId().equals(ac.getModel().getId())) {
          indexOfOlderRevision=counter;
          break;
        }
        counter++;
      }
      if (indexOfOlderRevision != -1) {
        final AmendmentController removed=amendmentControllers.remove(indexOfOlderRevision);
        amendmentControllers.add(indexOfOlderRevision,amendmentController);
        if (!removed.getDocumentController().equals(amendmentController.getDocumentController())) {
          throw new RuntimeException(""String_Node_Str"");
        }
        LOG.info(""String_Node_Str"" + removed + ""String_Node_Str""+ amendmentController);
        documentEventBus.fireEvent(new AmendmentContainerUpdatedEvent(removed,amendmentController));
      }
 else {
        amendmentControllers.add(amendmentController);
        LOG.info(""String_Node_Str"" + amendmentController);
        documentEventBus.fireEvent(new AmendmentContainerInjectEvent(toMerge));
      }
      documentEventBus.fireEvent(new AmendmentContainerSavedEvent(amendmentController));
    }
    documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionSaveSuccessful(toMerge.length)));
  }
}"
87367,"/** 
 * Creates a simple   {@link AmendmentController} associated with a given <tt>amendmentContainerDTO</tt>
 * @param amendmentContainerDTO the amendment container DTO to create a controller for
 * @return the controller
 */
private AmendmentController createAmendmentController(final AmendmentContainerDTO amendmentContainerDTO){
  final AmendmentController amendmentController=documentController.getInjector().getAmendmentController();
  amendmentController.registerListeners();
  amendmentController.registerViews();
  amendmentController.setModel(amendmentContainerDTO);
  amendmentController.setDocumentController(documentController);
  return amendmentController;
}","/** 
 * Creates a simple   {@link AmendmentController} associated with a given <tt>amendmentContainerDTO</tt>
 * @param amendmentContainerDTO the amendment container DTO to create a controller for
 * @return the controller
 */
private AmendmentController createAmendmentController(final AmendmentContainerDTO amendmentContainerDTO){
  final AmendmentController amendmentController=documentController.getInjector().getAmendmentController();
  amendmentController.registerViews();
  amendmentController.registerListeners();
  amendmentController.setModel(amendmentContainerDTO);
  amendmentController.setDocumentController(documentController);
  return amendmentController;
}"
87368,"@Override public String getLocation(final OverlayWidget parentOverlayWidget,final OverlayWidget newChild,final String languageIso,final boolean childrenIncluded){
  if (parentOverlayWidget == null)   return null;
  final List<OverlayWidget> path=parentOverlayWidget.getParentOverlayWidgets();
  path.add(parentOverlayWidget);
  if (newChild != null) {
    path.add(newChild);
  }
  final StringBuilder location=new StringBuilder();
  final String splitter=getSplitter(languageIso);
  for (  final OverlayWidget aw : path) {
    final Collection<Class<? extends OverlayWidget>> filtered=Collections2.filter(hiddenAmendableWidgets,new Predicate<Class<? extends OverlayWidget>>(){
      @Override public boolean apply(      Class<? extends OverlayWidget> input){
        return !ClassUtils.isAssignableFrom(input.getClass(),aw.getClass());
      }
    }
);
    if (!filtered.contains(aw.getClass()) || showAmendableWidgets.contains(aw.getClass())) {
      if (aw.getParentOverlayWidget() == null) {
        location.append(getRootNotation(aw,languageIso));
      }
 else {
        if (aw.getParentOverlayWidget().getType().equalsIgnoreCase(aw.getType())) {
          location.append(getSubNotation(aw,languageIso));
        }
 else {
          location.append(getNotation(aw,languageIso));
        }
        final String num=getNum(aw,languageIso,false);
        if (num != null && !(""String_Node_Str"".equals(num.trim()))) {
          location.append(""String_Node_Str"").append(num);
          if (aw.isIntroducedByAnAmendment())           location.append(""String_Node_Str"").append(getNewNotation(languageIso));
        }
      }
      location.append(splitter);
    }
    if (hideUnderLayingAmendableWidgets.contains(aw.getClass())) {
      break;
    }
  }
  final String locationString=location.toString().endsWith(splitter) ? location.substring(0,location.length() - splitter.length()) : location.toString();
  return locationString.trim();
}","@Override public String getLocation(final OverlayWidget overlayWidget,final String languageIso,final boolean childrenIncluded){
  if (overlayWidget == null)   return null;
  final List<OverlayWidget> path=overlayWidget.getParentOverlayWidgets();
  path.add(overlayWidget);
  final StringBuilder location=new StringBuilder();
  final String splitter=getSplitter(languageIso);
  for (  final OverlayWidget aw : path) {
    final Collection<Class<? extends OverlayWidget>> filtered=Collections2.filter(hiddenAmendableWidgets,new Predicate<Class<? extends OverlayWidget>>(){
      @Override public boolean apply(      Class<? extends OverlayWidget> input){
        return !ClassUtils.isAssignableFrom(input.getClass(),aw.getClass());
      }
    }
);
    if (!filtered.contains(aw.getClass()) || showAmendableWidgets.contains(aw.getClass())) {
      if (aw.getParentOverlayWidget() == null) {
        location.append(getRootNotation(aw,languageIso));
      }
 else {
        if (aw.getParentOverlayWidget().getType().equalsIgnoreCase(aw.getType())) {
          location.append(getSubNotation(aw,languageIso));
        }
 else {
          location.append(getNotation(aw,languageIso));
        }
        final String num=getNum(aw,languageIso,false);
        if (num != null && !(""String_Node_Str"".equals(num.trim()))) {
          location.append(""String_Node_Str"").append(num);
          if (aw.isIntroducedByAnAmendment())           location.append(""String_Node_Str"").append(getNewNotation(languageIso));
        }
      }
      location.append(splitter);
    }
    if (hideUnderLayingAmendableWidgets.contains(aw.getClass())) {
      break;
    }
  }
  final String locationString=location.toString().endsWith(splitter) ? location.substring(0,location.length() - splitter.length()) : location.toString();
  return locationString.trim();
}"
87369,"/** 
 * Get the injection point expression for a given <tt>overlayWidget</tt>. This expression uniquely identifies the position within its own branch up to the root.
 * @param reference the overlay widget to find the position expression for
 * @return the injection point expression (xpath like).
 */
@Override public AmendableWidgetReference getInjectionPoint(final OverlayWidget parent,final OverlayWidget reference,final OverlayWidget overlayWidget){
  AmendableWidgetReference injectionPoint;
  final String xPath=findXPathExpressionToOverlayWidget(reference);
  if (overlayWidget != null) {
    final boolean sibling=parent != reference;
    final int injectionPosition=overlayWidgetInjectionStrategy.getInjectionPosition(sibling ? reference.getParentOverlayWidget() : reference,reference,overlayWidget);
    injectionPoint=new AmendableWidgetReference(true,sibling,xPath,overlayWidget.getNamespaceURI(),overlayWidget.getType(),sibling ? (injectionPosition - reference.getParentOverlayWidget().getChildOverlayWidgets().indexOf(reference)) : injectionPosition);
  }
 else {
    injectionPoint=new AmendableWidgetReference(false,false,xPath,reference.getNamespaceURI(),reference.getType(),-1);
  }
  injectionPoint.setReferenceID(UUID.uuid());
  LOG.info(""String_Node_Str"" + injectionPoint);
  return injectionPoint;
}","/** 
 * Get the injection point expression for a given <tt>overlayWidget</tt>. This expression uniquely identifies the position within its own branch up to the root.
 * @param reference the overlay widget to find the position expression for
 * @return the injection point expression (xpath like).
 */
@Override public AmendableWidgetReference getInjectionPoint(final OverlayWidget parent,final OverlayWidget reference,final OverlayWidget overlayWidget){
  AmendableWidgetReference injectionPoint;
  final String xPath=findXPathExpressionToOverlayWidget(reference);
  if (overlayWidget.isIntroducedByAnAmendment()) {
    final boolean sibling=parent != reference;
    final int injectionPosition=overlayWidgetInjectionStrategy.getInjectionPosition(sibling ? reference.getParentOverlayWidget() : reference,reference,overlayWidget);
    injectionPoint=new AmendableWidgetReference(true,sibling,xPath,overlayWidget.getNamespaceURI(),overlayWidget.getType(),sibling ? (injectionPosition - reference.getParentOverlayWidget().getChildOverlayWidgets().indexOf(reference)) : injectionPosition);
  }
 else {
    injectionPoint=new AmendableWidgetReference(false,false,xPath,reference.getNamespaceURI(),reference.getType(),-1);
  }
  injectionPoint.setReferenceID(UUID.uuid());
  LOG.info(""String_Node_Str"" + injectionPoint);
  return injectionPoint;
}"
87370,"/** 
 * Get the injection point expression for a given <tt>overlayWidget</tt>. This expression uniquely identifies the position within its own branch up to the root.
 * @param reference the overlay widget to find the position expression for
 * @return the injection point expression (xpath like).
 */
@Override public AmendableWidgetReference getInjectionPoint(final OverlayWidget parent,final OverlayWidget reference,final OverlayWidget child){
  AmendableWidgetReference injectionPoint;
  final String xPath=findXPathExpressionToOverlayWidget(reference);
  if (child != null) {
    final boolean sibling=parent != reference;
    injectionPoint=new AmendableWidgetReference(true,sibling,xPath,child.getNamespaceURI(),child.getType(),overlayWidgetInjectionStrategy.getInjectionPosition(sibling ? reference.getParentOverlayWidget() : reference,reference,child));
  }
 else {
    injectionPoint=new AmendableWidgetReference(false,false,xPath,reference.getNamespaceURI(),reference.getType(),-1);
  }
  injectionPoint.setReferenceID(UUID.uuid());
  return injectionPoint;
}","/** 
 * Get the injection point expression for a given <tt>overlayWidget</tt>. This expression uniquely identifies the position within its own branch up to the root.
 * @param reference the overlay widget to find the position expression for
 * @return the injection point expression (xpath like).
 */
@Override public AmendableWidgetReference getInjectionPoint(final OverlayWidget parent,final OverlayWidget reference,final OverlayWidget child){
  AmendableWidgetReference injectionPoint;
  final String xPath=findXPathExpressionToOverlayWidget(reference);
  if (child != null) {
    final boolean sibling=parent != reference;
    final int injectionPosition=overlayWidgetInjectionStrategy.getInjectionPosition(sibling ? reference.getParentOverlayWidget() : reference,reference,child);
    injectionPoint=new AmendableWidgetReference(true,sibling,xPath,child.getNamespaceURI(),child.getType(),sibling ? (injectionPosition - reference.getParentOverlayWidget().getChildOverlayWidgets().indexOf(reference)) : injectionPosition);
  }
 else {
    injectionPoint=new AmendableWidgetReference(false,false,xPath,reference.getNamespaceURI(),reference.getType(),-1);
  }
  injectionPoint.setReferenceID(UUID.uuid());
  LOG.info(""String_Node_Str"" + injectionPoint);
  return injectionPoint;
}"
87371,"@Override public int getInjectionPosition(){
  if (injectionPosition == null)   throw new RuntimeException(""String_Node_Str"");
  return injectionPosition;
}","@Override public int getInjectionPosition(){
  if (amendment.getSourceReference() == null)   throw new RuntimeException(""String_Node_Str"");
  return amendment.getSourceReference().getOffset();
}"
87372,"/** 
 * Get the number for a given <tt>overlayWidget</tt>. The reported number depends various cases, but can be thought of in general that if the   {@link NumberingType} is constant, the {@link org.nsesa.editor.gwt.core.client.ui.overlay.document.OverlayWidget#getTypeIndex()}will instead be used to remove confusion about the path.
 * @param overlayWidget the overlay widget to get the number for
 * @param languageIso   the ISO code of the language
 * @return the number, should never return <tt>null</tt>
 */
@Override public String getNum(final OverlayWidget overlayWidget,final String languageIso){
  String index;
  if (overlayWidget.isIntroducedByAnAmendment()) {
    final OverlayWidget previous=overlayWidget.getPreviousSibling(new OverlayWidgetSelector(){
      @Override public boolean select(      OverlayWidget toSelect){
        return !toSelect.isIntroducedByAnAmendment() && overlayWidget.getType().equalsIgnoreCase(toSelect.getType());
      }
    }
);
    if (previous == null) {
      OverlayWidget next=overlayWidget.getNextSibling(new OverlayWidgetSelector(){
        @Override public boolean select(        OverlayWidget toSelect){
          return !toSelect.isIntroducedByAnAmendment() && overlayWidget.getType().equalsIgnoreCase(toSelect.getType());
        }
      }
);
      if (next == null) {
        index=Integer.toString(overlayWidget.getTypeIndex(true) + 1);
      }
 else {
        index=""String_Node_Str"" + NumberingType.LETTER.get(overlayWidget.getTypeIndex(true));
      }
    }
 else {
      String previousIndex=previous.getUnformattedIndex() != null ? previous.getUnformattedIndex() : Integer.toString(previous.getTypeIndex() + 1);
      int offset=overlayWidget.getTypeIndex(true) - previous.getTypeIndex();
      previousIndex+=NumberingType.LETTER.get(offset - 1);
      index=previousIndex;
    }
    return index + ""String_Node_Str"" + getNewNotation(languageIso);
  }
 else {
    final NumberingType numberingType=overlayWidget.getNumberingType();
    if (numberingType != null) {
      if (!numberingType.isConstant()) {
        final String unformattedIndex=overlayWidget.getUnformattedIndex();
        if (unformattedIndex != null) {
          return unformattedIndex;
        }
      }
    }
    return Integer.toString(overlayWidget.getTypeIndex() + 1);
  }
}","/** 
 * Get the number for a given <tt>overlayWidget</tt>. The reported number depends various cases, but can be thought of in general that if the   {@link NumberingType} is constant, the {@link org.nsesa.editor.gwt.core.client.ui.overlay.document.OverlayWidget#getTypeIndex()}will instead be used to remove confusion about the path.
 * @param overlayWidget the overlay widget to get the number for
 * @param languageIso   the ISO code of the language
 * @return the number, should never return <tt>null</tt>
 */
@Override public String getNum(final OverlayWidget overlayWidget,final String languageIso){
}"
87373,"@Override public int getInjectionPosition(OverlayWidget parent,OverlayWidget reference,OverlayWidget child){
  return reference.getChildOverlayWidgets().size();
}","@Override public int getInjectionPosition(OverlayWidget parent,OverlayWidget reference,OverlayWidget child){
  boolean sibling=parent != reference;
  if (sibling) {
    return reference.getParentOverlayWidget().getChildOverlayWidgets().indexOf(reference) + 1;
  }
 else {
    return reference.getChildOverlayWidgets().size() - 1;
  }
}"
87374,"@Override public void addOverlayWidget(final OverlayWidget child,int index,boolean skipValidation){
  if (child == null)   throw new NullPointerException(""String_Node_Str"");
  boolean vetoed=false;
  if (listener != null)   vetoed=listener.beforeOverlayWidgetAdded(this,child);
  if (!vetoed) {
    if (!skipValidation) {
      OverlayWidget wildCard=null;
      if (!getAllowedChildTypes().contains(wildCard)) {
        boolean canAdd=false;
        for (        OverlayWidget allowed : getAllowedChildTypes()) {
          if (allowed.getType().equalsIgnoreCase(child.getType()) && allowed.getNamespaceURI().equalsIgnoreCase(child.getNamespaceURI())) {
            canAdd=true;
          }
        }
        if (!canAdd) {
          LOG.warning(getType() + ""String_Node_Str"" + child);
        }
      }
      if (child.getParentOverlayWidget() != null) {
        if (child.getParentOverlayWidget().getChildOverlayWidgets().contains(child)) {
          child.getParentOverlayWidget().removeOverlayWidget(child);
        }
      }
    }
    if (index == -1) {
      if (!childOverlayWidgets.add(child)) {
        throw new RuntimeException(""String_Node_Str"" + child.getType());
      }
    }
 else {
      if (index > childOverlayWidgets.size()) {
        throw new RuntimeException(""String_Node_Str"" + index + ""String_Node_Str""+ childOverlayWidgets.size());
      }
      childOverlayWidgets.add(index,child);
    }
    child.setParentOverlayWidget(this);
    if (listener != null)     listener.afterOverlayWidgetAdded(this,child);
  }
 else {
    LOG.info(""String_Node_Str"");
  }
}","@Override public void addOverlayWidget(final OverlayWidget child,int index,boolean skipValidation){
  if (child == null)   throw new NullPointerException(""String_Node_Str"");
  boolean vetoed=false;
  if (listener != null)   vetoed=listener.beforeOverlayWidgetAdded(this,child);
  if (!vetoed) {
    if (!skipValidation) {
      OverlayWidget wildCard=null;
      if (!getAllowedChildTypes().contains(wildCard)) {
        boolean canAdd=false;
        for (        OverlayWidget allowed : getAllowedChildTypes()) {
          if (allowed.getType().equalsIgnoreCase(child.getType()) && allowed.getNamespaceURI().equalsIgnoreCase(child.getNamespaceURI())) {
            canAdd=true;
          }
        }
        if (!canAdd) {
          LOG.warning(getType() + ""String_Node_Str"" + child);
        }
      }
      if (child.getParentOverlayWidget() != null) {
        if (child.getParentOverlayWidget().getChildOverlayWidgets().contains(child)) {
          child.getParentOverlayWidget().removeOverlayWidget(child);
        }
      }
    }
    if (index == -1 || index == childOverlayWidgets.size()) {
      if (!childOverlayWidgets.add(child)) {
        throw new RuntimeException(""String_Node_Str"" + child.getType());
      }
    }
 else {
      if (index >= childOverlayWidgets.size()) {
        throw new RuntimeException(""String_Node_Str"" + index + ""String_Node_Str""+ childOverlayWidgets.size());
      }
      childOverlayWidgets.add(index,child);
    }
    child.setParentOverlayWidget(this);
    if (listener != null)     listener.afterOverlayWidgetAdded(this,child);
  }
 else {
    LOG.info(""String_Node_Str"");
  }
}"
87375,"@Override public String toString(){
  return ""String_Node_Str"" + type + ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + type + ""String_Node_Str""+ origin+ ""String_Node_Str"";
}"
87376,"/** 
 * Set the active overlay widget
 * @param activeOverlayWidget the active overlay widget
 */
public void setActiveOverlayWidget(OverlayWidget activeOverlayWidget){
  if (this.activeOverlayWidget != null) {
    activeOverlayWidget.asWidget().removeStyleName(style.selected());
  }
  LOG.info(""String_Node_Str"" + activeOverlayWidget + ""String_Node_Str""+ documentController);
  this.activeOverlayWidget=activeOverlayWidget;
  if (this.activeOverlayWidget != null) {
    this.activeOverlayWidget.asWidget().addStyleName(style.selected());
  }
}","/** 
 * Set the active overlay widget
 * @param activeOverlayWidget the active overlay widget
 */
public void setActiveOverlayWidget(OverlayWidget activeOverlayWidget){
  if (this.activeOverlayWidget != null) {
    this.activeOverlayWidget.asWidget().removeStyleName(style.selected());
  }
  LOG.info(""String_Node_Str"" + activeOverlayWidget + ""String_Node_Str""+ documentController);
  this.activeOverlayWidget=activeOverlayWidget;
  if (this.activeOverlayWidget != null) {
    this.activeOverlayWidget.asWidget().addStyleName(style.selected());
  }
}"
87377,"/** 
 * Resizes the dialog, centers and shows the popup.
 */
public void show(){
  overlayWidget.getParentOverlayWidget().asWidget().getElement().insertBefore(view.asWidget().getElement(),overlayWidget.getOverlayElement());
  view.getRichTextEditor().setHTML(overlayWidget.asWidget().getElement().getInnerHTML());
  adaptSize();
  view.asWidget().setVisible(true);
  view.init();
  view.getRichTextEditor().setOverlayWidget(overlayWidget);
  overlayWidget.asWidget().setVisible(false);
  showing=true;
}","/** 
 * Resizes the dialog, centers and shows the popup.
 */
public void show(){
  overlayWidget.getParentOverlayWidget().asWidget().getElement().insertBefore(view.asWidget().getElement(),overlayWidget.getOverlayElement());
  view.getRichTextEditor().setHTML(overlayWidget.asWidget().getElement().getInnerHTML());
  adaptSize();
  view.asWidget().setVisible(true);
  view.getRichTextEditor().setOverlayWidget(overlayWidget);
  view.init();
  overlayWidget.asWidget().setVisible(false);
  showing=true;
}"
87378,"public void setInjector(DocumentInjector documentInjector){
  if (documentInjector == null)   throw new UnsupportedOperationException(""String_Node_Str"");
  this.amendmentManager=documentInjector.getAmendmentManager();
  this.documentEventBus=documentInjector.getDocumentEventBus();
  this.view=documentInjector.getDocumentView();
  this.style=documentInjector.getDocumentViewCss();
  this.amendmentsPanelController=documentInjector.getAmendmentsPanelController();
  this.diffingManager=documentInjector.getDiffingManager();
  this.infoPanelController=documentInjector.getInfoPanelController();
  this.sourceFileController=documentInjector.getSourceFileController();
  this.documentHeaderController=documentInjector.getDocumentHeaderController();
  this.deadlineController=documentInjector.getDeadlineController();
  this.amendmentsHeaderController=documentInjector.getAmendmentsHeaderController();
  this.amendmentActionPanelController=documentInjector.getAmendmentActionPanelController();
  this.diffingManager.setDocumentController(this);
  this.amendmentManager.setDocumentController(this);
  this.amendmentManager.registerListeners();
  this.infoPanelController.setDocumentController(this);
  this.sourceFileController.setDocumentController(this);
  this.amendmentsPanelController.setDocumentController(this);
  this.documentHeaderController.setDocumentController(this);
  this.deadlineController.setDocumentController(this);
  this.amendmentsHeaderController.setDocumentController(this);
}","public void setInjector(DocumentInjector documentInjector){
  if (documentInjector == null)   throw new UnsupportedOperationException(""String_Node_Str"");
  this.amendmentManager=documentInjector.getAmendmentManager();
  this.localOverlayWidgetReferenceHandler=documentInjector.getLocalOverlayWidgetReferenceHandler();
  this.documentEventBus=documentInjector.getDocumentEventBus();
  this.view=documentInjector.getDocumentView();
  this.style=documentInjector.getDocumentViewCss();
  this.amendmentsPanelController=documentInjector.getAmendmentsPanelController();
  this.diffingManager=documentInjector.getDiffingManager();
  this.infoPanelController=documentInjector.getInfoPanelController();
  this.sourceFileController=documentInjector.getSourceFileController();
  this.documentHeaderController=documentInjector.getDocumentHeaderController();
  this.deadlineController=documentInjector.getDeadlineController();
  this.amendmentsHeaderController=documentInjector.getAmendmentsHeaderController();
  this.amendmentActionPanelController=documentInjector.getAmendmentActionPanelController();
  this.diffingManager.setDocumentController(this);
  this.amendmentManager.setDocumentController(this);
  this.amendmentManager.registerListeners();
  this.infoPanelController.setDocumentController(this);
  this.sourceFileController.setDocumentController(this);
  this.amendmentsPanelController.setDocumentController(this);
  this.documentHeaderController.setDocumentController(this);
  this.deadlineController.setDocumentController(this);
  this.amendmentsHeaderController.setDocumentController(this);
}"
87379,"/** 
 * Click callback; fires a   {@link OverlayWidgetSelectEvent} on the private document bus.
 * @param sender the overlay widget that was clicked
 */
@Override public void onClick(final OverlayWidget sender){
  documentEventBus.fireEvent(new OverlayWidgetSelectEvent(sender,documentController));
}","/** 
 * Click callback; fires a   {@link OverlayWidgetSelectEvent} on the private document bus.
 * @param sender the overlay widget that was clicked
 */
@Override public void onClick(final OverlayWidget sender,final Event event){
  String href=null;
  try {
    href=extractAttribute(event.getEventTarget(),""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  if (href != null && !""String_Node_Str"".equals(href.trim())) {
    if (documentController != null && documentController.getLocalOverlayWidgetReferenceHandler() != null) {
      documentController.getLocalOverlayWidgetReferenceHandler().resolve(""String_Node_Str"",href,sender,new AsyncCallback<OverlayWidget>(){
        @Override public void onFailure(        Throwable caught){
        }
        @Override public void onSuccess(        OverlayWidget result){
          if (result != null)           scrollTo(result.asWidget());
        }
      }
);
    }
  }
  documentEventBus.fireEvent(new OverlayWidgetSelectEvent(sender,documentController));
}"
87380,"/** 
 * We ignore on-mouse-out events since they tend to be unreliable. Rather, we're passing the  {@link ActionBarController} as a single token around.
 * @param sender the overlay widget that lost the mouse hoover
 */
@Override public void onMouseOut(OverlayWidget sender){
}","/** 
 * We ignore on-mouse-out events since they tend to be unreliable. Rather, we're passing the  {@link ActionBarController} as a single token around.
 * @param sender the overlay widget that lost the mouse hoover
 */
@Override public void onMouseOut(final OverlayWidget sender,final Event event){
}"
87381,"/** 
 * Double click callback; fires a   {@link AmendmentContainerCreateEvent} on the private document bus.
 * @param sender the overlay widget that was double clicked
 */
@Override public void onDblClick(final OverlayWidget sender){
  documentEventBus.fireEvent(new AmendmentContainerCreateEvent(sender,null,0,AmendmentAction.MODIFICATION,documentController));
}","/** 
 * Double click callback; fires a   {@link AmendmentContainerCreateEvent} on the private document bus.
 * @param sender the overlay widget that was double clicked
 */
@Override public void onDblClick(final OverlayWidget sender,final Event event){
  documentEventBus.fireEvent(new AmendmentContainerCreateEvent(sender,null,0,AmendmentAction.MODIFICATION,documentController));
}"
87382,"/** 
 * Mouse over callback; if the   {@link OverlayWidget} <tt>sender</tt> is amendable, we will attach the{@link ActionBarController} with the available amendment options, and set the location obtained via{@link org.nsesa.editor.gwt.core.client.ui.document.DocumentController#getLocator()}.
 * @param sender the overlay widget that was hovered
 */
@Override public void onMouseOver(final OverlayWidget sender){
  if (!sender.isIntroducedByAnAmendment()) {
    actionBarController.attach(sender,documentController);
    actionBarController.setLocation(documentController.getLocator().getLocation(sender,documentController.getDocument().getLanguageIso(),false));
  }
}","/** 
 * Mouse over callback; if the   {@link OverlayWidget} <tt>sender</tt> is amendable, we will attach the{@link ActionBarController} with the available amendment options, and set the location obtained via{@link org.nsesa.editor.gwt.core.client.ui.document.DocumentController#getLocator()}.
 * @param sender the overlay widget that was hovered
 */
@Override public void onMouseOver(final OverlayWidget sender,final Event event){
  if (!sender.isIntroducedByAnAmendment()) {
    actionBarController.attach(sender,documentController);
    actionBarController.setLocation(documentController.getLocator().getLocation(sender,documentController.getDocument().getLanguageIso(),false));
  }
}"
87383,"@Inject public DefaultAmendmentController(final AmendmentView amendmentView,final AmendmentView amendmentExtendedView){
  this.view=amendmentView;
  this.extendedView=amendmentExtendedView;
}","@Inject public DefaultAmendmentController(final AmendmentView amendmentView,final AmendmentView amendmentExtendedView,final AmendmentActionPanelController amendmentActionPanelController){
  this.view=amendmentView;
  this.extendedView=amendmentExtendedView;
  this.amendmentActionPanelController=amendmentActionPanelController;
  registerListeners();
}"
87384,"protected void registerListeners(){
  final ClickHandler confirmationHandler=new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerDeleteEvent(DefaultAmendmentController.this));
    }
  }
;
  final ClickHandler cancelHandler=new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
    }
  }
;
  final ClientFactory clientFactory=documentController.getClientFactory();
  final ConfirmationEvent confirmationEvent=new ConfirmationEvent(clientFactory.getCoreMessages().confirmationAmendmentDeleteTitle(),clientFactory.getCoreMessages().confirmationAmendmentDeleteMessage(),clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonConfirm(),confirmationHandler,clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonCancel(),cancelHandler);
  view.getDeleteButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(confirmationEvent);
    }
  }
);
  extendedView.getDeleteButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(confirmationEvent);
    }
  }
);
  view.getEditButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
  extendedView.getEditButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
  view.getMoreActionsButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final Element relativeElement=event.getRelativeElement();
      amendmentActionPanelController.setAmendmentController(DefaultAmendmentController.this);
      amendmentActionPanelController.show(relativeElement.getAbsoluteLeft(),relativeElement.getAbsoluteTop() + relativeElement.getOffsetHeight());
    }
  }
);
  extendedView.getMoreActionsButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final Element relativeElement=event.getRelativeElement();
      amendmentActionPanelController.setAmendmentController(DefaultAmendmentController.this);
      amendmentActionPanelController.show(relativeElement.getAbsoluteLeft(),relativeElement.getAbsoluteTop() + relativeElement.getOffsetHeight());
    }
  }
);
  view.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      event.preventDefault();
    }
  }
);
  view.addDoubleClickHandler(new DoubleClickHandler(){
    @Override public void onDoubleClick(    DoubleClickEvent event){
      event.preventDefault();
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
  extendedView.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      event.preventDefault();
    }
  }
);
  extendedView.addDoubleClickHandler(new DoubleClickHandler(){
    @Override public void onDoubleClick(    DoubleClickEvent event){
      event.preventDefault();
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
}","private void registerListeners(){
  final ClickHandler confirmationHandler=new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerDeleteEvent(DefaultAmendmentController.this));
    }
  }
;
  final ClickHandler cancelHandler=new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
    }
  }
;
  view.getDeleteButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final ClientFactory clientFactory=documentController.getClientFactory();
      final ConfirmationEvent confirmationEvent=new ConfirmationEvent(clientFactory.getCoreMessages().confirmationAmendmentDeleteTitle(),clientFactory.getCoreMessages().confirmationAmendmentDeleteMessage(),clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonConfirm(),confirmationHandler,clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonCancel(),cancelHandler);
      documentController.getDocumentEventBus().fireEvent(confirmationEvent);
    }
  }
);
  extendedView.getDeleteButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final ClientFactory clientFactory=documentController.getClientFactory();
      final ConfirmationEvent confirmationEvent=new ConfirmationEvent(clientFactory.getCoreMessages().confirmationAmendmentDeleteTitle(),clientFactory.getCoreMessages().confirmationAmendmentDeleteMessage(),clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonConfirm(),confirmationHandler,clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonCancel(),cancelHandler);
      documentController.getDocumentEventBus().fireEvent(confirmationEvent);
    }
  }
);
  view.getEditButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
  extendedView.getEditButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
  view.getMoreActionsButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final Element relativeElement=event.getRelativeElement();
      amendmentActionPanelController.setAmendmentController(DefaultAmendmentController.this);
      amendmentActionPanelController.show(relativeElement.getAbsoluteLeft(),relativeElement.getAbsoluteTop() + relativeElement.getOffsetHeight());
    }
  }
);
  extendedView.getMoreActionsButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final Element relativeElement=event.getRelativeElement();
      amendmentActionPanelController.setAmendmentController(DefaultAmendmentController.this);
      amendmentActionPanelController.show(relativeElement.getAbsoluteLeft(),relativeElement.getAbsoluteTop() + relativeElement.getOffsetHeight());
    }
  }
);
  view.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      event.preventDefault();
    }
  }
);
  view.addDoubleClickHandler(new DoubleClickHandler(){
    @Override public void onDoubleClick(    DoubleClickEvent event){
      event.preventDefault();
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
  extendedView.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      event.preventDefault();
    }
  }
);
  extendedView.addDoubleClickHandler(new DoubleClickHandler(){
    @Override public void onDoubleClick(    DoubleClickEvent event){
      event.preventDefault();
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
}"
87385,"/** 
 * Sets the document controller. If the document controller is not <tt>null</tt> (which can happen if an amendment controller is no longer injected in a document controller), then we also register the event listeners.
 * @param documentController the document controller
 */
@Override public void setDocumentController(final DocumentController documentController){
  this.documentController=documentController;
  if (documentController != null) {
    registerListeners();
    this.amendmentActionPanelController=documentController.getInjector().getAmendmentActionPanelController();
    this.documentController.getDocumentEventBus().addHandler(DocumentScrollEvent.TYPE,new DocumentScrollEventHandler(){
      @Override public void onEvent(      DocumentScrollEvent event){
        amendmentActionPanelController.hide();
      }
    }
);
  }
}","/** 
 * Sets the document controller. If the document controller is not <tt>null</tt> (which can happen if an amendment controller is no longer injected in a document controller), then we also register the event listeners.
 * @param documentController the document controller
 */
@Override public void setDocumentController(final DocumentController documentController){
  this.documentController=documentController;
}"
87386,"/** 
 * Registers the event listeners on the various anchors.
 */
protected void registerListeners(){
  final ClientFactory clientFactory=amendmentController.getDocumentController().getClientFactory();
  final ServiceFactory serviceFactory=amendmentController.getDocumentController().getServiceFactory();
  anchorTable.setText(clientFactory.getCoreMessages().amendmentActionTable());
  anchorWithdraw.setText(clientFactory.getCoreMessages().amendmentActionWithdraw());
  anchorDelete.setText(clientFactory.getCoreMessages().amendmentActionDelete());
  anchorTable.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final String oldStatus=amendmentController.getModel().getAmendmentContainerStatus();
      popupPanel.hide();
      serviceFactory.getGwtAmendmentService().tableAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentController.setModel(result[0]);
          final AmendmentContainerStatusUpdatedEvent updatedEvent=new AmendmentContainerStatusUpdatedEvent(amendmentController,oldStatus);
          final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
          documentEventBus.fireEvent(updatedEvent);
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionTableSuccessful(result.length)));
        }
      }
);
    }
  }
);
  anchorWithdraw.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final String oldStatus=amendmentController.getModel().getAmendmentContainerStatus();
      popupPanel.hide();
      serviceFactory.getGwtAmendmentService().withdrawAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentController.setModel(result[0]);
          final AmendmentContainerStatusUpdatedEvent updatedEvent=new AmendmentContainerStatusUpdatedEvent(amendmentController,oldStatus);
          final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
          documentEventBus.fireEvent(updatedEvent);
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionWithdrawSuccessful(result.length)));
        }
      }
);
    }
  }
);
  anchorDelete.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      popupPanel.hide();
      amendmentController.getDocumentController().getDocumentEventBus().fireEvent(new ConfirmationEvent(clientFactory.getCoreMessages().confirmationAmendmentDeleteTitle(),clientFactory.getCoreMessages().confirmationAmendmentDeleteMessage(),clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonConfirm(),new ClickHandler(){
        @Override public void onClick(        ClickEvent event){
          serviceFactory.getGwtAmendmentService().deleteAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
            @Override public void onFailure(            Throwable caught){
              clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
            }
            @Override public void onSuccess(            AmendmentContainerDTO[] result){
              amendmentController.setModel(result[0]);
              final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
              documentEventBus.fireEvent(new AmendmentContainerDeleteEvent(amendmentController));
              documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
            }
          }
);
        }
      }
,clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonCancel(),new ClickHandler(){
        @Override public void onClick(        ClickEvent event){
        }
      }
));
    }
  }
);
}","/** 
 * Registers the event listeners on the various anchors.
 */
private void registerListeners(){
  anchorTable.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final ClientFactory clientFactory=amendmentController.getDocumentController().getClientFactory();
      final ServiceFactory serviceFactory=amendmentController.getDocumentController().getServiceFactory();
      final String oldStatus=amendmentController.getModel().getAmendmentContainerStatus();
      popupPanel.hide();
      serviceFactory.getGwtAmendmentService().tableAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentController.setModel(result[0]);
          final AmendmentContainerStatusUpdatedEvent updatedEvent=new AmendmentContainerStatusUpdatedEvent(amendmentController,oldStatus);
          final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
          documentEventBus.fireEvent(updatedEvent);
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionTableSuccessful(result.length)));
        }
      }
);
    }
  }
);
  anchorWithdraw.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final ClientFactory clientFactory=amendmentController.getDocumentController().getClientFactory();
      final ServiceFactory serviceFactory=amendmentController.getDocumentController().getServiceFactory();
      final String oldStatus=amendmentController.getModel().getAmendmentContainerStatus();
      popupPanel.hide();
      serviceFactory.getGwtAmendmentService().withdrawAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentController.setModel(result[0]);
          final AmendmentContainerStatusUpdatedEvent updatedEvent=new AmendmentContainerStatusUpdatedEvent(amendmentController,oldStatus);
          final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
          documentEventBus.fireEvent(updatedEvent);
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionWithdrawSuccessful(result.length)));
        }
      }
);
    }
  }
);
  anchorDelete.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final ClientFactory clientFactory=amendmentController.getDocumentController().getClientFactory();
      final ServiceFactory serviceFactory=amendmentController.getDocumentController().getServiceFactory();
      popupPanel.hide();
      amendmentController.getDocumentController().getDocumentEventBus().fireEvent(new ConfirmationEvent(clientFactory.getCoreMessages().confirmationAmendmentDeleteTitle(),clientFactory.getCoreMessages().confirmationAmendmentDeleteMessage(),clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonConfirm(),new ClickHandler(){
        @Override public void onClick(        ClickEvent event){
          serviceFactory.getGwtAmendmentService().deleteAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
            @Override public void onFailure(            Throwable caught){
              clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
            }
            @Override public void onSuccess(            AmendmentContainerDTO[] result){
              amendmentController.setModel(result[0]);
              final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
              documentEventBus.fireEvent(new AmendmentContainerDeleteEvent(amendmentController));
              documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
            }
          }
);
        }
      }
,clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonCancel(),new ClickHandler(){
        @Override public void onClick(        ClickEvent event){
        }
      }
));
    }
  }
);
  documentEventBus.addHandler(DocumentScrollEvent.TYPE,new DocumentScrollEventHandler(){
    @Override public void onEvent(    DocumentScrollEvent event){
      hide();
    }
  }
);
}"
87387,"@Inject public AmendmentActionPanelController(final AmendmentActionPanelView amendmentActionPanelView){
  this.view=amendmentActionPanelView;
  this.popupPanel.setWidget(amendmentActionPanelView);
  addWidget(anchorTable);
  anchorTable.getElement().getStyle().setCursor(Style.Cursor.POINTER);
  addWidget(anchorWithdraw);
  anchorWithdraw.getElement().getStyle().setCursor(Style.Cursor.POINTER);
  addSeparator();
  addWidget(anchorDelete);
  anchorDelete.getElement().getStyle().setCursor(Style.Cursor.POINTER);
}","@Inject public AmendmentActionPanelController(final AmendmentActionPanelView amendmentActionPanelView,final CoreMessages coreMessages,final DocumentEventBus documentEventBus){
  this.view=amendmentActionPanelView;
  this.popupPanel.setWidget(amendmentActionPanelView);
  this.documentEventBus=documentEventBus;
  addWidget(anchorTable);
  addWidget(anchorWithdraw);
  addSeparator();
  addWidget(anchorDelete);
  anchorTable.setText(coreMessages.amendmentActionTable());
  anchorWithdraw.setText(coreMessages.amendmentActionWithdraw());
  anchorDelete.setText(coreMessages.amendmentActionDelete());
  registerListeners();
}"
87388,"/** 
 * Sets the parent amendment controller, and registers the event listeners.
 * @param amendmentController the parent amendment controller
 */
public void setAmendmentController(AmendmentController amendmentController){
  this.amendmentController=amendmentController;
  registerListeners();
}","/** 
 * Sets the parent amendment controller, and registers the event listeners.
 * @param amendmentController the parent amendment controller
 */
public void setAmendmentController(AmendmentController amendmentController){
  this.amendmentController=amendmentController;
}"
87389,"/** 
 * Creates a simple   {@link AmendmentController} associated with a given <tt>amendmentContainerDTO</tt>
 * @param amendmentContainerDTO the amendment container DTO to create a controller for
 * @return the controller
 */
private AmendmentController createAmendmentController(final AmendmentContainerDTO amendmentContainerDTO){
  final AmendmentController amendmentController=documentController.getInjector().getAmendmentController();
  amendmentController.setModel(amendmentContainerDTO);
  return amendmentController;
}","/** 
 * Creates a simple   {@link AmendmentController} associated with a given <tt>amendmentContainerDTO</tt>
 * @param amendmentContainerDTO the amendment container DTO to create a controller for
 * @return the controller
 */
private AmendmentController createAmendmentController(final AmendmentContainerDTO amendmentContainerDTO){
  final AmendmentController amendmentController=documentController.getInjector().getAmendmentController();
  amendmentController.setModel(amendmentContainerDTO);
  amendmentController.setDocumentController(documentController);
  return amendmentController;
}"
87390,"@Inject public DefaultAmendmentController(final AmendmentView amendmentView,final AmendmentView amendmentExtendedView,final AmendmentActionPanelController amendmentActionPanelController){
  this.view=amendmentView;
  this.extendedView=amendmentExtendedView;
  this.amendmentActionPanelController=amendmentActionPanelController;
  registerListeners();
}","@Inject public DefaultAmendmentController(final AmendmentView amendmentView,final AmendmentView amendmentExtendedView){
  this.view=amendmentView;
  this.extendedView=amendmentExtendedView;
  registerListeners();
}"
87391,"/** 
 * Sets the document controller. If the document controller is not <tt>null</tt> (which can happen if an amendment controller is no longer injected in a document controller), then we also register the event listeners.
 * @param documentController the document controller
 */
@Override public void setDocumentController(final DocumentController documentController){
  this.documentController=documentController;
}","/** 
 * Sets the document controller. If the document controller is not <tt>null</tt> (which can happen if an amendment controller is no longer injected in a document controller), then we also register the event listeners.
 * @param documentController the document controller
 */
@Override public void setDocumentController(final DocumentController documentController){
  this.documentController=documentController;
  if (documentController != null) {
    amendmentActionPanelController=documentController.getInjector().getAmendmentActionPanelController();
  }
}"
87392,"/** 
 * Registers the event listeners on the various anchors.
 */
private void registerListeners(){
  anchorTable.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final ClientFactory clientFactory=amendmentController.getDocumentController().getClientFactory();
      final ServiceFactory serviceFactory=amendmentController.getDocumentController().getServiceFactory();
      final String oldStatus=amendmentController.getModel().getAmendmentContainerStatus();
      popupPanel.hide();
      serviceFactory.getGwtAmendmentService().tableAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentController.setModel(result[0]);
          final AmendmentContainerStatusUpdatedEvent updatedEvent=new AmendmentContainerStatusUpdatedEvent(amendmentController,oldStatus);
          final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
          documentEventBus.fireEvent(updatedEvent);
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionTableSuccessful(result.length)));
        }
      }
);
    }
  }
);
  anchorWithdraw.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final ClientFactory clientFactory=amendmentController.getDocumentController().getClientFactory();
      final ServiceFactory serviceFactory=amendmentController.getDocumentController().getServiceFactory();
      final String oldStatus=amendmentController.getModel().getAmendmentContainerStatus();
      popupPanel.hide();
      serviceFactory.getGwtAmendmentService().withdrawAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentController.setModel(result[0]);
          final AmendmentContainerStatusUpdatedEvent updatedEvent=new AmendmentContainerStatusUpdatedEvent(amendmentController,oldStatus);
          final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
          documentEventBus.fireEvent(updatedEvent);
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionWithdrawSuccessful(result.length)));
        }
      }
);
    }
  }
);
  anchorDelete.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final ClientFactory clientFactory=amendmentController.getDocumentController().getClientFactory();
      final ServiceFactory serviceFactory=amendmentController.getDocumentController().getServiceFactory();
      popupPanel.hide();
      amendmentController.getDocumentController().getDocumentEventBus().fireEvent(new ConfirmationEvent(clientFactory.getCoreMessages().confirmationAmendmentDeleteTitle(),clientFactory.getCoreMessages().confirmationAmendmentDeleteMessage(),clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonConfirm(),new ClickHandler(){
        @Override public void onClick(        ClickEvent event){
          serviceFactory.getGwtAmendmentService().deleteAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
            @Override public void onFailure(            Throwable caught){
              clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
            }
            @Override public void onSuccess(            AmendmentContainerDTO[] result){
              amendmentController.setModel(result[0]);
              final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
              documentEventBus.fireEvent(new AmendmentContainerDeleteEvent(amendmentController));
              documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
            }
          }
);
        }
      }
,clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonCancel(),new ClickHandler(){
        @Override public void onClick(        ClickEvent event){
        }
      }
));
    }
  }
);
  documentEventBus.addHandler(DocumentScrollEvent.TYPE,new DocumentScrollEventHandler(){
    @Override public void onEvent(    DocumentScrollEvent event){
      hide();
    }
  }
);
}","/** 
 * Registers the event listeners on the various anchors.
 */
private void registerListeners(){
  anchorTable.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final ClientFactory clientFactory=amendmentController.getDocumentController().getClientFactory();
      final ServiceFactory serviceFactory=amendmentController.getDocumentController().getServiceFactory();
      final String oldStatus=amendmentController.getModel().getAmendmentContainerStatus();
      popupPanel.hide();
      serviceFactory.getGwtAmendmentService().tableAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentController.setModel(result[0]);
          final AmendmentContainerStatusUpdatedEvent updatedEvent=new AmendmentContainerStatusUpdatedEvent(amendmentController,oldStatus);
          final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
          documentEventBus.fireEvent(updatedEvent);
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionTableSuccessful(result.length)));
        }
      }
);
    }
  }
);
  anchorWithdraw.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final ClientFactory clientFactory=amendmentController.getDocumentController().getClientFactory();
      final ServiceFactory serviceFactory=amendmentController.getDocumentController().getServiceFactory();
      final String oldStatus=amendmentController.getModel().getAmendmentContainerStatus();
      popupPanel.hide();
      serviceFactory.getGwtAmendmentService().withdrawAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentController.setModel(result[0]);
          final AmendmentContainerStatusUpdatedEvent updatedEvent=new AmendmentContainerStatusUpdatedEvent(amendmentController,oldStatus);
          final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
          documentEventBus.fireEvent(updatedEvent);
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionWithdrawSuccessful(result.length)));
        }
      }
);
    }
  }
);
  anchorDelete.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final ClientFactory clientFactory=amendmentController.getDocumentController().getClientFactory();
      final ServiceFactory serviceFactory=amendmentController.getDocumentController().getServiceFactory();
      popupPanel.hide();
      amendmentController.getDocumentController().getDocumentEventBus().fireEvent(new ConfirmationEvent(clientFactory.getCoreMessages().confirmationAmendmentDeleteTitle(),clientFactory.getCoreMessages().confirmationAmendmentDeleteMessage(),clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonConfirm(),new ClickHandler(){
        @Override public void onClick(        ClickEvent event){
          serviceFactory.getGwtAmendmentService().deleteAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
            @Override public void onFailure(            Throwable caught){
              clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
            }
            @Override public void onSuccess(            AmendmentContainerDTO[] result){
              amendmentController.setModel(result[0]);
              final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
              documentEventBus.fireEvent(new AmendmentContainerDeleteEvent(amendmentController));
              documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
            }
          }
);
        }
      }
,clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonCancel(),new ClickHandler(){
        @Override public void onClick(        ClickEvent event){
        }
      }
));
    }
  }
);
}"
87393,"@Inject public AmendmentActionPanelController(final AmendmentActionPanelView amendmentActionPanelView,final CoreMessages coreMessages,final DocumentEventBus documentEventBus){
  this.view=amendmentActionPanelView;
  this.popupPanel.setWidget(amendmentActionPanelView);
  this.documentEventBus=documentEventBus;
  addWidget(anchorTable);
  addWidget(anchorWithdraw);
  addSeparator();
  addWidget(anchorDelete);
  anchorTable.getElement().getStyle().setCursor(Style.Cursor.POINTER);
  anchorWithdraw.getElement().getStyle().setCursor(Style.Cursor.POINTER);
  anchorDelete.getElement().getStyle().setCursor(Style.Cursor.POINTER);
  anchorTable.setText(coreMessages.amendmentActionTable());
  anchorWithdraw.setText(coreMessages.amendmentActionWithdraw());
  anchorDelete.setText(coreMessages.amendmentActionDelete());
  registerListeners();
}","@Inject public AmendmentActionPanelController(final AmendmentActionPanelView amendmentActionPanelView,final CoreMessages coreMessages){
  this.view=amendmentActionPanelView;
  this.popupPanel.setWidget(amendmentActionPanelView);
  addWidget(anchorTable);
  addWidget(anchorWithdraw);
  addSeparator();
  addWidget(anchorDelete);
  anchorTable.getElement().getStyle().setCursor(Style.Cursor.POINTER);
  anchorWithdraw.getElement().getStyle().setCursor(Style.Cursor.POINTER);
  anchorDelete.getElement().getStyle().setCursor(Style.Cursor.POINTER);
  anchorTable.setText(coreMessages.amendmentActionTable());
  anchorWithdraw.setText(coreMessages.amendmentActionWithdraw());
  anchorDelete.setText(coreMessages.amendmentActionDelete());
  registerListeners();
}"
87394,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  AmendmentContainerDTO that=(AmendmentContainerDTO)o;
  if (amendmentAction != that.amendmentAction)   return false;
  if (!amendmentContainerStatus.equals(that.amendmentContainerStatus))   return false;
  if (body != null ? !body.equals(that.body) : that.body != null)   return false;
  if (!id.equals(that.id))   return false;
  if (!languageISO.equals(that.languageISO))   return false;
  if (!revisionID.equals(that.revisionID))   return false;
  if (sourceReference != null ? !sourceReference.equals(that.sourceReference) : that.sourceReference != null)   return false;
  if (targetReferences != null ? !targetReferences.equals(that.targetReferences) : that.targetReferences != null)   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  AmendmentContainerDTO that=(AmendmentContainerDTO)o;
  if (amendmentAction != that.amendmentAction)   return false;
  if (!amendmentContainerStatus.equals(that.amendmentContainerStatus))   return false;
  if (body != null ? !body.equals(that.body) : that.body != null)   return false;
  if (!id.equals(that.id))   return false;
  if (languageISO != null ? !languageISO.equals(that.languageISO) : that.languageISO != null)   return false;
  if (!revisionID.equals(that.revisionID))   return false;
  if (sourceReference != null ? !sourceReference.equals(that.sourceReference) : that.sourceReference != null)   return false;
  if (targetReferences != null ? !targetReferences.equals(that.targetReferences) : that.targetReferences != null)   return false;
  return true;
}"
87395,"@Before public void setup(){
  AmendmentContainerDTO amendmentContainerDTO=new AmendmentContainerDTO();
  amendmentContainerDTO.setSourceReference(reference);
  amendmentController=new DefaultAmendmentController(new AmendmentViewImpl(null),new AmendmentViewImpl(null),null);
  amendmentController.setModel(amendmentContainerDTO);
  root=new OverlayWidgetImpl();
  root.setType(""String_Node_Str"");
  child1=new OverlayWidgetImpl();
  child1.setType(""String_Node_Str"");
  child2=new OverlayWidgetImpl();
  child2.setType(""String_Node_Str"");
  child3=new OverlayWidgetImpl();
  child3.setType(""String_Node_Str"");
  root.addOverlayWidget(child1);
  root.addOverlayWidget(child2);
  root.addOverlayWidget(child3);
}","@Before public void setup(){
  AmendmentContainerDTO amendmentContainerDTO=new AmendmentContainerDTO();
  amendmentContainerDTO.setSourceReference(reference);
  amendmentController=new DefaultAmendmentController(new AmendmentViewImpl(null),new AmendmentViewImpl(null));
  amendmentController.setModel(amendmentContainerDTO);
  root=new OverlayWidgetImpl();
  root.setType(""String_Node_Str"");
  child1=new OverlayWidgetImpl();
  child1.setType(""String_Node_Str"");
  child2=new OverlayWidgetImpl();
  child2.setType(""String_Node_Str"");
  child3=new OverlayWidgetImpl();
  child3.setType(""String_Node_Str"");
  root.addOverlayWidget(child1);
  root.addOverlayWidget(child2);
  root.addOverlayWidget(child3);
}"
87396,"@Test public void testAddAmendmentController() throws Exception {
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExtended=new AmendmentViewImpl(null);
  final OverlayWidget overlayWidget=new OverlayWidgetImpl();
  final AmendmentController amendmentController=new DefaultAmendmentController(amendmentView,amendmentViewExtended,null);
  overlayWidget.addAmendmentController(amendmentController);
  Assert.assertTrue(Arrays.asList(overlayWidget.getAmendmentControllers()).contains(amendmentController));
}","@Test public void testAddAmendmentController() throws Exception {
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExtended=new AmendmentViewImpl(null);
  final OverlayWidget overlayWidget=new OverlayWidgetImpl();
  final AmendmentController amendmentController=new DefaultAmendmentController(amendmentView,amendmentViewExtended);
  overlayWidget.addAmendmentController(amendmentController);
  Assert.assertTrue(Arrays.asList(overlayWidget.getAmendmentControllers()).contains(amendmentController));
}"
87397,"@Test public void testAddAmendmentControllerWithVetoListener() throws Exception {
  final OverlayWidget overlayWidget=new OverlayWidgetImpl();
  final Boolean[] hits=new Boolean[]{false,false};
  overlayWidget.setListener(new OverlayWidgetListenerMock(){
    @Override public void afterAmendmentControllerAdded(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[1]=true;
    }
    @Override public boolean beforeAmendmentControllerAdded(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[0]=true;
      return true;
    }
  }
);
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExtended=new AmendmentViewImpl(null);
  final AmendmentController amendmentController=new DefaultAmendmentController(amendmentView,amendmentViewExtended,null);
  overlayWidget.addAmendmentController(amendmentController);
  Assert.assertTrue(""String_Node_Str"",hits[0]);
  Assert.assertFalse(""String_Node_Str"",hits[1]);
  Assert.assertFalse(Arrays.asList(overlayWidget.getAmendmentControllers()).contains(amendmentController));
}","@Test public void testAddAmendmentControllerWithVetoListener() throws Exception {
  final OverlayWidget overlayWidget=new OverlayWidgetImpl();
  final Boolean[] hits=new Boolean[]{false,false};
  overlayWidget.setListener(new OverlayWidgetListenerMock(){
    @Override public void afterAmendmentControllerAdded(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[1]=true;
    }
    @Override public boolean beforeAmendmentControllerAdded(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[0]=true;
      return true;
    }
  }
);
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExtended=new AmendmentViewImpl(null);
  final AmendmentController amendmentController=new DefaultAmendmentController(amendmentView,amendmentViewExtended);
  overlayWidget.addAmendmentController(amendmentController);
  Assert.assertTrue(""String_Node_Str"",hits[0]);
  Assert.assertFalse(""String_Node_Str"",hits[1]);
  Assert.assertFalse(Arrays.asList(overlayWidget.getAmendmentControllers()).contains(amendmentController));
}"
87398,"@Test public void testRemoveAmendmentController() throws Exception {
  final OverlayWidget overlayWidget=new OverlayWidgetImpl(){
{
      amendmentControllersHolderElement=new HTMLPanel(""String_Node_Str"");
    }
  }
;
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExtended=new AmendmentViewImpl(null);
  final AmendmentController amendmentController=new DefaultAmendmentController(amendmentView,amendmentViewExtended,null);
  overlayWidget.addAmendmentController(amendmentController);
  overlayWidget.removeAmendmentController(amendmentController);
  Assert.assertFalse(Arrays.asList(overlayWidget.getAmendmentControllers()).contains(amendmentController));
}","@Test public void testRemoveAmendmentController() throws Exception {
  final OverlayWidget overlayWidget=new OverlayWidgetImpl(){
{
      amendmentControllersHolderElement=new HTMLPanel(""String_Node_Str"");
    }
  }
;
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExtended=new AmendmentViewImpl(null);
  final AmendmentController amendmentController=new DefaultAmendmentController(amendmentView,amendmentViewExtended);
  overlayWidget.addAmendmentController(amendmentController);
  overlayWidget.removeAmendmentController(amendmentController);
  Assert.assertFalse(Arrays.asList(overlayWidget.getAmendmentControllers()).contains(amendmentController));
}"
87399,"@Test public void testIsAmended() throws Exception {
  final OverlayWidget overlayWidget=new OverlayWidgetImpl();
  Assert.assertFalse(overlayWidget.isAmended());
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExt=new AmendmentViewImpl(null);
  AmendmentController amendmentController1=new DefaultAmendmentController(amendmentView,amendmentViewExt,null);
  overlayWidget.addAmendmentController(amendmentController1);
  Assert.assertTrue(overlayWidget.isAmended());
}","@Test public void testIsAmended() throws Exception {
  final OverlayWidget overlayWidget=new OverlayWidgetImpl();
  Assert.assertFalse(overlayWidget.isAmended());
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExt=new AmendmentViewImpl(null);
  AmendmentController amendmentController1=new DefaultAmendmentController(amendmentView,amendmentViewExt);
  overlayWidget.addAmendmentController(amendmentController1);
  Assert.assertTrue(overlayWidget.isAmended());
}"
87400,"@Test public void testRemoveAmendmentControllerWithVetoListener() throws Exception {
  final OverlayWidget overlayWidget=new OverlayWidgetImpl();
  final Boolean[] hits=new Boolean[]{false,false};
  overlayWidget.setListener(new OverlayWidgetListenerMock(){
    @Override public boolean beforeAmendmentControllerRemoved(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[0]=true;
      return true;
    }
    @Override public void afterAmendmentControllerRemoved(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[1]=true;
    }
  }
);
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExtended=new AmendmentViewImpl(null);
  final AmendmentController amendmentController=new DefaultAmendmentController(amendmentView,amendmentViewExtended,null);
  overlayWidget.addAmendmentController(amendmentController);
  overlayWidget.removeAmendmentController(amendmentController);
  Assert.assertTrue(""String_Node_Str"",hits[0]);
  Assert.assertFalse(""String_Node_Str"",hits[1]);
  Assert.assertTrue(Arrays.asList(overlayWidget.getAmendmentControllers()).contains(amendmentController));
}","@Test public void testRemoveAmendmentControllerWithVetoListener() throws Exception {
  final OverlayWidget overlayWidget=new OverlayWidgetImpl();
  final Boolean[] hits=new Boolean[]{false,false};
  overlayWidget.setListener(new OverlayWidgetListenerMock(){
    @Override public boolean beforeAmendmentControllerRemoved(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[0]=true;
      return true;
    }
    @Override public void afterAmendmentControllerRemoved(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[1]=true;
    }
  }
);
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExtended=new AmendmentViewImpl(null);
  final AmendmentController amendmentController=new DefaultAmendmentController(amendmentView,amendmentViewExtended);
  overlayWidget.addAmendmentController(amendmentController);
  overlayWidget.removeAmendmentController(amendmentController);
  Assert.assertTrue(""String_Node_Str"",hits[0]);
  Assert.assertFalse(""String_Node_Str"",hits[1]);
  Assert.assertTrue(Arrays.asList(overlayWidget.getAmendmentControllers()).contains(amendmentController));
}"
87401,"@Test public void testAddAmendmentControllerWithListener() throws Exception {
  final OverlayWidget overlayWidget=new OverlayWidgetImpl(){
{
      amendmentControllersHolderElement=new HTMLPanel(""String_Node_Str"");
    }
  }
;
  final Boolean[] hits=new Boolean[]{false,false};
  overlayWidget.setListener(new OverlayWidgetListenerMock(){
    @Override public void afterAmendmentControllerAdded(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[1]=true;
    }
    @Override public boolean beforeAmendmentControllerAdded(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[0]=true;
      return false;
    }
  }
);
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExtended=new AmendmentViewImpl(null);
  final AmendmentController amendmentController=new DefaultAmendmentController(amendmentView,amendmentViewExtended,null);
  overlayWidget.addAmendmentController(amendmentController);
  Assert.assertTrue(""String_Node_Str"",hits[0]);
  Assert.assertTrue(""String_Node_Str"",hits[1]);
  Assert.assertTrue(Arrays.asList(overlayWidget.getAmendmentControllers()).contains(amendmentController));
}","@Test public void testAddAmendmentControllerWithListener() throws Exception {
  final OverlayWidget overlayWidget=new OverlayWidgetImpl(){
{
      amendmentControllersHolderElement=new HTMLPanel(""String_Node_Str"");
    }
  }
;
  final Boolean[] hits=new Boolean[]{false,false};
  overlayWidget.setListener(new OverlayWidgetListenerMock(){
    @Override public void afterAmendmentControllerAdded(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[1]=true;
    }
    @Override public boolean beforeAmendmentControllerAdded(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[0]=true;
      return false;
    }
  }
);
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExtended=new AmendmentViewImpl(null);
  final AmendmentController amendmentController=new DefaultAmendmentController(amendmentView,amendmentViewExtended);
  overlayWidget.addAmendmentController(amendmentController);
  Assert.assertTrue(""String_Node_Str"",hits[0]);
  Assert.assertTrue(""String_Node_Str"",hits[1]);
  Assert.assertTrue(Arrays.asList(overlayWidget.getAmendmentControllers()).contains(amendmentController));
}"
87402,"@Test public void testRemoveAmendmentControllerWithListener() throws Exception {
  final OverlayWidget overlayWidget=new OverlayWidgetImpl();
  final Boolean[] hits=new Boolean[]{false,false};
  overlayWidget.setListener(new OverlayWidgetListenerMock(){
    @Override public boolean beforeAmendmentControllerRemoved(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[0]=true;
      return false;
    }
    @Override public void afterAmendmentControllerRemoved(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[1]=true;
    }
  }
);
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExtended=new AmendmentViewImpl(null);
  final AmendmentController amendmentController=new DefaultAmendmentController(amendmentView,amendmentViewExtended,null);
  overlayWidget.addAmendmentController(amendmentController);
  overlayWidget.removeAmendmentController(amendmentController);
  Assert.assertTrue(""String_Node_Str"",hits[0]);
  Assert.assertTrue(""String_Node_Str"",hits[1]);
  Assert.assertFalse(Arrays.asList(overlayWidget.getAmendmentControllers()).contains(amendmentController));
}","@Test public void testRemoveAmendmentControllerWithListener() throws Exception {
  final OverlayWidget overlayWidget=new OverlayWidgetImpl();
  final Boolean[] hits=new Boolean[]{false,false};
  overlayWidget.setListener(new OverlayWidgetListenerMock(){
    @Override public boolean beforeAmendmentControllerRemoved(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[0]=true;
      return false;
    }
    @Override public void afterAmendmentControllerRemoved(    OverlayWidget overlayWidget,    AmendmentController amendmentController){
      hits[1]=true;
    }
  }
);
  final ClientFactory clientFactory=new ClientFactoryMock();
  final AmendmentView amendmentView=new AmendmentViewImpl(null);
  final AmendmentView amendmentViewExtended=new AmendmentViewImpl(null);
  final AmendmentController amendmentController=new DefaultAmendmentController(amendmentView,amendmentViewExtended);
  overlayWidget.addAmendmentController(amendmentController);
  overlayWidget.removeAmendmentController(amendmentController);
  Assert.assertTrue(""String_Node_Str"",hits[0]);
  Assert.assertTrue(""String_Node_Str"",hits[1]);
  Assert.assertFalse(Arrays.asList(overlayWidget.getAmendmentControllers()).contains(amendmentController));
}"
87403,"@Override protected void onAttach(){
  super.onAttach();
  init();
}","@Override protected void onAttach(){
  super.onAttach();
  Scheduler.get().scheduleDeferred(new Scheduler.ScheduledCommand(){
    @Override public void execute(){
      init();
    }
  }
);
}"
87404,"@Inject public DefaultAmendmentManager(final ClientFactory clientFactory,final ServiceFactory serviceFactory,final Transformer transformer,final DocumentEventBus documentEventBus,final AmendmentInjectionPointFinder injectionPointFinder,final AmendmentInjectionPointProvider injectionPointProvider){
  this.clientFactory=clientFactory;
  this.serviceFactory=serviceFactory;
  this.transformer=transformer;
  this.documentEventBus=documentEventBus;
  this.injectionPointFinder=injectionPointFinder;
  this.injectionPointProvider=injectionPointProvider;
  registerListeners();
}","@Inject public DefaultAmendmentManager(final Transformer transformer,final DocumentEventBus documentEventBus,final AmendmentInjectionPointFinder injectionPointFinder,final AmendmentInjectionPointProvider injectionPointProvider){
  this.transformer=transformer;
  this.documentEventBus=documentEventBus;
  this.injectionPointFinder=injectionPointFinder;
  this.injectionPointProvider=injectionPointProvider;
}"
87405,"private void registerListeners(){
  documentEventBus.addHandler(AmendmentContainerSaveEvent.TYPE,new AmendmentContainerSaveEventHandler(){
    @Override public void onEvent(    final AmendmentContainerSaveEvent event){
      for (      final AmendmentContainerDTO amendment : event.getAmendments()) {
        amendment.setBody(transformer.transform(amendment.getRoot()));
        if (amendment.getRevisionID() == null)         throw new NullPointerException(""String_Node_Str"");
      }
      serviceFactory.getGwtAmendmentService().saveAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(event.getAmendments())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        final Throwable caught){
          documentEventBus.fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
          if (caught instanceof ValidationException) {
            LOG.log(Level.SEVERE,""String_Node_Str"",caught);
          }
        }
        @Override public void onSuccess(        final AmendmentContainerDTO[] result){
          for (          final AmendmentContainerDTO amendmentContainerDTO : result) {
            final AmendmentController amendmentController=documentController.getInjector().getAmendmentController();
            amendmentController.setAmendment(amendmentContainerDTO);
            amendmentController.setDocumentController(documentController);
            int indexOfOlderRevision=-1;
            int counter=0;
            for (            final AmendmentController ac : amendmentControllers) {
              if (amendmentController.getModel().getRevisionID().equals(ac.getModel().getRevisionID())) {
                indexOfOlderRevision=counter;
                break;
              }
              counter++;
            }
            if (indexOfOlderRevision != -1) {
              final AmendmentController removed=amendmentControllers.remove(indexOfOlderRevision);
              amendmentControllers.add(indexOfOlderRevision,amendmentController);
              if (!removed.getDocumentController().equals(amendmentController.getDocumentController())) {
                throw new RuntimeException(""String_Node_Str"");
              }
              LOG.info(""String_Node_Str"" + removed + ""String_Node_Str""+ amendmentController);
              documentEventBus.fireEvent(new AmendmentContainerUpdatedEvent(removed,amendmentController));
            }
 else {
              amendmentControllers.add(amendmentController);
              LOG.info(""String_Node_Str"" + amendmentController);
              documentEventBus.fireEvent(new AmendmentContainerInjectEvent(result));
            }
            documentEventBus.fireEvent(new AmendmentContainerSavedEvent(amendmentController));
          }
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionSaveSuccessful(result.length)));
        }
      }
);
    }
  }
);
  documentEventBus.addHandler(AmendmentContainerDeleteEvent.TYPE,new AmendmentContainerDeleteEventHandler(){
    @Override public void onEvent(    final AmendmentContainerDeleteEvent event){
      final ArrayList<AmendmentContainerDTO> amendmentContainerDTOs=new ArrayList<AmendmentContainerDTO>(Collections2.transform(Arrays.asList(event.getAmendmentControllers()),new Function<AmendmentController,AmendmentContainerDTO>(){
        @Override public AmendmentContainerDTO apply(        AmendmentController input){
          return input.getModel();
        }
      }
));
      serviceFactory.getGwtAmendmentService().deleteAmendmentContainers(clientFactory.getClientContext(),amendmentContainerDTOs,new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentControllers.removeAll(Arrays.asList(event.getAmendmentControllers()));
          for (int i=0; i < result.length; i++) {
            AmendmentController amendmentController=event.getAmendmentControllers()[i];
            documentEventBus.fireEvent(new AmendmentContainerDeletedEvent(amendmentController));
          }
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
        }
      }
);
    }
  }
);
}","private void registerListeners(){
  final ServiceFactory serviceFactory=documentController.getServiceFactory();
  final ClientFactory clientFactory=documentController.getClientFactory();
  documentEventBus.addHandler(AmendmentContainerSaveEvent.TYPE,new AmendmentContainerSaveEventHandler(){
    @Override public void onEvent(    final AmendmentContainerSaveEvent event){
      for (      final AmendmentContainerDTO amendment : event.getAmendments()) {
        amendment.setBody(transformer.transform(amendment.getRoot()));
        if (amendment.getRevisionID() == null)         throw new NullPointerException(""String_Node_Str"");
      }
      serviceFactory.getGwtAmendmentService().saveAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(event.getAmendments())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        final Throwable caught){
          documentEventBus.fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
          if (caught instanceof ValidationException) {
            LOG.log(Level.SEVERE,""String_Node_Str"",caught);
          }
        }
        @Override public void onSuccess(        final AmendmentContainerDTO[] result){
          for (          final AmendmentContainerDTO amendmentContainerDTO : result) {
            final AmendmentController amendmentController=documentController.getInjector().getAmendmentController();
            amendmentController.setAmendment(amendmentContainerDTO);
            amendmentController.setDocumentController(documentController);
            int indexOfOlderRevision=-1;
            int counter=0;
            for (            final AmendmentController ac : amendmentControllers) {
              if (amendmentController.getModel().getRevisionID().equals(ac.getModel().getRevisionID())) {
                indexOfOlderRevision=counter;
                break;
              }
              counter++;
            }
            if (indexOfOlderRevision != -1) {
              final AmendmentController removed=amendmentControllers.remove(indexOfOlderRevision);
              amendmentControllers.add(indexOfOlderRevision,amendmentController);
              if (!removed.getDocumentController().equals(amendmentController.getDocumentController())) {
                throw new RuntimeException(""String_Node_Str"");
              }
              LOG.info(""String_Node_Str"" + removed + ""String_Node_Str""+ amendmentController);
              documentEventBus.fireEvent(new AmendmentContainerUpdatedEvent(removed,amendmentController));
            }
 else {
              amendmentControllers.add(amendmentController);
              LOG.info(""String_Node_Str"" + amendmentController);
              documentEventBus.fireEvent(new AmendmentContainerInjectEvent(result));
            }
            documentEventBus.fireEvent(new AmendmentContainerSavedEvent(amendmentController));
          }
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionSaveSuccessful(result.length)));
        }
      }
);
    }
  }
);
  documentEventBus.addHandler(AmendmentContainerDeleteEvent.TYPE,new AmendmentContainerDeleteEventHandler(){
    @Override public void onEvent(    final AmendmentContainerDeleteEvent event){
      final ArrayList<AmendmentContainerDTO> amendmentContainerDTOs=new ArrayList<AmendmentContainerDTO>(Collections2.transform(Arrays.asList(event.getAmendmentControllers()),new Function<AmendmentController,AmendmentContainerDTO>(){
        @Override public AmendmentContainerDTO apply(        AmendmentController input){
          return input.getModel();
        }
      }
));
      serviceFactory.getGwtAmendmentService().deleteAmendmentContainers(clientFactory.getClientContext(),amendmentContainerDTOs,new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentControllers.removeAll(Arrays.asList(event.getAmendmentControllers()));
          for (int i=0; i < result.length; i++) {
            AmendmentController amendmentController=event.getAmendmentControllers()[i];
            documentEventBus.fireEvent(new AmendmentContainerDeletedEvent(amendmentController));
          }
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
        }
      }
);
    }
  }
);
}"
87406,"@Override public void setDocumentController(DocumentController documentController){
  this.documentController=documentController;
}","@Override public void setDocumentController(DocumentController documentController){
  this.documentController=documentController;
  registerListeners();
}"
87407,"@Inject public DefaultDiffingManager(final ServiceFactory serviceFactory,final ClientFactory clientFactory,final DocumentEventBus documentEventBus){
  this.serviceFactory=serviceFactory;
  this.clientFactory=clientFactory;
  this.documentEventBus=documentEventBus;
}","@Inject public DefaultDiffingManager(final DocumentEventBus documentEventBus){
  this.documentEventBus=documentEventBus;
}"
87408,"@Inject public DefaultAmendmentController(final ClientFactory clientFactory,final AmendmentView amendmentView,final AmendmentView amendmentExtendedView){
  this.clientFactory=clientFactory;
  this.view=amendmentView;
  this.extendedView=amendmentExtendedView;
  registerListeners();
}","@Inject public DefaultAmendmentController(final AmendmentView amendmentView,final AmendmentView amendmentExtendedView){
  this.view=amendmentView;
  this.extendedView=amendmentExtendedView;
}"
87409,"private void registerListeners(){
  final ClickHandler confirmationHandler=new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerDeleteEvent(DefaultAmendmentController.this));
    }
  }
;
  final ClickHandler cancelHandler=new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
    }
  }
;
  final ConfirmationEvent confirmationEvent=new ConfirmationEvent(clientFactory.getCoreMessages().confirmationAmendmentDeleteTitle(),clientFactory.getCoreMessages().confirmationAmendmentDeleteMessage(),clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonConfirm(),confirmationHandler,clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonCancel(),cancelHandler);
  view.getDeleteButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(confirmationEvent);
    }
  }
);
  extendedView.getDeleteButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(confirmationEvent);
    }
  }
);
  view.getEditButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
  extendedView.getEditButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
  view.getMoreActionsButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final Element relativeElement=event.getRelativeElement();
      amendmentActionPanelController.setAmendmentController(DefaultAmendmentController.this);
      amendmentActionPanelController.show(relativeElement.getAbsoluteLeft(),relativeElement.getAbsoluteTop() + relativeElement.getOffsetHeight());
    }
  }
);
  extendedView.getMoreActionsButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final Element relativeElement=event.getRelativeElement();
      amendmentActionPanelController.setAmendmentController(DefaultAmendmentController.this);
      amendmentActionPanelController.show(relativeElement.getAbsoluteLeft(),relativeElement.getAbsoluteTop() + relativeElement.getOffsetHeight());
    }
  }
);
  view.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      event.preventDefault();
    }
  }
);
  view.addDoubleClickHandler(new DoubleClickHandler(){
    @Override public void onDoubleClick(    DoubleClickEvent event){
      event.preventDefault();
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
  extendedView.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      event.preventDefault();
    }
  }
);
  extendedView.addDoubleClickHandler(new DoubleClickHandler(){
    @Override public void onDoubleClick(    DoubleClickEvent event){
      event.preventDefault();
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
}","private void registerListeners(){
  final ClickHandler confirmationHandler=new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerDeleteEvent(DefaultAmendmentController.this));
    }
  }
;
  final ClickHandler cancelHandler=new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
    }
  }
;
  final ClientFactory clientFactory=documentController.getClientFactory();
  final ConfirmationEvent confirmationEvent=new ConfirmationEvent(clientFactory.getCoreMessages().confirmationAmendmentDeleteTitle(),clientFactory.getCoreMessages().confirmationAmendmentDeleteMessage(),clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonConfirm(),confirmationHandler,clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonCancel(),cancelHandler);
  view.getDeleteButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(confirmationEvent);
    }
  }
);
  extendedView.getDeleteButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(confirmationEvent);
    }
  }
);
  view.getEditButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
  extendedView.getEditButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
  view.getMoreActionsButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final Element relativeElement=event.getRelativeElement();
      amendmentActionPanelController.setAmendmentController(DefaultAmendmentController.this);
      amendmentActionPanelController.show(relativeElement.getAbsoluteLeft(),relativeElement.getAbsoluteTop() + relativeElement.getOffsetHeight());
    }
  }
);
  extendedView.getMoreActionsButton().addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final Element relativeElement=event.getRelativeElement();
      amendmentActionPanelController.setAmendmentController(DefaultAmendmentController.this);
      amendmentActionPanelController.show(relativeElement.getAbsoluteLeft(),relativeElement.getAbsoluteTop() + relativeElement.getOffsetHeight());
    }
  }
);
  view.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      event.preventDefault();
    }
  }
);
  view.addDoubleClickHandler(new DoubleClickHandler(){
    @Override public void onDoubleClick(    DoubleClickEvent event){
      event.preventDefault();
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
  extendedView.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      event.preventDefault();
    }
  }
);
  extendedView.addDoubleClickHandler(new DoubleClickHandler(){
    @Override public void onDoubleClick(    DoubleClickEvent event){
      event.preventDefault();
      documentController.getDocumentEventBus().fireEvent(new AmendmentContainerEditEvent(DefaultAmendmentController.this));
    }
  }
);
}"
87410,"@Override public void setDocumentController(final DocumentController documentController){
  this.documentController=documentController;
  if (documentController != null) {
    this.amendmentActionPanelController=documentController.getInjector().getAmendmentActionPanelController();
    this.documentController.getDocumentEventBus().addHandler(DocumentScrollEvent.TYPE,new DocumentScrollEventHandler(){
      @Override public void onEvent(      DocumentScrollEvent event){
        amendmentActionPanelController.hide();
      }
    }
);
  }
}","@Override public void setDocumentController(final DocumentController documentController){
  this.documentController=documentController;
  if (documentController != null) {
    registerListeners();
    this.amendmentActionPanelController=documentController.getInjector().getAmendmentActionPanelController();
    this.documentController.getDocumentEventBus().addHandler(DocumentScrollEvent.TYPE,new DocumentScrollEventHandler(){
      @Override public void onEvent(      DocumentScrollEvent event){
        amendmentActionPanelController.hide();
      }
    }
);
  }
}"
87411,"private void registerListeners(){
  anchorTable.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final String oldStatus=amendmentController.getModel().getAmendmentContainerStatus();
      popupPanel.hide();
      serviceFactory.getGwtAmendmentService().tableAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentController.setAmendment(result[0]);
          final AmendmentContainerStatusUpdatedEvent updatedEvent=new AmendmentContainerStatusUpdatedEvent(amendmentController,oldStatus);
          final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
          documentEventBus.fireEvent(updatedEvent);
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionTableSuccessful(result.length)));
        }
      }
);
    }
  }
);
  anchorWithdraw.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final String oldStatus=amendmentController.getModel().getAmendmentContainerStatus();
      popupPanel.hide();
      serviceFactory.getGwtAmendmentService().withdrawAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentController.setAmendment(result[0]);
          final AmendmentContainerStatusUpdatedEvent updatedEvent=new AmendmentContainerStatusUpdatedEvent(amendmentController,oldStatus);
          final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
          documentEventBus.fireEvent(updatedEvent);
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionWithdrawSuccessful(result.length)));
        }
      }
);
    }
  }
);
  anchorDelete.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      popupPanel.hide();
      amendmentController.getDocumentController().getDocumentEventBus().fireEvent(new ConfirmationEvent(clientFactory.getCoreMessages().confirmationAmendmentDeleteTitle(),clientFactory.getCoreMessages().confirmationAmendmentDeleteMessage(),clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonConfirm(),new ClickHandler(){
        @Override public void onClick(        ClickEvent event){
          serviceFactory.getGwtAmendmentService().deleteAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
            @Override public void onFailure(            Throwable caught){
              clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
            }
            @Override public void onSuccess(            AmendmentContainerDTO[] result){
              amendmentController.setAmendment(result[0]);
              final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
              documentEventBus.fireEvent(new AmendmentContainerDeleteEvent(amendmentController));
              documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
            }
          }
);
        }
      }
,clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonCancel(),new ClickHandler(){
        @Override public void onClick(        ClickEvent event){
        }
      }
));
    }
  }
);
}","private void registerListeners(){
  final ClientFactory clientFactory=amendmentController.getDocumentController().getClientFactory();
  final ServiceFactory serviceFactory=amendmentController.getDocumentController().getServiceFactory();
  anchorTable.setText(clientFactory.getCoreMessages().amendmentActionTable());
  anchorWithdraw.setText(clientFactory.getCoreMessages().amendmentActionWithdraw());
  anchorDelete.setText(clientFactory.getCoreMessages().amendmentActionDelete());
  anchorTable.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final String oldStatus=amendmentController.getModel().getAmendmentContainerStatus();
      popupPanel.hide();
      serviceFactory.getGwtAmendmentService().tableAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentController.setAmendment(result[0]);
          final AmendmentContainerStatusUpdatedEvent updatedEvent=new AmendmentContainerStatusUpdatedEvent(amendmentController,oldStatus);
          final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
          documentEventBus.fireEvent(updatedEvent);
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionTableSuccessful(result.length)));
        }
      }
);
    }
  }
);
  anchorWithdraw.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      final String oldStatus=amendmentController.getModel().getAmendmentContainerStatus();
      popupPanel.hide();
      serviceFactory.getGwtAmendmentService().withdrawAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentController.setAmendment(result[0]);
          final AmendmentContainerStatusUpdatedEvent updatedEvent=new AmendmentContainerStatusUpdatedEvent(amendmentController,oldStatus);
          final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
          documentEventBus.fireEvent(updatedEvent);
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionWithdrawSuccessful(result.length)));
        }
      }
);
    }
  }
);
  anchorDelete.addClickHandler(new ClickHandler(){
    @Override public void onClick(    ClickEvent event){
      popupPanel.hide();
      amendmentController.getDocumentController().getDocumentEventBus().fireEvent(new ConfirmationEvent(clientFactory.getCoreMessages().confirmationAmendmentDeleteTitle(),clientFactory.getCoreMessages().confirmationAmendmentDeleteMessage(),clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonConfirm(),new ClickHandler(){
        @Override public void onClick(        ClickEvent event){
          serviceFactory.getGwtAmendmentService().deleteAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(amendmentController.getModel())),new AsyncCallback<AmendmentContainerDTO[]>(){
            @Override public void onFailure(            Throwable caught){
              clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
            }
            @Override public void onSuccess(            AmendmentContainerDTO[] result){
              amendmentController.setAmendment(result[0]);
              final DocumentEventBus documentEventBus=amendmentController.getDocumentController().getDocumentEventBus();
              documentEventBus.fireEvent(new AmendmentContainerDeleteEvent(amendmentController));
              documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
            }
          }
);
        }
      }
,clientFactory.getCoreMessages().confirmationAmendmentDeleteButtonCancel(),new ClickHandler(){
        @Override public void onClick(        ClickEvent event){
        }
      }
));
    }
  }
);
}"
87412,"@Inject public AmendmentActionPanelController(final ClientFactory clientFactory,final ServiceFactory serviceFactory,final AmendmentActionPanelView amendmentActionPanelView){
  this.clientFactory=clientFactory;
  this.serviceFactory=serviceFactory;
  this.view=amendmentActionPanelView;
  this.popupPanel.setWidget(amendmentActionPanelView);
  anchorTable.setText(clientFactory.getCoreMessages().amendmentActionTable());
  anchorWithdraw.setText(clientFactory.getCoreMessages().amendmentActionWithdraw());
  anchorDelete.setText(clientFactory.getCoreMessages().amendmentActionDelete());
  addWidget(anchorTable);
  addWidget(anchorWithdraw);
  addSeparator();
  addWidget(anchorDelete);
  registerListeners();
}","@Inject public AmendmentActionPanelController(final AmendmentActionPanelView amendmentActionPanelView){
  this.view=amendmentActionPanelView;
  this.popupPanel.setWidget(amendmentActionPanelView);
  addWidget(anchorTable);
  addWidget(anchorWithdraw);
  addSeparator();
  addWidget(anchorDelete);
}"
87413,"public void setAmendmentController(AmendmentController amendmentController){
  this.amendmentController=amendmentController;
}","public void setAmendmentController(AmendmentController amendmentController){
  this.amendmentController=amendmentController;
  registerListeners();
}"
87414,"protected String getFormattedDeadline(){
  final Date now=new Date();
  final Date midnight=new Date(now.getDay(),now.getMonth(),now.getYear(),0,0,0);
  final Date oneDayBefore=new Date(midnight.getTime() - (24 * 60 * 60* 1000));
  final Date oneHourBefore=new Date(deadline.getTime() - (60 * 60 * 1000));
  if (now.after(deadline)) {
    return coreMessages.documentDeadlinePassedMessage(DateTimeFormat.getFormat(coreMessages.documentDeadlinePassedFormat()).format(deadline));
  }
  if (deadline.after(oneHourBefore)) {
    return coreMessages.documentDeadlineH1Message(DateTimeFormat.getFormat(coreMessages.documentDeadlineH1Format()).format(deadline));
  }
  if (deadline.after(midnight)) {
    return coreMessages.documentDeadlineTodayMessage(DateTimeFormat.getFormat(coreMessages.documentDeadlineTodayFormat()).format(deadline));
  }
  if (deadline.after(oneDayBefore)) {
    return coreMessages.documentDeadlineTomorrowMessage(DateTimeFormat.getFormat(coreMessages.documentDeadlineTomorrowFormat()).format(deadline));
  }
  return coreMessages.documentDeadlineDefaultMessage(DateTimeFormat.getFormat(coreMessages.documentDeadlineDefaultFormat()).format(deadline));
}","protected String getFormattedDeadline(){
  final Date now=new Date();
  final Date midnight=new Date(now.getDay(),now.getMonth(),now.getYear(),0,0,0);
  final Date oneDayBefore=new Date(midnight.getTime() - (24 * 60 * 60* 1000));
  final Date oneHourBefore=new Date(deadline.getTime() - (60 * 60 * 1000));
  final CoreMessages coreMessages=documentController.getClientFactory().getCoreMessages();
  if (now.after(deadline)) {
    return coreMessages.documentDeadlinePassedMessage(DateTimeFormat.getFormat(coreMessages.documentDeadlinePassedFormat()).format(deadline));
  }
  if (deadline.after(oneHourBefore)) {
    return coreMessages.documentDeadlineH1Message(DateTimeFormat.getFormat(coreMessages.documentDeadlineH1Format()).format(deadline));
  }
  if (deadline.after(midnight)) {
    return coreMessages.documentDeadlineTodayMessage(DateTimeFormat.getFormat(coreMessages.documentDeadlineTodayFormat()).format(deadline));
  }
  if (deadline.after(oneDayBefore)) {
    return coreMessages.documentDeadlineTomorrowMessage(DateTimeFormat.getFormat(coreMessages.documentDeadlineTomorrowFormat()).format(deadline));
  }
  return coreMessages.documentDeadlineDefaultMessage(DateTimeFormat.getFormat(coreMessages.documentDeadlineDefaultFormat()).format(deadline));
}"
87415,"@Inject public DeadlineController(final DocumentEventBus documentEventBus,final DeadlineTracker deadlineTracker,final DeadlineView view,final CoreMessages coreMessages){
  this.documentEventBus=documentEventBus;
  this.deadlineTracker=deadlineTracker;
  this.deadlineTracker.setDeadlineController(this);
  this.view=view;
  this.coreMessages=coreMessages;
  registerListeners();
}","@Inject public DeadlineController(final DocumentEventBus documentEventBus,final DeadlineTracker deadlineTracker,final DeadlineView view){
  this.documentEventBus=documentEventBus;
  this.deadlineTracker=deadlineTracker;
  this.deadlineTracker.setDeadlineController(this);
  this.view=view;
  registerListeners();
}"
87416,"@Override public String getInnerHTML(){
  final NodeList<Node> childNodes=getElement().getChildNodes();
  final StringBuilder sb=new StringBuilder();
  for (int i=0; i < childNodes.getLength(); i++) {
    final Node node=childNodes.getItem(i);
    if (Node.ELEMENT_NODE == node.getNodeType()) {
      Element element=node.cast();
      if (element != getAmendmentHolderElement().getElement()) {
        sb.append(DOM.toString((com.google.gwt.user.client.Element)element));
      }
    }
 else     if (Node.TEXT_NODE == node.getNodeType()) {
      sb.append(node.getNodeValue());
    }
  }
  return sb.toString();
}","@Override public String getInnerHTML(){
  final Node clonedNode=getElement().cloneNode(true);
  NodeUtil.walk(clonedNode,new NodeUtil.NodeVisitor(){
    @Override public void visit(    final Node node){
      if (node.getNodeType() == Node.ELEMENT_NODE) {
        Element el=node.cast();
        if (el.getTagName().equals(getAmendmentHolderElement().getElement().getTagName()) && el.getClassName().equals(getAmendmentHolderElement().getElement().getClassName())) {
          el.removeFromParent();
        }
      }
    }
  }
);
  return ((Element)clonedNode.cast()).getInnerHTML();
}"
87417,"private void registerListeners(){
  documentEventBus.addHandler(AmendmentContainerSaveEvent.TYPE,new AmendmentContainerSaveEventHandler(){
    @Override public void onEvent(    final AmendmentContainerSaveEvent event){
      for (      final AmendmentContainerDTO amendment : event.getAmendments()) {
        amendment.setXmlContent(xmlTransformer.toXML(amendment.getRoot()));
      }
      serviceFactory.getGwtAmendmentService().saveAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(event.getAmendments())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        final Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        final AmendmentContainerDTO[] result){
          for (          final AmendmentContainerDTO amendmentContainerDTO : result) {
            final AmendmentController amendmentController=documentController.getInjector().getAmendmentController();
            amendmentController.setAmendment(amendmentContainerDTO);
            amendmentController.setDocumentController(documentController);
            int indexOfOlderRevision=-1;
            int counter=0;
            for (            final AmendmentController ac : amendmentControllers) {
              if (amendmentController.getModel().getRevisionID().equals(ac.getModel().getRevisionID())) {
                indexOfOlderRevision=counter;
                break;
              }
              counter++;
            }
            if (indexOfOlderRevision != -1) {
              final AmendmentController removed=amendmentControllers.remove(indexOfOlderRevision);
              amendmentControllers.add(indexOfOlderRevision,amendmentController);
              if (!removed.getDocumentController().equals(amendmentController.getDocumentController())) {
                throw new RuntimeException(""String_Node_Str"");
              }
              LOG.info(""String_Node_Str"" + removed + ""String_Node_Str""+ amendmentController);
              documentEventBus.fireEvent(new AmendmentContainerUpdatedEvent(removed,amendmentController));
            }
 else {
              amendmentControllers.add(amendmentController);
              LOG.info(""String_Node_Str"" + amendmentController);
              documentEventBus.fireEvent(new AmendmentContainerInjectEvent(result));
            }
            documentEventBus.fireEvent(new AmendmentContainerSavedEvent(amendmentController));
          }
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionSaveSuccessful(result.length)));
        }
      }
);
    }
  }
);
  documentEventBus.addHandler(AmendmentContainerDeleteEvent.TYPE,new AmendmentContainerDeleteEventHandler(){
    @Override public void onEvent(    final AmendmentContainerDeleteEvent event){
      final ArrayList<AmendmentContainerDTO> amendmentContainerDTOs=new ArrayList<AmendmentContainerDTO>(Collections2.transform(Arrays.asList(event.getAmendmentControllers()),new Function<AmendmentController,AmendmentContainerDTO>(){
        @Override public AmendmentContainerDTO apply(        AmendmentController input){
          return input.getModel();
        }
      }
));
      serviceFactory.getGwtAmendmentService().deleteAmendmentContainers(clientFactory.getClientContext(),amendmentContainerDTOs,new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentControllers.remove(event.getAmendmentControllers());
          for (int i=0; i < result.length; i++) {
            AmendmentController amendmentController=event.getAmendmentControllers()[i];
            documentEventBus.fireEvent(new AmendmentContainerDeletedEvent(amendmentController));
          }
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
        }
      }
);
    }
  }
);
}","private void registerListeners(){
  documentEventBus.addHandler(AmendmentContainerSaveEvent.TYPE,new AmendmentContainerSaveEventHandler(){
    @Override public void onEvent(    final AmendmentContainerSaveEvent event){
      for (      final AmendmentContainerDTO amendment : event.getAmendments()) {
        amendment.setXmlContent(xmlTransformer.toXML(amendment.getRoot()));
      }
      serviceFactory.getGwtAmendmentService().saveAmendmentContainers(clientFactory.getClientContext(),new ArrayList<AmendmentContainerDTO>(Arrays.asList(event.getAmendments())),new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        final Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        final AmendmentContainerDTO[] result){
          for (          final AmendmentContainerDTO amendmentContainerDTO : result) {
            final AmendmentController amendmentController=documentController.getInjector().getAmendmentController();
            amendmentController.setAmendment(amendmentContainerDTO);
            amendmentController.setDocumentController(documentController);
            int indexOfOlderRevision=-1;
            int counter=0;
            for (            final AmendmentController ac : amendmentControllers) {
              if (amendmentController.getModel().getRevisionID().equals(ac.getModel().getRevisionID())) {
                indexOfOlderRevision=counter;
                break;
              }
              counter++;
            }
            if (indexOfOlderRevision != -1) {
              final AmendmentController removed=amendmentControllers.remove(indexOfOlderRevision);
              amendmentControllers.add(indexOfOlderRevision,amendmentController);
              if (!removed.getDocumentController().equals(amendmentController.getDocumentController())) {
                throw new RuntimeException(""String_Node_Str"");
              }
              LOG.info(""String_Node_Str"" + removed + ""String_Node_Str""+ amendmentController);
              documentEventBus.fireEvent(new AmendmentContainerUpdatedEvent(removed,amendmentController));
            }
 else {
              amendmentControllers.add(amendmentController);
              LOG.info(""String_Node_Str"" + amendmentController);
              documentEventBus.fireEvent(new AmendmentContainerInjectEvent(result));
            }
            documentEventBus.fireEvent(new AmendmentContainerSavedEvent(amendmentController));
          }
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionSaveSuccessful(result.length)));
        }
      }
);
    }
  }
);
  documentEventBus.addHandler(AmendmentContainerDeleteEvent.TYPE,new AmendmentContainerDeleteEventHandler(){
    @Override public void onEvent(    final AmendmentContainerDeleteEvent event){
      final ArrayList<AmendmentContainerDTO> amendmentContainerDTOs=new ArrayList<AmendmentContainerDTO>(Collections2.transform(Arrays.asList(event.getAmendmentControllers()),new Function<AmendmentController,AmendmentContainerDTO>(){
        @Override public AmendmentContainerDTO apply(        AmendmentController input){
          return input.getModel();
        }
      }
));
      serviceFactory.getGwtAmendmentService().deleteAmendmentContainers(clientFactory.getClientContext(),amendmentContainerDTOs,new AsyncCallback<AmendmentContainerDTO[]>(){
        @Override public void onFailure(        Throwable caught){
          clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
        }
        @Override public void onSuccess(        AmendmentContainerDTO[] result){
          amendmentControllers.removeAll(Arrays.asList(event.getAmendmentControllers()));
          for (int i=0; i < result.length; i++) {
            AmendmentController amendmentController=event.getAmendmentControllers()[i];
            documentEventBus.fireEvent(new AmendmentContainerDeletedEvent(amendmentController));
          }
          documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
        }
      }
);
    }
  }
);
}"
87418,"@Override public void onEvent(final AmendmentContainerDeleteEvent event){
  final ArrayList<AmendmentContainerDTO> amendmentContainerDTOs=new ArrayList<AmendmentContainerDTO>(Collections2.transform(Arrays.asList(event.getAmendmentControllers()),new Function<AmendmentController,AmendmentContainerDTO>(){
    @Override public AmendmentContainerDTO apply(    AmendmentController input){
      return input.getModel();
    }
  }
));
  serviceFactory.getGwtAmendmentService().deleteAmendmentContainers(clientFactory.getClientContext(),amendmentContainerDTOs,new AsyncCallback<AmendmentContainerDTO[]>(){
    @Override public void onFailure(    Throwable caught){
      clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
    }
    @Override public void onSuccess(    AmendmentContainerDTO[] result){
      amendmentControllers.remove(event.getAmendmentControllers());
      for (int i=0; i < result.length; i++) {
        AmendmentController amendmentController=event.getAmendmentControllers()[i];
        documentEventBus.fireEvent(new AmendmentContainerDeletedEvent(amendmentController));
      }
      documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
    }
  }
);
}","@Override public void onEvent(final AmendmentContainerDeleteEvent event){
  final ArrayList<AmendmentContainerDTO> amendmentContainerDTOs=new ArrayList<AmendmentContainerDTO>(Collections2.transform(Arrays.asList(event.getAmendmentControllers()),new Function<AmendmentController,AmendmentContainerDTO>(){
    @Override public AmendmentContainerDTO apply(    AmendmentController input){
      return input.getModel();
    }
  }
));
  serviceFactory.getGwtAmendmentService().deleteAmendmentContainers(clientFactory.getClientContext(),amendmentContainerDTOs,new AsyncCallback<AmendmentContainerDTO[]>(){
    @Override public void onFailure(    Throwable caught){
      clientFactory.getEventBus().fireEvent(new CriticalErrorEvent(""String_Node_Str"",caught));
    }
    @Override public void onSuccess(    AmendmentContainerDTO[] result){
      amendmentControllers.removeAll(Arrays.asList(event.getAmendmentControllers()));
      for (int i=0; i < result.length; i++) {
        AmendmentController amendmentController=event.getAmendmentControllers()[i];
        documentEventBus.fireEvent(new AmendmentContainerDeletedEvent(amendmentController));
      }
      documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
    }
  }
);
}"
87419,"@Override public void onSuccess(AmendmentContainerDTO[] result){
  amendmentControllers.remove(event.getAmendmentControllers());
  for (int i=0; i < result.length; i++) {
    AmendmentController amendmentController=event.getAmendmentControllers()[i];
    documentEventBus.fireEvent(new AmendmentContainerDeletedEvent(amendmentController));
  }
  documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
}","@Override public void onSuccess(AmendmentContainerDTO[] result){
  amendmentControllers.removeAll(Arrays.asList(event.getAmendmentControllers()));
  for (int i=0; i < result.length; i++) {
    AmendmentController amendmentController=event.getAmendmentControllers()[i];
    documentEventBus.fireEvent(new AmendmentContainerDeletedEvent(amendmentController));
  }
  documentEventBus.fireEvent(new NotificationEvent(clientFactory.getCoreMessages().amendmentActionDeleteSuccessful(result.length)));
}"
87420,"public void hide(){
  richTextEditor.destroy();
  richTextEditor.asWidget().setVisible(false);
  amendableWidget.asWidget().setVisible(true);
}","public void hide(){
  richTextEditor.destroy();
  richTextEditor.asWidget().setVisible(false);
  if (amendableWidget != null)   amendableWidget.asWidget().setVisible(true);
}"
87421,"@Override public int getTypeIndex(final boolean includeAmendments){
  if (getParentAmendableWidget() != null) {
    final Iterator<AmendableWidget> iterator=getParentAmendableWidget().getChildAmendableWidgets().iterator();
    int count=0;
    while (iterator.hasNext()) {
      final AmendableWidget aw=iterator.next();
      if (aw != null) {
        if (aw == this) {
          break;
        }
        if (aw.getType().equalsIgnoreCase(getType())) {
          if (includeAmendments) {
            count++;
          }
 else {
            if (!aw.isIntroducedByAnAmendment()) {
              count++;
            }
          }
        }
      }
    }
    return count;
  }
  return -1;
}","@Override public int getTypeIndex(final boolean includeAmendments){
  if (getParentAmendableWidget() != null) {
    final Iterator<AmendableWidget> iterator=getParentAmendableWidget().getChildAmendableWidgets().iterator();
    int count=0;
    while (iterator.hasNext()) {
      final AmendableWidget aw=iterator.next();
      if (aw != null) {
        if (aw == this) {
          break;
        }
        if (aw.getType().equalsIgnoreCase(getType())) {
          if (includeAmendments) {
            count++;
          }
 else {
            if (!aw.isIntroducedByAnAmendment()) {
              count++;
            }
          }
        }
      }
    }
    return count;
  }
  return 0;
}"
87422,"@Override public void onDetach(){
  if (childAmendableWidgets != null) {
    for (    final AmendableWidget child : childAmendableWidgets) {
      if (child.isAttached()) {
        child.onDetach();
      }
    }
  }
  if (isAttached()) {
    super.onDetach();
    this.listener=null;
    this.overlayStrategy=null;
    this.origin=null;
    this.amendable=null;
    this.setElement(null);
    this.amendmentControllers=null;
    this.assignedNumber=null;
    this.amendmentHolderElement=null;
    this.childAmendableWidgets=null;
    this.format=null;
    this.id=null;
    this.immutable=null;
    this.type=null;
    this.UIListener=null;
  }
}","@Override public void onDetach(){
  if (childAmendableWidgets != null) {
    for (    final AmendableWidget child : childAmendableWidgets) {
      if (child.isAttached()) {
        child.onDetach();
      }
    }
  }
  if (isAttached()) {
    super.onDetach();
    this.listener=null;
    this.overlayStrategy=null;
    this.origin=null;
    this.amendable=null;
    this.amendmentControllers=null;
    this.assignedNumber=null;
    this.amendmentHolderElement=null;
    this.childAmendableWidgets=null;
    this.format=null;
    this.id=null;
    this.immutable=null;
    this.type=null;
    this.UIListener=null;
  }
}"
87423,"@Override public void init(){
  if (!attached) {
    final JsArrayString jsStrings=(JsArrayString)JsArrayString.createArray();
    for (    final String s : cssPath) {
      jsStrings.push(s);
    }
    JavaScriptObject configuration=getConfiguration(jsStrings,readOnly,textArea.getOffsetHeight());
    editorInstance=getEditor(configuration,this.id,temporaryContent);
    if (editorInstance == null) {
      throw new NullPointerException(""String_Node_Str"");
    }
    attached=true;
  }
}","@Override public void init(){
  if (!attached) {
    final JsArrayString jsStrings=(JsArrayString)JsArrayString.createArray();
    for (    final String s : cssPath) {
      jsStrings.push(s);
    }
    JavaScriptObject configuration=getConfiguration(jsStrings,readOnly,textArea.getOffsetHeight() + (readOnly ? -5 : -45));
    editorInstance=getEditor(configuration,this.id,temporaryContent);
    if (editorInstance == null) {
      throw new NullPointerException(""String_Node_Str"");
    }
    attached=true;
  }
}"
87424,"protected void injectInternal(final AmendmentController amendmentController,final AmendableWidget root,final DocumentController documentController){
  final List<AmendableWidget> injectionPoints=injectionPointFinder.findInjectionPoints(amendmentController,root,documentController);
  if (injectionPoints != null) {
    for (    final AmendableWidget injectionPoint : injectionPoints) {
      final AmendableWidget target=injectionPointProvider.provideInjectionPoint(amendmentController,injectionPoint,documentController);
      if (target != null) {
        target.addAmendmentController(amendmentController);
        amendmentController.setDocumentController(documentController);
        documentEventBus.fireEvent(new AmendmentContainerInjectedEvent(amendmentController));
      }
    }
  }
}","protected void injectInternal(final AmendmentController amendmentController,final AmendableWidget root,final DocumentController documentController){
  final List<AmendableWidget> injectionPoints=injectionPointFinder.findInjectionPoints(amendmentController,root,documentController);
  if (injectionPoints != null) {
    if (injectionPoints.size() > 1) {
    }
    for (    final AmendableWidget injectionPoint : injectionPoints) {
      final AmendableWidget target=injectionPointProvider.provideInjectionPoint(amendmentController,injectionPoint,documentController);
      if (target != null) {
        target.addAmendmentController(amendmentController);
        amendmentController.setDocumentController(documentController);
        documentEventBus.fireEvent(new AmendmentContainerInjectedEvent(amendmentController));
      }
    }
  }
}"
87425,"@Override public List<AmendableWidget> findInjectionPoints(final AmendmentController amendmentController,final AmendableWidget root,final DocumentController documentController){
  final List<AmendableWidget> injectionPoints=new ArrayList<AmendableWidget>();
  final AmendableWidgetWalker.AmendableVisitor visitor=new AmendableWidgetWalker.AmendableVisitor(){
    public AmendableWidget found=null;
    @Override public boolean visit(    final AmendableWidget visited){
      if (visited != null) {
        if (amendmentController.getAmendment().getSourceReference().getElement().equalsIgnoreCase(visited.getId())) {
          injectionPoints.add(visited);
        }
      }
      return true;
    }
    public AmendableWidget getFound(){
      return found;
    }
  }
;
  documentController.walk(root,visitor);
  return injectionPoints;
}","@Override public List<AmendableWidget> findInjectionPoints(final AmendmentController amendmentController,final AmendableWidget root,final DocumentController documentController){
  final List<AmendableWidget> injectionPoints=new ArrayList<AmendableWidget>();
  final String path=amendmentController.getAmendment().getSourceReference().getPath();
  final AmendableWidgetWalker.AmendableVisitor visitor;
  if (path.startsWith(""String_Node_Str"")) {
    visitor=new AmendableWidgetWalker.AmendableVisitor(){
      @Override public boolean visit(      final AmendableWidget visited){
        if (visited != null) {
          if (path.substring(1).equalsIgnoreCase(visited.getId())) {
            injectionPoints.add(visited);
          }
        }
        return true;
      }
    }
;
  }
 else   if (path.startsWith(""String_Node_Str"")) {
    final String[] parts=path.substring(2).split(""String_Node_Str"");
    final Counter tracker=new Counter(0);
    visitor=new AmendableWidgetWalker.AmendableVisitor(){
      @Override public boolean visit(      final AmendableWidget visited){
        if (visited != null && tracker.get() < parts.length) {
          final String part=parts[tracker.get()];
          final String partType=part.substring(0,part.indexOf(""String_Node_Str""));
          if (visited.getType().equalsIgnoreCase(partType)) {
            final int typeIndex=Integer.parseInt(part.substring(part.indexOf(""String_Node_Str"") + 1,part.length() - 1));
            if (typeIndex == visited.getTypeIndex()) {
              tracker.increment();
            }
            if (tracker.get() == parts.length) {
              injectionPoints.add(visited);
              return false;
            }
          }
        }
        return true;
      }
    }
;
  }
 else {
    visitor=new AmendableWidgetWalker.AmendableVisitor(){
      @Override public boolean visit(      final AmendableWidget visited){
        if (visited != null) {
          if (path.equalsIgnoreCase(visited.getId())) {
            injectionPoints.add(visited);
          }
        }
        return true;
      }
    }
;
  }
  documentController.walk(root,visitor);
  return injectionPoints;
}"
87426,"@Override public boolean visit(final AmendableWidget visited){
  if (visited != null) {
    if (amendmentController.getAmendment().getSourceReference().getElement().equalsIgnoreCase(visited.getId())) {
      injectionPoints.add(visited);
    }
  }
  return true;
}","@Override public boolean visit(final AmendableWidget visited){
  if (visited != null) {
    if (path.equalsIgnoreCase(visited.getId())) {
      injectionPoints.add(visited);
    }
  }
  return true;
}"
87427,"@Override public AmendableWidget provideInjectionPoint(AmendmentController amendmentController,AmendableWidget root,DocumentController documentController){
  final AmendableWidgetReference reference=amendmentController.getAmendment().getSourceReference();
  if (reference.isCreation()) {
    final AmendableWidget child=documentController.getOverlayFactory().getAmendableWidget(reference.getType());
    child.setOrigin(AmendableWidgetOrigin.AMENDMENT);
    if (reference.isSibling()) {
      final AmendableWidget grandParent=root.getParentAmendableWidget();
      com.google.gwt.user.client.Element parentElement=grandParent.getAmendableElement().cast();
      com.google.gwt.user.client.Element childElement=child.getAmendableElement().cast();
      DOM.insertChild(parentElement,childElement,grandParent.getChildAmendableWidgets().indexOf(root));
      grandParent.addAmendableWidget(child);
    }
 else {
      if (!root.getChildAmendableWidgets().isEmpty() && root.getChildAmendableWidgets().size() > reference.getOffset()) {
        if (root.getChildAmendableWidgets().get(reference.getOffset()).getOrigin() == AmendableWidgetOrigin.AMENDMENT) {
          return root.getChildAmendableWidgets().get(reference.getOffset());
        }
      }
      com.google.gwt.user.client.Element parentElement=root.getAmendableElement().cast();
      com.google.gwt.user.client.Element childElement=child.getAmendableElement().cast();
      DOM.appendChild(parentElement,childElement);
      root.addAmendableWidget(child);
    }
    return child;
  }
 else {
    return root;
  }
}","@Override public AmendableWidget provideInjectionPoint(AmendmentController amendmentController,AmendableWidget root,DocumentController documentController){
  final AmendableWidgetReference reference=amendmentController.getAmendment().getSourceReference();
  if (reference.isCreation()) {
    final AmendableWidget child=documentController.getOverlayFactory().getAmendableWidget(reference.getType());
    child.setOrigin(AmendableWidgetOrigin.AMENDMENT);
    if (!root.getChildAmendableWidgets().isEmpty() && root.getChildAmendableWidgets().size() > reference.getOffset()) {
      if (root.getChildAmendableWidgets().get(reference.getOffset()).getOrigin() == AmendableWidgetOrigin.AMENDMENT) {
        return root.getChildAmendableWidgets().get(reference.getOffset());
      }
    }
    com.google.gwt.user.client.Element parentElement=root.getAmendableElement().cast();
    com.google.gwt.user.client.Element childElement=child.getAmendableElement().cast();
    root.addAmendableWidget(child,reference.getOffset(),true);
    DOM.insertChild(parentElement,childElement,root.getChildAmendableWidgets().indexOf(child));
    LOG.info(""String_Node_Str"" + child + ""String_Node_Str""+ root+ ""String_Node_Str""+ reference.getOffset());
    return child;
  }
 else {
    LOG.info(""String_Node_Str"" + root);
    return root;
  }
}"
87428,"public static Integer getAssignedNumber(final AmendableWidget amendableWidget){
  if (amendableWidget.getParentAmendableWidget() != null) {
    final Iterator<AmendableWidget> iterator=amendableWidget.getParentAmendableWidget().getChildAmendableWidgets().iterator();
    int count=0;
    while (iterator.hasNext()) {
      final AmendableWidget aw=iterator.next();
      if (aw != null) {
        if (aw.getType().equalsIgnoreCase(amendableWidget.getType())) {
          count++;
        }
        if (aw == amendableWidget) {
          break;
        }
      }
    }
    return count;
  }
  return null;
}","public static Integer getAssignedNumber(final AmendableWidget amendableWidget){
  if (amendableWidget.getParentAmendableWidget() != null) {
    return amendableWidget.getTypeIndex() + 1;
  }
  return null;
}"
87429,"/** 
 * Add an amendable widget as a child, but do not perform a runtime validation check.
 * @param child             the child to add
 * @param skipValidation    <tt>true</tt> to skip validation.
 */
void addAmendableWidget(AmendableWidget child,boolean skipValidation);","/** 
 * Add an amendable widget as a child at position <tt>index</tt>, but do not perform a runtime validation check.
 * @param child          the child to add
 * @param index          the position to insert the widget at (-1 means it will be added at the end)
 * @param skipValidation <tt>true</tt> to skip validation.
 */
void addAmendableWidget(AmendableWidget child,int index,boolean skipValidation);"
87430,"public static Integer getAssignedNumber(final AmendableWidget amendableWidget){
  if (amendableWidget.getParentAmendableWidget() != null) {
    final Iterator<AmendableWidget> iterator=amendableWidget.getParentAmendableWidget().getChildAmendableWidgets().iterator();
    int count=1;
    while (iterator.hasNext()) {
      AmendableWidget aw=iterator.next();
      if (aw != null) {
        if (aw.getType().equalsIgnoreCase(amendableWidget.getType())) {
          count++;
        }
        if (aw == amendableWidget) {
          break;
        }
      }
    }
    return count;
  }
  return null;
}","public static Integer getAssignedNumber(final AmendableWidget amendableWidget){
  if (amendableWidget.getParentAmendableWidget() != null) {
    final Iterator<AmendableWidget> iterator=amendableWidget.getParentAmendableWidget().getChildAmendableWidgets().iterator();
    int count=0;
    while (iterator.hasNext()) {
      final AmendableWidget aw=iterator.next();
      if (aw != null) {
        if (aw.getType().equalsIgnoreCase(amendableWidget.getType())) {
          count++;
        }
        if (aw == amendableWidget) {
          break;
        }
      }
    }
    return count;
  }
  return null;
}"
87431,"@Override public boolean process(OverlayClass overlayClass){
  final CssOverlayStyle overlayStyle=new CssOverlayStyle(overlayClass);
  try {
    Map<String,Object> rootMap=new HashMap<String,Object>();
    rootMap.put(""String_Node_Str"",overlayClass);
    rootMap.put(""String_Node_Str"",CssOverlayStyle.CssOverlayFactory.getInstance());
    rootMap.put(""String_Node_Str"",styles);
    final Template template=configuration.getTemplate(templateName);
    final DefaultObjectWrapper wrapper=new DefaultObjectWrapper();
    template.process(rootMap,out,wrapper);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  TemplateException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return true;
}","@Override public boolean process(OverlayClass overlayClass){
  try {
    Map<String,Object> rootMap=new HashMap<String,Object>();
    rootMap.put(""String_Node_Str"",overlayClass);
    rootMap.put(""String_Node_Str"",CssOverlayStyle.CssOverlayFactory.getInstance());
    rootMap.put(""String_Node_Str"",styles);
    final Template template=configuration.getTemplate(templateName);
    final DefaultObjectWrapper wrapper=new DefaultObjectWrapper();
    template.process(rootMap,out,wrapper);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  TemplateException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return true;
}"
87432,"public static String capitalize(String input){
}","public static String capitalize(String input){
  if (input != null) {
    if (""String_Node_Str"".equals(input.trim()))     return input;
    return input.substring(0,1).toUpperCase() + input.substring(1);
  }
  return null;
}"
87433,"@Override public void onBrowserEvent(final Event event){
  event.stopPropagation();
  if (UIListener != null) {
switch (DOM.eventGetType(event)) {
case Event.ONCLICK:
      UIListener.onClick(this);
    break;
case Event.ONDBLCLICK:
  UIListener.onDblClick(this);
break;
case Event.ONMOUSEMOVE:
UIListener.onMouseOver(this);
break;
case Event.ONMOUSEOUT:
UIListener.onMouseOut(this);
break;
}
}
}","@Override public void onBrowserEvent(final Event event){
  event.stopPropagation();
  if (UIListener != null) {
switch (DOM.eventGetType(event)) {
case Event.ONCLICK:
      UIListener.onClick(this);
    break;
case Event.ONDBLCLICK:
  UIListener.onDblClick(this);
break;
case Event.ONMOUSEMOVE:
UIListener.onMouseOver(this);
break;
case Event.ONMOUSEOUT:
UIListener.onMouseOut(this);
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"");
}
}
}"
87434,"@Override public Element[] getChildren(Element element){
  return new Element[0];
}","@Override public Element[] getChildren(Element element){
  return new Element[]{};
}"
87435,"@Override public Boolean isImmutable(Element element){
  return null;
}","@Override public Boolean isImmutable(Element element){
  return false;
}"
87436,"private static boolean isLetter(char c){
  if (Arrays.binarySearch(Alphabet.GREEK_NUMBERING,c) != -1)   return true;
  if (Arrays.binarySearch(Alphabet.CYRILLIC_NUMBERING,c) != -1)   return true;
  return Character.isLetter(c);
}","private static boolean isLetter(char c){
  if (Arrays.binarySearch(Alphabet.getGreekNumbering(),c) != -1)   return true;
  if (Arrays.binarySearch(Alphabet.getCyrillicNumbering(),c) != -1)   return true;
  return Character.isLetter(c);
}"
87437,"public String[] getDocumentIDs(){
  return documentIDs;
}","public String[] getDocumentIDs(){
  return documentIDs != null ? Arrays.asList(documentIDs).toArray(new String[documentIDs.length]) : null;
}"
87438,"public HashMap<String,String[]> getParameters(){
  return parameters;
}","public HashMap<String,String[]> getParameters(){
  return parameters != null ? new HashMap<String,String[]>(parameters) : null;
}"
87439,"public String[] getRoles(){
  return roles;
}","public String[] getRoles(){
  return roles != null ? Arrays.asList(roles).toArray(new String[roles.length]) : null;
}"
87440,"public Date getDeadline(){
  return deadline;
}","public Date getDeadline(){
  return deadline != null ? new Date(deadline.getTime()) : null;
}"
87441,"@Override public String getType(){
  return amendableElement.getTagName();
}","@Override public String getType(){
  return amendableElement.getNodeName();
}"
87442,"@Inject public AmendmentManager(final ClientFactory clientFactory){
  this.clientFactory=clientFactory;
}","@Inject public AmendmentManager(final ClientFactory clientFactory){
  this.clientFactory=clientFactory;
  Log.info(""String_Node_Str"");
}"
87443,"private AmendmentController createAmendmentController(final AmendmentContainerDTO amendment){
  AmendmentController amendmentController=new AmendmentController(clientFactory,new AmendmentViewImpl());
  amendmentController.setAmendment(amendment);
  return amendmentController;
}","private AmendmentController createAmendmentController(final AmendmentContainerDTO amendment){
  AmendmentController amendmentController=injector.getAmendmentController();
  amendmentController.setAmendment(amendment);
  return amendmentController;
}"
87444,"public void setAmendment(AmendmentContainerDTO amendment){
  this.amendment=amendment;
}","public void setAmendment(AmendmentContainerDTO amendment){
  this.amendment=amendment;
  setJustification(""String_Node_Str"" + amendment.getAmendmentContainerID());
  setTitle(""String_Node_Str"" + amendment.getAmendmentContainerID());
}"
87445,"@Inject public AmendmentController(final ClientFactory clientFactory,final AmendmentView view){
  this.clientFactory=clientFactory;
  this.view=view;
  registerListeners();
}","@Inject public AmendmentController(final ClientFactory clientFactory){
  this.clientFactory=clientFactory;
  this.view=amendmentInjector.getAmendmentView();
  this.amendmentEventBus=amendmentInjector.getAmendmentEventBus();
  registerListeners();
}"
87446,"@Override public void configure(GinBinder binder){
  binder.bind(ClientContext.class).toProvider(DefaultClientContextProvider.class).in(Singleton.class);
  binder.bind(Scheduler.class).toProvider(DefaultSchedulerProvider.class).in(Singleton.class);
  binder.bind(EventBus.class).toProvider(DefaultEventBusProvider.class).in(Singleton.class);
  binder.bind(PlaceController.class).toProvider(DefaultPlaceControllerProvider.class).in(Singleton.class);
}","@Override public void configure(GinBinder binder){
  binder.bind(ClientFactory.class).to(ClientFactoryImpl.class).in(Singleton.class);
  binder.bind(ClientContext.class).toProvider(DefaultClientContextProvider.class).in(Singleton.class);
  binder.bind(Scheduler.class).toProvider(DefaultSchedulerProvider.class).in(Singleton.class);
  binder.bind(EventBus.class).toProvider(DefaultEventBusProvider.class).in(Singleton.class);
  binder.bind(PlaceController.class).toProvider(DefaultPlaceControllerProvider.class).in(Singleton.class);
}"
87447,"public AuthenticatedEvent(String principal){
  this.principal=principal;
}","public AuthenticatedEvent(ClientContext clientContext){
  this.clientContext=clientContext;
}"
87448,"public static void main(String[] argv) throws ConnectionError, ContentError, RuntimeError, ParseError, ParseException, BuildException, XMLException {
  if (argv.length == 0) {
    System.err.println(""String_Node_Str"");
    showUsage();
    System.exit(1);
  }
  if (argv.length == 1 && (argv[0].equals(""String_Node_Str"") || argv[0].equals(""String_Node_Str"") || argv[0].equals(""String_Node_Str""))) {
    showUsage();
    System.exit(0);
  }
  HashMap<String,String> argMap=parseArguments(argv);
  String typePath=null;
  String modelName=null;
  boolean verbose=false;
  if (argMap.containsKey(""String_Node_Str"")) {
    typePath=argMap.get(""String_Node_Str"");
    argMap.remove(""String_Node_Str"");
  }
  if (argMap.containsKey(""String_Node_Str"")) {
    modelName=argMap.get(""String_Node_Str"");
    argMap.remove(""String_Node_Str"");
  }
  if (modelName == null) {
    showUsage();
    System.exit(1);
  }
  File simFile=new File(modelName);
  if (!simFile.exists()) {
    E.error(""String_Node_Str"" + simFile.getAbsolutePath());
    System.exit(1);
  }
  FileInclusionReader fir=new FileInclusionReader(simFile);
  if (typePath != null) {
    fir.addSearchPaths(typePath);
  }
  Sim sim=new Sim(fir.read());
  sim.readModel();
  sim.build();
  ControlPanel.getInstance().registerSimulation(sim,simFile);
  StateInstance si=sim.getRootState(false);
  StateType st=sim.getTargetBehavior();
  if (verbose) {
    System.out.println(""String_Node_Str"");
    System.out.println(st.getSummary(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(si.getSummary(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  }
  boolean doRun=true;
  if (doRun) {
    sim.run();
    E.info(""String_Node_Str"");
  }
  IOUtil.saveReportAndTimesFile(sim);
}","public static void main(String[] argv) throws ConnectionError, ContentError, RuntimeError, ParseError, ParseException, BuildException, XMLException {
  if (argv.length == 0) {
    System.err.println(""String_Node_Str"");
    showUsage();
    System.exit(1);
  }
  if (argv.length == 1 && (argv[0].equals(""String_Node_Str"") || argv[0].equals(""String_Node_Str"") || argv[0].equals(""String_Node_Str""))) {
    showUsage();
    System.exit(0);
  }
  HashMap<String,String> argMap=parseArguments(argv);
  String typePath=null;
  String modelName=null;
  boolean verbose=false;
  if (argMap.containsKey(""String_Node_Str"")) {
    typePath=argMap.get(""String_Node_Str"");
    argMap.remove(""String_Node_Str"");
  }
  if (argMap.containsKey(""String_Node_Str"")) {
    modelName=argMap.get(""String_Node_Str"");
    argMap.remove(""String_Node_Str"");
  }
  if (modelName == null) {
    showUsage();
    System.exit(1);
  }
  final String typePathArg=typePath;
  ControlPanel cp=new ControlPanel(){
    @Override public Sim importFile(    File simFile){
      if (!simFile.exists()) {
        E.error(""String_Node_Str"" + simFile.getAbsolutePath());
        System.exit(1);
      }
      FileInclusionReader fir=new FileInclusionReader(simFile);
      if (typePathArg != null) {
        fir.addSearchPaths(typePathArg);
      }
      try {
        Sim sim=new Sim(fir.read());
        sim.readModel();
        sim.build();
        return sim;
      }
 catch (      Exception e) {
        return null;
      }
    }
  }
;
  File simFile=new File(modelName);
  Sim sim=cp.initialise(simFile);
  StateInstance si=sim.getRootState(false);
  StateType st=sim.getTargetBehavior();
  if (verbose) {
    System.out.println(""String_Node_Str"");
    System.out.println(st.getSummary(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(si.getSummary(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  }
  boolean doRun=true;
  if (doRun) {
    sim.run();
    E.info(""String_Node_Str"");
  }
  IOUtil.saveReportAndTimesFile(sim);
}"
87449,"/** 
 * The control panel handles one simulation at a time, this should be ""registered"" using this method. Load all the windows, one per display
 * @param sim - simulation object
 * @param simFile - new file to load (can be null)
 * @throws ConnectionError
 * @throws ContentError
 * @throws RuntimeError
 * @throws ParseError
 */
public void registerSimulation(Sim sim,File simFile) throws ConnectionError, ContentError, RuntimeError, ParseError {
  simulation=sim;
  if (simFile != null) {
    workingFile=simFile;
    statusLabel.setText(workingFile.getName());
  }
  loadRunConfigsFromSimulation();
  positionViewers();
}","/** 
 * The control panel handles one simulation at a time, this should be ""registered"" using this method. Load all the windows, one per display
 * @param sim - simulation object
 * @param simFile - new file to load (can be null)
 * @throws ConnectionError
 * @throws ContentError
 * @throws RuntimeError
 * @throws ParseError
 */
protected void registerSimulation(Sim sim,File simFile){
  simulation=sim;
  if (sim == null)   return;
  if (simFile != null) {
    setNewWorkingFile(simFile);
  }
  loadRunConfigsFromSimulation();
  positionViewers();
}"
87450,"/** 
 * load the runConfigs from the simulation into the runConfigs map. The runConfigs map is indexed for easy referencing
 */
private void loadRunConfigsFromSimulation(){
  int index=-1;
  for (  RunConfig conf : simulation.getRunConfigs()) {
    runConfigs.put(index++,conf);
  }
}","/** 
 * load the runConfigs from the simulation into the runConfigs map. The runConfigs map is indexed for easy referencing
 */
protected void loadRunConfigsFromSimulation(){
  int index=-1;
  for (  RunConfig conf : simulation.getRunConfigs()) {
    runConfigs.put(index++,conf);
  }
}"
87451,"private void clearCurrentSimulation(){
  for (  String key : simulation.getDvHM().keySet()) {
    if (simulation.getDvHM().get(key) instanceof StandaloneViewer) {
      StandaloneViewer viewer=((StandaloneViewer)simulation.getDvHM().get(key));
      viewerRects.put(key,viewer.getViewerRectangle());
      viewer.close();
    }
  }
}","protected void clearCurrentSimulation(){
  for (  String key : simulation.getDvHM().keySet()) {
    if (simulation.getDvHM().get(key) instanceof StandaloneViewer) {
      StandaloneViewer viewer=((StandaloneViewer)simulation.getDvHM().get(key));
      viewerRects.put(key,viewer.getViewerRectangle());
      viewer.close();
    }
  }
}"
87452,"/** 
 * Lay out the StandaloneViewer windows in a  
 */
private void positionViewers(){
  int borderWidth=10;
  int layerWidth=30;
  int start_cursor_x=(int)windowDimension.getWidth() + borderWidth;
  int start_cursor_y=0;
  frame.setLocation(0,0);
  int screenWidth=java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds().width;
  int screenHeight=java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds().height;
  int cursor_x=start_cursor_x;
  int cursor_y=start_cursor_y;
  for (  String key : simulation.getDvHM().keySet()) {
    if (simulation.getDvHM().get(key) instanceof StandaloneViewer) {
      StandaloneViewer sViewer=((StandaloneViewer)simulation.getDvHM().get(key));
      if (viewerRects.containsKey(key)) {
        sViewer.setViewerRectangle(viewerRects.get(key));
        sViewer.show();
        continue;
      }
      sViewer.setViewerRectangle(new Rectangle(cursor_x,cursor_y,(int)sViewer.getDimensions().getWidth(),(int)sViewer.getDimensions().getHeight()));
      sViewer.show();
      cursor_y+=sViewer.getDimensions().getHeight() + borderWidth;
      if ((cursor_y + sViewer.getDimensions().getHeight()) > screenHeight - start_cursor_y) {
        cursor_y=start_cursor_y;
        if ((cursor_x + sViewer.getDimensions().getWidth()) > screenWidth - start_cursor_x) {
          start_cursor_y+=layerWidth;
          start_cursor_x+=layerWidth;
          cursor_y=start_cursor_y;
          cursor_x=start_cursor_x;
        }
 else {
          cursor_x+=sViewer.getDimensions().getWidth() + borderWidth;
        }
      }
    }
  }
  frame.setVisible(true);
}","/** 
 * Lay out the StandaloneViewer windows in a  
 */
protected void positionViewers(){
  int borderWidth=10;
  int layerWidth=30;
  int start_cursor_x=(int)windowDimension.getWidth() + borderWidth;
  int start_cursor_y=0;
  frame.setLocation(0,0);
  int screenWidth=java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds().width;
  int screenHeight=java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds().height;
  int cursor_x=start_cursor_x;
  int cursor_y=start_cursor_y;
  for (  String key : simulation.getDvHM().keySet()) {
    if (simulation.getDvHM().get(key) instanceof StandaloneViewer) {
      StandaloneViewer sViewer=((StandaloneViewer)simulation.getDvHM().get(key));
      if (viewerRects.containsKey(key)) {
        sViewer.setViewerRectangle(viewerRects.get(key));
        sViewer.showWithoutPack();
        continue;
      }
      sViewer.setViewerRectangle(new Rectangle(cursor_x,cursor_y,(int)sViewer.getDimensions().getWidth(),(int)sViewer.getDimensions().getHeight()));
      sViewer.show();
      cursor_y+=sViewer.getDimensions().getHeight() + borderWidth;
      if ((cursor_y + sViewer.getDimensions().getHeight()) > screenHeight - start_cursor_y) {
        cursor_y=start_cursor_y;
        if ((cursor_x + sViewer.getDimensions().getWidth()) > screenWidth - start_cursor_x) {
          start_cursor_y+=layerWidth;
          start_cursor_x+=layerWidth;
          cursor_y=start_cursor_y;
          cursor_x=start_cursor_x;
        }
 else {
          cursor_x+=sViewer.getDimensions().getWidth() + borderWidth;
        }
      }
    }
  }
  frame.setVisible(true);
}"
87453,"private void importFile(){
  FileInclusionReader fir=new FileInclusionReader(workingFile);
  try {
    Sim sim=new Sim(fir.read());
    sim.readModel();
    sim.build();
    ControlPanel.getInstance().registerSimulation(sim,null);
  }
 catch (  Exception e) {
    JOptionPane.showMessageDialog(new JFrame(),String.format(""String_Node_Str"",e.getMessage()),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}",protected abstract Sim importFile(File sourceFile);
87454,"/** 
 * The toolbar for the control panel - open, layer and run The buttons have matching menu items performing the same actions 
 */
private void createToolbar(){
  int iconSize=20;
  JToolBar toolbar=new JToolBar();
  toolbar.setFloatable(false);
  toolbar.setRollover(true);
  toolbar.setPreferredSize(new Dimension(0,iconSize + 20));
  URL imgURL=getClass().getResource(""String_Node_Str"");
  ImageIcon iconOpen=new ImageIcon(imgURL);
  Image img=iconOpen.getImage().getScaledInstance(iconSize,iconSize,Image.SCALE_SMOOTH);
  iconOpen.setImage(img);
  JButton buttonOpen=new JButton(iconOpen);
  buttonOpen.setSize(iconSize,iconSize);
  buttonOpen.setToolTipText(""String_Node_Str"");
  buttonOpen.setActionCommand(""String_Node_Str"");
  buttonOpen.addActionListener(this);
  toolbar.add(buttonOpen);
  imgURL=getClass().getResource(""String_Node_Str"");
  ImageIcon iconBringToFront=new ImageIcon(imgURL);
  img=iconBringToFront.getImage().getScaledInstance(iconSize,iconSize,Image.SCALE_SMOOTH);
  iconBringToFront.setImage(img);
  JButton buttonBringToFront=new JButton(iconBringToFront);
  buttonBringToFront.setSize(iconSize,iconSize);
  buttonBringToFront.setToolTipText(""String_Node_Str"");
  buttonBringToFront.setActionCommand(""String_Node_Str"");
  buttonBringToFront.addActionListener(this);
  toolbar.add(buttonBringToFront);
  imgURL=getClass().getResource(""String_Node_Str"");
  ImageIcon iconReloadAndRun=new ImageIcon(imgURL);
  img=iconReloadAndRun.getImage().getScaledInstance(iconSize,iconSize,Image.SCALE_SMOOTH);
  iconReloadAndRun.setImage(img);
  JButton buttonReloadAndRun=new JButton(iconReloadAndRun);
  buttonReloadAndRun.setSize(iconSize,iconSize);
  buttonReloadAndRun.setToolTipText(""String_Node_Str"");
  buttonReloadAndRun.setActionCommand(""String_Node_Str"");
  buttonReloadAndRun.addActionListener(this);
  toolbar.add(buttonReloadAndRun);
  frame.add(toolbar,BorderLayout.NORTH);
}","/** 
 * The toolbar for the control panel - open, layer and run The buttons have matching menu items performing the same actions 
 */
protected void createToolbar(){
  int iconSize=20;
  JToolBar toolbar=new JToolBar();
  toolbar.setFloatable(false);
  toolbar.setRollover(true);
  toolbar.setPreferredSize(new Dimension(0,iconSize + 20));
  URL imgURL=getClass().getResource(""String_Node_Str"");
  ImageIcon iconOpen=new ImageIcon(imgURL);
  Image img=iconOpen.getImage().getScaledInstance(iconSize,iconSize,Image.SCALE_SMOOTH);
  iconOpen.setImage(img);
  JButton buttonOpen=new JButton(iconOpen);
  buttonOpen.setSize(iconSize,iconSize);
  buttonOpen.setToolTipText(""String_Node_Str"");
  buttonOpen.setActionCommand(""String_Node_Str"");
  buttonOpen.addActionListener(this);
  toolbar.add(buttonOpen);
  imgURL=getClass().getResource(""String_Node_Str"");
  ImageIcon iconBringToFront=new ImageIcon(imgURL);
  img=iconBringToFront.getImage().getScaledInstance(iconSize,iconSize,Image.SCALE_SMOOTH);
  iconBringToFront.setImage(img);
  JButton buttonBringToFront=new JButton(iconBringToFront);
  buttonBringToFront.setSize(iconSize,iconSize);
  buttonBringToFront.setToolTipText(""String_Node_Str"");
  buttonBringToFront.setActionCommand(""String_Node_Str"");
  buttonBringToFront.addActionListener(this);
  toolbar.add(buttonBringToFront);
  imgURL=getClass().getResource(""String_Node_Str"");
  ImageIcon iconReloadAndRun=new ImageIcon(imgURL);
  img=iconReloadAndRun.getImage().getScaledInstance(iconSize,iconSize,Image.SCALE_SMOOTH);
  iconReloadAndRun.setImage(img);
  buttonReloadAndRun=new JButton(iconReloadAndRun);
  buttonReloadAndRun.setEnabled(false);
  buttonReloadAndRun.setSize(iconSize,iconSize);
  buttonReloadAndRun.setToolTipText(""String_Node_Str"");
  buttonReloadAndRun.setActionCommand(""String_Node_Str"");
  buttonReloadAndRun.addActionListener(this);
  toolbar.add(buttonReloadAndRun);
  frame.add(toolbar,BorderLayout.NORTH);
}"
87455,"/** 
 * When simulation.run() is called from the actionPerformed method below, it holds up the  Java Swing display thread and we don't get the nice animation, so call run() in its own thread here.
 */
private void runSimulationInNewThread(){
  for (  final Entry<Integer,RunConfig> conf : runConfigs.entrySet()) {
    multiThreadService.execute(new Runnable(){
      @Override public void run(){
        try {
          simulation.run(conf.getValue(),false);
        }
 catch (        Exception ex) {
          JOptionPane.showMessageDialog(new JFrame(),String.format(""String_Node_Str"",ex.getMessage()),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        }
      }
    }
);
  }
}","/** 
 * When simulation.run() is called from the actionPerformed method below, it holds up the  Java Swing display thread and we don't get the nice animation, so call run() in its own thread here.
 */
protected void runSimulationInNewThread(){
  for (  final Entry<Integer,RunConfig> conf : runConfigs.entrySet()) {
    multiThreadService.execute(new Runnable(){
      @Override public void run(){
        try {
          simulation.run(conf.getValue(),false);
        }
 catch (        Exception ex) {
          JOptionPane.showMessageDialog(new JFrame(),String.format(""String_Node_Str"",ex.getMessage()),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        }
      }
    }
);
  }
}"
87456,"private void addToMenu(String[] actions,JMenu jm){
  for (  String s : actions) {
    JMenuItem jmi=new JMenuItem(s);
    jmi.setActionCommand(s.toLowerCase());
    jmi.addActionListener(this);
    jm.add(jmi);
  }
}","protected void addToMenu(String[] actions,JMenu jm){
  for (  String s : actions) {
    JMenuItem jmi=new JMenuItem(s);
    jmi.setActionCommand(s.toLowerCase());
    jmi.addActionListener(this);
    jm.add(jmi);
  }
}"
87457,"public void actionPerformed(ActionEvent e){
  String sev=e.getActionCommand();
  if (sev.equals(""String_Node_Str"")) {
    importNewFile();
    runSimulationInNewThread();
  }
 else   if (sev.equals(""String_Node_Str"")) {
    frame.dispatchEvent(new WindowEvent(frame,WindowEvent.WINDOW_CLOSING));
  }
 else   if (sev.equals(""String_Node_Str"")) {
    bringAllViewersToForeground();
  }
 else   if (sev.equals(""String_Node_Str"")) {
    if (simulation != null) {
      clearCurrentSimulation();
      importFile();
      runSimulationInNewThread();
    }
  }
}","public void actionPerformed(ActionEvent e){
  String sev=e.getActionCommand();
  if (sev.equals(""String_Node_Str"")) {
    File newfile=SwingDialogs.getInstance().getFileToRead();
    if (newfile == null)     return;
    clearAll();
    try {
      setNewWorkingFile(newfile);
      Sim sim=importFile(newfile);
      registerSimulation(sim,workingFile);
    }
 catch (    Exception ex) {
      setPrevWorkingFile();
      restoreViewerWindows();
      JOptionPane.showMessageDialog(new JFrame(),String.format(""String_Node_Str"",ex.getMessage()),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
    runSimulationInNewThread();
  }
 else   if (sev.equals(""String_Node_Str"")) {
    frame.dispatchEvent(new WindowEvent(frame,WindowEvent.WINDOW_CLOSING));
  }
 else   if (sev.equals(""String_Node_Str"")) {
    restoreViewerWindows();
  }
 else   if (sev.equals(""String_Node_Str"")) {
    if (simulation != null) {
      clearCurrentSimulation();
      try {
        Sim sim=importFile(workingFile);
        registerSimulation(sim,null);
      }
 catch (      Exception ex) {
        restoreViewerWindows();
        JOptionPane.showMessageDialog(new JFrame(),String.format(""String_Node_Str"",ex.getMessage()),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
      runSimulationInNewThread();
    }
  }
}"
87458,"private ControlPanel(){
  frame=new JFrame(""String_Node_Str"");
  frame.setPreferredSize(windowDimension);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  Container ctr=frame.getContentPane();
  JMenuBar jmb=new JMenuBar();
  JMenu jm=new JMenu(""String_Node_Str"");
  String[] actions={""String_Node_Str"",""String_Node_Str""};
  addToMenu(actions,jm);
  jmb.add(jm);
  JMenu jvm=new JMenu(""String_Node_Str"");
  String[] viewActions={""String_Node_Str""};
  addToMenu(viewActions,jvm);
  jmb.add(jvm);
  JMenu jmsimulation=new JMenu(""String_Node_Str"");
  addToMenuWithShortcut(""String_Node_Str"",jmsimulation,KeyEvent.VK_F6,0);
  jmb.add(jmsimulation);
  frame.setJMenuBar(jmb);
  statusLabel.setHorizontalAlignment(SwingConstants.LEFT);
  statusLabel.setVerticalAlignment(SwingConstants.TOP);
  statusLabel.setFont(new Font(statusLabel.getFont().getFontName(),10,10));
  statusLabel.setHorizontalAlignment(SwingConstants.LEFT);
  JPanel statusPanel=new JPanel();
  statusPanel.setBorder(BorderFactory.createLineBorder(Color.GRAY));
  statusPanel.setLayout(new BoxLayout(statusPanel,BoxLayout.X_AXIS));
  statusPanel.add(statusLabel);
  ctr.add(pmain,BorderLayout.SOUTH);
  ctr.add(statusPanel,BorderLayout.SOUTH);
  createToolbar();
  show();
}","public ControlPanel(){
  frame=new JFrame(""String_Node_Str"");
  frame.setPreferredSize(windowDimension);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  Container ctr=frame.getContentPane();
  JMenuBar jmb=new JMenuBar();
  JMenu jm=new JMenu(""String_Node_Str"");
  String[] actions={""String_Node_Str"",""String_Node_Str""};
  addToMenu(actions,jm);
  jmb.add(jm);
  JMenu jvm=new JMenu(""String_Node_Str"");
  String[] viewActions={""String_Node_Str""};
  addToMenu(viewActions,jvm);
  jmb.add(jvm);
  JMenu jmsimulation=new JMenu(""String_Node_Str"");
  menuItemReloadAndRun=addToMenuWithShortcut(""String_Node_Str"",jmsimulation,KeyEvent.VK_F6,0);
  jmb.add(jmsimulation);
  frame.setJMenuBar(jmb);
  statusLabel.setHorizontalAlignment(SwingConstants.LEFT);
  statusLabel.setVerticalAlignment(SwingConstants.TOP);
  statusLabel.setFont(new Font(statusLabel.getFont().getFontName(),10,10));
  statusLabel.setHorizontalAlignment(SwingConstants.LEFT);
  JPanel statusPanel=new JPanel();
  statusPanel.setBorder(BorderFactory.createLineBorder(Color.GRAY));
  statusPanel.setLayout(new BoxLayout(statusPanel,BoxLayout.X_AXIS));
  statusPanel.add(statusLabel);
  ctr.add(pmain,BorderLayout.SOUTH);
  ctr.add(statusPanel,BorderLayout.SOUTH);
  createToolbar();
  setRunSimulationEnabled(false);
  show();
}"
87459,"/** 
 * @param action - The name of the action item
 * @param jm - the menu for this item to be added to
 * @param key - int representing the ID of KeyEvent (eg KeyEvent.VK_F6)
 * @param modifier - int representing the ID of ActionEvent (eg ActionEvent.ALT_MASK , 0 for no modifier)
 */
private void addToMenuWithShortcut(String action,JMenu jm,int key,int modifier){
  JMenuItem jmi=new JMenuItem(action);
  jmi.setActionCommand(action.toLowerCase());
  jmi.addActionListener(this);
  jmi.setAccelerator(KeyStroke.getKeyStroke(key,modifier));
  jm.add(jmi);
}","/** 
 * @param action - The name of the action item
 * @param jm - the menu for this item to be added to
 * @param key - int representing the ID of KeyEvent (eg KeyEvent.VK_F6)
 * @param modifier - int representing the ID of ActionEvent (eg ActionEvent.ALT_MASK , 0 for no modifier)
 */
protected JMenuItem addToMenuWithShortcut(String action,JMenu jm,int key,int modifier){
  JMenuItem jmi=new JMenuItem(action);
  jmi.setActionCommand(action.toLowerCase());
  jmi.addActionListener(this);
  jmi.setAccelerator(KeyStroke.getKeyStroke(key,modifier));
  jm.add(jmi);
  return jmi;
}"
87460,"private String mapEs(String frm,String to,String str){
  int strlen=str.length();
  String ret=""String_Node_Str"";
  int lastmatch=0;
  int newmatch=str.indexOf(frm);
  while (newmatch >= 0) {
    ret+=str.substring(lastmatch,newmatch);
    if (newmatch + 3 < strlen && numberHS.contains(str.substring(newmatch + 2,newmatch + 3))) {
      ret+=to;
    }
 else {
      ret+=frm;
    }
    lastmatch=newmatch + frm.length();
    newmatch=str.indexOf(frm,lastmatch);
  }
  ret+=str.substring(lastmatch,str.length());
  return ret;
}","private String mapEs(String frm,String to,String str){
  int strlen=str.length();
  String ret=""String_Node_Str"";
  int lastmatch=0;
  int newmatch=str.indexOf(frm);
  while (newmatch >= 0) {
    ret+=str.substring(lastmatch,newmatch);
    if (newmatch + 3 <= strlen && numberHS.contains(str.substring(newmatch + 2,newmatch + 3))) {
      ret+=to;
    }
 else {
      ret+=frm;
    }
    lastmatch=newmatch + frm.length();
    newmatch=str.indexOf(frm,lastmatch);
  }
  ret+=str.substring(lastmatch,str.length());
  return ret;
}"
87461,"public ArrayList<Node> tokenize(String e){
  ArrayList<Node> ret=new ArrayList<Node>();
  String ewk=disambiguate(e);
  for (  String op : opHM.keySet()) {
    ewk=replaceAll(ewk,op,""String_Node_Str"" + op + ""String_Node_Str"");
  }
  ewk=replaceAll(ewk,""String_Node_Str"",""String_Node_Str"");
  ewk=replaceAll(ewk,""String_Node_Str"",""String_Node_Str"");
  ewk=reambiguate(ewk);
  if (verbose) {
    E.info(""String_Node_Str"" + ewk);
  }
  Node pretok=null;
  String[] bits=ewk.split(""String_Node_Str"");
  for (int i=0; i < bits.length; i++) {
    String stok=bits[i];
    stok=stok.trim();
    if (stok.length() > 0) {
      Node n=null;
      if (stok.equals(""String_Node_Str"")) {
        n=new GroupNode();
      }
 else       if (stok.equals(""String_Node_Str"")) {
        n=new OpenNode();
      }
 else       if (funcHS.contains(stok)) {
        n=new FunctionNode(stok);
      }
 else       if (opHM.containsKey(stok)) {
        n=opHM.get(stok).copy();
        if (n instanceof MinusNode && pretok instanceof AbstractOperatorNode) {
          n=new UnaryMinusNode();
        }
      }
 else       if (snum.indexOf(stok.substring(0,1)) >= 0) {
        n=new ConstantNode(stok);
      }
 else {
        n=new VariableNode(stok);
      }
      if (pretok != null) {
        pretok.linkNext(n);
      }
      pretok=n;
      ret.add(n);
    }
  }
  return ret;
}","public ArrayList<Node> tokenize(String e){
  ArrayList<Node> ret=new ArrayList<Node>();
  String ewk=disambiguate(e);
  if (verbose) {
    E.info(""String_Node_Str"" + ewk);
  }
  for (  String op : opHM.keySet()) {
    ewk=replaceAll(ewk,op,""String_Node_Str"" + op + ""String_Node_Str"");
  }
  ewk=replaceAll(ewk,""String_Node_Str"",""String_Node_Str"");
  ewk=replaceAll(ewk,""String_Node_Str"",""String_Node_Str"");
  ewk=reambiguate(ewk);
  if (verbose) {
    E.info(""String_Node_Str"" + ewk);
  }
  Node pretok=null;
  String[] bits=ewk.split(""String_Node_Str"");
  for (int i=0; i < bits.length; i++) {
    String stok=bits[i];
    stok=stok.trim();
    if (stok.length() > 0) {
      Node n=null;
      if (stok.equals(""String_Node_Str"")) {
        n=new GroupNode();
      }
 else       if (stok.equals(""String_Node_Str"")) {
        n=new OpenNode();
      }
 else       if (funcHS.contains(stok)) {
        n=new FunctionNode(stok);
      }
 else       if (opHM.containsKey(stok)) {
        n=opHM.get(stok).copy();
        if (n instanceof MinusNode && pretok instanceof AbstractOperatorNode) {
          n=new UnaryMinusNode();
        }
      }
 else       if (snum.indexOf(stok.substring(0,1)) >= 0) {
        n=new ConstantNode(stok);
      }
 else {
        n=new VariableNode(stok);
      }
      if (pretok != null) {
        pretok.linkNext(n);
      }
      pretok=n;
      ret.add(n);
    }
  }
  return ret;
}"
87462,"@Test public void testEvaluatingBoolean() throws ParseError, ContentError {
  Parser p=new Parser();
  String src=""String_Node_Str"";
  ParseTree pt=p.parseCondition(src);
  HashMap<String,Double> valHM=new HashMap<String,Double>();
  valHM.put(""String_Node_Str"",4.);
  valHM.put(""String_Node_Str"",5.);
  boolean res=pt.makeBooleanEvaluator().evalB(valHM);
  assertFalse(src,res);
  valHM.put(""String_Node_Str"",1.);
  valHM.put(""String_Node_Str"",50.);
  res=pt.makeBooleanEvaluator().evalB(valHM);
  assertTrue(src,res);
  pt=p.parseCondition(""String_Node_Str"");
  assertFalse(src,pt.makeBooleanEvaluator().evalB(valHM));
  pt=p.parseCondition(""String_Node_Str"");
  assertTrue(src,pt.makeBooleanEvaluator().evalB(valHM));
  pt=p.parseCondition(""String_Node_Str"");
  assertTrue(src,pt.makeBooleanEvaluator().evalB(valHM));
  pt=p.parseCondition(""String_Node_Str"");
  assertFalse(src,pt.makeBooleanEvaluator().evalB(valHM));
  pt=p.parseCondition(""String_Node_Str"" + AndNode.SYMBOL + ""String_Node_Str"");
  assertTrue(src,pt.makeBooleanEvaluator().evalB(valHM));
  pt=p.parseCondition(""String_Node_Str"" + AndNode.SYMBOL + ""String_Node_Str"");
  assertFalse(src,pt.makeBooleanEvaluator().evalB(valHM));
  ParseTree ptOr=p.parseCondition(""String_Node_Str"" + OrNode.SYMBOL + ""String_Node_Str"");
  assertTrue(src,ptOr.makeBooleanEvaluator().evalB(valHM));
  ptOr=p.parseCondition(""String_Node_Str"" + OrNode.SYMBOL + ""String_Node_Str"");
  assertTrue(src,ptOr.makeBooleanEvaluator().evalB(valHM));
  ptOr=p.parseCondition(""String_Node_Str"" + OrNode.SYMBOL + ""String_Node_Str"");
  assertFalse(src,ptOr.makeBooleanEvaluator().evalB(valHM));
  src=""String_Node_Str"";
  pt=p.parseCondition(src);
  valHM=new HashMap<String,Double>();
  valHM.put(""String_Node_Str"",-0.2);
  res=pt.makeBooleanEvaluator().evalB(valHM);
  assertFalse(src,res);
}","@Test public void testEvaluatingBoolean() throws ParseError, ContentError {
  Parser p=new Parser();
  String src=""String_Node_Str"";
  ParseTree pt=p.parseCondition(src);
  HashMap<String,Double> valHM=new HashMap<String,Double>();
  valHM.put(""String_Node_Str"",4.);
  valHM.put(""String_Node_Str"",5.);
  boolean res=pt.makeBooleanEvaluator().evalB(valHM);
  assertFalse(src,res);
  valHM.put(""String_Node_Str"",1.);
  valHM.put(""String_Node_Str"",50.);
  res=pt.makeBooleanEvaluator().evalB(valHM);
  assertTrue(src,res);
  pt=p.parseCondition(""String_Node_Str"");
  assertFalse(src,pt.makeBooleanEvaluator().evalB(valHM));
  pt=p.parseCondition(""String_Node_Str"");
  assertTrue(src,pt.makeBooleanEvaluator().evalB(valHM));
  pt=p.parseCondition(""String_Node_Str"");
  assertTrue(src,pt.makeBooleanEvaluator().evalB(valHM));
  pt=p.parseCondition(""String_Node_Str"");
  assertFalse(src,pt.makeBooleanEvaluator().evalB(valHM));
  pt=p.parseCondition(""String_Node_Str"" + AndNode.SYMBOL + ""String_Node_Str"");
  assertTrue(src,pt.makeBooleanEvaluator().evalB(valHM));
  pt=p.parseCondition(""String_Node_Str"" + AndNode.SYMBOL + ""String_Node_Str"");
  assertFalse(src,pt.makeBooleanEvaluator().evalB(valHM));
  ParseTree ptOr=p.parseCondition(""String_Node_Str"" + OrNode.SYMBOL + ""String_Node_Str"");
  assertTrue(src,ptOr.makeBooleanEvaluator().evalB(valHM));
  ptOr=p.parseCondition(""String_Node_Str"" + OrNode.SYMBOL + ""String_Node_Str"");
  assertTrue(src,ptOr.makeBooleanEvaluator().evalB(valHM));
  ptOr=p.parseCondition(""String_Node_Str"" + OrNode.SYMBOL + ""String_Node_Str"");
  assertFalse(src,ptOr.makeBooleanEvaluator().evalB(valHM));
  src=""String_Node_Str"";
  pt=p.parseCondition(src);
  valHM=new HashMap<String,Double>();
  valHM.put(""String_Node_Str"",-0.2);
  res=pt.makeBooleanEvaluator().evalB(valHM);
  assertFalse(src,res);
  src=""String_Node_Str"";
  pt=p.parseCondition(src);
  valHM=new HashMap<String,Double>();
  valHM.put(""String_Node_Str"",-0.2);
  res=pt.makeBooleanEvaluator().evalB(valHM);
  assertFalse(src,res);
}"
87463,"public void renderDepartures(TextView tv,Activity activity,Long currentTime){
  if (_cachednextDepartures == nextDepartures.size()) {
    if (expectedDeparture - System.currentTimeMillis() > (HelperFunctions.MINUTE * 9)) {
      tv.setText(_cachedSpanned);
      return;
    }
    if (_lastCacheUpdated != 0 && (System.currentTimeMillis() - _lastCacheUpdated) < (CACHE_INVALIDATETIME)) {
      tv.setText(_cachedSpanned);
      return;
    }
  }
  StringBuffer content=new StringBuffer(""String_Node_Str"");
  renderToContainer(content,activity,currentTime);
  for (  RealtimeDataGeneric nextDeparture : nextDepartures) {
    nextDeparture.renderToContainer(content,activity,currentTime);
  }
  _cachedSpanned=Html.fromHtml(content.toString(),new ImageGetter(activity),null);
  _cachednextDepartures=nextDepartures.size();
  tv.setText(_cachedSpanned);
  _lastCacheUpdated=System.currentTimeMillis();
}","public void renderDepartures(TextView tv,Activity activity,Long currentTime){
  if (_lastCacheUpdated != 0 && _cachednextDepartures == nextDepartures.size()) {
    if (expectedDeparture - System.currentTimeMillis() > (HelperFunctions.MINUTE * 9)) {
      tv.setText(_cachedSpanned);
      return;
    }
    if ((System.currentTimeMillis() - _lastCacheUpdated) < (CACHE_INVALIDATETIME)) {
      tv.setText(_cachedSpanned);
      return;
    }
  }
  StringBuffer content=new StringBuffer(""String_Node_Str"");
  renderToContainer(content,activity,currentTime);
  for (  RealtimeDataGeneric nextDeparture : nextDepartures) {
    nextDeparture.renderToContainer(content,activity,currentTime);
  }
  _cachedSpanned=Html.fromHtml(content.toString(),new ImageGetter(activity),null);
  _cachednextDepartures=nextDepartures.size();
  tv.setText(_cachedSpanned);
  _lastCacheUpdated=System.currentTimeMillis();
}"
87464,"public static void renderTime(final StringBuffer txt,Long currentTime,Context context,long time){
  int diffMinutes=Math.round(((float)(time - currentTime)) / MINUTE);
  if (diffMinutes < -1) {
    diffMinutes=diffMinutes * -1;
    txt.append(""String_Node_Str"");
    txt.append(diffMinutes);
    txt.append(""String_Node_Str"");
  }
 else   if (diffMinutes < 1) {
    if (nowText == null) {
      nowText=context.getText(R.string.now);
    }
    txt.append(nowText);
  }
 else   if (diffMinutes <= 9) {
    txt.append(diffMinutes);
    txt.append(""String_Node_Str"");
  }
  txt.append(hourFormater.format(time));
}","public static void renderTime(final StringBuffer txt,Long currentTime,Context context,long time){
  int diffMinutes=Math.round(((float)(time - currentTime)) / MINUTE);
  if (diffMinutes < -1) {
    diffMinutes=diffMinutes * -1;
    txt.append(""String_Node_Str"");
    txt.append(diffMinutes);
    txt.append(""String_Node_Str"");
    return;
  }
 else   if (diffMinutes < 1) {
    if (nowText == null) {
      nowText=context.getText(R.string.now);
    }
    txt.append(nowText);
    return;
  }
 else   if (diffMinutes <= 9) {
    txt.append(diffMinutes);
    txt.append(""String_Node_Str"");
    return;
  }
  txt.append(hourFormater.format(time));
}"
87465,"@Override protected Dialog onCreateDialog(int id){
switch (id) {
case DIALOG_SELECTTIME:
    Calendar oldTime=null;
  boolean travelAt=true;
if (routeSearch.arrival > 0) {
  travelAt=false;
  oldTime=Calendar.getInstance();
  oldTime.setTimeInMillis(routeSearch.arrival);
}
 else if (routeSearch.departure > 0) {
  oldTime=Calendar.getInstance();
  oldTime.setTimeInMillis(routeSearch.departure);
}
final Dialog dialog=new Dialog(this);
dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
dialog.setContentView(R.layout.selectroute_dialog_timepick);
final ArrayList<CharSequence> travelAtArriveBeforeItems=new ArrayList<CharSequence>();
travelAtArriveBeforeItems.add(getText(R.string.travelAt));
travelAtArriveBeforeItems.add(getText(R.string.arriveBefore));
final Spinner travelAtArriveBeforeSpinner=(Spinner)dialog.findViewById(R.id.travelAtArriveBefore);
final ArrayAdapter<CharSequence> travelAtArriveBeforeAdapter=new ArrayAdapter<CharSequence>(this,android.R.layout.simple_spinner_item,travelAtArriveBeforeItems);
travelAtArriveBeforeAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
travelAtArriveBeforeSpinner.setAdapter(travelAtArriveBeforeAdapter);
if (!travelAt) {
travelAtArriveBeforeSpinner.setSelection(1);
}
final TimePicker timePicker=(TimePicker)dialog.findViewById(R.id.timePicker);
View amPmView=((ViewGroup)timePicker.getChildAt(0)).getChildAt(2);
if (amPmView instanceof Button) {
amPmView.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.d(""String_Node_Str"",""String_Node_Str"");
if (v instanceof Button) {
if (((Button)v).getText().equals(""String_Node_Str"")) {
((Button)v).setText(""String_Node_Str"");
if (timePicker.getCurrentHour() < 12) {
timePicker.setCurrentHour(timePicker.getCurrentHour() + 12);
}
}
 else {
((Button)v).setText(""String_Node_Str"");
if (timePicker.getCurrentHour() >= 12) {
timePicker.setCurrentHour(timePicker.getCurrentHour() - 12);
}
}
}
}
}
);
}
if (oldTime != null) {
timePicker.setCurrentHour(oldTime.get(Calendar.HOUR_OF_DAY));
timePicker.setCurrentMinute(oldTime.get(Calendar.MINUTE));
}
final Spinner dayList=(Spinner)dialog.findViewById(R.id.dayList);
final SimpleDateFormat DATEFORMAT=new SimpleDateFormat(""String_Node_Str"");
ArrayList<String> dateList=new ArrayList<String>();
Calendar date=Calendar.getInstance();
int positionOfOldTime=0;
for (int i=0; i < 14; i++) {
if (oldTime != null && date.get(Calendar.DAY_OF_YEAR) == oldTime.get(Calendar.DAY_OF_YEAR)) {
positionOfOldTime=i;
}
dateList.add(DATEFORMAT.format(date.getTime()));
date.add(Calendar.DAY_OF_YEAR,1);
}
final ArrayAdapter<String> dayAdapter=new ArrayAdapter<String>(this,android.R.layout.simple_spinner_item,dateList);
dayAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
dayList.setAdapter(dayAdapter);
dayList.setSelection(positionOfOldTime);
final Button okButton=(Button)dialog.findViewById(R.id.okButton);
okButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
try {
boolean travelAt=travelAtArriveBeforeSpinner.getSelectedItemPosition() == 0;
Date date=DATEFORMAT.parse(dayAdapter.getItem(dayList.getSelectedItemPosition()));
date.setHours(timePicker.getCurrentHour());
date.setMinutes(timePicker.getCurrentMinute());
if (travelAt) {
routeSearch.departure=date.getTime();
routeSearch.arrival=0;
}
 else {
routeSearch.departure=0;
routeSearch.arrival=date.getTime();
}
refreshMenu();
dialog.dismiss();
}
 catch (ParseException e) {
}
}
}
);
final Button resetButton=(Button)dialog.findViewById(R.id.resetButton);
resetButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View arg0){
routeSearch.departure=0;
routeSearch.arrival=0;
refreshMenu();
dialog.dismiss();
}
}
);
return dialog;
case DIALOG_TRANSPORTTYPES:
final CharSequence[] transportItems=routeSearch.getTransportArray(this);
final boolean[] checkedTransportItems={true,true,true,true,true,true,true};
AlertDialog.Builder transportBuilder=new AlertDialog.Builder(this);
transportBuilder.setTitle(R.string.transportTypes);
transportBuilder.setMultiChoiceItems(transportItems,checkedTransportItems,new DialogInterface.OnMultiChoiceClickListener(){
@Override public void onClick(DialogInterface dialog,int which,boolean isChecked){
routeSearch.transportTypes[which]=isChecked;
refreshMenu();
}
}
);
final AlertDialog transportDialog=transportBuilder.create();
transportDialog.setOnDismissListener(new OnDismissListener(){
@Override public void onDismiss(DialogInterface dialog){
int enabled=0;
for (int i=0; i < 7; i++) {
if (routeSearch.transportTypes[i]) {
enabled++;
}
}
if (enabled == 0) {
for (int i=0; i < 7; i++) {
routeSearch.transportTypes[i]=true;
}
}
}
}
);
return transportDialog;
case DIALOG_CHANGEMARGIN:
final CharSequence[] changeMarginItems={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
AlertDialog.Builder changeBuilder=new AlertDialog.Builder(this);
changeBuilder.setTitle(R.string.setChangeMargin);
changeBuilder.setItems(changeMarginItems,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int item){
routeSearch.changeMargin=item + 1;
refreshMenu();
}
}
);
return changeBuilder.create();
case DIALOG_CHANGEPRIORITY:
final CharSequence[] priorityItems={getText(R.string.shortTravel),getText(R.string.directRoute)};
AlertDialog.Builder priorityBuilder=new AlertDialog.Builder(this);
priorityBuilder.setTitle(R.string.prioritize);
priorityBuilder.setItems(priorityItems,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int item){
if (item == 0) {
routeSearch.changePunish=2;
}
 else {
routeSearch.changePunish=10;
}
refreshMenu();
}
}
);
return priorityBuilder.create();
case DIALOG_PROPOSALS:
final CharSequence[] proposalItems={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
AlertDialog.Builder changeProposals=new AlertDialog.Builder(this);
changeProposals.setTitle(R.string.setProposals);
changeProposals.setItems(proposalItems,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int item){
switch (item) {
case 6:
routeSearch.proposals=15;
break;
case 5:
routeSearch.proposals=10;
break;
default :
routeSearch.proposals=item + 1;
}
refreshMenu();
}
}
);
return changeProposals.create();
}
return super.onCreateDialog(id);
}","@Override protected Dialog onCreateDialog(int id){
switch (id) {
case DIALOG_SELECTTIME:
    Calendar oldTime=null;
  boolean travelAt=true;
if (routeSearch.arrival > 0) {
  travelAt=false;
  oldTime=Calendar.getInstance();
  oldTime.setTimeInMillis(routeSearch.arrival);
}
 else if (routeSearch.departure > 0) {
  oldTime=Calendar.getInstance();
  oldTime.setTimeInMillis(routeSearch.departure);
}
final Dialog dialog=new Dialog(this);
dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
dialog.setContentView(R.layout.selectroute_dialog_timepick);
final ArrayList<CharSequence> travelAtArriveBeforeItems=new ArrayList<CharSequence>();
travelAtArriveBeforeItems.add(getText(R.string.travelAt));
travelAtArriveBeforeItems.add(getText(R.string.arriveBefore));
final Spinner travelAtArriveBeforeSpinner=(Spinner)dialog.findViewById(R.id.travelAtArriveBefore);
final ArrayAdapter<CharSequence> travelAtArriveBeforeAdapter=new ArrayAdapter<CharSequence>(this,android.R.layout.simple_spinner_item,travelAtArriveBeforeItems);
travelAtArriveBeforeAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
travelAtArriveBeforeSpinner.setAdapter(travelAtArriveBeforeAdapter);
if (!travelAt) {
travelAtArriveBeforeSpinner.setSelection(1);
}
final TimePicker timePicker=(TimePicker)dialog.findViewById(R.id.timePicker);
if (Build.VERSION.SDK_INT >= 11) {
View amPmView=((ViewGroup)timePicker.getChildAt(0)).getChildAt(2);
if (amPmView instanceof Button) {
amPmView.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
Log.d(""String_Node_Str"",""String_Node_Str"");
if (v instanceof Button) {
if (((Button)v).getText().equals(""String_Node_Str"")) {
((Button)v).setText(""String_Node_Str"");
if (timePicker.getCurrentHour() < 12) {
timePicker.setCurrentHour(timePicker.getCurrentHour() + 12);
}
}
 else {
((Button)v).setText(""String_Node_Str"");
if (timePicker.getCurrentHour() >= 12) {
timePicker.setCurrentHour(timePicker.getCurrentHour() - 12);
}
}
}
}
}
);
}
}
 else {
timePicker.setIs24HourView(true);
}
if (oldTime != null) {
timePicker.setCurrentHour(oldTime.get(Calendar.HOUR_OF_DAY));
timePicker.setCurrentMinute(oldTime.get(Calendar.MINUTE));
}
final Spinner dayList=(Spinner)dialog.findViewById(R.id.dayList);
final SimpleDateFormat DATEFORMAT=new SimpleDateFormat(""String_Node_Str"");
ArrayList<String> dateList=new ArrayList<String>();
Calendar date=Calendar.getInstance();
int positionOfOldTime=0;
for (int i=0; i < 14; i++) {
if (oldTime != null && date.get(Calendar.DAY_OF_YEAR) == oldTime.get(Calendar.DAY_OF_YEAR)) {
positionOfOldTime=i;
}
dateList.add(DATEFORMAT.format(date.getTime()));
date.add(Calendar.DAY_OF_YEAR,1);
}
final ArrayAdapter<String> dayAdapter=new ArrayAdapter<String>(this,android.R.layout.simple_spinner_item,dateList);
dayAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
dayList.setAdapter(dayAdapter);
dayList.setSelection(positionOfOldTime);
final Button okButton=(Button)dialog.findViewById(R.id.okButton);
okButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
try {
boolean travelAt=travelAtArriveBeforeSpinner.getSelectedItemPosition() == 0;
Date date=DATEFORMAT.parse(dayAdapter.getItem(dayList.getSelectedItemPosition()));
date.setHours(timePicker.getCurrentHour());
date.setMinutes(timePicker.getCurrentMinute());
if (travelAt) {
routeSearch.departure=date.getTime();
routeSearch.arrival=0;
}
 else {
routeSearch.departure=0;
routeSearch.arrival=date.getTime();
}
refreshMenu();
dialog.dismiss();
}
 catch (ParseException e) {
}
}
}
);
final Button resetButton=(Button)dialog.findViewById(R.id.resetButton);
resetButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View arg0){
routeSearch.departure=0;
routeSearch.arrival=0;
refreshMenu();
dialog.dismiss();
}
}
);
return dialog;
case DIALOG_TRANSPORTTYPES:
final CharSequence[] transportItems=routeSearch.getTransportArray(this);
final boolean[] checkedTransportItems={true,true,true,true,true,true,true};
AlertDialog.Builder transportBuilder=new AlertDialog.Builder(this);
transportBuilder.setTitle(R.string.transportTypes);
transportBuilder.setMultiChoiceItems(transportItems,checkedTransportItems,new DialogInterface.OnMultiChoiceClickListener(){
@Override public void onClick(DialogInterface dialog,int which,boolean isChecked){
routeSearch.transportTypes[which]=isChecked;
refreshMenu();
}
}
);
final AlertDialog transportDialog=transportBuilder.create();
transportDialog.setOnDismissListener(new OnDismissListener(){
@Override public void onDismiss(DialogInterface dialog){
int enabled=0;
for (int i=0; i < 7; i++) {
if (routeSearch.transportTypes[i]) {
enabled++;
}
}
if (enabled == 0) {
for (int i=0; i < 7; i++) {
routeSearch.transportTypes[i]=true;
}
}
}
}
);
return transportDialog;
case DIALOG_CHANGEMARGIN:
final CharSequence[] changeMarginItems={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
AlertDialog.Builder changeBuilder=new AlertDialog.Builder(this);
changeBuilder.setTitle(R.string.setChangeMargin);
changeBuilder.setItems(changeMarginItems,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int item){
routeSearch.changeMargin=item + 1;
refreshMenu();
}
}
);
return changeBuilder.create();
case DIALOG_CHANGEPRIORITY:
final CharSequence[] priorityItems={getText(R.string.shortTravel),getText(R.string.directRoute)};
AlertDialog.Builder priorityBuilder=new AlertDialog.Builder(this);
priorityBuilder.setTitle(R.string.prioritize);
priorityBuilder.setItems(priorityItems,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int item){
if (item == 0) {
routeSearch.changePunish=2;
}
 else {
routeSearch.changePunish=10;
}
refreshMenu();
}
}
);
return priorityBuilder.create();
case DIALOG_PROPOSALS:
final CharSequence[] proposalItems={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
AlertDialog.Builder changeProposals=new AlertDialog.Builder(this);
changeProposals.setTitle(R.string.setProposals);
changeProposals.setItems(proposalItems,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int item){
switch (item) {
case 6:
routeSearch.proposals=15;
break;
case 5:
routeSearch.proposals=10;
break;
default :
routeSearch.proposals=item + 1;
}
refreshMenu();
}
}
);
return changeProposals.create();
}
return super.onCreateDialog(id);
}"
87466,"@Override public void run(){
  try {
    String urlString;
    if (query != null) {
      if (isRealtimeStopFiltered) {
        urlString=""String_Node_Str"" + URLEncoder.encode(query,""String_Node_Str"");
      }
 else {
        urlString=""String_Node_Str"" + URLEncoder.encode(query,""String_Node_Str"");
      }
    }
 else {
      final LatLng latLong=new LatLng(latitude,longitude);
      final UTMRef utmRef=latLong.toUTMRef();
      urlString=""String_Node_Str"" + (int)utmRef.getEasting() + ""String_Node_Str""+ (int)utmRef.getNorthing()+ ""String_Node_Str"";
    }
    Log.i(TAG,""String_Node_Str"" + urlString);
    final InputStream stream=HelperFunctions.executeHttpRequest(context,new HttpGet(urlString));
    final JSONArray jsonArray=new JSONArray(HelperFunctions.InputStreamToString(stream));
    final int arraySize=jsonArray.length();
    for (int i=0; i < arraySize; i++) {
      final JSONObject json=jsonArray.getJSONObject(i);
      if (json.getInt(""String_Node_Str"") == 0) {
        StationData station=new StationData();
        if (query != null) {
          station.realtimeStop=isRealtimeStopFiltered;
        }
 else {
          station.realtimeStop=json.getBoolean(""String_Node_Str"");
          if (isRealtimeStopFiltered && !station.realtimeStop) {
            continue;
          }
        }
        station.stationId=json.getInt(""String_Node_Str"");
        station.stopName=json.getString(""String_Node_Str"");
        searchForAddress(station);
        final String district=json.getString(""String_Node_Str"");
        if (district.length() > 0) {
          if (station.extra == null) {
            station.extra=district;
          }
 else {
            station.extra=station.extra + ""String_Node_Str"" + district;
          }
        }
        if (json.has(""String_Node_Str"")) {
          station.walkingDistance=json.getInt(""String_Node_Str"");
        }
        station.utmCoords[0]=json.getInt(""String_Node_Str"");
        station.utmCoords[1]=json.getInt(""String_Node_Str"");
        ThreadHandlePostData(station);
      }
    }
  }
 catch (  Exception e) {
    if (e.getClass() == InterruptedException.class) {
      ThreadHandlePostExecute(null);
      return;
    }
    ThreadHandlePostExecute(e);
    return;
  }
  ThreadHandlePostExecute(null);
}","@Override public void run(){
  try {
    String urlString;
    if (query != null) {
      query=query.trim();
      if (isRealtimeStopFiltered) {
        urlString=""String_Node_Str"" + URLEncoder.encode(query,""String_Node_Str"");
      }
 else {
        urlString=""String_Node_Str"" + URLEncoder.encode(query,""String_Node_Str"");
      }
    }
 else {
      final LatLng latLong=new LatLng(latitude,longitude);
      final UTMRef utmRef=latLong.toUTMRef();
      urlString=""String_Node_Str"" + (int)utmRef.getEasting() + ""String_Node_Str""+ (int)utmRef.getNorthing()+ ""String_Node_Str"";
    }
    Log.i(TAG,""String_Node_Str"" + urlString);
    final InputStream stream=HelperFunctions.executeHttpRequest(context,new HttpGet(urlString));
    final JSONArray jsonArray=new JSONArray(HelperFunctions.InputStreamToString(stream));
    final int arraySize=jsonArray.length();
    for (int i=0; i < arraySize; i++) {
      final JSONObject json=jsonArray.getJSONObject(i);
      if (json.getInt(""String_Node_Str"") == 0) {
        StationData station=new StationData();
        if (query != null) {
          station.realtimeStop=isRealtimeStopFiltered;
        }
 else {
          station.realtimeStop=json.getBoolean(""String_Node_Str"");
          if (isRealtimeStopFiltered && !station.realtimeStop) {
            continue;
          }
        }
        station.stationId=json.getInt(""String_Node_Str"");
        station.stopName=json.getString(""String_Node_Str"");
        searchForAddress(station);
        final String district=json.getString(""String_Node_Str"");
        if (district.length() > 0) {
          if (station.extra == null) {
            station.extra=district;
          }
 else {
            station.extra=station.extra + ""String_Node_Str"" + district;
          }
        }
        if (json.has(""String_Node_Str"")) {
          station.walkingDistance=json.getInt(""String_Node_Str"");
        }
        station.utmCoords[0]=json.getInt(""String_Node_Str"");
        station.utmCoords[1]=json.getInt(""String_Node_Str"");
        ThreadHandlePostData(station);
      }
    }
  }
 catch (  Exception e) {
    if (e.getClass() == InterruptedException.class) {
      ThreadHandlePostExecute(null);
      return;
    }
    ThreadHandlePostExecute(e);
    return;
  }
  ThreadHandlePostExecute(null);
}"
87467,"private void loadDevi(){
  ArrayList<String> lineList=new ArrayList<String>();
{
    final int count=realtimeList.getCount();
    for (int i=0; i < count; i++) {
      final RealtimeData realtimeData=realtimeList.getItem(i);
      if (!lineList.contains(realtimeData.line)) {
        lineList.add(realtimeData.line);
      }
    }
  }
  StringBuffer deviLines=new StringBuffer();
{
    final int count=lineList.size();
    for (int i=0; i < count; i++) {
      if (i > 0) {
        deviLines.append(""String_Node_Str"");
      }
      deviLines.append(lineList.get(i));
    }
  }
  tracker.trackEvent(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0);
  deviProvider=new TrafikantenDevi(this,station.stationId,deviLines.toString(),new IGenericProviderHandler<DeviData>(){
    @Override public void onExtra(    int what,    Object obj){
    }
    @Override public void onData(    DeviData deviData){
      for (      final String deviName : deviData.stops) {
        if (deviName.equals(station.stopName)) {
          deviItems.add(deviData);
          break;
        }
      }
      realtimeList.addDeviItem(deviData);
      realtimeList.itemsAddedWithoutNotify++;
      if (realtimeList.itemsAddedWithoutNotify > 5) {
        realtimeList.itemsAddedWithoutNotify=0;
        realtimeList.notifyDataSetChanged();
      }
    }
    @Override public void onPostExecute(    Exception exception){
      setProgressBarIndeterminateVisibility(false);
      finishedLoading=true;
      deviProvider=null;
      if (exception != null) {
        Log.w(TAG,""String_Node_Str"" + exception);
        if (exception.getClass().getSimpleName().equals(""String_Node_Str"")) {
          Toast.makeText(RealtimeView.this,R.string.trafikantenErrorParse,Toast.LENGTH_LONG).show();
        }
 else {
          Toast.makeText(RealtimeView.this,R.string.trafikantenErrorOther,Toast.LENGTH_LONG).show();
        }
      }
 else {
        refreshDevi();
        if (realtimeList.itemsAddedWithoutNotify > 0) {
          realtimeList.itemsAddedWithoutNotify=0;
          realtimeList.notifyDataSetChanged();
        }
      }
    }
    @Override public void onPreExecute(){
      try {
        tracker.dispatch();
      }
 catch (      Exception e) {
      }
      setProgressBarIndeterminateVisibility(true);
    }
  }
);
}","private void loadDevi(){
  ArrayList<String> lineList=new ArrayList<String>();
{
    final int count=realtimeList.getCount();
    for (int i=0; i < count; i++) {
      final RealtimeData realtimeData=realtimeList.getItem(i);
      if (!lineList.contains(realtimeData.line)) {
        lineList.add(realtimeData.line);
      }
    }
  }
  StringBuffer deviLines=new StringBuffer();
{
    final int count=lineList.size();
    for (int i=0; i < count; i++) {
      if (i > 0) {
        deviLines.append(""String_Node_Str"");
      }
      deviLines.append(lineList.get(i));
    }
  }
  tracker.trackEvent(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0);
  try {
    tracker.dispatch();
  }
 catch (  Exception e) {
  }
  deviProvider=new TrafikantenDevi(this,station.stationId,deviLines.toString(),new IGenericProviderHandler<DeviData>(){
    @Override public void onExtra(    int what,    Object obj){
    }
    @Override public void onData(    DeviData deviData){
      for (      final String deviName : deviData.stops) {
        if (deviName.equals(station.stopName)) {
          deviItems.add(deviData);
          break;
        }
      }
      realtimeList.addDeviItem(deviData);
      realtimeList.itemsAddedWithoutNotify++;
      if (realtimeList.itemsAddedWithoutNotify > 5) {
        realtimeList.itemsAddedWithoutNotify=0;
        realtimeList.notifyDataSetChanged();
      }
    }
    @Override public void onPostExecute(    Exception exception){
      setProgressBarIndeterminateVisibility(false);
      finishedLoading=true;
      deviProvider=null;
      if (exception != null) {
        Log.w(TAG,""String_Node_Str"" + exception);
        if (exception.getClass().getSimpleName().equals(""String_Node_Str"")) {
          Toast.makeText(RealtimeView.this,R.string.trafikantenErrorParse,Toast.LENGTH_LONG).show();
        }
 else {
          Toast.makeText(RealtimeView.this,R.string.trafikantenErrorOther,Toast.LENGTH_LONG).show();
        }
      }
 else {
        refreshDevi();
        if (realtimeList.itemsAddedWithoutNotify > 0) {
          realtimeList.itemsAddedWithoutNotify=0;
          realtimeList.notifyDataSetChanged();
        }
      }
    }
    @Override public void onPreExecute(){
      setProgressBarIndeterminateVisibility(true);
    }
  }
);
}"
87468,"@Override public void onPreExecute(){
  try {
    tracker.dispatch();
  }
 catch (  Exception e) {
  }
  setProgressBarIndeterminateVisibility(true);
}","@Override public void onPreExecute(){
  setProgressBarIndeterminateVisibility(true);
}"
87469,"private void load(){
  if (routeProvider != null)   routeProvider.kill();
  routeList.getList().clear();
  routeList.notifyDataSetChanged();
  tracker.trackEvent(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0);
  routeProvider=new TrafikantenRoute(this,routeSearch,new IGenericProviderHandler<RouteProposal>(){
    @Override public void onExtra(    int what,    Object obj){
    }
    @Override public void onData(    RouteProposal data){
      routeList.addItem(data);
      routeList.notifyDataSetChanged();
      infoText.setVisibility(routeList.getCount() > 0 ? View.GONE : View.VISIBLE);
    }
    @Override public void onPostExecute(    Exception exception){
      setProgressBarIndeterminateVisibility(false);
      routeProvider=null;
      if (exception != null) {
        routeList.getList().clear();
        routeList.notifyDataSetChanged();
        Log.w(TAG,""String_Node_Str"" + exception);
        infoText.setVisibility(View.VISIBLE);
        if (exception.getClass().getSimpleName().equals(""String_Node_Str"")) {
          infoText.setText(R.string.trafikantenErrorParse);
        }
 else {
          infoText.setText(R.string.trafikantenErrorOther);
        }
        setProgressBarIndeterminateVisibility(false);
      }
 else {
        infoText.setText(R.string.noRoutesFound);
      }
      loadDevi();
    }
    @Override public void onPreExecute(){
      try {
        tracker.dispatch();
      }
 catch (      Exception e) {
      }
      setProgressBarIndeterminateVisibility(true);
    }
  }
);
}","private void load(){
  if (routeProvider != null)   routeProvider.kill();
  routeList.getList().clear();
  routeList.notifyDataSetChanged();
  tracker.trackEvent(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0);
  try {
    tracker.dispatch();
  }
 catch (  Exception e) {
  }
  routeProvider=new TrafikantenRoute(this,routeSearch,new IGenericProviderHandler<RouteProposal>(){
    @Override public void onExtra(    int what,    Object obj){
    }
    @Override public void onData(    RouteProposal data){
      routeList.addItem(data);
      routeList.notifyDataSetChanged();
      infoText.setVisibility(routeList.getCount() > 0 ? View.GONE : View.VISIBLE);
    }
    @Override public void onPostExecute(    Exception exception){
      setProgressBarIndeterminateVisibility(false);
      routeProvider=null;
      if (exception != null) {
        routeList.getList().clear();
        routeList.notifyDataSetChanged();
        Log.w(TAG,""String_Node_Str"" + exception);
        infoText.setVisibility(View.VISIBLE);
        if (exception.getClass().getSimpleName().equals(""String_Node_Str"")) {
          infoText.setText(R.string.trafikantenErrorParse);
        }
 else {
          infoText.setText(R.string.trafikantenErrorOther);
        }
        setProgressBarIndeterminateVisibility(false);
      }
 else {
        infoText.setText(R.string.noRoutesFound);
      }
      loadDevi();
    }
    @Override public void onPreExecute(){
      setProgressBarIndeterminateVisibility(true);
    }
  }
);
}"
87470,"private void loadDevi(){
  routeDeviLoader=new RouteDeviLoader(this,deviList,new IGenericProviderHandler<Void>(){
    @Override public void onData(    Void data){
    }
    @Override public void onExtra(    int i,    Object data){
    }
    @Override public void onPostExecute(    Exception e){
      Toast.makeText(DetailedRouteView.this,R.string.trafikantenErrorOther,Toast.LENGTH_SHORT).show();
      routeDeviLoader=null;
      routeList.notifyDataSetChanged();
      loadDevi();
    }
    @Override public void onPreExecute(){
    }
  }
);
  if (routeDeviLoader.load(routeProposalList.get(proposalPosition))) {
    setProgressBarIndeterminateVisibility(true);
  }
 else {
    setProgressBarIndeterminateVisibility(false);
  }
}","private void loadDevi(){
  routeDeviLoader=new RouteDeviLoader(this,deviList,new IGenericProviderHandler<Void>(){
    @Override public void onData(    Void data){
    }
    @Override public void onExtra(    int i,    Object data){
    }
    @Override public void onPostExecute(    Exception e){
      Log.e(TAG,""String_Node_Str"" + e);
      Toast.makeText(DetailedRouteView.this,R.string.trafikantenErrorOther,Toast.LENGTH_SHORT).show();
      routeDeviLoader=null;
      routeList.notifyDataSetChanged();
      loadDevi();
    }
    @Override public void onPreExecute(){
    }
  }
);
  if (routeDeviLoader.load(routeProposalList.get(proposalPosition))) {
    setProgressBarIndeterminateVisibility(true);
  }
 else {
    setProgressBarIndeterminateVisibility(false);
  }
}"
87471,"public void load(StationData station,final RouteData routeData){
  kill();
  searchLine=routeData.line;
  int bracket=routeData.destination.indexOf('[');
  if (bracket > 0) {
    destination=routeData.destination.subSequence(0,bracket - 1).toString();
  }
 else {
    destination=routeData.line;
  }
  tracker.trackEvent(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0);
  realtimeProvider=new TrafikantenRealtime(activity,station.stationId,new IGenericProviderHandler<RealtimeData>(){
    @Override public void onExtra(    int what,    Object obj){
switch (what) {
case TrafikantenRealtime.MSG_TIMEDATA:
        routeData.timeDifference=(Long)obj;
      break;
  }
}
@Override public void onData(RealtimeData item){
  if (item.line.equals(searchLine) && item.destination.equals(destination)) {
    if (routeData.realtimeData == null) {
      routeData.realtimeData=item;
      routeList.notifyDataSetChanged();
    }
 else {
      routeData.realtimeData.addDeparture(item.expectedDeparture,item.realtime,item.stopVisitNote);
      routeList.notifyDataSetChanged();
    }
  }
}
@Override public void onPostExecute(Exception exception){
  activity.setProgressBarIndeterminateVisibility(false);
  realtimeProvider=null;
  if (exception != null) {
    Log.w(TAG,""String_Node_Str"" + exception);
    if (exception.getClass().getSimpleName().equals(""String_Node_Str"")) {
      Toast.makeText(activity,R.string.trafikantenErrorParse,Toast.LENGTH_LONG).show();
    }
 else {
      Toast.makeText(activity,R.string.trafikantenErrorOther,Toast.LENGTH_LONG).show();
    }
  }
 else {
    if (routeData.realtimeData == null) {
      Toast.makeText(activity,R.string.realtimeEmpty,Toast.LENGTH_LONG).show();
    }
  }
  routeList.notifyDataSetChanged();
}
@Override public void onPreExecute(){
  activity.setProgressBarIndeterminateVisibility(true);
}
}
);
}","public void load(StationData station,final RouteData routeData){
  kill();
  searchLine=routeData.line;
  int bracket=routeData.destination.indexOf('[');
  if (bracket > 0) {
    searchDestination=routeData.destination.subSequence(0,bracket - 1).toString();
  }
 else {
    searchDestination=routeData.destination;
  }
  tracker.trackEvent(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0);
  realtimeProvider=new TrafikantenRealtime(activity,station.stationId,new IGenericProviderHandler<RealtimeData>(){
    @Override public void onExtra(    int what,    Object obj){
switch (what) {
case TrafikantenRealtime.MSG_TIMEDATA:
        routeData.timeDifference=(Long)obj;
      break;
  }
}
@Override public void onData(RealtimeData item){
  if (item.line.equals(searchLine) && item.destination.equals(searchDestination)) {
    if (routeData.realtimeData == null) {
      routeData.realtimeData=item;
      routeList.notifyDataSetChanged();
    }
 else {
      routeData.realtimeData.addDeparture(item.expectedDeparture,item.realtime,item.stopVisitNote);
      routeList.notifyDataSetChanged();
    }
  }
}
@Override public void onPostExecute(Exception exception){
  activity.setProgressBarIndeterminateVisibility(false);
  realtimeProvider=null;
  if (exception != null) {
    Log.w(TAG,""String_Node_Str"" + exception);
    if (exception.getClass().getSimpleName().equals(""String_Node_Str"")) {
      Toast.makeText(activity,R.string.trafikantenErrorParse,Toast.LENGTH_LONG).show();
    }
 else {
      Toast.makeText(activity,R.string.trafikantenErrorOther,Toast.LENGTH_LONG).show();
    }
  }
 else {
    if (routeData.realtimeData == null) {
      Toast.makeText(activity,R.string.realtimeEmpty,Toast.LENGTH_LONG).show();
    }
  }
  routeList.notifyDataSetChanged();
}
@Override public void onPreExecute(){
  activity.setProgressBarIndeterminateVisibility(true);
}
}
);
}"
87472,"@Override public void onData(RealtimeData item){
  if (item.line.equals(searchLine) && item.destination.equals(destination)) {
    if (routeData.realtimeData == null) {
      routeData.realtimeData=item;
      routeList.notifyDataSetChanged();
    }
 else {
      routeData.realtimeData.addDeparture(item.expectedDeparture,item.realtime,item.stopVisitNote);
      routeList.notifyDataSetChanged();
    }
  }
}","@Override public void onData(RealtimeData item){
  if (item.line.equals(searchLine) && item.destination.equals(searchDestination)) {
    if (routeData.realtimeData == null) {
      routeData.realtimeData=item;
      routeList.notifyDataSetChanged();
    }
 else {
      routeData.realtimeData.addDeparture(item.expectedDeparture,item.realtime,item.stopVisitNote);
      routeList.notifyDataSetChanged();
    }
  }
}"
87473,"private void loadRouteData(){
  if (routeList.size() == 0) {
    RouteOverlay routeOverlay=new RouteOverlay(iconMapMarker,stationOverlay.items);
    final List<Overlay> overlays=mapView.getOverlays();
    stationOverlay.doPopulate();
    overlays.add(routeOverlay);
    overlays.add(stationOverlay);
    setProgress(10000);
    mapView.invalidate();
    return;
  }
  final RouteData routeData=routeList.get(0);
  routeList.remove(0);
  setProgress((routeLength - routeList.size() + 1) * 10000 / routeLength);
  if (routeData.tourID == 0) {
    stationOverlay.add(GenericMap.this,routeData.fromStation);
    stationOverlay.add(GenericMap.this,routeData.toStation);
    loadRouteData();
    return;
  }
  tracker.trackPageView(""String_Node_Str"");
  tripProvider=new TrafikantenTrip(this,routeData.tourID,routeData.fromStation.stationId,routeData.toStation.stationId,new IGenericProviderHandler<StationData>(){
    @Override public void onData(    StationData data){
      stationOverlay.add(GenericMap.this,data);
    }
    @Override public void onExtra(    int i,    Object data){
    }
    @Override public void onPostExecute(    Exception exception){
      tripProvider=null;
      if (exception != null) {
        Log.w(TAG,""String_Node_Str"" + exception);
        Toast.makeText(GenericMap.this,getText(R.string.trafikantenErrorOther),Toast.LENGTH_SHORT).show();
        setProgress(10000);
      }
 else {
        loadRouteData();
      }
    }
    @Override public void onPreExecute(){
    }
  }
);
}","private void loadRouteData(){
  if (routeList.size() == 0) {
    RouteOverlay routeOverlay=new RouteOverlay(iconMapMarker,stationOverlay.items);
    final List<Overlay> overlays=mapView.getOverlays();
    overlays.add(routeOverlay);
    overlays.add(stationOverlay);
    setProgress(10000);
    mapView.invalidate();
    return;
  }
  final RouteData routeData=routeList.get(0);
  routeList.remove(0);
  setProgress((routeLength - routeList.size() + 1) * 10000 / routeLength);
  if (routeData.tourID == 0) {
    stationOverlay.add(GenericMap.this,routeData.fromStation,false);
    stationOverlay.add(GenericMap.this,routeData.toStation,true);
    loadRouteData();
    return;
  }
  tracker.trackPageView(""String_Node_Str"");
  tripProvider=new TrafikantenTrip(this,routeData.tourID,routeData.fromStation.stationId,routeData.toStation.stationId,new IGenericProviderHandler<StationData>(){
    @Override public void onData(    StationData data){
      stationOverlay.add(GenericMap.this,data,true);
    }
    @Override public void onExtra(    int i,    Object data){
    }
    @Override public void onPostExecute(    Exception exception){
      tripProvider=null;
      if (exception != null) {
        Log.w(TAG,""String_Node_Str"" + exception);
        Toast.makeText(GenericMap.this,getText(R.string.trafikantenErrorOther),Toast.LENGTH_SHORT).show();
        setProgress(10000);
      }
 else {
        loadRouteData();
      }
    }
    @Override public void onPreExecute(){
    }
  }
);
}"
87474,"@Override public void onData(StationData data){
  stationOverlay.add(GenericMap.this,data);
}","@Override public void onData(StationData data){
  stationOverlay.add(GenericMap.this,data,true);
}"
87475,"public void add(Activity activity,ArrayList<StationData> stationList){
  for (  StationData station : stationList) {
    add(activity,station);
  }
  populate();
}","public void add(Activity activity,ArrayList<StationData> stationList){
  for (  StationData station : stationList) {
    add(activity,station,false);
  }
  populate();
}"
87476,"@Override public View getView(int pos,View convertView,ViewGroup arg2){
  ViewHolder holder;
  if (convertView == null) {
    convertView=inflater.inflate(R.layout.route_overview_list,null);
    holder=new ViewHolder();
    holder.travelTypes=(LinearLayout)convertView.findViewById(R.id.travelTypes);
    holder.departureTime=(TextView)convertView.findViewById(R.id.departureTime);
    holder.arrivalTime=(TextView)convertView.findViewById(R.id.arrivalTime);
    holder.travelTime=(TextView)convertView.findViewById(R.id.travelTime);
    holder.deviSymbol=(TextView)convertView.findViewById(R.id.deviSymbol);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  final RouteProposal routeProposal=items.get(pos);
  long departure=0;
  long arrival=0;
  holder.travelTypes.removeAllViews();
  for (  RouteData routeData : routeProposal.travelStageList) {
    if (departure == 0) {
      departure=routeData.departure;
    }
    arrival=routeData.arrival;
{
      final int symbolImage=routeData.transportType;
      if (symbolImage > 0) {
        final LinearLayout layout=(LinearLayout)inflater.inflate(R.layout.route_overview_traveltype,null);
        final TextView line=(TextView)layout.findViewById(R.id.line);
        final ImageView icon=(ImageView)layout.findViewById(R.id.icon);
        icon.setImageResource(symbolImage);
        if (routeData.line.length() > 0) {
          line.setText(routeData.line);
          line.setVisibility(View.VISIBLE);
        }
 else {
          line.setVisibility(View.GONE);
        }
        LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
        params.leftMargin=1;
        params.rightMargin=1;
        holder.travelTypes.addView(layout,params);
      }
    }
  }
  if (getDevi(pos,true).size() > 0) {
    holder.deviSymbol.setVisibility(View.VISIBLE);
  }
 else {
    holder.deviSymbol.setVisibility(View.GONE);
  }
{
    holder.departureTime.setText(HelperFunctions.hourFormater.format(departure));
    holder.arrivalTime.setText(HelperFunctions.hourFormater.format(arrival));
    holder.travelTime.setText(parent.getText(R.string.travelTime) + ""String_Node_Str"" + HelperFunctions.renderAccurate(arrival - departure));
  }
  return convertView;
}","@Override public View getView(int pos,View convertView,ViewGroup arg2){
  ViewHolder holder;
  if (convertView == null) {
    convertView=inflater.inflate(R.layout.route_overview_list,null);
    holder=new ViewHolder();
    holder.travelTypes=(LinearLayout)convertView.findViewById(R.id.travelTypes);
    holder.departureTime=(TextView)convertView.findViewById(R.id.departureTime);
    holder.arrivalTime=(TextView)convertView.findViewById(R.id.arrivalTime);
    holder.travelTime=(TextView)convertView.findViewById(R.id.travelTime);
    holder.deviSymbol=(TextView)convertView.findViewById(R.id.deviSymbol);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  final RouteProposal routeProposal=items.get(pos);
  long departure=0;
  long arrival=0;
  holder.travelTypes.removeAllViews();
  for (  RouteData routeData : routeProposal.travelStageList) {
    if (departure == 0) {
      departure=routeData.departure;
    }
    arrival=routeData.arrival;
{
      final int symbolImage=routeData.transportType;
      if (symbolImage > 0) {
        final LinearLayout layout=(LinearLayout)inflater.inflate(R.layout.route_overview_traveltype,null);
        final TextView line=(TextView)layout.findViewById(R.id.line);
        final ImageView icon=(ImageView)layout.findViewById(R.id.icon);
        icon.setImageResource(symbolImage);
        if (routeData.line.length() > 0) {
          line.setText(routeData.line);
          line.setVisibility(View.VISIBLE);
        }
 else {
          line.setVisibility(View.GONE);
        }
        LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
        params.leftMargin=1;
        params.rightMargin=1;
        holder.travelTypes.addView(layout,params);
      }
    }
  }
  if (getDevi(pos,true).size() > 0) {
    holder.deviSymbol.setVisibility(View.VISIBLE);
  }
 else {
    holder.deviSymbol.setVisibility(View.GONE);
  }
{
    holder.departureTime.setText(HelperFunctions.hourFormater.format(departure));
    holder.arrivalTime.setText(HelperFunctions.hourFormater.format(arrival));
    long diff=arrival - departure;
    if (diff < HelperFunctions.HOUR) {
      holder.travelTime.setText(parent.getText(R.string.travelTime) + ""String_Node_Str"" + (diff / HelperFunctions.MINUTE)+ ""String_Node_Str"");
    }
 else {
      diff=diff - HelperFunctions.HOUR;
      holder.travelTime.setText(parent.getText(R.string.travelTime) + ""String_Node_Str"" + HelperFunctions.hourFormater.format(diff));
    }
  }
  return convertView;
}"
87477,"@Override public void onCreateContextMenu(ContextMenu menu,View v,ContextMenuInfo menuInfo){
  super.onCreateContextMenu(menu,v,menuInfo);
  menu.add(0,MAP_ID,0,R.string.map);
  final AdapterView.AdapterContextMenuInfo info=(AdapterView.AdapterContextMenuInfo)menuInfo;
  if (routeList.getDevi(info.position,true).size() > 0) {
    menu.add(0,DEVI_ID,0,R.string.warnings);
  }
  menu.add(0,NOTIFY_ID,0,R.string.alarm);
}","@Override public void onCreateContextMenu(ContextMenu menu,View v,ContextMenuInfo menuInfo){
  super.onCreateContextMenu(menu,v,menuInfo);
  menu.add(0,MAP_ID,0,R.string.map);
  if (routeList.getDevi(((AdapterView.AdapterContextMenuInfo)menuInfo).position,true).size() > 0) {
    menu.add(0,DEVI_ID,0,R.string.warnings);
  }
  menu.add(0,NOTIFY_ID,0,R.string.alarm);
}"
87478,"@Override public View getView(int pos,View convertView,ViewGroup arg2){
  final StationData station=items.get(pos);
  ViewHolder holder;
  if (convertView == null || convertView.getId() != layout) {
    convertView=inflater.inflate(layout,null);
    convertView.setId(layout);
    holder=new ViewHolder();
    holder.star=(ImageView)convertView.findViewById(R.id.star);
    holder.stopName=(TextView)convertView.findViewById(R.id.stopname);
    holder.address=(TextView)convertView.findViewById(R.id.address);
    holder.range=(TextView)convertView.findViewById(R.id.range);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  if (layout == R.layout.selectstation_list_multiselect) {
    CheckBox stopCheckBox=(CheckBox)convertView.findViewById(R.id.stopname);
    stopCheckBox.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        parent.stationSelected(station);
      }
    }
);
  }
  holder.stopName.setText(station.stopName);
  if (station.extra != null) {
    holder.address.setText(station.extra);
    holder.address.setVisibility(View.VISIBLE);
  }
 else {
    holder.address.setVisibility(View.INVISIBLE);
  }
  if (station.walkingDistance > 0) {
    holder.range.setText(""String_Node_Str"" + station.walkingDistance + ""String_Node_Str"");
    holder.range.setVisibility(View.VISIBLE);
  }
 else {
    holder.range.setText(""String_Node_Str"");
    holder.range.setVisibility(View.INVISIBLE);
  }
  if (station.isFavorite) {
    holder.star.setVisibility(View.VISIBLE);
  }
 else {
    holder.star.setVisibility(View.GONE);
  }
  return convertView;
}","@Override public View getView(final int pos,View convertView,ViewGroup arg2){
  final StationData station=items.get(pos);
  ViewHolder holder;
  if (convertView == null || convertView.getId() != layout) {
    convertView=inflater.inflate(layout,null);
    convertView.setId(layout);
    holder=new ViewHolder();
    holder.star=(ImageView)convertView.findViewById(R.id.star);
    holder.stopName=(TextView)convertView.findViewById(R.id.stopname);
    holder.address=(TextView)convertView.findViewById(R.id.address);
    holder.range=(TextView)convertView.findViewById(R.id.range);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.stopName.setText(station.stopName);
  if (station.extra != null) {
    holder.address.setText(station.extra);
    holder.address.setVisibility(View.VISIBLE);
  }
 else {
    holder.address.setVisibility(View.INVISIBLE);
  }
  if (station.walkingDistance > 0) {
    holder.range.setText(""String_Node_Str"" + station.walkingDistance + ""String_Node_Str"");
    holder.range.setVisibility(View.VISIBLE);
  }
 else {
    holder.range.setText(""String_Node_Str"");
    holder.range.setVisibility(View.INVISIBLE);
  }
  if (station.isFavorite) {
    holder.star.setVisibility(View.VISIBLE);
  }
 else {
    holder.star.setVisibility(View.GONE);
  }
  if (layout == R.layout.selectstation_list_multiselect) {
    final CheckBox stopCheckBox=(CheckBox)convertView.findViewById(R.id.stopname);
    stopCheckBox.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        parent.stationSelected(station);
      }
    }
);
    stopCheckBox.setChecked(parent.route_isStationSelected(station));
  }
  return convertView;
}"
87479,"@Override protected void onListItemClick(ListView l,View v,int position,long id){
  StationData station=(StationData)stationListAdapter.getItem(position);
  stationSelected(station);
}","@Override protected void onListItemClick(ListView l,View v,int position,long id){
  final StationData station=(StationData)stationListAdapter.getItem(position);
  stationSelected(station);
}"
87480,"private void refreshMultiSelect(){
  int layout=multiSelect == MULTISELECT_ENABLED ? R.layout.selectstation_list_multiselect : R.layout.selectstation_list;
  setAdapterLayout(layout);
}","private void refreshMultiSelect(){
  int layout=multiSelect == MULTISELECT_ENABLED ? R.layout.selectstation_list_multiselect : R.layout.selectstation_list;
  selectedStations.clear();
  setAdapterLayout(layout);
}"
87481,"private void loadDevi(){
  setProgressBarIndeterminateVisibility(true);
  tmpDataUpdated=0;
  deviItems=new ArrayList<DeviData>();
  deviProvider=DataProviderFactory.getDeviProvider(new DeviProviderHandler(){
    @Override public void onData(    DeviData deviData){
      if (deviData.lines.size() > 0) {
        realtimeList.addDeviItem(deviData);
        tmpDataUpdated++;
        if (tmpDataUpdated > 5) {
          realtimeList.notifyDataSetChanged();
          tmpDataUpdated=0;
        }
      }
 else {
        deviItems.add(deviData);
      }
    }
    @Override public void onError(    Exception exception){
      Log.w(TAG,""String_Node_Str"" + exception);
      Toast.makeText(RealtimeView.this,""String_Node_Str"" + getText(R.string.exception) + ""String_Node_Str""+ exception,Toast.LENGTH_LONG).show();
      setProgressBarIndeterminateVisibility(false);
    }
    @Override public void onFinished(){
      refreshDevi();
      setProgressBarIndeterminateVisibility(false);
      deviProvider=null;
      if (tmpDataUpdated > 0) {
        realtimeList.notifyDataSetChanged();
      }
    }
  }
);
  deviProvider.Fetch(station.stationId);
}","private void loadDevi(){
  setProgressBarIndeterminateVisibility(true);
  realtimeList.itemsAddedWithoutNotify=0;
  deviItems=new ArrayList<DeviData>();
  deviProvider=DataProviderFactory.getDeviProvider(new DeviProviderHandler(){
    @Override public void onData(    DeviData deviData){
      if (deviData.lines.size() > 0) {
        realtimeList.addDeviItem(deviData);
        realtimeList.itemsAddedWithoutNotify++;
        if (realtimeList.itemsAddedWithoutNotify > 5) {
          realtimeList.itemsAddedWithoutNotify=0;
          realtimeList.notifyDataSetChanged();
        }
      }
 else {
        deviItems.add(deviData);
      }
    }
    @Override public void onError(    Exception exception){
      Log.w(TAG,""String_Node_Str"" + exception);
      Toast.makeText(RealtimeView.this,""String_Node_Str"" + getText(R.string.exception) + ""String_Node_Str""+ exception,Toast.LENGTH_LONG).show();
      setProgressBarIndeterminateVisibility(false);
    }
    @Override public void onFinished(){
      refreshDevi();
      setProgressBarIndeterminateVisibility(false);
      deviProvider=null;
      if (realtimeList.itemsAddedWithoutNotify > 0) {
        realtimeList.itemsAddedWithoutNotify=0;
        realtimeList.notifyDataSetChanged();
      }
    }
  }
);
  deviProvider.Fetch(station.stationId);
}"
87482,"@Override public void onFinished(){
  refreshDevi();
  setProgressBarIndeterminateVisibility(false);
  deviProvider=null;
  if (tmpDataUpdated > 0) {
    realtimeList.notifyDataSetChanged();
  }
}","@Override public void onFinished(){
  refreshDevi();
  setProgressBarIndeterminateVisibility(false);
  deviProvider=null;
  if (realtimeList.itemsAddedWithoutNotify > 0) {
    realtimeList.itemsAddedWithoutNotify=0;
    realtimeList.notifyDataSetChanged();
  }
}"
87483,"private void load(){
  lastUpdate=System.currentTimeMillis();
  setProgressBarIndeterminateVisibility(true);
  if (realtimeProvider != null)   realtimeProvider.Stop();
  if (deviProvider != null)   deviProvider.Stop();
  realtimeList.clear();
  realtimeList.notifyDataSetChanged();
  final TextView infoText=(TextView)findViewById(R.id.emptyText);
  tmpDataUpdated=0;
  realtimeProvider=DataProviderFactory.getRealtimeProvider(new RealtimeProviderHandler(){
    @Override public void onData(    RealtimeData realtimeData){
      realtimeList.addItem(realtimeData);
      tmpDataUpdated++;
      if (tmpDataUpdated > 5) {
        realtimeList.notifyDataSetChanged();
        tmpDataUpdated=0;
      }
    }
    @Override public void onError(    Exception exception){
      Log.w(TAG,""String_Node_Str"" + exception);
      Toast.makeText(RealtimeView.this,""String_Node_Str"" + getText(R.string.exception) + ""String_Node_Str""+ exception,Toast.LENGTH_LONG).show();
      setProgressBarIndeterminateVisibility(false);
    }
    @Override public void onFinished(){
      refreshTitle();
      setProgressBarIndeterminateVisibility(false);
      infoText.setVisibility(realtimeList.getCount() > 0 ? View.GONE : View.VISIBLE);
      if (tmpDataUpdated > 0) {
        realtimeList.notifyDataSetChanged();
      }
      realtimeProvider=null;
      loadDevi();
    }
  }
);
  realtimeProvider.Fetch(station.stationId);
}","private void load(){
  lastUpdate=System.currentTimeMillis();
  setProgressBarIndeterminateVisibility(true);
  if (realtimeProvider != null)   realtimeProvider.Stop();
  if (deviProvider != null)   deviProvider.Stop();
  realtimeList.clear();
  realtimeList.notifyDataSetChanged();
  final TextView infoText=(TextView)findViewById(R.id.emptyText);
  realtimeList.itemsAddedWithoutNotify=0;
  realtimeProvider=DataProviderFactory.getRealtimeProvider(new RealtimeProviderHandler(){
    @Override public void onData(    RealtimeData realtimeData){
      realtimeList.addItem(realtimeData);
      realtimeList.itemsAddedWithoutNotify++;
      if (realtimeList.itemsAddedWithoutNotify > 5) {
        realtimeList.itemsAddedWithoutNotify=0;
        realtimeList.notifyDataSetChanged();
      }
    }
    @Override public void onError(    Exception exception){
      Log.w(TAG,""String_Node_Str"" + exception);
      Toast.makeText(RealtimeView.this,""String_Node_Str"" + getText(R.string.exception) + ""String_Node_Str""+ exception,Toast.LENGTH_LONG).show();
      setProgressBarIndeterminateVisibility(false);
    }
    @Override public void onFinished(){
      refreshTitle();
      setProgressBarIndeterminateVisibility(false);
      infoText.setVisibility(realtimeList.getCount() > 0 ? View.GONE : View.VISIBLE);
      if (realtimeList.itemsAddedWithoutNotify > 0) {
        realtimeList.itemsAddedWithoutNotify=0;
        realtimeList.notifyDataSetChanged();
      }
      realtimeProvider=null;
      loadDevi();
    }
  }
);
  realtimeProvider.Fetch(station.stationId);
}"
87484,"@Override public int getCount(){
  return itemsSize;
}","@Override public int getCount(){
  if (itemsAddedWithoutNotify > 0) {
    notifyDataSetChanged();
    itemsAddedWithoutNotify=0;
  }
  return itemsSize;
}"
87485,"@Override public void onData(DeviData deviData){
  if (deviData.lines.size() > 0) {
    realtimeList.addDeviItem(deviData);
    tmpDataUpdated++;
    if (tmpDataUpdated > 5) {
      realtimeList.notifyDataSetChanged();
      tmpDataUpdated=0;
    }
  }
 else {
    deviItems.add(deviData);
  }
}","@Override public void onData(DeviData deviData){
  if (deviData.lines.size() > 0) {
    realtimeList.addDeviItem(deviData);
    realtimeList.itemsAddedWithoutNotify++;
    if (realtimeList.itemsAddedWithoutNotify > 5) {
      realtimeList.itemsAddedWithoutNotify=0;
      realtimeList.notifyDataSetChanged();
    }
  }
 else {
    deviItems.add(deviData);
  }
}"
87486,"@Override public void endElement(String namespaceURI,String localName,String qName){
  if (!inPlace)   return;
  if (localName.equals(""String_Node_Str"")) {
    inPlace=false;
    if (!ignore) {
      final SearchStationData sendData=station;
      handler.post(new Runnable(){
        @Override public void run(){
          handler.onData(sendData);
        }
      }
);
    }
    ignore=false;
  }
 else {
    if (ignore)     return;
    if (inX && localName.equals(""String_Node_Str"")) {
      inX=false;
      station.utmCoords[0]=Integer.parseInt(buffer.toString());
    }
 else     if (inY && localName.equals(""String_Node_Str"")) {
      inY=false;
      station.utmCoords[1]=Integer.parseInt(buffer.toString());
    }
 else     if (inID && localName.equals(""String_Node_Str"")) {
      inID=false;
      station.stationId=Integer.parseInt(buffer.toString());
    }
 else     if (inName && localName.equals(""String_Node_Str"")) {
      inName=false;
      station.stopName=buffer.toString();
      searchForAddress();
    }
 else     if (inDistrict && localName.equals(""String_Node_Str"")) {
      inDistrict=false;
      if (station.extra == null) {
        station.extra=buffer.toString();
      }
 else {
        station.extra=station.extra + ""String_Node_Str"" + buffer.toString();
      }
    }
 else     if (inType && localName.equals(""String_Node_Str"")) {
      inType=false;
      if (buffer.length() != 4 && !buffer.toString().equals(""String_Node_Str"")) {
        ignore=true;
      }
    }
 else     if (inStops && localName.equals(""String_Node_Str"")) {
      inStops=false;
    }
 else     if (inWalkingDistance && localName.equals(""String_Node_Str"")) {
      inWalkingDistance=false;
      station.airDistance=Integer.parseInt(buffer.toString());
    }
  }
  buffer.setLength(0);
}","@Override public void endElement(String namespaceURI,String localName,String qName){
  if (!inPlace)   return;
  if (localName.equals(""String_Node_Str"")) {
    inPlace=false;
    if (!ignore) {
      final SearchStationData sendData=station;
      handler.post(new Runnable(){
        @Override public void run(){
          handler.onData(sendData);
        }
      }
);
    }
    ignore=false;
  }
 else {
    if (ignore)     return;
    if (inX && localName.equals(""String_Node_Str"")) {
      inX=false;
      station.utmCoords[0]=Integer.parseInt(buffer.toString());
    }
 else     if (inY && localName.equals(""String_Node_Str"")) {
      inY=false;
      station.utmCoords[1]=Integer.parseInt(buffer.toString());
    }
 else     if (inID && localName.equals(""String_Node_Str"")) {
      inID=false;
      station.stationId=Integer.parseInt(buffer.toString());
    }
 else     if (inName && localName.equals(""String_Node_Str"")) {
      inName=false;
      station.stopName=buffer.toString();
      searchForAddress();
    }
 else     if (inDistrict && localName.equals(""String_Node_Str"")) {
      inDistrict=false;
      if (station.extra == null) {
        station.extra=buffer.toString();
      }
 else {
        station.extra=station.extra + ""String_Node_Str"" + buffer.toString();
      }
    }
 else     if (inType && localName.equals(""String_Node_Str"")) {
      inType=false;
      if (buffer.length() != 4 && !buffer.toString().equals(""String_Node_Str"")) {
        ignore=true;
      }
    }
 else     if (inStops && localName.equals(""String_Node_Str"")) {
      inStops=false;
    }
 else     if (inWalkingDistance && localName.equals(""String_Node_Str"")) {
      inWalkingDistance=false;
      station.setWalkingDistance(Integer.parseInt(buffer.toString()));
    }
  }
  buffer.setLength(0);
}"
87487,"public SearchStationData(Parcel in){
  stopName=in.readString();
  extra=in.readString();
  stationId=in.readInt();
  hasAirDistance=in.readInt() != 0;
  airDistance=in.readInt();
  utmCoords[0]=in.readInt();
  utmCoords[1]=in.readInt();
  latLongCoords[0]=in.readDouble();
  latLongCoords[1]=in.readDouble();
}","public SearchStationData(Parcel in){
  stopName=in.readString();
  extra=in.readString();
  stationId=in.readInt();
  hasWalkingDistance=in.readInt() != 0;
  walkingDistance=in.readInt();
  utmCoords[0]=in.readInt();
  utmCoords[1]=in.readInt();
  latLongCoords[0]=in.readDouble();
  latLongCoords[1]=in.readDouble();
}"
87488,"@Override public void writeToParcel(Parcel out,int flags){
  out.writeString(stopName);
  out.writeString(extra);
  out.writeInt(stationId);
  out.writeInt(hasAirDistance ? 1 : 0);
  out.writeInt(airDistance);
  out.writeInt(utmCoords[0]);
  out.writeInt(utmCoords[1]);
  out.writeDouble(latLongCoords[0]);
  out.writeDouble(latLongCoords[1]);
}","@Override public void writeToParcel(Parcel out,int flags){
  out.writeString(stopName);
  out.writeString(extra);
  out.writeInt(stationId);
  out.writeInt(hasWalkingDistance ? 1 : 0);
  out.writeInt(walkingDistance);
  out.writeInt(utmCoords[0]);
  out.writeInt(utmCoords[1]);
  out.writeDouble(latLongCoords[0]);
  out.writeDouble(latLongCoords[1]);
}"
87489,"@Override public View getView(int pos,View convertView,ViewGroup arg2){
  ViewHolder holder;
  if (convertView == null) {
    convertView=inflater.inflate(R.layout.selectstation_list,null);
    holder=new ViewHolder();
    holder.star=(ImageView)convertView.findViewById(R.id.star);
    holder.stopName=(TextView)convertView.findViewById(R.id.stopname);
    holder.address=(TextView)convertView.findViewById(R.id.address);
    holder.range=(TextView)convertView.findViewById(R.id.range);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  final SearchStationData station=items.get(pos);
  holder.stopName.setText(station.stopName);
  if (station.extra != null) {
    holder.address.setText(station.extra);
    holder.address.setVisibility(View.VISIBLE);
  }
 else {
    holder.address.setVisibility(View.INVISIBLE);
  }
  if (station.airDistance > 0) {
    holder.range.setText(""String_Node_Str"" + station.airDistance + ""String_Node_Str"");
    holder.range.setVisibility(View.VISIBLE);
  }
 else {
    holder.range.setVisibility(View.INVISIBLE);
  }
  if (station.isFavorite) {
    holder.star.setVisibility(View.VISIBLE);
  }
 else {
    holder.star.setVisibility(View.GONE);
  }
  return convertView;
}","@Override public View getView(int pos,View convertView,ViewGroup arg2){
  ViewHolder holder;
  if (convertView == null) {
    convertView=inflater.inflate(R.layout.selectstation_list,null);
    holder=new ViewHolder();
    holder.star=(ImageView)convertView.findViewById(R.id.star);
    holder.stopName=(TextView)convertView.findViewById(R.id.stopname);
    holder.address=(TextView)convertView.findViewById(R.id.address);
    holder.range=(TextView)convertView.findViewById(R.id.range);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  final SearchStationData station=items.get(pos);
  holder.stopName.setText(station.stopName);
  if (station.extra != null) {
    holder.address.setText(station.extra);
    holder.address.setVisibility(View.VISIBLE);
  }
 else {
    holder.address.setVisibility(View.INVISIBLE);
  }
  if (station.hasWalkingDistance) {
    holder.range.setText(""String_Node_Str"" + station.walkingDistance + ""String_Node_Str"");
    holder.range.setVisibility(View.VISIBLE);
  }
 else {
    holder.range.setVisibility(View.INVISIBLE);
  }
  if (station.isFavorite) {
    holder.star.setVisibility(View.VISIBLE);
  }
 else {
    holder.star.setVisibility(View.GONE);
  }
  return convertView;
}"
87490,"public static InputStream soapRequest(final Resources resources,final int rid,final String[] args,final String url) throws IOException {
  final String soap=mergeXmlArgument(resources,rid,args);
  HttpPost httppost=new HttpPost(url);
  httppost.setHeader(""String_Node_Str"",""String_Node_Str"");
  httppost.setEntity(new StringEntity(soap));
  Log.d(""String_Node_Str"",""String_Node_Str"" + soap);
  HttpResponse response=new DefaultHttpClient().execute(httppost);
  Log.d(""String_Node_Str"",""String_Node_Str"");
  return response.getEntity().getContent();
}","public static InputStream soapRequest(final Resources resources,final int rid,final String[] args,final String url) throws IOException {
  final String soap=mergeXmlArgument(resources,rid,args);
  HttpPost httppost=new HttpPost(url);
  httppost.setHeader(""String_Node_Str"",""String_Node_Str"");
  httppost.setEntity(new StringEntity(soap));
  Log.d(""String_Node_Str"",""String_Node_Str"" + soap);
  HttpResponse response=new DefaultHttpClient().execute(httppost);
  return response.getEntity().getContent();
}"
87491,"public void updateHistory(SearchStationData station){
  if (hasStation(station.stationId)) {
    final String rowIdSql=""String_Node_Str"" + KEY_ROWID + ""String_Node_Str""+ table+ ""String_Node_Str"";
    final String sql=String.format(""String_Node_Str"",table,KEY_USED,KEY_USED,KEY_ROWID,rowIdSql,KEY_STATIONID,station.stationId);
    Log.i(""String_Node_Str"",sql);
    final Cursor c=db.rawQuery(sql,null);
    c.moveToFirst();
    c.close();
  }
 else {
    add(station);
  }
  db.delete(table,KEY_ROWID + ""String_Node_Str"" + table+ ""String_Node_Str"",null);
}","public void updateHistory(SearchStationData station){
  if (hasStation(station.stationId)) {
    final String rowIdSql=""String_Node_Str"" + KEY_ROWID + ""String_Node_Str""+ table+ ""String_Node_Str"";
    final String sql=String.format(""String_Node_Str"",table,KEY_USED,KEY_USED,KEY_ROWID,rowIdSql,KEY_STATIONID,station.stationId);
    final Cursor c=db.rawQuery(sql,null);
    c.moveToFirst();
    c.close();
  }
 else {
    add(station);
  }
  db.delete(table,KEY_ROWID + ""String_Node_Str"" + table+ ""String_Node_Str"",null);
}"
87492,"public void addFavoritesToList(List<SearchStationData> items){
  Cursor cursor=db.query(table,COLUMNS,null,null,null,null,KEY_USED + ""String_Node_Str"");
  while (cursor.moveToNext()) {
    SearchStationData station=new SearchStationData(cursor.getString(0),cursor.getString(1),cursor.getInt(2),new int[]{cursor.getInt(3),cursor.getInt(4)});
    station.isFavorite=true;
    items.add(station);
  }
  cursor.close();
}","public void addFavoritesToList(List<SearchStationData> items){
  Cursor cursor=db.query(table,COLUMNS,null,null,null,null,KEY_USED + ""String_Node_Str"");
  while (cursor.moveToNext()) {
    SearchStationData station=new SearchStationData(cursor.getString(0),cursor.getString(1),cursor.getInt(2),new int[]{cursor.getInt(4),cursor.getInt(5)});
    station.isFavorite=true;
    items.add(station);
  }
  cursor.close();
}"
87493,"public void addHistoryToList(ArrayList<SearchStationData> items){
  Cursor cursor=db.query(table,COLUMNS,null,null,null,null,KEY_USED + ""String_Node_Str"");
  while (cursor.moveToNext()) {
    SearchStationData station=new SearchStationData(cursor.getString(0),cursor.getString(1),cursor.getInt(2),new int[]{cursor.getInt(3),cursor.getInt(4)});
    boolean foundDuplicate=false;
    for (    SearchStationData listStation : items) {
      if (station.stationId == listStation.stationId) {
        foundDuplicate=true;
        break;
      }
    }
    if (!foundDuplicate) {
      items.add(station);
    }
  }
  cursor.close();
}","public void addHistoryToList(ArrayList<SearchStationData> items){
  Cursor cursor=db.query(table,COLUMNS,null,null,null,null,KEY_USED + ""String_Node_Str"");
  while (cursor.moveToNext()) {
    SearchStationData station=new SearchStationData(cursor.getString(0),cursor.getString(1),cursor.getInt(2),new int[]{cursor.getInt(4),cursor.getInt(5)});
    boolean foundDuplicate=false;
    for (    SearchStationData listStation : items) {
      if (station.stationId == listStation.stationId) {
        foundDuplicate=true;
        break;
      }
    }
    if (!foundDuplicate) {
      items.add(station);
    }
  }
  cursor.close();
}"
87494,"/** 
 * Returns the query string to count entities.
 * @return string to count entities
 */
protected String getCountQueryString(){
  PersistenceProvider provider=PersistenceProvider.fromEntityManager(getEntityManager());
  String countQuery=String.format(COUNT_QUERY_STRING,provider.getCountQueryPlaceholder(),""String_Node_Str"");
  return getQueryString(countQuery,getDomainClass());
}","/** 
 * Returns the query string to count entities.
 * @return string to count entities
 */
@Deprecated protected String getCountQueryString(){
  PersistenceProvider provider=PersistenceProvider.fromEntityManager(getEntityManager());
  String countQuery=String.format(COUNT_QUERY_STRING,provider.getCountQueryPlaceholder(),""String_Node_Str"");
  return getQueryString(countQuery,getDomainClass());
}"
87495,"@Transactional(readOnly=true) public Long count(){
  return getEntityManager().createQuery(getCountQueryString(),Long.class).getSingleResult();
}","private Long count(Specification<T> spec){
  return getCountQuery(spec).getSingleResult();
}"
87496,"/** 
 * @param query
 * @param pageable
 * @return
 */
private Page<T> readPage(final TypedQuery<T> query,final Pageable pageable){
  query.setFirstResult(pageable.getFirstItem());
  query.setMaxResults(pageable.getPageSize());
  return new PageImpl<T>(query.getResultList(),pageable,count());
}","/** 
 * @param query
 * @param spec
 * @param pageable
 * @return
 */
private Page<T> readPage(final TypedQuery<T> query,final Pageable pageable,final Specification<T> spec){
  query.setFirstResult(pageable.getFirstItem());
  query.setMaxResults(pageable.getPageSize());
  return new PageImpl<T>(query.getResultList(),pageable,count(spec));
}"
87497,"/** 
 * Creates a WHERE clause for a query of the referenced entity in form of a  {@link Predicate} for the given {@link Root} and {@link CriteriaQuery}.
 * @param root
 * @param query
 * @return a {@link Predicate}, must not be   {@literal null}.
 */
Predicate toPredicate(Root<T> root,CriteriaQuery<T> query,CriteriaBuilder builder);","/** 
 * Creates a WHERE clause for a query of the referenced entity in form of a  {@link Predicate} for the given {@link Root} and {@link CriteriaQuery}.
 * @param root
 * @param query
 * @return a {@link Predicate}, must not be   {@literal null}.
 */
Predicate toPredicate(Root<T> root,CriteriaQuery<?> query,CriteriaBuilder builder);"
87498,"/** 
 * Negates the given   {@link Specification}.
 * @param < T >
 * @param spec
 * @return
 */
public static <T>Specifications<T> not(final Specification<T> spec){
  return new Specifications<T>(spec){
    @Override public Predicate toPredicate(    Root<T> root,    CriteriaQuery<T> query,    CriteriaBuilder builder){
      return builder.not(spec.toPredicate(root,query,builder));
    }
  }
;
}","/** 
 * Negates the given   {@link Specification}.
 * @param < T >
 * @param spec
 * @return
 */
public static <T>Specifications<T> not(final Specification<T> spec){
  return new Specifications<T>(spec){
    @Override public Predicate toPredicate(    Root<T> root,    CriteriaQuery<?> query,    CriteriaBuilder builder){
      return builder.not(spec.toPredicate(root,query,builder));
    }
  }
;
}"
87499,"/** 
 * ORs the given specification to the current one.
 * @param other
 * @return
 */
public Specification<T> or(final Specification<T> other){
  return new Specification<T>(){
    public Predicate toPredicate(    Root<T> root,    CriteriaQuery<T> query,    CriteriaBuilder builder){
      return builder.or(spec.toPredicate(root,query,builder),other.toPredicate(root,query,builder));
    }
  }
;
}","/** 
 * ORs the given specification to the current one.
 * @param other
 * @return
 */
public Specification<T> or(final Specification<T> other){
  return new Specification<T>(){
    public Predicate toPredicate(    Root<T> root,    CriteriaQuery<?> query,    CriteriaBuilder builder){
      return builder.or(spec.toPredicate(root,query,builder),other.toPredicate(root,query,builder));
    }
  }
;
}"
87500,"/** 
 * ANDs the given   {@link Specification} to the current one.
 * @param other
 * @return
 */
public Specification<T> and(final Specification<T> other){
  return new Specification<T>(){
    public Predicate toPredicate(    Root<T> root,    CriteriaQuery<T> query,    CriteriaBuilder builder){
      return builder.and(spec.toPredicate(root,query,builder),other.toPredicate(root,query,builder));
    }
  }
;
}","/** 
 * ANDs the given   {@link Specification} to the current one.
 * @param other
 * @return
 */
public Specification<T> and(final Specification<T> other){
  return new Specification<T>(){
    public Predicate toPredicate(    Root<T> root,    CriteriaQuery<?> query,    CriteriaBuilder builder){
      return builder.and(spec.toPredicate(root,query,builder),other.toPredicate(root,query,builder));
    }
  }
;
}"
87501,"public Predicate toPredicate(Root<T> root,CriteriaQuery<T> query,CriteriaBuilder builder){
  return spec.toPredicate(root,query,builder);
}","public Predicate toPredicate(Root<T> root,CriteriaQuery<?> query,CriteriaBuilder builder){
  return spec.toPredicate(root,query,builder);
}"
87502,"private static <T>Specification<T> simplePropertySpec(final String property,final Object value){
  return new Specification<T>(){
    public Predicate toPredicate(    Root<T> root,    CriteriaQuery<T> query,    CriteriaBuilder builder){
      return builder.equal(root.get(property),value);
    }
  }
;
}","private static <T>Specification<T> simplePropertySpec(final String property,final Object value){
  return new Specification<T>(){
    public Predicate toPredicate(    Root<T> root,    CriteriaQuery<?> query,    CriteriaBuilder builder){
      return builder.equal(root.get(property),value);
    }
  }
;
}"
87503,"public Predicate toPredicate(Root<T> root,CriteriaQuery<T> query,CriteriaBuilder builder){
  return builder.equal(root.get(property),value);
}","public Predicate toPredicate(Root<T> root,CriteriaQuery<?> query,CriteriaBuilder builder){
  return builder.equal(root.get(property),value);
}"
87504,"/** 
 * Creates an anonymous factory to extract the actual  {@link javax.persistence.EntityManager} from the{@link javax.persistence.EntityManagerFactory} bean name reference.
 * @param entityManagerFactoryBeanName
 * @param source
 * @return
 */
private BeanDefinition getEntityManagerBeanDefinitionFor(String entityManagerFactoryBeanName,Object source){
  AbstractBeanDefinition bean=BeanDefinitionBuilder.rootBeanDefinition(""String_Node_Str"").getRawBeanDefinition();
  bean.setFactoryBeanName(entityManagerFactoryBeanName);
  bean.setFactoryMethodName(""String_Node_Str"");
  bean.setSource(source);
  return bean;
}","/** 
 * Creates an anonymous factory to extract the actual  {@link javax.persistence.EntityManager} from the{@link javax.persistence.EntityManagerFactory} bean name reference.
 * @param entityManagerFactoryBeanName
 * @param source
 * @return
 */
private BeanDefinition getEntityManagerBeanDefinitionFor(String entityManagerFactoryBeanName,Object source){
  BeanDefinitionBuilder builder=BeanDefinitionBuilder.rootBeanDefinition(""String_Node_Str"");
  builder.setFactoryMethod(""String_Node_Str"");
  builder.addConstructorArgReference(entityManagerFactoryBeanName);
  AbstractBeanDefinition bean=builder.getRawBeanDefinition();
  bean.setSource(source);
  return bean;
}"
87505,"/** 
 * Returns the generic type with the given index from the given  {@link Class} if it implements {@link GenericDao} or{@link ExtendedGenericDao}.
 * @param clazz
 * @param index
 * @return the domain class for index 0, the id class for index 1.
 */
private static Class<?> getGenericType(Class<?> clazz,int index){
  for (  Type type : clazz.getGenericInterfaces()) {
    if (type instanceof ParameterizedType) {
      ParameterizedType parammeterizedType=(ParameterizedType)type;
      if (isGenericDao(parammeterizedType)) {
        return (Class<?>)parammeterizedType.getActualTypeArguments()[index];
      }
    }
    Class<? extends Persistable<?>> result=getDomainClass((Class<?>)type);
    if (null != result) {
      return result;
    }
  }
  return null;
}","/** 
 * Returns the generic type with the given index from the given  {@link Class} if it implements {@link GenericDao} or{@link ExtendedGenericDao}.
 * @param clazz
 * @param index
 * @return the domain class for index 0, the id class for index 1.
 */
private static Class<?> getGenericType(Class<?> clazz,int index){
  for (  Type type : clazz.getGenericInterfaces()) {
    if (type instanceof ParameterizedType) {
      ParameterizedType parammeterizedType=(ParameterizedType)type;
      if (isGenericDao(parammeterizedType)) {
        return (Class<?>)parammeterizedType.getActualTypeArguments()[index];
      }
    }
    Class<?> result=getGenericType((Class<?>)type,index);
    if (null != result) {
      return result;
    }
  }
  return null;
}"
87506,"/** 
 * Returns whether the parameter with the given index is a special parameter.
 * @see #TYPES
 * @param index
 * @return
 */
public boolean isSpecialParameter(int index){
  return TYPES.contains(method.getParameterTypes()[index]);
}","/** 
 * Returns whether the parameter with the given index is a special parameter.
 * @see #TYPES
 * @param index
 * @return
 */
public final boolean isSpecialParameter(int index){
  return TYPES.contains(method.getParameterTypes()[index]);
}"
87507,"/** 
 * Executes the   {@link javax.persistence.Query} backing the{@link QueryMethod} with the given parameters.
 * @param em
 * @param parameters
 * @return
 */
public Object executeQuery(Object... methodParameters){
  Parameters parameters=new Parameters(method,methodParameters);
  if (isCollectionQuery()) {
    return COLLECTION.execute(hadesQuery,parameters);
  }
  if (isPageQuery()) {
    return PAGE.execute(hadesQuery,parameters);
  }
  if (isModifyingQuery()) {
    return MODIFY.execute(hadesQuery,parameters);
  }
  return SINGLE_ENTITY.execute(hadesQuery,parameters);
}","/** 
 * Executes the   {@link javax.persistence.Query} backing the{@link QueryMethod} with the given parameters.
 * @param em
 * @param parameters
 * @return
 */
public Object executeQuery(Object... methodParameters){
  Parameters executionParameters=new Parameters(method,methodParameters);
  if (isCollectionQuery()) {
    return COLLECTION.execute(hadesQuery,executionParameters);
  }
  if (isPageQuery()) {
    return PAGE.execute(hadesQuery,executionParameters);
  }
  if (isModifyingQuery()) {
    return MODIFY.execute(hadesQuery,executionParameters);
  }
  return SINGLE_ENTITY.execute(hadesQuery,executionParameters);
}"
87508,"public void delete(final List<T> entities){
  QueryUtils.applyAndBind(getDeleteAllQueryString(),entities,getEntityManager()).executeUpdate();
}","public void delete(final List<T> entities){
  if (null == entities || entities.isEmpty()) {
    return;
  }
  QueryUtils.applyAndBind(getDeleteAllQueryString(),entities,getEntityManager()).executeUpdate();
}"
87509,"@Override protected String getDaoImplPostfix(){
  String daoImplPostfix=element.getAttribute(DAO_IMPL_POSTFIX);
  return StringUtils.hasLength(daoImplPostfix) ? daoImplPostfix : parent.getDaoImplPostfix();
}","@Override protected String getDaoImplPostfix(){
  String daoImplPostfix=getElement().getAttribute(DAO_IMPL_POSTFIX);
  return StringUtils.hasLength(daoImplPostfix) ? daoImplPostfix : parent.getDaoImplPostfix();
}"
87510,"/** 
 * Returns if a custom DAO implementation shall be autodetected.
 * @return
 */
public boolean autodetectCustomImplementation(){
  return !StringUtils.hasText(element.getAttribute(CUSTOM_IMPL_REF));
}","/** 
 * Returns if a custom DAO implementation shall be autodetected.
 * @return
 */
public boolean autodetectCustomImplementation(){
  return !StringUtils.hasText(getElement().getAttribute(CUSTOM_IMPL_REF));
}"
87511,"@Override public String getFinderPrefix(){
  String finderPrefix=element.getAttribute(FINDER_PREFIX);
  return StringUtils.hasText(finderPrefix) ? finderPrefix : parent.getFinderPrefix();
}","@Override public String getFinderPrefix(){
  String finderPrefix=getElement().getAttribute(FINDER_PREFIX);
  return StringUtils.hasText(finderPrefix) ? finderPrefix : parent.getFinderPrefix();
}"
87512,"/** 
 * Returns the bean reference to the custom DAO implementation.
 * @return
 */
public String getCustomImplementationRef(){
  return element.getAttribute(CUSTOM_IMPL_REF);
}","/** 
 * Returns the bean reference to the custom DAO implementation.
 * @return
 */
public String getCustomImplementationRef(){
  return getElement().getAttribute(CUSTOM_IMPL_REF);
}"
87513,"@Override protected String getDaoBasePackageName(){
  String daoPackageName=element.getAttribute(DAO_PACKAGE_NAME);
  return StringUtils.hasText(daoPackageName) ? daoPackageName : parent.getDaoBasePackageName();
}","@Override protected String getDaoBasePackageName(){
  String daoPackageName=getElement().getAttribute(DAO_PACKAGE_NAME);
  return StringUtils.hasText(daoPackageName) ? daoPackageName : parent.getDaoBasePackageName();
}"
87514,"/** 
 * Creates a new   {@link FinderMethod} from the given parameters. Looks upthe correct query to use for following invocations of the method given.
 * @param method
 * @param prefix
 * @param domainClass
 * @param strategy
 * @param em
 */
public FinderMethod(Method method,String prefix,Class<?> domainClass,QueryLookupStrategy strategy,EntityManager em){
  Assert.notNull(method,""String_Node_Str"");
  Assert.hasText(prefix,""String_Node_Str"");
  Assert.notNull(domainClass,""String_Node_Str"");
  Assert.notNull(em,""String_Node_Str"");
  if (!method.getName().startsWith(prefix)) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"" + ""String_Node_Str"",prefix));
  }
  this.method=method;
  this.prefix=prefix;
  this.domainClass=domainClass;
  this.em=em;
  strategy=null == strategy ? QueryLookupStrategy.getDefault() : strategy;
  this.hadesQuery=strategy.resolveQuery(this);
}","/** 
 * Creates a new   {@link FinderMethod} from the given parameters. Looks upthe correct query to use for following invocations of the method given.
 * @param method
 * @param prefix
 * @param domainClass
 * @param strategy
 * @param em
 */
public FinderMethod(Method method,String prefix,Class<?> domainClass,QueryLookupStrategy strategy,EntityManager em){
  Assert.notNull(method,""String_Node_Str"");
  Assert.hasText(prefix,""String_Node_Str"");
  Assert.notNull(domainClass,""String_Node_Str"");
  Assert.notNull(em,""String_Node_Str"");
  if (!method.getName().startsWith(prefix)) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"" + ""String_Node_Str"",prefix));
  }
  this.method=method;
  this.prefix=prefix;
  this.domainClass=domainClass;
  this.em=em;
  QueryLookupStrategy strategyToUse=null == strategy ? QueryLookupStrategy.getDefault() : strategy;
  this.hadesQuery=strategyToUse.resolveQuery(this);
}"
87515,"/** 
 * Constructs a query from the given method. The method has to start with  {@code #FINDER_PREFIX}.
 * @return the query string
 */
String constructQuery(){
  final String AND=""String_Node_Str"";
  final String OR=""String_Node_Str"";
  String methodName=method.getName();
  int numberOfBlocks=0;
  methodName=methodName.substring(prefix.length(),methodName.length());
  StringBuilder queryBuilder=new StringBuilder(getQueryString(READ_ALL_QUERY,domainClass) + ""String_Node_Str"");
  String[] orParts=StringUtils.delimitedListToStringArray(methodName,OR);
  for (  String orPart : Arrays.asList(orParts)) {
    String[] andParts=StringUtils.delimitedListToStringArray(orPart,AND);
    StringBuilder andBuilder=new StringBuilder();
    for (    String andPart : Arrays.asList(andParts)) {
      andBuilder.append(""String_Node_Str"");
      andBuilder.append(StringUtils.uncapitalize(andPart));
      andBuilder.append(""String_Node_Str"");
      andBuilder.append(""String_Node_Str"");
      numberOfBlocks++;
    }
    andBuilder.delete(andBuilder.length() - 5,andBuilder.length());
    queryBuilder.append(andBuilder);
    queryBuilder.append(""String_Node_Str"");
  }
  if (numberOfBlocks != method.getParameterTypes().length) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  queryBuilder.delete(queryBuilder.length() - 4,queryBuilder.length());
  String query=queryBuilder.toString();
  if (LOG.isDebugEnabled()) {
    LOG.debug(String.format(""String_Node_Str"",query,method.getName()));
  }
  return query;
}","/** 
 * Constructs a query from the given method. The method has to start with  {@code #FINDER_PREFIX}.
 * @return the query string
 */
String constructQuery(){
  final String and=""String_Node_Str"";
  final String or=""String_Node_Str"";
  String methodName=method.getName();
  int numberOfBlocks=0;
  methodName=methodName.substring(prefix.length(),methodName.length());
  StringBuilder queryBuilder=new StringBuilder(getQueryString(READ_ALL_QUERY,domainClass) + ""String_Node_Str"");
  String[] orParts=StringUtils.delimitedListToStringArray(methodName,or);
  for (  String orPart : Arrays.asList(orParts)) {
    String[] andParts=StringUtils.delimitedListToStringArray(orPart,and);
    StringBuilder andBuilder=new StringBuilder();
    for (    String andPart : Arrays.asList(andParts)) {
      andBuilder.append(""String_Node_Str"");
      andBuilder.append(StringUtils.uncapitalize(andPart));
      andBuilder.append(""String_Node_Str"");
      andBuilder.append(""String_Node_Str"");
      numberOfBlocks++;
    }
    andBuilder.delete(andBuilder.length() - 5,andBuilder.length());
    queryBuilder.append(andBuilder);
    queryBuilder.append(""String_Node_Str"");
  }
  if (numberOfBlocks != method.getParameterTypes().length) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  queryBuilder.delete(queryBuilder.length() - 4,queryBuilder.length());
  String query=queryBuilder.toString();
  if (LOG.isDebugEnabled()) {
    LOG.debug(String.format(""String_Node_Str"",query,method.getName()));
  }
  return query;
}"
87516,"/** 
 * Returns sort properties.
 * @return the property
 */
public String[] getProperties(){
  return properties;
}","/** 
 * Returns sort properties.
 * @return the property
 */
public String[] getProperties(){
  return properties.clone();
}"
87517,"/** 
 * Creates a new instance of   {@code Sort}.
 * @param order
 * @param properties
 */
public Sort(Order order,String... properties){
  this.properties=properties;
  this.order=order;
}","/** 
 * Creates a new instance of   {@code Sort}.
 * @param order
 * @param properties
 */
public Sort(Order order,String... properties){
  this.properties=properties.clone();
  this.order=order;
}"
87518,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (!obj.getClass().equals(this.getClass())) {
    return false;
  }
  AbstractPersistable<?> that=(AbstractPersistable<?>)obj;
  return null == this.getId() ? false : this.getId().equals(that.getId());
}","@Override public boolean equals(Object obj){
  if (null == obj) {
    return false;
  }
  if (this == obj) {
    return true;
  }
  if (!getClass().equals(obj.getClass())) {
    return false;
  }
  AbstractPersistable<?> that=(AbstractPersistable<?>)obj;
  return null == this.getId() ? false : this.getId().equals(that.getId());
}"
87519,"public int getTotalPages(){
  return (int)Math.ceil(new Long(total).doubleValue() / new Integer(pageSize).doubleValue());
}","public int getTotalPages(){
  return (int)Math.ceil((double)total / (double)pageSize);
}"
87520,"/** 
 * Asserts that   {@link #equals(Object)} returns true for self references andother references of the exact same class and id and  {@code false}otherwise.
 * @throws Exception
 */
@Test public void correctEquals() throws Exception {
  assertEquals(user,user);
  assertNotEquals(user,new SampleUser(null));
  user.setId(1L);
  assertEquals(user,new SampleUser(1L));
  assertNotEquals(user,new SampleRole(1L));
}","/** 
 * Asserts that   {@link #equals(Object)} returns true for self references andother references of the exact same class and id and  {@code false}otherwise.
 * @throws Exception
 */
@Test public void correctEquals() throws Exception {
  assertEquals(user,user);
  assertNotEquals(user,new SampleUser(null));
  user.setId(1L);
  assertEquals(user,new SampleUser(1L));
  assertNotEquals(user,new SampleUser(1L){
    private static final long serialVersionUID=7716397091688803365L;
  }
);
  assertNotEquals(user,new SampleRole(1L));
}"
87521,"@Override public String toString(){
  return String.format(""String_Node_Str"",this.getClass().getName(),getId().toString());
}","@Override public String toString(){
  return String.format(""String_Node_Str"",this.getClass().getName(),getId());
}"
87522,"@SuppressWarnings(""String_Node_Str"") public Page<T> readByExample(final Pageable pageable,final Sort sort,final T... examples){
  Assert.notNull(pageable,""String_Node_Str"");
  if (null == examples || examples.length == 0) {
    return readAll(pageable,sort);
  }
  Criteria criteria=prepareCriteria(examples);
  if (null != pageable) {
    criteria.setFirstResult(pageable.getFirstItem());
    criteria.setMaxResults(pageable.getNumberOfItems());
  }
  if (null != sort) {
    applySorting(criteria,sort);
  }
  return new PageImpl(criteria.list(),pageable,count());
}","@SuppressWarnings(""String_Node_Str"") public Page<T> readByExample(final Pageable pageable,final Sort sort,final T... examples){
  Assert.notNull(pageable,""String_Node_Str"");
  if (null == examples || examples.length == 0) {
    return readAll(pageable,sort);
  }
  Criteria countCriteria=prepareCriteria(examples);
  countCriteria.setProjection(Projections.rowCount());
  Integer count=(Integer)countCriteria.uniqueResult();
  Criteria listCriteria=prepareCriteria(examples);
  if (null != sort) {
    applySorting(listCriteria,sort);
  }
  if (null != pageable) {
    listCriteria.setFirstResult(pageable.getFirstItem());
    listCriteria.setMaxResults(pageable.getNumberOfItems());
  }
  return new PageImpl(listCriteria.list(),pageable,count);
}"
87523,"/** 
 * Returns the query string to retrieve all entities.
 * @return
 */
private String getReadAllQuery(){
  return ""String_Node_Str"" + getDomainClass().getSimpleName() + ""String_Node_Str"";
}","/** 
 * Returns the query string to retrieve all entities.
 * @return
 */
protected String getReadAllQuery(){
  return ""String_Node_Str"" + getDomainClass().getSimpleName() + ""String_Node_Str"";
}"
87524,"@Override protected void onSetUpInTransaction() throws Exception {
  referenceUsers=new ArrayList<User>();
  for (int i=0; i < NUMBER_OF_INSTANCES; i++) {
    User user=new User(""String_Node_Str"" + i,""String_Node_Str"" + i,""String_Node_Str"" + (NUMBER_OF_INSTANCES - i));
    referenceUsers.add(userExtendedDao.save(user));
  }
  assertEquals(10,userExtendedDao.count().longValue());
}","@Override protected void onSetUpInTransaction() throws Exception {
  referenceUsers=new ArrayList<User>();
  for (int i=0; i < NUMBER_OF_INSTANCES; i++) {
    User user=new User(""String_Node_Str"" + i,""String_Node_Str"" + i % 2,""String_Node_Str"" + (NUMBER_OF_INSTANCES - i));
    referenceUsers.add(userExtendedDao.save(user));
  }
  assertEquals(NUMBER_OF_INSTANCES,userExtendedDao.count().longValue());
}"
87525,"@EventHandler(priority=EventPriority.LOWEST,ignoreCancelled=false) public void onBlockBreakLowest(final BlockBreakEvent event){
  if (!stack.isEmpty()) {
    checkStack();
    final Player player=event.getPlayer();
    final StackEntry entry=stack.get(stack.size() - 1);
    if (player.equals(entry.player))     addExemption(entry);
  }
}","@EventHandler(priority=EventPriority.LOWEST,ignoreCancelled=false) public void onBlockBreakLowest(final BlockBreakEvent event){
  checkStack();
  if (!stack.isEmpty()) {
    final Player player=event.getPlayer();
    final StackEntry entry=stack.get(stack.size() - 1);
    if (player.equals(entry.player))     addExemption(entry);
  }
}"
87526,"public Pair<Integer,List<JSONObject>> getModelsByCategoryId(final long categoryId,final int pageNumber){
  List<JSONObject> allModels=getAllModelsByCategoryId(categoryId);
  int modelsNumber=allModels.size();
  int pagesNumber=modelsNumber % MODELS_ON_PAGE_NUM == 0 ? modelsNumber / MODELS_ON_PAGE_NUM : modelsNumber / MODELS_ON_PAGE_NUM + 1;
  int indexFrom, indexTo;
  if (pageNumber < pagesNumber) {
    indexFrom=(pageNumber - 1) * MODELS_ON_PAGE_NUM;
    indexTo=pageNumber * MODELS_ON_PAGE_NUM - 1;
  }
 else   if (pageNumber == pagesNumber) {
    indexFrom=(pageNumber - 1) * MODELS_ON_PAGE_NUM;
    indexTo=modelsNumber - 1;
  }
 else {
    indexFrom=0;
    indexTo=pagesNumber > 1 ? MODELS_ON_PAGE_NUM - 1 : modelsNumber - 1;
  }
  return new Pair<Integer,List<JSONObject>>(pagesNumber,allModels.subList(indexFrom,indexTo));
}","public Pair<Integer,List<JSONObject>> getModelsByCategoryId(final long categoryId,final int pageNumber){
  List<JSONObject> allModels=getAllModelsByCategoryId(categoryId);
  int modelsNumber=allModels.size();
  if (modelsNumber == 0) {
    return new Pair<Integer,List<JSONObject>>(1,new ArrayList<JSONObject>());
  }
  int pagesNumber=modelsNumber % MODELS_ON_PAGE_NUM == 0 ? modelsNumber / MODELS_ON_PAGE_NUM : modelsNumber / MODELS_ON_PAGE_NUM + 1;
  int indexFrom, indexTo;
  if (pageNumber < pagesNumber) {
    indexFrom=(pageNumber - 1) * MODELS_ON_PAGE_NUM;
    indexTo=pageNumber * MODELS_ON_PAGE_NUM - 1;
  }
 else   if (pageNumber == pagesNumber) {
    indexFrom=(pageNumber - 1) * MODELS_ON_PAGE_NUM;
    indexTo=modelsNumber - 1;
  }
 else {
    indexFrom=0;
    indexTo=pagesNumber > 1 ? MODELS_ON_PAGE_NUM - 1 : modelsNumber - 1;
  }
  return new Pair<Integer,List<JSONObject>>(pagesNumber,allModels.subList(indexFrom,indexTo));
}"
87527,"private List<JSONObject> getNextLevelChildCategories(JSONObject parentCategory){
  List<JSONObject> childCategories=new ArrayList<JSONObject>();
  try {
    int childrenCount=parentCategory.getInt(JSONKeys.CHILDREN_COUNT.getKey());
    if (childrenCount != 0) {
      int pageCount=(childrenCount / COUNT_MAX_VALUE) + 1;
      for (Integer pageNum=1; pageNum <= pageCount; pageNum++) {
        long currId=parentCategory.getLong(JSONKeys.ID.getKey());
        CategoryRequestBuilder categoryRequestBuilder=new CategoryRequestBuilder();
        Map<String,String> parameters=new HashMap<String,String>();
        parameters.put(RequestParams.COUNT.getKey(),COUNT_MAX_VALUE.toString());
        parameters.put(RequestParams.PAGE.getKey(),pageNum.toString());
        UrlRequest urlRequest=categoryRequestBuilder.requestForListOfChildrenCategoriesById(currId,parameters);
        try {
          JSONObject mainObject=getContentApiProvider().provide(urlRequest);
          childCategories.addAll(JSONUtil.extractList(mainObject,JSONKeys.ITEMS.getKey(),JSONKeys.CATEGORIES.getKey()));
        }
 catch (        HTTPException e) {
          log.error(""String_Node_Str"" + e.getMessage());
        }
catch (        IOException e) {
          log.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ urlRequest.getUrl());
        }
catch (        JSONException e) {
          log.error(""String_Node_Str"" + ""String_Node_Str"" + urlRequest.getUrl(),e);
        }
      }
    }
  }
 catch (  JSONException e) {
    log.error(""String_Node_Str"",e);
  }
  return childCategories;
}","private List<JSONObject> getNextLevelChildCategories(JSONObject parentCategory){
  List<JSONObject> childCategories=new ArrayList<JSONObject>();
  try {
    int childrenCount=parentCategory.getInt(JSONKeys.CHILDREN_COUNT.getKey());
    if (childrenCount != 0) {
      int pageCount=(childrenCount % COUNT_MAX_VALUE == 0) ? (childrenCount / COUNT_MAX_VALUE) : (childrenCount / COUNT_MAX_VALUE) + 1;
      for (Integer pageNum=1; pageNum <= pageCount; pageNum++) {
        long currId=parentCategory.getLong(JSONKeys.ID.getKey());
        CategoryRequestBuilder categoryRequestBuilder=new CategoryRequestBuilder();
        Map<String,String> parameters=new HashMap<String,String>();
        parameters.put(RequestParams.COUNT.getKey(),COUNT_MAX_VALUE.toString());
        parameters.put(RequestParams.PAGE.getKey(),pageNum.toString());
        UrlRequest urlRequest=categoryRequestBuilder.requestForListOfChildrenCategoriesById(currId,parameters);
        try {
          JSONObject mainObject=getContentApiProvider().provide(urlRequest);
          childCategories.addAll(JSONUtil.extractList(mainObject,JSONKeys.ITEMS.getKey(),JSONKeys.CATEGORIES.getKey()));
        }
 catch (        HTTPException e) {
          log.error(""String_Node_Str"" + e.getMessage());
        }
catch (        IOException e) {
          log.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ urlRequest.getUrl());
        }
catch (        JSONException e) {
          log.error(""String_Node_Str"" + ""String_Node_Str"" + urlRequest.getUrl(),e);
        }
      }
    }
  }
 catch (  JSONException e) {
    log.error(""String_Node_Str"",e);
  }
  return childCategories;
}"
87528,"private List<JSONObject> grabModels(List<JSONObject> categories){
  List<JSONObject> models=new ArrayList<JSONObject>();
  log.info(""String_Node_Str"");
  for (  JSONObject category : categories) {
    try {
      long categoryId=category.getLong(JSONKeys.ID.getKey());
      int modelsNum=category.getInt(JSONKeys.MODELS_NUM.getKey());
      if (modelsNum != 0) {
        int pageCount=(modelsNum / COUNT_MAX_VALUE) + 1;
        for (Integer pageNum=1; pageNum <= pageCount; pageNum++) {
          CategoryRequestBuilder categoryRequestBuilder=new CategoryRequestBuilder();
          Map<String,String> parameters=new HashMap<String,String>();
          parameters.put(RequestParams.COUNT.getKey(),COUNT_MAX_VALUE.toString());
          parameters.put(RequestParams.PAGE.getKey(),pageNum.toString());
          UrlRequest urlRequest=categoryRequestBuilder.requestForListOfModelsOfCategoryById(categoryId,parameters);
          try {
            JSONObject mainObject=contentApiProvider.provide(urlRequest);
            List<JSONObject> modelsList=JSONUtil.extractList(mainObject,JSONKeys.ITEMS.getKey(),JSONKeys.MODELS.getKey());
            processEntityList(modelsList);
            models.addAll(modelsList);
          }
 catch (          HTTPException e) {
            log.error(""String_Node_Str"" + e.getMessage());
          }
catch (          IOException e) {
            log.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ urlRequest.getUrl());
          }
catch (          JSONException e) {
            log.error(""String_Node_Str"" + ""String_Node_Str"" + urlRequest.getUrl(),e);
          }
        }
      }
    }
 catch (    JSONException e) {
      log.error(""String_Node_Str"",e);
    }
  }
  log.info(""String_Node_Str"");
  return models;
}","private List<JSONObject> grabModels(List<JSONObject> categories){
  List<JSONObject> models=new ArrayList<JSONObject>();
  log.info(""String_Node_Str"");
  for (  JSONObject category : categories) {
    try {
      long categoryId=category.getLong(JSONKeys.ID.getKey());
      int modelsNum=category.getInt(JSONKeys.MODELS_NUM.getKey());
      if (modelsNum != 0) {
        int pageCount=(modelsNum % COUNT_MAX_VALUE == 0) ? (modelsNum / COUNT_MAX_VALUE) : (modelsNum / COUNT_MAX_VALUE) + 1;
        for (Integer pageNum=1; pageNum <= pageCount; pageNum++) {
          CategoryRequestBuilder categoryRequestBuilder=new CategoryRequestBuilder();
          Map<String,String> parameters=new HashMap<String,String>();
          parameters.put(RequestParams.COUNT.getKey(),COUNT_MAX_VALUE.toString());
          parameters.put(RequestParams.PAGE.getKey(),pageNum.toString());
          UrlRequest urlRequest=categoryRequestBuilder.requestForListOfModelsOfCategoryById(categoryId,parameters);
          try {
            JSONObject mainObject=contentApiProvider.provide(urlRequest);
            List<JSONObject> modelsList=JSONUtil.extractList(mainObject,JSONKeys.ITEMS.getKey(),JSONKeys.MODELS.getKey());
            processEntityList(modelsList);
            models.addAll(modelsList);
          }
 catch (          HTTPException e) {
            log.error(""String_Node_Str"" + e.getMessage());
          }
catch (          IOException e) {
            log.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ urlRequest.getUrl());
          }
catch (          JSONException e) {
            log.error(""String_Node_Str"" + ""String_Node_Str"" + urlRequest.getUrl(),e);
          }
        }
      }
    }
 catch (    JSONException e) {
      log.error(""String_Node_Str"",e);
    }
  }
  log.info(""String_Node_Str"");
  return models;
}"
87529,"private List<JSONObject> grabReviews(List<JSONObject> models){
  List<JSONObject> reviews=new ArrayList<JSONObject>();
  log.info(""String_Node_Str"");
  for (  JSONObject model : models) {
    try {
      long modelId=model.getLong(JSONKeys.ID.getKey());
      Map<String,String> parameters=new HashMap<String,String>();
      parameters.put(RequestParams.COUNT.getKey(),COUNT_MAX_VALUE.toString());
      parameters.put(RequestParams.PAGE.getKey(),""String_Node_Str"");
      OpinionRequestBuilder opinionRequestBuilder=new OpinionRequestBuilder();
      UrlRequest urlRequest=opinionRequestBuilder.requestForOpinionOnModelById(modelId,parameters);
      List<JSONObject> reviewsList=null;
      try {
        JSONObject mainObject=contentApiProvider.provide(urlRequest);
        reviewsList=JSONUtil.extractList(mainObject,JSONKeys.OPINION.getKey(),JSONKeys.MODEL_OPINIONS.getKey());
        setModelId(reviewsList,modelId);
        processEntityList(reviewsList);
        reviews.addAll(reviewsList);
        int opinionsCount=mainObject.getInt(JSONKeys.TOTAL.getKey());
        if (opinionsCount > COUNT_MAX_VALUE) {
          int pageCount=(opinionsCount / COUNT_MAX_VALUE) + 1;
          for (Integer pageNum=2; pageNum <= pageCount; pageNum++) {
            parameters=new HashMap<String,String>();
            parameters.put(RequestParams.COUNT.getKey(),COUNT_MAX_VALUE.toString());
            parameters.put(RequestParams.PAGE.getKey(),pageNum.toString());
            urlRequest=opinionRequestBuilder.requestForOpinionOnModelById(modelId,parameters);
            try {
              mainObject=contentApiProvider.provide(urlRequest);
              reviewsList=JSONUtil.extractList(mainObject,JSONKeys.OPINION.getKey(),JSONKeys.MODEL_OPINIONS.getKey());
              setModelId(reviewsList,modelId);
              processEntityList(reviewsList);
              reviews.addAll(reviewsList);
            }
 catch (            HTTPException e) {
              log.error(""String_Node_Str"" + e.getMessage());
            }
catch (            IOException e) {
              log.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ urlRequest.getUrl());
            }
catch (            JSONException e) {
              log.error(""String_Node_Str"" + ""String_Node_Str"" + urlRequest.getUrl(),e);
            }
          }
        }
        setOpinionsCount(model,opinionsCount);
      }
 catch (      HTTPException e) {
        log.error(""String_Node_Str"" + e.getMessage());
      }
catch (      IOException e) {
        log.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ urlRequest.getUrl());
      }
catch (      JSONException e) {
        log.error(""String_Node_Str"" + ""String_Node_Str"" + urlRequest.getUrl(),e);
      }
    }
 catch (    JSONException e) {
      log.error(""String_Node_Str"",e);
    }
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  update(models);
  log.info(""String_Node_Str"");
  return reviews;
}","private List<JSONObject> grabReviews(List<JSONObject> models){
  List<JSONObject> reviews=new ArrayList<JSONObject>();
  log.info(""String_Node_Str"");
  for (  JSONObject model : models) {
    try {
      long modelId=model.getLong(JSONKeys.ID.getKey());
      Map<String,String> parameters=new HashMap<String,String>();
      parameters.put(RequestParams.COUNT.getKey(),COUNT_MAX_VALUE.toString());
      parameters.put(RequestParams.PAGE.getKey(),""String_Node_Str"");
      OpinionRequestBuilder opinionRequestBuilder=new OpinionRequestBuilder();
      UrlRequest urlRequest=opinionRequestBuilder.requestForOpinionOnModelById(modelId,parameters);
      List<JSONObject> reviewsList=null;
      try {
        JSONObject mainObject=contentApiProvider.provide(urlRequest);
        reviewsList=JSONUtil.extractList(mainObject,JSONKeys.OPINION.getKey(),JSONKeys.MODEL_OPINIONS.getKey());
        setModelId(reviewsList,modelId);
        processEntityList(reviewsList);
        reviews.addAll(reviewsList);
        int opinionsCount=mainObject.getInt(JSONKeys.TOTAL.getKey());
        if (opinionsCount > COUNT_MAX_VALUE) {
          int pageCount=(opinionsCount % COUNT_MAX_VALUE == 0) ? (opinionsCount / COUNT_MAX_VALUE) : (opinionsCount / COUNT_MAX_VALUE) + 1;
          for (Integer pageNum=2; pageNum <= pageCount; pageNum++) {
            parameters=new HashMap<String,String>();
            parameters.put(RequestParams.COUNT.getKey(),COUNT_MAX_VALUE.toString());
            parameters.put(RequestParams.PAGE.getKey(),pageNum.toString());
            urlRequest=opinionRequestBuilder.requestForOpinionOnModelById(modelId,parameters);
            try {
              mainObject=contentApiProvider.provide(urlRequest);
              reviewsList=JSONUtil.extractList(mainObject,JSONKeys.OPINION.getKey(),JSONKeys.MODEL_OPINIONS.getKey());
              setModelId(reviewsList,modelId);
              processEntityList(reviewsList);
              reviews.addAll(reviewsList);
            }
 catch (            HTTPException e) {
              log.error(""String_Node_Str"" + e.getMessage());
            }
catch (            IOException e) {
              log.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ urlRequest.getUrl());
            }
catch (            JSONException e) {
              log.error(""String_Node_Str"" + ""String_Node_Str"" + urlRequest.getUrl(),e);
            }
          }
        }
        setOpinionsCount(model,opinionsCount);
      }
 catch (      HTTPException e) {
        log.error(""String_Node_Str"" + e.getMessage());
      }
catch (      IOException e) {
        log.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ urlRequest.getUrl());
      }
catch (      JSONException e) {
        log.error(""String_Node_Str"" + ""String_Node_Str"" + urlRequest.getUrl(),e);
      }
    }
 catch (    JSONException e) {
      log.error(""String_Node_Str"",e);
    }
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  update(models);
  log.info(""String_Node_Str"");
  return reviews;
}"
87530,"@Override protected void setValues(PreparedStatement ps,JSONObject element) throws SQLException {
  try {
    ps.setString(1,element.toString());
    ps.setLong(2,Long.parseLong(element.getString(EntityType.TYPE_ID_ATTR)));
    ps.setLong(3,Long.parseLong(element.getString(ID_ATTR)));
  }
 catch (  JSONException e) {
    log.error(""String_Node_Str"",e);
    throw new RuntimeException(e);
  }
}","@Override protected void setValues(final PreparedStatement ps,final JSONObject element) throws SQLException {
  try {
    ps.setString(1,element.toString());
    ps.setLong(2,Long.parseLong(element.getString(EntityType.TYPE_ID_ATTR)));
    ps.setLong(3,Long.parseLong(element.getString(ID_ATTR)));
  }
 catch (  JSONException e) {
    log.error(""String_Node_Str"" + element,e);
  }
}"
87531,"public void improveEntities(final Collection<JSONObject> entities){
  jdbcTemplate.update(""String_Node_Str"",new IterativeBatchPreparedStatementSetter<JSONObject>(entities){
    @Override protected void setValues(    PreparedStatement ps,    JSONObject element) throws SQLException {
      try {
        ps.setString(1,element.toString());
        ps.setLong(2,Long.parseLong(element.getString(EntityType.TYPE_ID_ATTR)));
        ps.setLong(3,Long.parseLong(element.getString(ID_ATTR)));
      }
 catch (      JSONException e) {
        log.error(""String_Node_Str"",e);
        throw new RuntimeException(e);
      }
    }
  }
);
}","public void improveEntities(final Collection<JSONObject> entities){
  jdbcTemplate.batchUpdate(""String_Node_Str"",new IterativeBatchPreparedStatementSetter<JSONObject>(entities){
    @Override protected void setValues(    final PreparedStatement ps,    final JSONObject element) throws SQLException {
      try {
        ps.setString(1,element.toString());
        ps.setLong(2,Long.parseLong(element.getString(EntityType.TYPE_ID_ATTR)));
        ps.setLong(3,Long.parseLong(element.getString(ID_ATTR)));
      }
 catch (      JSONException e) {
        log.error(""String_Node_Str"" + element,e);
      }
    }
  }
);
}"
87532,"@Test public void testEClass() throws Exception {
  XtextResourceSet rs=resourceSetProvider.get();
  URI xCoreURI=getURI(""String_Node_Str"",""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") Resource xCoreResoure=rs.getResource(xCoreURI,true);
  Greeting g=parseHelper.parse(""String_Node_Str"",rs);
  validationHelper.assertNoErrors(g);
  EClass anEClass=g.getEClass();
  assertEquals(""String_Node_Str"",anEClass.getName());
  EObject eObject=anEClass.getEPackage().getEFactoryInstance().create(anEClass);
  assertTrue(eObject.getClass().toString(),eObject instanceof TestModel);
}","@Test public void testEClass() throws Exception {
  XtextResourceSet rs=resourceSetProvider.get();
  Resource rx=rs.getResource(URI.createURI(""String_Node_Str""),true);
  Resource rx2=rs.getResource(URI.createURI(""String_Node_Str""),true);
  rx.load(null);
  rx2.load(null);
  URI xCoreURI=getURI(""String_Node_Str"",""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") Resource xCoreResoure=rs.getResource(xCoreURI,true);
  validationHelper.assertNoErrors(xCoreResoure.getContents().get(0));
  Greeting g=parseHelper.parse(""String_Node_Str"",rs);
  validationHelper.assertNoErrors(g);
  EClass anEClass=g.getEClass();
  assertEquals(""String_Node_Str"",anEClass.getName());
  EObject eObject=anEClass.getEPackage().getEFactoryInstance().create(anEClass);
  assertTrue(eObject.getClass().toString(),eObject instanceof TestModel);
}"
87533,"@Override public void accessed(PropertyChangeNotifier cn){
  cn.setChangeListener(ThreadLocal.get());
}","@Override public void accessed(PropertyChangeNotifier cn){
  if (ThreadLocal.get() != null)   cn.setChangeListener(ThreadLocal.get());
}"
87534,"@After public void tearDown(){
  db.dispose();
}","@After public void tearDown(){
}"
87535,"/** 
 * Tests that using an EObject in observe(), like the EMFProperties Data Binding API expects fails. The XtextProperties Data Binding API needs to be observing an XTextDocument (IReadAccess<XtextResource>, IWriteAccess<XtextResource>). 
 */
@Test public void testErrorObserveObjectInsteadOfResourceAcess(){
  Binding binding1=db.bindValue(BeanProperties.value(""String_Node_Str"").observe(bean),EMFXtextProperties.value(titleFeature).observe(eObject));
  bean.setName(""String_Node_Str"");
  assertIllegalArgumentExceptionValidationError(binding1);
  db.removeBinding(binding1);
}","/** 
 * Tests that using an EObject in observe(), like the EMFProperties Data Binding API expects fails. The XtextProperties Data Binding API needs to be observing an XTextDocument (IReadAccess<XtextResource>, IWriteAccess<XtextResource>). 
 */
@Test(expected=IllegalArgumentException.class) public void testErrorObserveObjectInsteadOfResourceAcess(){
  Binding binding1=db.bindValue(BeanProperties.value(""String_Node_Str"").observe(bean),EMFXtextProperties.value(titleFeature).observe(eObject));
}"
87536,"public static IEMFValueProperty value(FeaturePath featurePath){
  IValueProperty property;
  property=new EMFXtextValueProperty(featurePath.getFeaturePath()[0]);
  IEMFValueProperty featureProperty=new XtextValuePropertyDecorator(property,featurePath.getFeaturePath()[0]);
  for (int i=1; i < featurePath.getFeaturePath().length; i++) {
    featureProperty=featureProperty.value(featurePath.getFeaturePath()[i]);
  }
  return featureProperty;
}","public static IXtextValueProperty value(FeaturePath featurePath){
  IValueProperty property;
  property=new EMFXtextValueProperty(featurePath.getFeaturePath()[0]);
  IXtextValueProperty featureProperty=new XtextValuePropertyDecorator(property,featurePath.getFeaturePath()[0]);
  for (int i=1; i < featurePath.getFeaturePath().length; i++) {
    featureProperty=featureProperty.value(featurePath.getFeaturePath()[i]);
  }
  return featureProperty;
}"
87537,"@Override protected Object doSafeGetValue(final Object source){
  if (source instanceof IReadAccess<?>) {
    IReadAccess<XtextResource> access=(IReadAccess<XtextResource>)source;
    return access.readOnly(new IUnitOfWork<Object,XtextResource>(){
      @Override public Object exec(      XtextResource resource) throws Exception {
        EObject eObject=resource.getContents().get(0);
        return EMFXtextValueProperty.super.doSafeGetValue(eObject);
      }
    }
);
  }
 else   if (source instanceof Resource) {
    Resource resource=(Resource)source;
    EObject eObject=resource.getContents().get(0);
    return EMFXtextValueProperty.super.doSafeGetValue(eObject);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + source);
  }
}","@Override protected Object doSafeGetValue(final Object source){
  SourceAccessor sourceAccessor=(SourceAccessor)source;
  return sourceAccessor.eGet(getFeature());
}"
87538,"@Override protected void doSafeSetValue(final Object source,final Object value){
  if (source instanceof IWriteAccess<?>) {
    IWriteAccess<XtextResource> access=(IWriteAccess<XtextResource>)source;
    access.modify(new IUnitOfWork.Void<XtextResource>(){
      @Override public void process(      XtextResource state) throws Exception {
        EObject eObject=state.getContents().get(0);
        eObject.eSet(EMFXtextValueProperty.this.getFeature(),value);
      }
    }
);
  }
 else   if (source instanceof Resource) {
    Resource resource=(Resource)source;
    EObject eObject=resource.getContents().get(0);
    eObject.eSet(EMFXtextValueProperty.this.getFeature(),value);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + source);
  }
}","@Override protected void doSafeSetValue(final Object source,final Object value){
  SourceAccessor sourceAccessor=(SourceAccessor)source;
  sourceAccessor.eSet(getFeature(),value);
}"
87539,"@Override public void addTo(Object source){
  if (source != null) {
    getResource(source).eAdapters().add(this);
  }
}","@Override public void addTo(Object source){
  SourceAccessor sourceAccessor=(SourceAccessor)source;
  sourceAccessor.addAdapter(this);
}"
87540,"@Override public void removeFrom(Object source){
  if (source != null) {
    getResource(source).eAdapters().remove(this);
  }
}","@Override public void removeFrom(Object source){
  SourceAccessor sourceAccessor=(SourceAccessor)source;
  sourceAccessor.removeAdapter(this);
}"
87541,"/** 
 * Here is the scenario : - fact is the last word of a string - some regex based rules with logged actions log each matches as : <code>'[fact]' triggers [rule]</code> - If action occurs, log success
 */
@Test public void testScenario(){
  String token1=""String_Node_Str"";
  String token2=""String_Node_Str"";
  String token3=""String_Node_Str"";
  String token4=""String_Node_Str"";
  String token5=""String_Node_Str"";
  RegexRule lcRule=new RegexRule(""String_Node_Str"",""String_Node_Str"");
  lcRule.addCommand(new LogFactVerbRuleCommand(""String_Node_Str""));
  RegexRule domainRule=new RegexRule(""String_Node_Str"",""String_Node_Str"");
  domainRule.addCommand(new LogFactVerbRuleCommand(""String_Node_Str""));
  RegexRule instanceRule=new RegexRule(""String_Node_Str"",""String_Node_Str"");
  instanceRule.addCommand(new LogFactVerbRuleCommand(""String_Node_Str""));
  RegexRule withRule=new RegexRule(""String_Node_Str"",""String_Node_Str"");
  withRule.addCommand(new LogFactVerbRuleCommand(""String_Node_Str""));
  SingleFactRulesEngine engine=new SingleFactRulesEngine(OrderMode.INSERT);
  engine.addRule(lcRule);
  engine.addRule(domainRule);
  engine.addRule(instanceRule);
  engine.addRule(withRule);
  System.out.println(""String_Node_Str"");
  engine.processFact(token1);
  System.out.println(""String_Node_Str"");
  engine.processFact(token2);
  System.out.println(""String_Node_Str"");
  engine.processFact(token3);
  System.out.println(""String_Node_Str"");
  engine.processFact(token4);
  System.out.println(""String_Node_Str"");
  engine.processFact(token5);
  Report ctx=engine.getReport();
  engine.clearReport();
  Assert.assertTrue(""String_Node_Str"",ctx.contains(""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"",ctx.contains(""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token3 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token3 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token3 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token3 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token4 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token4 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token4 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token4 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token4 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token4 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token5 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token5 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token5 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token5 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token5 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token5 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token5 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token5 + ""String_Node_Str""));
}","/** 
 * Here is the scenario : - fact is the last word of a string - some regex based rules with logged actions log each matches as : <code>'[fact]' triggers [rule]</code> - If action occurs, log success
 */
@Test public void testScenario(){
  String token1=""String_Node_Str"";
  String token2=""String_Node_Str"";
  String token3=""String_Node_Str"";
  String token4=""String_Node_Str"";
  String token5=""String_Node_Str"";
  RegexRule lcRule=new RegexRule(""String_Node_Str"",""String_Node_Str"");
  lcRule.addCommand(new LogFactVerbRuleCommand(""String_Node_Str""));
  RegexRule domainRule=new RegexRule(""String_Node_Str"",""String_Node_Str"");
  domainRule.addCommand(new LogFactVerbRuleCommand(""String_Node_Str""));
  RegexRule instanceRule=new RegexRule(""String_Node_Str"",""String_Node_Str"");
  instanceRule.addCommand(new LogFactVerbRuleCommand(""String_Node_Str""));
  RegexRule withRule=new RegexRule(""String_Node_Str"",""String_Node_Str"");
  withRule.addCommand(new LogFactVerbRuleCommand(""String_Node_Str""));
  SingleFactRulesEngine engine=new SingleFactRulesEngine(OrderMode.INSERT);
  engine.addRule(lcRule);
  engine.addRule(domainRule);
  engine.addRule(instanceRule);
  engine.addRule(withRule);
  System.out.println(""String_Node_Str"");
  engine.processFact(token1);
  System.out.println(""String_Node_Str"");
  engine.processFact(token2);
  System.out.println(""String_Node_Str"");
  engine.processFact(token3);
  System.out.println(""String_Node_Str"");
  engine.processFact(token4);
  System.out.println(""String_Node_Str"");
  engine.processFact(token5);
  Report ctx=engine.getReport();
  Assert.assertTrue(""String_Node_Str"",ctx.contains(""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"",ctx.contains(""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token3 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token3 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token3 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token3 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token4 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token4 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token4 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token4 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token4 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token4 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token5 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token5 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token5 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token5 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token5 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token5 + ""String_Node_Str""));
  Assert.assertTrue(""String_Node_Str"" + token5 + ""String_Node_Str"",ctx.contains(""String_Node_Str"" + token5 + ""String_Node_Str""));
}"
87542,"@Override public void execute(Object fact,Report context){
  ArrayList<String> matches=new ArrayList<String>();
  matches=getMatches(fact.toString(),pattern);
  if (matches.size() > 0) {
    Log.debug(""String_Node_Str"" + this + ""String_Node_Str""+ fact+ ""String_Node_Str"");
    try {
      setReport(context);
      setFact(fact);
      executeCommands();
    }
 catch (    Exception e) {
    }
  }
}","@Override public void execute(Object fact,Report context){
  ArrayList<String> matches=new ArrayList<String>();
  matches=getMatches(fact.toString(),pattern);
  if (matches.size() > 0) {
    Log.debug(""String_Node_Str"" + this + ""String_Node_Str""+ fact+ ""String_Node_Str"");
    setReport(context);
    setFact(fact);
    executeCommands();
  }
}"
87543,"/** 
 * Returns the query.
 * @return the query
 */
public SopremoPlan getQuery(){
  if (this.query != null || this.planBuffer == null)   return this.query;
  final JobID dummId=new JobID();
  try {
    LibraryCacheManager.register(dummId,this.requiredPackages.toArray(new String[this.requiredPackages.size()]));
    this.query=SopremoUtil.byteArrayToSerializable(this.planBuffer,LibraryCacheManager.getClassLoader(dummId));
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      LibraryCacheManager.unregister(dummId);
    }
 catch (    IOException e) {
    }
  }
  return this.query;
}","/** 
 * Returns the query.
 * @return the query
 */
public SopremoPlan getQuery(){
  if (this.query != null || this.planBuffer == null)   return this.query;
  final JobID dummId=new JobID();
  try {
    LibraryCacheManager.register(dummId,this.requiredPackages.toArray(new String[this.requiredPackages.size()]));
    this.query=SopremoUtil.byteArrayToSerializable(this.planBuffer,SopremoPlan.class,LibraryCacheManager.getClassLoader(dummId));
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      LibraryCacheManager.unregister(dummId);
    }
 catch (    IOException e) {
    }
  }
  return this.query;
}"
87544,"@SuppressWarnings(""String_Node_Str"") public static <T extends Serializable>T byteArrayToSerializable(byte[] buffer,final ClassLoader classLoader) throws IOException {
  final ObjectInputStream ois=new ObjectInputStream(new ByteArrayInputStream(buffer)){
    @Override protected Class<?> resolveClass(    ObjectStreamClass desc) throws IOException, ClassNotFoundException {
      try {
        return classLoader.loadClass(desc.getName());
      }
 catch (      ClassNotFoundException e) {
        return super.resolveClass(desc);
      }
    }
  }
;
  try {
    return (T)ois.readObject();
  }
 catch (  ClassNotFoundException e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}","@SuppressWarnings(""String_Node_Str"") public static <T extends Serializable>T byteArrayToSerializable(byte[] buffer,Class<T> clazz,final ClassLoader classLoader) throws IOException {
  final ObjectInputStream ois=new ObjectInputStream(new ByteArrayInputStream(buffer)){
    @Override protected Class<?> resolveClass(    ObjectStreamClass desc) throws IOException, ClassNotFoundException {
      try {
        return classLoader.loadClass(desc.getName());
      }
 catch (      ClassNotFoundException e) {
        return super.resolveClass(desc);
      }
    }
  }
;
  try {
    return (T)ois.readObject();
  }
 catch (  ClassNotFoundException e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}"
87545,"/** 
 * Deserializes an   {@link Serializable} from a {@link DataInput}.<br> Please note that this method is not very efficient.
 */
public static <T extends Serializable>T deserializeObject(DataInput in,Class<T> clazz) throws IOException {
  byte[] buffer=new byte[in.readInt()];
  in.readFully(buffer);
  return byteArrayToSerializable(buffer,clazz.getClassLoader());
}","/** 
 * Deserializes an   {@link Serializable} from a {@link DataInput}.<br> Please note that this method is not very efficient.
 */
public static <T extends Serializable>T deserializeObject(DataInput in,Class<T> clazz) throws IOException {
  byte[] buffer=new byte[in.readInt()];
  in.readFully(buffer);
  return byteArrayToSerializable(buffer,clazz,clazz.getClassLoader());
}"
87546,"/** 
 * Tests whether the job manager has been shut down completely.
 * @return <code>true</code> if the job manager has been shut down completely, <code>false</code> otherwise
 */
public boolean isShutDown(){
  return this.isShutDown.get();
}","/** 
 * Tests whether the job manager has been shut down completely.
 * @return <code>true</code> if the job manager has been shut down completely, <code>false</code> otherwise
 */
public boolean isShutDown(){
  return this.isShutDown;
}"
87547,"public void shutdown(){
  if (this.isShutDown.compareAndSet(false,true)) {
    return;
  }
  if (this.instanceManager != null) {
    this.instanceManager.shutdown();
  }
  DiscoveryService.stopDiscoveryService();
  if (this.profiler != null) {
    this.profiler.shutdown();
  }
  if (this.jobManagerServer != null) {
    this.jobManagerServer.stop();
  }
  if (this.executorService != null) {
    this.executorService.shutdown();
    try {
      this.executorService.awaitTermination(5000L,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(StringUtils.stringifyException(e));
      }
    }
  }
  final Iterator<JobManagerPlugin> it=this.jobManagerPlugins.values().iterator();
  while (it.hasNext()) {
    it.next().shutdown();
  }
  if (this.eventCollector != null) {
    this.eventCollector.shutdown();
  }
  if (this.scheduler != null) {
    this.scheduler.shutdown();
  }
  this.isShutDown.set(true);
  LOG.debug(""String_Node_Str"");
}","public void shutdown(){
  if (!this.isShutdownInProgress.compareAndSet(false,true)) {
    return;
  }
  if (this.instanceManager != null) {
    this.instanceManager.shutdown();
  }
  DiscoveryService.stopDiscoveryService();
  if (this.profiler != null) {
    this.profiler.shutdown();
  }
  if (this.jobManagerServer != null) {
    this.jobManagerServer.stop();
  }
  if (this.executorService != null) {
    this.executorService.shutdown();
    try {
      this.executorService.awaitTermination(5000L,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(StringUtils.stringifyException(e));
      }
    }
  }
  final Iterator<JobManagerPlugin> it=this.jobManagerPlugins.values().iterator();
  while (it.hasNext()) {
    it.next().shutdown();
  }
  if (this.eventCollector != null) {
    this.eventCollector.shutdown();
  }
  if (this.scheduler != null) {
    this.scheduler.shutdown();
  }
  this.isShutDown=true;
  LOG.debug(""String_Node_Str"");
}"
87548,"private void process(String[] args){
  CommandLine cmd=this.parseOptions(args);
  final SopremoPlan plan=this.parseScript(cmd);
  this.configureClient(cmd);
  this.sopremoClient.submit(plan,new StateListener(){
    @Override public void stateChanged(    ExecutionState executionState,    String detail){
switch (executionState) {
case ENQUEUED:
        System.out.print(""String_Node_Str"");
      break;
case RUNNING:
    System.out.print(""String_Node_Str"");
  break;
case FINISHED:
System.out.println(""String_Node_Str"" + detail);
break;
case ERROR:
System.err.println(""String_Node_Str"" + detail);
break;
}
}
@Override public void progressUpdate(ExecutionState status,String detail){
super.progressUpdate(status,detail);
System.out.print(""String_Node_Str"");
}
}
,cmd.hasOption(""String_Node_Str""));
this.sopremoClient.close();
}","private void process(String[] args){
  CommandLine cmd=this.parseOptions(args);
  final SopremoPlan plan=this.parseScript(cmd);
  this.configureClient(cmd);
  this.sopremoClient.submit(plan,new StateListener(){
    @Override public void stateChanged(    ExecutionState executionState,    String detail){
      System.out.println();
switch (executionState) {
case ENQUEUED:
        System.out.print(""String_Node_Str"");
      break;
case RUNNING:
    System.out.print(""String_Node_Str"");
  break;
case FINISHED:
System.out.print(detail);
break;
case ERROR:
System.out.print(detail);
break;
}
}
@Override protected void stateNotChanged(ExecutionState state,String detail){
System.out.print(""String_Node_Str"");
}
}
,cmd.hasOption(""String_Node_Str""));
this.sopremoClient.close();
}"
87549,"protected void dealWithError(Exception e,final String message){
  System.err.print(message);
  if (e != null) {
    System.err.print(""String_Node_Str"");
    System.err.print(e);
  }
  System.err.println();
  System.exit(1);
}","protected void dealWithError(Exception e,final String message,Object... args){
  System.err.print(String.format(message,args));
  if (e != null) {
    System.err.print(""String_Node_Str"");
    System.err.print(e);
  }
  System.err.println();
  System.exit(1);
}"
87550,"@Override public void stateChanged(ExecutionState executionState,String detail){
switch (executionState) {
case ENQUEUED:
    System.out.print(""String_Node_Str"");
  break;
case RUNNING:
System.out.print(""String_Node_Str"");
break;
case FINISHED:
System.out.println(""String_Node_Str"" + detail);
break;
case ERROR:
System.err.println(""String_Node_Str"" + detail);
break;
}
}","@Override public void stateChanged(ExecutionState executionState,String detail){
  System.out.println();
switch (executionState) {
case ENQUEUED:
    System.out.print(""String_Node_Str"");
  break;
case RUNNING:
System.out.print(""String_Node_Str"");
break;
case FINISHED:
System.out.print(detail);
break;
case ERROR:
System.out.print(detail);
break;
}
}"
87551,"private SopremoPlan parseScript(CommandLine cmd){
  File file=new File(cmd.getOptionValue(""String_Node_Str""));
  if (!file.exists())   this.dealWithError(null,""String_Node_Str"");
  try {
    return new QueryParser().tryParse(new FileInputStream(file));
  }
 catch (  IOException e) {
    this.dealWithError(e,""String_Node_Str"");
    return null;
  }
}","private SopremoPlan parseScript(CommandLine cmd){
  File file=new File(cmd.getOptionValue(""String_Node_Str""));
  if (!file.exists())   this.dealWithError(null,""String_Node_Str"",file);
  try {
    return new QueryParser().tryParse(new FileInputStream(file));
  }
 catch (  IOException e) {
    this.dealWithError(e,""String_Node_Str"");
    return null;
  }
}"
87552,"private void configureClient(CommandLine cmd){
  String configDir=cmd.getOptionValue(""String_Node_Str"");
  GlobalConfiguration.loadConfiguration(configDir);
  this.sopremoClient=new DefaultClient();
  int updateTime=1000;
  if (cmd.hasOption(""String_Node_Str""))   updateTime=Integer.parseInt(cmd.getOptionValue(""String_Node_Str""));
  this.sopremoClient.setUpdateTime(updateTime);
  String address=cmd.getOptionValue(""String_Node_Str""), port=cmd.getOptionValue(""String_Node_Str"");
  if (address != null || port != null) {
    this.sopremoClient.setServerAddress(new InetSocketAddress(address == null ? ""String_Node_Str"" : address,port == null ? SopremoConstants.DEFAULT_SOPREMO_SERVER_IPC_PORT : Integer.parseInt(port)));
  }
  this.sopremoClient.setExecutionMode(ExecutionMode.RUN_WITH_STATISTICS);
}","private void configureClient(CommandLine cmd){
  String configDir=cmd.getOptionValue(""String_Node_Str"");
  GlobalConfiguration.loadConfiguration(configDir);
  this.sopremoClient=new DefaultClient(GlobalConfiguration.getConfiguration());
  int updateTime=1000;
  if (cmd.hasOption(""String_Node_Str""))   updateTime=Integer.parseInt(cmd.getOptionValue(""String_Node_Str""));
  this.sopremoClient.setUpdateTime(updateTime);
  String address=cmd.getOptionValue(""String_Node_Str""), port=cmd.getOptionValue(""String_Node_Str"");
  if (address != null || port != null) {
    this.sopremoClient.setServerAddress(new InetSocketAddress(address == null ? ""String_Node_Str"" : address,port == null ? SopremoConstants.DEFAULT_SOPREMO_SERVER_IPC_PORT : Integer.parseInt(port)));
  }
  this.sopremoClient.setExecutionMode(ExecutionMode.RUN_WITH_STATISTICS);
}"
87553,"/** 
 * Private utility method that generates the alternative CoGroup nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param subPlan1 The subplan for the first input.
 * @param subPlan2 The subplan for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createCoGroupAlternative(List<OptimizerNode> target,OptimizerNode subPlan1,OptimizerNode subPlan2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  GlobalProperties gp1, gp2;
  LocalProperties lp1, lp2;
  gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
  lp1=PactConnection.getLocalPropertiesAfterConnection(subPlan1,this,ss1);
  gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,ss2);
  lp2=PactConnection.getLocalPropertiesAfterConnection(subPlan2,this,ss2);
  int[] scrambledKeyOrder1=null;
  int[] scrambledKeyOrder2=null;
  if (ss1 == ShipStrategy.FORWARD && ss2 == ShipStrategy.PARTITION_HASH) {
    scrambledKeyOrder1=getScrambledKeyOrder(this.keySet1,gp1.getPartitionedFields());
    if (scrambledKeyOrder1 != null) {
      FieldList scrambledKeys2=new FieldList();
      for (int i=0; i < scrambledKeyOrder1.length; i++) {
        scrambledKeys2.set(i,this.keySet2.get(scrambledKeyOrder1[i]));
      }
      gp2.setPartitioning(gp2.getPartitioning(),scrambledKeys2);
    }
  }
  if (ss2 == ShipStrategy.FORWARD && ss1 == ShipStrategy.PARTITION_HASH) {
    scrambledKeyOrder2=getScrambledKeyOrder(this.keySet2,gp2.getPartitionedFields());
    if (scrambledKeyOrder2 != null) {
      FieldList scrambledKeys1=new FieldList();
      for (int i=0; i < scrambledKeyOrder2.length; i++) {
        scrambledKeys1.set(i,this.keySet1.get(scrambledKeyOrder2[i]));
      }
      gp1.setPartitioning(gp1.getPartitioning(),scrambledKeys1);
    }
  }
  int[] keyColumns1=getPactContract().getKeyColumnNumbers(0);
  Ordering ordering1=new Ordering();
  for (  int keyColumn : keyColumns1) {
    ordering1.appendOrdering(keyColumn,null,Order.ASCENDING);
  }
  int[] keyColumns2=getPactContract().getKeyColumnNumbers(1);
  Ordering ordering2=new Ordering();
  for (  int keyColumn : keyColumns2) {
    ordering2.appendOrdering(keyColumn,null,Order.ASCENDING);
  }
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
  CoGroupNode n=new CoGroupNode(this,subPlan1,subPlan2,this.input1,this.input2,outGp,new LocalProperties());
  n.input1.setShipStrategy(ss1);
  n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
  n.input2.setShipStrategy(ss2);
  n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
  n.getLocalProperties().setOrdering(ordering1);
  n.getLocalProperties().setGrouped(true,new FieldSet(keyColumns1));
  if (n.getLocalStrategy() == LocalStrategy.NONE) {
    if (ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.MERGE);
    }
 else     if (!ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_FIRST_MERGE);
    }
 else     if (ordering1.isMetBy(lp1.getOrdering()) && !ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_SECOND_MERGE);
    }
 else {
      n.setLocalStrategy(LocalStrategy.SORT_BOTH_MERGE);
    }
  }
  n.getGlobalProperties().filterByNodesConstantSet(this,0);
  n.getLocalProperties().filterByNodesConstantSet(this,0);
  estimator.costOperator(n);
  target.add(n);
  outGp=new GlobalProperties();
  outGp.setPartitioning(gp2.getPartitioning(),gp2.getPartitionedFields());
  n=new CoGroupNode(this,subPlan1,subPlan2,input1,input2,outGp,new LocalProperties());
  n.input1.setShipStrategy(ss1);
  n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
  n.input2.setShipStrategy(ss2);
  n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
  n.getLocalProperties().setOrdering(ordering2);
  n.getLocalProperties().setGrouped(true,new FieldSet(keyColumns2));
  if (n.getLocalStrategy() == LocalStrategy.NONE) {
    if (ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.MERGE);
    }
 else     if (!ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_FIRST_MERGE);
    }
 else     if (ordering1.isMetBy(lp1.getOrdering()) && !ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_SECOND_MERGE);
    }
 else {
      n.setLocalStrategy(LocalStrategy.SORT_BOTH_MERGE);
    }
  }
  n.getGlobalProperties().filterByNodesConstantSet(this,1);
  n.getLocalProperties().filterByNodesConstantSet(this,1);
  estimator.costOperator(n);
  target.add(n);
}","/** 
 * Private utility method that generates the alternative CoGroup nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param subPlan1 The subplan for the first input.
 * @param subPlan2 The subplan for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createCoGroupAlternative(List<OptimizerNode> target,OptimizerNode subPlan1,OptimizerNode subPlan2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  GlobalProperties gp1, gp2;
  LocalProperties lp1, lp2;
  gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
  lp1=PactConnection.getLocalPropertiesAfterConnection(subPlan1,this,ss1);
  gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,ss2);
  lp2=PactConnection.getLocalPropertiesAfterConnection(subPlan2,this,ss2);
  int[] scrambledKeyOrder1=null;
  int[] scrambledKeyOrder2=null;
  if (ss1 == ShipStrategy.FORWARD && ss2 == ShipStrategy.PARTITION_HASH) {
    scrambledKeyOrder1=getScrambledKeyOrder(this.keySet1,gp1.getPartitionedFields());
    if (scrambledKeyOrder1 != null) {
      FieldList scrambledKeys2=new FieldList();
      for (int i=0; i < scrambledKeyOrder1.length; i++) {
        scrambledKeys2.add(this.keySet2.get(scrambledKeyOrder1[i]));
      }
      gp2.setPartitioning(gp2.getPartitioning(),scrambledKeys2);
    }
  }
  if (ss2 == ShipStrategy.FORWARD && ss1 == ShipStrategy.PARTITION_HASH) {
    scrambledKeyOrder2=getScrambledKeyOrder(this.keySet2,gp2.getPartitionedFields());
    if (scrambledKeyOrder2 != null) {
      FieldList scrambledKeys1=new FieldList();
      for (int i=0; i < scrambledKeyOrder2.length; i++) {
        scrambledKeys1.add(this.keySet1.get(scrambledKeyOrder2[i]));
      }
      gp1.setPartitioning(gp1.getPartitioning(),scrambledKeys1);
    }
  }
  int[] keyColumns1=getPactContract().getKeyColumnNumbers(0);
  Ordering ordering1=new Ordering();
  for (  int keyColumn : keyColumns1) {
    ordering1.appendOrdering(keyColumn,null,Order.ASCENDING);
  }
  int[] keyColumns2=getPactContract().getKeyColumnNumbers(1);
  Ordering ordering2=new Ordering();
  for (  int keyColumn : keyColumns2) {
    ordering2.appendOrdering(keyColumn,null,Order.ASCENDING);
  }
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
  CoGroupNode n=new CoGroupNode(this,subPlan1,subPlan2,this.input1,this.input2,outGp,new LocalProperties());
  n.input1.setShipStrategy(ss1);
  n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
  n.input2.setShipStrategy(ss2);
  n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
  n.getLocalProperties().setOrdering(ordering1);
  n.getLocalProperties().setGrouped(true,new FieldSet(keyColumns1));
  if (n.getLocalStrategy() == LocalStrategy.NONE) {
    if (ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.MERGE);
    }
 else     if (!ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_FIRST_MERGE);
    }
 else     if (ordering1.isMetBy(lp1.getOrdering()) && !ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_SECOND_MERGE);
    }
 else {
      n.setLocalStrategy(LocalStrategy.SORT_BOTH_MERGE);
    }
  }
  n.getGlobalProperties().filterByNodesConstantSet(this,0);
  n.getLocalProperties().filterByNodesConstantSet(this,0);
  estimator.costOperator(n);
  target.add(n);
  outGp=new GlobalProperties();
  outGp.setPartitioning(gp2.getPartitioning(),gp2.getPartitionedFields());
  n=new CoGroupNode(this,subPlan1,subPlan2,input1,input2,outGp,new LocalProperties());
  n.input1.setShipStrategy(ss1);
  n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
  n.input2.setShipStrategy(ss2);
  n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
  n.getLocalProperties().setOrdering(ordering2);
  n.getLocalProperties().setGrouped(true,new FieldSet(keyColumns2));
  if (n.getLocalStrategy() == LocalStrategy.NONE) {
    if (ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.MERGE);
    }
 else     if (!ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_FIRST_MERGE);
    }
 else     if (ordering1.isMetBy(lp1.getOrdering()) && !ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_SECOND_MERGE);
    }
 else {
      n.setLocalStrategy(LocalStrategy.SORT_BOTH_MERGE);
    }
  }
  n.getGlobalProperties().filterByNodesConstantSet(this,1);
  n.getLocalProperties().filterByNodesConstantSet(this,1);
  estimator.costOperator(n);
  target.add(n);
}"
87554,"/** 
 * Private utility method that generates a candidate Match node, given fixed shipping strategies and a fixed local strategy.
 * @param target The list to put the alternatives in.
 * @param subPlan1 The predecessor node for the first input.
 * @param subPlan2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param ls The local strategy.
 * @param outGp The global properties of the data that goes to the user function.
 * @param outLp The local properties of the data that goes to the user function.
 * @param estimator The cost estimator.
 */
private void createMatchAlternative(List<OptimizerNode> target,OptimizerNode subPlan1,OptimizerNode subPlan2,ShipStrategy ss1,ShipStrategy ss2,LocalStrategy ls,Order order,boolean grouped,LocalProperties outLpp,CostEstimator estimator){
  if (ls != LocalStrategy.SELF_NESTEDLOOP && ls != LocalStrategy.SORT_SELF_NESTEDLOOP) {
    GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
    GlobalProperties gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,ss2);
    int[] scrambledKeyOrder1=null;
    int[] scrambledKeyOrder2=null;
    if (ss1 == ShipStrategy.FORWARD && ss2 == ShipStrategy.PARTITION_HASH) {
      scrambledKeyOrder1=getScrambledKeyOrder(this.keySet1,gp1.getPartitionedFields());
      if (scrambledKeyOrder1 != null) {
        FieldList scrambledKeys2=new FieldList();
        for (int i=0; i < scrambledKeyOrder1.length; i++) {
          scrambledKeys2.set(i,this.keySet2.get(scrambledKeyOrder1[i]));
        }
        gp2.setPartitioning(gp2.getPartitioning(),scrambledKeys2);
      }
    }
    if (ss2 == ShipStrategy.FORWARD && ss1 == ShipStrategy.PARTITION_HASH) {
      scrambledKeyOrder2=getScrambledKeyOrder(this.keySet2,gp2.getPartitionedFields());
      if (scrambledKeyOrder2 != null) {
        FieldList scrambledKeys1=new FieldList();
        for (int i=0; i < scrambledKeyOrder2.length; i++) {
          scrambledKeys1.set(i,this.keySet1.get(scrambledKeyOrder2[i]));
        }
        gp1.setPartitioning(gp1.getPartitioning(),scrambledKeys1);
      }
    }
    LocalProperties outLp=outLpp;
    GlobalProperties outGp=new GlobalProperties();
    outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
    outGp.setOrdering(gp1.getOrdering());
    if (outLpp == null) {
      outLp=new LocalProperties();
      if (order != Order.NONE) {
        Ordering ordering=new Ordering();
        for (        int keyColumn : this.keySet1) {
          ordering.appendOrdering(keyColumn,null,order);
        }
        outLp.setOrdering(ordering);
      }
 else {
        outLp.setOrdering(null);
      }
      outLp.setGrouped(grouped,new FieldSet(this.keySet1));
    }
    MatchNode n=new MatchNode(this,subPlan1,subPlan2,this.input1,this.input2,outGp,outLp);
    n.input1.setShipStrategy(ss1);
    n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
    n.input2.setShipStrategy(ss2);
    n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,0);
    n.getLocalProperties().filterByNodesConstantSet(this,0);
    estimator.costOperator(n);
    target.add(n);
    outGp=new GlobalProperties();
    outGp.setPartitioning(gp2.getPartitioning(),gp2.getPartitionedFields());
    outGp.setOrdering(gp2.getOrdering());
    if (outLpp == null) {
      outLp=new LocalProperties();
      if (order != Order.NONE) {
        Ordering ordering=new Ordering();
        for (        int keyColumn : this.keySet2) {
          ordering.appendOrdering(keyColumn,null,order);
        }
        outLp.setOrdering(ordering);
      }
 else {
        outLp.setOrdering(null);
      }
      outLp.setGrouped(grouped,new FieldSet(this.keySet2));
    }
    n=new MatchNode(this,subPlan1,subPlan2,input1,input2,outGp,outLp);
    n.input1.setShipStrategy(ss1);
    n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
    n.input2.setShipStrategy(ss2);
    n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,1);
    n.getLocalProperties().filterByNodesConstantSet(this,1);
    estimator.costOperator(n);
    target.add(n);
  }
 else {
    GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
    GlobalProperties outGp=new GlobalProperties();
    outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
    outGp.setOrdering(gp1.getOrdering());
    LocalProperties outLp=null;
    if (outLpp == null) {
      outLp=new LocalProperties();
      if (order != Order.NONE) {
        Ordering ordering=new Ordering();
        for (        int keyColumn : this.keySet1) {
          ordering.appendOrdering(keyColumn,null,order);
        }
        outLp.setOrdering(ordering);
      }
 else {
        outLp.setOrdering(null);
      }
      outLp.setGrouped(grouped,new FieldSet(this.keySet1));
    }
    MatchNode n=new MatchNode(this,subPlan1,null,this.input1,null,outGp,outLp);
    n.input1.setShipStrategy(ss1);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,0);
    n.getLocalProperties().filterByNodesConstantSet(this,0);
    estimator.costOperator(n);
    target.add(n);
  }
}","/** 
 * Private utility method that generates a candidate Match node, given fixed shipping strategies and a fixed local strategy.
 * @param target The list to put the alternatives in.
 * @param subPlan1 The predecessor node for the first input.
 * @param subPlan2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param ls The local strategy.
 * @param outGp The global properties of the data that goes to the user function.
 * @param outLp The local properties of the data that goes to the user function.
 * @param estimator The cost estimator.
 */
private void createMatchAlternative(List<OptimizerNode> target,OptimizerNode subPlan1,OptimizerNode subPlan2,ShipStrategy ss1,ShipStrategy ss2,LocalStrategy ls,Order order,boolean grouped,LocalProperties outLpp,CostEstimator estimator){
  if (ls != LocalStrategy.SELF_NESTEDLOOP && ls != LocalStrategy.SORT_SELF_NESTEDLOOP) {
    GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
    GlobalProperties gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,ss2);
    int[] scrambledKeyOrder1=null;
    int[] scrambledKeyOrder2=null;
    if (ss1 == ShipStrategy.FORWARD && ss2 == ShipStrategy.PARTITION_HASH) {
      scrambledKeyOrder1=getScrambledKeyOrder(this.keySet1,gp1.getPartitionedFields());
      if (scrambledKeyOrder1 != null) {
        FieldList scrambledKeys2=new FieldList();
        for (int i=0; i < scrambledKeyOrder1.length; i++) {
          scrambledKeys2.add(this.keySet2.get(scrambledKeyOrder1[i]));
        }
        gp2.setPartitioning(gp2.getPartitioning(),scrambledKeys2);
      }
    }
    if (ss2 == ShipStrategy.FORWARD && ss1 == ShipStrategy.PARTITION_HASH) {
      scrambledKeyOrder2=getScrambledKeyOrder(this.keySet2,gp2.getPartitionedFields());
      if (scrambledKeyOrder2 != null) {
        FieldList scrambledKeys1=new FieldList();
        for (int i=0; i < scrambledKeyOrder2.length; i++) {
          scrambledKeys1.add(this.keySet1.get(scrambledKeyOrder2[i]));
        }
        gp1.setPartitioning(gp1.getPartitioning(),scrambledKeys1);
      }
    }
    LocalProperties outLp=outLpp;
    GlobalProperties outGp=new GlobalProperties();
    outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
    outGp.setOrdering(gp1.getOrdering());
    if (outLpp == null) {
      outLp=new LocalProperties();
      if (order != Order.NONE) {
        Ordering ordering=new Ordering();
        for (        int keyColumn : this.keySet1) {
          ordering.appendOrdering(keyColumn,null,order);
        }
        outLp.setOrdering(ordering);
      }
 else {
        outLp.setOrdering(null);
      }
      outLp.setGrouped(grouped,new FieldSet(this.keySet1));
    }
    MatchNode n=new MatchNode(this,subPlan1,subPlan2,this.input1,this.input2,outGp,outLp);
    n.input1.setShipStrategy(ss1);
    n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
    n.input2.setShipStrategy(ss2);
    n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,0);
    n.getLocalProperties().filterByNodesConstantSet(this,0);
    estimator.costOperator(n);
    target.add(n);
    outGp=new GlobalProperties();
    outGp.setPartitioning(gp2.getPartitioning(),gp2.getPartitionedFields());
    outGp.setOrdering(gp2.getOrdering());
    if (outLpp == null) {
      outLp=new LocalProperties();
      if (order != Order.NONE) {
        Ordering ordering=new Ordering();
        for (        int keyColumn : this.keySet2) {
          ordering.appendOrdering(keyColumn,null,order);
        }
        outLp.setOrdering(ordering);
      }
 else {
        outLp.setOrdering(null);
      }
      outLp.setGrouped(grouped,new FieldSet(this.keySet2));
    }
    n=new MatchNode(this,subPlan1,subPlan2,input1,input2,outGp,outLp);
    n.input1.setShipStrategy(ss1);
    n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
    n.input2.setShipStrategy(ss2);
    n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,1);
    n.getLocalProperties().filterByNodesConstantSet(this,1);
    estimator.costOperator(n);
    target.add(n);
  }
 else {
    GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
    GlobalProperties outGp=new GlobalProperties();
    outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
    outGp.setOrdering(gp1.getOrdering());
    LocalProperties outLp=null;
    if (outLpp == null) {
      outLp=new LocalProperties();
      if (order != Order.NONE) {
        Ordering ordering=new Ordering();
        for (        int keyColumn : this.keySet1) {
          ordering.appendOrdering(keyColumn,null,order);
        }
        outLp.setOrdering(ordering);
      }
 else {
        outLp.setOrdering(null);
      }
      outLp.setGrouped(grouped,new FieldSet(this.keySet1));
    }
    MatchNode n=new MatchNode(this,subPlan1,null,this.input1,null,outGp,outLp);
    n.input1.setShipStrategy(ss1);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,0);
    n.getLocalProperties().filterByNodesConstantSet(this,0);
    estimator.costOperator(n);
    target.add(n);
  }
}"
87555,"@Override protected void fillArray(IJsonNode[] result){
  this.children.toArray(new IJsonNode[this.children.size()]);
}","@Override protected void fillArray(IJsonNode[] result){
  IJsonNode[] array=this.children.toArray(new IJsonNode[this.children.size()]);
  for (int i=0; i < this.children.size(); i++) {
    result[i]=array[i];
  }
}"
87556,"@Override protected void computeValidPlanAlternatives(List<? extends OptimizerNode> altSubPlans1,List<? extends OptimizerNode> altSubPlans2,CostEstimator estimator,List<OptimizerNode> outputPlans){
  for (  OptimizerNode subPlan1 : altSubPlans1) {
    for (    OptimizerNode subPlan2 : altSubPlans2) {
      if (!areBranchCompatible(subPlan1,subPlan2)) {
        continue;
      }
      ShipStrategy ss1=this.input1.getShipStrategy();
      ShipStrategy ss2=this.input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        gp1=subPlan1.getGlobalProperties();
        if (ss2 == ShipStrategy.NONE) {
          gp2=subPlan2.getGlobalProperties();
          if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning().isComputablyPartitioned()) {
            if (!partitioningIsOnRightFields(gp1,0) || !gp1.getPartitioning().isComputablyPartitioned()) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning() == gp2.getPartitioning() && partitioningIsOnSameSubkey(gp1.getPartitionedFields(),gp2.getPartitionedFields())) {
                ss2=ShipStrategy.FORWARD;
              }
 else {
                if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                  createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
                  createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
                }
 else                 if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                  createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
                  createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
                }
                continue;
              }
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
              }
            }
 else {
              if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
            }
          }
 else {
            createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss2);
switch (ss2) {
case FORWARD:
            if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning().isPartitioned()) {
              if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                ss1=ShipStrategy.PARTITION_HASH;
              }
 else               if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                ss1=ShipStrategy.PARTITION_RANGE;
              }
 else {
                throw new CompilerException();
              }
            }
 else {
              continue;
            }
          break;
case PARTITION_HASH:
        ss1=(partitioningIsOnSameSubkey(gp1.getPartitionedFields(),this.keySet2) && gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
      break;
case PARTITION_RANGE:
    ss1=(partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
  break;
default :
throw new CompilerException(""String_Node_Str"" + ss2.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
gp2=subPlan2.getGlobalProperties();
switch (ss1) {
case FORWARD:
if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
continue;
}
break;
case PARTITION_HASH:
ss2=(partitioningIsOnSameSubkey(this.keySet1,gp2.getPartitionedFields()) && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss1.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,ss2);
if (gp1.getPartitioning().isComputablyPartitioned() && gp1.getPartitioning() == gp2.getPartitioning() && partitioningIsOnSameSubkey(gp1.getPartitionedFields(),gp2.getPartitionedFields())) {
createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
}","@Override protected void computeValidPlanAlternatives(List<? extends OptimizerNode> altSubPlans1,List<? extends OptimizerNode> altSubPlans2,CostEstimator estimator,List<OptimizerNode> outputPlans){
  for (  OptimizerNode subPlan1 : altSubPlans1) {
    for (    OptimizerNode subPlan2 : altSubPlans2) {
      if (!areBranchCompatible(subPlan1,subPlan2)) {
        continue;
      }
      ShipStrategy ss1=this.input1.getShipStrategy();
      ShipStrategy ss2=this.input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        gp1=subPlan1.getGlobalProperties();
        if (ss2 == ShipStrategy.NONE) {
          gp2=subPlan2.getGlobalProperties();
          if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning().isComputablyPartitioned()) {
            if (!partitioningIsOnRightFields(gp1,0) || !gp1.getPartitioning().isComputablyPartitioned()) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning() == gp2.getPartitioning() && partitioningIsOnSameSubkey(gp1.getPartitionedFields(),gp2.getPartitionedFields())) {
                ss2=ShipStrategy.FORWARD;
              }
 else {
                if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                  createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
                  createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
                }
 else                 if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                  createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
                  createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
                }
                continue;
              }
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
              }
            }
 else {
              if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
            }
          }
 else {
            createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,1,ss2);
switch (ss2) {
case FORWARD:
            if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning().isPartitioned()) {
              if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                ss1=ShipStrategy.PARTITION_HASH;
              }
 else               if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                ss1=ShipStrategy.PARTITION_RANGE;
              }
 else {
                throw new CompilerException();
              }
            }
 else {
              continue;
            }
          break;
case PARTITION_HASH:
        ss1=(partitioningIsOnSameSubkey(gp1.getPartitionedFields(),this.keySet2) && gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
      break;
case PARTITION_RANGE:
    ss1=(partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
  break;
default :
throw new CompilerException(""String_Node_Str"" + ss2.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,0,ss1);
gp2=subPlan2.getGlobalProperties();
switch (ss1) {
case FORWARD:
if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
continue;
}
break;
case PARTITION_HASH:
ss2=(partitioningIsOnSameSubkey(this.keySet1,gp2.getPartitionedFields()) && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss1.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,0,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,1,ss2);
if (gp1.getPartitioning().isComputablyPartitioned() && gp1.getPartitioning() == gp2.getPartitioning() && partitioningIsOnSameSubkey(gp1.getPartitionedFields(),gp2.getPartitionedFields())) {
createCoGroupAlternative(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
}"
87557,"/** 
 * Private utility method that generates the alternative CoGroup nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param subPlan1 The subplan for the first input.
 * @param subPlan2 The subplan for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createCoGroupAlternative(List<OptimizerNode> target,OptimizerNode subPlan1,OptimizerNode subPlan2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  GlobalProperties gp1, gp2;
  LocalProperties lp1, lp2;
  gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
  lp1=PactConnection.getLocalPropertiesAfterConnection(subPlan1,this,ss1);
  gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,ss2);
  lp2=PactConnection.getLocalPropertiesAfterConnection(subPlan2,this,ss2);
  int[] scrambledKeyOrder1=null;
  int[] scrambledKeyOrder2=null;
  if (ss1 == ShipStrategy.FORWARD && ss2 == ShipStrategy.PARTITION_HASH) {
    scrambledKeyOrder1=getScrambledKeyOrder(this.keySet1,gp1.getPartitionedFields());
    if (scrambledKeyOrder1 != null) {
      FieldList scrambledKeys2=new FieldList();
      for (int i=0; i < scrambledKeyOrder1.length; i++) {
        scrambledKeys2.add(this.keySet2.get(scrambledKeyOrder1[i]));
      }
      gp2.setPartitioning(gp2.getPartitioning(),scrambledKeys2);
    }
  }
  if (ss2 == ShipStrategy.FORWARD && ss1 == ShipStrategy.PARTITION_HASH) {
    scrambledKeyOrder2=getScrambledKeyOrder(this.keySet2,gp2.getPartitionedFields());
    if (scrambledKeyOrder2 != null) {
      FieldList scrambledKeys1=new FieldList();
      for (int i=0; i < scrambledKeyOrder2.length; i++) {
        scrambledKeys1.add(this.keySet1.get(scrambledKeyOrder2[i]));
      }
      gp1.setPartitioning(gp1.getPartitioning(),scrambledKeys1);
    }
  }
  int[] keyColumns1=getPactContract().getKeyColumnNumbers(0);
  Ordering ordering1=new Ordering();
  for (  int keyColumn : keyColumns1) {
    ordering1.appendOrdering(keyColumn,null,Order.ASCENDING);
  }
  int[] keyColumns2=getPactContract().getKeyColumnNumbers(1);
  Ordering ordering2=new Ordering();
  for (  int keyColumn : keyColumns2) {
    ordering2.appendOrdering(keyColumn,null,Order.ASCENDING);
  }
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
  CoGroupNode n=new CoGroupNode(this,subPlan1,subPlan2,this.input1,this.input2,outGp,new LocalProperties());
  n.input1.setShipStrategy(ss1);
  n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
  n.input2.setShipStrategy(ss2);
  n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
  n.getLocalProperties().setOrdering(ordering1);
  n.getLocalProperties().setGrouped(true,new FieldSet(keyColumns1));
  if (n.getLocalStrategy() == LocalStrategy.NONE) {
    if (ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.MERGE);
    }
 else     if (!ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_FIRST_MERGE);
    }
 else     if (ordering1.isMetBy(lp1.getOrdering()) && !ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_SECOND_MERGE);
    }
 else {
      n.setLocalStrategy(LocalStrategy.SORT_BOTH_MERGE);
    }
  }
  n.getGlobalProperties().filterByNodesConstantSet(this,0);
  n.getLocalProperties().filterByNodesConstantSet(this,0);
  estimator.costOperator(n);
  target.add(n);
  outGp=new GlobalProperties();
  outGp.setPartitioning(gp2.getPartitioning(),gp2.getPartitionedFields());
  n=new CoGroupNode(this,subPlan1,subPlan2,input1,input2,outGp,new LocalProperties());
  n.input1.setShipStrategy(ss1);
  n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
  n.input2.setShipStrategy(ss2);
  n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
  n.getLocalProperties().setOrdering(ordering2);
  n.getLocalProperties().setGrouped(true,new FieldSet(keyColumns2));
  if (n.getLocalStrategy() == LocalStrategy.NONE) {
    if (ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.MERGE);
    }
 else     if (!ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_FIRST_MERGE);
    }
 else     if (ordering1.isMetBy(lp1.getOrdering()) && !ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_SECOND_MERGE);
    }
 else {
      n.setLocalStrategy(LocalStrategy.SORT_BOTH_MERGE);
    }
  }
  n.getGlobalProperties().filterByNodesConstantSet(this,1);
  n.getLocalProperties().filterByNodesConstantSet(this,1);
  estimator.costOperator(n);
  target.add(n);
}","/** 
 * Private utility method that generates the alternative CoGroup nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param subPlan1 The subplan for the first input.
 * @param subPlan2 The subplan for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createCoGroupAlternative(List<OptimizerNode> target,OptimizerNode subPlan1,OptimizerNode subPlan2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  GlobalProperties gp1, gp2;
  LocalProperties lp1, lp2;
  gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,0,ss1);
  lp1=PactConnection.getLocalPropertiesAfterConnection(subPlan1,this,ss1);
  gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,1,ss2);
  lp2=PactConnection.getLocalPropertiesAfterConnection(subPlan2,this,ss2);
  int[] scrambledKeyOrder1=null;
  int[] scrambledKeyOrder2=null;
  if (ss1 == ShipStrategy.FORWARD && ss2 == ShipStrategy.PARTITION_HASH) {
    scrambledKeyOrder1=getScrambledKeyOrder(this.keySet1,gp1.getPartitionedFields());
    if (scrambledKeyOrder1 != null) {
      FieldList scrambledKeys2=new FieldList();
      for (int i=0; i < scrambledKeyOrder1.length; i++) {
        scrambledKeys2.add(this.keySet2.get(scrambledKeyOrder1[i]));
      }
      gp2.setPartitioning(gp2.getPartitioning(),scrambledKeys2);
    }
  }
  if (ss2 == ShipStrategy.FORWARD && ss1 == ShipStrategy.PARTITION_HASH) {
    scrambledKeyOrder2=getScrambledKeyOrder(this.keySet2,gp2.getPartitionedFields());
    if (scrambledKeyOrder2 != null) {
      FieldList scrambledKeys1=new FieldList();
      for (int i=0; i < scrambledKeyOrder2.length; i++) {
        scrambledKeys1.add(this.keySet1.get(scrambledKeyOrder2[i]));
      }
      gp1.setPartitioning(gp1.getPartitioning(),scrambledKeys1);
    }
  }
  int[] keyColumns1=getPactContract().getKeyColumnNumbers(0);
  Ordering ordering1=new Ordering();
  for (  int keyColumn : keyColumns1) {
    ordering1.appendOrdering(keyColumn,null,Order.ASCENDING);
  }
  int[] keyColumns2=getPactContract().getKeyColumnNumbers(1);
  Ordering ordering2=new Ordering();
  for (  int keyColumn : keyColumns2) {
    ordering2.appendOrdering(keyColumn,null,Order.ASCENDING);
  }
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
  CoGroupNode n=new CoGroupNode(this,subPlan1,subPlan2,this.input1,this.input2,outGp,new LocalProperties());
  n.input1.setShipStrategy(ss1);
  n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
  n.input2.setShipStrategy(ss2);
  n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
  n.getLocalProperties().setOrdering(ordering1);
  n.getLocalProperties().setGrouped(true,new FieldSet(keyColumns1));
  if (n.getLocalStrategy() == LocalStrategy.NONE) {
    if (ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.MERGE);
    }
 else     if (!ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_FIRST_MERGE);
    }
 else     if (ordering1.isMetBy(lp1.getOrdering()) && !ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_SECOND_MERGE);
    }
 else {
      n.setLocalStrategy(LocalStrategy.SORT_BOTH_MERGE);
    }
  }
  n.getGlobalProperties().filterByNodesConstantSet(this,0);
  n.getLocalProperties().filterByNodesConstantSet(this,0);
  estimator.costOperator(n);
  target.add(n);
  outGp=new GlobalProperties();
  outGp.setPartitioning(gp2.getPartitioning(),gp2.getPartitionedFields());
  n=new CoGroupNode(this,subPlan1,subPlan2,input1,input2,outGp,new LocalProperties());
  n.input1.setShipStrategy(ss1);
  n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
  n.input2.setShipStrategy(ss2);
  n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
  n.getLocalProperties().setOrdering(ordering2);
  n.getLocalProperties().setGrouped(true,new FieldSet(keyColumns2));
  if (n.getLocalStrategy() == LocalStrategy.NONE) {
    if (ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.MERGE);
    }
 else     if (!ordering1.isMetBy(lp1.getOrdering()) && ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_FIRST_MERGE);
    }
 else     if (ordering1.isMetBy(lp1.getOrdering()) && !ordering2.isMetBy(lp2.getOrdering())) {
      n.setLocalStrategy(LocalStrategy.SORT_SECOND_MERGE);
    }
 else {
      n.setLocalStrategy(LocalStrategy.SORT_BOTH_MERGE);
    }
  }
  n.getGlobalProperties().filterByNodesConstantSet(this,1);
  n.getLocalProperties().filterByNodesConstantSet(this,1);
  estimator.costOperator(n);
  target.add(n);
}"
87558,"/** 
 * Private utility method that generates a candidate Cross node, given fixed shipping strategies and a fixed local strategy.
 * @param target The list to put the alternatives in.
 * @param subPlan1 The subPlan for the first input.
 * @param subPlan2 The subPlan for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param ls The local strategy.
 * @param outGp The global properties of the data that goes to the user function.
 * @param outLp The local properties of the data that goes to the user function.
 * @param estimator The cost estimator.
 */
private void createCrossAlternative(List<OptimizerNode> target,OptimizerNode subPlan1,OptimizerNode subPlan2,ShipStrategy ss1,ShipStrategy ss2,LocalStrategy ls,boolean keepFirstOrder,boolean keepSecondOrder,CostEstimator estimator){
  GlobalProperties gp;
  LocalProperties lp;
  gp=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
  lp=PactConnection.getLocalPropertiesAfterConnection(subPlan1,this,ss1);
  if (keepFirstOrder == false) {
    gp.setOrdering(null);
    lp.setOrdering(null);
  }
  CrossNode n=new CrossNode(this,subPlan1,subPlan2,input1,input2,gp,lp);
  n.input1.setShipStrategy(ss1);
  n.input2.setShipStrategy(ss2);
  n.setLocalStrategy(ls);
  n.getGlobalProperties().filterByNodesConstantSet(this,0);
  n.getLocalProperties().filterByNodesConstantSet(this,0);
  estimator.costOperator(n);
  target.add(n);
  gp=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,ss2);
  lp=PactConnection.getLocalPropertiesAfterConnection(subPlan2,this,ss2);
  if (keepSecondOrder == false) {
    gp.setOrdering(null);
    lp.setOrdering(null);
  }
  n=new CrossNode(this,subPlan1,subPlan2,input1,input2,gp,lp);
  n.input1.setShipStrategy(ss1);
  n.input2.setShipStrategy(ss2);
  n.setLocalStrategy(ls);
  n.getGlobalProperties().filterByNodesConstantSet(this,1);
  n.getLocalProperties().filterByNodesConstantSet(this,1);
  estimator.costOperator(n);
  target.add(n);
}","/** 
 * Private utility method that generates a candidate Cross node, given fixed shipping strategies and a fixed local strategy.
 * @param target The list to put the alternatives in.
 * @param subPlan1 The subPlan for the first input.
 * @param subPlan2 The subPlan for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param ls The local strategy.
 * @param outGp The global properties of the data that goes to the user function.
 * @param outLp The local properties of the data that goes to the user function.
 * @param estimator The cost estimator.
 */
private void createCrossAlternative(List<OptimizerNode> target,OptimizerNode subPlan1,OptimizerNode subPlan2,ShipStrategy ss1,ShipStrategy ss2,LocalStrategy ls,boolean keepFirstOrder,boolean keepSecondOrder,CostEstimator estimator){
  GlobalProperties gp;
  LocalProperties lp;
  gp=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,0,ss1);
  lp=PactConnection.getLocalPropertiesAfterConnection(subPlan1,this,ss1);
  if (keepFirstOrder == false) {
    gp.setOrdering(null);
    lp.setOrdering(null);
  }
  CrossNode n=new CrossNode(this,subPlan1,subPlan2,input1,input2,gp,lp);
  n.input1.setShipStrategy(ss1);
  n.input2.setShipStrategy(ss2);
  n.setLocalStrategy(ls);
  n.getGlobalProperties().filterByNodesConstantSet(this,0);
  n.getLocalProperties().filterByNodesConstantSet(this,0);
  estimator.costOperator(n);
  target.add(n);
  gp=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,1,ss2);
  lp=PactConnection.getLocalPropertiesAfterConnection(subPlan2,this,ss2);
  if (keepSecondOrder == false) {
    gp.setOrdering(null);
    lp.setOrdering(null);
  }
  n=new CrossNode(this,subPlan1,subPlan2,input1,input2,gp,lp);
  n.input1.setShipStrategy(ss1);
  n.input2.setShipStrategy(ss2);
  n.setLocalStrategy(ls);
  n.getGlobalProperties().filterByNodesConstantSet(this,1);
  n.getLocalProperties().filterByNodesConstantSet(this,1);
  estimator.costOperator(n);
  target.add(n);
}"
87559,"@Override protected void computeValidPlanAlternatives(List<? extends OptimizerNode> altSubPlans,CostEstimator estimator,List<OptimizerNode> outputPlans){
  ShipStrategy ss=ShipStrategy.NONE;
  ShipStrategy hintSS=this.inConn.getShipStrategy();
  if (hintSS == ShipStrategy.BROADCAST || hintSS == ShipStrategy.SFR)   return;
 else   ss=hintSS;
  if (ss == ShipStrategy.NONE)   ss=ShipStrategy.FORWARD;
  for (  OptimizerNode subPlan : altSubPlans) {
    GlobalProperties gp=PactConnection.getGlobalPropertiesAfterConnection(subPlan,this,ss);
    LocalProperties lp=PactConnection.getLocalPropertiesAfterConnection(subPlan,this,ss);
    MapNode nMap=new MapNode(this,subPlan,this.inConn,gp,lp);
    nMap.inConn.setShipStrategy(ss);
    nMap.getGlobalProperties().filterByNodesConstantSet(this,0);
    nMap.getLocalProperties().filterByNodesConstantSet(this,0);
    estimator.costOperator(nMap);
    outputPlans.add(nMap);
  }
}","@Override protected void computeValidPlanAlternatives(List<? extends OptimizerNode> altSubPlans,CostEstimator estimator,List<OptimizerNode> outputPlans){
  ShipStrategy ss=ShipStrategy.NONE;
  ShipStrategy hintSS=this.inConn.getShipStrategy();
  if (hintSS == ShipStrategy.BROADCAST || hintSS == ShipStrategy.SFR)   return;
 else   ss=hintSS;
  if (ss == ShipStrategy.NONE)   ss=ShipStrategy.FORWARD;
  for (  OptimizerNode subPlan : altSubPlans) {
    GlobalProperties gp=PactConnection.getGlobalPropertiesAfterConnection(subPlan,this,0,ss);
    LocalProperties lp=PactConnection.getLocalPropertiesAfterConnection(subPlan,this,ss);
    MapNode nMap=new MapNode(this,subPlan,this.inConn,gp,lp);
    nMap.inConn.setShipStrategy(ss);
    nMap.getGlobalProperties().filterByNodesConstantSet(this,0);
    nMap.getLocalProperties().filterByNodesConstantSet(this,0);
    estimator.costOperator(nMap);
    outputPlans.add(nMap);
  }
}"
87560,"/** 
 * Private utility method that generates a candidate Match node, given fixed shipping strategies and a fixed local strategy.
 * @param target The list to put the alternatives in.
 * @param subPlan1 The predecessor node for the first input.
 * @param subPlan2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param ls The local strategy.
 * @param outGp The global properties of the data that goes to the user function.
 * @param outLp The local properties of the data that goes to the user function.
 * @param estimator The cost estimator.
 */
private void createMatchAlternative(List<OptimizerNode> target,OptimizerNode subPlan1,OptimizerNode subPlan2,ShipStrategy ss1,ShipStrategy ss2,LocalStrategy ls,Order order,boolean grouped,LocalProperties outLpp,CostEstimator estimator){
  if (ls != LocalStrategy.SELF_NESTEDLOOP && ls != LocalStrategy.SORT_SELF_NESTEDLOOP) {
    GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
    GlobalProperties gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,ss2);
    int[] scrambledKeyOrder1=null;
    int[] scrambledKeyOrder2=null;
    if (ss1 == ShipStrategy.FORWARD && ss2 == ShipStrategy.PARTITION_HASH) {
      scrambledKeyOrder1=getScrambledKeyOrder(this.keySet1,gp1.getPartitionedFields());
      if (scrambledKeyOrder1 != null) {
        FieldList scrambledKeys2=new FieldList();
        for (int i=0; i < scrambledKeyOrder1.length; i++) {
          scrambledKeys2.add(this.keySet2.get(scrambledKeyOrder1[i]));
        }
        gp2.setPartitioning(gp2.getPartitioning(),scrambledKeys2);
      }
    }
    if (ss2 == ShipStrategy.FORWARD && ss1 == ShipStrategy.PARTITION_HASH) {
      scrambledKeyOrder2=getScrambledKeyOrder(this.keySet2,gp2.getPartitionedFields());
      if (scrambledKeyOrder2 != null) {
        FieldList scrambledKeys1=new FieldList();
        for (int i=0; i < scrambledKeyOrder2.length; i++) {
          scrambledKeys1.add(this.keySet1.get(scrambledKeyOrder2[i]));
        }
        gp1.setPartitioning(gp1.getPartitioning(),scrambledKeys1);
      }
    }
    LocalProperties outLp=outLpp;
    GlobalProperties outGp=new GlobalProperties();
    outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
    outGp.setOrdering(gp1.getOrdering());
    if (outLpp == null) {
      outLp=new LocalProperties();
      if (order != Order.NONE) {
        Ordering ordering=new Ordering();
        for (        int keyColumn : this.keySet1) {
          ordering.appendOrdering(keyColumn,null,order);
        }
        outLp.setOrdering(ordering);
      }
 else {
        outLp.setOrdering(null);
      }
      outLp.setGrouped(grouped,new FieldSet(this.keySet1));
    }
    MatchNode n=new MatchNode(this,subPlan1,subPlan2,this.input1,this.input2,outGp,outLp);
    n.input1.setShipStrategy(ss1);
    n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
    n.input2.setShipStrategy(ss2);
    n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,0);
    n.getLocalProperties().filterByNodesConstantSet(this,0);
    estimator.costOperator(n);
    target.add(n);
    outGp=new GlobalProperties();
    outGp.setPartitioning(gp2.getPartitioning(),gp2.getPartitionedFields());
    outGp.setOrdering(gp2.getOrdering());
    if (outLpp == null) {
      outLp=new LocalProperties();
      if (order != Order.NONE) {
        Ordering ordering=new Ordering();
        for (        int keyColumn : this.keySet2) {
          ordering.appendOrdering(keyColumn,null,order);
        }
        outLp.setOrdering(ordering);
      }
 else {
        outLp.setOrdering(null);
      }
      outLp.setGrouped(grouped,new FieldSet(this.keySet2));
    }
    n=new MatchNode(this,subPlan1,subPlan2,input1,input2,outGp,outLp);
    n.input1.setShipStrategy(ss1);
    n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
    n.input2.setShipStrategy(ss2);
    n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,1);
    n.getLocalProperties().filterByNodesConstantSet(this,1);
    estimator.costOperator(n);
    target.add(n);
  }
 else {
    GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
    GlobalProperties outGp=new GlobalProperties();
    outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
    outGp.setOrdering(gp1.getOrdering());
    LocalProperties outLp=null;
    if (outLpp == null) {
      outLp=new LocalProperties();
      if (order != Order.NONE) {
        Ordering ordering=new Ordering();
        for (        int keyColumn : this.keySet1) {
          ordering.appendOrdering(keyColumn,null,order);
        }
        outLp.setOrdering(ordering);
      }
 else {
        outLp.setOrdering(null);
      }
      outLp.setGrouped(grouped,new FieldSet(this.keySet1));
    }
    MatchNode n=new MatchNode(this,subPlan1,null,this.input1,null,outGp,outLp);
    n.input1.setShipStrategy(ss1);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,0);
    n.getLocalProperties().filterByNodesConstantSet(this,0);
    estimator.costOperator(n);
    target.add(n);
  }
}","/** 
 * Private utility method that generates a candidate Match node, given fixed shipping strategies and a fixed local strategy.
 * @param target The list to put the alternatives in.
 * @param subPlan1 The predecessor node for the first input.
 * @param subPlan2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param ls The local strategy.
 * @param outGp The global properties of the data that goes to the user function.
 * @param outLp The local properties of the data that goes to the user function.
 * @param estimator The cost estimator.
 */
private void createMatchAlternative(List<OptimizerNode> target,OptimizerNode subPlan1,OptimizerNode subPlan2,ShipStrategy ss1,ShipStrategy ss2,LocalStrategy ls,Order order,boolean grouped,LocalProperties outLpp,CostEstimator estimator){
  if (ls != LocalStrategy.SELF_NESTEDLOOP && ls != LocalStrategy.SORT_SELF_NESTEDLOOP) {
    GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,0,ss1);
    GlobalProperties gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,1,ss2);
    int[] scrambledKeyOrder1=null;
    int[] scrambledKeyOrder2=null;
    if (ss1 == ShipStrategy.FORWARD && ss2 == ShipStrategy.PARTITION_HASH) {
      scrambledKeyOrder1=getScrambledKeyOrder(this.keySet1,gp1.getPartitionedFields());
      if (scrambledKeyOrder1 != null) {
        FieldList scrambledKeys2=new FieldList();
        for (int i=0; i < scrambledKeyOrder1.length; i++) {
          scrambledKeys2.add(this.keySet2.get(scrambledKeyOrder1[i]));
        }
        gp2.setPartitioning(gp2.getPartitioning(),scrambledKeys2);
      }
    }
    if (ss2 == ShipStrategy.FORWARD && ss1 == ShipStrategy.PARTITION_HASH) {
      scrambledKeyOrder2=getScrambledKeyOrder(this.keySet2,gp2.getPartitionedFields());
      if (scrambledKeyOrder2 != null) {
        FieldList scrambledKeys1=new FieldList();
        for (int i=0; i < scrambledKeyOrder2.length; i++) {
          scrambledKeys1.add(this.keySet1.get(scrambledKeyOrder2[i]));
        }
        gp1.setPartitioning(gp1.getPartitioning(),scrambledKeys1);
      }
    }
    LocalProperties outLp=outLpp;
    GlobalProperties outGp=new GlobalProperties();
    outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
    outGp.setOrdering(gp1.getOrdering());
    if (outLpp == null) {
      outLp=new LocalProperties();
      if (order != Order.NONE) {
        Ordering ordering=new Ordering();
        for (        int keyColumn : this.keySet1) {
          ordering.appendOrdering(keyColumn,null,order);
        }
        outLp.setOrdering(ordering);
      }
 else {
        outLp.setOrdering(null);
      }
      outLp.setGrouped(grouped,new FieldSet(this.keySet1));
    }
    MatchNode n=new MatchNode(this,subPlan1,subPlan2,this.input1,this.input2,outGp,outLp);
    n.input1.setShipStrategy(ss1);
    n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
    n.input2.setShipStrategy(ss2);
    n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,0);
    n.getLocalProperties().filterByNodesConstantSet(this,0);
    estimator.costOperator(n);
    target.add(n);
    outGp=new GlobalProperties();
    outGp.setPartitioning(gp2.getPartitioning(),gp2.getPartitionedFields());
    outGp.setOrdering(gp2.getOrdering());
    if (outLpp == null) {
      outLp=new LocalProperties();
      if (order != Order.NONE) {
        Ordering ordering=new Ordering();
        for (        int keyColumn : this.keySet2) {
          ordering.appendOrdering(keyColumn,null,order);
        }
        outLp.setOrdering(ordering);
      }
 else {
        outLp.setOrdering(null);
      }
      outLp.setGrouped(grouped,new FieldSet(this.keySet2));
    }
    n=new MatchNode(this,subPlan1,subPlan2,input1,input2,outGp,outLp);
    n.input1.setShipStrategy(ss1);
    n.input1.setScramblePartitionedFields(scrambledKeyOrder2);
    n.input2.setShipStrategy(ss2);
    n.input2.setScramblePartitionedFields(scrambledKeyOrder1);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,1);
    n.getLocalProperties().filterByNodesConstantSet(this,1);
    estimator.costOperator(n);
    target.add(n);
  }
 else {
    GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,0,ss1);
    GlobalProperties outGp=new GlobalProperties();
    outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
    outGp.setOrdering(gp1.getOrdering());
    LocalProperties outLp=null;
    if (outLpp == null) {
      outLp=new LocalProperties();
      if (order != Order.NONE) {
        Ordering ordering=new Ordering();
        for (        int keyColumn : this.keySet1) {
          ordering.appendOrdering(keyColumn,null,order);
        }
        outLp.setOrdering(ordering);
      }
 else {
        outLp.setOrdering(null);
      }
      outLp.setGrouped(grouped,new FieldSet(this.keySet1));
    }
    MatchNode n=new MatchNode(this,subPlan1,null,this.input1,null,outGp,outLp);
    n.input1.setShipStrategy(ss1);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,0);
    n.getLocalProperties().filterByNodesConstantSet(this,0);
    estimator.costOperator(n);
    target.add(n);
  }
}"
87561,"@Override protected void computeValidPlanAlternatives(List<? extends OptimizerNode> altSubPlans1,List<? extends OptimizerNode> altSubPlans2,CostEstimator estimator,List<OptimizerNode> outputPlans){
  for (  OptimizerNode subPlan1 : altSubPlans1) {
    for (    OptimizerNode subPlan2 : altSubPlans2) {
      if (!areBranchCompatible(subPlan1,subPlan2)) {
        continue;
      }
      ShipStrategy ss1=this.input1.getShipStrategy();
      ShipStrategy ss2=this.input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        gp1=subPlan1.getGlobalProperties();
        if (ss2 == ShipStrategy.NONE) {
          gp2=subPlan2.getGlobalProperties();
          if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning().isComputablyPartitioned()) {
            if (!partitioningIsOnRightFields(gp1,0) || !gp1.getPartitioning().isComputablyPartitioned()) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning().isCompatibleWith(gp2.getPartitioning()) && partitioningIsOnSameSubkey(gp1.getPartitionedFields(),gp2.getPartitionedFields())) {
                ss2=ShipStrategy.FORWARD;
              }
 else {
                if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                  createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
                }
 else                 if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                  createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
                }
                if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                  createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
                }
 else                 if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                  createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
                }
                continue;
              }
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_RANGE,ShipStrategy.PARTITION_RANGE,estimator);
              }
            }
 else {
              if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
            }
          }
 else {
            createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            if (haveValidOutputEstimates(subPlan1) && haveValidOutputEstimates(subPlan2)) {
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.BROADCAST,ShipStrategy.FORWARD,estimator);
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.FORWARD,ShipStrategy.BROADCAST,estimator);
            }
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,ss2);
switch (ss2) {
case BROADCAST:
            ss1=ShipStrategy.FORWARD;
          break;
case FORWARD:
        if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning().isPartitioned()) {
          if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_HASH;
          }
 else           if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_RANGE;
          }
 else {
            throw new CompilerException();
          }
        }
 else {
          ss1=ShipStrategy.BROADCAST;
        }
      break;
case PARTITION_HASH:
    ss1=(partitioningIsOnSameSubkey(gp1.getPartitionedFields(),this.keySet2) && gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
  break;
case PARTITION_RANGE:
ss1=(partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss2.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
gp2=subPlan2.getGlobalProperties();
switch (ss1) {
case BROADCAST:
ss2=ShipStrategy.FORWARD;
break;
case FORWARD:
if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
ss2=ShipStrategy.BROADCAST;
}
break;
case PARTITION_HASH:
ss2=(partitioningIsOnSameSubkey(this.keySet1,gp2.getPartitionedFields()) && partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss1.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
if ((ss1 == ShipStrategy.BROADCAST && ss2 != ShipStrategy.BROADCAST) || (ss1 != ShipStrategy.BROADCAST && ss2 == ShipStrategy.BROADCAST)) {
createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,ss2);
if (gp1.getPartitioning().isComputablyPartitioned() && gp1.getPartitioning() == gp2.getPartitioning() && partitioningIsOnSameSubkey(gp1.getPartitionedFields(),gp2.getPartitionedFields())) {
createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
}
}","@Override protected void computeValidPlanAlternatives(List<? extends OptimizerNode> altSubPlans1,List<? extends OptimizerNode> altSubPlans2,CostEstimator estimator,List<OptimizerNode> outputPlans){
  for (  OptimizerNode subPlan1 : altSubPlans1) {
    for (    OptimizerNode subPlan2 : altSubPlans2) {
      if (!areBranchCompatible(subPlan1,subPlan2)) {
        continue;
      }
      ShipStrategy ss1=this.input1.getShipStrategy();
      ShipStrategy ss2=this.input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        gp1=subPlan1.getGlobalProperties();
        if (ss2 == ShipStrategy.NONE) {
          gp2=subPlan2.getGlobalProperties();
          if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning().isComputablyPartitioned()) {
            if (!partitioningIsOnRightFields(gp1,0) || !gp1.getPartitioning().isComputablyPartitioned()) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning().isCompatibleWith(gp2.getPartitioning()) && partitioningIsOnSameSubkey(gp1.getPartitionedFields(),gp2.getPartitionedFields())) {
                ss2=ShipStrategy.FORWARD;
              }
 else {
                if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                  createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
                }
 else                 if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                  createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
                }
                if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                  createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
                }
 else                 if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                  createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
                }
                continue;
              }
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_RANGE,ShipStrategy.PARTITION_RANGE,estimator);
              }
            }
 else {
              if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
            }
          }
 else {
            createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            if (haveValidOutputEstimates(subPlan1) && haveValidOutputEstimates(subPlan2)) {
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.BROADCAST,ShipStrategy.FORWARD,estimator);
              createLocalAlternatives(outputPlans,subPlan1,subPlan2,ShipStrategy.FORWARD,ShipStrategy.BROADCAST,estimator);
            }
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,1,ss2);
switch (ss2) {
case BROADCAST:
            ss1=ShipStrategy.FORWARD;
          break;
case FORWARD:
        if (partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning().isPartitioned()) {
          if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_HASH;
          }
 else           if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_RANGE;
          }
 else {
            throw new CompilerException();
          }
        }
 else {
          ss1=ShipStrategy.BROADCAST;
        }
      break;
case PARTITION_HASH:
    ss1=(partitioningIsOnSameSubkey(gp1.getPartitionedFields(),this.keySet2) && gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
  break;
case PARTITION_RANGE:
ss1=(partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss2.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,0,ss1);
gp2=subPlan2.getGlobalProperties();
switch (ss1) {
case BROADCAST:
ss2=ShipStrategy.FORWARD;
break;
case FORWARD:
if (partitioningIsOnRightFields(gp1,0) && gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
ss2=ShipStrategy.BROADCAST;
}
break;
case PARTITION_HASH:
ss2=(partitioningIsOnSameSubkey(this.keySet1,gp2.getPartitionedFields()) && partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(partitioningIsOnRightFields(gp2,1) && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss1.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
if ((ss1 == ShipStrategy.BROADCAST && ss2 != ShipStrategy.BROADCAST) || (ss1 != ShipStrategy.BROADCAST && ss2 == ShipStrategy.BROADCAST)) {
createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(subPlan1,this,0,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(subPlan2,this,1,ss2);
if (gp1.getPartitioning().isComputablyPartitioned() && gp1.getPartitioning() == gp2.getPartitioning() && partitioningIsOnSameSubkey(gp1.getPartitionedFields(),gp2.getPartitionedFields())) {
createLocalAlternatives(outputPlans,subPlan1,subPlan2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
}
}"
87562,"/** 
 * Gets the global properties of the source's output after it crossed a pact connection with the given shipping strategy. Global properties are maintained on <tt>FORWARD</tt> connections. If a partitioning happens, then a partitioning property exists afterwards. A <tt>BROADCAST</tt> connection destroys the key uniqueness. <p> If the shipping strategy has not yet been determined, the properties of the connections source are returned.
 * @return The properties of the data after this channel.
 */
public static GlobalProperties getGlobalPropertiesAfterConnection(OptimizerNode source,OptimizerNode target,ShipStrategy shipMode){
  GlobalProperties gp=source.getGlobalProperties().createCopy();
  FieldList keyFields=null;
  int inputNum=0;
  for (  PactConnection conn : target.getIncomingConnections()) {
    if (conn.getSourcePact().getId() == source.getId()) {
      if (conn.getScramblePartitionedFields() != null) {
        throw new CompilerException(""String_Node_Str"");
      }
 else       if (target.getPactContract() instanceof AbstractPact<?>) {
        keyFields=new FieldList(((AbstractPact<?>)target.getPactContract()).getKeyColumnNumbers(inputNum));
      }
      break;
    }
    inputNum++;
  }
switch (shipMode) {
case BROADCAST:
    gp.reset();
  break;
case PARTITION_RANGE:
gp.setPartitioning(PartitionProperty.RANGE_PARTITIONED,keyFields);
break;
case PARTITION_HASH:
gp.setPartitioning(PartitionProperty.HASH_PARTITIONED,keyFields);
gp.setOrdering(null);
break;
case FORWARD:
if (source.getDegreeOfParallelism() > target.getDegreeOfParallelism()) {
gp.setOrdering(null);
}
break;
case NONE:
throw new CompilerException(""String_Node_Str"");
case SFR:
default :
throw new CompilerException(""String_Node_Str"" + shipMode.name());
}
return gp;
}","/** 
 * Gets the global properties of the source's output after it crossed a pact connection with the given shipping strategy. Global properties are maintained on <tt>FORWARD</tt> connections. If a partitioning happens, then a partitioning property exists afterwards. A <tt>BROADCAST</tt> connection destroys the key uniqueness. <p> If the shipping strategy has not yet been determined, the properties of the connections source are returned.
 * @return The properties of the data after this channel.
 */
public static GlobalProperties getGlobalPropertiesAfterConnection(OptimizerNode source,OptimizerNode target,int targetInputNum,ShipStrategy shipMode){
  GlobalProperties gp=source.getGlobalProperties().createCopy();
  FieldList keyFields=null;
  PactConnection conn=target.getIncomingConnections().get(targetInputNum);
  if (conn.getScramblePartitionedFields() != null) {
    throw new CompilerException(""String_Node_Str"");
  }
 else   if (target.getPactContract() instanceof AbstractPact<?>) {
    keyFields=new FieldList(((AbstractPact<?>)target.getPactContract()).getKeyColumnNumbers(targetInputNum));
  }
switch (shipMode) {
case BROADCAST:
    gp.reset();
  break;
case PARTITION_RANGE:
gp.setPartitioning(PartitionProperty.RANGE_PARTITIONED,keyFields);
break;
case PARTITION_HASH:
gp.setPartitioning(PartitionProperty.HASH_PARTITIONED,keyFields);
gp.setOrdering(null);
break;
case FORWARD:
if (source.getDegreeOfParallelism() > target.getDegreeOfParallelism()) {
gp.setOrdering(null);
}
break;
case NONE:
throw new CompilerException(""String_Node_Str"");
case SFR:
default :
throw new CompilerException(""String_Node_Str"" + shipMode.name());
}
return gp;
}"
87563,"@Override protected void computeValidPlanAlternatives(List<? extends OptimizerNode> altSubPlans,CostEstimator estimator,List<OptimizerNode> outputPlans){
  FieldSet keySet=new FieldSet(getPactContract().getKeyColumnNumbers(0));
  ShipStrategy ss=ShipStrategy.NONE;
  ShipStrategy hintSS=this.inConn.getShipStrategy();
  if (hintSS == ShipStrategy.BROADCAST || hintSS == ShipStrategy.SFR)   return;
 else   ss=hintSS;
  for (  OptimizerNode subPlan : altSubPlans) {
    GlobalProperties gp;
    LocalProperties lp;
    if (ss == ShipStrategy.NONE) {
      gp=subPlan.getGlobalProperties();
      lp=subPlan.getLocalProperties();
      if ((partitioningIsOnRightFields(gp) && gp.getPartitioning().isPartitioned()) || isFieldSetUnique(keySet,0)) {
        ss=ShipStrategy.FORWARD;
      }
 else {
        ss=ShipStrategy.PARTITION_HASH;
      }
      gp=PactConnection.getGlobalPropertiesAfterConnection(subPlan,this,ss);
      lp=PactConnection.getLocalPropertiesAfterConnection(subPlan,this,ss);
    }
 else {
      gp=PactConnection.getGlobalPropertiesAfterConnection(subPlan,this,ss);
      lp=PactConnection.getLocalPropertiesAfterConnection(subPlan,this,ss);
      if (!((partitioningIsOnRightFields(gp) && gp.getPartitioning().isPartitioned()) || isFieldSetUnique(keySet,0))) {
        continue;
      }
    }
    boolean localStrategyNeeded=false;
    if (lp.getOrdering() == null || lp.getOrdering().groupsFieldSet(keySet) == false) {
      localStrategyNeeded=true;
    }
    if (localStrategyNeeded && lp.isGrouped() == true) {
      localStrategyNeeded=!lp.getGroupedFields().equals(keySet);
    }
    if (localStrategyNeeded) {
      localStrategyNeeded=!isFieldSetUnique(keySet,0);
    }
    LocalStrategy ls=getLocalStrategy();
    if (localStrategyNeeded) {
      if (ls != LocalStrategy.NONE) {
        if (ls != LocalStrategy.COMBININGSORT && ls != LocalStrategy.SORT) {
          continue;
        }
      }
 else {
        ls=isCombineable() ? LocalStrategy.COMBININGSORT : LocalStrategy.SORT;
      }
    }
    if (ls == LocalStrategy.COMBININGSORT || ls == LocalStrategy.SORT) {
      Ordering ordering=new Ordering();
      for (      Integer index : keySet) {
        ordering.appendOrdering(index,null,Order.ASCENDING);
      }
      lp.setOrdering(ordering);
      lp.setGrouped(true,keySet);
    }
    OptimizerNode reducePred=subPlan;
    if (isCombineable() && ss != ShipStrategy.FORWARD) {
      OptimizerNode combiner=new CombinerNode(getPactContract(),subPlan,this.combinerReducingFactor);
      combiner.setDegreeOfParallelism(subPlan.getDegreeOfParallelism());
      estimator.costOperator(combiner);
      reducePred=combiner;
    }
    ReduceNode n=new ReduceNode(this,reducePred,this.inConn,gp,lp);
    n.inConn.setShipStrategy(ss);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,0);
    n.getLocalProperties().filterByNodesConstantSet(this,0);
    estimator.costOperator(n);
    outputPlans.add(n);
  }
}","@Override protected void computeValidPlanAlternatives(List<? extends OptimizerNode> altSubPlans,CostEstimator estimator,List<OptimizerNode> outputPlans){
  FieldSet keySet=new FieldSet(getPactContract().getKeyColumnNumbers(0));
  ShipStrategy ss=ShipStrategy.NONE;
  ShipStrategy hintSS=this.inConn.getShipStrategy();
  if (hintSS == ShipStrategy.BROADCAST || hintSS == ShipStrategy.SFR)   return;
 else   ss=hintSS;
  for (  OptimizerNode subPlan : altSubPlans) {
    GlobalProperties gp;
    LocalProperties lp;
    if (ss == ShipStrategy.NONE) {
      gp=subPlan.getGlobalProperties();
      lp=subPlan.getLocalProperties();
      if ((partitioningIsOnRightFields(gp) && gp.getPartitioning().isPartitioned()) || isFieldSetUnique(keySet,0)) {
        ss=ShipStrategy.FORWARD;
      }
 else {
        ss=ShipStrategy.PARTITION_HASH;
      }
      gp=PactConnection.getGlobalPropertiesAfterConnection(subPlan,this,0,ss);
      lp=PactConnection.getLocalPropertiesAfterConnection(subPlan,this,ss);
    }
 else {
      gp=PactConnection.getGlobalPropertiesAfterConnection(subPlan,this,0,ss);
      lp=PactConnection.getLocalPropertiesAfterConnection(subPlan,this,ss);
      if (!((partitioningIsOnRightFields(gp) && gp.getPartitioning().isPartitioned()) || isFieldSetUnique(keySet,0))) {
        continue;
      }
    }
    boolean localStrategyNeeded=false;
    if (lp.getOrdering() == null || lp.getOrdering().groupsFieldSet(keySet) == false) {
      localStrategyNeeded=true;
    }
    if (localStrategyNeeded && lp.isGrouped() == true) {
      localStrategyNeeded=!lp.getGroupedFields().equals(keySet);
    }
    if (localStrategyNeeded) {
      localStrategyNeeded=!isFieldSetUnique(keySet,0);
    }
    LocalStrategy ls=getLocalStrategy();
    if (localStrategyNeeded) {
      if (ls != LocalStrategy.NONE) {
        if (ls != LocalStrategy.COMBININGSORT && ls != LocalStrategy.SORT) {
          continue;
        }
      }
 else {
        ls=isCombineable() ? LocalStrategy.COMBININGSORT : LocalStrategy.SORT;
      }
    }
    if (ls == LocalStrategy.COMBININGSORT || ls == LocalStrategy.SORT) {
      Ordering ordering=new Ordering();
      for (      Integer index : keySet) {
        ordering.appendOrdering(index,null,Order.ASCENDING);
      }
      lp.setOrdering(ordering);
      lp.setGrouped(true,keySet);
    }
    OptimizerNode reducePred=subPlan;
    if (isCombineable() && ss != ShipStrategy.FORWARD) {
      OptimizerNode combiner=new CombinerNode(getPactContract(),subPlan,this.combinerReducingFactor);
      combiner.setDegreeOfParallelism(subPlan.getDegreeOfParallelism());
      estimator.costOperator(combiner);
      reducePred=combiner;
    }
    ReduceNode n=new ReduceNode(this,reducePred,this.inConn,gp,lp);
    n.inConn.setShipStrategy(ss);
    n.setLocalStrategy(ls);
    n.getGlobalProperties().filterByNodesConstantSet(this,0);
    n.getLocalProperties().filterByNodesConstantSet(this,0);
    estimator.costOperator(n);
    outputPlans.add(n);
  }
}"
87564,"private final void initFields(final byte[] data,final int begin,final int len){
  try {
    int pos=begin + len - 2;
    int numFields=data[begin + len - 1] & 0xFF;
    if (numFields >= MAX_BIT) {
      int shift=7;
      int curr;
      numFields=numFields & 0x7f;
      while ((curr=data[pos--]) >= MAX_BIT) {
        numFields|=(curr & 0x7f) << shift;
        shift+=7;
      }
      numFields|=curr << shift;
    }
    this.numFields=numFields;
    if (this.offsets == null || this.offsets.length < numFields) {
      this.offsets=new int[numFields];
    }
    if (this.lengths == null || this.lengths.length < numFields) {
      this.lengths=new int[numFields];
    }
    if (this.readFields == null || this.readFields.length < numFields) {
      this.readFields=new Value[numFields];
    }
    if (this.writeFields == null || this.writeFields.length < numFields) {
      this.writeFields=new Value[numFields];
    }
    final int beginMasks=pos;
    final int fieldsBy8=(numFields >>> 3) + ((numFields & 0x7) == 0 ? 0 : 1);
    pos=beginMasks - fieldsBy8;
    int lastNonNullField=-1;
    for (int field=0, chunk=0; chunk < fieldsBy8; chunk++) {
      int mask=data[beginMasks - chunk];
      for (int i=0; i < 8 && field < numFields; i++, field++) {
        if ((mask & 0x1) == 0x1) {
          if (lastNonNullField >= 0) {
            int start=data[pos--] & 0xff;
            if (start >= MAX_BIT) {
              int shift=7;
              int curr;
              start=start & 0x7f;
              while ((curr=data[pos--] & 0xff) >= MAX_BIT) {
                start|=(curr & 0x7f) << shift;
                shift+=7;
              }
              start|=curr << shift;
            }
            this.offsets[field]=start + begin;
            this.lengths[lastNonNullField]=start + begin - this.offsets[lastNonNullField];
          }
 else {
            this.offsets[field]=begin;
          }
          lastNonNullField=field;
        }
 else {
          this.offsets[field]=NULL_INDICATOR_OFFSET;
        }
        mask>>=1;
      }
    }
    if (lastNonNullField >= 0) {
      this.lengths[lastNonNullField]=pos - this.offsets[lastNonNullField] + 1;
    }
    this.firstModifiedPos=Integer.MAX_VALUE;
  }
 catch (  ArrayIndexOutOfBoundsException aioobex) {
    StringBuilder bld=new StringBuilder(len * 4 + 64);
    bld.append(""String_Node_Str"");
    for (int i=0; i < len; i++) {
      int num=data[i + begin] & 0xff;
      bld.append(num);
      if (i < len - 1) {
        bld.append(',');
      }
    }
    throw new RuntimeException(bld.toString(),aioobex);
  }
}","private final void initFields(final byte[] data,final int begin,final int len){
  try {
    int pos=begin + len - 2;
    int numFields=data[begin + len - 1] & 0xFF;
    if (numFields >= MAX_BIT) {
      int shift=7;
      int curr;
      numFields=numFields & 0x7f;
      while ((curr=data[pos--] & 0xff) >= MAX_BIT) {
        numFields|=(curr & 0x7f) << shift;
        shift+=7;
      }
      numFields|=curr << shift;
    }
    this.numFields=numFields;
    if (this.offsets == null || this.offsets.length < numFields) {
      this.offsets=new int[numFields];
    }
    if (this.lengths == null || this.lengths.length < numFields) {
      this.lengths=new int[numFields];
    }
    if (this.readFields == null || this.readFields.length < numFields) {
      this.readFields=new Value[numFields];
    }
    if (this.writeFields == null || this.writeFields.length < numFields) {
      this.writeFields=new Value[numFields];
    }
    final int beginMasks=pos;
    final int fieldsBy8=(numFields >>> 3) + ((numFields & 0x7) == 0 ? 0 : 1);
    pos=beginMasks - fieldsBy8;
    int lastNonNullField=-1;
    for (int field=0, chunk=0; chunk < fieldsBy8; chunk++) {
      int mask=data[beginMasks - chunk];
      for (int i=0; i < 8 && field < numFields; i++, field++) {
        if ((mask & 0x1) == 0x1) {
          if (lastNonNullField >= 0) {
            int start=data[pos--] & 0xff;
            if (start >= MAX_BIT) {
              int shift=7;
              int curr;
              start=start & 0x7f;
              while ((curr=data[pos--] & 0xff) >= MAX_BIT) {
                start|=(curr & 0x7f) << shift;
                shift+=7;
              }
              start|=curr << shift;
            }
            this.offsets[field]=start + begin;
            this.lengths[lastNonNullField]=start + begin - this.offsets[lastNonNullField];
          }
 else {
            this.offsets[field]=begin;
          }
          lastNonNullField=field;
        }
 else {
          this.offsets[field]=NULL_INDICATOR_OFFSET;
        }
        mask>>=1;
      }
    }
    if (lastNonNullField >= 0) {
      this.lengths[lastNonNullField]=pos - this.offsets[lastNonNullField] + 1;
    }
    this.firstModifiedPos=Integer.MAX_VALUE;
  }
 catch (  ArrayIndexOutOfBoundsException aioobex) {
    StringBuilder bld=new StringBuilder(len * 4 + 64);
    bld.append(""String_Node_Str"");
    for (int i=0; i < len; i++) {
      int num=data[i + begin] & 0xff;
      bld.append(num);
      if (i < len - 1) {
        bld.append(',');
      }
    }
    throw new RuntimeException(bld.toString(),aioobex);
  }
}"
87565,"public RandomAccessInputView(ArrayList<MemorySegment> segments,int segmentSize,int limitInLastSegment){
  super(segments.get(0),segmentSize,0);
  this.segments=segments;
  this.currentSegmentIndex=0;
  this.segmentSize=segmentSize;
  this.segmentSizeBits=MathUtils.log2strict(segmentSize);
  this.segmentSizeMask=segmentSize - 1;
  this.limitInLastSegment=limitInLastSegment;
}","public RandomAccessInputView(ArrayList<MemorySegment> segments,int segmentSize,int limitInLastSegment){
  super(segments.get(0),segments.size() > 1 ? segmentSize : limitInLastSegment,0);
  this.segments=segments;
  this.currentSegmentIndex=0;
  this.segmentSize=segmentSize;
  this.segmentSizeBits=MathUtils.log2strict(segmentSize);
  this.segmentSizeMask=segmentSize - 1;
  this.limitInLastSegment=limitInLastSegment;
}"
87566,"@Override public void setReadPosition(long position){
  final int bufferNum=(int)(position >>> this.segmentSizeBits);
  final int offset=(int)(position & this.segmentSizeMask);
  this.currentSegmentIndex=bufferNum;
  seekInput(this.segments.get(bufferNum),offset,this.segmentSize);
}","@Override public void setReadPosition(long position){
  final int bufferNum=(int)(position >>> this.segmentSizeBits);
  final int offset=(int)(position & this.segmentSizeMask);
  this.currentSegmentIndex=bufferNum;
  seekInput(this.segments.get(bufferNum),offset,bufferNum < this.segments.size() - 1 ? this.segmentSize : this.limitInLastSegment);
}"
87567,"/** 
 * Creates a new block location
 * @param blockLocation the original HDFS block location
 */
public DistributedBlockLocation(org.apache.hadoop.fs.BlockLocation blockLocation){
  this.blockLocation=blockLocation;
}","/** 
 * Creates a new block location
 * @param blockLocation the original HDFS block location
 */
public DistributedBlockLocation(final org.apache.hadoop.fs.BlockLocation blockLocation){
  this.blockLocation=blockLocation;
}"
87568,"@Override public long getOffset(){
  return blockLocation.getOffset();
}","/** 
 * {@inheritDoc}
 */
@Override public long getOffset(){
  return this.blockLocation.getOffset();
}"
87569,"@Override public long getLength(){
  return blockLocation.getLength();
}","/** 
 * {@inheritDoc}
 */
@Override public long getLength(){
  return this.blockLocation.getLength();
}"
87570,"@Override public int compareTo(BlockLocation o){
  long diff=getOffset() - o.getOffset();
  return diff < 0 ? -1 : diff > 0 ? 1 : 0;
}","/** 
 * {@inheritDoc}
 */
@Override public int compareTo(final BlockLocation o){
  final long diff=getOffset() - o.getOffset();
  return diff < 0 ? -1 : diff > 0 ? 1 : 0;
}"
87571,"@Override public String[] getHosts() throws IOException {
  return blockLocation.getHosts();
}","/** 
 * {@inheritDoc}
 */
@Override public String[] getHosts() throws IOException {
  if (this.hostnames == null) {
    final String[] hadoopHostnames=blockLocation.getHosts();
    this.hostnames=new String[hadoopHostnames.length];
    for (int i=0; i < hadoopHostnames.length; ++i) {
      this.hostnames[i]=stripHostname(hadoopHostnames[i]);
    }
  }
  return this.hostnames;
}"
87572,"/** 
 * Checks if another thread requested the vertex to cancel while it was in state STARTING. If so, the method clears the respective flag and repeats the cancel request.
 */
private void checkCancelRequestedFlag(){
  if (this.cancelRequested.compareAndSet(true,false)) {
    final TaskCancelResult tsr=cancelTask();
    if (tsr.getReturnCode() != AbstractTaskResult.ReturnCode.SUCCESS || tsr.getReturnCode() != AbstractTaskResult.ReturnCode.TASK_NOT_FOUND) {
      LOG.error(""String_Node_Str"" + this + ""String_Node_Str""+ tsr.getReturnCode().toString()+ ((tsr.getDescription() != null) ? (""String_Node_Str"" + tsr.getDescription() + ""String_Node_Str"") : ""String_Node_Str""));
    }
  }
}","/** 
 * Checks if another thread requested the vertex to cancel while it was in state STARTING. If so, the method clears the respective flag and repeats the cancel request.
 */
private void checkCancelRequestedFlag(){
  if (this.cancelRequested.compareAndSet(true,false)) {
    final TaskCancelResult tsr=cancelTask();
    if (tsr.getReturnCode() != AbstractTaskResult.ReturnCode.SUCCESS && tsr.getReturnCode() != AbstractTaskResult.ReturnCode.TASK_NOT_FOUND) {
      LOG.error(""String_Node_Str"" + this + ""String_Node_Str""+ tsr.getReturnCode().toString()+ ((tsr.getDescription() != null) ? (""String_Node_Str"" + tsr.getDescription() + ""String_Node_Str"") : ""String_Node_Str""));
    }
  }
}"
87573,"/** 
 * {@inheritDoc}
 */
@Override public void setCompressedDataBuffer(Buffer buffer){
  if (buffer == null) {
    this.compressedBuffer=null;
    this.compressedDataBuffer=null;
    this.compressedDataBufferLength=0;
  }
 else {
    this.compressedDataBuffer=getInternalByteBuffer(buffer);
    this.compressedBuffer=buffer;
    this.compressedDataBufferLength=bufferToInt(this.compressedDataBuffer,0);
    this.uncompressedDataBufferLength=bufferToInt(this.compressedDataBuffer,4);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void setCompressedDataBuffer(final MemoryBuffer buffer){
  if (buffer == null) {
    this.compressedBuffer=null;
    this.compressedDataBuffer=null;
    this.compressedDataBufferLength=0;
  }
 else {
    this.compressedDataBuffer=buffer.getByteBuffer();
    this.compressedBuffer=buffer;
    this.compressedDataBufferLength=bufferToInt(this.compressedDataBuffer,0);
    this.uncompressedDataBufferLength=bufferToInt(this.compressedDataBuffer,4);
  }
}"
87574,"public String toString(){
  if (this.indexes.size() == 0) {
    return ""String_Node_Str"";
  }
  final StringBuffer buf=new StringBuffer();
  for (int i=0; i < indexes.size(); i++) {
    if (buf.length() == 0) {
      buf.append(""String_Node_Str"");
    }
 else {
      buf.append(""String_Node_Str"");
    }
    buf.append(this.indexes.get(i));
    buf.append(""String_Node_Str"");
    buf.append(this.types.get(i).getName());
    buf.append(""String_Node_Str"");
    buf.append(this.orders.get(i).name());
  }
  buf.append(""String_Node_Str"");
  return buf.toString();
}","public String toString(){
  if (this.indexes.size() == 0) {
    return ""String_Node_Str"";
  }
  final StringBuffer buf=new StringBuffer();
  for (int i=0; i < indexes.size(); i++) {
    if (buf.length() == 0) {
      buf.append(""String_Node_Str"");
    }
 else {
      buf.append(""String_Node_Str"");
    }
    buf.append(this.indexes.get(i));
    if (this.types.get(i) != null) {
      buf.append(""String_Node_Str"");
      buf.append(this.types.get(i).getName());
    }
    buf.append(""String_Node_Str"");
    buf.append(this.orders.get(i).name());
  }
  buf.append(""String_Node_Str"");
  return buf.toString();
}"
87575,"@Override public void postVisit(OptimizerNode visitable){
  this.jsonString.append(""String_Node_Str"");
  this.jsonString.append(""String_Node_Str"" + this.nodeIds.get(visitable));
  String type;
switch (visitable.getPactType()) {
case DataSink:
    type=""String_Node_Str"";
  break;
case DataSource:
type=""String_Node_Str"";
break;
default :
type=""String_Node_Str"";
break;
}
this.jsonString.append(""String_Node_Str"" + type + ""String_Node_Str"");
String contents;
switch (visitable.getPactType()) {
case DataSink:
contents=visitable.getPactContract().toString();
break;
case DataSource:
contents=visitable.getPactContract().toString();
break;
default :
jsonString.append(""String_Node_Str"" + visitable.getName() + ""String_Node_Str"");
contents=visitable.getPactContract().getName();
break;
}
this.jsonString.append(""String_Node_Str"" + contents + ""String_Node_Str"");
this.jsonString.append(""String_Node_Str"" + (visitable.getDegreeOfParallelism() >= 1 ? visitable.getDegreeOfParallelism() : ""String_Node_Str"") + ""String_Node_Str"");
List<PactConnection> inConns=visitable.getIncomingConnections();
String child1name=""String_Node_Str"", child2name=""String_Node_Str"";
if (inConns != null && inConns.size() > 0) {
this.jsonString.append(""String_Node_Str"");
int connCnt=0;
for (PactConnection conn : inConns) {
this.jsonString.append(connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
if (connCnt == 0) {
child1name+=child1name.length() > 0 ? ""String_Node_Str"" : ""String_Node_Str"";
child1name+=conn.getSourcePact().getPactContract().getName();
}
 else if (connCnt == 1) {
child2name+=child2name.length() > 0 ? ""String_Node_Str"" : ""String_Node_Str"";
child2name=conn.getSourcePact().getPactContract().getName();
}
this.jsonString.append(""String_Node_Str"" + this.nodeIds.get(conn.getSourcePact()));
if (inConns.size() == 2) {
this.jsonString.append(""String_Node_Str"" + (connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
}
String shipStrategy=null;
String channelType=null;
switch (conn.getShipStrategy()) {
case NONE:
break;
case FORWARD:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case BROADCAST:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_RANGE:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_LOCAL_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
case SFR:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + conn.getShipStrategy().name() + ""String_Node_Str"");
}
if (shipStrategy != null) {
this.jsonString.append(""String_Node_Str"" + shipStrategy + ""String_Node_Str"");
}
if (channelType != null) {
this.jsonString.append(""String_Node_Str"" + channelType + ""String_Node_Str"");
}
if (conn.getTempMode() != TempMode.NONE) {
String tempMode=conn.getTempMode().toString();
this.jsonString.append(""String_Node_Str"" + tempMode + ""String_Node_Str"");
}
this.jsonString.append('}');
connCnt++;
}
this.jsonString.append(""String_Node_Str"");
}
String locString=null;
if (visitable.getLocalStrategy() != null) {
switch (visitable.getLocalStrategy()) {
case NONE:
break;
case HYBRIDHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case HYBRIDHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case MMHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case MMHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case SORT_BOTH_MERGE:
locString=""String_Node_Str"";
break;
case SORT_FIRST_MERGE:
locString=""String_Node_Str"";
break;
case SORT_SECOND_MERGE:
locString=""String_Node_Str"";
break;
case MERGE:
locString=""String_Node_Str"";
break;
case SORT:
locString=""String_Node_Str"";
break;
case COMBININGSORT:
locString=""String_Node_Str"";
break;
case SORT_SELF_NESTEDLOOP:
locString=""String_Node_Str"";
break;
case SELF_NESTEDLOOP:
locString=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + visitable.getLocalStrategy().name() + ""String_Node_Str"");
}
if (locString != null) {
this.jsonString.append(""String_Node_Str"");
this.jsonString.append(locString);
this.jsonString.append(""String_Node_Str"");
}
}
{
GlobalProperties gp=visitable.getGlobalProperties();
this.jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",gp.getPartitioning().name(),true);
if (gp.getPartitioning() != PartitionProperty.NONE) {
addProperty(jsonString,""String_Node_Str"",gp.getPartitionedFields().toString(),false);
}
if (gp.getOrdering() != null) {
addProperty(jsonString,""String_Node_Str"",gp.getOrdering().toString(),false);
}
 else {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",false);
}
if (visitable.getUniqueFields() == null || visitable.getUniqueFields().size() == 0) {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",false);
}
 else {
addProperty(jsonString,""String_Node_Str"",visitable.getUniqueFields().toString(),false);
}
this.jsonString.append(""String_Node_Str"");
}
{
LocalProperties lp=visitable.getLocalProperties();
this.jsonString.append(""String_Node_Str"");
if (lp.getOrdering() != null) {
addProperty(jsonString,""String_Node_Str"",lp.getOrdering().toString(),true);
}
 else {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",true);
}
if (visitable.getUniqueFields() == null || visitable.getUniqueFields().size() == 0) {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",false);
}
 else {
addProperty(jsonString,""String_Node_Str"",visitable.getUniqueFields().toString(),false);
}
addProperty(jsonString,""String_Node_Str"",lp.isGrouped() ? ""String_Node_Str"" : ""String_Node_Str"",false);
if (lp.isGrouped()) {
addProperty(jsonString,""String_Node_Str"",lp.getGroupedFields().toString(),false);
}
this.jsonString.append(""String_Node_Str"");
}
this.jsonString.append(""String_Node_Str"");
addProperty(this.jsonString,""String_Node_Str"",visitable.getEstimatedNumRecords() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedNumRecords()),true);
String estCardinality=""String_Node_Str"";
if (visitable.getEstimatedCardinalities().size() > 0) {
estCardinality=""String_Node_Str"";
for (Entry<FieldSet,Long> entry : visitable.getEstimatedCardinalities().entrySet()) {
estCardinality+=""String_Node_Str"" + entry.getKey().toString() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
}
}
addProperty(jsonString,""String_Node_Str"",estCardinality,false);
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedOutputSize() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedOutputSize(),""String_Node_Str""),false);
this.jsonString.append(""String_Node_Str"");
if (visitable.getNodeCosts() != null) {
this.jsonString.append(""String_Node_Str"");
addProperty(this.jsonString,""String_Node_Str"",visitable.getNodeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getNetworkCost(),""String_Node_Str""),true);
addProperty(this.jsonString,""String_Node_Str"",visitable.getNodeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
addProperty(this.jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getNetworkCost(),""String_Node_Str""),false);
addProperty(this.jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
this.jsonString.append(""String_Node_Str"");
}
if (visitable.getPactContract().getCompilerHints() != null) {
CompilerHints hints=visitable.getPactContract().getCompilerHints();
CompilerHints defaults=new CompilerHints();
this.jsonString.append(""String_Node_Str"");
String hintCardinality=""String_Node_Str"";
if (hints.getDistinctCounts().size() > 0) {
hintCardinality=""String_Node_Str"";
for (Entry<FieldSet,Long> entry : visitable.getEstimatedCardinalities().entrySet()) {
hintCardinality+=""String_Node_Str"" + entry.getKey().toString() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
}
}
addProperty(jsonString,""String_Node_Str"",hintCardinality,true);
addProperty(jsonString,""String_Node_Str"",hints.getAvgRecordsEmittedPerStubCall() == defaults.getAvgRecordsEmittedPerStubCall() ? ""String_Node_Str"" : String.valueOf(hints.getAvgRecordsEmittedPerStubCall()),false);
String valuesKey=""String_Node_Str"";
if (hints.getAvgNumRecordsPerDistinctFields().size() > 0) {
valuesKey=""String_Node_Str"";
for (Entry<FieldSet,Float> entry : hints.getAvgNumRecordsPerDistinctFields().entrySet()) {
valuesKey+=""String_Node_Str"" + entry.getKey().toString() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
}
}
addProperty(jsonString,""String_Node_Str"",valuesKey,false);
addProperty(jsonString,""String_Node_Str"",hints.getAvgBytesPerRecord() == defaults.getAvgBytesPerRecord() ? ""String_Node_Str"" : String.valueOf(hints.getAvgBytesPerRecord()),false);
this.jsonString.append(""String_Node_Str"");
}
this.jsonString.append(""String_Node_Str"");
}","@Override public void postVisit(OptimizerNode visitable){
  this.jsonString.append(""String_Node_Str"");
  this.jsonString.append(""String_Node_Str"" + this.nodeIds.get(visitable));
  String type;
switch (visitable.getPactType()) {
case DataSink:
    type=""String_Node_Str"";
  break;
case DataSource:
type=""String_Node_Str"";
break;
default :
type=""String_Node_Str"";
break;
}
this.jsonString.append(""String_Node_Str"" + type + ""String_Node_Str"");
String contents;
switch (visitable.getPactType()) {
case DataSink:
contents=visitable.getPactContract().toString();
break;
case DataSource:
contents=visitable.getPactContract().toString();
break;
default :
jsonString.append(""String_Node_Str"" + visitable.getName() + ""String_Node_Str"");
contents=visitable.getPactContract().getName();
break;
}
this.jsonString.append(""String_Node_Str"" + contents + ""String_Node_Str"");
this.jsonString.append(""String_Node_Str"" + (visitable.getDegreeOfParallelism() >= 1 ? visitable.getDegreeOfParallelism() : ""String_Node_Str"") + ""String_Node_Str"");
List<PactConnection> inConns=visitable.getIncomingConnections();
String child1name=""String_Node_Str"", child2name=""String_Node_Str"";
if (inConns != null && inConns.size() > 0) {
this.jsonString.append(""String_Node_Str"");
int connCnt=0;
for (PactConnection conn : inConns) {
this.jsonString.append(connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
if (connCnt == 0) {
child1name+=child1name.length() > 0 ? ""String_Node_Str"" : ""String_Node_Str"";
child1name+=conn.getSourcePact().getPactContract().getName();
}
 else if (connCnt == 1) {
child2name+=child2name.length() > 0 ? ""String_Node_Str"" : ""String_Node_Str"";
child2name=conn.getSourcePact().getPactContract().getName();
}
this.jsonString.append(""String_Node_Str"" + this.nodeIds.get(conn.getSourcePact()));
if (inConns.size() == 2) {
this.jsonString.append(""String_Node_Str"" + (connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
}
String shipStrategy=null;
String channelType=null;
switch (conn.getShipStrategy()) {
case NONE:
break;
case FORWARD:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case BROADCAST:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_RANGE:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_LOCAL_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case SFR:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + conn.getShipStrategy().name() + ""String_Node_Str"");
}
if (shipStrategy != null) {
this.jsonString.append(""String_Node_Str"" + shipStrategy + ""String_Node_Str"");
}
if (channelType != null) {
this.jsonString.append(""String_Node_Str"" + channelType + ""String_Node_Str"");
}
if (conn.getTempMode() != TempMode.NONE) {
String tempMode=conn.getTempMode().toString();
this.jsonString.append(""String_Node_Str"" + tempMode + ""String_Node_Str"");
}
this.jsonString.append('}');
connCnt++;
}
this.jsonString.append(""String_Node_Str"");
}
String locString=null;
if (visitable.getLocalStrategy() != null) {
switch (visitable.getLocalStrategy()) {
case NONE:
break;
case HYBRIDHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case HYBRIDHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case MMHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case MMHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case SORT_BOTH_MERGE:
locString=""String_Node_Str"";
break;
case SORT_FIRST_MERGE:
locString=""String_Node_Str"";
break;
case SORT_SECOND_MERGE:
locString=""String_Node_Str"";
break;
case MERGE:
locString=""String_Node_Str"";
break;
case SORT:
locString=""String_Node_Str"";
break;
case COMBININGSORT:
locString=""String_Node_Str"";
break;
case SORT_SELF_NESTEDLOOP:
locString=""String_Node_Str"";
break;
case SELF_NESTEDLOOP:
locString=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + visitable.getLocalStrategy().name() + ""String_Node_Str"");
}
if (locString != null) {
this.jsonString.append(""String_Node_Str"");
this.jsonString.append(locString);
this.jsonString.append(""String_Node_Str"");
}
}
{
GlobalProperties gp=visitable.getGlobalProperties();
this.jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",gp.getPartitioning().name(),true);
if (gp.getPartitioning() != PartitionProperty.NONE) {
addProperty(jsonString,""String_Node_Str"",gp.getPartitionedFields().toString(),false);
}
if (gp.getOrdering() != null) {
addProperty(jsonString,""String_Node_Str"",gp.getOrdering().toString(),false);
}
 else {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",false);
}
if (visitable.getUniqueFields() == null || visitable.getUniqueFields().size() == 0) {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",false);
}
 else {
addProperty(jsonString,""String_Node_Str"",visitable.getUniqueFields().toString(),false);
}
this.jsonString.append(""String_Node_Str"");
}
{
LocalProperties lp=visitable.getLocalProperties();
this.jsonString.append(""String_Node_Str"");
if (lp.getOrdering() != null) {
addProperty(jsonString,""String_Node_Str"",lp.getOrdering().toString(),true);
}
 else {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",true);
}
if (visitable.getUniqueFields() == null || visitable.getUniqueFields().size() == 0) {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",false);
}
 else {
addProperty(jsonString,""String_Node_Str"",visitable.getUniqueFields().toString(),false);
}
addProperty(jsonString,""String_Node_Str"",lp.isGrouped() ? ""String_Node_Str"" : ""String_Node_Str"",false);
if (lp.isGrouped()) {
addProperty(jsonString,""String_Node_Str"",lp.getGroupedFields().toString(),false);
}
this.jsonString.append(""String_Node_Str"");
}
this.jsonString.append(""String_Node_Str"");
addProperty(this.jsonString,""String_Node_Str"",visitable.getEstimatedNumRecords() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedNumRecords()),true);
String estCardinality=""String_Node_Str"";
if (visitable.getEstimatedCardinalities().size() > 0) {
estCardinality=""String_Node_Str"";
for (Entry<FieldSet,Long> entry : visitable.getEstimatedCardinalities().entrySet()) {
estCardinality+=""String_Node_Str"" + entry.getKey().toString() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
}
}
addProperty(jsonString,""String_Node_Str"",estCardinality,false);
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedOutputSize() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedOutputSize(),""String_Node_Str""),false);
this.jsonString.append(""String_Node_Str"");
if (visitable.getNodeCosts() != null) {
this.jsonString.append(""String_Node_Str"");
addProperty(this.jsonString,""String_Node_Str"",visitable.getNodeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getNetworkCost(),""String_Node_Str""),true);
addProperty(this.jsonString,""String_Node_Str"",visitable.getNodeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
addProperty(this.jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getNetworkCost(),""String_Node_Str""),false);
addProperty(this.jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
this.jsonString.append(""String_Node_Str"");
}
if (visitable.getPactContract().getCompilerHints() != null) {
CompilerHints hints=visitable.getPactContract().getCompilerHints();
CompilerHints defaults=new CompilerHints();
this.jsonString.append(""String_Node_Str"");
String hintCardinality=""String_Node_Str"";
if (hints.getDistinctCounts().size() > 0) {
hintCardinality=""String_Node_Str"";
for (Entry<FieldSet,Long> entry : visitable.getEstimatedCardinalities().entrySet()) {
hintCardinality+=""String_Node_Str"" + entry.getKey().toString() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
}
}
addProperty(jsonString,""String_Node_Str"",hintCardinality,true);
addProperty(jsonString,""String_Node_Str"",hints.getAvgRecordsEmittedPerStubCall() == defaults.getAvgRecordsEmittedPerStubCall() ? ""String_Node_Str"" : String.valueOf(hints.getAvgRecordsEmittedPerStubCall()),false);
String valuesKey=""String_Node_Str"";
if (hints.getAvgNumRecordsPerDistinctFields().size() > 0) {
valuesKey=""String_Node_Str"";
for (Entry<FieldSet,Float> entry : hints.getAvgNumRecordsPerDistinctFields().entrySet()) {
valuesKey+=""String_Node_Str"" + entry.getKey().toString() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
}
}
addProperty(jsonString,""String_Node_Str"",valuesKey,false);
addProperty(jsonString,""String_Node_Str"",hints.getAvgBytesPerRecord() == defaults.getAvgBytesPerRecord() ? ""String_Node_Str"" : String.valueOf(hints.getAvgBytesPerRecord()),false);
this.jsonString.append(""String_Node_Str"");
}
this.jsonString.append(""String_Node_Str"");
}"
87576,"/** 
 * Collects all vertices with checkpoints from the given execution graph and advices the corresponding task managers to remove those checkpoints.
 * @param executionGraph the execution graph from which the checkpoints shall be removed
 */
private void removeAllCheckpoints(final ExecutionGraph executionGraph){
  final Map<AbstractInstance,SerializableArrayList<ExecutionVertexID>> instanceMap=new HashMap<AbstractInstance,SerializableArrayList<ExecutionVertexID>>();
  final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(executionGraph,true);
  while (it.hasNext()) {
    final ExecutionVertex vertex=it.next();
    final AllocatedResource allocatedResource=vertex.getAllocatedResource();
    if (allocatedResource == null) {
      continue;
    }
    final AbstractInstance abstractInstance=allocatedResource.getInstance();
    if (abstractInstance == null) {
      continue;
    }
    SerializableArrayList<ExecutionVertexID> vertexIDs=instanceMap.get(abstractInstance);
    if (vertexIDs == null) {
      vertexIDs=new SerializableArrayList<ExecutionVertexID>();
      instanceMap.put(abstractInstance,vertexIDs);
    }
    vertexIDs.add(vertex.getID());
  }
  final Iterator<Map.Entry<AbstractInstance,SerializableArrayList<ExecutionVertexID>>> it2=instanceMap.entrySet().iterator();
  while (it2.hasNext()) {
    final Map.Entry<AbstractInstance,SerializableArrayList<ExecutionVertexID>> entry=it2.next();
    final AbstractInstance abstractInstance=entry.getKey();
    if (abstractInstance == null) {
      LOG.error(""String_Node_Str"");
      continue;
    }
    final Runnable runnable=new Runnable(){
      @Override public void run(){
        try {
          abstractInstance.removeCheckpoints(entry.getValue());
        }
 catch (        IOException ioe) {
          LOG.error(StringUtils.stringifyException(ioe));
        }
      }
    }
;
    this.executorService.execute(runnable);
  }
}","/** 
 * Collects all vertices with checkpoints from the given execution graph and advices the corresponding task managers to remove those checkpoints.
 * @param executionGraph the execution graph from which the checkpoints shall be removed
 */
private void removeAllCheckpoints(final ExecutionGraph executionGraph){
  final Map<AbstractInstance,SerializableArrayList<ExecutionVertexID>> instanceMap=new HashMap<AbstractInstance,SerializableArrayList<ExecutionVertexID>>();
  final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(executionGraph,true);
  while (it.hasNext()) {
    final ExecutionVertex vertex=it.next();
    final AllocatedResource allocatedResource=vertex.getAllocatedResource();
    if (allocatedResource == null) {
      continue;
    }
    final AbstractInstance abstractInstance=allocatedResource.getInstance();
    if (abstractInstance == null) {
      continue;
    }
    SerializableArrayList<ExecutionVertexID> vertexIDs=instanceMap.get(abstractInstance);
    if (vertexIDs == null) {
      vertexIDs=new SerializableArrayList<ExecutionVertexID>();
      instanceMap.put(abstractInstance,vertexIDs);
    }
    vertexIDs.add(vertex.getID());
  }
  final Iterator<Map.Entry<AbstractInstance,SerializableArrayList<ExecutionVertexID>>> it2=instanceMap.entrySet().iterator();
  while (it2.hasNext()) {
    final Map.Entry<AbstractInstance,SerializableArrayList<ExecutionVertexID>> entry=it2.next();
    final AbstractInstance abstractInstance=entry.getKey();
    if (abstractInstance == null) {
      LOG.error(""String_Node_Str"");
      continue;
    }
    if (abstractInstance instanceof DummyInstance) {
      continue;
    }
    final Runnable runnable=new Runnable(){
      @Override public void run(){
        try {
          abstractInstance.removeCheckpoints(entry.getValue());
        }
 catch (        IOException ioe) {
          LOG.error(StringUtils.stringifyException(ioe));
        }
      }
    }
;
    this.executorService.execute(runnable);
  }
}"
87577,"/** 
 * Creates a copy of the given   {@link IOReadableWritable} object by an in-memory serialization and subsequentdeserialization.
 * @param original the original object to be copied
 * @return the copy of original object created by the original object's serialization/deserialization methods
 * @throws IOException thrown if an error occurs while creating the copy of the object
 */
@SuppressWarnings(""String_Node_Str"") public static IOReadableWritable createCopy(IOReadableWritable original) throws IOException {
  final ByteArrayOutputStream baos=new ByteArrayOutputStream();
  final DataOutputStream dos=new DataOutputStream(baos);
  original.write(dos);
  final String className=original.getClass().getName();
  if (className == null) {
    fail(""String_Node_Str"");
  }
  Class<? extends IOReadableWritable> clazz=null;
  try {
    clazz=(Class<? extends IOReadableWritable>)Class.forName(className);
  }
 catch (  ClassNotFoundException e) {
    fail(e.getMessage());
  }
  if (clazz == null) {
    fail(""String_Node_Str"" + className);
  }
  IOReadableWritable copy=null;
  try {
    copy=clazz.newInstance();
  }
 catch (  InstantiationException e) {
    fail(e.getMessage());
  }
catch (  IllegalAccessException e) {
    fail(e.getMessage());
  }
  if (copy == null) {
    fail(""String_Node_Str"" + className + ""String_Node_Str"");
  }
  final ByteArrayInputStream bais=new ByteArrayInputStream(baos.toByteArray());
  final DataInputStream dis=new DataInputStream(bais);
  copy.read(dis);
  return copy;
}","/** 
 * Creates a copy of the given   {@link IOReadableWritable} object by an in-memory serialization and subsequentdeserialization.
 * @param original the original object to be copied
 * @return the copy of original object created by the original object's serialization/deserialization methods
 * @throws IOException thrown if an error occurs while creating the copy of the object
 */
@SuppressWarnings(""String_Node_Str"") public static <T extends IOReadableWritable>T createCopy(final T original) throws IOException {
  final ByteArrayOutputStream baos=new ByteArrayOutputStream();
  final DataOutputStream dos=new DataOutputStream(baos);
  original.write(dos);
  final String className=original.getClass().getName();
  if (className == null) {
    fail(""String_Node_Str"");
  }
  Class<T> clazz=null;
  try {
    clazz=(Class<T>)Class.forName(className);
  }
 catch (  ClassNotFoundException e) {
    fail(e.getMessage());
  }
  if (clazz == null) {
    fail(""String_Node_Str"" + className);
  }
  T copy=null;
  try {
    copy=clazz.newInstance();
  }
 catch (  InstantiationException e) {
    fail(e.getMessage());
  }
catch (  IllegalAccessException e) {
    fail(e.getMessage());
  }
  if (copy == null) {
    fail(""String_Node_Str"" + className + ""String_Node_Str"");
  }
  final ByteArrayInputStream bais=new ByteArrayInputStream(baos.toByteArray());
  final DataInputStream dis=new DataInputStream(bais);
  copy.read(dis);
  return copy;
}"
87578,"/** 
 * Unregisters the   {@link ExecutionListener} object for this vertex. This objectwill no longer be notified about particular events during the vertex's lifetime.
 * @param checkpointStateChangeListener the object to be unregistered
 */
public void unregisterExecutionListener(final ExecutionListener executionListener){
  this.executionListeners.remove(executionListener);
}","/** 
 * Unregisters the   {@link ExecutionListener} object for this vertex. This objectwill no longer be notified about particular events during the vertex's lifetime.
 * @param checkpointStateChangeListener the object to be unregistered
 */
public void unregisterExecutionListener(final ExecutionListener executionListener){
  this.executionListeners.remove(Integer.valueOf(executionListener.getPriority()));
}"
87579,"/** 
 * Cancels and removes the task represented by this vertex from the instance it is currently running on. If the task is not currently running, its execution state is simply updated to <code>CANCELLED</code>.
 * @return the result of the task cancel attempt
 */
public TaskCancelResult cancelTask(){
  while (true) {
    final ExecutionState previousState=this.executionState.get();
    if (previousState == ExecutionState.CANCELED) {
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState == ExecutionState.FAILED) {
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState == ExecutionState.FINISHED) {
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState == ExecutionState.CANCELING) {
      return new TaskCancelResult(getID(),ReturnCode.SUCCESS);
    }
    if (previousState == ExecutionState.STARTING) {
      int retry=2000;
      while (this.executionState.get() == ExecutionState.STARTING) {
        if (--retry == 0) {
          return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.ILLEGAL_STATE);
        }
        try {
          Thread.sleep(1);
        }
 catch (        InterruptedException ie) {
          return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.ILLEGAL_STATE);
        }
      }
      continue;
    }
    if (compareAndUpdateExecutionState(previousState,ExecutionState.CANCELING)) {
      if (this.groupVertex.getStageNumber() != this.executionGraph.getIndexOfCurrentExecutionStage()) {
        updateExecutionState(ExecutionState.CANCELED,null);
        return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
      }
      if (previousState != ExecutionState.RUNNING && previousState != ExecutionState.FINISHING && previousState != ExecutionState.REPLAYING) {
        updateExecutionState(ExecutionState.CANCELED,null);
        return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
      }
      if (this.allocatedResource == null) {
        final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.NO_INSTANCE);
        result.setDescription(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
        return result;
      }
      try {
        return this.allocatedResource.getInstance().cancelTask(this.vertexID);
      }
 catch (      IOException e) {
        final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.IPC_ERROR);
        result.setDescription(StringUtils.stringifyException(e));
        return result;
      }
    }
  }
}","/** 
 * Cancels and removes the task represented by this vertex from the instance it is currently running on. If the task is not currently running, its execution state is simply updated to <code>CANCELLED</code>.
 * @return the result of the task cancel attempt
 */
public TaskCancelResult cancelTask(){
  while (true) {
    final ExecutionState previousState=this.executionState.get();
    if (previousState == ExecutionState.CANCELED) {
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState == ExecutionState.FAILED) {
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState == ExecutionState.FINISHED) {
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState == ExecutionState.CANCELING) {
      return new TaskCancelResult(getID(),ReturnCode.SUCCESS);
    }
    if (previousState == ExecutionState.STARTING) {
      this.cancelRequested.set(true);
      if (this.executionState.get() != ExecutionState.STARTING) {
        this.cancelRequested.set(false);
        continue;
      }
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (compareAndUpdateExecutionState(previousState,ExecutionState.CANCELING)) {
      if (this.groupVertex.getStageNumber() != this.executionGraph.getIndexOfCurrentExecutionStage()) {
        updateExecutionState(ExecutionState.CANCELED,null);
        return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
      }
      if (previousState != ExecutionState.RUNNING && previousState != ExecutionState.FINISHING && previousState != ExecutionState.REPLAYING) {
        updateExecutionState(ExecutionState.CANCELED,null);
        return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
      }
      if (this.allocatedResource == null) {
        final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.NO_INSTANCE);
        result.setDescription(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
        return result;
      }
      try {
        return this.allocatedResource.getInstance().cancelTask(this.vertexID);
      }
 catch (      IOException e) {
        final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.IPC_ERROR);
        result.setDescription(StringUtils.stringifyException(e));
        return result;
      }
    }
  }
}"
87580,"public boolean compareAndUpdateExecutionState(final ExecutionState expected,final ExecutionState update){
  if (update == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!this.executionState.compareAndSet(expected,update)) {
    return false;
  }
  ExecutionStateTransition.checkTransition(true,toString(),expected,update);
  final Iterator<ExecutionListener> it=this.executionListeners.values().iterator();
  while (it.hasNext()) {
    it.next().executionStateChanged(this.executionGraph.getJobID(),this.vertexID,update,null);
  }
  return true;
}","public boolean compareAndUpdateExecutionState(final ExecutionState expected,final ExecutionState update){
  if (update == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!this.executionState.compareAndSet(expected,update)) {
    return false;
  }
  ExecutionStateTransition.checkTransition(true,toString(),expected,update);
  final Iterator<ExecutionListener> it=this.executionListeners.values().iterator();
  while (it.hasNext()) {
    it.next().executionStateChanged(this.executionGraph.getJobID(),this.vertexID,update,null);
  }
  checkCancelRequestedFlag();
  return true;
}"
87581,"/** 
 * Updates the vertex's current execution state.
 * @param newExecutionState the new execution state
 * @param optionalMessage an optional message related to the state change
 */
public ExecutionState updateExecutionState(ExecutionState newExecutionState,final String optionalMessage){
  if (newExecutionState == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final ExecutionState currentExecutionState=this.executionState.get();
  if (currentExecutionState == ExecutionState.CANCELING) {
    if (newExecutionState == ExecutionState.FINISHING) {
      return currentExecutionState;
    }
    if (newExecutionState == ExecutionState.FINISHED) {
      LOG.info(""String_Node_Str"" + toString() + ""String_Node_Str"");
      newExecutionState=ExecutionState.CANCELED;
    }
  }
  final ExecutionState previousState=this.executionState.getAndSet(newExecutionState);
  if (previousState == newExecutionState) {
    return previousState;
  }
  ExecutionStateTransition.checkTransition(true,toString(),previousState,newExecutionState);
  final Iterator<ExecutionListener> it=this.executionListeners.values().iterator();
  while (it.hasNext()) {
    it.next().executionStateChanged(this.executionGraph.getJobID(),this.vertexID,newExecutionState,optionalMessage);
  }
  return previousState;
}","/** 
 * Updates the vertex's current execution state.
 * @param newExecutionState the new execution state
 * @param optionalMessage an optional message related to the state change
 */
public ExecutionState updateExecutionState(ExecutionState newExecutionState,final String optionalMessage){
  if (newExecutionState == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final ExecutionState currentExecutionState=this.executionState.get();
  if (currentExecutionState == ExecutionState.CANCELING) {
    if (newExecutionState == ExecutionState.FINISHING) {
      return currentExecutionState;
    }
    if (newExecutionState == ExecutionState.FINISHED) {
      LOG.info(""String_Node_Str"" + toString() + ""String_Node_Str"");
      newExecutionState=ExecutionState.CANCELED;
    }
  }
  final ExecutionState previousState=this.executionState.getAndSet(newExecutionState);
  if (previousState == newExecutionState) {
    return previousState;
  }
  ExecutionStateTransition.checkTransition(true,toString(),previousState,newExecutionState);
  final Iterator<ExecutionListener> it=this.executionListeners.values().iterator();
  while (it.hasNext()) {
    it.next().executionStateChanged(this.executionGraph.getJobID(),this.vertexID,newExecutionState,optionalMessage);
  }
  checkCancelRequestedFlag();
  return previousState;
}"
87582,"public boolean readRecord(PactRecord target,byte[] bytes,int offset,int numBytes){
  PactString str=this.theString;
  if (this.ascii) {
    str.setValueAscii(bytes,offset,numBytes);
  }
 else {
    ByteBuffer byteWrapper=this.byteWrapper;
    if (bytes != byteWrapper.array()) {
      byteWrapper=ByteBuffer.wrap(bytes,0,bytes.length);
      this.byteWrapper=byteWrapper;
    }
    byteWrapper.position(offset);
    byteWrapper.limit(numBytes);
    try {
      CharBuffer result=this.decoder.decode(byteWrapper);
      str.setValue(result);
    }
 catch (    CharacterCodingException e) {
      byte[] copy=new byte[numBytes];
      System.arraycopy(bytes,offset,copy,0,numBytes);
      LOG.warn(""String_Node_Str"" + Arrays.toString(copy),e);
      return false;
    }
  }
  target.clear();
  target.addField(str);
  return true;
}","public boolean readRecord(PactRecord target,byte[] bytes,int offset,int numBytes){
  PactString str=this.theString;
  if (this.ascii) {
    str.setValueAscii(bytes,offset,numBytes);
  }
 else {
    ByteBuffer byteWrapper=this.byteWrapper;
    if (bytes != byteWrapper.array()) {
      byteWrapper=ByteBuffer.wrap(bytes,0,bytes.length);
      this.byteWrapper=byteWrapper;
    }
    byteWrapper.clear();
    byteWrapper.position(offset);
    byteWrapper.limit(offset + numBytes);
    try {
      CharBuffer result=this.decoder.decode(byteWrapper);
      str.setValue(result);
    }
 catch (    CharacterCodingException e) {
      byte[] copy=new byte[numBytes];
      System.arraycopy(bytes,offset,copy,0,numBytes);
      LOG.warn(""String_Node_Str"" + Arrays.toString(copy),e);
      return false;
    }
  }
  target.clear();
  target.addField(str);
  return true;
}"
87583,"/** 
 * Gets the type of the input splits that are processed by this input format.
 * @return The type of the input splits.
 */
public Class<T> getInputSplitType();","/** 
 * Gets the type of the input splits that are processed by this input format.
 * @return The type of the input splits.
 */
public Class<? extends T> getInputSplitType();"
87584,"@Override public Class<GenericInputSplit> getInputSplitType(){
  return GenericInputSplit.class;
}","@Override public Class<? extends GenericInputSplit> getInputSplitType(){
  return GenericInputSplit.class;
}"
87585,"@Override public Class<InputSplit> getInputSplitType(){
  if (this.format == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return (Class<InputSplit>)this.format.getInputSplitType();
}","@SuppressWarnings(""String_Node_Str"") @Override public Class<InputSplit> getInputSplitType(){
  if (this.format == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return (Class<InputSplit>)this.format.getInputSplitType();
}"
87586,"/** 
 * Cancels and removes the task represented by this vertex from the instance it is currently running on. If the task is not currently running, its execution state is simply updated to <code>CANCELLED</code>.
 * @return the result of the task cancel attempt
 */
public TaskCancelResult cancelTask(){
  final ExecutionState previousState=this.executionState.get();
  if (previousState == ExecutionState.CANCELED) {
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (previousState == ExecutionState.FAILED) {
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (previousState == ExecutionState.FINISHED) {
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (updateExecutionState(ExecutionState.CANCELING) != ExecutionState.CANCELING) {
    if (this.groupVertex.getStageNumber() != this.executionGraph.getIndexOfCurrentExecutionStage()) {
      updateExecutionState(ExecutionState.CANCELED,null);
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState == ExecutionState.FINISHED || previousState == ExecutionState.FAILED) {
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState != ExecutionState.RUNNING && previousState != ExecutionState.STARTING && previousState != ExecutionState.FINISHING && previousState != ExecutionState.REPLAYING) {
      updateExecutionState(ExecutionState.CANCELED,null);
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (this.allocatedResource == null) {
      final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.NO_INSTANCE);
      result.setDescription(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
      return result;
    }
    try {
      return this.allocatedResource.getInstance().cancelTask(this.vertexID);
    }
 catch (    IOException e) {
      final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.IPC_ERROR);
      result.setDescription(StringUtils.stringifyException(e));
      return result;
    }
  }
  return new TaskCancelResult(getID(),ReturnCode.SUCCESS);
}","/** 
 * Cancels and removes the task represented by this vertex from the instance it is currently running on. If the task is not currently running, its execution state is simply updated to <code>CANCELLED</code>.
 * @return the result of the task cancel attempt
 */
public TaskCancelResult cancelTask(){
  ExecutionState previousState=this.executionState.get();
  int retry=1000;
  while (previousState == ExecutionState.STARTING) {
    if (--retry == 0) {
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.ILLEGAL_STATE);
    }
    try {
      Thread.sleep(1);
    }
 catch (    InterruptedException ie) {
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.ILLEGAL_STATE);
    }
    previousState=this.executionState.get();
  }
  if (previousState == ExecutionState.CANCELED) {
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (previousState == ExecutionState.FAILED) {
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (previousState == ExecutionState.FINISHED) {
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (updateExecutionState(ExecutionState.CANCELING) != ExecutionState.CANCELING) {
    if (this.groupVertex.getStageNumber() != this.executionGraph.getIndexOfCurrentExecutionStage()) {
      updateExecutionState(ExecutionState.CANCELED,null);
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState == ExecutionState.FINISHED || previousState == ExecutionState.FAILED) {
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState != ExecutionState.RUNNING && previousState != ExecutionState.STARTING && previousState != ExecutionState.FINISHING && previousState != ExecutionState.REPLAYING) {
      updateExecutionState(ExecutionState.CANCELED,null);
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (this.allocatedResource == null) {
      final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.NO_INSTANCE);
      result.setDescription(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
      return result;
    }
    try {
      return this.allocatedResource.getInstance().cancelTask(this.vertexID);
    }
 catch (    IOException e) {
      final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.IPC_ERROR);
      result.setDescription(StringUtils.stringifyException(e));
      return result;
    }
  }
  return new TaskCancelResult(getID(),ReturnCode.SUCCESS);
}"
87587,"@Override public void invoke() throws Exception {
  if (LOG.isInfoEnabled())   LOG.info(getLogString(""String_Node_Str""));
  boolean stubOpen=false;
  this.running=true;
  try {
    try {
      prepare();
    }
 catch (    Throwable t) {
      throw new Exception(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ t.getMessage(),t);
    }
    AbstractPactTask.openChainedTasks(this.chainedTasks,this);
    try {
      Configuration stubConfig=this.config.getStubParameters();
      stubConfig.setInteger(""String_Node_Str"",this.getEnvironment().getIndexInSubtaskGroup());
      stubConfig.setInteger(""String_Node_Str"",this.getEnvironment().getCurrentNumberOfSubtasks());
      if (this.getEnvironment().getTaskName() != null) {
        stubConfig.setString(""String_Node_Str"",this.getEnvironment().getTaskName());
      }
      this.stub.open(stubConfig);
      stubOpen=true;
    }
 catch (    Throwable t) {
      throw new Exception(""String_Node_Str"" + t.getMessage(),t);
    }
    run();
    if (this.running) {
      this.stub.close();
      stubOpen=false;
    }
    this.output.close();
    AbstractPactTask.closeChainedTasks(this.chainedTasks,this);
  }
 catch (  Exception ex) {
    if (stubOpen) {
      try {
        this.stub.close();
      }
 catch (      Throwable t) {
      }
    }
    AbstractPactTask.cancelChainedTasks(this.chainedTasks);
    if (this.running) {
      AbstractPactTask.logAndThrowException(ex,this);
    }
  }
 finally {
    cleanup();
  }
  if (this.running) {
    if (LOG.isInfoEnabled())     LOG.info(getLogString(""String_Node_Str""));
  }
 else {
    if (LOG.isWarnEnabled())     LOG.warn(getLogString(""String_Node_Str""));
  }
}","@Override public void invoke() throws Exception {
  if (LOG.isInfoEnabled())   LOG.info(getLogString(""String_Node_Str""));
  boolean stubOpen=false;
  this.running=true;
  try {
    try {
      prepare();
    }
 catch (    Throwable t) {
      throw new Exception(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ t.getMessage(),t);
    }
    if (!this.running) {
      return;
    }
    AbstractPactTask.openChainedTasks(this.chainedTasks,this);
    try {
      Configuration stubConfig=this.config.getStubParameters();
      stubConfig.setInteger(""String_Node_Str"",this.getEnvironment().getIndexInSubtaskGroup());
      stubConfig.setInteger(""String_Node_Str"",this.getEnvironment().getCurrentNumberOfSubtasks());
      if (this.getEnvironment().getTaskName() != null) {
        stubConfig.setString(""String_Node_Str"",this.getEnvironment().getTaskName());
      }
      this.stub.open(stubConfig);
      stubOpen=true;
    }
 catch (    Throwable t) {
      throw new Exception(""String_Node_Str"" + t.getMessage(),t);
    }
    run();
    if (this.running) {
      this.stub.close();
      stubOpen=false;
    }
    this.output.close();
    AbstractPactTask.closeChainedTasks(this.chainedTasks,this);
  }
 catch (  Exception ex) {
    if (stubOpen) {
      try {
        this.stub.close();
      }
 catch (      Throwable t) {
      }
    }
    AbstractPactTask.cancelChainedTasks(this.chainedTasks);
    if (this.running) {
      AbstractPactTask.logAndThrowException(ex,this);
    }
  }
 finally {
    cleanup();
  }
  if (this.running) {
    if (LOG.isInfoEnabled())     LOG.info(getLogString(""String_Node_Str""));
  }
 else {
    if (LOG.isWarnEnabled())     LOG.warn(getLogString(""String_Node_Str""));
  }
}"
87588,"@Override public void closeTask() throws Exception {
  while (!canceled && this.combinerThread.isAlive()) {
    try {
      this.combinerThread.join();
    }
 catch (    InterruptedException iex) {
    }
  }
  if (this.exception != null) {
    throw new ExceptionInChainedStubException(this.taskName,this.exception);
  }
  if (this.parent != null && this.combinerThread != null) {
    this.parent.userThreadFinished(this.combinerThread);
  }
  this.sorter.close();
  if (this.canceled)   return;
  AbstractPactTask.closeUserCode(this.combiner);
}","@Override public void closeTask() throws Exception {
  while (!this.canceled && this.combinerThread.isAlive()) {
    try {
      this.combinerThread.join();
    }
 catch (    InterruptedException iex) {
      cancelTask();
      throw iex;
    }
  }
  if (this.parent != null && this.combinerThread != null) {
    this.parent.userThreadFinished(this.combinerThread);
  }
  if (this.exception != null) {
    throw new ExceptionInChainedStubException(this.taskName,this.exception);
  }
  this.sorter.close();
  if (this.canceled)   return;
  AbstractPactTask.closeUserCode(this.combiner);
}"
87589,"@Override public void cancelTask(){
  this.canceled=true;
  this.exception=new Exception(""String_Node_Str"");
  this.combinerThread.cancel();
  this.inputCollector.close();
  this.sorter.close();
}","@Override public void cancelTask(){
  this.canceled=true;
  this.exception=new Exception(""String_Node_Str"");
  this.combinerThread.cancel();
  this.inputCollector.close();
  this.sorter.close();
  try {
    this.combinerThread.join();
  }
 catch (  InterruptedException iex) {
  }
 finally {
    if (this.parent != null && this.combinerThread != null) {
      this.parent.userThreadFinished(this.combinerThread);
    }
  }
}"
87590,"/** 
 * Copy constructor to create a copy of a node with a different predecessor. The predecessor is assumed to be of the same type and merely a copy with different strategies, as they are created in the process of the plan enumeration.
 * @param template The node to create a copy of.
 * @param predNode The new predecessor.
 * @param inConn The old connection to copy properties from.
 * @param globalProps The global properties of this copy.
 * @param localProps The local properties of this copy.
 */
protected SingleInputNode(SingleInputNode template,OptimizerNode predNode,PactConnection inConn,GlobalProperties globalProps,LocalProperties localProps){
  super(template,globalProps,localProps);
  this.constantSet=template.constantSet;
  this.keyList=template.keyList;
  this.inConn=new PactConnection(inConn,predNode,this);
  if (predNode.branchPlan != null && predNode.branchPlan.size() > 0) {
    this.branchPlan=new HashMap<OptimizerNode,OptimizerNode>(predNode.branchPlan);
  }
 else {
    this.branchPlan=null;
  }
}","/** 
 * Copy constructor to create a copy of a node with a different predecessor. The predecessor is assumed to be of the same type and merely a copy with different strategies, as they are created in the process of the plan enumeration.
 * @param template The node to create a copy of.
 * @param predNode The new predecessor.
 * @param inConn The old connection to copy properties from.
 * @param globalProps The global properties of this copy.
 * @param localProps The local properties of this copy.
 */
protected SingleInputNode(SingleInputNode template,OptimizerNode predNode,PactConnection inConn,GlobalProperties globalProps,LocalProperties localProps){
  super(template,globalProps,localProps);
  this.constantSet=template.constantSet;
  this.keyList=template.keyList;
  this.inConn=new PactConnection(inConn,predNode,this);
  if (this.branchPlan == null) {
    this.branchPlan=predNode.branchPlan;
  }
 else   if (predNode.branchPlan != null) {
    this.branchPlan.putAll(predNode.branchPlan);
  }
}"
87591,"/** 
 * Reads all stub annotations
 */
private void readStubAnnotations(){
  this.readConstantAnnotation();
  this.readUniqueFieldsAnnotation();
}","/** 
 * Reads all stub annotations
 */
private void readStubAnnotations(){
  this.readConstantAnnotation();
  this.readOutputCardBoundAnnotation();
  this.readUniqueFieldsAnnotation();
}"
87592,"@Override protected void map(final IJsonNode value,final JsonCollector out){
  System.out.println(""String_Node_Str"" + value);
  AnnotatorNodes.annotate(this.output,ANNOTATION_VALUE,value);
  System.out.println(this.output);
  out.collect(this.output);
}","@Override protected void map(final IJsonNode value,final JsonCollector out){
  AnnotatorNodes.annotate(this.output,ANNOTATION_VALUE,value);
  out.collect(this.output);
}"
87593,"@Override public void read(final IJsonNode node){
  if (node == null || !(node instanceof ObjectNode))   throw new IllegalArgumentException(""String_Node_Str"" + node);
  final ObjectNode objectNode=(ObjectNode)node;
  System.out.println(""String_Node_Str"" + node);
  this.key=PointNodes.getId(objectNode).getJavaValue();
  this.values=new ArrayList<String>();
  for (  final IJsonNode valuesNode : PointNodes.getValues(objectNode))   this.values.add(((TextNode)valuesNode).getTextValue());
  this.rowsum=PointNodes.getRowsum(objectNode).getIntValue();
}","@Override public void read(final IJsonNode node){
  if (node == null || !(node instanceof ObjectNode))   throw new IllegalArgumentException(""String_Node_Str"" + node);
  final ObjectNode objectNode=(ObjectNode)node;
  this.key=PointNodes.getId(objectNode).getJavaValue();
  this.values=new ArrayList<String>();
  for (  final IJsonNode valuesNode : PointNodes.getValues(objectNode))   this.values.add(((TextNode)valuesNode).getTextValue());
  this.rowsum=PointNodes.getRowsum(objectNode).getIntValue();
}"
87594,"@Override protected void reduce(final IArrayNode values,final JsonCollector out){
  System.out.println(""String_Node_Str"" + values);
  this.addPoints(values);
  this.cluster();
  this.emitClusters(out);
}","@Override protected void reduce(final IArrayNode values,final JsonCollector out){
  this.addPoints(values);
  this.cluster();
  this.emitClusters(out);
}"
87595,"public static IArrayNode getPoints(final ObjectNode clusterNode){
  return (IArrayNode)clusterNode.get(POINTS);
}","public static IArrayNode getPoints(final ObjectNode clusterNode){
  try {
    return (IArrayNode)clusterNode.get(POINTS);
  }
 catch (  ClassCastException e) {
    System.err.println(clusterNode);
    throw e;
  }
}"
87596,"@Override protected void map(final IJsonNode node,final JsonCollector out){
  System.out.println(""String_Node_Str"" + node);
  final ObjectNode clusterNode=(ObjectNode)node;
  final TextNode idNode=ClusterNodes.getId(clusterNode);
  final IArrayNode pointsNode=ClusterNodes.getPoints(clusterNode);
  for (  final IJsonNode pointNode : pointsNode) {
    this.outputNode.putAll((IObjectNode)pointNode);
    PointNodes.assignCluster(this.outputNode,idNode);
    out.collect(this.outputNode);
  }
}","@Override protected void map(final IJsonNode node,final JsonCollector out){
  final ObjectNode clusterNode=(ObjectNode)node;
  final TextNode idNode=ClusterNodes.getId(clusterNode);
  final IArrayNode pointsNode=ClusterNodes.getPoints(clusterNode);
  for (  final IJsonNode pointNode : pointsNode) {
    this.outputNode.putAll((IObjectNode)pointNode);
    PointNodes.assignCluster(this.outputNode,idNode);
    out.collect(this.outputNode);
  }
}"
87597,"@Override public ElementarySopremoModule asElementaryOperators(){
  final ElementarySopremoModule module=new ElementarySopremoModule(this.getName(),4,2);
  final Source initialClustersInput=module.getInput(0);
  final Source restPointsInput=module.getInput(1);
  final Source treeInput=module.getInput(2);
  final Source representationInput=module.getInput(3);
  final ClusterDisassemble disassemble=new ClusterDisassemble().withInputs(initialClustersInput);
  final PointMapper pointMapper=new PointMapper();
  pointMapper.setInput(PointMapper.POINT_INPUT_INDEX,restPointsInput);
  pointMapper.setInput(PointMapper.TREE_INPUT_INDEX,treeInput);
  final UnionAll pointUnionAll=new UnionAll().withInputs(disassemble,pointMapper);
  final RepresentationUpdate representationUpdate=new RepresentationUpdate().withInputs(representationInput,pointUnionAll);
  representationUpdate.setMaxClusterRadius(this.maxClusterRadius);
  representationUpdate.setMinPointCount(this.minPointCount);
  representationUpdate.setMaxClustroidShift(this.maxClustroidShift);
  representationUpdate.setRepresentationDetail(this.representationDetail);
  module.getOutput(0).setInputs(pointUnionAll);
  module.getOutput(1).setInputs(representationUpdate);
  return module;
}","@Override public ElementarySopremoModule asElementaryOperators(){
  final ElementarySopremoModule module=new ElementarySopremoModule(this.getName(),4,2);
  final Source initialClustersInput=module.getInput(0);
  final Source restPointsInput=module.getInput(1);
  final Source treeInput=module.getInput(2);
  final Source representationInput=module.getInput(3);
  final ClusterDisassemble disassemble=new ClusterDisassemble().withInputs(initialClustersInput);
  final PointMapper pointMapper=new PointMapper().withInputs(restPointsInput,treeInput);
  final UnionAll pointUnionAll=new UnionAll().withInputs(disassemble,pointMapper);
  final RepresentationUpdate representationUpdate=new RepresentationUpdate().withInputs(representationInput,pointUnionAll);
  representationUpdate.setMaxClusterRadius(this.maxClusterRadius);
  representationUpdate.setMinPointCount(this.minPointCount);
  representationUpdate.setMaxClustroidShift(this.maxClustroidShift);
  representationUpdate.setRepresentationDetail(this.representationDetail);
  module.getOutput(0).setInputs(pointUnionAll);
  module.getOutput(1).setInputs(representationUpdate);
  return module;
}"
87598,"@Override protected void cross(final IJsonNode pointNode,final IJsonNode treeNode,final JsonCollector out){
  System.out.println(""String_Node_Str"" + treeNode);
  System.out.println(""String_Node_Str"" + pointNode);
  final ClusterTree tree=new ClusterTree();
  tree.read(treeNode);
  final Point point=new Point();
  point.read(pointNode);
  final String clusterId=tree.findIdOfClusterNextTo(point);
  this.clusterIdNode.setValue(clusterId);
  PointNodes.assignCluster((ObjectNode)pointNode,this.clusterIdNode);
  System.out.println(pointNode);
  out.collect(pointNode);
}","@Override protected void cross(final IJsonNode pointNode,final IJsonNode treeNode,final JsonCollector out){
  final ClusterTree tree=new ClusterTree();
  tree.read(treeNode);
  final Point point=new Point();
  point.read(pointNode);
  final String clusterId=tree.findIdOfClusterNextTo(point);
  this.clusterIdNode.setValue(clusterId);
  PointNodes.assignCluster((ObjectNode)pointNode,this.clusterIdNode);
  out.collect(pointNode);
}"
87599,"@Override protected void coGroup(final IArrayNode representationsNode,final IArrayNode pointsNode,final JsonCollector out){
  if (representationsNode.size() != 1)   throw new IllegalStateException(""String_Node_Str"" + representationsNode.size());
  final ObjectNode representationNode=(ObjectNode)representationsNode.get(0);
  final String id=JsonUtil2.getField(representationNode,""String_Node_Str"",TextNode.class).getJavaValue();
  final Point oldClustroid=new Point();
  oldClustroid.read(representationNode.get(""String_Node_Str""));
  final ClusterRepresentation representation=new ClusterRepresentation(id,oldClustroid,this.representationDetail);
  for (  final IJsonNode memberNode : pointsNode) {
    final Point point=new Point();
    point.read(memberNode);
    representation.add(point);
  }
  this.emitRepresentation(representation,oldClustroid,out);
}","@Override protected void coGroup(final IArrayNode representationsNode,final IArrayNode pointsNode,final JsonCollector out){
  if (representationsNode.size() != 1)   throw new IllegalStateException(""String_Node_Str"" + representationsNode.size());
  final ObjectNode representationNode=(ObjectNode)representationsNode.get(0);
  final String id=JsonUtil2.getField(representationNode,RepresentationNodes.ID,TextNode.class).getJavaValue();
  final Point oldClustroid=new Point();
  oldClustroid.read(representationNode.get(RepresentationNodes.CLUSTROID));
  final ClusterRepresentation representation=new ClusterRepresentation(id,oldClustroid,this.representationDetail);
  for (  final IJsonNode memberNode : pointsNode) {
    final Point point=new Point();
    point.read(memberNode);
    representation.add(point);
  }
  this.emitRepresentation(representation,oldClustroid,out);
}"
87600,"private void emit(final String id,final Point clustroid,final int flag,final String oldId,final JsonCollector collector){
  this.outputNode.clear();
  if (clustroid == null)   throw new IllegalArgumentException(""String_Node_Str"" + id);
  this.idNode.setValue(id);
  this.outputNode.put(""String_Node_Str"",this.idNode);
  this.outputNode.put(""String_Node_Str"",clustroid.write(this.pointNode));
  this.flagNode.setValue(flag);
  this.outputNode.put(""String_Node_Str"",this.flagNode);
  this.oldIdNode.setValue(oldId);
  this.outputNode.put(""String_Node_Str"",this.oldIdNode);
  collector.collect(this.outputNode);
}","private void emit(final String id,final Point clustroid,final int flag,final String oldId,final JsonCollector collector){
  this.outputNode.clear();
  if (clustroid == null)   throw new IllegalArgumentException(""String_Node_Str"" + id);
  this.idNode.setValue(id);
  this.flagNode.setValue(flag);
  this.oldIdNode.setValue(oldId);
  clustroid.write(this.pointNode);
  RepresentationNodes.write(outputNode,idNode,oldIdNode,pointNode);
  RepresentationNodes.setFlag(outputNode,flagNode);
  collector.collect(this.outputNode);
}"
87601,"@Override protected void coGroup(final IArrayNode representationNodes,final IArrayNode pointNodes,final JsonCollector out){
  if (representationNodes.size() != 2)   throw new IllegalArgumentException(""String_Node_Str"" + representationNodes.size());
  final ObjectNode representationNode1=(ObjectNode)representationNodes.get(0);
  final ObjectNode representationNode2=(ObjectNode)representationNodes.get(1);
  this.representation1=RepresentationNodes.read(representationNode1,this.representationDetail);
  this.representation2=RepresentationNodes.read(representationNode2,this.representationDetail);
  this.parentId=RepresentationNodes.getParentId(representationNode1).getTextValue();
  this.addAll(pointNodes);
  this.emitRepresentations(out);
}","@Override protected void coGroup(final IArrayNode representationNodes,final IArrayNode pointNodes,final JsonCollector out){
  final int representationCount=representationNodes.size();
  if (representationCount == 0)   return;
 else   if (representationCount != 2)   throw new IllegalArgumentException(""String_Node_Str"" + representationCount + ""String_Node_Str""+ pointNodes.size()+ ""String_Node_Str"");
  final ObjectNode representationNode1=(ObjectNode)representationNodes.get(0);
  final ObjectNode representationNode2=(ObjectNode)representationNodes.get(1);
  this.representation1=RepresentationNodes.read(representationNode1,this.representationDetail);
  this.representation2=RepresentationNodes.read(representationNode2,this.representationDetail);
  this.parentId=RepresentationNodes.getParentId(representationNode1).getTextValue();
  this.addAll(pointNodes);
  this.emitRepresentations(out);
}"
87602,"@Override public void read(final IJsonNode node){
  this.degree=JsonUtil2.getField(node,JSON_KEY_DEGREE,IntNode.class).getIntValue();
  this.root=this.createInnerNode();
  this.root.read(JsonUtil2.getField(node,JSON_KEY_ROOT,ObjectNode.class));
}","@Override public void read(final IJsonNode node){
  try {
    this.degree=JsonUtil2.getField(node,JSON_KEY_DEGREE,IntNode.class).getIntValue();
  }
 catch (  ClassCastException e) {
    System.out.println(""String_Node_Str"" + node);
    throw e;
  }
  this.root=this.createInnerNode();
  this.root.read(JsonUtil2.getField(node,JSON_KEY_ROOT,ObjectNode.class));
}"
87603,"@Override protected void map(final IJsonNode value,final JsonCollector out){
  System.out.println(""String_Node_Str"" + value);
  final ObjectNode clusterNode=(ObjectNode)value;
  final TextNode idNode=ClusterNodes.getId(clusterNode);
  final ObjectNode clustroidNode=ClusterNodes.getClustroid(clusterNode);
  RepresentationNodes.write(this.outputNode,idNode,clustroidNode);
  AnnotatorNodes.flatAnnotate(this.outputNode,DUMMY_ANNOTATION);
  out.collect(this.outputNode);
}","@Override protected void map(final IJsonNode value,final JsonCollector out){
  final ObjectNode clusterNode=(ObjectNode)value;
  final TextNode idNode=ClusterNodes.getId(clusterNode);
  final ObjectNode clustroidNode=ClusterNodes.getClustroid(clusterNode);
  RepresentationNodes.write(this.outputNode,idNode,clustroidNode);
  AnnotatorNodes.flatAnnotate(this.outputNode,DUMMY_ANNOTATION);
  out.collect(this.outputNode);
}"
87604,"/** 
 * Creates an instance that wraps the plan defined in the jar file using the given arguments. For generating the plan the class defined in the className parameter is used.
 * @param jarFile The jar file which contains the plan.
 * @param className Name of the class which generates the plan. Overrides the class defined in the jar file manifest
 * @param args Optional. The arguments used to create the pact plan, depend on implementation of the pact plan. See getDescription().
 * @throws ProgramInvocationException This invocation is thrown if the PlanAssembler can't be properly loaded. Causes may be a missing / wrong class or manifest files.
 */
public PactProgram(File jarFile,String className,String... args) throws ProgramInvocationException {
  this.jarFile=jarFile;
  this.args=args;
  this.assemblerClass=getPactAssemblerFromJar(jarFile,className);
}","/** 
 * Creates an instance that wraps the plan defined in the jar file using the given arguments. For generating the plan the class defined in the className parameter is used.
 * @param jarFile The jar file which contains the plan.
 * @param className Name of the class which generates the plan. Overrides the class defined in the jar file manifest
 * @param args Optional. The arguments used to create the pact plan, depend on implementation of the pact plan. See getDescription().
 * @throws ProgramInvocationException This invocation is thrown if the PlanAssembler can't be properly loaded. Causes may be a missing / wrong class or manifest files.
 */
public PactProgram(File jarFile,String className,String... args) throws ProgramInvocationException {
  this.jarFile=jarFile;
  this.args=args == null ? new String[0] : args;
  this.assemblerClass=getPactAssemblerFromJar(jarFile,className);
}"
87605,"@Override public boolean readRecord(PactRecord target,byte[] bytes,int offset,int numBytes){
  this.keyString.setValueAscii(bytes,0,1);
  this.valueString.setValueAscii(bytes,2,1);
  target.setField(0,keyString);
  target.setField(1,valueString);
  LOG.debug(""String_Node_Str"" + keyString.getValue() + ""String_Node_Str""+ valueString.getValue()+ ""String_Node_Str"");
  return true;
}","@Override public boolean readRecord(PactRecord target,byte[] bytes,int offset,int numBytes){
  this.keyString.setValueAscii(bytes,offset,1);
  this.valueString.setValueAscii(bytes,offset + 2,1);
  target.setField(0,keyString);
  target.setField(1,valueString);
  LOG.debug(""String_Node_Str"" + keyString.getValue() + ""String_Node_Str""+ valueString.getValue()+ ""String_Node_Str"");
  return true;
}"
87606,"@Override public boolean readRecord(PactRecord target,byte[] bytes,int offset,int numBytes){
  this.keyString.setValueAscii(bytes,0,1);
  this.valueString.setValueAscii(bytes,2,1);
  target.setField(0,keyString);
  target.setField(1,valueString);
  LOG.debug(""String_Node_Str"" + keyString.getValue() + ""String_Node_Str""+ valueString.getValue()+ ""String_Node_Str"");
  return true;
}","@Override public boolean readRecord(PactRecord target,byte[] bytes,int offset,int numBytes){
  this.keyString.setValueAscii(bytes,offset,1);
  this.valueString.setValueAscii(bytes,offset + 2,1);
  target.setField(0,keyString);
  target.setField(1,valueString);
  LOG.debug(""String_Node_Str"" + keyString.getValue() + ""String_Node_Str""+ valueString.getValue()+ ""String_Node_Str"");
  return true;
}"
87607,"@Override public boolean readRecord(PactRecord target,byte[] line,int offset,int numBytes){
  final int limit=offset + numBytes;
  int readPos=offset;
  short[] offsets=new short[MAX_COLUMNS];
  int col=1;
  int countInWrapBuffer=0;
  int startPos=readPos;
  while (readPos < limit) {
    if (line[readPos++] == DELIMITER) {
      offsets[col++]=(short)(countInWrapBuffer + readPos - startPos);
    }
  }
  Tuple value=new Tuple(line,offsets,col - 1);
  PactInteger key=new PactInteger((int)value.getLongValueAt(0));
  target.setField(0,key);
  target.setField(1,value);
  return true;
}","@Override public boolean readRecord(PactRecord target,byte[] line,int offset,int numBytes){
  final int limit=offset + numBytes;
  int readPos=offset;
  final short[] offsets=this.offsets;
  offsets[0]=(short)offset;
  int col=1;
  while (readPos < limit) {
    if (line[readPos++] == DELIMITER) {
      offsets[col++]=(short)(readPos);
    }
  }
  final Tuple value=new Tuple(line,offsets,col - 1);
  this.key.setValue((int)value.getLongValueAt(0));
  target.setField(0,this.key);
  target.setField(1,value);
  return true;
}"
87608,"@Override public void postVisit(OptimizerNode visitable){
  this.jsonString.append(""String_Node_Str"");
  this.jsonString.append(""String_Node_Str"" + this.nodeIds.get(visitable));
  String type;
switch (visitable.getPactType()) {
case DataSink:
    type=""String_Node_Str"";
  break;
case DataSource:
type=""String_Node_Str"";
break;
default :
type=""String_Node_Str"";
break;
}
this.jsonString.append(""String_Node_Str"" + type + ""String_Node_Str"");
String contents;
switch (visitable.getPactType()) {
case DataSink:
contents=visitable.getPactContract().toString();
break;
case DataSource:
contents=visitable.getPactContract().toString();
break;
default :
jsonString.append(""String_Node_Str"" + visitable.getName() + ""String_Node_Str"");
contents=visitable.getPactContract().getName();
break;
}
this.jsonString.append(""String_Node_Str"" + contents + ""String_Node_Str"");
this.jsonString.append(""String_Node_Str"" + (visitable.getDegreeOfParallelism() >= 1 ? visitable.getDegreeOfParallelism() : ""String_Node_Str"") + ""String_Node_Str"");
List<PactConnection> inConns=visitable.getIncomingConnections();
String child1name=""String_Node_Str"", child2name=""String_Node_Str"";
if (inConns != null && inConns.size() > 0) {
this.jsonString.append(""String_Node_Str"");
int connCnt=0;
for (PactConnection conn : inConns) {
this.jsonString.append(""String_Node_Str"");
if (connCnt == 0) {
child1name+=child1name.length() > 0 ? ""String_Node_Str"" : ""String_Node_Str"";
child1name+=conn.getSourcePact().getPactContract().getName();
}
 else if (connCnt == 1) {
child2name+=child2name.length() > 0 ? ""String_Node_Str"" : ""String_Node_Str"";
child2name=conn.getSourcePact().getPactContract().getName();
}
this.jsonString.append(""String_Node_Str"" + this.nodeIds.get(conn.getSourcePact()));
if (inConns.size() == 2) {
this.jsonString.append(""String_Node_Str"" + (connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
}
String shipStrategy=null;
String channelType=null;
switch (conn.getShipStrategy()) {
case NONE:
break;
case FORWARD:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case BROADCAST:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_RANGE:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_LOCAL_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
case SFR:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + conn.getShipStrategy().name() + ""String_Node_Str"");
}
if (shipStrategy != null) {
this.jsonString.append(""String_Node_Str"" + shipStrategy + ""String_Node_Str"");
}
if (channelType != null) {
this.jsonString.append(""String_Node_Str"" + channelType + ""String_Node_Str"");
}
if (conn.getTempMode() != TempMode.NONE) {
String tempMode=conn.getTempMode().toString();
this.jsonString.append(""String_Node_Str"" + tempMode + ""String_Node_Str"");
}
this.jsonString.append('}');
connCnt++;
}
this.jsonString.append(""String_Node_Str"");
}
String locString=null;
if (visitable.getLocalStrategy() != null) {
switch (visitable.getLocalStrategy()) {
case NONE:
break;
case HYBRIDHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case HYBRIDHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case MMHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case MMHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case SORT_BOTH_MERGE:
locString=""String_Node_Str"";
break;
case SORT_FIRST_MERGE:
locString=""String_Node_Str"";
break;
case SORT_SECOND_MERGE:
locString=""String_Node_Str"";
break;
case MERGE:
locString=""String_Node_Str"";
break;
case SORT:
locString=""String_Node_Str"";
break;
case COMBININGSORT:
locString=""String_Node_Str"";
break;
case SORT_SELF_NESTEDLOOP:
locString=""String_Node_Str"";
break;
case SELF_NESTEDLOOP:
locString=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + visitable.getLocalStrategy().name() + ""String_Node_Str"");
}
if (locString != null) {
this.jsonString.append(""String_Node_Str"");
this.jsonString.append(locString);
this.jsonString.append(""String_Node_Str"");
}
}
{
GlobalProperties gp=visitable.getGlobalProperties();
this.jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",gp.getPartitioning().name(),true);
if (gp.getPartitioning() != PartitionProperty.NONE) {
addProperty(jsonString,""String_Node_Str"",gp.getPartitionedFields().toString(),false);
}
if (gp.getOrdering() != null) {
addProperty(jsonString,""String_Node_Str"",gp.getOrdering().toString(),false);
}
 else {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",false);
}
if (visitable.getUniqueFields() == null || visitable.getUniqueFields().size() == 0) {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",false);
}
 else {
addProperty(jsonString,""String_Node_Str"",visitable.getUniqueFields().toString(),false);
}
this.jsonString.append(""String_Node_Str"");
}
{
LocalProperties lp=visitable.getLocalProperties();
this.jsonString.append(""String_Node_Str"");
if (lp.getOrdering() != null) {
addProperty(jsonString,""String_Node_Str"",lp.getOrdering().toString(),true);
}
 else {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",true);
}
if (visitable.getUniqueFields() == null || visitable.getUniqueFields().size() == 0) {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",false);
}
 else {
addProperty(jsonString,""String_Node_Str"",visitable.getUniqueFields().toString(),false);
}
addProperty(jsonString,""String_Node_Str"",lp.isGrouped() ? ""String_Node_Str"" : ""String_Node_Str"",false);
if (lp.isGrouped()) {
addProperty(jsonString,""String_Node_Str"",lp.getGroupedFields().toString(),false);
}
this.jsonString.append(""String_Node_Str"");
}
this.jsonString.append(""String_Node_Str"");
addProperty(this.jsonString,""String_Node_Str"",visitable.getEstimatedNumRecords() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedNumRecords()),true);
String estCardinality=""String_Node_Str"";
if (visitable.getEstimatedCardinalities().size() > 0) {
estCardinality=""String_Node_Str"";
for (Entry<FieldSet,Long> entry : visitable.getEstimatedCardinalities().entrySet()) {
estCardinality+=""String_Node_Str"" + entry.getKey().toString() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
}
}
addProperty(jsonString,""String_Node_Str"",estCardinality,false);
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedOutputSize() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedOutputSize(),""String_Node_Str""),false);
this.jsonString.append(""String_Node_Str"");
if (visitable.getNodeCosts() != null) {
this.jsonString.append(""String_Node_Str"");
addProperty(this.jsonString,""String_Node_Str"",visitable.getNodeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getNetworkCost(),""String_Node_Str""),true);
addProperty(this.jsonString,""String_Node_Str"",visitable.getNodeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
addProperty(this.jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getNetworkCost(),""String_Node_Str""),false);
addProperty(this.jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
this.jsonString.append(""String_Node_Str"");
}
if (visitable.getPactContract().getCompilerHints() != null) {
CompilerHints hints=visitable.getPactContract().getCompilerHints();
CompilerHints defaults=new CompilerHints();
this.jsonString.append(""String_Node_Str"");
String hintCardinality=""String_Node_Str"";
if (hints.getDistinctCounts().size() > 0) {
hintCardinality=""String_Node_Str"";
for (Entry<FieldSet,Long> entry : visitable.getEstimatedCardinalities().entrySet()) {
hintCardinality+=""String_Node_Str"" + entry.getKey().toString() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
}
}
addProperty(jsonString,""String_Node_Str"",hintCardinality,true);
addProperty(jsonString,""String_Node_Str"",hints.getAvgRecordsEmittedPerStubCall() == defaults.getAvgRecordsEmittedPerStubCall() ? ""String_Node_Str"" : String.valueOf(hints.getAvgRecordsEmittedPerStubCall()),false);
String valuesKey=""String_Node_Str"";
if (hints.getAvgNumRecordsPerDistinctFields().size() > 0) {
valuesKey=""String_Node_Str"";
for (Entry<FieldSet,Float> entry : hints.getAvgNumRecordsPerDistinctFields().entrySet()) {
valuesKey+=""String_Node_Str"" + entry.getKey().toString() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
}
}
addProperty(jsonString,""String_Node_Str"",valuesKey,false);
addProperty(jsonString,""String_Node_Str"",hints.getAvgBytesPerRecord() == defaults.getAvgBytesPerRecord() ? ""String_Node_Str"" : String.valueOf(hints.getAvgBytesPerRecord()),false);
this.jsonString.append(""String_Node_Str"");
}
this.jsonString.append(""String_Node_Str"");
}","@Override public void postVisit(OptimizerNode visitable){
  this.jsonString.append(""String_Node_Str"");
  this.jsonString.append(""String_Node_Str"" + this.nodeIds.get(visitable));
  String type;
switch (visitable.getPactType()) {
case DataSink:
    type=""String_Node_Str"";
  break;
case DataSource:
type=""String_Node_Str"";
break;
default :
type=""String_Node_Str"";
break;
}
this.jsonString.append(""String_Node_Str"" + type + ""String_Node_Str"");
String contents;
switch (visitable.getPactType()) {
case DataSink:
contents=visitable.getPactContract().toString();
break;
case DataSource:
contents=visitable.getPactContract().toString();
break;
default :
jsonString.append(""String_Node_Str"" + visitable.getName() + ""String_Node_Str"");
contents=visitable.getPactContract().getName();
break;
}
this.jsonString.append(""String_Node_Str"" + contents + ""String_Node_Str"");
this.jsonString.append(""String_Node_Str"" + (visitable.getDegreeOfParallelism() >= 1 ? visitable.getDegreeOfParallelism() : ""String_Node_Str"") + ""String_Node_Str"");
List<PactConnection> inConns=visitable.getIncomingConnections();
String child1name=""String_Node_Str"", child2name=""String_Node_Str"";
if (inConns != null && inConns.size() > 0) {
this.jsonString.append(""String_Node_Str"");
int connCnt=0;
for (PactConnection conn : inConns) {
this.jsonString.append(connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
if (connCnt == 0) {
child1name+=child1name.length() > 0 ? ""String_Node_Str"" : ""String_Node_Str"";
child1name+=conn.getSourcePact().getPactContract().getName();
}
 else if (connCnt == 1) {
child2name+=child2name.length() > 0 ? ""String_Node_Str"" : ""String_Node_Str"";
child2name=conn.getSourcePact().getPactContract().getName();
}
this.jsonString.append(""String_Node_Str"" + this.nodeIds.get(conn.getSourcePact()));
if (inConns.size() == 2) {
this.jsonString.append(""String_Node_Str"" + (connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
}
String shipStrategy=null;
String channelType=null;
switch (conn.getShipStrategy()) {
case NONE:
break;
case FORWARD:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case BROADCAST:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_RANGE:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_LOCAL_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
case SFR:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + conn.getShipStrategy().name() + ""String_Node_Str"");
}
if (shipStrategy != null) {
this.jsonString.append(""String_Node_Str"" + shipStrategy + ""String_Node_Str"");
}
if (channelType != null) {
this.jsonString.append(""String_Node_Str"" + channelType + ""String_Node_Str"");
}
if (conn.getTempMode() != TempMode.NONE) {
String tempMode=conn.getTempMode().toString();
this.jsonString.append(""String_Node_Str"" + tempMode + ""String_Node_Str"");
}
this.jsonString.append('}');
connCnt++;
}
this.jsonString.append(""String_Node_Str"");
}
String locString=null;
if (visitable.getLocalStrategy() != null) {
switch (visitable.getLocalStrategy()) {
case NONE:
break;
case HYBRIDHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case HYBRIDHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case MMHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case MMHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case SORT_BOTH_MERGE:
locString=""String_Node_Str"";
break;
case SORT_FIRST_MERGE:
locString=""String_Node_Str"";
break;
case SORT_SECOND_MERGE:
locString=""String_Node_Str"";
break;
case MERGE:
locString=""String_Node_Str"";
break;
case SORT:
locString=""String_Node_Str"";
break;
case COMBININGSORT:
locString=""String_Node_Str"";
break;
case SORT_SELF_NESTEDLOOP:
locString=""String_Node_Str"";
break;
case SELF_NESTEDLOOP:
locString=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + visitable.getLocalStrategy().name() + ""String_Node_Str"");
}
if (locString != null) {
this.jsonString.append(""String_Node_Str"");
this.jsonString.append(locString);
this.jsonString.append(""String_Node_Str"");
}
}
{
GlobalProperties gp=visitable.getGlobalProperties();
this.jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",gp.getPartitioning().name(),true);
if (gp.getPartitioning() != PartitionProperty.NONE) {
addProperty(jsonString,""String_Node_Str"",gp.getPartitionedFields().toString(),false);
}
if (gp.getOrdering() != null) {
addProperty(jsonString,""String_Node_Str"",gp.getOrdering().toString(),false);
}
 else {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",false);
}
if (visitable.getUniqueFields() == null || visitable.getUniqueFields().size() == 0) {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",false);
}
 else {
addProperty(jsonString,""String_Node_Str"",visitable.getUniqueFields().toString(),false);
}
this.jsonString.append(""String_Node_Str"");
}
{
LocalProperties lp=visitable.getLocalProperties();
this.jsonString.append(""String_Node_Str"");
if (lp.getOrdering() != null) {
addProperty(jsonString,""String_Node_Str"",lp.getOrdering().toString(),true);
}
 else {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",true);
}
if (visitable.getUniqueFields() == null || visitable.getUniqueFields().size() == 0) {
addProperty(jsonString,""String_Node_Str"",""String_Node_Str"",false);
}
 else {
addProperty(jsonString,""String_Node_Str"",visitable.getUniqueFields().toString(),false);
}
addProperty(jsonString,""String_Node_Str"",lp.isGrouped() ? ""String_Node_Str"" : ""String_Node_Str"",false);
if (lp.isGrouped()) {
addProperty(jsonString,""String_Node_Str"",lp.getGroupedFields().toString(),false);
}
this.jsonString.append(""String_Node_Str"");
}
this.jsonString.append(""String_Node_Str"");
addProperty(this.jsonString,""String_Node_Str"",visitable.getEstimatedNumRecords() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedNumRecords()),true);
String estCardinality=""String_Node_Str"";
if (visitable.getEstimatedCardinalities().size() > 0) {
estCardinality=""String_Node_Str"";
for (Entry<FieldSet,Long> entry : visitable.getEstimatedCardinalities().entrySet()) {
estCardinality+=""String_Node_Str"" + entry.getKey().toString() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
}
}
addProperty(jsonString,""String_Node_Str"",estCardinality,false);
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedOutputSize() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedOutputSize(),""String_Node_Str""),false);
this.jsonString.append(""String_Node_Str"");
if (visitable.getNodeCosts() != null) {
this.jsonString.append(""String_Node_Str"");
addProperty(this.jsonString,""String_Node_Str"",visitable.getNodeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getNetworkCost(),""String_Node_Str""),true);
addProperty(this.jsonString,""String_Node_Str"",visitable.getNodeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
addProperty(this.jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getNetworkCost(),""String_Node_Str""),false);
addProperty(this.jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
this.jsonString.append(""String_Node_Str"");
}
if (visitable.getPactContract().getCompilerHints() != null) {
CompilerHints hints=visitable.getPactContract().getCompilerHints();
CompilerHints defaults=new CompilerHints();
this.jsonString.append(""String_Node_Str"");
String hintCardinality=""String_Node_Str"";
if (hints.getDistinctCounts().size() > 0) {
hintCardinality=""String_Node_Str"";
for (Entry<FieldSet,Long> entry : visitable.getEstimatedCardinalities().entrySet()) {
hintCardinality+=""String_Node_Str"" + entry.getKey().toString() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
}
}
addProperty(jsonString,""String_Node_Str"",hintCardinality,true);
addProperty(jsonString,""String_Node_Str"",hints.getAvgRecordsEmittedPerStubCall() == defaults.getAvgRecordsEmittedPerStubCall() ? ""String_Node_Str"" : String.valueOf(hints.getAvgRecordsEmittedPerStubCall()),false);
String valuesKey=""String_Node_Str"";
if (hints.getAvgNumRecordsPerDistinctFields().size() > 0) {
valuesKey=""String_Node_Str"";
for (Entry<FieldSet,Float> entry : hints.getAvgNumRecordsPerDistinctFields().entrySet()) {
valuesKey+=""String_Node_Str"" + entry.getKey().toString() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
}
}
addProperty(jsonString,""String_Node_Str"",valuesKey,false);
addProperty(jsonString,""String_Node_Str"",hints.getAvgBytesPerRecord() == defaults.getAvgBytesPerRecord() ? ""String_Node_Str"" : String.valueOf(hints.getAvgBytesPerRecord()),false);
this.jsonString.append(""String_Node_Str"");
}
this.jsonString.append(""String_Node_Str"");
}"
87609,"/** 
 * Converts a long to a byte array.
 * @param l the long variable to be converted
 * @param ba the byte array to store the result the of the conversion
 * @param offset the offset indicating at what position inside the byte array the result of the conversion shall be stored
 */
private static void longToByteArray(final long l,final byte[] ba,final int offset){
  for (int i=0; i < Long.SIZE; ++i) {
    final int shift=i << 3;
    ba[offset + Long.SIZE - 1 - i]=(byte)((l & (0xffL << shift)) >>> shift);
  }
}","/** 
 * Converts a long to a byte array.
 * @param l the long variable to be converted
 * @param ba the byte array to store the result the of the conversion
 * @param offset the offset indicating at what position inside the byte array the result of the conversion shall be stored
 */
private static void longToByteArray(final long l,final byte[] ba,final int offset){
  for (int i=0; i < SIZE_OF_LONG; ++i) {
    final int shift=i << 3;
    ba[offset + SIZE_OF_LONG - 1 - i]=(byte)((l & (0xffL << shift)) >>> shift);
  }
}"
87610,"/** 
 * Converts the given byte array to a long.
 * @param ba the byte array to be converted
 * @param offset the offset indicating at which byte inside the array the conversion shall begin
 * @return the long variable
 */
private static long byteArrayToLong(final byte[] ba,final int offset){
  long l=0;
  for (int i=0; i < Long.SIZE; ++i) {
    l|=(ba[offset + Long.SIZE - 1 - i] & 0xffL) << (i << 3);
  }
  return l;
}","/** 
 * Converts the given byte array to a long.
 * @param ba the byte array to be converted
 * @param offset the offset indicating at which byte inside the array the conversion shall begin
 * @return the long variable
 */
private static long byteArrayToLong(final byte[] ba,final int offset){
  long l=0;
  for (int i=0; i < SIZE_OF_LONG; ++i) {
    l|=(ba[offset + SIZE_OF_LONG - 1 - i] & 0xffL) << (i << 3);
  }
  return l;
}"
87611,"/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  final byte[] ba=new byte[SIZE];
  longToByteArray(this.lowerPart,ba,0);
  longToByteArray(this.upperPart,ba,Long.SIZE);
  return StringUtils.byteToHexString(ba);
}","/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  final byte[] ba=new byte[SIZE];
  longToByteArray(this.lowerPart,ba,0);
  longToByteArray(this.upperPart,ba,SIZE_OF_LONG);
  return StringUtils.byteToHexString(ba);
}"
87612,"@Override protected boolean readBufferData(final ReadableByteChannel readableByteChannel) throws IOException {
  final ByteBuffer tempBuffer=getTempBuffer();
  if (!this.bufferDataSerializationStarted) {
    tempBuffer.clear();
    this.bufferDataSerializationStarted=true;
  }
  readableByteChannel.read(tempBuffer);
  if (tempBuffer.hasRemaining()) {
    return true;
  }
  final long offset=byteBufferToLong(tempBuffer);
  final Buffer fileBuffer=BufferFactory.createFromCheckpoint(getSizeOfBuffer(),offset,this.ownerID,this.fileBufferManager,this.distributed);
  setBuffer(fileBuffer);
  this.bufferDataSerializationStarted=false;
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override protected boolean readBufferData(final ReadableByteChannel readableByteChannel) throws IOException {
  final ByteBuffer tempBuffer=getTempBuffer();
  if (!this.bufferDataSerializationStarted) {
    tempBuffer.clear();
    this.bufferDataSerializationStarted=true;
  }
  readableByteChannel.read(tempBuffer);
  if (tempBuffer.hasRemaining()) {
    return true;
  }
  final long offset=byteBufferToLong(tempBuffer);
  final Buffer fileBuffer=BufferFactory.createFromCheckpoint(getSizeOfBuffer(),offset,this.ownerID,this.fileBufferManager,this.distributed);
  setBuffer(fileBuffer);
  this.bufferDataSerializationStarted=false;
  return false;
}"
87613,"private long byteBufferToLong(final ByteBuffer byteBuffer) throws IOException {
  long l=0;
  if (Long.SIZE > byteBuffer.limit()) {
    throw new IOException(""String_Node_Str"" + byteBuffer.limit() + ""String_Node_Str"");
  }
  for (int i=0; i < Long.SIZE; ++i) {
    l|=(byteBuffer.get((Long.SIZE - 1) - i) & 0xffL) << (i << 3);
  }
  return l;
}","private long byteBufferToLong(final ByteBuffer byteBuffer) throws IOException {
  long l=0;
  if (SIZE_OF_LONG > byteBuffer.limit()) {
    throw new IOException(""String_Node_Str"" + byteBuffer.limit() + ""String_Node_Str"");
  }
  for (int i=0; i < SIZE_OF_LONG; ++i) {
    l|=(byteBuffer.get((SIZE_OF_LONG - 1) - i) & 0xffL) << (i << 3);
  }
  return l;
}"
87614,"private void longToByteBuffer(long longToSerialize,ByteBuffer byteBuffer) throws IOException {
  if (Long.SIZE > byteBuffer.capacity()) {
    throw new IOException(""String_Node_Str"" + byteBuffer.limit() + ""String_Node_Str""+ Long.SIZE+ ""String_Node_Str"");
  }
  byteBuffer.limit(Long.SIZE);
  for (int i=0; i < Long.SIZE; ++i) {
    final int shift=i << 3;
    byteBuffer.put((Long.SIZE - 1) - i,(byte)((longToSerialize & (0xffL << shift)) >>> shift));
  }
}","private void longToByteBuffer(long longToSerialize,ByteBuffer byteBuffer) throws IOException {
  if (SIZE_OF_LONG > byteBuffer.capacity()) {
    throw new IOException(""String_Node_Str"" + byteBuffer.limit() + ""String_Node_Str""+ SIZE_OF_LONG+ ""String_Node_Str"");
  }
  byteBuffer.limit(SIZE_OF_LONG);
  for (int i=0; i < SIZE_OF_LONG; ++i) {
    final int shift=i << 3;
    byteBuffer.put((SIZE_OF_LONG - 1) - i,(byte)((longToSerialize & (0xffL << shift)) >>> shift));
  }
}"
87615,"@Override public ElementarySopremoModule asElementaryOperators(){
  final ElementarySopremoModule module=new ElementarySopremoModule(this.getName(),this.getInputs().size(),this.getOutputs().size());
  final Operator<Self> clone=this.clone();
  for (int index=0; index < this.getInputs().size(); index++)   clone.setInput(index,module.getInput(index));
  for (int index=0; index < this.getOutputs().size(); index++)   module.getOutput(index).setInput(index,clone.getOutput(index));
  return module;
}","@Override public ElementarySopremoModule asElementaryOperators(){
  final ElementarySopremoModule module=new ElementarySopremoModule(this.getName(),this.getInputs().size(),this.getOutputs().size());
  final Operator<Self> clone=this.clone();
  for (int index=0; index < this.getInputs().size(); index++)   clone.setInput(index,module.getInput(index));
  final List<JsonStream> outputs=clone.getOutputs();
  for (int index=0; index < outputs.size(); index++)   module.getOutput(index).setInput(index,outputs.get(index));
  return module;
}"
87616,"/** 
 * {@inheritDoc}
 */
@Override public void registerOutputGate(final OutputGate<? extends Record> outputGate){
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public void registerOutputGate(final OutputGate<? extends Record> outputGate){
}"
87617,"/** 
 * {@inheritDoc}
 */
@Override public void registerInputGate(final InputGate<? extends Record> inputGate){
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public void registerInputGate(final InputGate<? extends Record> inputGate){
}"
87618,"/** 
 * Creates the initial edges between the group vertices
 * @param vertexMap the temporary vertex map
 * @throws GraphConversionException if the initial wiring cannot be created
 */
private void createInitialGroupEdges(final HashMap<AbstractJobVertex,ExecutionVertex> vertexMap) throws GraphConversionException {
  Iterator<Map.Entry<AbstractJobVertex,ExecutionVertex>> it=vertexMap.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<AbstractJobVertex,ExecutionVertex> entry=it.next();
    final AbstractJobVertex sjv=entry.getKey();
    final ExecutionVertex sev=entry.getValue();
    final ExecutionGroupVertex sgv=sev.getGroupVertex();
    if (sjv.getNumberOfForwardConnections() != sgv.getEnvironment().getNumberOfOutputGates()) {
      throw new GraphConversionException(""String_Node_Str"" + sjv.getName() + ""String_Node_Str"");
    }
    if (sjv.getNumberOfBackwardConnections() != sgv.getEnvironment().getNumberOfInputGates()) {
      throw new GraphConversionException(""String_Node_Str"" + sjv.getName() + ""String_Node_Str"");
    }
    for (int i=0; i < sjv.getNumberOfForwardConnections(); ++i) {
      final boolean isBroadcast=sgv.getEnvironment().getOutputGate(i).isBroadcast();
      final JobEdge edge=sjv.getForwardConnection(i);
      final AbstractJobVertex tjv=edge.getConnectedVertex();
      final ExecutionVertex tev=vertexMap.get(tjv);
      final ExecutionGroupVertex tgv=tev.getGroupVertex();
      final ChannelType channelType=edge.getChannelType();
      final CompressionLevel compressionLevel=edge.getCompressionLevel();
      final DistributionPattern distributionPattern=edge.getDistributionPattern();
      final boolean userDefinedChannelType=(channelType != null);
      final boolean userDefinedCompressionLevel=(compressionLevel != null);
      final ExecutionGroupEdge groupEdge=sgv.wireTo(tgv,edge.getIndexOfInputGate(),i,channelType,userDefinedChannelType,compressionLevel,userDefinedCompressionLevel,distributionPattern,isBroadcast);
      final ExecutionGate outputGate=new ExecutionGate(new GateID(),sev,groupEdge,false);
      sev.insertOutputGate(i,outputGate);
      final ExecutionGate inputGate=new ExecutionGate(new GateID(),tev,groupEdge,true);
      tev.insertInputGate(edge.getIndexOfInputGate(),inputGate);
    }
  }
}","/** 
 * Creates the initial edges between the group vertices
 * @param vertexMap the temporary vertex map
 * @throws GraphConversionException if the initial wiring cannot be created
 */
private void createInitialGroupEdges(final HashMap<AbstractJobVertex,ExecutionVertex> vertexMap) throws GraphConversionException {
  Iterator<Map.Entry<AbstractJobVertex,ExecutionVertex>> it=vertexMap.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<AbstractJobVertex,ExecutionVertex> entry=it.next();
    final AbstractJobVertex sjv=entry.getKey();
    final ExecutionVertex sev=entry.getValue();
    final ExecutionGroupVertex sgv=sev.getGroupVertex();
    if (sjv.getNumberOfForwardConnections() != sgv.getEnvironment().getNumberOfOutputGates()) {
      throw new GraphConversionException(""String_Node_Str"" + sjv.getName() + ""String_Node_Str"");
    }
    if (sjv.getNumberOfBackwardConnections() != sgv.getEnvironment().getNumberOfInputGates()) {
      throw new GraphConversionException(""String_Node_Str"" + sjv.getName() + ""String_Node_Str"");
    }
    for (int i=0; i < sjv.getNumberOfForwardConnections(); ++i) {
      final boolean isBroadcast=sgv.getEnvironment().getOutputGate(i).isBroadcast();
      final JobEdge edge=sjv.getForwardConnection(i);
      final AbstractJobVertex tjv=edge.getConnectedVertex();
      final ExecutionVertex tev=vertexMap.get(tjv);
      final ExecutionGroupVertex tgv=tev.getGroupVertex();
      ChannelType channelType=edge.getChannelType();
      boolean userDefinedChannelType=true;
      if (channelType == null) {
        userDefinedChannelType=false;
        channelType=ChannelType.NETWORK;
      }
      CompressionLevel compressionLevel=edge.getCompressionLevel();
      boolean userDefinedCompressionLevel=true;
      if (compressionLevel == null) {
        userDefinedCompressionLevel=false;
        compressionLevel=CompressionLevel.NO_COMPRESSION;
      }
      final DistributionPattern distributionPattern=edge.getDistributionPattern();
      final ExecutionGroupEdge groupEdge=sgv.wireTo(tgv,edge.getIndexOfInputGate(),i,channelType,userDefinedChannelType,compressionLevel,userDefinedCompressionLevel,distributionPattern,isBroadcast);
      final ExecutionGate outputGate=new ExecutionGate(new GateID(),sev,groupEdge,false);
      sev.insertOutputGate(i,outputGate);
      final ExecutionGate inputGate=new ExecutionGate(new GateID(),tev,groupEdge,true);
      tev.insertInputGate(edge.getIndexOfInputGate(),inputGate);
    }
  }
}"
87619,"/** 
 * {@inheritDoc}
 */
@Override public void bufferAvailable(){
synchronized (this.pendingReadEventSubscribeRequests) {
    this.pendingReadEventSubscribeRequests.add(this.canceledKey);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void bufferAvailable(){
synchronized (this.pendingReadEventSubscribeRequests) {
    this.pendingReadEventSubscribeRequests.add(this.key);
  }
}"
87620,"private IncomingConnectionBufferAvailListener(final Queue<SelectionKey> pendingReadEventSubscribeRequests,final SelectionKey canceledKey){
  this.pendingReadEventSubscribeRequests=pendingReadEventSubscribeRequests;
  this.canceledKey=canceledKey;
}","private IncomingConnectionBufferAvailListener(final Queue<SelectionKey> pendingReadEventSubscribeRequests,final SelectionKey key){
  this.pendingReadEventSubscribeRequests=pendingReadEventSubscribeRequests;
  this.key=key;
}"
87621,"private void doRead(SelectionKey key){
  final IncomingConnection incomingConnection=(IncomingConnection)key.attachment();
  try {
    incomingConnection.read();
  }
 catch (  EOFException eof) {
    if (incomingConnection.isCloseUnexpected()) {
      final SocketChannel socketChannel=(SocketChannel)key.channel();
      LOG.error(""String_Node_Str"" + socketChannel.socket().getRemoteSocketAddress() + ""String_Node_Str"");
      incomingConnection.reportTransmissionProblem(key,eof);
    }
 else {
      incomingConnection.closeConnection(key);
    }
  }
catch (  IOException ioe) {
    incomingConnection.reportTransmissionProblem(key,ioe);
  }
catch (  InterruptedException e) {
  }
catch (  NoBufferAvailableException e) {
    key.cancel();
    final BufferAvailabilityListener bal=new IncomingConnectionBufferAvailListener(this.pendingReadEventSubscribeRequests,key);
    if (!e.getBufferProvider().registerBufferAvailabilityListener(bal)) {
      final SocketChannel socketChannel=(SocketChannel)key.channel();
      try {
        final SelectionKey newKey=socketChannel.register(this.selector,SelectionKey.OP_READ);
        newKey.attach(incomingConnection);
      }
 catch (      ClosedChannelException e1) {
        incomingConnection.reportTransmissionProblem(key,e1);
      }
    }
  }
}","private void doRead(SelectionKey key){
  final IncomingConnection incomingConnection=(IncomingConnection)key.attachment();
  try {
    incomingConnection.read();
  }
 catch (  EOFException eof) {
    if (incomingConnection.isCloseUnexpected()) {
      final SocketChannel socketChannel=(SocketChannel)key.channel();
      LOG.error(""String_Node_Str"" + socketChannel.socket().getRemoteSocketAddress() + ""String_Node_Str"");
      incomingConnection.reportTransmissionProblem(key,eof);
    }
 else {
      incomingConnection.closeConnection(key);
    }
  }
catch (  IOException ioe) {
    incomingConnection.reportTransmissionProblem(key,ioe);
  }
catch (  InterruptedException e) {
  }
catch (  NoBufferAvailableException e) {
    final SocketChannel socketChannel=(SocketChannel)key.channel();
    try {
      final SelectionKey newKey=socketChannel.register(this.selector,0);
      newKey.attach(incomingConnection);
    }
 catch (    ClosedChannelException e1) {
      incomingConnection.reportTransmissionProblem(key,e1);
    }
    final BufferAvailabilityListener bal=new IncomingConnectionBufferAvailListener(this.pendingReadEventSubscribeRequests,key);
    if (!e.getBufferProvider().registerBufferAvailabilityListener(bal)) {
      try {
        final SelectionKey newKey=socketChannel.register(this.selector,SelectionKey.OP_READ);
        newKey.attach(incomingConnection);
      }
 catch (      ClosedChannelException e1) {
        incomingConnection.reportTransmissionProblem(key,e1);
      }
    }
  }
}"
87622,"@Override public void run(){
  while (!this.isInterrupted()) {
synchronized (this.pendingReadEventSubscribeRequests) {
      while (!this.pendingReadEventSubscribeRequests.isEmpty()) {
        final SelectionKey canceledKey=this.pendingReadEventSubscribeRequests.poll();
        final IncomingConnection incomingConnection=(IncomingConnection)canceledKey.attachment();
        final SocketChannel socketChannel=(SocketChannel)canceledKey.channel();
        try {
          final SelectionKey newKey=socketChannel.register(this.selector,SelectionKey.OP_READ);
          newKey.attach(incomingConnection);
        }
 catch (        ClosedChannelException e) {
          incomingConnection.reportTransmissionProblem(canceledKey,e);
        }
      }
    }
    try {
      this.selector.select(500);
    }
 catch (    IOException e) {
      LOG.error(e);
    }
    final Iterator<SelectionKey> iter=this.selector.selectedKeys().iterator();
    while (iter.hasNext()) {
      final SelectionKey key=iter.next();
      iter.remove();
      if (key.isValid()) {
        if (key.isReadable()) {
          doRead(key);
        }
 else         if (key.isAcceptable()) {
          doAccept(key);
        }
 else {
          LOG.error(""String_Node_Str"" + key);
        }
      }
 else {
        LOG.error(""String_Node_Str"" + key);
      }
    }
  }
  if (this.listeningSocket != null) {
    try {
      this.listeningSocket.close();
    }
 catch (    IOException ioe) {
      LOG.debug(ioe);
    }
  }
  try {
    this.selector.close();
  }
 catch (  IOException ioe) {
    LOG.debug(StringUtils.stringifyException(ioe));
  }
}","@Override public void run(){
  while (!this.isInterrupted()) {
synchronized (this.pendingReadEventSubscribeRequests) {
      while (!this.pendingReadEventSubscribeRequests.isEmpty()) {
        final SelectionKey key=this.pendingReadEventSubscribeRequests.poll();
        final IncomingConnection incomingConnection=(IncomingConnection)key.attachment();
        final SocketChannel socketChannel=(SocketChannel)key.channel();
        try {
          final SelectionKey newKey=socketChannel.register(this.selector,SelectionKey.OP_READ);
          newKey.attach(incomingConnection);
        }
 catch (        ClosedChannelException e) {
          incomingConnection.reportTransmissionProblem(key,e);
        }
      }
    }
    try {
      this.selector.select(500);
    }
 catch (    IOException e) {
      LOG.error(e);
    }
    final Iterator<SelectionKey> iter=this.selector.selectedKeys().iterator();
    while (iter.hasNext()) {
      final SelectionKey key=iter.next();
      iter.remove();
      if (key.isValid()) {
        if (key.isReadable()) {
          doRead(key);
        }
 else         if (key.isAcceptable()) {
          doAccept(key);
        }
 else {
          LOG.error(""String_Node_Str"" + key);
        }
      }
 else {
        LOG.error(""String_Node_Str"" + key);
      }
    }
  }
  if (this.listeningSocket != null) {
    try {
      this.listeningSocket.close();
    }
 catch (    IOException ioe) {
      LOG.debug(ioe);
    }
  }
  try {
    this.selector.close();
  }
 catch (  IOException ioe) {
    LOG.debug(StringUtils.stringifyException(ioe));
  }
}"
87623,"/** 
 * Removes the checkpoint of the vertex with the given ID. All files contained in the checkpoint are deleted.
 * @param vertexID the vertex whose checkpoint shall be removed
 */
public static void removeCheckpoint(final ExecutionVertexID vertexID){
  final Path localChPath=getLocalCheckpointPath();
  try {
    if (!removeCheckpointMetaData(new Path(localChPath + Path.SEPARATOR + METADATA_PREFIX+ ""String_Node_Str""+ vertexID))) {
      final Path distributedChPath=getDistributedCheckpointPath();
      if (distributedChPath != null) {
        removeCheckpointMetaData(new Path(distributedChPath + Path.SEPARATOR + METADATA_PREFIX+ ""String_Node_Str""+ vertexID));
      }
    }
    FileBufferManager.deleteFile(vertexID);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Removes the checkpoint of the vertex with the given ID. All files contained in the checkpoint are deleted.
 * @param vertexID the vertex whose checkpoint shall be removed
 */
public static void removeCheckpoint(final ExecutionVertexID vertexID){
  final Path localChPath=getLocalCheckpointPath();
  try {
    if (!removeCheckpointMetaData(new Path(localChPath + Path.SEPARATOR + METADATA_PREFIX+ ""String_Node_Str""+ vertexID))) {
      final Path distributedChPath=getDistributedCheckpointPath();
      if (distributedChPath != null && allowDistributedCheckpoints()) {
        removeCheckpointMetaData(new Path(distributedChPath + Path.SEPARATOR + METADATA_PREFIX+ ""String_Node_Str""+ vertexID));
      }
    }
    FileBufferManager.deleteFile(vertexID);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
87624,"private static boolean checkForCheckpoint(final ExecutionVertexID vertexID,final String suffix){
  try {
    final Path local=new Path(getLocalCheckpointPath() + Path.SEPARATOR + METADATA_PREFIX+ ""String_Node_Str""+ vertexID+ suffix);
    final FileSystem localFs=local.getFileSystem();
    if (localFs.exists(local)) {
      return true;
    }
    final Path distributedCheckpointPath=getDistributedCheckpointPath();
    if (distributedCheckpointPath == null) {
      return false;
    }
    final Path distributed=new Path(distributedCheckpointPath + Path.SEPARATOR + METADATA_PREFIX+ ""String_Node_Str""+ vertexID+ suffix);
    final FileSystem distFs=distributed.getFileSystem();
    return distFs.exists(distributed);
  }
 catch (  IOException ioe) {
    LOG.warn(StringUtils.stringifyException(ioe));
  }
  return false;
}","private static boolean checkForCheckpoint(final ExecutionVertexID vertexID,final String suffix){
  try {
    final Path local=new Path(getLocalCheckpointPath() + Path.SEPARATOR + METADATA_PREFIX+ ""String_Node_Str""+ vertexID+ suffix);
    final FileSystem localFs=local.getFileSystem();
    if (localFs.exists(local)) {
      return true;
    }
    if (!allowDistributedCheckpoints()) {
      return false;
    }
    final Path distributedCheckpointPath=getDistributedCheckpointPath();
    if (distributedCheckpointPath == null) {
      return false;
    }
    final Path distributed=new Path(distributedCheckpointPath + Path.SEPARATOR + METADATA_PREFIX+ ""String_Node_Str""+ vertexID+ suffix);
    final FileSystem distFs=distributed.getFileSystem();
    return distFs.exists(distributed);
  }
 catch (  IOException ioe) {
    LOG.warn(StringUtils.stringifyException(ioe));
  }
  return false;
}"
87625,"WriteThread(final FileBufferManager fileBufferManager,final ExecutionVertexID vertexID,final int numberOfConnectedChannels){
  super(""String_Node_Str"" + vertexID);
  this.fileBufferManager=fileBufferManager;
  this.vertexID=vertexID;
  this.numberOfConnectedChannels=numberOfConnectedChannels;
  this.queuedEnvelopes=new ArrayBlockingQueue<TransferEnvelope>(256);
  final boolean dist=CheckpointUtils.createDistributedCheckpoint();
  if (dist) {
    final Path p=CheckpointUtils.getDistributedCheckpointPath();
    if (p == null) {
      LOG.error(""String_Node_Str"");
      this.checkpointPath=CheckpointUtils.getLocalCheckpointPath();
      this.distributed=false;
    }
 else {
      this.checkpointPath=p;
      this.distributed=true;
    }
  }
 else {
    this.checkpointPath=CheckpointUtils.getLocalCheckpointPath();
    this.distributed=false;
  }
}","WriteThread(final FileBufferManager fileBufferManager,final ExecutionVertexID vertexID,final int numberOfConnectedChannels){
  super(""String_Node_Str"" + vertexID);
  this.fileBufferManager=fileBufferManager;
  this.vertexID=vertexID;
  this.numberOfConnectedChannels=numberOfConnectedChannels;
  this.queuedEnvelopes=new ArrayBlockingQueue<TransferEnvelope>(256);
  final boolean dist=CheckpointUtils.allowDistributedCheckpoints();
  if (dist) {
    final Path p=CheckpointUtils.getDistributedCheckpointPath();
    if (p == null) {
      LOG.error(""String_Node_Str"");
      this.checkpointPath=CheckpointUtils.getLocalCheckpointPath();
      this.distributed=false;
    }
 else {
      this.checkpointPath=p;
      this.distributed=true;
    }
  }
 else {
    this.checkpointPath=CheckpointUtils.getLocalCheckpointPath();
    this.distributed=false;
  }
}"
87626,"public static boolean deleteFile(final AbstractID ownerID){
  final FileBufferManager fbm=getInstance();
  final File f=fbm.constructLocalFile(ownerID);
  if (f.exists()) {
    System.out.println(""String_Node_Str"" + f);
    f.delete();
    return true;
  }
  if (fbm.distributedTempPath != null) {
    final Path p=fbm.constructDistributedPath(ownerID);
    try {
      final FileSystem fs=p.getFileSystem();
      if (fs.exists(p)) {
        fs.delete(p,false);
        return true;
      }
    }
 catch (    IOException ioe) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(StringUtils.stringifyException(ioe));
      }
    }
  }
  return false;
}","public static boolean deleteFile(final AbstractID ownerID){
  final FileBufferManager fbm=getInstance();
  final File f=fbm.constructLocalFile(ownerID);
  if (f.exists()) {
    f.delete();
    return true;
  }
  if (fbm.distributedTempPath != null) {
    final Path p=fbm.constructDistributedPath(ownerID);
    try {
      final FileSystem fs=p.getFileSystem();
      if (fs.exists(p)) {
        fs.delete(p,false);
        return true;
      }
    }
 catch (    IOException ioe) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(StringUtils.stringifyException(ioe));
      }
    }
  }
  return false;
}"
87627,"/** 
 * Constructs a new file buffer manager object.
 */
private FileBufferManager(){
  this.tmpDirs=GlobalConfiguration.getString(ConfigConstants.TASK_MANAGER_TMP_DIR_KEY,ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH).split(""String_Node_Str"");
  for (int i=0; i < this.tmpDirs.length; i++) {
    File f=new File(this.tmpDirs[i]);
    if (!(f.exists() && f.isDirectory() && f.canWrite())) {
      LOG.error(""String_Node_Str"" + f.getAbsolutePath() + ""String_Node_Str""+ ""String_Node_Str""+ ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH);
      this.tmpDirs[i]=ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH;
    }
    this.tmpDirs[i]=this.tmpDirs[i] + File.separator + FILE_BUFFER_PREFIX;
  }
  this.bufferSize=GlobalConfiguration.getInteger(""String_Node_Str"",64 * 1024);
  this.fileMap=new ConcurrentHashMap<AbstractID,ChannelWithAccessInfo>(2048,0.8f,64);
  this.distributedTempPath=CheckpointUtils.getDistributedCheckpointPath();
  FileSystem distFS=null;
  if (this.distributedTempPath != null) {
    try {
      distFS=this.distributedTempPath.getFileSystem();
      if (!distFS.exists(this.distributedTempPath)) {
        distFS.mkdirs(this.distributedTempPath);
      }
    }
 catch (    IOException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
  this.distributedFileSystem=distFS;
}","/** 
 * Constructs a new file buffer manager object.
 */
private FileBufferManager(){
  this.tmpDirs=GlobalConfiguration.getString(ConfigConstants.TASK_MANAGER_TMP_DIR_KEY,ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH).split(""String_Node_Str"");
  for (int i=0; i < this.tmpDirs.length; i++) {
    File f=new File(this.tmpDirs[i]);
    if (!(f.exists() && f.isDirectory() && f.canWrite())) {
      LOG.error(""String_Node_Str"" + f.getAbsolutePath() + ""String_Node_Str""+ ""String_Node_Str""+ ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH);
      this.tmpDirs[i]=ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH;
    }
    this.tmpDirs[i]=this.tmpDirs[i] + File.separator + FILE_BUFFER_PREFIX;
  }
  this.bufferSize=GlobalConfiguration.getInteger(""String_Node_Str"",64 * 1024);
  this.fileMap=new ConcurrentHashMap<AbstractID,ChannelWithAccessInfo>(2048,0.8f,64);
  this.distributedTempPath=CheckpointUtils.getDistributedCheckpointPath();
  FileSystem distFS=null;
  if (this.distributedTempPath != null && CheckpointUtils.allowDistributedCheckpoints()) {
    try {
      distFS=this.distributedTempPath.getFileSystem();
      if (!distFS.exists(this.distributedTempPath)) {
        distFS.mkdirs(this.distributedTempPath);
      }
    }
 catch (    IOException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
  this.distributedFileSystem=distFS;
}"
87628,"/** 
 * {@inheritDoc}
 */
@Override public Buffer requestEmptyBuffer(final int minimumSizeOfBuffer) throws IOException {
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public Buffer requestEmptyBuffer(final int minimumSizeOfBuffer) throws IOException {
  return this.inputGateContext.requestEmptyBuffer(minimumSizeOfBuffer);
}"
87629,"/** 
 * {@inheritDoc}
 */
@Override protected boolean readBufferData(final ReadableByteChannel readableByteChannel) throws IOException {
  if (getBuffer() == null) {
    try {
      if (!getDeserializedJobID().equals(this.lastDeserializedJobID) || !getDeserializedSourceID().equals(this.lastDeserializedSourceID)) {
        this.bufferProvider=this.bufferProviderBroker.getBufferProvider(getDeserializedJobID(),getDeserializedSourceID());
        this.lastDeserializedJobID=getDeserializedJobID();
        this.lastDeserializedSourceID=getDeserializedSourceID();
      }
      setBuffer(this.bufferProvider.requestEmptyBufferBlocking(getSizeOfBuffer()));
      if (getBuffer() == null) {
        Thread.sleep(100);
        return true;
      }
    }
 catch (    InterruptedException e) {
      return true;
    }
  }
 else {
    final Buffer buffer=getBuffer();
    final int bytesWritten=buffer.write(readableByteChannel);
    if (!buffer.hasRemaining()) {
      buffer.finishWritePhase();
      return false;
    }
 else {
      if (bytesWritten == -1) {
        throw new IOException(""String_Node_Str"" + buffer.remaining() + ""String_Node_Str"");
      }
    }
  }
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override protected boolean readBufferData(final ReadableByteChannel readableByteChannel) throws IOException {
  if (getBuffer() == null) {
    try {
      if (!getDeserializedJobID().equals(this.lastDeserializedJobID) || !getDeserializedSourceID().equals(this.lastDeserializedSourceID)) {
        this.bufferProvider=this.bufferProviderBroker.getBufferProvider(getDeserializedJobID(),getDeserializedSourceID());
        this.lastDeserializedJobID=getDeserializedJobID();
        this.lastDeserializedSourceID=getDeserializedSourceID();
      }
      final Buffer buf=this.bufferProvider.requestEmptyBuffer(getSizeOfBuffer());
      if (buf == null) {
        Thread.sleep(1);
        return true;
      }
      setBuffer(buf);
    }
 catch (    InterruptedException e) {
      return true;
    }
  }
 else {
    final Buffer buffer=getBuffer();
    final int bytesWritten=buffer.write(readableByteChannel);
    if (!buffer.hasRemaining()) {
      buffer.finishWritePhase();
      return false;
    }
 else {
      if (bytesWritten == -1) {
        throw new IOException(""String_Node_Str"" + buffer.remaining() + ""String_Node_Str"");
      }
    }
  }
  return true;
}"
87630,"@Override public String toString(){
  return ""String_Node_Str"" + this.cluster1 + ""String_Node_Str""+ this.cluster2+ ""String_Node_Str""+ this.distance+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + clusters.size() + ""String_Node_Str""+ distancedPairs+ ""String_Node_Str"";
}"
87631,"private void cluster(){
  while (this.queue.getNumberOfClusters() > 1) {
    final ClusterPair pair=this.queue.getFirstElement();
    final HierarchicalCluster cluster1=pair.getCluster1();
    final HierarchicalCluster cluster2=pair.getCluster2();
    final HierarchicalCluster mergedCluster=new MergedCluster(cluster1,cluster2,this.createNewId());
    this.queue.removeCluster(cluster1);
    this.queue.removeCluster(cluster2);
    final boolean makeFinal=this.canBeFinal(mergedCluster);
    mergedCluster.makeFinal(makeFinal);
    if (makeFinal)     this.queue.add(mergedCluster);
 else     for (    final HierarchicalCluster child : mergedCluster.getChildren())     this.clusters.add(child);
  }
  this.clusters.addAll(this.queue.getClusters());
  this.queue=null;
}","private void cluster(){
  while (this.queue.getNumberOfClusters() > 1) {
    final ClusterPair pair=this.queue.getFirstElement();
    if (pair.getDistance() > maxRadius) {
      break;
    }
    final HierarchicalCluster cluster1=pair.getCluster1();
    final HierarchicalCluster cluster2=pair.getCluster2();
    final HierarchicalCluster mergedCluster=new MergedCluster(cluster1,cluster2,this.createNewId());
    this.queue.removeCluster(cluster1);
    this.queue.removeCluster(cluster2);
    final boolean makeFinal=this.canBeFinal(mergedCluster);
    mergedCluster.makeFinal(makeFinal);
    if (makeFinal)     this.queue.add(mergedCluster);
 else     for (    final HierarchicalCluster child : mergedCluster.getChildren())     this.clusters.add(child);
  }
  this.clusters.addAll(this.queue.getClusters());
  this.queue=null;
}"
87632,"private void emit(final HierarchicalCluster cluster,final JsonCollector out){
  if (cluster.isFinal()) {
    this.pointsNode.clear();
    for (    final Point point : cluster.getPoints())     this.pointsNode.add(point.write((IJsonNode)null));
    this.idNode.setValue(cluster.getId());
    JsonUtil2.copy(this.pointsNode,cluster.getPoints());
    ClusterNodes.write(this.outputNode,this.idNode,this.clustroidNode,this.pointsNode);
    out.collect(this.outputNode);
  }
 else   for (  final HierarchicalCluster child : cluster.getChildren())   this.emit(child,out);
}","private void emit(final HierarchicalCluster cluster,final JsonCollector out){
  if (cluster.isFinal()) {
    this.pointsNode.clear();
    for (    final Point point : cluster.getPoints())     this.pointsNode.add(point.write((IJsonNode)null));
    this.idNode.setValue(cluster.getId());
    cluster.getClustroid().write(this.clustroidNode);
    ClusterNodes.write(this.outputNode,this.idNode,this.clustroidNode,this.pointsNode);
    out.collect(this.outputNode);
  }
 else   for (  final HierarchicalCluster child : cluster.getChildren())   this.emit(child,out);
}"
87633,"public static void annotate(final ObjectNode node,final IntNode annotation,final IJsonNode annotatee){
  node.put(ANNOTATION,annotation);
  node.put(ANNOTATEE,annotatee);
}","public static void annotate(final ObjectNode node,String annotationKey,final IntNode annotation,String annotateeKey,final IJsonNode annotatee){
  node.put(annotationKey,annotation);
  node.put(annotateeKey,annotatee);
}"
87634,"public static void copy(final IArrayNode array,final JsonSerializable... values){
  array.clear();
  for (  final JsonSerializable value : values)   array.add(value.write(null));
}","public static void copy(final IArrayNode array,final Iterable<JsonSerializable> values){
  array.clear();
  for (  final JsonSerializable value : values)   array.add(value.write(null));
}"
87635,"@Test public void testSequentialClustering(){
  final SequentialClustering clustering=new SequentialClustering();
  clustering.setMaxRadius(501);
  clustering.setMaxSize(50);
  final SopremoTestPlan plan=new SopremoTestPlan(clustering);
  final Point p1=new Point(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  final Point p2=new Point(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  final Point p3=new Point(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  final Point p4=new Point(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  plan.getInput(0).add(this.createAnnotatedPoint(p1)).add(this.createAnnotatedPoint(p2)).add(this.createAnnotatedPoint(p3)).add(this.createAnnotatedPoint(p4));
  plan.run();
  int count=0;
  for (  final IJsonNode node : plan.getActualOutput(0)) {
    System.out.println(node);
    final ObjectNode cluster=(ObjectNode)node;
    Assert.assertEquals(2,((IArrayNode)cluster.get(""String_Node_Str"")).size());
    count++;
  }
  Assert.assertEquals(2,count);
}","@Test public void testSequentialClustering() throws IOException {
  final SequentialClustering clustering=new SequentialClustering();
  clustering.setMaxRadius(200);
  clustering.setMaxSize(200);
  final SopremoTestPlan plan=new SopremoTestPlan(clustering);
  String testPointsJsonString=""String_Node_Str"";
  JsonParser parser=new JsonParser(testPointsJsonString);
  while (!parser.checkEnd()) {
    plan.getInput(0).add(createAnnotatedPoint(parser.readValueAsTree()));
  }
  plan.run();
  int count=0;
  for (  final IJsonNode node : plan.getActualOutput(0)) {
    final ObjectNode cluster=(ObjectNode)node;
    System.out.println(cluster);
    count++;
  }
}"
87636,"private IJsonNode createAnnotatedPoint(final Point point){
  final ObjectNode annotatedValue=new ObjectNode();
  AnnotatorNodes.annotate(annotatedValue,Annotator.ANNOTATION_VALUE,point.write(null));
  return annotatedValue;
}","private IJsonNode createAnnotatedPoint(final IJsonNode pointNode){
  final ObjectNode annotatedValue=new ObjectNode();
  AnnotatorNodes.annotate(annotatedValue,Annotator.ANNOTATION_VALUE,pointNode);
  return annotatedValue;
}"
87637,"@SuppressWarnings(""String_Node_Str"") public List<? extends EvaluationExpression> getKeyExpressions(int inputIndex){
  if (inputIndex >= this.keyExpressions.size())   return Collections.EMPTY_LIST;
  final List<? extends EvaluationExpression> expressions=this.keyExpressions.get(inputIndex);
  if (expressions == null)   return Collections.EMPTY_LIST;
  return expressions;
}","/** 
 * Returns the key expressions of the given input.
 * @param inputIndex the index of the input
 * @return the key expressions of the given input
 */
@SuppressWarnings(""String_Node_Str"") public List<? extends EvaluationExpression> getKeyExpressions(int inputIndex){
  if (inputIndex >= this.keyExpressions.size())   return Collections.EMPTY_LIST;
  final List<? extends EvaluationExpression> expressions=this.keyExpressions.get(inputIndex);
  if (expressions == null)   return Collections.EMPTY_LIST;
  return expressions;
}"
87638,"/** 
 * Callback to add parameters to the stub configuration.<br> The default implementation adds the context and all non-transient, non-final, non-static fields.
 * @param contract the contract to configure
 * @param stubConfiguration the configuration of the stub
 * @param context the context in which the  {@link PactModule} is created and evaluated
 */
protected void configureContract(final Contract contract,final Configuration stubConfiguration,final EvaluationContext context){
  context.pushOperator(this);
  SopremoUtil.serialize(stubConfiguration,SopremoUtil.CONTEXT,context);
  context.popOperator();
  for (  final Field stubField : contract.getUserCodeClass().getDeclaredFields())   if ((stubField.getModifiers() & (Modifier.TRANSIENT | Modifier.FINAL | Modifier.STATIC)) == 0) {
    Field thisField;
    try {
      thisField=this.getClass().getDeclaredField(stubField.getName());
      thisField.setAccessible(true);
      SopremoUtil.serialize(stubConfiguration,stubField.getName(),(Serializable)thisField.get(this));
    }
 catch (    final NoSuchFieldException e) {
    }
catch (    final Exception e) {
      LOG.error(String.format(""String_Node_Str"",stubField.getName(),contract.getClass(),e));
    }
  }
}","/** 
 * Callback to add parameters to the stub configuration.<br> The default implementation adds the context and all non-transient, non-final, non-static fields.
 * @param contract the contract to configure
 * @param stubConfiguration the configuration of the stub
 * @param context the context in which the  {@link PactModule} is created and evaluated
 */
protected void configureContract(final Contract contract,final Configuration stubConfiguration,final EvaluationContext context){
  context.pushOperator(this);
  SopremoUtil.serialize(stubConfiguration,SopremoUtil.CONTEXT,context);
  context.popOperator();
  for (  final Field stubField : contract.getUserCodeClass().getDeclaredFields())   if ((stubField.getModifiers() & (Modifier.TRANSIENT | Modifier.FINAL | Modifier.STATIC)) == 0) {
    Class<?> clazz=this.getClass();
    do {
      Field thisField;
      try {
        thisField=clazz.getDeclaredField(stubField.getName());
        thisField.setAccessible(true);
        SopremoUtil.serialize(stubConfiguration,stubField.getName(),(Serializable)thisField.get(this));
      }
 catch (      final NoSuchFieldException e) {
      }
catch (      final Exception e) {
        LOG.error(String.format(""String_Node_Str"",stubField.getName(),contract.getClass(),e));
      }
    }
 while ((clazz=clazz.getSuperclass()) != ElementaryOperator.class);
  }
}"
87639,"/** 
 * Sets the keyExpressions to the specified value.
 * @param keyExpressions the keyExpressions to set
 */
public void setKeyExpressions(int index,EvaluationExpression... keyExpressions){
  if (keyExpressions.length == 0)   throw new IllegalArgumentException(""String_Node_Str"");
  setKeyExpressions(index,Arrays.asList(keyExpressions));
}","/** 
 * Sets the keyExpressions of the given input to the specified value.
 * @param keyExpressions the keyExpressions to set
 */
public void setKeyExpressions(int index,EvaluationExpression... keyExpressions){
  if (keyExpressions.length == 0)   throw new IllegalArgumentException(""String_Node_Str"");
  setKeyExpressions(index,Arrays.asList(keyExpressions));
}"
87640,"ReplayTaskContext(final ReplayTask task,final TransferEnvelopeDispatcher transferEnvelopeDispatcher,final LocalBufferPoolOwner previousBufferPoolOwner,final int numberOfChannels){
  this.task=task;
  this.transferEnvelopeDispatcher=transferEnvelopeDispatcher;
  if (previousBufferPoolOwner == null) {
    this.localBufferPool=new LocalBufferPool(1,false,this);
  }
 else {
    if (!(previousBufferPoolOwner instanceof RuntimeTaskContext)) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final RuntimeTaskContext rtc=(RuntimeTaskContext)previousBufferPoolOwner;
    this.localBufferPool=rtc.getLocalBufferPool();
  }
  this.numberOfChannels=numberOfChannels;
}","ReplayTaskContext(final ReplayTask task,final TransferEnvelopeDispatcher transferEnvelopeDispatcher,final LocalBufferPoolOwner previousBufferPoolOwner,final int numberOfChannels){
  this.task=task;
  this.transferEnvelopeDispatcher=transferEnvelopeDispatcher;
  this.previousBufferPoolOwner=previousBufferPoolOwner;
  if (previousBufferPoolOwner == null) {
    this.localBufferPool=new LocalBufferPool(1,false,this);
  }
 else {
    if (!(previousBufferPoolOwner instanceof RuntimeTaskContext)) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    final RuntimeTaskContext rtc=(RuntimeTaskContext)previousBufferPoolOwner;
    this.localBufferPool=rtc.getLocalBufferPool();
  }
  this.numberOfChannels=numberOfChannels;
}"
87641,"/** 
 * {@inheritDoc}
 */
@Override public void clearLocalBufferPool(){
  this.localBufferPool.destroy();
}","/** 
 * {@inheritDoc}
 */
@Override public void clearLocalBufferPool(){
  if (this.previousBufferPoolOwner != null) {
    this.previousBufferPoolOwner.clearLocalBufferPool();
  }
 else {
    this.localBufferPool.destroy();
  }
}"
87642,"@Override public void requestInstance(JobID jobID,Configuration conf,Map<InstanceType,Integer> instanceMap,List<String> splitAffinityList) throws InstanceException {
  this.instanceListener.resourceAllocated(jobID,this.allocatedResource);
}","@Override public void requestInstance(final JobID jobID,Configuration conf,Map<InstanceType,Integer> instanceMap,List<String> splitAffinityList) throws InstanceException {
  ConcurrentUtil.invokeLater(new Runnable(){
    @Override public void run(){
      MockInstanceManager.this.instanceListener.resourceAllocated(jobID,getAllocatedResource());
    }
  }
);
}"
87643,"private void assignMemory(final TaskConfig config,final int memSize){
  config.setMemorySize(((long)memSize) * 1024L * 1024L);
  config.setNumFilehandles(DEFAUTL_MERGE_FACTOR);
}","private void assignMemory(final TaskConfig config,final int memSize){
  config.setMemorySize(memSize * 1024L * 1024L);
  config.setNumFilehandles(DEFAUTL_MERGE_FACTOR);
}"
87644,"/** 
 * {@inheritDoc}
 */
@Override public void write(final DataOutput out) throws IOException {
  final InetAddress ia=this.connectionAddress.getAddress();
  out.writeInt(ia.getAddress().length);
  out.write(ia.getAddress());
  out.write(this.connectionAddress.getPort());
  out.writeInt(this.connectionIndex);
}","/** 
 * {@inheritDoc}
 */
@Override public void write(final DataOutput out) throws IOException {
  final InetAddress ia=this.connectionAddress.getAddress();
  out.writeInt(ia.getAddress().length);
  out.write(ia.getAddress());
  out.writeInt(this.connectionAddress.getPort());
  out.writeInt(this.connectionIndex);
}"
87645,"public void logBufferUtilization(){
  System.out.println(""String_Node_Str"");
  final Iterator<Map.Entry<InetSocketAddress,OutgoingConnection>> it=this.outgoingConnections.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<InetSocketAddress,OutgoingConnection> entry=it.next();
    System.out.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue().getNumberOfQueuedWriteBuffers());
  }
}","public void logBufferUtilization(){
  System.out.println(""String_Node_Str"");
  final Iterator<Map.Entry<RemoteReceiver,OutgoingConnection>> it=this.outgoingConnections.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<RemoteReceiver,OutgoingConnection> entry=it.next();
    System.out.println(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue().getNumberOfQueuedWriteBuffers());
  }
}"
87646,"@Override public IArrayNode add(int index,IJsonNode element){
  if (element == null) {
    throw new NullPointerException();
  }
  if (element.isMissing()) {
    this.remove(index);
  }
  if (index < 0 || index > this.size()) {
    throw new IndexOutOfBoundsException();
  }
  if (index < this.schema.getTailSize()) {
    for (int i=this.schema.getTailSize() - 1; i >= index; i--) {
      if (!this.record.isNull(i)) {
        if (i == this.schema.getTailSize() - 1) {
          this.getOtherField().add(0,SopremoUtil.unwrap(this.record.getField(i,JsonNodeWrapper.class)));
        }
 else {
          this.record.setField(i + 1,this.record.getField(i,JsonNodeWrapper.class));
        }
      }
    }
    this.record.setField(index,SopremoUtil.wrap(element));
  }
  return this;
}","@Override public IArrayNode add(int index,IJsonNode element){
  if (element == null) {
    throw new NullPointerException();
  }
  if (element.isMissing()) {
    this.remove(index);
  }
  if (index < 0 || index > this.size()) {
    throw new IndexOutOfBoundsException();
  }
  int recordPosition=this.schema.getTailSize() - size() + index;
  if (recordPosition < 0) {
    this.getOtherField().add(index,element);
  }
 else {
    IJsonNode oldNode=SopremoUtil.unwrap(this.record.getField(recordPosition + 1,JsonNodeWrapper.class));
    IJsonNode tmpNode;
    this.record.setField(recordPosition + 1,SopremoUtil.wrap(element));
    for (int i=recordPosition + 1; i > 0; i--) {
      if (this.record.isNull(i)) {
        this.record.setField(i,SopremoUtil.wrap(oldNode));
        return this;
      }
 else {
        tmpNode=SopremoUtil.unwrap(this.record.getField(i,JsonNodeWrapper.class));
        if (oldNode != null) {
          this.record.setField(i,SopremoUtil.wrap(oldNode));
        }
        oldNode=tmpNode;
      }
    }
    if (oldNode != null) {
      this.getOtherField().add(oldNode);
    }
  }
  return this;
}"
87647,"@Override public IJsonNode set(int index,IJsonNode node){
  if (node == null) {
    throw new NullPointerException();
  }
  if (node.isMissing()) {
    return this.remove(index);
  }
  if (index < 0 || index >= this.size()) {
    if (index == this.size()) {
      this.add(node);
      return MissingNode.getInstance();
    }
 else {
      throw new IndexOutOfBoundsException();
    }
  }
  int pactRecordPosition=this.schema.getTailSize() - size() + index;
  if (pactRecordPosition < 0) {
    return this.getOtherField().set(index,node);
  }
 else {
    IJsonNode oldNode=SopremoUtil.unwrap(this.record.getField(pactRecordPosition + 1,JsonNodeWrapper.class));
    this.record.setField(pactRecordPosition + 1,node);
    return oldNode;
  }
}","@Override public IJsonNode set(int index,IJsonNode node){
  if (node == null) {
    throw new NullPointerException();
  }
  if (node.isMissing()) {
    return this.remove(index);
  }
  if (index < 0 || index >= this.size()) {
    if (index == this.size()) {
      this.add(node);
      return MissingNode.getInstance();
    }
 else {
      throw new IndexOutOfBoundsException();
    }
  }
  int recordPosition=this.schema.getTailSize() - size() + index;
  if (recordPosition < 0) {
    return this.getOtherField().set(index,node);
  }
 else {
    IJsonNode oldNode=SopremoUtil.unwrap(this.record.getField(recordPosition + 1,JsonNodeWrapper.class));
    this.record.setField(recordPosition + 1,node);
    return oldNode;
  }
}"
87648,"@Override public IJsonNode get(int index){
  int size=this.size();
  if (index < 0 || index >= size) {
    return MissingNode.getInstance();
  }
  if (size <= this.schema.getTailSize()) {
    return SopremoUtil.unwrap(this.record.getField(this.schema.getTailSize() - size + index + 1,JsonNodeWrapper.class));
  }
 else {
    return this.getOtherField().get(index);
  }
}","@Override public IJsonNode get(int index){
  int size=this.size();
  if (index < 0 || index >= size) {
    return MissingNode.getInstance();
  }
  int recordPosition=this.schema.getTailSize() - size + index;
  if (recordPosition >= 0) {
    return SopremoUtil.unwrap(this.record.getField(recordPosition + 1,JsonNodeWrapper.class));
  }
 else {
    return this.getOtherField().get(index);
  }
}"
87649,"@Override public void initArrayNode(){
  TailArraySchema schema=new TailArraySchema();
  schema.setTailSize(5);
  PactRecord record=schema.jsonToRecord(new ArrayNode(IntNode.valueOf(0),IntNode.valueOf(1),IntNode.valueOf(2)),null,null);
  this.node=new LazyTailArrayNode(record,schema);
}","@Override public void initArrayNode(){
}"
87650,"@Test public void shouldReturnTheCorrectNode(){
  this.node.add(0,TextNode.valueOf(""String_Node_Str""));
  Assert.assertEquals(TextNode.valueOf(""String_Node_Str""),this.node.get(0));
}","@Test public void shouldReturnTheCorrectNode(){
  this.node.add(0,TextNode.valueOf(""String_Node_Str""));
  this.node.add(0,TextNode.valueOf(""String_Node_Str""));
  Assert.assertEquals(TextNode.valueOf(""String_Node_Str""),this.node.get(0));
  Assert.assertEquals(TextNode.valueOf(""String_Node_Str""),this.node.get(1));
}"
87651,"/** 
 * {@inheritDoc}
 */
@Override public void invoke() throws Exception {
  if (LOG.isInfoEnabled())   LOG.info(getLogString(""String_Node_Str""));
  try {
    AbstractPactTask.openChainedTasks(this.chainedTasks,this);
    final Iterator<InputSplit> splitIterator=getInputSplits();
    while (!this.taskCanceled && splitIterator.hasNext()) {
      final InputSplit split=splitIterator.next();
      if (LOG.isDebugEnabled())       LOG.debug(getLogString(""String_Node_Str"" + split.toString()));
      final InputFormat<OT,InputSplit> format=this.format;
      format.open(split);
      if (LOG.isDebugEnabled())       LOG.debug(getLogString(""String_Node_Str"" + split.toString()));
      final OT record=this.serializer.createInstance();
      if (record.getClass() == PactRecord.class) {
        final PactRecord pactRecord=(PactRecord)record;
        @SuppressWarnings(""String_Node_Str"") final InputFormat<PactRecord,InputSplit> inFormat=(InputFormat<PactRecord,InputSplit>)format;
        if (this.output instanceof PactRecordOutputCollector) {
          final PactRecordOutputCollector output=(PactRecordOutputCollector)this.output;
          while (!this.taskCanceled && !inFormat.reachedEnd()) {
            if (inFormat.nextRecord(pactRecord)) {
              output.collect(pactRecord);
            }
          }
        }
 else         if (this.output instanceof ChainedMapTask) {
          @SuppressWarnings(""String_Node_Str"") final ChainedMapTask<PactRecord,?> output=(ChainedMapTask<PactRecord,?>)this.output;
          while (!this.taskCanceled && !inFormat.reachedEnd()) {
            if (inFormat.nextRecord(pactRecord)) {
              output.collect(pactRecord);
            }
          }
        }
      }
 else {
        if (this.output instanceof OutputCollector) {
          final OutputCollector<OT> output=(OutputCollector<OT>)this.output;
          while (!this.taskCanceled && !format.reachedEnd()) {
            if (format.nextRecord(record)) {
              output.collect(record);
            }
          }
        }
 else         if (this.output instanceof ChainedMapTask) {
          @SuppressWarnings(""String_Node_Str"") final ChainedMapTask<OT,?> output=(ChainedMapTask<OT,?>)this.output;
          while (!this.taskCanceled && !format.reachedEnd()) {
            if (format.nextRecord(record)) {
              output.collect(record);
            }
          }
        }
 else {
          final Collector<OT> output=this.output;
          while (!this.taskCanceled && !format.reachedEnd()) {
            if (format.nextRecord(record)) {
              output.collect(record);
            }
          }
        }
      }
      if (!this.taskCanceled) {
        if (LOG.isDebugEnabled())         LOG.debug(getLogString(""String_Node_Str"" + split.toString()));
        format.close();
      }
    }
    this.output.close();
    AbstractPactTask.closeChainedTasks(this.chainedTasks,this);
  }
 catch (  Exception ex) {
    try {
      this.format.close();
    }
 catch (    Throwable t) {
    }
    AbstractPactTask.cancelChainedTasks(this.chainedTasks);
    if (!this.taskCanceled) {
      AbstractPactTask.logAndThrowException(ex,this);
    }
  }
  if (!this.taskCanceled) {
    if (LOG.isInfoEnabled())     LOG.info(getLogString(""String_Node_Str""));
  }
 else {
    if (LOG.isWarnEnabled())     LOG.warn(getLogString(""String_Node_Str""));
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void invoke() throws Exception {
  if (LOG.isInfoEnabled())   LOG.info(getLogString(""String_Node_Str""));
  try {
    AbstractPactTask.openChainedTasks(this.chainedTasks,this);
    final Iterator<InputSplit> splitIterator=getInputSplits();
    while (!this.taskCanceled && splitIterator.hasNext()) {
      final InputSplit split=splitIterator.next();
      if (LOG.isDebugEnabled())       LOG.debug(getLogString(""String_Node_Str"" + split.toString()));
      final InputFormat<OT,InputSplit> format=this.format;
      format.open(split);
      if (LOG.isDebugEnabled())       LOG.debug(getLogString(""String_Node_Str"" + split.toString()));
      final OT record=this.serializer.createInstance();
      if (record.getClass() == PactRecord.class) {
        final PactRecord pactRecord=(PactRecord)record;
        @SuppressWarnings(""String_Node_Str"") final InputFormat<PactRecord,InputSplit> inFormat=(InputFormat<PactRecord,InputSplit>)format;
        if (this.output instanceof PactRecordOutputCollector) {
          final PactRecordOutputCollector output=(PactRecordOutputCollector)this.output;
          while (!this.taskCanceled && !inFormat.reachedEnd()) {
            if (inFormat.nextRecord(pactRecord)) {
              output.collect(pactRecord);
            }
          }
        }
 else         if (this.output instanceof ChainedMapTask) {
          @SuppressWarnings(""String_Node_Str"") final ChainedMapTask<PactRecord,?> output=(ChainedMapTask<PactRecord,?>)this.output;
          while (!this.taskCanceled && !inFormat.reachedEnd()) {
            if (inFormat.nextRecord(pactRecord)) {
              output.collect(pactRecord);
            }
          }
        }
 else {
          @SuppressWarnings(""String_Node_Str"") final Collector<PactRecord> output=(Collector<PactRecord>)this.output;
          while (!this.taskCanceled && !inFormat.reachedEnd()) {
            if (inFormat.nextRecord(pactRecord)) {
              output.collect(pactRecord);
            }
          }
        }
      }
 else {
        if (this.output instanceof OutputCollector) {
          final OutputCollector<OT> output=(OutputCollector<OT>)this.output;
          while (!this.taskCanceled && !format.reachedEnd()) {
            if (format.nextRecord(record)) {
              output.collect(record);
            }
          }
        }
 else         if (this.output instanceof ChainedMapTask) {
          @SuppressWarnings(""String_Node_Str"") final ChainedMapTask<OT,?> output=(ChainedMapTask<OT,?>)this.output;
          while (!this.taskCanceled && !format.reachedEnd()) {
            if (format.nextRecord(record)) {
              output.collect(record);
            }
          }
        }
 else {
          final Collector<OT> output=this.output;
          while (!this.taskCanceled && !format.reachedEnd()) {
            if (format.nextRecord(record)) {
              output.collect(record);
            }
          }
        }
      }
      if (!this.taskCanceled) {
        if (LOG.isDebugEnabled())         LOG.debug(getLogString(""String_Node_Str"" + split.toString()));
        format.close();
      }
    }
    this.output.close();
    AbstractPactTask.closeChainedTasks(this.chainedTasks,this);
  }
 catch (  Exception ex) {
    try {
      this.format.close();
    }
 catch (    Throwable t) {
    }
    AbstractPactTask.cancelChainedTasks(this.chainedTasks);
    if (!this.taskCanceled) {
      AbstractPactTask.logAndThrowException(ex,this);
    }
  }
  if (!this.taskCanceled) {
    if (LOG.isInfoEnabled())     LOG.info(getLogString(""String_Node_Str""));
  }
 else {
    if (LOG.isWarnEnabled())     LOG.warn(getLogString(""String_Node_Str""));
  }
}"
87652,"@Override public JsonNode evaluate(final JsonNode node,final EvaluationContext context){
  return LongNode.valueOf((((LongNode)((ArrayNode)node).get(0)).getLongValue() << 48) + ((LongNode)((ArrayNode)node).get(1)).getLongValue());
}","@Override public IJsonNode evaluate(IJsonNode node,IJsonNode target,EvaluationContext context){
  return LongNode.valueOf((((LongNode)((ArrayNode)node).get(0)).getLongValue() << 48) + ((LongNode)((ArrayNode)node).get(1)).getLongValue());
}"
87653,"@Override public IJsonNode evaluate(IJsonNode node,EvaluationContext context){
  throw new EvaluationException(""String_Node_Str"");
}","@Override public IJsonNode evaluate(IJsonNode node,IJsonNode target,EvaluationContext context){
  throw new EvaluationException(""String_Node_Str"");
}"
87654,"public void collect(final IJsonNode value){
  if (SopremoUtil.LOG.isTraceEnabled())   SopremoUtil.LOG.trace(String.format(""String_Node_Str"",value));
  this.collector.collect(this.record=this.schema.jsonToRecord(value,null,this.record));
}","public void collect(final IJsonNode value){
  if (SopremoUtil.LOG.isTraceEnabled())   SopremoUtil.LOG.trace(String.format(""String_Node_Str"",value));
  this.collector.collect(this.record=this.schema.jsonToRecord(value,this.record,this.context));
}"
87655,"@Override public void coGroup(final Iterator<PactRecord> records1,final Iterator<PactRecord> records2,final Collector out){
  this.context.increaseInputCounter();
  this.collector.setCollector(out);
  this.cachedIterator1.setIterator(records1);
  this.cachedIterator2.setIterator(records2);
  Iterator<IJsonNode> values1=this.cachedIterator1;
  Iterator<IJsonNode> values2=this.cachedIterator2;
  if (SopremoUtil.LOG.isTraceEnabled()) {
    final ArrayList<IJsonNode> cached1=new ArrayList<IJsonNode>(), cached2=new ArrayList<IJsonNode>();
    while (values1.hasNext())     cached1.add(values1.next());
    while (values2.hasNext())     cached2.add(values2.next());
    SopremoUtil.LOG.trace(String.format(""String_Node_Str"",this.getContext().operatorTrace(),cached1,cached2));
    values1=cached1.iterator();
    values2=cached2.iterator();
  }
  final ArrayNode array1=JsonUtil.wrapWithNode(this.needsResettableIterator(0,values1),values1);
  final ArrayNode array2=JsonUtil.wrapWithNode(this.needsResettableIterator(0,values2),values2);
  try {
    this.coGroup(array1,array2,this.collector);
  }
 catch (  final RuntimeException e) {
    SopremoUtil.LOG.error(String.format(""String_Node_Str"",this.getContext().operatorTrace(),array1,array2,e));
    throw e;
  }
}","@Override public void coGroup(final Iterator<PactRecord> records1,final Iterator<PactRecord> records2,final Collector out){
  this.context.increaseInputCounter();
  this.collector.configure(out,this.context);
  this.cachedIterator1.setIterator(records1);
  this.cachedIterator2.setIterator(records2);
  Iterator<IJsonNode> values1=this.cachedIterator1;
  Iterator<IJsonNode> values2=this.cachedIterator2;
  if (SopremoUtil.LOG.isTraceEnabled()) {
    final ArrayList<IJsonNode> cached1=new ArrayList<IJsonNode>(), cached2=new ArrayList<IJsonNode>();
    while (values1.hasNext())     cached1.add(values1.next());
    while (values2.hasNext())     cached2.add(values2.next());
    SopremoUtil.LOG.trace(String.format(""String_Node_Str"",this.getContext().operatorTrace(),cached1,cached2));
    values1=cached1.iterator();
    values2=cached2.iterator();
  }
  final ArrayNode array1=JsonUtil.wrapWithNode(this.needsResettableIterator(0,values1),values1);
  final ArrayNode array2=JsonUtil.wrapWithNode(this.needsResettableIterator(0,values2),values2);
  try {
    this.coGroup(array1,array2,this.collector);
  }
 catch (  final RuntimeException e) {
    SopremoUtil.LOG.error(String.format(""String_Node_Str"",this.getContext().operatorTrace(),array1,array2,e));
    throw e;
  }
}"
87656,"@Override public void cross(final PactRecord record1,final PactRecord record2,final Collector out){
  this.context.increaseInputCounter();
  this.collector.setCollector(out);
  final IJsonNode input1=this.inputSchema1.recordToJson(record1,this.cachedInput1);
  final IJsonNode input2=this.inputSchema2.recordToJson(record2,this.cachedInput2);
  if (SopremoUtil.LOG.isTraceEnabled())   SopremoUtil.LOG.trace(String.format(""String_Node_Str"",this.getContext().operatorTrace(),input1,input2));
  try {
    this.cross(input1,input2,this.collector);
  }
 catch (  final RuntimeException e) {
    SopremoUtil.LOG.error(String.format(""String_Node_Str"",this.getContext().operatorTrace(),input1,input2,e));
    throw e;
  }
}","@Override public void cross(final PactRecord record1,final PactRecord record2,final Collector out){
  this.context.increaseInputCounter();
  this.collector.configure(out,this.context);
  final IJsonNode input1=this.inputSchema1.recordToJson(record1,this.cachedInput1);
  final IJsonNode input2=this.inputSchema2.recordToJson(record2,this.cachedInput2);
  if (SopremoUtil.LOG.isTraceEnabled())   SopremoUtil.LOG.trace(String.format(""String_Node_Str"",this.getContext().operatorTrace(),input1,input2));
  try {
    this.cross(input1,input2,this.collector);
  }
 catch (  final RuntimeException e) {
    SopremoUtil.LOG.error(String.format(""String_Node_Str"",this.getContext().operatorTrace(),input1,input2,e));
    throw e;
  }
}"
87657,"@Override public void map(final PactRecord record,final Collector out) throws Exception {
  this.context.increaseInputCounter();
  this.collector.setCollector(out);
  final IJsonNode input=this.inputSchema.recordToJson(record,this.cachedInput);
  if (SopremoUtil.LOG.isTraceEnabled())   SopremoUtil.LOG.trace(String.format(""String_Node_Str"",this.getContext().operatorTrace(),input));
  try {
    this.map(input,this.collector);
  }
 catch (  final RuntimeException e) {
    SopremoUtil.LOG.error(String.format(""String_Node_Str"",this.getContext().operatorTrace(),this.cachedInput,e));
    throw e;
  }
}","@Override public void map(final PactRecord record,final Collector out) throws Exception {
  this.context.increaseInputCounter();
  this.collector.configure(out,this.context);
  final IJsonNode input=this.inputSchema.recordToJson(record,this.cachedInput);
  if (SopremoUtil.LOG.isTraceEnabled())   SopremoUtil.LOG.trace(String.format(""String_Node_Str"",this.getContext().operatorTrace(),input));
  try {
    this.map(input,this.collector);
  }
 catch (  final RuntimeException e) {
    SopremoUtil.LOG.error(String.format(""String_Node_Str"",this.getContext().operatorTrace(),this.cachedInput,e));
    throw e;
  }
}"
87658,"@Override public void match(final PactRecord record1,final PactRecord record2,final Collector out) throws Exception {
  this.context.increaseInputCounter();
  this.collector.setCollector(out);
  final IJsonNode input1=this.inputSchema1.recordToJson(record1,this.cachedInput1);
  final IJsonNode input2=this.inputSchema2.recordToJson(record2,this.cachedInput2);
  if (SopremoUtil.LOG.isTraceEnabled())   SopremoUtil.LOG.trace(String.format(""String_Node_Str"",this.getContext().operatorTrace(),input1,input2));
  try {
    this.match(input1,input2,this.collector);
  }
 catch (  final RuntimeException e) {
    SopremoUtil.LOG.error(String.format(""String_Node_Str"",this.getContext().operatorTrace(),input1,input2,e));
    throw e;
  }
}","@Override public void match(final PactRecord record1,final PactRecord record2,final Collector out) throws Exception {
  this.context.increaseInputCounter();
  this.collector.configure(out,this.context);
  final IJsonNode input1=this.inputSchema1.recordToJson(record1,this.cachedInput1);
  final IJsonNode input2=this.inputSchema2.recordToJson(record2,this.cachedInput2);
  if (SopremoUtil.LOG.isTraceEnabled())   SopremoUtil.LOG.trace(String.format(""String_Node_Str"",this.getContext().operatorTrace(),input1,input2));
  try {
    this.match(input1,input2,this.collector);
  }
 catch (  final RuntimeException e) {
    SopremoUtil.LOG.error(String.format(""String_Node_Str"",this.getContext().operatorTrace(),input1,input2,e));
    throw e;
  }
}"
87659,"@Override public void reduce(final Iterator<PactRecord> records,final Collector out) throws Exception {
  this.context.increaseInputCounter();
  this.collector.setCollector(out);
  this.cachedIterator.setIterator(records);
  Iterator<IJsonNode> values=this.cachedIterator;
  if (SopremoUtil.LOG.isTraceEnabled()) {
    final ArrayList<IJsonNode> cached=new ArrayList<IJsonNode>();
    while (this.cachedIterator.hasNext())     cached.add(this.cachedIterator.next());
    values=cached.iterator();
    SopremoUtil.LOG.trace(String.format(""String_Node_Str"",this.getContext().operatorTrace(),cached));
  }
  final ArrayNode array=JsonUtil.wrapWithNode(this.needsResettableIterator(values),values);
  try {
    this.reduce(array,this.collector);
  }
 catch (  final RuntimeException e) {
    SopremoUtil.LOG.error(String.format(""String_Node_Str"",this.getContext().operatorTrace(),array,e));
    throw e;
  }
}","@Override public void reduce(final Iterator<PactRecord> records,final Collector out) throws Exception {
  this.context.increaseInputCounter();
  this.collector.configure(out,this.context);
  this.cachedIterator.setIterator(records);
  Iterator<IJsonNode> values=this.cachedIterator;
  if (SopremoUtil.LOG.isTraceEnabled()) {
    final ArrayList<IJsonNode> cached=new ArrayList<IJsonNode>();
    while (this.cachedIterator.hasNext())     cached.add(this.cachedIterator.next());
    values=cached.iterator();
    SopremoUtil.LOG.trace(String.format(""String_Node_Str"",this.getContext().operatorTrace(),cached));
  }
  final ArrayNode array=JsonUtil.wrapWithNode(this.needsResettableIterator(values),values);
  try {
    this.reduce(array,this.collector);
  }
 catch (  final RuntimeException e) {
    SopremoUtil.LOG.error(String.format(""String_Node_Str"",this.getContext().operatorTrace(),array,e));
    throw e;
  }
}"
87660,"@Override public IJsonNode recordToJson(PactRecord record,IJsonNode target){
  if (this.getHeadSize() + 1 != record.getNumFields())   throw new IllegalStateException(""String_Node_Str"");
  if (target == null)   target=new ArrayNode();
}","@Override public IJsonNode recordToJson(PactRecord record,IJsonNode target){
  if (this.getHeadSize() + 1 != record.getNumFields())   throw new IllegalStateException(""String_Node_Str"");
  if (target == null)   target=new ArrayNode();
 else   ((IArrayNode)target).clear();
  for (int i=0; i < this.getHeadSize(); i++) {
    if (record.getField(i,JsonNodeWrapper.class) != null) {
      ((IArrayNode)target).add(SopremoUtil.unwrap(record.getField(i,JsonNodeWrapper.class)));
    }
  }
  ((IArrayNode)target).addAll((IArrayNode)SopremoUtil.unwrap(record.getField(this.getHeadSize(),JsonNodeWrapper.class)));
  return target;
}"
87661,"@Override public IJsonNode remove(int index){
}","@Override public IJsonNode remove(int index){
  if (index < 0 || index >= this.size())   return MissingNode.getInstance();
  if (index < this.schema.getHeadSize()) {
    IJsonNode oldNode=SopremoUtil.wrap(this.getOtherField().remove(0));
    IJsonNode buffer;
    for (int i=this.schema.getHeadSize() - 1; i >= index; i--) {
      buffer=this.record.getField(i,JsonNodeWrapper.class);
      if (buffer == null) {
        buffer=MissingNode.getInstance();
      }
      if (oldNode.isMissing())       this.record.setNull(i);
 else       this.record.setField(i,oldNode);
      oldNode=buffer;
    }
    return SopremoUtil.unwrap(oldNode);
  }
  return this.getOtherField().remove(index - this.schema.getHeadSize());
}"
87662,"@Override public PactRecord jsonToRecord(IJsonNode value,PactRecord target,EvaluationContext context){
}","@Override public PactRecord jsonToRecord(IJsonNode value,PactRecord target,EvaluationContext context){
  IObjectNode others;
  if (target == null) {
    target=new PactRecord(this.mappings.size() + 1);
    for (int i=0; i < this.mappings.size(); i++)     target.setField(i,new JsonNodeWrapper(MissingNode.getInstance()));
    target.setField(this.mappings.size(),new JsonNodeWrapper(others=new ObjectNode()));
  }
 else {
    JsonNodeWrapper wrappedField=target.getField(target.getNumFields() - 1,JsonNodeWrapper.class);
    others=wrappedField.getValue(IObjectNode.class);
    others.removeAll();
    target.setField(target.getNumFields() - 1,wrappedField);
  }
  IObjectNode object=(IObjectNode)value;
  for (int i=0; i < this.mappings.size(); i++) {
    IJsonNode node=object.get(this.mappings.get(i));
    JsonNodeWrapper wrappedField=target.getField(i,JsonNodeWrapper.class);
    wrappedField.setValue(node);
    target.setField(i,wrappedField);
  }
  for (  Entry<String,IJsonNode> entry : object.getEntries())   if (!this.mappings.contains(entry.getKey()))   others.put(entry.getKey(),entry.getValue());
  return target;
}"
87663,"/** 
 * Reconstructs the execution pipeline starting at the given vertex by conducting a depth-first search.
 * @param vertex the vertex to start the depth-first search from
 * @param forward <code>true</code> to traverse the graph according to the original direction of the edges or <code>false</code> for the opposite direction
 * @param alreadyVisited a set of vertices that have already been visited in the depth-first search
 */
private void reconstructExecutionPipeline(final ExecutionVertex vertex,final boolean forward,final Set<ExecutionVertex> alreadyVisited){
  ExecutionPipeline pipeline=vertex.getExecutionPipeline();
  if (pipeline == null) {
    pipeline=new ExecutionPipeline();
    vertex.setExecutionPipeline(pipeline);
  }
  alreadyVisited.add(vertex);
  final RuntimeEnvironment env=vertex.getEnvironment();
  if (forward) {
    final int numberOfOutputGates=env.getNumberOfOutputGates();
    for (int i=0; i < numberOfOutputGates; ++i) {
      final OutputGate<? extends Record> outputGate=env.getOutputGate(i);
      final ChannelType channelType=outputGate.getChannelType();
      final int numberOfOutputChannels=outputGate.getNumberOfOutputChannels();
      for (int j=0; j < numberOfOutputChannels; ++j) {
        final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
        final ExecutionVertex connectedVertex=this.executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
        boolean recurse=false;
        if (!alreadyVisited.contains(connectedVertex)) {
          recurse=true;
        }
 else         if (channelType == ChannelType.INMEMORY && !pipeline.equals(connectedVertex.getExecutionPipeline())) {
          connectedVertex.setExecutionPipeline(pipeline);
          recurse=true;
        }
        if (recurse) {
          reconstructExecutionPipeline(connectedVertex,true,alreadyVisited);
        }
      }
    }
  }
 else {
    final int numberOfInputGates=env.getNumberOfInputGates();
    for (int i=0; i < numberOfInputGates; ++i) {
      final InputGate<? extends Record> inputGate=env.getInputGate(i);
      final ChannelType channelType=inputGate.getChannelType();
      final int numberOfInputChannels=inputGate.getNumberOfInputChannels();
      for (int j=0; j < numberOfInputChannels; ++j) {
        final AbstractInputChannel<? extends Record> inputChannel=inputGate.getInputChannel(j);
        final ExecutionVertex connectedVertex=this.executionGraph.getVertexByChannelID(inputChannel.getConnectedChannelID());
        boolean recurse=false;
        if (!alreadyVisited.contains(connectedVertex)) {
          recurse=true;
        }
 else         if (channelType == ChannelType.INMEMORY && !pipeline.equals(connectedVertex.getExecutionPipeline())) {
          connectedVertex.setExecutionPipeline(pipeline);
          recurse=true;
        }
        if (recurse) {
          reconstructExecutionPipeline(connectedVertex,false,alreadyVisited);
        }
      }
    }
  }
}","/** 
 * Reconstructs the execution pipeline starting at the given vertex by conducting a depth-first search.
 * @param vertex the vertex to start the depth-first search from
 * @param forward <code>true</code> to traverse the graph according to the original direction of the edges or <code>false</code> for the opposite direction
 * @param alreadyVisited a set of vertices that have already been visited in the depth-first search
 */
private void reconstructExecutionPipeline(final ExecutionVertex vertex,final boolean forward,final Set<ExecutionVertex> alreadyVisited){
  ExecutionPipeline pipeline=vertex.getExecutionPipeline();
  if (pipeline == null) {
    pipeline=new ExecutionPipeline();
    vertex.setExecutionPipeline(pipeline);
  }
  alreadyVisited.add(vertex);
  final RuntimeEnvironment env=vertex.getEnvironment();
  if (forward) {
    final int numberOfOutputGates=env.getNumberOfOutputGates();
    for (int i=0; i < numberOfOutputGates; ++i) {
      final OutputGate<? extends Record> outputGate=env.getOutputGate(i);
      final ChannelType channelType=outputGate.getChannelType();
      final int numberOfOutputChannels=outputGate.getNumberOfOutputChannels();
      for (int j=0; j < numberOfOutputChannels; ++j) {
        final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
        final ExecutionVertex connectedVertex=this.executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
        boolean recurse=false;
        if (!alreadyVisited.contains(connectedVertex)) {
          recurse=true;
        }
        if (channelType == ChannelType.INMEMORY && !pipeline.equals(connectedVertex.getExecutionPipeline())) {
          connectedVertex.setExecutionPipeline(pipeline);
          recurse=true;
        }
        if (recurse) {
          reconstructExecutionPipeline(connectedVertex,true,alreadyVisited);
        }
      }
    }
  }
 else {
    final int numberOfInputGates=env.getNumberOfInputGates();
    for (int i=0; i < numberOfInputGates; ++i) {
      final InputGate<? extends Record> inputGate=env.getInputGate(i);
      final ChannelType channelType=inputGate.getChannelType();
      final int numberOfInputChannels=inputGate.getNumberOfInputChannels();
      for (int j=0; j < numberOfInputChannels; ++j) {
        final AbstractInputChannel<? extends Record> inputChannel=inputGate.getInputChannel(j);
        final ExecutionVertex connectedVertex=this.executionGraph.getVertexByChannelID(inputChannel.getConnectedChannelID());
        boolean recurse=false;
        if (!alreadyVisited.contains(connectedVertex)) {
          recurse=true;
        }
        if (channelType == ChannelType.INMEMORY && !pipeline.equals(connectedVertex.getExecutionPipeline())) {
          connectedVertex.setExecutionPipeline(pipeline);
          recurse=true;
        }
        if (recurse) {
          reconstructExecutionPipeline(connectedVertex,false,alreadyVisited);
        }
      }
    }
  }
}"
87664,"/** 
 * {@inheritDoc}
 */
@Override public void executionStateChanged(final JobID jobID,final ExecutionVertexID vertexID,final ExecutionState newExecutionState,final String optionalMessage){
  final ExecutionGraph eg=this.executionVertex.getExecutionGraph();
  if (newExecutionState == ExecutionState.FINISHING) {
    final ExecutionPipeline pipeline=this.executionVertex.getExecutionPipeline();
    if (!pipeline.isFinishing()) {
      return;
    }
    final ExecutionGroupVertex groupVertex=this.executionVertex.getGroupVertex();
    for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); ++i) {
      final ExecutionVertex groupMember=groupVertex.getGroupMember(i);
      if (groupMember.getExecutionState() == ExecutionState.SCHEDULED) {
        final ExecutionPipeline pipelineToBeDeployed=groupMember.getExecutionPipeline();
        pipelineToBeDeployed.setAllocatedResource(this.executionVertex.getAllocatedResource());
        pipelineToBeDeployed.updateExecutionState(ExecutionState.ASSIGNED);
        this.scheduler.deployAssignedVertices(groupMember);
        return;
      }
    }
  }
  if (newExecutionState == ExecutionState.CANCELED || newExecutionState == ExecutionState.FINISHED) {
synchronized (this.executionVertex.getExecutionGraph()) {
      if (this.scheduler.getVerticesToBeRestarted().remove(this.executionVertex.getID()) != null) {
        this.executionVertex.updateExecutionState(ExecutionState.ASSIGNED,""String_Node_Str"");
        this.scheduler.deployAssignedVertices(this.executionVertex);
        return;
      }
    }
  }
  if (newExecutionState == ExecutionState.FINISHED || newExecutionState == ExecutionState.CANCELED || newExecutionState == ExecutionState.FAILED) {
    this.scheduler.checkAndReleaseAllocatedResource(eg,this.executionVertex.getAllocatedResource());
  }
  if (newExecutionState == ExecutionState.FAILED) {
    if (this.executionVertex.decrementRetriesLeftAndCheck()) {
      final Set<ExecutionVertex> assignedVertices=new HashSet<ExecutionVertex>();
      if (RecoveryLogic.recover(this.executionVertex,this.scheduler.getVerticesToBeRestarted(),assignedVertices)) {
        if (RecoveryLogic.hasInstanceAssigned(this.executionVertex)) {
          this.scheduler.deployAssignedVertices(assignedVertices);
        }
      }
 else {
      }
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void executionStateChanged(final JobID jobID,final ExecutionVertexID vertexID,final ExecutionState newExecutionState,final String optionalMessage){
  final ExecutionGraph eg=this.executionVertex.getExecutionGraph();
  if (newExecutionState == ExecutionState.FINISHING) {
    final ExecutionPipeline pipeline=this.executionVertex.getExecutionPipeline();
    if (!pipeline.isFinishing()) {
      return;
    }
    final ExecutionGroupVertex groupVertex=this.executionVertex.getGroupVertex();
    for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); ++i) {
      final ExecutionVertex groupMember=groupVertex.getGroupMember(i);
      if (groupMember.compareAndUpdateExecutionState(ExecutionState.SCHEDULED,ExecutionState.ASSIGNED)) {
        final ExecutionPipeline pipelineToBeDeployed=groupMember.getExecutionPipeline();
        pipelineToBeDeployed.setAllocatedResource(this.executionVertex.getAllocatedResource());
        pipelineToBeDeployed.updateExecutionState(ExecutionState.ASSIGNED);
        this.scheduler.deployAssignedPipeline(pipelineToBeDeployed);
        return;
      }
    }
  }
  if (newExecutionState == ExecutionState.CANCELED || newExecutionState == ExecutionState.FINISHED) {
synchronized (this.executionVertex.getExecutionGraph()) {
      if (this.scheduler.getVerticesToBeRestarted().remove(this.executionVertex.getID()) != null) {
        this.executionVertex.updateExecutionState(ExecutionState.ASSIGNED,""String_Node_Str"");
        this.scheduler.deployAssignedVertices(this.executionVertex);
        return;
      }
    }
  }
  if (newExecutionState == ExecutionState.FINISHED || newExecutionState == ExecutionState.CANCELED || newExecutionState == ExecutionState.FAILED) {
    this.scheduler.checkAndReleaseAllocatedResource(eg,this.executionVertex.getAllocatedResource());
  }
  if (newExecutionState == ExecutionState.FAILED) {
    if (this.executionVertex.decrementRetriesLeftAndCheck()) {
      final Set<ExecutionVertex> assignedVertices=new HashSet<ExecutionVertex>();
      if (RecoveryLogic.recover(this.executionVertex,this.scheduler.getVerticesToBeRestarted(),assignedVertices)) {
        if (RecoveryLogic.hasInstanceAssigned(this.executionVertex)) {
          this.scheduler.deployAssignedVertices(assignedVertices);
        }
      }
 else {
      }
    }
  }
}"
87665,"private static void removeCheckpointMetaData(final Path pathPrefix) throws IOException {
  Path p=pathPrefix.suffix(COMPLETED_CHECKPOINT_SUFFIX);
  FileSystem fs=p.getFileSystem();
  if (fs.exists(p)) {
    fs.delete(p,false);
    return;
  }
  p=pathPrefix.suffix(""String_Node_Str"");
  if (fs.exists(p)) {
    fs.delete(p,false);
  }
  p=pathPrefix.suffix(""String_Node_Str"");
  if (fs.exists(p)) {
    fs.delete(p,false);
  }
}","private static boolean removeCheckpointMetaData(final Path pathPrefix) throws IOException {
  boolean removed=false;
  Path p=pathPrefix.suffix(""String_Node_Str"");
  FileSystem fs=p.getFileSystem();
  if (fs.exists(p)) {
    fs.delete(p,false);
    removed=true;
  }
  int suffix=0;
  while (true) {
    p=pathPrefix.suffix(""String_Node_Str"" + suffix++);
    if (fs.exists(p)) {
      fs.delete(p,false);
      removed=true;
    }
 else {
      break;
    }
  }
  p=pathPrefix.suffix(COMPLETED_CHECKPOINT_SUFFIX);
  if (fs.exists(p)) {
    fs.delete(p,false);
    removed=true;
  }
  return removed;
}"
87666,"/** 
 * Removes the checkpoint of the vertex with the given ID. All files contained in the checkpoint are deleted.
 * @param vertexID the vertex whose checkpoint shall be removed
 */
public static void removeCheckpoint(final ExecutionVertexID vertexID){
  final Path localChPath=getLocalCheckpointPath();
  try {
    removeCheckpointMetaData(new Path(localChPath + Path.SEPARATOR + METADATA_PREFIX));
    final Path distributedChPath=getDistributedCheckpointPath();
    if (distributedChPath != null) {
      removeCheckpointMetaData(new Path(distributedChPath + Path.SEPARATOR + METADATA_PREFIX));
    }
  }
 catch (  IOException e) {
  }
}","/** 
 * Removes the checkpoint of the vertex with the given ID. All files contained in the checkpoint are deleted.
 * @param vertexID the vertex whose checkpoint shall be removed
 */
public static void removeCheckpoint(final ExecutionVertexID vertexID){
  final Path localChPath=getLocalCheckpointPath();
  try {
    if (!removeCheckpointMetaData(new Path(localChPath + Path.SEPARATOR + METADATA_PREFIX+ ""String_Node_Str""+ vertexID))) {
      final Path distributedChPath=getDistributedCheckpointPath();
      if (distributedChPath != null) {
        removeCheckpointMetaData(new Path(distributedChPath + Path.SEPARATOR + METADATA_PREFIX+ ""String_Node_Str""+ vertexID));
      }
    }
    FileBufferManager.deleteFile(vertexID);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
87667,"public synchronized void shutdown(){
  if (this.isShutDown) {
    return;
  }
  if (this.instanceManager != null) {
    this.instanceManager.shutdown();
  }
  DiscoveryService.stopDiscoveryService();
  if (this.profiler != null) {
    this.profiler.shutdown();
  }
  if (this.jobManagerServer != null) {
    this.jobManagerServer.stop();
  }
  if (this.executorService != null) {
    this.executorService.shutdown();
  }
  final Iterator<JobManagerPlugin> it=this.jobManagerPlugins.values().iterator();
  while (it.hasNext()) {
    it.next().shutdown();
  }
  if (this.eventCollector != null) {
    this.eventCollector.shutdown();
  }
  if (this.scheduler != null) {
    this.scheduler.shutdown();
  }
  this.isShutDown=true;
  LOG.debug(""String_Node_Str"");
}","public synchronized void shutdown(){
  if (this.isShutDown) {
    return;
  }
  if (this.instanceManager != null) {
    this.instanceManager.shutdown();
  }
  DiscoveryService.stopDiscoveryService();
  if (this.profiler != null) {
    this.profiler.shutdown();
  }
  if (this.jobManagerServer != null) {
    this.jobManagerServer.stop();
  }
  if (this.executorService != null) {
    this.executorService.shutdown();
    try {
      this.executorService.awaitTermination(5000L,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(StringUtils.stringifyException(e));
      }
    }
  }
  final Iterator<JobManagerPlugin> it=this.jobManagerPlugins.values().iterator();
  while (it.hasNext()) {
    it.next().shutdown();
  }
  if (this.eventCollector != null) {
    this.eventCollector.shutdown();
  }
  if (this.scheduler != null) {
    this.scheduler.shutdown();
  }
  this.isShutDown=true;
  LOG.debug(""String_Node_Str"");
}"
87668,"/** 
 * {@inheritDoc}
 */
@Override public TaskCancelResult cancelTask(final ExecutionVertexID id) throws IOException {
  final Task task=this.runningTasks.get(id);
  if (task == null) {
    final TaskCancelResult taskCancelResult=new TaskCancelResult(id,AbstractTaskResult.ReturnCode.TASK_NOT_FOUND);
    taskCancelResult.setDescription(""String_Node_Str"" + id + ""String_Node_Str"");
    return taskCancelResult;
  }
  final Thread tmpThread=new Thread(new Runnable(){
    @Override public void run(){
      task.cancelExecution();
    }
  }
);
  tmpThread.start();
  return new TaskCancelResult(id,AbstractTaskResult.ReturnCode.SUCCESS);
}","/** 
 * {@inheritDoc}
 */
@Override public TaskCancelResult cancelTask(final ExecutionVertexID id) throws IOException {
  final Task task=this.runningTasks.get(id);
  if (task == null) {
    final TaskCancelResult taskCancelResult=new TaskCancelResult(id,AbstractTaskResult.ReturnCode.TASK_NOT_FOUND);
    taskCancelResult.setDescription(""String_Node_Str"" + id + ""String_Node_Str"");
    return taskCancelResult;
  }
  final Runnable r=new Runnable(){
    @Override public void run(){
      task.cancelExecution();
    }
  }
;
  this.executorService.execute(r);
  return new TaskCancelResult(id,AbstractTaskResult.ReturnCode.SUCCESS);
}"
87669,"/** 
 * {@inheritDoc}
 */
@Override public void removeCheckpoints(final List<ExecutionVertexID> listOfVertexIDs) throws IOException {
  final Thread checkpointRemovalThread=new Thread(""String_Node_Str""){
    @Override public void run(){
      final Iterator<ExecutionVertexID> it=listOfVertexIDs.iterator();
      while (it.hasNext()) {
        final ExecutionVertexID vertexID=it.next();
        EnvelopeConsumptionLog.removeLog(vertexID);
        CheckpointUtils.removeCheckpoint(vertexID);
      }
    }
  }
;
  checkpointRemovalThread.start();
}","/** 
 * {@inheritDoc}
 */
@Override public void removeCheckpoints(final List<ExecutionVertexID> listOfVertexIDs) throws IOException {
  final List<ExecutionVertexID> threadSafeList=Collections.unmodifiableList(listOfVertexIDs);
  final Runnable r=new Runnable(){
    @Override public void run(){
      final Iterator<ExecutionVertexID> it=threadSafeList.iterator();
      while (it.hasNext()) {
        final ExecutionVertexID vertexID=it.next();
        EnvelopeConsumptionLog.removeLog(vertexID);
        CheckpointUtils.removeCheckpoint(vertexID);
      }
    }
  }
;
  this.executorService.execute(r);
}"
87670,"/** 
 * {@inheritDoc}
 */
@Override public TaskKillResult killTask(final ExecutionVertexID id) throws IOException {
  final Task task=this.runningTasks.get(id);
  if (task == null) {
    final TaskKillResult taskKillResult=new TaskKillResult(id,AbstractTaskResult.ReturnCode.TASK_NOT_FOUND);
    taskKillResult.setDescription(""String_Node_Str"" + id + ""String_Node_Str"");
    return taskKillResult;
  }
  final Thread tmpThread=new Thread(new Runnable(){
    @Override public void run(){
      task.killExecution();
    }
  }
);
  tmpThread.start();
  return new TaskKillResult(id,AbstractTaskResult.ReturnCode.SUCCESS);
}","/** 
 * {@inheritDoc}
 */
@Override public TaskKillResult killTask(final ExecutionVertexID id) throws IOException {
  final Task task=this.runningTasks.get(id);
  if (task == null) {
    final TaskKillResult taskKillResult=new TaskKillResult(id,AbstractTaskResult.ReturnCode.TASK_NOT_FOUND);
    taskKillResult.setDescription(""String_Node_Str"" + id + ""String_Node_Str"");
    return taskKillResult;
  }
  final Runnable r=new Runnable(){
    @Override public void run(){
      task.killExecution();
    }
  }
;
  this.executorService.execute(r);
  return new TaskKillResult(id,AbstractTaskResult.ReturnCode.SUCCESS);
}"
87671,"/** 
 * Shuts the task manager down.
 */
public synchronized void shutdown(){
  if (this.isShutDown) {
    return;
  }
  LOG.info(""String_Node_Str"");
  RPC.stopProxy(this.jobManager);
  this.taskManagerServer.stop();
  if (this.profiler != null) {
    this.profiler.shutdown();
  }
  this.byteBufferedChannelManager.shutdown();
  if (this.ioManager != null) {
    this.ioManager.shutdown();
  }
  if (this.memoryManager != null) {
    this.memoryManager.shutdown();
  }
  final Iterator<TaskManagerPlugin> it=this.taskManagerPlugins.values().iterator();
  while (it.hasNext()) {
    it.next().shutdown();
  }
  this.isShutDown=true;
}","/** 
 * Shuts the task manager down.
 */
public synchronized void shutdown(){
  if (this.isShutDown) {
    return;
  }
  LOG.info(""String_Node_Str"");
  RPC.stopProxy(this.jobManager);
  this.taskManagerServer.stop();
  if (this.profiler != null) {
    this.profiler.shutdown();
  }
  this.byteBufferedChannelManager.shutdown();
  if (this.ioManager != null) {
    this.ioManager.shutdown();
  }
  if (this.memoryManager != null) {
    this.memoryManager.shutdown();
  }
  if (this.executorService != null) {
    this.executorService.shutdown();
    try {
      this.executorService.awaitTermination(5000L,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(StringUtils.stringifyException(e));
      }
    }
  }
  final Iterator<TaskManagerPlugin> it=this.taskManagerPlugins.values().iterator();
  while (it.hasNext()) {
    it.next().shutdown();
  }
  this.isShutDown=true;
}"
87672,"/** 
 * {@inheritDoc}
 */
@Override public void queueTransferEnvelope(final TransferEnvelope transferEnvelope){
  final int sequenceNumber=transferEnvelope.getSequenceNumber();
  AbstractEvent eventToSend=null;
  if (ReceiverNotFoundEvent.isReceiverNotFoundEvent(transferEnvelope)) {
    return;
  }
synchronized (this.queuedEnvelopes) {
    if (this.destroyCalled) {
      final Buffer buffer=transferEnvelope.getBuffer();
      if (buffer != null) {
        buffer.recycleBuffer();
      }
      return;
    }
    final int expectedSequenceNumber=this.lastReceivedEnvelope + 1;
    if (sequenceNumber != expectedSequenceNumber) {
      if (sequenceNumber > expectedSequenceNumber) {
        if (expectedSequenceNumber > 2000) {
          this.byteBufferedInputChannel.reportIOException(new IOException(""String_Node_Str"" + expectedSequenceNumber + ""String_Node_Str""+ sequenceNumber));
          this.byteBufferedInputChannel.checkForNetworkEvents();
        }
      }
 else {
        eventToSend=lookForCloseEvent(transferEnvelope);
        if (eventToSend == null) {
          eventToSend=new UnexpectedEnvelopeEvent(expectedSequenceNumber - 1);
        }
      }
      LOG.warn(""String_Node_Str"" + getChannelName() + ""String_Node_Str""+ expectedSequenceNumber+ ""String_Node_Str""+ sequenceNumber);
      final Buffer buffer=transferEnvelope.getBuffer();
      if (buffer != null) {
        buffer.recycleBuffer();
      }
    }
 else {
      this.queuedEnvelopes.add(transferEnvelope);
      this.lastReceivedEnvelope=sequenceNumber;
      this.envelopeConsumptionLog.reportEnvelopeAvailability(this.byteBufferedInputChannel);
    }
  }
  if (eventToSend != null) {
    try {
      transferEventToOutputChannel(eventToSend);
    }
 catch (    Exception e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void queueTransferEnvelope(final TransferEnvelope transferEnvelope){
  final int sequenceNumber=transferEnvelope.getSequenceNumber();
  AbstractEvent eventToSend=null;
  if (ReceiverNotFoundEvent.isReceiverNotFoundEvent(transferEnvelope)) {
    return;
  }
synchronized (this.queuedEnvelopes) {
    if (this.destroyCalled) {
      final Buffer buffer=transferEnvelope.getBuffer();
      if (buffer != null) {
        buffer.recycleBuffer();
      }
      return;
    }
    final int expectedSequenceNumber=this.lastReceivedEnvelope + 1;
    if (sequenceNumber != expectedSequenceNumber) {
      if (sequenceNumber > expectedSequenceNumber) {
        if (!this.isReexecuted) {
          this.byteBufferedInputChannel.reportIOException(new IOException(""String_Node_Str"" + expectedSequenceNumber + ""String_Node_Str""+ sequenceNumber));
          this.byteBufferedInputChannel.checkForNetworkEvents();
        }
      }
 else {
        eventToSend=lookForCloseEvent(transferEnvelope);
        if (eventToSend == null) {
          eventToSend=new UnexpectedEnvelopeEvent(expectedSequenceNumber - 1);
        }
      }
      LOG.warn(""String_Node_Str"" + getChannelName() + ""String_Node_Str""+ expectedSequenceNumber+ ""String_Node_Str""+ sequenceNumber);
      final Buffer buffer=transferEnvelope.getBuffer();
      if (buffer != null) {
        buffer.recycleBuffer();
      }
    }
 else {
      this.queuedEnvelopes.add(transferEnvelope);
      this.lastReceivedEnvelope=sequenceNumber;
      this.envelopeConsumptionLog.reportEnvelopeAvailability(this.byteBufferedInputChannel);
    }
  }
  if (eventToSend != null) {
    try {
      transferEventToOutputChannel(eventToSend);
    }
 catch (    Exception e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}"
87673,"RuntimeInputChannelContext(final RuntimeInputGateContext inputGateContext,final TransferEnvelopeDispatcher transferEnvelopeDispatcher,final AbstractByteBufferedInputChannel<?> byteBufferedInputChannel,final EnvelopeConsumptionLog envelopeConsumptionLog){
  this.inputGateContext=inputGateContext;
  this.transferEnvelopeDispatcher=transferEnvelopeDispatcher;
  this.byteBufferedInputChannel=byteBufferedInputChannel;
  this.byteBufferedInputChannel.setInputChannelBroker(this);
  this.envelopeConsumptionLog=envelopeConsumptionLog;
}","RuntimeInputChannelContext(final RuntimeInputGateContext inputGateContext,final TransferEnvelopeDispatcher transferEnvelopeDispatcher,final AbstractByteBufferedInputChannel<?> byteBufferedInputChannel,final EnvelopeConsumptionLog envelopeConsumptionLog){
  this.inputGateContext=inputGateContext;
  this.transferEnvelopeDispatcher=transferEnvelopeDispatcher;
  this.byteBufferedInputChannel=byteBufferedInputChannel;
  this.byteBufferedInputChannel.setInputChannelBroker(this);
  this.envelopeConsumptionLog=envelopeConsumptionLog;
  this.isReexecuted=(envelopeConsumptionLog.getNumberOfInitialLogEntries() > 0L);
}"
87674,"/** 
 * {@inheritDoc}
 */
@Override public synchronized void requestInstance(final JobID jobID,final Configuration conf,final InstanceRequestMap instanceRequestMap,final List<String> splitAffinityList) throws InstanceException {
  final List<AllocatedResource> allocatedResources=new ArrayList<AllocatedResource>();
  final Iterator<Map.Entry<InstanceType,Integer>> it=instanceRequestMap.getMaximumIterator();
  while (it.hasNext()) {
    final Map.Entry<InstanceType,Integer> entry=it.next();
    final int maximumNumberOfInstances=entry.getValue().intValue();
    for (int i=0; i < maximumNumberOfInstances; i++) {
      LOG.info(""String_Node_Str"" + entry.getKey().getIdentifier());
      final AllocatedSlice slice=getSliceOfType(jobID,entry.getKey());
      if (slice == null) {
        if (i < instanceRequestMap.getMinimumNumberOfInstances(entry.getKey())) {
          removeAllSlicesOfJob(jobID);
          throw new InstanceException(""String_Node_Str"");
        }
 else {
          final int numberOfRemainingInstances=maximumNumberOfInstances - i;
          if (numberOfRemainingInstances > 0) {
            PendingRequestsMap pendingRequests=this.pendingRequestsOfJob.get(jobID);
            if (pendingRequests == null) {
              pendingRequests=new PendingRequestsMap();
              this.pendingRequestsOfJob.put(jobID,pendingRequests);
            }
            pendingRequests.addRequest(entry.getKey(),numberOfRemainingInstances);
          }
          break;
        }
      }
      List<AllocatedSlice> allocatedSlices=this.slicesOfJobs.get(jobID);
      if (allocatedSlices == null) {
        allocatedSlices=new ArrayList<AllocatedSlice>();
        this.slicesOfJobs.put(jobID,allocatedSlices);
      }
      allocatedSlices.add(slice);
      allocatedResources.add(new AllocatedResource(slice.getHostingInstance(),slice.getType(),slice.getAllocationID()));
    }
  }
  if (this.instanceListener != null) {
    final ClusterInstanceNotifier clusterInstanceNotifier=new ClusterInstanceNotifier(this.instanceListener,jobID,allocatedResources);
    clusterInstanceNotifier.start();
  }
}","/** 
 * {@inheritDoc}
 */
@Override public synchronized void requestInstance(final JobID jobID,final Configuration conf,final InstanceRequestMap instanceRequestMap,final List<String> splitAffinityList) throws InstanceException {
  final List<AllocatedSlice> newlyAllocatedSlicesOfJob=new ArrayList<AllocatedSlice>();
  final Map<InstanceType,Integer> pendingRequests=new HashMap<InstanceType,Integer>();
  for (final Iterator<Map.Entry<InstanceType,Integer>> it=instanceRequestMap.getMaximumIterator(); it.hasNext(); ) {
    final Map.Entry<InstanceType,Integer> entry=it.next();
    final int maximumNumberOfInstances=entry.getValue().intValue();
    for (int i=0; i < maximumNumberOfInstances; i++) {
      LOG.info(""String_Node_Str"" + entry.getKey().getIdentifier());
      final AllocatedSlice slice=getSliceOfType(jobID,entry.getKey());
      if (slice == null) {
        if (i < instanceRequestMap.getMinimumNumberOfInstances(entry.getKey())) {
          for (          final AllocatedSlice sliceToRelease : newlyAllocatedSlicesOfJob) {
            sliceToRelease.getHostingInstance().removeAllocatedSlice(sliceToRelease.getAllocationID());
          }
          throw new InstanceException(""String_Node_Str"");
        }
 else {
          final int numberOfRemainingInstances=maximumNumberOfInstances - i;
          if (numberOfRemainingInstances > 0) {
            Integer val=pendingRequests.get(entry.getKey());
            if (val == null) {
              val=Integer.valueOf(0);
            }
            val=Integer.valueOf(val.intValue() + numberOfRemainingInstances);
            pendingRequests.put(entry.getKey(),val);
          }
          break;
        }
      }
      newlyAllocatedSlicesOfJob.add(slice);
    }
  }
  List<AllocatedSlice> allAllocatedSlicesOfJob=this.slicesOfJobs.get(jobID);
  if (allAllocatedSlicesOfJob == null) {
    allAllocatedSlicesOfJob=new ArrayList<AllocatedSlice>();
    this.slicesOfJobs.put(jobID,allAllocatedSlicesOfJob);
  }
  allAllocatedSlicesOfJob.addAll(newlyAllocatedSlicesOfJob);
  PendingRequestsMap allPendingRequestsOfJob=this.pendingRequestsOfJob.get(jobID);
  if (allPendingRequestsOfJob == null) {
    allPendingRequestsOfJob=new PendingRequestsMap();
    this.pendingRequestsOfJob.put(jobID,allPendingRequestsOfJob);
  }
  for (final Iterator<Map.Entry<InstanceType,Integer>> it=pendingRequests.entrySet().iterator(); it.hasNext(); ) {
    final Map.Entry<InstanceType,Integer> entry=it.next();
    allPendingRequestsOfJob.addRequest(entry.getKey(),entry.getValue().intValue());
  }
  final List<AllocatedResource> allocatedResources=new ArrayList<AllocatedResource>();
  for (  final AllocatedSlice slice : newlyAllocatedSlicesOfJob) {
    allocatedResources.add(new AllocatedResource(slice.getHostingInstance(),slice.getType(),slice.getAllocationID()));
  }
  if (this.instanceListener != null) {
    final ClusterInstanceNotifier clusterInstanceNotifier=new ClusterInstanceNotifier(this.instanceListener,jobID,allocatedResources);
    clusterInstanceNotifier.start();
  }
}"
87675,"/** 
 * This test covers the matching of instances to instance types It addresses the automatic matching through the hardware description as well as user-defined instance type matching.
 */
@Test public void testInstanceMatching(){
  final String configDir=getConfigDir();
  if (configDir == null) {
    fail(""String_Node_Str"");
  }
  GlobalConfiguration.loadConfiguration(configDir);
  final TestInstanceListener testInstanceListener=new TestInstanceListener();
  final ClusterManager cm=new ClusterManager();
  cm.setInstanceListener(testInstanceListener);
  Map<InstanceType,InstanceTypeDescription> instanceTypeDescriptions=null;
  try {
    final int ipcPort=ConfigConstants.DEFAULT_TASK_MANAGER_IPC_PORT;
    final int dataPort=ConfigConstants.DEFAULT_TASK_MANAGER_DATA_PORT;
    HardwareDescription hardwareDescription=HardwareDescriptionFactory.construct(2,2L * 1024L * 1024L* 1024L,2L * 1024L * 1024L* 1024L);
    InstanceConnectionInfo ici=new InstanceConnectionInfo(InetAddress.getByName(""String_Node_Str""),ipcPort,dataPort);
    cm.reportHeartBeat(ici,hardwareDescription);
    instanceTypeDescriptions=cm.getMapOfAvailableInstanceTypes();
    assertEquals(3,instanceTypeDescriptions.size());
    Iterator<Map.Entry<InstanceType,InstanceTypeDescription>> it=instanceTypeDescriptions.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,InstanceTypeDescription> entry=it.next();
      if (LARGE_INSTANCE_TYPE_NAME.equals(entry.getKey().getIdentifier())) {
        assertEquals(1,entry.getValue().getMaximumNumberOfAvailableInstances());
      }
 else       if (MEDIUM_INSTANCE_TYPE_NAME.equals(entry.getKey().getIdentifier())) {
        assertEquals(2,entry.getValue().getMaximumNumberOfAvailableInstances());
      }
 else       if (SMALL_INSTANCE_TYPE_NAME.equals(entry.getKey().getIdentifier())) {
        assertEquals(4,entry.getValue().getMaximumNumberOfAvailableInstances());
      }
 else {
        fail(""String_Node_Str"" + entry.getKey());
      }
    }
    hardwareDescription=HardwareDescriptionFactory.construct(3,2L * 1024L * 1024L* 1024L,1024L * 1024L * 1024L);
    ici=new InstanceConnectionInfo(InetAddress.getByName(""String_Node_Str""),ipcPort,dataPort);
    cm.reportHeartBeat(ici,hardwareDescription);
    instanceTypeDescriptions=cm.getMapOfAvailableInstanceTypes();
    assertEquals(3,instanceTypeDescriptions.size());
    it=instanceTypeDescriptions.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,InstanceTypeDescription> entry=it.next();
      if (LARGE_INSTANCE_TYPE_NAME.equals(entry.getKey().getIdentifier())) {
        assertEquals(1,entry.getValue().getMaximumNumberOfAvailableInstances());
      }
 else       if (MEDIUM_INSTANCE_TYPE_NAME.equals(entry.getKey().getIdentifier())) {
        assertEquals(2,entry.getValue().getMaximumNumberOfAvailableInstances());
      }
 else       if (SMALL_INSTANCE_TYPE_NAME.equals(entry.getKey().getIdentifier())) {
        assertEquals(5,entry.getValue().getMaximumNumberOfAvailableInstances());
      }
 else {
        fail(""String_Node_Str"" + entry.getKey());
      }
    }
  }
 catch (  UnknownHostException e) {
    fail(e.getMessage());
  }
 finally {
    if (cm != null) {
      cm.shutdown();
    }
  }
}","/** 
 * This test covers the matching of instances to instance types It addresses the automatic matching through the hardware description as well as user-defined instance type matching.
 */
@Test public void testInstanceMatching(){
  final String configDir=getConfigDir();
  if (configDir == null) {
    fail(""String_Node_Str"");
  }
  GlobalConfiguration.loadConfiguration(configDir);
  final TestInstanceListener testInstanceListener=new TestInstanceListener();
  final ClusterManager cm=new ClusterManager();
  cm.setInstanceListener(testInstanceListener);
  Map<InstanceType,InstanceTypeDescription> instanceTypeDescriptions=null;
  try {
    final int ipcPort=ConfigConstants.DEFAULT_TASK_MANAGER_IPC_PORT;
    final int dataPort=ConfigConstants.DEFAULT_TASK_MANAGER_DATA_PORT;
    HardwareDescription hardwareDescription=HardwareDescriptionFactory.construct(2,2L * 1024L * 1024L* 1024L,2L * 1024L * 1024L* 1024L);
    String ipAddress=""String_Node_Str"";
    InstanceConnectionInfo ici=new InstanceConnectionInfo(InetAddress.getByName(ipAddress),ipAddress,null,ipcPort,dataPort);
    cm.reportHeartBeat(ici,hardwareDescription);
    instanceTypeDescriptions=cm.getMapOfAvailableInstanceTypes();
    assertEquals(3,instanceTypeDescriptions.size());
    Iterator<Map.Entry<InstanceType,InstanceTypeDescription>> it=instanceTypeDescriptions.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,InstanceTypeDescription> entry=it.next();
      if (LARGE_INSTANCE_TYPE_NAME.equals(entry.getKey().getIdentifier())) {
        assertEquals(1,entry.getValue().getMaximumNumberOfAvailableInstances());
      }
 else       if (MEDIUM_INSTANCE_TYPE_NAME.equals(entry.getKey().getIdentifier())) {
        assertEquals(2,entry.getValue().getMaximumNumberOfAvailableInstances());
      }
 else       if (SMALL_INSTANCE_TYPE_NAME.equals(entry.getKey().getIdentifier())) {
        assertEquals(4,entry.getValue().getMaximumNumberOfAvailableInstances());
      }
 else {
        fail(""String_Node_Str"" + entry.getKey());
      }
    }
    hardwareDescription=HardwareDescriptionFactory.construct(3,2L * 1024L * 1024L* 1024L,1024L * 1024L * 1024L);
    ipAddress=""String_Node_Str"";
    ici=new InstanceConnectionInfo(InetAddress.getByName(ipAddress),ipAddress,null,ipcPort,dataPort);
    cm.reportHeartBeat(ici,hardwareDescription);
    instanceTypeDescriptions=cm.getMapOfAvailableInstanceTypes();
    assertEquals(3,instanceTypeDescriptions.size());
    it=instanceTypeDescriptions.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,InstanceTypeDescription> entry=it.next();
      if (LARGE_INSTANCE_TYPE_NAME.equals(entry.getKey().getIdentifier())) {
        assertEquals(1,entry.getValue().getMaximumNumberOfAvailableInstances());
      }
 else       if (MEDIUM_INSTANCE_TYPE_NAME.equals(entry.getKey().getIdentifier())) {
        assertEquals(2,entry.getValue().getMaximumNumberOfAvailableInstances());
      }
 else       if (SMALL_INSTANCE_TYPE_NAME.equals(entry.getKey().getIdentifier())) {
        assertEquals(5,entry.getValue().getMaximumNumberOfAvailableInstances());
      }
 else {
        fail(""String_Node_Str"" + entry.getKey());
      }
    }
  }
 catch (  UnknownHostException e) {
    fail(e.getMessage());
  }
 finally {
    if (cm != null) {
      cm.shutdown();
    }
  }
}"
87676,"/** 
 * This test checks the clean-up routines of the cluster manager.
 */
@Test public void testCleanUp(){
  GlobalConfiguration.loadConfiguration(System.getProperty(USER_DIR_KEY) + CORRECT_CONF_DIR);
  final TestInstanceListener testInstanceListener=new TestInstanceListener();
  final ClusterManager cm=new ClusterManager();
  cm.setInstanceListener(testInstanceListener);
  try {
    final InstanceConnectionInfo instanceConnectionInfo=new InstanceConnectionInfo(InetAddress.getByName(""String_Node_Str""),1234,1235);
    final HardwareDescription hardwareDescription=HardwareDescriptionFactory.construct(8,8L * 1024L * 1024L* 1024L,8L * 1024L * 1024L* 1024L);
    cm.reportHeartBeat(instanceConnectionInfo,hardwareDescription);
    final JobID jobID=new JobID();
    final Configuration conf=new Configuration();
    try {
      InstanceRequestMap instancem=new InstanceRequestMap();
      instancem.setNumberOfInstances(cm.getInstanceTypeByName(LARGE_INSTANCE_TYPE_NAME),1);
      cm.requestInstance(jobID,conf,instancem,null);
    }
 catch (    InstanceException ie) {
      fail(ie.getMessage());
    }
    ClusterManagerTestUtils.waitForInstances(jobID,testInstanceListener,1,MAX_WAIT_TIME);
    assertEquals(1,testInstanceListener.getNumberOfAllocatedResourcesForJob(jobID));
    try {
      Thread.sleep(CLEAN_UP_INTERVAL);
    }
 catch (    InterruptedException ie) {
      fail(ie.getMessage());
    }
    ClusterManagerTestUtils.waitForInstances(jobID,testInstanceListener,0,MAX_WAIT_TIME);
    assertEquals(0,testInstanceListener.getNumberOfAllocatedResourcesForJob(jobID));
  }
 catch (  UnknownHostException e) {
    fail(e.getMessage());
  }
 finally {
    if (cm != null) {
      cm.shutdown();
    }
  }
}","/** 
 * This test checks the clean-up routines of the cluster manager.
 */
@Test public void testCleanUp(){
  GlobalConfiguration.loadConfiguration(System.getProperty(USER_DIR_KEY) + CORRECT_CONF_DIR);
  final TestInstanceListener testInstanceListener=new TestInstanceListener();
  final ClusterManager cm=new ClusterManager();
  cm.setInstanceListener(testInstanceListener);
  try {
    final String ipAddress=""String_Node_Str"";
    final InstanceConnectionInfo instanceConnectionInfo=new InstanceConnectionInfo(InetAddress.getByName(ipAddress),ipAddress,null,1234,1235);
    final HardwareDescription hardwareDescription=HardwareDescriptionFactory.construct(8,8L * 1024L * 1024L* 1024L,8L * 1024L * 1024L* 1024L);
    cm.reportHeartBeat(instanceConnectionInfo,hardwareDescription);
    final JobID jobID=new JobID();
    final Configuration conf=new Configuration();
    try {
      InstanceRequestMap instancem=new InstanceRequestMap();
      instancem.setNumberOfInstances(cm.getInstanceTypeByName(LARGE_INSTANCE_TYPE_NAME),1);
      cm.requestInstance(jobID,conf,instancem,null);
    }
 catch (    InstanceException ie) {
      fail(ie.getMessage());
    }
    ClusterManagerTestUtils.waitForInstances(jobID,testInstanceListener,1,MAX_WAIT_TIME);
    assertEquals(1,testInstanceListener.getNumberOfAllocatedResourcesForJob(jobID));
    try {
      Thread.sleep(CLEAN_UP_INTERVAL);
    }
 catch (    InterruptedException ie) {
      fail(ie.getMessage());
    }
    ClusterManagerTestUtils.waitForInstances(jobID,testInstanceListener,0,MAX_WAIT_TIME);
    assertEquals(0,testInstanceListener.getNumberOfAllocatedResourcesForJob(jobID));
  }
 catch (  UnknownHostException e) {
    fail(e.getMessage());
  }
 finally {
    if (cm != null) {
      cm.shutdown();
    }
  }
}"
87677,"/** 
 * This test checks the correctness of extracting instance types from the configuration, mapping IPs to instance types from the slave file, instance slicing and allocation/deallocation.
 */
@Test public void testAllocationDeallocation(){
  final String configDir=getConfigDir();
  if (configDir == null) {
    fail(""String_Node_Str"");
  }
  GlobalConfiguration.loadConfiguration(configDir);
  final TestInstanceListener testInstanceListener=new TestInstanceListener();
  final ClusterManager cm=new ClusterManager();
  cm.setInstanceListener(testInstanceListener);
  try {
    final InstanceConnectionInfo instanceConnectionInfo=new InstanceConnectionInfo(InetAddress.getByName(""String_Node_Str""),1234,1235);
    final HardwareDescription hardwareDescription=HardwareDescriptionFactory.construct(8,8L * 1024L * 1024L* 1024L,8L * 1024L * 1024L* 1024L);
    cm.reportHeartBeat(instanceConnectionInfo,hardwareDescription);
    final JobID jobID=new JobID();
    final Configuration conf=new Configuration();
    final InstanceRequestMap instanceRequestMap=new InstanceRequestMap();
    instanceRequestMap.setNumberOfInstances(cm.getInstanceTypeByName(SMALL_INSTANCE_TYPE_NAME),2);
    instanceRequestMap.setNumberOfInstances(cm.getInstanceTypeByName(MEDIUM_INSTANCE_TYPE_NAME),1);
    try {
      cm.requestInstance(jobID,conf,instanceRequestMap,null);
    }
 catch (    InstanceException ie) {
      fail(ie.getMessage());
    }
    ClusterManagerTestUtils.waitForInstances(jobID,testInstanceListener,3,MAX_WAIT_TIME);
    final List<AllocatedResource> allocatedResources=testInstanceListener.getAllocatedResourcesForJob(jobID);
    assertEquals(3,allocatedResources.size());
    Iterator<AllocatedResource> it=allocatedResources.iterator();
    final Set<AllocationID> allocationIDs=new HashSet<AllocationID>();
    while (it.hasNext()) {
      final AllocatedResource allocatedResource=it.next();
      if (!LARGE_INSTANCE_TYPE_NAME.equals(allocatedResource.getInstance().getType().getIdentifier())) {
        fail(""String_Node_Str"" + allocatedResource.getInstance().getType().getIdentifier());
      }
      if (allocationIDs.contains(allocatedResource.getAllocationID())) {
        fail(""String_Node_Str"" + allocatedResource.getAllocationID() + ""String_Node_Str"");
      }
 else {
        allocationIDs.add(allocatedResource.getAllocationID());
      }
    }
    try {
      InstanceRequestMap instancem=new InstanceRequestMap();
      instancem.setNumberOfInstances(cm.getInstanceTypeByName(MEDIUM_INSTANCE_TYPE_NAME),1);
      cm.requestInstance(jobID,conf,instancem,null);
      fail(""String_Node_Str"");
    }
 catch (    InstanceException ie) {
    }
    it=allocatedResources.iterator();
    try {
      while (it.hasNext()) {
        final AllocatedResource allocatedResource=it.next();
        cm.releaseAllocatedResource(jobID,conf,allocatedResource);
      }
    }
 catch (    InstanceException ie) {
      fail(ie.getMessage());
    }
    try {
      InstanceRequestMap instancem=new InstanceRequestMap();
      instancem.setNumberOfInstances(cm.getInstanceTypeByName(LARGE_INSTANCE_TYPE_NAME),1);
      cm.requestInstance(jobID,conf,instancem,null);
    }
 catch (    InstanceException ie) {
      fail(ie.getMessage());
    }
  }
 catch (  UnknownHostException e) {
    fail(e.getMessage());
  }
 finally {
    if (cm != null) {
      cm.shutdown();
    }
  }
}","/** 
 * This test checks the correctness of extracting instance types from the configuration, mapping IPs to instance types from the slave file, instance slicing and allocation/deallocation.
 */
@Test public void testAllocationDeallocation(){
  final String configDir=getConfigDir();
  if (configDir == null) {
    fail(""String_Node_Str"");
  }
  GlobalConfiguration.loadConfiguration(configDir);
  final TestInstanceListener testInstanceListener=new TestInstanceListener();
  final ClusterManager cm=new ClusterManager();
  cm.setInstanceListener(testInstanceListener);
  try {
    final String ipAddress=""String_Node_Str"";
    final InstanceConnectionInfo instanceConnectionInfo=new InstanceConnectionInfo(InetAddress.getByName(ipAddress),ipAddress,null,1234,1235);
    final HardwareDescription hardwareDescription=HardwareDescriptionFactory.construct(8,8L * 1024L * 1024L* 1024L,8L * 1024L * 1024L* 1024L);
    cm.reportHeartBeat(instanceConnectionInfo,hardwareDescription);
    final JobID jobID=new JobID();
    final Configuration conf=new Configuration();
    final InstanceRequestMap instanceRequestMap=new InstanceRequestMap();
    instanceRequestMap.setNumberOfInstances(cm.getInstanceTypeByName(SMALL_INSTANCE_TYPE_NAME),2);
    instanceRequestMap.setNumberOfInstances(cm.getInstanceTypeByName(MEDIUM_INSTANCE_TYPE_NAME),1);
    try {
      cm.requestInstance(jobID,conf,instanceRequestMap,null);
    }
 catch (    InstanceException ie) {
      fail(ie.getMessage());
    }
    ClusterManagerTestUtils.waitForInstances(jobID,testInstanceListener,3,MAX_WAIT_TIME);
    final List<AllocatedResource> allocatedResources=testInstanceListener.getAllocatedResourcesForJob(jobID);
    assertEquals(3,allocatedResources.size());
    Iterator<AllocatedResource> it=allocatedResources.iterator();
    final Set<AllocationID> allocationIDs=new HashSet<AllocationID>();
    while (it.hasNext()) {
      final AllocatedResource allocatedResource=it.next();
      if (!LARGE_INSTANCE_TYPE_NAME.equals(allocatedResource.getInstance().getType().getIdentifier())) {
        fail(""String_Node_Str"" + allocatedResource.getInstance().getType().getIdentifier());
      }
      if (allocationIDs.contains(allocatedResource.getAllocationID())) {
        fail(""String_Node_Str"" + allocatedResource.getAllocationID() + ""String_Node_Str"");
      }
 else {
        allocationIDs.add(allocatedResource.getAllocationID());
      }
    }
    try {
      InstanceRequestMap instancem=new InstanceRequestMap();
      instancem.setNumberOfInstances(cm.getInstanceTypeByName(MEDIUM_INSTANCE_TYPE_NAME),1);
      cm.requestInstance(jobID,conf,instancem,null);
      fail(""String_Node_Str"");
    }
 catch (    InstanceException ie) {
    }
    it=allocatedResources.iterator();
    try {
      while (it.hasNext()) {
        final AllocatedResource allocatedResource=it.next();
        cm.releaseAllocatedResource(jobID,conf,allocatedResource);
      }
    }
 catch (    InstanceException ie) {
      fail(ie.getMessage());
    }
    try {
      InstanceRequestMap instancem=new InstanceRequestMap();
      instancem.setNumberOfInstances(cm.getInstanceTypeByName(LARGE_INSTANCE_TYPE_NAME),1);
      cm.requestInstance(jobID,conf,instancem,null);
    }
 catch (    InstanceException ie) {
      fail(ie.getMessage());
    }
  }
 catch (  UnknownHostException e) {
    fail(e.getMessage());
  }
 finally {
    if (cm != null) {
      cm.shutdown();
    }
  }
}"
87678,"/** 
 * {@inheritDoc}
 */
@Override public void read(DataInput in) throws IOException {
  final int addr_length=in.readInt();
  byte[] address=new byte[addr_length];
  in.readFully(address);
  this.hostname=StringRecord.readString(in);
  this.domainname=StringRecord.readString(in);
  try {
    this.inetAddress=InetAddress.getByAddress(address);
  }
 catch (  UnknownHostException uhe) {
    throw new IOException(StringUtils.stringifyException(uhe));
  }
  this.ipcPort=in.readInt();
  this.dataPort=in.readInt();
}","/** 
 * {@inheritDoc}
 */
@Override public void read(final DataInput in) throws IOException {
  final int addr_length=in.readInt();
  byte[] address=new byte[addr_length];
  in.readFully(address);
  this.hostName=StringRecord.readString(in);
  this.domainName=StringRecord.readString(in);
  try {
    this.inetAddress=InetAddress.getByAddress(address);
  }
 catch (  UnknownHostException uhe) {
    throw new IOException(StringUtils.stringifyException(uhe));
  }
  this.ipcPort=in.readInt();
  this.dataPort=in.readInt();
}"
87679,"/** 
 * Returns the host name of the instance. If the host name could not be determined, the return value will be a textual representation of the instance's IP address.
 * @return the host name of the instance
 */
public String getHostName(){
  return this.hostname;
}","/** 
 * Returns the host name of the instance. If the host name could not be determined, the return value will be a textual representation of the instance's IP address.
 * @return the host name of the instance
 */
public String getHostName(){
  return this.hostName;
}"
87680,"/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (obj instanceof InstanceConnectionInfo) {
    InstanceConnectionInfo ici=(InstanceConnectionInfo)obj;
    if (!this.inetAddress.equals(ici.getAddress())) {
      return false;
    }
    if (this.ipcPort != ici.getIPCPort()) {
      return false;
    }
    if (this.dataPort != ici.getDataPort()) {
      return false;
    }
    return true;
  }
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(final Object obj){
  if (obj instanceof InstanceConnectionInfo) {
    InstanceConnectionInfo ici=(InstanceConnectionInfo)obj;
    if (!this.inetAddress.equals(ici.getAddress())) {
      return false;
    }
    if (this.ipcPort != ici.getIPCPort()) {
      return false;
    }
    if (this.dataPort != ici.getDataPort()) {
      return false;
    }
    return true;
  }
  return false;
}"
87681,"/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  String iaString;
  if (this.hostname != null) {
    iaString=this.hostname;
  }
 else {
    iaString=inetAddress.toString();
    iaString=iaString.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return iaString;
}","/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  String iaString;
  if (this.hostName != null) {
    iaString=this.hostName;
  }
 else {
    iaString=inetAddress.toString();
    iaString=iaString.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return iaString;
}"
87682,"@Override public int compareTo(InstanceConnectionInfo o){
  return this.getAddress().getHostName().compareTo(((InstanceConnectionInfo)o).getAddress().getHostName());
}","/** 
 * {@inheritDoc}
 */
@Override public int compareTo(final InstanceConnectionInfo o){
  return this.getAddress().getHostName().compareTo(((InstanceConnectionInfo)o).getAddress().getHostName());
}"
87683,"/** 
 * Returns the domain name of the instance.
 * @return the domain name of the instance or <code>null</code> if the domain name could not be determined
 */
public String getDomainName(){
  return this.domainname;
}","/** 
 * Returns the domain name of the instance.
 * @return the domain name of the instance or <code>null</code> if the domain name could not be determined
 */
public String getDomainName(){
  return this.domainName;
}"
87684,"/** 
 * {@inheritDoc}
 */
@Override public void write(DataOutput out) throws IOException {
  out.writeInt(this.inetAddress.getAddress().length);
  out.write(this.inetAddress.getAddress());
  StringRecord.writeString(out,this.hostname);
  StringRecord.writeString(out,this.domainname);
  out.writeInt(this.ipcPort);
  out.writeInt(this.dataPort);
}","/** 
 * {@inheritDoc}
 */
@Override public void write(final DataOutput out) throws IOException {
  out.writeInt(this.inetAddress.getAddress().length);
  out.write(this.inetAddress.getAddress());
  StringRecord.writeString(out,this.hostName);
  StringRecord.writeString(out,this.domainName);
  out.writeInt(this.ipcPort);
  out.writeInt(this.dataPort);
}"
87685,"public ChannelReaderInputView(BlockChannelReader reader,List<MemorySegment> memory,int numBlocks,boolean waitForFirstBlock) throws IOException {
  super(ChannelWriterOutputView.HEADER_LENGTH);
  if (reader == null || memory == null)   throw new NullPointerException();
  if (memory.isEmpty())   throw new IllegalArgumentException(""String_Node_Str"");
  if (numBlocks < 1 && numBlocks != -1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.reader=reader;
  this.numRequestsRemaining=numBlocks;
  this.numSegments=memory.size();
  for (int i=0; i < memory.size(); i++) {
    sendReadRequest(memory.get(i));
  }
  if (waitForFirstBlock) {
    advance();
  }
}","public ChannelReaderInputView(BlockChannelReader reader,List<MemorySegment> memory,int numBlocks,boolean waitForFirstBlock) throws IOException {
  super(ChannelWriterOutputView.HEADER_LENGTH);
  if (reader == null || memory == null)   throw new NullPointerException();
  if (memory.isEmpty())   throw new IllegalArgumentException(""String_Node_Str"");
  if (numBlocks < 1 && numBlocks != -1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.reader=reader;
  this.numRequestsRemaining=numBlocks;
  this.numSegments=memory.size();
  this.freeMem=new ArrayList<MemorySegment>(this.numSegments);
  for (int i=0; i < memory.size(); i++) {
    sendReadRequest(memory.get(i));
  }
  if (waitForFirstBlock) {
    advance();
  }
}"
87686,"/** 
 * Sends a new read requests, if further requests remain. Otherwise, this method adds the segment directly to the readers return queue.
 * @param seg The segment to use for the read request.
 * @throws IOException Thrown, if the reader is in error.
 */
private void sendReadRequest(MemorySegment seg) throws IOException {
  if (this.numRequestsRemaining != 0) {
    this.reader.readBlock(seg);
    if (this.numRequestsRemaining != -1) {
      this.numRequestsRemaining--;
    }
  }
 else {
    this.reader.getReturnQueue().add(seg);
  }
}","/** 
 * Sends a new read requests, if further requests remain. Otherwise, this method adds the segment directly to the readers return queue.
 * @param seg The segment to use for the read request.
 * @throws IOException Thrown, if the reader is in error.
 */
private void sendReadRequest(MemorySegment seg) throws IOException {
  if (this.numRequestsRemaining != 0) {
    this.reader.readBlock(seg);
    if (this.numRequestsRemaining != -1) {
      this.numRequestsRemaining--;
    }
  }
 else {
    this.freeMem.add(seg);
  }
}"
87687,"/** 
 * Closes this InoutView, closing the underlying reader and returning all memory segments.
 * @return A list containing all memory segments originally supplied to this view.
 * @throws IOException Thrown, if the underlying reader could not be properly closed.
 */
public List<MemorySegment> close() throws IOException {
  if (this.closed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  this.closed=true;
  ArrayList<MemorySegment> list=new ArrayList<MemorySegment>(this.numSegments);
  final MemorySegment current=getCurrentSegment();
  if (current != null) {
    list.add(current);
  }
  clear();
  final LinkedBlockingQueue<MemorySegment> queue=this.reader.getReturnQueue();
  this.reader.close();
  while (list.size() < this.numSegments) {
    final MemorySegment m=queue.poll();
    if (m == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    list.add(m);
  }
  return list;
}","/** 
 * Closes this InputView, closing the underlying reader and returning all memory segments.
 * @return A list containing all memory segments originally supplied to this view.
 * @throws IOException Thrown, if the underlying reader could not be properly closed.
 */
public List<MemorySegment> close() throws IOException {
  if (this.closed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  this.closed=true;
  ArrayList<MemorySegment> list=this.freeMem;
  final MemorySegment current=getCurrentSegment();
  if (current != null) {
    list.add(current);
  }
  clear();
  final LinkedBlockingQueue<MemorySegment> queue=this.reader.getReturnQueue();
  this.reader.close();
  while (list.size() < this.numSegments) {
    final MemorySegment m=queue.poll();
    if (m == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    list.add(m);
  }
  return list;
}"
87688,"/** 
 * Creates an new ChannelWriterOutputView that writes to the given channel. It uses only a single memory segment for the buffering, which it takes from the writers return queue.
 * @param writer The writer to write to.
 * @param segmentSize The size of the memory segments.
 */
public ChannelWriterOutputView(BlockChannelWriter writer,int segmentSize){
  this(writer,null,segmentSize);
}","/** 
 * Creates an new ChannelWriterOutputView that writes to the given channel. It uses only a single memory segment for the buffering, which it takes from the writers return queue. Note that this variant locks if no buffers are contained in the return queue.
 * @param writer The writer to write to.
 * @param segmentSize The size of the memory segments.
 */
public ChannelWriterOutputView(BlockChannelWriter writer,int segmentSize){
  this(writer,null,segmentSize);
}"
87689,"/** 
 * {@inheritDoc}
 */
@Override public void processEvent(final AbstractEvent event){
  if (event instanceof ByteBufferedChannelCloseEvent) {
    LOG.info(""String_Node_Str"");
  }
 else   if (event instanceof UnexpectedEnvelopeEvent) {
    final UnexpectedEnvelopeEvent uee=(UnexpectedEnvelopeEvent)event;
    if (uee.getExpectedSequenceNumber() > this.nextEnvelopeToSend) {
      this.nextEnvelopeToSend=uee.getExpectedSequenceNumber();
    }
  }
 else   if (event instanceof ReceiverNotFoundEvent) {
    final ReceiverNotFoundEvent rnfe=(ReceiverNotFoundEvent)event;
    LOG.warn(""String_Node_Str"" + rnfe.getReceiverID() + ""String_Node_Str""+ rnfe.getSequenceNumber());
  }
 else {
    LOG.warn(""String_Node_Str"" + event);
  }
  getNext().processEvent(event);
}","/** 
 * {@inheritDoc}
 */
@Override public void processEvent(final AbstractEvent event){
  if (event instanceof ByteBufferedChannelCloseEvent) {
    LOG.info(""String_Node_Str"");
  }
 else   if (event instanceof UnexpectedEnvelopeEvent) {
    final UnexpectedEnvelopeEvent uee=(UnexpectedEnvelopeEvent)event;
    if (uee.getExpectedSequenceNumber() > this.nextEnvelopeToSend) {
      this.nextEnvelopeToSend=uee.getExpectedSequenceNumber();
    }
  }
 else   if (event instanceof ReceiverNotFoundEvent) {
    final ReceiverNotFoundEvent rnfe=(ReceiverNotFoundEvent)event;
    LOG.warn(""String_Node_Str"" + rnfe.getReceiverID() + ""String_Node_Str""+ rnfe.getSequenceNumber()+ ""String_Node_Str""+ this.nextEnvelopeToSend);
  }
 else {
    LOG.warn(""String_Node_Str"" + event);
  }
  getNext().processEvent(event);
}"
87690,"private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID,!this.isCheckpointLocal);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  Buffer firstDeserializedFileBuffer=null;
  FileChannel fileChannel=null;
  try {
    while (true) {
      if (this.restartRequested.compareAndSet(true,false)) {
        metaDataIndex=0;
      }
      final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
      while (!fileSystem.exists(metaDataFile)) {
        final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
        if (fileSystem.exists(finalMetaDataFile)) {
          return;
        }
        if (this.isCheckpointComplete) {
          throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
        }
        Thread.sleep(1000);
        if (this.executionObserver.isCanceled()) {
          return;
        }
      }
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputChannelBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              if (firstDeserializedFileBuffer == null) {
                firstDeserializedFileBuffer=srcBuffer.duplicate();
              }
              if (transferEnvelope.getSequenceNumber() < broker.getNextEnvelopeToSend()) {
                srcBuffer.recycleBuffer();
                continue;
              }
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
            if (this.executionObserver.isCanceled()) {
              return;
            }
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          fileChannel=null;
          ++metaDataIndex;
          break;
        }
      }
    }
  }
  finally {
    if (firstDeserializedFileBuffer != null) {
      firstDeserializedFileBuffer.recycleBuffer();
      firstDeserializedFileBuffer=null;
    }
    if (fileChannel != null) {
      fileChannel.close();
      fileChannel=null;
    }
  }
}","private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID,!this.isCheckpointLocal);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  Buffer firstDeserializedFileBuffer=null;
  FileChannel fileChannel=null;
  try {
    while (true) {
      if (this.restartRequested.compareAndSet(true,false)) {
        metaDataIndex=0;
        resetAllOutputBroker();
      }
      final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
      while (!fileSystem.exists(metaDataFile)) {
        final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
        if (fileSystem.exists(finalMetaDataFile)) {
          return;
        }
        if (this.isCheckpointComplete) {
          throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
        }
        Thread.sleep(1000);
        if (this.executionObserver.isCanceled()) {
          return;
        }
      }
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputChannelBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              if (firstDeserializedFileBuffer == null) {
                firstDeserializedFileBuffer=srcBuffer.duplicate();
              }
              if (transferEnvelope.getSequenceNumber() < broker.getNextEnvelopeToSend()) {
                srcBuffer.recycleBuffer();
                continue;
              }
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
            if (this.executionObserver.isCanceled()) {
              return;
            }
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          fileChannel=null;
          ++metaDataIndex;
          break;
        }
      }
    }
  }
  finally {
    if (firstDeserializedFileBuffer != null) {
      firstDeserializedFileBuffer.recycleBuffer();
      firstDeserializedFileBuffer=null;
    }
    if (fileChannel != null) {
      fileChannel.close();
      fileChannel=null;
    }
  }
}"
87691,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
  changeExecutionState(ExecutionState.REPLAYING,null);
  if (this.executionObserver.isCanceled()) {
    changeExecutionState(ExecutionState.CANCELED,null);
    return;
  }
  resetAllOutputBroker();
  try {
    replayCheckpoint();
    if (this.executionObserver.isCanceled()) {
      throw new InterruptedException();
    }
  }
 catch (  Exception e) {
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    waitForAllOutputBrokerToFinish();
  }
 catch (  Exception e) {
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
  changeExecutionState(ExecutionState.REPLAYING,null);
  if (this.executionObserver.isCanceled()) {
    changeExecutionState(ExecutionState.CANCELED,null);
    return;
  }
  try {
    replayCheckpoint();
    if (this.executionObserver.isCanceled()) {
      throw new InterruptedException();
    }
  }
 catch (  Exception e) {
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    waitForAllOutputBrokerToFinish();
  }
 catch (  Exception e) {
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}"
87692,"/** 
 * Checks, if all target vertices for multicast transmisison are ready. If vertices are in state ASSIGNED, it will deploy those vertices.
 * @param caller
 * @param jobID
 * @param sourceChannelID
 * @return
 */
private boolean checkIfAllTargetVerticesReady(InstanceConnectionInfo caller,JobID jobID,ChannelID sourceChannelID){
  final ExecutionGraph eg=this.scheduler.getExecutionGraphByID(jobID);
  final AbstractOutputChannel<? extends Record> outputChannel=eg.getOutputChannelByID(sourceChannelID);
  final OutputGate<? extends Record> broadcastgate=outputChannel.getOutputGate();
  List<ExecutionVertex> verticesToDeploy=null;
  for (  AbstractOutputChannel<? extends Record> c : broadcastgate.getOutputChannels()) {
    if (c.isBroadcastChannel()) {
      ExecutionVertex targetVertex=eg.getVertexByChannelID(c.getConnectedChannelID());
      if (targetVertex.getExecutionState() == ExecutionState.ASSIGNED) {
        if (verticesToDeploy == null) {
          verticesToDeploy=new ArrayList<ExecutionVertex>();
        }
        verticesToDeploy.add(targetVertex);
      }
 else {
        if (targetVertex.getExecutionState() != ExecutionState.RUNNING && targetVertex.getExecutionState() != ExecutionState.FINISHING && targetVertex.getExecutionState() != ExecutionState.READY && targetVertex.getExecutionState() != ExecutionState.STARTING) {
          return false;
        }
      }
    }
  }
  if (verticesToDeploy != null) {
    this.scheduler.deployAssignedVertices(verticesToDeploy);
    return false;
  }
  return true;
}","/** 
 * Checks, if all target vertices for multicast transmisison are ready. If vertices are in state ASSIGNED, it will deploy those vertices.
 * @param caller
 * @param jobID
 * @param sourceChannelID
 * @return
 */
private boolean checkIfAllTargetVerticesReady(InstanceConnectionInfo caller,JobID jobID,ChannelID sourceChannelID){
  final ExecutionGraph eg=this.scheduler.getExecutionGraphByID(jobID);
  final AbstractOutputChannel<? extends Record> outputChannel=eg.getOutputChannelByID(sourceChannelID);
  final OutputGate<? extends Record> broadcastgate=outputChannel.getOutputGate();
  List<ExecutionVertex> verticesToDeploy=null;
  for (  AbstractOutputChannel<? extends Record> c : broadcastgate.getOutputChannels()) {
    if (c.isBroadcastChannel()) {
      ExecutionVertex targetVertex=eg.getVertexByChannelID(c.getConnectedChannelID());
      if (targetVertex.getExecutionState() == ExecutionState.ASSIGNED) {
        if (verticesToDeploy == null) {
          verticesToDeploy=new ArrayList<ExecutionVertex>();
        }
        verticesToDeploy.add(targetVertex);
      }
 else {
        if (targetVertex.getExecutionState() != ExecutionState.RUNNING && targetVertex.getExecutionState() != ExecutionState.FINISHING) {
          return false;
        }
      }
    }
  }
  if (verticesToDeploy != null) {
    this.scheduler.deployAssignedVertices(verticesToDeploy);
    return false;
  }
  return true;
}"
87693,"/** 
 * {@inheritDoc}
 */
@Override public boolean equals(final Object obj){
  if (!(obj instanceof AbstractJobResult)) {
    return false;
  }
  final AbstractJobResult ajr=(AbstractJobResult)obj;
  if (this.returnCode == null) {
    if (ajr.getReturnCode() != null) {
      return false;
    }
  }
 else {
    if (!this.returnCode.equals(ajr.getReturnCode())) {
      return false;
    }
  }
  if (this.description == null) {
    if (this.description != null) {
      return false;
    }
  }
 else {
    if (!this.description.equals(ajr.getDescription())) {
      return false;
    }
  }
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(final Object obj){
  if (!(obj instanceof AbstractJobResult)) {
    return false;
  }
  final AbstractJobResult ajr=(AbstractJobResult)obj;
  if (this.returnCode == null) {
    if (ajr.getReturnCode() != null) {
      return false;
    }
  }
 else {
    if (!this.returnCode.equals(ajr.getReturnCode())) {
      return false;
    }
  }
  if (this.description == null) {
  }
 else {
    if (!this.description.equals(ajr.getDescription())) {
      return false;
    }
  }
  return true;
}"
87694,"/** 
 * Returns the next code point at the current position in the buffer. The buffer's position will be incremented. Any mark set on this buffer will be changed by this method!
 */
public static int bytesToCodePoint(final ByteBuffer bytes){
  bytes.mark();
  final byte b=bytes.get();
  bytes.reset();
  final int extraBytesToRead=bytesFromUTF8[(b & 0xFF)];
  if (extraBytesToRead < 0) {
    return -1;
  }
  int ch=0;
switch (extraBytesToRead) {
case 5:
    ch+=(bytes.get() & 0xFF);
  ch<<=6;
case 4:
ch+=(bytes.get() & 0xFF);
ch<<=6;
case 3:
ch+=(bytes.get() & 0xFF);
ch<<=6;
case 2:
ch+=(bytes.get() & 0xFF);
ch<<=6;
case 1:
ch+=(bytes.get() & 0xFF);
ch<<=6;
case 0:
ch+=(bytes.get() & 0xFF);
}
ch-=offsetsFromUTF8[extraBytesToRead];
return ch;
}","/** 
 * Returns the next code point at the current position in the buffer. The buffer's position will be incremented. Any mark set on this buffer will be changed by this method!
 */
public static int bytesToCodePoint(final ByteBuffer bytes){
  bytes.mark();
  final byte b=bytes.get();
  bytes.reset();
  final int extraBytesToRead=bytesFromUTF8[(b & 0xFF)];
  if (extraBytesToRead < 0) {
    return -1;
  }
  int ch=0;
switch (extraBytesToRead) {
case 5:
    ch+=(bytes.get() & 0xFF);
  ch<<=6;
case 4:
ch+=(bytes.get() & 0xFF);
ch<<=6;
case 3:
ch+=(bytes.get() & 0xFF);
ch<<=6;
case 2:
ch+=(bytes.get() & 0xFF);
ch<<=6;
case 1:
ch+=(bytes.get() & 0xFF);
ch<<=6;
case 0:
ch+=(bytes.get() & 0xFF);
default :
break;
}
ch-=offsetsFromUTF8[extraBytesToRead];
return ch;
}"
87695,"/** 
 * Check to see if a byte array is valid utf-8
 * @param utf8 the array of bytes
 * @param start the offset of the first byte in the array
 * @param len the length of the byte sequence
 * @throws MalformedInputException if the byte array contains invalid bytes
 */
public static void validateUTF8(final byte[] utf8,final int start,final int len) throws MalformedInputException {
  int count=start;
  int leadByte=0;
  int length=0;
  int state=LEAD_BYTE;
  while (count < start + len) {
    final int aByte=((int)utf8[count] & 0xFF);
switch (state) {
case LEAD_BYTE:
      leadByte=aByte;
    length=bytesFromUTF8[aByte];
switch (length) {
case 0:
    if (leadByte > 0x7F) {
      throw new MalformedInputException(count);
    }
  break;
case 1:
if (leadByte < 0xC2 || leadByte > 0xDF) {
  throw new MalformedInputException(count);
}
state=TRAIL_BYTE_1;
break;
case 2:
if (leadByte < 0xE0 || leadByte > 0xEF) {
throw new MalformedInputException(count);
}
state=TRAIL_BYTE_1;
break;
case 3:
if (leadByte < 0xF0 || leadByte > 0xF4) {
throw new MalformedInputException(count);
}
state=TRAIL_BYTE_1;
break;
default :
throw new MalformedInputException(count);
}
break;
case TRAIL_BYTE_1:
if (leadByte == 0xF0 && aByte < 0x90) {
throw new MalformedInputException(count);
}
if (leadByte == 0xF4 && aByte > 0x8F) {
throw new MalformedInputException(count);
}
if (leadByte == 0xE0 && aByte < 0xA0) {
throw new MalformedInputException(count);
}
if (leadByte == 0xED && aByte > 0x9F) {
throw new MalformedInputException(count);
}
case TRAIL_BYTE:
if (aByte < 0x80 || aByte > 0xBF) {
throw new MalformedInputException(count);
}
if (--length == 0) {
state=LEAD_BYTE;
}
 else {
state=TRAIL_BYTE;
}
break;
}
count++;
}
}","/** 
 * Check to see if a byte array is valid utf-8
 * @param utf8 the array of bytes
 * @param start the offset of the first byte in the array
 * @param len the length of the byte sequence
 * @throws MalformedInputException if the byte array contains invalid bytes
 */
public static void validateUTF8(final byte[] utf8,final int start,final int len) throws MalformedInputException {
  int count=start;
  int leadByte=0;
  int length=0;
  int state=LEAD_BYTE;
  while (count < start + len) {
    final int aByte=((int)utf8[count] & 0xFF);
switch (state) {
case LEAD_BYTE:
      leadByte=aByte;
    length=bytesFromUTF8[aByte];
switch (length) {
case 0:
    if (leadByte > 0x7F) {
      throw new MalformedInputException(count);
    }
  break;
case 1:
if (leadByte < 0xC2 || leadByte > 0xDF) {
  throw new MalformedInputException(count);
}
state=TRAIL_BYTE_1;
break;
case 2:
if (leadByte < 0xE0 || leadByte > 0xEF) {
throw new MalformedInputException(count);
}
state=TRAIL_BYTE_1;
break;
case 3:
if (leadByte < 0xF0 || leadByte > 0xF4) {
throw new MalformedInputException(count);
}
state=TRAIL_BYTE_1;
break;
default :
throw new MalformedInputException(count);
}
break;
case TRAIL_BYTE_1:
if (leadByte == 0xF0 && aByte < 0x90) {
throw new MalformedInputException(count);
}
if (leadByte == 0xF4 && aByte > 0x8F) {
throw new MalformedInputException(count);
}
if (leadByte == 0xE0 && aByte < 0xA0) {
throw new MalformedInputException(count);
}
if (leadByte == 0xED && aByte > 0x9F) {
throw new MalformedInputException(count);
}
case TRAIL_BYTE:
if (aByte < 0x80 || aByte > 0xBF) {
throw new MalformedInputException(count);
}
if (--length == 0) {
state=LEAD_BYTE;
}
 else {
state=TRAIL_BYTE;
}
break;
default :
break;
}
count++;
}
}"
87696,"/** 
 * Reads a hard-coded tree topology from file and creates a tree according to the hard-coded topology from the file.
 * @param nodes
 * @return
 */
private MulticastForwardingTable createHardCodedTree(LinkedList<TreeNode> nodes){
  try {
    FileInputStream fstream=new FileInputStream(this.hardcodedtreefilepath);
    DataInputStream in=new DataInputStream(fstream);
    BufferedReader br=new BufferedReader(new InputStreamReader(in));
    String strLine;
    while ((strLine=br.readLine()) != null) {
      String[] values=strLine.split(""String_Node_Str"");
      String actualhostname=values[0];
      for (      TreeNode n : nodes) {
        if (n.toString().equals(actualhostname)) {
          for (int i=1; i < values.length; i++) {
            for (            TreeNode childnode : nodes) {
              if (childnode.toString().equals(values[i])) {
                n.addChild(childnode);
              }
            }
          }
        }
      }
    }
    return nodes.getFirst().createForwardingTable();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return null;
  }
}","/** 
 * Reads a hard-coded tree topology from file and creates a tree according to the hard-coded topology from the file.
 * @param nodes
 * @return
 */
private MulticastForwardingTable createHardCodedTree(LinkedList<TreeNode> nodes){
  try {
    FileInputStream fstream=new FileInputStream(this.hardcodedtreefilepath);
    DataInputStream in=new DataInputStream(fstream);
    BufferedReader br=new BufferedReader(new InputStreamReader(in));
    String strLine;
    while ((strLine=br.readLine()) != null) {
      String[] values=strLine.split(""String_Node_Str"");
      String actualhostname=values[0];
      for (      TreeNode n : nodes) {
        if (n.toString().equals(actualhostname)) {
          for (int i=1; i < values.length; i++) {
            for (            TreeNode childnode : nodes) {
              if (childnode.toString().equals(values[i])) {
                n.addChild(childnode);
              }
            }
          }
        }
      }
    }
    br.close();
    return nodes.getFirst().createForwardingTable();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return null;
  }
}"
87697,"/** 
 * Auxiliary method that reads penalties for tree nodes from the given file. Expects penalties in format <HOSTNAME> <PENALTY_AS_INTEGER> and saves the penalty value in the corresponding TreeNode objects within the provided list.
 * @param f
 * @param nodes List with the nodes
 */
private void readPenalitesFromFile(File f,List<TreeNode> nodes){
  try {
    FileInputStream fstream=new FileInputStream(f);
    DataInputStream in=new DataInputStream(fstream);
    BufferedReader br=new BufferedReader(new InputStreamReader(in));
    String strLine;
    while ((strLine=br.readLine()) != null) {
      String[] values=strLine.split(""String_Node_Str"");
      String actualhostname=values[0];
      int actualpenalty=Integer.valueOf(values[1]);
      for (      TreeNode n : nodes) {
        if (n.toString().equals(actualhostname)) {
          System.out.println(""String_Node_Str"" + n.toString() + ""String_Node_Str""+ actualpenalty);
          n.setProperty(""String_Node_Str"",actualpenalty);
        }
      }
    }
    in.close();
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Auxiliary method that reads penalties for tree nodes from the given file. Expects penalties in format <HOSTNAME> <PENALTY_AS_INTEGER> and saves the penalty value in the corresponding TreeNode objects within the provided list.
 * @param f
 * @param nodes List with the nodes
 */
private void readPenalitesFromFile(File f,List<TreeNode> nodes){
  try {
    FileInputStream fstream=new FileInputStream(f);
    DataInputStream in=new DataInputStream(fstream);
    BufferedReader br=new BufferedReader(new InputStreamReader(in));
    String strLine;
    while ((strLine=br.readLine()) != null) {
      String[] values=strLine.split(""String_Node_Str"");
      String actualhostname=values[0];
      int actualpenalty=Integer.valueOf(values[1]);
      for (      TreeNode n : nodes) {
        if (n.toString().equals(actualhostname)) {
          System.out.println(""String_Node_Str"" + n.toString() + ""String_Node_Str""+ actualpenalty);
          n.setProperty(""String_Node_Str"",actualpenalty);
        }
      }
    }
    br.close();
    in.close();
    fstream.close();
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
  }
}"
87698,"@Override public Schema create(Iterable<EvaluationExpression> keyExpressions){
  List<ObjectAccess> objectAccesses=new ArrayList<ObjectAccess>();
  List<ArrayAccess> arrayAccesses=new ArrayList<ArrayAccess>();
  List<EvaluationExpression> mappings=new ArrayList<EvaluationExpression>();
  for (  EvaluationExpression evaluationExpression : keyExpressions) {
    mappings.add(evaluationExpression);
    if (evaluationExpression instanceof ObjectAccess) {
      objectAccesses.add((ObjectAccess)evaluationExpression);
    }
    if (evaluationExpression instanceof ArrayAccess) {
      arrayAccesses.add((ArrayAccess)evaluationExpression);
    }
  }
  if (mappings.isEmpty())   return new DirectSchema();
  if (objectAccesses.size() == mappings.size()) {
    ObjectSchema schema=new ObjectSchema();
    schema.setMappingsWithAccesses(objectAccesses);
    return schema;
  }
 else   if (arrayAccesses.size() == mappings.size()) {
    int startIndex=arrayAccesses.get(0).getStartIndex();
    int endIndex=arrayAccesses.get(arrayAccesses.size()).getEndIndex();
    if (startIndex == 0) {
      HeadArraySchema schema=new HeadArraySchema();
      schema.setHeadSize(endIndex + 1);
      return schema;
    }
 else {
      TailArraySchema schema=new TailArraySchema();
      schema.setTailSize(endIndex - startIndex + 1);
      return schema;
    }
  }
 else {
    return new GeneralSchema(mappings);
  }
}","@Override public Schema create(Iterable<EvaluationExpression> keyExpressions){
  List<ObjectAccess> objectAccesses=new ArrayList<ObjectAccess>();
  List<ArrayAccess> arrayAccesses=new ArrayList<ArrayAccess>();
  List<EvaluationExpression> mappings=new ArrayList<EvaluationExpression>();
  for (  EvaluationExpression evaluationExpression : keyExpressions) {
    mappings.add(evaluationExpression);
    if (evaluationExpression instanceof ObjectAccess) {
      objectAccesses.add((ObjectAccess)evaluationExpression);
    }
    if (evaluationExpression instanceof ArrayAccess) {
      arrayAccesses.add((ArrayAccess)evaluationExpression);
    }
  }
  if (mappings.isEmpty())   return new DirectSchema();
  if (objectAccesses.size() == mappings.size()) {
    ObjectSchema schema=new ObjectSchema();
    schema.setMappingsWithAccesses(objectAccesses);
    return schema;
  }
 else   if (arrayAccesses.size() == mappings.size()) {
    int startIndex=arrayAccesses.get(0).getStartIndex();
    int endIndex=arrayAccesses.get(arrayAccesses.size() - 1).getEndIndex();
    if (startIndex == 0) {
      HeadArraySchema schema=new HeadArraySchema();
      schema.setHeadSize(endIndex + 1);
      return schema;
    }
 else {
      TailArraySchema schema=new TailArraySchema();
      schema.setTailSize(endIndex - startIndex + 1);
      return schema;
    }
  }
 else {
    return new GeneralSchema(mappings);
  }
}"
87699,"void restart(){
  changeExecutionState(ExecutionState.STARTING,null);
  this.restartRequested.set(true);
  interrupt();
  this.interruptCalled.set(true);
}","void restart(){
  changeExecutionState(ExecutionState.STARTING,null);
  this.restartRequested.set(true);
  changeExecutionState(ExecutionState.REPLAYING,null);
}"
87700,"private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID,!this.isCheckpointLocal);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  Buffer firstDeserializedFileBuffer=null;
  FileChannel fileChannel=null;
  try {
    while (true) {
      final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
      while (!fileSystem.exists(metaDataFile)) {
        final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
        if (fileSystem.exists(finalMetaDataFile)) {
          return;
        }
        if (this.isCheckpointComplete) {
          throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
        }
        Thread.sleep(1000);
        if (this.executionObserver.isCanceled()) {
          return;
        }
      }
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputChannelBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              if (firstDeserializedFileBuffer == null) {
                firstDeserializedFileBuffer=srcBuffer.duplicate();
              }
              if (transferEnvelope.getSequenceNumber() < broker.getNextEnvelopeToSend()) {
                srcBuffer.recycleBuffer();
                continue;
              }
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
            if (this.executionObserver.isCanceled()) {
              return;
            }
            if (this.restartRequested.get()) {
              return;
            }
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          fileChannel=null;
          ++metaDataIndex;
          break;
        }
      }
    }
  }
  finally {
    if (firstDeserializedFileBuffer != null) {
      firstDeserializedFileBuffer.recycleBuffer();
      firstDeserializedFileBuffer=null;
    }
    if (fileChannel != null) {
      fileChannel.close();
      fileChannel=null;
    }
  }
}","private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID,!this.isCheckpointLocal);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  Buffer firstDeserializedFileBuffer=null;
  FileChannel fileChannel=null;
  try {
    while (true) {
      if (this.restartRequested.compareAndSet(true,false)) {
        metaDataIndex=0;
      }
      final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
      while (!fileSystem.exists(metaDataFile)) {
        final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
        if (fileSystem.exists(finalMetaDataFile)) {
          return;
        }
        if (this.isCheckpointComplete) {
          throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
        }
        Thread.sleep(1000);
        if (this.executionObserver.isCanceled()) {
          return;
        }
      }
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputChannelBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              if (firstDeserializedFileBuffer == null) {
                firstDeserializedFileBuffer=srcBuffer.duplicate();
              }
              if (transferEnvelope.getSequenceNumber() < broker.getNextEnvelopeToSend()) {
                srcBuffer.recycleBuffer();
                continue;
              }
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
            if (this.executionObserver.isCanceled()) {
              return;
            }
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          fileChannel=null;
          ++metaDataIndex;
          break;
        }
      }
    }
  }
  finally {
    if (firstDeserializedFileBuffer != null) {
      firstDeserializedFileBuffer.recycleBuffer();
      firstDeserializedFileBuffer=null;
    }
    if (fileChannel != null) {
      fileChannel.close();
      fileChannel=null;
    }
  }
}"
87701,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
  while (true) {
    changeExecutionState(ExecutionState.REPLAYING,null);
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
      return;
    }
    resetAllOutputBroker();
    try {
      replayCheckpoint();
      if (this.executionObserver.isCanceled()) {
        throw new InterruptedException();
      }
    }
 catch (    Exception e) {
      if (isRestartRequested()) {
        continue;
      }
      if (this.executionObserver.isCanceled()) {
        changeExecutionState(ExecutionState.CANCELED,null);
      }
 else {
        changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
      }
      return;
    }
    if (isRestartRequested()) {
      continue;
    }
    break;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    waitForAllOutputBrokerToFinish();
  }
 catch (  Exception e) {
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
  changeExecutionState(ExecutionState.REPLAYING,null);
  if (this.executionObserver.isCanceled()) {
    changeExecutionState(ExecutionState.CANCELED,null);
    return;
  }
  resetAllOutputBroker();
  try {
    replayCheckpoint();
    if (this.executionObserver.isCanceled()) {
      throw new InterruptedException();
    }
  }
 catch (  Exception e) {
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    waitForAllOutputBrokerToFinish();
  }
 catch (  Exception e) {
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}"
87702,"boolean followsLog(){
  if (this.numberOfInitialLogEntries == 0) {
    return false;
  }
synchronized (this) {
    return this.announcedEnvelopesAsIntBuffer.hasRemaining();
  }
}","boolean followsLog(){
  if (this.numberOfInitialLogEntries == 0) {
    return false;
  }
synchronized (this) {
    return this.outstandingEnvelopesAsIntBuffer.hasRemaining();
  }
}"
87703,"private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID,!this.isCheckpointLocal);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  Buffer firstDeserializedFileBuffer=null;
  FileChannel fileChannel=null;
  try {
    while (true) {
      final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
      while (!fileSystem.exists(metaDataFile)) {
        final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
        if (fileSystem.exists(finalMetaDataFile)) {
          return;
        }
        if (this.isCheckpointComplete) {
          throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
        }
        Thread.sleep(1000);
      }
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputChannelBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              if (firstDeserializedFileBuffer == null) {
                firstDeserializedFileBuffer=srcBuffer.duplicate();
              }
              if (transferEnvelope.getSequenceNumber() < broker.getNextEnvelopeToSend()) {
                srcBuffer.recycleBuffer();
                continue;
              }
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
            if (this.executionObserver.isCanceled()) {
              return;
            }
            if (this.restartRequested.get()) {
              return;
            }
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          fileChannel=null;
          ++metaDataIndex;
          break;
        }
      }
    }
  }
  finally {
    if (firstDeserializedFileBuffer != null) {
      firstDeserializedFileBuffer.recycleBuffer();
      firstDeserializedFileBuffer=null;
    }
    if (fileChannel != null) {
      fileChannel.close();
      fileChannel=null;
    }
  }
}","private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID,!this.isCheckpointLocal);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  Buffer firstDeserializedFileBuffer=null;
  FileChannel fileChannel=null;
  try {
    while (true) {
      final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
      while (!fileSystem.exists(metaDataFile)) {
        final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
        if (fileSystem.exists(finalMetaDataFile)) {
          return;
        }
        if (this.isCheckpointComplete) {
          throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
        }
        Thread.sleep(1000);
        if (this.executionObserver.isCanceled()) {
          return;
        }
      }
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputChannelBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              if (firstDeserializedFileBuffer == null) {
                firstDeserializedFileBuffer=srcBuffer.duplicate();
              }
              if (transferEnvelope.getSequenceNumber() < broker.getNextEnvelopeToSend()) {
                srcBuffer.recycleBuffer();
                continue;
              }
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
            if (this.executionObserver.isCanceled()) {
              return;
            }
            if (this.restartRequested.get()) {
              return;
            }
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          fileChannel=null;
          ++metaDataIndex;
          break;
        }
      }
    }
  }
  finally {
    if (firstDeserializedFileBuffer != null) {
      firstDeserializedFileBuffer.recycleBuffer();
      firstDeserializedFileBuffer=null;
    }
    if (fileChannel != null) {
      fileChannel.close();
      fileChannel=null;
    }
  }
}"
87704,"/** 
 * Sets up Nephele in local mode.
 */
@BeforeClass public static void startNephele(){
  if (jobManagerThread == null) {
    JobManager jobManager=null;
    try {
      final String userDir=System.getProperty(""String_Node_Str"");
      String configDir=userDir + File.separator + CONFIGURATION_DIRECTORY;
      if (!new File(configDir).exists()) {
        configDir=userDir + ""String_Node_Str"" + CONFIGURATION_DIRECTORY;
      }
      final Constructor<JobManager> c=JobManager.class.getDeclaredConstructor(new Class[]{String.class,String.class});
      c.setAccessible(true);
      jobManager=c.newInstance(new Object[]{configDir,new String(""String_Node_Str"")});
    }
 catch (    SecurityException e) {
      fail(e.getMessage());
    }
catch (    NoSuchMethodException e) {
      fail(e.getMessage());
    }
catch (    IllegalArgumentException e) {
      fail(e.getMessage());
    }
catch (    InstantiationException e) {
      fail(e.getMessage());
    }
catch (    IllegalAccessException e) {
      fail(e.getMessage());
    }
catch (    InvocationTargetException e) {
      fail(e.getMessage());
    }
    configuration=GlobalConfiguration.getConfiguration(new String[]{ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY});
    if (jobManager != null) {
      jobManagerThread=new JobManagerThread(jobManager);
      jobManagerThread.start();
    }
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}","/** 
 * Sets up Nephele in local mode.
 */
@BeforeClass public static void startNephele(){
  if (jobManagerThread == null) {
    JobManager jobManager=null;
    try {
      final String userDir=System.getProperty(""String_Node_Str"");
      String configDir=userDir + File.separator + CONFIGURATION_DIRECTORY;
      if (!new File(configDir).exists()) {
        configDir=userDir + ""String_Node_Str"" + CONFIGURATION_DIRECTORY;
      }
      final Constructor<JobManager> c=JobManager.class.getDeclaredConstructor(new Class[]{String.class,String.class});
      c.setAccessible(true);
      jobManager=c.newInstance(new Object[]{configDir,new String(""String_Node_Str"")});
    }
 catch (    SecurityException e) {
      fail(e.getMessage());
    }
catch (    NoSuchMethodException e) {
      fail(e.getMessage());
    }
catch (    IllegalArgumentException e) {
      fail(e.getMessage());
    }
catch (    InstantiationException e) {
      fail(e.getMessage());
    }
catch (    IllegalAccessException e) {
      fail(e.getMessage());
    }
catch (    InvocationTargetException e) {
      fail(e.getMessage());
    }
    configuration=GlobalConfiguration.getConfiguration(new String[]{ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY});
    if (jobManager != null) {
      jobManagerThread=new JobManagerThread(jobManager);
      jobManagerThread.start();
    }
    try {
      ServerTestUtils.waitForJobManagerToBecomeReady(jobManager);
    }
 catch (    Exception e) {
      fail(StringUtils.stringifyException(e));
    }
  }
}"
87705,"/** 
 * Sets up Nephele in local mode.
 */
@BeforeClass public static void startNephele(){
  if (jobManagerThread == null) {
    JobManager jobManager=null;
    try {
      Constructor<JobManager> c=JobManager.class.getDeclaredConstructor(new Class[]{String.class,String.class});
      c.setAccessible(true);
      jobManager=c.newInstance(new Object[]{ServerTestUtils.getConfigDir(),new String(""String_Node_Str"")});
    }
 catch (    SecurityException e) {
      fail(e.getMessage());
    }
catch (    NoSuchMethodException e) {
      fail(e.getMessage());
    }
catch (    IllegalArgumentException e) {
      fail(e.getMessage());
    }
catch (    InstantiationException e) {
      fail(e.getMessage());
    }
catch (    IllegalAccessException e) {
      fail(e.getMessage());
    }
catch (    InvocationTargetException e) {
      fail(e.getMessage());
    }
    configuration=GlobalConfiguration.getConfiguration(new String[]{ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY});
    if (jobManager != null) {
      jobManagerThread=new JobManagerThread(jobManager);
      jobManagerThread.start();
    }
    try {
      Thread.sleep(10000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}","/** 
 * Sets up Nephele in local mode.
 */
@BeforeClass public static void startNephele(){
  if (jobManagerThread == null) {
    JobManager jobManager=null;
    try {
      Constructor<JobManager> c=JobManager.class.getDeclaredConstructor(new Class[]{String.class,String.class});
      c.setAccessible(true);
      jobManager=c.newInstance(new Object[]{ServerTestUtils.getConfigDir(),new String(""String_Node_Str"")});
    }
 catch (    SecurityException e) {
      fail(e.getMessage());
    }
catch (    NoSuchMethodException e) {
      fail(e.getMessage());
    }
catch (    IllegalArgumentException e) {
      fail(e.getMessage());
    }
catch (    InstantiationException e) {
      fail(e.getMessage());
    }
catch (    IllegalAccessException e) {
      fail(e.getMessage());
    }
catch (    InvocationTargetException e) {
      fail(e.getMessage());
    }
    configuration=GlobalConfiguration.getConfiguration(new String[]{ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY});
    if (jobManager != null) {
      jobManagerThread=new JobManagerThread(jobManager);
      jobManagerThread.start();
    }
    try {
      ServerTestUtils.waitForJobManagerToBecomeReady(jobManager);
    }
 catch (    Exception e) {
      fail(StringUtils.stringifyException(e));
    }
  }
}"
87706,"private boolean isRestartRequested(){
  if (this.restartRequested.compareAndSet(true,false)) {
    if (!this.interruptCalled.compareAndSet(true,false)) {
      while (!Thread.currentThread().isInterrupted()) {
      }
      this.interruptCalled.set(false);
    }
    Thread.interrupted();
    return true;
  }
  return false;
}","private boolean isRestartRequested(){
  if (this.restartRequested.compareAndSet(true,false)) {
    if (!this.interruptCalled.compareAndSet(true,false)) {
      try {
        Thread.sleep(10L);
      }
 catch (      InterruptedException e) {
      }
      this.interruptCalled.set(false);
    }
    Thread.interrupted();
    return true;
  }
  return false;
}"
87707,"void wire(final ExecutionGroupVertex source,final int indexOfOutputGate,final ExecutionGroupVertex target,final int indexOfInputGate,final ChannelType channelType,final CompressionLevel compressionLevel) throws GraphConversionException {
  for (int i=0; i < source.getCurrentNumberOfGroupMembers(); i++) {
    final ExecutionVertex sourceVertex=source.getGroupMember(i);
    final OutputGate<? extends Record> outputGate=sourceVertex.getEnvironment().getOutputGate(indexOfOutputGate);
    if (outputGate == null) {
      throw new GraphConversionException(""String_Node_Str"" + sourceVertex.getName() + ""String_Node_Str""+ indexOfOutputGate);
    }
    if (outputGate.getNumberOfOutputChannels() > 0) {
      throw new GraphConversionException(""String_Node_Str"" + sourceVertex.getName() + ""String_Node_Str""+ i+ ""String_Node_Str""+ outputGate.getNumberOfOutputChannels()+ ""String_Node_Str"");
    }
    for (int j=0; j < target.getCurrentNumberOfGroupMembers(); j++) {
      final ExecutionVertex targetVertex=target.getGroupMember(j);
      final InputGate<? extends Record> inputGate=targetVertex.getEnvironment().getInputGate(indexOfInputGate);
      if (inputGate == null) {
        throw new GraphConversionException(""String_Node_Str"" + targetVertex.getName() + ""String_Node_Str""+ indexOfInputGate);
      }
      if (inputGate.getNumberOfInputChannels() > 0 && i == 0) {
        throw new GraphConversionException(""String_Node_Str"" + targetVertex.getName() + ""String_Node_Str""+ j+ ""String_Node_Str""+ inputGate.getNumberOfInputChannels()+ ""String_Node_Str"");
      }
      if (inputGate.getDistributionPattern().createWire(i,j,source.getCurrentNumberOfGroupMembers(),target.getCurrentNumberOfGroupMembers())) {
        createChannel(sourceVertex,outputGate,targetVertex,inputGate,channelType,compressionLevel);
      }
      inputGate.setChannelType(channelType);
    }
    outputGate.setChannelType(channelType);
  }
}","void wire(final ExecutionGroupVertex source,final int indexOfOutputGate,final ExecutionGroupVertex target,final int indexOfInputGate,final ChannelType channelType,final CompressionLevel compressionLevel) throws GraphConversionException {
  for (int i=0; i < source.getCurrentNumberOfGroupMembers(); i++) {
    final ExecutionVertex sourceVertex=source.getGroupMember(i);
    final OutputGate<? extends Record> outputGate=sourceVertex.getEnvironment().getOutputGate(indexOfOutputGate);
    if (outputGate == null) {
      throw new GraphConversionException(""String_Node_Str"" + sourceVertex.getName() + ""String_Node_Str""+ indexOfOutputGate);
    }
    if (outputGate.getNumberOfOutputChannels() > 0) {
      throw new GraphConversionException(""String_Node_Str"" + sourceVertex.getName() + ""String_Node_Str""+ i+ ""String_Node_Str""+ outputGate.getNumberOfOutputChannels()+ ""String_Node_Str"");
    }
    for (int j=0; j < target.getCurrentNumberOfGroupMembers(); j++) {
      final ExecutionVertex targetVertex=target.getGroupMember(j);
      final InputGate<? extends Record> inputGate=targetVertex.getEnvironment().getInputGate(indexOfInputGate);
      if (inputGate == null) {
        throw new GraphConversionException(""String_Node_Str"" + targetVertex.getName() + ""String_Node_Str""+ indexOfInputGate);
      }
      if (inputGate.getNumberOfInputChannels() > 0 && i == 0) {
        throw new GraphConversionException(""String_Node_Str"" + targetVertex.getName() + ""String_Node_Str""+ j+ ""String_Node_Str""+ inputGate.getNumberOfInputChannels()+ ""String_Node_Str"");
      }
      if (inputGate.getDistributionPattern().createWire(i,j,source.getCurrentNumberOfGroupMembers(),target.getCurrentNumberOfGroupMembers())) {
        createChannel(sourceVertex,outputGate,targetVertex,inputGate,channelType,compressionLevel);
      }
      inputGate.setChannelType(channelType);
    }
    outputGate.setChannelType(channelType);
    sourceVertex.checkInitialCheckpointState();
  }
}"
87708,"/** 
 * Private constructor used to duplicate execution vertices.
 * @param vertexID the ID of the new execution vertex.
 * @param invokableClass the task that is assigned to this execution vertex
 * @param executionGraph the execution graph the new vertex belongs to
 * @param groupVertex the group vertex the new vertex belongs to
 * @param environment the environment for the newly created vertex
 */
private ExecutionVertex(final ExecutionVertexID vertexID,final Class<? extends AbstractInvokable> invokableClass,final ExecutionGraph executionGraph,final ExecutionGroupVertex groupVertex,final RuntimeEnvironment environment){
  this.vertexID=vertexID;
  this.invokableClass=invokableClass;
  this.executionGraph=executionGraph;
  this.groupVertex=groupVertex;
  this.environment=environment;
  this.checkpointState=new AtomicEnum<CheckpointState>(groupVertex.getInitialCheckpointState());
  this.retriesLeft=new AtomicInteger(groupVertex.getNumberOfExecutionRetries());
  registerExecutionListener(this.executionGraph);
}","/** 
 * Private constructor used to duplicate execution vertices.
 * @param vertexID the ID of the new execution vertex.
 * @param invokableClass the task that is assigned to this execution vertex
 * @param executionGraph the execution graph the new vertex belongs to
 * @param groupVertex the group vertex the new vertex belongs to
 * @param environment the environment for the newly created vertex
 */
private ExecutionVertex(final ExecutionVertexID vertexID,final Class<? extends AbstractInvokable> invokableClass,final ExecutionGraph executionGraph,final ExecutionGroupVertex groupVertex,final RuntimeEnvironment environment){
  this.vertexID=vertexID;
  this.invokableClass=invokableClass;
  this.executionGraph=executionGraph;
  this.groupVertex=groupVertex;
  this.environment=environment;
  this.retriesLeft=new AtomicInteger(groupVertex.getNumberOfExecutionRetries());
  registerExecutionListener(this.executionGraph);
}"
87709,"/** 
 * Returns a duplicate of this execution vertex.
 * @param preserveVertexID <code>true</code> to copy the vertex's ID to the duplicated vertex, <code>false</code> to create a new ID
 * @return a duplicate of this execution vertex
 * @throws Exception any exception that might be thrown by the user code during instantiation and registration of input and output channels
 */
public ExecutionVertex duplicateVertex(final boolean preserveVertexID) throws Exception {
  ExecutionVertexID newVertexID;
  if (preserveVertexID) {
    newVertexID=this.vertexID;
  }
 else {
    newVertexID=new ExecutionVertexID();
  }
  final RuntimeEnvironment duplicatedEnvironment=this.environment.duplicateEnvironment();
  final ExecutionVertex duplicatedVertex=new ExecutionVertex(newVertexID,this.invokableClass,this.executionGraph,this.groupVertex,duplicatedEnvironment);
  duplicatedVertex.setAllocatedResource(this.allocatedResource);
  return duplicatedVertex;
}","/** 
 * Returns a duplicate of this execution vertex.
 * @param preserveVertexID <code>true</code> to copy the vertex's ID to the duplicated vertex, <code>false</code> to create a new ID
 * @return a duplicate of this execution vertex
 * @throws Exception any exception that might be thrown by the user code during instantiation and registration of input and output channels
 */
public ExecutionVertex duplicateVertex(final boolean preserveVertexID) throws Exception {
  ExecutionVertexID newVertexID;
  if (preserveVertexID) {
    newVertexID=this.vertexID;
  }
 else {
    newVertexID=new ExecutionVertexID();
  }
  final RuntimeEnvironment duplicatedEnvironment=this.environment.duplicateEnvironment();
  final ExecutionVertex duplicatedVertex=new ExecutionVertex(newVertexID,this.invokableClass,this.executionGraph,this.groupVertex,duplicatedEnvironment);
  duplicatedVertex.checkpointState.set(this.checkpointState.get());
  duplicatedVertex.setAllocatedResource(this.allocatedResource);
  return duplicatedVertex;
}"
87710,"void restart(){
  this.restartRequested.set(true);
}","void restart(){
  changeExecutionState(ExecutionState.STARTING,null);
  this.restartRequested.set(true);
  interrupt();
}"
87711,"private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID,!this.isCheckpointLocal);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  Buffer firstDeserializedFileBuffer=null;
  FileChannel fileChannel=null;
  try {
    while (true) {
      if (this.restartRequested.compareAndSet(true,false)) {
        metaDataIndex=0;
      }
      final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
      while (!fileSystem.exists(metaDataFile)) {
        final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
        if (fileSystem.exists(finalMetaDataFile)) {
          return;
        }
        if (this.isCheckpointComplete) {
          throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
        }
        Thread.sleep(1000);
      }
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputChannelBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              if (firstDeserializedFileBuffer == null) {
                firstDeserializedFileBuffer=srcBuffer.duplicate();
              }
              if (transferEnvelope.getSequenceNumber() < broker.getNextEnvelopeToSend()) {
                srcBuffer.recycleBuffer();
                continue;
              }
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          fileChannel=null;
          ++metaDataIndex;
          break;
        }
      }
    }
  }
  finally {
    if (firstDeserializedFileBuffer != null) {
      firstDeserializedFileBuffer.recycleBuffer();
      firstDeserializedFileBuffer=null;
    }
    if (fileChannel != null) {
      fileChannel.close();
      fileChannel=null;
    }
  }
}","private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID,!this.isCheckpointLocal);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  Buffer firstDeserializedFileBuffer=null;
  FileChannel fileChannel=null;
  try {
    while (true) {
      final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
      while (!fileSystem.exists(metaDataFile)) {
        final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
        if (fileSystem.exists(finalMetaDataFile)) {
          return;
        }
        if (this.isCheckpointComplete) {
          throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
        }
        Thread.sleep(1000);
      }
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputChannelBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              if (firstDeserializedFileBuffer == null) {
                firstDeserializedFileBuffer=srcBuffer.duplicate();
              }
              if (transferEnvelope.getSequenceNumber() < broker.getNextEnvelopeToSend()) {
                srcBuffer.recycleBuffer();
                continue;
              }
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
            if (this.restartRequested.get()) {
              return;
            }
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          fileChannel=null;
          ++metaDataIndex;
          break;
        }
      }
    }
  }
  finally {
    if (firstDeserializedFileBuffer != null) {
      firstDeserializedFileBuffer.recycleBuffer();
      firstDeserializedFileBuffer=null;
    }
    if (fileChannel != null) {
      fileChannel.close();
      fileChannel=null;
    }
  }
}"
87712,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
  changeExecutionState(ExecutionState.REPLAYING,null);
  if (this.executionObserver.isCanceled()) {
    changeExecutionState(ExecutionState.CANCELED,null);
    return;
  }
  try {
    replayCheckpoint();
    if (this.executionObserver.isCanceled()) {
      throw new InterruptedException();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    waitForAllOutputBrokerToFinish();
  }
 catch (  Exception e) {
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
  while (true) {
    changeExecutionState(ExecutionState.REPLAYING,null);
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
      return;
    }
    resetAllOutputBroker();
    try {
      replayCheckpoint();
      if (this.executionObserver.isCanceled()) {
        throw new InterruptedException();
      }
    }
 catch (    Exception e) {
      if (this.restartRequested.compareAndSet(true,false)) {
        while (!Thread.currentThread().isInterrupted()) {
        }
        Thread.interrupted();
        continue;
      }
      if (this.executionObserver.isCanceled()) {
        changeExecutionState(ExecutionState.CANCELED,null);
      }
 else {
        changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
      }
      return;
    }
    if (this.restartRequested.compareAndSet(true,false)) {
      while (!Thread.currentThread().isInterrupted()) {
      }
      Thread.interrupted();
      continue;
    }
    break;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    waitForAllOutputBrokerToFinish();
  }
 catch (  Exception e) {
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}"
87713,"/** 
 * Checks the transition of the execution state and outputs an error in case of an unexpected state transition.
 * @param jobManager <code>true</code> to indicate the method is called by the job manager, <code>false/<code> to indicate it is called by a task manager
 * @param taskName the name of the task whose execution has changed
 * @param oldState the old execution state
 * @param newState the new execution state
 */
public static void checkTransition(final boolean jobManager,final String taskName,final ExecutionState oldState,final ExecutionState newState){
  LOG.info((jobManager ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + oldState+ ""String_Node_Str""+ newState+ ""String_Node_Str""+ taskName+ ""String_Node_Str""+ System.currentTimeMillis());
  boolean unexpectedStateChange=true;
  if (oldState == ExecutionState.CREATED && newState == ExecutionState.SCHEDULED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.SCHEDULED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.ASSIGNED && newState == ExecutionState.READY) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.READY && newState == ExecutionState.STARTING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.STARTING && newState == ExecutionState.RUNNING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.FINISHING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.FINISHED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FAILED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FAILED && newState == ExecutionState.CREATED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHED && newState == ExecutionState.CREATED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.CANCELED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.CANCELED && newState == ExecutionState.CREATED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.STARTING && newState == ExecutionState.REPLAYING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.REPLAYING && newState == ExecutionState.FINISHING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.CREATED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.SCHEDULED && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.ASSIGNED && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.READY && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.STARTING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.REPLAYING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.CANCELING && newState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (unexpectedStateChange) {
    try {
      throw new IllegalStateException(""String_Node_Str"" + oldState + ""String_Node_Str""+ newState);
    }
 catch (    IllegalStateException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}","/** 
 * Checks the transition of the execution state and outputs an error in case of an unexpected state transition.
 * @param jobManager <code>true</code> to indicate the method is called by the job manager, <code>false/<code> to indicate it is called by a task manager
 * @param taskName the name of the task whose execution has changed
 * @param oldState the old execution state
 * @param newState the new execution state
 */
public static void checkTransition(final boolean jobManager,final String taskName,final ExecutionState oldState,final ExecutionState newState){
  LOG.info((jobManager ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + oldState+ ""String_Node_Str""+ newState+ ""String_Node_Str""+ taskName+ ""String_Node_Str""+ System.currentTimeMillis());
  boolean unexpectedStateChange=true;
  if (oldState == ExecutionState.CREATED && newState == ExecutionState.SCHEDULED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.SCHEDULED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.ASSIGNED && newState == ExecutionState.READY) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.READY && newState == ExecutionState.STARTING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.STARTING && newState == ExecutionState.RUNNING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.FINISHING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.FINISHED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FAILED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FAILED && newState == ExecutionState.CREATED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHED && newState == ExecutionState.CREATED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.CANCELED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.CANCELED && newState == ExecutionState.CREATED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.STARTING && newState == ExecutionState.REPLAYING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.REPLAYING && newState == ExecutionState.FINISHING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.CREATED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.SCHEDULED && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.ASSIGNED && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.READY && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.STARTING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.REPLAYING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.REPLAYING && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.CANCELING && newState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (unexpectedStateChange) {
    try {
      throw new IllegalStateException(""String_Node_Str"" + oldState + ""String_Node_Str""+ newState);
    }
 catch (    IllegalStateException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}"
87714,"/** 
 * {@inheritDoc}
 */
@Override public void logQueuedEnvelopes(){
  this.encapsulatedContext.logQueuedEnvelopes();
}","/** 
 * {@inheritDoc}
 */
@Override public void logQueuedEnvelopes(){
  if (this.encapsulatedContext != null) {
    this.encapsulatedContext.logQueuedEnvelopes();
  }
}"
87715,"/** 
 * {@inheritDoc}
 */
@Override public void processEvent(final AbstractEvent event){
  if (event instanceof ByteBufferedChannelCloseEvent) {
    LOG.info(""String_Node_Str"");
  }
 else   if (event instanceof UnexpectedEnvelopeEvent) {
    final UnexpectedEnvelopeEvent uee=(UnexpectedEnvelopeEvent)event;
    if (uee.getExpectedSequenceNumber() > this.nextEnvelopeToSend) {
      this.nextEnvelopeToSend=uee.getExpectedSequenceNumber();
    }
  }
 else {
    LOG.warn(""String_Node_Str"" + event);
  }
  getNext().processEvent(event);
}","/** 
 * {@inheritDoc}
 */
@Override public void processEvent(final AbstractEvent event){
  if (event instanceof ByteBufferedChannelCloseEvent) {
    LOG.info(""String_Node_Str"");
  }
 else   if (event instanceof UnexpectedEnvelopeEvent) {
    final UnexpectedEnvelopeEvent uee=(UnexpectedEnvelopeEvent)event;
    if (uee.getExpectedSequenceNumber() > this.nextEnvelopeToSend) {
      this.nextEnvelopeToSend=uee.getExpectedSequenceNumber();
    }
  }
 else   if (event instanceof ReceiverNotFoundEvent) {
    final ReceiverNotFoundEvent rnfe=(ReceiverNotFoundEvent)event;
    LOG.warn(""String_Node_Str"" + rnfe.getReceiverID() + ""String_Node_Str""+ rnfe.getSequenceNumber());
  }
 else {
    LOG.warn(""String_Node_Str"" + event);
  }
  getNext().processEvent(event);
}"
87716,"/** 
 * Cancels and removes the task represented by this vertex from the instance it is currently running on. If the task is not currently running, its execution state is simply updated to <code>CANCELLED</code>.
 * @return the result of the task cancel attempt
 */
public TaskCancelResult cancelTask(){
  final ExecutionState previousState=this.executionState.get();
  if (previousState == ExecutionState.CANCELED) {
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (updateExecutionState(ExecutionState.CANCELING) != ExecutionState.CANCELING) {
    if (this.groupVertex.getStageNumber() != this.executionGraph.getIndexOfCurrentExecutionStage()) {
      updateExecutionState(ExecutionState.CANCELED,null);
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState == ExecutionState.FINISHED || previousState == ExecutionState.FAILED) {
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState != ExecutionState.RUNNING && previousState != ExecutionState.STARTING && previousState != ExecutionState.FINISHING && previousState != ExecutionState.REPLAYING) {
      updateExecutionState(ExecutionState.CANCELED,null);
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (this.allocatedResource == null) {
      final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.NO_INSTANCE);
      result.setDescription(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
      return result;
    }
    try {
      return this.allocatedResource.getInstance().cancelTask(this.vertexID);
    }
 catch (    IOException e) {
      final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.IPC_ERROR);
      result.setDescription(StringUtils.stringifyException(e));
      return result;
    }
  }
  return new TaskCancelResult(getID(),ReturnCode.SUCCESS);
}","/** 
 * Cancels and removes the task represented by this vertex from the instance it is currently running on. If the task is not currently running, its execution state is simply updated to <code>CANCELLED</code>.
 * @return the result of the task cancel attempt
 */
public TaskCancelResult cancelTask(){
  final ExecutionState previousState=this.executionState.get();
  if (previousState == ExecutionState.CANCELED) {
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (previousState == ExecutionState.FAILED) {
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (previousState == ExecutionState.FINISHED) {
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (updateExecutionState(ExecutionState.CANCELING) != ExecutionState.CANCELING) {
    if (this.groupVertex.getStageNumber() != this.executionGraph.getIndexOfCurrentExecutionStage()) {
      updateExecutionState(ExecutionState.CANCELED,null);
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState == ExecutionState.FINISHED || previousState == ExecutionState.FAILED) {
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (previousState != ExecutionState.RUNNING && previousState != ExecutionState.STARTING && previousState != ExecutionState.FINISHING && previousState != ExecutionState.REPLAYING) {
      updateExecutionState(ExecutionState.CANCELED,null);
      return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
    }
    if (this.allocatedResource == null) {
      final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.NO_INSTANCE);
      result.setDescription(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
      return result;
    }
    try {
      return this.allocatedResource.getInstance().cancelTask(this.vertexID);
    }
 catch (    IOException e) {
      final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.IPC_ERROR);
      result.setDescription(StringUtils.stringifyException(e));
      return result;
    }
  }
  return new TaskCancelResult(getID(),ReturnCode.SUCCESS);
}"
87717,"/** 
 * Updates the vertex's current execution state.
 * @param newExecutionState the new execution state
 * @param optionalMessage an optional message related to the state change
 */
public ExecutionState updateExecutionState(ExecutionState newExecutionState,final String optionalMessage){
  if (newExecutionState == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (this.executionState.get() == ExecutionState.CANCELING && newExecutionState == ExecutionState.FINISHED) {
    LOG.info(""String_Node_Str"" + toString() + ""String_Node_Str"");
    newExecutionState=ExecutionState.CANCELED;
  }
  final ExecutionState previousState=this.executionState.getAndSet(newExecutionState);
  if (previousState == newExecutionState) {
    return previousState;
  }
  ExecutionStateTransition.checkTransition(true,toString(),previousState,newExecutionState);
  final Iterator<ExecutionListener> it=this.executionListeners.values().iterator();
  while (it.hasNext()) {
    it.next().executionStateChanged(this.executionGraph.getJobID(),this.vertexID,newExecutionState,optionalMessage);
  }
  return previousState;
}","/** 
 * Updates the vertex's current execution state.
 * @param newExecutionState the new execution state
 * @param optionalMessage an optional message related to the state change
 */
public ExecutionState updateExecutionState(ExecutionState newExecutionState,final String optionalMessage){
  if (newExecutionState == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final ExecutionState currentExecutionState=this.executionState.get();
  if (currentExecutionState == ExecutionState.CANCELING) {
    if (newExecutionState == ExecutionState.FINISHING) {
      return currentExecutionState;
    }
    if (newExecutionState == ExecutionState.FINISHED) {
      LOG.info(""String_Node_Str"" + toString() + ""String_Node_Str"");
      newExecutionState=ExecutionState.CANCELED;
    }
  }
  final ExecutionState previousState=this.executionState.getAndSet(newExecutionState);
  if (previousState == newExecutionState) {
    return previousState;
  }
  ExecutionStateTransition.checkTransition(true,toString(),previousState,newExecutionState);
  final Iterator<ExecutionListener> it=this.executionListeners.values().iterator();
  while (it.hasNext()) {
    it.next().executionStateChanged(this.executionGraph.getJobID(),this.vertexID,newExecutionState,optionalMessage);
  }
  return previousState;
}"
87718,"/** 
 * Registers an newly incoming runtime task with the task manager.
 * @param id the ID of the task to register
 * @param jobConfiguration the job configuration that has been attached to the original job graph
 * @param environment the environment of the task to be registered
 * @param activeOutputChannels the set of initially active output channels
 * @return the task to be started or <code>null</code> if a task with the same ID was already running
 */
private Task createAndRegisterTask(final ExecutionVertexID id,final Configuration jobConfiguration,final RuntimeEnvironment environment,final Set<ChannelID> activeOutputChannels) throws IOException {
  if (id == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (environment == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Task task=null;
synchronized (this) {
    final Task runningTask=this.runningTasks.get(id);
    boolean registerTask=true;
    if (runningTask == null) {
      if (CheckpointUtils.hasCompleteCheckpointAvailable(id)) {
        task=new ReplayTask(id,environment,this);
      }
 else {
        task=new RuntimeTask(id,environment,this);
      }
    }
 else {
      if (runningTask instanceof RuntimeTask) {
        if (CheckpointUtils.hasPartialCheckpointAvailable(id)) {
          task=new ReplayTask((RuntimeTask)runningTask,this);
        }
 else {
          return null;
        }
      }
 else {
        registerTask=false;
      }
    }
    final Environment ee=task.getEnvironment();
    if (registerTask) {
      task.registerMemoryManager(this.memoryManager);
      task.registerIOManager(this.ioManager);
      task.registerInputSplitProvider(new TaskInputSplitProvider(ee.getJobID(),id,this.globalInputSplitProvider));
      this.byteBufferedChannelManager.register(task,activeOutputChannels);
      boolean enableProfiling=false;
      if (this.profiler != null && jobConfiguration.getBoolean(ProfilingUtils.PROFILE_JOB_KEY,true)) {
        enableProfiling=true;
      }
      if (enableProfiling) {
        task.registerProfiler(this.profiler,jobConfiguration);
      }
      if (!this.taskManagerPlugins.isEmpty()) {
        final Iterator<TaskManagerPlugin> it=this.taskManagerPlugins.values().iterator();
        while (it.hasNext()) {
          it.next().registerTask(id,jobConfiguration,ee);
        }
      }
      this.runningTasks.put(id,task);
    }
  }
  return task;
}","/** 
 * Registers an newly incoming runtime task with the task manager.
 * @param id the ID of the task to register
 * @param jobConfiguration the job configuration that has been attached to the original job graph
 * @param environment the environment of the task to be registered
 * @param activeOutputChannels the set of initially active output channels
 * @return the task to be started or <code>null</code> if a task with the same ID was already running
 */
private Task createAndRegisterTask(final ExecutionVertexID id,final Configuration jobConfiguration,final RuntimeEnvironment environment,final Set<ChannelID> activeOutputChannels) throws IOException {
  if (id == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (environment == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Task task=null;
synchronized (this) {
    final Task runningTask=this.runningTasks.get(id);
    boolean registerTask=true;
    if (runningTask == null) {
      if (CheckpointUtils.hasCompleteCheckpointAvailable(id)) {
        task=new ReplayTask(id,environment,this);
      }
 else {
        task=new RuntimeTask(id,environment,this);
      }
    }
 else {
      if (runningTask instanceof RuntimeTask) {
        if (CheckpointUtils.hasPartialCheckpointAvailable(id)) {
          task=new ReplayTask((RuntimeTask)runningTask,this);
        }
 else {
          return null;
        }
      }
 else {
        task=runningTask;
        registerTask=false;
      }
    }
    final Environment ee=task.getEnvironment();
    if (registerTask) {
      task.registerMemoryManager(this.memoryManager);
      task.registerIOManager(this.ioManager);
      task.registerInputSplitProvider(new TaskInputSplitProvider(ee.getJobID(),id,this.globalInputSplitProvider));
      this.byteBufferedChannelManager.register(task,activeOutputChannels);
      boolean enableProfiling=false;
      if (this.profiler != null && jobConfiguration.getBoolean(ProfilingUtils.PROFILE_JOB_KEY,true)) {
        enableProfiling=true;
      }
      if (enableProfiling) {
        task.registerProfiler(this.profiler,jobConfiguration);
      }
      if (!this.taskManagerPlugins.isEmpty()) {
        final Iterator<TaskManagerPlugin> it=this.taskManagerPlugins.values().iterator();
        while (it.hasNext()) {
          it.next().registerTask(id,jobConfiguration,ee);
        }
      }
      this.runningTasks.put(id,task);
    }
  }
  return task;
}"
87719,"public void executionStateChanged(final JobID jobID,final ExecutionVertexID id,final ExecutionState newExecutionState,final String optionalDescription){
  if (newExecutionState == ExecutionState.FINISHED || newExecutionState == ExecutionState.CANCELED || newExecutionState == ExecutionState.FAILED) {
    unregisterTask(id);
  }
synchronized (this.jobManager) {
    try {
      this.jobManager.updateTaskExecutionState(new TaskExecutionState(jobID,id,newExecutionState,optionalDescription));
    }
 catch (    IOException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}","public void executionStateChanged(final JobID jobID,final ExecutionVertexID id,final ExecutionState newExecutionState,final String optionalDescription){
  if (newExecutionState == ExecutionState.CANCELING) {
    return;
  }
  if (newExecutionState == ExecutionState.FINISHED || newExecutionState == ExecutionState.CANCELED || newExecutionState == ExecutionState.FAILED) {
    unregisterTask(id);
  }
synchronized (this.jobManager) {
    try {
      this.jobManager.updateTaskExecutionState(new TaskExecutionState(jobID,id,newExecutionState,optionalDescription));
    }
 catch (    IOException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}"
87720,"void restart(){
  changeExecutionState(ExecutionState.STARTING,null);
  this.restartRequested.set(true);
  interrupt();
}","void restart(){
  changeExecutionState(ExecutionState.STARTING,null);
  this.restartRequested.set(true);
  interrupt();
  this.interruptCalled.set(true);
}"
87721,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
  while (true) {
    changeExecutionState(ExecutionState.REPLAYING,null);
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
      return;
    }
    resetAllOutputBroker();
    try {
      replayCheckpoint();
      if (this.executionObserver.isCanceled()) {
        throw new InterruptedException();
      }
    }
 catch (    Exception e) {
      if (this.restartRequested.compareAndSet(true,false)) {
        while (!Thread.currentThread().isInterrupted()) {
        }
        Thread.interrupted();
        continue;
      }
      if (this.executionObserver.isCanceled()) {
        changeExecutionState(ExecutionState.CANCELED,null);
      }
 else {
        changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
      }
      return;
    }
    if (this.restartRequested.compareAndSet(true,false)) {
      while (!Thread.currentThread().isInterrupted()) {
      }
      Thread.interrupted();
      continue;
    }
    break;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    waitForAllOutputBrokerToFinish();
  }
 catch (  Exception e) {
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
  while (true) {
    changeExecutionState(ExecutionState.REPLAYING,null);
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
      return;
    }
    resetAllOutputBroker();
    try {
      replayCheckpoint();
      if (this.executionObserver.isCanceled()) {
        throw new InterruptedException();
      }
    }
 catch (    Exception e) {
      if (isRestartRequested()) {
        continue;
      }
      if (this.executionObserver.isCanceled()) {
        changeExecutionState(ExecutionState.CANCELED,null);
      }
 else {
        changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
      }
      return;
    }
    if (isRestartRequested()) {
      continue;
    }
    break;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    waitForAllOutputBrokerToFinish();
  }
 catch (  Exception e) {
    if (this.executionObserver.isCanceled()) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}"
87722,"private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID,!this.isCheckpointLocal);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  Buffer firstDeserializedFileBuffer=null;
  FileChannel fileChannel=null;
  try {
    while (true) {
      final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
      while (!fileSystem.exists(metaDataFile)) {
        final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
        if (fileSystem.exists(finalMetaDataFile)) {
          return;
        }
        if (this.isCheckpointComplete) {
          throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
        }
        Thread.sleep(1000);
      }
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputChannelBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              if (firstDeserializedFileBuffer == null) {
                firstDeserializedFileBuffer=srcBuffer.duplicate();
              }
              if (transferEnvelope.getSequenceNumber() < broker.getNextEnvelopeToSend()) {
                srcBuffer.recycleBuffer();
                continue;
              }
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
            if (this.restartRequested.get()) {
              return;
            }
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          fileChannel=null;
          ++metaDataIndex;
          break;
        }
      }
    }
  }
  finally {
    if (firstDeserializedFileBuffer != null) {
      firstDeserializedFileBuffer.recycleBuffer();
      firstDeserializedFileBuffer=null;
    }
    if (fileChannel != null) {
      fileChannel.close();
      fileChannel=null;
    }
  }
}","private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID,!this.isCheckpointLocal);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  Buffer firstDeserializedFileBuffer=null;
  FileChannel fileChannel=null;
  try {
    while (true) {
      final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
      while (!fileSystem.exists(metaDataFile)) {
        final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
        if (fileSystem.exists(finalMetaDataFile)) {
          return;
        }
        if (this.isCheckpointComplete) {
          throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
        }
        Thread.sleep(1000);
      }
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputChannelBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              if (firstDeserializedFileBuffer == null) {
                firstDeserializedFileBuffer=srcBuffer.duplicate();
              }
              if (transferEnvelope.getSequenceNumber() < broker.getNextEnvelopeToSend()) {
                srcBuffer.recycleBuffer();
                continue;
              }
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
            if (this.executionObserver.isCanceled()) {
              return;
            }
            if (this.restartRequested.get()) {
              return;
            }
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          fileChannel=null;
          ++metaDataIndex;
          break;
        }
      }
    }
  }
  finally {
    if (firstDeserializedFileBuffer != null) {
      firstDeserializedFileBuffer.recycleBuffer();
      firstDeserializedFileBuffer=null;
    }
    if (fileChannel != null) {
      fileChannel.close();
      fileChannel=null;
    }
  }
}"
87723,"private TransferEnvelopeReceiverList getReceiverList(final JobID jobID,final ChannelID sourceChannelID){
  TransferEnvelopeReceiverList receiverList=this.receiverCache.get(sourceChannelID);
  if (receiverList == null) {
    try {
      while (true) {
        ConnectionInfoLookupResponse lookupResponse;
synchronized (this.channelLookupService) {
          lookupResponse=this.channelLookupService.lookupConnectionInfo(this.localConnectionInfo,jobID,sourceChannelID);
        }
        if (lookupResponse.receiverNotFound()) {
          throw new IOException(""String_Node_Str"" + sourceChannelID);
        }
        if (lookupResponse.receiverNotReady()) {
          Thread.sleep(500);
          continue;
        }
        if (lookupResponse.receiverReady()) {
          receiverList=new TransferEnvelopeReceiverList(lookupResponse);
          break;
        }
      }
      if (receiverList != null) {
        this.receiverCache.put(sourceChannelID,receiverList);
        if (LOG.isDebugEnabled()) {
          final StringBuilder sb=new StringBuilder();
          sb.append(""String_Node_Str"" + sourceChannelID + ""String_Node_Str""+ this.localConnectionInfo+ ""String_Node_Str"");
          if (receiverList.hasLocalReceivers()) {
            sb.append(""String_Node_Str"");
            final Iterator<ChannelID> it=receiverList.getLocalReceivers().iterator();
            while (it.hasNext()) {
              sb.append(""String_Node_Str"" + it.next() + ""String_Node_Str"");
            }
          }
          if (receiverList.hasRemoteReceivers()) {
            sb.append(""String_Node_Str"");
            final Iterator<InetSocketAddress> it=receiverList.getRemoteReceivers().iterator();
            while (it.hasNext()) {
              sb.append(""String_Node_Str"" + it.next() + ""String_Node_Str"");
            }
          }
          LOG.debug(sb.toString());
        }
      }
    }
 catch (    InterruptedException ie) {
    }
catch (    IOException ioe) {
    }
  }
  return receiverList;
}","/** 
 * Returns the list of receivers for transfer envelopes produced by the channel with the given source channel ID.
 * @param jobID the ID of the job the given channel ID belongs to
 * @param sourceChannelID the source channel ID for which the receiver list shall be retrieved
 * @return the list of receivers or <code>null</code> if the list of receivers could not be retrieved or therequesting thread has been interrupted
 */
private TransferEnvelopeReceiverList getReceiverList(final JobID jobID,final ChannelID sourceChannelID){
  TransferEnvelopeReceiverList receiverList=this.receiverCache.get(sourceChannelID);
  if (receiverList == null) {
    try {
      while (true) {
        if (Thread.currentThread().isInterrupted()) {
          break;
        }
        ConnectionInfoLookupResponse lookupResponse;
synchronized (this.channelLookupService) {
          lookupResponse=this.channelLookupService.lookupConnectionInfo(this.localConnectionInfo,jobID,sourceChannelID);
        }
        if (lookupResponse.receiverNotFound()) {
          LOG.error(""String_Node_Str"" + sourceChannelID);
          break;
        }
        if (lookupResponse.receiverNotReady()) {
          Thread.sleep(500);
          continue;
        }
        if (lookupResponse.receiverReady()) {
          receiverList=new TransferEnvelopeReceiverList(lookupResponse);
          break;
        }
      }
    }
 catch (    Exception e) {
    }
  }
  if (receiverList != null) {
    this.receiverCache.put(sourceChannelID,receiverList);
    if (LOG.isDebugEnabled()) {
      final StringBuilder sb=new StringBuilder();
      sb.append(""String_Node_Str"" + sourceChannelID + ""String_Node_Str""+ this.localConnectionInfo+ ""String_Node_Str"");
      if (receiverList.hasLocalReceivers()) {
        sb.append(""String_Node_Str"");
        final Iterator<ChannelID> it=receiverList.getLocalReceivers().iterator();
        while (it.hasNext()) {
          sb.append(""String_Node_Str"" + it.next() + ""String_Node_Str"");
        }
      }
      if (receiverList.hasRemoteReceivers()) {
        sb.append(""String_Node_Str"");
        final Iterator<InetSocketAddress> it=receiverList.getRemoteReceivers().iterator();
        while (it.hasNext()) {
          sb.append(""String_Node_Str"" + it.next() + ""String_Node_Str"");
        }
      }
      LOG.debug(sb.toString());
    }
  }
  return receiverList;
}"
87724,"/** 
 * Sets up Nephele in local mode.
 */
@BeforeClass public static void startNephele(){
  if (jobManagerThread == null) {
    JobManager jobManager=null;
    try {
      Constructor<JobManager> c=JobManager.class.getDeclaredConstructor(new Class[]{String.class,String.class});
      c.setAccessible(true);
      jobManager=c.newInstance(new Object[]{ServerTestUtils.getConfigDir(),new String(""String_Node_Str"")});
    }
 catch (    SecurityException e) {
      fail(e.getMessage());
    }
catch (    NoSuchMethodException e) {
      fail(e.getMessage());
    }
catch (    IllegalArgumentException e) {
      fail(e.getMessage());
    }
catch (    InstantiationException e) {
      fail(e.getMessage());
    }
catch (    IllegalAccessException e) {
      fail(e.getMessage());
    }
catch (    InvocationTargetException e) {
      fail(e.getMessage());
    }
    configuration=GlobalConfiguration.getConfiguration(new String[]{ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY});
    if (jobManager != null) {
      jobManagerThread=new JobManagerThread(jobManager);
      jobManagerThread.start();
    }
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}","/** 
 * Sets up Nephele in local mode.
 */
@BeforeClass public static void startNephele(){
  if (jobManagerThread == null) {
    JobManager jobManager=null;
    try {
      Constructor<JobManager> c=JobManager.class.getDeclaredConstructor(new Class[]{String.class,String.class});
      c.setAccessible(true);
      jobManager=c.newInstance(new Object[]{ServerTestUtils.getConfigDir(),new String(""String_Node_Str"")});
    }
 catch (    SecurityException e) {
      fail(e.getMessage());
    }
catch (    NoSuchMethodException e) {
      fail(e.getMessage());
    }
catch (    IllegalArgumentException e) {
      fail(e.getMessage());
    }
catch (    InstantiationException e) {
      fail(e.getMessage());
    }
catch (    IllegalAccessException e) {
      fail(e.getMessage());
    }
catch (    InvocationTargetException e) {
      fail(e.getMessage());
    }
    configuration=GlobalConfiguration.getConfiguration(new String[]{ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY});
    if (jobManager != null) {
      jobManagerThread=new JobManagerThread(jobManager);
      jobManagerThread.start();
    }
    try {
      Thread.sleep(10000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}"
87725,"/** 
 * Cancels or kills the task.
 * @param cancel <code>true/code> if the task shall be cancelled, <code>false</code> if it shall be killed
 */
private void cancelOrKillExecution(final boolean cancel){
  final Thread replayThread=this.environment.getExecutingThread();
  Thread encapsulatedThread=null;
  if (this.encapsulatedTask != null) {
    encapsulatedThread=this.encapsulatedTask.getRuntimeEnvironment().getExecutingThread();
  }
  if (replayThread == null && encapsulatedThread == null) {
    return;
  }
  if (cancel) {
    this.isCanceled=true;
    this.replayTaskExecutionState=ExecutionState.CANCELING;
    if (this.encapsulatedExecutionState != null) {
      this.encapsulatedExecutionState=ExecutionState.CANCELING;
    }
    reportExecutionStateChange(true,null);
  }
  if (this.encapsulatedTask != null) {
    try {
      final AbstractInvokable invokable=this.encapsulatedTask.getRuntimeEnvironment().getInvokable();
      if (invokable != null) {
        invokable.cancel();
      }
    }
 catch (    Throwable e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
  while (true) {
    replayThread.interrupt();
    if (encapsulatedThread != null) {
      encapsulatedThread.interrupt();
    }
    if (cancel) {
      if (this.overallExecutionState.get() == ExecutionState.CANCELED) {
        break;
      }
    }
 else {
      if (this.overallExecutionState.get() == ExecutionState.FAILED) {
        break;
      }
    }
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      break;
    }
  }
}","/** 
 * Cancels or kills the task.
 * @param cancel <code>true/code> if the task shall be cancelled, <code>false</code> if it shall be killed
 */
private void cancelOrKillExecution(final boolean cancel){
  final Thread replayThread=this.environment.getExecutingThread();
  Thread encapsulatedThread=null;
  if (this.encapsulatedTask != null) {
    encapsulatedThread=this.encapsulatedTask.getRuntimeEnvironment().getExecutingThread();
  }
  if (replayThread == null && encapsulatedThread == null) {
    return;
  }
  if (cancel) {
    this.isCanceled=true;
    this.replayTaskExecutionState=ExecutionState.CANCELING;
    if (this.encapsulatedExecutionState != null) {
      this.encapsulatedExecutionState=ExecutionState.CANCELING;
    }
    reportExecutionStateChange(true,null);
    if (this.encapsulatedTask != null) {
      try {
        final AbstractInvokable invokable=this.encapsulatedTask.getRuntimeEnvironment().getInvokable();
        if (invokable != null) {
          invokable.cancel();
        }
      }
 catch (      Throwable e) {
        LOG.error(StringUtils.stringifyException(e));
      }
    }
  }
  while (true) {
    replayThread.interrupt();
    if (encapsulatedThread != null) {
      encapsulatedThread.interrupt();
    }
    if (cancel) {
      if (this.overallExecutionState.get() == ExecutionState.CANCELED) {
        break;
      }
    }
 else {
      if (this.overallExecutionState.get() == ExecutionState.FAILED) {
        break;
      }
    }
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      break;
    }
  }
}"
87726,"/** 
 * Cancels or kills the task.
 * @param cancel <code>true/code> if the task shall be canceled, <code>false</code> if it shall be killed
 */
private void cancelOrKillExecution(final boolean cancel){
  final Thread executingThread=this.environment.getExecutingThread();
  if (executingThread == null) {
    return;
  }
  if (this.executionState != ExecutionState.RUNNING && this.executionState != ExecutionState.REPLAYING && this.executionState != ExecutionState.FINISHING) {
    return;
  }
  LOG.info((cancel ? ""String_Node_Str"" : ""String_Node_Str"") + this.environment.getTaskNameWithIndex());
  if (cancel) {
    this.isCanceled=true;
    executionStateChanged(ExecutionState.CANCELING,null);
  }
  try {
    final AbstractInvokable invokable=this.environment.getInvokable();
    if (invokable != null) {
      invokable.cancel();
    }
  }
 catch (  Throwable e) {
    LOG.error(StringUtils.stringifyException(e));
  }
  while (true) {
    executingThread.interrupt();
    if (!executingThread.isAlive()) {
      break;
    }
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      break;
    }
    LOG.info((cancel == true ? ""String_Node_Str"" : ""String_Node_Str"") + this.environment.getTaskName() + ""String_Node_Str""+ this.executionState);
  }
}","/** 
 * Cancels or kills the task.
 * @param cancel <code>true/code> if the task shall be canceled, <code>false</code> if it shall be killed
 */
private void cancelOrKillExecution(final boolean cancel){
  final Thread executingThread=this.environment.getExecutingThread();
  if (executingThread == null) {
    return;
  }
  if (this.executionState != ExecutionState.RUNNING && this.executionState != ExecutionState.REPLAYING && this.executionState != ExecutionState.FINISHING) {
    return;
  }
  LOG.info((cancel ? ""String_Node_Str"" : ""String_Node_Str"") + this.environment.getTaskNameWithIndex());
  if (cancel) {
    this.isCanceled=true;
    executionStateChanged(ExecutionState.CANCELING,null);
    try {
      final AbstractInvokable invokable=this.environment.getInvokable();
      if (invokable != null) {
        invokable.cancel();
      }
    }
 catch (    Throwable e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
  while (true) {
    executingThread.interrupt();
    if (!executingThread.isAlive()) {
      break;
    }
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      break;
    }
    LOG.info((cancel == true ? ""String_Node_Str"" : ""String_Node_Str"") + this.environment.getTaskName() + ""String_Node_Str""+ this.executionState);
  }
}"
87727,"/** 
 * Constructs a new ephemeral checkpoint.
 * @param task the task this checkpoint belongs to
 * @param ephemeral <code>true</code> if the checkpoint is initially ephemeral, <code>false</code> if the checkpoint shall be persistent from the beginning
 */
public EphemeralCheckpoint(final RuntimeTask task,final boolean ephemeral){
  this.task=task;
  int nooc=0;
  final RuntimeEnvironment environment=task.getRuntimeEnvironment();
  for (int i=0; i < environment.getNumberOfOutputGates(); ++i) {
    nooc+=environment.getOutputGate(i).getNumberOfOutputChannels();
  }
  this.numberOfConnectedChannels=nooc;
  this.checkpointingDecision=(ephemeral ? CheckpointingDecisionState.UNDECIDED : CheckpointingDecisionState.CHECKPOINTING);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + task.getVertexID() + ""String_Node_Str""+ this.checkpointingDecision);
  }
  if (this.checkpointingDecision == CheckpointingDecisionState.CHECKPOINTING) {
    this.task.checkpointStateChanged(CheckpointState.PARTIAL);
    this.writeThread=new WriteThread(FileBufferManager.getInstance(),this.task.getVertexID(),this.numberOfConnectedChannels);
  }
}","/** 
 * Constructs a new ephemeral checkpoint.
 * @param task the task this checkpoint belongs to
 * @param ephemeral <code>true</code> if the checkpoint is initially ephemeral, <code>false</code> if the checkpoint shall be persistent from the beginning
 */
public EphemeralCheckpoint(final RuntimeTask task,final boolean ephemeral){
  this.task=task;
  int nooc=0;
  final RuntimeEnvironment environment=task.getRuntimeEnvironment();
  for (int i=0; i < environment.getNumberOfOutputGates(); ++i) {
    nooc+=environment.getOutputGate(i).getNumberOfOutputChannels();
  }
  this.numberOfConnectedChannels=nooc;
  this.checkpointingDecision=(ephemeral ? CheckpointingDecisionState.UNDECIDED : CheckpointingDecisionState.CHECKPOINTING);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + task.getVertexID() + ""String_Node_Str""+ this.checkpointingDecision);
  }
  if (this.checkpointingDecision == CheckpointingDecisionState.CHECKPOINTING) {
    this.task.checkpointStateChanged(CheckpointState.PARTIAL);
    this.writeThread=new WriteThread(FileBufferManager.getInstance(),this.task.getVertexID(),this.numberOfConnectedChannels);
    this.writeThread.start();
  }
}"
87728,"public EphemeralCheckpointForwarder(final EphemeralCheckpoint ephemeralCheckpoint,final AbstractOutputChannelForwarder next){
  super(next);
  if (next == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.ephemeralCheckpoint=ephemeralCheckpoint;
}","public EphemeralCheckpointForwarder(final EphemeralCheckpoint ephemeralCheckpoint,final AbstractOutputChannelForwarder next){
  super(next);
  this.ephemeralCheckpoint=ephemeralCheckpoint;
}"
87729,"/** 
 * {@inheritDoc}
 */
@Override public boolean hasDataLeft() throws IOException, InterruptedException {
  if (this.ephemeralCheckpoint.hasDataLeft()) {
    return true;
  }
  return getNext().hasDataLeft();
}","/** 
 * {@inheritDoc}
 */
@Override public boolean hasDataLeft() throws IOException, InterruptedException {
  if (this.ephemeralCheckpoint.hasDataLeft()) {
    return true;
  }
  final AbstractOutputChannelForwarder next=getNext();
  if (next != null) {
    return getNext().hasDataLeft();
  }
  return false;
}"
87730,"/** 
 * {@inheritDoc}
 */
@Override public void push(final TransferEnvelope transferEnvelope) throws IOException, InterruptedException {
  this.ephemeralCheckpoint.forward(transferEnvelope);
  getNext().push(transferEnvelope);
}","/** 
 * {@inheritDoc}
 */
@Override public void push(final TransferEnvelope transferEnvelope) throws IOException, InterruptedException {
  this.ephemeralCheckpoint.forward(transferEnvelope);
  final AbstractOutputChannelForwarder next=getNext();
  if (next != null) {
    next.push(transferEnvelope);
  }
 else {
    recycleTransferEnvelope(transferEnvelope);
  }
}"
87731,"/** 
 * Constructs a new replay input channel context.
 * @param encapsulatedContext the encapsulated input channel context
 */
ReplayInputChannelContext(final InputChannelContext encapsulatedContext){
  this.encapsulatedContext=encapsulatedContext;
}","/** 
 * Constructs a new replay input channel context.
 * @param channelID the ID of the input channel this context belongs to
 * @param encapsulatedContext the encapsulated input channel context
 */
ReplayInputChannelContext(final ChannelID channelID,final InputChannelContext encapsulatedContext){
  this.channelID=channelID;
  this.encapsulatedContext=encapsulatedContext;
}"
87732,"/** 
 * {@inheritDoc}
 */
@Override public ChannelID getChannelID(){
  return this.encapsulatedContext.getChannelID();
}","/** 
 * {@inheritDoc}
 */
@Override public ChannelID getChannelID(){
  return this.channelID;
}"
87733,"/** 
 * {@inheritDoc}
 */
@Override public void destroy(){
  this.encapsulatedContext.destroy();
}","/** 
 * {@inheritDoc}
 */
@Override public void destroy(){
  if (this.encapsulatedContext != null) {
    this.encapsulatedContext.destroy();
  }
}"
87734,"/** 
 * {@inheritDoc}
 */
@Override public InputChannelContext createInputChannelContext(ChannelID channelID,InputChannelContext previousContext){
  return new ReplayInputChannelContext(previousContext);
}","/** 
 * {@inheritDoc}
 */
@Override public InputChannelContext createInputChannelContext(final ChannelID channelID,final InputChannelContext previousContext){
  return new ReplayInputChannelContext(channelID,previousContext);
}"
87735,"private static ExecutionState determineOverallExecutionState(final ExecutionState unchangedExecutionState,final ExecutionState changedExecutionState){
  if (changedExecutionState == null) {
    return changedExecutionState;
  }
  if (changedExecutionState == ExecutionState.REPLAYING) {
    if (unchangedExecutionState == ExecutionState.RUNNING || unchangedExecutionState == ExecutionState.FINISHING) {
      return ExecutionState.REPLAYING;
    }
 else {
      return unchangedExecutionState;
    }
  }
  if (changedExecutionState == ExecutionState.CANCELING) {
    return ExecutionState.CANCELING;
  }
  if (changedExecutionState == ExecutionState.CANCELED && unchangedExecutionState == ExecutionState.CANCELED) {
    return ExecutionState.CANCELED;
  }
  if (changedExecutionState == ExecutionState.FINISHING && (unchangedExecutionState == ExecutionState.FINISHING || unchangedExecutionState == ExecutionState.FINISHED)) {
    return ExecutionState.FINISHING;
  }
  if (changedExecutionState == ExecutionState.FINISHED && unchangedExecutionState == ExecutionState.FINISHED) {
    return ExecutionState.FINISHED;
  }
  if (changedExecutionState == ExecutionState.FAILED && unchangedExecutionState == ExecutionState.FAILED) {
    return ExecutionState.FAILED;
  }
  return null;
}","private static ExecutionState determineOverallExecutionState(final ExecutionState unchangedExecutionState,final ExecutionState changedExecutionState){
  if (unchangedExecutionState == null) {
    return changedExecutionState;
  }
  if (changedExecutionState == ExecutionState.REPLAYING) {
    if (unchangedExecutionState == ExecutionState.RUNNING || unchangedExecutionState == ExecutionState.FINISHING) {
      return ExecutionState.REPLAYING;
    }
 else {
      return unchangedExecutionState;
    }
  }
  if (changedExecutionState == ExecutionState.CANCELING) {
    return ExecutionState.CANCELING;
  }
  if (changedExecutionState == ExecutionState.CANCELED && unchangedExecutionState == ExecutionState.CANCELED) {
    return ExecutionState.CANCELED;
  }
  if (changedExecutionState == ExecutionState.FINISHING && (unchangedExecutionState == ExecutionState.FINISHING || unchangedExecutionState == ExecutionState.FINISHED)) {
    return ExecutionState.FINISHING;
  }
  if (changedExecutionState == ExecutionState.FINISHED && unchangedExecutionState == ExecutionState.FINISHED) {
    return ExecutionState.FINISHED;
  }
  if (changedExecutionState == ExecutionState.FAILED && unchangedExecutionState == ExecutionState.FAILED) {
    return ExecutionState.FAILED;
  }
  return null;
}"
87736,"protected void replayCheckpointsFromPreviousStage(final ExecutionGraph executionGraph){
  final int currentStageIndex=executionGraph.getIndexOfCurrentExecutionStage();
  final ExecutionStage previousStage=executionGraph.getStage(currentStageIndex - 1);
  for (int i=0; i < previousStage.getNumberOfOutputExecutionVertices(); ++i) {
    final ExecutionVertex vertex=previousStage.getOutputExecutionVertex(i);
    vertex.updateExecutionState(ExecutionState.ASSIGNED);
  }
  deployAssignedInputVertices(executionGraph);
}","protected void replayCheckpointsFromPreviousStage(final ExecutionGraph executionGraph){
  final int currentStageIndex=executionGraph.getIndexOfCurrentExecutionStage();
  final ExecutionStage previousStage=executionGraph.getStage(currentStageIndex - 1);
  final List<ExecutionVertex> verticesToBeReplayed=new ArrayList<ExecutionVertex>();
  for (int i=0; i < previousStage.getNumberOfOutputExecutionVertices(); ++i) {
    final ExecutionVertex vertex=previousStage.getOutputExecutionVertex(i);
    vertex.updateExecutionState(ExecutionState.ASSIGNED);
    verticesToBeReplayed.add(vertex);
  }
  deployAssignedVertices(verticesToBeReplayed);
}"
87737,"/** 
 * Registers the given task with the byte buffered channel manager.
 * @param task the task to be registered
 * @param the set of output channels which are initially active
 */
public void register(final Task task,final Set<ChannelID> activeOutputChannels){
  final Environment environment=task.getEnvironment();
  final TaskContext taskContext=task.createTaskContext(this,this.localBufferPoolOwner.remove(task.getVertexID()));
  final Set<GateID> outputGateIDs=environment.getOutputGateIDs();
  for (final Iterator<GateID> gateIt=outputGateIDs.iterator(); gateIt.hasNext(); ) {
    final GateID gateID=gateIt.next();
    final OutputGateContext outputGateContext=taskContext.createOutputGateContext(gateID);
    final Set<ChannelID> outputChannelIDs=environment.getOutputChannelIDsOfGate(gateID);
    for (final Iterator<ChannelID> channelIt=outputChannelIDs.iterator(); channelIt.hasNext(); ) {
      final ChannelID channelID=channelIt.next();
      final OutputChannelContext previousContext=(OutputChannelContext)this.registeredChannels.get(channelID);
      final boolean isActive=activeOutputChannels.contains(channelID);
      final OutputChannelContext outputChannelContext=outputGateContext.createOutputChannelContext(channelID,previousContext,isActive,this.mergeSpilledBuffers);
      if (outputChannelContext.getType() == ChannelType.INMEMORY) {
        addReceiverListHint(outputChannelContext);
      }
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + outputChannelContext.getChannelID() + ""String_Node_Str""+ (isActive ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      this.registeredChannels.put(outputChannelContext.getChannelID(),outputChannelContext);
    }
  }
  final Set<GateID> inputGateIDs=environment.getInputGateIDs();
  for (final Iterator<GateID> gateIt=inputGateIDs.iterator(); gateIt.hasNext(); ) {
    final GateID gateID=gateIt.next();
    final InputGateContext inputGateContext=taskContext.createInputGateContext(gateID);
    final Set<ChannelID> inputChannelIDs=environment.getInputChannelIDsOfGate(gateID);
    for (final Iterator<ChannelID> channelIt=inputChannelIDs.iterator(); channelIt.hasNext(); ) {
      final ChannelID channelID=channelIt.next();
      final InputChannelContext previousContext=(InputChannelContext)this.registeredChannels.get(channelID);
      final InputChannelContext inputChannelContext=inputGateContext.createInputChannelContext(channelID,previousContext);
      if (inputChannelContext.getType() == ChannelType.INMEMORY) {
        addReceiverListHint(inputChannelContext);
      }
      final boolean isActive=activeOutputChannels.contains(inputChannelContext.getChannelID());
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + inputChannelContext.getChannelID() + ""String_Node_Str""+ (isActive ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      this.registeredChannels.put(inputChannelContext.getChannelID(),inputChannelContext);
    }
    final LocalBufferPoolOwner bufferPoolOwner=inputGateContext.getLocalBufferPoolOwner();
    if (bufferPoolOwner != null) {
      this.localBufferPoolOwner.put(inputGateContext.getGateID(),bufferPoolOwner);
    }
  }
  this.localBufferPoolOwner.put(task.getVertexID(),taskContext);
  redistributeGlobalBuffers();
}","/** 
 * Registers the given task with the byte buffered channel manager.
 * @param task the task to be registered
 * @param the set of output channels which are initially active
 */
public void register(final Task task,final Set<ChannelID> activeOutputChannels){
  final Environment environment=task.getEnvironment();
  final TaskContext taskContext=task.createTaskContext(this,this.localBufferPoolOwner.remove(task.getVertexID()));
  final Set<GateID> outputGateIDs=environment.getOutputGateIDs();
  for (final Iterator<GateID> gateIt=outputGateIDs.iterator(); gateIt.hasNext(); ) {
    final GateID gateID=gateIt.next();
    final OutputGateContext outputGateContext=taskContext.createOutputGateContext(gateID);
    final Set<ChannelID> outputChannelIDs=environment.getOutputChannelIDsOfGate(gateID);
    for (final Iterator<ChannelID> channelIt=outputChannelIDs.iterator(); channelIt.hasNext(); ) {
      final ChannelID channelID=channelIt.next();
      final OutputChannelContext previousContext=(OutputChannelContext)this.registeredChannels.get(channelID);
      final boolean isActive=activeOutputChannels.contains(channelID);
      final OutputChannelContext outputChannelContext=outputGateContext.createOutputChannelContext(channelID,previousContext,isActive,this.mergeSpilledBuffers);
      if (outputChannelContext.getType() == ChannelType.INMEMORY) {
        addReceiverListHint(outputChannelContext);
      }
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + outputChannelContext.getChannelID() + ""String_Node_Str""+ (isActive ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      this.registeredChannels.put(outputChannelContext.getChannelID(),outputChannelContext);
    }
  }
  final Set<GateID> inputGateIDs=environment.getInputGateIDs();
  for (final Iterator<GateID> gateIt=inputGateIDs.iterator(); gateIt.hasNext(); ) {
    final GateID gateID=gateIt.next();
    final InputGateContext inputGateContext=taskContext.createInputGateContext(gateID);
    final Set<ChannelID> inputChannelIDs=environment.getInputChannelIDsOfGate(gateID);
    for (final Iterator<ChannelID> channelIt=inputChannelIDs.iterator(); channelIt.hasNext(); ) {
      final ChannelID channelID=channelIt.next();
      final InputChannelContext previousContext=(InputChannelContext)this.registeredChannels.get(channelID);
      final InputChannelContext inputChannelContext=inputGateContext.createInputChannelContext(channelID,previousContext);
      if (inputChannelContext.getType() == ChannelType.INMEMORY) {
        addReceiverListHint(inputChannelContext);
      }
      this.registeredChannels.put(inputChannelContext.getChannelID(),inputChannelContext);
    }
    final LocalBufferPoolOwner bufferPoolOwner=inputGateContext.getLocalBufferPoolOwner();
    if (bufferPoolOwner != null) {
      this.localBufferPoolOwner.put(inputGateContext.getGateID(),bufferPoolOwner);
    }
  }
  this.localBufferPoolOwner.put(task.getVertexID(),taskContext);
  redistributeGlobalBuffers();
}"
87738,"/** 
 * {@inheritDoc}
 */
@Override public boolean hasDataLeft() throws IOException, InterruptedException {
  if (this.closeAcknowledgementReceived) {
    return getNext().hasDataLeft();
  }
  if ((this.lastSequenceNumberWithReceiverNotFound + 1) == this.sequenceNumber) {
    return getNext().hasDataLeft();
  }
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean hasDataLeft() throws IOException, InterruptedException {
  if (this.byteBufferedOutputChannel.getType() == ChannelType.FILE) {
    return getNext().hasDataLeft();
  }
  if (this.closeAcknowledgmentReceived) {
    return getNext().hasDataLeft();
  }
  if ((this.lastSequenceNumberWithReceiverNotFound + 1) == this.sequenceNumber) {
    return getNext().hasDataLeft();
  }
  return true;
}"
87739,"/** 
 * {@inheritDoc}
 */
@Override public void processEvent(final AbstractEvent event){
  if (event instanceof ByteBufferedChannelCloseEvent) {
    this.closeAcknowledgementReceived=true;
  }
 else   if (event instanceof ReceiverNotFoundEvent) {
    this.lastSequenceNumberWithReceiverNotFound=((ReceiverNotFoundEvent)event).getSequenceNumber();
  }
 else   if (event instanceof AbstractTaskEvent) {
    this.byteBufferedOutputChannel.processEvent(event);
  }
  getNext().processEvent(event);
}","/** 
 * {@inheritDoc}
 */
@Override public void processEvent(final AbstractEvent event){
  if (event instanceof ByteBufferedChannelCloseEvent) {
    this.closeAcknowledgmentReceived=true;
  }
 else   if (event instanceof ReceiverNotFoundEvent) {
    this.lastSequenceNumberWithReceiverNotFound=((ReceiverNotFoundEvent)event).getSequenceNumber();
  }
 else   if (event instanceof AbstractTaskEvent) {
    this.byteBufferedOutputChannel.processEvent(event);
  }
  getNext().processEvent(event);
}"
87740,"/** 
 * {@inheritDoc}
 */
@Override public OutputChannelContext createOutputChannelContext(ChannelID channelID,OutputChannelContext previousContext,boolean isReceiverRunning,boolean mergeSpillBuffers){
  if (previousContext != null) {
    throw new IllegalStateException(""String_Node_Str"" + channelID);
  }
  AbstractOutputChannel<? extends Record> channel=null;
  for (int i=0; i < this.outputGate.getNumberOfOutputChannels(); ++i) {
    AbstractOutputChannel<? extends Record> candidateChannel=this.outputGate.getOutputChannel(i);
    if (candidateChannel.getID().equals(channelID)) {
      channel=candidateChannel;
      break;
    }
  }
  if (channel == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + channelID);
  }
  if (!(channel instanceof AbstractByteBufferedOutputChannel)) {
    throw new IllegalStateException(""String_Node_Str"" + channelID + ""String_Node_Str"");
  }
  AbstractByteBufferedOutputChannel<? extends Record> outputChannel=(AbstractByteBufferedOutputChannel<? extends Record>)channel;
  final RuntimeDispatcher runtimeDispatcher=new RuntimeDispatcher(this.taskContext.getTransferEnvelopeDispatcher());
  final SpillingBarrier spillingBarrier=new SpillingBarrier(isReceiverRunning,mergeSpillBuffers,runtimeDispatcher);
  final ForwardingBarrier forwardingBarrier=new ForwardingBarrier(channelID,spillingBarrier);
  final EphemeralCheckpoint checkpoint=this.taskContext.getEphemeralCheckpoint();
  RuntimeOutputChannelBroker outputChannelBroker;
  if (checkpoint != null) {
    final EphemeralCheckpointForwarder checkpointForwarder=new EphemeralCheckpointForwarder(checkpoint,forwardingBarrier);
    outputChannelBroker=new RuntimeOutputChannelBroker(this,outputChannel,checkpointForwarder);
  }
 else {
    outputChannelBroker=new RuntimeOutputChannelBroker(this,outputChannel,forwardingBarrier);
  }
  final OutputChannelForwardingChain forwardingChain=new OutputChannelForwardingChain(outputChannelBroker,runtimeDispatcher);
  outputChannelBroker.setForwardingChain(forwardingChain);
  return new RuntimeOutputChannelContext(outputChannel,forwardingChain);
}","/** 
 * {@inheritDoc}
 */
@Override public OutputChannelContext createOutputChannelContext(ChannelID channelID,OutputChannelContext previousContext,boolean isReceiverRunning,boolean mergeSpillBuffers){
  if (previousContext != null) {
    throw new IllegalStateException(""String_Node_Str"" + channelID);
  }
  AbstractOutputChannel<? extends Record> channel=null;
  for (int i=0; i < this.outputGate.getNumberOfOutputChannels(); ++i) {
    AbstractOutputChannel<? extends Record> candidateChannel=this.outputGate.getOutputChannel(i);
    if (candidateChannel.getID().equals(channelID)) {
      channel=candidateChannel;
      break;
    }
  }
  if (channel == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + channelID);
  }
  if (!(channel instanceof AbstractByteBufferedOutputChannel)) {
    throw new IllegalStateException(""String_Node_Str"" + channelID + ""String_Node_Str"");
  }
  final AbstractByteBufferedOutputChannel<? extends Record> outputChannel=(AbstractByteBufferedOutputChannel<? extends Record>)channel;
  RuntimeOutputChannelBroker outputChannelBroker;
  AbstractOutputChannelForwarder last;
  if (outputChannel.getType() == ChannelType.FILE) {
    final EphemeralCheckpoint checkpoint=this.taskContext.getEphemeralCheckpoint();
    if (checkpoint == null) {
      throw new IllegalStateException(""String_Node_Str"" + outputChannel.getID());
    }
    final EphemeralCheckpointForwarder checkpointForwarder=new EphemeralCheckpointForwarder(checkpoint,null);
    outputChannelBroker=new RuntimeOutputChannelBroker(this,outputChannel,checkpointForwarder);
    last=checkpointForwarder;
  }
 else {
    final RuntimeDispatcher runtimeDispatcher=new RuntimeDispatcher(this.taskContext.getTransferEnvelopeDispatcher());
    final SpillingBarrier spillingBarrier=new SpillingBarrier(isReceiverRunning,mergeSpillBuffers,runtimeDispatcher);
    final ForwardingBarrier forwardingBarrier=new ForwardingBarrier(channelID,spillingBarrier);
    final EphemeralCheckpoint checkpoint=this.taskContext.getEphemeralCheckpoint();
    if (checkpoint != null) {
      final EphemeralCheckpointForwarder checkpointForwarder=new EphemeralCheckpointForwarder(checkpoint,forwardingBarrier);
      outputChannelBroker=new RuntimeOutputChannelBroker(this,outputChannel,checkpointForwarder);
    }
 else {
      outputChannelBroker=new RuntimeOutputChannelBroker(this,outputChannel,forwardingBarrier);
    }
    last=runtimeDispatcher;
  }
  final OutputChannelForwardingChain forwardingChain=new OutputChannelForwardingChain(outputChannelBroker,last);
  outputChannelBroker.setForwardingChain(forwardingChain);
  return new RuntimeOutputChannelContext(outputChannel,forwardingChain);
}"
87741,"/** 
 * Sets up Nephele in local mode.
 */
@BeforeClass public static void startNephele(){
  if (jobManagerThread == null) {
    JobManager jobManager=null;
    try {
      Constructor<JobManager> c=JobManager.class.getDeclaredConstructor(new Class[]{String.class,String.class});
      c.setAccessible(true);
      jobManager=c.newInstance(new Object[]{new String(System.getProperty(""String_Node_Str"") + ""String_Node_Str""),new String(""String_Node_Str"")});
    }
 catch (    SecurityException e) {
      fail(e.getMessage());
    }
catch (    NoSuchMethodException e) {
      fail(e.getMessage());
    }
catch (    IllegalArgumentException e) {
      fail(e.getMessage());
    }
catch (    InstantiationException e) {
      fail(e.getMessage());
    }
catch (    IllegalAccessException e) {
      fail(e.getMessage());
    }
catch (    InvocationTargetException e) {
      fail(e.getMessage());
    }
    configuration=GlobalConfiguration.getConfiguration(new String[]{ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY});
    if (jobManager != null) {
      jobManagerThread=new JobManagerThread(jobManager);
      jobManagerThread.start();
    }
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}","/** 
 * Sets up Nephele in local mode.
 */
@BeforeClass public static void startNephele(){
  if (jobManagerThread == null) {
    JobManager jobManager=null;
    try {
      Constructor<JobManager> c=JobManager.class.getDeclaredConstructor(new Class[]{String.class,String.class});
      c.setAccessible(true);
      jobManager=c.newInstance(new Object[]{ServerTestUtils.getConfigDir(),new String(""String_Node_Str"")});
    }
 catch (    SecurityException e) {
      fail(e.getMessage());
    }
catch (    NoSuchMethodException e) {
      fail(e.getMessage());
    }
catch (    IllegalArgumentException e) {
      fail(e.getMessage());
    }
catch (    InstantiationException e) {
      fail(e.getMessage());
    }
catch (    IllegalAccessException e) {
      fail(e.getMessage());
    }
catch (    InvocationTargetException e) {
      fail(e.getMessage());
    }
    configuration=GlobalConfiguration.getConfiguration(new String[]{ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY});
    if (jobManager != null) {
      jobManagerThread=new JobManagerThread(jobManager);
      jobManagerThread.start();
    }
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}"
87742,"public long getDefaultBlockSize(){
  return 32 * 1024 * 1024;
}","/** 
 * Return the number of bytes that large input files should be optimally be split into to minimize I/O time.
 * @return the number of bytes that large input files should be optimally be split into to minimize I/O time
 */
public long getDefaultBlockSize(){
  return 32 * 1024 * 1024;
}"
87743,"/** 
 * {@inheritDoc}
 */
@Override protected void implCloseChannel() throws IOException {
  getOutputStream().close();
}","/** 
 * {@inheritDoc}
 */
@Override protected void implCloseChannel() throws IOException {
  getOutputStream().close();
  if (this.inputStream != null) {
    this.inputStream.close();
    this.inputStream=null;
  }
}"
87744,"private void writeTransferEnvelope(final TransferEnvelope transferEnvelope) throws IOException, InterruptedException {
  final Buffer buffer=transferEnvelope.getBuffer();
  if (buffer != null) {
    if (buffer.isBackedByMemory()) {
      final Buffer fileBuffer=BufferFactory.createFromFile(buffer.size(),this.task.getVertexID(),this.fileBufferManager,this.distributed);
      buffer.copyToBuffer(fileBuffer);
      transferEnvelope.setBuffer(fileBuffer);
      buffer.recycleBuffer();
    }
  }
  if (this.numberOfSerializedTransferEnvelopes % ENVELOPES_PER_META_DATA_FILE == 0) {
    if (this.fileSystem == null) {
      this.fileSystem=this.checkpointPath.getFileSystem();
    }
    if (this.metaDataFileChannel != null) {
      this.metaDataFileChannel.close();
      this.metaDataFileChannel=null;
      renameCheckpointPart();
      ++this.metaDataSuffix;
    }
  }
  if (this.metaDataFileChannel == null) {
    this.metaDataFileChannel=getMetaDataFileChannel(""String_Node_Str"");
  }
  this.transferEnvelopeSerializer.setTransferEnvelope(transferEnvelope);
  while (this.transferEnvelopeSerializer.write(this.metaDataFileChannel)) {
  }
  final EventList eventList=transferEnvelope.getEventList();
  if (eventList != null) {
    final Iterator<AbstractEvent> it=eventList.iterator();
    while (it.hasNext()) {
      if (it.next() instanceof ByteBufferedChannelCloseEvent) {
        ++this.numberOfClosedChannels;
      }
    }
  }
  ++this.numberOfSerializedTransferEnvelopes;
  if (this.numberOfClosedChannels == this.numberOfConnectedChannels) {
    if (this.metaDataFileChannel != null) {
      this.metaDataFileChannel.close();
      renameCheckpointPart();
    }
    getMetaDataFileChannel(CheckpointUtils.COMPLETED_CHECKPOINT_SUFFIX).close();
    LOG.info(""String_Node_Str"" + this.task.getVertexID());
    this.task.checkpointStateChanged(CheckpointState.COMPLETE);
  }
}","private void writeTransferEnvelope(final TransferEnvelope transferEnvelope) throws IOException, InterruptedException {
  Buffer buffer=transferEnvelope.getBuffer();
  if (buffer != null) {
    if (buffer.isBackedByMemory()) {
      final Buffer fileBuffer=BufferFactory.createFromFile(buffer.size(),this.task.getVertexID(),this.fileBufferManager,this.distributed);
      buffer.copyToBuffer(fileBuffer);
      transferEnvelope.setBuffer(fileBuffer);
      buffer.recycleBuffer();
    }
  }
  if (this.numberOfSerializedTransferEnvelopes % ENVELOPES_PER_META_DATA_FILE == 0) {
    if (this.fileSystem == null) {
      this.fileSystem=this.checkpointPath.getFileSystem();
    }
    if (this.metaDataFileChannel != null) {
      this.metaDataFileChannel.close();
      this.metaDataFileChannel=null;
      renameCheckpointPart();
      ++this.metaDataSuffix;
    }
  }
  if (this.metaDataFileChannel == null) {
    this.metaDataFileChannel=getMetaDataFileChannel(""String_Node_Str"");
  }
  this.transferEnvelopeSerializer.setTransferEnvelope(transferEnvelope);
  while (this.transferEnvelopeSerializer.write(this.metaDataFileChannel)) {
  }
  buffer=transferEnvelope.getBuffer();
  if (buffer != null) {
    if (this.firstSerializedFileBuffer == null) {
      this.firstSerializedFileBuffer=buffer;
    }
 else {
      buffer.recycleBuffer();
    }
  }
  final EventList eventList=transferEnvelope.getEventList();
  if (eventList != null) {
    final Iterator<AbstractEvent> it=eventList.iterator();
    while (it.hasNext()) {
      if (it.next() instanceof ByteBufferedChannelCloseEvent) {
        ++this.numberOfClosedChannels;
      }
    }
  }
  ++this.numberOfSerializedTransferEnvelopes;
  if (this.numberOfClosedChannels == this.numberOfConnectedChannels) {
    if (this.firstSerializedFileBuffer != null) {
      this.firstSerializedFileBuffer.recycleBuffer();
    }
    if (this.metaDataFileChannel != null) {
      this.metaDataFileChannel.close();
      renameCheckpointPart();
    }
    getMetaDataFileChannel(CheckpointUtils.COMPLETED_CHECKPOINT_SUFFIX).close();
    LOG.info(""String_Node_Str"" + this.task.getVertexID());
    this.task.checkpointStateChanged(CheckpointState.COMPLETE);
  }
}"
87745,"private void replayCheckpoint() throws Exception {
  System.out.println(""String_Node_Str"" + this.vertexID);
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  while (true) {
    if (this.restartRequested.compareAndSet(true,false)) {
      metaDataIndex=0;
    }
    final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
    while (!fileSystem.exists(metaDataFile)) {
      final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
      if (fileSystem.exists(finalMetaDataFile)) {
        return;
      }
      if (this.isCheckpointComplete) {
        throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
      }
      Thread.sleep(100);
    }
    FileChannel fileChannel=null;
    try {
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          ++metaDataIndex;
          break;
        }
      }
    }
  finally {
      if (fileChannel != null) {
        fileChannel.close();
      }
    }
  }
}","private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  while (true) {
    if (this.restartRequested.compareAndSet(true,false)) {
      metaDataIndex=0;
    }
    final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
    while (!fileSystem.exists(metaDataFile)) {
      final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
      if (fileSystem.exists(finalMetaDataFile)) {
        return;
      }
      if (this.isCheckpointComplete) {
        throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
      }
      Thread.sleep(100);
    }
    FileChannel fileChannel=null;
    try {
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          ++metaDataIndex;
          break;
        }
      }
    }
  finally {
      if (fileChannel != null) {
        fileChannel.close();
      }
    }
  }
}"
87746,"/** 
 * Creates an instance that wraps the plan defined in the jar file using the given arguments. For generating the plan the class defined in the className parameter is used.
 * @param jarFile The jar file which contains the plan.
 * @param className Name of the class which generates the plan. Overrides the class defined in the jar file manifest
 * @param args Optional. The arguments used to create the pact plan, depend on implementation of the pact plan. See getDescription().
 * @throws ProgramInvocationException This invocation is thrown if the PlanAssembler can't be properly loaded. Causes may be a missing / wrong class or manifest files.
 */
public PactProgram(File jarFile,String className,String... args) throws ProgramInvocationException {
  this.assemblerClass=getPactAssemblerFromJar(jarFile,className);
  this.jarFile=jarFile;
  this.args=args;
}","/** 
 * Creates an instance that wraps the plan defined in the jar file using the given arguments. For generating the plan the class defined in the className parameter is used.
 * @param jarFile The jar file which contains the plan.
 * @param className Name of the class which generates the plan. Overrides the class defined in the jar file manifest
 * @param args Optional. The arguments used to create the pact plan, depend on implementation of the pact plan. See getDescription().
 * @throws ProgramInvocationException This invocation is thrown if the PlanAssembler can't be properly loaded. Causes may be a missing / wrong class or manifest files.
 */
public PactProgram(File jarFile,String className,String... args) throws ProgramInvocationException {
  this.jarFile=jarFile;
  this.args=args;
  this.assemblerClass=getPactAssemblerFromJar(jarFile,className);
}"
87747,"/** 
 * {@inheritDoc}
 */
@Override public ChannelType getType(){
  return this.encapsulatedContext.getType();
}","/** 
 * {@inheritDoc}
 */
@Override public ChannelType getType(){
  return null;
}"
87748,"/** 
 * {@inheritDoc}
 */
@Override public boolean hasDataLeft(){
  return this.writeThread.hasDataLeft();
}","/** 
 * {@inheritDoc}
 */
@Override public boolean hasDataLeft() throws IOException, InterruptedException {
  if (isUndecided()) {
    setCheckpointDecisionSynchronously(true);
  }
  if (this.writeThread == null) {
    return false;
  }
  if (this.writeThread.hasDataLeft()) {
    return true;
  }
  if (!this.completeCheckpointAnnounced) {
    this.completeCheckpointAnnounced=true;
    this.task.checkpointStateChanged(CheckpointState.COMPLETE);
  }
  return false;
}"
87749,"boolean hasFinished(){
  this.incomingEventQueue.processQueuedEvents();
  return (!this.forwardingChain.anyForwarderHasDataLeft());
}","boolean hasFinished() throws IOException, InterruptedException {
  this.incomingEventQueue.processQueuedEvents();
  return (!this.forwardingChain.anyForwarderHasDataLeft());
}"
87750,"private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  Buffer firstDeserializedFileBuffer=null;
  FileChannel fileChannel=null;
  try {
    while (true) {
      if (this.restartRequested.compareAndSet(true,false)) {
        metaDataIndex=0;
      }
      final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
      while (!fileSystem.exists(metaDataFile)) {
        final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
        if (fileSystem.exists(finalMetaDataFile)) {
          return;
        }
        if (this.isCheckpointComplete) {
          throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
        }
        Thread.sleep(1000);
      }
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              if (firstDeserializedFileBuffer == null) {
                firstDeserializedFileBuffer=srcBuffer.duplicate();
              }
              if (transferEnvelope.getSequenceNumber() < broker.getNextEnvelopeToSend()) {
                srcBuffer.recycleBuffer();
                continue;
              }
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          fileChannel=null;
          ++metaDataIndex;
          break;
        }
      }
    }
  }
  finally {
    if (firstDeserializedFileBuffer != null) {
      firstDeserializedFileBuffer.recycleBuffer();
      firstDeserializedFileBuffer=null;
    }
    if (fileChannel != null) {
      fileChannel.close();
      fileChannel=null;
    }
  }
}","private void replayCheckpoint() throws Exception {
  final CheckpointDeserializer deserializer=new CheckpointDeserializer(this.vertexID,!this.isCheckpointLocal);
  final Path checkpointPath=this.isCheckpointLocal ? CheckpointUtils.getLocalCheckpointPath() : CheckpointUtils.getDistributedCheckpointPath();
  if (checkpointPath == null) {
    throw new IOException(""String_Node_Str"" + this.vertexID);
  }
  final FileSystem fileSystem=checkpointPath.getFileSystem();
  int metaDataIndex=0;
  Buffer firstDeserializedFileBuffer=null;
  FileChannel fileChannel=null;
  try {
    while (true) {
      if (this.restartRequested.compareAndSet(true,false)) {
        metaDataIndex=0;
      }
      final Path metaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str""+ metaDataIndex);
      while (!fileSystem.exists(metaDataFile)) {
        final Path finalMetaDataFile=checkpointPath.suffix(Path.SEPARATOR + CheckpointUtils.METADATA_PREFIX + ""String_Node_Str""+ this.vertexID+ ""String_Node_Str"");
        if (fileSystem.exists(finalMetaDataFile)) {
          return;
        }
        if (this.isCheckpointComplete) {
          throw new FileNotFoundException(""String_Node_Str"" + metaDataIndex + ""String_Node_Str""+ this.vertexID);
        }
        Thread.sleep(1000);
      }
      fileChannel=getFileChannel(fileSystem,metaDataFile);
      while (true) {
        try {
          deserializer.read(fileChannel);
          final TransferEnvelope transferEnvelope=deserializer.getFullyDeserializedTransferEnvelope();
          if (transferEnvelope != null) {
            final ReplayOutputBroker broker=this.outputBrokerMap.get(transferEnvelope.getSource());
            if (broker == null) {
              throw new IOException(""String_Node_Str"" + transferEnvelope.getSource());
            }
            final Buffer srcBuffer=transferEnvelope.getBuffer();
            if (srcBuffer != null) {
              if (firstDeserializedFileBuffer == null) {
                firstDeserializedFileBuffer=srcBuffer.duplicate();
              }
              if (transferEnvelope.getSequenceNumber() < broker.getNextEnvelopeToSend()) {
                srcBuffer.recycleBuffer();
                continue;
              }
              final Buffer destBuffer=broker.requestEmptyBufferBlocking(srcBuffer.size());
              srcBuffer.copyToBuffer(destBuffer);
              transferEnvelope.setBuffer(destBuffer);
              srcBuffer.recycleBuffer();
            }
            broker.outputEnvelope(transferEnvelope);
          }
        }
 catch (        EOFException eof) {
          fileChannel.close();
          fileChannel=null;
          ++metaDataIndex;
          break;
        }
      }
    }
  }
  finally {
    if (firstDeserializedFileBuffer != null) {
      firstDeserializedFileBuffer.recycleBuffer();
      firstDeserializedFileBuffer=null;
    }
    if (fileChannel != null) {
      fileChannel.close();
      fileChannel=null;
    }
  }
}"
87751,boolean hasDataLeft();,"boolean hasDataLeft() throws IOException, InterruptedException ;"
87752,"public boolean anyForwarderHasDataLeft(){
  final Iterator<OutputChannelForwarder> it=this.forwardingChain.iterator();
  while (it.hasNext()) {
    if (it.next().hasDataLeft()) {
      return true;
    }
  }
  return false;
}","public boolean anyForwarderHasDataLeft() throws IOException, InterruptedException {
  final Iterator<OutputChannelForwarder> it=this.forwardingChain.iterator();
  while (it.hasNext()) {
    if (it.next().hasDataLeft()) {
      return true;
    }
  }
  return false;
}"
87753,"public CheckpointDeserializer(final AbstractID ownerID){
  this.ownerID=ownerID;
  this.fileBufferManager=FileBufferManager.getInstance();
}","public CheckpointDeserializer(final AbstractID ownerID,final boolean distributed){
  this.ownerID=ownerID;
  this.fileBufferManager=FileBufferManager.getInstance();
  this.distributed=distributed;
}"
87754,"@Override protected boolean readBufferData(final ReadableByteChannel readableByteChannel) throws IOException {
  final ByteBuffer tempBuffer=getTempBuffer();
  if (!this.bufferDataSerializationStarted) {
    tempBuffer.clear();
    this.bufferDataSerializationStarted=true;
  }
  readableByteChannel.read(tempBuffer);
  if (tempBuffer.hasRemaining()) {
    return true;
  }
  final long offset=byteBufferToLong(tempBuffer);
  final Buffer fileBuffer=BufferFactory.createFromCheckpoint(getSizeOfBuffer(),offset,this.ownerID,this.fileBufferManager,true);
  setBuffer(fileBuffer);
  this.bufferDataSerializationStarted=false;
  return false;
}","@Override protected boolean readBufferData(final ReadableByteChannel readableByteChannel) throws IOException {
  final ByteBuffer tempBuffer=getTempBuffer();
  if (!this.bufferDataSerializationStarted) {
    tempBuffer.clear();
    this.bufferDataSerializationStarted=true;
  }
  readableByteChannel.read(tempBuffer);
  if (tempBuffer.hasRemaining()) {
    return true;
  }
  final long offset=byteBufferToLong(tempBuffer);
  final Buffer fileBuffer=BufferFactory.createFromCheckpoint(getSizeOfBuffer(),offset,this.ownerID,this.fileBufferManager,this.distributed);
  setBuffer(fileBuffer);
  this.bufferDataSerializationStarted=false;
  return false;
}"
87755,"@Override public Class<? extends Value>[] getPactSchema(){
  Class<? extends Value>[] schema=new Class[this.mapping.size()];
  for (int i=0; i < this.mapping.size(); i++) {
    schema[i]=JsonNodeWrapper.class;
  }
  return schema;
}","@Override public Class<? extends Value>[] getPactSchema(){
  Class<? extends Value>[] schema=new Class[this.mapping.size() + 1];
  for (int i=0; i <= this.mapping.size(); i++) {
    schema[i]=JsonNodeWrapper.class;
  }
  return schema;
}"
87756,"@Test public void shouldUseRecordTarget(){
  this.schema.setMappings(""String_Node_Str"",""String_Node_Str"");
  ObjectNode object=new ObjectNode().put(""String_Node_Str"",TextNode.valueOf(""String_Node_Str"")).put(""String_Node_Str"",TextNode.valueOf(""String_Node_Str""));
  PactRecord target=new PactRecord();
  PactRecord result=this.schema.jsonToRecord(object,target);
  Assert.assertSame(target,result);
}","@Test public void shouldUseRecordTarget(){
  this.schema.setMappings(""String_Node_Str"",""String_Node_Str"");
  ObjectNode object=new ObjectNode().put(""String_Node_Str"",TextNode.valueOf(""String_Node_Str"")).put(""String_Node_Str"",TextNode.valueOf(""String_Node_Str""));
  PactRecord target=new PactRecord();
  target.setField(2,new JsonNodeWrapper(new ObjectNode()));
  PactRecord result=this.schema.jsonToRecord(object,target);
  Assert.assertSame(target,result);
}"
87757,"@Test public void shouldConvertFromJsonToRecord(){
  this.schema.setMappings(""String_Node_Str"",""String_Node_Str"");
  ObjectNode object=new ObjectNode();
  object.put(""String_Node_Str"",TextNode.valueOf(""String_Node_Str"")).put(""String_Node_Str"",TextNode.valueOf(""String_Node_Str""));
  PactRecord result=this.schema.jsonToRecord(object,null);
  PactRecord expected=new PactRecord();
  expected.setField(0,new JsonNodeWrapper(TextNode.valueOf(""String_Node_Str"")));
  expected.setField(1,new JsonNodeWrapper(TextNode.valueOf(""String_Node_Str"")));
  Assert.assertTrue(PactRecordEqualer.recordsEqual(expected,result,this.schema.getPactSchema()));
}","@Test public void shouldConvertFromJsonToRecord(){
  this.schema.setMappings(""String_Node_Str"",""String_Node_Str"");
  ObjectNode object=new ObjectNode();
  object.put(""String_Node_Str"",TextNode.valueOf(""String_Node_Str"")).put(""String_Node_Str"",TextNode.valueOf(""String_Node_Str""));
  PactRecord result=this.schema.jsonToRecord(object,null);
  PactRecord expected=new PactRecord();
  expected.setField(0,new JsonNodeWrapper(TextNode.valueOf(""String_Node_Str"")));
  expected.setField(1,new JsonNodeWrapper(TextNode.valueOf(""String_Node_Str"")));
  expected.setField(2,new JsonNodeWrapper(new ObjectNode()));
  Assert.assertTrue(PactRecordEqualer.recordsEqual(expected,result,this.schema.getPactSchema()));
}"
87758,"/** 
 * {@inheritDoc}
 */
@Override public void read(DataInput in) throws IOException {
  final int addr_length=in.readInt();
  byte[] address=new byte[addr_length];
  in.readFully(address);
  this.hostname=StringRecord.readString(in);
  try {
    this.inetAddress=InetAddress.getByAddress(address);
  }
 catch (  UnknownHostException uhe) {
    throw new IOException(StringUtils.stringifyException(uhe));
  }
  this.ipcPort=in.readInt();
  this.dataPort=in.readInt();
}","/** 
 * {@inheritDoc}
 */
@Override public void read(DataInput in) throws IOException {
  final int addr_length=in.readInt();
  byte[] address=new byte[addr_length];
  in.readFully(address);
  this.hostname=StringRecord.readString(in);
  this.domainname=StringRecord.readString(in);
  try {
    this.inetAddress=InetAddress.getByAddress(address);
  }
 catch (  UnknownHostException uhe) {
    throw new IOException(StringUtils.stringifyException(uhe));
  }
  this.ipcPort=in.readInt();
  this.dataPort=in.readInt();
}"
87759,"/** 
 * Returns the host name of the instance.
 * @return the host name of the instance
 */
public String getHostName(){
  return this.hostname;
}","/** 
 * Returns the host name of the instance. If the host name could not be determined, the return value will be a textual representation of the instance's IP address.
 * @return the host name of the instance
 */
public String getHostName(){
  return this.hostname;
}"
87760,"/** 
 * {@inheritDoc}
 */
@Override public void write(DataOutput out) throws IOException {
  out.writeInt(this.inetAddress.getAddress().length);
  out.write(this.inetAddress.getAddress());
  StringRecord.writeString(out,this.hostname);
  out.writeInt(this.ipcPort);
  out.writeInt(this.dataPort);
}","/** 
 * {@inheritDoc}
 */
@Override public void write(DataOutput out) throws IOException {
  out.writeInt(this.inetAddress.getAddress().length);
  out.write(this.inetAddress.getAddress());
  StringRecord.writeString(out,this.hostname);
  StringRecord.writeString(out,this.domainname);
  out.writeInt(this.ipcPort);
  out.writeInt(this.dataPort);
}"
87761,"/** 
 * Filters these properties by what can be preserved through the given output contract.
 * @param contract The output contract.
 * @return True, if any non-default value is preserved, false otherwise.
 */
public boolean filterByNodesConstantSet(OptimizerNode node,int input){
  if (ordering != null) {
    ArrayList<Integer> involvedIndexes=ordering.getInvolvedIndexes();
    for (int i=0; i < involvedIndexes.size(); i++) {
      if (node.isFieldKept(input,i) == false) {
        ordering=ordering.createNewOrderingUpToIndex(i);
        break;
      }
    }
  }
  if (this.groupedFields != null) {
    for (    Integer index : this.groupedFields) {
      if (node.isFieldKept(input,index) == false) {
        this.groupedFields=null;
        this.grouped=false;
        break;
      }
    }
  }
 else {
    this.grouped=false;
  }
  return !isTrivial();
}","/** 
 * Filters these properties by what can be preserved through the given output contract.
 * @param contract The output contract.
 * @return True, if any non-default value is preserved, false otherwise.
 */
public boolean filterByNodesConstantSet(OptimizerNode node,int input){
  if (ordering != null) {
    ArrayList<Integer> involvedIndexes=ordering.getInvolvedIndexes();
    for (int i=0; i < involvedIndexes.size(); i++) {
      if (node.isFieldKept(input,involvedIndexes.get(i)) == false) {
        ordering=ordering.createNewOrderingUpToIndex(i);
        break;
      }
    }
  }
  if (this.groupedFields != null) {
    for (    Integer index : this.groupedFields) {
      if (node.isFieldKept(input,index) == false) {
        this.groupedFields=null;
        this.grouped=false;
        break;
      }
    }
  }
 else {
    this.grouped=false;
  }
  return !isTrivial();
}"
87762,"@Override public void run() throws Exception {
  final MutableObjectIterator<PactRecord> input=this.inputs[0];
  final MapStub stub=this.stub;
  final Collector output=this.output;
  final PactRecord record=new PactRecord();
  int count=0;
  long consumedPactRecordsInBytes=0L;
  final Environment env=getEnvironment();
  final OutputCollector oc=(OutputCollector)output;
  if (this.stub.getClass().isAnnotationPresent(ForceCheckpoint.class)) {
    env.isForced(this.stub.getClass().getAnnotation(ForceCheckpoint.class).checkpoint());
  }
  while (this.running && input.next(record)) {
    consumedPactRecordsInBytes=+record.getBinaryLength();
    stub.map(record,output);
    if (++count == 10) {
      env.reportPACTDataStatistics(consumedPactRecordsInBytes,oc.getCollectedPactRecordsInBytes());
      consumedPactRecordsInBytes=0L;
      count=0;
    }
  }
}","@Override public void run() throws Exception {
  final MutableObjectIterator<PactRecord> input=this.inputs[0];
  final MapStub stub=this.stub;
  final Collector output=this.output;
  final PactRecord record=new PactRecord();
  int count=0;
  long consumedPactRecordsInBytes=0L;
  final Environment env=getEnvironment();
  final OutputCollector oc=(OutputCollector)output;
  if (this.stub.getClass().isAnnotationPresent(ForceCheckpoint.class)) {
    env.isForced(this.stub.getClass().getAnnotation(ForceCheckpoint.class).checkpoint());
  }
  while (this.running && input.next(record)) {
    consumedPactRecordsInBytes+=record.getBinaryLength();
    stub.map(record,output);
    if (++count == 10) {
      env.reportPACTDataStatistics(consumedPactRecordsInBytes,oc.getCollectedPactRecordsInBytes());
      consumedPactRecordsInBytes=0L;
      count=0;
    }
  }
}"
87763,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
 else   if (obj == null) {
    return false;
  }
 else   if (getClass() != obj.getClass()) {
    return false;
  }
  GlobalProperties other=(GlobalProperties)obj;
  if ((ordering == other.getOrdering() || (ordering != null && ordering.equals(other.getOrdering()))) && partitioning == other.getPartitioning() && partitionedFields.equals(other.getPartitionedFields())) {
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
 else   if (obj == null) {
    return false;
  }
 else   if (getClass() != obj.getClass()) {
    return false;
  }
  GlobalProperties other=(GlobalProperties)obj;
  if ((ordering == other.getOrdering() || (ordering != null && ordering.equals(other.getOrdering()))) && partitioning == other.getPartitioning() && partitionedFields != null && partitionedFields.equals(other.getPartitionedFields())) {
    return true;
  }
 else {
    return false;
  }
}"
87764,"private static boolean isNetworkTask(final RuntimeTask task){
  final RuntimeEnvironment environment=task.getRuntimeEnvironment();
  for (int i=0; i < environment.getNumberOfOutputGates(); ++i) {
    if (environment.getOutputGate(i).getChannelType() == ChannelType.NETWORK) {
      return true;
    }
  }
  return false;
}","private static boolean isNetworkTask(final RuntimeTask task){
  final RuntimeEnvironment environment=task.getRuntimeEnvironment();
  for (int i=0; i < environment.getNumberOfOutputGates(); ++i) {
    if (environment.getOutputGate(i).getChannelType() == ChannelType.NETWORK) {
      LOG.info(environment.getTaskNameWithIndex() + ""String_Node_Str"");
      return true;
    }
  }
  return false;
}"
87765,"public static CheckpointMode getCheckpointMode(){
  if (CHECKPOINT_MODE == null) {
    final String mode=GlobalConfiguration.getString(""String_Node_Str"",""String_Node_Str"").toLowerCase();
    if (""String_Node_Str"".equals(mode)) {
      CHECKPOINT_MODE=CheckpointMode.ALWAYS;
    }
 else     if (""String_Node_Str"".equals(mode)) {
      CHECKPOINT_MODE=CheckpointMode.NETWORK;
    }
 else     if (""String_Node_Str"".equals(mode)) {
      CHECKPOINT_MODE=CheckpointMode.DYNAMIC;
    }
 else {
      CHECKPOINT_MODE=CheckpointMode.NETWORK;
    }
  }
  return CHECKPOINT_MODE;
}","public static CheckpointMode getCheckpointMode(){
  if (CHECKPOINT_MODE == null) {
    final String mode=GlobalConfiguration.getString(""String_Node_Str"",""String_Node_Str"").toLowerCase();
    if (""String_Node_Str"".equals(mode)) {
      CHECKPOINT_MODE=CheckpointMode.ALWAYS;
    }
 else     if (""String_Node_Str"".equals(mode)) {
      CHECKPOINT_MODE=CheckpointMode.NETWORK;
    }
 else     if (""String_Node_Str"".equals(mode)) {
      CHECKPOINT_MODE=CheckpointMode.DYNAMIC;
    }
 else {
      CHECKPOINT_MODE=CheckpointMode.NEVER;
    }
  }
  return CHECKPOINT_MODE;
}"
87766,"@Override protected Entry<String,IJsonNode> loadNext(){
  if (this.lastIndex >= LazyObjectNode.this.schema.getMappingSize()) {
    return noMoreElements();
  }
  String key=LazyObjectNode.this.schema.getMappings().get(this.lastIndex);
  IJsonNode value=SopremoUtil.unwrap(LazyObjectNode.this.record.getField(this.lastIndex,JsonNodeWrapper.class));
  this.lastIndex++;
  return new AbstractMap.SimpleEntry<String,IJsonNode>(key,value);
}","@Override protected Entry<String,IJsonNode> loadNext(){
  while (this.lastIndex < LazyObjectNode.this.schema.getMappingSize()) {
    String key=LazyObjectNode.this.schema.getMappings().get(this.lastIndex);
    if (!LazyObjectNode.this.record.isNull(lastIndex)) {
      IJsonNode value=SopremoUtil.unwrap(LazyObjectNode.this.record.getField(this.lastIndex,JsonNodeWrapper.class));
      this.lastIndex++;
      return new AbstractMap.SimpleEntry<String,IJsonNode>(key,value);
    }
    this.lastIndex++;
  }
  return noMoreElements();
}"
87767,"@Override public Iterator<Entry<String,IJsonNode>> iterator(){
  Iterator<Entry<String,IJsonNode>> iterator2=((IObjectNode)getOtherField()).iterator();
  Iterator<Entry<String,IJsonNode>> iterator1=new AbstractIterator<Map.Entry<String,IJsonNode>>(){
    int lastIndex=0;
    @Override protected Entry<String,IJsonNode> loadNext(){
      if (this.lastIndex >= LazyObjectNode.this.schema.getMappingSize()) {
        return noMoreElements();
      }
      String key=LazyObjectNode.this.schema.getMappings().get(this.lastIndex);
      IJsonNode value=SopremoUtil.unwrap(LazyObjectNode.this.record.getField(this.lastIndex,JsonNodeWrapper.class));
      this.lastIndex++;
      return new AbstractMap.SimpleEntry<String,IJsonNode>(key,value);
    }
  }
;
  return new ConcatenatingIterator<Map.Entry<String,IJsonNode>>(iterator1,iterator2);
}","@Override public Iterator<Entry<String,IJsonNode>> iterator(){
  Iterator<Entry<String,IJsonNode>> iterator2=((IObjectNode)getOtherField()).iterator();
  Iterator<Entry<String,IJsonNode>> iterator1=new AbstractIterator<Map.Entry<String,IJsonNode>>(){
    int lastIndex=0;
    @Override protected Entry<String,IJsonNode> loadNext(){
      while (this.lastIndex < LazyObjectNode.this.schema.getMappingSize()) {
        String key=LazyObjectNode.this.schema.getMappings().get(this.lastIndex);
        if (!LazyObjectNode.this.record.isNull(lastIndex)) {
          IJsonNode value=SopremoUtil.unwrap(LazyObjectNode.this.record.getField(this.lastIndex,JsonNodeWrapper.class));
          this.lastIndex++;
          return new AbstractMap.SimpleEntry<String,IJsonNode>(key,value);
        }
        this.lastIndex++;
      }
      return noMoreElements();
    }
  }
;
  return new ConcatenatingIterator<Map.Entry<String,IJsonNode>>(iterator1,iterator2);
}"
87768,"@Override public PactRecord jsonToRecord(IJsonNode value,PactRecord target){
  if (target == null) {
    target=new PactRecord(this.mapping.size() + 1);
  }
  for (int i=0; i < this.mapping.size(); i++) {
    target.setField(i,new JsonNodeWrapper(((IObjectNode)value).get(this.mapping.get(i))));
    ((IObjectNode)value).remove(this.mapping.get(i));
  }
  target.setField(this.mapping.size(),new JsonNodeWrapper(value));
  return target;
}","@Override public PactRecord jsonToRecord(IJsonNode value,PactRecord target){
  if (target == null) {
    target=new PactRecord(this.mapping.size() + 1);
  }
  for (int i=0; i < this.mapping.size(); i++) {
    target.setField(i,new JsonNodeWrapper(((IObjectNode)value).remove(this.mapping.get(i))));
  }
  target.setField(this.mapping.size(),new JsonNodeWrapper(value));
  return target;
}"
87769,"@Override public FileBaseStatistics getStatistics(BaseStatistics cachedStatistics){
  FileBaseStatistics stats=null;
  if (cachedStatistics != null && cachedStatistics instanceof FileBaseStatistics) {
    stats=(FileBaseStatistics)cachedStatistics;
  }
 else {
    stats=new FileBaseStatistics(-1,BaseStatistics.UNKNOWN,BaseStatistics.UNKNOWN);
  }
  try {
    final Path file=this.filePath;
    final URI uri=file.toUri();
    final FileSystem fs=FileSystem.get(uri);
    List<FileStatus> files=null;
{
      FileStatus status=fs.getFileStatus(file);
      if (status.isDir()) {
        FileStatus[] fss=fs.listStatus(file);
        files=new ArrayList<FileStatus>(fss.length);
        boolean unmodified=true;
        for (        FileStatus s : fss) {
          if (!s.isDir()) {
            files.add(s);
            if (s.getModificationTime() > stats.getLastModificationTime()) {
              stats.setFileModTime(s.getModificationTime());
              unmodified=false;
            }
          }
        }
        if (unmodified) {
          return stats;
        }
      }
 else {
        long modTime=status.getModificationTime();
        if (stats.getLastModificationTime() == modTime) {
          return stats;
        }
        stats.setFileModTime(modTime);
        files=new ArrayList<FileStatus>(1);
        files.add(status);
      }
    }
    stats.setAvgBytesPerRecord(-1.0f);
    stats.setFileSize(0);
    for (    FileStatus s : files) {
      stats.setFileSize(s.getLen());
    }
    if (stats.getTotalInputSize() <= 0) {
      stats.setFileSize(BaseStatistics.UNKNOWN);
      return stats;
    }
    final byte[] delimiter=getDelimiter();
    if (!((delimiter.length == 1 && delimiter[0] == '\n') || (delimiter.length == 2 && delimiter[0] == '\r' && delimiter[1] == '\n'))) {
      return stats;
    }
    int numSamples=Math.min(this.numLineSamples,(int)(stats.getTotalInputSize() / 1024));
    if (numSamples < 2) {
      numSamples=2;
    }
    long offset=0;
    long bytes=0;
    long stepSize=stats.getTotalInputSize() / numSamples;
    int fileNum=0;
    int samplesTaken=0;
    for (int sampleNum=0; sampleNum < numSamples && fileNum < files.size(); sampleNum++) {
      FileStatus currentFile=files.get(fileNum);
      FSDataInputStream inStream=null;
      try {
        inStream=fs.open(currentFile.getPath());
        LineReader lineReader=new LineReader(inStream,offset,currentFile.getLen() - offset,1024);
        byte[] line=lineReader.readLine();
        lineReader.close();
        if (line != null && line.length > 0) {
          samplesTaken++;
          bytes+=line.length + 1;
        }
      }
  finally {
        if (inStream != null) {
          try {
            inStream.close();
          }
 catch (          Throwable t) {
          }
        }
      }
      offset+=stepSize;
      while (fileNum < files.size() && offset >= (currentFile=files.get(fileNum)).getLen()) {
        offset-=currentFile.getLen();
        fileNum++;
      }
    }
    stats.setAvgBytesPerRecord(bytes / (float)samplesTaken);
  }
 catch (  IOException ioex) {
    if (LOG.isWarnEnabled())     LOG.warn(""String_Node_Str"" + filePath + ""String_Node_Str""+ ioex.getMessage());
  }
catch (  Throwable t) {
    if (LOG.isErrorEnabled())     LOG.error(""String_Node_Str"" + filePath + ""String_Node_Str""+ t.getMessage(),t);
  }
  return stats;
}","@Override public FileBaseStatistics getStatistics(BaseStatistics cachedStatistics){
  FileBaseStatistics stats=null;
  if (cachedStatistics != null && cachedStatistics instanceof FileBaseStatistics) {
    stats=(FileBaseStatistics)cachedStatistics;
  }
 else {
    stats=new FileBaseStatistics(-1,BaseStatistics.UNKNOWN,BaseStatistics.UNKNOWN);
  }
  try {
    final Path file=this.filePath;
    final URI uri=file.toUri();
    final FileSystem fs=FileSystem.get(uri);
    List<FileStatus> files=null;
{
      FileStatus status=fs.getFileStatus(file);
      if (status.isDir()) {
        FileStatus[] fss=fs.listStatus(file);
        files=new ArrayList<FileStatus>(fss.length);
        boolean unmodified=true;
        for (        FileStatus s : fss) {
          if (!s.isDir()) {
            files.add(s);
            if (s.getModificationTime() > stats.getLastModificationTime()) {
              stats.setFileModTime(s.getModificationTime());
              unmodified=false;
            }
          }
        }
        if (unmodified) {
          return stats;
        }
      }
 else {
        long modTime=status.getModificationTime();
        if (stats.getLastModificationTime() == modTime) {
          return stats;
        }
        stats.setFileModTime(modTime);
        files=new ArrayList<FileStatus>(1);
        files.add(status);
      }
    }
    stats.setAvgBytesPerRecord(-1.0f);
    stats.setFileSize(0);
    long totalInputSize=0;
    for (    FileStatus s : files) {
      totalInputSize+=s.getLen();
    }
    stats.setFileSize(totalInputSize);
    if (stats.getTotalInputSize() <= 0) {
      stats.setFileSize(BaseStatistics.UNKNOWN);
      return stats;
    }
    final byte[] delimiter=getDelimiter();
    if (!((delimiter.length == 1 && delimiter[0] == '\n') || (delimiter.length == 2 && delimiter[0] == '\r' && delimiter[1] == '\n'))) {
      return stats;
    }
    int numSamples=Math.min(this.numLineSamples,(int)(stats.getTotalInputSize() / 1024));
    if (numSamples < 2) {
      numSamples=2;
    }
    long offset=0;
    long bytes=0;
    long stepSize=stats.getTotalInputSize() / numSamples;
    int fileNum=0;
    int samplesTaken=0;
    for (int sampleNum=0; sampleNum < numSamples && fileNum < files.size(); sampleNum++) {
      FileStatus currentFile=files.get(fileNum);
      FSDataInputStream inStream=null;
      try {
        inStream=fs.open(currentFile.getPath());
        LineReader lineReader=new LineReader(inStream,offset,currentFile.getLen() - offset,1024);
        byte[] line=lineReader.readLine();
        lineReader.close();
        if (line != null && line.length > 0) {
          samplesTaken++;
          bytes+=line.length + 1;
        }
      }
  finally {
        if (inStream != null) {
          try {
            inStream.close();
          }
 catch (          Throwable t) {
          }
        }
      }
      offset+=stepSize;
      while (fileNum < files.size() && offset >= (currentFile=files.get(fileNum)).getLen()) {
        offset-=currentFile.getLen();
        fileNum++;
      }
    }
    stats.setAvgBytesPerRecord(bytes / (float)samplesTaken);
  }
 catch (  IOException ioex) {
    if (LOG.isWarnEnabled())     LOG.warn(""String_Node_Str"" + filePath + ""String_Node_Str""+ ioex.getMessage());
  }
catch (  Throwable t) {
    if (LOG.isErrorEnabled())     LOG.error(""String_Node_Str"" + filePath + ""String_Node_Str""+ t.getMessage(),t);
  }
  return stats;
}"
87770,"@Override public boolean callWithNextKey(MatchStub matchFunction,Collector collector) throws Exception {
  final OutputCollector oc=(OutputCollector)collector;
  if (this.hashJoin.nextRecord()) {
    final HashJoin.HashBucketIterator buildSideIterator=this.hashJoin.getBuildSideIterator();
    PactRecord probeRecord=this.hashJoin.getCurrentProbeRecord();
    PactRecord nextBuildSidePair=this.nextBuildSideObject;
    if (buildSideIterator.next(nextBuildSidePair)) {
      PactRecord tmpPair=new PactRecord();
      if (buildSideIterator.next(tmpPair)) {
        probeRecord.copyTo(this.probeCopy);
        long r1=nextBuildSidePair.getBinaryLength();
        long r2=probeRecord.getBinaryLength();
        matchFunction.match(nextBuildSidePair,probeRecord,collector);
        this.environment.reportPACTDataStatistics(r1 + r2,oc.getCollectedPactRecordsInBytes());
        probeRecord=new PactRecord();
        this.probeCopy.copyTo(probeRecord);
        r1=tmpPair.getBinaryLength();
        r2=probeRecord.getBinaryLength();
        matchFunction.match(tmpPair,probeRecord,collector);
        this.environment.reportPACTDataStatistics(r1 + r2,oc.getCollectedPactRecordsInBytes());
        tmpPair=new PactRecord();
        while (this.running && buildSideIterator.next(tmpPair)) {
          probeRecord=new PactRecord();
          this.probeCopy.copyTo(probeRecord);
          r1=tmpPair.getBinaryLength();
          r2=probeRecord.getBinaryLength();
          matchFunction.match(tmpPair,probeRecord,collector);
          this.environment.reportPACTDataStatistics(r1 + r2,oc.getCollectedPactRecordsInBytes());
          tmpPair=new PactRecord();
        }
        this.nextBuildSideObject=tmpPair;
      }
 else {
        this.nextBuildSideObject=tmpPair;
        final long r1=nextBuildSidePair.getBinaryLength();
        final long r2=probeRecord.getBinaryLength();
        matchFunction.match(nextBuildSidePair,probeRecord,collector);
        this.environment.reportPACTDataStatistics(r1 + r2,oc.getCollectedPactRecordsInBytes());
      }
    }
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean callWithNextKey(MatchStub matchFunction,Collector collector) throws Exception {
  if (this.hashJoin.nextRecord()) {
    final HashJoin.HashBucketIterator buildSideIterator=this.hashJoin.getBuildSideIterator();
    PactRecord probeRecord=this.hashJoin.getCurrentProbeRecord();
    PactRecord nextBuildSidePair=this.nextBuildSideObject;
    if (buildSideIterator.next(nextBuildSidePair)) {
      PactRecord tmpPair=new PactRecord();
      if (buildSideIterator.next(tmpPair)) {
        probeRecord.copyTo(this.probeCopy);
        long r1=nextBuildSidePair.getBinaryLength();
        long r2=probeRecord.getBinaryLength();
        matchFunction.match(nextBuildSidePair,probeRecord,collector);
        this.environment.reportPACTDataStatistics(r1 + r2,collector.getCollectedPactRecordsInBytes());
        probeRecord=new PactRecord();
        this.probeCopy.copyTo(probeRecord);
        r1=tmpPair.getBinaryLength();
        r2=probeRecord.getBinaryLength();
        matchFunction.match(tmpPair,probeRecord,collector);
        this.environment.reportPACTDataStatistics(r1 + r2,collector.getCollectedPactRecordsInBytes());
        tmpPair=new PactRecord();
        while (this.running && buildSideIterator.next(tmpPair)) {
          probeRecord=new PactRecord();
          this.probeCopy.copyTo(probeRecord);
          r1=tmpPair.getBinaryLength();
          r2=probeRecord.getBinaryLength();
          matchFunction.match(tmpPair,probeRecord,collector);
          this.environment.reportPACTDataStatistics(r1 + r2,collector.getCollectedPactRecordsInBytes());
          tmpPair=new PactRecord();
        }
        this.nextBuildSideObject=tmpPair;
      }
 else {
        this.nextBuildSideObject=tmpPair;
        final long r1=nextBuildSidePair.getBinaryLength();
        final long r2=probeRecord.getBinaryLength();
        matchFunction.match(nextBuildSidePair,probeRecord,collector);
        this.environment.reportPACTDataStatistics(r1 + r2,collector.getCollectedPactRecordsInBytes());
      }
    }
    return true;
  }
 else {
    return false;
  }
}"
87771,"@Override public boolean callWithNextKey(MatchStub matchFunction,Collector collector) throws Exception {
  final Environment env=this.environment;
  final OutputCollector oc=(OutputCollector)collector;
  if (this.hashJoin.nextRecord()) {
    final HashJoin.HashBucketIterator buildSideIterator=this.hashJoin.getBuildSideIterator();
    PactRecord probeRecord=this.hashJoin.getCurrentProbeRecord();
    PactRecord nextBuildSidePair=this.nextBuildSideObject;
    if (buildSideIterator.next(nextBuildSidePair)) {
      PactRecord tmpPair=new PactRecord();
      if (buildSideIterator.next(tmpPair)) {
        probeRecord.copyTo(this.probeCopy);
        long r1=probeRecord.getBinaryLength();
        long r2=nextBuildSidePair.getBinaryLength();
        matchFunction.match(probeRecord,nextBuildSidePair,collector);
        env.reportPACTDataStatistics(r1 + r2,oc.getCollectedPactRecordsInBytes());
        probeRecord=new PactRecord();
        this.probeCopy.copyTo(probeRecord);
        r1=probeRecord.getBinaryLength();
        r2=tmpPair.getBinaryLength();
        matchFunction.match(probeRecord,tmpPair,collector);
        env.reportPACTDataStatistics(r1 + r2,oc.getCollectedPactRecordsInBytes());
        tmpPair=new PactRecord();
        while (this.running && buildSideIterator.next(tmpPair)) {
          probeRecord=new PactRecord();
          this.probeCopy.copyTo(probeRecord);
          r1=probeRecord.getBinaryLength();
          r2=tmpPair.getBinaryLength();
          matchFunction.match(probeRecord,tmpPair,collector);
          env.reportPACTDataStatistics(r1 + r2,oc.getCollectedPactRecordsInBytes());
          tmpPair=new PactRecord();
        }
        this.nextBuildSideObject=tmpPair;
      }
 else {
        this.nextBuildSideObject=tmpPair;
        final long r1=probeRecord.getBinaryLength();
        final long r2=nextBuildSidePair.getBinaryLength();
        matchFunction.match(probeRecord,nextBuildSidePair,collector);
        env.reportPACTDataStatistics(r1 + r2,oc.getCollectedPactRecordsInBytes());
      }
    }
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean callWithNextKey(MatchStub matchFunction,Collector collector) throws Exception {
  final Environment env=this.environment;
  if (this.hashJoin.nextRecord()) {
    final HashJoin.HashBucketIterator buildSideIterator=this.hashJoin.getBuildSideIterator();
    PactRecord probeRecord=this.hashJoin.getCurrentProbeRecord();
    PactRecord nextBuildSidePair=this.nextBuildSideObject;
    if (buildSideIterator.next(nextBuildSidePair)) {
      PactRecord tmpPair=new PactRecord();
      if (buildSideIterator.next(tmpPair)) {
        probeRecord.copyTo(this.probeCopy);
        long r1=probeRecord.getBinaryLength();
        long r2=nextBuildSidePair.getBinaryLength();
        matchFunction.match(probeRecord,nextBuildSidePair,collector);
        env.reportPACTDataStatistics(r1 + r2,collector.getCollectedPactRecordsInBytes());
        probeRecord=new PactRecord();
        this.probeCopy.copyTo(probeRecord);
        r1=probeRecord.getBinaryLength();
        r2=tmpPair.getBinaryLength();
        matchFunction.match(probeRecord,tmpPair,collector);
        env.reportPACTDataStatistics(r1 + r2,collector.getCollectedPactRecordsInBytes());
        tmpPair=new PactRecord();
        while (this.running && buildSideIterator.next(tmpPair)) {
          probeRecord=new PactRecord();
          this.probeCopy.copyTo(probeRecord);
          r1=probeRecord.getBinaryLength();
          r2=tmpPair.getBinaryLength();
          matchFunction.match(probeRecord,tmpPair,collector);
          env.reportPACTDataStatistics(r1 + r2,collector.getCollectedPactRecordsInBytes());
          tmpPair=new PactRecord();
        }
        this.nextBuildSideObject=tmpPair;
      }
 else {
        this.nextBuildSideObject=tmpPair;
        final long r1=probeRecord.getBinaryLength();
        final long r2=nextBuildSidePair.getBinaryLength();
        matchFunction.match(probeRecord,nextBuildSidePair,collector);
        env.reportPACTDataStatistics(r1 + r2,collector.getCollectedPactRecordsInBytes());
      }
    }
    return true;
  }
 else {
    return false;
  }
}"
87772,"@Override public void collect(PactRecord record){
  this.list.add(record.createCopy());
}","@Override public void collect(PactRecord record){
  this.collectedPactRecordsInBytes+=record.getBinaryLength();
  this.list.add(record.createCopy());
}"
87773,"@Override public void collect(PactRecord record){
  try {
    if (this.spillingInThisBuffer) {
      if (this.currentBuffer.write(record)) {
        if (this.bytesUntilSpilling - this.currentBuffer.getOccupancy() <= 0) {
          this.bytesUntilSpilling=0;
          this.queues.sort.add(SPILLING_MARKER);
        }
        return;
      }
    }
 else {
      if (this.currentBuffer.write(record))       return;
    }
    if (this.bytesUntilSpilling > 0) {
      this.bytesUntilSpilling-=this.currentBuffer.getCapacity();
      if (this.bytesUntilSpilling <= 0) {
        this.bytesUntilSpilling=0;
        this.queues.sort.add(SPILLING_MARKER);
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + this.currentElement.id + ""String_Node_Str"");
    }
    this.queues.sort.add(this.currentElement);
    this.currentElement=null;
    while (this.running && this.currentElement == null) {
      try {
        this.currentElement=this.queues.empty.take();
      }
 catch (      InterruptedException iex) {
        if (this.running) {
          LOG.error(""String_Node_Str"" + ""String_Node_Str"");
        }
 else {
          return;
        }
      }
    }
    if (!this.running)     return;
    this.currentBuffer=this.currentElement.buffer;
    if (!this.currentBuffer.isEmpty()) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + this.currentElement.id + ""String_Node_Str"");
    }
    if (!this.currentBuffer.write(record)) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  IOException ioex) {
    throw new RuntimeException(""String_Node_Str"" + ioex.getMessage(),ioex);
  }
}","@Override public void collect(PactRecord record){
  this.collectedPactRecordsInBytes+=record.getBinaryLength();
  try {
    if (this.spillingInThisBuffer) {
      if (this.currentBuffer.write(record)) {
        if (this.bytesUntilSpilling - this.currentBuffer.getOccupancy() <= 0) {
          this.bytesUntilSpilling=0;
          this.queues.sort.add(SPILLING_MARKER);
        }
        return;
      }
    }
 else {
      if (this.currentBuffer.write(record))       return;
    }
    if (this.bytesUntilSpilling > 0) {
      this.bytesUntilSpilling-=this.currentBuffer.getCapacity();
      if (this.bytesUntilSpilling <= 0) {
        this.bytesUntilSpilling=0;
        this.queues.sort.add(SPILLING_MARKER);
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + this.currentElement.id + ""String_Node_Str"");
    }
    this.queues.sort.add(this.currentElement);
    this.currentElement=null;
    while (this.running && this.currentElement == null) {
      try {
        this.currentElement=this.queues.empty.take();
      }
 catch (      InterruptedException iex) {
        if (this.running) {
          LOG.error(""String_Node_Str"" + ""String_Node_Str"");
        }
 else {
          return;
        }
      }
    }
    if (!this.running)     return;
    this.currentBuffer=this.currentElement.buffer;
    if (!this.currentBuffer.isEmpty()) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + this.currentElement.id + ""String_Node_Str"");
    }
    if (!this.currentBuffer.write(record)) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  IOException ioex) {
    throw new RuntimeException(""String_Node_Str"" + ioex.getMessage(),ioex);
  }
}"
87774,"@Override public void collect(PactRecord record){
  if (this.exception != null)   throw new RuntimeException(""String_Node_Str"",this.exception.getCause() == null ? this.exception : this.exception.getCause());
  this.inputCollector.collect(record);
}","@Override public void collect(PactRecord record){
  this.collectedPactRecordsInBytes+=record.getBinaryLength();
  if (this.exception != null)   throw new RuntimeException(""String_Node_Str"",this.exception.getCause() == null ? this.exception : this.exception.getCause());
  this.inputCollector.collect(record);
}"
87775,"@Override public void collect(PactRecord record){
  try {
    this.consumedPactRecordsInBytes+=record.getBinaryLength();
    this.mapper.map(record,this.collector);
    if (++this.count == 10) {
      parent.getEnvironment().reportPACTDataStatistics(this.consumedPactRecordsInBytes,((OutputCollector)this.collector).getCollectedPactRecordsInBytes());
      this.consumedPactRecordsInBytes=0L;
      this.count=0;
    }
  }
 catch (  Exception ex) {
    throw new ExceptionInChainedStubException(this.taskName,ex);
  }
}","@Override public void collect(PactRecord record){
  final int recordLength=record.getBinaryLength();
  this.collectedPactRecordsInBytes+=recordLength;
  try {
    this.consumedPactRecordsInBytes+=recordLength;
    this.mapper.map(record,this.collector);
    if (++this.count == 10) {
      parent.getEnvironment().reportPACTDataStatistics(this.consumedPactRecordsInBytes,((OutputCollector)this.collector).getCollectedPactRecordsInBytes());
      this.consumedPactRecordsInBytes=0L;
      this.count=0;
    }
  }
 catch (  Exception ex) {
    throw new ExceptionInChainedStubException(this.taskName,ex);
  }
}"
87776,"/** 
 * {@inheritDoc}
 */
@Override public void killInstance(final StringRecord instanceName) throws IOException {
  final AbstractInstance instance=this.instanceManager.getInstanceByName(instanceName.toString());
  if (instance == null) {
    LOG.error(""String_Node_Str"" + instanceName + ""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + instance);
  final Runnable runnable=new Runnable(){
    @Override public void run(){
      try {
        instance.killTaskManager();
      }
 catch (      IOException ioe) {
        LOG.error(StringUtils.stringifyException(ioe));
      }
    }
  }
;
  this.executorService.execute(runnable);
}","/** 
 * {@inheritDoc}
 */
@Override public void killInstance(final StringRecord instanceName) throws IOException {
  final AbstractInstance instance=this.instanceManager.getInstanceByName(instanceName.toString());
  if (instance == null) {
    LOG.error(""String_Node_Str"" + instanceName + ""String_Node_Str"");
    return;
  }
  LOG.info(""String_Node_Str"" + instance);
  final Runnable runnable=new Runnable(){
    @Override public void run(){
      try {
        instance.killTaskManager();
      }
 catch (      IOException ioe) {
        LOG.error(StringUtils.stringifyException(ioe));
      }
    }
  }
;
  this.executorService.execute(runnable);
}"
87777,"/** 
 * Registers the spilling queue with this network connection. The network connection is then in charge of polling the elements from the queue.
 * @param spillingQueue the queue to register
 */
void registerSpillingQueue(final SpillingQueue spillingQueue){
synchronized (this.queuedEnvelopes) {
    checkConnection();
    this.queuedEnvelopes.registerSpillingQueue(spillingQueue);
  }
}","/** 
 * Registers the spilling queue with this network connection. The network connection is then in charge of polling the elements from the queue.
 * @param spillingQueue the queue to register
 */
void registerSpillingQueue(final SpillingQueue spillingQueue){
}"
87778,"private void showOustandingEnvelopeLog(){
  int dataAvailableCounter=0;
  final int pos=this.outstandingEnvelopesAsIntBuffer.position();
  final int limit=this.outstandingEnvelopesAsIntBuffer.limit();
  for (int i=0; i < this.outstandingEnvelopesAsIntBuffer.capacity(); ++i) {
    if (i < pos) {
      System.out.print('_');
      continue;
    }
    if (i >= limit) {
      System.out.print('_');
      continue;
    }
    final int entry=this.outstandingEnvelopesAsIntBuffer.get(i);
    final int channelIndex=getInputChannel(entry);
    final boolean dataAvailable=getDataAvailability(entry);
    if (dataAvailable) {
      ++dataAvailableCounter;
    }
    char ch=(char)(((int)'A') + channelIndex + (dataAvailable ? 0 : 32));
    System.out.print(ch);
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + dataAvailableCounter);
}","private void showOustandingEnvelopeLog(){
  int dataAvailableCounter=0;
  final int pos=this.outstandingEnvelopesAsIntBuffer.position();
  final int limit=this.outstandingEnvelopesAsIntBuffer.limit();
  final StringBuilder sb=new StringBuilder();
  for (int i=0; i < this.outstandingEnvelopesAsIntBuffer.capacity(); ++i) {
    if (i < pos) {
      sb.append('_');
      continue;
    }
    if (i >= limit) {
      sb.append('_');
      continue;
    }
    final int entry=this.outstandingEnvelopesAsIntBuffer.get(i);
    final int channelIndex=getInputChannel(entry);
    final boolean dataAvailable=getDataAvailability(entry);
    if (dataAvailable) {
      ++dataAvailableCounter;
    }
    char ch=(char)(((int)'A') + channelIndex + (dataAvailable ? 0 : 32));
    sb.append(ch);
  }
  LOG.debug(sb.toString());
}"
87779,"private void addOutstandingEnvelope(final int gateIndex,final int channelIndex){
  final int entryToTest=toEntry(gateIndex,channelIndex,false);
  boolean found=false;
  while (true) {
    for (int i=this.outstandingEnvelopesAsIntBuffer.position(); i < this.outstandingEnvelopesAsIntBuffer.limit(); ++i) {
      if (this.outstandingEnvelopesAsIntBuffer.get(i) == entryToTest) {
        this.outstandingEnvelopesAsIntBuffer.put(i,setDataAvailability(entryToTest,true));
        found=true;
        break;
      }
    }
    if (!found) {
      if (this.outstandingEnvelopesAsIntBuffer.limit() == this.outstandingEnvelopesAsIntBuffer.capacity()) {
        loadNextOutstandingEnvelopes();
        continue;
      }
      final int newEntry=setDataAvailability(entryToTest,true);
      final int limit=this.outstandingEnvelopesAsIntBuffer.limit();
      this.outstandingEnvelopesAsIntBuffer.limit(limit + 1);
      this.outstandingEnvelopesAsIntBuffer.put(limit,newEntry);
    }
    break;
  }
  int newPosition=this.outstandingEnvelopesAsIntBuffer.position();
  int count=0;
  for (int i=this.outstandingEnvelopesAsIntBuffer.position(); i < this.outstandingEnvelopesAsIntBuffer.limit(); ++i) {
    final int entry=this.outstandingEnvelopesAsIntBuffer.get(i);
    if (getDataAvailability(entry)) {
      announce(getInputGate(entry),getInputChannel(entry));
      newPosition=i + 1;
      ++count;
    }
 else {
      break;
    }
  }
  this.outstandingEnvelopesAsIntBuffer.position(Math.min(this.outstandingEnvelopesAsIntBuffer.limit(),newPosition));
  if (count > 0) {
    System.out.println(""String_Node_Str"" + count + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + this.numberOfInitialLogEntries + ""String_Node_Str""+ this.numberOfAnnouncedEnvelopes);
    System.out.println(""String_Node_Str"" + this.outstandingEnvelopesAsIntBuffer.remaining());
    showOustandingEnvelopeLog();
  }
  if (!this.outstandingEnvelopesAsIntBuffer.hasRemaining()) {
    loadNextOutstandingEnvelopes();
  }
}","private void addOutstandingEnvelope(final int gateIndex,final int channelIndex){
  final int entryToTest=toEntry(gateIndex,channelIndex,false);
  boolean found=false;
  while (true) {
    for (int i=this.outstandingEnvelopesAsIntBuffer.position(); i < this.outstandingEnvelopesAsIntBuffer.limit(); ++i) {
      if (this.outstandingEnvelopesAsIntBuffer.get(i) == entryToTest) {
        this.outstandingEnvelopesAsIntBuffer.put(i,setDataAvailability(entryToTest,true));
        found=true;
        break;
      }
    }
    if (!found) {
      if (this.outstandingEnvelopesAsIntBuffer.limit() == this.outstandingEnvelopesAsIntBuffer.capacity()) {
        loadNextOutstandingEnvelopes();
        continue;
      }
      final int newEntry=setDataAvailability(entryToTest,true);
      final int limit=this.outstandingEnvelopesAsIntBuffer.limit();
      this.outstandingEnvelopesAsIntBuffer.limit(limit + 1);
      this.outstandingEnvelopesAsIntBuffer.put(limit,newEntry);
    }
    break;
  }
  int newPosition=this.outstandingEnvelopesAsIntBuffer.position();
  int count=0;
  for (int i=this.outstandingEnvelopesAsIntBuffer.position(); i < this.outstandingEnvelopesAsIntBuffer.limit(); ++i) {
    final int entry=this.outstandingEnvelopesAsIntBuffer.get(i);
    if (getDataAvailability(entry)) {
      announce(getInputGate(entry),getInputChannel(entry));
      newPosition=i + 1;
      ++count;
    }
 else {
      break;
    }
  }
  this.outstandingEnvelopesAsIntBuffer.position(Math.min(this.outstandingEnvelopesAsIntBuffer.limit(),newPosition));
  if (count > 0 && LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
    LOG.debug(""String_Node_Str"" + this.numberOfInitialLogEntries + ""String_Node_Str""+ this.numberOfAnnouncedEnvelopes);
    LOG.debug(""String_Node_Str"" + this.outstandingEnvelopesAsIntBuffer.remaining());
    showOustandingEnvelopeLog();
  }
  if (!this.outstandingEnvelopesAsIntBuffer.hasRemaining()) {
    loadNextOutstandingEnvelopes();
  }
}"
87780,"/** 
 * {@inheritDoc}
 */
@Override public void queueTransferEnvelope(final TransferEnvelope transferEnvelope){
  final int sequenceNumber=transferEnvelope.getSequenceNumber();
  AbstractEvent eventToSend=null;
  if (ReceiverNotFoundEvent.isReceiverNotFoundEvent(transferEnvelope)) {
    return;
  }
synchronized (this.queuedEnvelopes) {
    if (this.destroyCalled) {
      final Buffer buffer=transferEnvelope.getBuffer();
      if (buffer != null) {
        buffer.recycleBuffer();
      }
      return;
    }
    final int expectedSequenceNumber=this.lastReceivedEnvelope + 1;
    if (sequenceNumber != expectedSequenceNumber) {
      if (sequenceNumber > expectedSequenceNumber) {
        if (expectedSequenceNumber > 0) {
          this.byteBufferedInputChannel.reportIOException(new IOException(""String_Node_Str"" + expectedSequenceNumber + ""String_Node_Str""+ sequenceNumber));
          this.envelopeConsumptionTracker.reportEnvelopeAvailability(this.byteBufferedInputChannel);
        }
      }
 else {
        eventToSend=lookForCloseEvent(transferEnvelope);
        if (eventToSend == null) {
          eventToSend=new UnexpectedEnvelopeEvent(expectedSequenceNumber - 1);
        }
      }
      LOG.warn(""String_Node_Str"" + getChannelID() + ""String_Node_Str""+ expectedSequenceNumber+ ""String_Node_Str""+ sequenceNumber);
      final Buffer buffer=transferEnvelope.getBuffer();
      if (buffer != null) {
        buffer.recycleBuffer();
      }
    }
 else {
      this.queuedEnvelopes.add(transferEnvelope);
      this.lastReceivedEnvelope=sequenceNumber;
    }
  }
  this.envelopeConsumptionTracker.reportEnvelopeAvailability(this.byteBufferedInputChannel);
  if (eventToSend != null) {
    try {
      transferEventToOutputChannel(eventToSend);
    }
 catch (    Exception e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void queueTransferEnvelope(final TransferEnvelope transferEnvelope){
  final int sequenceNumber=transferEnvelope.getSequenceNumber();
  AbstractEvent eventToSend=null;
  if (ReceiverNotFoundEvent.isReceiverNotFoundEvent(transferEnvelope)) {
    return;
  }
synchronized (this.queuedEnvelopes) {
    if (this.destroyCalled) {
      final Buffer buffer=transferEnvelope.getBuffer();
      if (buffer != null) {
        buffer.recycleBuffer();
      }
      return;
    }
    final int expectedSequenceNumber=this.lastReceivedEnvelope + 1;
    if (sequenceNumber != expectedSequenceNumber) {
      if (sequenceNumber > expectedSequenceNumber) {
        if (expectedSequenceNumber > 0) {
          this.byteBufferedInputChannel.reportIOException(new IOException(""String_Node_Str"" + expectedSequenceNumber + ""String_Node_Str""+ sequenceNumber));
          this.byteBufferedInputChannel.checkForNetworkEvents();
        }
      }
 else {
        eventToSend=lookForCloseEvent(transferEnvelope);
        if (eventToSend == null) {
          eventToSend=new UnexpectedEnvelopeEvent(expectedSequenceNumber - 1);
        }
      }
      LOG.warn(""String_Node_Str"" + getChannelID() + ""String_Node_Str""+ expectedSequenceNumber+ ""String_Node_Str""+ sequenceNumber);
      final Buffer buffer=transferEnvelope.getBuffer();
      if (buffer != null) {
        buffer.recycleBuffer();
      }
    }
 else {
      this.queuedEnvelopes.add(transferEnvelope);
      this.lastReceivedEnvelope=sequenceNumber;
      this.envelopeConsumptionTracker.reportEnvelopeAvailability(this.byteBufferedInputChannel);
    }
  }
  if (eventToSend != null) {
    try {
      transferEventToOutputChannel(eventToSend);
    }
 catch (    Exception e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}"
87781,"RuntimeInputGateContext(final String taskName,final TransferEnvelopeDispatcher transferEnvelopeDispatcher,final InputGate<? extends Record> inputGate,final EnvelopeConsumptionTracker envelopeConsumptionTracker){
  this.taskName=taskName;
  this.localBufferPool=new LocalBufferPool(1,false);
  this.transferEnvelopeDispatcher=transferEnvelopeDispatcher;
  this.inputGate=inputGate;
  this.envelopeConsumptionTracker=envelopeConsumptionTracker;
}","RuntimeInputGateContext(final String taskName,final TransferEnvelopeDispatcher transferEnvelopeDispatcher,final InputGate<? extends Record> inputGate,final EnvelopeConsumptionTracker envelopeConsumptionTracker){
  this.taskName=taskName;
  this.localBufferPool=new LocalBufferPool(1,false);
  this.transferEnvelopeDispatcher=transferEnvelopeDispatcher;
  this.inputGate=inputGate;
  this.envelopeConsumptionTracker=envelopeConsumptionTracker;
  this.fileBufferManager=FileBufferManager.getInstance();
}"
87782,"/** 
 * {@inheritDoc}
 */
@Override public Buffer requestEmptyBufferBlocking(final int minimumSizeOfBuffer) throws IOException, InterruptedException {
  return this.localBufferPool.requestEmptyBufferBlocking(minimumSizeOfBuffer);
}","/** 
 * {@inheritDoc}
 */
@Override public Buffer requestEmptyBufferBlocking(final int minimumSizeOfBuffer) throws IOException, InterruptedException {
  final Buffer buffer=this.localBufferPool.requestEmptyBuffer(minimumSizeOfBuffer);
  if (buffer != null) {
    return buffer;
  }
  if (this.envelopeConsumptionTracker.followsLog()) {
    return BufferFactory.createFromFile(minimumSizeOfBuffer,this.inputGate.getGateID(),fileBufferManager);
  }
  return this.localBufferPool.requestEmptyBufferBlocking(minimumSizeOfBuffer);
}"
87783,"private void processEnvelopeWithBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList,final boolean freeSourceBuffer){
  if (!freeSourceBuffer) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() != 1) {
      LOG.error(""String_Node_Str"");
    }
    final ChannelID localReceiver=localReceivers.get(0);
    final ChannelContext cc=this.registeredChannels.get(localReceiver);
    if (cc == null) {
      sendReceiverNotFoundEvent(transferEnvelope,localReceiver);
      recycleBuffer(transferEnvelope);
      return;
    }
    if (!cc.isInputChannel()) {
      LOG.error(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
    }
    cc.queueTransferEnvelope(transferEnvelope);
    return;
  }
  final Buffer srcBuffer=transferEnvelope.getBuffer();
  if (receiverList.hasLocalReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    for (    final ChannelID localReceiver : localReceivers) {
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        sendReceiverNotFoundEvent(transferEnvelope,localReceiver);
        continue;
      }
      if (!cc.isInputChannel()) {
        LOG.error(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
        continue;
      }
      final InputChannelContext inputChannelContext=(InputChannelContext)cc;
      Buffer destBuffer=null;
      try {
        destBuffer=inputChannelContext.requestEmptyBufferBlocking(srcBuffer.size());
        srcBuffer.copyToBuffer(destBuffer);
      }
 catch (      Exception e) {
        LOG.error(StringUtils.stringifyException(e));
        if (destBuffer != null) {
          destBuffer.recycleBuffer();
        }
        continue;
      }
      final TransferEnvelope dup=transferEnvelope.duplicateWithoutBuffer();
      dup.setBuffer(destBuffer);
      inputChannelContext.queueTransferEnvelope(dup);
    }
  }
  if (receiverList.hasRemoteReceivers()) {
    final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
    for (    final InetSocketAddress remoteReceiver : remoteReceivers) {
      TransferEnvelope dup=null;
      try {
        dup=transferEnvelope.duplicate();
      }
 catch (      Exception e) {
        LOG.error(StringUtils.stringifyException(e));
        if (dup != null) {
          recycleBuffer(dup);
          continue;
        }
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,dup);
    }
  }
  srcBuffer.recycleBuffer();
}","private void processEnvelopeWithBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList,final boolean freeSourceBuffer){
  if (!freeSourceBuffer) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() != 1) {
      LOG.error(""String_Node_Str"");
    }
    final ChannelID localReceiver=localReceivers.get(0);
    final ChannelContext cc=this.registeredChannels.get(localReceiver);
    if (cc == null) {
      sendReceiverNotFoundEvent(transferEnvelope,localReceiver);
      recycleBuffer(transferEnvelope);
      return;
    }
    if (!cc.isInputChannel()) {
      LOG.error(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
    }
    cc.queueTransferEnvelope(transferEnvelope);
    return;
  }
  final Buffer srcBuffer=transferEnvelope.getBuffer();
  if (receiverList.hasLocalReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    for (    final ChannelID localReceiver : localReceivers) {
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        sendReceiverNotFoundEvent(transferEnvelope,localReceiver);
        continue;
      }
      if (!cc.isInputChannel()) {
        LOG.error(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
        continue;
      }
      final InputChannelContext inputChannelContext=(InputChannelContext)cc;
      if (srcBuffer.isBackedByMemory()) {
        Buffer destBuffer=null;
        try {
          destBuffer=inputChannelContext.requestEmptyBufferBlocking(srcBuffer.size());
          srcBuffer.copyToBuffer(destBuffer);
        }
 catch (        Exception e) {
          LOG.error(StringUtils.stringifyException(e));
          if (destBuffer != null) {
            destBuffer.recycleBuffer();
          }
          continue;
        }
        final TransferEnvelope dup=transferEnvelope.duplicateWithoutBuffer();
        dup.setBuffer(destBuffer);
        inputChannelContext.queueTransferEnvelope(dup);
      }
 else {
        TransferEnvelope dup=null;
        try {
          dup=transferEnvelope.duplicate();
        }
 catch (        Exception e) {
          LOG.error(StringUtils.stringifyException(e));
          continue;
        }
        inputChannelContext.queueTransferEnvelope(dup);
      }
    }
  }
  if (receiverList.hasRemoteReceivers()) {
    final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
    for (    final InetSocketAddress remoteReceiver : remoteReceivers) {
      TransferEnvelope dup=null;
      try {
        dup=transferEnvelope.duplicate();
      }
 catch (      Exception e) {
        LOG.error(StringUtils.stringifyException(e));
        if (dup != null) {
          recycleBuffer(dup);
          continue;
        }
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,dup);
    }
  }
  srcBuffer.recycleBuffer();
}"
87784,"void finish(){
synchronized (this) {
    writeAnnouncedEnvelopesBufferToDisk();
  }
}","void finish(){
synchronized (this) {
    if (this.announcedEnvelopesAsIntBuffer.position() == 0) {
      return;
    }
  }
  final EnvelopeConsumptionLog lock=this;
  final Thread finisherThread=new Thread(""String_Node_Str"" + this.environment.getTaskNameWithIndex()){
    /** 
 * {@inheritDoc}
 */
    @Override public void run(){
synchronized (lock) {
        writeAnnouncedEnvelopesBufferToDisk();
      }
    }
  }
;
  finisherThread.start();
  boolean regularExit=false;
  while (!regularExit) {
    try {
      finisherThread.join();
      regularExit=true;
    }
 catch (    InterruptedException ie) {
    }
  }
}"
87785,"/** 
 * {@inheritDoc}
 */
@Override public boolean isInputChannel(){
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isInputChannel(){
  return false;
}"
87786,"private void sendReceiverNotFoundEvent(final TransferEnvelope envelope,final ChannelID unknownReceiver){
  if (ChannelID.SYSTEM_ID.equals(envelope.getSource())) {
    LOG.error(""String_Node_Str"");
    return;
  }
  final JobID jobID=envelope.getJobID();
  final TransferEnvelope transferEnvelope=new TransferEnvelope(0,jobID,ChannelID.SYSTEM_ID);
  final ReceiverNotFoundEvent unknownReceiverEvent=new ReceiverNotFoundEvent(unknownReceiver,envelope.getSequenceNumber());
  transferEnvelope.addEvent(unknownReceiverEvent);
  final TransferEnvelopeReceiverList receiverList=getReceiverList(jobID,unknownReceiver);
  if (receiverList == null) {
    LOG.error(""String_Node_Str"" + unknownReceiver);
    return;
  }
  processEnvelopeEnvelopeWithoutBuffer(transferEnvelope,receiverList);
}","private void sendReceiverNotFoundEvent(final TransferEnvelope envelope,final ChannelID receiver){
  if (envelope.getBuffer() == null && envelope.getSequenceNumber() == 0) {
    final EventList eventList=envelope.getEventList();
    if (eventList.size() == 1) {
      final AbstractEvent event=eventList.get(0);
      if (event instanceof ReceiverNotFoundEvent) {
        LOG.info(""String_Node_Str"");
        return;
      }
    }
  }
  final JobID jobID=envelope.getJobID();
  final TransferEnvelope transferEnvelope=new TransferEnvelope(0,jobID,receiver);
  final ReceiverNotFoundEvent unknownReceiverEvent=new ReceiverNotFoundEvent(receiver,envelope.getSequenceNumber());
  transferEnvelope.addEvent(unknownReceiverEvent);
  final TransferEnvelopeReceiverList receiverList=getReceiverList(jobID,receiver);
  if (receiverList == null) {
    LOG.error(""String_Node_Str"" + receiver);
    return;
  }
  processEnvelopeEnvelopeWithoutBuffer(transferEnvelope,receiverList);
}"
87787,"private TransferEnvelopeReceiverList getReceiverList(final JobID jobID,final ChannelID sourceChannelID){
  TransferEnvelopeReceiverList receiverList=this.receiverCache.get(sourceChannelID);
  if (receiverList == null) {
    try {
      while (true) {
        final ConnectionInfoLookupResponse lookupResponse=this.channelLookupService.lookupConnectionInfo(this.localConnectionInfo,jobID,sourceChannelID);
        if (lookupResponse.receiverNotFound()) {
          throw new IOException(""String_Node_Str"" + sourceChannelID);
        }
        if (lookupResponse.receiverNotReady()) {
          Thread.sleep(500);
          continue;
        }
        if (lookupResponse.receiverReady()) {
          receiverList=new TransferEnvelopeReceiverList(lookupResponse);
          break;
        }
      }
      if (receiverList != null) {
        this.receiverCache.put(sourceChannelID,receiverList);
        if (LOG.isDebugEnabled()) {
          final StringBuilder sb=new StringBuilder();
          sb.append(""String_Node_Str"" + sourceChannelID + ""String_Node_Str""+ this.localConnectionInfo+ ""String_Node_Str"");
          if (receiverList.hasLocalReceivers()) {
            sb.append(""String_Node_Str"");
            final Iterator<ChannelID> it=receiverList.getLocalReceivers().iterator();
            while (it.hasNext()) {
              sb.append(""String_Node_Str"" + it.next() + ""String_Node_Str"");
            }
          }
          if (receiverList.hasRemoteReceivers()) {
            sb.append(""String_Node_Str"");
            final Iterator<InetSocketAddress> it=receiverList.getRemoteReceivers().iterator();
            while (it.hasNext()) {
              sb.append(""String_Node_Str"" + it.next() + ""String_Node_Str"");
            }
          }
          LOG.debug(sb.toString());
        }
      }
    }
 catch (    InterruptedException ie) {
    }
catch (    IOException ioe) {
    }
  }
  return receiverList;
}","private TransferEnvelopeReceiverList getReceiverList(final JobID jobID,final ChannelID sourceChannelID){
  TransferEnvelopeReceiverList receiverList=this.receiverCache.get(sourceChannelID);
  if (receiverList == null) {
    try {
      while (true) {
        ConnectionInfoLookupResponse lookupResponse;
synchronized (this.channelLookupService) {
          lookupResponse=this.channelLookupService.lookupConnectionInfo(this.localConnectionInfo,jobID,sourceChannelID);
        }
        if (lookupResponse.receiverNotFound()) {
          throw new IOException(""String_Node_Str"" + sourceChannelID);
        }
        if (lookupResponse.receiverNotReady()) {
          Thread.sleep(500);
          continue;
        }
        if (lookupResponse.receiverReady()) {
          receiverList=new TransferEnvelopeReceiverList(lookupResponse);
          break;
        }
      }
      if (receiverList != null) {
        this.receiverCache.put(sourceChannelID,receiverList);
        if (LOG.isDebugEnabled()) {
          final StringBuilder sb=new StringBuilder();
          sb.append(""String_Node_Str"" + sourceChannelID + ""String_Node_Str""+ this.localConnectionInfo+ ""String_Node_Str"");
          if (receiverList.hasLocalReceivers()) {
            sb.append(""String_Node_Str"");
            final Iterator<ChannelID> it=receiverList.getLocalReceivers().iterator();
            while (it.hasNext()) {
              sb.append(""String_Node_Str"" + it.next() + ""String_Node_Str"");
            }
          }
          if (receiverList.hasRemoteReceivers()) {
            sb.append(""String_Node_Str"");
            final Iterator<InetSocketAddress> it=receiverList.getRemoteReceivers().iterator();
            while (it.hasNext()) {
              sb.append(""String_Node_Str"" + it.next() + ""String_Node_Str"");
            }
          }
          LOG.debug(sb.toString());
        }
      }
    }
 catch (    InterruptedException ie) {
    }
catch (    IOException ioe) {
    }
  }
  return receiverList;
}"
87788,"@Override public BufferProvider getBufferProvider(final JobID jobID,final ChannelID sourceChannelID) throws IOException, InterruptedException {
  final TransferEnvelopeReceiverList receiverList=getReceiverList(jobID,sourceChannelID);
  if (receiverList.hasLocalReceivers() && !receiverList.hasRemoteReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() == 1) {
      final ChannelID localReceiver=localReceivers.get(0);
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        return this.transitBufferPool;
      }
      if (!cc.isInputChannel()) {
        throw new IOException(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
      }
      final InputChannelContext icc=(InputChannelContext)cc;
      return icc;
    }
  }
  return this.transitBufferPool;
}","/** 
 * {@inheritDoc}
 */
@Override public BufferProvider getBufferProvider(final JobID jobID,final ChannelID sourceChannelID) throws IOException, InterruptedException {
  final TransferEnvelopeReceiverList receiverList=getReceiverList(jobID,sourceChannelID);
  if (receiverList.hasLocalReceivers() && !receiverList.hasRemoteReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() == 1) {
      final ChannelID localReceiver=localReceivers.get(0);
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        return this.transitBufferPool;
      }
      if (!cc.isInputChannel()) {
        throw new IOException(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
      }
      final InputChannelContext icc=(InputChannelContext)cc;
      return icc;
    }
  }
  return this.transitBufferPool;
}"
87789,"public static Buffer createFromMemory(final int bufferSize,final ByteBuffer byteBuffer,final Queue<ByteBuffer> queueForRecycledBuffers){
  final InternalBuffer internalBuffer=new MemoryBuffer(bufferSize,byteBuffer,queueForRecycledBuffers);
  return new Buffer(internalBuffer);
}","public static Buffer createFromMemory(final int bufferSize,final ByteBuffer byteBuffer,final MemoryBufferPoolConnector bufferPoolConnector){
  final InternalBuffer internalBuffer=new MemoryBuffer(bufferSize,byteBuffer,bufferPoolConnector);
  return new Buffer(internalBuffer);
}"
87790,"/** 
 * Increases the number of references to the physical buffer by one.
 */
synchronized void increaseReferenceCounter(){
  if (this.bufferAlreadyRecycled) {
    LOG.error(""String_Node_Str"");
  }
  ++this.referenceCounter;
}","/** 
 * Increases the number of references to the physical buffer by one.
 */
void increaseReferenceCounter(){
  if (this.referenceCounter.getAndIncrement() == 0) {
    LOG.error(""String_Node_Str"");
  }
}"
87791,"/** 
 * Constructs a new memory buffer recycler.
 * @param originalBuffer the original byte buffer
 * @param queueForRecycledBuffers the queue to append the buffer for recycling
 */
MemoryBufferRecycler(final ByteBuffer originalBuffer,final Queue<ByteBuffer> queueForRecycledBuffers){
  this.originalBuffer=originalBuffer;
  this.queueForRecycledBuffers=queueForRecycledBuffers;
}","/** 
 * Constructs a new memory buffer recycler.
 * @param originalBuffer the original byte buffer
 * @param bufferPoolConnector the connection to the pool from which the byte buffer has originally been taken
 */
MemoryBufferRecycler(final ByteBuffer originalBuffer,final MemoryBufferPoolConnector bufferPoolConnector){
  this.originalBuffer=originalBuffer;
  this.bufferPoolConnector=bufferPoolConnector;
}"
87792,"/** 
 * Decreases the number of references to the physical buffer by one. If the number of references becomes zero the physical buffer is recycled.
 */
synchronized void decreaseReferenceCounter(){
  if (this.bufferAlreadyRecycled) {
    LOG.error(""String_Node_Str"");
  }
  --this.referenceCounter;
  if (this.referenceCounter <= 0) {
    this.originalBuffer.clear();
synchronized (this.queueForRecycledBuffers) {
      this.queueForRecycledBuffers.add(this.originalBuffer);
      this.queueForRecycledBuffers.notify();
    }
    this.bufferAlreadyRecycled=true;
  }
}","/** 
 * Decreases the number of references to the physical buffer by one. If the number of references becomes zero the physical buffer is recycled.
 */
void decreaseReferenceCounter(){
  final int val=this.referenceCounter.decrementAndGet();
  if (val == 0) {
    this.originalBuffer.clear();
    this.bufferPoolConnector.recycle(this.originalBuffer);
  }
 else   if (val < 0) {
    LOG.error(""String_Node_Str"");
  }
}"
87793,"public LocalBufferPool(final String ownerName,final int designatedNumberOfBuffers,final boolean isShared){
  this(ownerName,designatedNumberOfBuffers,isShared,null);
}","public LocalBufferPool(final int designatedNumberOfBuffers,final boolean isShared){
  this(designatedNumberOfBuffers,isShared,null);
}"
87794,"private Buffer requestBufferInternal(final int minimumSizeOfBuffer,final boolean block) throws IOException, InterruptedException {
  if (minimumSizeOfBuffer > this.maximumBufferSize) {
    throw new IllegalArgumentException(""String_Node_Str"" + minimumSizeOfBuffer + ""String_Node_Str""+ this.maximumBufferSize);
  }
  while (true) {
    boolean async=false;
synchronized (this.buffers) {
      while (this.requestedNumberOfBuffers > this.designatedNumberOfBuffers) {
        final ByteBuffer buffer=this.buffers.poll();
        if (buffer == null) {
          break;
        }
        this.globalBufferPool.releaseGlobalBuffer(buffer);
        this.requestedNumberOfBuffers--;
      }
      while (this.buffers.isEmpty()) {
        if (this.requestedNumberOfBuffers < this.designatedNumberOfBuffers) {
          final ByteBuffer buffer=this.globalBufferPool.lockGlobalBuffer();
          if (buffer != null) {
            this.buffers.add(buffer);
            this.requestedNumberOfBuffers++;
            continue;
          }
        }
        if (this.asynchronousEventOccurred && block) {
          this.asynchronousEventOccurred=false;
          async=true;
          break;
        }
        if (block) {
          this.buffers.wait();
        }
 else {
          return null;
        }
      }
      if (!async) {
        final ByteBuffer byteBuffer=this.buffers.poll();
        return BufferFactory.createFromMemory(minimumSizeOfBuffer,byteBuffer,this.buffers);
      }
    }
    if (this.eventListener != null) {
      this.eventListener.asynchronousEventOccurred();
    }
  }
}","private Buffer requestBufferInternal(final int minimumSizeOfBuffer,final boolean block) throws IOException, InterruptedException {
  if (minimumSizeOfBuffer > this.maximumBufferSize) {
    throw new IllegalArgumentException(""String_Node_Str"" + minimumSizeOfBuffer + ""String_Node_Str""+ this.maximumBufferSize);
  }
  while (true) {
    boolean async=false;
synchronized (this.buffers) {
      while (this.requestedNumberOfBuffers > this.designatedNumberOfBuffers) {
        final ByteBuffer buffer=this.buffers.poll();
        if (buffer == null) {
          break;
        }
        this.globalBufferPool.releaseGlobalBuffer(buffer);
        this.requestedNumberOfBuffers--;
      }
      while (this.buffers.isEmpty()) {
        if (this.requestedNumberOfBuffers < this.designatedNumberOfBuffers) {
          final ByteBuffer buffer=this.globalBufferPool.lockGlobalBuffer();
          if (buffer != null) {
            this.buffers.add(buffer);
            this.requestedNumberOfBuffers++;
            continue;
          }
        }
        if (this.asynchronousEventOccurred && block) {
          this.asynchronousEventOccurred=false;
          async=true;
          break;
        }
        if (block) {
          this.buffers.wait();
        }
 else {
          return null;
        }
      }
      if (!async) {
        final ByteBuffer byteBuffer=this.buffers.poll();
        return BufferFactory.createFromMemory(minimumSizeOfBuffer,byteBuffer,this.bufferPoolConnector);
      }
    }
    if (this.eventListener != null) {
      this.eventListener.asynchronousEventOccurred();
    }
  }
}"
87795,"public ByteBufferedChannelManager(final ChannelLookupProtocol channelLookupService,final InstanceConnectionInfo localInstanceConnectionInfo) throws IOException {
  this.channelLookupService=channelLookupService;
  this.localConnectionInfo=localInstanceConnectionInfo;
  FileBufferManager.getInstance();
  GlobalBufferPool.getInstance();
  this.transitBufferPool=new LocalBufferPool(""String_Node_Str"",128,true);
  this.networkConnectionManager=new NetworkConnectionManager(this,localInstanceConnectionInfo.getAddress(),localInstanceConnectionInfo.getDataPort());
  this.allowSenderSideSpilling=GlobalConfiguration.getBoolean(""String_Node_Str"",DEFAULT_ALLOW_SENDER_SIDE_SPILLING);
  this.mergeSpilledBuffers=GlobalConfiguration.getBoolean(""String_Node_Str"",DEFAULT_MERGE_SPILLED_BUFFERS);
  LOG.info(""String_Node_Str"" + (this.allowSenderSideSpilling ? ""String_Node_Str"" : ""String_Node_Str"") + (this.mergeSpilledBuffers ? ""String_Node_Str"" : ""String_Node_Str""));
}","public ByteBufferedChannelManager(final ChannelLookupProtocol channelLookupService,final InstanceConnectionInfo localInstanceConnectionInfo) throws IOException {
  this.channelLookupService=channelLookupService;
  this.localConnectionInfo=localInstanceConnectionInfo;
  FileBufferManager.getInstance();
  GlobalBufferPool.getInstance();
  this.transitBufferPool=new LocalBufferPool(128,true);
  this.networkConnectionManager=new NetworkConnectionManager(this,localInstanceConnectionInfo.getAddress(),localInstanceConnectionInfo.getDataPort());
  this.allowSenderSideSpilling=GlobalConfiguration.getBoolean(""String_Node_Str"",DEFAULT_ALLOW_SENDER_SIDE_SPILLING);
  this.mergeSpilledBuffers=GlobalConfiguration.getBoolean(""String_Node_Str"",DEFAULT_MERGE_SPILLED_BUFFERS);
  LOG.info(""String_Node_Str"" + (this.allowSenderSideSpilling ? ""String_Node_Str"" : ""String_Node_Str"") + (this.mergeSpilledBuffers ? ""String_Node_Str"" : ""String_Node_Str""));
}"
87796,"/** 
 * {@inheritDoc}
 */
@Override public void clearLocalBufferPool(){
  this.localBufferPool.clear();
}","/** 
 * {@inheritDoc}
 */
@Override public void clearLocalBufferPool(){
  this.localBufferPool.destroy();
}"
87797,"RuntimeInputGateContext(final String taskName,final TransferEnvelopeDispatcher transferEnvelopeDispatcher,final InputGate<? extends Record> inputGate){
  final String poolOwnerName=(taskName == null ? ""String_Node_Str"" : taskName + ""String_Node_Str"" + inputGate.getIndex()+ ""String_Node_Str"");
  this.localBufferPool=new LocalBufferPool(poolOwnerName,1,false);
  this.transferEnvelopeDispatcher=transferEnvelopeDispatcher;
  this.inputGate=inputGate;
}","RuntimeInputGateContext(final TransferEnvelopeDispatcher transferEnvelopeDispatcher,final InputGate<? extends Record> inputGate){
  this.localBufferPool=new LocalBufferPool(1,false);
  this.transferEnvelopeDispatcher=transferEnvelopeDispatcher;
  this.inputGate=inputGate;
}"
87798,"RuntimeTaskContext(final RuntimeTask task,final TransferEnvelopeDispatcher transferEnvelopeDispatcher,final Map<ExecutionVertexID,RuntimeTaskContext> tasksWithUndecidedCheckpoints){
  final String poolOwnerName=(task.getEnvironment().getTaskName() == null ? ""String_Node_Str"" : task.getEnvironment().getTaskName());
  this.localBufferPool=new LocalBufferPool(poolOwnerName,1,false,this);
  this.task=task;
  final RuntimeEnvironment environment=task.getRuntimeEnvironment();
  int nooc=0;
  boolean ephemeral=true;
  for (int i=0; i < environment.getNumberOfOutputGates(); ++i) {
    final OutputGate<? extends Record> outputGate=environment.getOutputGate(i);
    nooc+=outputGate.getNumberOfOutputChannels();
    if (outputGate.getChannelType() == ChannelType.FILE) {
      ephemeral=false;
    }
  }
  this.numberOfOutputChannels=nooc;
  this.ephemeralCheckpoint=new EphemeralCheckpoint(task,ephemeral);
  if (ephemeral) {
    tasksWithUndecidedCheckpoints.put(task.getVertexID(),this);
  }
  this.transferEnvelopeDispatcher=transferEnvelopeDispatcher;
  this.runtimeDispatcher=new RuntimeDispatcher(transferEnvelopeDispatcher);
}","RuntimeTaskContext(final RuntimeTask task,final TransferEnvelopeDispatcher transferEnvelopeDispatcher,final Map<ExecutionVertexID,RuntimeTaskContext> tasksWithUndecidedCheckpoints){
  this.localBufferPool=new LocalBufferPool(1,false,this);
  this.task=task;
  final RuntimeEnvironment environment=task.getRuntimeEnvironment();
  int nooc=0;
  boolean ephemeral=true;
  for (int i=0; i < environment.getNumberOfOutputGates(); ++i) {
    final OutputGate<? extends Record> outputGate=environment.getOutputGate(i);
    nooc+=outputGate.getNumberOfOutputChannels();
    if (outputGate.getChannelType() == ChannelType.FILE) {
      ephemeral=false;
    }
  }
  this.numberOfOutputChannels=nooc;
  this.ephemeralCheckpoint=new EphemeralCheckpoint(task,ephemeral);
  if (ephemeral) {
    tasksWithUndecidedCheckpoints.put(task.getVertexID(),this);
  }
  this.transferEnvelopeDispatcher=transferEnvelopeDispatcher;
  this.runtimeDispatcher=new RuntimeDispatcher(transferEnvelopeDispatcher);
}"
87799,"/** 
 * {@inheritDoc}
 */
@Override public void clearLocalBufferPool(){
  this.localBufferPool.clear();
}","/** 
 * {@inheritDoc}
 */
@Override public void clearLocalBufferPool(){
  this.localBufferPool.destroy();
}"
87800,"/** 
 * {@inheritDoc}
 */
@Override public InputGateContext createInputGateContext(final GateID gateID){
  if (gateID == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  InputGate<? extends Record> inputGate=null;
  final RuntimeEnvironment re=this.task.getRuntimeEnvironment();
  for (int i=0; i < re.getNumberOfInputGates(); ++i) {
    final InputGate<? extends Record> candidateGate=re.getInputGate(i);
    if (candidateGate.getGateID().equals(gateID)) {
      inputGate=candidateGate;
      break;
    }
  }
  if (inputGate == null) {
    throw new IllegalStateException(""String_Node_Str"" + gateID);
  }
  return new RuntimeInputGateContext(this.task.getEnvironment().getTaskName(),this.transferEnvelopeDispatcher,inputGate);
}","/** 
 * {@inheritDoc}
 */
@Override public InputGateContext createInputGateContext(final GateID gateID){
  if (gateID == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  InputGate<? extends Record> inputGate=null;
  final RuntimeEnvironment re=this.task.getRuntimeEnvironment();
  for (int i=0; i < re.getNumberOfInputGates(); ++i) {
    final InputGate<? extends Record> candidateGate=re.getInputGate(i);
    if (candidateGate.getGateID().equals(gateID)) {
      inputGate=candidateGate;
      break;
    }
  }
  if (inputGate == null) {
    throw new IllegalStateException(""String_Node_Str"" + gateID);
  }
  return new RuntimeInputGateContext(this.transferEnvelopeDispatcher,inputGate);
}"
87801,"private static final boolean invalidateReceiverLookupCaches(final ExecutionVertex failedVertex,final Set<ExecutionVertex> verticesToBeCanceled){
  final Map<AbstractInstance,Set<ChannelID>> entriesToInvalidate=new HashMap<AbstractInstance,Set<ChannelID>>();
  final ExecutionGraph eg=failedVertex.getExecutionGraph();
  final RuntimeEnvironment env=failedVertex.getEnvironment();
  for (int i=0; i < env.getNumberOfOutputGates(); ++i) {
    final OutputGate<? extends Record> outputGate=env.getOutputGate(i);
    for (int j=0; j < outputGate.getNumberOfOutputChannels(); ++j) {
      final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
      if (outputChannel.getType() == ChannelType.FILE) {
        continue;
      }
      final ChannelID connectedChannelID=outputChannel.getConnectedChannelID();
      final ExecutionVertex connectedVertex=eg.getVertexByChannelID(connectedChannelID);
      if (connectedVertex == null) {
        LOG.error(""String_Node_Str"");
        continue;
      }
      if (verticesToBeCanceled.contains(connectedVertex)) {
        continue;
      }
      final AbstractInstance instance=connectedVertex.getAllocatedResource().getInstance();
      Set<ChannelID> channelIDs=entriesToInvalidate.get(instance);
      if (channelIDs == null) {
        channelIDs=new SerializableHashSet<ChannelID>();
        entriesToInvalidate.put(instance,channelIDs);
      }
      channelIDs.add(connectedChannelID);
    }
  }
  for (int i=0; i < env.getNumberOfInputGates(); ++i) {
    final InputGate<? extends Record> inputGate=env.getInputGate(i);
    for (int j=0; j < inputGate.getNumberOfInputChannels(); ++j) {
      final AbstractInputChannel<? extends Record> inputChannel=inputGate.getInputChannel(j);
      if (inputChannel.getType() == ChannelType.FILE) {
        continue;
      }
      final ChannelID connectedChannelID=inputChannel.getConnectedChannelID();
      final ExecutionVertex connectedVertex=eg.getVertexByChannelID(connectedChannelID);
      if (connectedVertex == null) {
        LOG.error(""String_Node_Str"");
        continue;
      }
      if (verticesToBeCanceled.contains(connectedVertex)) {
        continue;
      }
      final AbstractInstance instance=connectedVertex.getAllocatedResource().getInstance();
      Set<ChannelID> channelIDs=entriesToInvalidate.get(instance);
      if (channelIDs == null) {
        channelIDs=new SerializableHashSet<ChannelID>();
        entriesToInvalidate.put(instance,channelIDs);
      }
      channelIDs.add(connectedChannelID);
    }
  }
  final Iterator<Map.Entry<AbstractInstance,Set<ChannelID>>> it=entriesToInvalidate.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<AbstractInstance,Set<ChannelID>> entry=it.next();
    final AbstractInstance instance=entry.getKey();
    try {
      instance.invalidateLookupCacheEntries(entry.getValue());
    }
 catch (    IOException ioe) {
      LOG.error(StringUtils.stringifyException(ioe));
      return false;
    }
  }
  return true;
}","private static final boolean invalidateReceiverLookupCaches(final ExecutionVertex failedVertex,final Set<ExecutionVertex> verticesToBeCanceled){
  final Map<AbstractInstance,Set<ChannelID>> entriesToInvalidate=new HashMap<AbstractInstance,Set<ChannelID>>();
  collectCacheEntriesToInvalidate(failedVertex,entriesToInvalidate);
  for (final Iterator<ExecutionVertex> it=verticesToBeCanceled.iterator(); it.hasNext(); ) {
    collectCacheEntriesToInvalidate(it.next(),entriesToInvalidate);
  }
  final Iterator<Map.Entry<AbstractInstance,Set<ChannelID>>> it=entriesToInvalidate.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<AbstractInstance,Set<ChannelID>> entry=it.next();
    final AbstractInstance instance=entry.getKey();
    try {
      instance.invalidateLookupCacheEntries(entry.getValue());
    }
 catch (    IOException ioe) {
      LOG.error(StringUtils.stringifyException(ioe));
      return false;
    }
  }
  return true;
}"
87802,"public boolean keepsUniqueProperty(FieldSet uniqueSet,int input){
  for (  Integer uniqueField : uniqueSet) {
    if (isFieldKept(uniqueField,input) == false) {
      return false;
    }
  }
  return true;
}","public boolean keepsUniqueProperty(FieldSet uniqueSet,int input){
  for (  Integer uniqueField : uniqueSet) {
    if (isFieldKept(input,uniqueField) == false) {
      return false;
    }
  }
  return true;
}"
87803,"private void recycleBuffer(final ByteBuffer byteBuffer){
synchronized (this.buffers) {
    if (this.isDestroyed) {
      this.globalBufferPool.releaseGlobalBuffer(this.buffers.poll());
      this.requestedNumberOfBuffers--;
      return;
    }
    this.buffers.add(byteBuffer);
    this.buffers.notify();
  }
}","private void recycleBuffer(final ByteBuffer byteBuffer){
synchronized (this.buffers) {
    if (this.isDestroyed) {
      this.globalBufferPool.releaseGlobalBuffer(byteBuffer);
      this.requestedNumberOfBuffers--;
      return;
    }
    this.buffers.add(byteBuffer);
    this.buffers.notify();
  }
}"
87804,"/** 
 * {@inheritDoc}
 */
@Override public List<TaskSubmissionResult> submitTasks(final List<TaskSubmissionWrapper> tasks) throws IOException {
  final List<TaskSubmissionResult> submissionResultList=new SerializableArrayList<TaskSubmissionResult>();
  final List<Task> tasksToStart=new ArrayList<Task>();
  for (  final TaskSubmissionWrapper tsw : tasks) {
    final RuntimeEnvironment re=tsw.getEnvironment();
    final ExecutionVertexID id=tsw.getVertexID();
    final Configuration jobConfiguration=tsw.getConfiguration();
    final Set<ChannelID> activeOutputChannels=tsw.getActiveOutputChannels();
    final Task task=createAndRegisterTask(id,jobConfiguration,re,activeOutputChannels);
    if (task == null) {
      final TaskSubmissionResult result=new TaskSubmissionResult(id,AbstractTaskResult.ReturnCode.TASK_NOT_FOUND);
      result.setDescription(""String_Node_Str"" + id + ""String_Node_Str"");
      LOG.error(result.getDescription());
      submissionResultList.add(result);
    }
 else {
      submissionResultList.add(new TaskSubmissionResult(id,AbstractTaskResult.ReturnCode.SUCCESS));
    }
    tasksToStart.add(task);
  }
  for (  final Task task : tasksToStart) {
    task.startExecution();
  }
  return submissionResultList;
}","/** 
 * {@inheritDoc}
 */
@Override public List<TaskSubmissionResult> submitTasks(final List<TaskSubmissionWrapper> tasks) throws IOException {
  final List<TaskSubmissionResult> submissionResultList=new SerializableArrayList<TaskSubmissionResult>();
  final List<Task> tasksToStart=new ArrayList<Task>();
  for (  final TaskSubmissionWrapper tsw : tasks) {
    final RuntimeEnvironment re=tsw.getEnvironment();
    final ExecutionVertexID id=tsw.getVertexID();
    final Configuration jobConfiguration=tsw.getConfiguration();
    final Set<ChannelID> activeOutputChannels=tsw.getActiveOutputChannels();
    final Task task=createAndRegisterTask(id,jobConfiguration,re,activeOutputChannels);
    if (task == null) {
      final TaskSubmissionResult result=new TaskSubmissionResult(id,AbstractTaskResult.ReturnCode.TASK_NOT_FOUND);
      result.setDescription(""String_Node_Str"" + re.getTaskNameWithIndex() + ""String_Node_Str""+ id+ ""String_Node_Str"");
      LOG.error(result.getDescription());
      submissionResultList.add(result);
    }
 else {
      submissionResultList.add(new TaskSubmissionResult(id,AbstractTaskResult.ReturnCode.SUCCESS));
      tasksToStart.add(task);
    }
  }
  for (  final Task task : tasksToStart) {
    task.startExecution();
  }
  return submissionResultList;
}"
87805,"/** 
 * Returns the key column numbers for the specific input if it is preserved by this node. Null, otherwise.
 * @param input
 * @return
 */
protected int[] getConstantKeySet(int input){
  int[] keyColumns=null;
  Contract contract=getPactContract();
  if (contract instanceof AbstractPact<?>) {
    AbstractPact<?> abstractPact=(AbstractPact<?>)contract;
    keyColumns=abstractPact.getKeyColumnNumbers(input);
    if (keyColumns != null) {
      for (      int keyColumn : keyColumns) {
        if (isFieldKept(input,keyColumn) == false) {
          keyColumns=null;
          break;
        }
      }
    }
  }
  return keyColumns;
}","/** 
 * Returns the key column numbers for the specific input if it is preserved by this node. Null, otherwise.
 * @param input
 * @return
 */
protected int[] getConstantKeySet(int input){
  int[] keyColumns=null;
  Contract contract=getPactContract();
  if (contract instanceof AbstractPact<?>) {
    AbstractPact<?> abstractPact=(AbstractPact<?>)contract;
    keyColumns=abstractPact.getKeyColumnNumbers(input);
    if (keyColumns != null) {
      if (keyColumns.length == 0) {
        return null;
      }
      for (      int keyColumn : keyColumns) {
        if (isFieldKept(input,keyColumn) == false) {
          return null;
        }
      }
    }
  }
  return keyColumns;
}"
87806,"/** 
 * Causes this node to compute its output estimates (such as number of rows, size in bytes) based on the inputs and the compiler hints. The compiler hints are instantiated with conservative default values which are used if no other values are provided. Nodes may access the statistics to determine relevant information.
 * @param statistics The statistics object which may be accessed to get statistical information. The parameter may be null, if no statistics are available.
 */
public void computeOutputEstimates(DataStatistics statistics){
  boolean allPredsAvailable=true;
  for (  List<PactConnection> incomingConnections : getIncomingConnections()) {
    if (allPredsAvailable) {
      for (      PactConnection incomingConnection : incomingConnections) {
        if (incomingConnection.getSourcePact() == null) {
          allPredsAvailable=false;
          break;
        }
      }
    }
 else {
      break;
    }
  }
  CompilerHints hints=getPactContract().getCompilerHints();
  computeUniqueFields();
  if (!allPredsAvailable) {
    this.estimatedCardinality.putAll(hints.getDistinctCounts());
    this.estimatedNumRecords=0;
    int count=0;
    for (    Entry<FieldSet,Long> cardinality : hints.getDistinctCounts().entrySet()) {
      float avgNumValues=hints.getAvgNumRecordsPerDistinctFields(cardinality.getKey());
      if (avgNumValues != -1) {
        this.estimatedNumRecords+=cardinality.getValue() * avgNumValues;
        count++;
      }
    }
    if (count > 0) {
      this.estimatedNumRecords=(this.estimatedNumRecords / count) >= 1 ? (this.estimatedNumRecords / count) : 1;
    }
 else {
      this.estimatedNumRecords=-1;
    }
    if (this.estimatedNumRecords != -1 && hints.getAvgBytesPerRecord() != -1) {
      this.estimatedOutputSize=(this.estimatedNumRecords * hints.getAvgBytesPerRecord() >= 1) ? (long)(this.estimatedNumRecords * hints.getAvgBytesPerRecord()) : 1;
    }
  }
 else {
    boolean outputCardEstimated=true;
    this.estimatedNumRecords=0;
    int count=0;
    for (    Entry<FieldSet,Long> cardinality : hints.getDistinctCounts().entrySet()) {
      float avgNumValues=hints.getAvgNumRecordsPerDistinctFields(cardinality.getKey());
      if (avgNumValues != -1) {
        this.estimatedNumRecords+=cardinality.getValue() * avgNumValues;
        count++;
      }
    }
    if (count > 0) {
      this.estimatedNumRecords=(this.estimatedNumRecords / count) >= 1 ? (this.estimatedNumRecords / count) : 1;
    }
 else {
      this.estimatedNumRecords=this.computeNumberOfStubCalls();
      if (hints.getAvgRecordsEmittedPerStubCall() != -1.0 && this.computeNumberOfStubCalls() != -1) {
        this.estimatedNumRecords=(this.computeNumberOfStubCalls() * hints.getAvgRecordsEmittedPerStubCall() >= 1) ? (long)(this.computeNumberOfStubCalls() * hints.getAvgRecordsEmittedPerStubCall()) : 1;
      }
 else {
        outputCardEstimated=false;
      }
    }
    this.estimatedCardinality.putAll(hints.getDistinctCounts());
    if (this.getUniqueFields() != null) {
      for (      FieldSet uniqueFieldSet : this.uniqueFields) {
        if (this.estimatedCardinality.get(uniqueFieldSet) == null) {
          this.estimatedCardinality.put(uniqueFieldSet,1L);
        }
      }
    }
    for (int input=0; input < getIncomingConnections().size(); input++) {
      int[] keyColumns;
      if ((keyColumns=getConstantKeySet(input)) != null) {
        long estimatedKeyCardinality;
        if (hints.getAvgRecordsEmittedPerStubCall() < 1.0) {
          double probToKeepKey=1.0 - Math.pow((1.0 - hints.getAvgRecordsEmittedPerStubCall()),this.computeStubCallsPerProcessedKey());
          estimatedKeyCardinality=(this.computeNumberOfProcessedKeys() * probToKeepKey >= 1) ? (long)(this.computeNumberOfProcessedKeys() * probToKeepKey) : 1;
        }
 else {
          estimatedKeyCardinality=this.computeNumberOfProcessedKeys();
        }
        FieldSet fieldSet=new FieldSet(keyColumns);
        if (estimatedCardinality.get(fieldSet) != null) {
          estimatedCardinality.put(fieldSet,estimatedKeyCardinality);
        }
      }
    }
    if (this.estimatedNumRecords != -1) {
      for (      Entry<FieldSet,Float> avgNumValues : hints.getAvgNumRecordsPerDistinctFields().entrySet()) {
        if (estimatedCardinality.get(avgNumValues.getKey()) == null) {
          long estimatedCard=(this.estimatedNumRecords / avgNumValues.getValue() >= 1) ? (long)(this.estimatedNumRecords / avgNumValues.getValue()) : 1;
          estimatedCardinality.put(avgNumValues.getKey(),estimatedCard);
        }
      }
    }
    if (!outputCardEstimated) {
      long newEstimatedNumRecords=0;
      count=0;
      for (      Entry<FieldSet,Long> cardinality : estimatedCardinality.entrySet()) {
        float avgNumValues=hints.getAvgNumRecordsPerDistinctFields(cardinality.getKey());
        if (avgNumValues != -1) {
          newEstimatedNumRecords+=cardinality.getValue() * avgNumValues;
          count++;
        }
      }
      if (count > 0) {
        newEstimatedNumRecords=(newEstimatedNumRecords / count) >= 1 ? (newEstimatedNumRecords / count) : 1;
      }
    }
    double estAvgRecordWidth=this.computeAverageRecordWidth();
    if (this.estimatedNumRecords != -1 && estAvgRecordWidth != -1) {
      this.estimatedOutputSize=(this.estimatedNumRecords * estAvgRecordWidth) >= 1 ? (long)(this.estimatedNumRecords * estAvgRecordWidth) : 1;
    }
    for (    Entry<FieldSet,Long> cardinality : this.estimatedCardinality.entrySet()) {
      if (cardinality.getValue() > this.estimatedNumRecords) {
        cardinality.setValue(this.estimatedNumRecords);
      }
    }
  }
}","/** 
 * Causes this node to compute its output estimates (such as number of rows, size in bytes) based on the inputs and the compiler hints. The compiler hints are instantiated with conservative default values which are used if no other values are provided. Nodes may access the statistics to determine relevant information.
 * @param statistics The statistics object which may be accessed to get statistical information. The parameter may be null, if no statistics are available.
 */
public void computeOutputEstimates(DataStatistics statistics){
  boolean allPredsAvailable=true;
  for (  List<PactConnection> incomingConnections : getIncomingConnections()) {
    if (allPredsAvailable) {
      for (      PactConnection incomingConnection : incomingConnections) {
        if (incomingConnection.getSourcePact() == null) {
          allPredsAvailable=false;
          break;
        }
      }
    }
 else {
      break;
    }
  }
  CompilerHints hints=getPactContract().getCompilerHints();
  computeUniqueFields();
  if (!allPredsAvailable) {
    this.estimatedCardinality.putAll(hints.getDistinctCounts());
    this.estimatedNumRecords=0;
    int count=0;
    for (    Entry<FieldSet,Long> cardinality : hints.getDistinctCounts().entrySet()) {
      float avgNumValues=hints.getAvgNumRecordsPerDistinctFields(cardinality.getKey());
      if (avgNumValues != -1) {
        this.estimatedNumRecords+=cardinality.getValue() * avgNumValues;
        count++;
      }
    }
    if (count > 0) {
      this.estimatedNumRecords=(this.estimatedNumRecords / count) >= 1 ? (this.estimatedNumRecords / count) : 1;
    }
 else {
      this.estimatedNumRecords=-1;
    }
    if (this.estimatedNumRecords != -1 && hints.getAvgBytesPerRecord() != -1) {
      this.estimatedOutputSize=(this.estimatedNumRecords * hints.getAvgBytesPerRecord() >= 1) ? (long)(this.estimatedNumRecords * hints.getAvgBytesPerRecord()) : 1;
    }
  }
 else {
    boolean outputCardEstimated=true;
    this.estimatedNumRecords=0;
    int count=0;
    for (    Entry<FieldSet,Long> cardinality : hints.getDistinctCounts().entrySet()) {
      float avgNumValues=hints.getAvgNumRecordsPerDistinctFields(cardinality.getKey());
      if (avgNumValues != -1) {
        this.estimatedNumRecords+=cardinality.getValue() * avgNumValues;
        count++;
      }
    }
    if (count > 0) {
      this.estimatedNumRecords=(this.estimatedNumRecords / count) >= 1 ? (this.estimatedNumRecords / count) : 1;
    }
 else {
      this.estimatedNumRecords=this.computeNumberOfStubCalls();
      if (hints.getAvgRecordsEmittedPerStubCall() != -1.0 && this.computeNumberOfStubCalls() != -1) {
        this.estimatedNumRecords=(this.computeNumberOfStubCalls() * hints.getAvgRecordsEmittedPerStubCall() >= 1) ? (long)(this.computeNumberOfStubCalls() * hints.getAvgRecordsEmittedPerStubCall()) : 1;
      }
 else {
        outputCardEstimated=false;
      }
    }
    this.estimatedCardinality.putAll(hints.getDistinctCounts());
    if (this.getUniqueFields() != null) {
      for (      FieldSet uniqueFieldSet : this.uniqueFields) {
        if (this.estimatedCardinality.get(uniqueFieldSet) == null) {
          this.estimatedCardinality.put(uniqueFieldSet,this.estimatedNumRecords);
        }
      }
    }
    for (int input=0; input < getIncomingConnections().size(); input++) {
      int[] keyColumns;
      if ((keyColumns=getConstantKeySet(input)) != null) {
        long estimatedKeyCardinality;
        if (hints.getAvgRecordsEmittedPerStubCall() < 1.0) {
          double probToKeepKey=1.0 - Math.pow((1.0 - hints.getAvgRecordsEmittedPerStubCall()),this.computeStubCallsPerProcessedKey());
          estimatedKeyCardinality=(this.computeNumberOfProcessedKeys() * probToKeepKey >= 1) ? (long)(this.computeNumberOfProcessedKeys() * probToKeepKey) : 1;
        }
 else {
          estimatedKeyCardinality=this.computeNumberOfProcessedKeys();
        }
        FieldSet fieldSet=new FieldSet(keyColumns);
        if (estimatedCardinality.get(fieldSet) == null) {
          estimatedCardinality.put(fieldSet,estimatedKeyCardinality);
        }
      }
    }
    if (this.estimatedNumRecords != -1) {
      for (      Entry<FieldSet,Float> avgNumValues : hints.getAvgNumRecordsPerDistinctFields().entrySet()) {
        if (estimatedCardinality.get(avgNumValues.getKey()) == null) {
          long estimatedCard=(this.estimatedNumRecords / avgNumValues.getValue() >= 1) ? (long)(this.estimatedNumRecords / avgNumValues.getValue()) : 1;
          estimatedCardinality.put(avgNumValues.getKey(),estimatedCard);
        }
      }
    }
    if (!outputCardEstimated) {
      long newEstimatedNumRecords=0;
      count=0;
      for (      Entry<FieldSet,Long> cardinality : estimatedCardinality.entrySet()) {
        float avgNumValues=hints.getAvgNumRecordsPerDistinctFields(cardinality.getKey());
        if (avgNumValues != -1) {
          newEstimatedNumRecords+=cardinality.getValue() * avgNumValues;
          count++;
        }
      }
      if (count > 0) {
        newEstimatedNumRecords=(newEstimatedNumRecords / count) >= 1 ? (newEstimatedNumRecords / count) : 1;
      }
    }
    double estAvgRecordWidth=this.computeAverageRecordWidth();
    if (this.estimatedNumRecords != -1 && estAvgRecordWidth != -1) {
      this.estimatedOutputSize=(this.estimatedNumRecords * estAvgRecordWidth) >= 1 ? (long)(this.estimatedNumRecords * estAvgRecordWidth) : 1;
    }
    for (    Entry<FieldSet,Long> cardinality : this.estimatedCardinality.entrySet()) {
      if (cardinality.getValue() > this.estimatedNumRecords) {
        cardinality.setValue(this.estimatedNumRecords);
      }
    }
  }
}"
87807,"/** 
 * {@inheritDoc}
 */
@Override public ConnectionInfoLookupResponse lookupConnectionInfo(final InstanceConnectionInfo caller,final JobID jobID,final ChannelID sourceChannelID){
  final ExecutionGraph eg=this.scheduler.getExecutionGraphByID(jobID);
  if (eg == null) {
    LOG.error(""String_Node_Str"" + jobID);
    return ConnectionInfoLookupResponse.createReceiverNotFound();
  }
  final AbstractOutputChannel<? extends Record> outputChannel=eg.getOutputChannelByID(sourceChannelID);
  if (outputChannel == null) {
    AbstractInputChannel<? extends Record> inputChannel=eg.getInputChannelByID(sourceChannelID);
    final ChannelID connectedChannelID=inputChannel.getConnectedChannelID();
    final ExecutionVertex connectedVertex=eg.getVertexByChannelID(connectedChannelID);
    final AbstractInstance assignedInstance=connectedVertex.getAllocatedResource().getInstance();
    if (assignedInstance == null) {
      LOG.error(""String_Node_Str"" + connectedChannelID + ""String_Node_Str"");
      return ConnectionInfoLookupResponse.createReceiverNotReady();
    }
    final ExecutionState executionState=connectedVertex.getExecutionState();
    if (executionState == ExecutionState.FINISHED) {
      return ConnectionInfoLookupResponse.createReceiverFoundAndReady();
    }
    if (executionState != ExecutionState.RUNNING && executionState != ExecutionState.REPLAYING && executionState != ExecutionState.FINISHING) {
      return ConnectionInfoLookupResponse.createReceiverNotReady();
    }
    if (assignedInstance.getInstanceConnectionInfo().equals(caller)) {
      return ConnectionInfoLookupResponse.createReceiverFoundAndReady(connectedChannelID);
    }
 else {
      return ConnectionInfoLookupResponse.createReceiverFoundAndReady(assignedInstance.getInstanceConnectionInfo());
    }
  }
  if (outputChannel.isBroadcastChannel()) {
    return multicastManager.lookupConnectionInfo(caller,jobID,sourceChannelID);
  }
 else {
    final ExecutionVertex targetVertex=eg.getVertexByChannelID(outputChannel.getConnectedChannelID());
    if (targetVertex == null) {
      LOG.error(""String_Node_Str"" + outputChannel.getConnectedChannelID());
      return ConnectionInfoLookupResponse.createReceiverNotFound();
    }
    final ExecutionState executionState=targetVertex.getExecutionState();
    if (executionState == ExecutionState.FINISHED) {
      return ConnectionInfoLookupResponse.createReceiverFinished();
    }
    if (executionState != ExecutionState.RUNNING && executionState != ExecutionState.REPLAYING && executionState != ExecutionState.FINISHING) {
      return ConnectionInfoLookupResponse.createReceiverNotReady();
    }
    final AbstractInstance assignedInstance=targetVertex.getAllocatedResource().getInstance();
    if (assignedInstance == null) {
      LOG.error(""String_Node_Str"" + outputChannel.getConnectedChannelID() + ""String_Node_Str"");
      return ConnectionInfoLookupResponse.createReceiverNotReady();
    }
    if (assignedInstance.getInstanceConnectionInfo().equals(caller)) {
      return ConnectionInfoLookupResponse.createReceiverFoundAndReady(outputChannel.getConnectedChannelID());
    }
 else {
      return ConnectionInfoLookupResponse.createReceiverFoundAndReady(assignedInstance.getInstanceConnectionInfo());
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public ConnectionInfoLookupResponse lookupConnectionInfo(final InstanceConnectionInfo caller,final JobID jobID,final ChannelID sourceChannelID){
  final ExecutionGraph eg=this.scheduler.getExecutionGraphByID(jobID);
  if (eg == null) {
    LOG.error(""String_Node_Str"" + jobID);
    return ConnectionInfoLookupResponse.createReceiverNotFound();
  }
  final AbstractOutputChannel<? extends Record> outputChannel=eg.getOutputChannelByID(sourceChannelID);
  if (outputChannel == null) {
    AbstractInputChannel<? extends Record> inputChannel=eg.getInputChannelByID(sourceChannelID);
    final ChannelID connectedChannelID=inputChannel.getConnectedChannelID();
    final ExecutionVertex connectedVertex=eg.getVertexByChannelID(connectedChannelID);
    final AbstractInstance assignedInstance=connectedVertex.getAllocatedResource().getInstance();
    if (assignedInstance == null) {
      LOG.error(""String_Node_Str"" + connectedChannelID + ""String_Node_Str"");
      return ConnectionInfoLookupResponse.createReceiverNotReady();
    }
    final ExecutionState executionState=connectedVertex.getExecutionState();
    if (executionState == ExecutionState.FINISHED) {
      return ConnectionInfoLookupResponse.createReceiverFoundAndReady();
    }
    if (executionState != ExecutionState.RUNNING && executionState != ExecutionState.REPLAYING && executionState != ExecutionState.FINISHING) {
      return ConnectionInfoLookupResponse.createReceiverNotReady();
    }
    if (assignedInstance.getInstanceConnectionInfo().equals(caller)) {
      return ConnectionInfoLookupResponse.createReceiverFoundAndReady(connectedChannelID);
    }
 else {
      return ConnectionInfoLookupResponse.createReceiverFoundAndReady(assignedInstance.getInstanceConnectionInfo());
    }
  }
  if (outputChannel.isBroadcastChannel()) {
    return multicastManager.lookupConnectionInfo(caller,jobID,sourceChannelID);
  }
 else {
    final ExecutionVertex targetVertex=eg.getVertexByChannelID(outputChannel.getConnectedChannelID());
    if (targetVertex == null) {
      LOG.error(""String_Node_Str"" + outputChannel.getConnectedChannelID());
      return ConnectionInfoLookupResponse.createReceiverNotFound();
    }
    final ExecutionState executionState=targetVertex.getExecutionState();
    if (executionState != ExecutionState.RUNNING && executionState != ExecutionState.REPLAYING && executionState != ExecutionState.FINISHING && executionState != ExecutionState.FINISHED) {
      return ConnectionInfoLookupResponse.createReceiverNotReady();
    }
    final AbstractInstance assignedInstance=targetVertex.getAllocatedResource().getInstance();
    if (assignedInstance == null) {
      LOG.error(""String_Node_Str"" + outputChannel.getConnectedChannelID() + ""String_Node_Str"");
      return ConnectionInfoLookupResponse.createReceiverNotReady();
    }
    if (assignedInstance.getInstanceConnectionInfo().equals(caller)) {
      return ConnectionInfoLookupResponse.createReceiverFoundAndReady(outputChannel.getConnectedChannelID());
    }
 else {
      return ConnectionInfoLookupResponse.createReceiverFoundAndReady(assignedInstance.getInstanceConnectionInfo());
    }
  }
}"
87808,"public void runIOLoop(){
  long interval=GlobalConfiguration.getInteger(""String_Node_Str"",DEFAULTPERIODICTASKSINTERVAL);
  while (!Thread.interrupted()) {
    try {
      Thread.sleep(interval);
    }
 catch (    InterruptedException e1) {
      LOG.debug(""String_Node_Str"");
      break;
    }
    try {
      this.jobManager.sendHeartbeat(this.localInstanceConnectionInfo,this.hardwareDescription);
    }
 catch (    IOException e) {
      LOG.debug(""String_Node_Str"");
    }
    checkTaskExecution();
    this.byteBufferedChannelManager.cleanUpRecentlyRemovedChannelIDSet();
  }
  shutdown();
}","public void runIOLoop(){
  long interval=GlobalConfiguration.getInteger(""String_Node_Str"",DEFAULTPERIODICTASKSINTERVAL);
  while (!Thread.interrupted()) {
    try {
      Thread.sleep(interval);
    }
 catch (    InterruptedException e1) {
      LOG.debug(""String_Node_Str"");
      break;
    }
    try {
      this.jobManager.sendHeartbeat(this.localInstanceConnectionInfo,this.hardwareDescription);
    }
 catch (    IOException e) {
      LOG.debug(""String_Node_Str"");
    }
    checkTaskExecution();
  }
  shutdown();
}"
87809,"private void sendReceiverNotFoundEvent(final JobID jobID,final ChannelID unknownReceiver){
  if (ChannelID.SYSTEM_ID.equals(unknownReceiver)) {
    LOG.error(""String_Node_Str"");
    return;
  }
  final TransferEnvelope transferEnvelope=new TransferEnvelope(0,jobID,ChannelID.SYSTEM_ID);
  final UnknownReceiverEvent unknownReceiverEvent=new UnknownReceiverEvent(unknownReceiver);
  transferEnvelope.addEvent(unknownReceiverEvent);
  final TransferEnvelopeReceiverList receiverList=getReceiverList(jobID,unknownReceiver);
  if (receiverList == null) {
    LOG.error(""String_Node_Str"" + unknownReceiver);
    return;
  }
  processEnvelopeEnvelopeWithoutBuffer(transferEnvelope,receiverList);
}","private void sendReceiverNotFoundEvent(final TransferEnvelope envelope,final ChannelID unknownReceiver){
  if (ChannelID.SYSTEM_ID.equals(envelope.getSource())) {
    LOG.error(""String_Node_Str"");
    return;
  }
  final JobID jobID=envelope.getJobID();
  final TransferEnvelope transferEnvelope=new TransferEnvelope(0,jobID,ChannelID.SYSTEM_ID);
  final ReceiverNotFoundEvent unknownReceiverEvent=new ReceiverNotFoundEvent(unknownReceiver,envelope.getSequenceNumber());
  transferEnvelope.addEvent(unknownReceiverEvent);
  final TransferEnvelopeReceiverList receiverList=getReceiverList(jobID,unknownReceiver);
  if (receiverList == null) {
    LOG.error(""String_Node_Str"" + unknownReceiver);
    return;
  }
  processEnvelopeEnvelopeWithoutBuffer(transferEnvelope,receiverList);
}"
87810,"/** 
 * Unregisters the given task from the byte buffered channel manager.
 * @param vertexID the ID of the task to be unregistered
 * @param task the task to be unregistered
 */
public void unregister(final ExecutionVertexID vertexID,final Task task){
  final Environment environment=task.getEnvironment();
  this.recentlyRemovedChannelIDSet.add(environment);
  Iterator<ChannelID> channelIterator=environment.getOutputChannelIDs().iterator();
  while (channelIterator.hasNext()) {
    final ChannelID outputChannelID=channelIterator.next();
    final ChannelContext context=this.registeredChannels.remove(outputChannelID);
    if (context != null) {
      context.destroy();
    }
    this.receiverCache.remove(outputChannelID);
  }
  channelIterator=environment.getInputChannelIDs().iterator();
  while (channelIterator.hasNext()) {
    final ChannelID outputChannelID=channelIterator.next();
    final ChannelContext context=this.registeredChannels.remove(outputChannelID);
    if (context != null) {
      context.destroy();
    }
    this.receiverCache.remove(outputChannelID);
  }
  final Iterator<GateID> inputGateIterator=environment.getInputGateIDs().iterator();
  while (inputGateIterator.hasNext()) {
    final GateID inputGateID=inputGateIterator.next();
    final LocalBufferPoolOwner owner=this.localBufferPoolOwner.remove(inputGateID);
    if (owner != null) {
      owner.clearLocalBufferPool();
    }
  }
  final LocalBufferPoolOwner owner=this.localBufferPoolOwner.remove(vertexID);
  if (owner != null) {
    owner.clearLocalBufferPool();
  }
  redistributeGlobalBuffers();
}","/** 
 * Unregisters the given task from the byte buffered channel manager.
 * @param vertexID the ID of the task to be unregistered
 * @param task the task to be unregistered
 */
public void unregister(final ExecutionVertexID vertexID,final Task task){
  final Environment environment=task.getEnvironment();
  Iterator<ChannelID> channelIterator=environment.getOutputChannelIDs().iterator();
  while (channelIterator.hasNext()) {
    final ChannelID outputChannelID=channelIterator.next();
    final ChannelContext context=this.registeredChannels.remove(outputChannelID);
    if (context != null) {
      context.destroy();
    }
    this.receiverCache.remove(outputChannelID);
  }
  channelIterator=environment.getInputChannelIDs().iterator();
  while (channelIterator.hasNext()) {
    final ChannelID outputChannelID=channelIterator.next();
    final ChannelContext context=this.registeredChannels.remove(outputChannelID);
    if (context != null) {
      context.destroy();
    }
    this.receiverCache.remove(outputChannelID);
  }
  final Iterator<GateID> inputGateIterator=environment.getInputGateIDs().iterator();
  while (inputGateIterator.hasNext()) {
    final GateID inputGateID=inputGateIterator.next();
    final LocalBufferPoolOwner owner=this.localBufferPoolOwner.remove(inputGateID);
    if (owner != null) {
      owner.clearLocalBufferPool();
    }
  }
  final LocalBufferPoolOwner owner=this.localBufferPoolOwner.remove(vertexID);
  if (owner != null) {
    owner.clearLocalBufferPool();
  }
  redistributeGlobalBuffers();
}"
87811,"private TransferEnvelopeReceiverList getReceiverList(final JobID jobID,final ChannelID sourceChannelID){
  TransferEnvelopeReceiverList receiverList=this.receiverCache.get(sourceChannelID);
  if (receiverList == null) {
    try {
      while (true) {
        final ConnectionInfoLookupResponse lookupResponse=this.channelLookupService.lookupConnectionInfo(this.localConnectionInfo,jobID,sourceChannelID);
        if (lookupResponse.receiverNotFound()) {
          throw new IOException(""String_Node_Str"" + sourceChannelID);
        }
        if (lookupResponse.receiverNotReady()) {
          Thread.sleep(500);
          continue;
        }
        if (lookupResponse.receiverHasFinished()) {
          break;
        }
        if (lookupResponse.receiverReady()) {
          receiverList=new TransferEnvelopeReceiverList(lookupResponse);
          break;
        }
      }
      if (receiverList != null) {
        this.receiverCache.put(sourceChannelID,receiverList);
        if (LOG.isDebugEnabled()) {
          final StringBuilder sb=new StringBuilder();
          sb.append(""String_Node_Str"" + sourceChannelID + ""String_Node_Str""+ this.localConnectionInfo+ ""String_Node_Str"");
          if (receiverList.hasLocalReceivers()) {
            sb.append(""String_Node_Str"");
            final Iterator<ChannelID> it=receiverList.getLocalReceivers().iterator();
            while (it.hasNext()) {
              sb.append(""String_Node_Str"" + it.next() + ""String_Node_Str"");
            }
          }
          if (receiverList.hasRemoteReceivers()) {
            sb.append(""String_Node_Str"");
            final Iterator<InetSocketAddress> it=receiverList.getRemoteReceivers().iterator();
            while (it.hasNext()) {
              sb.append(""String_Node_Str"" + it.next() + ""String_Node_Str"");
            }
          }
          LOG.debug(sb.toString());
        }
      }
    }
 catch (    InterruptedException ie) {
    }
catch (    IOException ioe) {
    }
  }
  return receiverList;
}","private TransferEnvelopeReceiverList getReceiverList(final JobID jobID,final ChannelID sourceChannelID){
  TransferEnvelopeReceiverList receiverList=this.receiverCache.get(sourceChannelID);
  if (receiverList == null) {
    try {
      while (true) {
        final ConnectionInfoLookupResponse lookupResponse=this.channelLookupService.lookupConnectionInfo(this.localConnectionInfo,jobID,sourceChannelID);
        if (lookupResponse.receiverNotFound()) {
          throw new IOException(""String_Node_Str"" + sourceChannelID);
        }
        if (lookupResponse.receiverNotReady()) {
          Thread.sleep(500);
          continue;
        }
        if (lookupResponse.receiverReady()) {
          receiverList=new TransferEnvelopeReceiverList(lookupResponse);
          break;
        }
      }
      if (receiverList != null) {
        this.receiverCache.put(sourceChannelID,receiverList);
        if (LOG.isDebugEnabled()) {
          final StringBuilder sb=new StringBuilder();
          sb.append(""String_Node_Str"" + sourceChannelID + ""String_Node_Str""+ this.localConnectionInfo+ ""String_Node_Str"");
          if (receiverList.hasLocalReceivers()) {
            sb.append(""String_Node_Str"");
            final Iterator<ChannelID> it=receiverList.getLocalReceivers().iterator();
            while (it.hasNext()) {
              sb.append(""String_Node_Str"" + it.next() + ""String_Node_Str"");
            }
          }
          if (receiverList.hasRemoteReceivers()) {
            sb.append(""String_Node_Str"");
            final Iterator<InetSocketAddress> it=receiverList.getRemoteReceivers().iterator();
            while (it.hasNext()) {
              sb.append(""String_Node_Str"" + it.next() + ""String_Node_Str"");
            }
          }
          LOG.debug(sb.toString());
        }
      }
    }
 catch (    InterruptedException ie) {
    }
catch (    IOException ioe) {
    }
  }
  return receiverList;
}"
87812,"private void processEnvelopeWithBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList,final boolean freeSourceBuffer){
  if (!freeSourceBuffer) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() != 1) {
      LOG.error(""String_Node_Str"");
    }
    final ChannelID localReceiver=localReceivers.get(0);
    final ChannelContext cc=this.registeredChannels.get(localReceiver);
    if (cc == null) {
      if (!this.recentlyRemovedChannelIDSet.contains(localReceiver)) {
        sendReceiverNotFoundEvent(transferEnvelope.getJobID(),localReceiver);
      }
      recycleBuffer(transferEnvelope);
      return;
    }
    if (!cc.isInputChannel()) {
      LOG.error(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
    }
    cc.queueTransferEnvelope(transferEnvelope);
    return;
  }
  final Buffer srcBuffer=transferEnvelope.getBuffer();
  if (receiverList.hasLocalReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    for (    final ChannelID localReceiver : localReceivers) {
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        if (!this.recentlyRemovedChannelIDSet.contains(localReceiver)) {
          sendReceiverNotFoundEvent(transferEnvelope.getJobID(),localReceiver);
        }
        continue;
      }
      if (!cc.isInputChannel()) {
        LOG.error(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
        continue;
      }
      final InputChannelContext inputChannelContext=(InputChannelContext)cc;
      Buffer destBuffer=null;
      try {
        destBuffer=inputChannelContext.requestEmptyBufferBlocking(srcBuffer.size());
        srcBuffer.copyToBuffer(destBuffer);
      }
 catch (      Exception e) {
        LOG.error(StringUtils.stringifyException(e));
        if (destBuffer != null) {
          destBuffer.recycleBuffer();
        }
        continue;
      }
      final TransferEnvelope dup=transferEnvelope.duplicateWithoutBuffer();
      dup.setBuffer(destBuffer);
      inputChannelContext.queueTransferEnvelope(dup);
    }
  }
  if (receiverList.hasRemoteReceivers()) {
    final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
    for (    final InetSocketAddress remoteReceiver : remoteReceivers) {
      TransferEnvelope dup=null;
      try {
        dup=transferEnvelope.duplicate();
      }
 catch (      Exception e) {
        LOG.error(StringUtils.stringifyException(e));
        if (dup != null) {
          recycleBuffer(dup);
          continue;
        }
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,dup);
    }
  }
  srcBuffer.recycleBuffer();
}","private void processEnvelopeWithBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList,final boolean freeSourceBuffer){
  if (!freeSourceBuffer) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() != 1) {
      LOG.error(""String_Node_Str"");
    }
    final ChannelID localReceiver=localReceivers.get(0);
    final ChannelContext cc=this.registeredChannels.get(localReceiver);
    if (cc == null) {
      sendReceiverNotFoundEvent(transferEnvelope,localReceiver);
      recycleBuffer(transferEnvelope);
      return;
    }
    if (!cc.isInputChannel()) {
      LOG.error(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
    }
    cc.queueTransferEnvelope(transferEnvelope);
    return;
  }
  final Buffer srcBuffer=transferEnvelope.getBuffer();
  if (receiverList.hasLocalReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    for (    final ChannelID localReceiver : localReceivers) {
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        sendReceiverNotFoundEvent(transferEnvelope,localReceiver);
        continue;
      }
      if (!cc.isInputChannel()) {
        LOG.error(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
        continue;
      }
      final InputChannelContext inputChannelContext=(InputChannelContext)cc;
      Buffer destBuffer=null;
      try {
        destBuffer=inputChannelContext.requestEmptyBufferBlocking(srcBuffer.size());
        srcBuffer.copyToBuffer(destBuffer);
      }
 catch (      Exception e) {
        LOG.error(StringUtils.stringifyException(e));
        if (destBuffer != null) {
          destBuffer.recycleBuffer();
        }
        continue;
      }
      final TransferEnvelope dup=transferEnvelope.duplicateWithoutBuffer();
      dup.setBuffer(destBuffer);
      inputChannelContext.queueTransferEnvelope(dup);
    }
  }
  if (receiverList.hasRemoteReceivers()) {
    final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
    for (    final InetSocketAddress remoteReceiver : remoteReceivers) {
      TransferEnvelope dup=null;
      try {
        dup=transferEnvelope.duplicate();
      }
 catch (      Exception e) {
        LOG.error(StringUtils.stringifyException(e));
        if (dup != null) {
          recycleBuffer(dup);
          continue;
        }
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,dup);
    }
  }
  srcBuffer.recycleBuffer();
}"
87813,"private boolean processEnvelopeEnvelopeWithoutBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList){
  final Iterator<ChannelID> localIt=receiverList.getLocalReceivers().iterator();
  while (localIt.hasNext()) {
    final ChannelID localReceiver=localIt.next();
    final ChannelContext channelContext=this.registeredChannels.get(localReceiver);
    if (channelContext == null) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + localReceiver + ""String_Node_Str""+ transferEnvelope.getJobID());
      }
      continue;
    }
    channelContext.queueTransferEnvelope(transferEnvelope);
  }
  final Iterator<InetSocketAddress> remoteIt=receiverList.getRemoteReceivers().iterator();
  while (remoteIt.hasNext()) {
    final InetSocketAddress remoteReceiver=remoteIt.next();
    this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,transferEnvelope);
  }
  return true;
}","private boolean processEnvelopeEnvelopeWithoutBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList){
  final Iterator<ChannelID> localIt=receiverList.getLocalReceivers().iterator();
  while (localIt.hasNext()) {
    final ChannelID localReceiver=localIt.next();
    final ChannelContext channelContext=this.registeredChannels.get(localReceiver);
    if (channelContext == null) {
      sendReceiverNotFoundEvent(transferEnvelope,localReceiver);
      continue;
    }
    channelContext.queueTransferEnvelope(transferEnvelope);
  }
  final Iterator<InetSocketAddress> remoteIt=receiverList.getRemoteReceivers().iterator();
  while (remoteIt.hasNext()) {
    final InetSocketAddress remoteReceiver=remoteIt.next();
    this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,transferEnvelope);
  }
  return true;
}"
87814,"@Override public BufferProvider getBufferProvider(final JobID jobID,final ChannelID sourceChannelID) throws IOException, InterruptedException {
  final TransferEnvelopeReceiverList receiverList=getReceiverList(jobID,sourceChannelID);
  if (receiverList.hasLocalReceivers() && !receiverList.hasRemoteReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() == 1) {
      final ChannelID localReceiver=localReceivers.get(0);
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        if (this.recentlyRemovedChannelIDSet.contains(localReceiver)) {
          return this.transitBufferPool;
        }
 else {
          throw new IOException(""String_Node_Str"" + localReceiver);
        }
      }
      if (!cc.isInputChannel()) {
        throw new IOException(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
      }
      final InputChannelContext icc=(InputChannelContext)cc;
      return icc;
    }
  }
  return this.transitBufferPool;
}","@Override public BufferProvider getBufferProvider(final JobID jobID,final ChannelID sourceChannelID) throws IOException, InterruptedException {
  final TransferEnvelopeReceiverList receiverList=getReceiverList(jobID,sourceChannelID);
  if (receiverList.hasLocalReceivers() && !receiverList.hasRemoteReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() == 1) {
      final ChannelID localReceiver=localReceivers.get(0);
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        return this.transitBufferPool;
      }
      if (!cc.isInputChannel()) {
        throw new IOException(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
      }
      final InputChannelContext icc=(InputChannelContext)cc;
      return icc;
    }
  }
  return this.transitBufferPool;
}"
87815,"/** 
 * {@inheritDoc}
 */
@Override public boolean hasDataLeft(){
  return (!this.closeAcknowledgementReceived);
}","/** 
 * {@inheritDoc}
 */
@Override public boolean hasDataLeft(){
  if (this.closeAcknowledgementReceived) {
    return false;
  }
  if ((this.lastSequenceNumberWithReceiverNotFound + 1) == this.sequenceNumber) {
    return false;
  }
  return true;
}"
87816,"/** 
 * {@inheritDoc}
 */
@Override public void processEvent(final AbstractEvent event){
  if (event instanceof ByteBufferedChannelCloseEvent) {
    this.closeAcknowledgementReceived=true;
  }
 else   if (event instanceof AbstractTaskEvent) {
    this.byteBufferedOutputChannel.processEvent(event);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void processEvent(final AbstractEvent event){
  if (event instanceof ByteBufferedChannelCloseEvent) {
    this.closeAcknowledgementReceived=true;
  }
 else   if (event instanceof ReceiverNotFoundEvent) {
    this.lastSequenceNumberWithReceiverNotFound=((ReceiverNotFoundEvent)event).getSequenceNumber();
  }
 else   if (event instanceof AbstractTaskEvent) {
    this.byteBufferedOutputChannel.processEvent(event);
  }
}"
87817,"private void waitForAllOutputBrokerToFinish() throws IOException, InterruptedException {
  while (true) {
    boolean finished=true;
    final Iterator<ReplayOutputBroker> it=this.outputBrokerMap.values().iterator();
    while (it.hasNext()) {
      if (it.next().hasFinished()) {
        finished=false;
      }
    }
    if (finished) {
      break;
    }
    Thread.sleep(SLEEPINTERVAL);
  }
}","private void waitForAllOutputBrokerToFinish() throws IOException, InterruptedException {
  while (true) {
    boolean finished=true;
    final Iterator<ReplayOutputBroker> it=this.outputBrokerMap.values().iterator();
    while (it.hasNext()) {
      if (!it.next().hasFinished()) {
        finished=false;
      }
    }
    if (finished) {
      break;
    }
    Thread.sleep(SLEEPINTERVAL);
  }
}"
87818,"boolean hasFinished(){
  return (!this.forwardingChain.anyForwarderHasDataLeft());
}","boolean hasFinished(){
  this.incomingEventQueue.processQueuedEvents();
  return (!this.forwardingChain.anyForwarderHasDataLeft());
}"
87819,"/** 
 * {@inheritDoc}
 */
@Override public boolean hasDataLeft(){
  return (!this.closeAcknowledgementReceived);
}","/** 
 * {@inheritDoc}
 */
@Override public boolean hasDataLeft(){
  return false;
}"
87820,"/** 
 * {@inheritDoc}
 */
@Override public void processEvent(final AbstractEvent event){
  if (event instanceof ByteBufferedChannelCloseEvent) {
    this.closeAcknowledgementReceived=true;
  }
 else {
    System.out.println(""String_Node_Str"" + event);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void processEvent(final AbstractEvent event){
  if (event instanceof ByteBufferedChannelCloseEvent) {
    LOG.info(""String_Node_Str"");
  }
 else {
    LOG.warn(""String_Node_Str"" + event);
  }
}"
87821,"private static ExecutionState determineOverallExecutionState(final ExecutionState unchangedExecutionState,final ExecutionState changedExecutionState){
  if (changedExecutionState == null) {
    return changedExecutionState;
  }
  if (changedExecutionState == ExecutionState.REPLAYING) {
    if (unchangedExecutionState == ExecutionState.RUNNING) {
      return ExecutionState.REPLAYING;
    }
 else {
      return unchangedExecutionState;
    }
  }
  if (changedExecutionState == ExecutionState.CANCELING) {
    return ExecutionState.CANCELING;
  }
  if (changedExecutionState == ExecutionState.CANCELED && unchangedExecutionState == ExecutionState.CANCELED) {
    return ExecutionState.CANCELED;
  }
  if (changedExecutionState == ExecutionState.FINISHING && unchangedExecutionState == ExecutionState.FINISHING) {
    return ExecutionState.FINISHING;
  }
  if (changedExecutionState == ExecutionState.FINISHED && unchangedExecutionState == ExecutionState.FINISHED) {
    return ExecutionState.FINISHED;
  }
  if (changedExecutionState == ExecutionState.FAILED && unchangedExecutionState == ExecutionState.FAILED) {
    return ExecutionState.FAILED;
  }
  return null;
}","private static ExecutionState determineOverallExecutionState(final ExecutionState unchangedExecutionState,final ExecutionState changedExecutionState){
  if (changedExecutionState == null) {
    return changedExecutionState;
  }
  if (changedExecutionState == ExecutionState.REPLAYING) {
    if (unchangedExecutionState == ExecutionState.RUNNING || unchangedExecutionState == ExecutionState.FINISHING) {
      return ExecutionState.REPLAYING;
    }
 else {
      return unchangedExecutionState;
    }
  }
  if (changedExecutionState == ExecutionState.CANCELING) {
    return ExecutionState.CANCELING;
  }
  if (changedExecutionState == ExecutionState.CANCELED && unchangedExecutionState == ExecutionState.CANCELED) {
    return ExecutionState.CANCELED;
  }
  if (changedExecutionState == ExecutionState.FINISHING && (unchangedExecutionState == ExecutionState.FINISHING || unchangedExecutionState == ExecutionState.FINISHED)) {
    return ExecutionState.FINISHING;
  }
  if (changedExecutionState == ExecutionState.FINISHED && unchangedExecutionState == ExecutionState.FINISHED) {
    return ExecutionState.FINISHED;
  }
  if (changedExecutionState == ExecutionState.FAILED && unchangedExecutionState == ExecutionState.FAILED) {
    return ExecutionState.FAILED;
  }
  return null;
}"
87822,"private void waitForAllOutputBrokerToFinish() throws IOException, InterruptedException {
  while (true) {
    boolean finished=true;
    final Iterator<ReplayOutputBroker> it=this.outputBrokerMap.values().iterator();
    while (it.hasNext()) {
      if (!it.next().hasFinished()) {
        finished=false;
      }
    }
    if (finished) {
      break;
    }
    Thread.sleep(SLEEPINTERVAL);
  }
}","private void waitForAllOutputBrokerToFinish() throws IOException, InterruptedException {
  while (!this.executionObserver.isCanceled()) {
    boolean finished=true;
    final Iterator<ReplayOutputBroker> it=this.outputBrokerMap.values().iterator();
    while (it.hasNext()) {
      if (!it.next().hasFinished()) {
        finished=false;
      }
    }
    if (finished) {
      break;
    }
    Thread.sleep(SLEEPINTERVAL);
  }
}"
87823,"/** 
 * {@inheritDoc}
 */
@Override public boolean isCanceled(){
  if (this.encapsulatedTask != null) {
    if (this.encapsulatedTask.isCanceled()) {
      return true;
    }
  }
  return isCanceled;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isCanceled(){
  if (this.encapsulatedRuntimeTask != null) {
    if (this.encapsulatedRuntimeTask.isCanceled()) {
      return true;
    }
  }
  return isCanceled;
}"
87824,"/** 
 * {@inheritDoc}
 */
@Override public boolean isTerminated(){
  if (this.encapsulatedTask != null) {
    if (this.encapsulatedTask.isTerminated()) {
      return true;
    }
  }
  final Thread executingThread=this.environment.getExecutingThread();
  if (executingThread.getState() == Thread.State.TERMINATED) {
    return true;
  }
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isTerminated(){
  if (this.encapsulatedTask != null) {
    if (this.encapsulatedTask.isTerminated()) {
      if (this.encapsulatedExecutionState != ExecutionState.FINISHED && this.encapsulatedExecutionState != ExecutionState.CANCELED && this.encapsulatedExecutionState != ExecutionState.FAILED) {
        return true;
      }
    }
  }
  final Thread executingThread=this.environment.getExecutingThread();
  if (executingThread.getState() == Thread.State.TERMINATED) {
    if (this.replayTaskExecutionState != ExecutionState.FINISHED && this.replayTaskExecutionState != ExecutionState.CANCELED && this.replayTaskExecutionState != ExecutionState.FAILED) {
      return true;
    }
  }
  return false;
}"
87825,"/** 
 * {@inheritDoc}
 */
@Override public void userThreadFinished(final Thread userThread){
  if (this.encapsulatedTask != null) {
    this.encapsulatedTask.userThreadFinished(userThread);
  }
 else {
    LOG.error(""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void userThreadFinished(final Thread userThread){
  if (this.encapsulatedRuntimeTask != null) {
    this.encapsulatedRuntimeTask.userThreadFinished(userThread);
  }
 else {
    LOG.error(""String_Node_Str"");
  }
}"
87826,"/** 
 * {@inheritDoc}
 */
@Override public void markAsFailed(){
  this.replayTaskExecutionState=ExecutionState.FAILED;
  reportExecutionStateChange(true,""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public void markAsFailed(){
  if (this.encapsulatedTask != null) {
    this.encapsulatedTask.killExecution();
  }
  this.replayTaskExecutionState=ExecutionState.FAILED;
  reportExecutionStateChange(true,""String_Node_Str"");
}"
87827,"private ReplayTaskExecutionObserver(final RuntimeTask encapsulatedTask){
  this.encapsulatedTask=encapsulatedTask;
}","private ReplayTaskExecutionObserver(final RuntimeTask encapsulatedRuntimeTask){
  this.encapsulatedRuntimeTask=encapsulatedRuntimeTask;
}"
87828,"private static ExecutionState determineOverallExecutionState(final ExecutionState unchangedExecutionState,final ExecutionState changedExecutionState){
  if (changedExecutionState == null) {
    return changedExecutionState;
  }
  if (changedExecutionState == ExecutionState.REPLAYING) {
    if (unchangedExecutionState == ExecutionState.RUNNING) {
      return ExecutionState.REPLAYING;
    }
 else {
      return unchangedExecutionState;
    }
  }
  if (changedExecutionState == ExecutionState.CANCELING) {
    return ExecutionState.CANCELING;
  }
  if (changedExecutionState == ExecutionState.CANCELED && unchangedExecutionState == ExecutionState.CANCELED) {
    return ExecutionState.CANCELED;
  }
  if (changedExecutionState == ExecutionState.FINISHING && unchangedExecutionState == ExecutionState.FINISHING) {
    return ExecutionState.FINISHING;
  }
  if (changedExecutionState == ExecutionState.FINISHED && unchangedExecutionState == ExecutionState.FINISHED) {
    return ExecutionState.FINISHED;
  }
  return null;
}","private static ExecutionState determineOverallExecutionState(final ExecutionState unchangedExecutionState,final ExecutionState changedExecutionState){
  if (changedExecutionState == null) {
    return changedExecutionState;
  }
  if (changedExecutionState == ExecutionState.REPLAYING) {
    if (unchangedExecutionState == ExecutionState.RUNNING) {
      return ExecutionState.REPLAYING;
    }
 else {
      return unchangedExecutionState;
    }
  }
  if (changedExecutionState == ExecutionState.CANCELING) {
    return ExecutionState.CANCELING;
  }
  if (changedExecutionState == ExecutionState.CANCELED && unchangedExecutionState == ExecutionState.CANCELED) {
    return ExecutionState.CANCELED;
  }
  if (changedExecutionState == ExecutionState.FINISHING && unchangedExecutionState == ExecutionState.FINISHING) {
    return ExecutionState.FINISHING;
  }
  if (changedExecutionState == ExecutionState.FINISHED && unchangedExecutionState == ExecutionState.FINISHED) {
    return ExecutionState.FINISHED;
  }
  if (changedExecutionState == ExecutionState.FAILED && unchangedExecutionState == ExecutionState.FAILED) {
    return ExecutionState.FAILED;
  }
  return null;
}"
87829,"/** 
 * {@inheritDoc}
 */
@Override public void executionStateChanged(final ExecutionState newExecutionState,final String optionalMessage){
  if (this.encapsulatedTask == null) {
    replayTaskExecutionState=newExecutionState;
  }
 else {
    encapsulatedExecutionState=newExecutionState;
  }
  reportExecutionStateChange((this.encapsulatedTask == null),optionalMessage);
}","/** 
 * {@inheritDoc}
 */
@Override public void executionStateChanged(final ExecutionState newExecutionState,final String optionalMessage){
  if (this.encapsulatedRuntimeTask == null) {
    replayTaskExecutionState=newExecutionState;
    if (newExecutionState == ExecutionState.FAILED) {
      if (encapsulatedTask != null) {
        encapsulatedTask.killExecution();
      }
    }
  }
 else {
    encapsulatedExecutionState=newExecutionState;
    if (newExecutionState == ExecutionState.FAILED) {
      killExecution();
    }
  }
  reportExecutionStateChange((this.encapsulatedRuntimeTask == null),optionalMessage);
}"
87830,"/** 
 * {@inheritDoc}
 */
@Override public void userThreadStarted(final Thread userThread){
  if (this.encapsulatedTask != null) {
    this.encapsulatedTask.userThreadStarted(userThread);
  }
 else {
    LOG.error(""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void userThreadStarted(final Thread userThread){
  if (this.encapsulatedRuntimeTask != null) {
    this.encapsulatedRuntimeTask.userThreadStarted(userThread);
  }
 else {
    LOG.error(""String_Node_Str"");
  }
}"
87831,"/** 
 * This method is periodically called by the framework to check the state of the task threads. If any task thread has unexpectedly switch to TERMINATED, this indicates that an   {@link Error} has occurredduring its execution.
 */
private void checkTaskExecution(){
  final List<Task> failedTasks=new ArrayList<Task>();
synchronized (this.runningTasks) {
    final Iterator<ExecutionVertexID> it=this.runningTasks.keySet().iterator();
    while (it.hasNext()) {
      final ExecutionVertexID executionVertexID=it.next();
      final Task task=this.runningTasks.get(executionVertexID);
      if (task.isTerminated()) {
        it.remove();
        failedTasks.add(task);
      }
    }
  }
  final Iterator<Task> it2=failedTasks.iterator();
  while (it2.hasNext()) {
    it2.next().markAsFailed();
  }
}","/** 
 * This method is periodically called by the framework to check the state of the task threads. If any task thread has unexpectedly switch to TERMINATED, this indicates that an   {@link Error} has occurredduring its execution.
 */
private void checkTaskExecution(){
  final Iterator<Task> it=this.runningTasks.values().iterator();
  while (it.hasNext()) {
    final Task task=it.next();
    if (task.isTerminated()) {
      task.markAsFailed();
    }
  }
}"
87832,"private static final boolean invalidateReceiverLookupCaches(final ExecutionVertex failedVertex,final Set<ExecutionVertex> verticesToBeCanceled){
  final Map<AbstractInstance,Set<ChannelID>> entriesToInvalidate=new HashMap<AbstractInstance,Set<ChannelID>>();
  final ExecutionGraph eg=failedVertex.getExecutionGraph();
  final Environment env=failedVertex.getEnvironment();
  for (int i=0; i < env.getNumberOfOutputGates(); ++i) {
    final OutputGate<? extends Record> outputGate=env.getOutputGate(i);
    for (int j=0; j < outputGate.getNumberOfOutputChannels(); ++j) {
      final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
      if (outputChannel.getType() == ChannelType.FILE) {
        continue;
      }
      final ExecutionVertex connectedVertex=eg.getVertexByChannelID(outputChannel.getConnectedChannelID());
      if (connectedVertex == null) {
        LOG.error(""String_Node_Str"");
        continue;
      }
      if (verticesToBeCanceled.contains(connectedVertex)) {
        continue;
      }
      final AbstractInstance instance=connectedVertex.getAllocatedResource().getInstance();
      Set<ChannelID> channelIDs=entriesToInvalidate.get(instance);
      if (channelIDs == null) {
        channelIDs=new SerializableHashSet<ChannelID>();
        entriesToInvalidate.put(instance,channelIDs);
      }
      channelIDs.add(outputChannel.getID());
    }
  }
  for (int i=0; i < env.getNumberOfInputGates(); ++i) {
    final InputGate<? extends Record> inputGate=env.getInputGate(i);
    for (int j=0; j < inputGate.getNumberOfInputChannels(); ++j) {
      final AbstractInputChannel<? extends Record> inputChannel=inputGate.getInputChannel(j);
      if (inputChannel.getType() == ChannelType.FILE) {
        continue;
      }
      final ExecutionVertex connectedVertex=eg.getVertexByChannelID(inputChannel.getConnectedChannelID());
      if (connectedVertex == null) {
        LOG.error(""String_Node_Str"");
        continue;
      }
      if (verticesToBeCanceled.contains(connectedVertex)) {
        continue;
      }
      final AbstractInstance instance=connectedVertex.getAllocatedResource().getInstance();
      Set<ChannelID> channelIDs=entriesToInvalidate.get(instance);
      if (channelIDs == null) {
        channelIDs=new SerializableHashSet<ChannelID>();
        entriesToInvalidate.put(instance,channelIDs);
      }
      channelIDs.add(inputChannel.getID());
    }
  }
  final Iterator<Map.Entry<AbstractInstance,Set<ChannelID>>> it=entriesToInvalidate.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<AbstractInstance,Set<ChannelID>> entry=it.next();
    final AbstractInstance instance=entry.getKey();
    try {
      instance.invalidateLookupCacheEntries(entry.getValue());
    }
 catch (    IOException ioe) {
      LOG.error(StringUtils.stringifyException(ioe));
      return false;
    }
  }
  return true;
}","private static final boolean invalidateReceiverLookupCaches(final ExecutionVertex failedVertex,final Set<ExecutionVertex> verticesToBeCanceled){
  final Map<AbstractInstance,Set<ChannelID>> entriesToInvalidate=new HashMap<AbstractInstance,Set<ChannelID>>();
  final ExecutionGraph eg=failedVertex.getExecutionGraph();
  final Environment env=failedVertex.getEnvironment();
  for (int i=0; i < env.getNumberOfOutputGates(); ++i) {
    final OutputGate<? extends Record> outputGate=env.getOutputGate(i);
    for (int j=0; j < outputGate.getNumberOfOutputChannels(); ++j) {
      final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
      if (outputChannel.getType() == ChannelType.FILE) {
        continue;
      }
      final ChannelID connectedChannelID=outputChannel.getConnectedChannelID();
      final ExecutionVertex connectedVertex=eg.getVertexByChannelID(connectedChannelID);
      if (connectedVertex == null) {
        LOG.error(""String_Node_Str"");
        continue;
      }
      if (verticesToBeCanceled.contains(connectedVertex)) {
        continue;
      }
      final AbstractInstance instance=connectedVertex.getAllocatedResource().getInstance();
      Set<ChannelID> channelIDs=entriesToInvalidate.get(instance);
      if (channelIDs == null) {
        channelIDs=new SerializableHashSet<ChannelID>();
        entriesToInvalidate.put(instance,channelIDs);
      }
      channelIDs.add(connectedChannelID);
    }
  }
  for (int i=0; i < env.getNumberOfInputGates(); ++i) {
    final InputGate<? extends Record> inputGate=env.getInputGate(i);
    for (int j=0; j < inputGate.getNumberOfInputChannels(); ++j) {
      final AbstractInputChannel<? extends Record> inputChannel=inputGate.getInputChannel(j);
      if (inputChannel.getType() == ChannelType.FILE) {
        continue;
      }
      final ChannelID connectedChannelID=inputChannel.getConnectedChannelID();
      final ExecutionVertex connectedVertex=eg.getVertexByChannelID(connectedChannelID);
      if (connectedVertex == null) {
        LOG.error(""String_Node_Str"");
        continue;
      }
      if (verticesToBeCanceled.contains(connectedVertex)) {
        continue;
      }
      final AbstractInstance instance=connectedVertex.getAllocatedResource().getInstance();
      Set<ChannelID> channelIDs=entriesToInvalidate.get(instance);
      if (channelIDs == null) {
        channelIDs=new SerializableHashSet<ChannelID>();
        entriesToInvalidate.put(instance,channelIDs);
      }
      channelIDs.add(connectedChannelID);
    }
  }
  final Iterator<Map.Entry<AbstractInstance,Set<ChannelID>>> it=entriesToInvalidate.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<AbstractInstance,Set<ChannelID>> entry=it.next();
    final AbstractInstance instance=entry.getKey();
    try {
      instance.invalidateLookupCacheEntries(entry.getValue());
    }
 catch (    IOException ioe) {
      LOG.error(StringUtils.stringifyException(ioe));
      return false;
    }
  }
  return true;
}"
87833,"/** 
 * Cancels all the tasks in the current and upper stages of the given execution graph.
 * @param eg the execution graph representing the job to cancel.
 * @return <code>null</code> no error occurred during the cancel attempt,otherwise the returned object will describe the error
 */
private TaskCancelResult cancelJob(final ExecutionGraph eg){
  TaskCancelResult errorResult=null;
  final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),false,true);
  while (it.hasNext()) {
    final ExecutionVertex vertex=it.next();
    final TaskCancelResult result=vertex.cancelTask();
    if (result.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR) {
      errorResult=result;
    }
  }
  return errorResult;
}","/** 
 * Cancels all the tasks in the current and upper stages of the given execution graph.
 * @param eg the execution graph representing the job to cancel.
 * @return <code>null</code> if no error occurred during the cancel attempt,otherwise the returned object will describe the error
 */
private TaskCancelResult cancelJob(final ExecutionGraph eg){
  TaskCancelResult errorResult=null;
  final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),false,true);
  while (it.hasNext()) {
    final ExecutionVertex vertex=it.next();
    final TaskCancelResult result=vertex.cancelTask();
    if (result.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR) {
      errorResult=result;
    }
  }
  return errorResult;
}"
87834,"/** 
 * {@inheritDoc}
 */
@Override public void vertexAssignmentChanged(final ExecutionVertexID id,final AllocatedResource newAllocatedResource){
  final ManagementVertexID managementVertexID=id.toManagementVertexID();
  final long timestamp=System.currentTimeMillis();
  final AbstractInstance instance=newAllocatedResource.getInstance();
  VertexAssignmentEvent event;
  if (instance == null) {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,""String_Node_Str"",""String_Node_Str"");
  }
 else {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,instance.getName(),instance.getType().getIdentifier());
  }
  this.eventCollector.updateManagementGraph(jobID,event);
  this.eventCollector.addEvent(this.jobID,event);
}","/** 
 * {@inheritDoc}
 */
@Override public void vertexAssignmentChanged(final ExecutionVertexID id,final AllocatedResource newAllocatedResource){
  final ManagementVertexID managementVertexID=id.toManagementVertexID();
  final long timestamp=System.currentTimeMillis();
  final AbstractInstance instance=newAllocatedResource.getInstance();
  VertexAssignmentEvent event;
  if (instance == null) {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,""String_Node_Str"",""String_Node_Str"");
  }
 else {
    String instanceName=null;
    if (instance.getInstanceConnectionInfo() != null) {
      instanceName=instance.getInstanceConnectionInfo().toString();
    }
 else {
      instanceName=instance.toString();
    }
    event=new VertexAssignmentEvent(timestamp,managementVertexID,instanceName,instance.getType().getIdentifier());
  }
  this.eventCollector.updateManagementGraph(jobID,event);
  this.eventCollector.addEvent(this.jobID,event);
}"
87835,"/** 
 * This method computes the costs for an operator. It requires that all inputs are set and have a proper <tt>ShipStrategy</tt> set, which is not equal to <tt>NONE</tt>.
 * @param n The node to compute the costs for.
 */
public void costOperator(OptimizerNode n){
  if (n.getIncomingConnections() == null) {
    throw new CompilerException(""String_Node_Str"");
  }
  List<PactConnection> primConn=null;
  List<PactConnection> secConn=null;
{
    List<List<PactConnection>> conns=n.getIncomingConnections();
    if (conns.size() > 0) {
      primConn=conns.get(0);
    }
    if (conns.size() > 1) {
      secConn=conns.get(1);
    }
  }
  Costs globCost=new Costs();
  Costs locCost=new Costs();
  if (primConn != null && primConn.size() > 0) {
switch (primConn.get(0).getShipStrategy()) {
case NONE:
      throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
    globCost.setNetworkCost(0);
  globCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
for (PactConnection c : primConn) getHashPartitioningCost(c,globCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(primConn,globCost);
break;
case BROADCAST:
for (PactConnection c : primConn) getBroadcastCost(c,globCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + primConn.get(0).getShipStrategy().name());
}
}
 else {
globCost.setNetworkCost(0);
globCost.setSecondaryStorageCost(0);
}
if (secConn != null) {
Costs secCost=new Costs();
switch (secConn.get(0).getShipStrategy()) {
case NONE:
throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
secCost.setNetworkCost(0);
secCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
for (PactConnection c : secConn) getHashPartitioningCost(c,secCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(secConn,secCost);
break;
case BROADCAST:
for (PactConnection c : secConn) getBroadcastCost(c,secCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + secConn.get(0).getShipStrategy().name());
}
globCost.addCosts(secCost);
}
locCost.setNetworkCost(0);
switch (n.getLocalStrategy()) {
case NONE:
locCost.setNetworkCost(0);
locCost.setSecondaryStorageCost(0);
break;
case COMBININGSORT:
case SORT:
getLocalSortCost(n,primConn,locCost);
break;
case SORT_BOTH_MERGE:
getLocalDoubleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_FIRST_MERGE:
getLocalSingleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SECOND_MERGE:
getLocalSingleSortMergeCost(n,secConn,primConn,locCost);
break;
case MERGE:
getLocalMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SELF_NESTEDLOOP:
getLocalSortSelfNestedLoopCost(n,primConn,10,locCost);
break;
case SELF_NESTEDLOOP:
getLocalSelfNestedLoopCost(n,primConn,10,locCost);
break;
case HYBRIDHASH_FIRST:
getHybridHashCosts(n,primConn,secConn,locCost);
break;
case HYBRIDHASH_SECOND:
getHybridHashCosts(n,secConn,primConn,locCost);
break;
case MMHASH_FIRST:
getMainMemHashCosts(n,primConn,secConn,locCost);
break;
case MMHASH_SECOND:
getMainMemHashCosts(n,secConn,primConn,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
getBlockNestedLoopsCosts(n,primConn,secConn,BlockResettableMutableObjectIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
getBlockNestedLoopsCosts(n,secConn,primConn,BlockResettableMutableObjectIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
getStreamedNestedLoopsCosts(n,primConn,secConn,SpillingResettableIterator.MINIMUM_NUMBER_OF_BUFFERS * SpillingResettableIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
getStreamedNestedLoopsCosts(n,secConn,primConn,SpillingResettableIterator.MINIMUM_NUMBER_OF_BUFFERS * SpillingResettableIterator.MIN_BUFFER_SIZE,locCost);
break;
default :
throw new CompilerException(""String_Node_Str"" + n.getLocalStrategy().name());
}
globCost.addCosts(locCost);
n.setCosts(globCost);
}","/** 
 * This method computes the costs for an operator. It requires that all inputs are set and have a proper <tt>ShipStrategy</tt> set, which is not equal to <tt>NONE</tt>.
 * @param n The node to compute the costs for.
 */
public void costOperator(OptimizerNode n){
  if (n.getIncomingConnections() == null) {
    throw new CompilerException(""String_Node_Str"");
  }
  List<PactConnection> primConn=null;
  List<PactConnection> secConn=null;
{
    List<List<PactConnection>> conns=n.getIncomingConnections();
    if (conns.size() > 0) {
      primConn=conns.get(0);
    }
    if (conns.size() > 1) {
      secConn=conns.get(1);
    }
  }
  Costs globCost=new Costs();
  Costs locCost=new Costs();
  if (primConn != null && primConn.size() > 0) {
switch (primConn.get(0).getShipStrategy()) {
case NONE:
      throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
    globCost.setNetworkCost(0);
  globCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
for (PactConnection c : primConn) getHashPartitioningCost(c,globCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(primConn,globCost);
break;
case BROADCAST:
for (PactConnection c : primConn) getBroadcastCost(c,globCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + primConn.get(0).getShipStrategy().name());
}
}
 else {
globCost.setNetworkCost(0);
globCost.setSecondaryStorageCost(0);
}
if (secConn != null && secConn.size() > 0) {
Costs secCost=new Costs();
switch (secConn.get(0).getShipStrategy()) {
case NONE:
throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
secCost.setNetworkCost(0);
secCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
for (PactConnection c : secConn) getHashPartitioningCost(c,secCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(secConn,secCost);
break;
case BROADCAST:
for (PactConnection c : secConn) getBroadcastCost(c,secCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + secConn.get(0).getShipStrategy().name());
}
globCost.addCosts(secCost);
}
locCost.setNetworkCost(0);
switch (n.getLocalStrategy()) {
case NONE:
locCost.setNetworkCost(0);
locCost.setSecondaryStorageCost(0);
break;
case COMBININGSORT:
case SORT:
getLocalSortCost(n,primConn,locCost);
break;
case SORT_BOTH_MERGE:
getLocalDoubleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_FIRST_MERGE:
getLocalSingleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SECOND_MERGE:
getLocalSingleSortMergeCost(n,secConn,primConn,locCost);
break;
case MERGE:
getLocalMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SELF_NESTEDLOOP:
getLocalSortSelfNestedLoopCost(n,primConn,10,locCost);
break;
case SELF_NESTEDLOOP:
getLocalSelfNestedLoopCost(n,primConn,10,locCost);
break;
case HYBRIDHASH_FIRST:
getHybridHashCosts(n,primConn,secConn,locCost);
break;
case HYBRIDHASH_SECOND:
getHybridHashCosts(n,secConn,primConn,locCost);
break;
case MMHASH_FIRST:
getMainMemHashCosts(n,primConn,secConn,locCost);
break;
case MMHASH_SECOND:
getMainMemHashCosts(n,secConn,primConn,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
getBlockNestedLoopsCosts(n,primConn,secConn,BlockResettableMutableObjectIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
getBlockNestedLoopsCosts(n,secConn,primConn,BlockResettableMutableObjectIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
getStreamedNestedLoopsCosts(n,primConn,secConn,SpillingResettableIterator.MINIMUM_NUMBER_OF_BUFFERS * SpillingResettableIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
getStreamedNestedLoopsCosts(n,secConn,primConn,SpillingResettableIterator.MINIMUM_NUMBER_OF_BUFFERS * SpillingResettableIterator.MIN_BUFFER_SIZE,locCost);
break;
default :
throw new CompilerException(""String_Node_Str"" + n.getLocalStrategy().name());
}
globCost.addCosts(locCost);
n.setCosts(globCost);
}"
87836,"/** 
 * Private utility method that generates a candidate Match node, given fixed shipping strategies and a fixed local strategy.
 * @param target The list to put the alternatives in.
 * @param preds1 The predecessor node for the first input.
 * @param preds2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param ls The local strategy.
 * @param outGp The global properties of the data that goes to the user function.
 * @param outLp The local properties of the data that goes to the user function.
 * @param estimator The cost estimator.
 */
private void createMatchAlternative(List<OptimizerNode> target,List<OptimizerNode> preds1,List<OptimizerNode> preds2,ShipStrategy ss1,ShipStrategy ss2,LocalStrategy ls,Order order,boolean grouped,LocalProperties outLpp,CostEstimator estimator){
  GlobalProperties gp1;
  GlobalProperties gp2;
  if (preds1.size() == 1) {
    gp1=PactConnection.getGlobalPropertiesAfterConnection(preds1.get(0),this,ss1);
  }
 else {
    gp1=new GlobalProperties();
  }
  if (preds2.size() == 1) {
    gp2=PactConnection.getGlobalPropertiesAfterConnection(preds2.get(0),this,ss2);
  }
 else {
    gp2=new GlobalProperties();
  }
  int[] keyPositions1=null;
  int[] keyPositions2=null;
  if (ss1 == ShipStrategy.FORWARD && ss2 == ShipStrategy.PARTITION_HASH) {
    keyPositions2=this.input1.get(0).getPartitionedFields();
  }
  if (ss2 == ShipStrategy.FORWARD && ss1 == ShipStrategy.PARTITION_HASH) {
    keyPositions1=this.input2.get(0).getPartitionedFields();
  }
  LocalProperties outLp=outLpp;
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
  outGp.setOrdering(gp1.getOrdering());
  if (outLpp == null) {
    int[] keyColumns=getPactContract().getKeyColumnNumbers(0);
    outLp=new LocalProperties();
    if (order != Order.NONE) {
      Ordering ordering=new Ordering();
      for (      int keyColumn : keyColumns) {
        ordering.appendOrdering(keyColumn,order);
      }
      outLp.setOrdering(ordering);
    }
 else {
      outLp.setOrdering(null);
    }
    outLp.setGrouped(grouped,new FieldSet(keyColumns));
  }
  MatchNode n=new MatchNode(this,preds1,preds2,this.input1,this.input2,outGp,outLp);
  for (  PactConnection c : n.input1) {
    c.setShipStrategy(ss1);
    c.setPartitionedFields(keyPositions1);
  }
  for (  PactConnection c : n.input2) {
    c.setShipStrategy(ss2);
    c.setPartitionedFields(keyPositions2);
  }
  n.setLocalStrategy(ls);
  n.getGlobalProperties().filterByNodesConstantSet(this,0);
  n.getLocalProperties().filterByNodesConstantSet(this,0);
  estimator.costOperator(n);
  target.add(n);
  outGp=new GlobalProperties();
  outGp.setPartitioning(gp2.getPartitioning(),gp2.getPartitionedFields());
  outGp.setOrdering(gp2.getOrdering());
  if (outLpp == null) {
    int[] keyColumns=getPactContract().getKeyColumnNumbers(1);
    outLp=new LocalProperties();
    if (order != Order.NONE) {
      Ordering ordering=new Ordering();
      for (      int keyColumn : keyColumns) {
        ordering.appendOrdering(keyColumn,order);
      }
      outLp.setOrdering(ordering);
    }
 else {
      outLp.setOrdering(null);
    }
    outLp.setGrouped(grouped,new FieldSet(keyColumns));
  }
  n=new MatchNode(this,preds1,preds2,input1,input2,outGp,outLp);
  for (  PactConnection c : n.input1) {
    c.setShipStrategy(ss1);
    c.setPartitionedFields(keyPositions1);
  }
  for (  PactConnection c : n.input2) {
    c.setShipStrategy(ss2);
    c.setPartitionedFields(keyPositions2);
  }
  n.setLocalStrategy(ls);
  n.getGlobalProperties().filterByNodesConstantSet(this,1);
  n.getLocalProperties().filterByNodesConstantSet(this,1);
  estimator.costOperator(n);
  target.add(n);
}","/** 
 * Private utility method that generates a candidate Match node, given fixed shipping strategies and a fixed local strategy.
 * @param target The list to put the alternatives in.
 * @param preds1 The predecessor node for the first input.
 * @param preds2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param ls The local strategy.
 * @param outGp The global properties of the data that goes to the user function.
 * @param outLp The local properties of the data that goes to the user function.
 * @param estimator The cost estimator.
 */
private void createMatchAlternative(List<OptimizerNode> target,List<OptimizerNode> preds1,List<OptimizerNode> preds2,ShipStrategy ss1,ShipStrategy ss2,LocalStrategy ls,Order order,boolean grouped,LocalProperties outLpp,CostEstimator estimator){
  GlobalProperties gp1;
  GlobalProperties gp2;
  if (preds1.size() == 1) {
    gp1=PactConnection.getGlobalPropertiesAfterConnection(preds1.get(0),this,ss1);
  }
 else {
    gp1=new GlobalProperties();
  }
  if (preds2 != null && preds2.size() == 1) {
    gp2=PactConnection.getGlobalPropertiesAfterConnection(preds2.get(0),this,ss2);
  }
 else {
    gp2=new GlobalProperties();
  }
  int[] keyPositions1=null;
  int[] keyPositions2=null;
  if (ss1 == ShipStrategy.FORWARD && ss2 == ShipStrategy.PARTITION_HASH) {
    keyPositions2=this.input1.get(0).getPartitionedFields();
  }
  if (ss2 == ShipStrategy.FORWARD && ss1 == ShipStrategy.PARTITION_HASH) {
    keyPositions1=this.input2.get(0).getPartitionedFields();
  }
  LocalProperties outLp=outLpp;
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning(),gp1.getPartitionedFields());
  outGp.setOrdering(gp1.getOrdering());
  if (outLpp == null) {
    int[] keyColumns=getPactContract().getKeyColumnNumbers(0);
    outLp=new LocalProperties();
    if (order != Order.NONE) {
      Ordering ordering=new Ordering();
      for (      int keyColumn : keyColumns) {
        ordering.appendOrdering(keyColumn,order);
      }
      outLp.setOrdering(ordering);
    }
 else {
      outLp.setOrdering(null);
    }
    outLp.setGrouped(grouped,new FieldSet(keyColumns));
  }
  MatchNode n=new MatchNode(this,preds1,preds2,this.input1,this.input2,outGp,outLp);
  for (  PactConnection c : n.input1) {
    c.setShipStrategy(ss1);
    c.setPartitionedFields(keyPositions1);
  }
  for (  PactConnection c : n.input2) {
    c.setShipStrategy(ss2);
    c.setPartitionedFields(keyPositions2);
  }
  n.setLocalStrategy(ls);
  n.getGlobalProperties().filterByNodesConstantSet(this,0);
  n.getLocalProperties().filterByNodesConstantSet(this,0);
  estimator.costOperator(n);
  target.add(n);
  outGp=new GlobalProperties();
  outGp.setPartitioning(gp2.getPartitioning(),gp2.getPartitionedFields());
  outGp.setOrdering(gp2.getOrdering());
  if (outLpp == null) {
    int[] keyColumns=getPactContract().getKeyColumnNumbers(1);
    outLp=new LocalProperties();
    if (order != Order.NONE) {
      Ordering ordering=new Ordering();
      for (      int keyColumn : keyColumns) {
        ordering.appendOrdering(keyColumn,order);
      }
      outLp.setOrdering(ordering);
    }
 else {
      outLp.setOrdering(null);
    }
    outLp.setGrouped(grouped,new FieldSet(keyColumns));
  }
  n=new MatchNode(this,preds1,preds2,input1,input2,outGp,outLp);
  for (  PactConnection c : n.input1) {
    c.setShipStrategy(ss1);
    c.setPartitionedFields(keyPositions1);
  }
  for (  PactConnection c : n.input2) {
    c.setShipStrategy(ss2);
    c.setPartitionedFields(keyPositions2);
  }
  n.setLocalStrategy(ls);
  n.getGlobalProperties().filterByNodesConstantSet(this,1);
  n.getLocalProperties().filterByNodesConstantSet(this,1);
  estimator.costOperator(n);
  target.add(n);
}"
87837,"/** 
 * Returns the associated   {@link Contract} type for the given {@link Stub} class.
 * @param stubClass the stub class
 * @return the associated Contract type
 */
@SuppressWarnings({""String_Node_Str""}) public static Class<? extends Contract> getContractClass(final Class<?> stubClass){
  final Class<?> contract=STUB_CONTRACTS.get(stubClass);
  if (contract == null && stubClass != null)   return getContractClass(stubClass.getSuperclass());
  return (Class<? extends Contract>)contract;
}","/** 
 * Returns the associated   {@link Contract} type for the given {@link Stub} class.
 * @param stubClass the stub class
 * @return the associated Contract type
 */
@SuppressWarnings({""String_Node_Str""}) public static Class<? extends Contract> getContractClass(final Class<?> stubClass){
  if (stubClass == null)   return null;
  final Class<?> contract=STUB_CONTRACTS.get(stubClass);
  if (contract != null)   return (Class<? extends Contract>)contract;
  Iterator<Entry<Class<?>,Class<? extends Contract>>> stubContracts=STUB_CONTRACTS.entrySet().iterator();
  while (stubContracts.hasNext()) {
    Map.Entry<Class<?>,Class<? extends Contract>> entry=stubContracts.next();
    if (entry.getKey().isAssignableFrom(stubClass))     return entry.getValue();
  }
  return null;
}"
87838,"private void initAdhocInputs() throws IOException {
  for (  final FileDataSource source : this.sources) {
    final TestPairs input=this.getInput(source);
    if (input.isAdhoc())     input.saveToFile(source.getFilePath());
  }
}","private void initAdhocInputs() throws IOException {
  for (  final FileDataSource source : this.sources) {
    final TestRecords input=this.getInput(source);
    if (input.isAdhoc())     input.saveToFile(source.getFilePath());
  }
}"
87839,"/** 
 * Returns the input   {@link TestPairs} associated with the <i>i</i>th inputof the TestPlan. If multiple contracts are tested in the TestPlan, it is recommended to use the  {@link #getInput(GenericDataSource<?>)} method tounambiguously set the values.
 * @param number the number of the input.
 * @return the <i>i</i>th input of the TestPlan
 */
public TestPairs getInput(final int number){
  return this.getInput(this.getDataSources().get(number));
}","/** 
 * Returns the input   {@link TestPairs} associated with the <i>i</i>th inputof the TestPlan. If multiple contracts are tested in the TestPlan, it is recommended to use the  {@link #getInput(GenericDataSource<?>)} method tounambiguously set the values.
 * @param number the number of the input.
 * @return the <i>i</i>th input of the TestPlan
 */
public TestRecords getInput(final int number){
  return this.getInput(this.getDataSources().get(number));
}"
87840,"/** 
 * Returns the output   {@link TestPairs} associated with the <i>i</i>thoutput of the TestPlan. If multiple contracts are tested in the TestPlan, it is recommended to use the  {@link #getActualOutput(GenericDataSink)} method to unambiguously get thevalues.<br> The values are only meaningful after a  {@link #run()}.
 * @param number the number of the output.
 * @return the <i>i</i>th output of the TestPlan
 */
public TestPairs getActualOutput(final int number){
  return this.getActualOutput(this.getDataSinks().get(number));
}","/** 
 * Returns the output   {@link TestPairs} associated with the <i>i</i>thoutput of the TestPlan. If multiple contracts are tested in the TestPlan, it is recommended to use the  {@link #getActualOutput(GenericDataSink)} method to unambiguously get thevalues.<br> The values are only meaningful after a  {@link #run()}.
 * @param number the number of the output.
 * @return the <i>i</i>th output of the TestPlan
 */
public TestRecords getActualOutput(final int number){
  return this.getActualOutput(this.getDataSinks().get(number));
}"
87841,"/** 
 * Returns the expected output   {@link TestPairs} associated with the<i>i</i>th expected output of the TestPlan. If multiple contracts are tested in the TestPlan, it is recommended to use the  {@link #getExpectedOutput(GenericDataSink)} method tounambiguously set the values.
 * @param number the number of the expected output.
 * @return the <i>i</i>th expected output of the TestPlan
 */
public TestPairs getExpectedOutput(final int number,Class<? extends Value>[] schema){
  return this.getExpectedOutput(this.getDataSinks().get(number),schema);
}","/** 
 * Returns the expected output   {@link TestPairs} associated with the<i>i</i>th expected output of the TestPlan. If multiple contracts are tested in the TestPlan, it is recommended to use the  {@link #getExpectedOutput(GenericDataSink)} method tounambiguously set the values.
 * @param number the number of the expected output.
 * @return the <i>i</i>th expected output of the TestPlan
 */
public TestRecords getExpectedOutput(final int number,Class<? extends Value>[] schema){
  return this.getExpectedOutput(this.getDataSinks().get(number),schema);
}"
87842,"@Override public void close() throws IOException {
  ClosableManager closableManager=new ClosableManager();
  for (  TestPairs pairs : this.inputs.values())   closableManager.add(pairs);
  for (  TestPairs pairs : this.actualOutputs.values())   closableManager.add(pairs);
  for (  TestPairs pairs : this.expectedOutputs.values())   closableManager.add(pairs);
  closableManager.close();
}","@Override public void close() throws IOException {
  ClosableManager closableManager=new ClosableManager();
  for (  TestRecords pairs : this.inputs.values())   closableManager.add(pairs);
  for (  TestRecords pairs : this.actualOutputs.values())   closableManager.add(pairs);
  for (  TestRecords pairs : this.expectedOutputs.values())   closableManager.add(pairs);
  closableManager.close();
}"
87843,"/** 
 * Actually builds the plan but guarantees that the output can be read without additional knowledge. Currently the   {@link SequentialOutputFormat} is used for a guaranteeddeserializable output.<br> If a data source is not  {@link SequentialOutputFormat}, it is replaced by a   {@link SplittingOutputFormat}, with two outputs: the original one and one   {@link SequentialOutputFormat}.
 */
private Plan buildPlanWithReadableSinks(){
  final Collection<FileDataSink> existingSinks=this.getDataSinks();
  final Collection<GenericDataSink> wrappedSinks=new ArrayList<GenericDataSink>();
  for (  final FileDataSink fileSink : existingSinks)   if (!fileSink.getFormatClass().equals(SequentialOutputFormat.class)) {
    TestPairs expectedValues=this.expectedOutputs.get(fileSink);
    if (expectedValues == null)     continue;
    final FileDataSink safeSink=createDefaultSink(fileSink.getName());
    safeSink.setInputs(fileSink.getInputs());
    wrappedSinks.add(fileSink);
    wrappedSinks.add(safeSink);
    this.expectedOutputs.put(safeSink,expectedValues);
    this.actualOutputs.put(safeSink,this.getActualOutput(fileSink));
    this.getActualOutput(fileSink).fromFile(SequentialInputFormat.class,safeSink.getFilePath());
  }
 else {
    wrappedSinks.add(fileSink);
    this.getActualOutput(fileSink).fromFile(SequentialInputFormat.class,fileSink.getFilePath());
  }
  return new Plan(wrappedSinks);
}","/** 
 * Actually builds the plan but guarantees that the output can be read without additional knowledge. Currently the   {@link SequentialOutputFormat} is used for a guaranteeddeserializable output.<br> If a data source is not  {@link SequentialOutputFormat}, it is replaced by a   {@link SplittingOutputFormat}, with two outputs: the original one and one   {@link SequentialOutputFormat}.
 */
private Plan buildPlanWithReadableSinks(){
  final Collection<FileDataSink> existingSinks=this.getDataSinks();
  final Collection<GenericDataSink> wrappedSinks=new ArrayList<GenericDataSink>();
  for (  final FileDataSink fileSink : existingSinks)   if (!fileSink.getFormatClass().equals(SequentialOutputFormat.class)) {
    TestRecords expectedValues=this.expectedOutputs.get(fileSink);
    if (expectedValues == null)     continue;
    final FileDataSink safeSink=createDefaultSink(fileSink.getName());
    safeSink.setInputs(fileSink.getInputs());
    wrappedSinks.add(fileSink);
    wrappedSinks.add(safeSink);
    this.expectedOutputs.put(safeSink,expectedValues);
    this.actualOutputs.put(safeSink,this.getActualOutput(fileSink));
    this.getActualOutput(fileSink).fromFile(SequentialInputFormat.class,safeSink.getFilePath());
  }
 else {
    wrappedSinks.add(fileSink);
    this.getActualOutput(fileSink).fromFile(SequentialInputFormat.class,fileSink.getFilePath());
  }
  return new Plan(wrappedSinks);
}"
87844,"private void validateResults(){
  for (  final FileDataSink sinkContract : this.getDataSinks()) {
    TestPairs expectedValues=this.expectedOutputs.get(sinkContract);
    if (sinkContract.getFormatClass() == SequentialOutputFormat.class && expectedValues != null && expectedValues.isInitialized()) {
      final TestPairs actualValues=new TestPairs();
      actualValues.fromFile(SequentialInputFormat.class,sinkContract.getFilePath());
      FuzzyTestValueMatcher fuzzyMatcher=this.getFuzzyMatcher(sinkContract);
      FuzzyTestValueSimilarity fuzzySimilarity=this.getFuzzySimilarity(sinkContract);
      try {
        actualValues.assertEquals(expectedValues,fuzzyMatcher,fuzzySimilarity);
      }
 catch (      AssertionError e) {
        AssertionError assertionError=new AssertionError(sinkContract.getName() + ""String_Node_Str"" + e.getMessage());
        assertionError.initCause(e.getCause());
        throw assertionError;
      }
    }
  }
}","private void validateResults(){
  for (  final FileDataSink sinkContract : this.getDataSinks()) {
    TestRecords expectedValues=this.expectedOutputs.get(sinkContract);
    if (sinkContract.getFormatClass() == SequentialOutputFormat.class && expectedValues != null && expectedValues.isInitialized()) {
      final TestRecords actualValues=new TestRecords();
      actualValues.fromFile(SequentialInputFormat.class,sinkContract.getFilePath());
      FuzzyTestValueMatcher fuzzyMatcher=this.getFuzzyMatcher(sinkContract);
      FuzzyTestValueSimilarity fuzzySimilarity=this.getFuzzySimilarity(sinkContract);
      try {
        actualValues.assertEquals(expectedValues,fuzzyMatcher,fuzzySimilarity);
      }
 catch (      AssertionError e) {
        AssertionError assertionError=new AssertionError(sinkContract.getName() + ""String_Node_Str"" + e.getMessage());
        assertionError.initCause(e.getCause());
        throw assertionError;
      }
    }
  }
}"
87845,"/** 
 * Checks, if this set of properties, as interesting properties, is met by the given properties.
 * @param other The properties for which to check whether they meet these properties.
 * @return True, if the properties are met, false otherwise.
 */
public boolean isMetBy(GlobalProperties other){
  if (this.partitioning != PartitionProperty.NONE) {
    if (this.partitioning == PartitionProperty.ANY) {
      if (other.partitioning == PartitionProperty.NONE) {
        return false;
      }
    }
 else     if (other.partitioning != this.partitioning) {
      return false;
    }
  }
  FieldSet otherPartitionedFields=other.getPartitionedFiels();
  if (this.partitionedFields != null) {
    if (other.partitionedFields == null) {
      return false;
    }
    if (this.partitionedFields.size() > otherPartitionedFields.size()) {
      return false;
    }
    for (    Integer fieldIndex : this.partitionedFields) {
      if (otherPartitionedFields.contains(fieldIndex) == false) {
        return false;
      }
    }
  }
  return (this.ordering == null || this.ordering.isMetBy(other.getOrdering()));
}","/** 
 * Checks, if this set of properties, as interesting properties, is met by the given properties.
 * @param other The properties for which to check whether they meet these properties.
 * @return True, if the properties are met, false otherwise.
 */
public boolean isMetBy(GlobalProperties other){
  if (this.partitioning != PartitionProperty.NONE) {
    if (this.partitioning == PartitionProperty.ANY) {
      if (other.partitioning == PartitionProperty.NONE) {
        return false;
      }
    }
 else     if (other.partitioning != this.partitioning) {
      return false;
    }
  }
  FieldSet otherPartitionedFields=other.getPartitionedFiels();
  if (this.partitionedFields != null) {
    if (other.partitionedFields == null) {
      return false;
    }
    if (this.partitionedFields.size() < otherPartitionedFields.size()) {
      return false;
    }
    if (this.partitionedFields.containsAll(otherPartitionedFields) == false) {
      return false;
    }
  }
  return (this.ordering == null || this.ordering.isMetBy(other.getOrdering()));
}"
87846,"public GlobalProperties clone() throws CloneNotSupportedException {
  return (GlobalProperties)super.clone();
}","public GlobalProperties clone() throws CloneNotSupportedException {
  GlobalProperties newProps=(GlobalProperties)super.clone();
  if (this.ordering != null) {
    newProps.ordering=this.ordering.clone();
  }
  if (this.partitionedFields != null) {
    newProps.partitionedFields=(FieldSet)this.partitionedFields.clone();
  }
  return newProps;
}"
87847,"/** 
 * Checks, if this set of properties, as interesting properties, is met by the given properties.
 * @param other The properties for which to check whether they meet these properties.
 * @return True, if the properties are met, false otherwise.
 */
public boolean isMetBy(LocalProperties other){
  boolean groupingFulfilled=false;
  if (this.grouped) {
    if (other.isGrouped()) {
      groupingFulfilled=this.groupedFields.equals(other.groupedFields);
    }
    if (!groupingFulfilled && other.getOrdering() != null) {
      ArrayList<Integer> otherIndexes=other.getOrdering().getInvolvedIndexes();
      if (groupedFields.size() > otherIndexes.size()) {
        return false;
      }
      for (int i=0; i < groupedFields.size(); i++) {
        if (groupedFields.contains(otherIndexes.get(i)) == false) {
          return false;
        }
      }
    }
  }
  if (groupingFulfilled == false) {
    return false;
  }
  return (this.ordering == null || this.ordering.isMetBy(other.getOrdering()));
}","/** 
 * Checks, if this set of properties, as interesting properties, is met by the given properties.
 * @param other The properties for which to check whether they meet these properties.
 * @return True, if the properties are met, false otherwise.
 */
public boolean isMetBy(LocalProperties other){
  boolean groupingFulfilled=false;
  if (this.grouped) {
    if (other.isGrouped()) {
      groupingFulfilled=this.groupedFields.equals(other.groupedFields);
    }
    if (!groupingFulfilled && other.getOrdering() != null) {
      ArrayList<Integer> otherIndexes=other.getOrdering().getInvolvedIndexes();
      if (groupedFields.size() > otherIndexes.size()) {
        return false;
      }
      for (int i=0; i < groupedFields.size(); i++) {
        if (groupedFields.contains(otherIndexes.get(i)) == false) {
          return false;
        }
      }
      groupingFulfilled=true;
    }
    if (groupingFulfilled == false) {
      return false;
    }
  }
  return (this.ordering == null || this.ordering.isMetBy(other.getOrdering()));
}"
87848,"@Override public LocalProperties clone() throws CloneNotSupportedException {
  return (LocalProperties)super.clone();
}","@Override public LocalProperties clone() throws CloneNotSupportedException {
  LocalProperties newProps=(LocalProperties)super.clone();
  if (this.ordering != null) {
    newProps.ordering=this.ordering.clone();
  }
  if (this.groupedFields != null) {
    newProps.groupedFields=(FieldSet)this.groupedFields.clone();
  }
  return newProps;
}"
87849,"public static final List<InterestingProperties> filterByConstantSet(List<InterestingProperties> props,OptimizerNode node,int input){
  List<InterestingProperties> preserved=new ArrayList<InterestingProperties>();
  for (  InterestingProperties p : props) {
    boolean nonTrivial=p.getGlobalProperties().filterByNodesConstantSet(node,input);
    nonTrivial|=p.getLocalProperties().filterByNodesConstantSet(node,input);
    if (nonTrivial) {
      preserved.add(p);
    }
  }
  return preserved;
}","public static final List<InterestingProperties> filterByConstantSet(List<InterestingProperties> props,OptimizerNode node,int input){
  List<InterestingProperties> preserved=new ArrayList<InterestingProperties>();
  for (  InterestingProperties p : props) {
    GlobalProperties preservedGp=p.getGlobalProperties().createCopy();
    LocalProperties preservedLp=p.getLocalProperties().createCopy();
    boolean nonTrivial=preservedGp.filterByNodesConstantSet(node,input);
    nonTrivial|=preservedLp.filterByNodesConstantSet(node,input);
    if (nonTrivial) {
      try {
        preserved.add(new InterestingProperties(p.getMaximalCosts().clone(),preservedGp,preservedLp));
      }
 catch (      CloneNotSupportedException cnse) {
        throw new RuntimeException(cnse);
      }
    }
  }
  return preserved;
}"
87850,"public boolean isFieldKept(int input,int fieldNumber){
  if (input != 0) {
    throw new IndexOutOfBoundsException();
  }
switch (constantSetMode) {
case Constant:
    return (constantSet != null && Arrays.binarySearch(constantSet,fieldNumber) >= 0);
case Update:
  return (updateSet == null || Arrays.binarySearch(updateSet,fieldNumber) < 0);
default :
return false;
}
}","public boolean isFieldKept(int input,int fieldNumber){
  if (input != 0) {
    throw new IndexOutOfBoundsException();
  }
  if (constantSetMode == null) {
    return false;
  }
switch (constantSetMode) {
case Constant:
    return (constantSet != null && Arrays.binarySearch(constantSet,fieldNumber) >= 0);
case Update:
  return (updateSet == null || Arrays.binarySearch(updateSet,fieldNumber) < 0);
default :
return false;
}
}"
87851,"public boolean isFieldKept(int input,int fieldNumber){
  ConstantSetMode constantSetMode;
  int[] constantSet;
  int[] updateSet;
switch (input) {
case 0:
    constantSetMode=constantSet1Mode;
  constantSet=constantSet1;
updateSet=updateSet1;
break;
case 1:
constantSetMode=constantSet2Mode;
constantSet=constantSet2;
updateSet=updateSet2;
break;
default :
throw new IndexOutOfBoundsException();
}
switch (constantSetMode) {
case Constant:
return (constantSet != null && Arrays.binarySearch(constantSet,fieldNumber) >= 0);
case Update:
return (updateSet == null || Arrays.binarySearch(updateSet,fieldNumber) < 0);
default :
return false;
}
}","public boolean isFieldKept(int input,int fieldNumber){
  ConstantSetMode constantSetMode;
  int[] constantSet;
  int[] updateSet;
switch (input) {
case 0:
    constantSetMode=constantSet1Mode;
  constantSet=constantSet1;
updateSet=updateSet1;
break;
case 1:
constantSetMode=constantSet2Mode;
constantSet=constantSet2;
updateSet=updateSet2;
break;
default :
throw new IndexOutOfBoundsException();
}
if (constantSetMode == null) {
return false;
}
switch (constantSetMode) {
case Constant:
return (constantSet != null && Arrays.binarySearch(constantSet,fieldNumber) >= 0);
case Update:
return (updateSet == null || Arrays.binarySearch(updateSet,fieldNumber) < 0);
default :
return false;
}
}"
87852,"/** 
 * Updates the binary representation of the data, such that it reflects the state of the currently stored fields. If the binary representation is already up to date, nothing happens. Otherwise, this function triggers the modified fields to serialize themselves into the records buffer and afterwards updates the offset table.
 */
public void updateBinaryRepresenation(){
  final int firstModified=this.firstModifiedPos;
  if (firstModified == Integer.MAX_VALUE)   return;
  final InternalDeSerializer serializer=this.serializer;
  final int[] offsets=this.offsets;
  final int numFields=this.numFields;
  if (numFields > 0) {
    int offset=0;
    if (firstModified > 0) {
      for (int i=firstModified - 1; i >= 0; i--) {
        if (this.offsets[i] != NULL_INDICATOR_OFFSET) {
          offset=this.offsets[i] + this.lengths[i];
          break;
        }
      }
    }
    serializer.memory=this.switchBuffer != null ? this.switchBuffer : new byte[numFields * 8];
    serializer.position=offset;
    if (offset > 0) {
      System.arraycopy(this.binaryData,0,serializer.memory,0,offset);
    }
    try {
      for (int i=firstModified; i < numFields; i++) {
        final int co=offsets[i];
        if (co == NULL_INDICATOR_OFFSET)         continue;
        offsets[i]=offset;
        if (co == MODIFIED_INDICATOR_OFFSET)         this.writeFields[i].write(serializer);
 else         serializer.write(this.binaryData,co,this.lengths[i]);
        this.lengths[i]=serializer.position - offset;
        offset=serializer.position;
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
    }
    this.switchBuffer=this.binaryData;
    this.binaryData=serializer.memory;
  }
  try {
    int slp=serializer.position;
    if (numFields <= 8) {
      int mask=0;
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          slp=serializer.position;
          serializer.writeValLenIntBackwards(offsets[i]);
          mask|=0x1;
        }
        mask<<=1;
      }
      if (offsets[0] != NULL_INDICATOR_OFFSET) {
        mask|=0x1;
      }
 else {
        serializer.position=slp;
      }
      serializer.writeByte(mask);
    }
 else {
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          slp=serializer.position;
          serializer.writeValLenIntBackwards(offsets[i]);
        }
      }
      if (offsets[0] == NULL_INDICATOR_OFFSET) {
        serializer.position=slp;
      }
      int col=numFields - 1;
      int mask=0;
      for (int i=numFields & 0x7; i > 0; i--, col--) {
        mask<<=1;
        mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      }
      serializer.writeByte(mask);
      for (int i=numFields >>> 3; i > 0; i--) {
        mask=0;
        for (int k=0; k < 8; k++, col--) {
          mask<<=1;
          mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
        }
        serializer.writeByte(mask);
      }
    }
    serializer.writeValLenIntBackwards(numFields);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
  this.binaryData=serializer.memory;
  this.binaryLen=serializer.position;
  this.firstModifiedPos=Integer.MAX_VALUE;
}","/** 
 * Updates the binary representation of the data, such that it reflects the state of the currently stored fields. If the binary representation is already up to date, nothing happens. Otherwise, this function triggers the modified fields to serialize themselves into the records buffer and afterwards updates the offset table.
 */
public void updateBinaryRepresenation(){
  final int firstModified=this.firstModifiedPos < 0 ? 0 : this.firstModifiedPos;
  if (firstModified == Integer.MAX_VALUE)   return;
  final InternalDeSerializer serializer=this.serializer;
  final int[] offsets=this.offsets;
  final int numFields=this.numFields;
  if (numFields > 0) {
    int offset=0;
    if (firstModified > 0) {
      for (int i=firstModified - 1; i >= 0; i--) {
        if (this.offsets[i] != NULL_INDICATOR_OFFSET) {
          offset=this.offsets[i] + this.lengths[i];
          break;
        }
      }
    }
    serializer.memory=this.switchBuffer != null ? this.switchBuffer : new byte[numFields * 8];
    serializer.position=offset;
    if (offset > 0) {
      System.arraycopy(this.binaryData,0,serializer.memory,0,offset);
    }
    try {
      for (int i=firstModified; i < numFields; i++) {
        final int co=offsets[i];
        if (co == NULL_INDICATOR_OFFSET)         continue;
        offsets[i]=offset;
        if (co == MODIFIED_INDICATOR_OFFSET)         this.writeFields[i].write(serializer);
 else         serializer.write(this.binaryData,co,this.lengths[i]);
        this.lengths[i]=serializer.position - offset;
        offset=serializer.position;
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
    }
    this.switchBuffer=this.binaryData;
    this.binaryData=serializer.memory;
  }
  try {
    int slp=serializer.position;
    if (numFields <= 8) {
      int mask=0;
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          slp=serializer.position;
          serializer.writeValLenIntBackwards(offsets[i]);
          mask|=0x1;
        }
        mask<<=1;
      }
      if (offsets[0] != NULL_INDICATOR_OFFSET) {
        mask|=0x1;
      }
 else {
        serializer.position=slp;
      }
      serializer.writeByte(mask);
    }
 else {
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          slp=serializer.position;
          serializer.writeValLenIntBackwards(offsets[i]);
        }
      }
      if (offsets[0] == NULL_INDICATOR_OFFSET) {
        serializer.position=slp;
      }
      int col=numFields - 1;
      int mask=0;
      for (int i=numFields & 0x7; i > 0; i--, col--) {
        mask<<=1;
        mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      }
      serializer.writeByte(mask);
      for (int i=numFields >>> 3; i > 0; i--) {
        mask=0;
        for (int k=0; k < 8; k++, col--) {
          mask<<=1;
          mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
        }
        serializer.writeByte(mask);
      }
    }
    serializer.writeValLenIntBackwards(numFields);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
  this.binaryData=serializer.memory;
  this.binaryLen=serializer.position;
  this.firstModifiedPos=Integer.MAX_VALUE;
}"
87853,"/** 
 * Creates a new sorter that reads the data from a given reader and provides an iterator returning that data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers automatically. <p> WARNING: The given comparator is used simultaneously in multiple threads (the sorting thread and the merging thread). Make sure that the given comparator is stateless and does not make use of member variables.
 * @param memoryManager The memory manager from which to allocate the memory.
 * @param ioManager The I/O manager, which is used to write temporary files to disk.
 * @param totalMemory The total amount of memory dedicated to sorting, merging and I/O.
 * @param maxWriteMem The maximal amount of memory to be dedicated to writing sorted runs. Will be subtracted from the totalamount of memory (<code>totalMemory</code>).
 * @param numSortBuffers The number of distinct buffers to use creation of the initial runs.
 * @param maxNumFileHandles The maximum number of files to be merged at once.
 * @param keyComparators The comparator used to define the order among the keys.
 * @param keyPositions The logical positions of the keys in the records.
 * @param keyClasses The types of the keys.
 * @param input The input that is sorted by this sorter.
 * @param parentTask The parent task, which owns all resources used by this sorter.
 * @param startSpillingFraction The faction of the buffers that have to be filled before the spilling threadactually begins spilling data to disk.
 * @throws IOException Thrown, if an error occurs initializing the resources for external sorting.
 * @throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager toperform the sort.
 */
public UnilateralSortMerger(MemoryManager memoryManager,IOManager ioManager,long totalMemory,long maxWriteMem,int numSortBuffers,int maxNumFileHandles,Comparator<Key>[] keyComparators,int[] keyPositions,Class<? extends Key>[] keyClasses,MutableObjectIterator<PactRecord> input,AbstractInvokable parentTask,float startSpillingFraction) throws IOException, MemoryAllocationException {
  if (memoryManager == null | ioManager == null | keyComparators == null | keyPositions == null | keyClasses == null) {
    throw new NullPointerException();
  }
  if (parentTask == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (maxNumFileHandles < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (keyComparators.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (keyComparators.length != keyPositions.length || keyPositions.length != keyClasses.length) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (totalMemory < MIN_SORT_MEM + MIN_WRITE_MEM) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.maxNumFileHandles=maxNumFileHandles;
  this.memoryManager=memoryManager;
  this.ioManager=ioManager;
  this.keyComparators=keyComparators;
  this.keyPositions=keyPositions;
  this.keyClasses=keyClasses;
  this.parent=parentTask;
  this.memoryToReleaseAtShutdown=new ArrayList<List<MemorySegment>>();
  this.channelsToDeleteAtShutdown=new ArrayList<Channel.ID>();
  this.openChannels=new ArrayList<BlockChannelAccess<?,?>>();
  if (maxWriteMem != 0) {
    if (maxWriteMem != -1 && maxWriteMem < MIN_WRITE_MEM) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + MIN_WRITE_MEM + ""String_Node_Str"");
    }
    final int minBuffers=NUM_WRITE_BUFFERS + maxNumFileHandles;
    final int desiredBuffers=NUM_WRITE_BUFFERS + 2 * maxNumFileHandles;
    int bufferSize=(int)(totalMemory / desiredBuffers);
    if (bufferSize < MIN_IO_BUFFER_SIZE) {
      bufferSize=MIN_IO_BUFFER_SIZE;
      if (totalMemory / minBuffers < MIN_IO_BUFFER_SIZE) {
        maxNumFileHandles=(int)(totalMemory / MIN_IO_BUFFER_SIZE) - NUM_WRITE_BUFFERS;
        if (LOG.isWarnEnabled())         LOG.warn(""String_Node_Str"" + maxNumFileHandles + ""String_Node_Str"");
      }
    }
 else {
      bufferSize=Math.min(MAX_IO_BUFFER_SIZE,MathUtils.roundDownToPowerOf2(bufferSize));
    }
    if (maxWriteMem < 0) {
      maxWriteMem=Math.max(totalMemory / 64,MIN_WRITE_MEM);
    }
    this.ioBufferSize=Math.min(bufferSize,MathUtils.roundDownToPowerOf2((int)(maxWriteMem / NUM_WRITE_BUFFERS)));
    maxWriteMem=NUM_WRITE_BUFFERS * this.ioBufferSize;
  }
 else {
    this.ioBufferSize=-1;
  }
  final long sortMem=totalMemory - maxWriteMem;
  final long numSortMemSegments=sortMem / SORT_MEM_SEGMENT_SIZE;
  if (numSortBuffers < 1) {
    if (sortMem > 96 * 1024 * 1024) {
      numSortBuffers=3;
    }
 else     if (numSortMemSegments >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {
      numSortBuffers=2;
    }
 else {
      numSortBuffers=1;
    }
  }
  final int numSegmentsPerSortBuffer=numSortMemSegments / numSortBuffers > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)(numSortMemSegments / numSortBuffers);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + maxWriteMem + ""String_Node_Str""+ sortMem+ ""String_Node_Str""+ numSortBuffers+ ""String_Node_Str""+ numSegmentsPerSortBuffer+ ""String_Node_Str""+ SORT_MEM_SEGMENT_SIZE+ ""String_Node_Str""+ maxNumFileHandles+ ""String_Node_Str"");
  }
  final CircularQueues circularQueues=new CircularQueues();
  this.sortBuffers=new ArrayList<NormalizedKeySorter<?>>(numSortBuffers);
  final PactRecordAccessors accessors=new PactRecordAccessors(keyPositions,keyClasses);
  for (int i=0; i < numSortBuffers; i++) {
    final List<MemorySegment> sortSegments=memoryManager.allocateStrict(parentTask,numSegmentsPerSortBuffer,SORT_MEM_SEGMENT_SIZE);
    final NormalizedKeySorter<PactRecord> buffer=new NormalizedKeySorter<PactRecord>(accessors,sortSegments);
    this.sortBuffers.add(buffer);
    CircularElement element=new CircularElement(i,buffer);
    circularQueues.empty.add(element);
  }
  ExceptionHandler<IOException> exceptionHandler=new ExceptionHandler<IOException>(){
    public void handleException(    IOException exception){
      if (!closed) {
        setResultIteratorException(exception);
        close();
      }
    }
  }
;
  this.readThread=getReadingThread(exceptionHandler,input,circularQueues,parentTask,((long)(startSpillingFraction * sortMem)));
  this.sortThread=getSortingThread(exceptionHandler,circularQueues,parentTask);
  this.spillThread=getSpillingThread(exceptionHandler,circularQueues,memoryManager,ioManager,sortMem,parentTask);
  startThreads();
}","/** 
 * Creates a new sorter that reads the data from a given reader and provides an iterator returning that data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers automatically. <p> WARNING: The given comparator is used simultaneously in multiple threads (the sorting thread and the merging thread). Make sure that the given comparator is stateless and does not make use of member variables.
 * @param memoryManager The memory manager from which to allocate the memory.
 * @param ioManager The I/O manager, which is used to write temporary files to disk.
 * @param totalMemory The total amount of memory dedicated to sorting, merging and I/O.
 * @param maxWriteMem The maximal amount of memory to be dedicated to writing sorted runs. Will be subtracted from the totalamount of memory (<code>totalMemory</code>).
 * @param numSortBuffers The number of distinct buffers to use creation of the initial runs.
 * @param maxNumFileHandles The maximum number of files to be merged at once.
 * @param keyComparators The comparator used to define the order among the keys.
 * @param keyPositions The logical positions of the keys in the records.
 * @param keyClasses The types of the keys.
 * @param input The input that is sorted by this sorter.
 * @param parentTask The parent task, which owns all resources used by this sorter.
 * @param startSpillingFraction The faction of the buffers that have to be filled before the spilling threadactually begins spilling data to disk.
 * @throws IOException Thrown, if an error occurs initializing the resources for external sorting.
 * @throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager toperform the sort.
 */
public UnilateralSortMerger(MemoryManager memoryManager,IOManager ioManager,long totalMemory,long maxWriteMem,int numSortBuffers,int maxNumFileHandles,Comparator<Key>[] keyComparators,int[] keyPositions,Class<? extends Key>[] keyClasses,MutableObjectIterator<PactRecord> input,AbstractInvokable parentTask,float startSpillingFraction) throws IOException, MemoryAllocationException {
  if (memoryManager == null | ioManager == null | keyComparators == null | keyPositions == null | keyClasses == null) {
    throw new NullPointerException();
  }
  if (parentTask == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (maxNumFileHandles < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (keyComparators.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (keyComparators.length != keyPositions.length || keyPositions.length != keyClasses.length) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (totalMemory < MIN_SORT_MEM + MIN_WRITE_MEM) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.maxNumFileHandles=maxNumFileHandles;
  this.memoryManager=memoryManager;
  this.ioManager=ioManager;
  this.keyComparators=keyComparators;
  this.keyPositions=keyPositions;
  this.keyClasses=keyClasses;
  this.parent=parentTask;
  this.memoryToReleaseAtShutdown=new ArrayList<List<MemorySegment>>();
  this.channelsToDeleteAtShutdown=new ArrayList<Channel.ID>();
  this.openChannels=new ArrayList<BlockChannelAccess<?,?>>();
  if (maxWriteMem != 0) {
    if (maxWriteMem != -1 && maxWriteMem < MIN_WRITE_MEM) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + MIN_WRITE_MEM + ""String_Node_Str"");
    }
    final int minBuffers=NUM_WRITE_BUFFERS + maxNumFileHandles;
    final int desiredBuffers=NUM_WRITE_BUFFERS + 2 * maxNumFileHandles;
    int bufferSize=(int)(totalMemory / desiredBuffers);
    if (bufferSize < MIN_IO_BUFFER_SIZE) {
      bufferSize=MIN_IO_BUFFER_SIZE;
      if (totalMemory / minBuffers < MIN_IO_BUFFER_SIZE) {
        maxNumFileHandles=(int)(totalMemory / MIN_IO_BUFFER_SIZE) - NUM_WRITE_BUFFERS;
        if (LOG.isWarnEnabled())         LOG.warn(""String_Node_Str"" + maxNumFileHandles + ""String_Node_Str"");
      }
    }
 else {
      bufferSize=Math.min(MAX_IO_BUFFER_SIZE,MathUtils.roundDownToPowerOf2(bufferSize));
    }
    if (maxWriteMem < 0) {
      maxWriteMem=Math.max(totalMemory / 64,MIN_WRITE_MEM);
    }
    this.ioBufferSize=Math.min(bufferSize,MathUtils.roundDownToPowerOf2((int)(maxWriteMem / NUM_WRITE_BUFFERS)));
    maxWriteMem=NUM_WRITE_BUFFERS * this.ioBufferSize;
  }
 else {
    this.ioBufferSize=-1;
  }
  final long sortMem=totalMemory - maxWriteMem;
  final long numSortMemSegments=sortMem / SORT_MEM_SEGMENT_SIZE;
  if (numSortBuffers < 1) {
    if (sortMem > 96 * 1024 * 1024) {
      numSortBuffers=3;
    }
 else     if (numSortMemSegments >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {
      numSortBuffers=2;
    }
 else {
      numSortBuffers=1;
    }
  }
  final int numSegmentsPerSortBuffer=numSortMemSegments / numSortBuffers > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)(numSortMemSegments / numSortBuffers);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + maxWriteMem + ""String_Node_Str""+ sortMem+ ""String_Node_Str""+ numSortBuffers+ ""String_Node_Str""+ numSegmentsPerSortBuffer+ ""String_Node_Str""+ SORT_MEM_SEGMENT_SIZE+ ""String_Node_Str""+ maxNumFileHandles+ ""String_Node_Str"");
  }
  final CircularQueues circularQueues=new CircularQueues();
  this.sortBuffers=new ArrayList<NormalizedKeySorter<?>>(numSortBuffers);
  for (int i=0; i < numSortBuffers; i++) {
    final List<MemorySegment> sortSegments=memoryManager.allocateStrict(parentTask,numSegmentsPerSortBuffer,SORT_MEM_SEGMENT_SIZE);
    final PactRecordAccessors accessors=new PactRecordAccessors(keyPositions,keyClasses);
    final NormalizedKeySorter<PactRecord> buffer=new NormalizedKeySorter<PactRecord>(accessors,sortSegments);
    this.sortBuffers.add(buffer);
    CircularElement element=new CircularElement(i,buffer);
    circularQueues.empty.add(element);
  }
  ExceptionHandler<IOException> exceptionHandler=new ExceptionHandler<IOException>(){
    public void handleException(    IOException exception){
      if (!closed) {
        setResultIteratorException(exception);
        close();
      }
    }
  }
;
  this.readThread=getReadingThread(exceptionHandler,input,circularQueues,parentTask,((long)(startSpillingFraction * sortMem)));
  this.sortThread=getSortingThread(exceptionHandler,circularQueues,parentTask);
  this.spillThread=getSpillingThread(exceptionHandler,circularQueues,memoryManager,ioManager,sortMem,parentTask);
  startThreads();
}"
87854,"/** 
 * Updates the binary representation of the data, such that it reflects the state of the currently stored fields. If the binary representation is already up to date, nothing happens. Otherwise, this function triggers the modified fields to serialize themselves into the records buffer and afterwards updates the offset table.
 */
public void updateBinaryRepresenation(){
  final int firstModified=this.firstModifiedPos < 0 ? 0 : this.firstModifiedPos;
  if (firstModified == Integer.MAX_VALUE)   return;
  final InternalDeSerializer serializer=this.serializer;
  final int[] offsets=this.offsets;
  final int numFields=this.numFields;
  if (numFields > 0) {
    int offset=0;
    if (firstModified > 0) {
      for (int i=firstModified - 1; i >= 0; i--) {
        if (this.offsets[i] != NULL_INDICATOR_OFFSET) {
          offset=this.offsets[i] + this.lengths[i];
          break;
        }
      }
    }
    serializer.memory=this.switchBuffer != null ? this.switchBuffer : new byte[numFields * 8];
    serializer.position=offset;
    if (offset > 0) {
      System.arraycopy(this.binaryData,0,serializer.memory,0,offset);
    }
    try {
      for (int i=firstModified; i < numFields; i++) {
        final int co=offsets[i];
        if (co == NULL_INDICATOR_OFFSET)         continue;
        offsets[i]=offset;
        if (co == MODIFIED_INDICATOR_OFFSET)         this.writeFields[i].write(serializer);
 else         serializer.write(this.binaryData,co,this.lengths[i]);
        this.lengths[i]=serializer.position - offset;
        offset=serializer.position;
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
    }
    this.switchBuffer=this.binaryData;
    this.binaryData=serializer.memory;
  }
  try {
    int slp=serializer.position;
    if (numFields <= 8) {
      int mask=0;
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          slp=serializer.position;
          serializer.writeValLenIntBackwards(offsets[i]);
          mask|=0x1;
        }
        mask<<=1;
      }
      if (offsets[0] != NULL_INDICATOR_OFFSET) {
        mask|=0x1;
      }
 else {
        serializer.position=slp;
      }
      serializer.writeByte(mask);
    }
 else {
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          slp=serializer.position;
          serializer.writeValLenIntBackwards(offsets[i]);
        }
      }
      if (offsets[0] == NULL_INDICATOR_OFFSET) {
        serializer.position=slp;
      }
      int col=numFields - 1;
      int mask=0;
      for (int i=numFields & 0x7; i > 0; i--, col--) {
        mask<<=1;
        mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      }
      serializer.writeByte(mask);
      for (int i=numFields >>> 3; i > 0; i--) {
        mask=0;
        for (int k=0; k < 8; k++, col--) {
          mask<<=1;
          mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
        }
        serializer.writeByte(mask);
      }
    }
    serializer.writeValLenIntBackwards(numFields);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
  this.binaryData=serializer.memory;
  this.binaryLen=serializer.position;
  this.firstModifiedPos=Integer.MAX_VALUE;
}","/** 
 * Updates the binary representation of the data, such that it reflects the state of the currently stored fields. If the binary representation is already up to date, nothing happens. Otherwise, this function triggers the modified fields to serialize themselves into the records buffer and afterwards updates the offset table.
 */
public void updateBinaryRepresenation(){
  final int firstModified=this.firstModifiedPos < 0 ? 0 : this.firstModifiedPos;
  if (firstModified == Integer.MAX_VALUE)   return;
  final InternalDeSerializer serializer=this.serializer;
  final int[] offsets=this.offsets;
  final int numFields=this.numFields;
  if (numFields > 0) {
    int offset=0;
    if (firstModified > 0) {
      for (int i=firstModified - 1; i >= 0; i--) {
        if (this.offsets[i] != NULL_INDICATOR_OFFSET) {
          offset=this.offsets[i] + this.lengths[i];
          break;
        }
      }
    }
    serializer.memory=this.switchBuffer != null ? this.switchBuffer : new byte[numFields * 8];
    serializer.position=offset;
    if (offset > 0) {
      System.arraycopy(this.binaryData,0,serializer.memory,0,offset);
    }
    try {
      for (int i=firstModified; i < numFields; i++) {
        final int co=offsets[i];
        if (co == NULL_INDICATOR_OFFSET)         continue;
        offsets[i]=offset;
        if (co == MODIFIED_INDICATOR_OFFSET)         this.writeFields[i].write(serializer);
 else         serializer.write(this.binaryData,co,this.lengths[i]);
        this.lengths[i]=serializer.position - offset;
        offset=serializer.position;
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
    }
    this.switchBuffer=this.binaryData;
    this.binaryData=serializer.memory;
  }
  try {
    int slp=serializer.position;
    if (numFields <= 8) {
      int mask=0;
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          slp=serializer.position;
          serializer.writeValLenIntBackwards(offsets[i]);
          mask|=0x1;
        }
        mask<<=1;
      }
      if (offsets[0] != NULL_INDICATOR_OFFSET) {
        mask|=0x1;
      }
 else {
        serializer.position=slp;
      }
      serializer.writeByte(mask);
    }
 else {
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          slp=serializer.position;
          serializer.writeValLenIntBackwards(offsets[i]);
        }
      }
      if (offsets[0] == NULL_INDICATOR_OFFSET) {
        serializer.position=slp;
      }
      int col=numFields - 1;
      int mask=0;
      int i=numFields & 0x7;
      if (i > 0) {
        for (; i > 0; i--, col--) {
          mask<<=1;
          mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
        }
        serializer.writeByte(mask);
      }
      for (i=numFields >>> 3; i > 0; i--) {
        mask=0;
        for (int k=0; k < 8; k++, col--) {
          mask<<=1;
          mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
        }
        serializer.writeByte(mask);
      }
    }
    serializer.writeValLenIntBackwards(numFields);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
  this.binaryData=serializer.memory;
  this.binaryLen=serializer.position;
  this.firstModifiedPos=Integer.MAX_VALUE;
}"
87855,"/** 
 * Checks, if this set of properties, as interesting properties, is met by the given properties.
 * @param other The properties for which to check whether they meet these properties.
 * @return True, if the properties are met, false otherwise.
 */
public boolean isMetBy(GlobalProperties other){
  if (this.partitioning != PartitionProperty.NONE) {
    if (this.partitioning == PartitionProperty.ANY) {
      if (other.partitioning == PartitionProperty.NONE) {
        return false;
      }
    }
 else     if (other.partitioning != this.partitioning) {
      return false;
    }
  }
  FieldSet otherPartitionedFields=other.getPartitionedFiels();
  if (this.partitionedFields != null) {
    if (other.partitionedFields == null) {
      return false;
    }
    if (this.partitionedFields.size() > otherPartitionedFields.size()) {
      return false;
    }
    for (    Integer fieldIndex : this.partitionedFields) {
      if (otherPartitionedFields.contains(fieldIndex) == false) {
        return false;
      }
    }
  }
  return this.ordering.isMetBy(other.getOrdering());
}","/** 
 * Checks, if this set of properties, as interesting properties, is met by the given properties.
 * @param other The properties for which to check whether they meet these properties.
 * @return True, if the properties are met, false otherwise.
 */
public boolean isMetBy(GlobalProperties other){
  if (this.partitioning != PartitionProperty.NONE) {
    if (this.partitioning == PartitionProperty.ANY) {
      if (other.partitioning == PartitionProperty.NONE) {
        return false;
      }
    }
 else     if (other.partitioning != this.partitioning) {
      return false;
    }
  }
  FieldSet otherPartitionedFields=other.getPartitionedFiels();
  if (this.partitionedFields != null) {
    if (other.partitionedFields == null) {
      return false;
    }
    if (this.partitionedFields.size() > otherPartitionedFields.size()) {
      return false;
    }
    for (    Integer fieldIndex : this.partitionedFields) {
      if (otherPartitionedFields.contains(fieldIndex) == false) {
        return false;
      }
    }
  }
  return (this.ordering == null || this.ordering.isMetBy(other.getOrdering()));
}"
87856,"/** 
 * Checks, if this set of properties, as interesting properties, is met by the given properties.
 * @param other The properties for which to check whether they meet these properties.
 * @return True, if the properties are met, false otherwise.
 */
public boolean isMetBy(LocalProperties other){
  boolean groupingFulfilled=false;
  if (this.grouped) {
    if (other.isGrouped()) {
      groupingFulfilled=this.groupedFields.equals(other.groupedFields);
    }
    if (!groupingFulfilled && other.getOrdering() != null) {
      ArrayList<Integer> otherIndexes=other.getOrdering().getInvolvedIndexes();
      if (groupedFields.size() > otherIndexes.size()) {
        return false;
      }
      for (int i=0; i < groupedFields.size(); i++) {
        if (groupedFields.contains(otherIndexes.get(i)) == false) {
          return false;
        }
      }
    }
  }
  if (groupingFulfilled == false) {
    return false;
  }
  return this.ordering.isMetBy(other.getOrdering());
}","/** 
 * Checks, if this set of properties, as interesting properties, is met by the given properties.
 * @param other The properties for which to check whether they meet these properties.
 * @return True, if the properties are met, false otherwise.
 */
public boolean isMetBy(LocalProperties other){
  boolean groupingFulfilled=false;
  if (this.grouped) {
    if (other.isGrouped()) {
      groupingFulfilled=this.groupedFields.equals(other.groupedFields);
    }
    if (!groupingFulfilled && other.getOrdering() != null) {
      ArrayList<Integer> otherIndexes=other.getOrdering().getInvolvedIndexes();
      if (groupedFields.size() > otherIndexes.size()) {
        return false;
      }
      for (int i=0; i < groupedFields.size(); i++) {
        if (groupedFields.contains(otherIndexes.get(i)) == false) {
          return false;
        }
      }
    }
  }
  if (groupingFulfilled == false) {
    return false;
  }
  return (this.ordering == null || this.ordering.isMetBy(other.getOrdering()));
}"
87857,"/** 
 * Gets the global properties of the source's output after it crossed a pact connection with the given shipping strategy. Global properties are maintained on <tt>FORWARD</tt> connections. If a partitioning happens, then a partitioning property exists afterwards. A <tt>BROADCAST</tt> connection destroys the key uniqueness. <p> If the shipping strategy has not yet been determined, the properties of the connections source are returned.
 * @return The properties of the data after this channel.
 */
public static GlobalProperties getGlobalPropertiesAfterConnection(OptimizerNode source,OptimizerNode target,ShipStrategy shipMode){
  GlobalProperties gp=source.getGlobalProperties().createCopy();
  int inputNum=0;
  FieldSet keyFields=null;
  for (  List<PactConnection> connections : target.getIncomingConnections()) {
    boolean isThisConnection=false;
    for (    PactConnection connection : connections) {
      if (connection.getSourcePact().equals(source)) {
        if (target.getPactContract() instanceof AbstractPact<?>) {
          keyFields=new FieldSet(((AbstractPact<?>)target.getPactContract()).getKeyColumnNumbers(inputNum));
        }
        break;
      }
    }
    if (isThisConnection) {
      break;
    }
 else {
      inputNum++;
    }
  }
switch (shipMode) {
case BROADCAST:
    gp.reset();
  break;
case PARTITION_RANGE:
gp.setPartitioning(PartitionProperty.RANGE_PARTITIONED,keyFields);
break;
case PARTITION_HASH:
gp.setPartitioning(PartitionProperty.HASH_PARTITIONED,keyFields);
gp.setOrdering(null);
break;
case FORWARD:
if (source.getDegreeOfParallelism() > target.getDegreeOfParallelism()) {
gp.setOrdering(null);
}
break;
case NONE:
throw new CompilerException(""String_Node_Str"");
case SFR:
default :
throw new CompilerException(""String_Node_Str"" + shipMode.name());
}
return gp;
}","/** 
 * Gets the global properties of the source's output after it crossed a pact connection with the given shipping strategy. Global properties are maintained on <tt>FORWARD</tt> connections. If a partitioning happens, then a partitioning property exists afterwards. A <tt>BROADCAST</tt> connection destroys the key uniqueness. <p> If the shipping strategy has not yet been determined, the properties of the connections source are returned.
 * @return The properties of the data after this channel.
 */
public static GlobalProperties getGlobalPropertiesAfterConnection(OptimizerNode source,OptimizerNode target,ShipStrategy shipMode){
  GlobalProperties gp=source.getGlobalProperties().createCopy();
  int inputNum=0;
  FieldSet keyFields=null;
  for (  List<PactConnection> connections : target.getIncomingConnections()) {
    boolean isThisConnection=false;
    for (    PactConnection connection : connections) {
      if (connection.getSourcePact().getId() == source.getId()) {
        if (target.getPactContract() instanceof AbstractPact<?>) {
          keyFields=new FieldSet(((AbstractPact<?>)target.getPactContract()).getKeyColumnNumbers(inputNum));
        }
        break;
      }
    }
    if (isThisConnection) {
      break;
    }
 else {
      inputNum++;
    }
  }
switch (shipMode) {
case BROADCAST:
    gp.reset();
  break;
case PARTITION_RANGE:
gp.setPartitioning(PartitionProperty.RANGE_PARTITIONED,keyFields);
break;
case PARTITION_HASH:
gp.setPartitioning(PartitionProperty.HASH_PARTITIONED,keyFields);
gp.setOrdering(null);
break;
case FORWARD:
if (source.getDegreeOfParallelism() > target.getDegreeOfParallelism()) {
gp.setOrdering(null);
}
break;
case NONE:
throw new CompilerException(""String_Node_Str"");
case SFR:
default :
throw new CompilerException(""String_Node_Str"" + shipMode.name());
}
return gp;
}"
87858,"@Override public List<List<PactConnection>> getIncomingConnections(){
  return this.inputs;
}","@Override public List<List<PactConnection>> getIncomingConnections(){
  ArrayList<List<PactConnection>> inputs=new ArrayList<List<PactConnection>>(2);
  inputs.add(0,input1);
  inputs.add(1,input2);
  return inputs;
}"
87859,"/** 
 * Copy constructor to create a copy of a node with different predecessors. The predecessors is assumed to be of the same type as in the template node and merely copies with different strategies, as they are created in the process of the plan enumeration.
 * @param template The node to create a copy of.
 * @param pred1 The new predecessor for the first input.
 * @param pred2 The new predecessor for the second input.
 * @param conn1 The old connection of the first input to copy properties from.
 * @param conn2 The old connection of the second input to copy properties from.
 * @param globalProps The global properties of this copy.
 * @param localProps The local properties of this copy.
 */
protected TwoInputNode(TwoInputNode template,List<OptimizerNode> pred1,List<OptimizerNode> pred2,List<PactConnection> conn1,List<PactConnection> conn2,GlobalProperties globalProps,LocalProperties localProps){
  super(template,globalProps,localProps);
  this.inputs=new ArrayList<List<PactConnection>>(2);
  int i=0;
  if (pred1 != null) {
    for (    PactConnection c : conn1) {
      PactConnection cc=new PactConnection(c,pred1.get(i++),this);
      this.input1.add(cc);
    }
    this.inputs.add(this.input1);
  }
  if (pred2 != null) {
    i=0;
    for (    PactConnection c : conn2) {
      PactConnection cc=new PactConnection(c,pred2.get(i++),this);
      this.input2.add(cc);
    }
    this.inputs.add(this.input2);
  }
  if (template.openBranches != null) {
    if (this.branchPlan == null) {
      this.branchPlan=new HashMap<OptimizerNode,OptimizerNode>(8);
    }
    for (    UnclosedBranchDescriptor uc : template.openBranches) {
      OptimizerNode brancher=uc.branchingNode;
      OptimizerNode selectedCandidate=null;
      if (pred1 != null) {
        Iterator<OptimizerNode> it1=pred1.iterator();
        while (it1.hasNext()) {
          OptimizerNode n=it1.next();
          if (n.branchPlan != null) {
            selectedCandidate=n.branchPlan.get(brancher);
            this.branchPlan.put(brancher,selectedCandidate);
          }
        }
      }
      if (selectedCandidate == null && pred2 != null) {
        Iterator<OptimizerNode> it2=pred2.iterator();
        while (it2.hasNext()) {
          OptimizerNode n=it2.next();
          if (n.branchPlan != null) {
            selectedCandidate=n.branchPlan.get(brancher);
            this.branchPlan.put(brancher,selectedCandidate);
          }
        }
      }
      if (selectedCandidate == null) {
        throw new CompilerException(""String_Node_Str"");
      }
    }
  }
}","/** 
 * Copy constructor to create a copy of a node with different predecessors. The predecessors is assumed to be of the same type as in the template node and merely copies with different strategies, as they are created in the process of the plan enumeration.
 * @param template The node to create a copy of.
 * @param pred1 The new predecessor for the first input.
 * @param pred2 The new predecessor for the second input.
 * @param conn1 The old connection of the first input to copy properties from.
 * @param conn2 The old connection of the second input to copy properties from.
 * @param globalProps The global properties of this copy.
 * @param localProps The local properties of this copy.
 */
protected TwoInputNode(TwoInputNode template,List<OptimizerNode> pred1,List<OptimizerNode> pred2,List<PactConnection> conn1,List<PactConnection> conn2,GlobalProperties globalProps,LocalProperties localProps){
  super(template,globalProps,localProps);
  int i=0;
  if (pred1 != null) {
    for (    PactConnection c : conn1) {
      PactConnection cc=new PactConnection(c,pred1.get(i++),this);
      this.input1.add(cc);
    }
  }
  if (pred2 != null) {
    i=0;
    for (    PactConnection c : conn2) {
      PactConnection cc=new PactConnection(c,pred2.get(i++),this);
      this.input2.add(cc);
    }
  }
  if (template.openBranches != null) {
    if (this.branchPlan == null) {
      this.branchPlan=new HashMap<OptimizerNode,OptimizerNode>(8);
    }
    for (    UnclosedBranchDescriptor uc : template.openBranches) {
      OptimizerNode brancher=uc.branchingNode;
      OptimizerNode selectedCandidate=null;
      if (pred1 != null) {
        Iterator<OptimizerNode> it1=pred1.iterator();
        while (it1.hasNext()) {
          OptimizerNode n=it1.next();
          if (n.branchPlan != null) {
            selectedCandidate=n.branchPlan.get(brancher);
            this.branchPlan.put(brancher,selectedCandidate);
          }
        }
      }
      if (selectedCandidate == null && pred2 != null) {
        Iterator<OptimizerNode> it2=pred2.iterator();
        while (it2.hasNext()) {
          OptimizerNode n=it2.next();
          if (n.branchPlan != null) {
            selectedCandidate=n.branchPlan.get(brancher);
            this.branchPlan.put(brancher,selectedCandidate);
          }
        }
      }
      if (selectedCandidate == null) {
        throw new CompilerException(""String_Node_Str"");
      }
    }
  }
}"
87860,"/** 
 * Updates the binary representation of the data, such that it reflects the state of the currently stored fields. If the binary representation is already up to date, nothing happens. Otherwise, this function triggers the modified fields to serialize themselves into the records buffer and afterwards updates the offset table.
 */
public void updateBinaryRepresenation(){
  if (!this.modified)   return;
  final int firstModified=this.firstModifiedPos;
  final int numFields=this.numFields;
  final int[] offsets=this.offsets;
  if (this.serializer == null) {
    this.serializer=new InternalDeSerializer();
  }
  final InternalDeSerializer serializer=this.serializer;
  if (numFields > 0) {
    int offset=firstModified <= 0 ? 0 : this.offsets[firstModified - 1] + this.lengths[firstModified - 1];
    serializer.position=offset;
    if (firstModified > 0) {
      serializer.memory=this.binaryData == null ? new byte[numFields * DEFAULT_FIELD_LEN] : this.binaryData;
      try {
        for (int i=firstModified; i < numFields; i++) {
          if (offsets[i] == NULL_INDICATOR_OFFSET)           continue;
          offsets[i]=offset;
          this.fields[i].write(serializer);
          int newOffset=serializer.position;
          this.lengths[i]=newOffset - offset;
          offset=newOffset;
        }
      }
 catch (      Exception e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage());
      }
    }
 else {
      serializer.memory=this.serializationSwitchBuffer == null ? new byte[numFields * DEFAULT_FIELD_LEN] : this.serializationSwitchBuffer;
      if (offset > 0 & this.binaryData != null) {
        System.arraycopy(this.binaryData,0,serializer.memory,0,offset);
      }
      try {
        for (int i=firstModified; i < numFields; i++) {
          final int co=offsets[i];
          if (co == NULL_INDICATOR_OFFSET)           continue;
          offsets[i]=offset;
          if (co == MODIFIED_INDICATOR_OFFSET)           this.fields[i].write(serializer);
 else           serializer.write(this.binaryData,co,this.lengths[i]);
          this.lengths[i]=serializer.position - offset;
          offset=serializer.position;
        }
      }
 catch (      Exception e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage());
      }
      this.serializationSwitchBuffer=this.binaryData;
      this.binaryData=serializer.memory;
    }
  }
  try {
    int slp=serializer.position;
    if (numFields <= 8) {
      int mask=0;
      for (int i=numFields - 1; i > 0; i--) {
        mask<<=1;
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          slp=serializer.position;
          serializer.writeValLenIntBackwards(offsets[i]);
          mask|=0x1;
        }
      }
      mask<<=1;
      if (offsets[0] != NULL_INDICATOR_OFFSET) {
        mask|=0x1;
      }
 else {
        serializer.position=slp;
      }
      serializer.writeByte(mask);
    }
 else {
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          slp=serializer.position;
          serializer.writeValLenIntBackwards(offsets[i]);
        }
      }
      if (offsets[0] == NULL_INDICATOR_OFFSET) {
        serializer.position=slp;
      }
      int col=numFields - 1;
      int mask=0;
      for (int i=numFields & 0x7; i > 0; i--, col--) {
        mask<<=1;
        mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      }
      serializer.writeByte(mask);
      for (int i=numFields >>> 3; i > 0; i--) {
        mask=0;
        for (int k=0; k < 8; k++, col--) {
          mask<<=1;
          mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
        }
        serializer.writeByte(mask);
      }
    }
    serializer.writeValLenIntBackwards(numFields);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
  this.binaryData=serializer.memory;
  this.binaryLen=serializer.position;
  this.firstModifiedPos=Integer.MAX_VALUE;
  this.modified=false;
}","/** 
 * Updates the binary representation of the data, such that it reflects the state of the currently stored fields. If the binary representation is already up to date, nothing happens. Otherwise, this function triggers the modified fields to serialize themselves into the records buffer and afterwards updates the offset table.
 */
public void updateBinaryRepresenation(){
  if (!this.modified)   return;
  final int firstModified=this.firstModifiedPos;
  final int numFields=this.numFields;
  final int[] offsets=this.offsets;
  if (this.serializer == null) {
    this.serializer=new InternalDeSerializer();
  }
  final InternalDeSerializer serializer=this.serializer;
  if (numFields > 0) {
    int offset=0;
    if (firstModified > 0) {
      for (int i=firstModified - 1; i >= 0; i--) {
        if (this.offsets[i] != NULL_INDICATOR_OFFSET) {
          offset=this.offsets[i] + this.lengths[i];
          break;
        }
      }
    }
    serializer.position=offset;
    if (firstModified > 0) {
      serializer.memory=this.binaryData == null ? new byte[numFields * DEFAULT_FIELD_LEN] : this.binaryData;
      try {
        for (int i=firstModified; i < numFields; i++) {
          if (offsets[i] == NULL_INDICATOR_OFFSET)           continue;
          offsets[i]=offset;
          this.fields[i].write(serializer);
          int newOffset=serializer.position;
          this.lengths[i]=newOffset - offset;
          offset=newOffset;
        }
      }
 catch (      Exception e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage());
      }
    }
 else {
      serializer.memory=this.serializationSwitchBuffer == null ? new byte[numFields * DEFAULT_FIELD_LEN] : this.serializationSwitchBuffer;
      if (offset > 0 & this.binaryData != null) {
        System.arraycopy(this.binaryData,0,serializer.memory,0,offset);
      }
      try {
        for (int i=firstModified; i < numFields; i++) {
          final int co=offsets[i];
          if (co == NULL_INDICATOR_OFFSET)           continue;
          offsets[i]=offset;
          if (co == MODIFIED_INDICATOR_OFFSET)           this.fields[i].write(serializer);
 else           serializer.write(this.binaryData,co,this.lengths[i]);
          this.lengths[i]=serializer.position - offset;
          offset=serializer.position;
        }
      }
 catch (      Exception e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage());
      }
      this.serializationSwitchBuffer=this.binaryData;
      this.binaryData=serializer.memory;
    }
  }
  try {
    int slp=serializer.position;
    if (numFields <= 8) {
      int mask=0;
      for (int i=numFields - 1; i > 0; i--) {
        mask<<=1;
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          slp=serializer.position;
          serializer.writeValLenIntBackwards(offsets[i]);
          mask|=0x1;
        }
      }
      mask<<=1;
      if (offsets[0] != NULL_INDICATOR_OFFSET) {
        mask|=0x1;
      }
 else {
        serializer.position=slp;
      }
      serializer.writeByte(mask);
    }
 else {
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          slp=serializer.position;
          serializer.writeValLenIntBackwards(offsets[i]);
        }
      }
      if (offsets[0] == NULL_INDICATOR_OFFSET) {
        serializer.position=slp;
      }
      int col=numFields - 1;
      int mask=0;
      for (int i=numFields & 0x7; i > 0; i--, col--) {
        mask<<=1;
        mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      }
      serializer.writeByte(mask);
      for (int i=numFields >>> 3; i > 0; i--) {
        mask=0;
        for (int k=0; k < 8; k++, col--) {
          mask<<=1;
          mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
        }
        serializer.writeByte(mask);
      }
    }
    serializer.writeValLenIntBackwards(numFields);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
  this.binaryData=serializer.memory;
  this.binaryLen=serializer.position;
  this.firstModifiedPos=Integer.MAX_VALUE;
  this.modified=false;
}"
87861,"/** 
 * Does the aggregation of the query.  sum(l_extendedprice) as revenue GROUP BY l_orderkey, o_shippriority; Output Schema: Key: ORDERKEY Value: 0:ORDERKEY, 1:SHIPPRIORITY, 2:EXTENDEDPRICESUM
 */
@Override public void reduce(Iterator<PactRecord> values,Collector out){
  PactRecord rec=null;
  double partExtendedPriceSum=0;
  while (values.hasNext()) {
    rec=values.next();
    partExtendedPriceSum+=rec.getField(2,PactDouble.class).getValue();
  }
  this.extendedPrice.setValue(partExtendedPriceSum);
  rec.setField(2,this.extendedPrice);
  out.collect(rec);
}","/** 
 * Does the aggregation of the query.  sum(l_extendedprice) as revenue GROUP BY l_orderkey, o_shippriority; Output Schema: Key: ORDERKEY Value: 0:ORDERKEY, 1:SHIPPRIORITY, 2:EXTENDEDPRICESUM
 */
@Override public void reduce(Iterator<PactRecord> values,Collector out){
  PactRecord rec=null;
  double partExtendedPriceSum=0;
  while (values.hasNext()) {
    rec=values.next();
    partExtendedPriceSum+=rec.getField(5,PactDouble.class).getValue();
  }
  this.extendedPrice.setValue(partExtendedPriceSum);
  rec.setField(2,this.extendedPrice);
  out.collect(rec);
}"
87862,"/** 
 * Implements the join between LineItem and Order table on the  order key. WHERE l_orderkey = o_orderkey Output Schema - 0:ORDERKEY, 1:SHIPPRIORITY, 2:EXTENDEDPRICE
 */
@Override public void match(PactRecord first,PactRecord second,Collector out){
  first.setField(2,second.getField(1,PactDouble.class));
  out.collect(first);
}","/** 
 * Implements the join between LineItem and Order table on the  order key. WHERE l_orderkey = o_orderkey Output Schema - 0:ORDERKEY, 1:SHIPPRIORITY, 2:EXTENDEDPRICE
 */
@Override public void match(PactRecord order,PactRecord lineitem,Collector out){
  order.setField(5,lineitem.getField(1,PactDouble.class));
  out.collect(order);
}"
87863,"/** 
 * Does the projection on the LineItem table  Output Schema - 0:ORDERKEY, 1:null, 2:EXTENDEDPRICE
 */
@Override public void map(PactRecord record,Collector out){
  final Tuple t=record.getField(0,Tuple.class);
  try {
    this.orderKey.setValue(t.getLongValueAt(0));
    this.extendedPrice.setValue(Double.parseDouble(t.getStringValueAt(5)));
    result.setField(0,this.orderKey);
    result.setField(1,this.extendedPrice);
    out.collect(result);
  }
 catch (  NumberFormatException nfe) {
    LOGGER.error(nfe);
  }
}","/** 
 * Filters the orders table by year, orderstatus and orderpriority. o_orderstatus = ""X""  AND YEAR(o_orderdate) > Y AND o_orderpriority LIKE ""Z"" Output Schema - 0:ORDERKEY, 1:SHIPPRIORITY
 */
@Override public void map(final PactRecord record,final Collector out){
  record.getFieldInto(2,orderStatus);
  record.getFieldInto(3,orderDate);
  record.getFieldInto(4,orderPrio);
  if (Integer.parseInt(orderDate.getValue().substring(0,4)) > this.yearFilter && orderStatus.getValue().equals(""String_Node_Str"") && orderPrio.getValue().startsWith(this.prioFilter)) {
    outRecord.setField(0,record.getField(0,PactLong.class));
    outRecord.setField(1,record.getField(1,PactInteger.class));
    out.collect(outRecord);
  }
}"
87864,"/** 
 * Creates partial sums on the price attribute for each data batch.
 */
@Override public void combine(Iterator<PactRecord> values,Collector out){
  reduce(values,out);
}","/** 
 * Creates partial sums on the price attribute for each data batch.
 */
@Override public void combine(Iterator<PactRecord> values,Collector out){
  PactRecord rec=null;
  double partExtendedPriceSum=0;
  while (values.hasNext()) {
    rec=values.next();
    partExtendedPriceSum+=rec.getField(5,PactDouble.class).getValue();
  }
  this.extendedPrice.setValue(partExtendedPriceSum);
  rec.setField(5,this.extendedPrice);
  out.collect(rec);
}"
87865,"/** 
 * Returns the current status of the job represented by this execution graph.
 * @return the current status of the job
 */
public InternalJobStatus getJobStatus(){
  return this.jobStatus;
}","/** 
 * Returns the current status of the job represented by this execution graph.
 * @return the current status of the job
 */
public InternalJobStatus getJobStatus(){
  return this.jobStatus.get();
}"
87866,"/** 
 * {@inheritDoc}
 */
@Override public void executionStateChanged(final JobID jobID,final ExecutionVertexID vertexID,final ExecutionState newExecutionState,String optionalMessage){
  final InternalJobStatus oldStatus=this.jobStatus;
  if (newExecutionState == ExecutionState.RERUNNING) {
    this.recovering.remove(getVertexByID(vertexID));
  }
  checkAndUpdateJobStatus(newExecutionState);
  if (newExecutionState == ExecutionState.FINISHED) {
    if (this.isCurrentStageCompleted()) {
      ++this.indexToCurrentExecutionStage;
      if (this.indexToCurrentExecutionStage < this.stages.size()) {
        final Iterator<ExecutionStageListener> it=this.executionStageListeners.iterator();
        final ExecutionStage nextExecutionStage=getCurrentExecutionStage();
        while (it.hasNext()) {
          it.next().nextExecutionStageEntered(jobID,nextExecutionStage);
        }
      }
    }
  }
  if (newExecutionState == ExecutionState.FAILED && this.jobStatus == InternalJobStatus.RECOVERING) {
    LOG.info(""String_Node_Str"");
    if (!this.recovering.contains(vertexID)) {
      this.recovering.add(this.getVertexByID(vertexID));
    }
  }
  if (this.jobStatus != oldStatus) {
    if (this.jobStatus == InternalJobStatus.FAILING) {
      this.errorDescription=optionalMessage;
    }
    if (this.jobStatus == InternalJobStatus.FAILED) {
      optionalMessage=this.errorDescription;
    }
    final Iterator<JobStatusListener> it=this.jobStatusListeners.iterator();
    while (it.hasNext()) {
      it.next().jobStatusHasChanged(this,this.jobStatus,optionalMessage);
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void executionStateChanged(final JobID jobID,final ExecutionVertexID vertexID,final ExecutionState newExecutionState,String optionalMessage){
  if (newExecutionState == ExecutionState.RERUNNING) {
    this.recovering.remove(getVertexByID(vertexID));
  }
  final InternalJobStatus newJobStatus=determineNewJobStatus(this,newExecutionState);
  if (newExecutionState == ExecutionState.FINISHED) {
    if (this.isCurrentStageCompleted()) {
      ++this.indexToCurrentExecutionStage;
      if (this.indexToCurrentExecutionStage < this.stages.size()) {
        final Iterator<ExecutionStageListener> it=this.executionStageListeners.iterator();
        final ExecutionStage nextExecutionStage=getCurrentExecutionStage();
        while (it.hasNext()) {
          it.next().nextExecutionStageEntered(jobID,nextExecutionStage);
        }
      }
    }
  }
  if (newExecutionState == ExecutionState.FAILED && newJobStatus == InternalJobStatus.RECOVERING) {
    LOG.info(""String_Node_Str"");
    if (!this.recovering.contains(vertexID)) {
      this.recovering.add(this.getVertexByID(vertexID));
    }
  }
  updateJobStatus(newJobStatus,optionalMessage);
}"
87867,"/** 
 * {@inheritDoc}
 */
@Override public void deploy(final JobID jobID,final AbstractInstance instance,final List<ExecutionVertex> verticesToBeDeployed){
  if (verticesToBeDeployed.isEmpty()) {
    LOG.error(""String_Node_Str"");
    return;
  }
  final ExecutionGraph eg=verticesToBeDeployed.get(0).getExecutionGraph();
  for (  final ExecutionVertex vertex : verticesToBeDeployed) {
    if (vertex.getExecutionState() != ExecutionState.READY) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState());
    }
    vertex.updateExecutionState(ExecutionState.STARTING,null);
  }
  final Runnable deploymentRunnable=new Runnable(){
    /** 
 * {@inheritDoc}
 */
    @Override public void run(){
      try {
        instance.checkLibraryAvailability(jobID);
      }
 catch (      IOException ioe) {
        LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
      }
      final List<TaskSubmissionWrapper> submissionList=new SerializableArrayList<TaskSubmissionWrapper>();
      for (      final ExecutionVertex vertex : verticesToBeDeployed) {
        submissionList.add(new TaskSubmissionWrapper(vertex.getID(),vertex.getEnvironment(),vertex.getExecutionGraph().getJobConfiguration(),vertex.constructInitialActiveOutputChannelsSet()));
        LOG.info(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getAllocatedResource().getInstance());
      }
      List<TaskSubmissionResult> submissionResultList=null;
      try {
        submissionResultList=instance.submitTasks(submissionList);
      }
 catch (      final IOException ioe) {
        final String errorMsg=StringUtils.stringifyException(ioe);
        for (        final ExecutionVertex vertex : verticesToBeDeployed) {
          vertex.updateExecutionState(ExecutionState.FAILED,errorMsg);
        }
      }
      if (verticesToBeDeployed.size() != submissionResultList.size()) {
        LOG.error(""String_Node_Str"");
      }
      int count=0;
      for (      final TaskSubmissionResult tsr : submissionResultList) {
        ExecutionVertex vertex=verticesToBeDeployed.get(count++);
        if (!vertex.getID().equals(tsr.getVertexID())) {
          LOG.error(""String_Node_Str"");
          vertex=null;
          for (          final ExecutionVertex candVertex : verticesToBeDeployed) {
            if (tsr.getVertexID().equals(candVertex.getID())) {
              vertex=candVertex;
              break;
            }
          }
          if (vertex == null) {
            LOG.error(""String_Node_Str"" + tsr.getVertexID());
            continue;
          }
        }
        if (tsr.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR) {
          vertex.updateExecutionState(ExecutionState.FAILED,tsr.getDescription());
        }
      }
    }
  }
;
  this.executorService.execute(deploymentRunnable);
}","/** 
 * {@inheritDoc}
 */
@Override public void deploy(final JobID jobID,final AbstractInstance instance,final List<ExecutionVertex> verticesToBeDeployed){
  if (verticesToBeDeployed.isEmpty()) {
    LOG.error(""String_Node_Str"");
    return;
  }
  for (  final ExecutionVertex vertex : verticesToBeDeployed) {
    if (vertex.getExecutionState() != ExecutionState.READY) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState());
    }
    vertex.updateExecutionState(ExecutionState.STARTING,null);
  }
  final Runnable deploymentRunnable=new Runnable(){
    /** 
 * {@inheritDoc}
 */
    @Override public void run(){
      try {
        instance.checkLibraryAvailability(jobID);
      }
 catch (      IOException ioe) {
        LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
      }
      final List<TaskSubmissionWrapper> submissionList=new SerializableArrayList<TaskSubmissionWrapper>();
      for (      final ExecutionVertex vertex : verticesToBeDeployed) {
        submissionList.add(new TaskSubmissionWrapper(vertex.getID(),vertex.getEnvironment(),vertex.getExecutionGraph().getJobConfiguration(),vertex.constructInitialActiveOutputChannelsSet()));
        LOG.info(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getAllocatedResource().getInstance());
      }
      List<TaskSubmissionResult> submissionResultList=null;
      try {
        submissionResultList=instance.submitTasks(submissionList);
      }
 catch (      final IOException ioe) {
        final String errorMsg=StringUtils.stringifyException(ioe);
        for (        final ExecutionVertex vertex : verticesToBeDeployed) {
          vertex.updateExecutionState(ExecutionState.FAILED,errorMsg);
        }
      }
      if (verticesToBeDeployed.size() != submissionResultList.size()) {
        LOG.error(""String_Node_Str"");
      }
      int count=0;
      for (      final TaskSubmissionResult tsr : submissionResultList) {
        ExecutionVertex vertex=verticesToBeDeployed.get(count++);
        if (!vertex.getID().equals(tsr.getVertexID())) {
          LOG.error(""String_Node_Str"");
          vertex=null;
          for (          final ExecutionVertex candVertex : verticesToBeDeployed) {
            if (tsr.getVertexID().equals(candVertex.getID())) {
              vertex=candVertex;
              break;
            }
          }
          if (vertex == null) {
            LOG.error(""String_Node_Str"" + tsr.getVertexID());
            continue;
          }
        }
        if (tsr.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR) {
          vertex.updateExecutionState(ExecutionState.FAILED,tsr.getDescription());
        }
      }
    }
  }
;
  this.executorService.execute(deploymentRunnable);
}"
87868,"/** 
 * Prints an error message and throws the given exception. If the exception is of the type  {@link ExceptionInChainedStubException} then the chain of contained exceptions is followeduntil an exception of a different type is found.
 * @param ex The exception to be thrown.
 * @param parent The parent task, whose information is included in the log message.
 * @throws Exception Always thrown.
 */
public static void logAndThrowException(Exception ex,AbstractInvokable parent) throws Exception {
  String taskName;
  if (ex instanceof ExceptionInChainedStubException) {
    do {
      ExceptionInChainedStubException cex=(ExceptionInChainedStubException)ex;
      taskName=cex.getTaskName();
      ex=cex.getWrappedException();
    }
 while (ex instanceof ExceptionInChainedStubException);
  }
 else {
    taskName=parent.getEnvironment().getTaskName();
  }
  if (LOG.isErrorEnabled())   LOG.error(constructLogString(""String_Node_Str"",taskName,parent));
  throw ex;
}","/** 
 * Prints an error message and throws the given exception. If the exception is of the type  {@link ExceptionInChainedStubException} then the chain of contained exceptions is followeduntil an exception of a different type is found.
 * @param ex The exception to be thrown.
 * @param parent The parent task, whose information is included in the log message.
 * @throws Exception Always thrown.
 */
public static void logAndThrowException(Exception ex,AbstractInvokable parent) throws Exception {
  String taskName;
  if (ex instanceof ExceptionInChainedStubException) {
    do {
      ExceptionInChainedStubException cex=(ExceptionInChainedStubException)ex;
      taskName=cex.getTaskName();
      ex=cex.getWrappedException();
    }
 while (ex instanceof ExceptionInChainedStubException);
  }
 else {
    taskName=parent.getEnvironment().getTaskName();
  }
  if (LOG.isErrorEnabled()) {
    LOG.error(constructLogString(""String_Node_Str"",taskName,parent));
    LOG.error(ex,ex);
  }
  throw ex;
}"
87869,"@Override public void removeFailurePattern(final TreeItem selectedItem){
  final JobFailurePattern failurePattern=(JobFailurePattern)selectedItem.getData();
  if (failurePattern == null) {
    return;
  }
  final MessageBox messageBox=new MessageBox(this.shell,SWT.ICON_QUESTION | SWT.YES | SWT.NO);
  messageBox.setText(""String_Node_Str"");
  messageBox.setMessage(""String_Node_Str"" + failurePattern.getName() + ""String_Node_Str"");
  if (messageBox.open() != SWT.YES) {
    return;
  }
  selectedItem.dispose();
  this.loadedPatterns.remove(failurePattern.getName());
  if (this.jobTree.getItemCount() == 0) {
    jobFailurePatternSelected(null);
  }
 else {
    jobFailurePatternSelected(this.jobTree.getItem(0));
  }
}","@Override public void removeFailurePattern(final TreeItem selectedItem){
  final JobFailurePattern failurePattern=(JobFailurePattern)selectedItem.getData();
  if (failurePattern == null) {
    return;
  }
  final MessageBox messageBox=new MessageBox(this.shell,SWT.ICON_QUESTION | SWT.YES | SWT.NO);
  messageBox.setText(""String_Node_Str"");
  messageBox.setMessage(""String_Node_Str"" + failurePattern.getName() + ""String_Node_Str"");
  if (messageBox.open() != SWT.YES) {
    return;
  }
  selectedItem.dispose();
  this.loadedPatterns.remove(failurePattern.getName());
  if (this.jobTree.getItemCount() == 0) {
    jobFailurePatternSelected(null);
  }
 else {
    final TreeItem ti=this.jobTree.getItem(0);
    this.jobTree.setSelection(ti);
    jobFailurePatternSelected(ti);
  }
}"
87870,"public void addFailurePatternToTree(final JobFailurePattern failurePattern){
  final TreeItem jobFailureItem=new TreeItem(this.jobTree,SWT.NONE);
  jobFailureItem.setText(failurePattern.getName());
  jobFailureItem.setData(failurePattern);
}","public void addFailurePatternToTree(final JobFailurePattern failurePattern){
  final TreeItem jobFailureItem=new TreeItem(this.jobTree,SWT.NONE);
  jobFailureItem.setText(failurePattern.getName());
  jobFailureItem.setData(failurePattern);
  this.jobTree.setSelection(jobFailureItem);
}"
87871,"/** 
 * Constructs a new auto-completion combo box.
 * @param parent the parent composite
 * @param style the style of the combo box
 * @param suggestions a list of suggestions for the auto-completion
 */
public AutoCompletionCombo(final Composite parent,final int style,final List<String> suggestions){
  super(parent,style);
  this.suggestions=new ArrayList<String>(suggestions);
  Collections.sort(this.suggestions);
  setLayout(new FillLayout());
  this.combo=new Combo(this,style);
  this.combo.addKeyListener(this);
  for (  final String suggestion : this.suggestions) {
    this.combo.add(suggestion);
  }
}","/** 
 * Constructs a new auto-completion combo box.
 * @param parent the parent composite
 * @param style the style of the combo box
 * @param suggestions a list of suggestions for the auto-completion
 */
public AutoCompletionCombo(final Composite parent,final int style,final List<String> suggestions){
  super(parent,style);
  this.suggestions=new ArrayList<String>(suggestions);
  Collections.sort(this.suggestions);
  setLayout(new FillLayout());
  this.combo=new Combo(this,style);
  this.combo.addKeyListener(this);
  this.combo.addSelectionListener(this);
  for (  final String suggestion : this.suggestions) {
    this.combo.add(suggestion);
  }
}"
87872,"@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),2,1);
  JsonStream input=sopremoModule.getInput(0);
  JsonStream nullInput=sopremoModule.getInput(1);
  int n=3;
  Partitioning partitioning=new Partitioning().withInputs(input);
  Grouping group=new Grouping().withInputs(partitioning).withGroupingKey(EvaluationExpression.KEY).withResetKey(false);
  final GenerateBinarySparseMatrix genMatrix=new GenerateBinarySparseMatrix().withInputs(group);
  final GenerateEmptyMatrix emptyMatrix=new GenerateEmptyMatrix().withInputs(nullInput);
  emptyMatrix.setN(n);
  final FillMatrix filledMatrix=new FillMatrix().withInputs(genMatrix,emptyMatrix);
  sopremoModule.getOutput(0).setInput(0,filledMatrix);
  return sopremoModule;
}","@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),2,1);
  JsonStream input=sopremoModule.getInput(0);
  JsonStream nullInput=sopremoModule.getInput(1);
  int n=this.numberOfPartitions;
  Partitioning partitioning=new Partitioning().withInputs(input);
  partitioning.setNumberOfPartitions(n);
  Grouping group=new Grouping().withInputs(partitioning).withGroupingKey(EvaluationExpression.KEY).withResetKey(false);
  final GenerateBinarySparseMatrix genMatrix=new GenerateBinarySparseMatrix().withInputs(group);
  final GenerateEmptyMatrix emptyMatrix=new GenerateEmptyMatrix().withInputs(nullInput);
  emptyMatrix.setN(n);
  final FillMatrix filledMatrix=new FillMatrix().withInputs(genMatrix,emptyMatrix);
  sopremoModule.getOutput(0).setInput(0,filledMatrix);
  return sopremoModule;
}"
87873,"@Override protected void map(JsonNode key,JsonNode value,JsonCollector out){
  for (int i=1; i <= n; i++) {
    for (int j=1; j <= i; j++) {
      out.collect(new ArrayNode(new IntNode(j),new IntNode(i)),new BinarySparseMatrix());
    }
  }
}","@Override protected void map(JsonNode key,JsonNode value,JsonCollector out){
  for (int i=0; i < n; i++) {
    for (int j=0; j <= i; j++) {
      out.collect(new ArrayNode(new IntNode(j),new IntNode(i)),new BinarySparseMatrix());
    }
  }
}"
87874,"@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),2,1);
  JsonStream phase1=sopremoModule.getInput(0);
  JsonStream matrix=sopremoModule.getInput(1);
  final TransformDiagonal transDia=new TransformDiagonal().withInputs(phase1);
  final GenerateRows rows=new GenerateRows().withInputs(matrix);
  final ComputeBlockTuples computeRows=new ComputeBlockTuples().withInputs(transDia,rows);
  final GenerateColumns columns=new GenerateColumns().withInputs(computeRows);
  final ComputeBlockTuples computeTuples=new ComputeBlockTuples().withInputs(transDia,columns);
  sopremoModule.getOutput(0).setInput(0,computeTuples);
  return sopremoModule;
}","@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),2,1);
  JsonStream phase1=sopremoModule.getInput(0);
  JsonStream matrix=sopremoModule.getInput(1);
  final TransformDiagonal transDia=new TransformDiagonal().withInputs(phase1);
  final GenerateRows rows=new GenerateRows().withInputs(matrix);
  final ComputeBlockTuples computeRows=new ComputeBlockTuples().withInputs(transDia,rows);
  final GenerateColumns columns=new GenerateColumns().withInputs(computeRows);
  final ComputeBlockTuples computeTuples=new ComputeBlockTuples().withInputs(transDia,columns);
  GenerateFullMatrix fullMatrix=new GenerateFullMatrix().withInputs(computeTuples);
  sopremoModule.getOutput(0).setInput(0,fullMatrix);
  return sopremoModule;
}"
87875,"@Override protected void match(JsonNode key,JsonNode value1,JsonNode value2,JsonCollector out){
  JsonNode oldKeyPrimary=key;
  JsonNode oldKeyCurrent=((ArrayNode)value2).get(0);
  BinarySparseMatrix current=(BinarySparseMatrix)((ArrayNode)value2).get(1);
  if (oldKeyPrimary.equals(((ArrayNode)oldKeyCurrent).get(1))) {
    current=current.transpose();
  }
  TransitiveClosure.warshall((BinarySparseMatrix)value1,current);
  if (oldKeyPrimary.equals(((ArrayNode)oldKeyCurrent).get(1))) {
    current=current.transpose();
  }
  out.collect(oldKeyCurrent,current);
}","@Override protected void match(JsonNode key,JsonNode value1,JsonNode value2,JsonCollector out){
  JsonNode oldKeyPrimary=key;
  JsonNode oldKeyCurrent=((ArrayNode)value2).get(0);
  BinarySparseMatrix current=(BinarySparseMatrix)((ArrayNode)value2).get(1);
  if (oldKeyPrimary.equals(((ArrayNode)oldKeyCurrent).get(1))) {
    TransitiveClosure.warshall(current,(BinarySparseMatrix)value1,current);
  }
 else {
    TransitiveClosure.warshall((BinarySparseMatrix)value1,current,current);
  }
  out.collect(oldKeyCurrent,current);
}"
87876,"@Override protected void map(JsonNode key,JsonNode value,JsonCollector out){
  if (((ArrayNode)key).get(0).compareTo(((ArrayNode)key).get(1)) > 0) {
    out.collect(new ArrayNode(((ArrayNode)key).get(1),((ArrayNode)key).get(0)),value);
  }
}","@Override protected void map(JsonNode key,JsonNode value,JsonCollector out){
  if (!((ArrayNode)key).get(0).equals(((ArrayNode)key).get(1))) {
    out.collect(new ArrayNode(((ArrayNode)key).get(1),((ArrayNode)key).get(0)),((BinarySparseMatrix)value).transpose());
  }
  out.collect(key,value);
}"
87877,"@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),1,1);
  JsonStream input=sopremoModule.getInput(0);
  GenerateFullMatrix fullMatrix=new GenerateFullMatrix().withInputs(input);
  int itCount=3;
  ExtractRelatingBlocks xBlocks[]=new ExtractRelatingBlocks[itCount];
  ExtractNonRelatingBlocks abBlocks[]=new ExtractNonRelatingBlocks[itCount];
  TransformAKey[] a=new TransformAKey[itCount];
  TransformBKey[] b=new TransformBKey[itCount];
  TransformXKey[] x=new TransformXKey[itCount];
  BAndXMatch[] xb=new BAndXMatch[itCount];
  AMatch axb[]=new AMatch[itCount];
  UnionAll itOutput[]=new UnionAll[itCount];
  for (int i=0; i < itCount; i++) {
    JsonStream inputStream=i == 0 ? fullMatrix : itOutput[i - 1];
    xBlocks[i]=new ExtractRelatingBlocks().withInputs(inputStream);
    xBlocks[i].setIterationStep(i + 1);
    abBlocks[i]=new ExtractNonRelatingBlocks().withInputs(inputStream);
    abBlocks[i].setIterationStep(i + 1);
    a[i]=new TransformAKey().withInputs(abBlocks[i]);
    a[i].setIterationStep(i + 1);
    b[i]=new TransformBKey().withInputs(abBlocks[i]);
    b[i].setIterationStep(i + 1);
    x[i]=new TransformXKey().withInputs(xBlocks[i]);
    xb[i]=new BAndXMatch().withInputs(b[i],x[i]);
    axb[i]=new AMatch().withInputs(a[i],xb[i]);
    itOutput[i]=new UnionAll().withInputs(abBlocks[i],axb[i]);
  }
  sopremoModule.getOutput(0).setInput(0,itOutput[itCount - 1]);
  return sopremoModule;
}","@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),1,1);
  JsonStream input=sopremoModule.getInput(0);
  int itCount=this.numberOfPartitions;
  ExtractRelatingBlocks xBlocks[]=new ExtractRelatingBlocks[itCount];
  ExtractNonRelatingBlocks abBlocks[]=new ExtractNonRelatingBlocks[itCount];
  TransformAKey[] a=new TransformAKey[itCount];
  TransformBKey[] b=new TransformBKey[itCount];
  TransformXKey[] x=new TransformXKey[itCount];
  BAndXMatch[] xb=new BAndXMatch[itCount];
  AMatch axb[]=new AMatch[itCount];
  UnionAll itOutput[]=new UnionAll[itCount];
  for (int i=0; i < itCount; i++) {
    JsonStream inputStream=i == 0 ? input : itOutput[i - 1];
    xBlocks[i]=new ExtractRelatingBlocks().withInputs(inputStream);
    xBlocks[i].setIterationStep(i);
    abBlocks[i]=new ExtractNonRelatingBlocks().withInputs(inputStream);
    abBlocks[i].setIterationStep(i);
    a[i]=new TransformAKey().withInputs(abBlocks[i]);
    a[i].setIterationStep(i);
    b[i]=new TransformBKey().withInputs(abBlocks[i]);
    b[i].setIterationStep(i);
    x[i]=new TransformXKey().withInputs(xBlocks[i]);
    xb[i]=new BAndXMatch().withInputs(b[i],x[i]);
    axb[i]=new AMatch().withInputs(a[i],xb[i]);
    itOutput[i]=new UnionAll().withInputs(abBlocks[i],axb[i]);
  }
  sopremoModule.getOutput(0).setInput(0,itOutput[itCount - 1]);
  return sopremoModule;
}"
87878,"@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),2,1);
  JsonStream input=sopremoModule.getInput(0);
  JsonStream nullInput=sopremoModule.getInput(1);
  final GenerateMatrix filledMatrix=new GenerateMatrix().withInputs(input,nullInput);
  final Phase1 phase1=new Phase1().withInputs(filledMatrix);
  final Phase2 phase2=new Phase2().withInputs(phase1,filledMatrix);
  final Phase3 phase3=new Phase3().withInputs(new UnionAll().withInputs(phase1,phase2));
  final EmitMatrix result=new EmitMatrix().withInputs(phase3);
  sopremoModule.getOutput(0).setInput(0,result);
  return sopremoModule;
}","@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),2,1);
  JsonStream input=sopremoModule.getInput(0);
  JsonStream nullInput=sopremoModule.getInput(1);
  final GenerateMatrix filledMatrix=new GenerateMatrix().withInputs(input,nullInput);
  filledMatrix.setNumberOfPartitions(this.numberOfPartitions);
  final Phase1 phase1=new Phase1().withInputs(filledMatrix);
  final Phase2 phase2=new Phase2().withInputs(phase1,filledMatrix);
  final Phase3 phase3=new Phase3().withInputs(new UnionAll().withInputs(phase1,phase2));
  phase3.setNumberOfPartitions(this.numberOfPartitions);
  final EmitMatrix result=new EmitMatrix().withInputs(phase3);
  sopremoModule.getOutput(0).setInput(0,result);
  return sopremoModule;
}"
87879,"/** 
 * Updates the binary representation of the data, such that it reflects the state of the currently stored fields. If the binary representation is already up to date, nothing happens. Otherwise, this function triggers the modified fields to serialize themselves into the records buffer and afterwards updates the offset table.
 */
public void updateBinaryRepresenation(){
  if (!this.modified)   return;
  final int firstModified=this.firstModifiedPos;
  final int numFields=this.numFields;
  final int[] offsets=this.offsets;
  if (this.serializer == null) {
    this.serializer=new InternalDeSerializer();
  }
  final InternalDeSerializer serializer=this.serializer;
  if (numFields > 0) {
    int offset=firstModified <= 0 ? 0 : this.offsets[firstModified - 1] + this.lengths[firstModified - 1];
    serializer.position=offset;
    if (firstModified > 0) {
      serializer.memory=this.binaryData == null ? new byte[numFields * DEFAULT_FIELD_LEN] : this.binaryData;
      try {
        for (int i=firstModified; i < numFields; i++) {
          if (offsets[i] == NULL_INDICATOR_OFFSET)           continue;
          offsets[i]=offset;
          this.fields[i].write(serializer);
          int newOffset=serializer.position;
          this.lengths[i]=newOffset - offset;
          offset=newOffset;
        }
      }
 catch (      Exception e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage());
      }
    }
 else {
      serializer.memory=this.serializationSwitchBuffer == null ? new byte[numFields * DEFAULT_FIELD_LEN] : this.serializationSwitchBuffer;
      if (offset > 0 & this.binaryData != null) {
        System.arraycopy(this.binaryData,0,serializer.memory,0,offset);
      }
      try {
        for (int i=firstModified; i < numFields; i++) {
          final int co=offsets[i];
          if (co == NULL_INDICATOR_OFFSET)           continue;
          offsets[i]=offset;
          if (co == MODIFIED_INDICATOR_OFFSET)           this.fields[i].write(serializer);
 else           serializer.write(this.binaryData,co,this.lengths[i]);
          this.lengths[i]=serializer.position - offset;
          offset=serializer.position;
        }
      }
 catch (      Exception e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage());
      }
      this.serializationSwitchBuffer=this.binaryData;
      this.binaryData=serializer.memory;
    }
  }
  try {
    if (numFields <= 8) {
      int mask=0;
      for (int i=numFields - 1; i > 0; i--) {
        mask<<=1;
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          serializer.writeValLenIntBackwards(offsets[i]);
          mask|=0x1;
        }
      }
      mask<<=1;
      mask|=(offsets[0] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      serializer.writeByte(mask);
    }
 else {
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          serializer.writeValLenIntBackwards(offsets[i]);
        }
      }
      int col=numFields - 1;
      int mask=0;
      for (int i=numFields & 0x7; i >= 0; i--, col--) {
        mask<<=1;
        mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      }
      serializer.writeByte(mask);
      for (int i=numFields >>> 3; i >= 0; i--) {
        mask=0;
        for (int k=0; k < 8; k++, col--) {
          mask<<=1;
          mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
        }
        serializer.writeByte(mask);
      }
    }
    serializer.writeValLenIntBackwards(numFields);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
  this.binaryData=serializer.memory;
  this.binaryLen=serializer.position;
  this.firstModifiedPos=Integer.MAX_VALUE;
  this.modified=false;
}","/** 
 * Updates the binary representation of the data, such that it reflects the state of the currently stored fields. If the binary representation is already up to date, nothing happens. Otherwise, this function triggers the modified fields to serialize themselves into the records buffer and afterwards updates the offset table.
 */
public void updateBinaryRepresenation(){
  if (!this.modified)   return;
  final int firstModified=this.firstModifiedPos;
  final int numFields=this.numFields;
  final int[] offsets=this.offsets;
  if (this.serializer == null) {
    this.serializer=new InternalDeSerializer();
  }
  final InternalDeSerializer serializer=this.serializer;
  if (numFields > 0) {
    int offset=firstModified <= 0 ? 0 : this.offsets[firstModified - 1] + this.lengths[firstModified - 1];
    serializer.position=offset;
    if (firstModified > 0) {
      serializer.memory=this.binaryData == null ? new byte[numFields * DEFAULT_FIELD_LEN] : this.binaryData;
      try {
        for (int i=firstModified; i < numFields; i++) {
          if (offsets[i] == NULL_INDICATOR_OFFSET)           continue;
          offsets[i]=offset;
          this.fields[i].write(serializer);
          int newOffset=serializer.position;
          this.lengths[i]=newOffset - offset;
          offset=newOffset;
        }
      }
 catch (      Exception e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage());
      }
    }
 else {
      serializer.memory=this.serializationSwitchBuffer == null ? new byte[numFields * DEFAULT_FIELD_LEN] : this.serializationSwitchBuffer;
      if (offset > 0 & this.binaryData != null) {
        System.arraycopy(this.binaryData,0,serializer.memory,0,offset);
      }
      try {
        for (int i=firstModified; i < numFields; i++) {
          final int co=offsets[i];
          if (co == NULL_INDICATOR_OFFSET)           continue;
          offsets[i]=offset;
          if (co == MODIFIED_INDICATOR_OFFSET)           this.fields[i].write(serializer);
 else           serializer.write(this.binaryData,co,this.lengths[i]);
          this.lengths[i]=serializer.position - offset;
          offset=serializer.position;
        }
      }
 catch (      Exception e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage());
      }
      this.serializationSwitchBuffer=this.binaryData;
      this.binaryData=serializer.memory;
    }
  }
  try {
    if (numFields <= 8) {
      int mask=0;
      for (int i=numFields - 1; i > 0; i--) {
        mask<<=1;
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          serializer.writeValLenIntBackwards(offsets[i]);
          mask|=0x1;
        }
      }
      mask<<=1;
      mask|=(offsets[0] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      serializer.writeByte(mask);
    }
 else {
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          serializer.writeValLenIntBackwards(offsets[i]);
        }
      }
      int col=numFields - 1;
      int mask=0;
      for (int i=numFields & 0x7; i > 0; i--, col--) {
        mask<<=1;
        mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      }
      serializer.writeByte(mask);
      for (int i=numFields >>> 3; i > 0; i--) {
        mask=0;
        for (int k=0; k < 8; k++, col--) {
          mask<<=1;
          mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
        }
        serializer.writeByte(mask);
      }
    }
    serializer.writeValLenIntBackwards(numFields);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
  this.binaryData=serializer.memory;
  this.binaryLen=serializer.position;
  this.firstModifiedPos=Integer.MAX_VALUE;
  this.modified=false;
}"
87880,"@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),2,1);
  JsonStream phase1=sopremoModule.getInput(0);
  JsonStream matrix=sopremoModule.getInput(1);
  final TransformDiagonal transDia=new TransformDiagonal().withInputs(phase1);
  final GenerateRows rows=new GenerateRows().withInputs(matrix);
  final ComputeBlockTuples computeRows=new ComputeBlockTuples().withInputs(transDia,rows);
  final ExtractMirroredMatrix mirroredMatrix=new ExtractMirroredMatrix().withInputs(computeRows);
  final FillMatrix fillMatrix=new FillMatrix().withInputs(computeRows,mirroredMatrix);
  sopremoModule.getOutput(0).setInput(0,fillMatrix);
  return sopremoModule;
}","@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),2,1);
  JsonStream phase1=sopremoModule.getInput(0);
  JsonStream matrix=sopremoModule.getInput(1);
  final TransformDiagonal transDia=new TransformDiagonal().withInputs(phase1);
  final GenerateRows rows=new GenerateRows().withInputs(matrix);
  final ComputeBlockTuples computeRows=new ComputeBlockTuples().withInputs(transDia,rows);
  final GenerateColumns columns=new GenerateColumns().withInputs(computeRows);
  final ComputeBlockTuples computeTuples=new ComputeBlockTuples().withInputs(transDia,columns);
  sopremoModule.getOutput(0).setInput(0,computeTuples);
  return sopremoModule;
}"
87881,"@Override protected void match(JsonNode key,JsonNode value1,JsonNode value2,JsonCollector out){
  JsonNode oldKey=((ArrayNode)value2).get(0);
  TransitiveClosure.warshall((BinarySparseMatrix)value1,(BinarySparseMatrix)((ArrayNode)value2).get(1));
  out.collect(oldKey,((ArrayNode)value2).get(1));
}","@Override protected void match(JsonNode key,JsonNode value1,JsonNode value2,JsonCollector out){
  JsonNode oldKeyPrimary=key;
  JsonNode oldKeyCurrent=((ArrayNode)value2).get(0);
  BinarySparseMatrix current=(BinarySparseMatrix)((ArrayNode)value2).get(1);
  if (oldKeyPrimary.equals(((ArrayNode)oldKeyCurrent).get(1))) {
    current=current.transpose();
  }
  TransitiveClosure.warshall((BinarySparseMatrix)value1,current);
  if (oldKeyPrimary.equals(((ArrayNode)oldKeyCurrent).get(1))) {
    current=current.transpose();
  }
  out.collect(oldKeyCurrent,current);
}"
87882,"@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),1,1);
  JsonStream input=sopremoModule.getInput(0);
  int itCount=3;
  TransformAKey[] a=new TransformAKey[itCount];
  TransformBKey[] b=new TransformBKey[itCount];
  TransformXKey[] x=new TransformXKey[itCount];
  BAndXMatch[] xb=new BAndXMatch[itCount];
  AMatch axb[]=new AMatch[itCount];
  for (int i=0; i < itCount; i++) {
    a[i]=new TransformAKey().withInputs(i == 0 ? input : axb[i - 1]);
    a[i].setIterationStep(i + 1);
    b[i]=new TransformBKey().withInputs(i == 0 ? input : axb[i - 1]);
    b[i].setIterationStep(i + 1);
    x[i]=new TransformXKey().withInputs(i == 0 ? input : axb[i - 1]);
    xb[i]=new BAndXMatch().withInputs(b[i],x[i]);
    axb[i]=new AMatch().withInputs(a[i],xb[i]);
  }
  sopremoModule.getOutput(0).setInput(0,axb[itCount - 1]);
  return sopremoModule;
}","@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),1,1);
  JsonStream input=sopremoModule.getInput(0);
  int itCount=3;
  ExtractNonRelatingBlocks otherBlocks[]=new ExtractNonRelatingBlocks[itCount];
  TransformAKey[] a=new TransformAKey[itCount];
  TransformBKey[] b=new TransformBKey[itCount];
  TransformXKey[] x=new TransformXKey[itCount];
  BAndXMatch[] xb=new BAndXMatch[itCount];
  AMatch axb[]=new AMatch[itCount];
  UnionAll itOutput[]=new UnionAll[itCount];
  for (int i=0; i < itCount; i++) {
    JsonStream inputStream=i == 0 ? input : itOutput[i - 1];
    otherBlocks[i]=new ExtractNonRelatingBlocks().withInputs(inputStream);
    otherBlocks[i].setIterationStep(i + 1);
    a[i]=new TransformAKey().withInputs(inputStream);
    a[i].setIterationStep(i + 1);
    b[i]=new TransformBKey().withInputs(inputStream);
    b[i].setIterationStep(i + 1);
    x[i]=new TransformXKey().withInputs(inputStream);
    xb[i]=new BAndXMatch().withInputs(b[i],x[i]);
    axb[i]=new AMatch().withInputs(a[i],xb[i]);
    itOutput[i]=new UnionAll().withInputs(axb[i],otherBlocks[i]);
  }
  sopremoModule.getOutput(0).setInput(0,itOutput[itCount - 1]);
  return sopremoModule;
}"
87883,"@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),2,1);
  JsonStream input=sopremoModule.getInput(0);
  JsonStream nullInput=sopremoModule.getInput(1);
  int n=3;
  Partitioning partitioning=new Partitioning().withInputs(input);
  Grouping group=new Grouping().withInputs(partitioning).withGroupingKey(EvaluationExpression.KEY).withResetKey(false);
  final GenerateMatrix genMatrix=new GenerateMatrix().withInputs(group);
  final GenerateEmptyMatrix emptyMatrix=new GenerateEmptyMatrix().withInputs(nullInput);
  emptyMatrix.setN(n);
  final FillMatrix filledMatrix=new FillMatrix().withInputs(genMatrix,emptyMatrix);
  final Phase1 phase1=new Phase1().withInputs(filledMatrix);
  final Phase2 phase2=new Phase2().withInputs(phase1,genMatrix);
  final Phase3 phase3=new Phase3().withInputs(new UnionAll().withInputs(phase1,phase2));
  final EmitMatrix result=new EmitMatrix().withInputs(new UnionAll().withInputs(phase1,phase2));
  sopremoModule.getOutput(0).setInput(0,result);
  return sopremoModule;
}","@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),2,1);
  JsonStream input=sopremoModule.getInput(0);
  JsonStream nullInput=sopremoModule.getInput(1);
  int n=3;
  Partitioning partitioning=new Partitioning().withInputs(input);
  Grouping group=new Grouping().withInputs(partitioning).withGroupingKey(EvaluationExpression.KEY).withResetKey(false);
  final GenerateMatrix genMatrix=new GenerateMatrix().withInputs(group);
  final GenerateEmptyMatrix emptyMatrix=new GenerateEmptyMatrix().withInputs(nullInput);
  emptyMatrix.setN(n);
  final FillMatrix filledMatrix=new FillMatrix().withInputs(genMatrix,emptyMatrix);
  final Phase1 phase1=new Phase1().withInputs(filledMatrix);
  final Phase2 phase2=new Phase2().withInputs(phase1,filledMatrix);
  final Phase3 phase3=new Phase3().withInputs(new UnionAll().withInputs(phase1,phase2));
  final EmitMatrix result=new EmitMatrix().withInputs(phase3);
  sopremoModule.getOutput(0).setInput(0,result);
  return sopremoModule;
}"
87884,"/** 
 * {@inheritDoc}
 */
@Override public void accept(Visitor<Contract> visitor){
  boolean descend=visitor.preVisit(this);
  if (descend) {
    if (visitor.preVisit(this)) {
      for (      Contract c : this.input1) {
        c.accept(visitor);
      }
      for (      Contract c : this.input2) {
        c.accept(visitor);
      }
    }
    visitor.postVisit(this);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void accept(Visitor<Contract> visitor){
  boolean descend=visitor.preVisit(this);
  if (descend) {
    for (    Contract c : this.input1) {
      c.accept(visitor);
    }
    for (    Contract c : this.input2) {
      c.accept(visitor);
    }
    visitor.postVisit(this);
  }
}"
87885,"/** 
 * Creates the record readers for the number of inputs as defined by   {@link #getNumberOfInputs()}.
 */
protected void initInputs(){
  int numInputs=getNumberOfInputs();
  @SuppressWarnings(""String_Node_Str"") final MutableObjectIterator<PactRecord>[] inputs=new MutableObjectIterator[numInputs];
  for (int i=0; i < numInputs; i++) {
    final ShipStrategy shipStrategy=this.config.getInputShipStrategy(i);
    DistributionPattern dp=null;
switch (shipStrategy) {
case FORWARD:
case PARTITION_LOCAL_HASH:
case PARTITION_LOCAL_RANGE:
      dp=new PointwiseDistributionPattern();
    break;
case PARTITION_HASH:
case PARTITION_RANGE:
case BROADCAST:
case SFR:
  dp=new BipartiteDistributionPattern();
break;
default :
throw new RuntimeException(""String_Node_Str"" + i + ""String_Node_Str""+ shipStrategy.name());
}
final int groupSize=this.config.getGroupSize(i + 1);
if (groupSize == 1) {
inputs[i]=new NepheleReaderIterator(new MutableRecordReader<PactRecord>(this,dp));
}
 else {
@SuppressWarnings(""String_Node_Str"") MutableRecordReader<PactRecord>[] readers=new MutableRecordReader[groupSize];
for (int j=0; j < groupSize; ++j) {
readers[j]=new MutableRecordReader<PactRecord>(this,dp);
}
inputs[i]=new NepheleReaderIterator(new MutableUnionRecordReader<PactRecord>(readers));
}
}
this.inputs=inputs;
}","/** 
 * Creates the record readers for the number of inputs as defined by   {@link #getNumberOfInputs()}.
 */
protected void initInputs(){
  int numInputs=getNumberOfInputs();
  @SuppressWarnings(""String_Node_Str"") final MutableObjectIterator<PactRecord>[] inputs=new MutableObjectIterator[numInputs];
  for (int i=0; i < numInputs; i++) {
    final ShipStrategy shipStrategy=this.config.getInputShipStrategy(i);
    DistributionPattern dp=null;
switch (shipStrategy) {
case FORWARD:
case PARTITION_LOCAL_HASH:
case PARTITION_LOCAL_RANGE:
      dp=new PointwiseDistributionPattern();
    break;
case PARTITION_HASH:
case PARTITION_RANGE:
case BROADCAST:
case SFR:
  dp=new BipartiteDistributionPattern();
break;
default :
throw new RuntimeException(""String_Node_Str"" + i + ""String_Node_Str""+ shipStrategy.name());
}
final int groupSize=this.config.getGroupSize(i + 1);
if (groupSize < 2) {
inputs[i]=new NepheleReaderIterator(new MutableRecordReader<PactRecord>(this,dp));
}
 else {
@SuppressWarnings(""String_Node_Str"") MutableRecordReader<PactRecord>[] readers=new MutableRecordReader[groupSize];
for (int j=0; j < groupSize; ++j) {
readers[j]=new MutableRecordReader<PactRecord>(this,dp);
}
inputs[i]=new NepheleReaderIterator(new MutableUnionRecordReader<PactRecord>(readers));
}
}
this.inputs=inputs;
}"
87886,"/** 
 * Registers a new job represented by its   {@link ExecutionGraph} with the input split manager.
 * @param executionGraph the job to be registered
 */
public void registerJob(final ExecutionGraph executionGraph){
  final Iterator<ExecutionGroupVertex> it=new ExecutionGroupVertexIterator(executionGraph,true,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    final InputSplit[] inputSplits=groupVertex.getInputSplits();
    if (inputSplits == null) {
      continue;
    }
    if (inputSplits.length == 0) {
      continue;
    }
    final AbstractInvokable invokable=groupVertex.getGroupMember(0).getEnvironment().getInvokable();
    if (!(invokable instanceof AbstractInputTask)) {
      LOG.error(groupVertex.getName() + ""String_Node_Str"" + inputSplits.length+ ""String_Node_Str"");
      continue;
    }
    @SuppressWarnings(""String_Node_Str"") final AbstractInputTask<? extends InputSplit> inputTask=(AbstractInputTask<? extends InputSplit>)invokable;
    final Class<? extends InputSplit> splitType=inputTask.getInputSplitType();
    final InputSplitAssigner assigner=getAssignerByType(splitType,true);
    this.assignerCache.put(groupVertex,assigner);
    assigner.registerGroupVertex(groupVertex);
  }
}","/** 
 * Registers a new job represented by its   {@link ExecutionGraph} with the input split manager.
 * @param executionGraph the job to be registered
 */
public void registerJob(final ExecutionGraph executionGraph){
  final Iterator<ExecutionGroupVertex> it=new ExecutionGroupVertexIterator(executionGraph,true,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    final InputSplit[] inputSplits=groupVertex.getInputSplits();
    if (inputSplits == null) {
      continue;
    }
    if (inputSplits.length == 0) {
      continue;
    }
    final AbstractInvokable invokable=groupVertex.getGroupMember(0).getEnvironment().getInvokable();
    if (!(invokable instanceof AbstractInputTask)) {
      LOG.error(groupVertex.getName() + ""String_Node_Str"" + inputSplits.length+ ""String_Node_Str"");
      continue;
    }
    @SuppressWarnings(""String_Node_Str"") final AbstractInputTask<? extends InputSplit> inputTask=(AbstractInputTask<? extends InputSplit>)invokable;
    final Class<? extends InputSplit> splitType=inputTask.getInputSplitType();
    final InputSplitAssigner assigner=getAssignerByType(splitType,true,executionGraph.getJobID());
    this.assignerCache.put(groupVertex,assigner);
    assigner.registerGroupVertex(groupVertex);
  }
}"
87887,"/** 
 * Attempts to find the responsible type of   {@link InputSplitAssigner} for the given type of input split from theconfiguration and instantiate an object for it.
 * @param inputSplitType the type of input split to load the  {@link InputSplitAssigner} for
 * @return the newly loaded {@link InputSplitAssigner} object or <code>null</code> if no such object could belocated or loaded
 */
private InputSplitAssigner loadInputSplitAssigner(final Class<? extends InputSplit> inputSplitType){
  final String typeClassName=inputSplitType.getSimpleName();
  final String assignerKey=INPUT_SPLIT_CONFIG_KEY_PREFIX + typeClassName;
  LOG.info(""String_Node_Str"" + typeClassName);
  String assignerClassName=GlobalConfiguration.getString(assignerKey,null);
  if (assignerClassName == null) {
    if (FileInputSplit.class.getSimpleName().equals(typeClassName)) {
      assignerClassName=FileInputSplitAssigner.class.getName();
    }
 else {
      return null;
    }
  }
  try {
    @SuppressWarnings(""String_Node_Str"") final Class<? extends InputSplitAssigner> assignerClass=(Class<? extends InputSplitAssigner>)Class.forName(assignerClassName);
    return assignerClass.newInstance();
  }
 catch (  Exception e) {
    LOG.error(StringUtils.stringifyException(e));
  }
  return null;
}","/** 
 * Attempts to find the responsible type of   {@link InputSplitAssigner} for the given type of input split from theconfiguration and instantiate an object for it.
 * @param inputSplitType the type of input split to load the  {@link InputSplitAssigner} for
 * @return the newly loaded {@link InputSplitAssigner} object or <code>null</code> if no such object could belocated or loaded
 */
@SuppressWarnings(""String_Node_Str"") private InputSplitAssigner loadInputSplitAssigner(final Class<? extends InputSplit> inputSplitType,JobID jid){
  final String typeClassName=inputSplitType.getSimpleName();
  final String assignerKey=INPUT_SPLIT_CONFIG_KEY_PREFIX + typeClassName;
  LOG.info(""String_Node_Str"" + typeClassName);
  String assignerClassName=GlobalConfiguration.getString(assignerKey,null);
  if (assignerClassName == null) {
    if (FileInputSplit.class.getSimpleName().equals(typeClassName)) {
      assignerClassName=FileInputSplitAssigner.class.getName();
    }
 else {
      return null;
    }
  }
  try {
    Class<? extends InputSplitAssigner> assignerClass;
    boolean useUserJar=GlobalConfiguration.getBoolean(INPUT_SPLIT_CONFIG_KEY_PREFIX + ""String_Node_Str"",false);
    if (useUserJar) {
      final ClassLoader cl=LibraryCacheManager.getClassLoader(jid);
      assignerClass=(Class<? extends InputSplitAssigner>)Class.forName(assignerClassName,true,cl);
    }
 else {
      assignerClass=(Class<? extends InputSplitAssigner>)Class.forName(assignerClassName);
    }
    return assignerClass.newInstance();
  }
 catch (  Exception e) {
    LOG.error(StringUtils.stringifyException(e));
  }
  return null;
}"
87888,"/** 
 * Returns the   {@link InputSplitAssigner} which is defined for the given type of input split.
 * @param inputSplitType the type of input split to find the corresponding  {@link InputSplitAssigner} for
 * @param allowLoading <code>true</code> to indicate that the input split assigner is allowed to load additional classes if necessary, <code>false</code> otherwise
 * @return the {@link InputSplitAssigner} responsible for the given type of input split
 */
private InputSplitAssigner getAssignerByType(final Class<? extends InputSplit> inputSplitType,final boolean allowLoading){
synchronized (this.loadedAssigners) {
    InputSplitAssigner assigner=this.loadedAssigners.get(inputSplitType);
    if (assigner == null && allowLoading) {
      assigner=loadInputSplitAssigner(inputSplitType);
      if (assigner != null) {
        this.loadedAssigners.put(inputSplitType,assigner);
      }
    }
    if (assigner != null) {
      return assigner;
    }
  }
  LOG.warn(""String_Node_Str"" + inputSplitType.getName() + ""String_Node_Str"");
  return this.defaultAssigner;
}","/** 
 * Returns the   {@link InputSplitAssigner} which is defined for the given type of input split.
 * @param inputSplitType the type of input split to find the corresponding  {@link InputSplitAssigner} for
 * @param allowLoading <code>true</code> to indicate that the input split assigner is allowed to load additional classes if necessary, <code>false</code> otherwise
 * @return the {@link InputSplitAssigner} responsible for the given type of input split
 */
private InputSplitAssigner getAssignerByType(final Class<? extends InputSplit> inputSplitType,final boolean allowLoading,JobID jid){
synchronized (this.loadedAssigners) {
    InputSplitAssigner assigner=this.loadedAssigners.get(inputSplitType);
    if (assigner == null && allowLoading) {
      assigner=loadInputSplitAssigner(inputSplitType,jid);
      if (assigner != null) {
        this.loadedAssigners.put(inputSplitType,assigner);
      }
    }
    if (assigner != null) {
      return assigner;
    }
  }
  LOG.warn(""String_Node_Str"" + inputSplitType.getName() + ""String_Node_Str"");
  return this.defaultAssigner;
}"
87889,"/** 
 * {@inheritDoc}
 */
@Override public void accept(Visitor<Contract> visitor){
  boolean descend=visitor.preVisit(this);
  if (descend) {
    if (visitor.preVisit(this)) {
      for (      Contract c : this.input1) {
        c.accept(visitor);
      }
      for (      Contract c : this.input2) {
        c.accept(visitor);
      }
    }
    visitor.postVisit(this);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void accept(Visitor<Contract> visitor){
  boolean descend=visitor.preVisit(this);
  if (descend) {
    for (    Contract c : this.input1) {
      c.accept(visitor);
    }
    for (    Contract c : this.input2) {
      c.accept(visitor);
    }
    visitor.postVisit(this);
  }
}"
87890,"/** 
 * Retrieves the index of the <tt>BlockLocation</tt> that contains the part of the file described by the given offset.
 * @param blocks The different blocks of the file. Must be ordered by their offset.
 * @param offset The offset of the position in the file.
 * @param startIndex The earliest index to look at.
 * @return The index of the block containing the given position.
 */
private final int getBlockIndexForPosition(BlockLocation[] blocks,long offset,long halfSplitSize,int startIndex){
  for (int i=startIndex; i < blocks.length; i++) {
    long blockStart=blocks[i].getOffset();
    long blockEnd=blockStart + blocks[i].getLength();
    if (offset >= blockStart && offset < blockEnd) {
      if (i < blocks.length - 1 && blockEnd - offset < halfSplitSize) {
        return i + 1;
      }
 else {
        return i;
      }
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}","/** 
 * Retrieves the index of the <tt>BlockLocation</tt> that contains the part of the file described by the given offset.
 * @param blocks The different blocks of the file. Must be ordered by their offset.
 * @param offset The offset of the position in the file.
 * @param startIndex The earliest index to look at.
 * @return The index of the block containing the given position.
 */
protected final int getBlockIndexForPosition(BlockLocation[] blocks,long offset,long halfSplitSize,int startIndex){
  for (int i=startIndex; i < blocks.length; i++) {
    long blockStart=blocks[i].getOffset();
    long blockEnd=blockStart + blocks[i].getLength();
    if (offset >= blockStart && offset < blockEnd) {
      if (i < blocks.length - 1 && blockEnd - offset < halfSplitSize) {
        return i + 1;
      }
 else {
        return i;
      }
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}"
87891,"/** 
 * Opens an input stream to the file defined in the input format. The stream is positioned at the beginning of the given split. <p> The stream is actually opened in an asynchronous thread to make sure any interruptions to the thread  working on the input format do not reach the file system.
 * @see eu.stratosphere.pact.common.io.InputFormat#open(eu.stratosphere.nephele.template.InputSplit)
 */
@Override public void open(FileInputSplit split) throws IOException {
  if (!(split instanceof FileInputSplit)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final FileInputSplit fileSplit=(FileInputSplit)split;
  this.start=fileSplit.getStart();
  this.length=fileSplit.getLength();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + fileSplit.getPath() + ""String_Node_Str""+ start+ ""String_Node_Str""+ length+ ""String_Node_Str"");
  final InputSplitOpenThread isot=new InputSplitOpenThread(fileSplit,OPEN_TIMEOUT_MILLIES);
  isot.start();
  try {
    isot.waitForCompletion();
  }
 catch (  Throwable t) {
    throw new IOException(""String_Node_Str"" + fileSplit.getPath() + ""String_Node_Str""+ start+ ""String_Node_Str""+ length+ ""String_Node_Str""+ t.getMessage(),t);
  }
  this.stream=isot.getFSDataInputStream();
  this.stream.seek(this.start);
}","/** 
 * Opens an input stream to the file defined in the input format. The stream is positioned at the beginning of the given split. <p> The stream is actually opened in an asynchronous thread to make sure any interruptions to the thread  working on the input format do not reach the file system.
 * @see eu.stratosphere.pact.common.io.InputFormat#open(eu.stratosphere.nephele.template.InputSplit)
 */
@Override public void open(FileInputSplit split) throws IOException {
  if (!(split instanceof FileInputSplit)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final FileInputSplit fileSplit=(FileInputSplit)split;
  fileNumber=Integer.parseInt(split.getPath().getName());
  this.start=fileSplit.getStart();
  this.length=fileSplit.getLength();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + fileSplit.getPath() + ""String_Node_Str""+ start+ ""String_Node_Str""+ length+ ""String_Node_Str"");
  final InputSplitOpenThread isot=new InputSplitOpenThread(fileSplit,OPEN_TIMEOUT_MILLIES);
  isot.start();
  try {
    isot.waitForCompletion();
  }
 catch (  Throwable t) {
    throw new IOException(""String_Node_Str"" + fileSplit.getPath() + ""String_Node_Str""+ start+ ""String_Node_Str""+ length+ ""String_Node_Str""+ t.getMessage(),t);
  }
  this.stream=isot.getFSDataInputStream();
  this.stream.seek(this.start);
}"
87892,"/** 
 * Registers a new job represented by its   {@link ExecutionGraph} with the input split manager.
 * @param executionGraph the job to be registered
 */
public void registerJob(final ExecutionGraph executionGraph){
  final Iterator<ExecutionGroupVertex> it=new ExecutionGroupVertexIterator(executionGraph,true,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    final InputSplit[] inputSplits=groupVertex.getInputSplits();
    if (inputSplits == null) {
      continue;
    }
    if (inputSplits.length == 0) {
      continue;
    }
    final AbstractInvokable invokable=groupVertex.getGroupMember(0).getEnvironment().getInvokable();
    if (!(invokable instanceof AbstractInputTask)) {
      LOG.error(groupVertex.getName() + ""String_Node_Str"" + inputSplits.length+ ""String_Node_Str"");
      continue;
    }
    @SuppressWarnings(""String_Node_Str"") final AbstractInputTask<? extends InputSplit> inputTask=(AbstractInputTask<? extends InputSplit>)invokable;
    final Class<? extends InputSplit> splitType=inputTask.getInputSplitType();
    final InputSplitAssigner assigner=getAssignerByType(splitType,true,executionGraph.getJobID());
    this.assignerCache.put(groupVertex,assigner);
    assigner.registerGroupVertex(groupVertex);
  }
}","/** 
 * Registers a new job represented by its   {@link ExecutionGraph} with the input split manager.
 * @param executionGraph the job to be registered
 */
public void registerJob(final ExecutionGraph executionGraph){
  final Iterator<ExecutionGroupVertex> it=new ExecutionGroupVertexIterator(executionGraph,true,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    final InputSplit[] inputSplits=groupVertex.getInputSplits();
    if (inputSplits == null) {
      continue;
    }
    if (inputSplits.length == 0) {
      continue;
    }
    final AbstractInvokable invokable=groupVertex.getGroupMember(0).getEnvironment().getInvokable();
    if (!(invokable instanceof AbstractInputTask)) {
      LOG.error(groupVertex.getName() + ""String_Node_Str"" + inputSplits.length+ ""String_Node_Str"");
      continue;
    }
    @SuppressWarnings(""String_Node_Str"") final AbstractInputTask<? extends InputSplit> inputTask=(AbstractInputTask<? extends InputSplit>)invokable;
    final Class<? extends InputSplit> splitType=inputTask.getInputSplitType();
    final InputSplitAssigner assigner=getAssignerByType(splitType,true);
    this.assignerCache.put(groupVertex,assigner);
    assigner.registerGroupVertex(groupVertex);
  }
}"
87893,"/** 
 * Attempts to find the responsible type of   {@link InputSplitAssigner} for the given type of input split from theconfiguration and instantiate an object for it.
 * @param inputSplitType the type of input split to load the  {@link InputSplitAssigner} for
 * @return the newly loaded {@link InputSplitAssigner} object or <code>null</code> if no such object could belocated or loaded
 */
@SuppressWarnings(""String_Node_Str"") private InputSplitAssigner loadInputSplitAssigner(final Class<? extends InputSplit> inputSplitType,JobID jid){
  final String typeClassName=inputSplitType.getSimpleName();
  final String assignerKey=INPUT_SPLIT_CONFIG_KEY_PREFIX + typeClassName;
  LOG.info(""String_Node_Str"" + typeClassName);
  String assignerClassName=GlobalConfiguration.getString(assignerKey,null);
  if (assignerClassName == null) {
    if (FileInputSplit.class.getSimpleName().equals(typeClassName)) {
      assignerClassName=FileInputSplitAssigner.class.getName();
    }
 else {
      return null;
    }
  }
  try {
    Class<? extends InputSplitAssigner> assignerClass;
    boolean useUserJar=GlobalConfiguration.getBoolean(INPUT_SPLIT_CONFIG_KEY_PREFIX + ""String_Node_Str"",false);
    if (useUserJar) {
      final ClassLoader cl=LibraryCacheManager.getClassLoader(jid);
      assignerClass=(Class<? extends InputSplitAssigner>)Class.forName(assignerClassName,true,cl);
    }
 else {
      assignerClass=(Class<? extends InputSplitAssigner>)Class.forName(assignerClassName);
    }
    return assignerClass.newInstance();
  }
 catch (  Exception e) {
    LOG.error(StringUtils.stringifyException(e));
  }
  return null;
}","/** 
 * Attempts to find the responsible type of   {@link InputSplitAssigner} for the given type of input split from theconfiguration and instantiate an object for it.
 * @param inputSplitType the type of input split to load the  {@link InputSplitAssigner} for
 * @return the newly loaded {@link InputSplitAssigner} object or <code>null</code> if no such object could belocated or loaded
 */
private InputSplitAssigner loadInputSplitAssigner(final Class<? extends InputSplit> inputSplitType){
  final String typeClassName=inputSplitType.getSimpleName();
  final String assignerKey=INPUT_SPLIT_CONFIG_KEY_PREFIX + typeClassName;
  LOG.info(""String_Node_Str"" + typeClassName);
  String assignerClassName=GlobalConfiguration.getString(assignerKey,null);
  if (assignerClassName == null) {
    if (FileInputSplit.class.getSimpleName().equals(typeClassName)) {
      assignerClassName=FileInputSplitAssigner.class.getName();
    }
 else {
      return null;
    }
  }
  try {
    @SuppressWarnings(""String_Node_Str"") final Class<? extends InputSplitAssigner> assignerClass=(Class<? extends InputSplitAssigner>)Class.forName(assignerClassName);
    return assignerClass.newInstance();
  }
 catch (  Exception e) {
    LOG.error(StringUtils.stringifyException(e));
  }
  return null;
}"
87894,"/** 
 * Returns the   {@link InputSplitAssigner} which is defined for the given type of input split.
 * @param inputSplitType the type of input split to find the corresponding  {@link InputSplitAssigner} for
 * @param allowLoading <code>true</code> to indicate that the input split assigner is allowed to load additional classes if necessary, <code>false</code> otherwise
 * @return the {@link InputSplitAssigner} responsible for the given type of input split
 */
private InputSplitAssigner getAssignerByType(final Class<? extends InputSplit> inputSplitType,final boolean allowLoading,JobID jid){
synchronized (this.loadedAssigners) {
    InputSplitAssigner assigner=this.loadedAssigners.get(inputSplitType);
    if (assigner == null && allowLoading) {
      assigner=loadInputSplitAssigner(inputSplitType,jid);
      if (assigner != null) {
        this.loadedAssigners.put(inputSplitType,assigner);
      }
    }
    if (assigner != null) {
      return assigner;
    }
  }
  LOG.warn(""String_Node_Str"" + inputSplitType.getName() + ""String_Node_Str"");
  return this.defaultAssigner;
}","/** 
 * Returns the   {@link InputSplitAssigner} which is defined for the given type of input split.
 * @param inputSplitType the type of input split to find the corresponding  {@link InputSplitAssigner} for
 * @param allowLoading <code>true</code> to indicate that the input split assigner is allowed to load additional classes if necessary, <code>false</code> otherwise
 * @return the {@link InputSplitAssigner} responsible for the given type of input split
 */
private InputSplitAssigner getAssignerByType(final Class<? extends InputSplit> inputSplitType,final boolean allowLoading){
synchronized (this.loadedAssigners) {
    InputSplitAssigner assigner=this.loadedAssigners.get(inputSplitType);
    if (assigner == null && allowLoading) {
      assigner=loadInputSplitAssigner(inputSplitType);
      if (assigner != null) {
        this.loadedAssigners.put(inputSplitType,assigner);
      }
    }
    if (assigner != null) {
      return assigner;
    }
  }
  LOG.warn(""String_Node_Str"" + inputSplitType.getName() + ""String_Node_Str"");
  return this.defaultAssigner;
}"
87895,"/** 
 * {@inheritDoc}
 */
@Override public void accept(Visitor<Contract> visitor){
  boolean descend=visitor.preVisit(this);
  if (descend) {
    for (    Contract c : this.input1) {
      c.accept(visitor);
    }
    for (    Contract c : this.input2) {
      c.accept(visitor);
    }
    visitor.postVisit(this);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void accept(Visitor<Contract> visitor){
  boolean descend=visitor.preVisit(this);
  if (descend) {
    if (visitor.preVisit(this)) {
      for (      Contract c : this.input1) {
        c.accept(visitor);
      }
      for (      Contract c : this.input2) {
        c.accept(visitor);
      }
    }
    visitor.postVisit(this);
  }
}"
87896,"/** 
 * Retrieves the index of the <tt>BlockLocation</tt> that contains the part of the file described by the given offset.
 * @param blocks The different blocks of the file. Must be ordered by their offset.
 * @param offset The offset of the position in the file.
 * @param startIndex The earliest index to look at.
 * @return The index of the block containing the given position.
 */
protected final int getBlockIndexForPosition(BlockLocation[] blocks,long offset,long halfSplitSize,int startIndex){
  for (int i=startIndex; i < blocks.length; i++) {
    long blockStart=blocks[i].getOffset();
    long blockEnd=blockStart + blocks[i].getLength();
    if (offset >= blockStart && offset < blockEnd) {
      if (i < blocks.length - 1 && blockEnd - offset < halfSplitSize) {
        return i + 1;
      }
 else {
        return i;
      }
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}","/** 
 * Retrieves the index of the <tt>BlockLocation</tt> that contains the part of the file described by the given offset.
 * @param blocks The different blocks of the file. Must be ordered by their offset.
 * @param offset The offset of the position in the file.
 * @param startIndex The earliest index to look at.
 * @return The index of the block containing the given position.
 */
private final int getBlockIndexForPosition(BlockLocation[] blocks,long offset,long halfSplitSize,int startIndex){
  for (int i=startIndex; i < blocks.length; i++) {
    long blockStart=blocks[i].getOffset();
    long blockEnd=blockStart + blocks[i].getLength();
    if (offset >= blockStart && offset < blockEnd) {
      if (i < blocks.length - 1 && blockEnd - offset < halfSplitSize) {
        return i + 1;
      }
 else {
        return i;
      }
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}"
87897,"/** 
 * Opens an input stream to the file defined in the input format. The stream is positioned at the beginning of the given split. <p> The stream is actually opened in an asynchronous thread to make sure any interruptions to the thread  working on the input format do not reach the file system.
 * @see eu.stratosphere.pact.common.io.InputFormat#open(eu.stratosphere.nephele.template.InputSplit)
 */
@Override public void open(FileInputSplit split) throws IOException {
  if (!(split instanceof FileInputSplit)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final FileInputSplit fileSplit=(FileInputSplit)split;
  fileNumber=Integer.parseInt(split.getPath().getName());
  this.start=fileSplit.getStart();
  this.length=fileSplit.getLength();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + fileSplit.getPath() + ""String_Node_Str""+ start+ ""String_Node_Str""+ length+ ""String_Node_Str"");
  final InputSplitOpenThread isot=new InputSplitOpenThread(fileSplit,OPEN_TIMEOUT_MILLIES);
  isot.start();
  try {
    isot.waitForCompletion();
  }
 catch (  Throwable t) {
    throw new IOException(""String_Node_Str"" + fileSplit.getPath() + ""String_Node_Str""+ start+ ""String_Node_Str""+ length+ ""String_Node_Str""+ t.getMessage(),t);
  }
  this.stream=isot.getFSDataInputStream();
  this.stream.seek(this.start);
}","/** 
 * Opens an input stream to the file defined in the input format. The stream is positioned at the beginning of the given split. <p> The stream is actually opened in an asynchronous thread to make sure any interruptions to the thread  working on the input format do not reach the file system.
 * @see eu.stratosphere.pact.common.io.InputFormat#open(eu.stratosphere.nephele.template.InputSplit)
 */
@Override public void open(FileInputSplit split) throws IOException {
  if (!(split instanceof FileInputSplit)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final FileInputSplit fileSplit=(FileInputSplit)split;
  this.start=fileSplit.getStart();
  this.length=fileSplit.getLength();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + fileSplit.getPath() + ""String_Node_Str""+ start+ ""String_Node_Str""+ length+ ""String_Node_Str"");
  final InputSplitOpenThread isot=new InputSplitOpenThread(fileSplit,OPEN_TIMEOUT_MILLIES);
  isot.start();
  try {
    isot.waitForCompletion();
  }
 catch (  Throwable t) {
    throw new IOException(""String_Node_Str"" + fileSplit.getPath() + ""String_Node_Str""+ start+ ""String_Node_Str""+ length+ ""String_Node_Str""+ t.getMessage(),t);
  }
  this.stream=isot.getFSDataInputStream();
  this.stream.seek(this.start);
}"
87898,"private void initBufferSizes(){
  int bufferSize=GlobalConfiguration.getInteger(""String_Node_Str"",GlobalBufferPool.DEFAULT_BUFFER_SIZE_IN_BYTES);
  long now=System.currentTimeMillis();
  for (  ProfilingPath path : profilingModel.getProfilingSubgraph().getProfilingPaths()) {
    for (    ManagementAttachment pathElement : path.getPathElements()) {
      if (pathElement instanceof ManagementEdge) {
        ManagementEdge edge=(ManagementEdge)pathElement;
        BufferSizeHistory bufferSizeHistory=new BufferSizeHistory(edge,2);
        bufferSizeHistory.addToHistory(now,bufferSize);
        bufferSizes.put(edge,bufferSizeHistory);
      }
    }
  }
}","private void initBufferSizes(){
  int bufferSize=GlobalConfiguration.getInteger(""String_Node_Str"",GlobalBufferPool.DEFAULT_BUFFER_SIZE_IN_BYTES);
  this.maximumBufferSize=bufferSize;
  long now=System.currentTimeMillis();
  for (  ProfilingPath path : profilingModel.getProfilingSubgraph().getProfilingPaths()) {
    for (    ManagementAttachment pathElement : path.getPathElements()) {
      if (pathElement instanceof ManagementEdge) {
        ManagementEdge edge=(ManagementEdge)pathElement;
        BufferSizeHistory bufferSizeHistory=new BufferSizeHistory(edge,2);
        bufferSizeHistory.addToHistory(now,bufferSize);
        bufferSizes.put(edge,bufferSizeHistory);
      }
    }
  }
}"
87899,"private void increaseBufferSize(ManagementEdge edge,HashMap<ManagementEdge,Integer> edgesToAdjust){
  int oldBufferSize=bufferSizes.get(edge).getLastEntry().getBufferSize();
  int newBufferSize=proposedIncreasedBufferSize(oldBufferSize);
  edgesToAdjust.put(edge,newBufferSize);
}","private void increaseBufferSize(ManagementEdge edge,HashMap<ManagementEdge,Integer> edgesToAdjust){
  int oldBufferSize=bufferSizes.get(edge).getLastEntry().getBufferSize();
  int newBufferSize=Math.min(proposedIncreasedBufferSize(oldBufferSize),this.maximumBufferSize);
  if (isRelevantIncrease(oldBufferSize,newBufferSize)) {
    edgesToAdjust.put(edge,newBufferSize);
  }
}"
87900,"/** 
 * {@inheritDoc}
 */
@Override public void transferEvent(AbstractEvent event) throws IOException, InterruptedException {
  this.outputChannelBroker.transferEventToInputChannel(event);
  flush();
}","/** 
 * {@inheritDoc}
 */
@Override public void transferEvent(AbstractEvent event) throws IOException, InterruptedException {
  flush();
  this.outputChannelBroker.transferEventToInputChannel(event);
}"
87901,"/** 
 * {@inheritDoc}
 */
@Override public void requestClose() throws IOException, InterruptedException {
  if (!this.closeRequested) {
    this.closeRequested=true;
    flush();
    transferEvent(new ByteBufferedChannelCloseEvent());
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void requestClose() throws IOException, InterruptedException {
  if (!this.closeRequested) {
    this.closeRequested=true;
    transferEvent(new ByteBufferedChannelCloseEvent());
    flush();
  }
}"
87902,"@Override public BufferPairResponse getReadBufferToConsume(){
  TransferEnvelope transferEnvelope=null;
synchronized (this.queuedEnvelopes) {
    if (this.queuedEnvelopes.isEmpty()) {
      return null;
    }
    transferEnvelope=this.queuedEnvelopes.peek();
    if (transferEnvelope.getBuffer() == null) {
      this.queuedEnvelopes.poll();
    }
  }
  if (transferEnvelope.getBuffer() == null) {
    final EventList eventList=transferEnvelope.getEventList();
    if (!eventList.isEmpty()) {
      final Iterator<AbstractEvent> it=eventList.iterator();
      while (it.hasNext()) {
        this.byteBufferedInputChannel.processEvent(it.next());
      }
    }
    return null;
  }
  BufferPairResponse response;
  if (this.byteBufferedInputChannel.getCompressionLevel() == CompressionLevel.NO_COMPRESSION) {
    response=new BufferPairResponse(null,transferEnvelope.getBuffer());
  }
 else {
    final int maximumBufferSize=this.byteBufferedChannelManager.getMaximumBufferSize();
    final BufferPairRequest request=new BufferPairRequest(transferEnvelope.getBuffer().isBackedByMemory() ? -1 : transferEnvelope.getBuffer().size(),maximumBufferSize,true);
    try {
      response=this.byteBufferedChannelManager.requestEmptyReadBuffers(request);
    }
 catch (    InterruptedException e) {
      this.byteBufferedInputChannel.checkForNetworkEvents();
      return null;
    }
    if (transferEnvelope.getBuffer().isBackedByMemory()) {
      response=new BufferPairResponse(transferEnvelope.getBuffer(),response.getUncompressedDataBuffer());
    }
 else {
      final Buffer oldBuffer=transferEnvelope.getBuffer();
      try {
        oldBuffer.copyToMemoryBackedBuffer(response.getCompressedDataBuffer());
        transferEnvelope.setBuffer(response.getCompressedDataBuffer());
      }
 catch (      IOException ioe) {
        LOG.error(ioe);
        this.byteBufferedInputChannel.reportIOException(ioe);
        return null;
      }
      oldBuffer.recycleBuffer();
    }
    this.uncompressedDataBuffer=response.getUncompressedDataBuffer();
  }
  final EventList eventList=transferEnvelope.getEventList();
  if (!eventList.isEmpty()) {
    final Iterator<AbstractEvent> it=eventList.iterator();
    while (it.hasNext()) {
      this.byteBufferedInputChannel.processEvent(it.next());
    }
  }
  return response;
}","@Override public BufferPairResponse getReadBufferToConsume(){
  TransferEnvelope transferEnvelope=null;
synchronized (this.queuedEnvelopes) {
    if (this.queuedEnvelopes.isEmpty()) {
      return null;
    }
    transferEnvelope=this.queuedEnvelopes.peek();
    if (transferEnvelope.getBuffer() == null) {
      this.queuedEnvelopes.poll();
    }
  }
  if (transferEnvelope.getBuffer() == null) {
    final EventList eventList=transferEnvelope.getEventList();
    if (!eventList.isEmpty()) {
      final Iterator<AbstractEvent> it=eventList.iterator();
      while (it.hasNext()) {
        this.byteBufferedInputChannel.processEvent(it.next());
      }
    }
    return null;
  }
  BufferPairResponse response;
  if (this.byteBufferedInputChannel.getCompressionLevel() == CompressionLevel.NO_COMPRESSION) {
    response=new BufferPairResponse(null,transferEnvelope.getBuffer());
  }
 else {
    final int maximumBufferSize=this.byteBufferedChannelManager.getMaximumBufferSize();
    final BufferPairRequest request=new BufferPairRequest(transferEnvelope.getBuffer().isBackedByMemory() ? -1 : transferEnvelope.getBuffer().size(),maximumBufferSize,true);
    try {
      response=this.byteBufferedChannelManager.requestEmptyReadBuffers(request);
    }
 catch (    InterruptedException e) {
      this.byteBufferedInputChannel.checkForNetworkEvents();
      return null;
    }
    if (transferEnvelope.getBuffer().isBackedByMemory()) {
      response=new BufferPairResponse(transferEnvelope.getBuffer(),response.getUncompressedDataBuffer());
    }
 else {
      final Buffer oldBuffer=transferEnvelope.getBuffer();
      try {
        oldBuffer.copyToMemoryBackedBuffer(response.getCompressedDataBuffer());
        transferEnvelope.setBuffer(response.getCompressedDataBuffer());
      }
 catch (      IOException ioe) {
        LOG.error(ioe);
        this.byteBufferedInputChannel.reportIOException(ioe);
        return null;
      }
      oldBuffer.recycleBuffer();
    }
    this.uncompressedDataBuffer=response.getUncompressedDataBuffer();
  }
  return response;
}"
87903,"@Override public void releaseConsumedReadBuffer(){
  TransferEnvelope transferEnvelope=null;
synchronized (this.queuedEnvelopes) {
    if (this.queuedEnvelopes.isEmpty()) {
      LOG.error(""String_Node_Str"");
      return;
    }
    transferEnvelope=this.queuedEnvelopes.poll();
    if (transferEnvelope.getBuffer() != null) {
      if (transferEnvelope.getBuffer().isBackedByMemory()) {
        --this.numberOfMemoryBuffers;
      }
 else {
        --this.numberOfFileBuffers;
      }
    }
  }
  final Buffer consumedBuffer=transferEnvelope.getBuffer();
  if (consumedBuffer == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (consumedBuffer.remaining() > 0) {
    LOG.error(""String_Node_Str"" + consumedBuffer.remaining() + ""String_Node_Str"");
  }
  consumedBuffer.recycleBuffer();
  if (this.uncompressedDataBuffer != null) {
    this.uncompressedDataBuffer.recycleBuffer();
    this.uncompressedDataBuffer=null;
  }
}","@Override public void releaseConsumedReadBuffer(){
  TransferEnvelope transferEnvelope=null;
synchronized (this.queuedEnvelopes) {
    if (this.queuedEnvelopes.isEmpty()) {
      LOG.error(""String_Node_Str"");
      return;
    }
    transferEnvelope=this.queuedEnvelopes.poll();
    if (transferEnvelope.getBuffer() != null) {
      if (transferEnvelope.getBuffer().isBackedByMemory()) {
        --this.numberOfMemoryBuffers;
      }
 else {
        --this.numberOfFileBuffers;
      }
    }
  }
  final EventList eventList=transferEnvelope.getEventList();
  if (!eventList.isEmpty()) {
    final Iterator<AbstractEvent> it=eventList.iterator();
    while (it.hasNext()) {
      this.byteBufferedInputChannel.processEvent(it.next());
    }
  }
  final Buffer consumedBuffer=transferEnvelope.getBuffer();
  if (consumedBuffer == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (consumedBuffer.remaining() > 0) {
    LOG.error(""String_Node_Str"" + consumedBuffer.remaining() + ""String_Node_Str"");
  }
  consumedBuffer.recycleBuffer();
  if (this.uncompressedDataBuffer != null) {
    this.uncompressedDataBuffer.recycleBuffer();
    this.uncompressedDataBuffer=null;
  }
}"
87904,"@Override public StringBuilder toString(StringBuilder sb){
  for (  final JsonNode row : this.getRows())   sb.append(""String_Node_Str"").append(row).append(""String_Node_Str"").append(this.get(row)).append(""String_Node_Str"");
  return sb.append(""String_Node_Str"");
}","@Override public StringBuilder toString(StringBuilder sb){
  for (  final JsonNode row : this.getRows())   sb.append(""String_Node_Str"").append(row).append(""String_Node_Str"").append(this.get(row)).append(""String_Node_Str"");
  return sb;
}"
87905,"@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),2,1);
  JsonStream phase1=sopremoModule.getInput(0);
  JsonStream matrix=sopremoModule.getInput(1);
  final TransformDiagonal transDia=new TransformDiagonal().withInputs(phase1);
  final GenerateRows rows=new GenerateRows().withInputs(matrix);
  final ComputeBlockTuples computeRows=new ComputeBlockTuples().withInputs(transDia,rows);
  sopremoModule.getOutput(0).setInput(0,computeRows);
  return sopremoModule;
}","@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),2,1);
  JsonStream phase1=sopremoModule.getInput(0);
  JsonStream matrix=sopremoModule.getInput(1);
  final TransformDiagonal transDia=new TransformDiagonal().withInputs(phase1);
  final GenerateRows rows=new GenerateRows().withInputs(matrix);
  final ComputeBlockTuples computeRows=new ComputeBlockTuples().withInputs(transDia,rows);
  final ExtractMirroredMatrix mirroredMatrix=new ExtractMirroredMatrix().withInputs(computeRows);
  final FillMatrix fillMatrix=new FillMatrix().withInputs(computeRows,mirroredMatrix);
  sopremoModule.getOutput(0).setInput(0,fillMatrix);
  return sopremoModule;
}"
87906,"@Override protected void map(JsonNode key,JsonNode value,JsonCollector out){
  ArrayNode castedKey=(ArrayNode)key;
  if (!castedKey.get(0).equals(castedKey.get(1))) {
    out.collect(castedKey.get(1),new ArrayNode(key,value));
  }
}","@Override protected void map(JsonNode key,JsonNode value,JsonCollector out){
  if (((ArrayNode)key).get(0).compareTo(((ArrayNode)key).get(1)) > 0) {
    out.collect(new ArrayNode(((ArrayNode)key).get(1),((ArrayNode)key).get(0)),value);
  }
}"
87907,"@Override protected void coGroup(JsonNode key,ArrayNode values1,ArrayNode values2,JsonCollector out){
  if (!key.isArray()) {
    for (    JsonNode array : values2) {
      out.collect(((ArrayNode)array).get(0),((ArrayNode)array).get(1));
    }
  }
 else {
    for (    JsonNode value2 : values2) {
      BinarySparseMatrix matrixB=(BinarySparseMatrix)((ArrayNode)(((ArrayNode)value2).get(0))).get(1);
      BinarySparseMatrix matrixX=(BinarySparseMatrix)((ArrayNode)(((ArrayNode)value2).get(1))).get(1);
      JsonNode oldKeyX=((ArrayNode)(((ArrayNode)value2).get(1))).get(0);
      if (!values1.isEmpty()) {
      }
 else {
        JsonNode oldKeyB=((ArrayNode)(((ArrayNode)value2).get(0))).get(0);
        out.collect(oldKeyB,matrixB);
      }
      out.collect(oldKeyX,matrixX);
    }
  }
}","@Override protected void coGroup(JsonNode key,ArrayNode values1,ArrayNode values2,JsonCollector out){
  if (!key.isArray()) {
    for (    JsonNode array : values2) {
      out.collect(((ArrayNode)array).get(0),((ArrayNode)array).get(1));
    }
  }
 else {
    if (values2.isEmpty()) {
      out.collect(key,values1.get(0));
    }
 else {
      for (      JsonNode value2 : values2) {
        BinarySparseMatrix matrixB=(BinarySparseMatrix)((ArrayNode)(((ArrayNode)value2).get(0))).get(1);
        BinarySparseMatrix matrixX=(BinarySparseMatrix)((ArrayNode)(((ArrayNode)value2).get(1))).get(1);
        JsonNode oldKeyX=((ArrayNode)(((ArrayNode)value2).get(1))).get(0);
        if (!values1.isEmpty()) {
        }
        out.collect(oldKeyX,matrixX);
      }
    }
  }
}"
87908,"@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),1,1);
  JsonStream input=sopremoModule.getInput(0);
  int itCount=2;
  TransformAKey[] a=new TransformAKey[itCount];
  TransformBKey[] b=new TransformBKey[itCount];
  TransformXKey[] x=new TransformXKey[itCount];
  BAndXCoGroup[] xb=new BAndXCoGroup[itCount];
  ACoGroup axb[]=new ACoGroup[itCount];
  for (int i=0; i < itCount; i++) {
    a[i]=new TransformAKey().withInputs(i == 0 ? input : axb[i - 1]);
    a[i].setIterationStep(i + 1);
    b[i]=new TransformBKey().withInputs(i == 0 ? input : axb[i - 1]);
    b[i].setIterationStep(i + 1);
    x[i]=new TransformXKey().withInputs(i == 0 ? input : axb[i - 1]);
    xb[i]=new BAndXCoGroup().withInputs(b[i],x[i]);
    axb[i]=new ACoGroup().withInputs(a[i],xb[i]);
  }
  sopremoModule.getOutput(0).setInput(0,axb[itCount - 1]);
  return sopremoModule;
}","@Override public SopremoModule asElementaryOperators(){
  final SopremoModule sopremoModule=new SopremoModule(this.getName(),1,1);
  JsonStream input=sopremoModule.getInput(0);
  int itCount=3;
  TransformAKey[] a=new TransformAKey[itCount];
  TransformBKey[] b=new TransformBKey[itCount];
  TransformXKey[] x=new TransformXKey[itCount];
  BAndXCoGroup[] xb=new BAndXCoGroup[itCount];
  ACoGroup axb[]=new ACoGroup[itCount];
  for (int i=0; i < itCount; i++) {
    a[i]=new TransformAKey().withInputs(i == 0 ? input : axb[i - 1]);
    a[i].setIterationStep(i + 1);
    b[i]=new TransformBKey().withInputs(i == 0 ? input : axb[i - 1]);
    b[i].setIterationStep(i + 1);
    x[i]=new TransformXKey().withInputs(i == 0 ? input : axb[i - 1]);
    xb[i]=new BAndXCoGroup().withInputs(b[i],x[i]);
    axb[i]=new ACoGroup().withInputs(a[i],xb[i]);
  }
  sopremoModule.getOutput(0).setInput(0,axb[itCount - 1]);
  return sopremoModule;
}"
87909,"public void refreshEdgeLatency(long timestamp,ChannelLatency channelLatency){
  ManagementEdgeID sourceEdgeID=profilingSubgraph.getEdgeByReceiverVertexID(channelLatency.getSinkVertexID().toManagementVertexID());
  EdgeCharacteristics edgeCharacteristics=profilingSubgraph.getEdgeCharacteristicsBySourceEdgeID(sourceEdgeID);
  edgeCharacteristics.addLatencyMeasurement(timestamp,channelLatency.getChannelLatency());
}","public void refreshEdgeLatency(long timestamp,ChannelLatency channelLatency){
  if (Double.isInfinite(channelLatency.getChannelLatency()) || Double.isNaN(channelLatency.getChannelLatency())) {
    return;
  }
  if (!channelLatency.getSourceVertexID().equals(channelLatency.getSinkVertexID())) {
    XoredVertexID xored=new XoredVertexID(channelLatency.getSourceVertexID().toManagementVertexID(),channelLatency.getSinkVertexID().toManagementVertexID());
    ManagementEdgeID sourceEdgeID=profilingSubgraph.getSourceEdgeIDByXoredVertexID(xored);
    if (sourceEdgeID == null) {
      ExecutionVertex source=executionGraph.getVertexByID(channelLatency.getSourceVertexID());
      ExecutionVertex sink=executionGraph.getVertexByID(channelLatency.getSinkVertexID());
      throw new RuntimeException(""String_Node_Str"" + getName(source) + ""String_Node_Str""+ getName(sink)+ ""String_Node_Str""+ xored.toString());
    }
    EdgeCharacteristics edgeCharacteristics=profilingSubgraph.getEdgeCharacteristicsBySourceEdgeID(sourceEdgeID);
    edgeCharacteristics.addLatencyMeasurement(timestamp,channelLatency.getChannelLatency());
  }
}"
87910,"public void refreshChannelThroughput(long timestamp,ChannelThroughput channelThroughput){
  ManagementEdgeID edgeID=new ManagementEdgeID(channelThroughput.getSourceChannelID());
  EdgeCharacteristics edgeCharaceristics=profilingSubgraph.getEdgeCharacteristicsBySourceEdgeID(edgeID);
  edgeCharaceristics.addThroughputMeasurement(timestamp,channelThroughput.getThroughput());
}","public void refreshChannelThroughput(long timestamp,ChannelThroughput channelThroughput){
  if (Double.isInfinite(channelThroughput.getThroughput()) || Double.isNaN(channelThroughput.getThroughput())) {
    return;
  }
  ManagementEdgeID edgeID=new ManagementEdgeID(channelThroughput.getSourceChannelID());
  EdgeCharacteristics edgeCharaceristics=profilingSubgraph.getEdgeCharacteristicsBySourceEdgeID(edgeID);
  edgeCharaceristics.addThroughputMeasurement(timestamp,channelThroughput.getThroughput());
}"
87911,"public void refreshTaskLatency(long timestamp,TaskLatency taskLatency){
  VertexLatency vertexLatency=profilingSubgraph.getVertexLatency(taskLatency.getVertexID().toManagementVertexID());
  vertexLatency.addLatencyMeasurement(timestamp,taskLatency.getTaskLatency());
}","public void refreshTaskLatency(long timestamp,TaskLatency taskLatency){
  if (Double.isInfinite(taskLatency.getTaskLatency()) || Double.isNaN(taskLatency.getTaskLatency())) {
    return;
  }
  VertexLatency vertexLatency=profilingSubgraph.getVertexLatency(taskLatency.getVertexID().toManagementVertexID());
  vertexLatency.addLatencyMeasurement(timestamp,taskLatency.getTaskLatency());
}"
87912,"private void initReceiverVertexToSourceEdgeIDMap(final ManagementGraph managementGraph){
  final Iterator<ManagementVertex> it=new ManagementGraphIterator(managementGraph,true);
  while (it.hasNext()) {
    final ManagementVertex source=it.next();
    final int numberOfOutputGates=source.getNumberOfOutputGates();
    for (int i=0; i < numberOfOutputGates; ++i) {
      final ManagementGate outputGate=source.getOutputGate(i);
      final int numberOfOutgoingEdges=outputGate.getNumberOfForwardEdges();
      for (int j=0; j < numberOfOutgoingEdges; ++j) {
        final ManagementEdge edge=outputGate.getForwardEdge(j);
        final ManagementVertex receiver=edge.getTarget().getVertex();
        this.receiverVertexToSourceEdgeIDMap.put(receiver.getID(),edge.getSourceEdgeID());
      }
    }
  }
}","private void initReceiverVertexToSourceEdgeIDMap(final ManagementGraph managementGraph){
  final Iterator<ManagementVertex> it=new ManagementGraphIterator(managementGraph,true);
  while (it.hasNext()) {
    final ManagementVertex source=it.next();
    final int numberOfOutputGates=source.getNumberOfOutputGates();
    for (int i=0; i < numberOfOutputGates; ++i) {
      final ManagementGate outputGate=source.getOutputGate(i);
      final int numberOfOutgoingEdges=outputGate.getNumberOfForwardEdges();
      for (int j=0; j < numberOfOutgoingEdges; ++j) {
        final ManagementEdge edge=outputGate.getForwardEdge(j);
        final ManagementVertex receiver=edge.getTarget().getVertex();
        XoredVertexID xored=new XoredVertexID(source.getID(),receiver.getID());
        System.out.println(""String_Node_Str"" + getName(source) + ""String_Node_Str""+ getName(receiver)+ ""String_Node_Str""+ xored.toString());
        this.xoredVertexToSourceEdgeIDMap.put(xored,edge.getSourceEdgeID());
      }
    }
  }
}"
87913,"/** 
 * {@inheritDoc}
 */
@Override public T readRecord(final T target) throws IOException, InterruptedException {
  T record=null;
  if (this.executingThread == null) {
    this.executingThread=Thread.currentThread();
  }
  if (this.executingThread.isInterrupted()) {
    throw new InterruptedException();
  }
  while (true) {
    if (this.channelToReadFrom == -1) {
      this.availableChannelRetVal=waitForAnyChannelToBecomeAvailable();
      this.channelToReadFrom=this.availableChannelRetVal;
    }
    try {
      record=this.getInputChannel(this.channelToReadFrom).readRecord(target);
    }
 catch (    EOFException e) {
      if (this.isClosed()) {
        return null;
      }
    }
    if (++this.channelToReadFrom == getNumberOfInputChannels()) {
      this.channelToReadFrom=0;
    }
    if (record != null) {
      break;
    }
 else {
      if (this.channelToReadFrom == this.availableChannelRetVal) {
        this.channelToReadFrom=-1;
      }
    }
  }
  this.streamListener.recordReceived(record);
  return record;
}","/** 
 * {@inheritDoc}
 */
@Override public T readRecord(final T target) throws IOException, InterruptedException {
  T record=null;
  if (this.executingThread == null) {
    this.executingThread=Thread.currentThread();
  }
  if (this.executingThread.isInterrupted()) {
    throw new InterruptedException();
  }
  final int numberOfInputChannels=getNumberOfInputChannels();
  while (true) {
    if (this.channelToReadFrom == -1) {
      this.availableChannelRetVal=waitForAnyChannelToBecomeAvailable();
      this.channelToReadFrom=this.availableChannelRetVal;
    }
    try {
      record=this.getInputChannel(this.channelToReadFrom).readRecord(target);
    }
 catch (    EOFException e) {
      if (this.isClosed()) {
        return null;
      }
    }
    if (record == null && this.channelToReadFrom == this.availableChannelRetVal) {
      this.channelToReadFrom=-1;
      continue;
    }
    if (++this.channelToReadFrom == numberOfInputChannels) {
      this.channelToReadFrom=0;
    }
    if (record != null) {
      break;
    }
  }
  this.streamListener.recordReceived(record);
  return record;
}"
87914,"@Override public void close(){
  this.running=false;
  if (this.currentBuffer.isEmpty()) {
    this.queues.empty.add(this.currentElement);
  }
 else {
    this.queues.sort.add(this.currentElement);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + this.currentElement.id + ""String_Node_Str"");
    }
  }
  this.currentBuffer=null;
  this.currentElement=null;
  this.queues.sort.add(SENTINEL);
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"");
}","@Override public void close(){
  if (this.running) {
    this.running=false;
    if (this.currentBuffer != null && this.currentElement != null) {
      if (this.currentBuffer.isEmpty()) {
        this.queues.empty.add(this.currentElement);
      }
 else {
        this.queues.sort.add(this.currentElement);
        if (LOG.isDebugEnabled()) {
          LOG.debug(""String_Node_Str"" + this.currentElement.id + ""String_Node_Str"");
        }
      }
    }
    this.currentBuffer=null;
    this.currentElement=null;
    this.queues.sort.add(SENTINEL);
  }
}"
87915,"public ProfilingValue(double value,long timestamp){
  this.value=value;
  this.timestamp=timestamp;
}","public ProfilingValue(double value,long timestamp){
  this.value=value;
  this.timestamp=timestamp;
  this.id=nextFreeId++;
}"
87916,"/** 
 * Sorts first by value and then by timestamp.
 */
@Override public int compareTo(ProfilingValue other){
  if (this.value > other.value) {
    return 1;
  }
 else   if (this.value < other.value) {
    return -1;
  }
 else {
    if (this.timestamp > other.timestamp) {
      return 1;
    }
 else     if (this.timestamp < other.timestamp) {
      return -1;
    }
 else {
      return 0;
    }
  }
}","/** 
 * Sorts first by value and then by id.
 */
@Override public int compareTo(ProfilingValue other){
  if (this.value > other.value) {
    return 1;
  }
 else   if (this.value < other.value) {
    return -1;
  }
 else {
    if (this.id > other.id) {
      return 1;
    }
 else     if (this.id < other.id) {
      return -1;
    }
 else {
      return 0;
    }
  }
}"
87917,"public ProfilingValueStatistic(int valueSetSize){
  this.sortedByTimestamp=new LinkedList<ProfilingValue>();
  this.sortedByValue=new ArrayList<ProfilingValue>();
  this.valueArraySize=valueSetSize;
  this.noOfStoredValues=0;
  this.sumOfValues=0;
}","public ProfilingValueStatistic(int statisticWindowSize){
  this.sortedById=new LinkedList<ProfilingValue>();
  this.sortedByValue=new ArrayList<ProfilingValue>();
  this.statisticWindowSize=statisticWindowSize;
  this.noOfStoredValues=0;
  this.sumOfValues=0;
}"
87918,"private ProfilingValue insertIntoSortedByTimestamp(ProfilingValue value){
  if (!sortedByTimestamp.isEmpty() && sortedByTimestamp.getLast().getTimestamp() > value.getTimestamp()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  sortedByTimestamp.add(value);
  if (noOfStoredValues >= valueArraySize) {
    return sortedByTimestamp.removeFirst();
  }
 else {
    return null;
  }
}","private ProfilingValue insertIntoSortedByTimestamp(ProfilingValue value){
  if (!sortedById.isEmpty() && sortedById.getLast().getId() >= value.getId()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  sortedById.add(value);
  if (noOfStoredValues >= statisticWindowSize) {
    return sortedById.removeFirst();
  }
 else {
    return null;
  }
}"
87919,"public static PluginID fromByteArray(final byte[] byteArray){
  if (byteArray == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (byteArray.length != SIZE) {
    throw new IllegalArgumentException(""String_Node_Str"" + SIZE);
  }
  return new PluginID(byteArray);
}","/** 
 * Constructs a new plugin ID from the given byte array.
 * @param byteArray the byte array to construct the plugin ID from
 */
public static PluginID fromByteArray(final byte[] byteArray){
  if (byteArray == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (byteArray.length != SIZE) {
    throw new IllegalArgumentException(""String_Node_Str"" + SIZE);
  }
  return new PluginID(byteArray);
}"
87920,"private PluginID(final byte[] byteArray){
  super(byteArray);
}","/** 
 * Default constructor required for the deserialization.
 */
public PluginID(){
  super();
}"
87921,"/** 
 * Creates a new file input channel and assigns it to the input gate.
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 * @return the new file input channel
 */
FileInputChannel<T> createFileInputChannel(ChannelID channelID,CompressionLevel compressionLevel);","/** 
 * Creates a new file input channel and assigns it to the given input gate.
 * @param inputGate the input gate the channel shall be assigned to
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 * @return the new file input channel
 */
FileInputChannel<T> createFileInputChannel(InputGate<T> inputGate,ChannelID channelID,CompressionLevel compressionLevel);"
87922,"/** 
 * Creates a new in-memory input channel and assigns it to the input gate.
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 * @return the new in-memory input channel
 */
InMemoryInputChannel<T> createInMemoryInputChannel(ChannelID channelID,CompressionLevel compressionLevel);","/** 
 * Creates a new in-memory input channel and assigns it to the given input gate.
 * @param inputGate the input gate the channel shall be assigned to
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 * @return the new in-memory input channel
 */
InMemoryInputChannel<T> createInMemoryInputChannel(InputGate<T> inputGate,ChannelID channelID,CompressionLevel compressionLevel);"
87923,"/** 
 * Creates a new network input channel and assigns it to the input gate.
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 * @return the new network input channel
 */
NetworkInputChannel<T> createNetworkInputChannel(ChannelID channelID,CompressionLevel compressionLevel);","/** 
 * Creates a new network input channel and assigns it to the given input gate.
 * @param inputGate the input gate the channel shall be assigned to
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 * @return the new network input channel
 */
NetworkInputChannel<T> createNetworkInputChannel(InputGate<T> inputGate,ChannelID channelID,CompressionLevel compressionLevel);"
87924,"/** 
 * Creates a new in-memory output channel and assigns it to the output gate.
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 * @return the new in-memory output channel
 */
InMemoryOutputChannel<T> createInMemoryOutputChannel(ChannelID channelID,CompressionLevel compressionLevel);","/** 
 * Creates a new in-memory output channel and assigns it to the given output gate.
 * @param outputGate the output gate the channel shall be assigned to
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 * @return the new in-memory output channel
 */
InMemoryOutputChannel<T> createInMemoryOutputChannel(OutputGate<T> outputGate,ChannelID channelID,CompressionLevel compressionLevel);"
87925,"/** 
 * Creates a new network output channel and assigns it to the output gate.
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 * @return the new network output channel
 */
NetworkOutputChannel<T> createNetworkOutputChannel(ChannelID channelID,CompressionLevel compressionLevel);","/** 
 * Creates a new network output channel and assigns it to the given output gate.
 * @param outputGate the output gate the channel shall be assigned to
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 * @return the new network output channel
 */
NetworkOutputChannel<T> createNetworkOutputChannel(OutputGate<T> outputGate,ChannelID channelID,CompressionLevel compressionLevel);"
87926,"/** 
 * Creates a new file output channel and assigns it to the output gate.
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 * @return the new file output channel
 */
FileOutputChannel<T> createFileOutputChannel(ChannelID channelID,CompressionLevel compressionLevel);","/** 
 * Creates a new file output channel and assigns it to the given output gate.
 * @param outputGate the output gate the channel shall be assigned to
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 * @return the new file output channel
 */
FileOutputChannel<T> createFileOutputChannel(OutputGate<T> outputGate,ChannelID channelID,CompressionLevel compressionLevel);"
87927,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public void read(final DataInput in) throws IOException {
  this.jobID=new JobID();
  this.jobID.read(in);
  this.taskName=StringRecord.readString(in);
  final String[] requiredJarFiles=new String[in.readInt()];
  for (int i=0; i < requiredJarFiles.length; i++) {
    requiredJarFiles[i]=StringRecord.readString(in);
  }
  LibraryCacheManager.register(this.jobID,requiredJarFiles);
  final ClassLoader cl=LibraryCacheManager.getClassLoader(this.jobID);
  final String invokableClassName=StringRecord.readString(in);
  if (invokableClassName == null) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    this.invokableClass=(Class<? extends AbstractInvokable>)Class.forName(invokableClassName,true,cl);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IOException(""String_Node_Str"" + invokableClassName + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
  }
  final int numOuputGates=in.readInt();
  for (int i=0; i < numOuputGates; i++) {
    final GateID gateID=new GateID();
    gateID.read(in);
    this.unboundOutputGateIDs.add(gateID);
  }
  final int numInputGates=in.readInt();
  for (int i=0; i < numInputGates; i++) {
    final GateID gateID=new GateID();
    gateID.read(in);
    this.unboundInputGateIDs.add(gateID);
  }
  this.taskConfiguration=new Configuration();
  this.taskConfiguration.read(in);
  this.jobConfiguration=new Configuration();
  this.jobConfiguration.read(in);
  this.currentNumberOfSubtasks=in.readInt();
  this.indexInSubtaskGroup=in.readInt();
  try {
    instantiateInvokable();
  }
 catch (  Exception e) {
    throw new IOException(StringUtils.stringifyException(e));
  }
  for (int i=0; i < numOuputGates; ++i) {
    final OutputGate<? extends Record> outputGate=this.outputGates.get(i);
    final int numberOfOutputChannels=in.readInt();
    for (int j=0; j < numberOfOutputChannels; ++j) {
      final ChannelID channelID=new ChannelID();
      channelID.read(in);
      final ChannelID connectedChannelID=new ChannelID();
      connectedChannelID.read(in);
      final ChannelType channelType=EnumUtils.readEnum(in,ChannelType.class);
      final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
      AbstractOutputChannel<? extends Record> outputChannel=null;
switch (channelType) {
case INMEMORY:
        outputChannel=outputGate.createInMemoryOutputChannel(channelID,compressionLevel);
      break;
case NETWORK:
    outputChannel=outputGate.createNetworkOutputChannel(channelID,compressionLevel);
  break;
case FILE:
outputChannel=outputGate.createFileOutputChannel(channelID,compressionLevel);
break;
}
if (outputChannel == null) {
throw new IOException(""String_Node_Str"" + channelID);
}
outputChannel.setConnectedChannelID(connectedChannelID);
}
}
for (int i=0; i < numInputGates; ++i) {
final InputGate<? extends Record> inputGate=this.inputGates.get(i);
final int numberOfInputChannels=in.readInt();
for (int j=0; j < numberOfInputChannels; ++j) {
final ChannelID channelID=new ChannelID();
channelID.read(in);
final ChannelID connectedChannelID=new ChannelID();
connectedChannelID.read(in);
final ChannelType channelType=EnumUtils.readEnum(in,ChannelType.class);
final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
AbstractInputChannel<? extends Record> inputChannel=null;
switch (channelType) {
case INMEMORY:
inputChannel=inputGate.createInMemoryInputChannel(channelID,compressionLevel);
break;
case NETWORK:
inputChannel=inputGate.createNetworkInputChannel(channelID,compressionLevel);
break;
case FILE:
inputChannel=inputGate.createFileInputChannel(channelID,compressionLevel);
break;
}
if (inputChannel == null) {
throw new IOException(""String_Node_Str"" + channelID);
}
inputChannel.setConnectedChannelID(connectedChannelID);
}
}
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void read(final DataInput in) throws IOException {
  this.jobID=new JobID();
  this.jobID.read(in);
  this.taskName=StringRecord.readString(in);
  final String[] requiredJarFiles=new String[in.readInt()];
  for (int i=0; i < requiredJarFiles.length; i++) {
    requiredJarFiles[i]=StringRecord.readString(in);
  }
  LibraryCacheManager.register(this.jobID,requiredJarFiles);
  final ClassLoader cl=LibraryCacheManager.getClassLoader(this.jobID);
  final String invokableClassName=StringRecord.readString(in);
  if (invokableClassName == null) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    this.invokableClass=(Class<? extends AbstractInvokable>)Class.forName(invokableClassName,true,cl);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IOException(""String_Node_Str"" + invokableClassName + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
  }
  final int numOuputGates=in.readInt();
  for (int i=0; i < numOuputGates; i++) {
    final GateID gateID=new GateID();
    gateID.read(in);
    this.unboundOutputGateIDs.add(gateID);
  }
  final int numInputGates=in.readInt();
  for (int i=0; i < numInputGates; i++) {
    final GateID gateID=new GateID();
    gateID.read(in);
    this.unboundInputGateIDs.add(gateID);
  }
  this.taskConfiguration=new Configuration();
  this.taskConfiguration.read(in);
  this.jobConfiguration=new Configuration();
  this.jobConfiguration.read(in);
  this.currentNumberOfSubtasks=in.readInt();
  this.indexInSubtaskGroup=in.readInt();
  try {
    instantiateInvokable();
  }
 catch (  Exception e) {
    throw new IOException(StringUtils.stringifyException(e));
  }
  for (int i=0; i < numOuputGates; ++i) {
    final OutputGate<? extends Record> outputGate=this.outputGates.get(i);
    final int numberOfOutputChannels=in.readInt();
    for (int j=0; j < numberOfOutputChannels; ++j) {
      final ChannelID channelID=new ChannelID();
      channelID.read(in);
      final ChannelID connectedChannelID=new ChannelID();
      connectedChannelID.read(in);
      final ChannelType channelType=EnumUtils.readEnum(in,ChannelType.class);
      final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
      AbstractOutputChannel<? extends Record> outputChannel=null;
switch (channelType) {
case INMEMORY:
        outputChannel=outputGate.createInMemoryOutputChannel((OutputGate)outputGate,channelID,compressionLevel);
      break;
case NETWORK:
    outputChannel=outputGate.createNetworkOutputChannel((OutputGate)outputGate,channelID,compressionLevel);
  break;
case FILE:
outputChannel=outputGate.createFileOutputChannel((OutputGate)outputGate,channelID,compressionLevel);
break;
}
if (outputChannel == null) {
throw new IOException(""String_Node_Str"" + channelID);
}
outputChannel.setConnectedChannelID(connectedChannelID);
}
}
for (int i=0; i < numInputGates; ++i) {
final InputGate<? extends Record> inputGate=this.inputGates.get(i);
final int numberOfInputChannels=in.readInt();
for (int j=0; j < numberOfInputChannels; ++j) {
final ChannelID channelID=new ChannelID();
channelID.read(in);
final ChannelID connectedChannelID=new ChannelID();
connectedChannelID.read(in);
final ChannelType channelType=EnumUtils.readEnum(in,ChannelType.class);
final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
AbstractInputChannel<? extends Record> inputChannel=null;
switch (channelType) {
case INMEMORY:
inputChannel=inputGate.createInMemoryInputChannel((InputGate)inputGate,channelID,compressionLevel);
break;
case NETWORK:
inputChannel=inputGate.createNetworkInputChannel((InputGate)inputGate,channelID,compressionLevel);
break;
case FILE:
inputChannel=inputGate.createFileInputChannel((InputGate)inputGate,channelID,compressionLevel);
break;
}
if (inputChannel == null) {
throw new IOException(""String_Node_Str"" + channelID);
}
inputChannel.setConnectedChannelID(connectedChannelID);
}
}
}"
87928,"private void createChannel(final ExecutionVertex source,final OutputGate<? extends Record> outputGate,final ExecutionVertex target,final InputGate<? extends Record> inputGate,final ChannelType channelType,final CompressionLevel compressionLevel) throws GraphConversionException {
  AbstractOutputChannel<? extends Record> outputChannel;
  AbstractInputChannel<? extends Record> inputChannel;
switch (channelType) {
case NETWORK:
    outputChannel=outputGate.createNetworkOutputChannel(null,compressionLevel);
  inputChannel=inputGate.createNetworkInputChannel(null,compressionLevel);
break;
case INMEMORY:
outputChannel=outputGate.createInMemoryOutputChannel(null,compressionLevel);
inputChannel=inputGate.createInMemoryInputChannel(null,compressionLevel);
break;
case FILE:
outputChannel=outputGate.createFileOutputChannel(null,compressionLevel);
inputChannel=inputGate.createFileInputChannel(null,compressionLevel);
break;
default :
throw new GraphConversionException(""String_Node_Str"");
}
inputChannel.setConnectedChannelID(outputChannel.getID());
outputChannel.setConnectedChannelID(inputChannel.getID());
this.outputChannelMap.put(outputChannel.getID(),outputChannel);
this.inputChannelMap.put(inputChannel.getID(),inputChannel);
this.channelToVertexMap.put(outputChannel.getID(),source);
this.channelToVertexMap.put(inputChannel.getID(),target);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void createChannel(final ExecutionVertex source,final OutputGate<? extends Record> outputGate,final ExecutionVertex target,final InputGate<? extends Record> inputGate,final ChannelType channelType,final CompressionLevel compressionLevel) throws GraphConversionException {
  AbstractOutputChannel<? extends Record> outputChannel;
  AbstractInputChannel<? extends Record> inputChannel;
switch (channelType) {
case NETWORK:
    outputChannel=outputGate.createNetworkOutputChannel((OutputGate)outputGate,null,compressionLevel);
  inputChannel=inputGate.createNetworkInputChannel((InputGate)inputGate,null,compressionLevel);
break;
case INMEMORY:
outputChannel=outputGate.createInMemoryOutputChannel((OutputGate)outputGate,null,compressionLevel);
inputChannel=inputGate.createInMemoryInputChannel((InputGate)inputGate,null,compressionLevel);
break;
case FILE:
outputChannel=outputGate.createFileOutputChannel((OutputGate)outputGate,null,compressionLevel);
inputChannel=inputGate.createFileInputChannel((InputGate)inputGate,null,compressionLevel);
break;
default :
throw new GraphConversionException(""String_Node_Str"");
}
inputChannel.setConnectedChannelID(outputChannel.getID());
outputChannel.setConnectedChannelID(inputChannel.getID());
this.outputChannelMap.put(outputChannel.getID(),outputChannel);
this.inputChannelMap.put(inputChannel.getID(),inputChannel);
this.channelToVertexMap.put(outputChannel.getID(),source);
this.channelToVertexMap.put(inputChannel.getID(),target);
}"
87929,"private static void addExecutionVertices(Map<ExecutionGroupVertex,ManagementGroupVertex> groupMap,ExecutionGraph executionGraph){
  ExecutionGraphIterator iterator=new ExecutionGraphIterator(executionGraph,true);
  final Map<ExecutionVertex,ManagementVertex> vertexMap=new HashMap<ExecutionVertex,ManagementVertex>();
  final Map<Gate<? extends Record>,ManagementGate> gateMap=new HashMap<Gate<? extends Record>,ManagementGate>();
  while (iterator.hasNext()) {
    final ExecutionVertex ev=iterator.next();
    final ManagementGroupVertex parent=groupMap.get(ev.getGroupVertex());
    final ManagementVertex managementVertex=new ManagementVertex(parent,ev.getID().toManagementVertexID(),(ev.getAllocatedResource().getInstance().getInstanceConnectionInfo() != null) ? ev.getAllocatedResource().getInstance().getInstanceConnectionInfo().toString() : ev.getAllocatedResource().getInstance().toString(),ev.getAllocatedResource().getInstance().getType().toString(),ev.getCheckpointState().toString(),ev.getEnvironment().getIndexInSubtaskGroup());
    managementVertex.setExecutionState(ev.getExecutionState());
    vertexMap.put(ev,managementVertex);
    for (int i=0; i < ev.getEnvironment().getNumberOfOutputGates(); i++) {
      final OutputGate<? extends Record> outputGate=ev.getEnvironment().getOutputGate(i);
      final ManagementGate managementGate=new ManagementGate(managementVertex,new ManagementGateID(),i,false,outputGate.getType().toString());
      gateMap.put(outputGate,managementGate);
    }
    for (int i=0; i < ev.getEnvironment().getNumberOfInputGates(); i++) {
      final InputGate<? extends Record> inputGate=ev.getEnvironment().getInputGate(i);
      final ManagementGate managementGate=new ManagementGate(managementVertex,new ManagementGateID(),i,true,""String_Node_Str"");
      gateMap.put(inputGate,managementGate);
    }
  }
  iterator=new ExecutionGraphIterator(executionGraph,true);
  while (iterator.hasNext()) {
    final ExecutionVertex source=iterator.next();
    for (int i=0; i < source.getEnvironment().getNumberOfOutputGates(); i++) {
      final RuntimeOutputGate<? extends Record> outputGate=(RuntimeOutputGate<? extends Record>)source.getEnvironment().getOutputGate(i);
      final ManagementGate manangementOutputGate=gateMap.get(outputGate);
      for (int j=0; j < outputGate.getNumberOfOutputChannels(); j++) {
        final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
        final ChannelID inputChannelID=outputChannel.getConnectedChannelID();
        final AbstractInputChannel<? extends Record> inputChannel=executionGraph.getInputChannelByID(inputChannelID);
        final ManagementGate managementInputGate=gateMap.get(inputChannel.getInputGate());
        final ManagementEdgeID managementEdgeID=new ManagementEdgeID(manangementOutputGate.getVertex().getID(),managementInputGate.getVertex().getID());
        new ManagementEdge(managementEdgeID,manangementOutputGate,j,managementInputGate,inputChannel.getChannelIndex(),inputChannel.getType(),inputChannel.getCompressionLevel());
      }
    }
  }
}","private static void addExecutionVertices(Map<ExecutionGroupVertex,ManagementGroupVertex> groupMap,ExecutionGraph executionGraph){
  ExecutionGraphIterator iterator=new ExecutionGraphIterator(executionGraph,true);
  final Map<ExecutionVertex,ManagementVertex> vertexMap=new HashMap<ExecutionVertex,ManagementVertex>();
  final Map<Gate<? extends Record>,ManagementGate> gateMap=new HashMap<Gate<? extends Record>,ManagementGate>();
  while (iterator.hasNext()) {
    final ExecutionVertex ev=iterator.next();
    final ManagementGroupVertex parent=groupMap.get(ev.getGroupVertex());
    final ManagementVertex managementVertex=new ManagementVertex(parent,ev.getID().toManagementVertexID(),(ev.getAllocatedResource().getInstance().getInstanceConnectionInfo() != null) ? ev.getAllocatedResource().getInstance().getInstanceConnectionInfo().toString() : ev.getAllocatedResource().getInstance().toString(),ev.getAllocatedResource().getInstance().getType().toString(),ev.getCheckpointState().toString(),ev.getEnvironment().getIndexInSubtaskGroup());
    managementVertex.setExecutionState(ev.getExecutionState());
    vertexMap.put(ev,managementVertex);
    for (int i=0; i < ev.getEnvironment().getNumberOfOutputGates(); i++) {
      final OutputGate<? extends Record> outputGate=ev.getEnvironment().getOutputGate(i);
      final ManagementGate managementGate=new ManagementGate(managementVertex,new ManagementGateID(),i,false,outputGate.getType().toString());
      gateMap.put(outputGate,managementGate);
    }
    for (int i=0; i < ev.getEnvironment().getNumberOfInputGates(); i++) {
      final InputGate<? extends Record> inputGate=ev.getEnvironment().getInputGate(i);
      final ManagementGate managementGate=new ManagementGate(managementVertex,new ManagementGateID(),i,true,""String_Node_Str"");
      gateMap.put(inputGate,managementGate);
    }
  }
  iterator=new ExecutionGraphIterator(executionGraph,true);
  while (iterator.hasNext()) {
    final ExecutionVertex source=iterator.next();
    for (int i=0; i < source.getEnvironment().getNumberOfOutputGates(); i++) {
      final OutputGate<? extends Record> outputGate=source.getEnvironment().getOutputGate(i);
      final ManagementGate manangementOutputGate=gateMap.get(outputGate);
      for (int j=0; j < outputGate.getNumberOfOutputChannels(); j++) {
        final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
        final ChannelID inputChannelID=outputChannel.getConnectedChannelID();
        final AbstractInputChannel<? extends Record> inputChannel=executionGraph.getInputChannelByID(inputChannelID);
        final ManagementGate managementInputGate=gateMap.get(inputChannel.getInputGate());
        final ManagementEdgeID managementEdgeID=new ManagementEdgeID(manangementOutputGate.getVertex().getID(),managementInputGate.getVertex().getID());
        new ManagementEdge(managementEdgeID,manangementOutputGate,j,managementInputGate,inputChannel.getChannelIndex(),inputChannel.getType(),inputChannel.getCompressionLevel());
      }
    }
  }
}"
87930,"/** 
 * {@inheritDoc}
 */
@Override public InMemoryInputChannel<T> createInMemoryInputChannel(final ChannelID channelID,final CompressionLevel compressionLevel){
  final InMemoryInputChannel<T> eimic=new InMemoryInputChannel<T>(this,this.inputChannels.size(),deserializer,channelID,compressionLevel);
  addInputChannel(eimic);
  return eimic;
}","/** 
 * {@inheritDoc}
 */
@Override public InMemoryInputChannel<T> createInMemoryInputChannel(final InputGate<T> inputGate,final ChannelID channelID,final CompressionLevel compressionLevel){
  final InMemoryInputChannel<T> eimic=new InMemoryInputChannel<T>(inputGate,this.inputChannels.size(),this.deserializer,channelID,compressionLevel);
  addInputChannel(eimic);
  return eimic;
}"
87931,"/** 
 * {@inheritDoc}
 */
@Override public FileInputChannel<T> createFileInputChannel(final ChannelID channelID,final CompressionLevel compressionLevel){
  final FileInputChannel<T> efic=new FileInputChannel<T>(this,this.inputChannels.size(),deserializer,channelID,compressionLevel);
  addInputChannel(efic);
  return efic;
}","/** 
 * {@inheritDoc}
 */
@Override public FileInputChannel<T> createFileInputChannel(final InputGate<T> inputGate,final ChannelID channelID,final CompressionLevel compressionLevel){
  final FileInputChannel<T> efic=new FileInputChannel<T>(inputGate,this.inputChannels.size(),this.deserializer,channelID,compressionLevel);
  addInputChannel(efic);
  return efic;
}"
87932,"/** 
 * {@inheritDoc}
 */
@Override public NetworkInputChannel<T> createNetworkInputChannel(final ChannelID channelID,final CompressionLevel compressionLevel){
  final NetworkInputChannel<T> enic=new NetworkInputChannel<T>(this,this.inputChannels.size(),deserializer,channelID,compressionLevel);
  addInputChannel(enic);
  return enic;
}","/** 
 * {@inheritDoc}
 */
@Override public NetworkInputChannel<T> createNetworkInputChannel(final InputGate<T> inputGate,final ChannelID channelID,final CompressionLevel compressionLevel){
  final NetworkInputChannel<T> enic=new NetworkInputChannel<T>(inputGate,this.inputChannels.size(),this.deserializer,channelID,compressionLevel);
  addInputChannel(enic);
  return enic;
}"
87933,"/** 
 * {@inheritDoc}
 */
@Override public InMemoryOutputChannel<T> createInMemoryOutputChannel(final ChannelID channelID,final CompressionLevel compressionLevel){
  final InMemoryOutputChannel<T> einoc=new InMemoryOutputChannel<T>(this,this.outputChannels.size(),channelID,compressionLevel);
  addOutputChannel(einoc);
  return einoc;
}","/** 
 * {@inheritDoc}
 */
@Override public InMemoryOutputChannel<T> createInMemoryOutputChannel(final OutputGate<T> outputGate,final ChannelID channelID,final CompressionLevel compressionLevel){
  final InMemoryOutputChannel<T> einoc=new InMemoryOutputChannel<T>(outputGate,this.outputChannels.size(),channelID,compressionLevel);
  addOutputChannel(einoc);
  return einoc;
}"
87934,"/** 
 * {@inheritDoc}
 */
@Override public NetworkOutputChannel<T> createNetworkOutputChannel(final ChannelID channelID,final CompressionLevel compressionLevel){
  final NetworkOutputChannel<T> enoc=new NetworkOutputChannel<T>(this,this.outputChannels.size(),channelID,compressionLevel);
  addOutputChannel(enoc);
  return enoc;
}","/** 
 * {@inheritDoc}
 */
@Override public NetworkOutputChannel<T> createNetworkOutputChannel(final OutputGate<T> outputGate,final ChannelID channelID,final CompressionLevel compressionLevel){
  final NetworkOutputChannel<T> enoc=new NetworkOutputChannel<T>(outputGate,this.outputChannels.size(),channelID,compressionLevel);
  addOutputChannel(enoc);
  return enoc;
}"
87935,"/** 
 * {@inheritDoc}
 */
@Override public FileOutputChannel<T> createFileOutputChannel(final ChannelID channelID,final CompressionLevel compressionLevel){
  final FileOutputChannel<T> efoc=new FileOutputChannel<T>(this,this.outputChannels.size(),channelID,compressionLevel);
  addOutputChannel(efoc);
  return efoc;
}","/** 
 * {@inheritDoc}
 */
@Override public FileOutputChannel<T> createFileOutputChannel(final OutputGate<T> outputGate,final ChannelID channelID,final CompressionLevel compressionLevel){
  final FileOutputChannel<T> efoc=new FileOutputChannel<T>(outputGate,this.outputChannels.size(),channelID,compressionLevel);
  addOutputChannel(efoc);
  return efoc;
}"
87936,"/** 
 * {@inheritDoc}
 */
@Override public NetworkInputChannel<T> createNetworkInputChannel(final ChannelID channelID,final CompressionLevel compressionLevel){
  return this.wrappedInputGate.createNetworkInputChannel(channelID,compressionLevel);
}","/** 
 * {@inheritDoc}
 */
@Override public NetworkInputChannel<T> createNetworkInputChannel(final InputGate<T> inputGate,final ChannelID channelID,final CompressionLevel compressionLevel){
  return this.wrappedInputGate.createNetworkInputChannel(inputGate,channelID,compressionLevel);
}"
87937,"/** 
 * {@inheritDoc}
 */
@Override public InMemoryInputChannel<T> createInMemoryInputChannel(final ChannelID channelID,final CompressionLevel compressionLevel){
  return this.wrappedInputGate.createInMemoryInputChannel(channelID,compressionLevel);
}","/** 
 * {@inheritDoc}
 */
@Override public InMemoryInputChannel<T> createInMemoryInputChannel(final InputGate<T> inputGate,final ChannelID channelID,final CompressionLevel compressionLevel){
  return this.wrappedInputGate.createInMemoryInputChannel(inputGate,channelID,compressionLevel);
}"
87938,"/** 
 * {@inheritDoc}
 */
@Override public FileInputChannel<T> createFileInputChannel(final ChannelID channelID,final CompressionLevel compressionLevel){
  return this.wrappedInputGate.createFileInputChannel(channelID,compressionLevel);
}","/** 
 * {@inheritDoc}
 */
@Override public FileInputChannel<T> createFileInputChannel(final InputGate<T> inputGate,final ChannelID channelID,final CompressionLevel compressionLevel){
  return this.wrappedInputGate.createFileInputChannel(inputGate,channelID,compressionLevel);
}"
87939,"/** 
 * {@inheritDoc}
 */
@Override public InMemoryOutputChannel<T> createInMemoryOutputChannel(final ChannelID channelID,final CompressionLevel compressionLevel){
  return this.wrappedOutputGate.createInMemoryOutputChannel(channelID,compressionLevel);
}","/** 
 * {@inheritDoc}
 */
@Override public InMemoryOutputChannel<T> createInMemoryOutputChannel(final OutputGate<T> outputGate,final ChannelID channelID,final CompressionLevel compressionLevel){
  return this.wrappedOutputGate.createInMemoryOutputChannel(outputGate,channelID,compressionLevel);
}"
87940,"/** 
 * {@inheritDoc}
 */
@Override public NetworkOutputChannel<T> createNetworkOutputChannel(final ChannelID channelID,final CompressionLevel compressionLevel){
  return this.wrappedOutputGate.createNetworkOutputChannel(channelID,compressionLevel);
}","/** 
 * {@inheritDoc}
 */
@Override public NetworkOutputChannel<T> createNetworkOutputChannel(final OutputGate<T> outputGate,final ChannelID channelID,final CompressionLevel compressionLevel){
  return this.wrappedOutputGate.createNetworkOutputChannel(outputGate,channelID,compressionLevel);
}"
87941,"/** 
 * {@inheritDoc}
 */
@Override public FileOutputChannel<T> createFileOutputChannel(final ChannelID channelID,final CompressionLevel compressionLevel){
  return this.wrappedOutputGate.createFileOutputChannel(channelID,compressionLevel);
}","/** 
 * {@inheritDoc}
 */
@Override public FileOutputChannel<T> createFileOutputChannel(final OutputGate<T> outputGate,final ChannelID channelID,final CompressionLevel compressionLevel){
  return this.wrappedOutputGate.createFileOutputChannel(outputGate,channelID,compressionLevel);
}"
87942,"/** 
 * {@inheritDoc}
 */
@Override public void read(final DataInput in) throws IOException {
  this.sourceChannelID.read(in);
  this.bufferSize=in.readInt();
}","/** 
 * {@inheritDoc}
 */
@Override public void read(final DataInput in) throws IOException {
  super.read(in);
  this.sourceChannelID.read(in);
  this.bufferSize=in.readInt();
}"
87943,"/** 
 * {@inheritDoc}
 */
@Override public void write(final DataOutput out) throws IOException {
  this.sourceChannelID.write(out);
  out.writeInt(this.bufferSize);
}","/** 
 * {@inheritDoc}
 */
@Override public void write(final DataOutput out) throws IOException {
  super.write(out);
  this.sourceChannelID.write(out);
  out.writeInt(this.bufferSize);
}"
87944,"public void refreshEdgeLatency(PathLatency pathLatency){
}","public void refreshEdgeLatency(PathLatency pathLatency){
  LOG.info(""String_Node_Str"" + pathLatency);
}"
87945,"public LatencyOptimizerThread(ExecutionGraph executionGraph){
  this.latencyModel=new LatencyModel(executionGraph);
  this.streamingDataQueue=new LinkedBlockingQueue<AbstractStreamingData>();
}","public LatencyOptimizerThread(ExecutionGraph executionGraph){
  this.executionGraph=executionGraph;
  this.latencyModel=new LatencyModel(executionGraph);
  this.streamingDataQueue=new LinkedBlockingQueue<AbstractStreamingData>();
}"
87946,"public void run(){
  try {
    while (!interrupted()) {
      AbstractStreamingData streamingData=streamingDataQueue.take();
      if (streamingData instanceof PathLatency) {
        latencyModel.refreshEdgeLatency((PathLatency)streamingData);
      }
    }
  }
 catch (  InterruptedException e) {
  }
}","public void run(){
  LOG.info(""String_Node_Str"" + executionGraph.getJobName());
  try {
    while (!interrupted()) {
      AbstractStreamingData streamingData=streamingDataQueue.take();
      if (streamingData instanceof PathLatency) {
        latencyModel.refreshEdgeLatency((PathLatency)streamingData);
      }
    }
  }
 catch (  InterruptedException e) {
  }
  LOG.info(""String_Node_Str"" + executionGraph.getJobName());
}"
87947,"public ManagementVertex getEnd(){
  return pathVertices.getFirst();
}","public ManagementVertex getEnd(){
  return pathVertices.getLast();
}"
87948,"/** 
 * Output Schema: Key: C_MKTSEGMENT Value: 0:PARTIAL_COUNT=1
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  value2.getField(1,mktSeg);
  value2.setField(0,mktSeg);
  value2.setField(1,oneInteger);
  out.collect(value2);
}","/** 
 * Output Schema: Key: C_MKTSEGMENT Value: 0:PARTIAL_COUNT=1
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  mktSeg=value2.getField(1,mktSeg);
  value2.setField(0,mktSeg);
  value2.setField(1,oneInteger);
  out.collect(value2);
}"
87949,"/** 
 * Output Schema: Key: CUSTOMERKEY Value: 0:MKTSEGMENT
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  record.getField(1,value);
  PactString mktSegment=new PactString(value.getStringValueAt(6));
  record.setField(1,mktSegment);
  out.collect(record);
}","/** 
 * Output Schema: Key: CUSTOMERKEY Value: 0:MKTSEGMENT
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  value=record.getField(1,value);
  PactString mktSegment=new PactString(value.getStringValueAt(6));
  record.setField(1,mktSegment);
  out.collect(record);
}"
87950,"@Override public void coGroup(Iterator<PactRecord> records1,Iterator<PactRecord> records2,Collector out){
  int sum=0;
  LOG.debug(""String_Node_Str"");
  while (records1.hasNext()) {
    record=records1.next();
    record.getField(0,keyString);
    record.getField(1,valueString);
    sum+=Integer.parseInt(valueString.getValue());
    LOG.debug(""String_Node_Str"" + keyString.getValue() + ""String_Node_Str""+ valueString.getValue()+ ""String_Node_Str"");
  }
  LOG.debug(""String_Node_Str"");
  while (records2.hasNext()) {
    record=records2.next();
    record.getField(0,keyString);
    record.getField(1,valueString);
    sum-=Integer.parseInt(valueString.getValue());
    LOG.debug(""String_Node_Str"" + keyString.getValue() + ""String_Node_Str""+ valueString.getValue()+ ""String_Node_Str"");
  }
  record.setField(1,new PactInteger(sum));
  LOG.debug(""String_Node_Str"");
  out.collect(record);
}","@Override public void coGroup(Iterator<PactRecord> records1,Iterator<PactRecord> records2,Collector out){
  int sum=0;
  LOG.debug(""String_Node_Str"");
  while (records1.hasNext()) {
    record=records1.next();
    keyString=record.getField(0,keyString);
    valueString=record.getField(1,valueString);
    sum+=Integer.parseInt(valueString.getValue());
    LOG.debug(""String_Node_Str"" + keyString.getValue() + ""String_Node_Str""+ valueString.getValue()+ ""String_Node_Str"");
  }
  LOG.debug(""String_Node_Str"");
  while (records2.hasNext()) {
    record=records2.next();
    keyString=record.getField(0,keyString);
    valueString=record.getField(1,valueString);
    sum-=Integer.parseInt(valueString.getValue());
    LOG.debug(""String_Node_Str"" + keyString.getValue() + ""String_Node_Str""+ valueString.getValue()+ ""String_Node_Str"");
  }
  record.setField(1,new PactInteger(sum));
  LOG.debug(""String_Node_Str"");
  out.collect(record);
}"
87951,"@Override public void cross(PactRecord record1,PactRecord record2,Collector out){
  record1.getField(1,string);
  int val1=Integer.parseInt(string.toString());
  record2.getField(1,string);
  int val2=Integer.parseInt(string.toString());
  record1.getField(0,string);
  int key1=Integer.parseInt(string.toString());
  record2.getField(0,string);
  int key2=Integer.parseInt(string.toString());
  LOG.debug(""String_Node_Str"" + key1 + ""String_Node_Str""+ val1+ ""String_Node_Str""+ key2+ ""String_Node_Str""+ val2+ ""String_Node_Str"");
  if (val1 + val2 <= 6) {
    string.setValue((key1 + key2 + 2) + ""String_Node_Str"");
    integer.setValue(val2 - val1 + 1);
    record1.setField(0,string);
    record1.setField(1,integer);
    out.collect(record1);
  }
}","@Override public void cross(PactRecord record1,PactRecord record2,Collector out){
  string=record1.getField(1,string);
  int val1=Integer.parseInt(string.toString());
  string=record2.getField(1,string);
  int val2=Integer.parseInt(string.toString());
  string=record1.getField(0,string);
  int key1=Integer.parseInt(string.toString());
  string=record2.getField(0,string);
  int key2=Integer.parseInt(string.toString());
  LOG.debug(""String_Node_Str"" + key1 + ""String_Node_Str""+ val1+ ""String_Node_Str""+ key2+ ""String_Node_Str""+ val2+ ""String_Node_Str"");
  if (val1 + val2 <= 6) {
    string.setValue((key1 + key2 + 2) + ""String_Node_Str"");
    integer.setValue(val2 - val1 + 1);
    record1.setField(0,string);
    record1.setField(1,integer);
    out.collect(record1);
  }
}"
87952,"@Override public void map(PactRecord record,Collector out) throws Exception {
  record.getField(0,keyString);
  record.getField(1,valueString);
  LOG.debug(""String_Node_Str"" + keyString.toString() + ""String_Node_Str""+ valueString.getValue()+ ""String_Node_Str"");
  if (Integer.parseInt(keyString.toString()) + Integer.parseInt(valueString.toString()) < 10) {
    record.setField(0,valueString);
    record.setField(1,new PactInteger(Integer.parseInt(keyString.toString()) + 10));
    out.collect(record);
  }
}","@Override public void map(PactRecord record,Collector out) throws Exception {
  keyString=record.getField(0,keyString);
  valueString=record.getField(1,valueString);
  LOG.debug(""String_Node_Str"" + keyString.toString() + ""String_Node_Str""+ valueString.getValue()+ ""String_Node_Str"");
  if (Integer.parseInt(keyString.toString()) + Integer.parseInt(valueString.toString()) < 10) {
    record.setField(0,valueString);
    record.setField(1,new PactInteger(Integer.parseInt(keyString.toString()) + 10));
    out.collect(record);
  }
}"
87953,"@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  value1.getField(0,keyString);
  keyString.setValue(""String_Node_Str"" + (Integer.parseInt(keyString.getValue()) + 1));
  value1.setField(0,keyString);
  value1.getField(1,valueString);
  int val1=Integer.parseInt(valueString.getValue()) + 2;
  value2.getField(1,valueString);
  int val2=Integer.parseInt(valueString.getValue()) + 1;
  value1.setField(1,new PactInteger(val1 - val2));
  out.collect(value1);
  LOG.debug(""String_Node_Str"" + keyString.toString() + ""String_Node_Str""+ val1+ ""String_Node_Str""+ ""String_Node_Str""+ keyString.toString()+ ""String_Node_Str""+ val2+ ""String_Node_Str"");
}","@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  keyString=value1.getField(0,keyString);
  keyString.setValue(""String_Node_Str"" + (Integer.parseInt(keyString.getValue()) + 1));
  value1.setField(0,keyString);
  valueString=value1.getField(1,valueString);
  int val1=Integer.parseInt(valueString.getValue()) + 2;
  valueString=value2.getField(1,valueString);
  int val2=Integer.parseInt(valueString.getValue()) + 1;
  value1.setField(1,new PactInteger(val1 - val2));
  out.collect(value1);
  LOG.debug(""String_Node_Str"" + keyString.toString() + ""String_Node_Str""+ val1+ ""String_Node_Str""+ ""String_Node_Str""+ keyString.toString()+ ""String_Node_Str""+ val2+ ""String_Node_Str"");
}"
87954,"@Override public void reduce(Iterator<PactRecord> records,Collector out) throws Exception {
  int sum=0;
  PactRecord record=new PactRecord();
  while (records.hasNext()) {
    record=records.next();
    record.getField(1,reduceValue);
    sum+=Integer.parseInt(reduceValue.toString());
    LOG.debug(""String_Node_Str"" + record.getField(0,PactString.class).toString() + ""String_Node_Str""+ reduceValue.toString()+ ""String_Node_Str"");
  }
  record.setField(1,new PactInteger(sum));
  out.collect(record);
}","@Override public void reduce(Iterator<PactRecord> records,Collector out) throws Exception {
  int sum=0;
  PactRecord record=new PactRecord();
  while (records.hasNext()) {
    record=records.next();
    reduceValue=record.getField(1,reduceValue);
    sum+=Integer.parseInt(reduceValue.toString());
    LOG.debug(""String_Node_Str"" + record.getField(0,PactString.class).toString() + ""String_Node_Str""+ reduceValue.toString()+ ""String_Node_Str"");
  }
  record.setField(1,new PactInteger(sum));
  out.collect(record);
}"
87955,"@Override public void combine(Iterator<PactRecord> records,Collector out) throws Exception {
  int sum=0;
  PactRecord record=new PactRecord();
  while (records.hasNext()) {
    record=records.next();
    record.getField(1,combineValue);
    sum+=Integer.parseInt(combineValue.toString());
    LOG.debug(""String_Node_Str"" + record.getField(0,PactString.class).toString() + ""String_Node_Str""+ combineValue.toString()+ ""String_Node_Str"");
  }
  combineValue.setValue(sum + ""String_Node_Str"");
  record.setField(1,combineValue);
  out.collect(record);
}","@Override public void combine(Iterator<PactRecord> records,Collector out) throws Exception {
  int sum=0;
  PactRecord record=new PactRecord();
  while (records.hasNext()) {
    record=records.next();
    combineValue=record.getField(1,combineValue);
    sum+=Integer.parseInt(combineValue.toString());
    LOG.debug(""String_Node_Str"" + record.getField(0,PactString.class).toString() + ""String_Node_Str""+ combineValue.toString()+ ""String_Node_Str"");
  }
  combineValue.setValue(sum + ""String_Node_Str"");
  record.setField(1,combineValue);
  out.collect(record);
}"
87956,"@Override public void reduce(Iterator<PactRecord> records,Collector out) throws Exception {
  double sum=0;
  while (records.hasNext()) {
    record=records.next();
    record.getField(0,key);
    record.getField(1,v);
    if (v.getNumberOfColumns() > 1) {
      long val=Math.round(Double.parseDouble(v.getStringValueAt(0)) * (1 - Double.parseDouble(v.getStringValueAt(1))) * 10000);
      sum+=(((double)val) / 10000d);
    }
 else {
      sum+=Double.parseDouble(v.getStringValueAt(0));
    }
  }
  Tuple summed=new Tuple();
  summed.addAttribute(FORMATTER.format(sum));
  LOGGER.info(""String_Node_Str"" + key);
  record.setField(1,summed);
  out.collect(record);
}","@Override public void reduce(Iterator<PactRecord> records,Collector out) throws Exception {
  double sum=0;
  while (records.hasNext()) {
    record=records.next();
    key=record.getField(0,key);
    v=record.getField(1,v);
    if (v.getNumberOfColumns() > 1) {
      long val=Math.round(Double.parseDouble(v.getStringValueAt(0)) * (1 - Double.parseDouble(v.getStringValueAt(1))) * 10000);
      sum+=(((double)val) / 10000d);
    }
 else {
      sum+=Double.parseDouble(v.getStringValueAt(0));
    }
  }
  Tuple summed=new Tuple();
  summed.addAttribute(FORMATTER.format(sum));
  LOGGER.info(""String_Node_Str"" + key);
  record.setField(1,summed);
  out.collect(record);
}"
87957,"@Override public void map(PactRecord record,Collector out) throws Exception {
  record.getField(1,tuple);
  tuple.project(2);
  record.setField(1,tuple);
  out.collect(record);
}","@Override public void map(PactRecord record,Collector out) throws Exception {
  tuple=record.getField(1,tuple);
  tuple.project(2);
  record.setField(1,tuple);
  out.collect(record);
}"
87958,"/** 
 * Project ""partsupp"". Output Schema: Key: partkey Value: (suppkey, supplycost)
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  record.getField(1,inputTuple);
  inputTuple.project((0 << 0) | (1 << 1) | (0 << 2)| (1 << 3)| (0 << 4));
  record.setField(1,inputTuple);
  out.collect(record);
}","/** 
 * Project ""partsupp"". Output Schema: Key: partkey Value: (suppkey, supplycost)
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  inputTuple=record.getField(1,inputTuple);
  inputTuple.project((0 << 0) | (1 << 1) | (0 << 2)| (1 << 3)| (0 << 4));
  record.setField(1,inputTuple);
  out.collect(record);
}"
87959,"@Override public void writeRecord(PactRecord record) throws IOException {
  record.getField(0,key);
  record.getField(1,value);
  this.buffer.setLength(0);
  this.buffer.append(key.getFirst().toString());
  this.buffer.append('|');
  this.buffer.append(key.getSecond().toString());
  this.buffer.append('|');
  this.buffer.append(value.toString());
  this.buffer.append('\n');
  byte[] bytes=this.buffer.toString().getBytes();
  this.stream.write(bytes);
}","@Override public void writeRecord(PactRecord record) throws IOException {
  key=record.getField(0,key);
  value=record.getField(1,value);
  this.buffer.setLength(0);
  this.buffer.append(key.getFirst().toString());
  this.buffer.append('|');
  this.buffer.append(key.getSecond().toString());
  this.buffer.append('|');
  this.buffer.append(value.toString());
  this.buffer.append('\n');
  byte[] bytes=this.buffer.toString().getBytes();
  this.stream.write(bytes);
}"
87960,"/** 
 * Project ""supplier"". Output Schema: Key: nationkey Value: suppkey
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  record.getField(0,suppKey);
  record.getField(1,inputTuple);
  PactInteger nationKey=new PactInteger(Integer.parseInt(inputTuple.getStringValueAt(3)));
  record.setField(0,nationKey);
  record.setField(1,suppKey);
  out.collect(record);
}","/** 
 * Project ""supplier"". Output Schema: Key: nationkey Value: suppkey
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  suppKey=record.getField(0,suppKey);
  inputTuple=record.getField(1,inputTuple);
  PactInteger nationKey=new PactInteger(Integer.parseInt(inputTuple.getStringValueAt(3)));
  record.setField(0,nationKey);
  record.setField(1,suppKey);
  out.collect(record);
}"
87961,"/** 
 * Join ""nation"" and ""supplier"" by ""nationkey"". Output Schema: Key: suppkey Value: ""nation"" (name of the nation)
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  value1.getField(1,suppKey);
  value2.getField(1,nationVal);
  PactString nationName=new PactString(nationVal.getStringValueAt(1));
  value1.setField(0,suppKey);
  value1.setField(1,nationName);
  out.collect(value1);
}","/** 
 * Join ""nation"" and ""supplier"" by ""nationkey"". Output Schema: Key: suppkey Value: ""nation"" (name of the nation)
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  suppKey=value1.getField(1,suppKey);
  nationVal=value2.getField(1,nationVal);
  PactString nationName=new PactString(nationVal.getStringValueAt(1));
  value1.setField(0,suppKey);
  value1.setField(1,nationName);
  out.collect(value1);
}"
87962,"/** 
 * Compute the new position (coordinate vector) of a cluster center.
 */
@Override public void reduce(Iterator<PactRecord> dataPoints,Collector out){
  PactRecord next=null;
  this.coordinates.setCoordinates(null);
  double[] coordinateSum=null;
  int count=0;
  while (dataPoints.hasNext()) {
    next=dataPoints.next();
    double[] thisCoords=next.getField(1,CoordVector.class).getCoordinates();
    int thisCount=next.getField(2,PactInteger.class).getValue();
    if (coordinateSum == null) {
      if (this.coordinates.getCoordinates() != null) {
        coordinateSum=this.coordinates.getCoordinates();
      }
 else {
        coordinateSum=new double[thisCoords.length];
      }
    }
    addToCoordVector(coordinateSum,thisCoords);
    count+=thisCount;
  }
  for (int i=0; i < coordinateSum.length; i++) {
    coordinateSum[i]/=count;
  }
  this.coordinates.setCoordinates(coordinateSum);
  next.setField(1,this.coordinates);
  out.collect(next);
}","/** 
 * Compute the new position (coordinate vector) of a cluster center.
 */
@Override public void reduce(Iterator<PactRecord> dataPoints,Collector out){
  PactRecord next=null;
  CoordVector coordinates=new CoordVector();
  double[] coordinateSum=null;
  int count=0;
  while (dataPoints.hasNext()) {
    next=dataPoints.next();
    double[] thisCoords=next.getField(1,CoordVector.class).getCoordinates();
    int thisCount=next.getField(2,PactInteger.class).getValue();
    if (coordinateSum == null) {
      if (coordinates.getCoordinates() != null) {
        coordinateSum=coordinates.getCoordinates();
      }
 else {
        coordinateSum=new double[thisCoords.length];
      }
    }
    addToCoordVector(coordinateSum,thisCoords);
    count+=thisCount;
  }
  for (int i=0; i < coordinateSum.length; i++) {
    coordinateSum[i]/=count;
  }
  coordinates.setCoordinates(coordinateSum);
  next.setField(1,coordinates);
  out.collect(next);
}"
87963,"/** 
 * Computes a pre-aggregated average value of a coordinate vector.
 */
@Override public void combine(Iterator<PactRecord> dataPoints,Collector out){
  PactRecord next=null;
  this.coordinates.setCoordinates(null);
  double[] coordinateSum=null;
  int count=0;
  while (dataPoints.hasNext()) {
    next=dataPoints.next();
    double[] thisCoords=next.getField(1,CoordVector.class).getCoordinates();
    int thisCount=next.getField(2,PactInteger.class).getValue();
    if (coordinateSum == null) {
      if (this.coordinates.getCoordinates() != null) {
        coordinateSum=this.coordinates.getCoordinates();
      }
 else {
        coordinateSum=new double[thisCoords.length];
      }
    }
    addToCoordVector(coordinateSum,thisCoords);
    count+=thisCount;
  }
  this.coordinates.setCoordinates(coordinateSum);
  this.count.setValue(count);
  next.setField(1,this.coordinates);
  next.setField(2,this.count);
  out.collect(next);
}","/** 
 * Computes a pre-aggregated average value of a coordinate vector.
 */
@Override public void combine(Iterator<PactRecord> dataPoints,Collector out){
  PactRecord next=null;
  CoordVector coordinates=new CoordVector();
  double[] coordinateSum=null;
  int count=0;
  while (dataPoints.hasNext()) {
    next=dataPoints.next();
    double[] thisCoords=next.getField(1,CoordVector.class).getCoordinates();
    int thisCount=next.getField(2,PactInteger.class).getValue();
    if (coordinateSum == null) {
      if (coordinates.getCoordinates() != null) {
        coordinateSum=coordinates.getCoordinates();
      }
 else {
        coordinateSum=new double[thisCoords.length];
      }
    }
    addToCoordVector(coordinateSum,thisCoords);
    count+=thisCount;
  }
  coordinates.setCoordinates(coordinateSum);
  this.count.setValue(count);
  next.setField(1,coordinates);
  next.setField(2,this.count);
  out.collect(next);
}"
87964,"boolean canBeAdded(final TransferEnvelope transferEnvelope){
  if (this.tailSequenceNumber == -1) {
    return true;
  }
  final EventList eventList=transferEnvelope.getEventList();
  if (eventList != null) {
    if (!eventList.isEmpty()) {
      return false;
    }
  }
  if (!this.jobID.equals(transferEnvelope.getJobID())) {
    return false;
  }
  if (!this.source.equals(transferEnvelope.getSource())) {
    return false;
  }
  if (this.tailSequenceNumber != (transferEnvelope.getSequenceNumber() - 1)) {
    return false;
  }
  return true;
}","boolean canBeAdded(final TransferEnvelope transferEnvelope){
  if (this.tailSequenceNumber == -1) {
    return true;
  }
  final EventList eventList=transferEnvelope.getEventList();
  if (eventList != null) {
    if (!eventList.isEmpty()) {
      return false;
    }
  }
  if (!this.jobID.equals(transferEnvelope.getJobID())) {
    return false;
  }
  if (!this.source.equals(transferEnvelope.getSource())) {
    return false;
  }
  if (this.tailSequenceNumber != (transferEnvelope.getSequenceNumber() - 1)) {
    return false;
  }
  if (this.size() >= SIZE_LIMIT) {
    return false;
  }
  return true;
}"
87965,"int unspill(final BufferProvider bufferProvider) throws IOException {
  if (this.headSequenceNumber == -1) {
    return 0;
  }
  if (this.headSequenceNumber == this.tailSequenceNumber) {
    final Buffer buffer=(Buffer)this.bufferRef;
    if (buffer == null) {
      return 0;
    }
    if (buffer.isBackedByMemory()) {
      return 0;
    }
    final int size=buffer.size();
    final Buffer memBuffer=bufferProvider.requestEmptyBuffer(size);
    if (memBuffer == null) {
      return 0;
    }
    buffer.copyToBuffer(memBuffer);
    this.bufferRef=memBuffer;
    buffer.recycleBuffer();
    return size;
  }
  @SuppressWarnings(""String_Node_Str"") final Queue<Object> bufferQueue=(Queue<Object>)this.bufferRef;
  final int queueSize=bufferQueue.size();
  int usedMemory=0;
  int count=0;
  while (count++ < queueSize) {
    final Object obj=bufferQueue.poll();
    if (obj == NULL_OBJECT) {
      bufferQueue.add(obj);
      continue;
    }
    final Buffer buffer=(Buffer)obj;
    if (buffer.isBackedByMemory()) {
      bufferQueue.add(buffer);
      continue;
    }
    final int size=buffer.size();
    final Buffer memBuffer=bufferProvider.requestEmptyBuffer(size);
    if (memBuffer != null) {
      buffer.copyToBuffer(memBuffer);
      bufferQueue.add(memBuffer);
      buffer.recycleBuffer();
    }
 else {
      bufferQueue.add(buffer);
      return usedMemory;
    }
    usedMemory+=size;
  }
  return usedMemory;
}","int unspill(final BufferProvider bufferProvider) throws IOException {
  if (this.headSequenceNumber == -1) {
    return 0;
  }
  if (this.headSequenceNumber == this.tailSequenceNumber) {
    final Buffer buffer=(Buffer)this.bufferRef;
    if (buffer == null) {
      return 0;
    }
    if (buffer.isBackedByMemory()) {
      return 0;
    }
    final int size=buffer.size();
    final Buffer memBuffer=bufferProvider.requestEmptyBuffer(size);
    if (memBuffer == null) {
      return 0;
    }
    buffer.copyToBuffer(memBuffer);
    this.bufferRef=memBuffer;
    buffer.recycleBuffer();
    return size;
  }
  @SuppressWarnings(""String_Node_Str"") final Queue<Object> bufferQueue=(Queue<Object>)this.bufferRef;
  final int queueSize=bufferQueue.size();
  int usedMemory=0;
  int count=0;
  while (count++ < queueSize) {
    final Object obj=bufferQueue.poll();
    if (obj == NULL_OBJECT) {
      bufferQueue.add(obj);
      continue;
    }
    final Buffer buffer=(Buffer)obj;
    if (buffer.isBackedByMemory()) {
      bufferQueue.add(buffer);
      continue;
    }
    final int size=buffer.size();
    final Buffer memBuffer=bufferProvider.requestEmptyBuffer(size);
    if (memBuffer != null) {
      buffer.copyToBuffer(memBuffer);
      bufferQueue.add(memBuffer);
      buffer.recycleBuffer();
    }
 else {
      bufferQueue.add(buffer);
      continue;
    }
    usedMemory+=size;
  }
  return usedMemory;
}"
87966,"/** 
 * Compute the new position (coordinate vector) of a cluster center.
 */
@Override public void reduce(Iterator<PactRecord> dataPoints,Collector out){
  this.coordinates.setCoordinates(null);
  double[] coordinateSum=null;
  int count=0;
  while (dataPoints.hasNext()) {
    PactRecord next=dataPoints.next();
    next.getField(0,cid);
    double[] thisCoords=next.getField(1,CoordVector.class).getCoordinates();
    int thisCount=next.getField(2,PactInteger.class).getValue();
    if (coordinateSum == null) {
      if (this.coordinates.getCoordinates() != null) {
        coordinateSum=this.coordinates.getCoordinates();
      }
 else {
        coordinateSum=new double[thisCoords.length];
      }
    }
    addToCoordVector(coordinateSum,thisCoords);
    count+=thisCount;
  }
  for (int i=0; i < coordinateSum.length; i++) {
    coordinateSum[i]/=count;
  }
  this.coordinates.setCoordinates(coordinateSum);
  result.setField(0,cid);
  result.setField(1,this.coordinates);
  out.collect(result);
}","/** 
 * Compute the new position (coordinate vector) of a cluster center.
 */
@Override public void reduce(Iterator<PactRecord> dataPoints,Collector out){
  PactRecord next=null;
  this.coordinates.setCoordinates(null);
  double[] coordinateSum=null;
  int count=0;
  while (dataPoints.hasNext()) {
    next=dataPoints.next();
    double[] thisCoords=next.getField(1,CoordVector.class).getCoordinates();
    int thisCount=next.getField(2,PactInteger.class).getValue();
    if (coordinateSum == null) {
      if (this.coordinates.getCoordinates() != null) {
        coordinateSum=this.coordinates.getCoordinates();
      }
 else {
        coordinateSum=new double[thisCoords.length];
      }
    }
    addToCoordVector(coordinateSum,thisCoords);
    count+=thisCount;
  }
  for (int i=0; i < coordinateSum.length; i++) {
    coordinateSum[i]/=count;
  }
  this.coordinates.setCoordinates(coordinateSum);
  next.setField(1,this.coordinates);
  out.collect(next);
}"
87967,"/** 
 * Computes the distance of one data point to one cluster center and emits a key-value-pair where the id of the data point is the key and a Distance object is the value.
 */
@Override public void cross(PactRecord dataPointRecord,PactRecord clusterCenterRecord,Collector out){
  dataPointRecord.getField(1,dataPoint);
  clusterCenterRecord.getField(0,clusterCenterId);
  clusterCenterRecord.getField(1,clusterPoint);
  this.distance.setValue(dataPoint.computeEuclidianDistance(clusterPoint));
  dataPointRecord.setField(2,clusterCenterId);
  dataPointRecord.setField(3,this.distance);
  out.collect(dataPointRecord);
}","/** 
 * Computes the distance of one data point to one cluster center and emits a key-value-pair where the id of the data point is the key and a Distance object is the value.
 */
@Override public void cross(PactRecord dataPointRecord,PactRecord clusterCenterRecord,Collector out){
  CoordVector dataPoint=dataPointRecord.getField(1,CoordVector.class);
  PactInteger clusterCenterId=clusterCenterRecord.getField(0,PactInteger.class);
  CoordVector clusterPoint=clusterCenterRecord.getField(1,CoordVector.class);
  this.distance.setValue(dataPoint.computeEuclidianDistance(clusterPoint));
  dataPointRecord.setField(2,clusterCenterId);
  dataPointRecord.setField(3,this.distance);
  out.collect(dataPointRecord);
}"
87968,"@Override public int serializeRecord(PactRecord record,byte[] target){
  record.getField(0,this.centerId);
  record.getField(1,this.centerPos);
  StringBuilder line=new StringBuilder();
  line.append(this.centerId.getValue());
  for (  double coord : this.centerPos.getCoordinates()) {
    line.append('|');
    line.append(df.format(coord));
  }
  line.append('|');
  byte[] byteString=line.toString().getBytes();
  if (byteString.length <= target.length) {
    System.arraycopy(byteString,0,target,0,byteString.length);
    return byteString.length;
  }
 else {
    return -1 * byteString.length;
  }
}","@Override public int serializeRecord(PactRecord record,byte[] target){
  line.setLength(0);
  PactInteger centerId=record.getField(0,PactInteger.class);
  CoordVector centerPos=record.getField(1,CoordVector.class);
  line.append(centerId.getValue());
  for (  double coord : centerPos.getCoordinates()) {
    line.append('|');
    line.append(df.format(coord));
  }
  line.append('|');
  byte[] byteString=line.toString().getBytes();
  if (byteString.length <= target.length) {
    System.arraycopy(byteString,0,target,0,byteString.length);
    return byteString.length;
  }
 else {
    return -byteString.length;
  }
}"
87969,"/** 
 * Computes a pre-aggregated average value of a coordinate vector.
 */
@Override public void combine(Iterator<PactRecord> dataPoints,Collector out){
  this.coordinates.setCoordinates(null);
  double[] coordinateSum=null;
  int count=0;
  while (dataPoints.hasNext()) {
    PactRecord next=dataPoints.next();
    next.getField(0,cid);
    double[] thisCoords=next.getField(1,CoordVector.class).getCoordinates();
    int thisCount=next.getField(2,PactInteger.class).getValue();
    if (coordinateSum == null) {
      if (this.coordinates.getCoordinates() != null) {
        coordinateSum=this.coordinates.getCoordinates();
      }
 else {
        coordinateSum=new double[thisCoords.length];
      }
    }
    addToCoordVector(coordinateSum,thisCoords);
    count+=thisCount;
  }
  this.coordinates.setCoordinates(coordinateSum);
  this.count.setValue(count);
  result.setField(0,cid);
  result.setField(1,this.coordinates);
  result.setField(2,this.count);
  out.collect(result);
}","/** 
 * Computes a pre-aggregated average value of a coordinate vector.
 */
@Override public void combine(Iterator<PactRecord> dataPoints,Collector out){
  PactRecord next=null;
  this.coordinates.setCoordinates(null);
  double[] coordinateSum=null;
  int count=0;
  while (dataPoints.hasNext()) {
    next=dataPoints.next();
    double[] thisCoords=next.getField(1,CoordVector.class).getCoordinates();
    int thisCount=next.getField(2,PactInteger.class).getValue();
    if (coordinateSum == null) {
      if (this.coordinates.getCoordinates() != null) {
        coordinateSum=this.coordinates.getCoordinates();
      }
 else {
        coordinateSum=new double[thisCoords.length];
      }
    }
    addToCoordVector(coordinateSum,thisCoords);
    count+=thisCount;
  }
  this.coordinates.setCoordinates(coordinateSum);
  this.count.setValue(count);
  next.setField(1,this.coordinates);
  next.setField(2,this.count);
  out.collect(next);
}"
87970,"/** 
 * Aggregate ""amount"": sum(amount) GROUP BY nation, year Output Schema: Key: (nation, year) Value: amount
 */
@Override public void reduce(Iterator<PactRecord> records,Collector out) throws Exception {
  float amount=0;
  while (records.hasNext()) {
    record=records.next();
    record.getField(1,value);
    amount+=Float.parseFloat(value.toString());
  }
  if (value != null) {
    value.setValue(""String_Node_Str"" + amount);
    record.setField(1,value);
    out.collect(record);
  }
}","/** 
 * Aggregate ""amount"": sum(amount) GROUP BY nation, year Output Schema: Key: (nation, year) Value: amount
 */
@Override public void reduce(Iterator<PactRecord> records,Collector out) throws Exception {
  PactRecord record=null;
  float amount=0;
  while (records.hasNext()) {
    record=records.next();
    PactString value=record.getField(1,PactString.class);
    amount+=Float.parseFloat(value.toString());
  }
  value.setValue(String.valueOf(amount));
  record.setField(1,value);
  out.collect(record);
}"
87971,"/** 
 * Join together parts and orderedParts by matching partkey and suppkey. Output Schema: Key: suppkey Value: (amount, year)
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  value1.getField(0,partAndSupplierKey);
  value1.getField(1,supplyCostStr);
  value2.getField(1,ordersValue);
  PactInteger year=new PactInteger(Integer.parseInt(ordersValue.getStringValueAt(0)));
  float quantity=Float.parseFloat(ordersValue.getStringValueAt(1));
  float price=Float.parseFloat(ordersValue.getStringValueAt(2));
  float supplyCost=Float.parseFloat(supplyCostStr.toString());
  float amount=price - supplyCost * quantity;
  value1.setField(0,partAndSupplierKey.getSecond());
  value1.setField(1,new StringIntPair(new PactString(""String_Node_Str"" + amount),year));
  out.collect(value1);
}","/** 
 * Join together parts and orderedParts by matching partkey and suppkey. Output Schema: Key: suppkey Value: (amount, year)
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  IntPair partAndSupplierKey=value1.getField(0,this.partAndSupplierKey);
  PactString supplyCostStr=value1.getField(1,this.supplyCostStr);
  Tuple ordersValue=value2.getField(1,this.ordersValue);
  PactInteger year=new PactInteger(Integer.parseInt(ordersValue.getStringValueAt(0)));
  float quantity=Float.parseFloat(ordersValue.getStringValueAt(1));
  float price=Float.parseFloat(ordersValue.getStringValueAt(2));
  float supplyCost=Float.parseFloat(supplyCostStr.toString());
  float amount=price - supplyCost * quantity;
  value1.setField(0,partAndSupplierKey.getSecond());
  value1.setField(1,new StringIntPair(new PactString(""String_Node_Str"" + amount),year));
  out.collect(value1);
}"
87972,"/** 
 * Filter ""lineitem"". Output Schema: Key: orderkey Value: (partkey, suppkey, quantity, price)
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  record.getField(1,inputTuple);
  float price=Float.parseFloat(inputTuple.getStringValueAt(5)) * (1 - Float.parseFloat(inputTuple.getStringValueAt(6)));
  inputTuple.project((0 << 0) | (1 << 1) | (1 << 2)| (0 << 3)| (1 << 4));
  inputTuple.addAttribute(""String_Node_Str"" + price);
  record.setField(1,inputTuple);
  out.collect(record);
}","/** 
 * Filter ""lineitem"". Output Schema: Key: orderkey Value: (partkey, suppkey, quantity, price)
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  Tuple inputTuple=record.getField(1,Tuple.class);
  float price=Float.parseFloat(inputTuple.getStringValueAt(5)) * (1 - Float.parseFloat(inputTuple.getStringValueAt(6)));
  inputTuple.project((0 << 0) | (1 << 1) | (1 << 2)| (0 << 3)| (1 << 4));
  inputTuple.addAttribute(""String_Node_Str"" + price);
  record.setField(1,inputTuple);
  out.collect(record);
}"
87973,"/** 
 * Project ""orders"" Output Schema: Key: orderkey Value: year (from date)
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  record.getField(1,inputTuple);
  int year=Integer.parseInt(inputTuple.getStringValueAt(4).substring(0,4));
  record.setField(1,new PactInteger(year));
  out.collect(record);
}","/** 
 * Project ""orders"" Output Schema: Key: orderkey Value: year (from date)
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  Tuple inputTuple=record.getField(1,this.inputTuple);
  int year=Integer.parseInt(inputTuple.getStringValueAt(4).substring(0,4));
  record.setField(1,new PactInteger(year));
  out.collect(record);
}"
87974,"/** 
 * Join ""orders"" and ""lineitem"" by ""orderkey"". Output Schema: Key: (partkey, suppkey) Value: (year, quantity, price)
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  value1.getField(1,year);
  value2.getField(1,lineItem);
  IntPair newKey=new IntPair(new PactInteger(Integer.parseInt(lineItem.getStringValueAt(0))),new PactInteger(Integer.parseInt(lineItem.getStringValueAt(1))));
  Tuple newValue=new Tuple();
  newValue.addAttribute(year.toString());
  newValue.addAttribute(lineItem.getStringValueAt(2));
  newValue.addAttribute(lineItem.getStringValueAt(3));
  value1.setField(0,newKey);
  value1.setField(1,newValue);
  out.collect(value1);
}","/** 
 * Join ""orders"" and ""lineitem"" by ""orderkey"". Output Schema: Key: (partkey, suppkey) Value: (year, quantity, price)
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  PactInteger year=value1.getField(1,PactInteger.class);
  Tuple lineItem=value2.getField(1,Tuple.class);
  IntPair newKey=new IntPair(new PactInteger(Integer.parseInt(lineItem.getStringValueAt(0))),new PactInteger(Integer.parseInt(lineItem.getStringValueAt(1))));
  Tuple newValue=new Tuple();
  newValue.addAttribute(year.toString());
  newValue.addAttribute(lineItem.getStringValueAt(2));
  newValue.addAttribute(lineItem.getStringValueAt(3));
  value1.setField(0,newKey);
  value1.setField(1,newValue);
  out.collect(value1);
}"
87975,"/** 
 * Filter and project ""part"". The parts are filtered by ""name LIKE %green%"". Output Schema: Key: partkey Value: (empty)
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  record.getField(1,inputTuple);
  if (inputTuple.getStringValueAt(1).indexOf(COLOR) != -1) {
    record.setField(1,PactNull.getInstance());
    out.collect(record);
  }
}","/** 
 * Filter and project ""part"". The parts are filtered by ""name LIKE %green%"". Output Schema: Key: partkey Value: (empty)
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  Tuple inputTuple=record.getField(1,this.inputTuple);
  if (inputTuple.getStringValueAt(1).indexOf(COLOR) != -1) {
    record.setField(1,PactNull.getInstance());
    out.collect(record);
  }
}"
87976,"/** 
 * Join ""part"" and ""partsupp"" by ""partkey"". Output Schema: Key: (partkey, suppkey) Value: supplycost
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  value1.getField(0,partKey);
  value2.getField(1,partSuppValue);
  IntPair newKey=new IntPair(partKey,new PactInteger(Integer.parseInt(partSuppValue.getStringValueAt(0))));
  String supplyCost=partSuppValue.getStringValueAt(1);
  value1.setField(0,newKey);
  value1.setField(1,new PactString(supplyCost));
  out.collect(value1);
}","/** 
 * Join ""part"" and ""partsupp"" by ""partkey"". Output Schema: Key: (partkey, suppkey) Value: supplycost
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  PactInteger partKey=value1.getField(0,this.partKey);
  Tuple partSuppValue=value2.getField(1,this.partSuppValue);
  IntPair newKey=new IntPair(partKey,new PactInteger(Integer.parseInt(partSuppValue.getStringValueAt(0))));
  String supplyCost=partSuppValue.getStringValueAt(1);
  value1.setField(0,newKey);
  value1.setField(1,new PactString(supplyCost));
  out.collect(value1);
}"
87977,"/** 
 * Join ""filteredParts"" and ""suppliers"" by ""suppkey"". Output Schema: Key: (nation, year) Value: amount
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  value1.getField(1,amountYearPair);
  value2.getField(1,nationName);
  PactInteger year=amountYearPair.getSecond();
  PactString amount=amountYearPair.getFirst();
  StringIntPair key=new StringIntPair(nationName,year);
  value1.setField(0,key);
  value1.setField(1,amount);
  out.collect(value1);
}","/** 
 * Join ""filteredParts"" and ""suppliers"" by ""suppkey"". Output Schema: Key: (nation, year) Value: amount
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  StringIntPair amountYearPair=value1.getField(1,this.amountYearPair);
  PactString nationName=value2.getField(1,this.nationName);
  PactInteger year=amountYearPair.getSecond();
  PactString amount=amountYearPair.getFirst();
  StringIntPair key=new StringIntPair(nationName,year);
  value1.setField(0,key);
  value1.setField(1,amount);
  out.collect(value1);
}"
87978,"@Override public void openTask() throws Exception {
  AbstractPactTask.openUserCode(this.combiner,this.config.getStubParameters());
  final long availableMemory=this.config.getMemorySize();
  LocalStrategy ls=config.getLocalStrategy();
  long strategyMinMem=0;
switch (ls) {
case COMBININGSORT:
    strategyMinMem=MIN_REQUIRED_MEMORY;
  break;
}
if (availableMemory < strategyMinMem) {
throw new RuntimeException(""String_Node_Str"" + config.getLocalStrategy() + ""String_Node_Str""+ availableMemory+ ""String_Node_Str""+ ""String_Node_Str""+ strategyMinMem+ ""String_Node_Str"");
}
final MemoryManager memoryManager=this.parent.getEnvironment().getMemoryManager();
final IOManager ioManager=this.parent.getEnvironment().getIOManager();
final int[] keyPositions=this.config.getLocalStrategyKeyPositions(0);
final Class<? extends Key>[] keyClasses=this.config.getLocalStrategyKeyClasses(this.userCodeClassLoader);
if (keyPositions == null || keyClasses == null) {
throw new Exception(""String_Node_Str"");
}
@SuppressWarnings(""String_Node_Str"") final Comparator<Key>[] comparators=new Comparator[keyPositions.length];
final KeyComparator kk=new KeyComparator();
for (int i=0; i < comparators.length; i++) {
comparators[i]=kk;
}
switch (ls) {
case COMBININGSORT:
this.sorter=new AsynchronousPartialSorterCollector(memoryManager,ioManager,availableMemory,comparators,keyPositions,keyClasses,this.parent);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
this.combinerThread=new CombinerThread(this.sorter,keyPositions,keyClasses,this.combiner,this.outputCollector);
this.combinerThread.start();
}","@Override public void openTask() throws Exception {
  AbstractPactTask.openUserCode(this.combiner,this.config.getStubParameters());
  final long availableMemory=this.config.getMemorySize();
  LocalStrategy ls=config.getLocalStrategy();
  long strategyMinMem=0;
switch (ls) {
case COMBININGSORT:
    strategyMinMem=MIN_REQUIRED_MEMORY;
  break;
}
if (availableMemory < strategyMinMem) {
throw new RuntimeException(""String_Node_Str"" + config.getLocalStrategy() + ""String_Node_Str""+ availableMemory+ ""String_Node_Str""+ ""String_Node_Str""+ strategyMinMem+ ""String_Node_Str"");
}
final MemoryManager memoryManager=this.parent.getEnvironment().getMemoryManager();
final IOManager ioManager=this.parent.getEnvironment().getIOManager();
final int[] keyPositions=this.config.getLocalStrategyKeyPositions(0);
final Class<? extends Key>[] keyClasses=this.config.getLocalStrategyKeyClasses(this.userCodeClassLoader);
if (keyPositions == null || keyClasses == null) {
throw new Exception(""String_Node_Str"");
}
@SuppressWarnings(""String_Node_Str"") final Comparator<Key>[] comparators=new Comparator[keyPositions.length];
final KeyComparator kk=new KeyComparator();
for (int i=0; i < comparators.length; i++) {
comparators[i]=kk;
}
switch (ls) {
case COMBININGSORT:
this.sorter=new AsynchronousPartialSorterCollector(memoryManager,ioManager,availableMemory,comparators,keyPositions,keyClasses,this.parent);
this.inputCollector=this.sorter.getInputCollector();
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
this.combinerThread=new CombinerThread(this.sorter,keyPositions,keyClasses,this.combiner,this.outputCollector);
this.combinerThread.start();
}"
87979,"private CombinerThread(AsynchronousPartialSorterCollector sorter,int[] keyPositions,Class<? extends Key>[] keyClasses,ReduceStub stub,Collector output){
  super(""String_Node_Str"");
  setDaemon(true);
  this.sorter=sorter;
  this.keyPositions=keyPositions;
  this.keyClasses=keyClasses;
  this.stub=stub;
  this.output=output;
}","private CombinerThread(AsynchronousPartialSorterCollector sorter,int[] keyPositions,Class<? extends Key>[] keyClasses,ReduceStub stub,Collector output){
  super(""String_Node_Str"");
  setDaemon(true);
  this.sorter=sorter;
  this.keyPositions=keyPositions;
  this.keyClasses=keyClasses;
  this.stub=stub;
  this.output=output;
  this.running=true;
}"
87980,"protected ThreadBase getReadingThread(ExceptionHandler<IOException> exceptionHandler,MutableObjectIterator<PactRecord> reader,CircularQueues queues,AbstractTask parentTask,long startSpillingBytes){
  this.collector=new InputDataCollector(queues,startSpillingBytes);
  return new DummyThread(exceptionHandler,queues,parentTask);
}","@Override protected ThreadBase getReadingThread(ExceptionHandler<IOException> exceptionHandler,MutableObjectIterator<PactRecord> reader,CircularQueues queues,AbstractInvokable parentTask,long startSpillingBytes){
  this.collector=new InputDataCollector(queues,startSpillingBytes);
  return new DummyThread(exceptionHandler,queues,parentTask);
}"
87981,"/** 
 * This method step over all inputs recursively and combines all alternatives per input with all other alternative of all other inputs.
 * @param inPlans		all alternative plans for all incoming connections (which are unioned)
 * @param predList		list of currently chosen alternative plans (has one entry for each incoming connection)[this list is build up recursively within the method]
 * @param estimator		the cost estimator
 * @param alternativeSubPlans	all generated alternative for this node
 */
@SuppressWarnings(""String_Node_Str"") final protected void getAlternativeSubPlanCombinationsRecursively(List<? extends OptimizerNode>[] inPlans,ArrayList<OptimizerNode> predList,List<List<OptimizerNode>> alternativeSubPlans){
  final int inputNumberToProcess=predList.size();
  final int numberOfAlternatives=inPlans[inputNumberToProcess].size();
  for (int i=0; i < numberOfAlternatives; ++i) {
    predList.add(inPlans[inputNumberToProcess].get(i));
    if (inputNumberToProcess + 1 == inPlans.length) {
      alternativeSubPlans.add(predList);
      predList=(ArrayList<OptimizerNode>)predList.clone();
    }
 else {
      getAlternativeSubPlanCombinationsRecursively(inPlans,predList,alternativeSubPlans);
    }
    predList.remove(inputNumberToProcess);
  }
}","/** 
 * This method step over all inputs recursively and combines all alternatives per input with all other alternative of all other inputs.
 * @param inPlans		all alternative plans for all incoming connections (which are unioned)
 * @param predList		list of currently chosen alternative plans (has one entry for each incoming connection)[this list is build up recursively within the method]
 * @param estimator		the cost estimator
 * @param alternativeSubPlans	all generated alternative for this node
 */
@SuppressWarnings(""String_Node_Str"") final protected void getAlternativeSubPlanCombinationsRecursively(List<? extends OptimizerNode>[] inPlans,ArrayList<OptimizerNode> predList,List<List<OptimizerNode>> alternativeSubPlans){
  final int inputNumberToProcess=predList.size();
  final int numberOfAlternatives=inPlans[inputNumberToProcess].size();
  for (int i=0; i < numberOfAlternatives; ++i) {
    predList.add(inPlans[inputNumberToProcess].get(i));
    if (inputNumberToProcess + 1 == inPlans.length) {
      alternativeSubPlans.add((ArrayList<OptimizerNode>)predList.clone());
    }
 else {
      getAlternativeSubPlanCombinationsRecursively(inPlans,predList,alternativeSubPlans);
    }
    predList.remove(inputNumberToProcess);
  }
}"
87982,"/** 
 * Copy constructor to create a copy of a node with different predecessors. The predecessors is assumed to be of the same type as in the template node and merely copies with different strategies, as they are created in the process of the plan enumeration.
 * @param template The node to create a copy of.
 * @param pred1 The new predecessor for the first input.
 * @param pred2 The new predecessor for the second input.
 * @param conn1 The old connection of the first input to copy properties from.
 * @param conn2 The old connection of the second input to copy properties from.
 * @param globalProps The global properties of this copy.
 * @param localProps The local properties of this copy.
 */
protected TwoInputNode(TwoInputNode template,List<OptimizerNode> pred1,List<OptimizerNode> pred2,List<PactConnection> conn1,List<PactConnection> conn2,GlobalProperties globalProps,LocalProperties localProps){
  super(template,globalProps,localProps);
  this.inputs=new ArrayList<List<PactConnection>>(2);
  int i=0;
  for (  PactConnection c : conn1) {
    PactConnection cc=new PactConnection(c,pred1.get(i++),this);
    this.input1.add(cc);
  }
  this.inputs.add(this.input1);
  i=0;
  for (  PactConnection c : conn2) {
    PactConnection cc=new PactConnection(c,pred2.get(i++),this);
    this.input2.add(cc);
  }
  this.inputs.add(this.input2);
  if (template.openBranches != null) {
    if (this.branchPlan == null) {
      this.branchPlan=new HashMap<OptimizerNode,OptimizerNode>(8);
    }
    Iterator<OptimizerNode> it1=pred1.iterator();
    Iterator<OptimizerNode> it2=pred2.iterator();
    for (    UnclosedBranchDescriptor uc : template.openBranches) {
      OptimizerNode brancher=uc.branchingNode;
      OptimizerNode selectedCandidate=null;
      if (it1.hasNext()) {
        OptimizerNode n=it1.next();
        if (n.branchPlan != null) {
          selectedCandidate=n.branchPlan.get(brancher);
        }
      }
      if (selectedCandidate == null && it2.hasNext()) {
        OptimizerNode n=it2.next();
        if (n.branchPlan != null) {
          selectedCandidate=n.branchPlan.get(brancher);
        }
      }
      if (selectedCandidate == null) {
        throw new CompilerException(""String_Node_Str"");
      }
      this.branchPlan.put(brancher,selectedCandidate);
    }
  }
}","/** 
 * Copy constructor to create a copy of a node with different predecessors. The predecessors is assumed to be of the same type as in the template node and merely copies with different strategies, as they are created in the process of the plan enumeration.
 * @param template The node to create a copy of.
 * @param pred1 The new predecessor for the first input.
 * @param pred2 The new predecessor for the second input.
 * @param conn1 The old connection of the first input to copy properties from.
 * @param conn2 The old connection of the second input to copy properties from.
 * @param globalProps The global properties of this copy.
 * @param localProps The local properties of this copy.
 */
protected TwoInputNode(TwoInputNode template,List<OptimizerNode> pred1,List<OptimizerNode> pred2,List<PactConnection> conn1,List<PactConnection> conn2,GlobalProperties globalProps,LocalProperties localProps){
  super(template,globalProps,localProps);
  this.inputs=new ArrayList<List<PactConnection>>(2);
  int i=0;
  if (pred1 != null) {
    for (    PactConnection c : conn1) {
      PactConnection cc=new PactConnection(c,pred1.get(i++),this);
      this.input1.add(cc);
    }
    this.inputs.add(this.input1);
  }
  if (pred2 != null) {
    i=0;
    for (    PactConnection c : conn2) {
      PactConnection cc=new PactConnection(c,pred2.get(i++),this);
      this.input2.add(cc);
    }
    this.inputs.add(this.input2);
  }
  if (template.openBranches != null) {
    if (this.branchPlan == null) {
      this.branchPlan=new HashMap<OptimizerNode,OptimizerNode>(8);
    }
    for (    UnclosedBranchDescriptor uc : template.openBranches) {
      OptimizerNode brancher=uc.branchingNode;
      OptimizerNode selectedCandidate=null;
      if (pred1 != null) {
        Iterator<OptimizerNode> it1=pred1.iterator();
        while (it1.hasNext()) {
          OptimizerNode n=it1.next();
          if (n.branchPlan != null) {
            selectedCandidate=n.branchPlan.get(brancher);
            this.branchPlan.put(brancher,selectedCandidate);
          }
        }
      }
      if (selectedCandidate == null && pred2 != null) {
        Iterator<OptimizerNode> it2=pred2.iterator();
        while (it2.hasNext()) {
          OptimizerNode n=it2.next();
          if (n.branchPlan != null) {
            selectedCandidate=n.branchPlan.get(brancher);
            this.branchPlan.put(brancher,selectedCandidate);
          }
        }
      }
      if (selectedCandidate == null) {
        throw new CompilerException(""String_Node_Str"");
      }
    }
  }
}"
87983,"/** 
 * Checks the transition of the execution state and outputs an error in case of an unexpected state transition.
 * @param taskName the name of the task whose execution has changed
 * @param oldState the old execution state
 * @param newState the new execution state
 */
public static void checkTransition(final String taskName,final ExecutionState oldState,final ExecutionState newState){
  if (oldState == ExecutionState.CANCELED || oldState == ExecutionState.FINISHED || oldState == ExecutionState.FAILED) {
    return;
  }
  LOG.info(""String_Node_Str"" + oldState + ""String_Node_Str""+ newState+ ""String_Node_Str""+ taskName);
  boolean unexpectedStateChange=true;
  if (oldState == ExecutionState.CREATED && newState == ExecutionState.SCHEDULED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.SCHEDULED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.ASSIGNED && newState == ExecutionState.READY) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.READY && newState == ExecutionState.STARTING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.STARTING && newState == ExecutionState.RUNNING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.FINISHING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.FINISHED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.SCHEDULED && newState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.ASSIGNED && newState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.READY && newState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.STARTING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.CANCELING && newState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (unexpectedStateChange) {
    LOG.error(""String_Node_Str"" + oldState + ""String_Node_Str""+ newState);
  }
}","/** 
 * Checks the transition of the execution state and outputs an error in case of an unexpected state transition.
 * @param taskName the name of the task whose execution has changed
 * @param oldState the old execution state
 * @param newState the new execution state
 */
public static void checkTransition(final String taskName,final ExecutionState oldState,final ExecutionState newState){
  if (oldState == ExecutionState.CANCELED || oldState == ExecutionState.FINISHED || oldState == ExecutionState.FAILED) {
    return;
  }
  LOG.info(""String_Node_Str"" + oldState + ""String_Node_Str""+ newState+ ""String_Node_Str""+ taskName);
  boolean unexpectedStateChange=true;
  if (oldState == ExecutionState.CREATED && newState == ExecutionState.SCHEDULED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.SCHEDULED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.ASSIGNED && newState == ExecutionState.READY) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.READY && newState == ExecutionState.STARTING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.STARTING && newState == ExecutionState.RUNNING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.FINISHING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.FINISHED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.CREATED && newState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.SCHEDULED && newState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.ASSIGNED && newState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.READY && newState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.STARTING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.RUNNING && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.FINISHING && newState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (oldState == ExecutionState.CANCELING && newState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (unexpectedStateChange) {
    LOG.error(""String_Node_Str"" + oldState + ""String_Node_Str""+ newState);
  }
}"
87984,"@SuppressWarnings(""String_Node_Str"") private final <K extends Key,V extends Value>RecordReader<KeyValuePair<K,V>> getReader1(){
  return (RecordReader<KeyValuePair<K,V>>)this.reader1;
}","@SuppressWarnings(""String_Node_Str"") private final <K extends Key,V extends Value>Reader<KeyValuePair<K,V>> getReader1(){
  return (Reader<KeyValuePair<K,V>>)this.reader1;
}"
87985,"@SuppressWarnings(""String_Node_Str"") private final <K extends Key,V extends Value>RecordReader<KeyValuePair<K,V>> getReader2(){
  return (RecordReader<KeyValuePair<K,V>>)this.reader2;
}","@SuppressWarnings(""String_Node_Str"") private final <K extends Key,V extends Value>Reader<KeyValuePair<K,V>> getReader2(){
  return (Reader<KeyValuePair<K,V>>)this.reader2;
}"
87986,"/** 
 * Returns a CoGroupTaskIterator according to the specified local strategy. The iterator is typed according to the given classes.
 * @param < K > The type of the input key.
 * @param < V1 > The type of the first input's value.
 * @param < V2 > The type of the second input's value.
 * @param ikClass The class of the input key.
 * @param iv1Class The class of the first input's value.
 * @param iv2Class The class of the second input's value.
 * @return The iterator implementation for the given local strategy.
 * @throws IllegalConfigurationException Thrown if the local strategy is not supported.
 */
private <K extends Key,V1 extends Value,V2 extends Value>CoGroupTaskIterator<K,V1,V2> getIterator(Class<K> ikClass,Class<V1> iv1Class,Class<V2> iv2Class){
  final MemoryManager memoryManager=getEnvironment().getMemoryManager();
  final IOManager ioManager=getEnvironment().getIOManager();
  RecordReader<KeyValuePair<K,V1>> reader1=getReader1();
  RecordReader<KeyValuePair<K,V2>> reader2=getReader2();
switch (this.config.getLocalStrategy()) {
case SORT_BOTH_MERGE:
    return new SortMergeCoGroupIterator<K,V1,V2>(memoryManager,ioManager,reader1,reader2,ikClass,iv1Class,iv2Class,this.availableMemory,this.maxFileHandles,this.spillThreshold,this.config.getLocalStrategy(),this);
case SORT_FIRST_MERGE:
  return new SortMergeCoGroupIterator<K,V1,V2>(memoryManager,ioManager,reader1,reader2,ikClass,iv1Class,iv2Class,this.availableMemory,this.maxFileHandles,this.spillThreshold,this.config.getLocalStrategy(),this);
case SORT_SECOND_MERGE:
return new SortMergeCoGroupIterator<K,V1,V2>(memoryManager,ioManager,reader1,reader2,ikClass,iv1Class,iv2Class,this.availableMemory,this.maxFileHandles,this.spillThreshold,this.config.getLocalStrategy(),this);
case MERGE:
return new SortMergeCoGroupIterator<K,V1,V2>(memoryManager,ioManager,reader1,reader2,ikClass,iv1Class,iv2Class,this.availableMemory,this.maxFileHandles,this.spillThreshold,this.config.getLocalStrategy(),this);
default :
throw new RuntimeException(""String_Node_Str"" + this.config.getLocalStrategy());
}
}","/** 
 * Returns a CoGroupTaskIterator according to the specified local strategy. The iterator is typed according to the given classes.
 * @param < K > The type of the input key.
 * @param < V1 > The type of the first input's value.
 * @param < V2 > The type of the second input's value.
 * @param ikClass The class of the input key.
 * @param iv1Class The class of the first input's value.
 * @param iv2Class The class of the second input's value.
 * @return The iterator implementation for the given local strategy.
 * @throws IllegalConfigurationException Thrown if the local strategy is not supported.
 */
private <K extends Key,V1 extends Value,V2 extends Value>CoGroupTaskIterator<K,V1,V2> getIterator(Class<K> ikClass,Class<V1> iv1Class,Class<V2> iv2Class){
  final MemoryManager memoryManager=getEnvironment().getMemoryManager();
  final IOManager ioManager=getEnvironment().getIOManager();
  Reader<KeyValuePair<K,V1>> reader1=getReader1();
  Reader<KeyValuePair<K,V2>> reader2=getReader2();
switch (this.config.getLocalStrategy()) {
case SORT_BOTH_MERGE:
    return new SortMergeCoGroupIterator<K,V1,V2>(memoryManager,ioManager,reader1,reader2,ikClass,iv1Class,iv2Class,this.availableMemory,this.maxFileHandles,this.spillThreshold,this.config.getLocalStrategy(),this);
case SORT_FIRST_MERGE:
  return new SortMergeCoGroupIterator<K,V1,V2>(memoryManager,ioManager,reader1,reader2,ikClass,iv1Class,iv2Class,this.availableMemory,this.maxFileHandles,this.spillThreshold,this.config.getLocalStrategy(),this);
case SORT_SECOND_MERGE:
return new SortMergeCoGroupIterator<K,V1,V2>(memoryManager,ioManager,reader1,reader2,ikClass,iv1Class,iv2Class,this.availableMemory,this.maxFileHandles,this.spillThreshold,this.config.getLocalStrategy(),this);
case MERGE:
return new SortMergeCoGroupIterator<K,V1,V2>(memoryManager,ioManager,reader1,reader2,ikClass,iv1Class,iv2Class,this.availableMemory,this.maxFileHandles,this.spillThreshold,this.config.getLocalStrategy(),this);
default :
throw new RuntimeException(""String_Node_Str"" + this.config.getLocalStrategy());
}
}"
87987,"void shareInstancesWith(final ExecutionGroupVertex groupVertex) throws GraphConversionException {
  if (userDefinedVertexToShareInstancesWith && this.vertexToShareInstancesWith != null) {
    throw new GraphConversionException(""String_Node_Str"");
  }
  if (groupVertex == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final ExecutionGroupVertex oldVertex=this.vertexToShareInstancesWith.getAndSet(groupVertex);
  if (oldVertex != null) {
    oldVertex.removeFromVerticesSharingInstances(this);
  }
  groupVertex.addToVerticesSharingInstances(this);
  reassignInstances();
  this.executionGraph.repairInstanceAssignment();
}","void shareInstancesWith(final ExecutionGroupVertex groupVertex) throws GraphConversionException {
  if (userDefinedVertexToShareInstancesWith && this.vertexToShareInstancesWith.get() != null) {
    throw new GraphConversionException(""String_Node_Str"");
  }
  if (groupVertex == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final ExecutionGroupVertex oldVertex=this.vertexToShareInstancesWith.getAndSet(groupVertex);
  if (oldVertex != null) {
    oldVertex.removeFromVerticesSharingInstances(this);
  }
  groupVertex.addToVerticesSharingInstances(this);
  reassignInstances();
  this.executionGraph.repairInstanceAssignment();
}"
87988,"private List<AllocatedResource> collectAvailableResources(){
  List<AllocatedResource> availableResources;
  if (this.vertexToShareInstancesWith != null) {
    availableResources=this.vertexToShareInstancesWith.get().collectAvailableResources();
  }
 else {
    availableResources=new ArrayList<AllocatedResource>();
synchronized (this.groupMembers) {
      final Iterator<ExecutionVertex> it=this.groupMembers.iterator();
      while (it.hasNext()) {
        final ExecutionVertex vertex=it.next();
        final AllocatedResource allocatedResource=vertex.getAllocatedResource();
        if (allocatedResource != null) {
          if (!availableResources.contains(allocatedResource)) {
            availableResources.add(allocatedResource);
          }
        }
      }
    }
  }
  return availableResources;
}","private List<AllocatedResource> collectAvailableResources(){
  List<AllocatedResource> availableResources;
  if (this.vertexToShareInstancesWith.get() != null) {
    availableResources=this.vertexToShareInstancesWith.get().collectAvailableResources();
  }
 else {
    availableResources=new ArrayList<AllocatedResource>();
synchronized (this.groupMembers) {
      final Iterator<ExecutionVertex> it=this.groupMembers.iterator();
      while (it.hasNext()) {
        final ExecutionVertex vertex=it.next();
        final AllocatedResource allocatedResource=vertex.getAllocatedResource();
        if (allocatedResource != null) {
          if (!availableResources.contains(allocatedResource)) {
            availableResources.add(allocatedResource);
          }
        }
      }
    }
  }
  return availableResources;
}"
87989,"private static final int readLengthIncludingLengthBytes(MemorySegment seg,List<MemorySegment> sources,int segmentNum,int segmentOffset){
  int lenBytes=1;
  if (seg.size() - segmentOffset > 5) {
    int val=seg.get(segmentOffset++) & 0xff;
    if (val >= MAX_BIT) {
      int shift=7;
      int curr;
      val=val & 0x7f;
      while ((curr=seg.get(segmentOffset++) & 0xff) >= MAX_BIT) {
        val|=(curr & 0x7f) << shift;
        shift+=7;
        lenBytes++;
      }
      val|=curr << shift;
    }
    return val + lenBytes;
  }
 else {
    int end=seg.size();
    int val=seg.get(segmentOffset++) & 0xff;
    if (segmentOffset == end) {
      segmentOffset=0;
      seg=sources.get(++segmentNum);
    }
    if (val >= MAX_BIT) {
      int shift=7;
      int curr;
      val=val & 0x7f;
      while ((curr=seg.get(segmentOffset++) & 0xff) >= MAX_BIT) {
        val|=(curr & 0x7f) << shift;
        shift+=7;
        lenBytes++;
        if (segmentOffset == end) {
          segmentOffset=0;
          seg=sources.get(++segmentNum);
        }
      }
      val|=curr << shift;
    }
    return val + lenBytes;
  }
}","private static final int readLengthIncludingLengthBytes(MemorySegment seg,List<MemorySegment> sources,int segmentNum,int segmentOffset){
  int lenBytes=1;
  if (seg.size() - segmentOffset > 5) {
    int val=seg.get(segmentOffset++) & 0xff;
    if (val >= MAX_BIT) {
      int shift=7;
      int curr;
      val=val & 0x7f;
      while ((curr=seg.get(segmentOffset++) & 0xff) >= MAX_BIT) {
        val|=(curr & 0x7f) << shift;
        shift+=7;
        lenBytes++;
      }
      val|=curr << shift;
      lenBytes++;
    }
    return val + lenBytes;
  }
 else {
    int end=seg.size();
    int val=seg.get(segmentOffset++) & 0xff;
    if (segmentOffset == end) {
      segmentOffset=0;
      seg=sources.get(++segmentNum);
    }
    if (val >= MAX_BIT) {
      int shift=7;
      int curr;
      val=val & 0x7f;
      while ((curr=seg.get(segmentOffset++) & 0xff) >= MAX_BIT) {
        val|=(curr & 0x7f) << shift;
        shift+=7;
        lenBytes++;
        if (segmentOffset == end) {
          segmentOffset=0;
          seg=sources.get(++segmentNum);
        }
      }
      val|=curr << shift;
    }
    return val + lenBytes;
  }
}"
87990,"/** 
 * Checks which instance types and how many instances of these types are required to execute this stage of the job graph. The required instance types and the number of instances are collected in the given map. Note that this method does not clear the map before collecting the instances.
 * @param instanceRequestMap the map containing the instances types and the required number of instances of the respective type
 * @param executionState the execution state the considered vertices must be in
 */
public void collectRequiredInstanceTypes(final InstanceRequestMap instanceRequestMap,final ExecutionState executionState){
  final Set<AbstractInstance> collectedInstances=new HashSet<AbstractInstance>();
  for (int i=0; i < getNumberOfStageMembers(); i++) {
    final ExecutionGroupVertex groupVertex=getStageMember(i);
    for (int j=0; j < groupVertex.getCurrentNumberOfGroupMembers(); j++) {
      final ExecutionVertex vertex=groupVertex.getGroupMember(j);
      if (vertex.getExecutionState() == executionState) {
        final AbstractInstance instance=vertex.getAllocatedResource().getInstance();
        if (collectedInstances.contains(instance)) {
          continue;
        }
 else {
          collectedInstances.add(instance);
        }
        if (instance instanceof DummyInstance) {
          final InstanceType instanceType=instance.getType();
          int num=instanceRequestMap.getMaximumNumberOfInstances(instanceType);
          ++num;
          instanceRequestMap.setMaximumNumberOfInstances(instanceType,num);
          if (groupVertex.isInputVertex()) {
            num=instanceRequestMap.getMinimumNumberOfInstances(instanceType);
            ++num;
            instanceRequestMap.setMinimumNumberOfInstances(instanceType,num);
          }
        }
 else {
          LOG.debug(""String_Node_Str"" + vertex.getName() + ""String_Node_Str""+ vertex.getID()+ ""String_Node_Str"");
        }
      }
    }
  }
  final Iterator<Map.Entry<InstanceType,Integer>> it=instanceRequestMap.getMaximumIterator();
  while (it.hasNext()) {
    final Map.Entry<InstanceType,Integer> entry=it.next();
    if (instanceRequestMap.getMinimumNumberOfInstances(entry.getKey()) == 0) {
      instanceRequestMap.setMinimumNumberOfInstances(entry.getKey(),entry.getValue());
    }
  }
}","/** 
 * Checks which instance types and how many instances of these types are required to execute this stage of the job graph. The required instance types and the number of instances are collected in the given map. Note that this method does not clear the map before collecting the instances.
 * @param instanceRequestMap the map containing the instances types and the required number of instances of the respective type
 * @param executionState the execution state the considered vertices must be in
 */
public void collectRequiredInstanceTypes(final InstanceRequestMap instanceRequestMap,final ExecutionState executionState){
  final Set<AbstractInstance> collectedInstances=new HashSet<AbstractInstance>();
  final ExecutionGroupVertexIterator groupIt=new ExecutionGroupVertexIterator(this.getExecutionGraph(),true,this.stageNum);
  while (groupIt.hasNext()) {
    final ExecutionGroupVertex groupVertex=groupIt.next();
    System.out.println(""String_Node_Str"" + groupVertex.getName());
    for (int j=0; j < groupVertex.getCurrentNumberOfGroupMembers(); j++) {
      final ExecutionVertex vertex=groupVertex.getGroupMember(j);
      if (vertex.getExecutionState() == executionState) {
        final AbstractInstance instance=vertex.getAllocatedResource().getInstance();
        if (collectedInstances.contains(instance)) {
          continue;
        }
 else {
          collectedInstances.add(instance);
        }
        if (instance instanceof DummyInstance) {
          final InstanceType instanceType=instance.getType();
          int num=instanceRequestMap.getMaximumNumberOfInstances(instanceType);
          ++num;
          instanceRequestMap.setMaximumNumberOfInstances(instanceType,num);
          if (groupVertex.isInputVertex()) {
            num=instanceRequestMap.getMinimumNumberOfInstances(instanceType);
            ++num;
            instanceRequestMap.setMinimumNumberOfInstances(instanceType,num);
          }
        }
 else {
          LOG.debug(""String_Node_Str"" + vertex.getName() + ""String_Node_Str""+ vertex.getID()+ ""String_Node_Str"");
        }
      }
    }
  }
  final Iterator<Map.Entry<InstanceType,Integer>> it=instanceRequestMap.getMaximumIterator();
  while (it.hasNext()) {
    final Map.Entry<InstanceType,Integer> entry=it.next();
    if (instanceRequestMap.getMinimumNumberOfInstances(entry.getKey()) == 0) {
      instanceRequestMap.setMinimumNumberOfInstances(entry.getKey(),entry.getValue());
    }
  }
}"
87991,"/** 
 * Implements the join between LineItem and Order table on the  order key. WHERE l_orderkey = o_orderkey Output Schema - 0:ORDERKEY, 1:SHIPPRIORITY, 2:EXTENDEDPRICE
 */
@Override public void match(PactRecord first,PactRecord second,Collector out){
  first.unionFields(second);
  out.collect(first);
}","/** 
 * Implements the join between LineItem and Order table on the  order key. WHERE l_orderkey = o_orderkey Output Schema - 0:ORDERKEY, 1:SHIPPRIORITY, 2:EXTENDEDPRICE
 */
@Override public void match(PactRecord first,PactRecord second,Collector out){
  first.setField(1,second.getField(1,PactString.class));
  out.collect(first);
}"
87992,"/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(final String... args){
  int noSubtasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String ordersPath=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String lineitemsPath=(args.length > 2 ? args[2] : ""String_Node_Str"");
  String output=(args.length > 3 ? args[3] : ""String_Node_Str"");
  FileDataSource orders=new FileDataSource(NewTupleInFormat.class,ordersPath,""String_Node_Str"");
  orders.setParameter(NewTupleInFormat.RECORD_DELIMITER,""String_Node_Str"");
  orders.getCompilerHints().setAvgNumValuesPerKey(1);
  FileDataSource lineitems=new FileDataSource(NewTupleInFormat.class,lineitemsPath,""String_Node_Str"");
  lineitems.setParameter(NewTupleInFormat.RECORD_DELIMITER,""String_Node_Str"");
  lineitems.getCompilerHints().setAvgNumValuesPerKey(4);
  MapContract filterO=new MapContract(FilterO.class,orders,""String_Node_Str"");
  filterO.setParameter(""String_Node_Str"",1993);
  filterO.setParameter(""String_Node_Str"",""String_Node_Str"");
  filterO.getCompilerHints().setAvgBytesPerRecord(16);
  filterO.getCompilerHints().setAvgRecordsEmittedPerStubCall(0.05f);
  filterO.getCompilerHints().setAvgNumValuesPerKey(1);
  MapContract projectLi=new MapContract(ProjectLi.class,lineitems,""String_Node_Str"");
  projectLi.getCompilerHints().setAvgBytesPerRecord(20);
  projectLi.getCompilerHints().setAvgRecordsEmittedPerStubCall(1.0f);
  projectLi.getCompilerHints().setAvgNumValuesPerKey(4);
  MatchContract joinLiO=new MatchContract(JoinLiO.class,PactLong.class,0,0,filterO,projectLi,""String_Node_Str"");
  joinLiO.getCompilerHints().setAvgBytesPerRecord(24);
  joinLiO.getCompilerHints().setAvgNumValuesPerKey(4);
  @SuppressWarnings(""String_Node_Str"") ReduceContract aggLiO=new ReduceContract(AggLiO.class,new Class[]{PactLong.class,PactString.class},new int[]{0,1},joinLiO,""String_Node_Str"");
  aggLiO.getCompilerHints().setAvgBytesPerRecord(30);
  aggLiO.getCompilerHints().setAvgRecordsEmittedPerStubCall(1.0f);
  aggLiO.getCompilerHints().setAvgNumValuesPerKey(1);
  FileDataSink result=new FileDataSink(RecordOutputFormat.class,output,aggLiO,""String_Node_Str"");
  result.getParameters().setString(RecordOutputFormat.RECORD_DELIMITER_PARAMETER,""String_Node_Str"");
  result.getParameters().setString(RecordOutputFormat.FIELD_DELIMITER_PARAMETER,""String_Node_Str"");
  result.getParameters().setInteger(RecordOutputFormat.NUM_FIELDS_PARAMETER,3);
  result.getParameters().setClass(RecordOutputFormat.FIELD_TYPE_PARAMETER_PREFIX + 0,PactLong.class);
  result.getParameters().setClass(RecordOutputFormat.FIELD_TYPE_PARAMETER_PREFIX + 1,PactString.class);
  result.getParameters().setClass(RecordOutputFormat.FIELD_TYPE_PARAMETER_PREFIX + 2,PactDouble.class);
  Plan plan=new Plan(result,""String_Node_Str"");
  plan.setDefaultParallelism(noSubtasks);
  return plan;
}","/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(final String... args){
  int noSubtasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String ordersPath=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String lineitemsPath=(args.length > 2 ? args[2] : ""String_Node_Str"");
  String output=(args.length > 3 ? args[3] : ""String_Node_Str"");
  FileDataSource orders=new FileDataSource(NewTupleInFormat.class,ordersPath,""String_Node_Str"");
  orders.setParameter(NewTupleInFormat.RECORD_DELIMITER,""String_Node_Str"");
  orders.getCompilerHints().setAvgNumValuesPerKey(1);
  FileDataSource lineitems=new FileDataSource(NewTupleInFormat.class,lineitemsPath,""String_Node_Str"");
  lineitems.setParameter(NewTupleInFormat.RECORD_DELIMITER,""String_Node_Str"");
  lineitems.getCompilerHints().setAvgNumValuesPerKey(4);
  MapContract filterO=new MapContract(FilterO.class,orders,""String_Node_Str"");
  filterO.setParameter(YEAR_FILTER,1993);
  filterO.setParameter(PRIO_FILTER,""String_Node_Str"");
  filterO.getCompilerHints().setAvgBytesPerRecord(16);
  filterO.getCompilerHints().setAvgRecordsEmittedPerStubCall(0.05f);
  filterO.getCompilerHints().setAvgNumValuesPerKey(1);
  MapContract projectLi=new MapContract(ProjectLi.class,lineitems,""String_Node_Str"");
  projectLi.getCompilerHints().setAvgBytesPerRecord(20);
  projectLi.getCompilerHints().setAvgRecordsEmittedPerStubCall(1.0f);
  projectLi.getCompilerHints().setAvgNumValuesPerKey(4);
  MatchContract joinLiO=new MatchContract(JoinLiO.class,PactLong.class,0,0,filterO,projectLi,""String_Node_Str"");
  joinLiO.getCompilerHints().setAvgBytesPerRecord(24);
  joinLiO.getCompilerHints().setAvgNumValuesPerKey(4);
  @SuppressWarnings(""String_Node_Str"") ReduceContract aggLiO=new ReduceContract(AggLiO.class,new Class[]{PactLong.class,PactString.class},new int[]{0,1},joinLiO,""String_Node_Str"");
  aggLiO.getCompilerHints().setAvgBytesPerRecord(30);
  aggLiO.getCompilerHints().setAvgRecordsEmittedPerStubCall(1.0f);
  aggLiO.getCompilerHints().setAvgNumValuesPerKey(1);
  FileDataSink result=new FileDataSink(RecordOutputFormat.class,output,aggLiO,""String_Node_Str"");
  result.getParameters().setString(RecordOutputFormat.RECORD_DELIMITER_PARAMETER,""String_Node_Str"");
  result.getParameters().setString(RecordOutputFormat.FIELD_DELIMITER_PARAMETER,""String_Node_Str"");
  result.getParameters().setInteger(RecordOutputFormat.NUM_FIELDS_PARAMETER,3);
  result.getParameters().setClass(RecordOutputFormat.FIELD_TYPE_PARAMETER_PREFIX + 0,PactLong.class);
  result.getParameters().setClass(RecordOutputFormat.FIELD_TYPE_PARAMETER_PREFIX + 1,PactString.class);
  result.getParameters().setClass(RecordOutputFormat.FIELD_TYPE_PARAMETER_PREFIX + 2,PactDouble.class);
  Plan plan=new Plan(result,""String_Node_Str"");
  plan.setDefaultParallelism(noSubtasks);
  return plan;
}"
87993,"@Override public int serializeRecord(PactRecord rec,byte[] target) throws Exception {
  Tuple tuple=rec.getField(0,Tuple.class);
  String tupleStr=tuple.toString();
  byte[] tupleBytes=tupleStr.getBytes();
  if (target.length >= tupleBytes.length) {
    System.arraycopy(tupleBytes,0,target,0,tupleBytes.length);
    return tupleBytes.length;
  }
 else {
    return -1 * tupleBytes.length;
  }
}","@Override public int serializeRecord(PactRecord rec,byte[] target) throws Exception {
  String string=rec.getField(0,PactString.class).toString();
  byte[] stringBytes=string.getBytes();
  Tuple tuple=rec.getField(1,Tuple.class);
  String tupleStr=tuple.toString();
  byte[] tupleBytes=tupleStr.getBytes();
  int totalLength=stringBytes.length + 1 + tupleBytes.length;
  if (target.length >= totalLength) {
    System.arraycopy(stringBytes,0,target,0,stringBytes.length);
    target[stringBytes.length]='|';
    System.arraycopy(tupleBytes,0,target,stringBytes.length + 1,tupleBytes.length);
    return totalLength;
  }
 else {
    return -1 * totalLength;
  }
}"
87994,"public void setContents(byte[] bytes,int offset,int len,char delimiter){
  if (this.bytes == null || this.bytes.length < len) {
    this.bytes=new byte[len];
  }
  System.arraycopy(bytes,offset,this.bytes,0,len);
  int readPos=offset;
  if (this.offsets == null) {
    this.offsets=new short[4];
  }
  int col=1;
  int startPos=readPos;
  while (readPos < offset + len) {
    if (bytes[readPos++] == delimiter) {
      if (offsets.length <= col) {
        this.offsets=new short[this.offsets.length * 2];
      }
      this.offsets[col++]=(short)(readPos - startPos);
    }
  }
  this.numCols=col - 1;
}","public void setContents(byte[] bytes,int offset,int len,char delimiter){
  if (this.bytes == null || this.bytes.length < len) {
    this.bytes=new byte[len];
  }
  System.arraycopy(bytes,offset,this.bytes,0,len);
  int readPos=offset;
  if (this.offsets == null) {
    this.offsets=new short[4];
  }
  int col=1;
  int startPos=readPos;
  while (readPos < offset + len) {
    if (bytes[readPos++] == delimiter) {
      if (offsets.length <= col) {
        short newOffsets[]=new short[this.offsets.length * 2];
        System.arraycopy(this.offsets,0,newOffsets,0,this.offsets.length);
        this.offsets=newOffsets;
      }
      this.offsets[col++]=(short)(readPos - startPos);
    }
  }
  this.numCols=col - 1;
}"
87995,"/** 
 * {@inheritDoc}
 */
@Override protected int getTimeout(){
  return 30000;
}","/** 
 * {@inheritDoc}
 */
@Override protected int getTimeout(){
  return 30;
}"
87996,"@Override public void reduce(Iterator<PactRecord> records,Collector out) throws Exception {
  long count=0;
  PactRecord rec=null;
  while (records.hasNext()) {
    rec=records.next();
    count++;
  }
  if (rec != null) {
    Tuple tuple=rec.getField(1,Tuple.class);
    tuple.addAttribute(""String_Node_Str"" + count);
    rec.setField(1,tuple);
  }
  out.collect(rec);
}","@Override public void reduce(Iterator<PactRecord> records,Collector out) throws Exception {
  long count=0;
  PactRecord rec=null;
  while (records.hasNext()) {
    rec=records.next();
    count++;
  }
  if (rec != null) {
    Tuple tuple=new Tuple();
    tuple.addAttribute(""String_Node_Str"" + count);
    rec.setField(1,tuple);
  }
  out.collect(rec);
}"
87997,"/** 
 * Join together parts and orderedParts by matching partkey and suppkey. Output Schema: Key: suppkey Value: (amount, year)
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  value1.getField(0,partAndSupplierKey);
  value1.getField(1,supplyCostStr);
  value2.getField(1,ordersValue);
  PactInteger year=new PactInteger(Integer.parseInt(ordersValue.getStringValueAt(0)));
  float quantity=Float.parseFloat(ordersValue.getStringValueAt(1));
  float price=Float.parseFloat(ordersValue.getStringValueAt(2));
  float supplyCost=Float.parseFloat(supplyCostStr.toString());
  float amount=price - supplyCost * quantity;
  value1.setField(0,partAndSupplierKey);
  value1.setField(1,new StringIntPair(new PactString(""String_Node_Str"" + amount),year));
  out.collect(value1);
}","/** 
 * Join together parts and orderedParts by matching partkey and suppkey. Output Schema: Key: suppkey Value: (amount, year)
 */
@Override public void match(PactRecord value1,PactRecord value2,Collector out) throws Exception {
  value1.getField(0,partAndSupplierKey);
  value1.getField(1,supplyCostStr);
  value2.getField(1,ordersValue);
  PactInteger year=new PactInteger(Integer.parseInt(ordersValue.getStringValueAt(0)));
  float quantity=Float.parseFloat(ordersValue.getStringValueAt(1));
  float price=Float.parseFloat(ordersValue.getStringValueAt(2));
  float supplyCost=Float.parseFloat(supplyCostStr.toString());
  float amount=price - supplyCost * quantity;
  value1.setField(0,partAndSupplierKey.getSecond());
  value1.setField(1,new StringIntPair(new PactString(""String_Node_Str"" + amount),year));
  out.collect(value1);
}"
87998,"/** 
 * Project ""partsupp"". Output Schema: Key: partkey Value: (suppkey, supplycost)
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  record.getField(1,inputTuple);
  inputTuple.project((0 << 0) | (1 << 1) | (0 << 2)| (1 << 3)| (0 << 4));
  out.collect(record);
}","/** 
 * Project ""partsupp"". Output Schema: Key: partkey Value: (suppkey, supplycost)
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  record.getField(1,inputTuple);
  inputTuple.project((0 << 0) | (1 << 1) | (0 << 2)| (1 << 3)| (0 << 4));
  record.setField(1,inputTuple);
  out.collect(record);
}"
87999,"/** 
 * Project ""supplier"". Output Schema: Key: nationkey Value: suppkey
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  record.getField(0,suppKey);
  record.getField(1,inputTuple);
  PactInteger nationKey=new PactInteger(Integer.parseInt(inputTuple.getStringValueAt(3)));
  record.setField(0,nationKey);
  record.setField(1,suppKey);
}","/** 
 * Project ""supplier"". Output Schema: Key: nationkey Value: suppkey
 */
@Override public void map(PactRecord record,Collector out) throws Exception {
  record.getField(0,suppKey);
  record.getField(1,inputTuple);
  PactInteger nationKey=new PactInteger(Integer.parseInt(inputTuple.getStringValueAt(3)));
  record.setField(0,nationKey);
  record.setField(1,suppKey);
  out.collect(record);
}"
88000,"@Override public void writeRecord(PactRecord record) throws IOException {
  int numFields=record.getNumFields();
  for (int i=0; i < numFields; i++) {
    buffer.append(record.getField(0,PactString.class).getValue());
    char delim=(i == numFields - 1) ? '\n' : '|';
    buffer.append(delim);
  }
  byte[] bytes=this.buffer.toString().getBytes();
  this.stream.write(bytes);
}","@Override public void writeRecord(PactRecord record) throws IOException {
  buffer.setLength(0);
  buffer.append(record.getField(1,PactInteger.class).toString());
  buffer.append('|');
  buffer.append(record.getField(0,PactString.class).toString());
  buffer.append('|');
  buffer.append(record.getField(2,PactInteger.class).toString());
  buffer.append('|');
  buffer.append('\n');
  byte[] bytes=this.buffer.toString().getBytes();
  this.stream.write(bytes);
}"
